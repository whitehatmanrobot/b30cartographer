this, UserFont, BMPPath, TTFPath, TRUE);
	dlg.DoModal();

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\blinkdlg.cpp ===
/**************************************************/
/*                                                */
/*                                                */
/*      Chinese IME Batch Mode                    */
/*              (Dialogbox)                       */
/*                                                */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include    "stdafx.h"
#include    "eudcedit.h"
#if 1 // use function in imeblink.c!
#include    "imeblink.h"
#endif
#include    "blinkdlg.h"
#include    "util.h"
#define STRSAFE_LIB
#include <strsafe.h>

#define     SIGN_CWIN       0x4E495743      /* Sign of CWin */
#define     SIGN__TBL       0x4C42545F      /* Sign of IME Table */

#if 0 // move to imeblink.c!

#define     UNICODE_CP      1200

#define     BIG5_CP         950
#define     ALT_BIG5_CP     938
#define     GB2312_CP       936

typedef struct _tagCOUNTRYSETTING {
    UINT    uCodePage;
    LPCTSTR szCodePage;
} COUNTRYSETTING;

static const COUNTRYSETTING sCountry[] = {
    {
        BIG5_CP, TEXT("BIG5")
    }
    , {
        ALT_BIG5_CP, TEXT("BIG5")
    }
#if defined(UNICODE)
    , {
        UNICODE_CP, TEXT("UNICODE")
    }
#endif
    , {
        GB2312_CP, TEXT("GB2312")
    }
};

#endif // move to imeblink.c!

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/****************************************/
/*                                      */
/*            Constructor               */
/*                                      */
/****************************************/
CBLinkDlg::CBLinkDlg(   CWnd *pParent)
    : CDialog( CBLinkDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CBLinkDlg)
    //}}AFX_DATA_INIT
}

/****************************************/
/*                                      */
/*      MESSAGE "WM_INITDIALOG"         */
/*                                      */
/****************************************/
BOOL
CBLinkDlg::OnInitDialog()
{
    CString DlgTtl;
    CDialog::OnInitDialog();

//  Increment contexthelp mark "?" in dialog caption.
//    LONG WindowStyle = GetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE);
//    WindowStyle |= WS_EX_CONTEXTHELP;
//    SetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE, WindowStyle);

//  Set dialog title name.
    DlgTtl.LoadString( IDS_BATCHLNK_DLGTITLE);
    this->SetWindowText( DlgTtl);

    return TRUE;
}

/****************************************/
/*                                      */
/*      COMMAND "BROWSE"                */
/*                                      */
/****************************************/
void
CBLinkDlg::OnBrowsetable()
{
    OPENFILENAME    ofn;
    CString         DlgTtl, DlgMsg;
    CString         sFilter;
    TCHAR           chReplace;
    TCHAR           szFilter[64];
    TCHAR           szFileName[MAX_PATH];
    TCHAR           szDirName[MAX_PATH];
    TCHAR           szTitleName[MAX_PATH];
    HRESULT        hresult;

//  Check size of IME batch table structure
    if( sizeof( USRDICIMHDR) != 256){
        OutputMessageBox( this->GetSafeHwnd(),
            IDS_INTERNAL_TITLE,
            IDS_INTERNAL_MSG, TRUE);
        return;
    }

//  Set filter of file( from string table)
    GetStringRes(szFilter, IDS_BATCHIME_FILTER, ARRAYLEN(szFilter));
    int StringLength = lstrlen( szFilter);

    chReplace = szFilter[StringLength-1];
    for( int i = 0; szFilter[i]; i++){
        if( szFilter[i] == chReplace)
            szFilter[i] = '\0';
    }

    GetSystemWindowsDirectory( szDirName, sizeof(szDirName)/sizeof(TCHAR));
    //*STRSAFE*     lstrcpy( szFileName, TEXT("*.TBL"));
    hresult = StringCchCopy(szFileName , ARRAYLEN(szFileName),  TEXT("*.TBL"));
    if (!SUCCEEDED(hresult))
    {
       return ;
    }
    DlgTtl.LoadString( IDS_BROWSETABLE_DLGTITLE);

//  Set data in structure of OPENFILENAME
    ofn.lStructSize = sizeof( OPENFILENAME);
    ofn.hwndOwner = this->GetSafeHwnd();
    ofn.lpstrFilter = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFileTitle = szTitleName;
    ofn.nMaxFileTitle = sizeof( szTitleName) / sizeof(TCHAR);
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = sizeof( szFileName) / sizeof(TCHAR);
    ofn.lpstrInitialDir = szDirName;
    ofn.Flags = OFN_HIDEREADONLY | OFN_NOCHANGEDIR
        | OFN_CREATEPROMPT | OFN_PATHMUSTEXIST;
    ofn.lpstrDefExt = NULL;
    ofn.lpstrTitle = DlgTtl;

    if( !GetOpenFileName( &ofn))
        return;

    this->SetDlgItemText( IDC_IMETABLE, ofn.lpstrFile);
    CWnd *cWnd = GetDlgItem( IDOK);
    GotoDlgCtrl( cWnd);
}

/****************************************/
/*                                      */
/*      COMMAND "IDOK"                  */
/*                                      */
/****************************************/
void
CBLinkDlg::OnOK()
{
    if( !RegistStringTable())
        return;

    CDialog::OnOK();
}

/****************************************/
/*                                      */
/*      Register reading string         */
/*                                      */
/****************************************/
BOOL
CBLinkDlg::RegistStringTable()
{
    LPUSRDICIMHDR lpIsvUsrDic;
    HANDLE        hIsvUsrDicFile, hIsvUsrDic;
    DWORD         dwSize, dwFileSize;
    BOOL          stFunc;
    TCHAR         szTableFile[MAX_PATH];
    TCHAR         szFileName[MAX_PATH];
    CString       DlgMsg, DlgTtl;
    HRESULT     hresult;

    this->GetDlgItemText( IDC_IMETABLE, szTableFile, sizeof( szTableFile)/sizeof(TCHAR));
    //*STRSAFE*     lstrcpy( szFileName, TEXT("*.TBL"));
    hresult = StringCchCopy(szFileName , ARRAYLEN(szFileName),  TEXT("*.TBL"));
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }

//  Create file( to read)
    hIsvUsrDicFile = CreateFile( szTableFile, GENERIC_READ, 0, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if( hIsvUsrDicFile == INVALID_HANDLE_VALUE){
        DlgTtl.LoadString( IDS_NOTOPEN_TITLE);
        DlgMsg.LoadString( IDS_NOTOPEN_MSG);
        this->MessageBox( DlgMsg, DlgTtl, MB_OK | MB_ICONHAND |
            MB_TASKMODAL | MB_TOPMOST);
        return FALSE;
    }

#if 0
    for( i = 0; i < sizeof( szFileName); i++){
        if( szFileName[i] == '\\'){
            szFileName[i] = ' ';
        }
    }
#endif

//  Create file mapping( read only)
    hIsvUsrDic = CreateFileMapping((HANDLE)hIsvUsrDicFile, NULL,
        PAGE_READONLY, 0, 0, NULL);
    if( !hIsvUsrDic){
        stFunc = FALSE;
        DlgTtl.LoadString( IDS_NOTOPEN_TITLE);
        DlgMsg.LoadString( IDS_NOTOPEN_MSG);
        this->MessageBox( DlgMsg, DlgTtl, MB_OK | MB_ICONHAND |
            MB_TASKMODAL | MB_TOPMOST);
        goto BatchCloseUsrDicFile;
    }

//  Set view file
    lpIsvUsrDic = (LPUSRDICIMHDR)MapViewOfFile( hIsvUsrDic,
        FILE_MAP_READ, 0, 0, 0);
    if( !lpIsvUsrDic){
        stFunc = FALSE;
        DlgTtl.LoadString( IDS_NOTOPEN_TITLE);
        DlgMsg.LoadString( IDS_NOTOPEN_MSG);
        this->MessageBox( DlgMsg, DlgTtl, MB_OK | MB_ICONHAND |
            MB_TASKMODAL | MB_TOPMOST);
        goto BatchCloseUsrDic;
    }
		
    dwSize = lpIsvUsrDic->ulTableCount * ( sizeof(WORD) + sizeof(WORD)
        + lpIsvUsrDic->cMethodKeySize) + 256;
    dwFileSize = GetFileSize( hIsvUsrDicFile, (LPDWORD)NULL);

#if 0
    dwSize = dwFileSize;
#endif

//  Check table file data
    if( dwSize != dwFileSize){
        stFunc = FALSE;
        OutputMessageBox( this->GetSafeHwnd(),
            IDS_FILESIZE_MSGTITLE,
            IDS_FILESIZE_MSG, TRUE);
    }else if( lpIsvUsrDic->uHeaderSize != 256){
        stFunc = FALSE;
        OutputMessageBox( this->GetSafeHwnd(),
            IDS_FILEHEADER_MSGTITLE,
            IDS_FILEHEADER_MSG, TRUE);
    }else if( lpIsvUsrDic->uInfoSize != 13){
        stFunc = FALSE;
        OutputMessageBox( this->GetSafeHwnd(),
            IDS_INMETHOD_MSGTITLE,
            IDS_INMETHOD_MSG, TRUE);
    }else if( CodePageInfo( lpIsvUsrDic->idCP) == -1){
        stFunc = FALSE;
        OutputMessageBox( this->GetSafeHwnd(),
            IDS_CODEPAGE_MSGTITLE,
            IDS_CODEPAGE_MSG, TRUE);
    }else if( *(DWORD UNALIGNED *)lpIsvUsrDic->idUserCharInfoSign != SIGN_CWIN){
        stFunc = FALSE;
        OutputMessageBox( this->GetSafeHwnd(),
            IDS_SIGN_MSGTITLE,
            IDS_SIGN_MSG, TRUE);
    }else if( *(DWORD UNALIGNED *)((LPBYTE)lpIsvUsrDic->idUserCharInfoSign +
        sizeof(DWORD)) != SIGN__TBL){
        stFunc = FALSE;
        OutputMessageBox( this->GetSafeHwnd(),
            IDS_SIGN_MSGTITLE,
            IDS_SIGN_MSG, TRUE);
    }else{
        stFunc = TRUE;
        if( !RegisterTable( this->GetSafeHwnd(),
            lpIsvUsrDic, dwFileSize, lpIsvUsrDic->idCP)){
            OutputMessageBox( this->GetSafeHwnd(),
                IDS_UNMATCHED_TITLE,
                IDS_UNMATCHED_MSG, TRUE);
            stFunc = FALSE;
        }
    }
    UnmapViewOfFile( lpIsvUsrDic);
					
BatchCloseUsrDic:
    CloseHandle( hIsvUsrDic);

BatchCloseUsrDicFile:
    CloseHandle( hIsvUsrDicFile);

    return stFunc;
}



static DWORD    aIds[] =
{
    IDC_STATICIMETBL, IDH_EUDC_BLINK_EDITTBL,
    IDC_IMETABLE, IDH_EUDC_BLINK_EDITTBL,
    IDC_BROWSETABLE, IDH_EUDC_BROWSE,
    0, 0
};

/****************************************/
/*                                      */
/*      Window Procedure                */
/*                                      */
/****************************************/		
LRESULT
CBLinkDlg::WindowProc(
UINT    message,
WPARAM  wParam,
LPARAM  lParam)
{/*
    if( message == WM_HELP){
        ::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
            HelpPath, HELP_WM_HELP, (DWORD_PTR)(LPDWORD)aIds);
        return(0);
    }
    if( message == WM_CONTEXTMENU){
        ::WinHelp((HWND)wParam, HelpPath,
            HELP_CONTEXTMENU, (DWORD_PTR)(LPDWORD)aIds);
        return(0);
    }
  */
    return CDialog::WindowProc(message, wParam, lParam);
}

BEGIN_MESSAGE_MAP(CBLinkDlg, CDialog)
    //{{AFX_MSG_MAP(CBLinkDlg)
    ON_BN_CLICKED(IDC_BROWSETABLE, OnBrowsetable)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\clipbook\datasrv\ddeutil.c ===
#include    <windows.h>
#include    <string.h>
#include    <stdlib.h>
#include    <stdio.h>
#include    <memory.h>
#include    <ddeml.h>
#include    <strsafe.h>

#include    "common.h"
#include    "clipfile.h"
#include    "clipsrv.h"
#include    "ddeutil.h"
#include    "callback.h"
#include    "debugout.h"




/*
 *      GetTopicListA
 *
 *  Purpose: Creata a DDE handle to a block containing a tab-delimited
 *     list of the available topics with a NULL at the end.
 *
 *  Parameters:
 *     fAllTopicReq - TRUE to get all topics, FALSE to just get shared.
 *
 *  Returns: The data handle.
 *
 *  Notes: AW variants
 */

HDDEDATA GetTopicListA(
    HCONV   hConv,
    BOOL    fAllTopicReq)
{
LPSTR       lpszTopics;
LPSTR       pTmp;
HDDEDATA    hData;
DWORD       cbData = 0L;
pShrInfo    pshrinfo;



    for ( pshrinfo=SIHead; pshrinfo; pshrinfo = pshrinfo->Next )
        {
       /*
        * Keep enough buffer for MBCS string,
        */
        cbData += ( ( lstrlenW( pshrinfo->szName ) + 1 ) * sizeof(WORD) );
        }

    cbData += sizeof(szUpdateName) +1;


    // if there are no entries, must send a "" string, not 0!

    if ( !cbData )
        return (DdeCreateDataHandle (idInst, TEXT(""), 1, 0L, hszTopicList, CF_TEXT, 0));


    hData = DdeCreateDataHandle (idInst, NULL, cbData, 0L, hszTopicList, CF_TEXT, 0);


    if ( !hData )
        {
        SetXactErr (hConv, XERRT_DDE, DdeGetLastError (idInst));
        PERROR(TEXT("error creating hddedata for topic list\n\r"));
        }
    else
        {
        if ( ( pTmp = lpszTopics = DdeAccessData(hData, NULL) ) == (LPSTR)NULL )
            {
            SetXactErr (hConv, XERRT_DDE, DdeGetLastError (idInst));
            PERROR(TEXT("error accessing data handle for topic list\n\r"));

            DdeFreeDataHandle(hData);
            hData = 0L;
            }
        else
            {
            // put the updated name first
            #ifdef UNICODE
              StringCchPrintfA (pTmp, cbData, "%lc%ls\t", BOGUS_CHAR, szUpdateName);
            #else
              StringCchPrintfA (pTmp, cbData, "%hc%hs\t", BOGUS_CHAR, szUpdateName);
            #endif

            pTmp += lstrlenA (pTmp);


            // Create a tab-delimited list of topics in CF_TEXT format.
            for ( pshrinfo=SIHead; pshrinfo; pshrinfo = pshrinfo->Next )
                {
                // Only list SHARED topics if this isn't a "[alltopiclist]" req
                if (SHR_CHAR == pshrinfo->szName[0] ||
                    fAllTopicReq)
                    {

                    WideCharToMultiByte (CP_ACP,
                                         0,
                                         pshrinfo->szName,
                                         -1,
                                         pTmp,
                                         (int)(cbData - (size_t)(pTmp - lpszTopics)),
                                         NULL,
                                         NULL);

                    pTmp += lstrlenA(pTmp);
                    *pTmp++ = '\t';
                    }
                }

            // Turn the last tab into a NULL.
            if ( pTmp != lpszTopics )
                *--pTmp = '\0';

            DdeUnaccessData ( hData );
            }
        }

    return hData;
}



/*
 *      GetTopicListW
 */

HDDEDATA GetTopicListW(
    HCONV   hConv,
    BOOL    fAllTopicsReq)
{
LPWSTR      lpszTopics;
LPWSTR      pTmp;
HDDEDATA    hData;
DWORD       cbData = 0L;
pShrInfo    pshrinfo;

    for (pshrinfo=SIHead; pshrinfo; pshrinfo = pshrinfo->Next)
        {
       /*
        * Keep enough buffer for MBCS string,
        */
        cbData += ( ( lstrlenW( pshrinfo->szName ) + 1 ) * sizeof(WORD) );

        }

        cbData += sizeof(szUpdateName) + sizeof(WORD);

    // if there are no entries, must send a "" string, not 0!

    if ( !cbData )
        return DdeCreateDataHandle (idInst, TEXT(""), 1, 0L, hszTopicList, CF_UNICODETEXT, 0);


    hData = DdeCreateDataHandle (idInst, NULL, cbData, 0L, hszTopicList, CF_UNICODETEXT, 0);


    if ( !hData )
        {
        SetXactErr (hConv, XERRT_DDE, DdeGetLastError(idInst));
        PERROR(TEXT("error creating hddedata for topic list\n\r"));
        }
    else
        {
        if ((pTmp = lpszTopics = (LPWSTR)DdeAccessData( hData, NULL ))
                 == (LPWSTR)NULL)
            {
            SetXactErr (hConv, XERRT_DDE, DdeGetLastError(idInst));
            PERROR(TEXT("error accessing data handle for topic list\n\r"));

            DdeFreeDataHandle(hData);
            hData = 0L;
            }
        else
            {

            // put the updated name first
            #ifdef UNICODE
              StringCbPrintfW (pTmp, cbData, L"%lc%ls\t", BOGUS_CHAR, szUpdateName);
            #else
              StringCbPrintfW (pTmp, cbData, L"%hc%hs\t", BOGUS_CHAR, szUpdateName);
            #endif

            pTmp += lstrlenW (pTmp);
            // Create a tab-delimited list of topics in CF_TEXT format.
            for (pshrinfo=SIHead; pshrinfo; pshrinfo = pshrinfo->Next )
                {
                if (SHR_CHAR == pshrinfo->szName[0] ||
                    fAllTopicsReq)
                    {
                    StringCbCopyW( pTmp, cbData - (pTmp-lpszTopics), pshrinfo->szName );
                    pTmp += lstrlenW(pTmp);
                    *pTmp++ = '\t';
                    }
                }

            // Turn the last tab into a NULL.
            if ( pTmp != lpszTopics )
                *--pTmp = '\0';

            DdeUnaccessData ( hData );
            }
        }

    return hData;
}





/*
 *      GetFormatListA
 *
 *  Purpose: Create a DDE handle containing a tab-delimited list of the
 *     formats available for the given topic -- it's assumed to be a share.
 *
 *  Parameters:
 *     hszTopic - String handle to the topic name.
 *
 *  Returns:
 *     DDE handle to the list.
 *
 *  Notes:
 *     AW variants
 */

HDDEDATA GetFormatListA(
    HCONV   hConv,
    HSZ     hszTopic )
{
LPSTR           lpszFormats;
LPSTR           lpcsTmp;
HDDEDATA        hData = 0L;
DWORD           cbData = 0L;
pShrInfo        pshrinfo;
unsigned        cFormats;
FORMATHEADER    FormatHeader;
unsigned        i;
HANDLE          fh;



    PINFO(TEXT("GetFormatList:"));

    for ( pshrinfo=SIHead; pshrinfo; pshrinfo = pshrinfo->Next )
        {
        if ( DdeCmpStringHandles ( hszTopic, pshrinfo->hszName ) == 0 )
            {

            #ifdef CACHEFORMATLIST
            if (pshrinfo->hFormatList)
                return pshrinfo->hFormatList;
            #endif


            fh = CreateFileW (pshrinfo->szFileName,
                              GENERIC_READ,
                              0,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL);


            if ( INVALID_HANDLE_VALUE == fh)
                {
                SetXactErr (hConv, XERRT_SYS, GetLastError());
                PERROR(TEXT("ERROR opening %s\n\r"), pshrinfo->szFileName);
                }
            else
                {
                cFormats = ReadFileHeader(fh);

                // allocate max data - some will be wasted.
                // Keep enought buffer for MBCS string,

                cbData = cFormats * CCHFMTNAMEMAX * sizeof(WORD);

                hData = DdeCreateDataHandle (idInst,
                                             NULL,
                                             cbData,
                                             0L,
                                             hszFormatList,
                                             CF_TEXT,
                                           #ifdef CACHEFORMATLIST
                                             HDATA_APPOWNED );
                                           #else
                                             0 );
                                           #endif

                if (!hData)
                    {
                    SetXactErr (hConv, XERRT_DDE, DdeGetLastError (idInst));
                    PERROR(TEXT("DdeCreateDataHandle failed!!!\n\r"));
                    }
                else
                    {
                    lpszFormats = DdeAccessData(hData, NULL);
                    lpcsTmp = lpszFormats;
                    if (NULL == lpcsTmp)
                        {
                        SetXactErr (hConv, XERRT_DDE, DdeGetLastError (idInst));
                        DdeFreeDataHandle ( hData );
                        hData = 0L;
                        PERROR(TEXT("DdeAccessData failed!!!\n\r"));
                        }
                    else
                        {
                        PINFO(TEXT("%d formats found\n\r"), cFormats);

                        // form tab-separated list

                        for (i=0; i < cFormats; i++)
                            {
                            ReadFormatHeader(fh, &FormatHeader, i);
                            PINFO(TEXT("getformat: read >%ws<\n\r"), FormatHeader.Name);
                            WideCharToMultiByte (CP_ACP,
                                                 0,
                                                 FormatHeader.Name,
                                                 -1,
                                                 lpcsTmp,
                                                 cbData - (UINT)(lpcsTmp-lpszFormats),
                                                 NULL,
                                                 NULL);

                            lpcsTmp += lstrlenA(lpcsTmp);
                            *lpcsTmp++ = '\t';
                            }

                       *--lpcsTmp = '\0';

                       PINFO(TEXT("clipsrv: returning format list >%cs<\n\r"), lpszFormats );
                       DdeUnaccessData ( hData );

                       #ifdef CACHEFORMATLIST
                         pshrinfo->hFormatList = hData;
                       #endif
                       }
                   }
                CloseHandle(fh);
                }
            }
        }

    if (!hData)
        {
        PERROR (TEXT("GetFormatList: Topic not found\n\r"));
        }

    return hData;
}




/*
 *      GetFormatListW
 */

HDDEDATA GetFormatListW(
    HCONV   hConv,
    HSZ     hszTopic )
{
LPWSTR          lpszFormats;
LPWSTR          lpwsTmp;
HDDEDATA        hData = 0L;
DWORD           cbData = 0L;
pShrInfo        pshrinfo;
unsigned        cFormats;
FORMATHEADER    FormatHeader;
unsigned        i;
HANDLE          fh;


    PINFO(TEXT("GetFormatList:"));


    for ( pshrinfo=SIHead; pshrinfo; pshrinfo = pshrinfo->Next )
        {
        if ( DdeCmpStringHandles ( hszTopic, pshrinfo->hszName ) == 0 )
            {

            #ifdef CACHEFORMATLIST
            if ( pshrinfo->hFormatList )
                return pshrinfo->hFormatList;
            #endif

            fh = CreateFileW (pshrinfo->szFileName,
                              GENERIC_READ,
                              0,
                              NULL,
                              OPEN_EXISTING,
                              0,
                              NULL);


            if ( INVALID_HANDLE_VALUE == fh)
                {
                SetXactErr (hConv, XERRT_SYS, GetLastError());
                PERROR(TEXT("ERROR opening %s\n\r"), pshrinfo->szFileName);
                }
            else
                {
                cFormats = ReadFileHeader(fh);

                // allocate max data - some will be wasted.
                // Keep enought buffer for MBCS string,

                cbData = cFormats * CCHFMTNAMEMAX * sizeof(WORD);

                hData = DdeCreateDataHandle (idInst,
                                             NULL,
                                             cbData,
                                             0L,
                                             hszFormatList,
                                             CF_TEXT,
                                           #ifdef CACHEFORMATLIST
                                             HDATA_APPOWNED );
                                           #else
                                             0);
                                           #endif

                if ( !hData )
                    {
                    SetXactErr (hConv, XERRT_DDE, DdeGetLastError(idInst));
                    PERROR(TEXT("DdeCreateDataHandle failed!!!\n\r"));
                    }
                else
                    {
                    lpszFormats = (LPWSTR)DdeAccessData(hData, NULL);
                    lpwsTmp = lpszFormats;
                    if (NULL == lpwsTmp)
                        {
                        SetXactErr (hConv, XERRT_DDE, DdeGetLastError(idInst));

                        DdeFreeDataHandle ( hData );
                        hData = 0L;
                        PERROR(TEXT("DdeAccessData failed!!!\n\r"));
                        }
                    else
                        {
                        PINFO(TEXT("%d formats found\n\r"), cFormats);

                        // form tab-separated list

                        for (i=0; i < cFormats; i++)
                            {
                            ReadFormatHeader (fh, &FormatHeader, i);
                            PINFO(TEXT("getformat: read >%ws<\n\r"), FormatHeader.Name);

                            StringCbCopyW (lpwsTmp, cbData-(lpwsTmp-lpszFormats), FormatHeader.Name);
                            lpwsTmp += lstrlenW (FormatHeader.Name);
                            *lpwsTmp++ = '\t';
                            }

                        *--lpwsTmp = '\0';

                        PINFO(TEXT("clipsrv: returning format list >%ws<\n\r"), lpszFormats );
                        DdeUnaccessData ( hData );


                        #ifdef CACHEFORMATLIST
                        pshrinfo->hFormatList = hData;
                        #endif
                        }
                    }

                CloseHandle(fh);
                }
            }
        }

    if (!hData)
        {
        PERROR (TEXT("GetFormatList: Topic not found\n\r"));
        }

    return hData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\dataif.cpp ===
/*
 *	Bitmap and TTF control 
 *
 *  Copyright (c) 1997-1999 Microsoft Corporation.
 */

#include	"stdafx.h"
#include	"eudcedit.h"


#pragma		pack(2)


#include	"vdata.h"
#include	"ttfstruc.h"
#include	"extfunc.h"

static void reverseBMP( unsigned char *mem, int siz);
static int makeNullGlyph( int lstH, struct BBX *bbx, short uPEm);

#define		OUTLSTH		0
#define		TMPLSTH		1
#define		NGLYPHLSTH	3
static int init = 0;
static int	inputSiz = 0;
/***********************************************************************
 *	initialize
 */
/* */	int
/* */	OInit( )
/*
 *	returns 0 , -1 (Failed)
 ***********************************************************************/
{
	if ( init)
		return 0;


	if (VDInit())
		return -1;
	else	{
		init = 1;
		return 0;
	}
}
/***********************************************************************
 *	initialize
 */
/* */	int
/* */	OTerm( )
/*
 *	returns 0 
 ***********************************************************************/
{
	if ( init) {
		init = 0;
		VDTerm();
	}
	return 0;
}
/***********************************************************************
 *	Make Outline
 */
/* */	int
/* */	OMakeOutline( 
/* */		unsigned char *buf, 
/* */		int	siz,
/* */		int	level)
/*
 *	returns : 0< : list handle, -1 ( error)
 ***********************************************************************/
{
	int	pb1=-1, pb2=-1, pb3=-1;
struct SMOOTHPRM	prm;
	unsigned char	*tmp1, *tmp2;
	int	msiz;

       if (!buf)
       {
          return -1;
       }
	inputSiz = siz;
	reverseBMP( buf, ((siz+15)/16*2*siz));
	if ( init==0)
		if (OInit())	return -1;

	tmp1 = tmp2 = (unsigned char *)0;
	BMPInit();

	msiz = (siz+15)/16*2 * siz;

	if ( (tmp1 = (unsigned char *)malloc( msiz))==(unsigned char *)0)
		goto	ERET;
	if ( (tmp2 = (unsigned char *)malloc( msiz))==(unsigned char *)0)
		goto	ERET;
	if ( (pb1 = BMPDefine( buf, siz, siz))<0)
		goto	ERET;

	if ( (pb2 = BMPDefine( tmp1, siz, siz))<0)
		goto	ERET;
	if ( (pb3 = BMPDefine( tmp2, siz, siz))<0)
		goto	ERET;

	VDNew( OUTLSTH);
	if (BMPMkCont( pb1, pb2, pb3, OUTLSTH)<0)
		goto	ERET;
	prm.SmoothLevel = level;
	prm.UseConic = 1;
	/* ͂̂S{ŏ_ȉSrbgŌvZ */
	if (SmoothVector( OUTLSTH, TMPLSTH, siz, siz,siz*4, &prm, 16))
		goto	ERET;

	VDCopy( OUTLSTH, TMPLSTH);
	RemoveFp( TMPLSTH, siz*4, 16);

	free( tmp1);
	free( tmp2);
	BMPFreDef( pb1);
	BMPFreDef( pb2);
	BMPFreDef( pb3);
	reverseBMP( buf, ((siz+15)/16*2*siz));

	/* Ԃ̂́A͂̂S{ɂ */
	return TMPLSTH;
ERET:
	if ( tmp1)	free( tmp1);	
	if ( tmp2)	free( tmp2);	
	if (pb1 > 0) BMPFreDef( pb1);
	if (pb2 > 0) BMPFreDef( pb2);
	if (pb3 > 0) BMPFreDef( pb3);
	return -1;
}
/***********************************************************************
 *	check File exist
 */
/* */	int
/* */	OExistTTF( TCHAR	*path)
/*
 *	returns : 0, 1 (exist)
 ***********************************************************************/
{
	HANDLE	fh;
       if (!path)
       {
           return 0;
       }
	fh = CreateFile(path,
					GENERIC_READ,
					FILE_SHARE_READ,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fh == INVALID_HANDLE_VALUE)	return 0;
	CloseHandle( fh);
	return	1;
}
#ifdef BUILD_ON_WINNT
int OExistUserFont( TCHAR	*path)
{
	HANDLE	fh;
	fh = CreateFile(path,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fh == INVALID_HANDLE_VALUE)
		return 0;
	CloseHandle( fh);
	return	1;
}
#endif // BUILD_ON_WINNT
static void
setWIFEBBX( struct BBX *bbx, short *uPEm)
{

       if ( (!bbx) || (!uPEm))
       {
          return;
       }	
	bbx->xMin = 0;
	bbx->xMax = 255;
	bbx->yMin = 0;
	bbx->yMax = 255;
	*uPEm = 256;
}
/***********************************************************************
 *	Create EUDC TTF
 */
/* */	int
/* */	OCreateTTF( 
/* */		HDC	hDC,
/* */		TCHAR	*path,
/* */		int	fontType)
/* 		
 *	returns : 0, -1
 ***********************************************************************/
{
struct BBX	bbx;
	short	uPEm;

       if (!path)
       {
          goto ERET;
       }
	if ( fontType)
		setWIFEBBX( &bbx, &uPEm);
	else {
		if (TTFGetBBX( hDC, &bbx, &uPEm))
			goto	ERET;
	}
	makeNullGlyph( NGLYPHLSTH, &bbx, uPEm);
	if (TTFCreate( hDC, path, &bbx,  NGLYPHLSTH, fontType))
		goto	ERET;
	return 0;
ERET:
	return -1;
}
/***********************************************************************
 *	Output to EUDC TTF
 */
/* */	int
/* */	OOutTTF( 
/* */		HDC	hDC,
/* */		TCHAR *path,	/* TrueType Path */
/* */		unsigned short	code,
/* */       BOOL bUnicode)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	int	mesh;
struct BBX	bbx;
	short	uPEm;
	int	sts;

       if (!path)
       {
          goto ERET;
       }
	if (TTFGetEUDCBBX( path, &bbx, &uPEm))
		goto	ERET;

	mesh = uPEm;
	/* OUTLSTH mesh is inputBitmapSiz*4 , and made into ufp 4bit*/
	/* ufp : under Fixed Point */
	ConvMesh( OUTLSTH, inputSiz*4, mesh);
	RemoveFp( OUTLSTH,  mesh, 16);

	if (toTTFFrame( OUTLSTH, &bbx))
		goto	ERET;
    if (!bUnicode)
    {
	    code = sjisToUniEUDC( code);
    }
	if ( sts = TTFAddEUDCChar( path,code, &bbx,  OUTLSTH)) {
    if (sts == -3) // tte file is being used by another process.
      return -3;
		if ( TTFLastError()==-2)
			return -2;
		else	return -1;
	}
	return 0;
ERET:
	return -1;
}
static void
smtoi( unsigned short *s)
{
	unsigned short	sval;
	unsigned char	*c;

       if (!s)
       {
          return;
       }
	c = (unsigned char *)s;
	sval = *c;
	sval<<=8;
	sval += (unsigned short)*c;
}
static void
reverseBMP( unsigned char *mem, int siz)
{
       if (!mem)
       {
          return;
       }
	while ( siz-->0)
		*mem++ ^= (unsigned char)0xff;
}
static int
makeNullGlyph( int lstH, struct BBX *bbx, short uPEm)
{
	int	width;
	int	height;
	int	cx, cy;
	int	dx, dy;
struct vecdata	vd;

       if (!bbx)
       {
          goto ERET;
       }      
	width = height = uPEm;
	cx = bbx->xMin + width/2;
	cy = bbx->yMin + height/2;
	dx = width/20;
	dy = height/20;

	VDNew( lstH);

	vd.atr = 0;
	vd.x = cx - dx;
	vd.y = cy - dy;

	if (VDSetData( lstH, &vd)) goto	ERET;
	vd.y = cy + dy;

	if (VDSetData( lstH, &vd)) goto	ERET;
	vd.x = cx + dx;

	if (VDSetData( lstH, &vd)) goto	ERET;
	vd.y = cy - dy;

	if (VDSetData( lstH, &vd)) goto	ERET;
	if ( VDClose( lstH))	goto	ERET;
	return 0;
ERET:
	return -1;
}
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\code.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//

#include	"stdafx.h"
#include	"eudcedit.h"
#ifdef BUILD_ON_WINNT
#include    "extfunc.h"
#endif // BUILD_ON_WINNT
#pragma		pack(2)


#define		SEGMAX	256
#define		EUDCCODEBASE	((unsigned short)0xe000)


static int init = 0;
static unsigned short	segStart[SEGMAX];
static unsigned short	segEnd[SEGMAX];
static unsigned short	segUni[SEGMAX];
static int	segCnt = 0;
static int	recCnt = 0;
static void
setseg( unsigned short segH, unsigned short segLS, unsigned short segLE)
{
	unsigned short	cCnt;

	if ( segCnt >= SEGMAX)
		return;
	cCnt = segLE - segLS + 1;
	segStart[segCnt] = (segH<<8)+segLS;
	segEnd[segCnt] = (segH<<8)+segLE;
	segUni[segCnt]  = EUDCCODEBASE	+recCnt;
	recCnt += cCnt;
	segCnt++;
}
void
makeUniCodeTbl ( )
{
	int	base;
	unsigned short	slow, elow;
	int	n;
	int	nlow;
	unsigned short high;
	COUNTRYINFO	*cInfo;

    //we don't need an unicode table if we only have unicode
    if (CountryInfo.bOnlyUnicode) 
        return;

	if ( init)	return ;
	cInfo = &CountryInfo;
	base = 0;
	segCnt = recCnt = 0;
	for ( n=0; n < cInfo->nRange - 1; n++) {

#ifdef BUILD_ON_WINNT
        /* CHS needs to dynamically calculate trailbyte range for each 
         * EUDC select range.
         */
        if (cInfo->LangID == EUDC_CHS)
            CorrectTrailByteRange(n);
#endif // BUILD_ON_WINNT

		for ( high = cInfo->sLeadByte[n]; high <=cInfo->eLeadByte[n]; 
                                                        high++){
		    if ( high == cInfo->sLeadByte[n])
			    slow = cInfo->sRange[n] & 0xff;
		    else
			    slow = cInfo->sTralByte[0];
		    if ( high ==cInfo->eLeadByte[n])
			    elow = cInfo->eRange[n] & 0xff;
		    else
			    elow = cInfo->eTralByte[cInfo->nTralByte-1];

		    for ( nlow = 0; nlow < cInfo->nTralByte; nlow++) {
			if (  slow >= cInfo->sTralByte[nlow]
					&& slow <= cInfo->eTralByte[nlow]) {
				if ( elow <=  cInfo->eTralByte[nlow] )
					setseg( high, slow, elow);
				else
				    setseg( high, slow, cInfo->eTralByte[nlow]);
			}
			else if ( slow < cInfo->sTralByte[nlow]
				&& elow >= cInfo->sTralByte[nlow]) {
				if ( elow <=  cInfo->eTralByte[nlow] )
				    setseg( high, cInfo->sTralByte[nlow], elow);
				else
				    setseg( high, cInfo->sTralByte[nlow],
						cInfo->sTralByte[nlow]);
			}
		    }
		}
	}
	init = 1;
}
unsigned short
sjisToUniEUDC( unsigned short code)
{
	int	seg;
	unsigned short	ofs;

	for ( seg = 0; seg < segCnt; seg++) {
		if ( code <= segEnd[seg]) {
			if ( segStart[seg] <= code) {
				ofs = code - segStart[seg];
				return segUni[seg]+ofs;
			}
		}
	}
	return (unsigned short)0xffff;
}
unsigned short
getMaxUniCode( )
{
		USHORT ansiMax;
		if (CountryInfo.bOnlyUnicode)
			ansiMax = 0;
		else
			ansiMax = segUni[segCnt-1] + (segEnd[segCnt-1] - segStart[segCnt-1]);
        return max(ansiMax, CountryInfo.eRange[CountryInfo.nRange-1]);
}


/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\bmpope.cpp ===
/***********************************************************************
 *
 *	BitMap Openration modules
 *
 * Copyright (c) 1997-1999 Microsoft Corporation.
 *
 ***********************************************************************
 *	BitMap Specifications
 *
 *	Coordinate
 *		(0,0)	X    (255,0)
 *		 +--------------*
 *		 |
 *	       Y |
 *		 |
 *		 |
 *		 |
 *		 *
 *	      (0,255)
 *	Memory Boundary : Word Boundary
 *
 *	Entry List
 *		BMPDefine,
 *		BMPZoomUp,
 *		BMPOutline
 ***********************************************************************/

#include	"stdafx.h"


#include	"vdata.h"
#include	"extfunc.h"
#define		BMPWIDMAX		256
#define		BMPDEPMAX		256

#define		BMPMAX		8

struct BMPDef {
	int	width, depth;
	unsigned char *buf;
	int	bWid;
	};


void  BMPInit(void);
int  BMPDefine(unsigned char  *buf,int  xWid,int  yWid);
int  BMPFreDef(int  bmpno);
int  BMPMkCont(int  BMPNo,int  wkBMP,int  refBMP,int  lsthdl);
static int  SearchON(int  BMPNo,int  x,int  y);
static int  outline(int  BMPNo,int  x,int  y,int  lsthdl,int  wkBMP,int  refBMP);
static int  ContributeOutside(int  BMPNo,int  wkBMP,struct  vecdata *org,int  lsthdl);
static int  ContributeInside(int  BMPNo,int  wkBMP,struct  vecdata *org,int  lsthdl);
int  rdot(int  BMP,int  x,int  y);
void  wdot(int  BMP,int  x,int  y,int  onoff);
int  ReverseRight(int  BMPNo,int  x,int  y);
static void  cpybuf(int  src,int  dst);
int  BMPReverse(int  bmpNo);
int  BMPClear(int  bmpNo);

struct BMPDef BMPTbl[BMPMAX]={0};

	/* On Bit Most left position */
static unsigned char	bitptbl[256] = {
	 8,  7,  6,  6,  5,  5,  5,  5,  4,  4,  4,  4,  4,  4,  4,  4,
	 3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,
	 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
	 2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,
	 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
	};
static unsigned char	wmaskB[8]={
	0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01
	};
static unsigned char	rightmask[8] = {
	0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01
	};
/***********************************************************************
 *	BMP Initialize
 */
/* */	void
/* */	BMPInit()
/*
 *	returns; none
 ***********************************************************************/
{
	int	i;

	for ( i = 0; i < BMPMAX; i++)
		BMPTbl[i].buf=(unsigned char *)0;
	return;
}
/***********************************************************************
 *	Define BitMap
 */
/* */	int
/* */	BMPDefine(
/* */		unsigned char *buf,
/* */		int	xWid,
/* */		int	yWid)
/*
 *	returns : 0-(BMPMAX-1), -1
 ***********************************************************************/
{
	int	i;

       if (!buf)
       {
          goto ERET;
       }
	/* Check Size */
	if ( xWid > BMPWIDMAX || xWid < 0
		    ||	yWid > BMPWIDMAX || yWid < 0)
		goto	ERET;

	/* Set Define */
	for ( i = 0; i < BMPMAX; i++) {
		if (BMPTbl[i].buf==(unsigned char *)0) {
			BMPTbl[i].bWid =  (xWid + 15)/16*2;
			BMPTbl[i].width = xWid;
			BMPTbl[i].depth = yWid;
			BMPTbl[i].buf = buf;

			return(i);
		}
	}
ERET:
	return( -1);
}
/***********************************************************************
 *	Free BMP define
 */
/* */	int
/* */	BMPFreDef( int bmpno)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	if ( bmpno < 0 || bmpno >= BMPMAX)
		return -1;
	else {
		BMPTbl[bmpno].buf = 0;
		return 0;
	}
}
/***********************************************************************
 *	Get Outline
 */
/* */	int
/* */	BMPMkCont( int BMPNo, int wkBMP, int refBMP, int lsthdl)
/*
 *	returns : Number of Contour, -1
 *	REMARKS : Used BMP be destroyed
 ***********************************************************************/
{
	int	x, y;
	int	ncont;
	int	sts;

	VDNew( lsthdl);
	sts = 0;
	ncont = 0;
	cpybuf( BMPNo, wkBMP);
	cpybuf( BMPNo, refBMP);
	for ( y = 0; y < BMPTbl[BMPNo].depth; y++) {
		x = 0;
		while ( (x = SearchON( wkBMP, x, y)) <BMPTbl[BMPNo].width) {
			if ((sts = outline( BMPNo, x, y,lsthdl, wkBMP, refBMP))<0)
				goto	RET;

			ncont++;
			x++;
		}
	}
	sts = ncont;
    	cpybuf(refBMP,BMPNo);
RET:
	return( sts);
}
/***********************************************************************
 *	Search ON dot
 */
/* */	static int
/* */	SearchON( int BMPNo, int x, int y)
/*
 *	returns : found position, Width(Not Found case)
 ***********************************************************************/
{
	int	bpos;		/* byte position */
	int	sbitpos;	/* Start Byte Bit position */
unsigned char	*p;

	bpos = x/8;
	sbitpos = x % 8;
	p = BMPTbl[BMPNo].buf + BMPTbl[BMPNo].bWid*y + bpos;
	/* First Byte */
	if ( *p & rightmask[sbitpos])
		x = bpos*8 + bitptbl[(int)(*p& rightmask[sbitpos])];
	else {
		bpos++;
		x = bpos*8;
		for ( ; bpos < BMPTbl[BMPNo].bWid; bpos++, x+=8) {
			p++;
			if (*p) {
				x += bitptbl[(int)*p];
				break;
			}
		}
	}
	return( x);
}
/***********************************************************************
 *	make outline data
 */
/* */	static int
/* */	outline(
/* */		int	BMPNo,
/* */		int	x,
/* */		int	y,
/* */		int	lsthdl,
/* */		int	wkBMP,
/* */		int	refBMP)
/*
 *	returns : 0, -1
 **********************************************************************/
{
	int	inout;
    struct vecdata	vd;	
	int	sts;

	/* Check Inside/Outside */
	if ( rdot( refBMP, x, y) ==rdot( wkBMP, x, y))	/* OUTSIDE */
		inout = 0;
	else	/* INSIDE */
		inout = 1;

	/* copy buffer */
	cpybuf( wkBMP, BMPNo);
	/* contribute */
	vd.x = (short)x;
	vd.y = (short)y;
	vd.atr = 0;
	if ( inout==0)
		sts = ContributeOutside( BMPNo, wkBMP, &vd, lsthdl);
	else
		sts = ContributeInside( BMPNo, wkBMP, &vd, lsthdl);
	return( sts);
}
/***********************************************************************
 *	Contribute Outside Contour
 */
/* */	static int
/* */	ContributeOutside(int BMPNo, int wkBMP, struct vecdata *org, int lsthdl)
/*
 *	returns : 0, -1
 *	Direction	2
 *			|
 *			|
 *		3-------+-------1
 *			|
 *			|
 *			0
 ***********************************************************************/
{
	int	orgx, orgy;
struct vecdata	vd;
	int	dir;

       if (!org)
       {
           return -1;
       }
	orgx = org->x;
	orgy = org->y;
	vd = *org;
	dir = 0;
	/*
	if (ReverseRight( wkBMP, vd.x, vd.y))
		return( -1);
	*/
	do {
		if (VDSetData( lsthdl, &vd))
			return(-1);
		switch( dir) {
		    case 0:
			if (ReverseRight( wkBMP, vd.x, vd.y))
				return( -1);
			vd.y++;
			if ( rdot( BMPNo, vd.x-1, vd.y))
				dir = 3;
			else if ( rdot( BMPNo, vd.x, vd.y))
				dir = 0;
			else	dir = 1;
			break;
		    case 1:
			vd.x++;
			if ( rdot( BMPNo, vd.x, vd.y))
				dir = 0;
			else if ( rdot( BMPNo, vd.x, vd.y-1))
				dir = 1;
			else	dir = 2;
			break;
		    case 2:
			vd.y--;
			if (ReverseRight( wkBMP, vd.x, vd.y))
				return( -1);
			if ( rdot( BMPNo, vd.x, vd.y-1))
				dir = 1;
			else if ( rdot( BMPNo, vd.x-1, vd.y-1))
				dir = 2;
			else	dir = 3;
			break;
		    case 3:
			vd.x--;
			if ( rdot( BMPNo, vd.x-1, vd.y-1))
				dir = 2;
			else if ( rdot( BMPNo, vd.x-1, vd.y))
				dir = 3;
			else	dir = 0;
			break;
		}

	} while( vd.x!=orgx || vd.y != orgy);
	VDClose(lsthdl);
	return( 0);
}
/***********************************************************************
 *	Contribute Outside Contour
 */
/* */	static int
/* */	ContributeInside( int BMPNo, int wkBMP, struct vecdata *org, int lsthdl)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	int	orgx, orgy;
struct vecdata	vd;
	int	dir;

       if (!org)
       {
           return -1;
       }
	orgx = org->x;
	orgy = org->y;
	vd = *org;
	dir = 1;
	do {
		if (VDSetData( lsthdl, &vd))
			return(-1);
		switch( dir) {
		    case 0:
			if (ReverseRight( wkBMP, vd.x, vd.y))
				return( -1);
			vd.y++;
			if ( rdot( BMPNo, vd.x-1, vd.y)==0)	/* right */
				dir = 3;
			else if ( rdot( BMPNo, vd.x, vd.y)==0) /* left */
				dir = 0;
			else	dir = 1;
			break;
		    case 1:
			vd.x++;
			if ( rdot( BMPNo, vd.x, vd.y)==0) /* right */
				dir = 0;
			else if ( rdot( BMPNo, vd.x, vd.y-1)==0) /* left */
				dir = 1;
			else	dir = 2;
			break;
		    case 2:
			vd.y--;
			if (ReverseRight( wkBMP, vd.x, vd.y))
				return( -1);
			if ( rdot( BMPNo, vd.x, vd.y-1)==0)
				dir = 1;
			else if ( rdot( BMPNo, vd.x-1, vd.y-1)==0)
				dir = 2;
			else	dir = 3;
			break;
		    case 3:
			vd.x--;
			if ( rdot( BMPNo, vd.x-1, vd.y-1)==0)
				dir = 2;
			else if ( rdot( BMPNo, vd.x-1, vd.y)==0)
				dir = 3;
			else	dir = 0;
			break;
		}
	} while( vd.x!=orgx || vd.y != orgy);
	VDClose(lsthdl);

	return( 0);
}
/***********************************************************************
 *	Read Dot
 */
/* */	int
/* */	rdot( int BMP, int x, int y)
/*
 *	returns : 0, nonzero
 ***********************************************************************/
{
	unsigned char	*radd;
	int	rbit;
	int	onoff;

	if ( x < 0 || y < 0 || x>=BMPTbl[BMP].width ||y>=BMPTbl[BMP].depth)
		return( 0);

	radd = BMPTbl[BMP].buf + BMPTbl[BMP].bWid*y + x/8;
	rbit = x % 8;
	onoff = (int)(wmaskB[rbit] & *radd);
	return  onoff;
}
/***********************************************************************
 *	Write Dot
 */
/* */	void
/* */	wdot( int BMP, int x, int y, int onoff)
/*
 *	returns : none
 ***********************************************************************/
{
	unsigned char	*radd;
	int	rbit;

	if ( x < 0 || y < 0 || x>=BMPTbl[BMP].width ||y>=BMPTbl[BMP].depth)
		return;

	radd = BMPTbl[BMP].buf + BMPTbl[BMP].bWid*y + x/8;
	rbit = x % 8;

	if ( onoff)	*radd |= wmaskB[rbit];
	else		*radd &= ~wmaskB[rbit];
	return;
}
/***********************************************************************
 *	Reverse right side ( Edge fill method)
 */
/* */	int
/* */	ReverseRight( int BMPNo, int x, int y)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	int	rb;
	int	bitp;
unsigned char	*wp;

	if ( BMPNo < 0 || BMPNo >= BMPMAX)
		return 0;
	if ( x < 0 || x >= BMPTbl[BMPNo].width
	 || y < 0 || y >= BMPTbl[BMPNo].depth)
		return 0;
	rb = BMPTbl[BMPNo].bWid - x/8 -1;
	bitp = x%8;
	wp = BMPTbl[BMPNo].buf + y*BMPTbl[BMPNo].bWid + x/8;

	/* First Byte */
	*wp ^= rightmask[bitp];

	/* to right limit */
	while( rb-->0) {
		wp++;
		*wp = (unsigned char)~(*wp);
	}
	return ( 0);
}
/***********************************************************************
 *	Copy Buffer
 */
/* */	static void
/* */	cpybuf( int src, int dst)
/*
 *	returns : none
 ***********************************************************************/
{
	int	siz;

	if ( src < 0 || src >= BMPMAX)
		return;
	if ( dst < 0 || dst >= BMPMAX)
		return;
	siz = BMPTbl[src].bWid * BMPTbl[src].depth;
	memcpy( BMPTbl[dst].buf, BMPTbl[src].buf, siz);
}
/***********************************************************************
 *	Reverse bitmap
 */
/* */	int
/* */	BMPReverse( int bmpNo)
/*
 *	returns : none
 ***********************************************************************/
{
	int	siz;
	char	*buf;

	if ( bmpNo < 0 || bmpNo >= BMPMAX)
		return -1;
	else if (BMPTbl[bmpNo].buf==(unsigned char *)0)
		return -1;
	else {
		siz = BMPTbl[bmpNo].bWid * BMPTbl[bmpNo].depth;
		buf = (char *)BMPTbl[bmpNo].buf;
		while ( siz-->0) {
			*buf = (char)~*buf;
			buf++;
		}
			
	}
	return 0;
}
/***********************************************************************
 *	Clear BMP
 */
/* */	int
/* */	BMPClear( int bmpNo)
/*
 *	returns : 0,-1
 ***********************************************************************/
{
	int	siz;

	if ( bmpNo < 0 || bmpNo >= BMPMAX)
		return -1;
	else if (BMPTbl[bmpNo].buf==(unsigned char *)0)
		return -1;
	siz = BMPTbl[bmpNo].bWid * BMPTbl[bmpNo].depth;
	memset( BMPTbl[bmpNo].buf, 0, siz);
	return 0;
}

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\editwnd.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#include	<afxtempl.h>

class CEditWnd : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CEditWnd)
public:
	CEditWnd();
	int  	SaveEUDCCode(UINT msgBoxType);
	void 	CallCharTextOut();
	void 	SetDuplicateRect( RECT	*rect, POINT *point);
	void 	FlipRotate( int RadioItem);
	void	WriteSelRectBitmap();
	BOOL 	SelectCodes();
	BOOL	UpdateBitmap();
	BOOL 	GetBitmapDirty();
	BOOL	SetBitmapDirty( BOOL Flg);
	BOOL 	Create( LPCTSTR szTitle, LONG Style, 
			RECT EudcWndRect, CMDIFrameWnd* Parent);
	virtual ~CEditWnd();
	void 	CaptionDraw();

private:
	BOOL	MoveClipRect();
	void	RotateFigure90( LPBYTE pBuf1, LPBYTE pBuf2, int bWid, int bHgt);
	void	RotateFigure270( LPBYTE pBuf1, LPBYTE pBuf2,int bWid, int bHgt);
	void	DrawGridLine( CDC *dc);
	void 	DrawMoveRect( CDC *dc);
	void 	DrawStretchRect( CDC *dc);
	BOOL	CurveFittingDraw( CDC *dc);
	void 	CorrectMouseDownPoint( CPoint point);
	void 	CorrectMouseUpPoint( CPoint point);
	void 	DrawClipBmp();
	void 	UndoImageDraw();
	void 	EraseRectangle();
	void 	EraseFreeForm();
	BOOL 	SetFreeForm();
	void 	ZoomPoint( CPoint *DrawPt, int x, int y);
	void 	IllegalRect( PPOINT ptTL, PPOINT ptBR);
	void 	DrawFreeForm( BOOL MouseSts);
	void 	SelectFreeForm( BOOL MouseSts);
	void 	ToolInit( int LRButton);
	void 	ToolTerm();
	void 	DrawRubberBand( BOOL StretchFlag);
	void 	SetMoveRect();
	void 	SetValidRect();
	void 	SetPickRect();
	void	SetClickRect();
	void 	StretchMoveRect();
	void 	DrawRectBmp();
	void 	DrawPoint( CPoint Pt, BOOL bErase);
	void 	DrawToPoint(BOOL bErase);
	void 	InitFlipRotate( CDC *RotateDC, CBitmap *RotateBMP);
	BOOL 	DrawStretchClipToDisp();
	BOOL 	CreateNewBitmap();
	BOOL 	CreateUndoBitmap();
	BOOL 	ClipPickValueInit();
	BOOL	InitEditLogfont();
	BOOL 	ClipImageCopy();
	BOOL 	ClipImageCut();
	int	CheckClipRect( POINT ClickPoint);

private:
	CBitmap	UndoImage;
	CBitmap	CRTDrawBmp;
	CBitmap	ImageBmp;
	CDC	CRTDrawDC;
	CDC	ImageDC;
	BOOL	BitmapDirty;
	BOOL	RectClipFlag;
	BOOL 	UndoBitmapFlag;
	BOOL 	IsCapture;
	BOOL	ButtonFlag;
	UINT	ClipboardFormat;
	int	Ratio;
	int	CheckNum;
	int	BrushWidth;
	CArray<CPoint,CPoint>	m_pointArray;
	CArray<CPoint,CPoint>	m_SelectArray;
	CRgn	FreeRgn;
	CRgn	PickRgn;
	CPoint	ptStart;
	CPoint	ptPrev;
	CPoint	ptEnd;
	CRect	PickRect[8];
	CRect	ClipRect[5];
	CRect	EudcWndRect;

public:
	TCHAR 	SelectFont[40];
	int	SelectItem;
	int	ZoomRate;
	WORD	UpdateCode;
	BOOL	GridShow;
	WORD	CallCode;
	BOOL	FlagTmp;
	BOOL    bFocus;

protected:
	static CMenu NEAR menu;

	//{{AFX_MSG(CEditWnd)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnPaint();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnGaijiCopy();
	afx_msg void OnGaijiCut();
	afx_msg void OnGaijiPaste();
	afx_msg void OnGaijiUndo();
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnUpdateGaijiPaste(CCmdUI* pCmdUI);
	afx_msg void OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd);
	afx_msg void OnUpdateGaijiCopy(CCmdUI* pCmdUI);
	afx_msg void OnUpdateGaijiCut(CCmdUI* pCmdUI);
	afx_msg void OnDeleteEdit();
	afx_msg void OnUpdateDeleteEdit(CCmdUI* pCmdUI);
	afx_msg void OnUpdateGaijiUndo(CCmdUI* pCmdUI);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnClose();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\blinkdlg.h ===
/**************************************************/
/*                                                */
/*                                                */
/*      Chinese IME Batch Mode                    */
/*              (Dialogbox)                       */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#if 0 // move to imeblink.h!

#ifndef RC_INVOKED
#pragma pack(1)
#endif

//	data structure of IME table 
typedef struct tagUSRDICIMHDR {
    WORD  uHeaderSize;                  // 0x00
    BYTE  idUserCharInfoSign[8];        // 0x02
    BYTE  idMajor;                      // 0x0A
    BYTE  idMinor;                      // 0x0B
    DWORD ulTableCount;                 // 0x0C
    WORD  cMethodKeySize;               // 0x10
    BYTE  uchBankID;                    // 0x12
    WORD  idInternalBankID;             // 0x13
    BYTE  achCMEXReserved1[43];         // 0x15
    WORD  uInfoSize;                    // 0x40
    BYTE  chCmdKey;                     // 0x42
    BYTE  idStlnUpd;                    // 0x43
    BYTE  cbField;                      // 0x44
    WORD  idCP;                         // 0x45
    BYTE  achMethodName[6];             // 0x47
    BYTE  achCSIReserved2[51];          // 0x4D
    BYTE  achCopyRightMsg[128];         // 0x80
} USRDICIMHDR;

#ifndef RC_INVOKED
#pragma pack()
#endif

typedef USRDICIMHDR FAR *LPUSRDICIMHDR;

#endif 0 // move to imeblink.h!

class CBLinkDlg : public CDialog
{
public:
    CBLinkDlg(CWnd* pParent = NULL);

    //{{AFX_DATA(CBLinkDlg)
    enum { IDD = IDD_LINKBATCH };
    //}}AFX_DATA

    //{{AFX_VIRTUAL(CBLinkDlg)
    protected:
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

protected:
    BOOL    RegistStringTable();
#if 0 // move to imeblink.h!
    HKL     MatchImeName( LPCTSTR szStr);
    HKL     RegisterTable( HWND hWnd, LPUSRDICIMHDR lpIsvUsrDic,
            DWORD dwFileSize, UINT  uCodePage);
    int     CodePageInfo( UINT uCodePage);
#endif 0 // move to imeblink.h!

protected:
    //{{AFX_MSG(CBLinkDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnBrowsetable();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\common.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
typedef int int16;
typedef long int32;
typedef unsigned int uint16;
typedef unsigned long uint32;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\editwnd.cpp ===
/**************************************************/
/*                                           */
/*                                           */
/* MDI Child Window( For Edit)                     */
/*                                           */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include    "stdafx.h"
#include    "eudcedit.h"
#include    "editwnd.h"
#include    "refrwnd.h"
#include    "vdata.h"
#include "extfunc.h"
#include "util.h"
#include "rotatdlg.h"
#define STRSAFE_LIB
#include <strsafe.h>

// For mouse
#define     NCLICK   0
#define     LCLICK   1
#define     RCLICK   2

// For selected rectangle
#define     LUPPER   0
#define     RUPPER   1
#define     RLOWER   2
#define     LLOWER   3
#define     MUPPER   4
#define     RMIDLE   5
#define     MLOWER   6
#define     LMIDLE   7
#define     NCHECK   8

// For Rectangular selection and freeform selection
#define     BMP   0
#define     DSP   1  
#define     PRV   2
#define     VLD   3
#define     PIN   4

// max of freeform selection point
#define     FREELIAIS   1000
#define     MKOUTHDL 2

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CMenu NEAR CEditWnd::menu;
IMPLEMENT_DYNCREATE( CEditWnd, CMDIChildWnd)
BEGIN_MESSAGE_MAP(CEditWnd, CMDIChildWnd)
//{{AFX_MSG_MAP(CEditWnd)
   ON_WM_LBUTTONDOWN()
   ON_WM_LBUTTONUP()
   ON_WM_MOUSEMOVE()
   ON_WM_PAINT()
   ON_WM_CREATE()
   ON_COMMAND(ID_GAIJI_COPY, OnGaijiCopy)
   ON_COMMAND(ID_GAIJI_CUT, OnGaijiCut)
   ON_COMMAND(ID_GAIJI_PASTE, OnGaijiPaste)
   ON_COMMAND(ID_GAIJI_UNDO, OnGaijiUndo)
   ON_WM_RBUTTONDOWN()
   ON_WM_RBUTTONUP()
   ON_WM_SIZE()
   ON_WM_SETCURSOR()
   ON_UPDATE_COMMAND_UI(ID_GAIJI_PASTE, OnUpdateGaijiPaste)
   ON_WM_MDIACTIVATE()
   ON_UPDATE_COMMAND_UI(ID_GAIJI_COPY, OnUpdateGaijiCopy)
   ON_UPDATE_COMMAND_UI(ID_GAIJI_CUT, OnUpdateGaijiCut)
   ON_COMMAND(ID_DELETE_EDIT, OnDeleteEdit)
   ON_UPDATE_COMMAND_UI(ID_DELETE_EDIT, OnUpdateDeleteEdit)
   ON_UPDATE_COMMAND_UI(ID_GAIJI_UNDO, OnUpdateGaijiUndo)
   ON_WM_KEYDOWN()
   ON_WM_CLOSE()
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// Global parameter
LOGFONT  EditLogFont;
extern   int   SelectItems;
extern  CBitmap   DupBmp;
extern  CRect  DupRect;
extern CRefrWnd *pRefrChild;
extern BOOL g_bKeepEUDCLink;

/****************************************/
/*             */
/*   Create MDI child window for edit  */
/*             */
/****************************************/
BOOL
CEditWnd::Create(
LPCTSTR  szTitle,
LONG  Style,
RECT  EudcWndRect,
CMDIFrameWnd* Parent)
{
// Load menu as same as MainFrame
   if( menu.m_hMenu == NULL)
      menu.LoadMenu( IDR_MAINFRAME);
   m_hMenuShared = menu.m_hMenu;

// Register window class of MDI child for edit
   const TCHAR *pszEudcWndClass =
      AfxRegisterWndClass( CS_BYTEALIGNCLIENT,
      NULL, (HBRUSH)(COLOR_WINDOW+1), NULL);

   return CMDIChildWnd::Create( pszEudcWndClass,
          szTitle, Style, EudcWndRect, Parent);
}

/****************************************/
/*             */
/*   Process before window is created  */
/*             */
/****************************************/
int
CEditWnd::OnCreate( LPCREATESTRUCT lpCreateStruct)
{
   if( CMDIChildWnd::OnCreate( lpCreateStruct) == -1)
      goto ERR;

// If it is mirrored then turn off mirroing.
   ModifyStyleEx( WS_EX_LAYOUTRTL, 0);

   if( !CreateNewBitmap())
      goto ERR;
   if( !ClipPickValueInit())
      goto ERR;
   if( !InitEditLogfont())
      goto ERR;

   return  0;
ERR:
   return -1;
}

/****************************************/
/*             */
/* Create bitmap, and initialized   */
/*             */
/****************************************/
BOOL
CEditWnd::CreateNewBitmap()
{
   WORD  BitSize;
   HANDLE   BitInit;
   BYTE  *BitmapPtr;

   CClientDC   ChildDC( this);

   if( !ImageDC.CreateCompatibleDC( &ChildDC))
      return FALSE;

   if( !CRTDrawDC.CreateCompatibleDC( &ChildDC))
      return FALSE;

   BitSize = (WORD)((( BITMAP_WIDTH +15) /16) *2) *(WORD)BITMAP_HEIGHT;
   if (BitSize == 0)
   {
   	return (FALSE);
   }
   if(( BitInit = LocalAlloc( LMEM_MOVEABLE, BitSize)) == 0)
      return FALSE;

   if(( BitmapPtr = (BYTE *)LocalLock( BitInit)) == NULL){
      LocalFree( BitInit);
      return FALSE;
   }

// Initialize with white color
   memset( BitmapPtr, 0xffff, BitSize);
   if( !ImageBmp.CreateBitmap( BITMAP_WIDTH, BITMAP_HEIGHT,
      1, 1, (LPSTR)BitmapPtr)){
      LocalUnlock( BitInit);
      LocalFree( BitInit);
      return FALSE;
   }

// Initialize with white color
   if( !CRTDrawBmp.CreateBitmap( BITMAP_WIDTH, BITMAP_HEIGHT,
       1, 1, (LPSTR)BitmapPtr)){
       LocalUnlock( BitInit);
       LocalFree( BitInit);
      return FALSE;
   }
   LocalUnlock( BitInit);
   LocalFree( BitInit);    
   ImageDC.SelectObject( &ImageBmp);
   CRTDrawDC.SelectObject( &CRTDrawBmp);

   return TRUE;
}
               
/****************************************/
/*             */
/* Registry clipboard format  */
/*             */
/****************************************/
BOOL
CEditWnd::ClipPickValueInit()
{
// Register "EUDCEDIT" clipboard format
   if( !( ClipboardFormat = RegisterClipboardFormat(TEXT("EudcEdit"))))
      return FALSE;

   return TRUE;
}
               
/****************************************/
/*             */
/* Initialize EditLogFont     */
/*             */
/****************************************/
BOOL
CEditWnd::InitEditLogfont()
{
   CFont cFont;

#ifdef BUILD_ON_WINNT
  cFont.CreateStockObject(DEFAULT_GUI_FONT);
#else
   cFont.CreateStockObject( SYSTEM_FONT);
#endif
   cFont.GetObject( sizeof(LOGFONT), &EditLogFont);
   cFont.DeleteObject();

   return TRUE;
}

/****************************************/
/*             */
/* Default Constructor     */
/*             */
/****************************************/
CEditWnd::CEditWnd()
{
// Initialize static parameter
   BitmapDirty = FALSE;
   GridShow = TRUE;
   SelectItem = PEN;
   RectClipFlag = FALSE;
   CheckNum = NCHECK;
   ButtonFlag = NCLICK;
   IsCapture = FALSE;
   UndoBitmapFlag = FALSE;
   FlagTmp = FALSE;
   UpdateCode = 0x0000;
   Ratio = 3;
   bFocus = TRUE;
}
   
/****************************************/
/*             */
/* Destructor        */
/*             */ 
/****************************************/
CEditWnd::~CEditWnd()
{
// Delete CDC and CBitmap object
   if( CRTDrawBmp.Detach() != NULL)
      CRTDrawBmp.DeleteObject();
   if( ImageBmp.Detach() != NULL)
      ImageBmp.DeleteObject();
   if( CRTDrawDC.Detach() != NULL)
      CRTDrawDC.DeleteDC();
   if( ImageDC.Detach() != NULL)
      ImageDC.DeleteDC();
   if( UndoImage.Detach() != NULL)
      UndoImage.DeleteObject();
  menu.DestroyMenu();
}

/****************************************/
/*             */
/* COMMAND     "UNDO"      */
/*             */
/****************************************/
void
CEditWnd::OnGaijiUndo()
{
   int   wSize;
   LPBYTE   pBuf1, pBuf2;

   if( !UndoBitmapFlag)
      CreateUndoBitmap();
   UndoBitmapFlag = TRUE;

   if( SelectItem == RECTCLIP || SelectItem == FREEFORM)
      WriteSelRectBitmap();

   wSize = (int)((( BITMAP_WIDTH +15) /16) *2) *(int)BITMAP_HEIGHT;
   pBuf1 = (LPBYTE)malloc( wSize);
   pBuf2 = (LPBYTE)malloc( wSize);
   ImageBmp.GetBitmapBits( wSize, (LPVOID)pBuf1);
   UndoImage.GetBitmapBits( wSize, (LPVOID)pBuf2);
   ImageBmp.SetBitmapBits( wSize, (LPVOID)pBuf2);
   UndoImage.SetBitmapBits( wSize, (LPVOID)pBuf1);          
   free(pBuf1);
   free(pBuf2);
   
   this->Invalidate(FALSE);   
   this->UpdateWindow();
}

/****************************************/
/*             */
/* COMMAND     "UNDO" (Update)   */
/*             */
/****************************************/
void
CEditWnd::OnUpdateGaijiUndo(
CCmdUI* pCmdUI)
{
   if( BitmapDirty)
      pCmdUI->Enable(TRUE);
   else  pCmdUI->Enable(FALSE);
}

/****************************************/
/*             */
/* COMMAND     "CUT"    */
/*             */
/****************************************/
void
CEditWnd::OnGaijiCut()
{
   UndoImageDraw();
   BitmapDirty = TRUE;
   ClipImageCopy();
   ClipImageCut();
   this->Invalidate(FALSE);
   if( RectClipFlag){
      ToolTerm();
      RectClipFlag = FALSE;
   }        
}

/****************************************/
/*             */
/* COMMAND     "Cut" (Update) */
/*             */
/****************************************/
void
CEditWnd::OnUpdateGaijiCut(
CCmdUI* pCmdUI)
{
   if (pCmdUI)
   {
       pCmdUI->Enable( RectClipFlag);   
   }
}

/****************************************/
/*             */
/* COMMAND     "COPY"      */
/*             */
/****************************************/
void
CEditWnd::OnGaijiCopy()
{
   ClipImageCopy();
}

/****************************************/
/*             */
/* COMMAND     "Copy" (Update)   */
/*             */
/****************************************/
void
CEditWnd::OnUpdateGaijiCopy( CCmdUI* pCmdUI)
{
   if (pCmdUI)
   {
      pCmdUI->Enable( RectClipFlag);   
   }
}

/****************************************/
/*             */
/* COMMAND     "PASTE"     */
/*             */
/****************************************/
void
CEditWnd::OnGaijiPaste()
{
   HBITMAP  ClipBmpHandle, hTempBitmap1;
   CBitmap  ClipBmp1, ClipBmp2;
   HDC   hStdDC, hTempDC1;
   HGDIOBJ  hOldSObj, hOldSObj2;
   BITMAP   Bmp;
   CSize StretchSize;
   BOOL  BitmapFmt, PrivateFmt;

   BitmapFmt  = FALSE;
   PrivateFmt = FALSE;
   UndoImageDraw();
   BitmapDirty = TRUE;
   WriteSelRectBitmap();
   this->Invalidate( FALSE);
   this->UpdateWindow();

   if( !this->OpenClipboard())
      return;

   if(( ClipBmpHandle = (HBITMAP)GetClipboardData(CF_BITMAP)) == NULL){
      CloseClipboard();
         return;
      }
   GetObject(ClipBmpHandle, sizeof(BITMAP), (LPVOID)&Bmp);
   hStdDC = CreateCompatibleDC( ImageDC.GetSafeHdc());
   hOldSObj = SelectObject(hStdDC, ClipBmpHandle);

   hTempBitmap1 = CreateBitmap(Bmp.bmWidth, Bmp.bmHeight, 1, 1, NULL);
   hTempDC1 = CreateCompatibleDC( ImageDC.GetSafeHdc());
   hOldSObj2 = SelectObject( hTempDC1, hTempBitmap1);
   ::BitBlt( hTempDC1, 0, 0, Bmp.bmWidth, Bmp.bmHeight,
      hStdDC, 0, 0, SRCCOPY);

   if( !CloseClipboard())
  {
   SelectObject( hStdDC, hOldSObj);
     SelectObject( hTempDC1, hOldSObj2);
     DeleteObject( hTempBitmap1);
     DeleteDC( hStdDC);
     DeleteDC( hTempDC1);
      return;
  }
   if( (int)Bmp.bmWidth  < BITMAP_WIDTH  &&
            (int)Bmp.bmHeight < BITMAP_HEIGHT ){
         StretchSize.cx = (int)Bmp.bmWidth;
         StretchSize.cy = (int)Bmp.bmHeight;
      ::StretchBlt( CRTDrawDC.GetSafeHdc(), 0, 0,
         StretchSize.cx, StretchSize.cy, hTempDC1, 0, 0,
         StretchSize.cx, StretchSize.cy, SRCCOPY);
      }else if( Bmp.bmWidth < BITMAP_WIDTH){
      StretchSize.cx = (int)Bmp.bmWidth;
      StretchSize.cy = BITMAP_HEIGHT;
      ::StretchBlt( CRTDrawDC.GetSafeHdc(), 0, 0,
         StretchSize.cx, StretchSize.cy, hTempDC1, 0, 0,
         StretchSize.cx, Bmp.bmHeight, SRCCOPY);
   }else if( Bmp.bmHeight < BITMAP_HEIGHT){
      StretchSize.cx = BITMAP_HEIGHT;
      StretchSize.cy = (int)Bmp.bmHeight;
      ::StretchBlt( CRTDrawDC.GetSafeHdc(), 0, 0,
         StretchSize.cx, StretchSize.cy, hTempDC1, 0, 0,
         Bmp.bmWidth, StretchSize.cy, SRCCOPY);
   }else{
         StretchSize.cx = BITMAP_WIDTH;
         StretchSize.cy = BITMAP_HEIGHT;
      ::StretchBlt( CRTDrawDC.GetSafeHdc(), 0, 0,
         StretchSize.cx, StretchSize.cy, hTempDC1, 0, 0,
         Bmp.bmWidth, Bmp.bmHeight, SRCCOPY);
      }
   ptStart.x = 0;
   ptStart.y = 0;
   ptEnd.x = (StretchSize.cx-1) *ZoomRate;
   ptEnd.y = (StretchSize.cy-1) *ZoomRate;
   SetMoveRect();
   SetValidRect();
   SetClickRect();
   SetPickRect();
   SelectItem = RECTCLIP;
   RectClipFlag = TRUE;
   this->InvalidateRect( &ClipRect[VLD], FALSE);
   this->UpdateWindow();

   SelectObject( hStdDC, hOldSObj);
   SelectObject( hTempDC1, hOldSObj2);
   DeleteObject( hTempBitmap1);
   DeleteDC( hStdDC);
   DeleteDC( hTempDC1);

    return; 
}

/****************************************/
/*             */
/* COMMAND  "PASTE" (Update)  */
/*             */
/****************************************/
void
CEditWnd::OnUpdateGaijiPaste(
CCmdUI* pCmdUI)
{
   UINT  ClipFormat;
   BOOL  BitmapFmt;
   BOOL  PrivateFmt;

   if (!pCmdUI)
   {
      return;
   }
   BitmapFmt  = FALSE;
   PrivateFmt = FALSE;
   if( !::OpenClipboard(this->GetSafeHwnd()))
      return;

   for( ClipFormat = 0;;){
         ClipFormat = EnumClipboardFormats( ClipFormat);
         if( ClipFormat == CF_BITMAP){
                  BitmapFmt = TRUE;
                  if( PrivateFmt)   break;
         }
         if( ClipFormat == ClipboardFormat){
                  PrivateFmt = TRUE;
                  if( BitmapFmt) break;
         }
         if( ClipFormat == 0)   break;
      }
      if( !PrivateFmt){
         if( BitmapFmt){
         CloseClipboard();
         pCmdUI->Enable(TRUE);
         return;
         }else{
                  CloseClipboard();
         pCmdUI->Enable(FALSE);
                  return;
         }
      }else{
         if ( !BitmapFmt){
                  CloseClipboard();
         pCmdUI->Enable(FALSE);
                  return;
         }
      }
   CloseClipboard();
   pCmdUI->Enable(FALSE);
}

/****************************************/
/*             */
/* COMMAND     "Delete" */
/*             */
/****************************************/
void
CEditWnd::OnDeleteEdit()
{
   UndoImageDraw();
   BitmapDirty = TRUE;
   if(( SelectItem == RECTCLIP || SelectItem == FREEFORM) &&
        RectClipFlag){
      RectClipFlag = FALSE;
      ToolTerm();
   }
   this->Invalidate( FALSE);
   this->UpdateWindow();
}

/****************************************/
/*             */
/* COMMAND     "Delete"(Update)*/
/*             */
/****************************************/
void
CEditWnd::OnUpdateDeleteEdit(
CCmdUI* pCmdUI)
{
   pCmdUI->Enable( RectClipFlag);   
}

/****************************************/
/*             */
/* Create bitmap for undo     */
/*             */
/****************************************/
BOOL
CEditWnd::CreateUndoBitmap()
{
   HANDLE   BitHandle;
   BYTE  *pBitmap;
   WORD  wSize;

   wSize = (WORD)((( BITMAP_WIDTH + 15) /16) *2) *(WORD)BITMAP_HEIGHT;
   if(( BitHandle = LocalAlloc( LMEM_MOVEABLE, wSize)) == 0)
      return FALSE;

   if(( pBitmap = (BYTE *)LocalLock( BitHandle)) == NULL){
      LocalFree( BitHandle);
      return FALSE;
   }
   memset( pBitmap, 0xffff, wSize);
   if( !UndoImage.CreateBitmap( BITMAP_WIDTH, BITMAP_HEIGHT,
             1, 1, (LPSTR)pBitmap)){
      LocalFree( BitHandle);
      return FALSE;
   }
   LocalUnlock( BitHandle);
   LocalFree( BitHandle);
   return TRUE;   
}

/****************************************/
/*             */
/* Cut image to clipboard     */
/*             */
/****************************************/
BOOL
CEditWnd::ClipImageCut()
{
   CPen   CutPen;
   CBrush CutBrush;

   CutPen.CreateStockObject( NULL_PEN);
   CPen *OldPen = CRTDrawDC.SelectObject( &CutPen);
   CutBrush.CreateSolidBrush( COLOR_WHITE );
      CBrush *OldBrush = CRTDrawDC.SelectObject( &CutBrush);

   ClipRect[BMP].right  += 1;
   ClipRect[BMP].bottom += 1;
      CRTDrawDC.Rectangle( &ClipRect[BMP]);

      CRTDrawDC.SelectObject( OldPen);
      CRTDrawDC.SelectObject( OldBrush);
   CutPen.DeleteObject();
   CutBrush.DeleteObject();
   return TRUE;
}

/****************************************/
/*             */
/* Copy image to clipboard    */
/*             */
/****************************************/
BOOL
CEditWnd::ClipImageCopy()
{
   CBitmap  ClipBmp;
   CDC   ClipDC;
   CRect pRect;

   pRect.SetRect( ClipRect[DSP].left /ZoomRate,
        ( ClipRect[DSP].top - CAPTION_HEIGHT) /ZoomRate,
          ClipRect[DSP].right /ZoomRate,
        ( ClipRect[DSP].bottom - CAPTION_HEIGHT) /ZoomRate);

   ClipDC.CreateCompatibleDC( &ImageDC);
      ClipBmp.CreateCompatibleBitmap( &ImageDC,
         pRect.Width(), pRect.Height());
      CBitmap *OldClip = ClipDC.SelectObject( &ClipBmp);

      ClipDC.PatBlt( 0, 0, pRect.Width(), pRect.Height(), WHITENESS);
      ClipDC.StretchBlt( 0, 0, pRect.Width(), pRect.Height(), &CRTDrawDC,
         ClipRect[BMP].left, ClipRect[BMP].top,
      ClipRect[BMP].Width(), ClipRect[BMP].Height(),SRCCOPY);

      if( !this->OpenClipboard()){
      ClipDC.SelectObject( OldClip);
      ClipBmp.DeleteObject();
         ClipDC.DeleteDC();
         return FALSE;
      }
      EmptyClipboard();

   if( !SetClipboardData( CF_BITMAP, ClipBmp.Detach())){
      ClipDC.SelectObject( OldClip);
      ClipBmp.DeleteObject();
         ClipDC.DeleteDC();
         CloseClipboard();
         return FALSE;
      }
      CloseClipboard();
   ClipDC.SelectObject( OldClip);
   ClipBmp.DeleteObject();
      ClipDC.DeleteDC();
      return TRUE;
}

/****************************************/
/*             */
/* MESSAGE  "WM_PAINT"     */
/*             */
/****************************************/
void
CEditWnd::OnPaint()
{
   CPaintDC dc( this);
   DWORD    OldTextColor;

   this->GetClientRect( &EudcWndRect);

// Set textcolor to gray if fitting curve
   if( FlagTmp)
      OldTextColor = dc.SetTextColor( COLOR_FITTING);
   else  OldTextColor = dc.SetTextColor( COLOR_BLACK);

// Put bitmap data   on display
   ZoomRate = EudcWndRect.right /BITMAP_WIDTH;
   dc.StretchBlt( 0, CAPTION_HEIGHT, EudcWndRect.right,
      EudcWndRect.bottom - CAPTION_HEIGHT,
      &ImageDC, 0, 0, BITMAP_WIDTH, BITMAP_HEIGHT, SRCCOPY);

// Draw selected rectangle if RectClipFlag is build
   if( RectClipFlag){
      dc.StretchBlt( ClipRect[DSP].left - 1, ClipRect[DSP].top - 1,
         ClipRect[DSP].Width(), ClipRect[DSP].Height(),
         &CRTDrawDC, ClipRect[BMP].left, ClipRect[BMP].top,
         ClipRect[BMP].Width(), ClipRect[BMP].Height(), SRCAND);

      DrawMoveRect( &dc);
      DrawStretchRect( &dc);
   }
   dc.SetTextColor( OldTextColor);
   CaptionDraw();

   if( ZoomRate >= 2 && GridShow)
      DrawGridLine( &dc);

   if( FlagTmp)
      CurveFittingDraw( &dc);
}
               
/****************************************/
/*             */
/* MESSAGE  "WM_LBUTTONDOWN"  */
/*             */
/****************************************/
void
CEditWnd::OnLButtonDown(
UINT  ,
CPoint   point)
{
   CRect CaptionRect;
   CPoint   ClickPt;

   if( ButtonFlag == RCLICK){
      this->Invalidate();
      ToolTerm(); 
      return;
   }
   ClickPt = point;
   CaptionRect.CopyRect( &EudcWndRect);
   CaptionRect.top = CAPTION_HEIGHT;
   if( !CaptionRect.PtInRect( point))
      return;

   ToolInit(LCLICK);
// Modurate coordinate
   CorrectMouseDownPoint( point);

// Stretch selected rectangle
   if( RectClipFlag){
      SetClickRect();
      if( ClipRect[PIN].PtInRect( ClickPt) &&
             ( EudcWndRect.Width() > ClipRect[DSP].Width() ||
          EudcWndRect.Height() - CAPTION_HEIGHT
          > ClipRect[DSP].Height())){
            BitmapDirty = TRUE;
      }else if(( CheckNum = CheckClipRect( ClickPt)) != NCHECK){
         BitmapDirty = TRUE;
         SetValidRect();
         RectClipFlag = FALSE;
         this->InvalidateRect( &ClipRect[VLD], FALSE);
         this->UpdateWindow();
         RectClipFlag = TRUE;
         CClientDC   dc( this);
         DrawMoveRect( &dc);
      }else{
         RectClipFlag = FALSE;
         this->InvalidateRect( &ClipRect[VLD], FALSE);
         this->UpdateWindow();
         DrawClipBmp();
         SetPickRect();
         if( SelectItem == RECTCLIP)
            DrawRubberBand( TRUE);
         else{
            CPoint   Sp;

            Sp.x = ptStart.x;
            Sp.y = ptStart.y + CAPTION_HEIGHT;
            m_pointArray.RemoveAll();
            m_SelectArray.RemoveAll();
            m_pointArray.Add( Sp);
            Sp.x = ptStart.x /ZoomRate;
            Sp.y = ptStart.y /ZoomRate;
            m_SelectArray.Add( Sp);

         }
      }
   }else{
      if( SelectItem == PEN || SelectItem == BRUSH ){
         UndoImageDraw();
         BitmapDirty = TRUE;
         DrawPoint( ptStart, FALSE);
      }else if (SelectItem == ERASER){
         UndoImageDraw();
         BitmapDirty = TRUE;
         DrawPoint( ptStart, TRUE);
      }else{
         UndoImageDraw();
         BitmapDirty = TRUE;
         if( SelectItem == FREEFORM){
            CPoint   Sp;

            Sp.x = ptStart.x;
            Sp.y = ptStart.y + CAPTION_HEIGHT;
            m_pointArray.RemoveAll();
            m_SelectArray.RemoveAll();
            m_pointArray.Add( Sp);
            Sp.x = ptStart.x /ZoomRate;
            Sp.y = ptStart.y /ZoomRate;
            m_SelectArray.Add( Sp);
         }else    DrawRubberBand( TRUE);
      }
   }
}

/****************************************/
/*             */
/* MESSAGE  "WM_MOUSEMOVE"    */
/*             */
/****************************************/
void
CEditWnd::OnMouseMove(
UINT  ,
CPoint   point)
{

   if( IsCapture){
//    Modurate coordinate
      CorrectMouseUpPoint( point);
      if( ptPrev.x == ptEnd.x && ptPrev.y == ptEnd.y)
         return;

      if( RectClipFlag){
         if( CheckNum == NCHECK){
            CRect URect, MRect, PRRect;

            if( !MoveClipRect())
               return;
            MRect.SetRect(  ClipRect[DSP].left   - Ratio,
               ClipRect[DSP].top    - Ratio,
               ClipRect[DSP].right  + Ratio,
               ClipRect[DSP].bottom + Ratio);

            PRRect.SetRect( ClipRect[PRV].left   - Ratio,
               ClipRect[PRV].top    - Ratio,
               ClipRect[PRV].right  + Ratio,
               ClipRect[PRV].bottom + Ratio);

            URect.UnionRect( &MRect, &PRRect);
            this->InvalidateRect( &URect, FALSE);
            this->UpdateWindow();

         }else    StretchMoveRect();
      }else{
         if( SelectItem == PEN || SelectItem == BRUSH)
            DrawToPoint(FALSE);
         else if (SelectItem == ERASER)
            DrawToPoint(TRUE);
         else if( SelectItem == FREEFORM){
            DrawFreeForm( FALSE);
            SelectFreeForm(FALSE);
         }else DrawRubberBand( FALSE);
      }
   }
}

/****************************************/
/*             */
/* MESSAGE  "WM_LBUTTONUP"    */
/*             */
/****************************************/
void
CEditWnd::OnLButtonUp(
UINT  ,
CPoint   point)
{
    if (!bFocus)
    {
        bFocus = TRUE;
        CaptionDraw();

        pRefrChild->bFocus = FALSE;
        pRefrChild->CaptionDraw();

    }

   if( IsCapture){
//    Modurate coordinate
      CorrectMouseUpPoint( point);

      if( SelectItem == PEN || SelectItem == BRUSH ||SelectItem == ERASER){
         if( FlagTmp)
            this->Invalidate(FALSE);
         ToolTerm();
         return;
      }

//    draw a figure on bitmap
      if( SelectItem == RECTCLIP && !RectClipFlag){
         SetMoveRect();
         SetPickRect();
         SetValidRect();
         SetClickRect();
         if(( abs( ptEnd.x - ptStart.x) >= ZoomRate*2) &&
            ( abs( ptEnd.y - ptStart.y) >= ZoomRate*2) ){
            CRTDrawDC.BitBlt( ClipRect[BMP].left,
               ClipRect[BMP].top,
               ClipRect[BMP].Width(),
               ClipRect[BMP].Height(),
               &ImageDC, ClipRect[BMP].left,
               ClipRect[BMP].top, SRCCOPY);

            EraseRectangle();
            RectClipFlag = TRUE;
         }
         this->InvalidateRect( &ClipRect[VLD], FALSE);
         this->UpdateWindow();
      }else if( SelectItem == FREEFORM && !RectClipFlag){
         POINT nArray[FREELIAIS];
         POINT pArray[FREELIAIS];
   
         DrawFreeForm( FALSE);
         SelectFreeForm( FALSE);
         DrawFreeForm( TRUE);
         SelectFreeForm( TRUE);

         if( m_pointArray.GetSize()  >= FREELIAIS ||
             m_SelectArray.GetSize() >= FREELIAIS ){
               ToolTerm();
               this->Invalidate(FALSE);
            this->UpdateWindow();
            return;
         }
         for( int i = 0; i < m_pointArray.GetSize(); i++)
            nArray[i] = m_pointArray[i];
         for( i = 0; i < m_SelectArray.GetSize(); i++)
            pArray[i] = m_SelectArray[i];

         if( FreeRgn.GetSafeHandle() != NULL)
            FreeRgn.DeleteObject();
         if( PickRgn.GetSafeHandle() != NULL)
            PickRgn.DeleteObject();
         FreeRgn.CreatePolygonRgn( nArray,
            (int)(m_pointArray.GetSize()), ALTERNATE);
         PickRgn.CreatePolygonRgn( pArray,
            (int)(m_SelectArray.GetSize()), ALTERNATE);

         if( FreeRgn.GetSafeHandle()  == NULL ||
             PickRgn.GetSafeHandle()  == NULL){
            m_pointArray.RemoveAll();
            m_SelectArray.RemoveAll();
            RectClipFlag = FALSE;
         }else{
            RectClipFlag = TRUE;
            if( !SetFreeForm()){
               RectClipFlag = FALSE;
               FreeRgn.DeleteObject();
               PickRgn.DeleteObject();
               SetPickRect();
               SetValidRect();
               SetClickRect();
               ClipRect[PRV].CopyRect( &ClipRect[DSP]);
               this->InvalidateRect( &ClipRect[VLD], FALSE);
               this->UpdateWindow();
            }else{
               EraseFreeForm();
               SetPickRect();
               SetValidRect();
               SetClickRect();
               ClipRect[PRV].CopyRect( &ClipRect[DSP]);
               this->InvalidateRect( &ClipRect[VLD], FALSE);
               this->UpdateWindow();
            }
         }
      }else if( RectClipFlag){
         if( CheckNum != NCHECK){
            DrawStretchClipToDisp();
            CheckNum = NCHECK;
         }else{
            if( !MoveClipRect()){
               ToolTerm();
               return;
            }
         }
         SetValidRect();
         SetClickRect();

         this->InvalidateRect( &ClipRect[VLD], FALSE);
         this->UpdateWindow();
      }else{      
         if( SelectItem != SLOPE)
            IllegalRect( &ptStart, &ptEnd);
         else{
            ptEnd.x = ( ptEnd.x /ZoomRate) *ZoomRate;
            ptEnd.y = ( ptEnd.y /ZoomRate) *ZoomRate;
            ptStart.x = ( ptStart.x /ZoomRate) *ZoomRate;
            ptStart.y = ( ptStart.y /ZoomRate) *ZoomRate;
         }
         DrawRectBmp();
         if( SelectItem == SLOPE)
            IllegalRect( &ptStart, &ptEnd);
         SetMoveRect();
         if( FlagTmp)
            this->Invalidate( FALSE);
         else if( SelectItem != PEN && SelectItem != BRUSH && SelectItem != ERASER){
            this->InvalidateRect( &ClipRect[DSP], FALSE);
         }
      }
      ToolTerm();
   }
}

/****************************************/
/*             */
/* MESSAGE  "WM_RBUTTONDOWN"  */
/*             */
/****************************************/
void
CEditWnd::OnRButtonDown(
UINT  nFlags,
CPoint   point)
{
   CRect CaptionRect;

   if( ButtonFlag == LCLICK){
      this->Invalidate();
      ToolTerm();
      return;
   }
   if( SelectItem == RECTCLIP || SelectItem == FREEFORM){
      ToolTerm();
      return;
   }
   CaptionRect.CopyRect( &EudcWndRect);
   CaptionRect.top = CAPTION_HEIGHT;
   if( !CaptionRect.PtInRect( point))
      return;
   ToolInit(RCLICK);

// Modurate coordinate
   CorrectMouseDownPoint( point);
   UndoImageDraw();
   BitmapDirty = TRUE;
   if( SelectItem == PEN || SelectItem == BRUSH )
      DrawPoint( ptStart, FALSE);
   else if (SelectItem == ERASER)
      DrawPoint( ptStart, TRUE);
   else
      DrawRubberBand( TRUE);  
}

/****************************************/
/*             */
/* MESSAGE  "WM_RBUTTONUP"    */
/*             */
/****************************************/
void
CEditWnd::OnRButtonUp(
UINT  nFlags,
CPoint   point)
{
   if( IsCapture){
      if( SelectItem == PEN || SelectItem == BRUSH || SelectItem == ERASER ||
          SelectItem == RECTCLIP || SelectItem == FREEFORM){
         if( FlagTmp)
            this->Invalidate( FALSE);
         ToolTerm();
         return;
      }
//    Modurate coordinate
      CorrectMouseUpPoint( point);
      DrawRubberBand( TRUE);
      if( SelectItem != SLOPE)
         IllegalRect( &ptStart, &ptEnd);
      else{
         ptEnd.x = ( ptEnd.x /ZoomRate) *ZoomRate;
         ptEnd.y = ( ptEnd.y /ZoomRate) *ZoomRate;
         ptStart.x = ( ptStart.x /ZoomRate) *ZoomRate;
         ptStart.y = ( ptStart.y /ZoomRate) *ZoomRate;
      }

//    Draw a figure on bitmap
      DrawRectBmp();
      if( SelectItem == SLOPE)
         IllegalRect( &ptStart, &ptEnd);
      SetMoveRect();
      if( FlagTmp)
         this->Invalidate( FALSE);
      else  this->InvalidateRect( &ClipRect[DSP], FALSE);
      ToolTerm();
   }
}

/****************************************/
/*             */
/* MESSAGE     "WM_SIZE"   */
/*             */
/****************************************/
void
CEditWnd::OnSize(
UINT  nType,
int   cx,
int   cy)
{
   int   NewZoomRate;

   NewZoomRate = cx / BITMAP_WIDTH;
   if( RectClipFlag && NewZoomRate > 1){
      ClipRect[PRV].left = ( ClipRect[PRV].left /ZoomRate)
         * NewZoomRate;

      ClipRect[PRV].top  = ((( ClipRect[PRV].top - CAPTION_HEIGHT)
         /ZoomRate) * NewZoomRate) + CAPTION_HEIGHT;

      ClipRect[PRV].right = ( ClipRect[PRV].right /ZoomRate)
         * NewZoomRate + 1;

      ClipRect[PRV].bottom = ((( ClipRect[PRV].bottom -CAPTION_HEIGHT)
         / ZoomRate) * NewZoomRate) + CAPTION_HEIGHT + 1;

      ClipRect[DSP].left = ( ClipRect[DSP].left /ZoomRate)
         * NewZoomRate;

      ClipRect[DSP].top = ((( ClipRect[DSP].top - CAPTION_HEIGHT)
         / ZoomRate) * NewZoomRate) + CAPTION_HEIGHT;

      ClipRect[DSP].right = ( ClipRect[DSP].right /ZoomRate)
         * NewZoomRate + 1;

      ClipRect[DSP].bottom = ((( ClipRect[DSP].bottom -CAPTION_HEIGHT)
         / ZoomRate) * NewZoomRate) + CAPTION_HEIGHT + 1;

      SetClickRect();
      SetValidRect();
   }else if( RectClipFlag && NewZoomRate <= 1)
      WriteSelRectBitmap();

   CMDIChildWnd::OnSize(nType, cx, cy);

   this->Invalidate(FALSE);
   this->UpdateWindow();
}

/****************************************/
/*             */
/* MESSAGE     "WM_SETCURSOR"  */
/*             */
/****************************************/
BOOL
CEditWnd::OnSetCursor(
CWnd*    pWnd,
UINT  nHitTest,
UINT  message)
{
   CPoint   point;
   CRect CaptionRect;
   CRect EditRect;
   HCURSOR  hArrowCur;

   GetCursorPos( &point);
   this->ScreenToClient( &point);
   this->GetClientRect( &CaptionRect);
   EditRect.CopyRect( &CaptionRect);
   CaptionRect.bottom = CAPTION_HEIGHT;
   EditRect.top = CAPTION_HEIGHT;

   if(CaptionRect.PtInRect( point)){
      hArrowCur = AfxGetApp()->LoadStandardCursor( IDC_ARROW);
      ::SetCursor( hArrowCur);
   }else if( RectClipFlag && !IsCapture && EditRect.PtInRect( point)){
      if( PickRect[LUPPER].PtInRect( point) ||
          PickRect[RLOWER].PtInRect( point)){
         ::SetCursor((HCURSOR)ArrowCursor[LEFTSLOPE]);
      }else if( PickRect[RUPPER].PtInRect( point) ||
           PickRect[LLOWER].PtInRect( point)){
         ::SetCursor((HCURSOR)ArrowCursor[RIGHTSLOPE]);
      }else if( PickRect[MUPPER].PtInRect( point) ||
           PickRect[MLOWER].PtInRect( point)){
         ::SetCursor((HCURSOR)ArrowCursor[HORIZONTAL]);
      }else if( PickRect[RMIDLE].PtInRect( point) ||
           PickRect[LMIDLE].PtInRect( point)){
         ::SetCursor((HCURSOR)ArrowCursor[VERTICAL]);
      }else if( ClipRect[DSP].PtInRect( point)){
         ::SetCursor((HCURSOR)ArrowCursor[ALLDIRECT]);
      }else ::SetCursor((HCURSOR)ToolCursor[SelectItem]);
   }else if( !IsCapture && EditRect.PtInRect( point))
      ::SetCursor((HCURSOR)ToolCursor[SelectItem]);
   else{
      hArrowCur = AfxGetApp()->LoadStandardCursor( IDC_ARROW);
      ::SetCursor( hArrowCur);
   }  
   return TRUE;
}

/****************************************/
/*             */
/* MESSAGE     "WM_MDIACTIVATE"*/
/*             */
/****************************************/
void
CEditWnd::OnMDIActivate(
BOOL  bActivate,
CWnd*    pActivateWnd,
CWnd*    pDeactivateWnd)
{
   if( bActivate == FALSE){
      if( SelectItem == RECTCLIP || SelectItem == FREEFORM)
         WriteSelRectBitmap();
   }
}

/****************************************/
/*             */
/* MESSAGE     "WM_KEYDOWN"   */
/*             */
/****************************************/
void
CEditWnd::OnKeyDown(
UINT  nChar,
UINT  nRepCnt,
UINT  nFlags)
{
   if( nChar == VK_ESCAPE)
      WriteSelRectBitmap();
   else  CMDIChildWnd::OnKeyDown(nChar, nRepCnt, nFlags);
}

/****************************************/
/*             */
/* Draw Caption         */
/*             */
/****************************************/
void
CEditWnd::CaptionDraw()
{
COLORREF TextColor;
   CString  WndCaption;
   CRect CaptionRect;
   CBrush   CaptionBrush;
   CFont *OldFont;
   int   BkMode;
   CDC    dc;
   dc.Attach( ::GetDC( this->GetSafeHwnd()));

// Get brush with active caption color    
   CaptionRect.CopyRect( &EudcWndRect);
   if (bFocus)
   {
      CaptionBrush.CreateSolidBrush(::GetSysColor(COLOR_ACTIVECAPTION));
   }
   else
   {
      CaptionBrush.CreateSolidBrush(::GetSysColor(COLOR_INACTIVECAPTION));
   }
   CaptionRect.bottom = CAPTION_HEIGHT;
   dc.FillRect( &CaptionRect, &CaptionBrush);
   CaptionBrush.DeleteObject();

// Get font to draw caption
#ifdef BUILD_ON_WINNT
   OldFont = (CFont *)dc.SelectStockObject(DEFAULT_GUI_FONT);
#else
   OldFont = (CFont *)dc.SelectStockObject(SYSTEM_FONT);
#endif
   BkMode = dc.SetBkMode( TRANSPARENT);
   if (bFocus)
   {
      TextColor = dc.SetTextColor( ::GetSysColor(COLOR_CAPTIONTEXT));
   }
   else
   {
      TextColor = dc.SetTextColor( ::GetSysColor(COLOR_INACTIVECAPTIONTEXT));
   }
   WndCaption.LoadString( IDS_EDIT_STR);
   dc.TextOut( EudcWndRect.right /2 - 30, 1, WndCaption);
   dc.SelectObject( OldFont);
   dc.SetTextColor( TextColor);
   dc.SetBkMode( BkMode);
    ::ReleaseDC(NULL, dc.Detach());
}
               
/****************************************/
/*             */
/* Draw Grid line       */
/*             */
/****************************************/
void
CEditWnd::DrawGridLine(
CDC   *dc)
{
   CPen  GlyphPen;
register int   i;

   if (!dc)
   {
      return;
   }
// Create pen to draw grid
   GlyphPen.CreatePen( PS_SOLID, 1, COLOR_GRID);
   CPen *OldPen = dc->SelectObject( &GlyphPen);

// Draw grid
   for( i = ZoomRate - 1; i < EudcWndRect.right; i += ZoomRate){
      dc->MoveTo( i, CAPTION_HEIGHT-1);
      dc->LineTo( i, EudcWndRect.bottom);
   }
   for( i =ZoomRate +CAPTION_HEIGHT -1;i<EudcWndRect.bottom;i += ZoomRate){
      dc->MoveTo( 0, i);
      dc->LineTo( EudcWndRect.right, i);
   }
   dc->SelectObject( OldPen);
   GlyphPen.DeleteObject();
}

/****************************************/
/*             */
/* Draw OutLine         */
/*             */
/****************************************/
BOOL
CEditWnd::CurveFittingDraw(
CDC*  dc)
{
struct VHEAD   *vhd;
struct VDATA   *vp;
   CPen  CurvePen;
   CPoint   DrawPt;
   LPBYTE   pBuf;
   int   pcnt, TmpHdl, SetHdl;

   if (!dc)
   {
      return FALSE;
   }
   SetHdl = MKOUTHDL;

   DWORD wSize = (WORD)((( BITMAP_WIDTH +15)/16)*2)*(WORD)BITMAP_HEIGHT;
   pBuf = (LPBYTE)malloc(((( BITMAP_WIDTH +15) /16) *2) *BITMAP_HEIGHT);
   if( pBuf == NULL){
      return FALSE;
   }
   ImageBmp.GetBitmapBits( wSize, (LPVOID)pBuf);

   OInit();
   VDNew( SetHdl);
   if(( TmpHdl = OMakeOutline((LPBYTE)pBuf,
        BITMAP_WIDTH,SMOOTHLVL)) < 0){
      free( pBuf);
      OTerm();
      return FALSE;
   }
   if( MkPoly( TmpHdl, SetHdl) < 0){
      free( pBuf);
      OTerm();
      return FALSE;
   }

   VDGetHead( SetHdl, &vhd);
   if( VDGetNCont( SetHdl) > 0){
      CurvePen.CreatePen( PS_SOLID, 1, COLOR_CURVE);
      CPen *OldPen = dc->SelectObject( &CurvePen);
      CBrush *OldBrush = (CBrush *)dc->SelectStockObject( NULL_BRUSH);

      while ( vhd->next != NIL){
         vp = vhd->headp;
         pcnt = vhd->nPoints - 1;
         ZoomPoint( &DrawPt, vp->vd.x, vp->vd.y);
         dc->MoveTo( DrawPt.x, DrawPt.y);
         vp = vp->next;
         while( pcnt-- > 0){
            ZoomPoint( &DrawPt, vp->vd.x, vp->vd.y);
            dc->LineTo( DrawPt.x, DrawPt.y);
            vp = vp->next;
         }
         vhd = vhd->next;
      }
      dc->SelectObject( OldBrush);
      dc->SelectObject( OldPen);
      CurvePen.DeleteObject();
   }
   OTerm();
   free( pBuf);

   return TRUE;
}

/****************************************/
/*             */
/* Zoom coordinate of outline */
/*             */
/****************************************/
void
CEditWnd::ZoomPoint(
CPoint   *DrawPt,
int   x,
int   y)
{
   DWORD px, py;

    if (!DrawPt)
   {
      return;
   }
   px = (DWORD)(x * EudcWndRect.right);
   py = (DWORD)(y * (EudcWndRect.bottom - CAPTION_HEIGHT));
   DrawPt->x = (int)( px/(BITMAP_WIDTH *4));
   DrawPt->y = (int)( py/(BITMAP_HEIGHT*4)) + CAPTION_HEIGHT;
}

/****************************************/
/*             */
/* Draw MoveRect rectangle    */
/*             */
/****************************************/
void
CEditWnd::DrawMoveRect(
CDC   *dc)
{
   CPen  *OldPen;
   CBrush   *OldBrush;

   if (!dc)
   {
      return;
   }
   OldPen = (CPen *)dc->SelectStockObject( BLACK_PEN);
   OldBrush = (CBrush *)dc->SelectStockObject( NULL_BRUSH);
   int OldMode = dc->SetROP2( R2_NOTXORPEN);

   dc->Rectangle( &ClipRect[DSP]);

   dc->SelectObject( OldPen);
   dc->SelectObject( OldBrush);
   dc->SetROP2( OldMode);
}

/****************************************/
/*             */
/* Draw clipping rectangle    */
/*             */
/****************************************/
void
CEditWnd::DrawStretchRect(
CDC   *dc)
{
   CPen  *OldPen;
   CBrush   *OldBrush;
   int   Left, Top;
   int   Right, Bottom;

   if (!dc)
   {
      return;
   }
   OldPen = (CPen *)dc->SelectStockObject( BLACK_PEN);
   OldBrush = (CBrush *)dc->SelectStockObject( BLACK_BRUSH);

   for( int i = 0; i < 8; i++){
//    Set left and right side of PickRect[]
      if( i == LUPPER || i == LLOWER || i == LMIDLE){
         Left  = ClipRect[DSP].left - Ratio;
         Right = ClipRect[DSP].left + Ratio;
      }else if( i == RUPPER || i == RLOWER || i == RMIDLE){
         Left  = ClipRect[DSP].right - Ratio;
         Right = ClipRect[DSP].right + Ratio;
      }else{
         Left  = ClipRect[DSP].left + ClipRect[DSP].Width()/2
            - Ratio;
         Right = ClipRect[DSP].left + ClipRect[DSP].Width()/2
            + Ratio;
      }

//    Set top and bottom side of PickRect[]
      if( i == LUPPER || i == RUPPER || i == MUPPER){
         Top    = ClipRect[DSP].top - Ratio;
         Bottom = ClipRect[DSP].top + Ratio;
      }else if( i == RMIDLE || i == LMIDLE){
         Top    = ClipRect[DSP].top + ClipRect[DSP].Height()/2
            - Ratio;
         Bottom = ClipRect[DSP].top + ClipRect[DSP].Height()/2
            + Ratio;
      }else{
         Top    = ClipRect[DSP].bottom - Ratio;
         Bottom = ClipRect[DSP].bottom + Ratio;
      }
      PickRect[i].SetRect( Left, Top, Right, Bottom);
      dc->InvertRect( &PickRect[i]);
   }
   dc->SelectObject( OldPen);
   dc->SelectObject( OldBrush);
}

/****************************************/
/*             */
/* Write Selected Rectangle   */
/*             */ 
/****************************************/
void           
CEditWnd::WriteSelRectBitmap()
{
   if( RectClipFlag){
      RectClipFlag = FALSE;
      DrawClipBmp();
      ToolTerm();
   }
}

/****************************************/
/*             */
/* Modurate coordinate     */
/*             */
/****************************************/
void
CEditWnd::CorrectMouseDownPoint(
CPoint   point)
{
   ptStart.x = point.x;
   ptStart.y = point.y - CAPTION_HEIGHT;
   if( ptStart.y < 0)
      ptStart.y = 0;

   if( SelectItem == FREEFORM){
      ptStart.x = (( ptStart.x + ZoomRate/2) /ZoomRate) *ZoomRate;
      ptStart.y = (( ptStart.y + ZoomRate/2) /ZoomRate) *ZoomRate;
   }else if( SelectItem != SLOPE){
      ptStart.x = ( ptStart.x /ZoomRate) *ZoomRate;
      ptStart.y = ( ptStart.y /ZoomRate) *ZoomRate;
   }else{
      ptStart.x = ( ptStart.x /ZoomRate) *ZoomRate +ZoomRate /2;
      ptStart.y = ( ptStart.y /ZoomRate) *ZoomRate +ZoomRate /2;
   }
   if( SelectItem == RECTBAND || SelectItem == RECTFILL   ||
       SelectItem == CIRCLE   || SelectItem == CIRCLEFILL ){
      if( ptStart.x > EudcWndRect.right - ZoomRate)
         ptStart.x -= ZoomRate;
      if( ptStart.y > EudcWndRect.bottom - CAPTION_HEIGHT - ZoomRate)
         ptStart.y -= ZoomRate;
      ptEnd.x = ptPrev.x = ptStart.x + ZoomRate;
      ptEnd.y = ptPrev.y = ptStart.y + ZoomRate;
   }else ptEnd = ptPrev = ptStart;
}

/****************************************/
/*             */
/* Modurate coordinate     */
/*             */
/****************************************/
void
CEditWnd::CorrectMouseUpPoint(
CPoint   point)
{
   ptPrev = ptEnd;
   ptEnd.x = point.x;
   ptEnd.y = point.y - CAPTION_HEIGHT;

   if( ptEnd.x < 0)  ptEnd.x = 0;
   if( ptEnd.y < 0)  ptEnd.y = 0;
   if( ptEnd.x > EudcWndRect.right){
      if( SelectItem == BRUSH)
         ptEnd.x = EudcWndRect.right - ZoomRate*2;
      else if( SelectItem == FREEFORM)
         ptEnd.x = EudcWndRect.right;
      else
         ptEnd.x = EudcWndRect.right - ZoomRate;
   }
   if( ptEnd.y > EudcWndRect.bottom - CAPTION_HEIGHT){
      if( SelectItem == BRUSH)
         ptEnd.y = EudcWndRect.bottom - CAPTION_HEIGHT
            - ZoomRate*2;
      else if( SelectItem == FREEFORM)
         ptEnd.y = EudcWndRect.bottom - CAPTION_HEIGHT;
      else
         ptEnd.y = EudcWndRect.bottom - CAPTION_HEIGHT
            - ZoomRate;
   }
   if( SelectItem == FREEFORM){
      ptEnd.x = (( ptEnd.x + ZoomRate/2) /ZoomRate) *ZoomRate ;
      ptEnd.y = (( ptEnd.y + ZoomRate/2) /ZoomRate) *ZoomRate ;
   }else if( SelectItem != SLOPE){
      ptEnd.x = ( ptEnd.x /ZoomRate)*ZoomRate;
      ptEnd.y = ( ptEnd.y /ZoomRate)*ZoomRate;
   }else{
      ptEnd.x = ( ptEnd.x /ZoomRate) *ZoomRate + ZoomRate /2;
      ptEnd.y = ( ptEnd.y /ZoomRate) *ZoomRate + ZoomRate /2;
   }
   if( SelectItem == RECTBAND || SelectItem == RECTFILL   ||
       SelectItem == CIRCLE   || SelectItem == CIRCLEFILL ){
      if( ptEnd.x - ptStart.x <= ZoomRate &&
         ptEnd.x - ptStart.x >= 0)
         ptEnd.x = ptStart.x + ZoomRate;
      if( ptStart.x - ptEnd.x <= ZoomRate &&
         ptStart.x - ptEnd.x > 0)
         ptEnd.x = ptStart.x - ZoomRate;
      if( ptStart.y - ptEnd.y <= ZoomRate &&
         ptStart.y - ptEnd.y > 0)
         ptEnd.y = ptStart.y - ZoomRate;
      if( ptEnd.y - ptStart.y <= ZoomRate &&
         ptEnd.y -ptStart.y >= 0)
         ptEnd.y = ptStart.y + ZoomRate;
   }
}

/****************************************/
/*             */
/* Move Selected Rectangle    */
/*             */
/****************************************/
BOOL
CEditWnd::MoveClipRect()
{
   int   Movex, Movey;
   int   Wid, High;
   BOOL  sts;

   sts = TRUE;
   ClipRect[PRV].CopyRect( &ClipRect[DSP]);

// Boundary condition
   Movex = ptEnd.x - ptPrev.x;
   Movey = ptEnd.y - ptPrev.y;
   Wid  = ClipRect[DSP].Width();
   High = ClipRect[DSP].Height();
   ClipRect[DSP].OffsetRect( Movex, Movey);

   if( ClipRect[DSP].left < 0){
      ClipRect[DSP].left = 0;
      ClipRect[DSP].right = Wid;
   }
   if( ClipRect[DSP].right > EudcWndRect.right){
      ClipRect[DSP].right = EudcWndRect.right + 1;
      ClipRect[DSP].left  = ClipRect[DSP].right - Wid;
   }
   if( ClipRect[DSP].top < CAPTION_HEIGHT){
      ClipRect[DSP].top = CAPTION_HEIGHT;
      ClipRect[DSP].bottom = CAPTION_HEIGHT +High;
   }
   if( ClipRect[DSP].bottom > EudcWndRect.bottom){
      ClipRect[DSP].bottom = EudcWndRect.bottom +1;
      ClipRect[DSP].top = ClipRect[DSP].bottom - High;
   }
   if( ClipRect[PRV].EqualRect( &ClipRect[DSP])){
      sts = FALSE;
   }
   return sts;
}

/************************************************/
/*                */
/* whether point is in rectangle or not   */
/*                */
/************************************************/
int
CEditWnd::CheckClipRect(
POINT    ClipPoint)
{
   for( int i = 0; i < 8; i++){
      if( PickRect[i].PtInRect( ClipPoint))
         return i;
   }
   return NCHECK;
}

/****************************************/
/*             */
/* Process to stretch rectangle  */
/*             */
/****************************************/
BOOL
CEditWnd::DrawStretchClipToDisp()
{
   CDC   SwapDC;
   CBitmap  SwapBmp;
   CRect SwapRect;
            
   CClientDC   dc( this);

   if( !SwapDC.CreateCompatibleDC( &dc))
      return FALSE;

   if( !SwapBmp.CreateCompatibleBitmap( &SwapDC, EudcWndRect.Width(),
            EudcWndRect.Height()))
      return FALSE;
   CBitmap *OldBitmap = SwapDC.SelectObject( &SwapBmp);

   SwapRect.CopyRect( &ClipRect[DSP]);
   if( EudcWndRect.right < SwapRect.right)
      SwapRect.right -= 1;
   if( EudcWndRect.bottom < SwapRect.bottom)
      SwapRect.bottom -= 1;
   
   SwapDC.StretchBlt( SwapRect.left, SwapRect.top,
         SwapRect.Width(), SwapRect.Height(),
         &CRTDrawDC, ClipRect[BMP].left, ClipRect[BMP].top,
         ClipRect[BMP].Width(), ClipRect[BMP].Height(),
         SRCCOPY);

   SetPickRect();
   CRTDrawDC.StretchBlt( ClipRect[BMP].left, ClipRect[BMP].top,
      ClipRect[BMP].Width(), ClipRect[BMP].Height(),
      &SwapDC, SwapRect.left, SwapRect.top,
      SwapRect.Width(), SwapRect.Height(), SRCCOPY);

   SwapDC.SelectObject( OldBitmap);
   SwapBmp.DeleteObject();
   SwapDC.DeleteDC();

   return TRUE;
}

/****************************************/
/*             */
/* Draw select rectangle to bitmap  */
/*             */
/****************************************/
void
CEditWnd::DrawClipBmp()
{
   CRect pRect;

   pRect.SetRect(( ClipRect[DSP].left + 1) /ZoomRate,
       ( ClipRect[DSP].top - CAPTION_HEIGHT + 1) /ZoomRate,
       ( ClipRect[DSP].right + 1)/ZoomRate,
       ( ClipRect[DSP].bottom - CAPTION_HEIGHT + 1) /ZoomRate);

   ImageDC.StretchBlt( pRect.left, pRect.top,
         pRect.Width(), pRect.Height(), &CRTDrawDC,
         ClipRect[BMP].left, ClipRect[BMP].top,
      ClipRect[BMP].Width(), ClipRect[BMP].Height(), SRCAND);
   SetValidRect();
   this->InvalidateRect( &ClipRect[VLD], FALSE);
   this->UpdateWindow();
}

/****************************************/
/*             */
/* Set size of clipping rectangle   */
/*             */
/****************************************/
void
CEditWnd::SetPickRect()
{
   ClipRect[BMP].SetRect( ClipRect[DSP].left /ZoomRate,
      ( ClipRect[DSP].top - CAPTION_HEIGHT) /ZoomRate,
        ClipRect[DSP].right /ZoomRate,
      ( ClipRect[DSP].bottom - CAPTION_HEIGHT) /ZoomRate);
}

/****************************************/
/*             */
/* Set size of clipping rectangle   */
/*             */
/****************************************/
void
CEditWnd::SetMoveRect()
{
   IllegalRect( &ptStart, &ptEnd);

   ClipRect[DSP].SetRect( ptStart.x, ptStart.y + CAPTION_HEIGHT,
      ptEnd.x + ZoomRate + 1,
      ptEnd.y + ZoomRate + 1 + CAPTION_HEIGHT);
   ClipRect[PRV].CopyRect( &ClipRect[DSP]);
}

/****************************************/
/*             */
/* Set size of clipping rectangle   */
/*             */
/****************************************/
void
CEditWnd::SetValidRect()
{
   ClipRect[VLD].SetRect( ClipRect[DSP].left - Ratio,
      ClipRect[DSP].top - Ratio,
      ClipRect[DSP].right + Ratio,
      ClipRect[DSP].bottom + Ratio);
}

/****************************************/
/*             */
/* Set size of clipping rectangle   */
/*             */
/****************************************/
void
CEditWnd::SetClickRect()
{
   ClipRect[PIN].SetRect( ClipRect[DSP].left + Ratio,
      ClipRect[DSP].top + Ratio,
      ClipRect[DSP].right - Ratio,
      ClipRect[DSP].bottom - Ratio);
}

/****************************************/
/*             */
/* Draw a figure to bitmap    */
/*             */
/****************************************/
void
CEditWnd::DrawRectBmp()
{
   CPen  *OldPen;
   CBrush   *OldBrush;
   CRect    BRect;
   CPoint   ptLT;
   CPoint   ptRB;

   ptLT.x = ptStart.x /ZoomRate;
   ptLT.y = ptStart.y /ZoomRate;
   ptRB.x = ptEnd.x   /ZoomRate;
   ptRB.y = ptEnd.y   /ZoomRate;
   
   if( ButtonFlag == LCLICK)
      OldPen = (CPen *)ImageDC.SelectStockObject( BLACK_PEN);
   else  OldPen = (CPen *)ImageDC.SelectStockObject( WHITE_PEN);

   if( SelectItem == RECTBAND || SelectItem == CIRCLE)
      OldBrush = (CBrush *)ImageDC.SelectStockObject( NULL_BRUSH);
   else if( ButtonFlag == LCLICK)
      OldBrush = (CBrush *)ImageDC.SelectStockObject( BLACK_BRUSH);
   else  OldBrush = (CBrush *)ImageDC.SelectStockObject( WHITE_BRUSH);

   BRect.SetRect( ptLT.x, ptLT.y, ptRB.x +1, ptRB.y +1);
   if( SelectItem == CIRCLE || SelectItem == CIRCLEFILL)
      ImageDC.Ellipse( &BRect);
   else if( SelectItem == RECTBAND || SelectItem == RECTFILL)
      ImageDC.Rectangle( &BRect);
   else{
      ImageDC.MoveTo( ptLT);
      ImageDC.LineTo( ptRB);
      if (SelectItem == ERASER)
         DrawPoint( ptEnd, TRUE);
      else
         DrawPoint( ptEnd, FALSE);
   }
   ImageDC.SelectObject( OldPen);
   ImageDC.SelectObject( OldBrush);
}

/****************************************/
/*             */
/* Draw 1Point       */
/*             */
/****************************************/
void
CEditWnd::DrawPoint( CPoint Pt, BOOL bErase)
{
   CBrush   PointBrush,*OldBrush1, *OldBrush2;
   CPoint   W;
   int   Wstep, i, j;
         
   CClientDC   dc( this);
   if( ButtonFlag == LCLICK && !bErase){
      if( FlagTmp)
         PointBrush.CreateSolidBrush( COLOR_FITTING);
      else  PointBrush.CreateSolidBrush( COLOR_BLACK);
   }else PointBrush.CreateSolidBrush( COLOR_WHITE);
   
   OldBrush1 = dc.SelectObject( &PointBrush);
   

   W = Pt;
   Wstep = ZoomRate;
   if( ZoomRate > 1 && GridShow)
      Wstep -= 1;
   for( i = 0; i < BrushWidth; i++, W.x += ZoomRate){
      W.y = Pt.y;
      for( j = 0; j < BrushWidth; j++ , W.y += ZoomRate)
         dc.PatBlt( W.x, W.y+CAPTION_HEIGHT,Wstep,Wstep,PATCOPY);
   }
   dc.SelectObject( OldBrush1);
   PointBrush.DeleteObject();
   
   if( ButtonFlag == LCLICK && !bErase)
      OldBrush2 = (CBrush *)ImageDC.SelectStockObject(BLACK_BRUSH);
   else  OldBrush2 = (CBrush *)ImageDC.SelectStockObject(WHITE_BRUSH);

   W.x = Pt.x /ZoomRate;
   W.y = Pt.y /ZoomRate;
   if( W.x < BITMAP_WIDTH && W.y < BITMAP_HEIGHT)
      ImageDC.PatBlt( W.x, W.y, BrushWidth, BrushWidth, PATCOPY);
   ImageDC.SelectObject( OldBrush2);
   
}

/****************************************/
/*             */
/* Degital differencial analyzer */
/*             */
/****************************************/
void
CEditWnd::DrawToPoint(BOOL bErase)
{
   CPoint   Pt, Start, End, Inc;
   int   Xf, Yf;
   int   Inc1, Inc2;
   int   Dx, Dy,  D, Tmp;
   BOOL  Slope;

   End.x = Xf = ptEnd.x /ZoomRate;
   End.y = Yf = ptEnd.y /ZoomRate;
   Start.x = ptPrev.x   /ZoomRate;
   Start.y = ptPrev.y   /ZoomRate;

   if( Xf >= Start.x)
      Inc.x = 1;
   else  Inc.x = -1;
   if( Yf >= Start.y)
      Inc.y = 1;
   else  Inc.y = -1;

   Dx = ( Xf - Start.x)*Inc.x;
   Dy = ( Yf - Start.y)*Inc.y;
   if( !Dx && !Dy)   return;
   if( Dx < Dy){
      Tmp = Dy;
      Dy = Dx;
      Dx = Tmp;
      Tmp = Inc.x;
      Inc.x = Inc.y;
      Inc.y = Tmp;
      Slope = TRUE;
   }else   Slope = FALSE;

   Inc1 = Dy*2;
   Inc2 = (Dy - Dx)*2;
   D = Inc1 - Dx;
   End.x = Start.x;
   End.y = Start.y;  
   while(1){
      Pt.x = End.x *ZoomRate;
      Pt.y = End.y *ZoomRate;
      DrawPoint( Pt, bErase);
      if( End.x == Xf && End.y == Yf)
         break;
      if( Slope){
         Tmp = End.x;
         End.x = End.y;
         End.y = Tmp;
      }
      End.x += Inc.x;
      if( D < 0)  D += Inc1;
      else{
         End.y += Inc.y;
         D += Inc2;
      }
      if( Slope){
         Tmp = End.x;
         End.x = End.y;
         End.y = Tmp;
      }
   }
}

/****************************************/
/*             */
/* Initialize tool width and color */
/*             */
/****************************************/
void
CEditWnd::ToolInit(
int   LRButton)
{
   this->SetCapture();
   ButtonFlag = LRButton;
   IsCapture = TRUE;
   if( SelectItem == PEN || SelectItem == SLOPE)
      BrushWidth = 1;
   else if( SelectItem == BRUSH || SelectItem == ERASER)
      BrushWidth = 2;
}

/****************************************/
/*             */ 
/* Rubberband stretch mode    */
/*             */
/****************************************/
void
CEditWnd::StretchMoveRect()
{
   CPen  *OldPen;
   CBrush   *OldBrush;
   int   Left, Top, Right, Bottom;

   CClientDC   dc( this);

   OldPen   = (CPen *)dc.SelectStockObject( BLACK_PEN);
   OldBrush = (CBrush *)dc.SelectStockObject( NULL_BRUSH);
   int OldMode = dc.SetROP2( R2_NOTXORPEN);
   dc.Rectangle( &ClipRect[PRV]);

   Left   = ClipRect[DSP].left;
   Top    = ClipRect[DSP].top;
   Right  = ClipRect[DSP].right;
   Bottom = ClipRect[DSP].bottom;
   switch( CheckNum){
      case RLOWER:
         ClipRect[DSP].SetRect( Left, Top,
            ptEnd.x + ZoomRate + 1,
            ptEnd.y + CAPTION_HEIGHT + ZoomRate + 1);

         if( ClipRect[DSP].Height() < ZoomRate*2)
            ClipRect[DSP].bottom = ClipRect[DSP].top
               + ZoomRate*2+1;

         if( ClipRect[DSP].Width() < ZoomRate*2)
            ClipRect[DSP].right = ClipRect[DSP].left
               + ZoomRate*2+1;
         break;
      case RMIDLE:
         ClipRect[DSP].SetRect( Left, Top,
               ptEnd.x + ZoomRate + 1, Bottom);

         if( ClipRect[DSP].Width() < ZoomRate*2)
            ClipRect[DSP].right = ClipRect[DSP].left
               + ZoomRate*2+1;
         break;
      case MLOWER:
         ClipRect[DSP].SetRect( Left, Top,
            Right, ptEnd.y + CAPTION_HEIGHT + ZoomRate + 1);

         if( ClipRect[DSP].Height() < ZoomRate*2)
            ClipRect[DSP].bottom = ClipRect[DSP].top
               + ZoomRate*2+1;
         break;
      case RUPPER:
         ClipRect[DSP].SetRect( Left, ptEnd.y + CAPTION_HEIGHT,
               ptEnd.x + ZoomRate + 1, Bottom);

         if( ClipRect[DSP].Height() < ZoomRate*2)
            ClipRect[DSP].top = ClipRect[DSP].bottom
               - ZoomRate*2+1;
         if( ClipRect[DSP].Width() < ZoomRate*2)
            ClipRect[DSP].right = ClipRect[DSP].left
               + ZoomRate*2+1;
         break;
      case LLOWER:
         ClipRect[DSP].SetRect( ptEnd.x, Top,
            Right, ptEnd.y + CAPTION_HEIGHT + ZoomRate + 1);

         if( ClipRect[DSP].Width() < ZoomRate*2)
            ClipRect[DSP].left = ClipRect[DSP].right
               - ZoomRate*2+1;
         if( ClipRect[DSP].Height() < ZoomRate*2)
            ClipRect[DSP].bottom = ClipRect[DSP].top
               + ZoomRate*2+1;
         break;
      case LMIDLE:
         ClipRect[DSP].SetRect( ptEnd.x, Top, Right, Bottom);

         if( ClipRect[DSP].Width() < ZoomRate*2)
            ClipRect[DSP].left = ClipRect[DSP].right
               - ZoomRate*2+1;
         break;
      case MUPPER:
         ClipRect[DSP].SetRect( Left, ptEnd.y + CAPTION_HEIGHT,
                  Right, Bottom);

         if( ClipRect[DSP].Height() < ZoomRate*2)
            ClipRect[DSP].top = ClipRect[DSP].bottom
               - ZoomRate*2+1;
         break;
      case LUPPER:
         ClipRect[DSP].SetRect( ptEnd.x,
            ptEnd.y + CAPTION_HEIGHT, Right, Bottom);

         if( ClipRect[DSP].Height() < ZoomRate*2)
            ClipRect[DSP].top = ClipRect[DSP].bottom
               - ZoomRate*2+1;
         if( ClipRect[DSP].Width() < ZoomRate*2)
            ClipRect[DSP].left = ClipRect[DSP].right
               - ZoomRate*2+1;
         break;
      default:
         break;
   }
   ClipRect[PRV].CopyRect( &ClipRect[DSP]);
   dc.Rectangle( &ClipRect[DSP]);
   dc.SelectObject( OldPen);
   dc.SelectObject( OldBrush);
   dc.SetROP2( OldMode);
}

/****************************************/
/*             */
/*       FreeForm       */
/*             */
/****************************************/
void
CEditWnd::SelectFreeForm(
BOOL  MouseSts)
{
   CPoint   Ep, Sp, Cp;
   CPoint   Fp, Inc;
   CPoint   Dp, Err;
   BOOL  Slope;
   int   D;
   int   Tmp;

   if( !MouseSts){
      Sp.x = ptPrev.x /ZoomRate;
      Sp.y = ptPrev.y /ZoomRate;
      Ep.x = Fp.x = ptEnd.x /ZoomRate;
      Ep.y = Fp.y = ptEnd.y /ZoomRate;
   }else{
      Sp.x = ptEnd.x /ZoomRate;
      Sp.y = ptEnd.y /ZoomRate;
      Ep.x = Fp.x = ptStart.x /ZoomRate;
      Ep.y = Fp.y = ptStart.y /ZoomRate;
   }

   if( Fp.x >= Sp.x)
      Inc.x = 1;
   else  Inc.x = -1;
   if( Fp.y >= Sp.y)
      Inc.y = 1;
   else  Inc.y = -1;

   Dp.x = ( Fp.x - Sp.x)*Inc.x;
   Dp.y = ( Fp.y - Sp.y)*Inc.y;
   if( !Dp.x && !Dp.y)  return;
   if( Dp.x < Dp.y){
      Tmp = Dp.y;
      Dp.y = Dp.x;
      Dp.x = Tmp;
      Tmp = Inc.x;
      Inc.x = Inc.y;
      Inc.y = Tmp;
      Slope = TRUE;
   }else   Slope = FALSE;

   Err.x = Dp.y * 2;
   Err.y = ( Dp.y - Dp.x) * 2;
   D = Err.x - Dp.x;
   Ep = Sp;
   while(1){
      m_SelectArray.Add( Ep);
      if( Ep.x == Fp.x && Ep.y == Fp.y)
         break;
      if( Slope){
         Tmp = Ep.x;
         Ep.x = Ep.y;
         Ep.y = Tmp;
      }
      Ep.x += Inc.x;
      if( D < 0)  D += Err.x;
      else{
         Ep.y += Inc.y;
         D += Err.y;
      }
      if( Slope){
         Tmp = Ep.x;
         Ep.x = Ep.y;
         Ep.y = Tmp;
      }
   }
}

/****************************************/
/*             */
/*       FreeForm       */
/*             */
/****************************************/
void
CEditWnd::DrawFreeForm(
BOOL  MouseSts)
{
   CPoint   Ep, Sp, Cp;
   CPoint   Fp, Inc;
   CPoint   Dp, Err;
   CPoint   P1, P2;
   BOOL  Slope;
   int   D;
   int   Tmp;

   CClientDC   dc( this);

   CPen  *OldPen = (CPen *)dc.SelectStockObject( BLACK_PEN);
   int OldMode = dc.SetROP2( R2_NOTXORPEN);

   if( !MouseSts){
      Sp.x = ptPrev.x;
      Sp.y = ptPrev.y + CAPTION_HEIGHT;
      Ep.x = Fp.x = ptEnd.x;
      Ep.y = Fp.y = ptEnd.y + CAPTION_HEIGHT;
   }else{
      Sp.x = ptEnd.x;
      Sp.y = ptEnd.y + CAPTION_HEIGHT;
      Ep.x = Fp.x = ptStart.x;
      Ep.y = Fp.y = ptStart.y + CAPTION_HEIGHT;
   }
   if( Fp.x >= Sp.x)
      Inc.x = ZoomRate;
   else  Inc.x = 0 - ZoomRate;
   if( Fp.y >= Sp.y)
      Inc.y = ZoomRate;
   else  Inc.y = 0 - ZoomRate;

   Dp.x = ( Fp.x - Sp.x)*Inc.x;
   Dp.y = ( Fp.y - Sp.y)*Inc.y;
   if( !Dp.x && !Dp.y)  return;
   if( Dp.x < Dp.y){
      Tmp = Dp.y;
      Dp.y = Dp.x;
      Dp.x = Tmp;
      Tmp = Inc.x;
      Inc.x = Inc.y;
      Inc.y = Tmp;
      Slope = TRUE;
   }else   Slope = FALSE;

   Err.x = Dp.y * 2;
   Err.y = ( Dp.y - Dp.x) * 2;
   D = Err.x - Dp.x;
   Ep = Sp;
   dc.MoveTo( Sp);
   while(1){
      if( Sp.x != Ep.x && Sp.y != Ep.y){
         if( Sp.y < Ep.y && Sp.x > Ep.x){
            Cp.x = Sp.x;
            Cp.y = Ep.y;
         }else if( Sp.y < Ep.y && Sp.x < Ep.x){
            Cp.x = Sp.x;
            Cp.y = Ep.y;
         }else if( Sp.y > Ep.y && Sp.x > Ep.x){
            Cp.y = Sp.y;
            Cp.x = Ep.x;
         }else{
            Cp.y = Sp.y;
            Cp.x = Ep.x;
         }
         dc.LineTo( Cp);
         dc.LineTo( Ep);
         P1 = Cp;
         P2 = Ep;
         m_pointArray.Add( P1);
         m_pointArray.Add( P2);
      }else if( Sp.x != Ep.x || Sp.y != Ep.y){
         dc.LineTo( Ep);
         P1 = Ep;
         m_pointArray.Add( P1);
      }
      Sp.x = Ep.x;
      Sp.y = Ep.y;
      if( Ep.x == Fp.x && Ep.y == Fp.y)
         break;
      if( Slope){
         Tmp = Ep.x;
         Ep.x = Ep.y;
         Ep.y = Tmp;
      }
      Ep.x += Inc.x;
      if( D < 0)  D += Err.x;
      else{
         Ep.y += Inc.y;
         D += Err.y;
      }
      if( Slope){
         Tmp = Ep.x;
         Ep.x = Ep.y;
         Ep.y = Tmp;
      }
   }
   dc.SelectObject( OldPen);
   dc.SetROP2( OldMode);
}

/****************************************/
/*             */
/*   Rubber Band( rectangle and circle)   */
/*             */
/****************************************/
void
CEditWnd::DrawRubberBand(
BOOL  StretchFlag)
{
   CRect RubberBandRect;
   CPoint   ptLT, ptRB;
   int   OldMode;

   CClientDC   dc( this);

   CPen  *OldPen   = (CPen *)dc.SelectStockObject( BLACK_PEN);
   CBrush   *OldBrush = (CBrush *)dc.SelectStockObject( NULL_BRUSH);
   OldMode = dc.SetROP2( R2_NOTXORPEN);

   if( !StretchFlag){
      ptLT.x = ptStart.x;
      ptLT.y = ptStart.y + CAPTION_HEIGHT;
      ptRB.x = ptPrev.x;
      ptRB.y = ptPrev.y  + CAPTION_HEIGHT;
      if( SelectItem != SLOPE)
         IllegalRect( &ptLT, &ptRB);
      RubberBandRect.SetRect( ptLT.x, ptLT.y,
         ptRB.x + ZoomRate + 1, ptRB.y + ZoomRate + 1);
      if( SelectItem == SLOPE){
         dc.MoveTo( ptLT);
         dc.LineTo( ptRB);
      }else if( SelectItem == CIRCLE || SelectItem == CIRCLEFILL)
         dc.Ellipse( &RubberBandRect);
      else  dc.Rectangle( &RubberBandRect);
   }
   ptLT.x = ptStart.x;
   ptLT.y = ptStart.y + CAPTION_HEIGHT;
   ptRB.x = ptEnd.x;
   ptRB.y = ptEnd.y + CAPTION_HEIGHT;
   ptPrev = ptRB;
   if( SelectItem != SLOPE)
      IllegalRect( &ptLT, &ptRB);
      RubberBandRect.SetRect( ptLT.x, ptLT.y,
         ptRB.x + ZoomRate + 1, ptRB.y + ZoomRate + 1);
   if( SelectItem == SLOPE){
      dc.MoveTo( ptLT);
      dc.LineTo( ptRB);
   }else if( SelectItem == CIRCLE || SelectItem == CIRCLEFILL)
      dc.Ellipse( &RubberBandRect);
   else  dc.Rectangle( &RubberBandRect);
   
   dc.SelectObject( OldPen);
   dc.SelectObject( OldBrush);
   dc.SetROP2( OldMode);
}

/****************************************/
/*             */
/* Correct coordinate of rectangle  */
/*             */
/****************************************/
void
CEditWnd::IllegalRect(
PPOINT   ptTL,
PPOINT   ptBR)
{
   int   Tmp;

   if( ptTL->x > ptBR->x){
      Tmp = ptTL->x;
      ptTL->x = ptBR->x;
      ptBR->x = Tmp; 
   }
   if( ptTL->y > ptBR->y){
      Tmp = ptTL->y;
      ptTL->y = ptBR->y;
      ptBR->y = Tmp;
   }
}

/****************************************/
/*             */
/* Process to term tool    */
/*             */
/****************************************/
void
CEditWnd::ToolTerm()
{
   if( IsCapture){
      IsCapture = FALSE;
      ReleaseCapture();
   }
   ButtonFlag = NCLICK;
}


/****************************************/
/*             */
/* Set Freeform selection     */
/*             */
/****************************************/
BOOL
CEditWnd::SetFreeForm()
{
   CBrush   EraseBrush;
   CBrush   BlackBrush;

   PickRgn.GetRgnBox( &ClipRect[BMP]);
   if( ClipRect[BMP].Width() < 3 ||
       ClipRect[BMP].Height() < 3){
      FreeRgn.GetRgnBox( &ClipRect[DSP]);
      ClipRect[DSP].right += 1;
      ClipRect[DSP].bottom += 1;
         return FALSE;
   }
   EraseBrush.CreateStockObject( WHITE_BRUSH);
   BlackBrush.CreateStockObject( BLACK_BRUSH);
   CRTDrawDC.FillRect( &ClipRect[BMP], &EraseBrush);
   CRTDrawDC.FillRgn( &PickRgn, &BlackBrush);
   EraseBrush.DeleteObject();
   BlackBrush.DeleteObject();

      CRTDrawDC.BitBlt( ClipRect[BMP].left, ClipRect[BMP].top,
      ClipRect[BMP].Width(), ClipRect[BMP].Height(),
      &ImageDC, ClipRect[BMP].left, ClipRect[BMP].top, SRCPAINT);


   FreeRgn.GetRgnBox( &ClipRect[DSP]);
   ClipRect[DSP].right += 1;
   ClipRect[DSP].bottom += 1;

   return TRUE;
}

/****************************************/
/*             */
/* Erase Freeform selection area */
/*             */
/****************************************/
void
CEditWnd::EraseFreeForm()
{
   CBrush   CutBrush;
   CutBrush.CreateSolidBrush( COLOR_WHITE );
      ImageDC.FillRgn( &PickRgn, &CutBrush);
   CutBrush.DeleteObject();
}

/****************************************/
/*             */
/* Erase rectangle selection area   */
/*             */
/****************************************/
void
CEditWnd::EraseRectangle()
{
   CRect pRect;
   CPen  *OldPen;
   CBrush   CutBrush;

   OldPen = (CPen *)ImageDC.SelectStockObject( NULL_PEN);
   CutBrush.CreateSolidBrush( COLOR_WHITE );
      CBrush *OldBrush = ImageDC.SelectObject( &CutBrush);

   pRect.CopyRect( &ClipRect[BMP]);
   pRect.right  += 1;
   pRect.bottom += 1;
      ImageDC.Rectangle( &pRect);
      ImageDC.SelectObject( OldPen);
      ImageDC.SelectObject( OldBrush);
   CutBrush.DeleteObject();

   RectClipFlag = FALSE;
   SetValidRect();
   this->InvalidateRect( &ClipRect[VLD], FALSE);
   this->UpdateWindow();
   RectClipFlag = TRUE;
}

/****************************************/
/*             */
/* Save character with same code */
/*             */
/****************************************/
#define ABORT  1
#define CANCEL 0
int 
CEditWnd::SaveEUDCCode(UINT msgBoxType)
{
  CClientDC dc(this);
   CFont cFont, *OldFont;
   LOGFONT  LogFont;
   DWORD wSize;
   LPBYTE   pBuf=NULL;
   LPBYTE   pBuf2=NULL;
   TCHAR BMPPath[MAX_PATH];
   TCHAR TTFPath[MAX_PATH];
   TCHAR *FilePtr;
   int   FontType, sts=0;
//fix for FontIsLinked
  BOOL firstTime = false;
//
   HRESULT hresult;

   if( SelectItem == RECTCLIP || SelectItem == FREEFORM)
      WriteSelRectBitmap();

   //*STRSAFE*    lstrcpy(TTFPath, SelectEUDC.m_File);
   hresult = StringCchCopy(TTFPath , ARRAYLEN(TTFPath),  SelectEUDC.m_File);
   if (!SUCCEEDED(hresult))
   {
      goto RET3;
   }
   //*STRSAFE*    lstrcpy(BMPPath,TTFPath);
   hresult = StringCchCopy(BMPPath , ARRAYLEN(BMPPath), TTFPath);
   if (!SUCCEEDED(hresult))
   {
      goto RET3;
   }
   if(( FilePtr = Mytcsrchr( BMPPath, '.')) != NULL)
      *FilePtr = '\0';
   //*STRSAFE*    lstrcat( BMPPath, TEXT(".EUF"));
   hresult = StringCchCat(BMPPath , ARRAYLEN(BMPPath),  TEXT(".EUF"));
   if (!SUCCEEDED(hresult))
   {
      goto RET3;
   }

    
    DWORD dwStart = GetTickCount();

    // Stop if this has taken too long
    while (1)
    {
        if( GetTickCount() - dwStart >= 1000 )
            break;
    }

   if( !EnableEUDC( FALSE)){
      MessageBox(TEXT("EnableEUDC() Error"), TEXT("EudcEditor"), MB_OK);
    return ABORT;
   }

//fix for FontIsLinked
//create logFont first, then use this font to create new character
  OInit();
  if( !OExistTTF( TTFPath)){
    firstTime = TRUE;
     memset( &LogFont, 0, sizeof( LogFont));
    //*STRSAFE*     lstrcpy (LogFont.lfFaceName, CountryInfo.szForceFont);
    hresult = StringCchCopy(LogFont.lfFaceName , ARRAYLEN(LogFont.lfFaceName),  CountryInfo.szForceFont);
    if (!SUCCEEDED(hresult))
    {
       goto RET;
    }
     LogFont.lfHeight  = BITMAP_HEIGHT;
     LogFont.lfWidth   = BITMAP_WIDTH;
     LogFont.lfOutPrecision  = OUT_TT_ONLY_PRECIS;
     LogFont.lfCharSet = (BYTE)CountryInfo.CharacterSet;
     LogFont.lfPitchAndFamily = FF_ROMAN; //| FIXED_PITCH;
    if (CountryInfo.LangID == EUDC_JPN)
    {
      //  JPN platform, use fixed pitch font.
       LogFont.lfPitchAndFamily |= FIXED_PITCH;
    }
     if( !cFont.CreateFontIndirect( &LogFont)){
        OutputMessageBox(this->GetSafeHwnd(),
           IDS_ASSOCIATE_DLGTITLE,
           IDS_SELECTFONT_ERROR, TRUE);
      OTerm();
      EnableEUDC(TRUE);
        return ABORT;
    }
     OldFont = dc.SelectObject( &cFont);

    FontType = !SelectEUDC.m_FontTypeFlg? 1:0;
     if( OCreateTTF( dc.GetSafeHdc(), TTFPath, FontType))
    {
      dc.SelectObject(OldFont);
      cFont.DeleteObject();
      OTerm();
      EnableEUDC(TRUE);
       return ABORT;
    }
    dc.SelectObject(OldFont);
     cFont.DeleteObject();
  }

   wSize = (DWORD)((( BITMAP_WIDTH +15) /16) *2) *(WORD)BITMAP_HEIGHT;
   pBuf = (LPBYTE)malloc(((( BITMAP_WIDTH +15) /16) *2) *BITMAP_HEIGHT);
   if( pBuf == NULL){
    OTerm();
    EnableEUDC(TRUE);
      return ABORT;
   }
   pBuf2 = pBuf;
   ImageBmp.GetBitmapBits( wSize, (LPVOID)pBuf2);     

   if( OMakeOutline( (LPBYTE)pBuf2, BITMAP_WIDTH, SMOOTHLVL) < 0)
  {
    free(pBuf);
    OTerm();
    EnableEUDC(TRUE);
      return ABORT;
  }
   sts = OOutTTF( dc.GetSafeHdc(),
                   TTFPath,
                   (unsigned short)UpdateCode,
                   CountryInfo.bUnicodeMode);
  if (sts == -3) //tte file is being used by another process
  {
    free(pBuf);
    OTerm();
    EnableEUDC(TRUE);

    HINSTANCE hInst = AfxGetInstanceHandle();
    TCHAR szMessage[256];
    LoadString(hInst, IDS_OVERWRITEFAIL, szMessage, sizeof(szMessage) / sizeof(TCHAR));
    TCHAR szTitle[256];
    LoadString(hInst, IDS_MAINFRAMETITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
    if (MessageBox( szMessage, szTitle, msgBoxType) == IDCANCEL)
      return CANCEL;
    else
      return ABORT;
  }
  else if (sts < 0)
  {
    free(pBuf);
    OTerm();
    EnableEUDC(TRUE);

    OutputMessageBox( this->GetSafeHwnd(),
         IDS_MAINFRAMETITLE,
         IDS_NOTENOUGHMEMORY_ERROR, TRUE);
    return ABORT;
  }

//fix for FontIsLinked
  if (firstTime)
  {
      if (creatW31JEUDC(BMPPath))
    {
      free(pBuf);
      OTerm();
      EnableEUDC(TRUE);
      return ABORT;
    }
  }
//
   if( OpenW31JEUDC( BMPPath)){
    free(pBuf);
    OTerm();
    EnableEUDC(TRUE);
    return ABORT;
   }
   if( PutW31JEUDCFont((unsigned short)UpdateCode, pBuf2, BITMAP_WIDTH,
             BITMAP_HEIGHT, CountryInfo.bUnicodeMode)){
      CloseW31JEUDC();
    free(pBuf);
    OTerm();
    EnableEUDC(TRUE);
    return ABORT;
   }
   CloseW31JEUDC();
   BitmapDirty = FALSE;
   g_bKeepEUDCLink = TRUE;

RET:
  if (pBuf)
  {
     free(pBuf);
  }
  OTerm();
  EnableEUDC(TRUE);
RET3:
  return ABORT;
}

/****************************************/
/*             */
/* draw image for undo     */
/*             */
/****************************************/
void
CEditWnd::UndoImageDraw()
{
   CDC   UndoDC;

   if( !UndoBitmapFlag)
         CreateUndoBitmap();

      UndoDC.CreateCompatibleDC( &ImageDC);
      CBitmap *OldBitmap = UndoDC.SelectObject( &UndoImage);

      UndoDC.BitBlt( 0, 0, BITMAP_WIDTH, BITMAP_HEIGHT,
      &ImageDC, 0, 0, SRCCOPY);

   if( RectClipFlag && (SelectItem == RECTCLIP || SelectItem == FREEFORM)){
      CRect pRect;

      pRect.SetRect(( ClipRect[DSP].left + 1) /ZoomRate,
          ( ClipRect[DSP].top - CAPTION_HEIGHT +1) /ZoomRate,
          ( ClipRect[DSP].right + 1)/ZoomRate,
          ( ClipRect[DSP].bottom - CAPTION_HEIGHT +1) /ZoomRate);

      UndoDC.StretchBlt( pRect.left, pRect.top,
         pRect.Width(), pRect.Height(), &CRTDrawDC,
         ClipRect[BMP].left, ClipRect[BMP].top,
         ClipRect[BMP].Width(), ClipRect[BMP].Height(), SRCAND);
   }
      UndoDC.SelectObject( OldBitmap);
      UndoDC.DeleteDC();
   UndoBitmapFlag = TRUE;
}

/****************************************/
/*             */
/*    for Update     */
/*             */
/****************************************/
BOOL
CEditWnd::SelectCodes()
{
   int   xSize, ySize;
   int   wSize;
   LPBYTE   pBuf=NULL;
   TCHAR *FilePtr;
   TCHAR BMPPath[MAX_PATH];
   HRESULT hresult;

   //*STRSAFE*    lstrcpy( BMPPath, SelectEUDC.m_File);
   hresult = StringCchCopy(BMPPath , ARRAYLEN(BMPPath),  SelectEUDC.m_File);
   if (!SUCCEEDED(hresult))
   {
      return FALSE;
   }
   if(( FilePtr = Mytcsrchr( BMPPath, '.')) != NULL)
      *FilePtr = '\0';
   //*STRSAFE*    lstrcat( BMPPath, TEXT(".EUF"));
   hresult = StringCchCat(BMPPath , ARRAYLEN(BMPPath),  TEXT(".EUF"));
   if (!SUCCEEDED(hresult))
   {
      return FALSE;
   }

   wSize = (int)((( BITMAP_WIDTH + 15) /16) *2) *(int)BITMAP_HEIGHT;
   pBuf = (LPBYTE)malloc( wSize);
   if( OpenW31JEUDC( BMPPath)){
      free( pBuf);
      return FALSE;
   }
   if( GetW31JEUDCFont((unsigned short)UpdateCode, pBuf, wSize,
              &xSize, &ySize, CountryInfo.bUnicodeMode)){
      CloseW31JEUDC();
      free( pBuf);
      return FALSE;
   }else if( xSize != BITMAP_WIDTH || ySize != BITMAP_HEIGHT){
      CloseW31JEUDC();
      free( pBuf);
      return FALSE;
   }
   CloseW31JEUDC();

   ImageBmp.SetBitmapBits( wSize, (LPVOID)pBuf);
   BitmapDirty = FALSE;
   if (pBuf)
   {
      free( pBuf);
   }
   this->Invalidate( FALSE);
   this->UpdateWindow();
   return TRUE;
}

/****************************************/
/*             */
/* Clear bitmap data    */
/*             */
/****************************************/
BOOL
CEditWnd::UpdateBitmap()
{
   WORD  wSize;
   HANDLE   BitHandle;
   BYTE  *pBitmap;

   wSize = (WORD)((( BITMAP_WIDTH +15) /16) *2) *(WORD)BITMAP_HEIGHT;
   if(( BitHandle = LocalAlloc( LMEM_MOVEABLE, wSize)) == 0)
      return FALSE;

   if(( pBitmap = (BYTE *)LocalLock( BitHandle)) == NULL){
      LocalFree( BitHandle);
      return FALSE;
   }
   memset( pBitmap, 0xffff, wSize);

   ImageBmp.SetBitmapBits((DWORD)wSize, (const void far *)pBitmap);
   LocalUnlock( BitHandle);
   LocalFree( BitHandle);

   if(( SelectItem == RECTCLIP || SelectItem == FREEFORM) && RectClipFlag){
      RectClipFlag = FALSE;
      ToolTerm();
   }
   this->Invalidate( FALSE);
   this->UpdateWindow();
   BitmapDirty = FALSE;

   return TRUE;
}

/****************************************/
/*             */
/* Get bitmap dirty flag      */
/*             */
/****************************************/
BOOL
CEditWnd::GetBitmapDirty()
{
   return BitmapDirty;
}

/****************************************/
/*             */
/* Get bitmap dirty flag      */
/*             */
/****************************************/
BOOL
CEditWnd::SetBitmapDirty(
BOOL  Flg)
{
   BitmapDirty = Flg;
   return TRUE;
}

/****************************************/
/*             */
/* Call Charcter        */
/*             */
/****************************************/
void
CEditWnd::CallCharTextOut()
{
   CFont CallFont;
   CSize CharSize;
   BYTE  sWork[10];
   int   Length;
   int   xOffset, yOffset;

   EditLogFont.lfHeight  = BITMAP_HEIGHT; 
   EditLogFont.lfWeight  = 0;
   EditLogFont.lfQuality = PROOF_QUALITY;
   if( !CallFont.CreateFontIndirect( &EditLogFont))
      return;
   CFont *OldFont = ImageDC.SelectObject( &CallFont);

   if( !CallCode)
      Length = 0;

   else
   {
      sWork[0] = LOBYTE(CallCode);
     sWork[1] = HIBYTE(CallCode);
      sWork[2] = sWork[3] = 0;
      Length = 1;
   }
/*
   else if( !HIBYTE(CallCode)){
//    SBCS
      sWork[0] = LOBYTE(CallCode);
      sWork[1] = (BYTE)'\0';
      Length = 1;
   }else{
//    DBCS
      sWork[0] = HIBYTE(CallCode);
      sWork[1] = LOBYTE(CallCode);
      sWork[2] = (BYTE)'\0';
      Length = 2;
   }
*/
   if( Length){
      CRect TextImage;
/*
      GetTextExtentPoint32A( ImageDC.GetSafeHdc(), (LPCSTR)sWork,
            Length, &CharSize);
*/
      GetTextExtentPoint32W( ImageDC.GetSafeHdc(), (LPCWSTR)sWork,
            Length, &CharSize);

      TextImage.SetRect( 0, 0, BITMAP_WIDTH, BITMAP_HEIGHT);
      if( CharSize.cx < BITMAP_WIDTH)
         xOffset = ( BITMAP_HEIGHT - CharSize.cx) /2;
      else  xOffset = 0;

      if( CharSize.cy < BITMAP_HEIGHT)
         yOffset = ( BITMAP_WIDTH  - CharSize.cy) /2;
      else  yOffset = 0;

      if( EditLogFont.lfFaceName[0] == '@' &&
          Length == 1)
         xOffset = yOffset = 0;
/*    
         ExtTextOutA(ImageDC.GetSafeHdc(), xOffset, yOffset, ETO_OPAQUE,
         &TextImage, (LPCSTR)sWork, Length, NULL);
*/
         ExtTextOutW(ImageDC.GetSafeHdc(), xOffset, yOffset, ETO_OPAQUE,
         &TextImage, (LPCWSTR)sWork, Length, NULL);

   }
   ImageDC.SelectObject( OldFont);
   CallFont.DeleteObject();
   this->Invalidate( FALSE);
   this->UpdateWindow();
}

/****************************************/
/*             */
/* COMMAND     "Flip/Rotate"  */
/*             */
/****************************************/
void
CEditWnd::FlipRotate(
int   RadioItem)
{
   CDC   RotateDC;
   CBitmap RotateBMP;
   CBrush   wBrush;
   int   wSize;
   LPBYTE   pBuf1 = NULL; 
   LPBYTE   pBuf2 = NULL;
   LPBYTE   pPtr1, pPtr2;

   UndoImageDraw();
   BitmapDirty = TRUE;
   InitFlipRotate( &RotateDC, &RotateBMP);

   switch( RadioItem){
   case FLIP_HOR:
      if( !RectClipFlag){
         ImageDC.StretchBlt( BITMAP_WIDTH - 1, 0,
            0 - BITMAP_WIDTH, BITMAP_HEIGHT, &CRTDrawDC,
            0, 0, BITMAP_WIDTH, BITMAP_HEIGHT, SRCCOPY);
      }else{
         wBrush.CreateStockObject( WHITE_BRUSH);
         CRTDrawDC.FillRect( &ClipRect[BMP], &wBrush);
         wBrush.DeleteObject();

         CRTDrawDC.StretchBlt(
            ClipRect[BMP].right - 1, ClipRect[BMP].top,
            0 - ClipRect[BMP].Width(),
            ClipRect[BMP].Height(), &RotateDC,
            ClipRect[BMP].left, ClipRect[BMP].top,
            ClipRect[BMP].Width(),
            ClipRect[BMP].Height(), SRCCOPY);
      }
      break;

   case FLIP_VER:
      if( !RectClipFlag){
         ImageDC.StretchBlt( 0, BITMAP_HEIGHT - 1, BITMAP_WIDTH,
            0 - BITMAP_HEIGHT, &CRTDrawDC, 0, 0,
            BITMAP_WIDTH, BITMAP_HEIGHT, SRCCOPY);
      }else{
         wBrush.CreateStockObject( WHITE_BRUSH);
         CRTDrawDC.FillRect( &ClipRect[BMP], &wBrush);
         wBrush.DeleteObject();

         CRTDrawDC.StretchBlt(
            ClipRect[BMP].left,ClipRect[BMP].bottom - 1,
            ClipRect[BMP].Width(),
            0 - ClipRect[BMP].Height(), &RotateDC,
            ClipRect[BMP].left, ClipRect[BMP].top,
            ClipRect[BMP].Width(),
            ClipRect[BMP].Height(), SRCCOPY);
      }
      break;

   case ROTATE_9:
      wSize = (int)((( BITMAP_WIDTH +15) /16) *2)*(int)BITMAP_HEIGHT;
      pBuf1 = (LPBYTE)malloc( wSize);
      pBuf2 = (LPBYTE)malloc( wSize);
      if (pBuf1==NULL || pBuf2==NULL)
      {
      	goto Exit;
      }
      if( !RectClipFlag){
         ImageBmp.GetBitmapBits( wSize, (LPVOID)pBuf1);
         CRTDrawBmp.GetBitmapBits( wSize, (LPVOID)pBuf2);
         pPtr1 = pBuf1;
         pPtr2 = pBuf2;
         RotateFigure90(pPtr1,pPtr2,BITMAP_WIDTH, BITMAP_HEIGHT);
         ImageBmp.SetBitmapBits( wSize, (LPVOID)pBuf1);
         CRTDrawBmp.SetBitmapBits( wSize, (LPVOID)pBuf2);

      }else{
         CPoint   Mid;  
         CRTDrawBmp.GetBitmapBits( wSize, (LPVOID)pBuf1);
         RotateBMP.GetBitmapBits(  wSize, (LPVOID)pBuf2);
         pPtr1 = pBuf1;
         pPtr2 = pBuf2;
         RotateFigure90(pPtr1,pPtr2,BITMAP_WIDTH, BITMAP_HEIGHT);

         int Lft = ClipRect[BMP].left;
         int Btm = ClipRect[BMP].bottom;
         int Wid = ClipRect[BMP].Width();
         int Hgt = ClipRect[BMP].Height();
         ClipRect[BMP].left = BITMAP_HEIGHT - Btm;
         ClipRect[BMP].top  = Lft;
         ClipRect[BMP].right = ClipRect[BMP].left + Hgt;
         ClipRect[BMP].bottom = ClipRect[BMP].top + Wid;

         Lft = ClipRect[DSP].left;
         Btm = ClipRect[DSP].bottom - CAPTION_HEIGHT - 1;
         Wid = ClipRect[DSP].Width();
         Hgt = ClipRect[DSP].Height();
         Mid.x = Lft
         +((ClipRect[DSP].Width()/2)/ZoomRate)*ZoomRate;
         Mid.y = ClipRect[DSP].top - CAPTION_HEIGHT
         +((ClipRect[DSP].Height()/2)/ZoomRate)*ZoomRate;

         Mid.x -= (((ClipRect[DSP].Height()/2)/ZoomRate)*ZoomRate);
         Mid.y -= (((ClipRect[DSP].Width()/2)/ZoomRate)*ZoomRate);
         if( Mid.x < 0)    ClipRect[DSP].left = 0;
         else{
            if( ClipRect[DSP].left + Hgt <=
               EudcWndRect.right){
               ClipRect[DSP].left = Mid.x;
            }else{
               ClipRect[DSP].left =
                  Mid.x - ((Mid.x + Hgt - EudcWndRect.right)/ZoomRate)*ZoomRate;
            }
         }
         if( Mid.y < 0)    ClipRect[DSP].top = CAPTION_HEIGHT;
         else{
            if( ClipRect[DSP].top + Wid   <= EudcWndRect.bottom){
               ClipRect[DSP].top =
                  CAPTION_HEIGHT + Mid.y;
            }else{
               ClipRect[DSP].top =
                  CAPTION_HEIGHT + Mid.y - (( CAPTION_HEIGHT + Mid.y + Wid - EudcWndRect.bottom)/ZoomRate)*ZoomRate;
            }
         }
         ClipRect[DSP].right = ClipRect[DSP].left + Hgt;
         ClipRect[DSP].bottom = ClipRect[DSP].top + Wid;
         CRTDrawBmp.SetBitmapBits( wSize, (LPVOID)pBuf1);
         RotateBMP.SetBitmapBits(  wSize, (LPVOID)pBuf2);
      }
      break;

   case ROTATE_18:
      if( !RectClipFlag){
         ImageDC.StretchBlt( BITMAP_WIDTH -1, BITMAP_HEIGHT-1,
            0-BITMAP_HEIGHT, 0-BITMAP_WIDTH, &CRTDrawDC,
            0, 0, BITMAP_WIDTH, BITMAP_HEIGHT, SRCCOPY);
      }else{
         wBrush.CreateStockObject( WHITE_BRUSH);
         CRTDrawDC.FillRect( &ClipRect[BMP], &wBrush);
         wBrush.DeleteObject();

         CRTDrawDC.StretchBlt(
            ClipRect[BMP].right-1, ClipRect[BMP].bottom-1,
            0 - ClipRect[BMP].Width(),
            0 - ClipRect[BMP].Height(), &RotateDC,
            ClipRect[BMP].left, ClipRect[BMP].top,
            ClipRect[BMP].Width(),
            ClipRect[BMP].Height(), SRCCOPY);
      }
      break;

   case ROTATE_27:
      wSize = (int)((( BITMAP_WIDTH +15) /16) *2) *(int)BITMAP_HEIGHT;
      pBuf1 = (LPBYTE)malloc( wSize);
      pBuf2 = (LPBYTE)malloc( wSize);
      if (pBuf1==NULL || pBuf2==NULL)
      {
        goto Exit;
      }      
      if( !RectClipFlag){
         ImageBmp.GetBitmapBits( wSize, (LPVOID)pBuf1);
         CRTDrawBmp.GetBitmapBits( wSize, (LPVOID)pBuf2);
         pPtr1 = pBuf1;
         pPtr2 = pBuf2;
         RotateFigure270( pPtr1, pPtr2, BITMAP_WIDTH,
               BITMAP_HEIGHT);
         ImageBmp.SetBitmapBits( wSize, (LPVOID)pBuf1);
         CRTDrawBmp.SetBitmapBits( wSize, (LPVOID)pBuf2);

      }else{
         CPoint   Mid;
         CRTDrawBmp.GetBitmapBits( wSize, (LPVOID)pBuf1);
         RotateBMP.GetBitmapBits(  wSize, (LPVOID)pBuf2);
         pPtr1 = pBuf1;
         pPtr2 = pBuf2;
         RotateFigure270( pPtr1, pPtr2,
            BITMAP_WIDTH, BITMAP_HEIGHT);

         int Rgt = ClipRect[BMP].right;
         int Top = ClipRect[BMP].top;
         int Wid = ClipRect[BMP].Width();
         int Hgt = ClipRect[BMP].Height();
         ClipRect[BMP].left = Top;
         ClipRect[BMP].top  = BITMAP_WIDTH - Rgt;
         ClipRect[BMP].right = ClipRect[BMP].left + Hgt;
         ClipRect[BMP].bottom = ClipRect[BMP].top + Wid;

         Rgt = ClipRect[DSP].right - 1;
         Top = ClipRect[DSP].top - CAPTION_HEIGHT;
         Wid = ClipRect[DSP].Width();
         Hgt = ClipRect[DSP].Height();
         Mid.x = ClipRect[DSP].left
         + ((ClipRect[DSP].Width()/2)/ZoomRate)*ZoomRate;
         Mid.y = Top
         + ((ClipRect[DSP].Height()/2)/ZoomRate)*ZoomRate;
         Mid.x -= (((ClipRect[DSP].Height()/2)/ZoomRate)*ZoomRate);
         Mid.y -= (((ClipRect[DSP].Width()/2)/ZoomRate)*ZoomRate);
         if( Mid.x < 0)    ClipRect[DSP].left = 0;
         else{
            if( ClipRect[DSP].left + Hgt
               <= EudcWndRect.right){
               ClipRect[DSP].left = Mid.x;
            }else{
               ClipRect[DSP].left =
                  Mid.x - ((Mid.x + Hgt - EudcWndRect.right)/ZoomRate)*ZoomRate;
            }
         }
         if( Mid.y < 0)
            ClipRect[DSP].top = CAPTION_HEIGHT;
         else{
            if( ClipRect[DSP].top + Wid   <= EudcWndRect.bottom){
               ClipRect[DSP].top =
                  CAPTION_HEIGHT + Mid.y;
            }else{
               ClipRect[DSP].top =
                  CAPTION_HEIGHT + Mid.y - (( CAPTION_HEIGHT + Mid.y + Wid - EudcWndRect.bottom)/ZoomRate)*ZoomRate;
            }
         }
         ClipRect[DSP].right = ClipRect[DSP].left + Hgt;
         ClipRect[DSP].bottom = ClipRect[DSP].top + Wid;
            
         CRTDrawBmp.SetBitmapBits( wSize, (LPVOID)pBuf1);
         RotateBMP.SetBitmapBits(  wSize, (LPVOID)pBuf2);
      }
      break;

   default:
      break;
   }
   if( RectClipFlag){
      if( RotateBMP.Detach() != NULL)
         RotateBMP.DeleteObject();
      if( RotateDC.Detach() != NULL)
         RotateDC.DeleteDC();
   }
   this->Invalidate(FALSE);
   this->UpdateWindow();

Exit:
    if (pBuf1 != NULL)
    {
        free(pBuf1);
    }
    if (pBuf2 != NULL)
    {
        free(pBuf2);
    }
}

/************************************************/
/*                */
/* Initialize before flip or rotate */
/*                */
/************************************************/
void
CEditWnd::InitFlipRotate(
CDC*  RotateDC,
CBitmap *RotateBMP)
{
   WORD  BitSize;
   HANDLE   BitInit;
   BYTE  *BitmapPtr;

   if( RectClipFlag){
      CClientDC   dc( this);
      if( !RotateDC->CreateCompatibleDC( &dc))
         return;

      BitSize = (WORD)((( BITMAP_WIDTH +15) /16) *2)
         * (WORD)BITMAP_HEIGHT;
      if (BitSize == 0)
      {
        return;
      }
      if(( BitInit = LocalAlloc( LMEM_MOVEABLE, BitSize))==0)
         return;

      if(( BitmapPtr = (BYTE *)LocalLock( BitInit)) == NULL){
         LocalFree( BitInit);
         return;
      }
      memset( BitmapPtr, 0xffff, BitSize);
      if( !RotateBMP->CreateBitmap(BITMAP_WIDTH,BITMAP_HEIGHT,
         1, 1, (LPSTR)BitmapPtr)){
         LocalUnlock( BitInit);
         LocalFree( BitInit);
         return;
      }
      LocalUnlock( BitInit);
      LocalFree( BitInit);    
      RotateDC->SelectObject( RotateBMP);

      RotateDC->BitBlt( 0, 0, BITMAP_WIDTH, BITMAP_HEIGHT,
         &CRTDrawDC, 0, 0, SRCCOPY);
   }else{
      CRTDrawDC.BitBlt( 0, 0, BITMAP_WIDTH, BITMAP_HEIGHT,
         &ImageDC, 0, 0, SRCCOPY);
   }
}

#define     set_p(a,i)  ((a)[(i)>>3] & (0x80>>((i)&7)))
/****************************************/
/*             */
/* Rotate 90         */
/*             */
/****************************************/
void
CEditWnd::RotateFigure90(
LPBYTE   pBuf1,
LPBYTE   pBuf2,
int   bWid,
int   bHgt)
{
   int   i, j, k, l;
   int   wSize, aSize;
   BYTE  Pt, *test;

   if ( (!pBuf1) ||(!pBuf2))
   {
      return;
   }
   aSize = (int)(((( bWid + 15) /16) *2) *bHgt);
   wSize = (int)((( bWid  + 15) /16) *2);
   test = pBuf2;
   for( i = 0; i < wSize; i++){
      pBuf2 = test + aSize - wSize + i;
      for( j = 0; j < 8; j++){
         for( k = wSize-1; k >= 0; k--){
            memset( &Pt, 0x00, sizeof(BYTE));
            for( l = 0; l < 8; l++){
               if( set_p(pBuf2, j))
                  Pt |= (1<<(7-l));
               pBuf2 -= wSize;
            }
            *pBuf1++ = Pt;
         }
         pBuf2 = test + aSize - wSize + i;
      }
   }
   return;
}

/****************************************/
/*             */
/* Rotate 270        */
/*             */
/****************************************/
void
CEditWnd::RotateFigure270(
LPBYTE   pBuf1,
LPBYTE   pBuf2,
int   bWid,
int   bHgt)
{
   int   i, j, k, l;
   int   wSize, aSize;
   BYTE  Pt, *test;

   aSize = (int)(((( bWid + 15) /16) *2) *bHgt);
   wSize = (int)((( bWid  + 15) /16) *2);
   test = pBuf2;
   for( i = 0; i < wSize; i++){
      pBuf2 = test + wSize - 1 - i;
      for( j = 7; j >= 0; j--){
         for( k = wSize-1; k >= 0; k--){
            memset( &Pt, 0x00, sizeof(BYTE));
            for( l = 0; l < 8; l++){
               if( set_p(pBuf2, j))
                  Pt |= (1<<(7-l));
               pBuf2 += wSize;
            }
            *pBuf1++ = Pt;
         }
         pBuf2 = test + wSize - 1 - i;
      }
   }
   return;
}

/****************************************/
/*             */
/* Set Duplicate rectangle    */
/*             */
/****************************************/
void
CEditWnd::SetDuplicateRect(
RECT  *rect,
POINT    *point)
{
   LPBYTE pDupBmp;
   int   wSize;

   UndoImageDraw();
   BitmapDirty = TRUE;
   WriteSelRectBitmap();
   this->Invalidate( FALSE);
   this->UpdateWindow();

   wSize = ((( BITMAP_WIDTH +15) /16) *2) *BITMAP_HEIGHT;
   pDupBmp = (LPBYTE)malloc( wSize);
   DupBmp.GetBitmapBits( wSize, (LPVOID)pDupBmp);
   CRTDrawBmp.SetBitmapBits( wSize, (LPVOID)pDupBmp);
   free( pDupBmp);

   ClipRect[DSP].CopyRect( rect);
   ClipRect[PRV].CopyRect( rect);
   SetValidRect();
   SetClickRect();
   ClipRect[BMP].SetRect( DupRect.left /ZoomRate,
      ( DupRect.top - CAPTION_HEIGHT) /ZoomRate,
        DupRect.right /ZoomRate,
      ( DupRect.bottom - CAPTION_HEIGHT) /ZoomRate);
   RectClipFlag = TRUE;

   this->InvalidateRect( &ClipRect[VLD], FALSE);
   this->UpdateWindow();
}

void CEditWnd::OnClose() 
{
   // Don't allow user to use hot key to close this window
   
   //CMDIChildWnd::OnClose();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\create.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//


#include	"stdafx.h"
#include	"eudcedit.h" 

#pragma		pack(2)

#include	"ttfstruc.h"
#include	"vdata.h"
#include	"extfunc.h"

#define		EUDCCODEBASE	((unsigned short)0xe000)
/*
 File Structure */

struct W31_Header {
	char	identify[72];
unsigned char	segCnt[2];		/* ??? */
unsigned char	sCode[2],
		eCode[2];
	unsigned short	cCnt;       // Max character count
	unsigned long	ofsCmap;    // CMAP table offset
	unsigned short	sizCmap;    // Size of CMAP table
	unsigned long	ofsHCmap;
	unsigned short	sizHCmap;
	unsigned long	ofsStbl;    // Search table
	unsigned short	sizStbl;    // Size of search table
	unsigned long	ofsBdatSub; // Sub table of bitmap data
	};

struct BDatSubTbl {
	unsigned long	tail;
	long	locStartOfs;
	unsigned long	head;
	short	filler2;
	/* Following Pointer tbl. */
	};
struct BMPHeader {
	unsigned long	bitmapSiz;
	unsigned short	xsiz, ysiz;
	};

struct SrchEntry {
	unsigned short	sCode;
	unsigned short	eCode;
	unsigned short	sloc;
	};
/************************
 *	Tables 
 */
/*
 *	For Japan 
 */

#if (WINVER >= 0x0500)
static struct W31_Header W31Hdr= {
	"Windows EUDC Editor Bitmap File (Uni-Code) ",
	{(unsigned char)0x0, (unsigned char)0x1},
	{(unsigned char)0xe0, (unsigned char)0x00},
	{(unsigned char)0xf8, (unsigned char)0xff},
	(unsigned short)6400,
	(unsigned long)	0,
	(unsigned short)0,
	(unsigned long)0,
	(unsigned short) 512,
	(unsigned long)0,
	(unsigned short)0,
	(unsigned long)0
	};
#else
static struct W31_Header W31Hdr= {
	"Windows95 EUDC Editor Bitmap File (Uni-Code) ",
	{(unsigned char)0x0, (unsigned char)0x1},
	{(unsigned char)0xe0, (unsigned char)0x00},
	{(unsigned char)0xe7, (unsigned char)0x57},
	(unsigned short)1880,
	(unsigned long)	0,
	(unsigned short)0,
	(unsigned long)0,
	(unsigned short) 512,
	(unsigned long)0,
	(unsigned short)0,
	(unsigned long)0
	};
#endif

static struct SrchEntry cSrchEntry = {
	(unsigned short)0xE000,(unsigned short)0xE757,(unsigned short)0
	};

static void
setFileHeader( )
{
struct W31_Header *hdr;
	unsigned short	maxCode;

	maxCode = getMaxUniCode();
	hdr = &W31Hdr;
	hdr->eCode[0] = (unsigned char)(maxCode>>8);
	hdr->eCode[1] = (unsigned char)(maxCode & 0xff);
	hdr->cCnt =  maxCode - EUDCCODEBASE +1;
	hdr->ofsCmap = sizeof(struct W31_Header);
	hdr->sizCmap = hdr->cCnt*2;
	hdr->ofsHCmap = hdr->ofsCmap + hdr->sizCmap;
	hdr->ofsStbl = hdr->ofsHCmap+hdr->sizHCmap;
	hdr->sizStbl = sizeof(struct SrchEntry);
	hdr->ofsBdatSub = hdr->ofsStbl + hdr->sizStbl;

	cSrchEntry.sCode = EUDCCODEBASE;
	cSrchEntry.eCode = maxCode;
	return;
}
static int
makeCodeMap( char **mem, unsigned int *msiz)
{
	unsigned short	code;
	unsigned short	*cbuf;
	unsigned short	startC, endC;

       if ((!mem) || (!msiz))
       {
          return -1;
       }
	*msiz = W31Hdr.cCnt*2;
	if ( (*mem = (char *)malloc(*msiz)) == (char *)0)
		return -1;
	cbuf = (unsigned short *)*mem;

	startC =  cSrchEntry.sCode;
	endC =  cSrchEntry.eCode = getMaxUniCode();
	for ( code = startC; code <= endC; code++, cbuf++)
			*cbuf = code;
	return 0;
}
static int
makeHCMap( char **mem, unsigned int *msiz)
{
	unsigned short	*hcp;
	unsigned short	hc;
	unsigned short	sofs;
	unsigned short	start, end;

       if ((!mem) || (!msiz))
       {
          return -1;
       }

	*msiz = W31Hdr.sizHCmap;

	if ( (*mem = (char *)malloc( *msiz))==(char *)0)
		return -1;
	memset( *mem, 0xff, *msiz);
	hcp = (unsigned short *)*mem;
	sofs = (unsigned short)0;
	start = (unsigned short)W31Hdr.sCode[0];
	end = (unsigned short)W31Hdr.eCode[0];
	for ( hc = start; hc <= end; hc++) {
		*(hcp+hc) = (unsigned short)0;
	}
	return 0;
}
static int
makeSrchTbl( char **mem, unsigned int *msiz)
{

       if ((!mem) || (!msiz))
       {
          return -1;
       }
	*msiz = sizeof(struct SrchEntry);
	if ( (*mem = (char *)malloc( *msiz))==(char *)0)
		return -1;

	memcpy( *mem, &cSrchEntry, *msiz);

	return 0;
}
static int
makeBdatSub( char **mem, unsigned int *msiz)
{
struct BDatSubTbl	*bdtbl;
       if ((!mem) || (!msiz))
       {
          return -1;
       }
	*msiz = (W31Hdr.cCnt)*4 + sizeof(struct BDatSubTbl);
	if ( (*mem = (char *)malloc(*msiz))==(char *)0)
		return -1;
	memset( *mem, 0, *msiz);
	bdtbl = (struct BDatSubTbl *)*mem;
	bdtbl->head = bdtbl->tail = *msiz;
	bdtbl->locStartOfs=sizeof(struct BDatSubTbl);
	return 0;
}
/***************************************************************
 *	Create EUDC Bitmap File (.EUF)
 */
/* */	int
/* */	creatW31JEUDC( 
/* */		TCHAR *path)		/* .EUF file path */
/*
 *	returns : 0, -1
 ***************************************************************/
{
	HANDLE	fh=INVALID_HANDLE_VALUE;
	char	*mem=NULL;
	unsigned int msiz;
	DWORD nByte;
	BOOL res;

       if (!path)
       {
           goto ERET;
       }
 
	mem = (char *)0;
	makeUniCodeTbl();
	fh = CreateFile(path,
					GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
					NULL,
					CREATE_ALWAYS,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fh == INVALID_HANDLE_VALUE)
		goto	ERET;

	/* File Header */
	setFileHeader( );
	res =WriteFile( fh, (char *)&W31Hdr, sizeof(W31Hdr), &nByte, NULL);
	if (!res || nByte !=sizeof(W31Hdr))
		goto	ERET;
	/* Code Map */	
	if (makeCodeMap( &mem, &msiz))
		goto	ERET;
	res =WriteFile( fh, mem, msiz, &nByte, NULL);
	if (!res || nByte !=msiz)
		goto	ERET;
	free(mem);

	/* High Byte Mapping for Search table */
	if ( makeHCMap( &mem, &msiz))
		goto	ERET;
	res =WriteFile( fh, mem, msiz, &nByte, NULL);
	if (!res || nByte !=msiz)
		goto	ERET;
	free(mem);

	/* Srch Table */
	if (makeSrchTbl( &mem, &msiz))
		goto	ERET;
	res =WriteFile( fh, mem, msiz, &nByte, NULL);
	if (!res || nByte !=msiz)
		goto	ERET;
	free(mem);

	/* Segment Def Header */
	makeBdatSub( &mem, &msiz);
	res =WriteFile( fh, mem, msiz, &nByte, NULL);
	if (!res || nByte !=msiz)
		goto	ERET;
	free(mem);
	CloseHandle( fh);
	return 0;
ERET:
	if ( mem!=(char *)0)
		free( mem);
	if ( fh != INVALID_HANDLE_VALUE)
		CloseHandle( fh);
	return -1;
}
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\eten.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
/*
CWIN31 EUDC Format and ETEN format
The structures are not aligned to word order. For the reason, it is need to use
'char' array base structures for the purpose of R/W files.
For the further item, the word is strored in Intel monor, use set/get functions.

+---------------------------+
| File Header  256 bytes    | -----> USERFONTHEADER
+---------------------------+
| Code Bank ID  2 bytes     | ~|
+---------------------------+  |---> CODEELEMENT
| DBCS Code    2 bytes      | _|
+---------------------------+
| Patten     ?? bytes       | -----> Glyph Patten depend on width and height
+---------------------------+
.              .
.              .
.              .
+---------------------------+
| Code Bank ID  2 bytes     |
+---------------------------+
| DBCS Code    2 bytes      |
+---------------------------+
| Patten     ?? bytes       |	---> Byte Boundary,remaining bits are not stable
+---------------------------+
*/

#ifdef BUILD_ON_WINNT
#pragma pack(1)
#endif // BUILD_ON_WINNT

struct CFONTINFO {
unsigned short	uInfoSize;		// Size of this structure.
unsigned short  idCP;			// Code page ID 938 for Taiwan.
	char	idCharSet;		// Character set is CHINESEBIG5_CHARSET
	char	fbTypeFace;  		// Type face.
	char	achFontName[12];	// Font Name.
unsigned long	ulCharDefine;		// Number of usable characters.
unsigned short  uCellWidth;		// Width of font cell.
unsigned short  uCellHeight;		// Height of font cell.
unsigned short  uCharHeight;		// Height of character height.
unsigned short  uBaseLine;		//
unsigned short  uUnderLine;		//
unsigned short  uUnlnHeight;		// Height of underline.
	char	fchStrokeWeight;	// Weight of font (Bold or Thin)
unsigned short  fCharStyle;		// italy
	char	fbFontAttrib;		//
unsigned long	ulCellWidthMax;		// Max width of font cell.
unsigned long	ulCellHeightMax;	// Max height of font cell.
	};

struct ETENHEADER {
unsigned short  uHeaderSize;	 	// Size of this structure.
	char	idUserFontSign[8];	// Must be "CWIN_PTN", "CMEX_PTN"
	char	idMajor;		// Version number if it is 1.0 then
	char	idMinor;		// idMajor is 1 and idMinor is 0
unsigned long	ulCharCount;		// Number of characters in file
unsigned short  uCharWidth;		// Width of the character.
unsigned short  uCharHeight;		// Height of the character.
unsigned long	cPatternSize;		// size of pattern in byte.
	char	uchBankID;	  	// if data is in same bank.
unsigned short  idInternalBankID;	// Internal code bank ID.
	char	achReserved1[37];	// must be zero.
struct	CFONTINFO  sFontInfo;		// chinese font structure.
	char	achReserved2[18];	// must be zero.
	char	achCopyRightMsg[128];	// Copyright message.
	};

struct CODEELEMENT {
	unsigned short   nBankID;		// BankID
	unsigned short   nInternalCode;		// Internal Code
	};


struct R_CFONTINFO {
unsigned char   uInfoSize[2];		// Size of this structure.
unsigned char   idCP[2];		// Code page ID 938 for Taiwan.
	char	idCharSet;		// Character set is CHINESEBIG5_CHARSET
	char	fbTypeFace;		// Type face.
	char	achFontName[12];	// Font Name.
unsigned char	ulCharDefine[4];	// Number of usable characters.
unsigned char   uCellWidth[2];		// Width of font cell.
unsigned char   uCellHeight[2];		// Height of font cell.
unsigned char   uCharHeight[2];		// Height of character height.
unsigned char   uBaseLine[2];		//
unsigned char   uUnderLine[2]; 		//
unsigned char   uUnlnHeight[2];		// Height of underline.
	char	fchStrokeWeight;	// Weight of font (Bold or Thin)
unsigned char   fCharStyle[2];		// italy
	char	fbFontAttrib;		//
unsigned char	ulCellWidthMax[4];	// Max width of font cell.
unsigned char	ulCellHeightMax[4];	// Max height of font cell.
	};

struct R_ETENHEADER {
unsigned char	uHeaderSize[2];		// Size of this structure.
	char	idUserFontSign[8];	// Must be "CWIN_PTN", "CMEX_PTN"
	char	idMajor;		// Version number if it is 1.0 then
	char	idMinor;		// idMajor is 1 and idMinor is 0
unsigned char	ulCharCount[4];		// Number of characters in file
unsigned char	uCharWidth[2];		// Width of the character.
unsigned char	uCharHeight[2];		// Height of the character.
unsigned char	cPatternSize[4];	// size of pattern in byte.
	char	uchBankID;		// if data is in same bank.
unsigned char	idInternalBankID[2];	// Internal code bank ID.
	char	achReserved1[37];	// must bezero.
struct R_CFONTINFO sFontInfo;		// chinese font structure.
	char	achReserved2[18]; 	// must be zero.
	char	achCopyRightMsg[128];	// Copyright message.
	};

struct R_CODEELEMENT {
	unsigned char   nBankID[2];		// BankID
	unsigned char   nInternalCode[2];		// Internal Code
	};

/* Open Mode */
#define	ETEN_READ	0
#define	ETEN_WRITE	1

int  openETENBMP(TCHAR  *path,int  md);
int  closeETENBMP(void);
int  createETENBMP(TCHAR  *path,int  width,int  height);
int  readETENBMPRec(int  rec,LPBYTE buf,int  bufsiz,unsigned short  *code);
int  appendETENBMP(LPBYTE buf,unsigned short  code);

#ifdef BUILD_ON_WINNT
#pragma pack()
#endif // BUILD_ON_WINNT
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\eudcdlg.h ===
/**************************************************/
/*						                          */
/*						                          */
/*		Update EUDC Dialog		                  */
/*						                          */
/*						                          */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include "eudclist.h"

class CEudcDlg : public CDialog
{
public:
	CEudcDlg(CWnd* pParent = NULL);

	//{{AFX_DATA(CEudcDlg)
	enum { IDD = IDD_CUSTOMCODE };
	//}}AFX_DATA

protected:
	void SetViewCustomFont();

public:
	CEudcList	m_EditList;
	CViewEdit	m_ViewChar;
#ifdef BUILD_ON_WINNT
    CColumnHeading  m_ColumnHeading;
#endif //BUILD_ON_WINNT
CCustomListFrame	m_ListFrame;
CCustomInfoFrame	m_Frame;
CCustomInfoFrame	m_InfoFrame2;
CCustomInfoFrame	m_InfoFrame3;
	CComboBox	m_ComboRange;
	CStatic		m_StaticRange;
	BOOL		WorRFlag;

private:
	void	AdjustFileName();
	void	AdjustFontName();
	void	RegistRegFont();
	TCHAR	FileName[MAX_PATH];
	TCHAR	FontName[LF_FACESIZE];

protected:
	virtual BOOL OnInitDialog();
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	//{{AFX_MSG(CEudcDlg)
	virtual void OnOK();
	afx_msg void OnSelchangeChinarange();
	virtual void OnCancel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\eudcdlg.cpp ===
/**************************************************/
/*						                          */
/*						                          */
/*	SelectCode... EUDC Editor Dialog	          */
/*						                          */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"eudcdlg.h"
#include 	"registry.h"
#include	"util.h"
#define STRSAFE_LIB
#include <strsafe.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

typedef struct _tagRegistDef{
	TCHAR	RegFont[LF_FACESIZE];
	TCHAR	RegFile[MAX_PATH];
	BOOL	RegFlg;
} REGISTDEF;

static 	REGISTDEF	RegistDef;	
BEGIN_MESSAGE_MAP(CEudcDlg, CDialog)
	//{{AFX_MSG_MAP(CEudcDlg)
	ON_CBN_SELCHANGE(IDC_CHINARANGE, OnSelchangeChinarange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*					*/
/*	Constructor			*/
/*					*/
/****************************************/
CEudcDlg::CEudcDlg( CWnd* pParent)
	: CDialog(CEudcDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEudcDlg)
	//}}AFX_DATA_INIT
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_INITDIALOG"		*/
/*					*/
/****************************************/
BOOL
CEudcDlg::OnInitDialog()
{
	LOGFONT	LogFont;
	CString	DialogTitle;		
	TCHAR	SBuf[5], EBuf[5], CodeBuf[15];
	TCHAR	SysFace[LF_FACESIZE];
	long	WindowStyle;
	HRESULT hresult;

	CDialog::OnInitDialog();

	WindowStyle = GetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE);
	WindowStyle |= WS_EX_CONTEXTHELP;
	SetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE, WindowStyle);

	m_EditList.SubclassDlgItem( IDC_CUSTOMEDIT, this);
	m_ViewChar.SubclassDlgItem( IDC_CUSTOMCHR, this);
#ifdef BUILD_ON_WINNT
	m_ColumnHeading.SubclassDlgItem( IDC_COLUMNHEADING, this);
#endif //BUILD_ON_WINNT
	m_Frame.SubclassDlgItem( IDC_CUSTOMFRAME, this);
	m_ListFrame.SubclassDlgItem( IDC_CUSTOMLISTFRAME, this);
	m_InfoFrame2.SubclassDlgItem( IDC_CUSTOMFRAME2, this);
	m_InfoFrame3.SubclassDlgItem( IDC_CUSTOMFRAME3, this);
	m_StaticRange.SubclassDlgItem( IDC_STATICRANGE, this);
	m_ComboRange.SubclassDlgItem( IDC_CHINARANGE, this);

	if( CountryInfo.LangID != EUDC_KRW || CountryInfo.bUnicodeMode){
		m_EditList.EnableScrollBar( SB_VERT, ESB_ENABLE_BOTH);
	}else	m_EditList.ShowScrollBar( SB_VERT, FALSE);

	AdjustFileName();
	AdjustFontName();
	this->SetDlgItemText( IDC_SETFONTNAME, FontName);
	this->SetDlgItemText( IDC_SETFILENAME, FileName);
	if( WorRFlag)
		DialogTitle.LoadString( IDS_REGISTAS_DLGTITLE);
	else	DialogTitle.LoadString( IDS_SELECTCODE_DLGTITLE);
	this->SetWindowText( DialogTitle);

	m_EditList.cRange = CountryInfo.CurrentRange;
	if( CountryInfo.nRange > 2 && !CountryInfo.bUnicodeMode){
	    m_StaticRange.ShowWindow( SW_SHOWNORMAL);
		m_ComboRange.ShowWindow( SW_SHOWNORMAL);
		m_StaticRange.UpdateWindow();
		m_ComboRange.UpdateWindow();

		for( int i = 0; i < CountryInfo.nRange-1; i++){
			//*STRSAFE* 			wsprintf( SBuf, TEXT("%X"), CountryInfo.sRange[i]);
			hresult = StringCchPrintf(SBuf , ARRAYLEN(SBuf),  TEXT("%X"), CountryInfo.sRange[i]);
			if (!SUCCEEDED(hresult))
			{
			   return FALSE;
			}
			//*STRSAFE* 			wsprintf( EBuf, TEXT("%X"), CountryInfo.eRange[i]);
			hresult = StringCchPrintf(EBuf , ARRAYLEN(EBuf),  TEXT("%X"), CountryInfo.eRange[i]);
			if (!SUCCEEDED(hresult))
			{
			   return FALSE;
			}
			//*STRSAFE* 			lstrcpy( CodeBuf, SBuf);
			hresult = StringCchCopy(CodeBuf , ARRAYLEN(CodeBuf),  SBuf);
			if (!SUCCEEDED(hresult))
			{
			   return FALSE;
			}
			//*STRSAFE* 			lstrcat( CodeBuf, TEXT(" - "));
			hresult = StringCchCat(CodeBuf , ARRAYLEN(CodeBuf),  TEXT(" - "));
			if (!SUCCEEDED(hresult))
			{
			   return FALSE;
			}
			//*STRSAFE* 			lstrcat( CodeBuf, EBuf);
			hresult = StringCchCat(CodeBuf , ARRAYLEN(CodeBuf),  EBuf);
			if (!SUCCEEDED(hresult))
			{
			   return FALSE;
			}
			m_ComboRange.InsertString( i, CodeBuf);
		}
		m_ComboRange.DeleteString( CountryInfo.nRange-1);
		m_ComboRange.SetCurSel( CountryInfo.CurrentRange);
	}

//	Set font for output character code
	GetFont()->GetObject( sizeof( LOGFONT), &LogFont);
	m_EditList.SysFFont.CreateFontIndirect( &LogFont);
	m_EditList.CalcCharSize();
#ifdef BUILD_ON_WINNT
//  Set font for the column heading
	m_ColumnHeading.SysFFont.CreateFontIndirect( &LogFont);
#endif //BUILD_ON_WINNT

//	Set font for output character
	memset( &LogFont, 0, sizeof( LogFont));
	if( m_EditList.CharSize.cx >= m_EditList.CharSize.cy)
		LogFont.lfHeight = m_EditList.CharSize.cy-2;
	else	LogFont.lfHeight = m_EditList.CharSize.cx-2;
	LogFont.lfCharSet = (BYTE)CountryInfo.CharacterSet;
	
  GetStringRes((TCHAR *)SysFace, IDS_SYSTEMEUDCFONT_STR, ARRAYLEN(SysFace));
  if( !lstrcmp(SelectEUDC.m_Font, (const TCHAR *)SysFace) )
  {
    //*STRSAFE*     lstrcpy (LogFont.lfFaceName, TEXT("System"));
    hresult = StringCchCopy(LogFont.lfFaceName , ARRAYLEN(LogFont.lfFaceName),  TEXT("System"));
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
	}else{
    //*STRSAFE*     lstrcpy( LogFont.lfFaceName, SelectEUDC.m_Font);
    hresult = StringCchCopy(LogFont.lfFaceName , ARRAYLEN(LogFont.lfFaceName),  SelectEUDC.m_Font);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
	}
	if( !m_EditList.EUDCFont.CreateFontIndirect( &LogFont))
		return FALSE;

	if( !m_ViewChar.EUDCFont.CreateFontIndirect( &LogFont))
		return FALSE;

	return TRUE;
}

/****************************************/
/*		Deal with "OK"		*/
/****************************************/
void CEudcDlg::OnOK()
{
	if( !m_EditList.SelectCode){
		if( WorRFlag){
			OutputMessageBox( this->GetSafeHwnd(),
				IDS_REGISTAS_DLGTITLE,
				IDS_NOTSELCHARACTER_MSG, TRUE);
		}else{
			OutputMessageBox( this->GetSafeHwnd(),
				IDS_SELECTCODE_DLGTITLE,
				IDS_NOTSELCHARACTER_MSG, TRUE);
		}
		return;
	}
	RegistRegFont();
	EndDialog(IDOK);
}
void CEudcDlg::OnCancel()
{
	RegistRegFont();
	CDialog::OnCancel();
}
/****************************************/
/*	Take off ".TTF" from filename	*/
/****************************************/
void CEudcDlg::AdjustFileName()
{
	TCHAR	*FilePtr;
	HRESULT hresult;

      
	//*STRSAFE* 	lstrcpy(FileName, SelectEUDC.m_FileTitle);
	hresult = StringCchCopy(FileName , ARRAYLEN(FileName),  SelectEUDC.m_FileTitle);
	if (!SUCCEEDED(hresult))
	{
	   return ;
	}
	if(( FilePtr = Mytcsrchr( FileName, '.')) != NULL)
		*FilePtr = '\0';	

#ifdef BUILD_ON_WINNT
    /*
     * Trim the string more better way...
     */
    CClientDC   dc(this);
	CRect	    ViewFileRect;
	CSize       FileNameSize;
	CWnd       *cWnd = GetDlgItem( IDC_SETFILENAME);
    INT         MaxChars;
    INT         cchString = lstrlen(FileName);

	cWnd->GetClientRect( &ViewFileRect);

	GetTextExtentExPoint( dc.GetSafeHdc(), FileName,
		cchString, ViewFileRect.Width(), &MaxChars, NULL ,&FileNameSize);

    if( cchString > MaxChars) {
        INT Chars = 0;

        FilePtr = FileName;
        while (Chars < (MaxChars-3)) {
            FilePtr++; Chars++;
        }

        for (; Chars < MaxChars; Chars++) {
            FileName[Chars] = TEXT('.');
        }
        FileName[Chars] = TEXT('\0');
    }
#else
	if( strlen((const char *)FileName) > 11){
		FileName[11] = '.';
		FileName[12] = '.';
		FileName[13] = '\0';
	}
#endif // BUILD_ON_WINNT

	return;
}

/****************************************/
/*	Adjust EUDC Font name		*/
/****************************************/
void CEudcDlg::AdjustFontName()
{
CClientDC	dc(this);
	CRect	ViewFontRect;
	CSize	FontNameSize, CharSize;
	int	i;
	HRESULT hresult;

	//*STRSAFE* 	lstrcpy(FontName, SelectEUDC.m_Font);
	hresult = StringCchCopy(FontName , ARRAYLEN(FontName),  SelectEUDC.m_Font);
	if (!SUCCEEDED(hresult))
	{
	   return ;
	}

	CWnd *cWnd = GetDlgItem( IDC_SETFONTNAME);
	cWnd->GetClientRect( &ViewFontRect);

	GetTextExtentPoint32( dc.GetSafeHdc(), FontName,
		lstrlen(FontName), &FontNameSize);

	if( ViewFontRect.Width() <= FontNameSize.cx){
		GetTextExtentPoint32( dc.GetSafeHdc(), TEXT("<<"), 2, &CharSize);
		i = ( ViewFontRect.Width() /CharSize.cx) * 2;
		FontName[i-2] = '.';
		FontName[i-1] = '.';
		FontName[i] = '\0';
	}
}

/****************************************/
/*	Change EUDC code range(CHINESE)	*/
/****************************************/
void CEudcDlg::OnSelchangeChinarange()
{
	int nIndex = m_ComboRange.GetCurSel();

	m_EditList.cRange = nIndex;
	m_EditList.SetEUDCCodeRange( nIndex);
	this->SetDlgItemText( IDC_CUSTOMCHR, TEXT(""));
	this->SetDlgItemText( IDC_CODECUST,  TEXT(""));
	m_EditList.Invalidate();
	m_EditList.UpdateWindow();

	CWnd *cWnd = this->GetDlgItem( IDC_CUSTOMEDIT);
	this->GotoDlgCtrl( cWnd);
}

void CEudcDlg::RegistRegFont()
{
	if( RegistDef.RegFlg){

        
        DWORD dwStart = GetTickCount();

        // Stop if this has taken too long
        while (1)
        {
            if( GetTickCount() - dwStart >= 1000 )
                break;
        }
        
		EnableEUDC(FALSE);
		RegistTypeFace( RegistDef.RegFont,  RegistDef.RegFile);
		EnableEUDC(TRUE);
	}
}

static DWORD aIds[] =
{
    IDC_CUSTOMEDIT, IDH_EUDC_SELLIST,
    IDC_COLUMNHEADING,  IDH_EUDC_SELLIST,
    IDC_CODECUST,   IDH_EUDC_SELCODE,
    IDC_CODE_NAME,  IDH_EUDC_SELCODE,
    IDC_CUSTOMFRAME,    IDH_EUDC_SELCODE,
    IDC_SETFONTNAME,IDH_EUDC_SELFONT,
    IDC_FONT_NAME, IDH_EUDC_SELFONT,
    IDC_CUSTOMFRAME3, IDH_EUDC_SELFONT,
    IDC_SETFILENAME,IDH_EUDC_SELFILE,
    IDC_FILE_NAME, IDH_EUDC_SELFILE,
    IDC_CUSTOMFRAME2, IDH_EUDC_SELFILE,
    IDC_CUSTOMCHR, IDH_EUDC_SELCHAR,
    IDC_STATICRANGE, IDH_EUDC_SELRANGE,
    IDC_CHINARANGE, IDH_EUDC_SELRANGE,
	0,0
};

static DWORD aIdsReg[] =
{
    IDC_CUSTOMEDIT, IDH_EUDC_REGLIST,
    IDC_COLUMNHEADING,  IDH_EUDC_REGLIST,
    IDC_CODECUST,   IDH_EUDC_REGCODE,
    IDC_CODE_NAME,  IDH_EUDC_REGCODE,
    IDC_CUSTOMFRAME,    IDH_EUDC_REGCODE,
    IDC_SETFONTNAME,IDH_EUDC_REGFONT,
    IDC_FONT_NAME, IDH_EUDC_REGFONT,
    IDC_CUSTOMFRAME3, IDH_EUDC_REGFONT,
    IDC_SETFILENAME,IDH_EUDC_REGFILE,
    IDC_FILE_NAME, IDH_EUDC_REGFILE,
    IDC_CUSTOMFRAME2, IDH_EUDC_REGFILE,
    IDC_CUSTOMCHR, IDH_EUDC_REGCHAR,
    IDC_STATICRANGE, IDH_EUDC_REGRANGE,
    IDC_CHINARANGE, IDH_EUDC_REGRANGE,
	0,0
};
/****************************************/
/*	Customdlg Window Procedure	*/
/****************************************/
LRESULT CEudcDlg::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	if( message == WM_VIEWUPDATE){
		m_ViewChar.Invalidate( FALSE);
		m_ViewChar.UpdateWindow();
		return(0);
	}
	if( message == WM_HELP){
		::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
			HelpPath, HELP_WM_HELP, (DWORD_PTR)(LPTSTR)(WorRFlag ? aIdsReg : aIds));
		return(0);
	}
	if( message == WM_CONTEXTMENU){
		::WinHelp((HWND)wParam, HelpPath,
			HELP_CONTEXTMENU, (DWORD_PTR)(LPTSTR) (WorRFlag ? aIdsReg : aIds));
		return(0);
	}
	return CDialog::WindowProc( message, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\eten.cpp ===
/*
 *	CWIN3.1 and ETEN format file i/o
 *
 * Copyright (c) 1997-1999 Microsoft Corporation.
 */

#include	"stdafx.h"
#pragma		pack(2)


#include	"extfunc.h"
#include	"eten.h"

#define		EUDCCODEBASE	((unsigned short)0xe000)
#define		ETENBANKID	0x8001
/*
static unsigned short  getsval(unsigned char  *s);
static unsigned long  getlval(unsigned char  *l);
static void  setsval(unsigned char  *m,unsigned short  s);
static void  setlval(unsigned char  *m,unsigned long  lval);
static int  readHdr(HANDLE fhdl,struct  ETENHEADER *hdr);
static int  updHdr(void);
static int  getETENBankID( HANDLE  fh, WORD  *BankID);
int  openETENBMP(TCHAR *path,int  md);
int  closeETENBMP(void);
static void  setIniHdr(struct  R_ETENHEADER *hdr,int  width,int  height);
int  createETENBMP(TCHAR *path,int  wid,int  hei);
int  getETENBMPInf(int  *n, int *ng, int  *wid,int  *hei, char *sign,WORD *bID);
int  readETENBMPRec(int  rec,LPBYTE buf,int  bufsiz,unsigned short  *code);
int  appendETENBMP(LPBYTE buf,unsigned short  code);
int  isETENBMP(TCHAR  *path);
*/
static HANDLE	bmpFh = INVALID_HANDLE_VALUE;
static int	openmd = -1;
static int	nChar;
static int	width, height;
static int	*recordBuf=0;
	int	uNum=0;
static int	*codep=0;
static char	UserFontSign[8];
static WORD	BankID;

static unsigned short
getsval( unsigned char *s)
{
	unsigned short	sval=0;
       
       if (!s)
       {
           return  sval;
       }

	sval = (unsigned short )*(s+1);
	sval <<=8;
	sval |= (unsigned short )*s;
	return sval;
}
static unsigned long
getlval( unsigned char *l)
{
	unsigned long	lval=0;
	int	i;

       if (!l)
       {
           return  lval;
       }

	lval = (unsigned long)*(l+3);
	for ( i=2; i>=0; i--) {
		lval<<=8;
		lval |=(unsigned long)*(l+i);
	}
	return lval;
}
static void
setsval( unsigned char *m, unsigned short s)
{
      if (!m)
      {
          return;
      }
	*m = (unsigned char)(s & 0xff);
	*(m+1) = (unsigned char)((s>>8) & 0xff);
}
static void
setlval( unsigned char *m, unsigned long lval)
{
	int	i;

      if (!m)
      {
          return;
      }

	for ( i=0; i<4; i++) {
		*m++ = (unsigned char)(lval & 0xff);
		lval>>=8;
	}
}
static int
readHdr( HANDLE fhdl, struct ETENHEADER *hdr)
{
struct R_ETENHEADER	rhdr;
DWORD nByte;
BOOL res;

       if (!hdr)
       {
           goto ERET;
       }
	res = ReadFile( fhdl, &rhdr, 256, &nByte, NULL);
	if (!res || nByte !=256)
		goto	ERET;

	memset( hdr, 0, sizeof(struct ETENHEADER));

	/* Set values to hdr */
	hdr->uHeaderSize = getsval( rhdr.uHeaderSize);
	memcpy( hdr->idUserFontSign, rhdr.idUserFontSign, 8);
	hdr->idMajor = rhdr.idMajor;
	hdr->idMinor = rhdr.idMinor;
	hdr->ulCharCount = getlval( rhdr.ulCharCount);
	hdr->uCharWidth = getsval( rhdr.uCharWidth);
	hdr->uCharHeight = getsval( rhdr.uCharHeight);
	hdr->cPatternSize = getlval( rhdr.cPatternSize);
	hdr->uchBankID = rhdr.uchBankID;
	hdr->idInternalBankID = getsval( rhdr.idInternalBankID);
	hdr->sFontInfo.uInfoSize = getsval(rhdr.sFontInfo.uInfoSize);
	hdr->sFontInfo.idCP = getsval(rhdr.sFontInfo.idCP);
	hdr->sFontInfo.idCharSet = rhdr.sFontInfo.idCharSet;
	hdr->sFontInfo.fbTypeFace = rhdr.sFontInfo.fbTypeFace;
	memcpy( hdr->sFontInfo.achFontName , rhdr.sFontInfo.achFontName,12);
	hdr->sFontInfo.ulCharDefine = getlval(rhdr.sFontInfo.ulCharDefine);
	hdr->sFontInfo.uCellWidth = getsval(rhdr.sFontInfo.uCellWidth);
	hdr->sFontInfo.uCellHeight = getsval(rhdr.sFontInfo.uCellHeight);
	hdr->sFontInfo.uCharHeight = getsval(rhdr.sFontInfo.uCharHeight);
	hdr->sFontInfo.uBaseLine = getsval(rhdr.sFontInfo.uBaseLine);
	hdr->sFontInfo.uUnderLine = getsval(rhdr.sFontInfo.uUnderLine);
	hdr->sFontInfo.uUnlnHeight = getsval(rhdr.sFontInfo.uUnlnHeight);
	hdr->sFontInfo.fchStrokeWeight = rhdr.sFontInfo.fchStrokeWeight;
	hdr->sFontInfo.fCharStyle = getsval(rhdr.sFontInfo.fCharStyle);
	hdr->sFontInfo.fbFontAttrib = rhdr.sFontInfo.fbFontAttrib;
	hdr->sFontInfo.ulCellWidthMax = getlval(rhdr.sFontInfo.ulCellWidthMax);
	hdr->sFontInfo.ulCellHeightMax= getlval(rhdr.sFontInfo.ulCellHeightMax);
	return 0;
ERET:
	return -1;
}
static int
updHdr( )
{
struct R_ETENHEADER	rhdr;
DWORD nByte;
BOOL res;
	
	if ( (long) SetFilePointer( bmpFh, 0L, NULL, FILE_BEGIN)!=0L)
		goto	ERET;
	res = ReadFile( bmpFh, &rhdr, 256, &nByte, NULL);
	if (!res || nByte !=256)
		goto	ERET;

	setlval( rhdr.ulCharCount, (long)nChar);
	setlval( rhdr.sFontInfo.ulCharDefine, (long)nChar);
	if ( (long) SetFilePointer( bmpFh, 0L, NULL, FILE_BEGIN)!=0L)
		goto	ERET;
	res = WriteFile(bmpFh, (char *)&rhdr, 256,&nByte, NULL);
	if (!res || nByte !=256)
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static int
getETENBankID( HANDLE fh, WORD *BankID)
{
struct R_CODEELEMENT	cElm;
	long	ofs;
	DWORD nByte;
	BOOL res;

       if (!BankID)
       {
            goto	ERET;
       }
	ofs = sizeof(struct R_ETENHEADER);
	if ((long) SetFilePointer( fh, ofs, NULL, FILE_BEGIN) != ofs)
		goto	ERET;

	res = ReadFile( fh, &cElm, sizeof(struct R_CODEELEMENT), &nByte, NULL);
	if (!res || nByte !=sizeof(struct R_CODEELEMENT))
		goto	ERET;
	*BankID = getsval( cElm.nBankID);
	return 0;
ERET:
	return -1;
}
/***
	recBuf
	+-------+
	| rec#	| E000
	+-------+
	|	| E001
	+-------+
	    |
	+-------+
	|	| maxUCode
	+-------+
****/
static int
scanETENBMP( int **recBuf, unsigned int maxUCode, int  nRec)
{
	long	ofs;
	int	recsiz, bmpsiz;
struct R_CODEELEMENT *bhd;
	int	rec;
	char	*rbuf;
	unsigned short	code;
	unsigned short	ucode;
	int	urec;
	int	*recp;
	DWORD nByte;
	BOOL res;
   
      if (!recBuf)
      {
         return -1;
      }
	
	recp = 0;
	rbuf = 0;
	if (  maxUCode < EUDCCODEBASE)
		return -1;
	else if ( nRec <=0)
		return -1;
	uNum = maxUCode - EUDCCODEBASE+1;
	if ( (codep = (int *)malloc( uNum*sizeof(int)))==0)
		goto	ERET;
		
	ofs = sizeof( struct R_ETENHEADER);
	if ( (long) SetFilePointer( bmpFh, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ERET;
	bmpsiz = (width+7)/8*height;
	recsiz =bmpsiz+sizeof (bhd);
	if ((rbuf = (char *)malloc( recsiz))==(char *)0)
		goto	ERET;
	for ( code = EUDCCODEBASE; code <= maxUCode; code++)
		codep[code-EUDCCODEBASE] = -1;
	bhd = (struct R_CODEELEMENT *)rbuf;

	for ( rec = 0; rec < nRec; rec++) {
		res = ReadFile( bmpFh, rbuf, (unsigned int)recsiz, &nByte, NULL);
		if (!res || nByte !=(unsigned int)recsiz)
			goto	ERET;
		code = getsval( bhd->nInternalCode);
		if( memcmp(UserFontSign, "CMEX_PTN", 8) ||
		    BankID != ETENBANKID){
			ucode = sjisToUniEUDC( code);
		}else	ucode = code;

		if( ucode > maxUCode || ucode < EUDCCODEBASE)
			continue;
		urec = (int)(ucode - EUDCCODEBASE);
		codep[urec] = rec;
	}
	free( rbuf);

	if ( (recp = (int *)malloc( nRec*sizeof(int)))==0)
		goto	ERET;

	*recBuf=recp;
	for ( rec=0; rec < uNum; rec++) {
		if ( codep[rec]>0)
			*recp++ = codep[rec];
	}
	return 0;
ERET:
	if ( codep)	free( codep);
	if ( recp)	free( recp);
	if ( rbuf)	free( rbuf);
	return -1;
}
int
openETENBMP( TCHAR *path, int md)
{
	HANDLE	fh=INVALID_HANDLE_VALUE;
struct ETENHEADER hdr;

       if (!path)
       {
           goto ERET;
       }
	makeUniCodeTbl();
	if ( md) {
		fh = CreateFile(path,
					GENERIC_READ | GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

		if ( fh == INVALID_HANDLE_VALUE)
			goto	ERET;
		bmpFh = fh;
		openmd = 1;
	}
	else {
		fh = CreateFile(path,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

		if ( fh == INVALID_HANDLE_VALUE)
			goto	ERET;
		bmpFh = fh;
		openmd = 0;
	}
	if (readHdr( fh, &hdr))
		goto	ERET;
	if (getETENBankID( fh, &BankID))
		goto 	ERET;

	nChar = (int)hdr.ulCharCount;
	width =  (int)hdr.uCharWidth;
	height =  (int)hdr.uCharHeight;
	memcpy((char *)UserFontSign, hdr.idUserFontSign, 8);

	if ( scanETENBMP( &recordBuf, getMaxUniCode(), nChar))
		goto	ERET;

	return 0;
ERET:
  if (fh != INVALID_HANDLE_VALUE)
    CloseHandle(fh);
	return -1;
}
int
closeETENBMP( )
{
	int	sts;
	if ( openmd)
		sts = updHdr();
	else	sts = 0;
	if ( bmpFh!=INVALID_HANDLE_VALUE)
		CloseHandle( bmpFh);
	if(recordBuf)	{
		free(recordBuf);
		recordBuf = 0;
	}
	if ( codep) {
		free(codep);
		codep = 0;
	}
	return sts;
}
static void
setIniHdr( struct R_ETENHEADER *hdr, int width, int height)
{
       if (!hdr)
       {
           return;
       }
	memset( hdr, 0, sizeof(struct R_ETENHEADER));
	setsval( hdr->uHeaderSize, sizeof(struct R_ETENHEADER));
	memcpy( hdr->idUserFontSign, "CWIN_PTN", 8);
	hdr->idMajor = 1;
	hdr->idMinor = 0;
	setsval( hdr->uCharWidth, (unsigned short)width);
	setsval( hdr->uCharHeight, (unsigned short)height);
	setlval( hdr->cPatternSize, (unsigned long)(((width+7)/8)*height));
	setsval( hdr->sFontInfo.uInfoSize,
			(unsigned short)sizeof(struct R_CFONTINFO));
	setsval( hdr->sFontInfo.idCP, 938);
	hdr->sFontInfo.idCharSet = (char)0x88;
	setsval( hdr->sFontInfo.uCellWidth, (unsigned short)width);
	setsval( hdr->sFontInfo.uCellHeight, (unsigned short)height);
	setsval( hdr->sFontInfo.uCharHeight, (unsigned short)height);
	setlval( hdr->sFontInfo.ulCellWidthMax, (unsigned long)width);
	setlval( hdr->sFontInfo.ulCellHeightMax, (unsigned long)height);
}
int
createETENBMP( TCHAR *path, int wid, int hei)
{
	HANDLE	fh=INVALID_HANDLE_VALUE;
struct R_ETENHEADER	hdr;
	DWORD nByte;
	BOOL res;

       if (!path)
       {
           goto ERET;
       }
	 fh = CreateFile(path,
					GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
					NULL,
					CREATE_ALWAYS,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fh == INVALID_HANDLE_VALUE)
		goto	ERET;

	width = wid;
	height = hei;
	setIniHdr( &hdr, width, height);
	res = WriteFile( fh, (char *)&hdr, sizeof(hdr), &nByte, NULL);
	if (!res || nByte !=sizeof(hdr))
		goto	ERET;
	bmpFh = fh;
	openmd = 1;
	nChar =0;
	return 0;
ERET:
  if (fh != INVALID_HANDLE_VALUE)
    CloseHandle(fh);
	return -1;
}
int
getETENBMPInf( int *nRec, int *nGlyph, int *wid, int *hei, char *sign,WORD *bID)
{
       if ((!nRec) || (!nGlyph) || (!wid) || (!hei) || (!sign) || (!bID))
       {
           return 0;
       }
	if ( bmpFh <0)	return -1;
	*nRec = uNum;
	*nGlyph = nChar;
	*wid = width;
	*hei = height;
	*bID = BankID;
	memcpy( sign, UserFontSign, 8);
	return 0;
}
int
readETENBMPRec( int rec, LPBYTE buf, int bufsiz, unsigned short *code)
{
	long	ofs;
	int	recsiz;
struct R_CODEELEMENT bhd;
	int	rdsiz;
	int	bWid, wWid;
	int	y, ylim;
	unsigned char	*rbuf;
	DWORD nByte;
	BOOL res;

       if ( (!code) || (!buf))
       {
           goto ERET;
       }
	bWid = (width+7)/8;
	wWid = (bWid+1)/2*2;
	recsiz = (width+7)/8*height;
	ofs = sizeof( struct R_ETENHEADER)+(long)(recsiz+sizeof (bhd))*rec;
	if ( (long) SetFilePointer( bmpFh, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ERET;
	res = ReadFile( bmpFh, &bhd, sizeof(bhd), &nByte, NULL);
	if (!res || nByte !=sizeof(bhd))
		goto	ERET;
	if ( bufsiz<recsiz)	rdsiz = bufsiz;
	else			rdsiz = recsiz;

	if ( bWid!=wWid) {
		BYTE	*src, *dst;
		if ((rbuf = (unsigned char *)malloc( recsiz))==(unsigned char *)0)
			goto	ERET;
		res = ReadFile( bmpFh, (char *)rbuf, (unsigned int)recsiz, &nByte, NULL);
		if (!res || nByte !=(unsigned int)recsiz) {
			free(rbuf);
			goto	ERET;
		}
		ylim = rdsiz / bWid;
		src = (LPBYTE)rbuf;
		dst = buf;
		memset( buf, 0xff, rdsiz);
		for ( y = 0; y < ylim; y++, src+=bWid, dst+=wWid)
			memcpy(dst , src , bWid);

		free( rbuf);
	}
	else {
		res = ReadFile( bmpFh, (char *)buf, (unsigned int)rdsiz, &nByte, NULL);
		if (!res || nByte !=(unsigned int)rdsiz)
			goto	ERET;
	}

	*code = getsval( bhd.nInternalCode);
	return 0;
ERET:
	return -1;
}
int
appendETENBMP( LPBYTE buf, unsigned short code)
{
struct R_CODEELEMENT bhd;
	int	bmpsiz;
	DWORD nByte;
	BOOL res;

       if (!buf)
       {
          goto ERET;
       }
	SetFilePointer( bmpFh, 0L, NULL, FILE_END);
	bmpsiz = (width+7)/8*height;
	setsval( bhd.nBankID, 1);
	setsval( bhd.nInternalCode, code);
	res = WriteFile( bmpFh, (LPBYTE)(&bhd), sizeof( bhd), &nByte, NULL);
	if (!res || nByte !=sizeof(bhd))
		goto	ERET;
	res = WriteFile( bmpFh, (LPBYTE)buf, (unsigned int)bmpsiz, &nByte, NULL);
	if (!res || nByte != (unsigned int)bmpsiz)
		goto	ERET;

	nChar++;
	return 0;
ERET:
	return -1;
}
int
isETENBMP(TCHAR *path)
{
struct ETENHEADER	hdr;
	HANDLE fhdl;
       
       if (!path)
       {
           return 0;
       }
	fhdl = CreateFile(path,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fhdl == INVALID_HANDLE_VALUE)
		return -1;
	if ( readHdr( fhdl, &hdr)) {
		CloseHandle( fhdl);
		return -1;
	}
	CloseHandle( fhdl);
	/* check Header size and keyWord*/
	if ( hdr.uHeaderSize != sizeof(struct R_ETENHEADER))
		goto	NO_ETEN;

	if ( memcmp(hdr.idUserFontSign, "CWIN_PTN", 8) &&
	     memcmp(hdr.idUserFontSign, "CMEX_PTN", 8))
		goto	NO_ETEN;
	return 1;
NO_ETEN:
	return 0;
}

int
ETENrecTbl( int **recTbl)
{
       if (recTbl)
       {
	   *recTbl=codep;
       }
	return 0;
}
/* EOF */
/* For test  +/
static int
dispHdr( struct ETENHEADER *hdr)
{
	printf("hdr->uHeaderSize= %d\n", hdr->uHeaderSize );
	printf("hdr->idMajor %d\n", hdr->idMajor );
	printf("hdr->idMinor  %d\n", hdr->idMinor );
	printf("hdr->ulCharCout  %ld\n", hdr->ulCharCount );
	printf("hdr->uCharWidth  %d\n", hdr->uCharWidth );
	printf(" hdr->uCharHeight  %d\n", hdr->uCharHeight );
	printf(" hdr->cPatternSize %d\n", hdr->cPatternSize);
	printf("hdr->uchBankID %d\n", hdr->uchBankID);
	printf("hdr->idInternalBankID %d\n", hdr->idInternalBankID);
	printf("hdr->sFontInfo.uInfoSize %d\n", hdr->sFontInfo.uInfoSize);
	printf("hdr->sFontInfo.idCP %d\n", hdr->sFontInfo.idCP);
	printf("hdr->sFontInfo.idCharSet %d\n", hdr->sFontInfo.idCharSet);
	printf("hdr->sFontInfo.fbTypeFace %d\n", hdr->sFontInfo.fbTypeFace);
	printf("hdr->sFontInfo.ulCharDefine %ld\n", hdr->sFontInfo.ulCharDefine);
	printf("hdr->sFontInfo.uCellWidth %d\n", hdr->sFontInfo.uCellWidth);
	printf("hdr->sFontInfo.uCellHeight %d\n", hdr->sFontInfo.uCellHeight);
	printf("hdr->sFontInfo.uCharHeight %d\n", hdr->sFontInfo.uCharHeight);
	printf("hdr->sFontInfo.uBaseLine %d\n", hdr->sFontInfo.uBaseLine);
	printf("hdr->sFontInfo.uUnderLine %d\n", hdr->sFontInfo.uUnderLine);
	printf("hdr->sFontInfo.uUnlnHeight %d\n", hdr->sFontInfo.uUnlnHeight);
	printf("hdr->sFontInfo.fchStrokeWeight %d\n", hdr->sFontInfo.fchStrokeWeight);
	printf("hdr->sFontInfo.fCharStyle %d\n", hdr->sFontInfo.fCharStyle);
	printf("hdr->sFontInfo.fbFontAttrib %d\n", hdr->sFontInfo.fbFontAttrib);
	printf("hdr->sFontInfo.ulCellWidthMax %ld\n", hdr->sFontInfo.ulCellWidthMax);
	printf("hdr->sFontInfo.ulCellHeightMax %ld\n", hdr->sFontInfo.ulCellHeightMax);
}
main( int argc, char *argv[])
{
	int	fh;
struct ETENHEADER hdr;
	fh = _lopen( argv[1], O_RDONLY | O_BINARY);
	
	readHdr( fh, &hdr);
	dispHdr( &hdr);
	_lclose(fh);
	exit(0);
}
/+ */
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\eudcedit.h ===
/**************************************************/
/*						                          */
/*						                          */
/*	EUDC EDITOR (MAIN HEADER)		              */
/*						                          */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"resource.h"
#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif
#include <htmlhelp.h>
#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))
/* EUDC editor defined windows message */
#define		WM_IMPORTGAGE	(WM_USER)	// start import
#define		WM_IMPORTSTOP	(WM_USER + 1)	// stop import
#define		WM_DUPLICATE	(WM_USER + 2)	// duplicate bitmap
#define		WM_VIEWUPDATE	(WM_USER + 3)	// view update

/* Country ID */
#define		EUDC_JPN	0x411		// Japanese
#define		EUDC_CHT	0x404		// Chinese (Taipei)
#define		EUDC_CHS	0x804		// Chinese (General)
#define		EUDC_HKG	0xc04		// Chinese (Hong Kong)
#define		EUDC_SIN	0x1004		// Chinese (Singapore)
#define		EUDC_KRW	0x412		// Korea   (Wansung)
#define   EUDC_HEBREW 0x40d
#define   EUDC_HINDI  0x439
#define   EUDC_TAMIL  0x449

/*
#ifdef BUILD_ON_WINNT
#define		EUDC_UNICODE	0xFFFF		// Unicode
#endif
*/

/* Smoothing level */
#define		SMOOTHLVL	1		// show outline
						// regist truetype
/* Code string size */
#define		MAX_CODE	5		// size of code string 

/* Tool */
#define		NOTSELECT	0		// "Not Selected"
#define		PEN		1		// "Pen" 
#define		SLOPE		2		// "Straight Line"
#define		RECTBAND	3		// "Hollow Ractangle"
#define		RECTFILL	4		// "Filled Rectangle"
#define		CIRCLE		5		// "Hollow Circle"
#define		CIRCLEFILL	6		// "Filled Circle"
#define		RECTCLIP	7		// "Rectangular Selection"
#define		BRUSH		8		// "Brush"
#define		FREEFORM	9		// "Freeform Selection"
#define		ERASER		10		// "Eraser"

/* Cursor */
#define		VERTICAL	0		// vertical arrow for resize 
#define		RIGHTSLOPE	1		// right arrow for resize
#define		LEFTSLOPE	2		// left arrow for resize
#define		HORIZONTAL	3		// horizontal arrow for resize
#define		ALLDIRECT	4		// all direct arrow for resize
#define		NUMRESIZE	5		// the number of resize cursor
#define		NUMTOOL		11		// the number of tool cursor

/* Color */
#define		COLOR_WHITE	RGB(255,255,255) // white
#define		COLOR_BLACK	RGB(  0,  0,  0) // black
#define		COLOR_LGRAY	RGB(192,192,192) // light Gray
#define		COLOR_DGRAY	RGB(128,128,128) // dark Gray
#define		COLOR_YELLO	RGB(255,255,  0) // yellow
#define		COLOR_BLUE	RGB(  0,  0,255) // blue
#define		COLOR_RED	RGB(255,  0,  0) // red

/* Bitmap size */
#define		MAX_BITMAPSIZE	256		// maximun of bitmap size
#define		MIN_BITMAPSIZE	16		// minimun of bitmap size
#define		DEF_BITMAPSIZE	64		// default of bitmap size

/* Selected font, file and code structure */
typedef struct _tagSELECTEUDC{
	TCHAR	m_Font[LF_FACESIZE];		// selected EUDC typeFace
	TCHAR	m_File[MAX_PATH];		// selected EUDC fileName
	TCHAR	m_FileTitle[MAX_PATH];		// selected EUDC fileTitle
	TCHAR	m_Code[MAX_CODE];		// selected EUDC code
	BOOL	m_FontTypeFlg;			// flag whether TTF or not
}SELECTEUDC;

/* EUDC coderange and languageID structure */
typedef struct _tagCOUNTRYINFO{
	INT	nRange;				// the number of code range
	USHORT	sRange[MAX_LEADBYTES];		// start of code range
	USHORT	eRange[MAX_LEADBYTES];		// end of code range
	INT	nLeadByte;			// the number of lead byte
	UCHAR	sLeadByte[MAX_LEADBYTES];	// start of lead byte
	UCHAR	eLeadByte[MAX_LEADBYTES];	// end of lead byte
	INT	nTralByte;			// the number of trail byte
	UCHAR	sTralByte[MAX_LEADBYTES];	// start of trail byte
	UCHAR	eTralByte[MAX_LEADBYTES];	// end of trail byte
    TCHAR   szForceFont[LF_FACESIZE];   // default font facename;

#ifdef BUILD_ON_WINNT
    BOOL bUnicodeMode;                      // user select unicode mode
	BOOL bOnlyUnicode;                      // We only have unicode 


/*  For CHS to keep the original trail byte range in order to dynamically 
 *  calculate trailbyte range with EUDC selection range.
 */
    INT nOrigTralByte;
	UCHAR	sOrigTralByte[MAX_LEADBYTES];	// start of trail byte
	UCHAR	eOrigTralByte[MAX_LEADBYTES];	// end of trail byte
#endif // BUILD_ON_WINNT

	INT	LangID;				// language ID
	INT	CharacterSet;			// Character Set
	INT	CurrentRange; 			// selected currently range 
}COUNTRYINFO;

/* DBCS coderange except EUDC */
/*typedef struct _tagDBCSINFO{
	INT	nLeadByte;			// the number of lead byte
	UCHAR	sLeadByte[MAX_LEADBYTES];	// start of lead byte
	UCHAR	eLeadByte[MAX_LEADBYTES];	// end of lead byte
	INT	nTralByte;			// the number of trail byte
	UCHAR	sTralByte[MAX_LEADBYTES];	// start of trail byte
	UCHAR	eTralByte[MAX_LEADBYTES];	// end of trail byte
}DBCSINFO;
*/



/* Global parameter */
extern HCURSOR	ToolCursor[NUMTOOL];		// tool cursor
extern HCURSOR	ArrowCursor[NUMRESIZE];		// resize cursor
extern INT	CAPTION_HEIGHT;			// height of caption
extern INT	BITMAP_HEIGHT;			// height of bitmap
extern INT	BITMAP_WIDTH;			// width of bitmap
extern DWORD	COLOR_GRID;			// grid color
extern DWORD	COLOR_CURVE;			// outline color
extern DWORD	COLOR_FITTING;			// bitmap color in show outline
extern DWORD	COLOR_FACE;			// Win95 3D Face System Color
extern DWORD	COLOR_SHADOW;			// Win95 3D Shadow Color	
extern DWORD	COLOR_HLIGHT;			// Win95 3D HighLight
extern DWORD	COLOR_WIN;			// Win95 Window Color
extern TCHAR	HelpPath[MAX_PATH];		// Help file path
extern TCHAR	ChmHelpPath[MAX_PATH];	// Help file path
extern TCHAR	FontPath[MAX_PATH];		// Font file path
extern CString	NotMemTtl;
extern CString	NotMemMsg;
extern SELECTEUDC	SelectEUDC;
extern COUNTRYINFO	CountryInfo;


class CEudcApp : public CWinApp
{
public:
	CEudcApp();
	virtual BOOL	InitInstance();
	virtual BOOL	ExitInstance();
	virtual BOOL	OnIdle(LONG lCount);

private:
	BOOL	CheckPrevInstance();
        void    DisableCUAS();
	BOOL	GetProfileText( LPRECT MainWndRect, UINT *MaxWndFlag);
	BOOL	GetCountryInfo();
	BOOL	GetCursorRes();
	BOOL	GetFilePath();

public:
	//{{AFX_MSG(CEudcApp)
	afx_msg void OnAppAbout();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef BUILD_ON_WINNT
//
// Hard codeded font face name
//
//
// Public API prototype definition.
//  (should be in wingdi.h)
//
extern "C" BOOL APIENTRY EnableEUDC(BOOL bEnable);
#endif // BUILD_ON_WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\eudclist.cpp ===
/**************************************************/
/*						                          */
/*						                          */
/*   EUDC Character List ( Japan, China, Korea)	  */
/*						                          */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"eudclist.h"
#include	"util.h"
#define STRSAFE_LIB
#include <strsafe.h>

#ifdef BUILD_ON_WINNT
#include    "extfunc.h"
#endif // BUILD_ON_WINNT


/* Matrics of Characterlist */
#define		NUM_CHAR	16	// Row  of matrics
#define		NUM_LINE	6	// Line of matrics

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE( CEudcList, CEdit)
BEGIN_MESSAGE_MAP( CEudcList, CEdit)
	//{{AFX_MSG_MAP( CEudcList)
	ON_WM_PAINT()
	ON_WM_VSCROLL()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_SETCURSOR()
	ON_WM_KEYDOWN()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_RBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

#ifdef BUILD_ON_WINNT
static CRect	rcColumnHead[NUM_CHAR];
#endif //BUILD_ON_WINNT
static CRect	rcEditChar[NUM_LINE][NUM_CHAR];
static CRect	rcEditCode[NUM_LINE];
static BYTE	ViewCode[NUM_LINE];
static BOOL   bHasGlyph;
#define EUDCCODEBASE    ((unsigned short)0xe000)

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CEudcList::CEudcList()
{
//	Initialize parameter( Japan, China and Korea)
	SetInitEUDCCodeRange( CountryInfo.CurrentRange);
	FocusFlag = FALSE;
}

/****************************************/
/*					*/
/*	Set coderange of EUDC		*/
/*					*/
/****************************************/
void
CEudcList::SetInitEUDCCodeRange(
int 	nIndex)
{
       if ( (nIndex >= ARRAYLEN(CountryInfo.sRange)) || (nIndex >= ARRAYLEN(CountryInfo.eRange)))
       {
           return;
       }
	m_Index = nIndex;
	EUDC_SCode = CountryInfo.sRange[m_Index];
	EUDC_ECode = CountryInfo.eRange[m_Index];

    EUDC_EView =(CountryInfo.eRange[m_Index] & 0xfff0) -(0x10*(NUM_LINE-1));
	if( SelectEUDC.m_Code[0] != '\0'){
		SelectCode = (WORD)Mytcstol(SelectEUDC.m_Code, (TCHAR **)0, 16);
		EUDC_SView = (WORD)Mytcstol(SelectEUDC.m_Code, (TCHAR **)0, 16);
		EUDC_SView &= 0xfff0;
		if( EUDC_EView <= EUDC_SView)
			EUDC_SView = EUDC_EView;
	}else{
		EUDC_SView = CountryInfo.sRange[m_Index] & 0xfff0;
		SelectCode = EUDC_SCode;
		
	}
	
#ifdef BUILD_ON_WINNT
    //In case of CHS, each range will have a different trail byte range
    //after user selects a new range, we have to correct them with
    //sOrigTralByte and eOrigTralByte and form new trail byte range.
    if (CountryInfo.LangID == EUDC_CHS && !CountryInfo.bUnicodeMode)
        CorrectTrailByteRange(m_Index);
#endif // BUILD_ON_WINNT

	LButtonPt.x = LButtonPt.y = 0;
	ScrlBarPos = (short)GetBarPosition( EUDC_SView);
	this->SetScrollPos( SB_VERT, ScrlBarPos, TRUE);
}

/****************************************/
/*					*/
/*	Set coderange of EUDC		*/
/*					*/
/****************************************/
void
CEudcList::SetEUDCCodeRange(
int 	nIndex)
{
       if ( (nIndex >= ARRAYLEN(CountryInfo.sRange)) || (nIndex >= ARRAYLEN(CountryInfo.eRange)))
       {
           return;
       }
	m_Index = nIndex;
	EUDC_SView = CountryInfo.sRange[m_Index] & 0xfff0;
    EUDC_EView =(CountryInfo.eRange[m_Index] & 0xfff0) -(0x10*(NUM_LINE-1));
	EUDC_SCode = CountryInfo.sRange[m_Index];
	EUDC_ECode = CountryInfo.eRange[m_Index];

#ifdef BUILD_ON_WINNT
    //In case of CHS, each range will have a different trail byte range
    //after user selects a new range, we have to correct them with
    //sOrigTralByte and eOrigTralByte and form new trail byte range.
    if (CountryInfo.LangID == EUDC_CHS && !CountryInfo.bUnicodeMode)
        CorrectTrailByteRange(m_Index);
#endif // BUILD_ON_WINNT

	SelectCode = (WORD)EUDC_SCode;
	LButtonPt.x = LButtonPt.y = 0;
	ScrlBarPos = (short)0;
	this->SetScrollPos( SB_VERT, ScrlBarPos, TRUE);
}


/****************************************/
/*					*/
/*	Destructor			*/
/*					*/
/****************************************/
CEudcList::~CEudcList()
{
    	SysFFont.DeleteObject();
   	EUDCFont.DeleteObject();
}

/****************************************/
/*					*/
/*	Correct it if code is illegal 	*/
/*					*/
/****************************************/
WORD
CEudcList::CorrectEUDCCode(
WORD 	Code,
BOOL 	UporDown)
{
COUNTRYINFO	Info;
	WORD	wCode;
	BYTE 	LByte, HByte;
	int	TralPos = 0;

	LByte = LOBYTE( Code);
	HByte = HIBYTE( Code);
	Info = CountryInfo;

    //decide code falls in which trail byte range
	for( int i = 0; i < Info.nTralByte; i++){
		if( LByte >= (Info.sTralByte[i] & 0xf0) &&
		    LByte <= (Info.eTralByte[i] & 0xf0)){
		    	goto RET;
		}else if( LByte < (Info.sTralByte[i] & 0xf0)){
			TralPos = i;
			break;
		}else	TralPos = i+1;
	}

#ifdef BUILD_ON_WINNT
    // If we are going up on the code range, make the code in the first
    // first line of next valid trailbyte. Otherwise make the code in
    // the last line the preivous valid range.
	if( UporDown){
		if( TralPos == Info.nTralByte){
            TralPos =0;
			HByte += 0x1;
		}
        LByte = Info.sTralByte[TralPos] & 0xf0;
	}else{
		if( TralPos ==0 ){
			HByte -= 0x1;
            TralPos = Info.nTralByte;
        }
	    LByte = Info.eTralByte[TralPos-1] & 0xf0;
	}
#else
	if( UporDown)
		if( TralPos == Info.nTralByte){
			LByte = (Info.sTralByte[0] & 0xf0);
			HByte += 0x1;
		}else 	LByte = (Info.sTralByte[TralPos] & 0xf0);
	else{
		if( !TralPos){
			LByte = (Info.eTralByte[Info.nTralByte-1] & 0xf0);
			HByte -= 0x1;
		}else	LByte = (Info.eTralByte[TralPos-1] & 0xf0);
	}
#endif // BUILD_ON_WINNT

RET:
	wCode = MAKEWORD( LByte, HByte);
	return wCode;
}

/****************************************/
/*					*/
/*	Get position of scrollbar	*/
/*					*/		
/****************************************/
#ifdef BUILD_ON_WINNT
int
CEudcList::GetBarPosition(
WORD 	Code)
{
COUNTRYINFO	Info;
	WORD 	NumPage=0, NumCode=0;
	BYTE	Space[MAX_LEADBYTES];
	int	TotalSpace=0,TralPos=0;
	int	Err;
    BOOL ValidCode=FALSE;

	Info = CountryInfo;
	NumPage = HIBYTE( Code) - HIBYTE( EUDC_SCode);

    // Calculate each code space block for each trail byte range
    // and decide how many of each we count.

    /* space before first trailbyte range */
	Space[0] = ( Info.sTralByte[0] & 0xf0);
	for( int i = 1; i < Info.nTralByte; i++){
		Space[i] = (( Info.sTralByte[i]   & 0xf0)
			 -  ( Info.eTralByte[i-1] & 0xf0) - 0x10);
	}

    /* space after last trailbyte range */
	Space[i] = (0xff - Info.eTralByte[Info.nTralByte-1]) & 0xf0;

    for (i = 0; i < Info.nTralByte; i++)
        if( LOBYTE( Code) >= (Info.sTralByte[i] & 0xf0) &&
            LOBYTE( Code) <= (Info.eTralByte[i] & 0xff)){
            ValidCode=TRUE; //within our trail byte range.
            TralPos=i;
            break;
        }

    if (!ValidCode)
        return(0);  //not within our trail byte range.

    for (i = 0; i < Info.nTralByte; i++){
        if (Info.sTralByte[TralPos] >  LOBYTE( EUDC_SCode )){
            if((Info.sTralByte[i])  > LOBYTE(EUDC_SCode)  && i <= TralPos)
                TotalSpace += Space[i] * (NumPage + 1);
            else
                TotalSpace += Space[i] * NumPage ;
        }else{
            if((Info.sTralByte[i] & 0xf0) < LOBYTE(EUDC_SCode) && i > TralPos)
                TotalSpace += Space[i] * (NumPage - 1);
            else
                TotalSpace += Space[i] * NumPage ;
        }

	}
    TotalSpace += Space[i] * NumPage;

    Err = EUDC_SCode & 0x000f;
	NumCode = Code - EUDC_SCode - TotalSpace + Err;
	return( NumCode /NUM_CHAR);
}
#else
int
CEudcList::GetBarPosition(
WORD 	Code)
{
COUNTRYINFO	Info;
	WORD 	NumPage, NumCode;
	BYTE	Space[MAX_LEADBYTES];
	int	LoSpace, HiSpace;
	int	Err;

	Info = CountryInfo;
	NumPage = HIBYTE( Code) - HIBYTE( EUDC_SCode);
	Space[0] = ( Info.sTralByte[0] & 0xf0);
	Space[1] = 0x00;
	for( int i = 1; i < Info.nTralByte; i++){
		Space[i] = (( Info.sTralByte[i]   & 0xf0)
			 -  ( Info.eTralByte[i-1] & 0xf0) - 0x10);
	}

	for( i = 0; i < Info.nTralByte; i++){
		if( LOBYTE( Code) >= (Info.sTralByte[i] & 0xf0) &&
		    LOBYTE( Code) <= (Info.eTralByte[i] & 0xff)){
		    	if( LOBYTE( EUDC_SCode) > Info.sTralByte[0]){
				LoSpace = ( Space[0] * NumPage);
				HiSpace = ( Space[1] * (i + NumPage - 1));
			}else{
				LoSpace = ( Space[0] * NumPage);
				HiSpace = ( Space[1] * (i + NumPage));
			}
			Err = EUDC_SCode & 0x000f;
			NumCode = Code - EUDC_SCode - LoSpace - HiSpace + Err;
			break;
		}
	}
	return( NumCode /NUM_CHAR);
}
#endif // BUILD_ON_WINNT

/****************************************/
/*					*/
/*	Calculate bar pos from code	*/
/*					*/
/****************************************/
WORD
CEudcList::GetCodeScrPos(
int 	Pos)
{
	WORD	i;
	WORD	Code = 0;
	WORD	NumLine  = 0;
	WORD	PNumLine = 0;

	if( !Pos)
        	return( EUDC_SCode & 0xfff0);
#ifdef BUILD_ON_WINNT
    // we dont't need to go through each char, instead we can examine each
    // line to make this faster
	for( i = EUDC_SCode; i <= EUDC_ECode;  i+= NUM_CHAR){
#else
	for( i = EUDC_SCode; i <= EUDC_ECode;  ++i){
#endif // BUILD_ON_WINNT
    		NumLine = (WORD)GetBarPosition( i);
        	if( NumLine >= Pos){
        		NumLine = PNumLine;
            		break;
        	}
        	PNumLine = NumLine;
   	}
	Code = i;
	Pos -= NumLine;
	Code &= 0xfff0;

	return Code;
}

#define	FIX_SPACE	6
#define	LINEWIDTH	4
/****************************************/
/*					*/
/*	Calcurate character size 	*/
/*					*/
/****************************************/
void
CEudcList::CalcCharSize()
{
	TCHAR	Dummy[] = TEXT("FA40");
	int	Sx;
	int	OldMode;

	CClientDC	dc( this);

	this->GetClientRect( &EditListRect);
	OldMode = dc.SetMapMode( MM_TEXT);

	CFont	*OldFont = dc.SelectObject( &SysFFont);
	GetTextExtentPoint32( dc.GetSafeHdc(), Dummy, 4, &FixSize);
	FixSize.cx += FIX_SPACE;
	dc.SelectObject( OldFont);

	CharSize.cy = ( EditListRect.Height()
		- (NUM_LINE-1)*LINEWIDTH - 2) / NUM_LINE;
	CharSize.cx = ( EditListRect.Width()
		- FixSize.cx - 2 - (NUM_CHAR*LINEWIDTH)) / NUM_CHAR;

	for( int i = 0; i < NUM_LINE; i++){
		rcEditCode[i].left   = 1;
		rcEditCode[i].top    = 1 + i*( CharSize.cy + LINEWIDTH);
		rcEditCode[i].right  = rcEditCode[i].left + FixSize.cx;
		rcEditCode[i].bottom = rcEditCode[i].top  + CharSize.cy;
		Sx = rcEditCode[i].right + LINEWIDTH;
		for( int j = 0; j < NUM_CHAR; j++){
			rcEditChar[i][j].left   = Sx +j*(CharSize.cx+LINEWIDTH);
			rcEditChar[i][j].top    = rcEditCode[i].top;
			rcEditChar[i][j].right  = rcEditChar[i][j].left
						+ CharSize.cx;
			rcEditChar[i][j].bottom = rcEditChar[i][j].top
						+ CharSize.cy;
		}
	}
#ifdef BUILD_ON_WINNT
	for( int j = 0; j < NUM_CHAR; j++){
		rcColumnHead[j].left   = Sx +j*(CharSize.cx+LINEWIDTH);
		rcColumnHead[j].top    = 1;
		rcColumnHead[j].right  = rcColumnHead[j].left + CharSize.cx;
		rcColumnHead[j].bottom = 1 + FixSize.cy;
    }
#endif //BUILD_ON_WINNT
	dc.SetMapMode( MM_TEXT);
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void
CEudcList::OnPaint()
{
	register int	i, j, k;
	WORD    Code;
	CFont	*OldFont;
	BYTE    Glyph[800];
	BOOL    bGlyph = FALSE;
	HRESULT hresult;

	CPaintDC	dc( this);
	int BottomCode = GetBarPosition((WORD)EUDC_EView);
	SetScrollRange( SB_VERT, 0, BottomCode, FALSE);
	this->SetScrollPos( SB_VERT, ScrlBarPos, TRUE);

	Code = EUDC_SView;
	int OldMapMode = dc.SetMapMode( MM_TEXT);
	dc.SetViewportOrg( 0, 0);
	OldFont = dc.SelectObject( &SysFFont);

	//
	// access *.euf to set bits in the array (800 * 8 = 6400)
	// to indicate a char has a glyph
	//
	bGlyph = GetGlyph(SelectEUDC.m_File, Glyph);
	for( i = 0; i < NUM_LINE; i++){
		BYTE	CodeArray[10];
		int	xOffset, yOffset;

//	Check character code
		dc.SelectObject( &SysFFont);
		Code = CorrectEUDCCode( Code, TRUE);
		//*STRSAFE* 		wsprintf((LPTSTR)CodeArray, TEXT("%04X"), Code);
		hresult = StringCbPrintf((LPTSTR)CodeArray , sizeof(CodeArray),  TEXT("%04X"), Code);
		if (!SUCCEEDED(hresult))
		{
		   return ;
		}

		dc.SetBkColor( COLOR_FACE);
		dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT)); // COLOR_BLACK);
		if( rcEditChar[i][0].Height() > FixSize.cy){
			yOffset = ( rcEditChar[i][0].Height() - FixSize.cy) /2;
		}else	yOffset = 0;

    ExtTextOut( dc.GetSafeHdc(), rcEditCode[i].left,
				rcEditCode[i].top  + yOffset,
				ETO_OPAQUE, &rcEditCode[i],
				(LPCTSTR)CodeArray, 4, NULL);

		dc.SelectObject( &EUDCFont);
		for( j = 0; j < NUM_CHAR; j++,Code++){
			BYTE	sOffset;
			CSize	cSize;
			BOOL	flg;
			int	wLength;

            //
            // see if the character has a glyph
            //
            bHasGlyph = TRUE;
            if(bGlyph == TRUE)
            {
                WORD  wIndex;
								if (CountryInfo.bUnicodeMode)
									wIndex = Code - EUDCCODEBASE;
								else
								{
									CHAR  pchar[3];
									WCHAR wpchar[2];
									pchar[0] = HIBYTE(Code);
									pchar[1] = LOBYTE(Code);
									pchar[2] = 0;
									MultiByteToWideChar(CP_ACP, 0, pchar, 2, wpchar, 1);
									wIndex = wpchar[0] - EUDCCODEBASE;
								}
                if((Glyph[wIndex>>3] & (0x80>>(wIndex%8))) == 0)
                    bHasGlyph = FALSE;
            }
            //fix for FontIsLinked
            else
              bHasGlyph = FALSE;
            //

			flg = FALSE;
			sOffset = LOBYTE( Code);
			for( k = 0; k < CountryInfo.nTralByte; k++){
				if( sOffset >= CountryInfo.sTralByte[k] &&
				    sOffset <= CountryInfo.eTralByte[k]){
				    	flg = TRUE;
				}
			}
			if((Code < CountryInfo.sRange[cRange])
			||(Code > CountryInfo.eRange[cRange]))
				flg = FALSE;


			if( !flg) 	continue;

			if (CountryInfo.bUnicodeMode){
                CodeArray[1] = HIBYTE(Code);
                CodeArray[0] = LOBYTE(Code);
                wLength = 1;
      }
			else{
                CodeArray[0] = HIBYTE(Code);
                CodeArray[1] = LOBYTE(Code);
								wLength = 2;
      }
    	CodeArray[2] = (BYTE)'\0';
			
			BOOL	PtIn;

			if(( rcEditChar[i][j].PtInRect( LButtonPt) ||
			     SelectCode == Code) && wLength != 0){
				TCHAR	CodeNum[10];

//				If character is selected by left clickking ,
//				Put it on dialog.
				PtIn = TRUE;
				SelectCode = Code;
				dc.SetBkColor(COLOR_FACE);
				dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT)); // COLOR_BLACK);
				//*STRSAFE* 				wsprintf(CodeNum, TEXT("%04X"),Code);
				hresult = StringCchPrintf(CodeNum , ARRAYLEN(CodeNum),  TEXT("%04X"),Code);
				if (!SUCCEEDED(hresult))
				{
				   return ;
				}

				GetParent()->SetDlgItemText(IDC_CODECUST,CodeNum);

        if (CountryInfo.bUnicodeMode)
        {
           //*STRSAFE* lstrcpyW((WCHAR *)ViewCode, (WCHAR *)CodeArray);
           hresult = StringCbCopyW((WCHAR *)ViewCode, sizeof(ViewCode), (WCHAR *)CodeArray);
           if (!SUCCEEDED(hresult))
	   {
		   return ;
	   }           
        }
        else
        {
          //*STRSAFE*  lstrcpyA((CHAR *)ViewCode, (CHAR *)CodeArray);
          hresult = StringCbCopyA((CHAR *)ViewCode, sizeof(ViewCode), (CHAR *)CodeArray);
          if (!SUCCEEDED(hresult))
	   {
		   return ;
	   }      
          
        }
				GetParent()->SendMessage( WM_VIEWUPDATE, 0, 0);
			}else{
				PtIn = FALSE;
				dc.SetBkColor( COLOR_FACE);
				dc.SetTextColor( GetSysColor(COLOR_WINDOWTEXT));  //COLOR_BLACK);
			}

      if (CountryInfo.bUnicodeMode)
			  GetTextExtentPoint32W( dc.GetSafeHdc(), (LPCWSTR)CodeArray, wLength, &cSize);
      else
    		GetTextExtentPoint32A( dc.GetSafeHdc(),	(LPCSTR)CodeArray, wLength, &cSize);

			if( rcEditChar[i][j].Width() > cSize.cx){
				xOffset = rcEditChar[i][j].Width() - cSize.cx;
				xOffset /= 2;
			}else	xOffset = 0;

			if( rcEditChar[i][j].Height() > cSize.cy){
				yOffset = rcEditChar[i][j].Height() - cSize.cy;
				yOffset /= 2;
			}else	yOffset = 0;

            if(bHasGlyph == TRUE)
            {
                if (CountryInfo.bUnicodeMode)
                {
#ifdef UNICODE
                    ExtTextOutW(dc.GetSafeHdc(),rcEditChar[i][j].left + xOffset,
                        rcEditChar[i][j].top + yOffset, ETO_OPAQUE,
                        &rcEditChar[i][j], (LPCWSTR)CodeArray, wLength, NULL);
		
#else
                    CHAR ViewTmp[2];
                    wLength = WideCharToMultiByte(CP_ACP, 0, (LPWSTR) CodeArray, 1, ViewTmp, 2, NULL, NULL);
                    ExtTextOutA(dc.GetSafeHdc(),rcEditChar[i][j].left + xOffset,
                        rcEditChar[i][j].top + yOffset, ETO_OPAQUE,
                        &rcEditChar[i][j], (LPCSTR)ViewTmp, wLength, NULL);
#endif
                }
                else
                {
                    ExtTextOutA(dc.GetSafeHdc(), rcEditChar[i][j].left + xOffset,
                        rcEditChar[i][j].top + yOffset, ETO_OPAQUE,
                        &rcEditChar[i][j], (LPCSTR)CodeArray,
                        wLength, NULL);
                }
            }
			DrawConcave( &dc, rcEditChar[i][j], PtIn);
		}
	}
	dc.SetMapMode( OldMapMode);
	dc.SelectObject( OldFont);

	LButtonPt.x = LButtonPt.y = 0;
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_VSCROLL"		*/
/*					*/
/****************************************/
void
CEudcList::OnVScroll(
UINT 	nSBCode,
UINT 	nPos,
CScrollBar* pScrollBar)
{
	int	MoveScr;
	BOOL	ThumbTrkFlag;
	BOOL	ThumbPosFlag;

	MoveScr = 0;
	ThumbTrkFlag = FALSE;
	ThumbPosFlag = FALSE;
	BarRange = GetBarPosition((WORD)EUDC_EView);
	SetScrollRange( SB_VERT, 0, BarRange, FALSE);
	switch( nSBCode)
	{
		case SB_LINEDOWN:
			if(( EUDC_SView + NUM_CHAR) <= EUDC_EView){
				MoveScr =  0 - (CharSize.cy + LINEWIDTH);
				EUDC_SView += NUM_CHAR;
				EUDC_SView  = CorrectEUDCCode(EUDC_SView,TRUE);
				ScrlBarPos = (short)GetBarPosition( EUDC_SView);
			}
			break;

		case SB_LINEUP:
			if(( EUDC_SView - NUM_CHAR) >= ( EUDC_SCode & 0xfff0)){
				MoveScr = CharSize.cy + LINEWIDTH;
				EUDC_SView -= NUM_CHAR;
				EUDC_SView = CorrectEUDCCode(EUDC_SView,FALSE);
				ScrlBarPos = (short)GetBarPosition( EUDC_SView);
			}
			break;

		case SB_PAGEDOWN:
			if(( EUDC_SView + NUM_CHAR*NUM_LINE) <= EUDC_EView){
				MoveScr = ( 0-(CharSize.cy+LINEWIDTH))*NUM_LINE;
				ScrlBarPos = (short)GetBarPosition( EUDC_SView);
				ScrlBarPos += NUM_LINE;
				EUDC_SView = GetCodeScrPos( ScrlBarPos);
			}else{
				MoveScr = ( 0-(CharSize.cy+LINEWIDTH))*NUM_LINE;
				EUDC_SView = EUDC_EView;
				ScrlBarPos = (short)GetBarPosition( EUDC_SView);	
			}
			break;

		case SB_PAGEUP:
			if(( EUDC_SView - NUM_CHAR*NUM_LINE)
				>= ( EUDC_SCode & 0xfff0)){
				MoveScr = (CharSize.cy + LINEWIDTH)*NUM_LINE;
				ScrlBarPos = (short)GetBarPosition( EUDC_SView);
				ScrlBarPos -= NUM_LINE;
				EUDC_SView = GetCodeScrPos( ScrlBarPos);
			}else{
				MoveScr = (CharSize.cy + LINEWIDTH)*NUM_LINE;
				EUDC_SView = (EUDC_SCode & 0xfff0);
				ScrlBarPos = (short)GetBarPosition( EUDC_SView);
			}
			break;

		case SB_TOP:
			EUDC_SView = ( EUDC_SCode & 0xfff0);
			ScrlBarPos = 0;
			break;

		case SB_BOTTOM:
			EUDC_SView = EUDC_EView;
			ScrlBarPos = (short)BarRange;
			break;

		case SB_THUMBPOSITION:
			ThumbPosFlag = TRUE;
			ScrlBarPos = (short)nPos;
			EUDC_SView = GetCodeScrPos( nPos);
			break;

		case SB_THUMBTRACK:
			ThumbTrkFlag = TRUE;
			break;

		default:
			break;
	}

	if( abs( MoveScr) < (CharSize.cy + LINEWIDTH)*NUM_LINE &&
		abs( MoveScr) > 0 && !ThumbTrkFlag){
		CRect	ScrllRect;
		CRect	ClintRect;

		GetClientRect( &ClintRect);
		ScrllRect.CopyRect( &ClintRect);
		if( MoveScr < 0){
			ClintRect.top = 0 - MoveScr;
			this->ScrollWindow( 0, MoveScr, &ClintRect, NULL);
			ScrllRect.top = ( 0 - MoveScr)*(NUM_LINE-1);			
		}else{
			ClintRect.top = LINEWIDTH;
			ClintRect.bottom = MoveScr*(NUM_LINE - 1);
			this->ScrollWindow( 0, MoveScr, &ClintRect, NULL);
			ScrllRect.top = 0;
			ScrllRect.bottom = ScrllRect.top + MoveScr;
		}
		this->InvalidateRect( &ScrllRect, FALSE);
	}else if(!ThumbTrkFlag && ( MoveScr || ThumbPosFlag)){
		this->Invalidate( TRUE);
	}
	this->SetScrollPos( SB_VERT, ScrlBarPos, TRUE);
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_LBUTTONDOWN"	*/
/*					*/
/****************************************/
void
CEudcList::OnLButtonDown(
UINT 	nFlags,
CPoint 	point)
{
	CRect	test;
	BOOL	PtIn;
unsigned int	i, j;

	PtIn = FALSE;
	this->SetFocus();
	for( i = 0; i < NUM_LINE; i++){
		for( j = 0; j < NUM_CHAR; j++){
			if( rcEditChar[i][j].PtInRect( point)){
				if( IsCorrectChar( i, j))
					PtIn = TRUE;
				break;
			}
		}
	}
	if( !PtIn){
		MessageBeep((UINT)-1);
		return;
	}

	LButtonPt = point;
	SearchSelectPosition();
	SelectCode = 0;


	for( i = 0; i < NUM_LINE; i++){
		for( j = 0; j < NUM_CHAR; j++){
			if( rcEditChar[i][j].PtInRect( LButtonPt)){

				test.SetRect( rcEditChar[i][j].left - 2,
						rcEditChar[i][j].top - 2,
						rcEditChar[i][j].right + 2,
						rcEditChar[i][j].bottom + 2);

				this->InvalidateRect( &test, FALSE);

				break;
			}
		}
	}


	this->UpdateWindow();

}

/****************************************/
/*					*/
/*	MESSAGE	"WM_LBUTTONDBLCLK"	*/
/*					*/
/****************************************/
void
CEudcList::OnLButtonDblClk(
UINT 	nFlags,
CPoint 	point)
{
	BOOL 	PtIn;
unsigned int	i, j;

	LButtonPt = point;
	this->Invalidate( FALSE);
	this->UpdateWindow();

	PtIn = FALSE;
	this->SetFocus();
	for( i = 0; i < NUM_LINE; i++){
		for( j = 0; j < NUM_CHAR; j++){
			if( rcEditChar[i][j].PtInRect( point)){
				if( IsCorrectChar( i, j))
					PtIn = TRUE;
				break;
			}
		}
	}
	if( !PtIn){
		MessageBeep((UINT)-1);
		return;
	}else{
		GetParent()->PostMessage( WM_COMMAND, IDOK, 0L);
	}
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_SETCURSOR"		*/
/*					*/
/****************************************/
BOOL
CEudcList::OnSetCursor(
CWnd* 	pWnd,
UINT 	nHitTest,
UINT 	message)
{
	::SetCursor( AfxGetApp()->LoadStandardCursor(IDC_ARROW));
	return TRUE;
}

/****************************************/
/*					*/
/*	Draw ConcaveRectangle		*/
/*					*/
/****************************************/
void
CEudcList::DrawConcave(
CDC 	*dc,
CRect 	rect,
BOOL 	PtIn)
{
	CBrush	ConBrush, *OldBrush;
	CRect	Rt, Rf;

       if (!dc)
       {
          return;
       }
	Rt.SetRect( rect.left-1, rect.top-1, rect.right+1, rect.bottom+1);
	Rf.CopyRect( &rect);

	if( !PtIn){
		ConBrush.CreateSolidBrush( COLOR_HLIGHT);
		OldBrush = dc->SelectObject( &ConBrush);
		dc->PatBlt( Rt.left, Rt.top, Rt.Width(), 1, PATCOPY);
		dc->PatBlt( Rt.left, Rt.top, 1, Rt.Height(), PATCOPY);
		dc->SelectObject( OldBrush);
		ConBrush.DeleteObject();

		ConBrush.CreateSolidBrush( COLOR_SHADOW);
		OldBrush = dc->SelectObject( &ConBrush);
		dc->PatBlt( Rt.left, Rt.bottom, Rt.Width(), 1, PATCOPY);
		dc->PatBlt( Rt.right, Rt.top, 1, Rt.Height()+1, PATCOPY);
		dc->SelectObject( OldBrush);
		ConBrush.DeleteObject();

		if( FocusFlag){
			CBrush	fBrush;
			CPen	fPen, *OldPen;

			fBrush.CreateStockObject( NULL_BRUSH);
			fPen.CreatePen( PS_SOLID, 1, COLOR_FACE);
			OldBrush = dc->SelectObject( &fBrush);
			OldPen   = dc->SelectObject( &fPen);
			dc->Rectangle( &Rf);
			dc->SelectObject( OldBrush);
			dc->SelectObject( OldPen);
			fBrush.DeleteObject();
			fPen.DeleteObject();
		}
	}else{
		ConBrush.CreateSolidBrush( COLOR_SHADOW);
		OldBrush = dc->SelectObject( &ConBrush);
	        dc->PatBlt( Rt.left, Rt.top, Rt.Width(), 1, PATCOPY);
		dc->PatBlt( Rt.left, Rt.top, 1, Rt.Height(), PATCOPY);
		dc->SelectObject( OldBrush);
		ConBrush.DeleteObject();

		ConBrush.CreateSolidBrush( COLOR_HLIGHT);
		OldBrush = dc->SelectObject( &ConBrush);
		dc->PatBlt( Rt.left, Rt.bottom, Rt.Width(), 1, PATCOPY);
		dc->PatBlt( Rt.right, Rt.top, 1, Rt.Height()+1, PATCOPY);
		dc->SelectObject( OldBrush);
		ConBrush.DeleteObject();

		if( FocusFlag){
			CBrush	fBrush;
			CPen	fPen, *OldPen;

			fBrush.CreateStockObject( NULL_BRUSH);
			fPen.CreatePen( PS_SOLID, 1, COLOR_SHADOW);
			OldBrush = dc->SelectObject( &fBrush);
			OldPen   = dc->SelectObject( &fPen);
			dc->Rectangle( &Rf);
			dc->SelectObject( OldBrush);
			dc->SelectObject( OldPen);
			fBrush.DeleteObject();
			fPen.DeleteObject();
		}
	}
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_KEYDOWN"		*/
/*					*/
/****************************************/
void
CEudcList::OnKeyDown(
UINT 	nChar,
UINT	nRepCnt,
UINT 	nFlags)
{
	int	sPos;
	int	ePos;
#ifdef BUILD_ON_WINNT
    int i;
	WORD	TmpCode;
#endif // BUILD_ON_WINNT

	if( nChar == VK_DOWN  || nChar == VK_UP  ||
	    nChar == VK_RIGHT || nChar == VK_LEFT){
		sPos = GetBarPosition( EUDC_SView);
		ePos = GetBarPosition( SelectCode);
		if( ePos - sPos >= NUM_LINE || ePos < sPos){
			EUDC_SView = SelectCode & 0xfff0;
			ScrlBarPos = (short)GetBarPosition( EUDC_SView);
			this->Invalidate(FALSE);
			this->UpdateWindow();
		}

		switch( nChar){

		case VK_DOWN:
			if( SelectCode + NUM_CHAR > EUDC_ECode)
				break;
#ifdef BUILD_ON_WINNT
			TmpCode = SelectCode + NUM_CHAR;
			TmpCode = CorrectEUDCCodeKey( TmpCode, NUM_CHAR, TRUE);
			sPos = GetBarPosition( EUDC_SView);
			ePos = GetBarPosition( TmpCode);
			for (i=0;i <= ePos - sPos - NUM_LINE; i++){
#else
			if( ePos - sPos >= NUM_LINE - 1){
#endif // BUILD_ON_WINNT
				this->SendMessage( WM_VSCROLL, SB_LINEDOWN, 0);
			}
			SearchSelectPosition();
			SelectCode += NUM_CHAR;
			SelectCode = CorrectEUDCCodeKey( SelectCode,
							NUM_CHAR, TRUE);
			SearchSelectPosition();
			this->UpdateWindow();
			break;

		case VK_UP:
			if( SelectCode - NUM_CHAR < EUDC_SCode)
				break;
#ifdef BUILD_ON_WINNT
			TmpCode = SelectCode - NUM_CHAR;
			TmpCode = CorrectEUDCCodeKey( TmpCode, NUM_CHAR, FALSE);
			sPos = GetBarPosition( EUDC_SView);
			ePos = GetBarPosition( TmpCode);
			for ( i=0; i < sPos - ePos; i++){
#else
			if( SelectCode - NUM_CHAR < EUDC_SView){
#endif // BUILD_ON_WINNT
				this->SendMessage( WM_VSCROLL, SB_LINEUP, 0);
			}

			SearchSelectPosition();
			SelectCode -= NUM_CHAR;
			SelectCode = CorrectEUDCCodeKey( SelectCode,
							NUM_CHAR, FALSE);
			SearchSelectPosition();
			this->UpdateWindow();
			break;

		case VK_LEFT:
			if( SelectCode - 1 < EUDC_SCode)
				break;
#ifdef BUILD_ON_WINNT
            TmpCode = SelectCode - 1;
            TmpCode = CorrectEUDCCodeKey( TmpCode, 1, FALSE);
            sPos = GetBarPosition( EUDC_SView);
            ePos = GetBarPosition( TmpCode);
            if( ePos < sPos){
#else
			if( SelectCode - 1 < EUDC_SView){
#endif // BUILD_ON_WINNT
                this->SendMessage( WM_VSCROLL, SB_LINEUP, 0);
            }
			SearchSelectPosition();
			SelectCode--;
			SelectCode = CorrectEUDCCodeKey( SelectCode, 1, FALSE);
			SearchSelectPosition();
			this->UpdateWindow();
			break;

		case VK_RIGHT:
#ifdef BUILD_ON_WINNT
            // Move to above...
#else
			WORD	TmpCode;
#endif // BUILD_ON_WINNT

			if( SelectCode + 1 > EUDC_ECode)
				break;
			TmpCode = SelectCode + 1;
			TmpCode = CorrectEUDCCodeKey( TmpCode, 1, TRUE);
			sPos = GetBarPosition( EUDC_SView);
			ePos = GetBarPosition( TmpCode);
			if( ePos - sPos >= NUM_LINE){
				this->SendMessage( WM_VSCROLL, SB_LINEDOWN, 0);
			}
			SearchSelectPosition();
			SelectCode++;
			SelectCode = CorrectEUDCCodeKey( SelectCode, 1, TRUE);
			SearchSelectPosition();
			this->UpdateWindow();
			break;
		}
	}else 	CEdit::OnKeyDown(nChar, nRepCnt, nFlags);
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_SETFOCUS"		*/
/*					*/
/****************************************/
void
CEudcList::OnSetFocus(
CWnd* 	pOldWnd)
{
	CEdit::OnSetFocus(pOldWnd);
	FocusFlag = TRUE;
	SearchSelectPosition();
	this->UpdateWindow();
	::HideCaret( NULL);
//	DestroyCaret();
}

/****************************************/
/*					*/
/*	Search select posistion		*/
/*					*/
/****************************************/
void
CEudcList::SearchSelectPosition()
{

	CRect	test;
	int	sViewPt, sCodePt;
unsigned int	i, j;


	sViewPt = GetBarPosition( EUDC_SView);
	sCodePt = GetBarPosition( SelectCode);

#ifdef BUILD_ON_WINNT
    // the new view does not contain previsouly selected char,
    // we don't need to redraw the concave.
    if (sCodePt < sViewPt || sCodePt > sViewPt+NUM_LINE)
        return;
#endif



	i = (unsigned int)(sCodePt - sViewPt);
	j = (unsigned int)(SelectCode & 0x000f);
	test.SetRect( rcEditChar[i][j].left - 2,
			rcEditChar[i][j].top - 2,
			rcEditChar[i][j].right + 2,
			rcEditChar[i][j].bottom + 2);
	this->InvalidateRect( &test, FALSE);

}

/****************************************/
/*					*/
/*	Correct it if code is illegal 	*/
/*					*/
/****************************************/
#ifdef BUILD_ON_WINNT
WORD
CEudcList::CorrectEUDCCodeKey(
WORD 	Code,
int 	MovePt,
BOOL 	UporDown)
{
COUNTRYINFO	Info;
	WORD	wCode;
	BYTE 	LByte, HByte, Tmp0;
	int	TralPos = 0;

	LByte = LOBYTE( Code);
	HByte = HIBYTE( Code);
	Info = CountryInfo;
	for( int i = 0; i < Info.nTralByte; i++){
		if( LByte >= Info.sTralByte[i] && LByte <= Info.eTralByte[i]){
		    	goto RET;
		}else if( LByte < Info.sTralByte[i]){
        /* decide which range of starting trailbyte we are less than */
			TralPos = i;
			break;
        }else	TralPos = i+1;
	}
	if( UporDown){  //code increasing
		if( TralPos == Info.nTralByte){ //greater than last eTrailByte
		    HByte += 0x1; //same as less than next sTraiByte
            TralPos=0;
        }

		if( MovePt < NUM_CHAR){  //
			LByte = Info.sTralByte[TralPos];
		}else{
            Tmp0 = LByte & 0x0f;
            LByte = Info.sTralByte[TralPos] & 0xf0;
            LByte |= Tmp0;
            if (LByte < Info.sTralByte[TralPos])
                LByte += NUM_CHAR;

		}
	}else{
		if( TralPos == 0){ //greater than last eTrailByte
            TralPos = Info.nTralByte;
		    HByte -= 0x1;
        }

		if( MovePt < NUM_CHAR){
			LByte = Info.eTralByte[TralPos-1];
	    }else{
            Tmp0 = LByte & 0x0f;
            LByte = Info.eTralByte[TralPos-1] & 0xf0;
            LByte |= Tmp0;
            if (LByte > Info.eTralByte[TralPos-1])
                LByte -= NUM_CHAR;
		}
	}
RET:
	wCode = MAKEWORD( LByte, HByte);
	return wCode;
}
#else
WORD
CEudcList::CorrectEUDCCodeKey(
WORD 	Code,
int 	MovePt,
BOOL 	UporDown)
{
COUNTRYINFO	Info;
	WORD	wCode;
	BYTE 	LByte, HByte;
	int	TralPos = 0;

	LByte = LOBYTE( Code);
	HByte = HIBYTE( Code);
	Info = CountryInfo;
	for( int i = 0; i < Info.nTralByte; i++){
		if( LByte >= Info.sTralByte[i] && LByte <= Info.eTralByte[i]){
		    	goto RET;
		}else if( LByte < Info.sTralByte[i]){
			TralPos = i;
			break;
		}else	TralPos = i+1;
	}
	if( UporDown)
		if( TralPos == Info.nTralByte){
			if( MovePt < NUM_CHAR){
				LByte = Info.sTralByte[0];
				HByte += 0x1;
			}else{
				LByte = Info.eTralByte[Info.nTralByte - 1];
			}
		}else if( MovePt < NUM_CHAR){
			LByte = Info.sTralByte[TralPos];
		}else{
			if( TralPos){
				BYTE	Tmp1;
				BYTE	Tmp2;

				Tmp1 = Info.eTralByte[TralPos-1] & 0xf0;
				Tmp2 = LByte & 0xf0;
				if( Tmp1 == Tmp2){
					LByte = Info.eTralByte[TralPos-1];
				}else{
					Tmp1 = LByte & 0x0f;
					LByte = Info.sTralByte[TralPos]	& 0xf0;
					LByte |= Tmp1;
				}
			}else{
				LByte += (Info.sTralByte[0] & 0xf0);
			}
		}
	else{
		if( !TralPos){
			if( MovePt < NUM_CHAR){
				LByte = Info.eTralByte[Info.nTralByte - 1];
				HByte -= 0x1;
			}else{
				BYTE	Tmp;

				Tmp = LByte & 0x0f;
				LByte = Info.eTralByte[Info.nTralByte - 1]&0xf0;
				LByte |= Tmp;
				HByte -= 0x1;
				if( LByte > Info.eTralByte[Info.nTralByte-1]){
					LByte = Info.eTralByte[Info.nTralByte-1];
				}
			}
		}else{
			BYTE	Tmp;

			Tmp = LByte & 0x0f;
			LByte = Info.eTralByte[TralPos-1] & 0xf0;
			LByte |= Tmp;
			if( LByte > Info.eTralByte[TralPos-1])
				LByte = Info.eTralByte[TralPos-1];

		}
	}
RET:
	wCode = MAKEWORD( LByte, HByte);
	return wCode;
}
#endif // BUILD_ON_WINNT

/****************************************/
/*					*/
/*	Whether correct or not?		*/
/*					*/
/****************************************/
BOOL
CEudcList::IsCorrectChar(
UINT 	i,
UINT 	j)
{
	int	sViewPt;
	WORD	wCode;
	BYTE	sOffset;
	BOOL	flg;

	flg = FALSE;
	BarRange = GetBarPosition((WORD)EUDC_EView);
	sViewPt = GetBarPosition( EUDC_SView);
	wCode = GetCodeScrPos( sViewPt + i);
	wCode |= j;

	sOffset = LOBYTE( wCode);
	for( int k = 0; k < CountryInfo.nTralByte; k++){
		if( sOffset >= CountryInfo.sTralByte[k] &&
		    sOffset <= CountryInfo.eTralByte[k]){
		    	flg = TRUE;
		}
	}
	return flg;
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_KILLFOCUS"		*/
/*					*/
/****************************************/
void
CEudcList::OnKillFocus(
CWnd* 	pNewWnd)
{
	FocusFlag = FALSE;
	SearchSelectPosition();
	this->UpdateWindow();
	CEdit::OnKillFocus( pNewWnd);
	::HideCaret( NULL);
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_RBUTTONUP"		*/
/*					*/
/****************************************/
void
CEudcList::OnRButtonUp(
UINT 	nFlags,
CPoint 	point)
{
	GetParent()->SendMessage( WM_CONTEXTMENU, (WPARAM)this->GetSafeHwnd(), 0);
}

BEGIN_MESSAGE_MAP( CViewEdit, CEdit)
	//{{AFX_MSG_MAP( CViewEdit)
	ON_WM_PAINT()
	ON_WM_SETCURSOR()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_RBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CViewEdit::CViewEdit()
{
}

/****************************************/
/*					*/
/*	Destructor			*/
/*					*/
/****************************************/
CViewEdit::~CViewEdit()
{
//fix for 261529  
  EUDCFont.DeleteObject();
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void
CViewEdit::OnPaint()
{
	LOGFONT	LogFont;
	CFont	ViewFont, *OldFont;
	CSize	cSize;
	CRect	ViewRect;
	int	xOffset, yOffset;
	CPaintDC	dc( this);


	GetClientRect( &ViewRect);
	DrawConcave( &dc, ViewRect);

    if(bHasGlyph == FALSE) return;

	memset( &LogFont, 0, sizeof( LogFont));
//fix for 261529    
  EUDCFont.GetLogFont(&LogFont);

	if( ViewRect.Width() >= ViewRect.Height())
		LogFont.lfHeight = ViewRect.Height() - 10;
	else	LogFont.lfHeight = ViewRect.Width()  - 10;

  if( !ViewFont.CreateFontIndirect( &LogFont))
		return;
	OldFont = dc.SelectObject( &ViewFont);

#ifdef BUILD_ON_WINNT
    if (CountryInfo.bUnicodeMode)
	    GetTextExtentPoint32W(dc.GetSafeHdc(), (LPCWSTR)ViewCode, 1, &cSize);
    else
#endif //BUILD_ON_WINNT
	    GetTextExtentPoint32A(dc.GetSafeHdc(), (LPCSTR)ViewCode, 2, &cSize);

	if( ViewRect.Width() > cSize.cx){
		xOffset = ViewRect.Width() - cSize.cx;
		xOffset /= 2;
	}else	xOffset = 0;

	if( ViewRect.Height() > cSize.cy){
		yOffset = ViewRect.Height() - cSize.cy;
		yOffset /= 2;
	}else	yOffset = 0;

	dc.SetBkColor( COLOR_FACE);
	dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT)); // COLOR_BLACK);

    if (CountryInfo.bUnicodeMode)
	{
#ifdef UNICODE
	    ExtTextOutW(dc.GetSafeHdc(), xOffset, yOffset, ETO_OPAQUE,
		    &ViewRect, (LPCWSTR)ViewCode, 1, NULL);
#else
		CHAR ViewTmp[2];
		WideCharToMultiByte(CP_ACP, 0, (LPWSTR) ViewCode, 1, ViewTmp, 2, NULL, NULL);
		ExtTextOutA(dc.GetSafeHdc(), xOffset, yOffset, ETO_OPAQUE,
						&ViewRect, (LPCSTR)ViewTmp, 2, NULL);
#endif

	}
    else
	{
		ExtTextOutA(dc.GetSafeHdc(), xOffset, yOffset, ETO_OPAQUE,
			&ViewRect, (LPCSTR)ViewCode, 2, NULL);
	}
	dc.SelectObject( OldFont);
	ViewFont.DeleteObject();
}

/****************************************/
/*					*/
/*	Draw Concave Rect		*/
/*					*/
/****************************************/
void
CViewEdit::DrawConcave(
CDC 	*dc,
CRect 	rect)
{
	CBrush	ConBrush, *OldBrush;
	CRect	Rt;
       if (!dc)
       {
           return;
       }
	Rt.SetRect( rect.left-1, rect.top-1, rect.right, rect.bottom);

 	ConBrush.CreateSolidBrush(COLOR_FACE);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.top, Rt.right, Rt.bottom, PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();

	ConBrush.CreateSolidBrush( COLOR_HLIGHT);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.top, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.left, Rt.top, 1, Rt.Height(), PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();

	ConBrush.CreateSolidBrush( COLOR_SHADOW);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.bottom, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.right, Rt.top, 1, Rt.Height()+1, PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();
}

BEGIN_MESSAGE_MAP( CCustomListFrame, CStatic)
	//{{AFX_MSG_MAP( CCustomListFrame)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CCustomListFrame::CCustomListFrame()
{
}

/****************************************/
/*					*/
/*	Destructor			*/
/*					*/
/****************************************/
CCustomListFrame::~CCustomListFrame()
{
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void
CCustomListFrame::OnPaint()
{
	CRect	FrameRect;
	CPaintDC	dc( this);

	this->GetClientRect( &FrameRect);
	this->DrawConcave( &dc, FrameRect);
}

/****************************************/
/*					*/
/*	Draw Concave Rect		*/
/*					*/
/****************************************/
void
CCustomListFrame::DrawConcave(
CDC 	*dc,
CRect 	rect)
{
	CBrush	ConBrush, *OldBrush;
	CRect	Rt;

       if (!dc)
       {
          return;
       }
	Rt.SetRect( rect.left-1, rect.top-1, rect.right, rect.bottom);

	ConBrush.CreateSolidBrush( COLOR_HLIGHT);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.top, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.left, Rt.top, 1, Rt.Height(), PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();

	ConBrush.CreateSolidBrush( COLOR_SHADOW);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.bottom, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.right, Rt.top, 1, Rt.Height()+1, PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();
}

BEGIN_MESSAGE_MAP( CCustomInfoFrame, CStatic)
	//{{AFX_MSG_MAP( CCustomInfoFrame)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CCustomInfoFrame::CCustomInfoFrame()
{
}

/****************************************/
/*					*/
/*	Destructor			*/
/*					*/
/****************************************/
CCustomInfoFrame::~CCustomInfoFrame()
{
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void
CCustomInfoFrame::OnPaint()
{
	CRect	FrameRect;
	CPaintDC	dc( this);

	this->GetClientRect( &FrameRect);
	this->DrawConcave( &dc, FrameRect);
}

/****************************************/
/*					*/
/*	Draw Concave Rect		*/
/*					*/
/****************************************/
void
CCustomInfoFrame::DrawConcave(
CDC 	*dc,
CRect 	rect)
{
	CBrush	ConBrush, *OldBrush;
	CRect	Rt;

       if (!dc)
       {
           return;
       }

	Rt.SetRect( rect.left-1, rect.top-1, rect.right, rect.bottom);

	ConBrush.CreateSolidBrush( COLOR_SHADOW);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.top, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.left, Rt.top, 1, Rt.Height(), PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();

	ConBrush.CreateSolidBrush( COLOR_HLIGHT);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.bottom, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.right, Rt.top, 1, Rt.Height()+1, PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();
}

BOOL CViewEdit::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	::SetCursor( AfxGetApp()->LoadStandardCursor(IDC_ARROW));
	return TRUE;
}

void CViewEdit::OnSetFocus(CWnd* pOldWnd)
{
	CEdit::OnSetFocus(pOldWnd);
	::HideCaret( NULL);
}

void CViewEdit::OnKillFocus(CWnd* pNewWnd)
{
	CEdit::OnKillFocus(pNewWnd);
	::HideCaret( NULL);
}

void CViewEdit::OnLButtonDown(UINT nFlags, CPoint point)
{
}

void CViewEdit::OnLButtonDblClk(UINT nFlags, CPoint point)
{
}

void CViewEdit::OnRButtonUp(UINT nFlags, CPoint point)
{
	GetParent()->SendMessage( WM_CONTEXTMENU, (WPARAM)this->GetSafeHwnd(), 0);
}

#ifdef BUILD_ON_WINNT

BEGIN_MESSAGE_MAP( CColumnHeading, CWnd)
    //{{AFX_MSG_MAP( CColumnHeading)
    ON_WM_PAINT()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CColumnHeading::CColumnHeading()
{
}

/****************************************/
/*					*/
/*	Destructor			*/
/*					*/
/****************************************/
CColumnHeading::~CColumnHeading()
{
    SysFFont.DeleteObject();
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void
CColumnHeading::OnPaint()
{
    // column heading support
	CPaintDC	dc( this);
    TCHAR ColumnHead[2];
    CSize cSize;
    int	j,xOffset;
    HRESULT hresult;

    dc.SetMapMode( MM_TEXT);
    dc.SelectObject( &SysFFont);
    dc.SetBkColor( COLOR_FACE);
    dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT)); // COLOR_BLACK);
    for( j = 0; j < NUM_CHAR; j++){
        //*STRSAFE*         wsprintf(ColumnHead, TEXT("%X"), j);
        hresult = StringCchPrintf(ColumnHead , ARRAYLEN(ColumnHead),  TEXT("%X"), j);
        if (!SUCCEEDED(hresult))
        {
           return ;
        }
	    GetTextExtentPoint32(dc.GetSafeHdc(),
                ColumnHead, 1, &cSize);
        if( rcColumnHead[j].Width() > cSize.cx){
		    xOffset = rcColumnHead[j].Width() - cSize.cx;
	        xOffset /= 2;
	    }else	
            xOffset= 0;

        dc.ExtTextOut( rcColumnHead[j].left + xOffset,
             rcColumnHead[j].top,
             ETO_OPAQUE, &rcColumnHead[j],
             ColumnHead, 1, NULL);
    }
}


#endif //BUILD_ON_WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\eudcid.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#define IDH_EUDC_ASSOCIATE	1010	;change
#define IDH_EUDC_ASSO_STANDARD	1011	;change
#define IDH_EUDC_ASSO_TYPEFACE	1015	;change
;#define IDH_EUDC_ASSO_FONT	1010	;delete
;#define IDH_EUDC_ASSO_FILE	1011	;delete
#define IDH_EUDC_ASSO_LIST	1012
#define IDH_EUDC_MODIFY		1013	;button
#define IDH_EUDC_REMOVE		1014	;button
#define IDH_EUDC_MODFILE	1020
#define IDH_EUDC_SELLIST	1030
#define IDH_EUDC_SELCODE	1031
#define IDH_EUDC_SELFONT	1032
#define IDH_EUDC_SELFILE	1033
#define IDH_EUDC_SELCHAR	1034
#define IDH_EUDC_REFLIST	1040
#define IDH_EUDC_REFCODE	1041
#define IDH_EUDC_REFFONT	1042
#define	IDH_EUDC_REFCHAR	1043
#define IDH_EUDC_IMPOBMP	1050
;#define IDH_EUDC_IMPOTT	1051	;delete
#define IDH_EUDC_FLIPH		1060	
#define IDH_EUDC_FLIPV		1061	
#define IDH_EUDC_ROTA90		1062	
#define IDH_EUDC_ROTA180	1063	
#define IDH_EUDC_ROTA270	1064	
#define IDH_EUDC_OK		1070	
#define IDH_EUDC_CANCEL		1071	;button
#define IDH_EUDC_BROWSE		1072	;button
#define IDH_EUDC_FONT		1073	;NEWbutton
#define IDH_EUDC_browse_TTF	1080
#define	IDH_EUDC_LINK_IMELIST	1090
#define	IDH_EUDC_BLINK_EDITTBL	1100
#define	IDH_EUDC_OUTCAUTION	1200
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\eudcedit.cpp ===
/********************************************************/
/*							                            */
/*							                            */
/*	EUDC EDITOR     ( Windows 95)			            */
/*							                            */
/*		* Japanese Version			                    */
/*		* Korea	   Version			                    */
/*		* Chinese  Version			                    */
/*							                            */
/*                                                      */
/* Copyright (c) 1997-1999 Microsoft Corporation.       */
/********************************************************/

#include 	"stdafx.h"
#include 	<afxpriv.h>
#include 	"eudcedit.h"
#include 	"mainfrm.h"
#include	"registry.h"
#include	"util.h"
#include  "assocdlg.h"
#define STRSAFE_LIB
#include <strsafe.h>

#ifdef _DEBUG
#undef THIS_FILE
static char 	BASED_CODE THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CEudcApp, CWinApp)
//{{AFX_MSG_MAP(CEudcApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
//}}AFX_MSG_MAP
	ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
END_MESSAGE_MAP()

/* Global parameter */
INT	CAPTION_HEIGHT;		// height of caption
INT	BITMAP_WIDTH;		// width of bitmap
INT	BITMAP_HEIGHT;		// height of bitmap
TCHAR	HelpPath[MAX_PATH];	// help file path
TCHAR	ChmHelpPath[MAX_PATH];	// help file path for HtmlHelp
TCHAR	FontPath[MAX_PATH];	// font file path
DWORD	COLOR_GRID;		// grid color
DWORD	COLOR_FITTING;		// bitmap color on show outline
DWORD	COLOR_CURVE;		// color of outline
DWORD	COLOR_FACE;		// Win95 3D Face SystemColor
DWORD	COLOR_HLIGHT;		// Win95 3D HighLight System Color
DWORD	COLOR_SHADOW;		// Win95 3D Shadow SystemColor
DWORD	COLOR_WIN;		// Win95 Window System Color
CString	NotMemTtl;
CString	NotMemMsg;
HCURSOR	ToolCursor[NUMTOOL];	// cursor for tool
HCURSOR	ArrowCursor[NUMRESIZE];	// cursor for resize
COUNTRYINFO	CountryInfo;	// country information structure

/* Global function */
extern BOOL 	SetCountryInfo( UINT LocalCP);
BOOL     g_bKeepEUDCLink = TRUE;

extern "C" BOOL AnyLinkedFonts();


CEudcApp NEAR theApp;
/************************************************/
/*						*/
/*	Default Constructor			*/
/*						*/
/************************************************/
CEudcApp::CEudcApp()
{
}

/************************************************/
/*						*/
/*	Initialize Instance			*/
/*						*/
/************************************************/
BOOL
CEudcApp::InitInstance()
{
	CString	MainWndTitle;
	CRect	MainWndRect;
	UINT	MaxWndFlag;
	HRESULT hresult;

//	Check whether EUDC editor can open or not
	if( !CheckPrevInstance())
		return FALSE;

    //
    // Cicero and Cicero TIP currently does not support EUDC mode.
    // Use IMM32's IMEs on eudcedit.exe.
    //
    DisableCUAS();

/*------------------------------------------------
 * check if it's Administrator
 *------------------------------------------------*/
  TCHAR winpath[MAX_PATH];
  HANDLE nfh;

  GetSystemWindowsDirectory( winpath, MAX_PATH);
#ifdef IN_FONTS_DIR // CAssocDlg::OnOK()
		//*STRSAFE* 		lstrcat( winpath, TEXT("\\FONTS\\"));
		hresult = StringCchCat(winpath , ARRAYLEN(winpath),  TEXT("\\FONTS\\"));
		if (!SUCCEEDED(hresult))
		{
		   return FALSE;
		}
#else
		//*STRSAFE* 		lstrcat( winpath, TEXT("\\"));
		hresult = StringCchCat(winpath , ARRAYLEN(winpath),  TEXT("\\"));
		if (!SUCCEEDED(hresult))
		{
		   return FALSE;
		}
#endif // IN_FONTS_DIR
  //*STRSAFE*   lstrcat(winpath, _T("eudcadm.tte"));
  hresult = StringCchCat(winpath , ARRAYLEN(winpath),  _T("eudcadm.tte"));
  if (!SUCCEEDED(hresult))
  {
     return FALSE;
  }
	nfh = CreateFile(winpath,
					GENERIC_WRITE,
					FILE_SHARE_DELETE,
					NULL,
					CREATE_ALWAYS,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( nfh  == INVALID_HANDLE_VALUE)
  {
    HINSTANCE hInst = AfxGetInstanceHandle();
    TCHAR szMessage[256];
    LoadString(hInst, IDS_ACCESSDENIED, szMessage, sizeof(szMessage) / sizeof(TCHAR));
    AfxMessageBox(szMessage, MB_OK, 0);
		return FALSE;
  }
	else
  {
    CloseHandle(nfh);
    DeleteFile(winpath);
  }

//	Set background color for dialog
	COLOR_FACE   = ::GetSysColor( COLOR_3DFACE);
	COLOR_HLIGHT = ::GetSysColor( COLOR_3DHILIGHT);
	COLOR_SHADOW = ::GetSysColor( COLOR_3DSHADOW);
	COLOR_WIN    = ::GetSysColor( COLOR_WINDOW);
//	SetDialogBkColor( COLOR_FACE);

//	Set 3d controls
	Enable3dControls();

//	Create registry subkey
	if( !CreateRegistrySubkey())
		return FALSE;

//	Open "EUDCEDIT.INI", read data
	if( !GetProfileText( &MainWndRect, &MaxWndFlag))
		return FALSE;

//	Get Language ID with GetSystemDefaultLCID()
//      Get area of EUDC from registry and WideCharToMultiByte().
	if( !GetCountryInfo())
		return FALSE;

#if WINVER >= 0x0500
//	Remember original font link status before we do anything
//pliu  g_bKeepEUDCLink = AnyLinkedFonts();
#endif

//      Get Cursor from resource
	if( !GetCursorRes())
		return FALSE;

//      Get font and help file path
	if( !GetFilePath())
		return FALSE;

//	Create MDI mainFrame window
	MainWndTitle.LoadString( IDS_MAINFRAMETITLE);
	CMainFrame* pMainFrame = new CMainFrame;


	if (!pMainFrame->Create( MainWndTitle,
	    WS_OVERLAPPEDWINDOW , MainWndRect,
	    MAKEINTRESOURCE( IDR_MAINFRAME))){
		return FALSE;
	}

	pMainFrame->ShowWindow( m_nCmdShow);
	if( MaxWndFlag){
		pMainFrame->ShowWindow( SW_SHOWMAXIMIZED);
	}
	pMainFrame->UpdateWindow();
	m_pMainWnd = pMainFrame;

	CAssocDlg dlg(m_pMainWnd);

	if (!dlg.InitSystemFontAssoc())
	{
		return FALSE;
	}
	pMainFrame->m_wndGuideBar.PositionStatusPane();
	pMainFrame->SendMessage(WM_COMMAND, ID_READ_CHAR, NULL);

	return TRUE;
}

BOOL
CEudcApp::ExitInstance()
{
    HRESULT hresult;
    if (!g_bKeepEUDCLink && CountryInfo.bOnlyUnicode)
    {
        
        DWORD dwStart = GetTickCount();

        // Stop if this has taken too long
        while (1)
        {
            if( GetTickCount() - dwStart >= 1000 )
                break;
        }
        EnableEUDC(FALSE);
        TCHAR szDefaultFace[LF_FACESIZE];
        TCHAR szFontPath[MAX_PATH];
        TCHAR *Ptr;

        GetStringRes(szDefaultFace, IDS_SYSTEMEUDCFONT_STR, ARRAYLEN(szDefaultFace));

        if (InqTypeFace(szDefaultFace, szFontPath,MAX_PATH))
        {
            //
            // delete file eudc.tte
            //
            DeleteFile(szFontPath);
            if(( Ptr = Mytcsrchr( szFontPath, '.')) != NULL)
            {
                *Ptr = '\0';
                //*STRSAFE*                 lstrcat( szFontPath, TEXT(".EUF"));
                hresult = StringCchCat(szFontPath , ARRAYLEN(szFontPath),  TEXT(".EUF"));
                if (!SUCCEEDED(hresult))
                {
                   goto RET;
                }
                //
                // delete file eudc.euf
                //
                DeleteFile(szFontPath);
            }
        }
        DeleteRegistrySubkey();
        EnableEUDC(TRUE);
    }
RET:
    return CWinApp::ExitInstance();
}

/************************************************/
/*						*/
/*	Check whether editor can open or not	*/
/*						*/
/************************************************/
BOOL
CEudcApp::CheckPrevInstance()
{
	HWND	hWnd;
	TCHAR	TitleBuf[50];

	GetStringRes(TitleBuf, IDS_MAINFRAMETITLE, ARRAYLEN(TitleBuf));

//	Search previous eudcedit mainframe.	
	hWnd = ::FindWindow( NULL, TitleBuf);
	if( hWnd == NULL)
		return TRUE;
	else 	::SetForegroundWindow( hWnd);

	return FALSE;
}

/************************************************/
/*						*/
/*	disable CUAS                            */
/*						*/
/************************************************/
void
CEudcApp::DisableCUAS()
{
    typedef BOOL (*PFNIMMDISABLETEXTFRAMESERVICE)(DWORD);

    PFNIMMDISABLETEXTFRAMESERVICE pfn;
    HMODULE hMod = LoadLibrary(TEXT("imm32.dll"));

    if (hMod)
    {
        pfn = (PFNIMMDISABLETEXTFRAMESERVICE)GetProcAddress(hMod,
                           "ImmDisableTextFrameService");

        if (pfn)
            pfn(-1);
    }
}

/************************************************/
/*						*/
/*	Correspond to waitting for Input	*/
/*						*/
/************************************************/
BOOL
CEudcApp::OnIdle(
LONG 	lCount)
{
	CWnd	*pWnd;

	if( !lCount){
		for( pWnd = m_pMainWnd->GetWindow( GW_HWNDFIRST); pWnd != NULL;
		     pWnd = pWnd->GetNextWindow( GW_HWNDNEXT)){
			if( m_pMainWnd == pWnd->GetParent()){
				if( pWnd == m_pMainWnd->GetActiveWindow() &&
				  ( ::GetCapture() == NULL))
					m_pMainWnd->SetActiveWindow();

				pWnd->SendMessage( WM_IDLEUPDATECMDUI,
						 (WPARAM)TRUE, 0L);
			}
		}
	}
	return CWinApp::OnIdle( lCount);
}
					
/************************************************/
/*						*/
/*   Open "EUDCEDIT.INI"			*/
/*   Set parameter of EUDC Editor		*/
/*						*/
/************************************************/
BOOL
CEudcApp::GetProfileText(
LPRECT 	MainWndRect,
UINT 	*MaxWndFlag)
{
	TCHAR	ProfileBuf[MAX_PATH], *pString;
	TCHAR	Separation[] = TEXT(" ,");
	INT	xScreen , yScreen;
	UINT	BitmapSiz;
	BYTE	Rcolor, Gcolor, Bcolor;
	CString	GridColor, CurvColor, FittColor, MainWnd;

       if (!MaxWndFlag)
       {
          return FALSE;
       }
//	Get system metrics
	CAPTION_HEIGHT = ::GetSystemMetrics( SM_CYCAPTION);
	xScreen = ::GetSystemMetrics( SM_CXSCREEN);
	yScreen = ::GetSystemMetrics( SM_CYSCREEN);

//	Read bitmapsize and maxflag
	BitmapSiz = this->GetProfileInt(TEXT("Bitmap"), TEXT("BitmapSize"), DEF_BITMAPSIZE);
	if( BitmapSiz <= 0)
		BitmapSiz = DEF_BITMAPSIZE;
	if( BitmapSiz > MAX_BITMAPSIZE)
		BitmapSiz = DEF_BITMAPSIZE;

	BitmapSiz = ((BitmapSiz + sizeof(WORD)-1)/sizeof(WORD))*sizeof(WORD);
	if( BitmapSiz > MAX_BITMAPSIZE)
		BitmapSiz = MAX_BITMAPSIZE;
	if( BitmapSiz < MIN_BITMAPSIZE)
		BitmapSiz = MIN_BITMAPSIZE;

	BITMAP_WIDTH  = BitmapSiz;
	BITMAP_HEIGHT = BitmapSiz;
	*MaxWndFlag = this->GetProfileInt(TEXT("WindowSize"), TEXT("MinMaxFlag"), 0);

//	Read color
	GridColor = this->GetProfileString(TEXT("Color"), TEXT("Grid"), TEXT("128 128 128"));
	CurvColor = this->GetProfileString(TEXT("Color"), TEXT("Curve"), TEXT("255 0 0"));
	FittColor = this->GetProfileString(TEXT("Color"), TEXT("Fitting"), TEXT("128 128 128"));

//	Read grid color
	ConvStringRes((TCHAR *)ProfileBuf, GridColor, ARRAYLEN(ProfileBuf));
	if(( pString = Mytcstok( ProfileBuf, Separation)) == NULL)
		Rcolor = 0;
	else	Rcolor = (BYTE)Myttoi( pString);
	if(( pString = Mytcstok( NULL, Separation)) == NULL)
		Gcolor = 0;
	else	Gcolor = (BYTE)Myttoi( pString);
	if(( pString = Mytcstok( NULL, Separation)) == NULL)
		Bcolor = 0;
	else	Bcolor = (BYTE)Myttoi( pString);
	COLOR_GRID = RGB( Rcolor, Gcolor, Bcolor);

//	Read outline color
	ConvStringRes(ProfileBuf, CurvColor,ARRAYLEN(ProfileBuf));
	if(( pString = Mytcstok( ProfileBuf, Separation)) == NULL)
		Rcolor = 0;
	else	Rcolor = (BYTE)Myttoi( pString);
	if(( pString = Mytcstok( NULL, Separation)) == NULL)
		Gcolor = 0;
	else	Gcolor = (BYTE)Myttoi( pString);
	if(( pString = Mytcstok( NULL, Separation)) == NULL)
		Bcolor = 0;
	else	Bcolor = (BYTE)Myttoi( pString);
	COLOR_CURVE = RGB( Rcolor, Gcolor, Bcolor);

//	Read bitmap color in show outline
	ConvStringRes(ProfileBuf, FittColor,ARRAYLEN(ProfileBuf));
	if(( pString = Mytcstok( ProfileBuf, Separation)) == NULL)
		Rcolor = 0;
	else	Rcolor = (BYTE)Myttoi( pString);
	if(( pString = Mytcstok( NULL, Separation)) == NULL)
		Gcolor = 0;
	else	Gcolor = (BYTE)Myttoi( pString);
	if(( pString = Mytcstok( NULL, Separation)) == NULL)
		Bcolor = 0;
	else	Bcolor = (BYTE)Myttoi( pString);
	COLOR_FITTING = RGB( Rcolor, Gcolor, Bcolor);

//	Read main window size
	MainWnd = this->GetProfileString(TEXT("WindowSize"),TEXT("MainWindowSize"), TEXT(""));
	if( *MainWnd == '\0'){
		MainWndRect->left = 0;
		MainWndRect->top  = 0;
		MainWndRect->right = (xScreen/5)*4;
		MainWndRect->bottom =(yScreen/5)*4;
	}else{
		ConvStringRes(ProfileBuf, MainWnd, ARRAYLEN(ProfileBuf));
		pString = Mytcstok( ProfileBuf, Separation);
		MainWndRect->left = Myttoi( pString);
		pString = Mytcstok( NULL, Separation);
		MainWndRect->top = Myttoi( pString);
		pString = Mytcstok( NULL, Separation);
		MainWndRect->right = Myttoi( pString);
		pString = Mytcstok( NULL, Separation);
		MainWndRect->bottom = Myttoi( pString);
	}
	return TRUE;
}

/************************************************/
/*						*/
/*	Get country information			*/
/*						*/
/************************************************/
BOOL
CEudcApp::GetCountryInfo()
{
	UINT	LocalCP;
	HRESULT hresult;

	CountryInfo.CurrentRange = 0;
	CountryInfo.LangID = (int)GetSystemDefaultLCID();

	LocalCP = GetACP();

    CountryInfo.bUnicodeMode = FALSE;
	CountryInfo.bOnlyUnicode = FALSE;

	switch( CountryInfo.LangID){
	case EUDC_JPN:
		CountryInfo.CharacterSet = SHIFTJIS_CHARSET;
		break;
    case EUDC_HKG:
        CountryInfo.LangID = EUDC_CHT;
        //
        // fall through
        //
	case EUDC_CHT:
		CountryInfo.CharacterSet = CHINESEBIG5_CHARSET;
		break;
	case EUDC_KRW:
		CountryInfo.CharacterSet = HANGEUL_CHARSET;
		break;
    case EUDC_SIN:
        CountryInfo.LangID = EUDC_CHS;
        //
        // Fall through
        //
	case EUDC_CHS:
		CountryInfo.CharacterSet = GB2312_CHARSET;
		break;
	default:
    CHARSETINFO csi;
    if (TranslateCharsetInfo((DWORD*)IntToPtr(LocalCP), &csi, TCI_SRCCODEPAGE))
       CountryInfo.CharacterSet = csi.ciCharset;
		CountryInfo.bOnlyUnicode = TRUE;
   	CountryInfo.bUnicodeMode = TRUE;
    //*STRSAFE*     lstrcpy(CountryInfo.szForceFont, _T("Microsoft Sans Serif"));
    hresult = StringCchCopy(CountryInfo.szForceFont , ARRAYLEN(CountryInfo.szForceFont),  _T("Microsoft Sans Serif"));
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
		break;
	}
	if( !SetCountryInfo( LocalCP))
		return FALSE;
	else 	return TRUE;
}

/************************************************/
/*						*/
/*	Get Cursor resource file		*/
/*						*/
/************************************************/
BOOL
CEudcApp::GetCursorRes()
{
	int	i;

//	For tool cursor
	ToolCursor[PEN]        = this->LoadCursor(IDC_PENCIL);
	ToolCursor[BRUSH]      = this->LoadCursor(IDC_BRUSH);
	ToolCursor[CIRCLE]     = this->LoadStandardCursor(IDC_CROSS);
	ToolCursor[CIRCLEFILL] = this->LoadStandardCursor(IDC_CROSS);
	ToolCursor[SLOPE]      = this->LoadStandardCursor(IDC_CROSS);
	ToolCursor[RECTBAND]   = this->LoadStandardCursor(IDC_CROSS);
	ToolCursor[RECTFILL]   = this->LoadStandardCursor(IDC_CROSS);
	ToolCursor[FREEFORM]   = this->LoadStandardCursor(IDC_CROSS);
	ToolCursor[RECTCLIP]   = this->LoadStandardCursor(IDC_CROSS);
	ToolCursor[ERASER]     = this->LoadCursor(IDC_ERASER);
	for( i = PEN; i <= ERASER; i++){
		if( ToolCursor[i] == NULL){
			return FALSE;
		}
	}
	
//	For select rectangle cursur
	ArrowCursor[VERTICAL]  = this->LoadStandardCursor(
				 MAKEINTRESOURCE(IDC_SIZEWE));
	ArrowCursor[RIGHTSLOPE]= this->LoadStandardCursor(
				 MAKEINTRESOURCE(IDC_SIZENESW));
	ArrowCursor[LEFTSLOPE] = this->LoadStandardCursor(
				 MAKEINTRESOURCE(IDC_SIZENWSE));
	ArrowCursor[HORIZONTAL]= this->LoadStandardCursor(
				 MAKEINTRESOURCE(IDC_SIZENS));
	ArrowCursor[ALLDIRECT] = this->LoadStandardCursor(
				 MAKEINTRESOURCE(IDC_SIZEALL));
	for( i = VERTICAL; i <= ALLDIRECT; i++){
		if( ArrowCursor[i] == NULL){
			return FALSE;
		}
	}
	return TRUE;
}

/************************************************/
/*						*/
/*	Get help file path			*/
/*						*/
/************************************************/
BOOL
CEudcApp::GetFilePath()
{
       HRESULT hresult;
	if( !GetSystemWindowsDirectory( FontPath, MAX_PATH))
		return FALSE;
	//*STRSAFE* 	lstrcat(FontPath, TEXT("\\"));
	hresult = StringCchCat(FontPath , ARRAYLEN(FontPath),  TEXT("\\"));
	if (!SUCCEEDED(hresult))
	{
	   return FALSE;
	}

	//*STRSAFE* 	lstrcpy(HelpPath, FontPath);
	hresult = StringCchCopy(HelpPath , ARRAYLEN(HelpPath),  FontPath);
	if (!SUCCEEDED(hresult))
	{
	   return FALSE;
	}
    //*STRSAFE*     lstrcpy(ChmHelpPath, FontPath);
    hresult = StringCchCopy(ChmHelpPath , ARRAYLEN(ChmHelpPath),  FontPath);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
	//*STRSAFE* 	lstrcat(HelpPath, TEXT("Help\\EUDCEDIT.HLP"));
	hresult = StringCchCat(HelpPath , ARRAYLEN(HelpPath),  TEXT("Help\\EUDCEDIT.HLP"));
	if (!SUCCEEDED(hresult))
	{
	   return FALSE;
	}
    //*STRSAFE*     lstrcat(ChmHelpPath, TEXT("Help\\EUDCEDIT.CHM"));
    hresult = StringCchCat(ChmHelpPath , ARRAYLEN(ChmHelpPath),  TEXT("Help\\EUDCEDIT.CHM"));
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }

	NotMemTtl.LoadString( IDS_MAINFRAMETITLE);
	NotMemMsg.LoadString( IDS_NOTENOUGHMEMORY_ERROR);

	return TRUE;
}

/************************************************/
/*						*/
/*	COMMAND 	"About"			*/
/*						*/
/************************************************/
void
CEudcApp::OnAppAbout()
{
	HICON	hIcon;
	TCHAR	TitleBuf[50];

	hIcon = LoadIcon( IDR_MAINFRAME);

	GetStringRes((TCHAR *)TitleBuf, IDS_MAINFRAMETITLE, ARRAYLEN(TitleBuf));
	ShellAbout( m_pMainWnd->GetSafeHwnd(), TitleBuf, TEXT(""), hIcon);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\eudclist.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#ifndef _EUDCLIST_H_
#define _EUDCLIST_H_

/************************************************/
/*						*/
/*	Character List (Update EUDC)		*/
/*						*/
/************************************************/

class CViewEdit :public CEdit
{
//	member function
public:
	CViewEdit();
	~CViewEdit();
  CFont EUDCFont;

private:
	void DrawConcave( CDC *dc, CRect rect);

protected:

	//{{AFX_MSG(CViewEdit)
	afx_msg void OnPaint();
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CCustomListFrame :public CStatic
{
//	member function
public:
	CCustomListFrame();
	~CCustomListFrame();

private:
	void DrawConcave( CDC *dc, CRect rect);

protected:

	//{{AFX_MSG(CCustomListFrame)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CCustomInfoFrame :public CStatic
{
//	member function
public:
	CCustomInfoFrame();
	~CCustomInfoFrame();

private:
	void DrawConcave( CDC *dc, CRect rect);

protected:

	//{{AFX_MSG(CCustomInfoFrame)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef BUILD_ON_WINNT
class CColumnHeading :public CWnd
{
//	member function
public:
	CColumnHeading();
	~CColumnHeading();

protected:

	//{{AFX_MSG(CColumnHeading)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

//	member parameter
public:
	CFont	SysFFont;
};
#endif //BUILD_ON_WINNT

class CEudcList : public CEdit
{
	DECLARE_DYNCREATE( CEudcList)

//	Member function
public:
	CEudcList();
	~CEudcList();
	BOOL	CodeButtonClicked();
	void	SetInitEUDCCodeRange( int nIndex);
	void 	SetEUDCCodeRange( int nIndex);
	void 	CalcCharSize();

private:
	WORD 	GetNextCode( WORD Code);
	WORD 	CorrectEUDCCode( WORD Code, BOOL UporDown);
	WORD 	CorrectEUDCCodeKey( WORD Code, int MovePt, BOOL UporDown);
	WORD 	GetCodeScrPos( int Pos);
	int	GetBarPosition( WORD Code);
	void 	DrawConcave( CDC *dc, CRect rect, BOOL PtIn);
	void 	SearchSelectPosition();
	BOOL	IsCorrectChar( UINT i, UINT j);

//	Member parameter
public:
	CFont	EUDCFont;
	CFont	SysFFont;
	WORD 	EUDC_SView;
	WORD	EUDC_EView;
	WORD	EUDC_SCode;
	WORD	EUDC_ECode;
	WORD	SelectCode;
	int	cRange;
	int	BarRange;
	CPoint  LButtonPt;
	CSize 	CharSize;
	short	ScrlBarPos;

private:
	CRect	EditListRect;
	CSize 	FixSize;
	CPoint	WritePos;
	int	ySpace;
	int	m_Index;
	BYTE	CSpace[5];
	BOOL	FocusFlag;

protected:

	//{{AFX_MSG(CEudcList)
	afx_msg void OnPaint();
	afx_msg void OnVScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\guidebar.cpp ===
/**************************************************/
/*					                              */
/*					                              */
/*		Guide Bar 		                          */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/ 

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"guidebar.h"
#include	"registry.h"
#include	"util.h"
#define STRSAFE_LIB
#include <strsafe.h>



#define		GUIDEHIGH	50
#define		COMBOWIDTH	55
#define		COMBOHEIGHT	200



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC( CGuideBar, CStatusBar)
BEGIN_MESSAGE_MAP( CGuideBar, CStatusBar)
	//{{AFX_MSG_MAP(CGuideBar)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*					*/
/*	Constructor			*/
/*					*/
/****************************************/
CGuideBar::CGuideBar()
{
	m_comboBoxAdded = FALSE;
}

/****************************************/
/*					*/
/*	Destructor			*/
/*					*/
/****************************************/
CGuideBar::~CGuideBar()
{
}

/****************************************/
/*					*/
/*	Create GuideBar 		*/
/*					*/
/****************************************/
BOOL 
CGuideBar::Create(
CWnd* 	pOwnerWnd, 
UINT 	pID)
{

	LONG lStyle;
	//
	// We don't want the sizegrip for this status bar because it is at
	// the top of the frame.  However MFC creates a sizegrip if the
	// parent window has a thickframe.  We temporarily turn off the bit
	// to fool MFC so that SBARS_GRIPSIZE is not set.
	//
	lStyle = ::SetWindowLong(pOwnerWnd->GetSafeHwnd(),
                             GWL_STYLE,
                             (pOwnerWnd->GetStyle() & ~WS_THICKFRAME));
	m_pOwnerWnd = pOwnerWnd;
	if (!CStatusBar::Create( pOwnerWnd, WS_CHILD | WS_VISIBLE
           | CBRS_TOP | CBRS_NOALIGN, AFX_IDW_STATUS_BAR))
	{
		return FALSE;
	}

	::SetWindowLong(pOwnerWnd->GetSafeHwnd(),  GWL_STYLE,  lStyle);
	return TRUE;
}

int
CGuideBar::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	CRect rect;
	TCHAR	CharBuf[MAX_PATH];
	UINT nID = 0;

	if (CStatusBar::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_comboCharset.Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP |
		CBS_DROPDOWNLIST | CBS_HASSTRINGS, rect, this, IDC_SELECTCHARSET)){
		return -1;
	}

	m_comboCharset.SendMessage(WM_SETFONT, (WPARAM) CStatusBar::GetFont()->GetSafeHandle());


	switch (CountryInfo.LangID){
	case EUDC_JPN:
		nID=IDS_SHIFTJIS;
		break;
	case EUDC_CHS:
		nID=IDS_GB2312;
		break;
	case EUDC_KRW:
		nID=IDS_HANGUL;
		break;
	case EUDC_CHT:
		nID=IDS_CHINESEBIG5;
		break;
	}

	if (nID){
		GetStringRes(CharBuf, nID, ARRAYLEN(CharBuf));
		m_comboCharset.AddString(CharBuf);
	}

	GetStringRes(CharBuf, IDS_UNICODE, ARRAYLEN(CharBuf));
	m_comboCharset.AddString(CharBuf);
	m_comboCharset.SetCurSel(0);
	return TRUE;
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void 
CGuideBar::PositionStatusPane()
{

	TCHAR	CharBuf[MAX_PATH], BufTmp[MAX_PATH], *FilePtr;
	int	nWidth;
	UINT nStyle, nID;
	CRect rect;
	CSize StringSize;
	HRESULT hresult;
	

	GetPaneInfo(0,nID,nStyle,nWidth);
	CDC* dc = this->GetDC();
	int nComboWidth;
	int nDlgBaseUnitX = LOWORD(GetDialogBaseUnits());
	nComboWidth = (nDlgBaseUnitX * COMBOWIDTH + 2) /4;

	if (!m_comboBoxAdded)
	{
		SetPaneInfo(0,nID, nStyle | SBPS_NOBORDERS,nWidth+nComboWidth);
		m_comboCharset.SetWindowPos( NULL, nWidth+nDlgBaseUnitX, 0,
			nComboWidth, COMBOHEIGHT, SWP_NOZORDER);
		m_comboBoxAdded = TRUE;
	}
	

//	Draw "Code:"
	if( SelectEUDC.m_Code[0] != '\0'){
		GetStringRes(CharBuf, IDS_CODE_STR, ARRAYLEN(CharBuf));
		//*STRSAFE* 		lstrcat( CharBuf, TEXT(" "));
		hresult = StringCchCat(CharBuf , ARRAYLEN(CharBuf),  TEXT(" "));
		if (!SUCCEEDED(hresult))
		{
		   goto RET; ;
		}
		//*STRSAFE* 		lstrcat( CharBuf, SelectEUDC.m_Code);
		hresult = StringCchCat(CharBuf , ARRAYLEN(CharBuf),  SelectEUDC.m_Code);
		if (!SUCCEEDED(hresult))
		{
		   goto RET;;
		}
		SetPaneText (1, CharBuf, TRUE);	
		StringSize = dc->GetTextExtent(CharBuf,lstrlen(CharBuf)); 
  	GetPaneInfo(1,nID,nStyle,nWidth);
		SetPaneInfo(1,nID,nStyle,StringSize.cx + 3*nDlgBaseUnitX);
	}
	if( SelectEUDC.m_Font[0] != '\0'){
		GetStringRes(CharBuf, IDS_FONT_STR, ARRAYLEN(CharBuf));
		//*STRSAFE* 		lstrcat( CharBuf, TEXT(" "));
		hresult = StringCchCat(CharBuf , ARRAYLEN(CharBuf),  TEXT(" "));
		if (!SUCCEEDED(hresult))
		{
		   goto RET; ;
		}
		//*STRSAFE* 		lstrcat( CharBuf, SelectEUDC.m_Font);
		hresult = StringCchCat(CharBuf , ARRAYLEN(CharBuf),  SelectEUDC.m_Font);
		if (!SUCCEEDED(hresult))
		{
		   goto RET; ;
		}
		SetPaneText (2, CharBuf, TRUE);
		StringSize = dc->GetTextExtent(CharBuf,lstrlen(CharBuf)); 
		GetPaneInfo(2,nID,nStyle,nWidth);
		SetPaneInfo(2,nID,nStyle,StringSize.cx + 3*nDlgBaseUnitX);
	}
	

	if( SelectEUDC.m_Font[0] != TEXT('\0') && InqTypeFace(SelectEUDC.m_Font,
		SelectEUDC.m_File, sizeof( SelectEUDC.m_File)/sizeof(TCHAR))){
		GetStringRes(CharBuf, IDS_FILE_STR, ARRAYLEN(CharBuf));
		//*STRSAFE* 		lstrcat( CharBuf, TEXT(" "));
		hresult = StringCchCat(CharBuf , ARRAYLEN(CharBuf),  TEXT(" "));
		if (!SUCCEEDED(hresult))
		{
		   goto RET; ;
		}
		//*STRSAFE* 		lstrcpy( BufTmp, SelectEUDC.m_FileTitle);
		hresult = StringCchCopy(BufTmp , ARRAYLEN(BufTmp),  SelectEUDC.m_FileTitle);
		if (!SUCCEEDED(hresult))
		{
		   goto RET; ;
		}
		if(( FilePtr = Mytcsrchr( BufTmp, '.')) != NULL)
			*FilePtr = '\0';
		if( lstrlen((const TCHAR *)BufTmp) > 20){
			BufTmp[20] = '\0';
			//*STRSAFE* 			lstrcat(BufTmp, TEXT(".."));
			hresult = StringCchCat(BufTmp , ARRAYLEN(BufTmp),  TEXT(".."));
			if (!SUCCEEDED(hresult))
			{
			   goto RET;
			}
		}
		//*STRSAFE* 		lstrcat( CharBuf, BufTmp);
		hresult = StringCchCat(CharBuf , ARRAYLEN(CharBuf),  BufTmp);
		if (!SUCCEEDED(hresult))
		{
		   goto RET;
		}
		SetPaneText (3, CharBuf, TRUE);
		StringSize = dc->GetTextExtent(CharBuf,lstrlen(CharBuf)); 
		GetPaneInfo(3,nID,nStyle,nWidth);
		SetPaneInfo(3,nID,nStyle,StringSize.cx + 3*nDlgBaseUnitX);
	}
RET:
	UpdateWindow();
    this->ReleaseDC(dc);

}


#ifdef _DEBUG
void CGuideBar::AssertValid() const
{
	CStatusBar::AssertValid();
}
void CGuideBar::Dump(CDumpContext& dc) const
{
	CStatusBar::Dump(dc);
}
#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\eudcrang.cpp ===
/**************************************************/
/*					                              */
/*					                              */
/*	Setting code range		                      */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include	"stdafx.h"
#include	"eudcedit.h"
#include	"registry.h"
#ifdef BUILD_ON_WINNT
#include    "extfunc.h"
#endif // BUILD_ON_WINNT
#include    "util.h"
#define STRSAFE_LIB
#include <strsafe.h>

#define		S_UNICODE	0xE000
#define		E_UNICODE	0xE0ff

BOOL	SetCountryInfo( UINT LocalCP);
int		SetLeadByteRange(TCHAR * CodeRange,int nCode);
void	SetTrailByteRange();
#ifdef BUILD_ON_WINNT
void    CorrectTrailByteRange(int nIndex);
#endif // BUILD_ON_WINNT
/****************************************/
/*					*/
/*	Set Country Infomation		*/
/*					*/
/****************************************/
BOOL 
SetCountryInfo( 
UINT 	LocalCP)
{
	TCHAR	CodePage[10], szUnicode[] = TEXT("Unicode");
	TCHAR	Coderange[50];
	int nCode = 0;
	HRESULT hresult;

	SetTrailByteRange(LocalCP);
	
	if (!CountryInfo.bOnlyUnicode){

/* Read EUDC Coderange from Registry */
#ifndef NEWREG
		/* Old Version */
		TCHAR 	CodeTmp[10];
		//*STRSAFE* 		wsprintf( CodeTmp, TEXT("%d"), LocalCP);
		hresult = StringCchPrintf(CodeTmp , ARRAYLEN(CodeTmp),  TEXT("%d"), LocalCP);
		if (!SUCCEEDED(hresult))
		{
		   return FALSE;
		}
		if( lstrlen( CodeTmp) == 3){
			//*STRSAFE* 			lstrcpy(CodePage, TEXT("CP00"));
			hresult = StringCchCopy(CodePage , ARRAYLEN(CodePage),  TEXT("CP00"));
			if (!SUCCEEDED(hresult))
			{
			   return FALSE;
			}
		}else{
			//*STRSAFE* 			lstrcpy(CodePage, TEXT("CP0"));
			hresult = StringCchCopy(CodePage , ARRAYLEN(CodePage),  TEXT("CP0"));
			if (!SUCCEEDED(hresult))
			{
			   return FALSE;
			}
		}
		//*STRSAFE* 		lstrcat(CodePage, CodeTmp);
		hresult = StringCchCat(CodePage , ARRAYLEN(CodePage),  CodeTmp);
		if (!SUCCEEDED(hresult))
		{
		   return FALSE;
		}
#else
		/* New Version */
		//*STRSAFE* 		wsprintf( CodePage, TEXT("%d"), LocalCP);
		hresult = StringCchPrintf(CodePage , ARRAYLEN(CodePage),  TEXT("%d"), LocalCP);
		if (!SUCCEEDED(hresult))
		{
		   return FALSE;
		}
#endif
		if( !InqCodeRange(CodePage, (BYTE *)Coderange, 50))
		return FALSE;
		
		if ((nCode = SetLeadByteRange ( Coderange, 0)) == -1)
			return FALSE;
	} //!CountryInfo.bOnlyUnicode	

#ifdef UNICODE
	// unicode range will always be the last one.
	//*STRSAFE* 	lstrcpy(CodePage, szUnicode);
	hresult = StringCchCopy(CodePage , ARRAYLEN(CodePage),  szUnicode);
	if (!SUCCEEDED(hresult))
	{
	   return FALSE;
	}
	if( !InqCodeRange(CodePage, (BYTE *)Coderange, 50))
		return FALSE;

	if (SetLeadByteRange (Coderange, nCode) == -1)
		return FALSE;
#else
	//
	//	Ansi version, we have to set end Unicode 
	//	code point to the last ansi range.
	//
	WCHAR RangeTmp[2];
	CHAR AnsiRange[2];
	CountryInfo.nRange = nCode+1;
	CountryInfo.nLeadByte = nCode+1;
	CountryInfo.sRange[nCode] = S_UNICODE;
	
	AnsiRange[0] = HIBYTE(CountryInfo.eRange[nCode-1]);
	AnsiRange[1] = LOBYTE(CountryInfo.eRange[nCode-1]);
	MultiByteToWideChar(CP_ACP, 0, AnsiRange,2,RangeTmp, 1);
	CountryInfo.eRange[nCode] = RangeTmp[0];
	CountryInfo.sLeadByte[nCode] = HIBYTE(CountryInfo.sRange[nCode]);
	CountryInfo.eLeadByte[nCode] = HIBYTE(CountryInfo.eRange[nCode]);
#endif

	
	return TRUE;

}

void 
SetTrailByteRange(
UINT LocalCP)
{
	WORD	UCode[MAX_CODE];
	BYTE	SCode[MAX_CODE], sTral, cTral;
	int	nTral = 0;
	
	if (!CountryInfo.bUnicodeMode){
		// calculate trailbyte range.
		UCode[0] = S_UNICODE;
		UCode[1] = '\0';
		WideCharToMultiByte( LocalCP, 0L, (const unsigned short *)UCode,
			-1, (char *)SCode, sizeof(SCode), NULL, NULL);
		sTral = cTral = SCode[1];
		CountryInfo.sTralByte[nTral] = sTral;

		for( WORD Cnt = S_UNICODE + 1; Cnt <= E_UNICODE; Cnt++){
			UCode[0] = Cnt;
			UCode[1] = '\0';

			WideCharToMultiByte( LocalCP, 0L, (const unsigned short *)UCode,
		 		-1, (char *)SCode, sizeof(SCode), NULL, NULL);

			if( cTral + 1 != SCode[1]){
				CountryInfo.eTralByte[nTral] = cTral;
				nTral++;
				if( sTral != SCode[1]){
					CountryInfo.sTralByte[nTral] = SCode[1];
				}
			}
			cTral = SCode[1];
			if( sTral == cTral)
				break;
		}
		CountryInfo.nTralByte = nTral;

		/* For Extend Wansung (test) */
		if( CountryInfo.LangID == EUDC_KRW){
			CountryInfo.nTralByte = 3;
			CountryInfo.sTralByte[0] = 0x41;
			CountryInfo.eTralByte[0] = 0x5a;
			CountryInfo.sTralByte[1] = 0x61;
			CountryInfo.eTralByte[1] = 0x7a;
			CountryInfo.sTralByte[2] = 0x81;
			CountryInfo.eTralByte[2] = 0xfe;
		}

		/* For CHS  we have to remember the original trail byte range and calculate
		 	 trail byte range dynamically 
		*/
		if( CountryInfo.LangID == EUDC_CHS){
			CountryInfo.nOrigTralByte = 2;
			CountryInfo.sOrigTralByte[0] = 0x40;
			CountryInfo.eOrigTralByte[0] = 0x7e;
			CountryInfo.sOrigTralByte[1] = 0x80;
			CountryInfo.eOrigTralByte[1] = 0xfe;

		//To start with, calculate trailbyte range for the default EUDC selection range.
			CorrectTrailByteRange(0); 

		}else{
			CountryInfo.nOrigTralByte = 0;
		}

	}else { //!CountryInfo.bUnicodeMode
		CountryInfo.nTralByte = 1;
		CountryInfo.sTralByte[0] = 0x00;
		CountryInfo.eTralByte[0] = 0xff;
	} //!CountryInfo.bUnicodeMode
}


int 
SetLeadByteRange( 
TCHAR * Coderange,
int nCode)
{
	// Calculate LeadByte Range 
	TCHAR	*pStr1, *pStr2;
	WORD	wLow, wHigh;
	
       if (!Coderange)
       {
           return -1;
       }
	pStr1 = pStr2 = Coderange;
	while(1){
		if(( pStr2 = Mytcschr( pStr1, '-')) != NULL){
			*pStr2 = '\0';
			wLow = (WORD)Mytcstol( pStr1, (TCHAR **)0, 16);
			CountryInfo.sRange[nCode] = wLow;
			CountryInfo.sLeadByte[nCode] = HIBYTE( wLow);	
			pStr2++;
			pStr1 = pStr2;
		}else	return -1;

		if(( pStr2 = Mytcschr( pStr1, ',')) != NULL){
			*pStr2 = '\0';
			wHigh = (WORD)Mytcstol( pStr1, (TCHAR **)0, 16);
			CountryInfo.eRange[nCode] = (unsigned short)wHigh;
			CountryInfo.eLeadByte[nCode] = HIBYTE( wHigh);	
			pStr2++;
			pStr1 = pStr2;
		}else{
			wHigh = (WORD)Mytcstol( pStr1, (TCHAR **)0, 16);
			CountryInfo.eRange[nCode] = (unsigned short)wHigh;
			CountryInfo.eLeadByte[nCode] = HIBYTE( wHigh);	
			break;
		}
		nCode++;
	}

	CountryInfo.nLeadByte = ++nCode;
	CountryInfo.nRange = nCode;
	return nCode;
}

#ifdef BUILD_ON_WINNT
/**************************************************************************\
 * CorrectTralByteRange                                                   * 
 * Correct trailbyte range of EUDC range with each of original trail byte *
 * ranges.  It is used by countries where EUDC trail byte range changes   *
 * with selection of different EUDC range, for example CHS.               *
\**************************************************************************/
void
CorrectTrailByteRange(
int nIndex)
{
    COUNTRYINFO *Info;
    int i, Unique=0;
    
	if (CountryInfo.bUnicodeMode)
		return;

    Info=&CountryInfo;
    for (i=0; i< Info->nOrigTralByte; i++){
        //take the smaller of the two ranges.
        Info->sTralByte[Unique] = max(LOBYTE(Info->sRange[nIndex]),
                                      Info->sOrigTralByte[i]);
        Info->eTralByte[Unique] = min(LOBYTE(Info->eRange[nIndex]),
                                      Info->eOrigTralByte[i]);

        //we keep valid ranges and overwrite invalid one with next loop 
        if (Info->eTralByte[Unique] >= Info->sTralByte[Unique])
            Unique +=1;
    }
    Info->nTralByte=Unique;
}
#endif // BUILD_ON_WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\gagedlg.cpp ===
/**************************************************/
/*					                              */
/*					                              */
/*	Gage when import bitmap		                  */ 
/*		(Dialog)		                          */
/*					                              */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"gagedlg.h"
#include	"extfunc.h"
#include	"util.h"

#define STRSAFE_LIB
#include <strsafe.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern TCHAR	UserFont[MAX_PATH];
extern TCHAR	EUDCTTF[MAX_PATH];
extern TCHAR	EUDCBMP[MAX_PATH];
static HWND	hDlg;
static UINT	nEUDC;
static UINT	cEUDC;
static BOOL	ExecuteFlag;
static BOOL	testtest;
extern BOOL 	g_bKeepEUDCLink;
BOOL	SendImportMessage( unsigned int cEudc, unsigned int nEudc);

/****************************************/
/*					*/
/*	Constructor			*/
/*					*/
/****************************************/
CGageDlg::CGageDlg( CWnd* pParent, LPTSTR szUserFont, LPTSTR szBmpFile, LPTSTR szTtfFile, BOOL bIsWin95EUDC)
	: CDialog(CGageDlg::IDD, pParent)
{

       HRESULT hresult;
       
	//*STRSAFE* 	lstrcpy (m_szTtfFile, szTtfFile? szTtfFile : EUDCTTF);
	hresult = StringCchCopy(m_szTtfFile , ARRAYLEN(m_szTtfFile),  szTtfFile? szTtfFile : EUDCTTF);
	if (!SUCCEEDED(hresult))
	{
	   return ;
	}
	//*STRSAFE* 	lstrcpy (m_szBmpFile, szBmpFile? szBmpFile : EUDCBMP);
	hresult = StringCchCopy(m_szBmpFile , ARRAYLEN(m_szBmpFile),  szBmpFile? szBmpFile : EUDCBMP);
	if (!SUCCEEDED(hresult))
	{
	   return ;
	}
	//*STRSAFE* 	lstrcpy (m_szUserFont, szUserFont? szUserFont : UserFont);
	hresult = StringCchCopy(m_szUserFont , ARRAYLEN(m_szUserFont),  szUserFont? szUserFont : UserFont);
	if (!SUCCEEDED(hresult))
	{
	   return ;
	}
	m_bIsWin95EUDC = bIsWin95EUDC;


	//{{AFX_DATA_INIT(CGageDlg)
	//}}AFX_DATA_INIT
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_INITDIALOG"		*/
/*					*/
/****************************************/
BOOL 
CGageDlg::OnInitDialog()
{
	CString	DlgTitle;

	CDialog::OnInitDialog();

//	Implement "?" in this dialog.
	DlgTitle.LoadString( IDS_IMPORT_DLGTITLE);	
	this->SetWindowText( DlgTitle);

//	Set Dialog Title name.
	m_EditGage.SubclassDlgItem( IDC_GAGE, this);
	hDlg = this->GetSafeHwnd();

	testtest = FALSE;

	OutputMessageBox( this->GetSafeHwnd(),
                    IDS_MAINFRAMETITLE,
                    IDS_IMPORTFONT_MSG, TRUE);
	return TRUE;
}

/****************************************/
/*					*/
/*	COMMAND	"OK"			*/
/*					*/
/****************************************/
void 
CGageDlg::OnOK() 
{
	ExecuteFlag = FALSE;
	CDialog::OnOK();
}

/****************************************/
/*					*/
/*	Window procedure		*/
/*					*/
/****************************************/
LRESULT 
CGageDlg::WindowProc(
UINT 	message, 
WPARAM 	wParam, 
LPARAM 	lParam) 
{
	int	sts;

	if( message == WM_IMPORTGAGE){
		if( lParam){
			cEUDC = (UINT)wParam;
			nEUDC = (UINT)lParam;
			m_EditGage.Invalidate( FALSE);
			m_EditGage.UpdateWindow();
		}
		return (0L);
	}
	if( message == WM_IMPORTSTOP){
		ExecuteFlag = TRUE;

        
        DWORD dwStart = GetTickCount();

        // Stop if this has taken too long
        while (1)
        {
            if( GetTickCount() - dwStart >= 1000 )
                break;
        }
        
		EnableEUDC( FALSE);
		sts = Import(m_szUserFont, m_szBmpFile, m_szTtfFile,
			BITMAP_WIDTH, BITMAP_HEIGHT, SMOOTHLVL, m_bIsWin95EUDC);
		//
		// we import some glyphs and will not delete the link.
		//
		g_bKeepEUDCLink = TRUE;
		EnableEUDC( TRUE);

		if( sts)	return (0L);	// for debug
		return (0L);
	}
	return CDialog::WindowProc( message, wParam, lParam);
}

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CEditGage::CEditGage()
{
}

/****************************************/
/*					*/
/*	Destructor			*/
/*					*/
/****************************************/
CEditGage::~CEditGage()
{
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void 
CEditGage::OnPaint()
{
	TCHAR	cEUDCBuf[10];
	TCHAR	nEUDCBuf[10];
	TCHAR	ViewBuf[30];
	CRect	EditGageRect;
	CRect	BrueGageRect, WhiteGageRect;
	CBrush	wBrush, bBrush;
	CPaintDC	dc( this);
	HRESULT hresult;

	this->GetClientRect( &EditGageRect);

	if( !testtest){
		testtest = TRUE;
		::SendMessage( hDlg, WM_IMPORTSTOP, (WPARAM)0, (LPARAM)0);
	}else{
		if( nEUDC){
			//*STRSAFE* 			wsprintf( cEUDCBuf, TEXT("%d"), cEUDC);
			hresult = StringCchPrintf(cEUDCBuf , ARRAYLEN(cEUDCBuf),  TEXT("%d"), cEUDC);
			if (!SUCCEEDED(hresult))
			{
			   return ;
			}
			//*STRSAFE* 			wsprintf( nEUDCBuf, TEXT("%d"), nEUDC);
			hresult = StringCchPrintf(nEUDCBuf , ARRAYLEN(nEUDCBuf),  TEXT("%d"), nEUDC);
			if (!SUCCEEDED(hresult))
			{
			   return ;
			}
			//*STRSAFE* 			lstrcpy(ViewBuf, cEUDCBuf);
			hresult = StringCchCopy(ViewBuf , ARRAYLEN(ViewBuf),  cEUDCBuf);
			if (!SUCCEEDED(hresult))
			{
			   return ;
			}
			//*STRSAFE* 			lstrcat(ViewBuf, TEXT(" /"));
			hresult = StringCchCat(ViewBuf , ARRAYLEN(ViewBuf),  TEXT(" /"));
			if (!SUCCEEDED(hresult))
			{
			   return ;
			}
			//*STRSAFE* 			lstrcat(ViewBuf, nEUDCBuf);
			hresult = StringCchCat(ViewBuf , ARRAYLEN(ViewBuf),  nEUDCBuf);
			if (!SUCCEEDED(hresult))
			{
			   return ;
			}
			GetParent()->SetDlgItemText( IDC_IMPORT_STATIC, (LPCTSTR)ViewBuf);
			BrueGageRect.CopyRect( &EditGageRect);
			WhiteGageRect.CopyRect( &EditGageRect);
			BrueGageRect.right = (cEUDC*EditGageRect.Width()) / nEUDC;
			WhiteGageRect.left = BrueGageRect.right;

			bBrush.CreateSolidBrush(COLOR_BLUE);
			dc.FillRect( &BrueGageRect, &bBrush);
			bBrush.DeleteObject();

			wBrush.CreateStockObject( WHITE_BRUSH);
			dc.FillRect( &WhiteGageRect, &wBrush);
			wBrush.DeleteObject();
		}
	}
	if( cEUDC >= nEUDC){
		::SendMessage( hDlg, WM_COMMAND, (WPARAM)IDOK, (LPARAM)0);
	}
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_ONLBUTTONDOWN"	*/
/*					*/
/****************************************/
void 
CEditGage::OnLButtonDown(
UINT 	nFlags, 
CPoint 	point)
{
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_SETCURSOR"		*/
/*					*/
/****************************************/
BOOL 
CEditGage::OnSetCursor(
CWnd* 	pWnd, 
UINT 	nHitTest, 
UINT 	message)
{
	::SetCursor( AfxGetApp()->LoadStandardCursor(IDC_ARROW));
	return TRUE;
}

BEGIN_MESSAGE_MAP( CEditGage, CEdit)
	//{{AFX_MSG_MAP( CEditGage)
	ON_WM_PAINT()
	ON_WM_LBUTTONDOWN()
	ON_WM_SETCURSOR()
	ON_WM_RBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*					*/
/*	Send Import Message		*/
/*					*/
/****************************************/
BOOL 
SendImportMessage(
unsigned int 	cEudc,
unsigned int 	nEudc)
{
	MSG	msg;

	while( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE)){
		if( msg.message == WM_QUIT) 
			break;
		TranslateMessage( &msg);
		DispatchMessage( &msg);
	}
	if( !ExecuteFlag){
		cEudc = 0;
		nEudc = 0;
		return FALSE;
	}
	SendMessage( hDlg, WM_IMPORTGAGE, (WPARAM)cEudc, (LPARAM)nEudc);

	return TRUE;
}

BEGIN_MESSAGE_MAP(CGageDlg, CDialog)
	//{{AFX_MSG_MAP(CGageDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


void CEditGage::OnRButtonUp(UINT nFlags, CPoint point) 
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\extfunc.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//

/*****
 * FITCONIC.C
 *****/

int  FitConic(int  inLst,int  outLst,int  level,int  ufp);

/*****
 *	BMPOPE.C
 *****/

void  BMPInit(void);
int  BMPDefine(unsigned char  *buf,int  xWid,int  yWid);
int  BMPFreDef(int  bmpno);
int  BMPMkCont(int  BMPNo,int  wkBMP,int  refBMP,int  lsthdl);
int  rdot(int  BMP,int  x,int  y);
void  wdot(int  BMP,int  x,int  y,int  onoff);
int  ReverseRight(int  BMPNo,int  x,int  y);
int  BMPReverse(int  bmpNo);
int  BMPClear(int  bmpNo);

/*****
 *	W31JEUDC.C
 *****/
int  OpenW31JEUDC(TCHAR  *path);
void  CloseW31JEUDC(void);
int  GetW31JEUDCFont(unsigned short  code, LPBYTE buf,int  bufsiz,int  *xsiz,int  *ysiz, BOOL bUnicode);
int  PutW31JEUDCFont(unsigned short  code, LPBYTE buf,int  xsiz,int  ysiz, BOOL bUniocde);
int  IsWin95EUDCBmp(LPTSTR szBmpPath);
BOOL GetGlyph(TCHAR *path, BYTE* pGlyph);

/*****
 *	SMOOTH.C
 *****/
struct SMOOTHPRM	{
	int	SmoothLevel;
	int	UseConic;
	};

#define		SMOOTHLEVELMAX	8


int  SmoothVector(int  lstHdl,int  tmpLst,int  xinMesh,int yinMesh, int  outMesh,struct  SMOOTHPRM *prm,int  fp);
int  searchanchor(int  sn,struct  VDATA *sp,struct  VDATA * *ep,int  lim);
int  RemoveFp(int  lstHdl,int  outMesh,int  uFp);
int  toTTFFrame(int  lstH,struct  BBX *bbx);
int  SmoothLight(int  ioLst,int  tmpLst,int  width,int height, int  oWidth,int  ufpVal);
int  ConvMesh(int  lstH,int  inMesh,int  outMesh);

/*****
 *	DATAIF.C
 *****/
int  OInit(void);
int  OTerm(void);
#ifdef BUILD_ON_WINNT
int  OExistUserFont( TCHAR*path);
#endif // BUILD_ON_WINNT
int  OExistTTF(  TCHAR *path);
int  OCreateTTF( HDC hDC, TCHAR *path, int fontType);
int  OMakeOutline( UCHAR  *buf,int  siz,int  level);
int  OOutTTF(HDC hDC, TCHAR  *path,unsigned short  code, BOOL bUnicode);
/*****
 *	TTFFILE.C
 *****/
void  smtoi(short  *sval);
void  lmtoi(long  *lval);
void  sitom(short  *sval);
void  litom(long  *lval);
int  TTFReadHdr(HANDLE  fHdl,struct  TTFHeader *hdr);
int  TTFWriteHdr(HANDLE  fHdl,struct  TTFHeader *hdr);
int  TTFReadDirEntry(HANDLE fHdl,struct  TableEntry *entry,int  eCnt);
int  TTFWriteDirEntry(HANDLE  fHdl,struct  TableEntry *entry,int  eCnt);
int  TTFGetTableEntry(HANDLE  fH,struct  TableEntry *entry,char  *tag);
int  TTFReadTable(HANDLE  fH,struct  TableEntry *entry,void  *buf,int  bufsiz);
int  TTFReadFixedTable(HANDLE  fH,char  *buf,int  bufsiz,char  *tag);
int  TTFReadVarTable(HANDLE  fH,char  * *buf,unsigned int  *bufsiz,char  *tag);
int  TTFWriteTable(HANDLE fH,struct  TableEntry *entry,void  *buf,int  bufsiz);
int  TTFAppendTable(HANDLE  fH,struct  TableEntry *entry,void  *buf,int  siz);
int  TTFReadOrgFixedTable(HDC  hDC,char  *buf,int  bufsiz,char  *tag);
int  TTFReadOrgVarTable(HDC  hDC,char  * *buf,unsigned int  *bufsiz,char  *tag);
int  TTFCreate(HDC  hDC,TCHAR  *newf,struct  BBX *bbx,int  lstHdl,int  fontType);
int  TTFGetBBX(HDC  hDC,struct  BBX *bbx,short  *uPEm);
int  TTFTmpPath(TCHAR  *path,TCHAR  *tmpPath);
int  TTFAddEUDCChar(TCHAR *path,unsigned short  code,struct  BBX *bbx,int  lstH);
int  TTFOpen(TCHAR  *path);
int  TTFClose(void);
int  TTFGetEUDCBBX(TCHAR  *path,struct  BBX *bbx,short  *upem);
int  TTFAppend(unsigned short  code,struct  BBX *bbx,int  lsthdl);
int  TTFImpCopy(TCHAR  *sPath,TCHAR  *dPath);
int  TTFImpGlyphCopy(HANDLE  sFh,int  glyphID);
int  TTFImpGlyphWrite(int  glyphID, char *buf, int siz);
int  TTFImpTerm( HANDLE orgFh, int glyphID);
int  TTFLastError( void);
/*
 *	Create.c
 */
int creatW31JEUDC( TCHAR *path);

/*
 *	makepoly.c
 */

int	MkPoly(	int inlst, int outLst);

/*
 *	W31JBMP.C
 */
int  isW31JEUDCBMP( TCHAR *path);
int  OpenW31JBMP(TCHAR  *path,int  omd);
int  CloseW31JBMP(void);
int  GetW31JBMPnRecs( int *nRec, int *nGlyph, int *xsiz, int *ysiz);
int  GetW31JBMP(unsigned short  code,char  *buf,int  bufsiz,int  *xsiz,int  *ysiz);
int  GetW31JBMPRec(int  rec,LPBYTE buf,int  bufsiz,int  *xsiz,int  *ysiz,unsigned short  *code);
int  PutW31JBMPRec(int  rec,LPBYTE buf,int  xsiz,int  ysiz);
int  W31JrecTbl(int  * *recTbl, BOOL bIsWin95EUDC);
int  GetW31JBMPMeshSize( int *xsiz, int *ysiz);

/*
 *	code.c
 */

void  makeUniCodeTbl(void);
unsigned short  sjisToUniEUDC(unsigned short  code);
unsigned short  getMaxUniCode(void);

/*
 *	IMPORT.C
 */

int  Import(TCHAR  *eudcPath,TCHAR *bmpPath,TCHAR *ttfPath,int  oWidth,int  oHeight, int level, BOOL bIsWin95EUDC);

/*
 *	eten.c
 */
int  openETENBMP(TCHAR  *path,int  md);
int  closeETENBMP(void);
int  createETENBMP(TCHAR *path,int  wid,int  hei);
int  getETENBMPInf(int  *nRec, int *nGlyph,int  *wid,int  *hei, char *sign, 
WORD *bID);
int  readETENBMPRec(int  rec, LPBYTE buf,int  bufsiz,unsigned short  *code);
int  appendETENBMP(LPBYTE buf,unsigned short  code);
int  isETENBMP(TCHAR *path);
int  ETENrecTbl(int  * *recTbl);

#ifdef BUILD_ON_WINNT
/*
 * EUDCRANG.CPP  
 */
void    CorrectTrailByteRange(int nIndex);
void	SetTrailByteRange(UINT LocalCP);
#endif // BUILD_ON_WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\gagedlg.h ===
/**************************************************/
/*					                              */
/*					                              */
/*	Gage when import bitmap		                  */
/*		(Dialog)		                          */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

class CEditGage : public CEdit
{
public:
	CEditGage();
	~CEditGage();

protected:
	//{{AFX_MSG(CEditGage)
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown( UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CGageDlg : public CDialog
{
public:
	CGageDlg(CWnd* pParent = NULL, 
			 LPTSTR szUserFont=NULL, 
			 PTSTR szBmpFile=NULL, 
			 LPTSTR szTtfFile=NULL,
			 BOOL bIsWin95EUDC = FALSE);   // standard constructor

	//{{AFX_DATA(CGageDlg)
	enum { IDD = IDD_GAGE };
	//}}AFX_DATA

	//{{AFX_VIRTUAL(CGageDlg)
	protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL
private:
	CEditGage	m_EditGage;
	TCHAR m_szUserFont[MAX_PATH];
	TCHAR m_szTtfFile[MAX_PATH];
	TCHAR m_szBmpFile[MAX_PATH];
	BOOL m_bIsWin95EUDC;

protected:

	// Generated message map functions
	//{{AFX_MSG(CGageDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\fitconic.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//

#include	"stdafx.h"


#include	"vdata.h"
#include	"extfunc.h"
#define		sign(n)		(n < 0 ? 1 : 0)
#define		fpow(f)		((double)f*f)
#define		lpow(f)		((long)f*f)
#define		SPLINE_ATR	0x0001
#define	SMOOTHANCHOR	0x80
#define	SABUNMIN	(1*16)


int  FitConic(int  inLst,int  outLst,int  level,int  ufp);
static int  SetConic(struct  VDATA *svp,int  nElm,int  outLst,int  level);
static int  CurvTerm(struct  VDATA *svp,int  nElm,struct  VDATA * *term,int  level);
static void  sabun2(struct  VDATA *vp,struct  vecdata *vd);
static int  Fitting(struct  VDATA *sp,struct  VDATA *ep,int  nElm,int  outLst);
static void  onecurve(struct  VDATA *sp,struct  VDATA *midp,struct  VDATA *ep,struct  vecdata *cp);
static int  twocurve(struct  VDATA *sp,struct  VDATA *ep,int  nElm,struct  vecdata *cp,struct  vecdata *mid,struct  vecdata *cp2);
static long  getdist(struct  vecdata *lp1,struct  vecdata *lp2,struct  vecdata *p);
static int  CrsPnt(struct  vecdata *p1,struct  vecdata *p2,struct  vecdata *p3,struct  vecdata *p4,struct  vecdata *crsp);
static long  plen(struct  vecdata *p1,struct  vecdata *p2);
static int  isbind(struct  vecdata *v1,struct  vecdata *v2,struct  vecdata *v3);
static long  GetCurveHeight(struct  VDATA *sp,struct  VDATA *ep,int  nelm,struct  VDATA * *rvp,int  *pos);

static int	underFP;
/***********************************************************************
 *	Fit Conic Spline to Short Vector
 */
/* */	int
/* */	FitConic(
/* */		int	inLst, 
/* */		int	outLst,
/* */		int	level,		/* Smoothing Level 0-SMOOTHLEVELMAX-1 */
/* */		int	ufp)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*svp, *evp;
	int	sp, ep;
	int	ncont;

	underFP = ufp;
	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	VDNew( outLst);
	ncont=0;
	while ( vhd->next != NIL) {
	    svp = vhd->headp;
	    if ((sp=searchanchor(0,svp,&svp,vhd->nPoints))<vhd->nPoints){
		while(sp<vhd->nPoints) {
			ep = searchanchor(sp+1, svp->next,&evp, vhd->nPoints);

			if ((sts = SetConic( svp, ep-sp, outLst, level))<0)
				goto	RET;

			if ( ep >= vhd->nPoints)
				break;
			sp = ep;
			svp = evp;
		}
	    }
	    ncont++;
	    if ((sts = VDClose( outLst))<0)
		goto	RET;
	    vhd = vhd->next;
	}
RET:
	return( sts);
}
/***********************************************************************
 *	Set Conic Curves to specified category
 */
/* */	static int
/* */	SetConic ( struct VDATA *svp, int nElm, int outLst, int level)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
struct VDATA *vp;
	int	nPart;
	int	sts;

       if (!svp)
       {
          return -1;
       }	
	sts = 0;
	while ( nElm > 0) {
		/* Divide non contigus */
		nPart = CurvTerm( svp,  nElm, &vp , level);
		sts = Fitting( svp, vp, nPart, outLst);
		svp = vp;
		nElm -= nPart;
	}
	return	sts;
}
/***********************************************************************
 *	Determine the part which is described with one Conic
 */
/* */	static int
/* */	CurvTerm(
/* */		struct VDATA *svp, 
/* */			int	nElm, 
/* */		struct VDATA **term,
/* */			int	level)
/*
 *	returns: none
 ***********************************************************************/
{
struct vecdata	sub1, sub2;
	int	ecnt;

       if (!svp)
       {
          goto RET;
       }	
	if ( nElm < 3) {
		for ( ecnt=0; ecnt < nElm; ecnt++)
			svp = svp->next;
		*term =  svp;
		return( nElm);
	}
	sabun2( svp, &sub1);
	for ( ecnt = 2; ecnt < nElm; ecnt++)	{
		svp = svp->next;
		sabun2( svp, &sub2);
		if ((sign(sub1.x)!=sign(sub2.x)
			&& abs(sub1.x)+abs(sub2.x)> SABUNMIN*(level+1))
		 || (sign(sub1.y)!=sign(sub2.y)
			 &&abs(sub1.y)+abs(sub2.y)> SABUNMIN*(level+1))) {
			*term = svp->next;
			return ecnt;
		}
		sub1 = sub2;
	}
	*term = svp->next->next;
RET:
	return	nElm;
}
/***********************************************************************
 *	2nd Sabun
 */
/* */	static void
/* */	sabun2( struct VDATA *vp, struct vecdata *vd)
/*
 *	returns : none
 ***********************************************************************/
{
       if ((!vp) || (!vd))
       {
           return;
       }
	vd->x = vp->vd.x - vp->next->vd.x*2 + vp->next->next->vd.x;
	vd->y = vp->vd.y - vp->next->vd.y*2 + vp->next->next->vd.y;
	return;
}
/***********************************************************************
 *	Curve fit and set data
 */
/* */	static int
/* */	Fitting(
/* */		struct VDATA *sp,	/* Conic Start Point */
/* */		struct VDATA *ep,	/* Conic End Point */
/* */		int	nElm,
/* */		int	outLst)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
struct vecdata	vd;
struct vecdata	cp, mid, cp2;
	int	sts;

       if ((!sp) || (!ep))
       {
           sts = -1;
           goto RET;
       }
	if ( nElm==0) 
		return 0;
	else if ( nElm == 1) {
		vd = sp->vd;
		if ((sts = VDSetData( outLst, &vd))<0)
			goto	RET;
	}
	else if ( nElm == 2) {
		onecurve( sp , sp->next, ep,  &cp );
		vd = sp->vd;
		if ((sts = VDSetData( outLst, &vd))<0)
			goto	RET;
		cp.atr = SPLINE_ATR;
		if ((sts = VDSetData( outLst, &cp))<0)
			goto	RET;
	}
	else {
		if ( twocurve( sp, ep, nElm, &cp, &mid, &cp2)) {
			vd = sp->vd;
			if ((sts = VDSetData( outLst, &vd))<0)
				goto	RET;
			cp.atr = SPLINE_ATR;
			if ((sts = VDSetData( outLst, &cp))<0)
				goto	RET;
			mid.atr = 0;
			if ((sts = VDSetData( outLst, &mid))<0)
				goto	RET;
			cp2.atr = SPLINE_ATR;
			if ((sts = VDSetData( outLst, &cp2))<0)
				goto	RET;
		}
		else {
			vd = sp->vd;
			if ((sts = VDSetData( outLst, &vd))<0)
				goto	RET;
			cp.atr = SPLINE_ATR;
			if ((sts = VDSetData( outLst, &cp))<0)
				goto	RET;
		}
	}
RET:
	return	sts;
}
/***********************************************************************
 *	Fit One Curve
 */
/* */	static void
/* */	onecurve( 
/* */	struct VDATA *sp, 
/* */	struct VDATA *midp, 
/* */	struct VDATA *ep, 
/* */	struct vecdata *cp)
/*
 *	returns : none
 ***********************************************************************/
{
struct vecdata	p;

       if ((!sp) || (!midp) || (!ep) || (!cp))
       {
           return;
       }
	p.x = (midp->vd.x*4 - sp->vd.x - ep->vd.x)/2;
	p.y = (midp->vd.y*4 - sp->vd.y - ep->vd.y)/2;

	if ( sp->vd.x < ep->vd.x) {
		if ( p.x > ep->vd.x)	p.x = ep->vd.x;
		if ( p.x < sp->vd.x)	p.x = sp->vd.x;
	}
	else {
		if ( p.x < ep->vd.x)	p.x = ep->vd.x;
		if ( p.x > sp->vd.x)	p.x = sp->vd.x;
	}
	if ( sp->vd.y < ep->vd.y) {
		if ( p.y > ep->vd.y)	p.y = ep->vd.y;
		if ( p.y < sp->vd.y)	p.y = sp->vd.y;
	}
	else {
		if ( p.y < ep->vd.y)	p.y = ep->vd.y;
		if ( p.y > sp->vd.y)	p.y = sp->vd.y;
	}
	*cp = p;
}
/**********************************************************************
 *	Fit with a pair of Conic
 */
/* */	static int
/* */	twocurve( 
/* */		struct VDATA *sp, 
/* */		struct VDATA *ep, 
/* */		int	nElm,
/* */		struct vecdata *cp,
/* */		struct vecdata *mid,
/* */		struct vecdata *cp2)
/*
 *	returns : 0, 1( pair)
 **********************************************************************/
{
struct  VDATA	*midvp, *maxvp;
	long	maxlen;
	int	twin=0;
	long	sclen, eclen;
	int	pos;
	int	cp1pos, cp2pos;

         if ((!sp) || (!ep) || (!cp) || (!mid) || (!cp2) )
       {
           goto RET;
       }
	/* Get Curve Peak */
	maxlen = GetCurveHeight( sp, ep, nElm, &maxvp, &pos);
	/*
	if ( plen( &sp->vd, &ep->vd)/25 > maxlen) {
		onecurve( sp , maxvp, ep,  cp );
		twin = 0;
	}
	else {
	*/
		onecurve( sp , maxvp, ep,  cp );
		sclen = plen( &sp->vd, cp);
		eclen = plen( &ep->vd, cp);
		midvp = maxvp;
		if ( sclen > eclen*4 
		  || sclen*4 < eclen
		  || (long)(maxvp->vd.x - sp->vd.x)*(cp->x-sp->vd.x)<0L
		  || (long)(maxvp->vd.y - sp->vd.y)*(cp->y-sp->vd.y)<0L
		  || ( plen( &sp->vd, &ep->vd)>25L*25*underFP
			&& plen( &sp->vd, &ep->vd)<maxlen*64)) {

			maxlen=GetCurveHeight(sp, midvp, pos, &maxvp, &cp1pos);
			onecurve( sp, maxvp, midvp,  cp );
			maxlen=GetCurveHeight(midvp,ep,nElm-pos,&maxvp,&cp2pos);
			onecurve( midvp , maxvp, ep,  cp2 );
			*mid = midvp->vd;
			twin = 1;
		}
		else  {
			twin = 0;
		}
/*
	}
*/
RET:
	return( twin);
}
/**********************************************************************
 *	distance of point from line
 */	
/* */	static long
/* */	getdist(
/* */	struct vecdata	*lp1,
/* */	struct vecdata	*lp2,	/* Line p1, p2 */
/* */	struct vecdata	*p)		/* Point */
/*
 *	return :  Disttance 2nd Value
 **********************************************************************/
{
	long	a, b, c;
	long	height;

       if ((!lp1) || (!lp2) || (!p))
       {
           return 0;
       }
    
	a = - ( lp2->y - lp1->y);
	b = lp2->x - lp1->x;
	c = (long)(-lp1->y) * lp2->x + (long)(lp1->x) * lp2->y;
	if ( a==0 && b==0)
		height = c;
	else {
		height = a*p->x + b*p->y+c;
		if ( labs(height)>46340L)
			height = (long)(fpow(height)/(fpow(a)+fpow(b)));
		else
			height = lpow(height)/(lpow(a)+lpow(b));
	}
	return( height);
}
/**********************************************************************
 *	Cross Point
 */
/* */	static int
/* */	CrsPnt(
/* */	struct	vecdata	*p1,		/* vector point p1 to p2 */
/* */	struct	vecdata	*p2,
/* */	struct	vecdata	*p3,		/* vector point p3 to p4 */
/* */	struct	vecdata	*p4,
/* */	struct	vecdata	*crsp)
/*
 *	returns : 0, -1(no cross)
 **********************************************************************/
{
	int	rel1x, rel1y, rel2x, rel2y;
	long	cmul, cmul2;
	int	sts;

       if ( (!p1)  || (!p2) || (!p3) || (!p4) || (!crsp) )
       {
          sts = -1;
          goto RET;
       }
	rel1x = p2->x - p1->x;	
	rel1y = p2->y - p1->y;	
	rel2x = p4->x - p3->x;	
	rel2y = p4->y - p3->y;	
	cmul = (long)rel1y*rel2x - (long)rel2y*rel1x;

	if (cmul == 0L)
		sts = -1;
	else {
		cmul2 = (long)rel2x * (p3->y - p1->y) - 
			(long)rel2y * (p3->x - p1->x);
		crsp->x = (int)(cmul2*rel1x/cmul) + p1->x;
		crsp->y = (int)(cmul2*rel1y/cmul) + p1->y;
		if ( (long)rel1x*(crsp->x-p1->x)<0
		   || (long)rel1y*(crsp->y-p1->y)<0
		   || (long)rel2x*(crsp->x-p4->x)<0
		   || (long)rel2y*(crsp->y-p4->y)<0)
			sts = -1;
		else	sts = 0;
	}
RET:
	return	sts;
}
/**********************************************************************
 *	distance of points
 */	
/* */	static long
/* */	plen(
/* */		struct vecdata	*p1,
/* */		struct vecdata	*p2)
/*
 *	return :  Disttance 2nd Value
 **********************************************************************/
{
       if ((!p1) || (!p2))
       {
           return 0;
       }
	return( lpow((long)(p2->x-p1->x)) + lpow((long)(p2->y - p1->y)));
}
/**********************************************************************
 *	bind two conic to one
 */
/* */	static  int
/* */	isbind( 
/* */		struct vecdata	*v1,
/* */		struct vecdata	*v2,
/* */		struct vecdata	*v3)
/*
 *	returns : 0, 1
 **********************************************************************/
{
	int	l12, l23;

       if ((!v1) || (!v2) || (!v3))
       {
           goto NORET;
       }
	l12  = v1->x - v2->x;
	l23  = v2->x - v3->x;
	if ( sign( l12)!=sign(l23))
		goto	NORET;
	l12  = abs( l12);
	l23  = abs( l23);
	if ( (l12-l23)!=0) {
		if ( l12 / abs(l12 - l23) <10)
			goto	NORET;
	}
	l12  = v1->y - v2->y;
	l23  = v2->y - v3->y;
	if ( sign( l12)!=sign(l23))
		goto	NORET;
	l12  = abs( l12);
	l23  = abs( l23);
	if ( (l12-l23)!=0) {
		if ( l12 / abs(l12 - l23) <10)
			goto	NORET;
	}
	return 1;
NORET:
	return 0;
}
/**********************************************************************
 *	Get Curve liaison Peak height
 */
/* */	static long
/* */	GetCurveHeight( 
/* */	struct VDATA	*sp, 
/* */	struct VDATA	*ep, 
/* */		int	nelm, 
/* */	struct VDATA * * rvp,
/* */		int	*pos)
/*
 *	returns : maxlength( 2nd value)
 **********************************************************************/
{
	int	ecnt;
struct VDATA	*vp, *maxvp;
	long	maxlen=0, len;
	int	maxpos;

       if ((!sp) || (!ep) || (!rvp) || (!pos))
       {
            goto RET;
       }
	/* Get Curve Peak */
	vp = sp->next;
	maxvp = vp;
	maxlen = 0;
	maxpos = 0;
	for ( ecnt = 0; ecnt < nelm-1; ecnt++, vp = vp->next) {
		len = getdist( &sp->vd, &ep->vd, &vp->vd);
		if ( len > maxlen) {
			maxlen = len;
			maxvp = vp;
			maxpos = ecnt;
		}
	}
	*rvp = maxvp;
	*pos = maxpos;
RET:
	return maxlen;
}
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\guidebar.h ===
/**************************************************/
/*					                              */
/*					                              */
/*		GuideBar		                          */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#ifndef __AFXEXT_H_
#include <afxext.h>
#endif

class CGuideBar : public CStatusBar
{
	DECLARE_DYNAMIC(CGuideBar)
public:
	CGuideBar();
	BOOL 	Create( CWnd* pOwnerWnd, UINT pID);
//	void 	RecalcLayout();
	virtual ~CGuideBar();
	CComboBox m_comboCharset;
	void	PositionStatusPane();

protected:


#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

private:
//	void 	DrawConcaveRect( CDC *pDC, int x, int y, CSize size);


protected:
	UINT    m_nColumns;
	CWnd*   m_pOwnerWnd;

private:
	BOOL    m_comboBoxAdded;

protected:
	//{{AFX_MSG(CGuideBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\imelist.h ===
/**************************************************/
/*                                                */
/*                                                */
/*      Chinese IME Link Dialog Class             */
/*                                                */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

typedef struct _tagREGWORDSTRUCT {
    HKL   hKL;
    BOOL  bUpdate;
    TCHAR szIMEName[16];
    UINT  uIMENameLen;
    TCHAR szReading[14];
    DWORD dwReadingLen;
} REGWORDSTRUCT;
typedef REGWORDSTRUCT FAR *LPREGWORDSTRUCT;

typedef struct _tagIMELINKREGWORD {
    HIMC          hOldIMC;
    HIMC          hRegWordIMC;
    BOOL          fCompMsg;
    UINT          nEudcIMEs;
    UINT          nCurrIME;
    TCHAR         szEudcCodeString[4];
    REGWORDSTRUCT sRegWordStruct[1];
} IMELINKREGWORD;
typedef IMELINKREGWORD FAR *LPIMELINKREGWORD;

typedef struct _tagIMERADICALRECT {
    UINT nStartIME;
    UINT nPerPageIMEs;
    SIZE lTextSize;
    SIZE lCurrReadingExtent;
    HWND hRegWordButton;
    HWND hScrollWnd;
    RECT rcRadical[1];
} IMERADICALRECT;
typedef IMERADICALRECT FAR *LPIMERADICALRECT;

typedef struct _tagCOUNTRYSETTING {
    UINT    uCodePage;
    LPCTSTR szCodePage;
} COUNTRYSETTING;

#define WM_EUDC_CODE            (WM_USER + 0x0400)
#define WM_EUDC_COMPMSG         (WM_USER + 0x0401)
#define WM_EUDC_SWITCHIME       (WM_USER + 0x0402)
#define WM_EUDC_REGISTER_BUTTON (WM_USER + 0x0403)
#define UPDATE_NONE             0
#define UPDATE_START            1
#define UPDATE_FINISH           2
#define UPDATE_ERROR            3
#define UPDATE_REGISTERED       4
#define GWLP_IMELINKREGWORD     0
#define GWLP_RADICALRECT        (GWLP_IMELINKREGWORD + sizeof(PVOID))
#define UI_MARGIN               3
#define CARET_MARGIN            2
#define RECT_IMENAME            0
#define RECT_RADICAL            1
#define RECT_NUMBER             (RECT_RADICAL + 1)
#define UNICODE_CP              1200
#define BIG5_CP                 950
#define ALT_BIG5_CP             938
#define GB2312_CP               936

#define SIGN_CWIN               0x4E495743
#define SIGN__TBL               0x4C42545F
#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))
void	ImeLink( HWND hWnd, UINT uCode, BOOL bUnicodeMode, HINSTANCE hInst);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\imelist.c ===
/**************************************************/
/*                                                */
/*                                                */
/*      Chinese IME List Dialog Class             */
/*                                                */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include  <windows.h>
#include  <windowsx.h>
#include  "imm.h"
#include  "imelist.h"
#include  "resource.h"


static const TCHAR  szRegWordCls[] = TEXT("Radical");
static const TCHAR  szImeLinkDlg[] = TEXT("ImeLinkDlg");

static HINSTANCE    hAppInst;

static DWORD    aIds[] =
{
    IDD_RADICAL, IDH_EUDC_LINK_IMELIST,
    0, 0
};

static const COUNTRYSETTING sCountry[] = {
    {
        BIG5_CP, TEXT("BIG5")
    }
    , {
        ALT_BIG5_CP, TEXT("BIG5")
    }
#if defined(UNICODE)
    , {
        UNICODE_CP, TEXT("UNICODE")
    }
#endif
    , {
        GB2312_CP, TEXT("GB2312")
    }
};


/****************************************/
/*                                      */
/*      Create IME string listbox       */
/*                                      */
/****************************************/
LPIMELINKREGWORD
RegWordCreate(
HWND    hWnd)
{
    LPIMERADICALRECT lpImeLinkRadical;
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPREGWORDSTRUCT  lpRegWordStructTmp;
    HDC              hDC;
    HWND             hEudcEditWnd;
    UINT             nLayouts, i, nIMEs;
    HKL FAR         *lphKL;
    DWORD            dwSize;
    TCHAR            szStrBuf[16];
    SIZE             lTextSize;
    RECT             rcRect;
    TCHAR            szTitle[32];
    TCHAR            szMessage[256];

    hEudcEditWnd = GetWindow( GetParent( hWnd), GW_OWNER);

    nLayouts = GetKeyboardLayoutList( 0, NULL);

    if( !(lphKL = GlobalAlloc(GPTR, sizeof(HKL)*nLayouts)))
        return NULL;

    lpImeLinkRegWord = NULL;
    GetKeyboardLayoutList( nLayouts, lphKL);

    for( i = 0, nIMEs = 0; i < nLayouts; i++) {
        LRESULT lRet;
        HKL   hKL;
        TCHAR szImeEudcDic[MAX_PATH];

        hKL = *(lphKL + i);
        if( !(lRet = ImmIsIME( hKL)))
            continue;

        szImeEudcDic[0] = '\0';
        lRet = ImmEscape( hKL, (HIMC)NULL, IME_ESC_GET_EUDC_DICTIONARY,
            szImeEudcDic);

        if( !lRet){
            continue;
        }else if( szImeEudcDic[0]){
        }else{
            continue;
        }
        *(lphKL + nIMEs) = hKL;

        nIMEs++;
    }
    if( !nIMEs){
        LoadString( hAppInst, IDS_NOIME_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
        LoadString( hAppInst, IDS_NOIME_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));

        MessageBox( hEudcEditWnd, szMessage, szTitle, MB_OK);
        goto RegWordCreateFreeHKL;
    }

    dwSize = sizeof( IMELINKREGWORD) - sizeof( REGWORDSTRUCT) +
        sizeof( REGWORDSTRUCT) * nIMEs;
    lpImeLinkRegWord = (LPIMELINKREGWORD)GlobalAlloc( GPTR, dwSize);

    if( !lpImeLinkRegWord){
        LoadString( hAppInst, IDS_NOMEM_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
        LoadString( hAppInst, IDS_NOMEM_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));

        MessageBox( hEudcEditWnd, szMessage, szTitle, MB_OK);
        goto RegWordCreateFreeHKL;
    }

    lpImeLinkRegWord->nEudcIMEs = nIMEs;
    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[0];
    for( i = 0; i < nIMEs; i++){
        LRESULT lRet;
#ifndef UNICODE
        UINT    j, uInternal;
#endif
        UINT uReadingSize;

        lpRegWordStructTmp->hKL = *(lphKL + i);
        if( !(lRet = ImmEscape(lpRegWordStructTmp->hKL, (HIMC)NULL,
            IME_ESC_MAX_KEY, NULL))){
            lpImeLinkRegWord->nEudcIMEs--;
            continue;
        }

        uReadingSize = sizeof(TCHAR);

#ifndef UNICODE
        for (j = 0; j < 256; j++) {
            uInternal = ImmEscape(lpRegWordStructTmp->hKL, (HIMC)NULL,
                IME_ESC_SEQUENCE_TO_INTERNAL, &j);
            if (uInternal > 255) {
                uReadingSize = sizeof(WCHAR);
                break;
            }
        }
#endif

        if( lRet * uReadingSize > sizeof(lpRegWordStructTmp->szReading) - sizeof(TCHAR)){
            lpImeLinkRegWord->nEudcIMEs--;
            continue;
        }

        if( !(lRet = ImmEscape(lpRegWordStructTmp->hKL, (HIMC)NULL,
            IME_ESC_IME_NAME, lpRegWordStructTmp->szIMEName))){
            lpImeLinkRegWord->nEudcIMEs--;
            continue;
        }

        lpRegWordStructTmp->szIMEName[
            sizeof(lpRegWordStructTmp->szIMEName) / sizeof(TCHAR) - 1] = '\0';
        lpRegWordStructTmp->uIMENameLen =
            lstrlen( lpRegWordStructTmp->szIMEName);

        lpRegWordStructTmp++;
    }
    if( !lpImeLinkRegWord->nEudcIMEs){
        LoadString( hAppInst, IDS_NOIME_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
        LoadString( hAppInst, IDS_NOIME_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));

        MessageBox( hEudcEditWnd, szMessage, szTitle, MB_OK);
        goto RegWordCreateFreeRegWord;
    }
    LoadString( hAppInst, IDS_CHINESE_CHAR, szStrBuf, sizeof( szStrBuf) / sizeof(TCHAR));
    hDC = GetDC(NULL);
    GetTextExtentPoint( hDC, szStrBuf, lstrlen( szStrBuf), &lTextSize);
    ReleaseDC(NULL, hDC);
    GetWindowRect( hWnd, &rcRect);

    nIMEs = (rcRect.bottom - rcRect.top) / (2 * lTextSize.cy);
    if( lpImeLinkRegWord->nEudcIMEs <= nIMEs){
        nIMEs = lpImeLinkRegWord->nEudcIMEs;
    }
    dwSize = sizeof(IMERADICALRECT) - sizeof(RECT) + sizeof(RECT) *
        RECT_NUMBER * nIMEs;
    lpImeLinkRadical = (LPIMERADICALRECT)GlobalAlloc( GPTR, dwSize);

    if( !lpImeLinkRadical){
        lpImeLinkRegWord->nEudcIMEs = 0;
        LoadString( hAppInst, IDS_NOMEM_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
        LoadString( hAppInst, IDS_NOMEM_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));

        MessageBox( hEudcEditWnd, szMessage, szTitle, MB_OK);
        goto RegWordCreateFreeRegWord;
    }
    lpImeLinkRadical->nStartIME = 0;
    lpImeLinkRadical->nPerPageIMEs = nIMEs;
    lpImeLinkRadical->lTextSize = lTextSize;
    if( lpImeLinkRegWord->nEudcIMEs > nIMEs) {
        SCROLLINFO scInfo;
        lpImeLinkRadical->hScrollWnd = CreateWindowEx( 0,
            TEXT("scrollbar"), NULL, WS_CHILD|WS_VISIBLE|SBS_VERT,
            rcRect.right - rcRect.left - lTextSize.cx, 0,
            lTextSize.cx, rcRect.bottom - rcRect.top,
            hWnd, 0, hAppInst, NULL);

        scInfo.cbSize = sizeof(SCROLLINFO);
        scInfo.fMask = SIF_ALL;
        scInfo.nMin = 0;
        scInfo.nMax = lpImeLinkRegWord->nEudcIMEs - 1 + (nIMEs - 1);
        scInfo.nPage = nIMEs;
        scInfo.nPos = 0;
        scInfo.nTrackPos = 0;
        SetScrollInfo( lpImeLinkRadical->hScrollWnd,
            SB_CTL, &scInfo, FALSE);
    }
    for( i = 0; i < nIMEs; i++){
        UINT j, k;
        j = i * RECT_NUMBER + RECT_IMENAME;
        lpImeLinkRadical->rcRadical[j].left = lTextSize.cx;
        lpImeLinkRadical->rcRadical[j].top = lTextSize.cy *
            (i * 4 + 1) / 2 - UI_MARGIN;

        lpImeLinkRadical->rcRadical[j].right =
            lpImeLinkRadical->rcRadical[j].left + lTextSize.cx * 6;

        lpImeLinkRadical->rcRadical[j].bottom =
            lpImeLinkRadical->rcRadical[j].top + lTextSize.cy +
            UI_MARGIN * 2;

        k = i * RECT_NUMBER + RECT_RADICAL;
        lpImeLinkRadical->rcRadical[k].left =
            lpImeLinkRadical->rcRadical[j].right + lTextSize.cx;

        lpImeLinkRadical->rcRadical[k].top =
            lpImeLinkRadical->rcRadical[j].top;

        lpImeLinkRadical->rcRadical[k].right =
            lpImeLinkRadical->rcRadical[k].left + lTextSize.cx *
            (sizeof(lpRegWordStructTmp->szReading) / sizeof(TCHAR) / 2 - 1);

        lpImeLinkRadical->rcRadical[k].bottom =
            lpImeLinkRadical->rcRadical[k].top + lTextSize.cy +
            UI_MARGIN * 2;
    }
    SetWindowLongPtr(hWnd, GWLP_RADICALRECT, (LONG_PTR)lpImeLinkRadical);

RegWordCreateFreeRegWord:
    if( !lpImeLinkRegWord->nEudcIMEs){
        GlobalFree((HGLOBAL)lpImeLinkRegWord);
        lpImeLinkRegWord = NULL;
    }

RegWordCreateFreeHKL:
    GlobalFree((HGLOBAL)lphKL);
    return( lpImeLinkRegWord);
}

/****************************************/
/*                                      */
/*      Switch To Mouse Clicked IME     */
/*                                      */
/****************************************/
void
SwitchToThisIME(
HWND 	hWnd,
UINT 	uIndex)
{
    LPIMELINKREGWORD  lpImeLinkRegWord;
    LPREGWORDSTRUCT   lpRegWordStructTmp;
    LPIMERADICALRECT  lpImeLinkRadical;
    DWORD             fdwConversionMode, fdwSentenceMode;

    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr( hWnd,
        GWLP_IMELINKREGWORD);

    if( lpImeLinkRegWord->nCurrIME == uIndex)
        return;

    if( uIndex >= lpImeLinkRegWord->nEudcIMEs){
        MessageBeep((UINT)-1);
        return;
    }
    lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
        GWLP_RADICALRECT);

    if( uIndex < lpImeLinkRadical->nStartIME){
        lpImeLinkRadical->nStartIME = uIndex;
    }else if(( uIndex - lpImeLinkRadical->nStartIME) >=
        lpImeLinkRadical->nPerPageIMEs){
        lpImeLinkRadical->nStartIME = uIndex -
            (lpImeLinkRadical->nPerPageIMEs - 1);
    }else{
    }
    SendMessage(hWnd, WM_EUDC_COMPMSG, 0, FALSE);
    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[uIndex];
    ActivateKeyboardLayout(lpRegWordStructTmp->hKL, 0);

    if( !ImmGetConversionStatus(lpImeLinkRegWord->hRegWordIMC,
        &fdwConversionMode, &fdwSentenceMode))
    {
        return;
    }
    
    fdwConversionMode = (fdwConversionMode | IME_CMODE_EUDC |
        IME_CMODE_NATIVE) | (fdwConversionMode & IME_CMODE_SOFTKBD);

    ImmSetConversionStatus(lpImeLinkRegWord->hRegWordIMC,
        fdwConversionMode, fdwSentenceMode);

    SendMessage(hWnd, WM_EUDC_COMPMSG, 0, TRUE);
    lpImeLinkRegWord->nCurrIME = uIndex;

    if(lpImeLinkRadical->hScrollWnd){
        SCROLLINFO scInfo;

        scInfo.cbSize = sizeof(SCROLLINFO);
        scInfo.fMask = SIF_POS;
        scInfo.nPos = lpImeLinkRegWord->nCurrIME;

        SetScrollInfo(lpImeLinkRadical->hScrollWnd,
            SB_CTL, &scInfo, FALSE);
    }
    InvalidateRect(hWnd, NULL, TRUE);

    *(LPTSTR)&lpRegWordStructTmp->szReading[
        lpRegWordStructTmp->dwReadingLen] = '\0';

    ImmSetCompositionString(lpImeLinkRegWord->hRegWordIMC, SCS_SETSTR,
        NULL, 0, lpRegWordStructTmp->szReading,
        lpRegWordStructTmp->dwReadingLen * sizeof(TCHAR));
    SetFocus(hWnd);
    return;
}

/****************************************/
/*                                      */
/*      MESSAGE "WM_IMECOMPOSITION"     */
/*                                      */
/****************************************/
void
WmImeComposition(
HWND   	hWnd,
LPARAM 	lParam)
{
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPREGWORDSTRUCT  lpRegWordStructTmp;
    TCHAR            szReading[sizeof(lpRegWordStructTmp->szReading)/sizeof(TCHAR)];
    LONG             lRet;
    BOOL             bUpdate;

    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr( hWnd,
        GWLP_IMELINKREGWORD);
    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[
        lpImeLinkRegWord->nCurrIME];

    lRet = ImmGetCompositionString(lpImeLinkRegWord->hRegWordIMC,
        GCS_COMPREADSTR, szReading, sizeof(szReading));
    if (lRet < 0) {
        lpRegWordStructTmp->bUpdate = UPDATE_ERROR;
        return;
    }
    if (lRet > (sizeof(szReading) - sizeof(TCHAR))) {
        lRet = sizeof(szReading) - sizeof(TCHAR);
    }
    szReading[lRet / sizeof(TCHAR)] = '\0';

    if( lpRegWordStructTmp->dwReadingLen != (DWORD)lRet / sizeof(TCHAR)){
        bUpdate = TRUE;
    }else if( lstrcmp(lpRegWordStructTmp->szReading, szReading)){
        bUpdate = TRUE;
    }else  bUpdate = FALSE;

    if( bUpdate){
        LPIMERADICALRECT lpImeLinkRadical;
        UINT             i;
        UINT             j, k;

        lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
            GWLP_RADICALRECT);

        lstrcpy( lpRegWordStructTmp->szReading, szReading);

        if( lParam & GCS_RESULTSTR){
            lpRegWordStructTmp->bUpdate = UPDATE_FINISH;
        }else{
            lpRegWordStructTmp->bUpdate = UPDATE_START;
        }

        lpRegWordStructTmp->dwReadingLen = (DWORD)lRet / sizeof(TCHAR);

        if( !IsWindowEnabled(lpImeLinkRadical->hRegWordButton)){
            EnableWindow(lpImeLinkRadical->hRegWordButton, TRUE);
        }

        i = lpImeLinkRegWord->nCurrIME - lpImeLinkRadical->nStartIME;
        j = i * RECT_NUMBER + RECT_IMENAME;
        InvalidateRect(hWnd, &lpImeLinkRadical->rcRadical[j], FALSE);

        k = i * RECT_NUMBER + RECT_RADICAL;

        InvalidateRect(hWnd, &lpImeLinkRadical->rcRadical[k], FALSE);
    }else if( lParam & GCS_RESULTSTR){
        LPIMERADICALRECT lpImeLinkRadical;
        UINT i;
        UINT j, k;

        lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
            GWLP_RADICALRECT);
        if( lpRegWordStructTmp->bUpdate){
            lpRegWordStructTmp->bUpdate = UPDATE_FINISH;
        }
        i = lpImeLinkRegWord->nCurrIME - lpImeLinkRadical->nStartIME;
        j = i * RECT_NUMBER + RECT_IMENAME;
        InvalidateRect(hWnd, &lpImeLinkRadical->rcRadical[j], FALSE);

        k = i * RECT_NUMBER + RECT_RADICAL;
        InvalidateRect(hWnd, &lpImeLinkRadical->rcRadical[k], FALSE);
    }
    return;
}

/************************************************************/
/*                                                          */
/*  lstrcmpn                                                */
/*                                                          */
/************************************************************/
int lstrcmpn(
    LPCTSTR lpctszStr1,
    LPCTSTR lpctszStr2,
    int     cCount)
{
    int i;

    for (i = 0; i < cCount; i++) {
        int iCmp = *lpctszStr1++ - *lpctszStr2++;
        if (iCmp) { return iCmp; }
    }

    return 0;
}

/****************************************/
/*                                      */
/*      CALLBACK  ENUMREADING           */
/*                                      */
/****************************************/
int CALLBACK
EnumReading(
LPCTSTR         lpszReading,
DWORD           dwStyle,
LPCTSTR         lpszString,
LPREGWORDSTRUCT lpRegWordStructTmp)
{
    int     iLen;
    DWORD   dwZeroSeq;
    LRESULT lRet;
    TCHAR   tszZeroSeq[8];

    iLen = lstrlen(lpszReading);

    if (iLen * sizeof(TCHAR) > sizeof(lpRegWordStructTmp->szReading) -
        sizeof(WORD)) {
        return (0);
    }

    lpRegWordStructTmp->dwReadingLen = (DWORD)iLen;

    lstrcpy(lpRegWordStructTmp->szReading, lpszReading);

    dwZeroSeq = 0;
    lRet = ImmEscape(lpRegWordStructTmp->hKL, (HIMC)NULL,
        IME_ESC_SEQUENCE_TO_INTERNAL, &dwZeroSeq);

    if (!lRet) { goto Over; }

    iLen = 0;

    if (LOWORD(lRet)) {
#ifdef UNICODE
        tszZeroSeq[iLen++] = LOWORD(lRet);
#else
        if (LOWORD(lRet) > 0xFF) {
            tszZeroSeq[iLen++] = HIBYTE(LOWORD(lRet));
            tszZeroSeq[iLen++] = LOBYTE(LOWORD(lRet));
        } else {
            tszZeroSeq[iLen++] = LOBYTE(LOWORD(lRet));
        }
#endif
    }

    if (HIWORD(lRet) == 0xFFFF) {
        // This is caused by sign extent in Win9x in the return value of
        // ImmEscape, it causes an invalid internal code.
    } else if (HIWORD(lRet)) {
#ifdef UNICODE
        tszZeroSeq[iLen++] = HIWORD(lRet);
#else
        if (HIWORD(lRet) > 0xFF) {
            tszZeroSeq[iLen++] = HIBYTE(HIWORD(lRet));
            tszZeroSeq[iLen++] = LOBYTE(HIWORD(lRet));
        } else {
            tszZeroSeq[iLen++] = LOBYTE(HIWORD(lRet));
        }
#endif
    } else {
    }

    for (; lpRegWordStructTmp->dwReadingLen > 0;
        lpRegWordStructTmp->dwReadingLen -= iLen) {
        if (lstrcmpn(&lpRegWordStructTmp->szReading[
            lpRegWordStructTmp->dwReadingLen - iLen], tszZeroSeq, iLen) != 0) {
            break;
        }
    }

Over:
    lpRegWordStructTmp->szReading[lpRegWordStructTmp->dwReadingLen] = '\0';

    return (1);
}

/****************************************/
/*                                      */
/*      EUDC CODE Calcurater            */
/*                                      */
/****************************************/
void
EudcCode(
HWND    hWnd,
DWORD   dwComboCode)
{
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPREGWORDSTRUCT  lpRegWordStructTmp;
    UINT             i, uCode;
    BOOL             bUnicodeMode=FALSE;

    WCHAR            TmpCode[1];
    CHAR             TmpCodeAnsi[2];

    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
        GWLP_IMELINKREGWORD);

    uCode = LOWORD(dwComboCode);

    if (HIWORD(dwComboCode)) // the code is in unicode
        bUnicodeMode = TRUE;

#ifdef UNICODE
    if (bUnicodeMode) {
        lpImeLinkRegWord->szEudcCodeString[0] = (WCHAR)uCode;
        lpImeLinkRegWord->szEudcCodeString[1] = TEXT('\0');
    }else{
        TmpCodeAnsi[0] = HIBYTE(uCode);
        TmpCodeAnsi[1] = LOBYTE(uCode);
        //
        // convert to Unicode string
        //
        MultiByteToWideChar(GetACP(), MB_PRECOMPOSED,
            (LPCSTR)TmpCodeAnsi, 2,
            (LPWSTR)TmpCode, 1);

        lpImeLinkRegWord->szEudcCodeString[0] = (WCHAR)TmpCode[0];
        lpImeLinkRegWord->szEudcCodeString[1] = TEXT('\0');
    }
#else //UNICODE
    if (bUnicodeMode) {
        TmpCode[0] = (WCHAR) uCode;

        //
        //  Convert to Ansi byte string
        //
        WideCharToMultiByte(GetACP(), WC_COMPOSITECHECK,
            (LPWSTR)TmpCode, 1,
            (LPSTR)TmpCodeAnsi, 2,
            NULL, NULL);

        lpImeLinkRegWord->szEudcCodeString[0] = TmpCodeAnsi[0];
        lpImeLinkRegWord->szEudcCodeString[1] = TmpCodeAnsi[1];
    }else{
        lpImeLinkRegWord->szEudcCodeString[0] = HIBYTE(uCode);
        lpImeLinkRegWord->szEudcCodeString[1] = LOBYTE(uCode);
    }
#endif //UNICODE

    lpImeLinkRegWord->szEudcCodeString[2] =
        lpImeLinkRegWord->szEudcCodeString[3] = '\0';

    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[0];

    for( i = 0; i < lpImeLinkRegWord->nEudcIMEs; i++){
        lpRegWordStructTmp->bUpdate = UPDATE_NONE;
        lpRegWordStructTmp->szReading[0] = '\0';
        lpRegWordStructTmp->dwReadingLen = 0;

        ImmEnumRegisterWord(lpRegWordStructTmp->hKL, EnumReading,
            NULL, IME_REGWORD_STYLE_EUDC,
            lpImeLinkRegWord->szEudcCodeString,
            lpRegWordStructTmp);

        lpRegWordStructTmp->dwReadingLen =
            lstrlen( lpRegWordStructTmp->szReading);
        lpRegWordStructTmp++;
    }
    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[
        lpImeLinkRegWord->nCurrIME];

    ImmSetCompositionString(lpImeLinkRegWord->hRegWordIMC, SCS_SETSTR,
        NULL, 0, lpRegWordStructTmp->szReading,
        lpRegWordStructTmp->dwReadingLen * sizeof(TCHAR));

    InvalidateRect(hWnd, NULL, FALSE);
    return;
}

/****************************************/
/*                                      */
/*      Change To Mouse Clicked IME     */
/*                                      */
/****************************************/
void
ChangeToOtherIME(
HWND   	hWnd,
LPARAM 	lMousePos)
{
    LPIMERADICALRECT lpImeLinkRadical;
    POINT            ptMouse;
    UINT             i;
    BOOL             bFound;

    ptMouse.x = GET_X_LPARAM( lMousePos);
    ptMouse.y = GET_Y_LPARAM( lMousePos);

    lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr( hWnd,
        GWLP_RADICALRECT);
    bFound = FALSE;
    for( i = 0; i < lpImeLinkRadical->nPerPageIMEs; i++){
        UINT j;

        j = i * RECT_NUMBER + RECT_RADICAL;
        if( PtInRect(&lpImeLinkRadical->rcRadical[j], ptMouse)){
            bFound = TRUE;
            break;
        }
    }
    if( !bFound) return;
    SwitchToThisIME( hWnd, lpImeLinkRadical->nStartIME + i);
    return;
}

/****************************************/
/*                                      */
/*      ScrollUP or Down IME LISTBOX    */
/*                                      */
/****************************************/
void
ScrollIME(
HWND   	hWnd,
WPARAM 	wParam)
{
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPIMERADICALRECT lpImeLinkRadical;
    int              iLines;
    UINT             uIndex;

    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr( hWnd,
        GWLP_IMELINKREGWORD);
    lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr( hWnd,
        GWLP_RADICALRECT);

    switch( LOWORD( wParam)){
    case SB_PAGEDOWN:
        iLines = lpImeLinkRadical->nPerPageIMEs - 1;
        break;
    case SB_LINEDOWN:
        iLines = 1;
        break;
    case SB_PAGEUP:
        iLines = 1 - lpImeLinkRadical->nPerPageIMEs;
        break;
    case SB_LINEUP:
        iLines = -1;
        break;
    case SB_TOP:
        SwitchToThisIME(hWnd, 0);
        return;
    case SB_BOTTOM:
        SwitchToThisIME(hWnd, lpImeLinkRegWord->nEudcIMEs - 1);
        return;
    case SB_THUMBPOSITION:
        SwitchToThisIME(hWnd, HIWORD(wParam));
        return;
    default:
        return;
    }
    uIndex = lpImeLinkRegWord->nCurrIME;
    if( iLines > 0){
        uIndex += (UINT)iLines;
        if( uIndex >= lpImeLinkRegWord->nEudcIMEs){
            uIndex = lpImeLinkRegWord->nEudcIMEs - 1;
        }
    }else{
        UINT uLines;

        uLines = -iLines;
        if( uLines > uIndex){
            uIndex = 0;
        }else  uIndex -= uLines;
    }
    SwitchToThisIME(hWnd, uIndex);
    return;
}

/****************************************/
/*                                      */
/*      ScrollUP or Down IME LISTBOX    */
/*                                      */
/****************************************/
void
ScrollIMEByKey(
HWND   	hWnd,
WPARAM 	wParam)
{
    switch( wParam){
    case VK_NEXT:
        ScrollIME( hWnd, SB_PAGEDOWN);
        break;
    case VK_DOWN:
        ScrollIME( hWnd, SB_LINEDOWN);
        break;
    case VK_PRIOR:
        ScrollIME(hWnd, SB_PAGEUP);
        break;
    case VK_UP:
        ScrollIME(hWnd, SB_LINEUP);
        break;
    default:
        return;
    }
    return;
}

/****************************************/
/*                                      */
/*      Get Focus in RegWord List       */
/*                                      */
/****************************************/
void
RegWordGetFocus(
HWND    hWnd)
{
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPIMERADICALRECT lpImeLinkRadical;
    UINT             i;

    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr( hWnd,
        GWLP_IMELINKREGWORD);
    lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr( hWnd,
        GWLP_RADICALRECT);

    CreateCaret( hWnd, NULL, 2, lpImeLinkRadical->lTextSize.cy +
        CARET_MARGIN * 2);
    if( lpImeLinkRegWord->nCurrIME < lpImeLinkRadical->nStartIME){
        lpImeLinkRegWord->nCurrIME = lpImeLinkRadical->nStartIME;
    }else if(( lpImeLinkRegWord->nCurrIME - lpImeLinkRadical->nStartIME) >=
        lpImeLinkRadical->nPerPageIMEs) {
        lpImeLinkRegWord->nCurrIME = lpImeLinkRadical->nStartIME +
            lpImeLinkRadical->nPerPageIMEs - 1;
    }
    i = lpImeLinkRegWord->nCurrIME - lpImeLinkRadical->nStartIME;
    i = (i * RECT_NUMBER) + RECT_RADICAL;
    SetCaretPos(lpImeLinkRadical->rcRadical[i].left +
        lpImeLinkRadical->lCurrReadingExtent.cx + 2,
        lpImeLinkRadical->rcRadical[i].top + UI_MARGIN - CARET_MARGIN);
    ShowCaret(hWnd);
    return;
}

/****************************************/
/*                                      */
/*      MESSAGE "WM_PAINT"              */
/*                                      */
/****************************************/
void RegWordPaint(
HWND    hWnd)
{
    LPIMERADICALRECT lpImeLinkRadical;
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPREGWORDSTRUCT  lpRegWordStructTmp;
    PAINTSTRUCT      ps;
    HDC              hDC;
    UINT             i;
    UINT             nShowIMEs;

    lpImeLinkRadical = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
        GWLP_RADICALRECT);
    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
        GWLP_IMELINKREGWORD);
    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[
        lpImeLinkRadical->nStartIME];
    HideCaret(hWnd);

    hDC = BeginPaint(hWnd, &ps);

    nShowIMEs = lpImeLinkRegWord->nEudcIMEs - lpImeLinkRadical->nStartIME;
    if( nShowIMEs > lpImeLinkRadical->nPerPageIMEs){
        nShowIMEs = lpImeLinkRadical->nPerPageIMEs;
    }
    for( i = 0; i < nShowIMEs; i++){
        RECT rcSunken;
        UINT j, k;

        k = i * RECT_NUMBER + RECT_RADICAL;
        rcSunken = lpImeLinkRadical->rcRadical[k];
        rcSunken.left -= 2;
        rcSunken.top -= 2;
        rcSunken.right += 2;
        rcSunken.bottom += 2;
        DrawEdge(hDC, &rcSunken, BDR_SUNKENOUTER, BF_RECT);
        SetBkColor(hDC, GetSysColor(COLOR_BTNFACE));
        if( lpRegWordStructTmp->bUpdate == UPDATE_ERROR){
            SetTextColor(hDC, RGB(0xFF, 0x00, 0x00));
        }else if(lpRegWordStructTmp->bUpdate == UPDATE_START){
            SetTextColor(hDC, RGB(0xFF, 0xFF, 0x00));
        }else if(lpRegWordStructTmp->bUpdate == UPDATE_REGISTERED){
            SetTextColor(hDC, RGB(0x00, 0x80, 0x00));
        }else{
            SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
        }
        j = i * RECT_NUMBER + RECT_IMENAME;

        ExtTextOut(hDC, lpImeLinkRadical->rcRadical[j].left,
            lpImeLinkRadical->rcRadical[j].top,
            ETO_OPAQUE | ETO_CLIPPED, &lpImeLinkRadical->rcRadical[j],
            lpRegWordStructTmp->szIMEName,
            lpRegWordStructTmp->uIMENameLen, NULL);

        if(( lpImeLinkRegWord->nCurrIME - lpImeLinkRadical->nStartIME) == i){
            SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
            SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));

            GetTextExtentPoint(hDC, lpRegWordStructTmp->szReading,
                lpRegWordStructTmp->dwReadingLen,
                &lpImeLinkRadical->lCurrReadingExtent);

            SetCaretPos(lpImeLinkRadical->rcRadical[k].left +
                lpImeLinkRadical->lCurrReadingExtent.cx + 2,
                lpImeLinkRadical->rcRadical[k].top +
                UI_MARGIN - CARET_MARGIN);

        }else{
            SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
        }
        ExtTextOut(hDC, lpImeLinkRadical->rcRadical[k].left,
            lpImeLinkRadical->rcRadical[k].top + UI_MARGIN,
            ETO_OPAQUE, &lpImeLinkRadical->rcRadical[k],
            lpRegWordStructTmp->szReading,
            lpRegWordStructTmp->dwReadingLen, NULL);
        lpRegWordStructTmp++;
    }
    EndPaint(hWnd, &ps);
    ShowCaret(hWnd);
    return;
}

/****************************************/
/*                                      */
/*      Registry Word Window Proc       */
/*                                      */
/****************************************/
LRESULT CALLBACK
RegWordWndProc(
HWND   	hWnd,
UINT   	uMsg,
WPARAM 	wParam,
LPARAM 	lParam)
{
    switch( uMsg){
    case WM_CREATE:
        {
            LPIMELINKREGWORD lpImeLinkRegWord;
            UINT uIndex;

            SetWindowLongPtr( hWnd, GWLP_IMELINKREGWORD, 0L);
            SetWindowLongPtr( hWnd, GWLP_RADICALRECT, 0L);
            if( !(lpImeLinkRegWord = RegWordCreate( hWnd)))
                return (-1);
            lpImeLinkRegWord->fCompMsg = TRUE;
            lpImeLinkRegWord->nCurrIME = 0xFFFFFFFF;
            lpImeLinkRegWord->hRegWordIMC = ImmCreateContext();
            if( !lpImeLinkRegWord->hRegWordIMC){
                return (-1);
            }
            lpImeLinkRegWord->hOldIMC = ImmAssociateContext( hWnd,
                lpImeLinkRegWord->hRegWordIMC);

            SetWindowLongPtr(hWnd, GWLP_IMELINKREGWORD, (LONG_PTR)lpImeLinkRegWord);

            uIndex = 0;
            SwitchToThisIME(hWnd, 0);

            PostMessage( hWnd, WM_EUDC_SWITCHIME, 0, uIndex);
        }
        break;
    case WM_EUDC_COMPMSG:
        {
            LPIMELINKREGWORD lpImeLinkRegWord;

            lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
                GWLP_IMELINKREGWORD);
            lpImeLinkRegWord->fCompMsg = (BOOL)lParam;
        }
        break;
    case WM_EUDC_SWITCHIME:
        {
            LPIMELINKREGWORD lpImeLinkRegWord;

            lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr( hWnd,
                GWLP_IMELINKREGWORD);

            lpImeLinkRegWord->nCurrIME = 0xFFFFFFFF;

            SwitchToThisIME( hWnd, (UINT)lParam);
        }
        break;
    case WM_IME_STARTCOMPOSITION:
    case WM_IME_ENDCOMPOSITION:
        break;
    case WM_IME_COMPOSITION:
        {
            LPIMELINKREGWORD lpImeLinkRegWord;

            lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
                GWLP_IMELINKREGWORD);
            if( lpImeLinkRegWord->fCompMsg){
                WmImeComposition(hWnd, lParam);
            }
        }
        break;
    case WM_IME_NOTIFY:
        switch( wParam){
        case IMN_OPENSTATUSWINDOW:
        case IMN_CLOSESTATUSWINDOW:
        case IMN_OPENCANDIDATE:
        case IMN_CHANGECANDIDATE:
        case IMN_CLOSECANDIDATE:
            break;
        default:
            return DefWindowProc( hWnd, uMsg, wParam, lParam);
        }
        break;
    case WM_IME_SETCONTEXT:
        return DefWindowProc( hWnd, uMsg, wParam,
            lParam & ~(ISC_SHOWUIALL));
    case WM_EUDC_REGISTER_BUTTON:
        {
            LPIMERADICALRECT lpImeRadicalRect;

            lpImeRadicalRect = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
                GWLP_RADICALRECT);
            lpImeRadicalRect->hRegWordButton = (HWND)lParam;
        }
        break;
    case WM_EUDC_CODE:
        EudcCode(hWnd, (DWORD)lParam);
        break;
    case WM_LBUTTONDOWN:
        ChangeToOtherIME(hWnd, lParam);
        break;
    case WM_VSCROLL:
        ScrollIME(hWnd, wParam);
        break;
    case WM_KEYDOWN:
        ScrollIMEByKey(hWnd, wParam);
        break;
    case WM_SETFOCUS:
        RegWordGetFocus(hWnd);
        break;
    case WM_KILLFOCUS:
        DestroyCaret();
        break;
    case WM_PAINT:
        RegWordPaint(hWnd);
        break;
    case WM_DESTROY:
        {
            LPIMERADICALRECT lpImeRadicalRect;
            LPIMELINKREGWORD lpImeLinkRegWord;

            lpImeRadicalRect = (LPIMERADICALRECT)GetWindowLongPtr(hWnd,
                GWLP_RADICALRECT);
            if( lpImeRadicalRect){
                GlobalFree((HGLOBAL)lpImeRadicalRect);
            }
            lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
                GWLP_IMELINKREGWORD);
            if (!lpImeLinkRegWord) {
                break;
            }

            ImmAssociateContext(hWnd, lpImeLinkRegWord->hOldIMC);
            ImmDestroyContext(lpImeLinkRegWord->hRegWordIMC);
            GlobalFree((HGLOBAL)lpImeLinkRegWord);
        }
        break;
    default:
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }
    return (0L);
}

/****************************************/
/*                                      */
/*      Regist IME String               */
/*                                      */
/****************************************/
int
RegisterThisEudc(
HWND    hWnd)
{
    LPIMELINKREGWORD lpImeLinkRegWord;
    LPREGWORDSTRUCT  lpRegWordStructTmp;
    UINT             i;
    int              iRet;

    lpImeLinkRegWord = (LPIMELINKREGWORD)GetWindowLongPtr(hWnd,
        GWLP_IMELINKREGWORD);
    lpRegWordStructTmp = &lpImeLinkRegWord->sRegWordStruct[0];
    iRet = -1;

    for( i = 0; i < lpImeLinkRegWord->nEudcIMEs; i++, lpRegWordStructTmp++){
        if (( lpRegWordStructTmp->bUpdate == UPDATE_NONE) ||
            ( lpRegWordStructTmp->bUpdate == UPDATE_REGISTERED))
				{
        }
				else if( lpRegWordStructTmp->bUpdate != UPDATE_FINISH){
            TCHAR szStrBuf[128];
            int   iYesNo;
            if( iRet != -1){
                continue;
            }
            LoadString( hAppInst, IDS_QUERY_NOTFINISH, szStrBuf,
                sizeof(szStrBuf) / sizeof(TCHAR));

            iYesNo = MessageBox(hWnd, szStrBuf,
                lpRegWordStructTmp->szIMEName,
                MB_APPLMODAL|MB_YESNO|MB_DEFBUTTON1);
            if( iYesNo == IDYES){
                iRet = i;
            }
        }else{
            BOOL  fRet;
            TCHAR szStrBuf[128];
            int   iYesNo;

            fRet = ImmRegisterWord(lpRegWordStructTmp->hKL,
                lpRegWordStructTmp->szReading,
                IME_REGWORD_STYLE_EUDC,
                lpImeLinkRegWord->szEudcCodeString);
            if( fRet){
                lpRegWordStructTmp->bUpdate = UPDATE_REGISTERED;
                continue;
            }else{
                lpRegWordStructTmp->bUpdate = UPDATE_ERROR;
            }
            if( iRet != -1){
                continue;
            }
            LoadString(hAppInst, IDS_QUERY_REGISTER, szStrBuf,
                sizeof(szStrBuf) / sizeof(TCHAR));
            iYesNo = MessageBox(hWnd, szStrBuf,
                lpRegWordStructTmp->szIMEName,
                MB_APPLMODAL|MB_YESNO|MB_DEFBUTTON1);
            if( iYesNo == IDYES){
                iRet = i;
            }
        }
    }
    InvalidateRect( hWnd, NULL, FALSE);
    return (iRet);
}

/****************************************/
/*                                      */
/*      CodePage Info                   */
/*                                      */
/****************************************/
int CodePageInfo(
    UINT    uCodePage)
{
    int i;

    for (i = 0; i < sizeof(sCountry) / sizeof(COUNTRYSETTING); i++) {
        if (sCountry[i].uCodePage == uCodePage) {
            return(i);
        }
    }

    return (-1);
}

/****************************************/
/*                                      */
/*  IME LINK LISTBOX DIALOG             */
/*                                      */
/****************************************/
INT_PTR CALLBACK
ImeLinkDlgProc(
HWND    hDlg,
UINT   	uMsg,
WPARAM 	wParam,
LPARAM 	lParam)
{
    switch( uMsg){
    case WM_INITDIALOG:
        {
            HWND    hRadicalWnd, hRegWordButton;
            int     cbString;
            UINT    uCode;
            BOOL    bUnicodeMode=FALSE;
#ifdef UNICODE
            UINT    uCodePage, uNativeCode;
            int     i;
#endif
            TCHAR  szTitle[128];
//            LONG   WindowStyle;

//            WindowStyle = GetWindowLong( hDlg, GWL_EXSTYLE);
//            WindowStyle |= WS_EX_CONTEXTHELP;
//            SetWindowLong( hDlg, GWL_EXSTYLE, WindowStyle);

            cbString = GetWindowText(hDlg, szTitle, sizeof(szTitle) /
                sizeof(TCHAR));

            uCode = LOWORD((DWORD)lParam);
            if (HIWORD((DWORD)lParam))
                bUnicodeMode = TRUE;

#ifdef UNICODE
            if (bUnicodeMode){
                uCodePage = GetACP();

                i = CodePageInfo(uCodePage);

                if (uCodePage == UNICODE_CP || i == -1) {
                    wsprintf(&szTitle[cbString], TEXT("%4X"), (UINT)lParam);
                } else {
                    uNativeCode = 0;

                    WideCharToMultiByte(uCodePage, WC_COMPOSITECHECK,
                        (LPCWSTR)&uCode, 1,
                        (LPSTR)&uNativeCode, sizeof(uNativeCode),
                        NULL, NULL);

                    // convert to multi byte string
                    uNativeCode = LOBYTE(uNativeCode) << 8 | HIBYTE(uNativeCode);

                    wsprintf(&szTitle[cbString], TEXT("%4X (%s - %4X)"),
                        (UINT)uCode, sCountry[i].szCodePage, (UINT)uNativeCode);
                }
            }else{
                wsprintf( &szTitle[cbString], TEXT("%4X"), (UINT)uCode);
            }
#else
            wsprintf( &szTitle[cbString], "%4X", (UINT)uCode);
#endif            	
            SetWindowText( hDlg, szTitle);
            hRadicalWnd = GetDlgItem(hDlg, IDD_RADICAL);
            SendMessage( hRadicalWnd, WM_EUDC_CODE, 0, lParam);

            hRegWordButton = GetDlgItem(hDlg, IDOK);
            EnableWindow( hRegWordButton, FALSE);
            SendMessage( hRadicalWnd, WM_EUDC_REGISTER_BUTTON, 0,
                (LPARAM)hRegWordButton);
        }
        return (TRUE);
    case WM_COMMAND:
        switch( wParam){
        case IDOK:
            {
                HWND    hRadicalWnd;

                hRadicalWnd = GetDlgItem(hDlg, IDD_RADICAL);
                if( RegisterThisEudc(hRadicalWnd) == -1){
                    EndDialog(hDlg, TRUE);
                }else SetFocus(hRadicalWnd);
            }
            break;
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;
        default:
            return (FALSE);
        }
        return( TRUE);
    case WM_IME_NOTIFY:
        switch( wParam){
        case IMN_OPENSTATUSWINDOW:
        case IMN_CLOSESTATUSWINDOW:
            return (TRUE);
        default:
            return (FALSE);
        }
    case WM_HELP:
        {/*
            TCHAR HelpPath[MAX_PATH];

            if( !GetSystemWindowsDirectory( HelpPath, MAX_PATH))
                return FALSE;
            lstrcat(HelpPath, TEXT("\\HELP\\EUDCEDIT.HLP"));
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                HelpPath, HELP_WM_HELP, (DWORD_PTR)(LPDWORD)aIds);
         */
        }
        return FALSE;
    case WM_CONTEXTMENU:
        {/*
            TCHAR HelpPath[MAX_PATH];

            if( !GetSystemWindowsDirectory( HelpPath, MAX_PATH))
                return FALSE;
            lstrcat(HelpPath, TEXT("\\HELP\\EUDCEDIT.HLP"));
            WinHelp((HWND)wParam, HelpPath,
                HELP_CONTEXTMENU, (DWORD_PTR)(LPDWORD)aIds);
         */
        }
        return FALSE;
    default:
        return( FALSE);
    }
    return (TRUE);
}

/****************************************/
/*                                      */
/*      COMMAND "IME LINK"              */
/*                                      */
/****************************************/
void
ImeLink(
HWND        hWnd,
UINT        uCode,
BOOL        bUnicodeMode,
HINSTANCE   hInst)
{
    static  BOOL bFirstTime[20];
    int ii;
    
    WNDCLASSEX  wcClass;
    UINT        nLayouts;
    HKL FAR    *lphKL;
    TCHAR       szTitle[32];
    TCHAR       szMessage[256];
    UINT        i, nIMEs;
    HKL         hOldKL;

    for (ii = 0; ii < ARRAYLEN(bFirstTime); ii++)
      bFirstTime[ii] = TRUE;

    hAppInst = hInst;

    //
    // user32!GetKeyboardLayoutList sometimes return huge number when an AV occurs in IME 
    //
    nLayouts = GetKeyboardLayoutList(0, NULL);
    if (nLayouts > ARRAYLEN(bFirstTime))
    {
       return;
    }

    lphKL = GlobalAlloc(GPTR, sizeof(HKL) * nLayouts);

    if (!lphKL) {
        LoadString(hAppInst, IDS_NOMEM_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
        LoadString(hAppInst, IDS_NOMEM_MSG, szMessage, sizeof(szMessage) /sizeof(TCHAR));
        MessageBox(hWnd, szMessage, szTitle, MB_OK);
        return;
    }

    GetKeyboardLayoutList(nLayouts, lphKL);
    for (i = 0, nIMEs = 0; i < nLayouts; i++) {
        LRESULT  lRet;
        HKL   hKL;
        TCHAR szImeEudcDic[80];

        hKL = *(lphKL + i);
        lRet = ImmIsIME(hKL);
        if (!lRet) {
            continue;
        }
        szImeEudcDic[0] = '\0';

        lRet = ImmEscape(hKL, (HIMC)NULL, IME_ESC_GET_EUDC_DICTIONARY,
            szImeEudcDic);

        if (!lRet) {
            continue;
        }

        if (szImeEudcDic[0]) {
            lRet = TRUE;
        } 
        else if( !bFirstTime[i]) {
        } 
        else {
            lRet = ImmConfigureIME(hKL, hWnd, IME_CONFIG_SELECTDICTIONARY, NULL);
        }
        if (!lRet) {
            continue;
        }
        else {
          bFirstTime[i] = FALSE;
        }

        if (szImeEudcDic[0] == '\0') {
            lRet = ImmEscape(hKL, (HIMC)NULL, IME_ESC_GET_EUDC_DICTIONARY,
                szImeEudcDic);

            if (!lRet) {
                continue;
            } else if (szImeEudcDic[0] == '\0') {
                continue;
            } else {
            }
        } else {
        }
        nIMEs++;
    }
    GlobalFree((HGLOBAL)lphKL);

    if (!nIMEs) {
        LoadString(hAppInst, IDS_NOIME_TITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
        LoadString(hAppInst, IDS_NOIME_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));
        MessageBox(hWnd, szMessage, szTitle, MB_OK);
        return;
    }

    if( !GetClassInfoEx( hAppInst, szRegWordCls, &wcClass)){
        wcClass.cbSize = sizeof(WNDCLASSEX);
        wcClass.style = CS_HREDRAW|CS_VREDRAW;
        wcClass.lpfnWndProc = RegWordWndProc;
        wcClass.cbClsExtra = 0;
        wcClass.cbWndExtra = 2 * sizeof(PVOID);
        wcClass.hInstance = hAppInst;
        wcClass.hIcon = NULL;
        wcClass.hCursor = LoadCursor(NULL, IDC_ARROW);
        wcClass.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
        wcClass.lpszMenuName = NULL;
        wcClass.lpszClassName = szRegWordCls;
        wcClass.hIconSm = NULL;
        RegisterClassEx( &wcClass);
    }
    hOldKL = GetKeyboardLayout(0);
    DialogBoxParam(hAppInst, szImeLinkDlg, hWnd, ImeLinkDlgProc,
        (LPARAM) MAKELONG(uCode , bUnicodeMode ? 0xffff : 0));
    ActivateKeyboardLayout(hOldKL, 0);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\imeblink.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#ifndef RC_INVOKED
#pragma pack(1)
#endif
#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))
//	data structure of IME table 
typedef struct tagUSRDICIMHDR {
    WORD  uHeaderSize;                  // 0x00
    BYTE  idUserCharInfoSign[8];        // 0x02
    BYTE  idMajor;                      // 0x0A
    BYTE  idMinor;                      // 0x0B
    DWORD ulTableCount;                 // 0x0C
    WORD  cMethodKeySize;               // 0x10
    BYTE  uchBankID;                    // 0x12
    WORD  idInternalBankID;             // 0x13
    BYTE  achCMEXReserved1[43];         // 0x15
    WORD  uInfoSize;                    // 0x40
    BYTE  chCmdKey;                     // 0x42
    BYTE  idStlnUpd;                    // 0x43
    BYTE  cbField;                      // 0x44
    WORD  idCP;                         // 0x45
    BYTE  achMethodName[6];             // 0x47
    BYTE  achCSIReserved2[51];          // 0x4D
    BYTE  achCopyRightMsg[128];         // 0x80
} USRDICIMHDR;

#ifndef RC_INVOKED
#pragma pack()
#endif

typedef USRDICIMHDR FAR *LPUSRDICIMHDR;

typedef WCHAR UNALIGNED *LPUNATSTR;

#ifdef __cplusplus
extern "C"
{
#endif

HKL 
RegisterTable( 
HWND            hWnd,
LPUSRDICIMHDR   lpIsvUsrDic,
DWORD           dwFileSize,
UINT            uCodePage);

HKL 
MatchImeName( 
LPCTSTR         szStr);

int
CodePageInfo(
    UINT uCodePage);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\imprtdlg.h ===
/**************************************************/
/*					                              */
/*	Import Bimmap(Windows 3.1)	                  */ 
/*		(Dialogbox)		                          */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

class CImportDlg : public CDialog
{
public:
	CImportDlg(CWnd* pParent = NULL);   // standard constructor

	//{{AFX_DATA(CImportDlg)
	enum { IDD = IDD_IMPORT };
	//}}AFX_DATA
private:
	char	UserFontTitle[MAX_PATH];
	char	EUDCFontTitle[MAX_PATH];

	//{{AFX_VIRTUAL(CImportDlg)
	protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

protected:

	//{{AFX_MSG(CImportDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnFileBrowse();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\imprtdlg.cpp ===
/**************************************************/
/*					                              */
/*					                              */
/*	Convert from bmp to ttf		                  */
/*		(Dialogbox)		                          */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"imprtdlg.h"
#include	"ttfstruc.h"
#include	"extfunc.h"
#include	"util.h"
#define STRSAFE_LIB
#include <strsafe.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

TCHAR	UserFont[MAX_PATH];
TCHAR	EUDCTTF[MAX_PATH];
TCHAR	EUDCBMP[MAX_PATH];

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CImportDlg::CImportDlg( CWnd* pParent)
	: CDialog(CImportDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CImportDlg)
	//}}AFX_DATA_INIT
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_INITDIALOG"		*/
/*					*/
/****************************************/
BOOL
CImportDlg::OnInitDialog()
{
	CString	DlgTitle;

	CDialog::OnInitDialog();

//	Implement "?" in this dialogbox.
//	LONG WindowStyle = GetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE);
//	WindowStyle |= WS_EX_CONTEXTHELP;
//	SetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE, WindowStyle);

//	Set dialog title name.
	DlgTitle.LoadString( IDS_IMPORT_DLGTITLE);
	this->SetWindowText( DlgTitle);

	return TRUE;
}

/****************************************/
/*					*/
/*	COMMAND	"BROWSE"		*/
/*					*/
/****************************************/
void
CImportDlg::OnFileBrowse()
{
OPENFILENAME	ofn;
	CString	DlgTtl, DlgMsg;
	CString	sFilter;
	CWnd	*cWnd;
	TCHAR	chReplace;
	TCHAR 	szFilter[MAX_PATH];
	TCHAR	szFileName[MAX_PATH];
	TCHAR	szTitleName[MAX_PATH];
	TCHAR	szDirName[MAX_PATH];
	HRESULT hresult;

	if( CountryInfo.LangID == EUDC_JPN){
//		Set filter of file( from string table)
		GetStringRes(szFilter, IDS_IMPORT_JAPAN_FILTER, ARRAYLEN(szFilter));
		int StringLength = lstrlen( szFilter);

		chReplace = szFilter[StringLength-1];
		for( int i = 0; szFilter[i]; i++){
			if( szFilter[i] == chReplace)
				szFilter[i] = '\0';
		}
		GetSystemWindowsDirectory( szDirName, sizeof(szDirName)/sizeof(TCHAR));
		//*STRSAFE* 		lstrcpy( szFileName, TEXT("USERFONT.FON"));
		hresult = StringCchCopy(szFileName , ARRAYLEN(szFileName),  TEXT("USERFONT.FON"));
		if (!SUCCEEDED(hresult))
		{
		   return ;
		}
		DlgTtl.LoadString( IDS_BROWSEUSER_DLGTITLE);

//		Set data in structure of OPENFILENAME
		ofn.lStructSize = sizeof( OPENFILENAME);
		ofn.hInstance = AfxGetInstanceHandle();
		ofn.hwndOwner = this->GetSafeHwnd();
		ofn.lpstrFilter = szFilter;
		ofn.lpstrCustomFilter = NULL;
		ofn.nMaxCustFilter = 0;
		ofn.nFilterIndex = 0;
		ofn.lpstrFile = szFileName;
		ofn.lpstrFileTitle = szTitleName;
		ofn.nMaxFileTitle = sizeof( szTitleName) / sizeof(TCHAR);
		ofn.nMaxFile = sizeof( szFileName) / sizeof(TCHAR);
		ofn.lpstrInitialDir = szDirName;
		ofn.Flags = OFN_HIDEREADONLY | OFN_NOCHANGEDIR
			 | OFN_PATHMUSTEXIST;
		ofn.lpstrDefExt = NULL;
		ofn.lpstrTitle = DlgTtl;

		if( !GetOpenFileName( &ofn)){
			return;
		}

		memcpy( UserFont, ofn.lpstrFile, sizeof( UserFont));
		this->SetDlgItemText( IDC_BMP_IMPUT, ofn.lpstrFile);
#ifdef BUILD_ON_WINNT
        if( OExistUserFont( UserFont) != 1){
			OutputMessageBoxEx( this->GetSafeHwnd(),
				IDS_IMPORT_DLGTITLE,
				AFX_IDP_FAILED_INVALID_PATH, TRUE, UserFont);

			cWnd = this->GetDlgItem( IDC_BMP_IMPUT);
			GotoDlgCtrl( cWnd);
			return;
        }
#endif // BUILD_ON_WINNT
		if( isW31JEUDCBMP( UserFont) != 1){
			OutputMessageBox( this->GetSafeHwnd(),
				IDS_IMPORT_DLGTITLE,
				IDS_NOTUSERFONT_MSG, TRUE);

			cWnd = this->GetDlgItem( IDC_BMP_IMPUT);
			GotoDlgCtrl( cWnd);
			return;
		}
		cWnd = GetDlgItem( IDOK);
		GotoDlgCtrl( cWnd);
	}else if( CountryInfo.LangID == EUDC_CHT ||
		  CountryInfo.LangID == EUDC_CHS ){
//		Set filter of file( from string table)
		GetStringRes(szFilter, IDS_IMPORT_CHINA_FILTER, ARRAYLEN(szFilter));
		int StringLength = lstrlen( szFilter);

		chReplace = szFilter[StringLength-1];
		for( int i = 0; szFilter[i]; i++){
			if( szFilter[i] == chReplace)
				szFilter[i] = '\0';
		}
		GetSystemWindowsDirectory( szDirName, sizeof(szDirName)/sizeof(TCHAR));
		//*STRSAFE* 		lstrcpy( szFileName, TEXT("*.*"));
		hresult = StringCchCopy(szFileName , ARRAYLEN(szFileName),  TEXT("*.*"));
		if (!SUCCEEDED(hresult))
		{
		   return ;
		}
		DlgTtl.LoadString( IDS_BROWSEUSER_DLGTITLE);

//		Set data in structure of OPENFILENAME
		ofn.lStructSize = sizeof( OPENFILENAME);
		ofn.hwndOwner = this->GetSafeHwnd();
		ofn.hInstance = AfxGetInstanceHandle();
		ofn.lpstrFilter = szFilter;
		ofn.lpstrCustomFilter = NULL;
		ofn.nMaxCustFilter = 0;
		ofn.nFilterIndex = 0;
		ofn.lpstrFileTitle = szTitleName;
		ofn.nMaxFileTitle = sizeof( szTitleName) / sizeof(TCHAR);
		ofn.lpstrFile = szFileName;
		ofn.nMaxFile = sizeof( szFileName) / sizeof(TCHAR);
		ofn.lpstrInitialDir = szDirName;
		ofn.Flags = OFN_HIDEREADONLY | OFN_NOCHANGEDIR
			 | OFN_PATHMUSTEXIST;
		ofn.lpstrDefExt = NULL;
		ofn.lpstrTitle = DlgTtl;

		if( !GetOpenFileName( &ofn))
			return;

		memcpy( UserFont, ofn.lpstrFile, sizeof( UserFont));
		this->SetDlgItemText( IDC_BMP_IMPUT, ofn.lpstrFile);
#ifdef BUILD_ON_WINNT
        if( OExistUserFont( UserFont) != 1){
			OutputMessageBoxEx( this->GetSafeHwnd(),
				IDS_IMPORT_DLGTITLE,
				AFX_IDP_FAILED_INVALID_PATH, TRUE, UserFont);

			cWnd = this->GetDlgItem( IDC_BMP_IMPUT);
			GotoDlgCtrl( cWnd);
			return;
        }
#endif // BUILD_ON_WINNT
		if( isETENBMP( UserFont) != 1){
			OutputMessageBox( this->GetSafeHwnd(),
				IDS_IMPORT_DLGTITLE,
				IDS_NOTUSERFONT_MSG, TRUE);

			cWnd = this->GetDlgItem( IDC_BMP_IMPUT);
			GotoDlgCtrl( cWnd);
			return;
		}

		cWnd = GetDlgItem( IDOK);
		GotoDlgCtrl( cWnd);
	}
}

/****************************************/
/*					*/
/*	COMMAND	"IDOK"			*/
/*					*/
/****************************************/
void
CImportDlg::OnOK()
{
	TCHAR 	*FilePtr;
	CWnd	*cWnd;
	HRESULT hresult;

	//*STRSAFE* 	lstrcpy(EUDCTTF,SelectEUDC.m_File);
	hresult = StringCchCopy(EUDCTTF , ARRAYLEN(EUDCTTF), SelectEUDC.m_File);
	if (!SUCCEEDED(hresult))
	{
	   goto RET ;
	}
	//*STRSAFE* 	lstrcpy( EUDCBMP, EUDCTTF);
	hresult = StringCchCopy(EUDCBMP , ARRAYLEN(EUDCBMP),  EUDCTTF);
	if (!SUCCEEDED(hresult))
	{
	   goto RET ;
	}
	if(( FilePtr = Mytcsrchr( EUDCBMP, '.')) != NULL)
		*FilePtr = '\0';
	//*STRSAFE* 	lstrcat( EUDCBMP, TEXT(".EUF"));
	hresult = StringCchCat(EUDCBMP , ARRAYLEN(EUDCBMP),  TEXT(".EUF"));
	if (!SUCCEEDED(hresult))
	{
	   goto RET ;
	}
	if( !this->GetDlgItemText(IDC_BMP_IMPUT, UserFont, MAX_PATH)){
		OutputMessageBox( this->GetSafeHwnd(),
			IDS_IMPORT_DLGTITLE,
			IDS_NOTUSERFONT_MSG, TRUE);

		cWnd = this->GetDlgItem( IDC_BMP_IMPUT);
		GotoDlgCtrl( cWnd);
		return;
	}
	if( CountryInfo.LangID == EUDC_JPN){
#ifdef BUILD_ON_WINNT
        if( OExistUserFont( UserFont) != 1){
			OutputMessageBoxEx( this->GetSafeHwnd(),
				IDS_IMPORT_DLGTITLE,
				AFX_IDP_FAILED_INVALID_PATH, TRUE, UserFont);

			cWnd = this->GetDlgItem( IDC_BMP_IMPUT);
			GotoDlgCtrl( cWnd);
			return;
        }
#endif // BUILD_ON_WINNT
		if( isW31JEUDCBMP( UserFont) != 1){
			OutputMessageBox( this->GetSafeHwnd(),
				IDS_IMPORT_DLGTITLE,
				IDS_NOTUSERFONT_MSG, TRUE);

			cWnd = this->GetDlgItem( IDC_BMP_IMPUT);
			GotoDlgCtrl( cWnd);
			return;
		}
	}else{
#ifdef BUILD_ON_WINNT
        if( OExistUserFont( UserFont) != 1){
			OutputMessageBoxEx( this->GetSafeHwnd(),
				IDS_IMPORT_DLGTITLE,
				AFX_IDP_FAILED_INVALID_PATH, TRUE, UserFont);

			cWnd = this->GetDlgItem( IDC_BMP_IMPUT);
			GotoDlgCtrl( cWnd);
			return;
        }
#endif // BUILD_ON_WINNT
		if( isETENBMP( UserFont) != 1){
			OutputMessageBox( this->GetSafeHwnd(),
				IDS_IMPORT_DLGTITLE,
				IDS_NOTUSERFONT_MSG, TRUE);

			cWnd = this->GetDlgItem( IDC_BMP_IMPUT);
			GotoDlgCtrl( cWnd);
			return;
		}
	}
RET:
	EndDialog(IDOK);
}

static DWORD aIds[] =
{
  IDC_STATICBMP,    IDH_EUDC_IMPOBMP,
	IDC_BMP_IMPUT,		IDH_EUDC_IMPOBMP,
	IDC_FILE_BROWSE,	IDH_EUDC_BROWSE,
	0,0
};

/****************************************/
/*					*/
/*	Window procedure		*/
/*					*/
/****************************************/
LRESULT
CImportDlg::WindowProc(
UINT 	message,
WPARAM 	wParam,
LPARAM 	lParam)
{/*
	if( message == WM_HELP){
		::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
			HelpPath, HELP_WM_HELP, (DWORD_PTR)(LPTSTR)aIds);
		return(0);
	}
	if( message == WM_CONTEXTMENU){
		::WinHelp((HWND)wParam, HelpPath,
			HELP_CONTEXTMENU, (DWORD_PTR)(LPTSTR)aIds);
		return(0);
	}
 */
	return CDialog::WindowProc(message, wParam, lParam);
}

BEGIN_MESSAGE_MAP(CImportDlg, CDialog)
	//{{AFX_MSG_MAP(CImportDlg)
	ON_BN_CLICKED(IDC_FILE_BROWSE, OnFileBrowse)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\imeblink.c ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#include    <windows.h>
#include    <imm.h>
#include    "resource.h"
#include    "imeblink.h"

#define     UNICODE_CP      1200

/************************************************************/
/*  MatchImeName()                                          */
/************************************************************/
HKL MatchImeName(
    LPCTSTR szStr)
{
    TCHAR     szImeName[MAX_PATH];
    int       nLayout;
    HKL       hKL=NULL;
    HGLOBAL   hMem;
    HKL FAR * lpMem;
    int       i;

    if (!szStr)
   {
        return hKL;
   }
    nLayout = GetKeyboardLayoutList(0, NULL);

    // alloc temp buffer
    hMem = GlobalAlloc(GHND, sizeof(HKL) * nLayout);

    if (!hMem) {
        return (NULL);
    }

    lpMem = (HKL FAR *)GlobalLock(hMem);

    if (!lpMem) {
        GlobalFree(hMem);
        return (NULL);
    }

    // get all keyboard layouts, it includes all IMEs
    GetKeyboardLayoutList(nLayout, lpMem);

    for (i = 0; i < nLayout; i++) {
        LRESULT lRet;

        hKL = *(lpMem + i);

        lRet = ImmEscape(hKL, (HIMC)NULL, IME_ESC_IME_NAME, szImeName);

        if (!lRet) {                // this hKL can not ask name
            continue;
        }

        if (lstrcmp(szStr, szImeName) == 0) {
            goto MatchOvr;
        }
    }

    hKL = NULL;

MatchOvr:
    GlobalUnlock(hMem);
    GlobalFree(hMem);

    return (hKL);
}

/************************************************************/
/*  RegisterTable()                                         */
/************************************************************/
HKL RegisterTable(
    HWND          hWnd,
    LPUSRDICIMHDR lpIsvUsrDic,
    DWORD         dwFileSize,
    UINT          uCodePage)
{
    HKL    hKL=NULL;
   // HDC    hDC;
   // SIZE   lTextSize;
   // RECT   rcProcess;
    DWORD  i;
    LPBYTE lpCurr, lpEnd;
    BOOL   fRet;
    TCHAR  szStr[ARRAYLEN(lpIsvUsrDic->achMethodName)];
   // TCHAR  szProcessFmt[32];
   // TCHAR  szResult[2][32];
   // TCHAR  szProcessInfo[48];
    WORD   wInternalCode[256];
    WORD   wAltInternalCode[256];

    if (!lpIsvUsrDic)
    {
        return hKL;
    }
#ifdef UNICODE
    if (uCodePage == UNICODE_CP) {
        LPUNATSTR lpszMethodName;

        lpszMethodName = (LPUNATSTR)lpIsvUsrDic->achMethodName;

        for (i = 0; i < sizeof(lpIsvUsrDic->achMethodName) / sizeof(TCHAR); i++) {
            szStr[i] = *lpszMethodName++;
        }

        szStr[i] = '\0';
    } else {
        UINT uLen;

        uLen = MultiByteToWideChar(uCodePage, MB_PRECOMPOSED,
            (LPCSTR)lpIsvUsrDic->achMethodName,
            sizeof(lpIsvUsrDic->achMethodName),
            szStr,
            ARRAYLEN(szStr));
        if (uLen == 0)
        {
            uCodePage = CP_ACP;
            uLen = MultiByteToWideChar(uCodePage, MB_PRECOMPOSED,
                (LPCSTR)lpIsvUsrDic->achMethodName,
                sizeof(lpIsvUsrDic->achMethodName),
                szStr,
                ARRAYLEN(szStr));
        }

        szStr[uLen] = '\0';
    }
#else
    for (i = 0; i < sizeof(lpIsvUsrDic->achMethodName); i++) {
        szStr[i] = lpIsvUsrDic->achMethodName[i];
    }

    szStr[i] = '\0';
#endif

    hKL = MatchImeName(szStr);

    if (!hKL) {
        return (hKL);
    }

    // convert sequence code to internal code
    for (i = 0; i < sizeof(wInternalCode) / sizeof(WORD); i++) {
        LRESULT lRet;

        lRet = ImmEscape(hKL, (HIMC)NULL,
            IME_ESC_SEQUENCE_TO_INTERNAL, &i);

        if (HIWORD(lRet) == 0xFFFF) {
            // This is caused by sign extent in Win9x in the return value of
            // ImmEscape, it causes an invalid internal code.
            wAltInternalCode[i] = 0;
        } else {
            wAltInternalCode[i] = HIWORD(lRet);
        }

        wInternalCode[i] = LOWORD(lRet);

#ifndef UNICODE
        if (wAltInternalCode[i] > 0xFF) {
            // convert to multi byte string
            wAltInternalCode[i] = LOBYTE(wAltInternalCode[i]) << 8 |
                HIBYTE(wAltInternalCode[i]);
        }

        if (wInternalCode[i] > 0xFF) {
            // convert to multi byte string
            wInternalCode[i] = LOBYTE(wInternalCode[i]) << 8 |
                HIBYTE(wInternalCode[i]);
        }
#endif
    }

    // check for each record and register it
    // get to the first record and skip the Bank ID
    lpCurr = (LPBYTE)(lpIsvUsrDic + 1) + sizeof(WORD);
    lpEnd = (LPBYTE)lpIsvUsrDic + dwFileSize;

    for (; lpCurr < lpEnd;
        // internal code + sequence code + Bank ID of next record
        lpCurr += sizeof(WORD) + lpIsvUsrDic->cMethodKeySize + sizeof(WORD)) {

        int j;

        // quick way to init \0 for the register string
        *(LPDWORD)szStr = 0;

#ifdef UNICODE
        if (uCodePage == UNICODE_CP) {
            szStr[0] = *(LPUNATSTR)lpCurr;
        } else {
            CHAR szMultiByte[4];

            szMultiByte[0] = HIBYTE(*(LPTSTR)lpCurr);
            szMultiByte[1] = LOBYTE(*(LPTSTR)lpCurr);

            MultiByteToWideChar(uCodePage, MB_PRECOMPOSED,
                szMultiByte, 2, szStr, 2);
        }
#else
        szStr[1] = *lpCurr;
        szStr[0] = *(lpCurr + 1);
#endif

        for (i = 0, j = 0; i < lpIsvUsrDic->cMethodKeySize; i++) {
           if ((*(LPBYTE)(lpCurr + sizeof(WORD) + i)  >= ARRAYLEN(wAltInternalCode)) ||
           	  ((4+j) >= ARRAYLEN(szStr)) )
           {
               return NULL;
           }
           
            if (!wAltInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)]) {
            } else if (wAltInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)] < 0xFF) {
                *(LPTSTR)&szStr[4 + j] = (TCHAR)
                    wAltInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)];
                j += sizeof(TCHAR) / sizeof(TCHAR);
            } else {
                *(LPWSTR)&szStr[4 + j] = (WCHAR)
                    wAltInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)];
                j += sizeof(WCHAR) / sizeof(TCHAR);
            }

            if (wInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)] < 0xFF) {
                *(LPTSTR)&szStr[4 + j] = (TCHAR)
                    wInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)];
                j += sizeof(TCHAR) / sizeof(TCHAR);
            } else {
                *(LPWSTR)&szStr[4 + j] = (WCHAR)
                    wInternalCode[*(LPBYTE)(lpCurr + sizeof(WORD) + i)];
                j += sizeof(WCHAR) / sizeof(TCHAR);
            }
        }
       if ( (j+4+2) >= ARRAYLEN(szStr))
       {
          return NULL;
       }	
        szStr[4 + j] = szStr[4 + j + 1] = szStr[4 + j + 2] = '\0';

        fRet = ImmRegisterWord(hKL, &szStr[4], IME_REGWORD_STYLE_EUDC,
            szStr);
    }

    return (hKL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\mainfrm.cpp ===
/**************************************************/
/*						                          */
/*						                          */
/*	MDI Mainframe window class		              */
/*						                          */
/*						                          */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"mainfrm.h"
#include 	"editwnd.h"
#include 	"refrwnd.h"
#include 	"eudcdlg.h"
#include 	"refrdlg.h"
#include	"registry.h"
#include	"assocdlg.h"
#include	"imprtdlg.h"
#include	"gagedlg.h"
#include	"blinkdlg.h"
#include	"util.h"
#include	"rotatdlg.h"
#include	"extfunc.h"
extern "C"
{
#include	"imelist.h"
}

#define STRSAFE_LIB
#include <strsafe.h>

#define		BUFFERMAX	800

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//	Global paramter
BOOL	TitleFlag;
extern CPoint	PalettePt;
CEditWnd	*pEditChild;
CRefrWnd *pRefrChild;
extern BOOL SetCountryInfo(UINT LocalCP);

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)
BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_COMMAND_EX(IDW_STYLES, OnStylesBar)
	ON_UPDATE_COMMAND_UI(IDW_STYLES, OnUpdateStylesBar)
	ON_UPDATE_COMMAND_UI(ID_TOOLBAR, OnUpdateToolbar)
	ON_WM_DESTROY()
	ON_COMMAND(ID_REFFERFILE_NEW, OnRefferfileNew)
	ON_COMMAND(ID_READ_CHAR, OnReadChar)
	ON_UPDATE_COMMAND_UI(ID_REFFERFILE_NEW, OnUpdateRefferfileNew)
	ON_COMMAND(ID_TOOLBAR, OnToolbar)
	ON_COMMAND(ID_REFFER_CLOSE, OnRefferClose)
	ON_UPDATE_COMMAND_UI(ID_REFFER_CLOSE, OnUpdateRefferClose)
	ON_WM_CLOSE()
	ON_COMMAND(ID_SHOW_GRID, OnShowGrid)
	ON_UPDATE_COMMAND_UI(ID_SHOW_GRID, OnUpdateShowGrid)
	ON_COMMAND(ID_SELECTFAMILY, OnSelectfamily)
	ON_COMMAND(ID_SAVECHAR, OnSavechar)
	ON_UPDATE_COMMAND_UI(ID_SAVECHAR, OnUpdateSavechar)
	ON_COMMAND(ID_SAVE_CHARAS, OnSaveCharas)
	ON_UPDATE_COMMAND_UI(ID_SAVE_CHARAS, OnUpdateSaveCharas)
	ON_COMMAND(ID_LINKIME, OnLinkime)
	ON_WM_INITMENU()
	ON_UPDATE_COMMAND_UI(ID_READ_CHAR, OnUpdateReadChar)
	ON_UPDATE_COMMAND_UI(ID_LINKIME, OnUpdateLinkime)
	ON_COMMAND(ID_NEXTCODE, OnNextcode)
	ON_UPDATE_COMMAND_UI(ID_NEXTCODE, OnUpdateNextcode)
	ON_COMMAND(ID_PREVCODE, OnPrevcode)
	ON_UPDATE_COMMAND_UI(ID_PREVCODE, OnUpdatePrevcode)
	ON_COMMAND(ID_CALL_CHAR, OnCallChar)
	ON_UPDATE_COMMAND_UI(ID_CALL_CHAR, OnUpdateCallChar)
	ON_COMMAND(ID_IMPORT_FILE, OnImportFile)
	ON_UPDATE_COMMAND_UI(ID_IMPORT_FILE, OnUpdateImportFile)
	ON_COMMAND(ID_LINKBATCHMODE, OnLinkbatchmode)
	ON_UPDATE_COMMAND_UI(ID_LINKBATCHMODE, OnUpdateLinkbatchmode)
	ON_COMMAND(ID_HELP, OnHelp)
	ON_COMMAND(ID_FIT_CURVE, OnFitCurve)
	ON_UPDATE_COMMAND_UI(ID_FIT_CURVE, OnUpdateFitCurve)
	ON_COMMAND(ID_ROTATE, OnRotate)
	ON_UPDATE_COMMAND_UI(ID_ROTATE, OnUpdateRotate)
	ON_COMMAND(ID_PALETTEBRUSH, OnPalettebrush)
	ON_UPDATE_COMMAND_UI(ID_PALETTEBRUSH, OnUpdatePalettebrush)
	ON_COMMAND(ID_PALETTECIRCLE, OnPalettecircle)
	ON_UPDATE_COMMAND_UI(ID_PALETTECIRCLE, OnUpdatePalettecircle)
	ON_COMMAND(ID_PALETTECIRCLEFILL, OnPalettecirclefill)
	ON_UPDATE_COMMAND_UI(ID_PALETTECIRCLEFILL, OnUpdatePalettecirclefill)
	ON_COMMAND(ID_PALETTEFREEFORM, OnPalettefreeform)
	ON_UPDATE_COMMAND_UI(ID_PALETTEFREEFORM, OnUpdatePalettefreeform)
	ON_COMMAND(ID_PALETTEERASER, OnPaletteeraser)
	ON_UPDATE_COMMAND_UI(ID_PALETTEERASER, OnUpdatePaletteeraser)
	ON_COMMAND(ID_PALETTEPEN, OnPalettepen)
	ON_UPDATE_COMMAND_UI(ID_PALETTEPEN, OnUpdatePalettepen)
	ON_COMMAND(ID_PALETTERECT, OnPaletterect)
	ON_UPDATE_COMMAND_UI(ID_PALETTERECT, OnUpdatePaletterect)
	ON_COMMAND(ID_PALETTERECTBAND, OnPaletterectband)
	ON_UPDATE_COMMAND_UI(ID_PALETTERECTBAND, OnUpdatePaletterectband)
	ON_COMMAND(ID_PALETTERECTFILL, OnPaletterectfill)
	ON_UPDATE_COMMAND_UI(ID_PALETTERECTFILL, OnUpdatePaletterectfill)
	ON_COMMAND(ID_PALETTESLOPE, OnPaletteslope)
	ON_UPDATE_COMMAND_UI(ID_PALETTESLOPE, OnUpdatePaletteslope)
	ON_CBN_SELCHANGE(IDC_SELECTCHARSET, OnSelectCharSet)

	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT BASED_CODE Palette[] =
{
//	Correspond to palette bitmap data
	ID_PALETTEPEN,
	ID_PALETTEBRUSH,
	ID_PALETTESLOPE,
	ID_PALETTERECT,
	ID_PALETTERECTFILL,
	ID_PALETTECIRCLE,
	ID_PALETTECIRCLEFILL,
	ID_PALETTERECTBAND,
	ID_PALETTEFREEFORM,
	ID_PALETTEERASER
};

/************************************************/
/*						*/
/*	Constructor				*/
/*						*/	
/************************************************/
CMainFrame::CMainFrame()
{
	CustomWndOpen = FALSE;		// Whether edit open or not
	RefferWndVisible = FALSE;	// Whether referrence visible or not
	ToolBarVisible = TRUE;		// Whether toolbox visible or not
	GuideBarVisible = TRUE;		// Whether guidebar visible or not
}

/************************************************/
/*						*/
/*	Destructor				*/
/*						*/
/************************************************/
CMainFrame::~CMainFrame()
{
}

/************************************************/
/*						*/
/*	Create MDI mainframe window 		*/
/*						*/
/************************************************/
BOOL
CMainFrame::Create(
LPCTSTR WndTitle,
DWORD 	WndStyle,
RECT 	MainWndRect,
LPCTSTR 	nID)
{
//	Register MDI mainframe window class
	const TCHAR *MainWndClass =
	AfxRegisterWndClass( 0, AfxGetApp()->LoadStandardCursor(IDC_ARROW),
		 	(HBRUSH)(COLOR_WINDOW+1),
		 	 AfxGetApp()->LoadIcon(IDR_MAINFRAME));

	if( !CFrameWnd::Create( MainWndClass,
		WndTitle, WndStyle, MainWndRect, NULL, nID))
		return FALSE;

	return TRUE;
}

/************************************************/
/*						*/
/*	Process before MDI mainframe create	*/
/*						*/
/************************************************/
int
CMainFrame::OnCreate(
LPCREATESTRUCT lpCreateStruct)
{
	if( CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	if( !LoadAccelTable( MAKEINTRESOURCE(IDR_MAINFRAME)))
		return -1;
	if( !CreateGuideBar())
		return -1;
	if( !CreateToolBar())
		return -1;
	EnableDocking(CBRS_ALIGN_ANY);

	if( !CreateReferWnd())
		return -1;
	m_wndToolBar.EnableDocking(CBRS_ALIGN_TOP | CBRS_ALIGN_LEFT);
	DockControlBar(&m_wndToolBar);
 	return 0;
}

/************************************************/
/*						*/
/*	Create client area			*/
/*						*/
/************************************************/
BOOL
CMainFrame::OnCreateClient(
LPCREATESTRUCT	lpcs,
CCreateContext 	*pContext)
{
	if( !CMDIFrameWnd::CreateClient( lpcs, NULL))
		return FALSE;

	return TRUE;
}

/************************************************/
/*						*/
/*	Create tool bar ( left side)		*/
/*						*/
/************************************************/
BOOL
CMainFrame::CreateToolBar()
{
	if( !m_wndToolBar.Create( this, WS_CHILD | WS_VISIBLE | CBRS_LEFT |
			CBRS_TOOLTIPS, 0)||
	    !m_wndToolBar.LoadBitmap( IDR_MAINFRAME)   ||
	    !m_wndToolBar.SetButtons( Palette,
	    sizeof( Palette)/sizeof( UINT)))
		return FALSE;
	else
		return TRUE;
}



/************************************************/
/*						*/
/*	Create Guideline bar ( upper side)	*/
/*						*/
/************************************************/
BOOL
CMainFrame::CreateGuideBar()
{
	const UINT nIndicators[] = {IDS_CHARSET_STR,
								IDS_CODE_STR,
								IDS_FONT_STR,
								IDS_FILE_STR};
	
	if( !m_wndGuideBar.Create( this, ID_TOOLBAR) ||
		!m_wndGuideBar.SetIndicators(nIndicators,
			sizeof(nIndicators)/sizeof(UINT)))
		return FALSE;
	else{
		m_wndGuideBar.PositionStatusPane();	
		return TRUE;
	}
}




/************************************************/
/*						*/
/*	COMMAND 	"ASSOCIATIONS"		*/
/*						*/
/************************************************/
void
CMainFrame::OnSelectfamily()
{
	CAssocDlg	dlg;

	if( CustomWndOpen){
		if( !OutputSaveMessage())
			return;
	}
	if( dlg.DoModal() == IDOK){
		if( CustomWndOpen){
			pEditChild->UpdateBitmap();
			pEditChild->SelectCodes();
		}
		m_wndGuideBar.PositionStatusPane();
	
	}
}

/************************************************/
/*						*/
/*	COMMAND 	"SELECTCODE"		*/
/*						*/
/************************************************/
void
CMainFrame::OnReadChar()
{
	CEudcDlg	dlg;
	HRESULT hresult;

	if( CustomWndOpen){
		if( !OutputSaveMessage())
			return;
	}
	dlg.WorRFlag = FALSE;
	if( dlg.DoModal() == IDOK){
		AfxGetApp()->DoWaitCursor(1);

		EudcWndRect.SetRectEmpty();
		if( !CustomWndOpen){
//			CalcEudcWndRect();
			CEditWnd *pEudcWnd = new CEditWnd;
			if( !pEudcWnd->Create( TEXT("EDITWINDOW"),
			    WS_CHILD | WS_VISIBLE | WS_BORDER,
			    EudcWndRect,this))
				return;
					
			pEditChild = pEudcWnd;
			SetEudcWndPos();			
			pEudcWnd->ShowWindow( SW_SHOWNORMAL);
			pEudcWnd->UpdateWindow();
			CustomWndOpen = TRUE;
		}
		pEditChild->UpdateBitmap();
		pEditChild->UpdateCode = dlg.m_EditList.SelectCode;
		pEditChild->SelectCodes();
		//*STRSAFE* 		wsprintf( SelectEUDC.m_Code, TEXT("%X"), dlg.m_EditList.SelectCode);
		hresult = StringCchPrintf(SelectEUDC.m_Code , ARRAYLEN(SelectEUDC.m_Code),  TEXT("%X"), dlg.m_EditList.SelectCode);
		if (!SUCCEEDED(hresult))
		{
		   return;
		}
	
		CountryInfo.CurrentRange = dlg.m_EditList.cRange;
		m_wndGuideBar.PositionStatusPane();
	
		AfxGetApp()->DoWaitCursor( -1);
	}
}

/************************************************/
/*						*/
/*	COMMAND		"SELECTCODE" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateReadChar(
CCmdUI* pCmdUI)
{
	if( SelectEUDC.m_Font[0] != TEXT('\0') &&
		InqTypeFace((TCHAR *)SelectEUDC.m_Font,
	  ( TCHAR *)SelectEUDC.m_File, sizeof( SelectEUDC.m_File)/sizeof(TCHAR)))
		pCmdUI->Enable( TRUE);
	else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"REGISTER"		*/
/*						*/
/************************************************/
void
CMainFrame::OnSavechar()
{
	AfxGetApp()->DoWaitCursor(1);
	pEditChild->SaveEUDCCode(MB_OK);
	AfxGetApp()->DoWaitCursor(-1);
}

/************************************************/
/*						*/
/*	COMMAND 	"REGISTER" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateSavechar(
CCmdUI* pCmdUI)
{
	if( InqTypeFace((TCHAR *)SelectEUDC.m_Font,
	  ( TCHAR *)SelectEUDC.m_File,
	    sizeof( SelectEUDC.m_File )/sizeof(TCHAR)) && CustomWndOpen)
		pCmdUI->Enable( TRUE);
	else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"REGISTER AS"		*/
/*						*/
/************************************************/
void
CMainFrame::OnSaveCharas()
{
	CEudcDlg	dlg;
	HRESULT hresult;

	dlg.WorRFlag = TRUE;
	if( dlg.DoModal() == IDOK){
		AfxGetApp()->DoWaitCursor(1);

		pEditChild->UpdateCode = dlg.m_EditList.SelectCode;
		pEditChild->SaveEUDCCode(MB_OK);
		//*STRSAFE* 		wsprintf( SelectEUDC.m_Code, TEXT("%X"), dlg.m_EditList.SelectCode);
		hresult = StringCchPrintf(SelectEUDC.m_Code , ARRAYLEN(SelectEUDC.m_Code),  TEXT("%X"), dlg.m_EditList.SelectCode);
		if (!SUCCEEDED(hresult))
		{
                 AfxGetApp()->DoWaitCursor(-1);
		   return ;
		}
		CountryInfo.CurrentRange = dlg.m_EditList.cRange;
		m_wndGuideBar.PositionStatusPane();

		AfxGetApp()->DoWaitCursor(-1);
	}
}

/************************************************/
/*						*/
/*	COMMAND 	"REGISTER AS" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateSaveCharas(
CCmdUI* pCmdUI)
{		
	if( InqTypeFace((TCHAR *)SelectEUDC.m_Font,
	  ( TCHAR *)SelectEUDC.m_File,
	    sizeof( SelectEUDC.m_File )/sizeof(TCHAR)) && CustomWndOpen)
		pCmdUI->Enable( TRUE);
	else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"IMPORT"		*/
/*						*/
/************************************************/
void
CMainFrame::OnImportFile()
{
	CImportDlg	dlg1;
	BOOL		Tmp = FALSE;

	if( CustomWndOpen){
		if( !OutputSaveMessage())
			return;
	}
  if (!OExistTTF(SelectEUDC.m_File))
  {
    OutputMessageBox(this->GetSafeHwnd(), IDS_MAINFRAMETITLE, IDS_NOTTE, TRUE);
    return;
  }
	if( dlg1.DoModal() == IDOK){
		if( CustomWndOpen){
			Tmp = FALSE;	
			if( pEditChild->FlagTmp){
				Tmp = TRUE;
				this->SendMessage( WM_COMMAND,
					ID_FIT_CURVE, 0L);
			}
		}
		CGageDlg	dlg2;
		if( dlg2.DoModal() == IDOK){
			;
		}
		if( CustomWndOpen){
			if( Tmp){
				this->SendMessage( WM_COMMAND,
					ID_FIT_CURVE, 0L);
			}
		}
	}else	;
}
/************************************************/
/*						*/
/*	COMMAND		"IMPORT" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateImportFile(
CCmdUI* pCmdUI)
{
	if(InqTypeFace((TCHAR *)SelectEUDC.m_Font,
	               (TCHAR *)SelectEUDC.m_File, 
                 sizeof( SelectEUDC.m_File)/sizeof(TCHAR)))
		pCmdUI->Enable( TRUE);
	else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND		"Select Charset"	*/
/*						*/
/************************************************/

void
CMainFrame::OnSelectCharSet()
{
	CHAR CPCode[2];
	WCHAR UCode[1];
	CEudcDlg dlg;
	HRESULT hresult;
	UINT LocalCP =GetACP();
	if (m_wndGuideBar.m_comboCharset.GetCurSel() ==
		m_wndGuideBar.m_comboCharset.GetCount()-1){
		//We are switching to unicode.
		if ( CountryInfo.bUnicodeMode )
			// We are already in unicode mode.  No change.
			return;
		CountryInfo.CurrentRange = CountryInfo.nRange-1;
		CountryInfo.bUnicodeMode =TRUE;
		SetTrailByteRange(LocalCP);
		if( SelectEUDC.m_Code[0] != '\0'){
			CPCode[0]= HIBYTE(Mytcstol(SelectEUDC.m_Code, (TCHAR **)0, 16));
			CPCode[1]= LOBYTE(Mytcstol(SelectEUDC.m_Code, (TCHAR **)0, 16));
			MultiByteToWideChar(LocalCP, 0, CPCode,2, UCode,1);
			//*STRSAFE* 			wsprintf( SelectEUDC.m_Code, TEXT("%X"),UCode[0]);
			hresult = StringCchPrintf(SelectEUDC.m_Code , ARRAYLEN(SelectEUDC.m_Code),  TEXT("%X"),UCode[0]);
			if (!SUCCEEDED(hresult))
			{
			   return ;
			}
			m_wndGuideBar.PositionStatusPane();
			pEditChild->UpdateCode = UCode[0];
			dlg.m_EditList.SelectCode = UCode[0];
		}
	}else{
		//We are switching to code page
		if ( !CountryInfo.bUnicodeMode )
			// We are already in code page mode.  No change.
			return;

		CountryInfo.bUnicodeMode = FALSE;
		SetTrailByteRange(LocalCP);
		if( SelectEUDC.m_Code[0] != '\0'){
			BOOL bNotConverted;
			UCode[0] = (WCHAR)Mytcstol(SelectEUDC.m_Code, (TCHAR **)0, 16);
			WideCharToMultiByte(LocalCP, 0,UCode,1, CPCode,2, NULL, &bNotConverted);
			TCHAR CodeTmp[16] = {0};

      
      BOOL bValidCode = TRUE;
      if (CountryInfo.LangID == EUDC_CHS)
      {
        bValidCode = FALSE;
        WORD wdCode = MAKEWORD(CPCode[1], CPCode[0]);
			  BYTE sOffset = LOBYTE(wdCode);
        int  kk;
        for (kk = 0; kk < CountryInfo.nRange-1; kk++)
        {
          if ((wdCode >= CountryInfo.sRange[kk]) &&
              (wdCode <= CountryInfo.eRange[kk]))
              break;
        }
        CorrectTrailByteRange(kk);
	      for( kk = 0; kk < CountryInfo.nTralByte; kk++)
        {
				  if( sOffset >= CountryInfo.sTralByte[kk] &&
				      sOffset <= CountryInfo.eTralByte[kk])
          {
				   	  bValidCode = TRUE;
              break;
          }
        }
      }
      

			if (bNotConverted || !bValidCode){
				OutputMessageBox( this->GetSafeHwnd(),
					IDS_MAINFRAMETITLE,
					IDS_INVALID_CODE_MSG, TRUE);
				
				if( CustomWndOpen){
					CountryInfo.bUnicodeMode = TRUE;
					OutputSaveMessage();
					CountryInfo.bUnicodeMode = FALSE;
				}
				CountryInfo.CurrentRange = 0;
				dlg.m_EditList.SetInitEUDCCodeRange(CountryInfo.CurrentRange);
				dlg.m_EditList.SelectCode=CountryInfo.sRange[CountryInfo.CurrentRange];
				pEditChild->SelectCodes();
				//*STRSAFE* 				wsprintf( SelectEUDC.m_Code, TEXT("%X"), dlg.m_EditList.SelectCode);
				hresult = StringCchPrintf(SelectEUDC.m_Code , ARRAYLEN(SelectEUDC.m_Code),  TEXT("%X"), dlg.m_EditList.SelectCode);
				if (!SUCCEEDED(hresult))
				{
				   return ;
				}
				OnReadChar();
				return;
			}else{
				//*STRSAFE* 				wsprintf( CodeTmp, TEXT("%X"), (BYTE)CPCode[0]);
				hresult = StringCchPrintf(CodeTmp , ARRAYLEN(CodeTmp),  TEXT("%X"), (BYTE)CPCode[0]);
				if (!SUCCEEDED(hresult))
				{
				   return ;
				}
				SelectEUDC.m_Code[0] = CodeTmp[0];
				SelectEUDC.m_Code[1] = CodeTmp[1];
				//*STRSAFE* 				wsprintf( CodeTmp, TEXT("%X"), (BYTE)CPCode[1]);
				hresult = StringCchPrintf(CodeTmp , ARRAYLEN(CodeTmp),  TEXT("%X"), (BYTE)CPCode[1]);
				if (!SUCCEEDED(hresult))
				{
				   return ;
				}
				SelectEUDC.m_Code[2] = CodeTmp[0];
				SelectEUDC.m_Code[3] = CodeTmp[1];
				dlg.m_EditList.SelectCode = (WORD)Mytcstol(SelectEUDC.m_Code, (TCHAR **)0, 16);
				for (int i=0;i<CountryInfo.nRange - 1; i++)
				{
					if (dlg.m_EditList.SelectCode >= CountryInfo.sRange[i] &&
						dlg.m_EditList.SelectCode <= CountryInfo.eRange[i])
					{
							CountryInfo.CurrentRange = i;
					}
				}
			}
			m_wndGuideBar.PositionStatusPane();
			pEditChild->UpdateCode = dlg.m_EditList.SelectCode;

			
		}
        else
        {
            CountryInfo.CurrentRange = 0;
        }
	}
	dlg.m_EditList.SetInitEUDCCodeRange( CountryInfo.CurrentRange);
}

/************************************************/
/*						*/
/*	COMMAND  	"CALL"			*/
/*						*/
/************************************************/
void
CMainFrame::OnCallChar()
{
	UINT	Result;

	if( CustomWndOpen){
		if( !OutputSaveMessage())
			return;
	}
	if(( Result = SetReffCode( TRUE)) == IDOK){
		pEditChild->UpdateBitmap();
		pEditChild->CallCharTextOut();
	}
}

/************************************************/
/*						*/
/*	COMMAND 	"CALL" (Update)		*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateCallChar(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen)
		pCmdUI->Enable( TRUE);
	else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"LINK"			*/
/*						*/
/************************************************/
void
CMainFrame::OnLinkime()
{
#if 0
	CIMEDlg		dlg;
	dlg.EudcCode = pEditChild->UpdateCode;
	dlg.DoModal();
#endif
	ImeLink( this->GetSafeHwnd(),
		pEditChild->UpdateCode,
		CountryInfo.bUnicodeMode ? TRUE : FALSE,
		AfxGetInstanceHandle());
}

/************************************************/
/*						*/
/*	COMMAND 	"LINK" (Update)		*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateLinkime(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen &&
	  ( CountryInfo.LangID == EUDC_CHT ||
	    CountryInfo.LangID == EUDC_CHS )){
		pCmdUI->Enable(TRUE);
	}else	pCmdUI->Enable(FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"BATCHLINK"		*/
/*						*/
/************************************************/
void
CMainFrame::OnLinkbatchmode()
{
	CBLinkDlg	dlg;

	dlg.DoModal();
}

/************************************************/
/*						*/
/*	COMMAND 	"BATCHLINK" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateLinkbatchmode(
CCmdUI* pCmdUI)
{
#ifdef BUILD_ON_WINNT
//
//  IME batch link should be font independent feature
// and available after launch EUDCEDIT. The batch link
// menu item is grayed after launching EUDCEDIT.
//  It will be enabled after font association and EUDC
// code are selected.
//  But font association and EUDC code selection do not
// have any relationship with IME batch link.
//  The user does not need to select font association
// and EUDC code if they want to do IME batch link only.
//
// NTRaid #19424.
//
	if( CountryInfo.LangID == EUDC_CHT ||
	    CountryInfo.LangID == EUDC_CHS ){
		pCmdUI->Enable(TRUE);
	}else	pCmdUI->Enable(FALSE);
#else
	if( CustomWndOpen &&
	  ( CountryInfo.LangID == EUDC_CHT ||
	    CountryInfo.LangID == EUDC_CHS )){
		pCmdUI->Enable(TRUE);
	}else	pCmdUI->Enable(FALSE);
#endif // BUILD_ON_WINNT
}

/************************************************/
/*						*/
/*	COMMAND 	"GUIDEBAR"		*/
/*						*/
/************************************************/
BOOL
CMainFrame::OnStylesBar(
UINT 	nID)
{
	GuideBarVisible = !GuideBarVisible;


	if( GuideBarVisible)
		m_wndGuideBar.ShowWindow(SW_SHOWNA);
	else	m_wndGuideBar.ShowWindow(SW_HIDE);
	m_wndGuideBar.PositionStatusPane();
	this->SendMessage( WM_SIZE);

	return TRUE;
}

/************************************************/
/*						*/
/*	COMMAND 	"GUIDEBAR" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateStylesBar(
CCmdUI* pCmdUI)
{
       if (pCmdUI)
       {
	     pCmdUI->SetCheck(GuideBarVisible);
       }
}

/************************************************/
/*						*/
/*	COMMAND 	"TOOLBOX"		*/
/*						*/
/************************************************/
void
CMainFrame::OnToolbar()
{
    ToolBarVisible = !ToolBarVisible;
	if( ToolBarVisible)
    {
        DockControlBar(&m_wndToolBar);
		m_wndToolBar.ShowWindow( SW_SHOWNORMAL);
	}else{
        if (m_wndToolBar.IsFloating())
        {
		    m_wndToolBar.GetParentOwner()->ShowWindow( SW_HIDE);
        }
        else
        {
		    m_wndToolBar.ShowWindow( SW_HIDE);
        }
	}	
	this->SendMessage(WM_SIZE);
}

/************************************************/
/*						*/
/*	COMMAND		"TOOLBOX" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateToolbar(
CCmdUI* pCmdUI)
{
    ToolBarVisible = m_wndToolBar.IsWindowVisible();
	pCmdUI->SetCheck(ToolBarVisible);
}

/************************************************/
/*						*/
/*	COMMAND 	"GRID"			*/
/*						*/
/************************************************/
void
CMainFrame::OnShowGrid()
{
	pEditChild->GridShow = !pEditChild->GridShow;
	pEditChild->Invalidate( FALSE);
	pEditChild->UpdateWindow();
	if( RefferWndVisible){
		pRefrChild->GridShow = !pRefrChild->GridShow;
		pRefrChild->Invalidate(FALSE);
		pRefrChild->UpdateWindow();
	}
}

/************************************************/
/*						*/
/*	COMMAND 	"GRID" (Update)		*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateShowGrid(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable(1);
		pCmdUI->SetCheck( pEditChild->GridShow);
	}else 	pCmdUI->Enable(0);
}

/************************************************/
/*						*/
/*	COMMAND 	"NEXT CODE"		*/
/*						*/
/************************************************/
void
CMainFrame::OnNextcode()
{
      HRESULT hresult;
	if( CustomWndOpen){
		if( !OutputSaveMessage())
			return;
	}
	EudcWndRect.SetRectEmpty();
	pEditChild->UpdateBitmap();
	pEditChild->UpdateCode++;
	pEditChild->UpdateCode = CorrectCode( pEditChild->UpdateCode, TRUE);
	pEditChild->SelectCodes();
	//*STRSAFE* 	wsprintf( SelectEUDC.m_Code, TEXT("%X"), pEditChild->UpdateCode);
	hresult = StringCchPrintf(SelectEUDC.m_Code , ARRAYLEN(SelectEUDC.m_Code),  TEXT("%X"), pEditChild->UpdateCode);
	if (!SUCCEEDED(hresult))
	{
	   return ;
	}
	
	m_wndGuideBar.PositionStatusPane();
}

/************************************************/
/*						*/
/*	COMMAND 	"NEXT CODE" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateNextcode(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen &&
	  ( InqTypeFace((TCHAR *)SelectEUDC.m_Font,
	  (TCHAR *)SelectEUDC.m_File, sizeof( SelectEUDC.m_File)/sizeof(TCHAR)))){
		if( CountryInfo.eRange[CountryInfo.CurrentRange]
				<= pEditChild->UpdateCode)
			pCmdUI->Enable( FALSE);
		else	pCmdUI->Enable( TRUE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"PREV CODE"		*/
/*						*/
/************************************************/
void
CMainFrame::OnPrevcode()
{
      HRESULT hresult;
	if( CustomWndOpen){
		if( !OutputSaveMessage())
			return;
	}
	EudcWndRect.SetRectEmpty();
	pEditChild->UpdateBitmap();
	pEditChild->UpdateCode--;
	pEditChild->UpdateCode = CorrectCode( pEditChild->UpdateCode, FALSE);
	pEditChild->SelectCodes();
	//*STRSAFE* 	wsprintf( SelectEUDC.m_Code, TEXT("%X"), pEditChild->UpdateCode);
	hresult = StringCchPrintf(SelectEUDC.m_Code , ARRAYLEN(SelectEUDC.m_Code),  TEXT("%X"), pEditChild->UpdateCode);
	if (!SUCCEEDED(hresult))
	{
	   return ;
	}

	m_wndGuideBar.PositionStatusPane();
}

/************************************************/
/*						*/
/*	COMMAND 	"PREV CODE" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePrevcode(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen &&
	  ( InqTypeFace((TCHAR *)SelectEUDC.m_Font,
	  (TCHAR *)SelectEUDC.m_File, sizeof( SelectEUDC.m_File)/sizeof(TCHAR)))){
		if( CountryInfo.sRange[CountryInfo.CurrentRange]
				>= pEditChild->UpdateCode)
			pCmdUI->Enable( FALSE);
		else	pCmdUI->Enable( TRUE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"SHOW OUTLINE"		*/
/*						*/
/************************************************/
void
CMainFrame::OnFitCurve()
{
	if( CustomWndOpen){
		pEditChild->FlagTmp = !pEditChild->FlagTmp;

		pEditChild->Invalidate(FALSE);
		pEditChild->UpdateWindow();
	}
}

/************************************************/
/*						*/
/*	COMMAND 	"SHOW OUTLINE"(Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateFitCurve(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable(TRUE);
		pCmdUI->SetCheck( pEditChild->FlagTmp);
	}else	pCmdUI->Enable(FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"PEN"			*/
/*						*/
/************************************************/
void
CMainFrame::OnPalettepen()
{
	pEditChild->SelectItem = PEN;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"PEN" (Update)		*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePalettepen(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == PEN)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"BRUSh"			*/
/*						*/
/************************************************/
void
CMainFrame::OnPalettebrush()
{
	pEditChild->SelectItem = BRUSH;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"BRUSH" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePalettebrush(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == BRUSH)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"STRAIGHT LINE"		*/
/*						*/
/************************************************/
void
CMainFrame::OnPaletteslope()
{
	pEditChild->SelectItem = SLOPE;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"STRAIGHT LINE"(Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePaletteslope(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == SLOPE)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"RECTANGLE" 		*/
/*						*/
/************************************************/
void
CMainFrame::OnPaletterect()
{
	pEditChild->SelectItem = RECTBAND;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"RECTANGLE" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePaletterect(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == RECTBAND)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"FILRECTANGLE" 		*/
/*						*/
/************************************************/
void
CMainFrame::OnPaletterectfill()
{
	pEditChild->SelectItem = RECTFILL;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"FILRECTANGLE" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePaletterectfill(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == RECTFILL)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"CIRCLE" 		*/
/*						*/
/************************************************/
void
CMainFrame::OnPalettecircle()
{
	pEditChild->SelectItem = CIRCLE;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"CIRCLE" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePalettecircle(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == CIRCLE)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"FILCIRCLE" 		*/
/*						*/
/************************************************/
void
CMainFrame::OnPalettecirclefill()
{
	pEditChild->SelectItem = CIRCLEFILL;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"FILCIRCLE" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePalettecirclefill(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == CIRCLEFILL)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"FREEFORM" 		*/
/*						*/
/************************************************/
void
CMainFrame::OnPalettefreeform()
{
	pEditChild->SelectItem = FREEFORM;
	pRefrChild->SelectItems = FREEFORM;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"FREEFORM" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePalettefreeform(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == FREEFORM)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"ERASER" 		*/
/*						*/
/************************************************/
void
CMainFrame::OnPaletteeraser()
{
	pEditChild->SelectItem = ERASER;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"ERASER" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePaletteeraser(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == ERASER)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"RECTBAND" 		*/
/*						*/
/************************************************/
void
CMainFrame::OnPaletterectband()
{
	pEditChild->SelectItem = RECTCLIP;
	pRefrChild->SelectItems = RECTCLIP;
	pEditChild->WriteSelRectBitmap();
	pEditChild->MDIActivate();
}

/************************************************/
/*						*/
/*	COMMAND 	"RECTBAND"(Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdatePaletterectband(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable( TRUE);
		if( pEditChild->SelectItem == RECTCLIP)
			pCmdUI->SetRadio( TRUE);
		else	pCmdUI->SetRadio( FALSE);
	}else	pCmdUI->Enable( FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"FLIP/ROTATE"		*/
/*						*/
/************************************************/
void
CMainFrame::OnRotate()
{
CRotateDlg	dlg;

	if( CustomWndOpen){
		if( dlg.DoModal() == IDOK){
			pEditChild->FlipRotate( dlg.RadioItem);
		}
	}
}

/************************************************/
/*						*/
/*	COMMAND 	"FLIP/ROTATE" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateRotate(
CCmdUI* pCmdUI)
{
	if( CustomWndOpen){
		pCmdUI->Enable(TRUE);
	}else	pCmdUI->Enable(FALSE);
}

/************************************************/
/*						*/
/*	COMMAND 	"REFERRENCE"		*/
/*						*/
/************************************************/
void
CMainFrame::OnRefferfileNew()
{
	UINT	Result;

	if( !RefferWndVisible){
		if(( Result = SetReffCode( FALSE)) == IDOK){
			SetReffWndPos();
			pRefrChild->UpdateBitmap();
			pRefrChild->GridShow = pEditChild->GridShow;
			pRefrChild->ShowWindow(SW_SHOWNORMAL);
			pRefrChild->UpdateWindow();
			RefferWndVisible = TRUE;
			if( CustomWndOpen)
				SetEudcWndPos();
		}
	}else{
		if(( Result = SetReffCode( FALSE)) == IDOK){
			pRefrChild->UpdateBitmap();
		}
	}
}

/************************************************/
/*						*/
/*	COMMAND 	"REFERRENCE" (Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateRefferfileNew(
CCmdUI* pCmdUI)
{
	pCmdUI->Enable( CustomWndOpen);	
}

/************************************************/
/*						*/
/*	COMMAND 	"CLOSE REF"		*/
/*						*/
/************************************************/
void
CMainFrame::OnRefferClose()
{
	RefferWndVisible = FALSE;
	pRefrChild->ShowWindow( SW_HIDE);
	pRefrChild->UpdateWindow();
	SetEudcWndPos();
}

/************************************************/
/*						*/
/*	COMMAND 	"CLOSE REF"(Update)	*/
/*						*/
/************************************************/
void
CMainFrame::OnUpdateRefferClose(
CCmdUI* pCmdUI)
{
	pCmdUI->Enable(RefferWndVisible);	
}

/************************************************/
/*						*/
/*	COMMAND 	"HELP TOPICS"		*/
/*						*/
/************************************************/
void
CMainFrame::OnHelp()
{
	if( this->IsWindowEnabled())
    {       
        ::HtmlHelp (this->GetSafeHwnd(), TEXT("eudcedit.chm"), HH_DISPLAY_TOPIC,(DWORD)0);	
    }
}

/************************************************/
/*						*/
/*	if bitmap is dirty, output message	*/
/*						*/
/************************************************/
BOOL
CMainFrame::OutputSaveMessage()
{
	int	Result;

	Result = IDYES;
	if( pEditChild->GetBitmapDirty()){
		Result = OutputMessageBox( this->GetSafeHwnd(),
			IDS_MAINFRAMETITLE,
			IDS_SAVEORNOT, FALSE);
		if( Result == IDYES){
			AfxGetApp()->DoWaitCursor(1);
			if (!pEditChild->SaveEUDCCode(MB_OKCANCEL))
        Result = IDCANCEL;
			AfxGetApp()->DoWaitCursor(-1);
		}else if( Result == IDNO){
			pEditChild->SetBitmapDirty( FALSE);
		}
	}
	if( Result == IDCANCEL)
		return FALSE;
	else	return TRUE;
}

/************************************************/
/*						*/
/*	Create refferrence window		*/
/*						*/
/************************************************/
BOOL
CMainFrame::CreateReferWnd()
{
	ReffWndRect.SetRectEmpty();
	CalcReffWndRect();

	CRefrWnd *pReffWnd = new CRefrWnd;
	if( !pReffWnd->Create( TEXT("REFERWINDOW"),
	    WS_CHILD | WS_BORDER, ReffWndRect, this))
		return FALSE;
				
	pRefrChild = pReffWnd;
	RefferWndVisible = FALSE;

	return TRUE;
}

/************************************************/
/*						*/
/*	Change size of edit window		*/
/*						*/
/************************************************/
void
CMainFrame::SetEudcWndPos()
{
	CalcEudcWndRect();
	pEditChild->MoveWindow( EudcWndRect.left, EudcWndRect.top,
		EudcWndRect.Width(), EudcWndRect.Height(), TRUE);
}

/************************************************/
/*						*/
/*	Calcurate size of edit window		*/
/*						*/
/************************************************/
void
CMainFrame::CalcEudcWndRect()
{
	CRect	CalcRect;
	CSize	Frame;
	int	Twice;
	int	Remain;

    //
    // Try to determine the proper value of the Frame. Can be
    // different depending with Theme is used. The Luna Theme
    // take more prixel for the width of the frame.
    //
	CRect* FrameBefore = new CRect(0, 0, BITMAP_WIDTH, BITMAP_HEIGHT);
    if (FrameBefore == NULL)
    {
        return;
    }
    CRect  FrameAfter;
    pEditChild->MoveWindow(FrameBefore, TRUE);
    pEditChild->GetClientRect(&FrameAfter);
    
	Frame.cx = FrameBefore->Width() - FrameAfter.Width();
	Frame.cy = FrameBefore->Height() - FrameAfter.Height();

	GetClientRect( &EudcWndRect);
	if( GuideBarVisible){
		m_wndGuideBar.GetWindowRect( &CalcRect);
		EudcWndRect.bottom -= CalcRect.Height();
	}
	if( ToolBarVisible){
		m_wndToolBar.GetWindowRect( &CalcRect);
		EudcWndRect.right -= CalcRect.Width();
	}

	if( RefferWndVisible)
		EudcWndRect.right = EudcWndRect.right /2;

	if( EudcWndRect.Width() < EudcWndRect.Height()){
		Twice  = EudcWndRect.Width() /BITMAP_WIDTH;
		Remain = EudcWndRect.Width() %BITMAP_WIDTH;
		if( Remain < Frame.cx )
			Twice -= 1;
		if( Twice <= 0)		Twice = 1;
		EudcWndRect.left   = 0;
		EudcWndRect.right  = EudcWndRect.left + BITMAP_WIDTH *Twice
				   + Frame.cx;
		EudcWndRect.bottom = BITMAP_HEIGHT*Twice + Frame.cy
				   + CAPTION_HEIGHT;
	}else{
		Twice  = EudcWndRect.Height() /BITMAP_HEIGHT;
		Remain = EudcWndRect.Height() %BITMAP_HEIGHT;
		if( Remain < CAPTION_HEIGHT + Frame.cy )
			Twice -= 1;
		if( Twice <= 0)		Twice = 1;
		EudcWndRect.left   = 0;
		EudcWndRect.right  = EudcWndRect.left + BITMAP_WIDTH *Twice
				   + Frame.cx;
		EudcWndRect.bottom = BITMAP_HEIGHT*Twice + Frame.cy + CAPTION_HEIGHT;
	}
    delete FrameBefore;
}

/************************************************/
/*						*/
/*	Change size of referrence window	*/
/*						*/
/************************************************/
void
CMainFrame::SetReffWndPos()
{
 	CalcReffWndRect();
	pRefrChild->MoveWindow( ReffWndRect.left, ReffWndRect.top,
		 ReffWndRect.Width(), ReffWndRect.Height(), TRUE);
}

/************************************************/
/*						*/
/*	Calcurate size of referrence window	*/
/*						*/
/************************************************/
void
CMainFrame::CalcReffWndRect()
{
	CRect	CalcRect;
	CSize	Frame;
	int	Twice;
	int	Remain;

	Frame.cx = ( GetSystemMetrics( SM_CXFRAME)
		   - GetSystemMetrics( SM_CXBORDER)) * 2;
  	Frame.cy = ( GetSystemMetrics( SM_CYFRAME)
		   - GetSystemMetrics( SM_CYBORDER)) * 2;
	GetClientRect( &ReffWndRect);
	if( GuideBarVisible){
		m_wndGuideBar.GetWindowRect( &CalcRect);
		ReffWndRect.bottom -= CalcRect.Height();
	}
	if( ToolBarVisible){
		m_wndToolBar.GetWindowRect( &CalcRect);
		ReffWndRect.right -= CalcRect.Width();
	}

	ReffWndRect.left  = ReffWndRect.right /2;
	if( ReffWndRect.Width() < ReffWndRect.Height()){
		Twice  = ReffWndRect.Width() /BITMAP_WIDTH;
		Remain = ReffWndRect.Width() %BITMAP_WIDTH;
		if( Remain < Frame.cx + 4)
			Twice -= 1;
		if( Twice <= 0){/*
			if( RefferWndVisible){
				pRefrChild->ShowWindow( SW_HIDE);
				pRefrChild->UpdateWindow();
				RefferWndVisible = FALSE;
			}*/
		}
		ReffWndRect.right  = ReffWndRect.left + BITMAP_WIDTH*Twice
				   + Frame.cx;
		ReffWndRect.bottom = BITMAP_HEIGHT*Twice + Frame.cy
				   + CAPTION_HEIGHT;
	}else{
		Twice  = ReffWndRect.Height() /BITMAP_HEIGHT;
		Remain = ReffWndRect.Height() %BITMAP_HEIGHT;
		if( Remain < CAPTION_HEIGHT + Frame.cy + 4)
			Twice -= 1;
		if( Twice <= 0)		Twice = 1;
		ReffWndRect.right  = ReffWndRect.left + BITMAP_WIDTH*Twice
				   + Frame.cx;
		ReffWndRect.bottom = BITMAP_HEIGHT*Twice + Frame.cy
				   + CAPTION_HEIGHT;
	}
}

/************************************************/
/*						*/
/*	MESSAGE		"WM_SIZE"		*/
/*						*/
/************************************************/
void
CMainFrame::OnSize(
UINT 	nType,
int 	cx,
int 	cy)
{
	CMDIFrameWnd::OnSize(nType, cx, cy);
	if( RefferWndVisible){
		SetReffWndPos();
	}
	if( CustomWndOpen){
		SetEudcWndPos();
	}

	if( !ToolBarVisible){
		m_wndToolBar.Invalidate( FALSE);
		m_wndToolBar.UpdateWindow();
	}

}

/************************************************/
/*						*/
/*	MESSAGE	"WM_DESTROY"			*/
/*	Write "EUDCEDIT.INI"			*/
/*						*/
/************************************************/
void
CMainFrame::OnDestroy()
{
	TCHAR	ProfileBuf[BUFFERMAX];
	TCHAR	SelectName1[] = TEXT("WindowSize");
	TCHAR	SelectName2[] = TEXT("Bitmap");
	TCHAR	SelectName3[] = TEXT("Color");
	TCHAR	EntryName1[]  = TEXT("MainWindowSize");
	TCHAR	EntryName2[]  = TEXT("MinMaxFlag");
	TCHAR 	EntryName3[]  = TEXT("BitmapSize");
	TCHAR	EntryName4[]  = TEXT("Grid");
	TCHAR	EntryName5[]  = TEXT("Curve");
	TCHAR	EntryName6[]  = TEXT("Fitting");
	TCHAR 	EudcIniFile[] = TEXT("Eudcedit.ini");
	CRect	rect;
	short	MaxWndFlag;
	HRESULT hresult;

 	if( IsZoomed())
		MaxWndFlag = 1;
	else	MaxWndFlag = 0;

	//*STRSAFE* 	wsprintf( ProfileBuf,TEXT("%d %d %d"), GetRValue(COLOR_GRID),	GetGValue(COLOR_GRID), GetBValue(COLOR_GRID));
	hresult = StringCchPrintf(ProfileBuf , ARRAYLEN(ProfileBuf), TEXT("%d %d %d"), GetRValue(COLOR_GRID),	GetGValue(COLOR_GRID), GetBValue(COLOR_GRID));
	if (!SUCCEEDED(hresult))
	{
	   goto RET ;
	}
	::WritePrivateProfileString( SelectName3, EntryName4,
		ProfileBuf, EudcIniFile);
						
	//*STRSAFE* 	wsprintf( ProfileBuf,TEXT("%d %d %d"), GetRValue(COLOR_CURVE),GetGValue(COLOR_CURVE), GetBValue(COLOR_CURVE));
	hresult = StringCchPrintf(ProfileBuf , ARRAYLEN(ProfileBuf), TEXT("%d %d %d"), GetRValue(COLOR_CURVE),GetGValue(COLOR_CURVE), GetBValue(COLOR_CURVE));
	if (!SUCCEEDED(hresult))
	{
	  goto RET ;
	}
	::WritePrivateProfileString( SelectName3, EntryName5,
		ProfileBuf, EudcIniFile);

	//*STRSAFE* 	wsprintf( ProfileBuf,TEXT("%d %d %d"), GetRValue(COLOR_FITTING),GetGValue(COLOR_FITTING), GetBValue(COLOR_FITTING));
	hresult = StringCchPrintf(ProfileBuf , ARRAYLEN(ProfileBuf), TEXT("%d %d %d"), GetRValue(COLOR_FITTING),GetGValue(COLOR_FITTING), GetBValue(COLOR_FITTING));
	if (!SUCCEEDED(hresult))
	{
	  goto RET ;
	}
	::WritePrivateProfileString( SelectName3, EntryName6,
		ProfileBuf, EudcIniFile);

	//*STRSAFE* 	wsprintf( ProfileBuf, TEXT("%d"), BITMAP_WIDTH);
	hresult = StringCchPrintf(ProfileBuf , ARRAYLEN(ProfileBuf),  TEXT("%d"), BITMAP_WIDTH);
	if (!SUCCEEDED(hresult))
	{
	  goto RET ;
	}
	::WritePrivateProfileString( SelectName2, EntryName3,
		ProfileBuf, EudcIniFile);

	//*STRSAFE* 	wsprintf( ProfileBuf, TEXT("%d"), MaxWndFlag);
	hresult = StringCchPrintf(ProfileBuf , ARRAYLEN(ProfileBuf),  TEXT("%d"), MaxWndFlag);
	if (!SUCCEEDED(hresult))
	{
	   goto RET ;
	}
	::WritePrivateProfileString( SelectName1, EntryName2,
		ProfileBuf, EudcIniFile);

	if( !MaxWndFlag && !IsIconic()){	
		GetWindowRect( &rect);
		//*STRSAFE* 		wsprintf( ProfileBuf, TEXT("%d %d %d %d"), rect.left, rect.top,	rect.right, rect.bottom);
		hresult = StringCchPrintf(ProfileBuf , ARRAYLEN(ProfileBuf),  TEXT("%d %d %d %d"), rect.left, rect.top,	rect.right, rect.bottom);
		if (!SUCCEEDED(hresult))
		{
		   goto RET ;
		}

		::WritePrivateProfileString( SelectName1, EntryName1,
			ProfileBuf, EudcIniFile);
	}
RET:
	CMDIFrameWnd::OnDestroy();
}

/************************************************/
/*						*/
/*	MESSAGE		"WM_CLOSE"		*/
/*						*/
/************************************************/
void
CMainFrame::OnClose()
{
	CString	MsgTitle;
	CString Msg;
	int	result;

	if( CustomWndOpen){
		if(( pEditChild->GetBitmapDirty()) &&
		   ( InqTypeFace((TCHAR *)SelectEUDC.m_Font,
		   (TCHAR *)SelectEUDC.m_File, sizeof( SelectEUDC.m_File)/sizeof(TCHAR)))){
			MsgTitle.LoadString( IDS_MAINFRAMETITLE);
			Msg.LoadString( IDS_SAVEORNOT);
			result = MessageBox( Msg, MsgTitle,
					 MB_ICONQUESTION | MB_YESNOCANCEL);
			if( result == IDYES){
				AfxGetApp()->DoWaitCursor(1);
				if (!pEditChild->SaveEUDCCode(MB_OKCANCEL))
          result = IDCANCEL;
				AfxGetApp()->DoWaitCursor(-1);
			}
			if( result == IDCANCEL)
				return;
		}
	}		
	CMDIFrameWnd::OnClose();
}

/************************************************/
/*						*/
/*	MESSAGE		"WM_INITMENU"		*/
/*						*/
/************************************************/
void
CMainFrame::OnInitMenu(
CMenu* 	pMenu)
{
       if (!pMenu)
       {
           return;
       }
	CMDIFrameWnd::OnInitMenu(pMenu);

	if( CountryInfo.LangID != EUDC_CHT &&
	    CountryInfo.LangID != EUDC_CHS ){
		pMenu->DeleteMenu( ID_LINKIME, MF_BYCOMMAND);
		pMenu->DeleteMenu( ID_LINKBATCHMODE, MF_BYCOMMAND);
		if (CountryInfo.LangID != EUDC_JPN)
			pMenu->DeleteMenu( ID_IMPORT_FILE, MF_BYCOMMAND);
		this->DrawMenuBar();
	}
}

/************************************************/
/*						*/
/*	Correct it if code is illegal range	*/
/*						*/
/************************************************/
WORD
CMainFrame::CorrectCode(
WORD 	Code,
BOOL 	UporDown)
{
COUNTRYINFO	Info;
	WORD	wCode;
	BYTE 	LByte, HByte;
	int	TralPos = 0;

	LByte = LOBYTE( Code);
	HByte = HIBYTE( Code);
	Info = CountryInfo;
	for( int i = 0; i < Info.nTralByte; i++){
		if( LByte >= (Info.sTralByte[i]) &&
		    LByte <= (Info.eTralByte[i])){
		    	goto RET;
		}else if( LByte < (Info.sTralByte[i])){
			TralPos = i;
			break;
		}else	TralPos = i+1;
	}
	if( UporDown)
		if( TralPos == Info.nTralByte){
			LByte = (Info.sTralByte[0]);
			HByte += 0x1;
		}else 	LByte = (Info.sTralByte[TralPos]);
	else{
		if( !TralPos){
			LByte = (Info.eTralByte[Info.nTralByte-1]);
			HByte -= 0x1;
		}else	LByte = (Info.eTralByte[TralPos-1]);
	}
RET:
	wCode = MAKEWORD( LByte, HByte);
	return wCode;
}

/************************************************/
/*						*/
/*	Set Reference dialog			*/
/*						*/
/************************************************/
UINT
CMainFrame::SetReffCode( BOOL EditorRefer)
{
CRefrDlg	dlg;
	UINT	Result;

	TitleFlag = EditorRefer;
	if(( Result = (UINT)dlg.DoModal()) == IDOK){
		if( !EditorRefer){
			if( dlg.m_CodeList.SelectCode){
				pRefrChild->ReferCode =
					dlg.m_CodeList.SelectCode;
			}else	pRefrChild->ReferCode = 0;
		}else{
			if( dlg.m_CodeList.SelectCode)
				pEditChild->CallCode =
					dlg.m_CodeList.SelectCode;
			else	pEditChild->CallCode = 0;
		}
	}else{
		if( !EditorRefer)
			pRefrChild->ReferCode = 0;
		else 	pEditChild->CallCode = 0;
	}

	return Result;
}

/************************************************/
/*						*/
/*	Window procedure			*/
/*						*/
/************************************************/
LRESULT
CMainFrame::WindowProc(
UINT 	message,
WPARAM 	wParam,
LPARAM 	lParam)
{
	CRect	WorkRect;
	CRect	rect;
	CRect	Dummy;
	RECT	*Rect;
	POINT	*Point;
	int	Zm;

	if( message == WM_DUPLICATE){
		Zm = pEditChild->ZoomRate;
		pEditChild->GetClientRect( &WorkRect);
		pEditChild->ClientToScreen( &WorkRect);
		Point = (LPPOINT)lParam;
		Rect  = (LPRECT)wParam;
		pEditChild->ScreenToClient( Point);

		Rect->left = ((Point->x - Rect->left) /Zm) *Zm;
		Rect->top  = ((Point->y - Rect->top - CAPTION_HEIGHT)
				/Zm) *Zm + CAPTION_HEIGHT;
		Rect->right  = Rect->left + Rect->right;
		Rect->bottom = Rect->top  + Rect->bottom;

		pEditChild->ClientToScreen( Rect);
		if( Dummy.IntersectRect( &WorkRect, Rect)){
			if( Dummy.EqualRect( Rect)){
				pEditChild->ScreenToClient( Rect);
				pEditChild->SetDuplicateRect( Rect, Point);
			}else{
				int	Tmp;

				rect.SetRect( Rect->left, Rect->top,
						Rect->right, Rect->bottom);
				if( rect.left < WorkRect.left){
					Tmp = WorkRect.left - rect.left;
					rect.OffsetRect( Tmp, 0);
				}
				if( rect.top < WorkRect.top + CAPTION_HEIGHT){
					Tmp = WorkRect.top + CAPTION_HEIGHT
						- rect.top;
					rect.OffsetRect( 0, Tmp);
				}
				if( rect.right > WorkRect.right){
					Tmp = WorkRect.right - rect.right + 1;
					rect.OffsetRect( Tmp, 0);
				}
				if( rect.bottom > WorkRect.bottom){
					Tmp = WorkRect.bottom - rect.bottom + 1;
					rect.OffsetRect( 0, Tmp);
				}
				pEditChild->ScreenToClient( &rect);
				pEditChild->SetDuplicateRect( &rect, Point);
			}
			pRefrChild->RectVisible = FALSE;
			pEditChild->MDIActivate();
			if( pRefrChild->SelectItems == FREEFORM)
				pEditChild->SelectItem = FREEFORM;
			else	pEditChild->SelectItem = RECTCLIP;
		}else{
			pRefrChild->Invalidate( FALSE);
			pRefrChild->UpdateWindow();
		}
		return (0L);
	}else 	return CFrameWnd::WindowProc( message, wParam, lParam);
}

/************************************************/
/*						*/
/*	Activate Edit Window			*/
/*						*/
/************************************************/
BOOL CMainFrame::CustomActivate()
{
	pEditChild->MDIActivate();
	return TRUE;
}

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}
void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}
#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\import.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
/*
 *	Import function for W31JEUDC and ETEN
 *----------------------------------------------
 *   bitmap proccessing steps
 *	1. Read bitmap
 *	2. Make outline
 *	3. Smoothing
 *	4. Rasterize -> editting bitmap image
 *	5. Make outline
 *	6. Smoothing
 *	7. Fitting
 *	8. Output TTF and bitmap
 *
 *   File proccessing
 *	1.Copy .EUF as temp to update
 *	2.Copy TTF tables as temp to update
 *	3.Make input bitamp code-rec table
 *	4.Per glyph proc.
 *	5.Replace files
 *
 *   Per glyph proccessing
 *	1.judge to merge to make glyph with input bitmap code-rec table.
 *	2.merge or make glyphdata and metrics
 *
 */

#include	"stdafx.h"
#include	"eudcedit.h"

#pragma		pack(2)
extern BOOL	SendImportMessage(unsigned int cEUDC, unsigned int nRec);

#include	"vdata.h"
#include	"ttfstruc.h"
#include	"extfunc.h"

#define		OUTLSTH		0
#define		TMPLSTH		1
#define		EUDCCODEBASE	((unsigned short)0xe000)


static void  pline(int  bmpNo,int  sx,int  sy,int  tx,int  ty);
static int  rasterize(int  lstHdl,int  bmpNo, int mesh, int outSiz);
static int  initmem(int  iSiz,int  oSiz);
static void  termmem(void);
static int  modmem(int  iSiz);
int  Import(TCHAR *eudcPath, TCHAR *bmpPath,TCHAR *ttfPath,int  oWidth,int  oHeight,int level, BOOL bIsWin95EUDC);
/* For Import static */
static	int	iBmpSiz;
static	int	oBmpSiz;
static	BYTE	*rBuf, *wkBuf, *refBuf;
static	BYTE	*oBuf, *owkBuf, *orefBuf;
static	int	iBmpNo, wkBmpNo, refBmpNo;
static	int	oBmpNo, owkBmpNo, orefBmpNo;
static  int	*recTbl=0;

static void
pline( int bmpNo, int sx, int sy, int tx, int ty)
{
	int	dx, dy;
	int	dx2, dy2;
	int	exy;
	int	tmp;
	

	dx = abs( sx - tx);
	dy = abs( sy - ty);
	dx2 = dx*2;
	dy2 = dy*2;

	if ( dx==0) {
		if( sy>ty) {
			while ( sy>ty) {
				sy--;
				ReverseRight( bmpNo, sx, sy);
			}
		}
		else if ( sy < ty) {
			while ( sy < ty) {
				ReverseRight( bmpNo, sx, sy);
				sy++;
			}
		}
	}
	else if ( dy==0)
		;
/*Loose*/
	else if ( dx >= dy){
		if (sx > tx) {
			tmp = tx;
			tx = sx;
			sx = tmp;
			tmp = ty;
			ty = sy;
			sy = tmp;
		}
		exy = -dx ;
	
		if ( sy < ty ) {
			while ( sx <= tx) {
				exy += dy2;
				sx++;
				if ( exy > 0) {
					exy -= dx2;
					if ( sy!=ty)
						ReverseRight( bmpNo, sx, sy);
					sy++;
				}
			}
		}
		else {
			while ( sx <= tx) {
				exy += dy2;
				sx++;
				if ( exy > 0) {
					exy -= dx2;
					sy--;
					if ( sy >= ty)
						ReverseRight( bmpNo, sx, sy);
				}
			}
		}
		
/*Steep*/	
	}
	else {	
		if (sy > ty) {
			tmp = tx;
			tx = sx;
			sx = tmp;
			tmp = ty;
			ty = sy;
			sy = tmp;
		}
		exy = -dy ;
	/*	while ( sy <= ty) { */
		while ( sy < ty) { 
			ReverseRight( bmpNo, sx, sy);
			exy += dx2;
			if ( exy >= 0) {	
				exy -= dy2;
				if ( sx < tx)	sx++;
				else		sx--;
			}
			sy++;
		}
	}
}
static int
rasterize( int lstHdl, int bmpNo, int mesh, int outSiz)
/* lstHdl : abs coord*/
{
	int	nliais, nelm;
	int	liais;
struct VHEAD	*vhead;
struct VDATA	*vp;
struct vecdata	lvd, cvd;
	if ( (nliais = VDGetNCont( lstHdl))<0)
		goto	ERET;

	BMPClear( bmpNo);
	if ( VDGetHead( lstHdl, &vhead)) 
		goto	ERET;
	for ( liais = 0; liais < nliais; liais++) {
		nelm = vhead->nPoints;
		lvd = vhead->headp->vd;
		lvd.x = (lvd.x * outSiz+mesh/2)/mesh;
		lvd.y = (lvd.y * outSiz+mesh/2)/mesh;
		vp = vhead->headp->next;
		while ( nelm-- > 0) {
			cvd = vp->vd;
			cvd.x = (cvd.x * outSiz+mesh/2)/mesh;
			cvd.y = (cvd.y * outSiz+mesh/2)/mesh;
			pline( bmpNo, lvd.x, lvd.y, cvd.x, cvd.y);
			lvd = cvd;
			vp = vp->next;
		}
		vhead = vhead->next;
	}
	return 0;
ERET:
	return -1;
}
static int
initmem( int iSiz,  int oSiz)
{
	iBmpSiz = (iSiz+15)/16*2*iSiz;
	
	rBuf = wkBuf = refBuf = 0;
	oBuf = owkBuf = orefBuf = 0;

	if ( (rBuf = (LPBYTE)malloc( iBmpSiz))==0)
		goto	ERET;
	if ( (wkBuf =(LPBYTE)malloc( iBmpSiz))==0)
		goto	ERET;
	if ( (refBuf =(LPBYTE)malloc( iBmpSiz))==0)
		goto	ERET;

	if ( (iBmpNo = BMPDefine( rBuf, iSiz, iSiz))<0)
		goto	ERET;
	if ( (wkBmpNo = BMPDefine( wkBuf, iSiz, iSiz))<0)
		goto	ERET;
	if ( (refBmpNo = BMPDefine( refBuf, iSiz, iSiz))<0)
		goto	ERET;

	oBmpSiz = (oSiz+15)/16*2*oSiz;

	if ( (oBuf = (LPBYTE)malloc( oBmpSiz))==0)
		goto	ERET;
	if ( (owkBuf = (LPBYTE)malloc( oBmpSiz))==0)
		goto	ERET;
	if ( (orefBuf = (LPBYTE)malloc( oBmpSiz))==0)
		goto	ERET;

	if ( (oBmpNo = BMPDefine( oBuf, oSiz, oSiz))<0)
		goto	ERET;
	if ( (owkBmpNo = BMPDefine( owkBuf, oSiz, oSiz))<0)
		goto	ERET;
	if ( (orefBmpNo = BMPDefine( orefBuf, oSiz, oSiz))<0)
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static void
termmem()
{
	if ( rBuf )	free( rBuf);
	if ( refBuf )	free( refBuf);
	if ( wkBuf )	free( wkBuf);
	if ( oBuf )	free( oBuf);
	if ( orefBuf )	free( orefBuf);
	if ( owkBuf )	free( owkBuf);

	oBuf = wkBuf = refBuf = 0;
	rBuf = orefBuf = owkBuf = 0;
	recTbl = 0;
}
static int
modmem( int iSiz)
{
	free( rBuf);
	free( wkBuf);
	free( refBuf);
	BMPFreDef( iBmpNo);
	BMPFreDef( wkBmpNo);
	BMPFreDef( refBmpNo);
	if ( (rBuf = (LPBYTE)malloc( iBmpSiz))==0)
		goto	ERET;
	if ( (wkBuf = (LPBYTE)malloc( iBmpSiz))==0)
		goto	ERET;
	if ( (refBuf = (LPBYTE)malloc( iBmpSiz))==0)
		goto	ERET;

	if ( (iBmpNo = BMPDefine( rBuf, iSiz, iSiz))<0)
		goto	ERET;
	if ( (wkBmpNo = BMPDefine( wkBuf, iSiz, iSiz))<0)
		goto	ERET;
	if ( (refBmpNo = BMPDefine( refBuf, iSiz, iSiz))<0)
		goto	ERET;
	return 0;
ERET:
	return -1;
}
/*********************************************************************
 *	Make rec-gid table of input bitmap
 */
/* */	static int
/* */	makeRecTbl(
/* */	 	int	nRec,
/* */		BOOL bIsWin95EUDC)
/*
 *	returns : none
 *********************************************************************/
{
	int	sts;

	if ( CountryInfo.LangID == EUDC_JPN || bIsWin95EUDC)
		sts = W31JrecTbl(&recTbl, bIsWin95EUDC);
	else
		sts = ETENrecTbl(&recTbl);
				
	return sts;
}
static int
impSub( 
	int	rec,
struct	BBX	*bbx,
	short	uPEm,
	int	oWidth, 	/* output bmp width */
	int	oHeight,	/* output bmp height(==width) */
struct SMOOTHPRM *prm,
	BOOL bIsWin95EUDC)
{
	int	rdsiz;
	int	width, height;
	char	UserFontSign[8];
	WORD	BankID;
unsigned short	code;
	int	sts;
	int	nRec;
	int	nGlyph;
	BOOL bUnicode;

       if (!bbx)
       {
           sts = -1;
           goto ERET;
       }
       
	/* Read EUDC Bitmap */
	if ( CountryInfo.LangID == EUDC_JPN || bIsWin95EUDC) {
		rdsiz = GetW31JBMPRec( rec, (LPBYTE)rBuf, iBmpSiz, &width, &height, &code);
		if ( rdsiz < 0)
    {
      sts = -1;
			goto	ERET;
    }
		else if ( rdsiz==0)
			return 0;
             
		if ( rdsiz > iBmpSiz) {
			iBmpSiz = rdsiz;
			modmem( width);
			if ( GetW31JBMPRec( rec, (LPBYTE)rBuf, iBmpSiz,
					 &width, &height, &code)<0)
      {
        sts = -1;
				goto	ERET;
      }
		}

	}
	else {
		if ( getETENBMPInf( &nRec, &nGlyph, &width, &height,
		     UserFontSign, &BankID)) {
			sts = -2;
			goto	ERET;
		}
		iBmpSiz = (width+7)/8*height;
		if (readETENBMPRec( rec, (LPBYTE)rBuf, iBmpSiz, &code)) {
			sts = -3;
			goto	ERET;
		}
	}	
	if( !memcmp( UserFontSign,"CMEX_PTN", 8) && BankID == 0x8001 || bIsWin95EUDC)
		bUnicode = TRUE;
	else	bUnicode = FALSE;

	/* vectorize */
	if( memcmp( UserFontSign,"CMEX_PTN", 8))
		BMPReverse( iBmpNo);
	if ( (BMPMkCont(  iBmpNo, wkBmpNo, refBmpNo, OUTLSTH))<0) {
		sts = -4;
		goto	ERET;
	}

	/* Smoothing */
	if (SmoothLight( OUTLSTH, TMPLSTH, width, height, oWidth*4, 16)) {
		sts = -5;
		goto	ERET;
	}
	rasterize( OUTLSTH, oBmpNo, oWidth*4, oWidth);

	/* Write Bitmap */
	BMPReverse( oBmpNo);

	if (PutW31JEUDCFont(code,(LPBYTE)oBuf,  oWidth, oWidth, bUnicode)) {
		sts = -6;
		goto	ERET;
	}
	BMPReverse( oBmpNo);

	if ( BMPMkCont(  oBmpNo, owkBmpNo, orefBmpNo, OUTLSTH)<0) {
		sts = -7;
		goto	ERET;
	}
	if (SmoothVector( OUTLSTH, TMPLSTH, oWidth, oHeight, oWidth*4,prm , 16)) {
		sts = -8;
		goto	ERET;
	}

	if (ConvMesh( OUTLSTH,oWidth*4, uPEm)) {
		sts = -9;
		goto	ERET;
	}
	if ( RemoveFp( OUTLSTH, uPEm, 16)) {
		sts = -10;
		goto	ERET;
	}
	if ( toTTFFrame( OUTLSTH, bbx)) {
		sts = -11;
		goto	ERET;
	}

	if( !bUnicode) 
		code = sjisToUniEUDC( code);

	/* write TTF */
	if ( TTFAppend( code, bbx, OUTLSTH)) {
		sts = -12;
		goto	ERET;
	}
	return 0;
ERET:
	return sts;
}
/*********************************************************************
 *	Import WIN31J EUDC or ETEN contiguous
 */
/* */	int
/* */	Import( 
/* */		TCHAR	*eudcPath, 	/* W31J EUDC Bitmap .fon*/
/* */		TCHAR	*bmpPath, 	/* Win95 EUDCEDIT bitmap .euf*/
/* */		TCHAR	*ttfPath,	/* TTF EUDC .ttf */
/* */		int	oWidth, 	/* output bmp width */
/* */		int	oHeight,	/* output bmp height(==width) */
/* */		int	level,
/* */		BOOL bIsWin95EUDC)
/*
 *	returns : 0, -1
 *********************************************************************/
{
	int	nRec;
	int	rec;
	int	width, height;
	char	UserFontSign[8];
	short	uPEm;
struct BBX	bbx;
	WORD	BankID;
	unsigned short	maxC;
	TCHAR	tmpPath[MAX_PATH];
	TCHAR	savPath[MAX_PATH];
	HANDLE	orgFh=INVALID_HANDLE_VALUE;
	int	sts;
struct SMOOTHPRM	prm;
	int	nGlyph;
	int	gCnt;
	int	cancelFlg;

       if ((!eudcPath) || (!bmpPath) || (!ttfPath))
       {
          return -1;
       }
//	orgFh = 0;
	BMPInit();
	VDInit();
	makeUniCodeTbl();
	maxC = getMaxUniCode();
	prm.SmoothLevel = level;
	prm.UseConic = 1;

	TTFTmpPath( ttfPath, tmpPath);
	if ( TTFImpCopy( ttfPath, tmpPath))
		goto	ERET;

	/* Open W31J EUDC bitmap font file userfont.fon or CWin31 ETEN*/
	if ( CountryInfo.LangID == EUDC_JPN || bIsWin95EUDC) {
		if (OpenW31JBMP( eudcPath, 0))
			goto	ERET;
	}
	else {
		if (openETENBMP( eudcPath, 0))
			goto	ERET;
	}

	/* Open EUDCEDIT .EUF File */
	if ( OpenW31JEUDC( bmpPath))
  {
    if (creatW31JEUDC(bmpPath))
		  goto	ERET;
    else
      if (OpenW31JEUDC( bmpPath))
        goto ERET;
  }

	if ( CountryInfo.LangID == EUDC_JPN || bIsWin95EUDC) {
		/* get number of record */
		if ( GetW31JBMPnRecs(&nRec, &nGlyph, &width, &height))
			goto	ERET;
		iBmpSiz = (width + 7)/8 * height;
	}
	else{
		if ( getETENBMPInf( &nRec, &nGlyph, &width, &height, 
		     UserFontSign, &BankID))
			goto	ERET;
		iBmpSiz = (width+7)/8*height;

	}

	/* Limit nRec */
	if ( nRec > (int)( maxC-EUDCCODEBASE+1))
		nRec = (int)( maxC-EUDCCODEBASE+1);
	initmem( width, oWidth);

	if ( makeRecTbl( nRec, bIsWin95EUDC))
		goto	ERET;

	/* Get BBX */
	if ( TTFGetEUDCBBX( ttfPath, &bbx, &uPEm))
		goto	ERET;
	/* Open temporaly */
	if ( TTFOpen( tmpPath))
		goto	ERET;

	/* Open Original */
	orgFh = CreateFile(ttfPath,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( orgFh == INVALID_HANDLE_VALUE)
		goto	ERET;
	/* copy missing glyph*/
	TTFImpGlyphCopy(orgFh, 0);
	/* per glyph */
	gCnt = 0;
	cancelFlg = 0;
	for ( rec = 0; rec < nRec; rec++) {
		if ( recTbl[rec]>= 0) {
			gCnt++;
			if ( gCnt < nGlyph) {
				if (SendImportMessage((unsigned int)gCnt,
						(unsigned int)nGlyph)==0)
					cancelFlg=1;
			}
		}
		if ( cancelFlg==0 && recTbl[rec]>= 0) {
			if ((sts = impSub(recTbl[rec],&bbx,uPEm,oWidth, oHeight,&prm,bIsWin95EUDC))<0)
				goto	ERET;
	 		else if (sts >0)
				break;
		}
		else {
			if (TTFImpGlyphCopy(orgFh, rec+2)) 
				goto	ERET;
		}
	}

	SendImportMessage((unsigned int)nGlyph, (unsigned int)nGlyph);

	if ( TTFImpTerm(orgFh, rec+2))
		goto ERET;
	
	
	CloseHandle( orgFh);
	
	if ( TTFClose())
		goto ERET;

	if ( CountryInfo.LangID == EUDC_JPN || bIsWin95EUDC) {
		if (CloseW31JBMP())
			goto	ERET;
	
	}
	else {
		if (closeETENBMP())
			goto	ERET;
	}
	CloseW31JEUDC();

	/* Replace file */
	TTFTmpPath( ttfPath, savPath);
	if ( DeleteFile( savPath)==0)
		goto	ERET;
	if (MoveFile( ttfPath, savPath)==0)
		goto	ERET;
	if (MoveFile( tmpPath, ttfPath)==0)
		goto	ERET;

	if ( DeleteFile( savPath)==0)
		goto	ERET;
	VDTerm();
	termmem();
	return 0;
ERET:
	if ( orgFh != INVALID_HANDLE_VALUE) {
		CloseHandle( orgFh);
		orgFh = INVALID_HANDLE_VALUE;
	}
	TTFClose();
	CloseW31JBMP();
	CloseW31JEUDC();
	VDTerm();
	termmem();
	return -1;
}
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\makepoly.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//

#include	"stdafx.h"


#include	"vdata.h"

#define		UNDERFP	0
#define		NMAX	129

int	MkPoly(	int inlst, int outLst);
static int DDACon(struct vecdata *s,struct vecdata *cp,struct vecdata *e,int lstHdl);
static int  fsqrt(int  n);
/***********************************************************************
 *	Make Poly line
 */
/* */	int
/* */	MkPoly(
/* */		int	inLst,
/* */		int	outLst)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	pcnt,
		sts;
struct VDATA	*vp;

	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	VDNew( outLst);
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		pcnt = vhd->nPoints;
		while ( pcnt >0) {
			if ( vp->next->vd.atr &1) {
				sts = DDACon( &vp->vd, &vp->next->vd,
					&vp->next->next->vd, outLst);
				if ( sts)
					goto	RET;
				vp = vp->next;
				pcnt--;
				if ( pcnt>0) {
					vp = vp->next;
					pcnt--;
				}
			}
			else {
				if ( (sts = VDSetData( outLst, &vp->vd))<0)
					goto	RET;
				vp = vp->next;
				pcnt--;
			}
		}
		vhd = vhd->next;
		if ( (sts = VDClose( outLst))<0)
			goto	RET;
	}
RET:
	return( sts);
}


static int	lowsqr[NMAX] = {
			   1,   2,   2,   3,   3,
			   4,   4,   4,   4,   5,
			   5,   5,   5,   6,   6,
			   6,   6,   6,   6,   7,

			   7,   7,   7,   7,   7,
			   8,   8,   8,   8,   8,
			   8,   8,   8,   9,   9,
			   9,   9,   9,   9,   9,

			   9,  10,  10,  10,  10,
			  10,  10,  10,  10,  10,
			  10,  11,  11,  11,  11,
			  11,  11,  11,  11,  11,

			  11,  12,  12,  12,  12,
			  12,  12,  12,  12,  12,
			  12,  12,  12,  13,  13,
			  13,  13,  13,  13,  13,

			  13,  13,  13,  13,  13,
			  14,  14,  14,  14,  14,
			  14,  14,  14,  14,  14,
			  14,  14,  14,  14,  15,

			  15,  15,  15,  15,  15,
			  15,  15,  15,  15,  15,
			  15,  15,  15,  16,  16,
			  16,  16,  16,  16,  16,

			  16,  16,  16,  16,  16,
			  16,  16,  16,  16,
			   };

static int	sqrtbl[NMAX] = {
			    1,    4,    9,   16,   25,
			   36,   49,   64,   81,  100,
			  121,  144,  169,  196,  225,
			  256,  289,  324,  361,  400,
			  441,  484,  529,  576,  625,
			  676,  729,  784,  841,  900,
			  961, 1024, 1089, 1156, 1225,
			 1296, 1369, 1444, 1521, 1600,
			 1681, 1764, 1849, 1936, 2025,
			 2116, 2209, 2304, 2401, 2500,
			 2601, 2704, 2809, 2916, 3025,
			 3136, 3249, 3364, 3481, 3600,
			 3721, 3844, 3969, 4096, 4225,
			 4356, 4489, 4624, 4761, 4900,
			 5041, 5181, 5329, 5476, 5625, 
			 5776, 5929, 6084, 6241, 6400,
			 6561, 6724, 6889, 7056, 7225,
			 7396, 7569, 7744, 7921, 8100,
			 8281, 8464, 8649, 8836, 9025,
			 9216, 9409, 9604, 9801, 10000,
			 10201, 10404, 10609, 10816, 11025,
			 11236, 11449, 11664, 11881, 12100,
			 12321, 12544, 12769, 12996, 13225,
			 13456, 13689, 13924, 14161, 14400,
			 14641, 14884, 15129, 15376, 15625,
			 15876, 16129, 16384, 16641 
			 };

/************************************************************
 *	DDA Poly line generate
 */
/* */	static int
/* */	DDACon(
/* */		struct vecdata	*s,
/* */		struct vecdata	*cp,
/* */		struct vecdata	*e,
/* */			int	lstHdl)
/*
 *	returns :  0, -1
 ************************************************************/
{
	int	n2xmax, n2ymax, n2max;
	int	i, n;
	long	f1x,		/* for f1@ */
		fx,		/* for F(i) */
		px,		/* for G(i) */
		g1x, g2x;
	long	f1y,		/* for f1@ */
		fy,		/* for F(i) */
		py,		/* for G(i) */
		g1y, g2y;
	int	sts, num;
	long	relx, rely; 	/* ΍W */
	int	n2, n2hlf;
struct vecdata	pntdata;

	/* Set Start Point */
	if ( (sts= VDSetData( lstHdl, s))<0)
		goto	RET;

	/*  N߂ */
	n2xmax = (e->x - cp->x) - ( cp->x - s->x);

	if ( n2xmax < 0)	n2xmax = -n2xmax;
	else if ( n2xmax == 0 && cp->x==s->x)
		goto	TERM_SET;

	n2ymax = (e->y - cp->y) - ( cp->y - s->y);
	if ( n2ymax < 0)	n2ymax = -n2ymax;
	else if ( n2ymax == 0 && cp->y==s->y)
		goto	TERM_SET;

	if ( n2xmax > n2ymax)		n2max = (n2xmax*2) >> UNDERFP;
	else				n2max = (n2ymax*2) >> UNDERFP;
	n = fsqrt( n2max); 

	/* _̍W߂ */ 
	if ( n > 1) {
		n2 = n*n;
		n2hlf = (n*n)/2;	 /* Expect Optimize */

		px = (long)s->x*n2;
		py = (long)s->y*n2;

		g2x = (e->x - cp->x) - (cp->x - s->x);
		g2y = (e->y - cp->y) - (cp->y - s->y);

		g1x = (long)n*(cp->x - s->x) *2;
		g1y = (long)n*(cp->y - s->y) *2;

		f1x = g2x*2;
		f1y = g2y*2;

		fx = g1x + g2x;
		fy = g1y + g2y;

		px += fx;
		py += fy;

		/* ŏ̓_߂ : n_̑΍WvZ */
		relx = fx;
		rely = fy;
		if (relx >= 0)	relx += n2hlf;
		else		relx -= n2hlf;
		if (rely >= 0)	rely += n2hlf;
		else		rely -= n2hlf;

		pntdata.x = (int)(relx / n2 + s->x);
		pntdata.y = (int)(rely / n2 + s->y);
		pntdata.atr = 0;
		if ( (sts= VDSetData( lstHdl, &pntdata ))<0)
			goto	RET;
		if (n > 2) {
			num = n - 1;
			for ( i = 2; i < num; i++) {
				fx += f1x;
				fy += f1y;

				px +=  fx;
				py +=  fy;

				/* ŏƍŌ̓_ȊO̓_΍WŌvZ */
				pntdata.x = (int)((px + n2hlf) /n2);
				pntdata.y = (int)((py + n2hlf) /n2);
				if ( (sts= VDSetData(lstHdl, &pntdata ))<0)
					goto	RET;
			}
			fx += f1x;
			fy += f1y;

			px +=  fx;
			py +=  fy;

			relx = px - (long)e->x*n2;
			rely = py - (long)e->y*n2;
			if (relx >= 0)	relx += n2hlf;
			else		relx -= n2hlf;
			if (rely >= 0)	rely += n2hlf;
			else		rely -= n2hlf;
	
			/* Ō̓_߂ : I_̑΍WvZ */
			pntdata.x = (int)(relx / n2 + e->x);
			pntdata.y = (int)(rely / n2 + e->y);
			if ( (sts= VDSetData(lstHdl, &pntdata))<0)
				goto	RET;
		}
	}
TERM_SET:

	/* Ȑ̏I_͐ݒ肵Ȃ */
RET:
	return( sts);
}
/************************************************************
 *	Fast SQRT (N̕߂)
 */
/* */	static int
/* */	fsqrt( int n)
/*
 *	returns : 
 ************************************************************/
{
	int	i;

	if ( n < NMAX*2) {
		i = lowsqr[ n/2];
	}
	else {
		for ( i=0; i<NMAX; i++ )
			if ( sqrtbl[i] > n)	break;
		i++;
	}
	return( i );
}
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\refrlist.cpp ===
/**************************************************/
/*						                          */
/*						                          */
/*	Character List( Referrence Dialog)	          */
/*						                          */
/*						                          */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"refrlist.h"
#include    "util.h"
#define STRSAFE_LIB
#include <strsafe.h>

//	6 * 16 Matrics
#define		NUM_CHAR	16
#define		NUM_LINE	6

//	Type of Character Code
#define		CHAR_INIT	0	// Initial value
#define		CHAR_SBCS	1	// SBCS
#define		CHAR_DBCS1	2	// DBCS1
#define		CHAR_DBCS2	3	// DBCS2
#define		CHAR_EUDC	4	// EUDC
#define		CHAR_ETC	5	// Other

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE( CRefrList, CEdit)
BEGIN_MESSAGE_MAP( CRefrList, CEdit)
	//{{AFX_MSG_MAP( CRefrList)
	ON_WM_PAINT()
	ON_WM_VSCROLL()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_SETCURSOR()
	ON_WM_KEYDOWN()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_RBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//	Range of character code( high byte)
static WORD HiByteRange[][10] =
{
//    JPN             CHT             KRW             CHS             OTHER
	{ 0x00a0, 0xfca0, 0x00a0, 0xfea0, 0x00a0, 0xfea0, 0x00a0, 0xfea0, 0x00a0, 0x00a0}, // CHAR_INIT
	{ 0x0020, 0x00ff, 0x0020, 0x00ff, 0x0020, 0x00ff, 0x0020, 0x00ff, 0x0020, 0x00ff}, // CHAR_SBCS
	{ 0x8140, 0x9fff, 0x8140, 0xa0ff, 0x8140, 0x8fff, 0x8140, 0xafff, 0x0020, 0x00ff}, // CHAR_DBCS1
	{ 0xe040, 0xeaff, 0xa140, 0xf9ff, 0x9040, 0x9fff, 0xb040, 0xf7ff, 0x0020, 0x00ff}, // CHAR_DBCS2
	{ 0xf040, 0xfcff, 0xfa40, 0xfeff, 0xa040, 0xfeff, 0xf840, 0xfeff, 0x0020, 0x00ff}, // CHAR_EUDC
};

//	Range of character code( low byte)
static WORD LoByteRange[][10] =
{
	{ 0x0020, 0x00ff, 0x0020, 0x00ff, 0x0020, 0x00ff, 0x0020, 0x00ff, 0x0020, 0x00ff },
	{ 0x0040, 0x007e, 0x0040, 0x007e, 0x0041, 0x005a, 0x0040, 0x007e, 0x0040, 0x007e },
	{ 0x0080, 0x00fc, 0x0080, 0x00fe, 0x0061, 0x007a, 0x0080, 0x00fe, 0x0040, 0x007e },
	{ 0x0080, 0x00fc, 0x0080, 0x00fe, 0x0081, 0x00fe, 0x0080, 0x00fe, 0x0040, 0x007e },
	{ 0x0000, 0x003f, 0x0000, 0x003f, 0x0000, 0x003f, 0x0000, 0x003f, 0x0040, 0x007e },
};

extern LOGFONT	ReffLogFont;
extern LOGFONT	EditLogFont;
extern BOOL	TitleFlag;
extern BOOL	CodeFocus;
extern BOOL	CharFocus;
static CRect	rcReferChar[NUM_LINE][NUM_CHAR];
static CRect	rcReferCode[NUM_LINE];

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CRefrList::CRefrList()
{
/*
//	Initialize static parameter
	if( CountryInfo.LangID == EUDC_CHT)
		CHN = 2;
	else if( CountryInfo.LangID == EUDC_JPN)
		CHN = 0;
	else if( CountryInfo.LangID == EUDC_KRW)
		CHN = 4;
	else if( CountryInfo.LangID == EUDC_CHS)
		CHN = 6;
	else 	CHN = 8;
*/
	FocusFlag = FALSE;
}
								
/****************************************/
/*					*/
/*	Destructor( Virtual)		*/
/*					*/
/****************************************/
CRefrList::~CRefrList()
{
    SysFFont.DeleteObject();
    CharFont.DeleteObject();
		ViewFont.DeleteObject();
}
			      		
/****************************************/
/*					*/
/*	Set intitial code range		*/
/*					*/
/****************************************/
void
CRefrList::SetCodeRange()
{
    CHARSETINFO CharsetInfo;
    BYTE CharSet;

		SelectCode = 0x0020;
		ScrlBarPos = 0;
		StartCode  = 0x0020;
		EndCode    = 0xffff;
		ViewStart  = 0x0020;
		ViewEnd    = 0xffa0;
/*
	SelectCode = HiByteRange[CHAR_SBCS][CHN];
	ScrlBarPos = 0;
	StartCode  = HiByteRange[CHAR_SBCS][CHN];
	ViewStart  = HiByteRange[CHAR_SBCS][CHN];
	if( !TitleFlag){
		if( rLogFont.lfCharSet == CountryInfo.CharacterSet){
//			Correspond to DBCS		    	
			ViewEnd = HiByteRange[CHAR_INIT][CHN+1];
			EndCode	= HiByteRange[CHAR_EUDC][CHN+1];
		}else{
//			Correspond to SBCS
			ViewEnd = HiByteRange[CHAR_INIT][CHN];
			EndCode	= HiByteRange[CHAR_SBCS][CHN+1];
		}
        CharSet = rLogFont.lfCharSet;

	}else{
		if( cLogFont.lfCharSet == CountryInfo.CharacterSet){
			ViewEnd = HiByteRange[CHAR_INIT][CHN+1];
			EndCode	= HiByteRange[CHAR_EUDC][CHN+1];
		}else{
			ViewEnd = HiByteRange[CHAR_INIT][CHN];
			EndCode	= HiByteRange[CHAR_SBCS][CHN+1];
		}
        CharSet = cLogFont.lfCharSet;
	}

    if(CharSet == SYMBOL_CHARSET)
    {
        dwCodePage = 1252;
    }
    else if(TranslateCharsetInfo((DWORD *)CharSet,&CharsetInfo,TCI_SRCCHARSET))
    {
        dwCodePage = CharsetInfo.ciACP;
    }
    else
    {
        dwCodePage = CP_ACP;
    }
*/
}

/****************************************/
/*					*/
/*	Check type of character code	*/
/*					*/
/****************************************/
int
CRefrList::CheckCharType(
WORD 	Code)
{
	/*
	if( !( Code & 0xff00))
		return	CHAR_SBCS;
	else if(( Code >= HiByteRange[CHAR_DBCS1][CHN]) &&
	        ( Code <= HiByteRange[CHAR_DBCS1][CHN+1]))
		return  CHAR_DBCS1;
	else if(( Code >= HiByteRange[CHAR_DBCS2][CHN]) &&
		( Code <= HiByteRange[CHAR_DBCS2][CHN+1]))
	 	return  CHAR_DBCS2;
	else if(( Code >= HiByteRange[CHAR_EUDC][CHN])  &&
		( Code <= HiByteRange[CHAR_EUDC][CHN+1]))
		return  CHAR_EUDC;
	else	return  CHAR_ETC;
	*/
	return 0;
}

/****************************************/
/*					*/
/*	Increase character code		*/
/*					*/
/****************************************/
WORD
CRefrList::GetPlusCode(
WORD 	Code,
int 	ScrollNum)
{
	WORD	PrevCode;
	WORD 	LowByte, HighByte;
	int	CharType;
	int	CharType1, CharType2;
	int	Offset;

	Code += (WORD)ScrollNum;
/*
	PrevCode = (WORD)(Code - (WORD)ScrollNum);
	CharType1 = CheckCharType( PrevCode);
	CharType2 = CheckCharType( Code);
	if( CharType1 != CharType2){
		if( CharType1 == CHAR_EUDC)
			Code = PrevCode;		
		else{
			Offset = Code - HiByteRange[CharType1][CHN+1];
			Code = (WORD)( HiByteRange[CharType1+1][CHN] +Offset-1);
		}
	}
	CharType = CheckCharType( Code);
	if( CharType != CHAR_SBCS){
		LowByte  = Code & 0x00ff;
		HighByte = Code & 0xff00;
		if( LowByte <= LoByteRange[4][CHN+1] &&
		    LowByte >= LoByteRange[4][CHN] ){
#if 0
			if( CountryInfo.LangID == EUDC_CHS)
				LowByte = 0x00a0;
			else	LowByte = 0x0040;
#endif
			LowByte = 0x0040;
		}
		Code = ( HighByte | LowByte);
	}
*/
	return Code;
}
					
/****************************************/
/*					*/
/*	Decrease Character Code		*/
/*					*/
/****************************************/
WORD
CRefrList::GetMinusCode(
WORD 	Code,
int 	ScrollNum)
{
	WORD	PrevCode;
	int	CharType;
	int	CharType1, CharType2;
	int	Offset;

	Code -= (WORD)ScrollNum;
/*
	PrevCode = (WORD)( Code + (WORD)ScrollNum);
	CharType1 = CheckCharType( Code);
	CharType2 = CheckCharType( PrevCode);
	if( CharType1 != CharType2){
	 	if( CharType2 == CHAR_SBCS)
			return (WORD)HiByteRange[CHAR_SBCS][CHN];
		else{
			Offset = HiByteRange[CharType2][CHN] - Code;
			return (WORD)(HiByteRange[CharType2-1][CHN+1]-Offset+1);
		}	
	}
	CharType = CheckCharType( Code);
	if( CharType != CHAR_SBCS){
		WORD 	LowByte;
		WORD	HighByte;
		WORD	Tmp;

		LowByte  = Code & 0x00ff;
		HighByte = Code & 0xff00;
		if( LowByte <= LoByteRange[4][CHN+1] &&
		    LowByte >= LoByteRange[4][CHN] ){
			LowByte = 0xf0;
			Tmp = ( HighByte >> 8);
			Tmp -= 0x1;
			HighByte = Tmp << 8;
		}
		Code = ( HighByte | LowByte);
	}
*/
	return Code;
}
					
/****************************************/
/*					*/
/*	Calculate scroll position	*/
/*					*/	
/****************************************/
int
CRefrList::GetBarPosition(
WORD 	Code)
{
	short   i, StartType, EndType;
	int     Pos = 0;

	Pos = (Code - StartCode) /NUM_CHAR;
	return Pos;
/*
	StartType = CheckCharType( StartCode);
	EndType   = CheckCharType( Code);
	if( EndType == CHAR_SBCS){
		Pos = ( Code - HiByteRange[CHAR_SBCS][CHN]) /NUM_CHAR;
		return Pos;

	}

	for (i = StartType; i < EndType; i++){
		if( i == CHAR_SBCS){
			Pos += (HiByteRange[CHAR_SBCS][CHN+1]
				- HiByteRange[CHAR_SBCS][CHN] + 1) / NUM_CHAR;
		}else{
        		Pos += CalculateCode( HiByteRange[i][CHN],
        			HiByteRange[i][CHN+1]) / NUM_CHAR;
		}
	}
	Pos += CalculateCode( HiByteRange[i][CHN], Code) / NUM_CHAR;
	return Pos;
*/
}
					
/****************************************/
/*					*/
/*	Calculate character code	*/
/*					*/
/****************************************/
WORD
CRefrList::CalculateCode(
WORD 	Start,
WORD 	End)
{
	WORD 	PageNum = 0;
	WORD	CodeNum = 0;

    	if ( Start >= End )
         	return 0;

    	PageNum = HIBYTE(End) - HIBYTE(Start);
#if 0
	if( CountryInfo.LangID == EUDC_CHS){
		if( HIBYTE(End)){
			WORD	LoCode;
			WORD	HiCode;

			HiCode = End & 0xff00;
			LoCode = End & 0x00ff;
			if( LoCode < 0xa0)
				LoCode = 0xa0;
			End = HiCode | LoCode;
		}
		CodeNum	= End - Start - PageNum * 0x00a0;
	}else   CodeNum = End - Start - PageNum * 0x0040;
#endif
	CodeNum = End - Start - PageNum * 0x0040;

    	return CodeNum;
}
					
/****************************************/
/*					*/
/*  	Calculate code from scroll pos	*/
/*					*/
/****************************************/
WORD
CRefrList::GetCodeScrPos(
int 	Pos)
{
	short	i, StartType, EndType;
	WORD	Code = 0;
	WORD	NumLine = 0, PNumLine = 0;

	if (Pos == 0)
		return StartCode;
	if (Pos >= BottomCode)
	  return ViewEnd;
	Code = StartCode + Pos * NUM_CHAR;
	Code &= 0xfff0;
	return Code;

/*
	if( !Pos)
        	return HiByteRange[1][CHN];
	if( Pos >= BottomCode)
        	return ViewEnd;

	StartType = CheckCharType( HiByteRange[1][CHN]);
	EndType   = CheckCharType( HiByteRange[4][CHN+1]);
	for( i = StartType; i <= EndType; ++i){
    if( i == CHAR_SBCS )
      NumLine += (HiByteRange[i][CHN+1] - HiByteRange[i][CHN] + 1) /NUM_CHAR;
    else
    	NumLine += CalculateCode( HiByteRange[i][CHN],HiByteRange[i][CHN+1])/NUM_CHAR;
    if( NumLine > Pos){
			NumLine = PNumLine;
      break;
    }
    PNumLine = NumLine;
	}
	Code = HiByteRange[i][CHN];
	Pos -= NumLine;
  while( Code < HiByteRange[i][CHN+1]){
    NumLine = CalculateCode( HiByteRange[i][CHN], Code) /NUM_CHAR;
    if( Pos <= NumLine){
	        	break;
		}
    Code += NUM_CHAR;
  }

	Code &= 0xfff0;
	return Code;
*/
}
					
/****************************************/
/*					*/
/*	Jump view if editbox get focus	*/
/*					*/
/****************************************/
BOOL
CRefrList::CodeButtonClicked()
{
	WCHAR CodeValue[15] = {0};
	WCHAR	CharValue[15] = {0};
	WORD	Code1, Code2;

	Code1 = (WORD)0;
	Code2 = (WORD)0;
#ifdef UNICODE
  ::GetDlgItemTextW(GetParent()->GetSafeHwnd(), IDC_EDITCODE, CodeValue, 15);
  ::GetDlgItemTextW(GetParent()->GetSafeHwnd(), IDC_EDITCHAR, CharValue, 15);
#else
	CHAR CodeValueA[15];
	CHAR CharValueA[15];
  ::GetDlgItemText(GetParent()->GetSafeHwnd(), IDC_EDITCODE, CodeValueA, 15);
  int nchar = ::GetDlgItemText(GetParent()->GetSafeHwnd(), IDC_EDITCHAR, CharValueA, 15);
  MultiByteToWideChar(CP_ACP, 0, CodeValueA, 4, CodeValue, sizeof(CodeValue)/sizeof(CodeValue[0]));
  MultiByteToWideChar(CP_ACP, 0, CharValueA, nchar, CharValue, sizeof(CharValue)/sizeof(CharValue[0]));
#endif

  /*	::GetDlgItemTextA( GetParent()->GetSafeHwnd(),IDC_EDITCHAR, CharValue, 15); */

	if( CodeValue[0] == '\0' && CharValue[0] == '\0')
		return TRUE;

	if( CodeValue[0] == '\0')
		Code2 = 0xffff;
	else	Code2 = (WORD)wcstol((LPWSTR)CodeValue, (WCHAR **)0, 16);
		
	if( CharValue[0] == '\0')
		Code1 = 0xffff;
	else
		Code1  = CharValue[0];
	
	if( CodeFocus){
		if( !IsCheckedCode( Code2))
			goto Error;
		SelectCode = Code2;		
	}

	if( CharFocus){
		if( !IsCheckedCode( Code1))
			goto Error;
		SelectCode = Code1;		
	}
		
	if( SelectCode >= ViewEnd)
		ViewStart = ViewEnd;
	else	ViewStart = SelectCode & 0xfff0;

 	BottomCode = (WORD)GetBarPosition((WORD)ViewEnd);
 	this->SetScrollRange( SB_VERT, 0, BottomCode, FALSE);
	ScrlBarPos = (short)GetBarPosition( ViewStart);
	this->SetScrollPos( SB_VERT, ScrlBarPos, TRUE);
	this->InvalidateRect( &CodeListRect, TRUE);
	this->UpdateWindow();
	return TRUE;
Error:
	return FALSE;
}
					
/****************************************/
/*					*/
/*	Check Character Code Range	*/
/*					*/
/****************************************/
BOOL
CRefrList::IsCheckedCode(
WORD 	CodeStock)
{
	WORD	Offset;
	int	CharType;
	int	CharType1;
/*
	if(( CharType = CheckCharType( CodeStock)) == CHAR_ETC)
		return FALSE;
	CharType1 = CheckCharType( ViewEnd);

	Offset = CodeStock & 0x00ff;
	if( CharType == CHAR_SBCS){
		if( Offset < LoByteRange[0][CHN])
			return FALSE;
	}else{
		if( CharType1 == CHAR_SBCS)
			return FALSE;
		if( Offset >= LoByteRange[4][CHN] &&
		    Offset <= LoByteRange[4][CHN+1] )
			return FALSE;
		if(( Offset >= LoByteRange[1][CHN]  &&
		     Offset <= LoByteRange[1][CHN+1]) ||
		   ( Offset >= LoByteRange[2][CHN]  &&
		     Offset <= LoByteRange[2][CHN+1]) ||
		   ( Offset >= LoByteRange[3][CHN]  &&
		     Offset <= LoByteRange[3][CHN+1])){
				;
		}else	return FALSE;
	}
*/
	return TRUE;
}

#define	FIX_SPACE	6
#define	LINEWIDTH	4
/****************************************/
/*					*
/*	Calcurate character size	*/
/*					*/
/****************************************/
void
CRefrList::CalcCharSize()
{
	char	Dummy[] = "FA40";
	int	Sx;

	CClientDC	dc( this);
	this->GetClientRect( &CodeListRect);

	CFont	*OldFont = dc.SelectObject( &SysFFont);
	GetTextExtentPoint32A( dc.GetSafeHdc(), Dummy, 4, &FixSize);
	FixSize.cx += FIX_SPACE;
	dc.SelectObject( OldFont);

	CharSize.cy = ( CodeListRect.Height()
			- ((NUM_LINE-1)*LINEWIDTH) - 2) /NUM_LINE;
	CharSize.cx = ( CodeListRect.Width()
			- FixSize.cx - 2 - (NUM_CHAR*LINEWIDTH)) / NUM_CHAR;

	for( int i = 0; i < NUM_LINE; i++){
		rcReferCode[i].left   = 1;
		rcReferCode[i].top    = 1 + i*(CharSize.cy + LINEWIDTH);
		rcReferCode[i].right  = rcReferCode[i].left + FixSize.cx;
		rcReferCode[i].bottom = rcReferCode[i].top  + CharSize.cy;
		Sx = rcReferCode[i].right + LINEWIDTH;
		for( int j = 0; j < NUM_CHAR; j++){
			rcReferChar[i][j].left   = Sx + j*( CharSize.cx
						 + LINEWIDTH);
			rcReferChar[i][j].top    = rcReferCode[i].top;
			rcReferChar[i][j].right  = rcReferChar[i][j].left
						+ CharSize.cx;
			rcReferChar[i][j].bottom = rcReferChar[i][j].top
						+ CharSize.cy;
		}
	}
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void
CRefrList::OnPaint()
{
register int	i, j;
	WORD	Code;
	HRESULT hresult;

	CPaintDC	dc( this);

	int BottomCode = GetBarPosition((WORD)ViewEnd);
	this->SetScrollRange( SB_VERT, 0, BottomCode, FALSE);
	this->SetScrollPos( SB_VERT, ScrlBarPos, TRUE);

//	Initialize character code
	Code = ViewStart;

//	Change Mapping mode
	int OldMode = dc.SetMapMode(MM_TEXT);
	dc.SetViewportOrg( 0, 0);
	CFont	*OldFont = dc.SelectObject( &SysFFont);

	for( i = 0; i < NUM_LINE; i++){
		int	xOffset, yOffset;
		TCHAR	Work[5];
		int	wLength, CharType;

//		Draw character code on character list to display
		dc.SelectObject( &SysFFont);
		//*STRSAFE* 		wsprintf(Work, _T("%04X"), Code);
		hresult = StringCchPrintf(Work , ARRAYLEN(Work),  _T("%04X"), Code);
		if (!SUCCEEDED(hresult))
		{
		   return ;
		}
		dc.SetBkColor( COLOR_FACE);
		dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT));  //COLOR_BLACK);

		if( rcReferCode[i].Height() > FixSize.cy){
			yOffset = (rcReferCode[i].Height() - FixSize.cy) /2;
		}else	yOffset = 0;

        ::ExtTextOut(dc, rcReferCode[i].left + FIX_SPACE/2,
				      rcReferCode[i].top  + yOffset,
			        ETO_OPAQUE, &rcReferCode[i],
			        (TCHAR *)Work, 4, NULL);

		dc.SelectObject( &CharFont);
		for( j = 0; j < NUM_CHAR; j++ , Code = GetPlusCode( Code, 1)){
			WORD	Offset;
			CSize	cSize;
      WCHAR Work1[5];
			Work1[0] = Code;
			Work1[1] = 0;
			wLength = 1;
/*
			if(( CharType = CheckCharType( Code)) == CHAR_SBCS){
				Work[0] = LOBYTE(Code);
				wLength = 1;

			}else if( CharType == CHAR_DBCS1 ||
				  CharType == CHAR_DBCS2 ||
				  CharType == CHAR_EUDC  ){
				Offset = Code & 0x00ff;
				if(( Offset <= LoByteRange[1][CHN+1]  &&
				     Offset >= LoByteRange[1][CHN]) ||
				   ( Offset <= LoByteRange[2][CHN+1]  &&
				     Offset >= LoByteRange[2][CHN]) ||
				   ( Offset <= LoByteRange[3][CHN+1]  &&
				     Offset >= LoByteRange[3][CHN]) ){
	   					Work[0] = (BYTE)((Code>>8) & 0x00ff);
    	        		Work[1] = (BYTE) (Code & 0x00ff);
        	    		wLength = 2;
				}else{
					continue;				
				}
	   		}else	wLength = 0;
            		Work[wLength] = (BYTE)'\0';

#ifdef UNICODE
            WCHAR wszCodeTemp[2];
            wLength = MultiByteToWideChar(dwCodePage,
                                              0,
                                              (LPSTR) Work,
                                              wLength,
                                              wszCodeTemp,
                                              1);
                Work[0] = LOBYTE(wszCodeTemp[0]);
                Work[1] = HIBYTE(wszCodeTemp[0]);
                Work[2] = '\0';
#endif
*/
			BOOL	PtIn;
			if( rcReferChar[i][j].PtInRect( LButtonPt) ||
			    SelectCode == Code){
				TCHAR 	CodeNum[10];

//				If character is selected by clickking
//			 	left button, draw it on dialog
				PtIn = TRUE;
				SelectCode = Code;
				dc.SetBkColor( COLOR_FACE);
				dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT)); // COLOR_BLACK);
				//*STRSAFE*    wsprintf((TCHAR *)CodeNum, _T("%04X"), Code);
				hresult = StringCchPrintf((TCHAR *)CodeNum , ARRAYLEN(CodeNum), _T("%04X"), Code);
		              if (!SUCCEEDED(hresult))
		              {
		                  return ;
		              }

				if (!CodeFocus)
				{
          ::SetDlgItemText(GetParent()->GetSafeHwnd(), IDC_EDITCODE, (LPCTSTR)CodeNum);
				}

				if (!CharFocus)
				{
#ifdef UNICODE
          ::SetDlgItemTextW(GetParent()->GetSafeHwnd(), IDC_EDITCHAR, (LPCWSTR)Work1);
#else
          CHAR Work2[5];
          int nchar=WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)Work1, 1, (LPSTR)Work2, sizeof(Work2), 0,0);
          Work2[nchar]=0;
          ::SetDlgItemText(GetParent()->GetSafeHwnd(), IDC_EDITCHAR, (LPCSTR)Work2);
#endif        
        }

			}else{
				PtIn = FALSE;
				dc.SetBkColor( COLOR_FACE);
				dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT)); // COLOR_BLACK);
			}
			BOOL sts = GetTextExtentPoint32W( dc.GetSafeHdc(),
				(LPCWSTR)Work1, wLength, &cSize);

			if( rcReferChar[i][j].Width() > cSize.cx){
				xOffset = rcReferChar[i][j].Width() - cSize.cx;
				xOffset /= 2;
			}else	xOffset = 0;

			if( rcReferChar[i][j].Height() > cSize.cy){
				yOffset = rcReferChar[i][j].Height() - cSize.cy;
				yOffset /= 2;
			}else	yOffset = 0;

//			Draw character code on character list
			ExtTextOutW(dc.GetSafeHdc(), rcReferChar[i][j].left + xOffset,
				       rcReferChar[i][j].top  + yOffset,
				       ETO_OPAQUE, &rcReferChar[i][j],
				       (LPCWSTR)Work1, wLength, NULL);
			DrawConcave( &dc, rcReferChar[i][j], PtIn);
		}
    }
    dc.SelectObject( OldFont);
	dc.SetMapMode(OldMode);
	LButtonPt.x = 0;
	LButtonPt.y = 0;
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_VSCROLL"		*/
/*					*/
/****************************************/
void
CRefrList::OnVScroll(
UINT 		nSBCode,
UINT 		nPos,
CScrollBar	*pScrollBar)
{
	int	MoveScr;
	BOOL 	ThumbTrkFlag, ThumbPosFlag;

      
	BottomCode = (WORD)GetBarPosition((WORD)ViewEnd);
	this->SetScrollRange( SB_VERT, 0, BottomCode, FALSE);

	MoveScr = 0;
	ThumbTrkFlag = ThumbPosFlag = FALSE;
	switch( nSBCode){
		case SB_LINEDOWN:
			if(( ViewStart + NUM_CHAR) <= ViewEnd){
				MoveScr = 0 - (CharSize.cy + LINEWIDTH);
				ViewStart  = GetPlusCode( ViewStart,NUM_CHAR);
				ScrlBarPos = (short)GetBarPosition( ViewStart);
			}
			break;

		case SB_LINEUP:
			if(( ViewStart - NUM_CHAR) >= StartCode){
				MoveScr = CharSize.cy + LINEWIDTH;
				ViewStart  = GetMinusCode(ViewStart,NUM_CHAR);
				ScrlBarPos = (short)GetBarPosition( ViewStart);
			}
			break;

		case SB_PAGEDOWN:
			if(( ViewStart + NUM_CHAR*NUM_LINE) <= ViewEnd){
				MoveScr = ( 0 -(CharSize.cy+LINEWIDTH)) *NUM_LINE;
				ScrlBarPos = (short)GetBarPosition( ViewStart);
				ScrlBarPos += NUM_LINE;
				ViewStart = GetCodeScrPos( ScrlBarPos);
 			}else{
				MoveScr = ( 0 -(CharSize.cy+LINEWIDTH)) *NUM_LINE;
				ViewStart = ViewEnd;
				ScrlBarPos = (short)GetBarPosition( ViewStart);
			}
			break;

		case SB_PAGEUP:
			if(( ViewStart - NUM_CHAR*NUM_LINE) >= StartCode &&
				 ViewStart >= NUM_CHAR*NUM_LINE){
				MoveScr =  (CharSize.cy + LINEWIDTH) *NUM_LINE;
				ScrlBarPos = (short)GetBarPosition( ViewStart);
				ScrlBarPos -= NUM_LINE;
				ViewStart = GetCodeScrPos( ScrlBarPos);
			}else{
				MoveScr = (CharSize.cy + LINEWIDTH) *NUM_LINE;
				ViewStart = StartCode;
				ScrlBarPos = (short)GetBarPosition( ViewStart);
			}
			break;

		case SB_THUMBPOSITION:
			ThumbPosFlag = TRUE;
			ScrlBarPos = (short)nPos;
			ViewStart = GetCodeScrPos( nPos);
			break;

		case SB_THUMBTRACK:
			ThumbTrkFlag = TRUE;
			break;

		case SB_TOP:
			ViewStart = StartCode;
			ScrlBarPos = 0;
			break;

		case SB_BOTTOM:
			ViewStart = ViewEnd;
			ScrlBarPos = BottomCode;
			break;

		default:
			break;
	}
	if( abs( MoveScr) <= (CharSize.cy + LINEWIDTH) &&
	    abs( MoveScr) > 0 && !ThumbTrkFlag){
		CRect	ScrllRect;
		CRect	ClintRect;

		GetClientRect( &ClintRect);
		ScrllRect.CopyRect( &ClintRect);
		if( MoveScr < 0){
			ClintRect.top = 0 - MoveScr;
			this->ScrollWindow( 0, MoveScr, &ClintRect, NULL);
			ScrllRect.top = ( 0-MoveScr)*(NUM_LINE -1);
		}else{
			ClintRect.top = 0;
			ClintRect.bottom = MoveScr*(NUM_LINE -1);
			this->ScrollWindow( 0, MoveScr, &ClintRect, NULL);
			ScrllRect.top = 0;
			ScrllRect.bottom = ScrllRect.top + MoveScr;
		}
		this->InvalidateRect( &ScrllRect, FALSE);
	}else if( !ThumbTrkFlag && ( MoveScr || ThumbPosFlag)){
		this->InvalidateRect( &CodeListRect, TRUE);
	}
	this->SetScrollPos( SB_VERT, ScrlBarPos, TRUE);
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_LBUTTONDOWN"	*/
/*					*/
/****************************************/
void
CRefrList::OnLButtonDown(
UINT	,
CPoint 	point)
{
	CRect	test;
	BOOL	PtIn;
unsigned int	i, j;

	PtIn = FALSE;
	this->SetFocus();
	for( i = 0; i < NUM_LINE; i++){
		for( j = 0; j < NUM_CHAR; j++){
			if( rcReferChar[i][j].PtInRect( point)){
				if( IsCorrectChar( i, j))
					PtIn = TRUE;
				break;
			}
		}
	}

	if( !PtIn){
		MessageBeep((UINT)-1);
		return;
	}

	LButtonPt = point;
	SearchKeyPosition( TRUE);
	SelectCode = 0;

	for( i = 0; i < NUM_LINE; i++){
		for( j = 0; j < NUM_CHAR; j++){
			if( rcReferChar[i][j].PtInRect( LButtonPt)){
				test.SetRect( rcReferChar[i][j].left - 2,
					      rcReferChar[i][j].top - 2,
					      rcReferChar[i][j].right + 2,
					      rcReferChar[i][j].bottom + 2);
				this->InvalidateRect( &test, FALSE);
				break;
			}
		}
	}
	this->UpdateWindow();
}
					
/****************************************/
/*					*/
/*	MESSAGE	"WM_LBUTTONDBLCLK"	*/
/*					*/
/****************************************/	
void
CRefrList::OnLButtonDblClk(
UINT 	nFlags,
CPoint 	point)
{
	BOOL	PtIn;
unsigned int	i, j;

	LButtonPt = point;
	this->InvalidateRect( &CodeListRect, FALSE);
	this->UpdateWindow();

 	PtIn = FALSE;
	this->SetFocus();
	for( i = 0; i < NUM_LINE; i++){
		for( j = 0; j < NUM_CHAR; j++){
			if( rcReferChar[i][j].PtInRect( point)){
				if( IsCorrectChar( i, j))
					PtIn = TRUE;
				break;
			}
		}
	}
	if( !PtIn){
		MessageBeep((UINT)-1);
		return;
	}else{
		GetParent()->PostMessage( WM_COMMAND, IDOK, 0L);
	}
}
					
/****************************************/
/*					*/
/*	MESSAGE	"WM_SETCURSOR"		*/
/*					*/
/****************************************/
BOOL
CRefrList::OnSetCursor(
CWnd* 	pWnd,
UINT 	nHitTest,
UINT 	message)
{
	::SetCursor( AfxGetApp()->LoadStandardCursor(IDC_ARROW));
	return TRUE;
}

/****************************************/
/*					*/
/*	Reset parameter			*/
/*					*/
/****************************************/
void
CRefrList::ResetParam()
{
	LButtonPt.x = LButtonPt.y = 0;
/*
	SelectCode = HiByteRange[CHAR_SBCS][CHN];
*/
	SelectCode = 0x0020;
	ScrlBarPos = 0;
	this->SetScrollPos( SB_VERT, ScrlBarPos, TRUE);
}

/****************************************/
/*					*/
/*	Draw Concave ractangle		*/
/*					*/
/****************************************/
void
CRefrList::DrawConcave(
CDC 	*dc,
CRect 	rect,
BOOL 	PtIn)
{
	CBrush	ConBrush, *OldBrush;
	CRect	Rt;

       if (!dc)
       {
          return;
       }
	Rt.SetRect( rect.left-1, rect.top-1, rect.right+1, rect.bottom+1);

	if( !PtIn){
		ConBrush.CreateSolidBrush( COLOR_HLIGHT);
		OldBrush = dc->SelectObject( &ConBrush);
		dc->PatBlt( Rt.left, Rt.top, Rt.Width(), 1, PATCOPY);
		dc->PatBlt( Rt.left, Rt.top, 1, Rt.Height(), PATCOPY);
		dc->SelectObject( OldBrush);
		ConBrush.DeleteObject();

		ConBrush.CreateSolidBrush( COLOR_SHADOW);
		OldBrush = dc->SelectObject( &ConBrush);
		dc->PatBlt( Rt.left, Rt.bottom, Rt.Width(), 1, PATCOPY);
		dc->PatBlt( Rt.right, Rt.top, 1, Rt.Height()+1, PATCOPY);
		dc->SelectObject( OldBrush);
		ConBrush.DeleteObject();

		if( FocusFlag){
			CBrush	fBrush;
			CPen 	fPen, *OldPen;

			fBrush.CreateStockObject( NULL_BRUSH);
			fPen.CreatePen( PS_SOLID, 1, COLOR_FACE);
			OldBrush = dc->SelectObject( &fBrush);
			OldPen   = dc->SelectObject( &fPen);
			dc->Rectangle( &rect);
			dc->SelectObject( OldBrush);
			dc->SelectObject( OldPen);
			fBrush.DeleteObject();
			fPen.DeleteObject();
		}
	}else{
		ConBrush.CreateSolidBrush( COLOR_SHADOW);
		OldBrush = dc->SelectObject( &ConBrush);
		dc->PatBlt( Rt.left, Rt.top, Rt.Width(), 1, PATCOPY);
		dc->PatBlt( Rt.left, Rt.top, 1, Rt.Height(), PATCOPY);
		dc->SelectObject( OldBrush);
		ConBrush.DeleteObject();

		ConBrush.CreateSolidBrush( COLOR_HLIGHT);
		OldBrush = dc->SelectObject( &ConBrush);
		dc->PatBlt( Rt.left, Rt.bottom, Rt.Width(), 1, PATCOPY);
		dc->PatBlt( Rt.right, Rt.top, 1, Rt.Height()+1, PATCOPY);
		dc->SelectObject( OldBrush);
		ConBrush.DeleteObject();

		if( FocusFlag){
			CBrush	fBrush;
			CPen 	fPen, *OldPen;

			fBrush.CreateStockObject( NULL_BRUSH);
			fPen.CreatePen( PS_SOLID, 1, COLOR_SHADOW);
			OldBrush = dc->SelectObject( &fBrush);
			OldPen   = dc->SelectObject( &fPen);
			dc->Rectangle( &rect);
			dc->SelectObject( OldBrush);
			dc->SelectObject( OldPen);
			fBrush.DeleteObject();
			fPen.DeleteObject();
		}
	}
}
/****************************************/
/*					*/
/*	MESSAGE	"WM_KEYDOWN"		*/
/*					*/
/****************************************/
void
CRefrList::OnKeyDown(
UINT 	nChar,
UINT 	nRepCnt,
UINT 	nFlags)
{
	int	sPos;
	int	ePos;

	if( nChar == VK_UP   || nChar == VK_DOWN ||
	    nChar == VK_LEFT || nChar == VK_RIGHT){
		sPos = GetBarPosition( ViewStart);
		ePos = GetBarPosition( SelectCode);
		if( ePos - sPos >= NUM_LINE || ePos < sPos){
			ViewStart = SelectCode & 0xfff0;
			ScrlBarPos = (short)GetBarPosition( ViewStart);
			this->Invalidate(FALSE);
			this->UpdateWindow();
		}

	    	switch( nChar){
		case VK_UP:
			if( SelectCode - NUM_CHAR < StartCode)
				break;
			if( SelectCode - NUM_CHAR < ViewStart){
				this->SendMessage(WM_VSCROLL, SB_LINEUP, 0);
			}
			SearchKeyPosition(FALSE);
			SelectCode = GetMinusCodeKey( SelectCode, NUM_CHAR);
			SearchKeyPosition(FALSE);
			break;
		case VK_DOWN:

			if( SelectCode + NUM_CHAR > EndCode)
				break;
			if( ePos - sPos >= NUM_LINE - 1){
				this->SendMessage(WM_VSCROLL, SB_LINEDOWN, 0);
			}
			SearchKeyPosition(FALSE);
			SelectCode = GetPlusCodeKey( SelectCode, NUM_CHAR);
			SearchKeyPosition(FALSE);
			break;
		case VK_LEFT:
			if( SelectCode - 1 < StartCode)
				break;
			if( SelectCode - 1 < ViewStart){
				this->SendMessage(WM_VSCROLL, SB_LINEUP, 0);
			}
			SearchKeyPosition(FALSE);
			SelectCode = GetMinusCodeKey( SelectCode, 1);
			SearchKeyPosition(FALSE);
			break;
		case VK_RIGHT:
			WORD 	TmpCode;
			int	TmpPos;

			if( SelectCode + 1 > EndCode)
				break;
			TmpCode = GetPlusCodeKey( SelectCode, 1);
			sPos = GetBarPosition( ViewStart);
			ePos = GetBarPosition( SelectCode);
			TmpPos = GetBarPosition( TmpCode);
			if( TmpPos - sPos >= NUM_LINE){
				this->SendMessage(WM_VSCROLL, SB_LINEDOWN, 0);
			}
			SearchKeyPosition(FALSE);
			SelectCode = GetPlusCodeKey( SelectCode, 1);
			SearchKeyPosition(FALSE);
			break;
		}

	}else 	CEdit::OnKeyDown(nChar, nRepCnt, nFlags);
}

/****************************************/
/*					*/
/*	Search focus position		*/
/*					*/
/****************************************/
void
CRefrList::SearchKeyPosition(
BOOL	Flg)
{
	CRect	test;
	int	sViewPt, sCodePt;
	int	sType, eType;
unsigned int	i, j;

	sViewPt = GetBarPosition( ViewStart);
	sCodePt = GetBarPosition( SelectCode);
	if(( sViewPt > sCodePt || abs( sCodePt - sViewPt) >= NUM_LINE) && Flg){
		this->Invalidate( FALSE);
		return;
	}
	i = (unsigned int)(sCodePt - sViewPt);
	j = (unsigned int)(SelectCode & 0x000f);
/*
	sType = CheckCharType( ViewStart);
	eType = CheckCharType( SelectCode);
	if( sType != eType && sType != CHAR_SBCS)
		i++;
*/
	test.SetRect( rcReferChar[i][j].left - 2,
		      rcReferChar[i][j].top - 2,
		      rcReferChar[i][j].right + 2,
		      rcReferChar[i][j].bottom + 2);
	this->InvalidateRect( &test, FALSE);
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_SETFOCUS"		*/
/*					*/
/****************************************/
void
CRefrList::OnSetFocus(
CWnd* 	pOldWnd)
{
	CEdit::OnSetFocus(pOldWnd);
	this->HideCaret();
	FocusFlag = TRUE;
	SearchKeyPosition(TRUE);
	this->UpdateWindow();
}

/****************************************/
/*					*/
/*	SearchCode			*/
/*					*/
/****************************************/
BOOL
CRefrList::IsCorrectChar(
UINT 	i,
UINT 	j)
{
	int	sViewPt, CharType;
	WORD	wCode;
	WORD	sOffset;
	BOOL	flg;

	flg = FALSE;
	BottomCode = (WORD)GetBarPosition((WORD)ViewEnd);
	sViewPt = GetBarPosition( ViewStart);
	wCode = GetCodeScrPos( sViewPt + i);
	wCode |= j;	

/*
	CharType = CheckCharType( wCode);	
	sOffset = wCode & 0x00ff;
	if( CharType == CHAR_SBCS){
		if( sOffset >= LoByteRange[0][CHN] &&
		    sOffset <= LoByteRange[0][CHN+1])
		    	flg = TRUE;
	}else{
		if(( sOffset >= LoByteRange[1][CHN] &&
		     sOffset <= LoByteRange[1][CHN+1]) ||
		   ( sOffset >= LoByteRange[2][CHN] &&
		     sOffset <= LoByteRange[2][CHN+1]) ||
		   ( sOffset >= LoByteRange[3][CHN] &&
		     sOffset <= LoByteRange[3][CHN+1]))
		     	flg = TRUE;
	}

	return flg;
*/
	return TRUE;
}

/****************************************/
/*					*/
/*	Increase key focus		*/
/*					*/
/****************************************/
WORD
CRefrList::GetPlusCodeKey(
WORD 	Code,
int 	ScrollNum)
{
  /*
	WORD	PrevCode;
	WORD 	LowByte, HighByte;
	WORD	LLByte;
	int	CharType;
	int	CharType1, CharType2;
	int	Offset;
  */
	Code += (WORD)ScrollNum;
	/*
  PrevCode = (WORD)(Code - (WORD)ScrollNum);
	CharType1 = CheckCharType( PrevCode);
	CharType2 = CheckCharType( Code);
	if( CharType1 != CharType2){
		if( CharType1 == CHAR_EUDC)
			Code = PrevCode;		
		else{
			Offset = Code - HiByteRange[CharType1][CHN+1];
			Code = (WORD)( HiByteRange[CharType1+1][CHN] +Offset-1);
		}
	}
	CharType = CheckCharType( Code);
	if( CharType != CHAR_SBCS){
		LowByte  = Code & 0x00ff;
		HighByte = Code & 0xff00;
		LLByte	 = Code & 0x000f;
		if( LowByte <= LoByteRange[4][CHN+1] &&
		    LowByte >= LoByteRange[4][CHN] ){
			LowByte = 0x0040 + LLByte;
		}
		Code = ( HighByte | LowByte);
	}*/
	return Code;
}
					
/****************************************/
/*					*/
/*	Decrease focus key		*/
/*					*/
/****************************************/
WORD
CRefrList::GetMinusCodeKey(
WORD 	Code,
int 	ScrollNum)
{
  /*
	WORD	PrevCode;
	WORD	LLByte;
	int	CharType;
	int	CharType1, CharType2;
	int	Offset;
  */
	Code -= (WORD)ScrollNum;
  /*
	PrevCode = (WORD)( Code + (WORD)ScrollNum);
	CharType1 = CheckCharType( Code);
	CharType2 = CheckCharType( PrevCode);
	if( CharType1 != CharType2){
	 	if( CharType2 == CHAR_SBCS)
			return (WORD)HiByteRange[CHAR_SBCS][CHN];
		else{
			Offset = HiByteRange[CharType2][CHN] - Code;
			return (WORD)(HiByteRange[CharType2-1][CHN+1]-Offset+1);
		}	
	}
	CharType = CheckCharType( Code);
	if( CharType != CHAR_SBCS){
		WORD 	LowByte;
		WORD	HighByte;
		WORD	Tmp;

		LowByte  = Code & 0x00ff;
		HighByte = Code & 0xff00;
		LLByte	 = Code & 0x000f;
		if( LowByte <= LoByteRange[4][CHN+1] &&
		    LowByte >= LoByteRange[4][CHN] ){
			LowByte = 0xf0 + LLByte;
			Tmp = ( HighByte >> 8);
			Tmp -= 0x1;
			HighByte = Tmp << 8;
		}
		Code = ( HighByte | LowByte);
	}*/
	return Code;
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_KILLFOCUS"		*/
/*					*/
/****************************************/
void
CRefrList::OnKillFocus(
CWnd* 	pNewWnd)
{
	CEdit::OnKillFocus(pNewWnd);
	FocusFlag = FALSE;
	SearchKeyPosition(TRUE);
	this->UpdateWindow();
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_RBUTTONUP"		*/
/*					*/
/****************************************/
void
CRefrList::OnRButtonUp(
UINT 	nFlags,
CPoint 	point)
{
	GetParent()->SendMessage( WM_CONTEXTMENU, (WPARAM)this->GetSafeHwnd(), 0);
}

BEGIN_MESSAGE_MAP( CRefListFrame, CStatic)
	//{{AFX_MSG_MAP( CRefListFrame)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CRefListFrame::CRefListFrame()
{
}

/****************************************/
/*					*/
/*		Destructor		*/
/*					*/
/****************************************/
CRefListFrame::~CRefListFrame()
{
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void
CRefListFrame::OnPaint()
{
	CRect	FrameRect;
	CPaintDC	dc( this);

	this->GetClientRect( &FrameRect);
	this->DrawConcave( &dc, FrameRect);
}

/****************************************/
/*					*/
/*	Draw Concave Rect		*/
/*					*/				
/****************************************/
void
CRefListFrame::DrawConcave(
CDC 	*dc,
CRect 	rect)
{
	CBrush	ConBrush, *OldBrush;
	CRect	Rt;

	Rt.SetRect( rect.left-1, rect.top-1, rect.right, rect.bottom);

	ConBrush.CreateSolidBrush( COLOR_HLIGHT);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.top, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.left, Rt.top, 1, Rt.Height(), PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();

	ConBrush.CreateSolidBrush( COLOR_SHADOW);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.bottom, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.right, Rt.top, 1, Rt.Height()+1, PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();
}

BEGIN_MESSAGE_MAP( CRefInfoFrame, CStatic)
	//{{AFX_MSG_MAP( CRefInfoFrame)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CRefInfoFrame::CRefInfoFrame()
{
}

/****************************************/
/*					*/
/*	Destructor			*/
/*					*/
/****************************************/
CRefInfoFrame::~CRefInfoFrame()
{
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_PAINT"		*/
/*					*/
/****************************************/
void
CRefInfoFrame::OnPaint()
{
	CRect	FrameRect;
	CPaintDC	dc( this);

	this->GetClientRect( &FrameRect);
	this->DrawConcave( &dc, FrameRect);
}

/****************************************/
/*					*/
/*	Draw Concave Rect		*/
/*					*/
/****************************************/
void
CRefInfoFrame::DrawConcave(
CDC 	*dc,
CRect 	rect)
{
	CBrush	ConBrush, *OldBrush;
	CRect	Rt;

	Rt.SetRect( rect.left-1, rect.top-1, rect.right, rect.bottom);

	ConBrush.CreateSolidBrush( COLOR_SHADOW);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.top, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.left, Rt.top, 1, Rt.Height(), PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();

	ConBrush.CreateSolidBrush( COLOR_HLIGHT);
	OldBrush = dc->SelectObject( &ConBrush);
	dc->PatBlt( Rt.left, Rt.bottom, Rt.Width(), 1, PATCOPY);
	dc->PatBlt( Rt.right, Rt.top, 1, Rt.Height()+1, PATCOPY);
	dc->SelectObject( OldBrush);
	ConBrush.DeleteObject();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\memop.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#include "common.h"

extern void FAR *memory_alloc(unsigned int bytes);
extern void memory_free(void FAR *p);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\refrlist.h ===
/**************************************************/
/*						                          */
/*	Character List (Referrence Dialog)	          */		
/*						                          */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

class CRefListFrame :public CStatic
{
//	member function
public:
	CRefListFrame();
	~CRefListFrame();

private:
	void DrawConcave( CDC *dc, CRect rect);

protected:

	//{{AFX_MSG(CRefListFrame)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CRefInfoFrame :public CStatic
{
//	member function
public:
	CRefInfoFrame();
	~CRefInfoFrame();

private:
	void DrawConcave( CDC *dc, CRect rect);

protected:

	//{{AFX_MSG(CRefInfoFrame)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CRefrList : public CEdit
{
	DECLARE_DYNCREATE( CRefrList)

//	Member function
public:
	CRefrList();
	~CRefrList();

public:
	BOOL	CodeButtonClicked();
	void	SetCodeRange();
	void	ResetParam();
	void 	CalcCharSize();

private:
	int	CheckCharType( WORD Code);
	int	GetBarPosition( WORD Code);
	WORD 	CalculateCode( WORD Start, WORD End);
	WORD 	GetPlusCode( WORD Code, int ScrollNum);
	WORD 	GetMinusCode( WORD Code, int ScrollNum);
	WORD 	GetPlusCodeKey( WORD Code, int ScrollNum);
	WORD 	GetMinusCodeKey( WORD Code, int ScrollNum);
	WORD 	GetCodeScrPos( int Pos);
	BOOL 	IsCheckedCode( WORD CodeStock);
	BOOL	IsCorrectChar( UINT i, UINT j);
	void 	SearchKeyPosition( BOOL Flg);
	void 	DrawConcave( CDC *dc, CRect rect, BOOL PtIn);

//	Member parameter
public:
	CPoint	LButtonPt;
	WORD 	ViewStart;
	WORD	ViewEnd;
	WORD	SelectCode;
	short	ScrlBarPos;
	CFont	SysFFont;
	CFont	CharFont;
	CFont	ViewFont;
	CSize 	CharSize;
	int	PointSize;
	LOGFONT	rLogFont;
	LOGFONT	cLogFont;
	DWORD   dwCodePage;

private:
	CRect	CodeListRect;
	CPoint	WritePos;
	CSize 	FixSize;
	WORD	StartCode;
	WORD	EndCode;
	WORD	BottomCode;
	int	xSpace;
	int	ySpace;
	int	CHN;
	BOOL	FocusFlag;

protected:
	//{{AFX_MSG(CRefrList)
	afx_msg void OnPaint();
	afx_msg void OnVScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\mainfrm.h ===
/**************************************************/
/*						                          */
/*						                          */
/*	MDI mainframe window class		              */
/*						                          */
/*						                          */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include	"guidebar.h"

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();
	BOOL 	Create( LPCTSTR WndTitle, DWORD WndStyle, RECT MainWndRect, LPCTSTR nID);
	BOOL 	OpenReferWindow();
	BOOL	OutputSaveMessage();
	BOOL	CustomActivate();
	CGuideBar	m_wndGuideBar;

private:
	WORD	CorrectCode( WORD Code, BOOL UporDown);	
	UINT	SetReffCode( BOOL EditorRefer);

private:
	BOOL 	CustomWndOpen;
	BOOL 	RefferWndVisible;
	BOOL	ToolBarVisible;
	BOOL 	GuideBarVisible;
	CRect	EudcWndRect;
	CRect	ReffWndRect;

protected:
	CToolBar	m_wndToolBar;

public:
	virtual ~CMainFrame();

protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext *pContext);

#ifdef _DEBUG
	virtual	void AssertValid() const;
	virtual	void Dump(CDumpContext& dc) const;
#endif

private:
	BOOL CreateToolBar();
	BOOL CreateGuideBar();
	BOOL CreateReferWnd();
	void SetEudcWndPos();
	void SetReffWndPos();
	void CalcEudcWndRect();
	void CalcReffWndRect();

protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnStylesBar(UINT nID);
	afx_msg void OnUpdateStylesBar(CCmdUI* pCmdUI);
	afx_msg void OnUpdateToolbar(CCmdUI* pCmdUI);
	afx_msg void OnDestroy();
	afx_msg void OnRefferfileNew();
	afx_msg void OnReadChar();
	afx_msg void OnUpdateRefferfileNew(CCmdUI* pCmdUI);
	afx_msg void OnToolbar();
	afx_msg void OnRefferClose();
	afx_msg void OnUpdateRefferClose(CCmdUI* pCmdUI);
	afx_msg void OnClose();
	afx_msg void OnShowGrid();
	afx_msg void OnUpdateShowGrid(CCmdUI* pCmdUI);
	afx_msg void OnSelectfamily();
	afx_msg void OnSavechar();
	afx_msg void OnUpdateSavechar(CCmdUI* pCmdUI);
	afx_msg void OnSaveCharas();
	afx_msg void OnUpdateSaveCharas(CCmdUI* pCmdUI);
	afx_msg void OnLinkime();
	afx_msg void OnInitMenu(CMenu* pMenu);
	afx_msg void OnUpdateReadChar(CCmdUI* pCmdUI);
	afx_msg void OnUpdateLinkime(CCmdUI* pCmdUI);
	afx_msg void OnNextcode();
	afx_msg void OnUpdateNextcode(CCmdUI* pCmdUI);
	afx_msg void OnPrevcode();
	afx_msg void OnUpdatePrevcode(CCmdUI* pCmdUI);
	afx_msg void OnCallChar();
	afx_msg void OnUpdateCallChar(CCmdUI* pCmdUI);
	afx_msg void OnImportFile();
	afx_msg void OnUpdateImportFile(CCmdUI* pCmdUI);
	afx_msg void OnLinkbatchmode();
	afx_msg void OnUpdateLinkbatchmode(CCmdUI* pCmdUI);
	afx_msg void OnHelp();
	afx_msg void OnFitCurve();
	afx_msg void OnUpdateFitCurve(CCmdUI* pCmdUI);
	afx_msg void OnRotate();
	afx_msg void OnUpdateRotate(CCmdUI* pCmdUI);
	afx_msg void OnPalettebrush();
	afx_msg void OnUpdatePalettebrush(CCmdUI* pCmdUI);
	afx_msg void OnPalettecircle();
	afx_msg void OnUpdatePalettecircle(CCmdUI* pCmdUI);
	afx_msg void OnPalettecirclefill();
	afx_msg void OnUpdatePalettecirclefill(CCmdUI* pCmdUI);
	afx_msg void OnPalettefreeform();
	afx_msg void OnUpdatePalettefreeform(CCmdUI* pCmdUI);
	afx_msg void OnPalettepen();
	afx_msg void OnUpdatePalettepen(CCmdUI* pCmdUI);
	afx_msg void OnPaletterect();
	afx_msg void OnUpdatePaletterect(CCmdUI* pCmdUI);
	afx_msg void OnPaletterectband();
	afx_msg void OnUpdatePaletterectband(CCmdUI* pCmdUI);
	afx_msg void OnPaletterectfill();
	afx_msg void OnUpdatePaletterectfill(CCmdUI* pCmdUI);
	afx_msg void OnPaletteeraser();
	afx_msg void OnUpdatePaletteeraser(CCmdUI* pCmdUI);
	afx_msg void OnPaletteslope();
	afx_msg void OnUpdatePaletteslope(CCmdUI* pCmdUI);
	afx_msg void OnSelectCharSet();

	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\refrdlg.h ===
/**************************************************/
/*					                              */
/*					                              */
/*	Reference other characters	                  */
/*		(Dialog)		                          */
/*					                              */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include "refrlist.h"
#include "eudclist.h"

class CRefrDlg : public CDialog
{

public:
	CRefrDlg(CWnd* pParent = NULL);

	//{{AFX_DATA(CRefrDlg)
	enum { IDD = IDD_REFERENCE };
	//}}AFX_DATA

private:
	void 	SetViewFont();
	void 	JumpReferCode();
	void 	AdjustFontName();

private:
	int	vHeight;
	TCHAR	FocusCode[5];
	TCHAR	FocusChar[3];
	TCHAR	FontName[LF_FACESIZE];
	CRefListFrame	m_RefListFrame1;
	CRefInfoFrame	m_RefInfoFrame;
	CColumnHeading	m_ColumnHeadingR;
	CEdit       m_EditChar;

public:
	CRefrList	m_CodeList;

protected:
	virtual BOOL OnInitDialog();
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	//{{AFX_MSG(CRefrDlg)
	afx_msg void OnClickedButtomfont();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnChangeEditcode();
	afx_msg void OnSetfocusEditcode();
	afx_msg void OnKillfocusEditcode();
	afx_msg void OnSetfocusEditchar();
	afx_msg void OnKillfocusEditchar();
	afx_msg void OnChangeEditchar();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\refrdlg.cpp ===
/**************************************************/
/*					                              */
/*					                              */
/*	Reference other characters	                  */
/*		(Dialog)		                          */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"refrdlg.h"
#include	"util.h"
#define STRSAFE_LIB
#include <strsafe.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BOOL	CodeFocus;
BOOL	CharFocus;
BOOL	CompFinalized;
CHOOSEFONT	chf;
extern 	LOGFONT	ReffLogFont;
extern 	LOGFONT	EditLogFont;
extern 	BOOL	TitleFlag;
static 	BOOL 	CALLBACK ComDlg32DlgProc(HWND hDlg, UINT uMsg,
		WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK EditCharProc( HWND  hwnd, UINT  uMsg,
                                     WPARAM wParam, LPARAM  lParam);
HIMC hImcCode = NULL;

BEGIN_MESSAGE_MAP(CRefrDlg, CDialog)
	//{{AFX_MSG_MAP(CRefrDlg)
	ON_BN_CLICKED(IDC_BUTTOMFONT, OnClickedButtomfont)
	ON_EN_CHANGE(IDC_EDITCODE, OnChangeEditcode)
	ON_EN_SETFOCUS(IDC_EDITCODE, OnSetfocusEditcode)
	ON_EN_KILLFOCUS(IDC_EDITCODE, OnKillfocusEditcode)
	ON_EN_SETFOCUS(IDC_EDITCHAR, OnSetfocusEditchar)
	ON_EN_KILLFOCUS(IDC_EDITCHAR, OnKillfocusEditchar)
	ON_EN_CHANGE(IDC_EDITCHAR, OnChangeEditchar)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


LRESULT CALLBACK EditCharProc( HWND  hwnd, UINT  uMsg,
                               WPARAM wParam, LPARAM  lParam)
{
    switch (uMsg)
    {
        case WM_CHAR:
        {
        	//
	        // We always delete whatever in edit window before
	        // proceeding to avoid multiple characters in the
	        // window
	        //
		SetWindowText(hwnd, TEXT(""));
        	CompFinalized = TRUE;
            break;
        }
        case WM_IME_COMPOSITION:
        {
            if (lParam & CS_INSERTCHAR)
            {
                // This is KOR ime only.  We want to clear the edit
                // window when the first and only the first composition
                // char is entered.
                //

                if (CompFinalized)
                {
                    SetWindowText(hwnd, TEXT(""));
                }
        	    CompFinalized = FALSE;
            }
            break;
        }

	}

	return(AfxWndProc(hwnd, uMsg, wParam, lParam));
}

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CRefrDlg::CRefrDlg( CWnd* pParent)
	: CDialog(CRefrDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRefrDlg)
	//}}AFX_DATA_INIT
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_INITDIALOG"		*/
/*					*/
/****************************************/
BOOL
CRefrDlg::OnInitDialog()
{
	CString	DialogTitle;
	LOGFONT	LogFont;
	CWnd	*ViewWnd;
	CRect	CharViewRect;
	HWND 	hWndCode;
	HWND    hWndChar;
	HRESULT hresult;

	CDialog::OnInitDialog();

//	Implement "?" in this dialog.
	LONG WindowStyle = GetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE);
	WindowStyle |= WS_EX_CONTEXTHELP;
	SetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE, WindowStyle);

//	Set Dialog title name.
	if( !TitleFlag)
		DialogTitle.LoadString( IDS_REFERENCE_DLGTITLE);
	else	DialogTitle.LoadString( IDS_CALL_DLGTITLE);
	this->SetWindowText( DialogTitle);

//	Subclass Dialog Control Item
	m_CodeList.SubclassDlgItem( ID_REFERCODE, this);
	m_RefListFrame1.SubclassDlgItem( IDC_LISTFRAME1, this);
	m_RefInfoFrame.SubclassDlgItem(  IDC_INFOFRAME, this);
	m_ColumnHeadingR.SubclassDlgItem( IDC_COLUMNHEADINGR, this);
	m_EditChar.SubclassDlgItem( IDC_EDITCHAR, this);
	hWndChar = this->GetDlgItem(IDC_EDITCHAR)->GetSafeHwnd();
	if (GetWindowLongPtr(hWndChar, GWLP_WNDPROC) == (LONG_PTR)AfxWndProc)
	{
		SetWindowLongPtr(hWndChar, GWLP_WNDPROC, (LONG_PTR)EditCharProc);
	}
	hWndCode = GetDlgItem(IDC_EDITCODE)->GetSafeHwnd();
	if (hWndCode && ::IsWindow(hWndCode))
	{
		hImcCode = ImmAssociateContext(hWndCode, NULL);
	}

	GetFont()->GetObject( sizeof(LOGFONT), &LogFont);
	m_CodeList.SysFFont.CreateFontIndirect( &LogFont);
	m_CodeList.CalcCharSize();
	m_CodeList.SendMessage( WM_SETFONT,
		(WPARAM)m_CodeList.SysFFont.GetSafeHandle(),
		MAKELPARAM( TRUE, 0));
	m_ColumnHeadingR.SysFFont.CreateFontIndirect( &LogFont);
	ViewWnd = this->GetDlgItem( IDC_EDITCHAR);
	ViewWnd->GetClientRect( &CharViewRect);
	if( CharViewRect.Width() >= CharViewRect.Height())
		vHeight = CharViewRect.Height() - 10;
	else	vHeight = CharViewRect.Width()  - 10;

	if( !TitleFlag){
		memcpy( &m_CodeList.rLogFont, &ReffLogFont, sizeof( LOGFONT));
		m_CodeList.rLogFont.lfHeight = vHeight;
		m_CodeList.ViewFont.CreateFontIndirect( &m_CodeList.rLogFont);
		
		if( m_CodeList.CharSize.cx >= m_CodeList.CharSize.cy)
			m_CodeList.rLogFont.lfHeight = m_CodeList.CharSize.cy-2;
		else	m_CodeList.rLogFont.lfHeight = m_CodeList.CharSize.cx-2;
		m_CodeList.CharFont.CreateFontIndirect( &m_CodeList.rLogFont);

		//*STRSAFE* 		lstrcpy( (TCHAR *)FontName,(const TCHAR *)m_CodeList.rLogFont.lfFaceName);
		hresult = StringCchCopy((TCHAR *)FontName , ARRAYLEN(FontName), (const TCHAR *)m_CodeList.rLogFont.lfFaceName);
		if (!SUCCEEDED(hresult))
		{
		   return FALSE;
		}
		AdjustFontName();
		this->SetDlgItemText( IDC_EDITFONT, (LPTSTR)FontName);
	}else{
		memcpy( &m_CodeList.cLogFont, &EditLogFont, sizeof( LOGFONT));
		m_CodeList.cLogFont.lfHeight = vHeight;
		m_CodeList.ViewFont.CreateFontIndirect( &m_CodeList.cLogFont);

		if( m_CodeList.CharSize.cx >= m_CodeList.CharSize.cy)
			m_CodeList.cLogFont.lfHeight = m_CodeList.CharSize.cy-2;
		else	m_CodeList.cLogFont.lfHeight = m_CodeList.CharSize.cx-2;
		m_CodeList.CharFont.CreateFontIndirect( &m_CodeList.cLogFont);

		//*STRSAFE* 		lstrcpy( (TCHAR *)FontName,(const TCHAR *)m_CodeList.cLogFont.lfFaceName);
		hresult = StringCchCopy((TCHAR *)FontName , ARRAYLEN(FontName), (const TCHAR *)m_CodeList.cLogFont.lfFaceName);
		if (!SUCCEEDED(hresult))
		{
		   return FALSE;
		}
		AdjustFontName();
		this->SetDlgItemText( IDC_EDITFONT, (LPTSTR)FontName);
	}
	m_CodeList.SetCodeRange();
	SetViewFont();
	m_CodeList.EnableScrollBar(SB_VERT, ESB_ENABLE_BOTH);
	m_CodeList.Invalidate( FALSE);
	m_CodeList.UpdateWindow();

	CodeFocus = FALSE;
	CharFocus = FALSE;
	CompFinalized=TRUE;
	this->SendDlgItemMessage(IDC_EDITCODE, EM_LIMITTEXT,
		(WPARAM)4, (LPARAM)0);
	this->SendDlgItemMessage(IDC_EDITCHAR, EM_LIMITTEXT,
		(WPARAM)1, (LPARAM)0);

	return TRUE;
}
void
CRefrDlg::OnDestroy()
{
	if (hImcCode)
	{
		HWND 	hWndCode;
		hWndCode = GetDlgItem(IDC_EDITCODE)->GetSafeHwnd();
		if (hWndCode && ::IsWindow(hWndCode))
		{
			ImmAssociateContext(hWndCode, hImcCode);
			hImcCode = NULL;
		}
	}
}

/****************************************/
/*					*/
/*	Set font on ViewEdit		*/
/*					*/
/****************************************/
void
CRefrDlg::SetViewFont()
{
	HWND	hWnd;

	hWnd = ::GetDlgItem( this->GetSafeHwnd(), IDC_EDITCHAR);
	::SendMessage( hWnd, WM_SETFONT,
		(WPARAM)m_CodeList.ViewFont.m_hObject, MAKELPARAM(TRUE,0));
}

/****************************************/
/*					*/
/*	COMMAND	"FONT"			*/
/*					*/
/****************************************/
void
CRefrDlg::OnClickedButtomfont()
{
	HDC hDC;
	HRESULT hresult;

	hDC = ::GetDC( this->GetSafeHwnd());
	chf.hDC = ::CreateCompatibleDC( hDC);
	::ReleaseDC( this->GetSafeHwnd(), hDC);
	if( !TitleFlag){
		m_CodeList.rLogFont.lfHeight = 40;
		chf.lpLogFont = &m_CodeList.rLogFont;
	}else{
		m_CodeList.cLogFont.lfHeight = 40;
		chf.lpLogFont = &m_CodeList.cLogFont;
	}
	chf.lStructSize = sizeof(CHOOSEFONT);
	chf.hwndOwner = this->GetSafeHwnd();
	chf.rgbColors = GetSysColor(COLOR_WINDOWTEXT); //COLOR_BLACK;
	chf.lCustData = 0;
	chf.hInstance = AfxGetInstanceHandle();
	chf.lpszStyle = (LPTSTR)NULL;
	chf.nFontType = SCREEN_FONTTYPE;
	chf.lpfnHook = (LPCFHOOKPROC)(FARPROC)ComDlg32DlgProc;
	chf.lpTemplateName = (LPTSTR)MAKEINTRESOURCE(FORMATDLGORD31);
	chf.Flags = CF_SCREENFONTS | CF_NOSIMULATIONS | CF_ENABLEHOOK |
     			CF_ENABLETEMPLATE | CF_INITTOLOGFONTSTRUCT;

	if( ChooseFont( &chf ) == FALSE){
		::DeleteDC( chf.hDC);
        	return ;
   	}
	::DeleteDC( chf.hDC);
	m_CodeList.SetCodeRange();
	m_CodeList.ResetParam();
	this->SetDlgItemText( IDC_EDITCODE, TEXT(""));
	this->SetDlgItemText( IDC_EDITCHAR, TEXT(""));

	m_CodeList.CharFont.DeleteObject();
	m_CodeList.ViewFont.DeleteObject();
	if( !TitleFlag){
		//*STRSAFE* 		lstrcpy( (TCHAR *)FontName,(const TCHAR *)m_CodeList.rLogFont.lfFaceName);
		hresult = StringCchCopy((TCHAR *)FontName , ARRAYLEN(FontName), (const TCHAR *)m_CodeList.rLogFont.lfFaceName);
		if (!SUCCEEDED(hresult))
		{
		   return ;
		}
		AdjustFontName();
		this->SetDlgItemText( IDC_EDITFONT, FontName);

		m_CodeList.rLogFont.lfHeight  = vHeight;
		m_CodeList.rLogFont.lfQuality = PROOF_QUALITY;
		m_CodeList.ViewFont.CreateFontIndirect( &m_CodeList.rLogFont);

		if( m_CodeList.CharSize.cx >= m_CodeList.CharSize.cy)
			m_CodeList.rLogFont.lfHeight = m_CodeList.CharSize.cy-2;
		else	m_CodeList.rLogFont.lfHeight = m_CodeList.CharSize.cx-2;
		m_CodeList.CharFont.CreateFontIndirect( &m_CodeList.rLogFont);
	}else{
		//*STRSAFE* 		lstrcpy(FontName,	(const TCHAR *)m_CodeList.cLogFont.lfFaceName);
		hresult = StringCchCopy(FontName , ARRAYLEN(FontName), 	(const TCHAR *)m_CodeList.cLogFont.lfFaceName);
		if (!SUCCEEDED(hresult))
		{
		   return ;
		}
		AdjustFontName();
		this->SetDlgItemText( IDC_EDITFONT, FontName);

		m_CodeList.cLogFont.lfHeight = vHeight;
		m_CodeList.cLogFont.lfQuality = PROOF_QUALITY;
		m_CodeList.ViewFont.CreateFontIndirect( &m_CodeList.cLogFont);

		if( m_CodeList.CharSize.cx >= m_CodeList.CharSize.cy)
			m_CodeList.cLogFont.lfHeight = m_CodeList.CharSize.cy-2;
		else	m_CodeList.cLogFont.lfHeight = m_CodeList.CharSize.cx-2;
		m_CodeList.CharFont.CreateFontIndirect( &m_CodeList.cLogFont);
	}
	SetViewFont();
	m_CodeList.Invalidate( TRUE);
	m_CodeList.UpdateWindow();

	CWnd *cWnd = GetDlgItem( ID_REFERCODE);
	GotoDlgCtrl( cWnd);

   	return;
}

/****************************************/
/*					*/
/*	Adjust Font Name		*/
/*					*/
/****************************************/
void
CRefrDlg::AdjustFontName()
{
CClientDC	dc(this);
	CRect	ViewFontRect;
	CSize	FontNameSize, CharSize;
	int	i;

	CWnd *cWnd = GetDlgItem( IDC_EDITFONT);
	cWnd->GetClientRect( &ViewFontRect);

	GetTextExtentPoint32( dc.GetSafeHdc(), (const TCHAR *)FontName,
		lstrlen((const TCHAR *)FontName), &FontNameSize);

	if( ViewFontRect.Width() <= FontNameSize.cx){
		GetTextExtentPoint32( dc.GetSafeHdc(), TEXT("<<"), 2, &CharSize);
		i = ( ViewFontRect.Width() /CharSize.cx) * 2;
		FontName[i-2] = '.';
		FontName[i-1] = '.';
		FontName[i] = '\0';
	}	
}

/****************************************/
/*					*/
/*	jump Reference code		*/	
/*					*/
/****************************************/
void CRefrDlg::JumpReferCode()
{
	if( !m_CodeList.CodeButtonClicked())
	{
		if (CharFocus && !CompFinalized)
		{
			//
			// We want to cancel ime composition with wParam = 0, lParam
			// contains CS_INSERTCHAR.
			//
			this->SendDlgItemMessage(IDC_EDITCHAR,
                                     WM_IME_COMPOSITION,
                                     0,
                                     CS_INSERTCHAR | CS_NOMOVECARET |
                                     GCS_COMPSTR | GCS_COMPATTR);
		}
		OutputMessageBox( this->GetSafeHwnd(),
			IDS_ILLEGALCODE_TITLE,
			IDS_ILLEGALCODE_MSG, TRUE);

	}else{

		if (CharFocus)
		{
		//
		// We don't want to highlight an interim KOR IME composition.
		//
			if (CompFinalized)
			{
				this->SendDlgItemMessage(IDC_EDITCHAR, EM_SETSEL, 0, -1);
			}
		}
		else
		{
			this->SendDlgItemMessage(IDC_EDITCODE, EM_SETSEL, 0, -1);
		}
	}
}

/****************************************/
/*					*/
/*	COMMAND "IDOK"			*/
/*					*/
/****************************************/
void
CRefrDlg::OnOK()
{
	if( !m_CodeList.SelectCode){
		OutputMessageBox( this->GetSafeHwnd(),
			IDS_REFERENCE_DLGTITLE,
			IDS_NOTSELCHARACTER_MSG, TRUE);
		return;
	}
	if( !TitleFlag){
		memcpy( &ReffLogFont, &m_CodeList.rLogFont, sizeof( LOGFONT));
	}else{
		memcpy( &EditLogFont, &m_CodeList.cLogFont, sizeof( LOGFONT));
	}
	CDialog::OnOK();
}

/****************************************/
/*					*/
/*	COMMAND "IDCANCEL"		*/
/*					*/
/****************************************/
void
CRefrDlg::OnCancel()
{
 	m_CodeList.SelectCode = 0;		

	CDialog::OnCancel();
}

/****************************************/
/*					*/
/*	MESSAGE "EM_CHANGE"		*/
/*					*/
/****************************************/
void CRefrDlg::OnChangeEditcode()
{
	TCHAR	EditCode[5];
	int i;

	EditCode[0] = '\0';
	this->GetDlgItemText(IDC_EDITCODE, EditCode, sizeof(EditCode)/sizeof(TCHAR));
	
	for (i=0; i<lstrlen(EditCode); i++)
	{
		if ( EditCode[i] <  TEXT('0') ||
		     (EditCode[i] > TEXT('9') && EditCode[i] < TEXT('A')) ||
		     (EditCode[i] > TEXT('F') && EditCode[i] < TEXT('a')) ||
		     EditCode[i] > TEXT('f'))
		{
			OutputMessageBox( this->GetSafeHwnd(),
								IDS_ILLEGALCODE_TITLE,
								IDS_ILLEGALCODE_MSG, TRUE);
			this->SendDlgItemMessage(IDC_EDITCODE, EM_SETSEL, 0, -1);
			return;
		}
	}
		
	if( lstrlen( EditCode) == 4 && CodeFocus)
	{
		JumpReferCode();
	}
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_SETFOCUS"		*/
/*					*/
/****************************************/
void
CRefrDlg::OnSetfocusEditcode()
{
	this->SendDlgItemMessage(IDC_EDITCODE, EM_SETSEL, 0, -1);
	CodeFocus = TRUE;
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_KILLFOCUS"		*/
/*					*/
/****************************************/
void
CRefrDlg::OnKillfocusEditcode()
{
	CodeFocus = FALSE;
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_SETFOCUS"		*/
/*					*/
/****************************************/
void
CRefrDlg::OnSetfocusEditchar()
{
	if (CompFinalized)
	{
	    this->SendDlgItemMessage( IDC_EDITCHAR, EM_SETSEL, 0, -1);
	}
	CharFocus = TRUE;
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_KILLFOCUS"		*/
/*					*/
/****************************************/
void
CRefrDlg::OnKillfocusEditchar()
{
	CharFocus = FALSE;
}

/****************************************/
/*					*/
/*	MESSAGE	"EM_CHANGE"		*/
/*					*/
/****************************************/
void
CRefrDlg::OnChangeEditchar()
{
	WCHAR	EditChar[5] = {0};

	EditChar[0]=TEXT('\0');
#ifdef UNICODE
  ::GetDlgItemTextW(this->GetSafeHwnd(),IDC_EDITCHAR, (LPWSTR)EditChar, sizeof(EditChar)/sizeof(WCHAR));
#else
  CHAR eChar[5];
  int nchar = ::GetDlgItemText(this->GetSafeHwnd(),IDC_EDITCHAR, (LPSTR)eChar, sizeof(eChar));
  MultiByteToWideChar(CP_ACP, 0, eChar, nchar, EditChar, sizeof(EditChar)/sizeof(EditChar[0]));
#endif

	if( CharFocus && EditChar[0] != TEXT('\0') )
	{
		int iPos = 1;
/*
#ifndef UNICODE
		if (IsDBCSLeadByte(EditChar[0]))
		{
			iPos = 2;
		}
#endif
*/
		EditChar[iPos]=TEXT('\0');
		JumpReferCode();
	}
}

/****************************************/
/*					*/
/*	Callback function		*/
/*					*/
/****************************************/
static BOOL CALLBACK
ComDlg32DlgProc(
HWND 	hDlg,
UINT 	uMsg,
WPARAM 	wParam,
LPARAM 	lParam)
{
	switch (uMsg)
	{
		case WM_INITDIALOG:
 			long	WindowStyle;

			WindowStyle = GetWindowLong( hDlg, GWL_EXSTYLE);
			WindowStyle |= WS_EX_CONTEXTHELP;
			SetWindowLong( hDlg, GWL_EXSTYLE, WindowStyle);
			break;

		default:
			return FALSE;
	}
	return TRUE;
}

static DWORD aIds[] =
{
	ID_REFERCODE,	IDH_EUDC_REFLIST,
	IDC_COLUMNHEADINGR,	IDH_EUDC_REFLIST,
	IDC_STATICC,	IDH_EUDC_REFCODE,
	IDC_EDITCODE,	IDH_EUDC_REFCODE,
	IDC_STATICS,	IDH_EUDC_REFCHAR,
	IDC_EDITCHAR, 	IDH_EUDC_REFCHAR,
	IDC_STATICF,	IDH_EUDC_REFFONT,
	IDC_EDITFONT,	IDH_EUDC_REFFONT,
	IDC_INFOFRAME,	IDH_EUDC_REFFONT,
	IDC_BUTTOMFONT,	IDH_EUDC_FONT,
//	IDOK, IDH_EUDC_OK,
//	IDCANCEL, IDH_EUDC_CANCEL,
	0,0
};

static DWORD aIdsCall[] =
{
	ID_REFERCODE,	IDH_EUDC_CALLLIST,
	IDC_COLUMNHEADINGR,	IDH_EUDC_CALLLIST,
	IDC_STATICC,	IDH_EUDC_CALLCODE,
	IDC_EDITCODE,	IDH_EUDC_CALLCODE,
	IDC_STATICS,	IDH_EUDC_CALLCHAR,
	IDC_EDITCHAR, 	IDH_EUDC_CALLCHAR,
	IDC_STATICF,	IDH_EUDC_CALLFONT,
	IDC_EDITFONT,	IDH_EUDC_CALLFONT,
	IDC_INFOFRAME,	IDH_EUDC_CALLFONT,
	IDC_BUTTOMFONT,	IDH_EUDC_FONT,
//	IDOK, IDH_EUDC_OK,
//	IDCANCEL, IDH_EUDC_CANCEL,
	0,0
};

/****************************************/
/*					*/
/*	Window procedure		*/
/*					*/
/****************************************/
LRESULT
CRefrDlg::WindowProc(
UINT 	message,
WPARAM 	wParam,
LPARAM 	lParam)
{
	if( message == WM_HELP){
		::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
			HelpPath, HELP_WM_HELP, (DWORD_PTR)(LPTSTR)(TitleFlag ? aIdsCall:aIds));
		return(0);
	}
	if( message == WM_CONTEXTMENU){
		::WinHelp((HWND)wParam, HelpPath,
			HELP_CONTEXTMENU, (DWORD_PTR)(LPTSTR)(TitleFlag ? aIdsCall : aIds));
		return(0);
	}
	return CDialog::WindowProc( message, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\refrwnd.cpp ===
/**************************************************/
/*                                           */
/*                                           */
/* MDI Child Window( Reference)                */
/*                                           */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include    "stdafx.h"
#include    "eudcedit.h"
#include    "refrwnd.h"
#include    "editwnd.h"
#include    "mainfrm.h"

#define     FREELIAIS   1000

LOGFONT     ReffLogFont;
CBitmap     DupBmp;
CRect    DupRect;

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
extern CEditWnd *pEditChild;

CMenu NEAR CRefrWnd::menu;
IMPLEMENT_DYNCREATE(CRefrWnd, CMDIChildWnd)
BEGIN_MESSAGE_MAP(CRefrWnd, CMDIChildWnd)
   //{{AFX_MSG_MAP(CRefrWnd)
   ON_BN_CLICKED( IDB_CLOSE_REF, OnClickClose)
   ON_WM_PAINT()
   ON_WM_CREATE()
   ON_WM_SIZE()
   ON_WM_LBUTTONDOWN()
   ON_WM_LBUTTONUP()
   ON_WM_MOUSEMOVE()
   ON_COMMAND(ID_GAIJI_COPY, OnGaijiCopy)
   ON_UPDATE_COMMAND_UI(ID_GAIJI_COPY, OnUpdateGaijiCopy)
   ON_WM_SETCURSOR()
   ON_WM_MDIACTIVATE()
   ON_WM_KEYDOWN()
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/****************************************/
/*             */
/* Create reference Window    */
/*             */
/****************************************/
BOOL
CRefrWnd::Create(
LPCTSTR  szTitle,
LONG  Style,
RECT  ReffWndRect,
CMDIFrameWnd* Parent)
{
// Set Mainframe menu for reference
   if( menu.m_hMenu == NULL)
      menu.LoadMenu( IDR_MAINFRAME);
   m_hMenuShared = menu.m_hMenu;

// Register WindowClass
   const TCHAR *pszReffWndClass =
      AfxRegisterWndClass( CS_BYTEALIGNCLIENT,
         NULL, (HBRUSH)(COLOR_WINDOW + 1), NULL);

   return CMDIChildWnd::Create( pszReffWndClass,
         szTitle, Style, ReffWndRect, Parent);
}

/****************************************/
/*             */
/* Process before window create  */
/*             */
/****************************************/
int
CRefrWnd::OnCreate(
LPCREATESTRUCT lpCreateStruct)
{
   if( CMDIChildWnd::OnCreate( lpCreateStruct) == -1)
      return -1;
// Check if m_hWnd is mirrored then we need to set the colse button on the other side.
   m_bCloseOnLeft = (BOOL)(GetWindowLongPtr(m_hWnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL);
// Then turn off miroring if any.
   if (m_bCloseOnLeft) {
       ModifyStyleEx( WS_EX_LAYOUTRTL, 0);
   }

   if( !CreateNewBitmap())
      return -1;
   if( !ClipPickValueInit())
      return -1;
   if( !InitSelectLogfont())
      return -1;
   if( !LoadCloseBitmap())
      return -1;

   return 0;
}

/****************************************/
/*             */
/* Create New Bitmap    */
/*             */
/****************************************/
BOOL
CRefrWnd::CreateNewBitmap()
{
   WORD  wSize;
   HANDLE   BmpHdl;
   BYTE  *pBmp;

   CClientDC   dc( this);

   if( !ImageDC.CreateCompatibleDC( &dc))
      return FALSE;

   wSize = (WORD)((( BITMAP_WIDTH +15) /16) *2) *(WORD)BITMAP_HEIGHT;
   if (wSize == 0)
   {
        return (FALSE);
   }
   if(( BmpHdl = LocalAlloc( LMEM_MOVEABLE, wSize)) == 0)
      return FALSE;

   if(( pBmp = (BYTE *)LocalLock( BmpHdl)) == NULL){
      LocalUnlock( BmpHdl);
      LocalFree( BmpHdl);
      return FALSE;
   }
   memset( pBmp, 0xffff, wSize);
   if( !ImageBmp.CreateBitmap( BITMAP_WIDTH, BITMAP_HEIGHT,
       1, 1, (LPSTR)pBmp)){
      LocalUnlock( BmpHdl);
      LocalFree( BmpHdl);
      return FALSE;
   }
   LocalUnlock( BmpHdl);
   LocalFree( BmpHdl);
   ImageDC.SelectObject( &ImageBmp);

   return TRUE;
}

/****************************************/
/*             */
/* Initialize clipboard format   */
/*             */
/****************************************/
BOOL
CRefrWnd::ClipPickValueInit()
{
   if( !( ClipboardFormat = RegisterClipboardFormat(TEXT("EudcEdit"))))
      return FALSE;
   else  return TRUE;
}

/****************************************/
/*             */
/* Initialize selected logfont   */
/*             */
/****************************************/
BOOL
CRefrWnd::InitSelectLogfont()
{
   CFont cFont;

#ifdef BUILD_ON_WINNT
   cFont.CreateStockObject(DEFAULT_GUI_FONT);
#else
   cFont.CreateStockObject( SYSTEM_FONT);
#endif
   cFont.GetObject( sizeof(LOGFONT), &ReffLogFont);
   cFont.DeleteObject();

   return TRUE;
}

/****************************************/
/*             */
/* Load Close Bitmap (to close)  */
/*             */
/****************************************/
BOOL
CRefrWnd::LoadCloseBitmap()
{
   CRect rect;

   this->GetClientRect( &rect);
   rect.top = 2;
   rect.bottom = CAPTION_HEIGHT - 2;
   rect.right -= 2;
   rect.left = rect.right - ( rect.bottom - rect.top) - 5;

   if( !CloseBtm.Create( NULL, WS_CHILD | WS_VISIBLE | BS_OWNERDRAW |
       WS_EX_TOPMOST | BS_PUSHBUTTON, rect, this, IDB_CLOSE_REF) ||
       !CloseBtm.LoadBitmaps( IDB_CLOSEBMP, IDB_CLOSEBMPP))
      return FALSE;
   else{
      CloseBtm.SizeToContent();
      return TRUE;
   }
}

/****************************************/
/*             */
/* Default Constructor     */
/*             */
/****************************************/
CRefrWnd::CRefrWnd()
{
   RectVisible = FALSE;
   IsCapture = FALSE;
   SelectItems = RECTCLIP;
   GridShow = TRUE;
   bFocus = FALSE;
   m_bCloseOnLeft = FALSE;
}

/****************************************/
/*             */
/* Destructor        */
/*             */
/****************************************/
CRefrWnd::~CRefrWnd()
{
   if( ImageBmp.Detach() != NULL)
      ImageBmp.DeleteObject();
   if( ImageDC.Detach() != NULL)
      ImageDC.DeleteDC();
  menu.DestroyMenu();
}

/****************************************/
/*             */
/* MESSAGE "WM_PAINT"      */
/*             */
/****************************************/
void
CRefrWnd::OnPaint()
{
   CString  WndCaption;
   CFont RefferFont;
   BYTE  sWork[10];
   CSize CharSize;
   short    xOffset, yOffset;
   int   Length;

   CPaintDC dc( this);

   this->GetClientRect( &ReffWndRect);

   ZoomRate = ReffWndRect.right /BITMAP_WIDTH;
   ReffLogFont.lfHeight  = BITMAP_HEIGHT; 
   ReffLogFont.lfWidth  = 0;  
   ReffLogFont.lfQuality = PROOF_QUALITY;
   if( !RefferFont.CreateFontIndirect( &ReffLogFont))
      return;
   CFont *OldFont = ImageDC.SelectObject( &RefferFont);

   if( !ReferCode)
      Length = 0;
/*
   else if( !(ReferCode & 0xff00)){
//    SBCS
      sWork[0] = (BYTE)( ReferCode & 0x00ff);
      sWork[1] = (BYTE)'\0';
      Length = 1;
   }else{
//    DBCS
      sWork[0] = (BYTE)(( ReferCode & 0xff00) >> 8);
      sWork[1] = (BYTE)( ReferCode & 0x00ff);
      sWork[2] = (BYTE)'\0';
      Length = 2;
   }
*/
  else
  {
    sWork[0] = LOBYTE(ReferCode);
    sWork[1] = HIBYTE(ReferCode);
    Length = 1;
  }
   if( Length){
      CRect TextImage;

      GetTextExtentPoint32W( ImageDC.GetSafeHdc(), (const unsigned short *)sWork,
         Length, &CharSize);
/*
      GetTextExtentPoint32A( ImageDC.GetSafeHdc(), (LPCSTR)sWork,
         Length, &CharSize);*/
      TextImage.SetRect( 0, 0, BITMAP_WIDTH, BITMAP_HEIGHT);

      if( CharSize.cx < BITMAP_WIDTH)
         xOffset = (short)(( BITMAP_HEIGHT - CharSize.cx) /2);
      else  xOffset = 0;
      if( CharSize.cy < BITMAP_HEIGHT)
         yOffset = (short)(( BITMAP_WIDTH  - CharSize.cy) /2);
      else  yOffset = 0;
/*
      if( ReffLogFont.lfFaceName[0] == '@' && Length == 2)
         xOffset = yOffset = 0;
*/
      if( ReffLogFont.lfFaceName[0] == '@' && Length == 1)
         xOffset = yOffset = 0;
/*
      ExtTextOutA(ImageDC.GetSafeHdc(), xOffset, yOffset, ETO_OPAQUE,
            &TextImage, (LPCSTR)sWork, Length, NULL);
*/
      ExtTextOutW(ImageDC.GetSafeHdc(), xOffset, yOffset, ETO_OPAQUE,
            &TextImage, (const unsigned short *)sWork, Length, NULL);
   }

   dc.StretchBlt( 0, CAPTION_HEIGHT, ReffWndRect.Width(),
         ReffWndRect.Height() - CAPTION_HEIGHT,
         &ImageDC, 0, 0, BITMAP_WIDTH, BITMAP_HEIGHT,SRCCOPY);

   CRect rect;

   rect.CopyRect( &ReffWndRect);
   rect.top = 2;
   rect.bottom = CAPTION_HEIGHT - 2;
   if (m_bCloseOnLeft) {
       rect.left += 2;
       rect.right = rect.left + ( rect.bottom - rect.top) - 2;
   } else {
       rect.right -= 2;
       rect.left = rect.right - ( rect.bottom - rect.top) - 2;
   }
   CloseBtm.SetWindowPos( NULL, rect.left, rect.top,
         0, 0, SWP_NOSIZE );

   CaptionDraw();

   if( RectVisible)
      RubberBandPaint( &dc);
   if( GridShow && ZoomRate >= 2)
      DrawGridLine( &dc);

   ImageDC.SelectObject( OldFont);
   RefferFont.DeleteObject();
   return;
}

/****************************************/
/*             */
/* Draw Caption         */
/*             */
/****************************************/
void
CRefrWnd::CaptionDraw()
{
COLORREF TextColor;
   CString  WndCaption;
   CRect CaptionRect;
   CBrush   CaptionBrush;
   CFont *OldFont;
   int   BkMode;
   CDC    dc;
   dc.Attach( ::GetDC( this->GetSafeHwnd()));


// Get brush with active caption color    
   CaptionRect.CopyRect( &ReffWndRect);
   if (bFocus)
   {
      CaptionBrush.CreateSolidBrush(::GetSysColor( COLOR_ACTIVECAPTION));
   }
   else
   {
      CaptionBrush.CreateSolidBrush(::GetSysColor(COLOR_INACTIVECAPTION));
   }
   CaptionRect.bottom = CAPTION_HEIGHT;
   dc.FillRect( &CaptionRect, &CaptionBrush);
   CaptionBrush.DeleteObject();

// Get font to draw caption
#ifdef BUILD_ON_WINNT
   OldFont = (CFont *)dc.SelectStockObject(DEFAULT_GUI_FONT);
#else
   OldFont = (CFont *)dc.SelectStockObject(SYSTEM_FONT);
#endif
   BkMode = dc.SetBkMode( TRANSPARENT);
   if (bFocus)
   {
      TextColor = dc.SetTextColor( ::GetSysColor(COLOR_CAPTIONTEXT));
   }
   else
   {
      TextColor = dc.SetTextColor( ::GetSysColor(COLOR_INACTIVECAPTIONTEXT));
   }
   WndCaption.LoadString( IDS_REFERENCE_STR);
   dc.TextOut( ReffWndRect.right /2 - 30, 1, WndCaption);
   dc.SelectObject( OldFont);
   dc.SetTextColor( TextColor);
   dc.SetBkMode( BkMode);

   //
   // redraw the close button.
   //
   CloseBtm.Invalidate(FALSE);

   ::ReleaseDC( NULL, dc.Detach());
   return;
}
               
/****************************************/
/*             */
/* Draw Grid         */
/*             */
/****************************************/
void
CRefrWnd::DrawGridLine(
CDC   *dc)
{
   CPen  GlyphPen;
register int   i;
   if (!dc)
   {
      return;
   }

// Create pen to draw grid
   GlyphPen.CreatePen( PS_SOLID, 1, COLOR_GRID);
   CPen *OldPen = dc->SelectObject( &GlyphPen);

// Draw grid
   for( i = ZoomRate - 1; i < ReffWndRect.right; i += ZoomRate){
      dc->MoveTo( i, CAPTION_HEIGHT-1);
      dc->LineTo( i, ReffWndRect.bottom);
   }
   for( i =ZoomRate +CAPTION_HEIGHT -1;i<ReffWndRect.bottom;i += ZoomRate){
      dc->MoveTo( 0, i);
      dc->LineTo( ReffWndRect.right, i);
   }
   dc->SelectObject( OldPen);
   GlyphPen.DeleteObject();
}

/****************************************/
/*             */
/* Draw RubberBand         */
/*             */
/****************************************/
void
CRefrWnd::RubberBandPaint(
CDC   *dc)
{
   CPen  *OldPen;
   CBrush   *OldBrush;
   int   OldMode;

   if (!dc)
   {
      return;
   }

   OldPen = (CPen *)dc->SelectStockObject( BLACK_PEN);
   OldBrush = (CBrush *)dc->SelectStockObject( NULL_BRUSH);
   OldMode = dc->SetROP2( R2_NOTXORPEN);

   dc->Rectangle( &MoveRect);
   dc->SelectObject( OldPen);
   dc->SelectObject( OldBrush);
   dc->SetROP2( OldMode);
}

/****************************************/
/*             */
/* MESSAGE  "WM_LBUTTONDOWN"  */
/*             */
/****************************************/
void
CRefrWnd::OnLButtonDown(
UINT  ,
CPoint   point)
{
   CRect CaptionRect;

   CaptionRect.CopyRect( &ReffWndRect);
   CaptionRect.top = CAPTION_HEIGHT;
   if( !CaptionRect.PtInRect( point))
      return;

   IsCapture = TRUE;
   this->SetCapture();
   CorrectMouseDownPt( point);

   if( RectVisible){
      if( MoveRect.PtInRect( point)){
         RectVisible = FALSE;
         this->InvalidateRect( &MoveRect, FALSE);
         this->UpdateWindow();
         RectVisible = TRUE;
         m_ptMouse.x = point.x - MoveRect.left;
         m_ptMouse.y = point.y - MoveRect.top;
         this->ClientToScreen( &point);
         MoveRectangle( point);
         m_ptLast = point;
         return;
      }else{
         RectVisible = FALSE;
         this->InvalidateRect( &MoveRect, FALSE);
         this->UpdateWindow();
      }
   }
   if( SelectItems == RECTCLIP)
      RubberBand( TRUE);
   else{
      CPoint   Sp;
      
      Sp.x = ptStart.x;
      Sp.y = ptStart.y + CAPTION_HEIGHT;
      m_pointArray.RemoveAll();
      m_selectArray.RemoveAll();
      m_pointArray.Add( Sp);
      Sp.x = ptStart.x /ZoomRate;
      Sp.y = ptStart.y /ZoomRate;
      m_selectArray.Add( Sp);
   }
}

/****************************************/
/*             */
/* MESSAGE  "WM_MOUSEMOVE"       */
/*             */
/****************************************/
void
CRefrWnd::OnMouseMove(
UINT  ,
CPoint   point)
{
   if( IsCapture){
      CorrectMouseUpPt( point);
      if( ptEnd.x == ptPrev.x && ptEnd.y == ptPrev.y)
         return;

      if( RectVisible){
         this->ClientToScreen( &point);
         MoveRectangle( m_ptLast);
         m_ptLast = point;
         MoveRectangle( m_ptLast);
      }else{
         if( SelectItems == RECTCLIP)
            RubberBand( FALSE);
         else{
            DrawFreeForm( FALSE);
            SelectFreeForm( FALSE);
         }
      }
   }
}

/****************************************/
/*             */
/* MESSAGE  "WM_LBUTTONUP"    */
/*             */
/****************************************/
void
CRefrWnd::OnLButtonUp(
UINT  ,
CPoint   point)
{
   CRect WorkRect;
   int   wSize;
   char  *pDupBmp;

   if (!bFocus)
      {
      bFocus = TRUE;
      CaptionDraw();
      pEditChild->bFocus = FALSE;
      pEditChild->CaptionDraw();
   }

   if( IsCapture){
      CorrectMouseUpPt( point);
      if( RectVisible){
         MoveRectangle( m_ptLast);

         WorkRect.CopyRect( &MoveRect);
         WorkRect.left = ptStart.x - MoveRect.left;
         WorkRect.top  = ptStart.y - MoveRect.top+CAPTION_HEIGHT;
         WorkRect.right = MoveRect.Width();
         WorkRect.bottom = MoveRect.Height();
         this->ClientToScreen( &point);
         DupBmp.CreateBitmap( BITMAP_WIDTH, BITMAP_HEIGHT,
            1, 1, NULL);
         wSize = ((( BITMAP_WIDTH +15) /16) *2) *BITMAP_HEIGHT;
         pDupBmp = (char *)malloc( wSize);

         if( SelectItems == FREEFORM){
            CBitmap hStdBitmap;
               CDC   hStdDC;
            CBrush   BlackBrush;

               hStdDC.CreateCompatibleDC( &ImageDC);
               hStdBitmap.CreateCompatibleBitmap( &ImageDC,
                  BITMAP_WIDTH, BITMAP_HEIGHT);
               CBitmap *hOldSObj =
               hStdDC.SelectObject( &hStdBitmap);

               hStdDC.PatBlt( 0, 0, BITMAP_WIDTH,
               BITMAP_HEIGHT, WHITENESS);

            BlackBrush.CreateStockObject( BLACK_BRUSH);
            hStdDC.FillRgn( &PickRgn, &BlackBrush);
            BlackBrush.DeleteObject();
               hStdDC.BitBlt( 0, 0, BITMAP_WIDTH,
               BITMAP_HEIGHT, &ImageDC,0, 0, SRCPAINT);
            hStdBitmap.GetBitmapBits( wSize,
               (LPVOID)pDupBmp);

            hStdDC.SelectObject( &hOldSObj);
            hStdBitmap.DeleteObject();
            hStdDC.DeleteDC();
         }else{
            ImageBmp.GetBitmapBits( wSize, (LPVOID)pDupBmp);
         }
         DupBmp.SetBitmapBits( wSize, (LPVOID)pDupBmp);
         free( pDupBmp);

         DupRect.CopyRect( &MoveRect);
         AfxGetMainWnd()->SendMessage( WM_DUPLICATE,
            (WPARAM)&WorkRect,(LPARAM)&point);
         DupBmp.DeleteObject();

      }else if( SelectItems == RECTCLIP){
         IllegalRect( &ptStart, &ptEnd);
         MoveRect.SetRect( ptStart.x, ptStart.y + CAPTION_HEIGHT,
            ptEnd.x + ZoomRate + 1,
            ptEnd.y + ZoomRate + CAPTION_HEIGHT + 1);

         if( abs( ptEnd.x - ptStart.x) < ZoomRate*2 ||
             abs( ptEnd.y - ptStart.y) < ZoomRate*2){
            this->InvalidateRect( &MoveRect, FALSE);
            this->UpdateWindow();
         }else{
            RectVisible = TRUE;
            this->InvalidateRect( &MoveRect, FALSE);
            this->UpdateWindow();
         }
         PickRect.SetRect(ptStart.x/ZoomRate, ptStart.y/ZoomRate,
            ( ptEnd.x+ZoomRate)/ZoomRate,
            ( ptEnd.y+ZoomRate)/ZoomRate);
      }else{
         CPoint   nArray[FREELIAIS];
         CPoint   pArray[FREELIAIS];

         DrawFreeForm( FALSE);
         SelectFreeForm( FALSE);
         DrawFreeForm( TRUE);
         SelectFreeForm( TRUE);

         if( m_pointArray.GetSize()  >= FREELIAIS ||
             m_selectArray.GetSize() >= FREELIAIS ){
               IsCapture = FALSE;
            ReleaseCapture();
            this->Invalidate( FALSE);
            this->UpdateWindow();
            return;
         }
         for( int i = 0; i < m_pointArray.GetSize(); i++)
            nArray[i] = m_pointArray[i];
         for( int k = 0; k < m_selectArray.GetSize(); k++)
            pArray[k] = m_selectArray[k];

         if( FreeRgn.GetSafeHandle() != NULL)
            FreeRgn.DeleteObject();

         if( PickRgn.GetSafeHandle() != NULL)
            PickRgn.DeleteObject();

         FreeRgn.CreatePolygonRgn( nArray,
            (int)(m_pointArray.GetSize()), ALTERNATE);
         PickRgn.CreatePolygonRgn( pArray,
            (int)(m_selectArray.GetSize()), ALTERNATE);

         if( FreeRgn.GetSafeHandle() == NULL ||
             PickRgn.GetSafeHandle() == NULL ){
            m_pointArray.RemoveAll();
            m_selectArray.RemoveAll();
         }else{
            RectVisible = TRUE;
            FreeRgn.GetRgnBox( &MoveRect);
            PickRgn.GetRgnBox( &PickRect);
            if( PickRect.Width()  < 3 ||
                PickRect.Height() < 3){
                  RectVisible = FALSE;
               FreeRgn.DeleteObject();
               PickRgn.DeleteObject();
            }
            MoveRect.right += 1;
            MoveRect.bottom += 1;
            this->InvalidateRect( &MoveRect);
            this->UpdateWindow();

         }
      }
      IsCapture = FALSE;
   }
   ReleaseCapture();
}

/****************************************/
/*             */
/* Correct Mouse Down Point   */
/*             */
/****************************************/
void
CRefrWnd::CorrectMouseDownPt(
CPoint   point)
{
   CRect WorkRect;

   WorkRect.CopyRect( &ReffWndRect);
   ptStart.x = point.x;
   ptStart.y = point.y - CAPTION_HEIGHT;
   if( ptStart.y < 0)
      ptStart.y = 0;

   if( SelectItems == RECTCLIP){
      ptStart.x = ( ptStart.x /ZoomRate) *ZoomRate;
      ptStart.y = ( ptStart.y /ZoomRate) *ZoomRate;
   }else{
      ptStart.x = (( ptStart.x + ZoomRate/2) /ZoomRate) *ZoomRate;
      ptStart.y = (( ptStart.y + ZoomRate/2) /ZoomRate) *ZoomRate;
   }
   ptEnd = ptPrev = ptStart;
}

/****************************************/
/*             */
/* Correct Mouse Up point     */
/*             */
/****************************************/
void
CRefrWnd::CorrectMouseUpPt(
CPoint   point)
{
   ptPrev = ptEnd;
   ptEnd.x = point.x;
   ptEnd.y = point.y - CAPTION_HEIGHT;
   CRect WorkRect;
   WorkRect.CopyRect( &ReffWndRect);
   if( ptEnd.x < 0)  ptEnd.x = 0;
   if( ptEnd.y < 0)  ptEnd.y = 0;
   if( ptEnd.x > WorkRect.right){
      if( SelectItems == RECTCLIP)
         ptEnd.x = WorkRect.right - ZoomRate;
      else  ptEnd.x = WorkRect.right;     
   }
   if( ptEnd.y > WorkRect.bottom - CAPTION_HEIGHT){
      if( SelectItems == RECTCLIP){
         ptEnd.y = WorkRect.bottom - CAPTION_HEIGHT
            - ZoomRate;
      }else ptEnd.y = WorkRect.bottom - CAPTION_HEIGHT;
   }

   if( SelectItems == RECTCLIP){
      ptEnd.x = ( ptEnd.x /ZoomRate) *ZoomRate;
      ptEnd.y = ( ptEnd.y /ZoomRate) *ZoomRate;
   }else{
      ptEnd.x = (( ptEnd.x + ZoomRate/2) /ZoomRate) *ZoomRate;
      ptEnd.y = (( ptEnd.y + ZoomRate/2) /ZoomRate) *ZoomRate;
   }
   if( SelectItems == RECTCLIP){
      if( ptEnd.x - ptStart.x <= ZoomRate &&
         ptEnd.x - ptStart.x >= 0)
         ptEnd.x = ptStart.x + ZoomRate;
      if( ptStart.x - ptEnd.x <= ZoomRate &&
         ptStart.x - ptEnd.x > 0)
         ptEnd.x = ptStart.x - ZoomRate;
      if( ptStart.y - ptEnd.y <= ZoomRate &&
         ptStart.y - ptEnd.y > 0)
         ptEnd.y = ptStart.y - ZoomRate;
      if( ptEnd.y - ptStart.y <= ZoomRate &&
         ptEnd.y - ptStart.y >= 0)
         ptEnd.y = ptStart.y + ZoomRate;
   }
}

/****************************************/
/*             */
/* Correct Illegal rectangle  */
/*             */
/****************************************/
void
CRefrWnd::IllegalRect(
PPOINT   ptTL,
PPOINT   ptBR)
{
   int   Tmp;

   if( ptTL->x > ptBR->x){
      Tmp = ptTL->x;
      ptTL->x = ptBR->x;
      ptBR->x = Tmp; 
   }
   if( ptTL->y > ptBR->y){
      Tmp = ptTL->y;
      ptTL->y = ptBR->y;
      ptBR->y = Tmp;
   }
}

/****************************************/
/*             */
/* COMMAND  "COPY"         */
/*             */
/****************************************/
void
CRefrWnd::OnGaijiCopy()
{
   ClipImageCopy();
   CMainFrame *pMain = new CMainFrame;
   pMain->CustomActivate();
   delete pMain;
}

/************************************************/
/*                */
/* COMMAND  "COPY" (Update)         */
/*                */
/************************************************/
void
CRefrWnd::OnUpdateGaijiCopy(
CCmdUI   *pCmdUI)
{
   if( RectVisible)
      pCmdUI->Enable(TRUE);
   else  pCmdUI->Enable(FALSE);
}

/****************************************/
/*             */
/* Copy Bitmap data     */
/*             */
/****************************************/
BOOL
CRefrWnd::ClipImageCopy()
{
   CBitmap hStdBitmap;
      CDC hStdDC;

      hStdDC.CreateCompatibleDC( &ImageDC);
      hStdBitmap.CreateCompatibleBitmap( &ImageDC,
               PickRect.Width(), PickRect.Height());
      CBitmap *hOldSObj = hStdDC.SelectObject( &hStdBitmap);

      hStdDC.PatBlt( 0, 0, PickRect.Width(), PickRect.Height(), WHITENESS);
   if( SelectItems == FREEFORM){
      CBrush   BlackBrush;

      BlackBrush.CreateStockObject( BLACK_BRUSH);
      PickRgn.OffsetRgn( 0 - PickRect.left, 0 - PickRect.top);
      hStdDC.FillRgn( &PickRgn, &BlackBrush);
      BlackBrush.DeleteObject();
         hStdDC.BitBlt( 0, 0, PickRect.Width(), PickRect.Height(),
         &ImageDC, PickRect.left, PickRect.top, SRCPAINT);
   }else{
         hStdDC.BitBlt( 0, 0, PickRect.Width(), PickRect.Height(),
         &ImageDC, PickRect.left, PickRect.top, SRCCOPY);
   }     

      if (!this->OpenClipboard()) {
      hStdDC.SelectObject( hOldSObj);
      hStdBitmap.DeleteObject();
            hStdDC.DeleteDC();
            return FALSE;
      }
      EmptyClipboard();

      if( !SetClipboardData( CF_BITMAP, hStdBitmap.Detach())) {
      hStdDC.SelectObject( hOldSObj);
      hStdBitmap.DeleteObject();
            hStdDC.DeleteDC();
            CloseClipboard();
            return FALSE;
      }
      CloseClipboard();
   hStdDC.SelectObject( hOldSObj);
   hStdBitmap.DeleteObject();
      hStdDC.DeleteDC();

   RectVisible = FALSE;
      this->InvalidateRect( &MoveRect, FALSE);
   this->UpdateWindow();
      return TRUE;
}

/****************************************/
/*             */
/* Draw Rubber Band rectanble */
/*             */
/****************************************/
void
CRefrWnd::RubberBand(
BOOL  TestFlag)
{
   CPen  *OldPen;
   CBrush   *OldBrush;
   CPoint   ptTL;
   CPoint   ptBR;

   CClientDC   dc( this);

   OldPen = (CPen *)dc.SelectStockObject( BLACK_PEN);
   OldBrush = (CBrush *)dc.SelectStockObject( NULL_BRUSH);
   int OldMode = dc.SetROP2( R2_NOTXORPEN);

   CRect BRect;
   if( !TestFlag){
      ptTL.x = ptStart.x;
      ptTL.y = ptStart.y + CAPTION_HEIGHT;
      ptBR.x = ptPrev.x;
      ptBR.y = ptPrev.y  + CAPTION_HEIGHT;
      IllegalRect( &ptTL, &ptBR);

      BRect.SetRect( ptTL.x, ptTL.y,
         ptBR.x + ZoomRate +1, ptBR.y + ZoomRate +1);
      dc.Rectangle( &BRect);
   }
   ptTL.x = ptStart.x;
   ptTL.y = ptStart.y + CAPTION_HEIGHT;
   ptBR.x = ptEnd.x;
   ptBR.y = ptEnd.y   + CAPTION_HEIGHT;
   IllegalRect( &ptTL, &ptBR);
   ptPrev = ptBR;
   BRect.SetRect( ptTL.x, ptTL.y, ptBR.x + ZoomRate +1,ptBR.y+ZoomRate+1);
   dc.Rectangle( &BRect);

   dc.SelectObject( OldPen);
   dc.SelectObject( OldBrush);
   dc.SetROP2( OldMode);
}

/****************************************/
/*             */
/* Initialize bitmap data     */
/*             */
/****************************************/
BOOL
CRefrWnd::UpdateBitmap()
{
   WORD  wSize;
   HANDLE   BitHandle;
   BYTE  *pBitmap;

   wSize = (WORD)((( BITMAP_WIDTH + 15) /16) *2) *(WORD)BITMAP_HEIGHT;
   if(( BitHandle = LocalAlloc( LMEM_MOVEABLE, wSize)) == 0)
      return FALSE;

   if(( pBitmap = (BYTE *)LocalLock( BitHandle)) == NULL){
      LocalUnlock( BitHandle);
      LocalFree( BitHandle);
      return FALSE;
   }
   memset( pBitmap, 0xffff, wSize);

   ImageBmp.SetBitmapBits((DWORD)wSize, (const void far *)pBitmap);
   LocalUnlock( BitHandle);
   LocalFree( BitHandle);

   RectVisible = FALSE;
   this->Invalidate(FALSE);
   this->UpdateWindow();

   return TRUE;
}

/****************************************/
/*             */
/* MESSAGE  "WM_SETCURSOR"    */
/*             */
/****************************************/
BOOL
CRefrWnd::OnSetCursor(
CWnd*    pWnd,
UINT  nHitTest,
UINT  message)
{
   CPoint   point;
   CRect CaptionRect;
   HCURSOR  hArrowCur;

   GetCursorPos( &point);
   this->GetClientRect( &CaptionRect);
   this->ScreenToClient( &point);
   CaptionRect.top = CAPTION_HEIGHT;

   if( CaptionRect.PtInRect( point))
      if( MoveRect.PtInRect( point) && RectVisible)
         ::SetCursor((HCURSOR)ArrowCursor[ALLDIRECT]);
      else  ::SetCursor((HCURSOR)ToolCursor[SelectItems]);
   else{
      hArrowCur = AfxGetApp()->LoadStandardCursor(IDC_ARROW);
      ::SetCursor( hArrowCur);   
   }
   return TRUE;
}

/****************************************/
/*             */
/* MESSAGE "WM_MDIACTIVATE"   */
/*             */
/****************************************/
void
CRefrWnd::OnMDIActivate(
BOOL  bActivate,
CWnd*    pActivateWnd,
CWnd*    pDeactivateWnd)
{
   if( bActivate == FALSE){
      RectVisible = FALSE;
      this->InvalidateRect( &MoveRect, FALSE);
      this->UpdateWindow();
   }
}

/****************************************/
/*             */
/* MESSAGE  "WM_SIZE"      */
/*             */
/****************************************/
void
CRefrWnd::OnSize(
UINT  nType,
int   cx,
int   cy)
{
   int   NewZoomRate;

   NewZoomRate = cx / BITMAP_WIDTH;
   if( RectVisible && NewZoomRate > 1){
      MoveRect.left = ( MoveRect.left /ZoomRate) * NewZoomRate;

      MoveRect.top = ((( MoveRect.top - CAPTION_HEIGHT)
         / ZoomRate) * NewZoomRate) + CAPTION_HEIGHT;

      MoveRect.right = ( MoveRect.right /ZoomRate) * NewZoomRate + 1;

      MoveRect.bottom = ((( MoveRect.bottom -CAPTION_HEIGHT)
         / ZoomRate) * NewZoomRate) + CAPTION_HEIGHT + 1;

   }else if( RectVisible && NewZoomRate <= 1){
      RectVisible = FALSE;
   }
   CMDIChildWnd::OnSize(nType, cx, cy);

   this->Invalidate(FALSE);
   this->UpdateWindow();
}

/****************************************/
/*             */
/*    Select FreeForm      */
/*             */
/****************************************/
void
CRefrWnd::SelectFreeForm(
BOOL  MouseSts)
{
   CPoint   Ep, Sp, Cp;
   CPoint   Fp, Inc;
   CPoint   Dp, Err;
   BOOL  Slope;
   int   D;
   int   Tmp;

   if( !MouseSts){
      Sp.x = ptPrev.x /ZoomRate;
      Sp.y = ptPrev.y /ZoomRate;
      Ep.x = Fp.x = ptEnd.x /ZoomRate;
      Ep.y = Fp.y = ptEnd.y /ZoomRate;
   }else{
      Sp.x = ptEnd.x /ZoomRate;
      Sp.y = ptEnd.y /ZoomRate;
      Ep.x = Fp.x = ptStart.x /ZoomRate;
      Ep.y = Fp.y = ptStart.y /ZoomRate;
   }

   if( Fp.x >= Sp.x)
      Inc.x = 1;
   else  Inc.x = -1;

   if( Fp.y >= Sp.y)
      Inc.y = 1;
   else  Inc.y = -1;

   Dp.x = ( Fp.x - Sp.x)*Inc.x;
   Dp.y = ( Fp.y - Sp.y)*Inc.y;
   if( !Dp.x && !Dp.y)
      return;
   if( Dp.x < Dp.y){
      Tmp = Dp.y;
      Dp.y = Dp.x;
      Dp.x = Tmp;
      Tmp = Inc.x;
      Inc.x = Inc.y;
      Inc.y = Tmp;
      Slope = TRUE;
   }else   Slope = FALSE;

   Err.x = Dp.y * 2;
   Err.y = ( Dp.y - Dp.x) * 2;
   D = Err.x - Dp.x;

   Ep = Sp;
   while(1){
      m_selectArray.Add( Ep);
      
      if( Ep.x == Fp.x && Ep.y == Fp.y)
         break;
      if( Slope){
         Tmp = Ep.x;
         Ep.x = Ep.y;
         Ep.y = Tmp;
      }
      Ep.x += Inc.x;
      if( D < 0)
         D += Err.x;
      else{
         Ep.y += Inc.y;
         D += Err.y;
      }
      if( Slope){
         Tmp = Ep.x;
         Ep.x = Ep.y;
         Ep.y = Tmp;
      }
   }
}

/****************************************/
/*             */
/*    Draw FreeForm        */
/*             */
/****************************************/
void
CRefrWnd::DrawFreeForm(
BOOL  MouseSts)
{
   CPoint   Ep, Sp, Cp;
   CPoint   Fp, Inc;
   CPoint   Dp, Err;
   CPoint   P1, P2;
   BOOL  Slope;
   int   D;
   int   Tmp;

   CClientDC   dc( this);

   CPen  *OldPen = (CPen *)dc.SelectStockObject( BLACK_PEN);
   int OldMode = dc.SetROP2( R2_NOTXORPEN);

   if( !MouseSts){
      Sp.x = ptPrev.x;
      Sp.y = ptPrev.y + CAPTION_HEIGHT;
      Ep.x = Fp.x = ptEnd.x;
      Ep.y = Fp.y = ptEnd.y + CAPTION_HEIGHT;
   }else{
      Sp.x = ptEnd.x;
      Sp.y = ptEnd.y + CAPTION_HEIGHT;
      Ep.x = Fp.x = ptStart.x;
      Ep.y = Fp.y = ptStart.y + CAPTION_HEIGHT;
   }

   if( Fp.x >= Sp.x)
      Inc.x = ZoomRate;
   else  Inc.x = 0 - ZoomRate;

   if( Fp.y >= Sp.y)
      Inc.y = ZoomRate;
   else  Inc.y = 0 - ZoomRate;

   Dp.x = ( Fp.x - Sp.x)*Inc.x;
   Dp.y = ( Fp.y - Sp.y)*Inc.y;
   if( !Dp.x && !Dp.y)
      return;
   if( Dp.x < Dp.y){
      Tmp = Dp.y;
      Dp.y = Dp.x;
      Dp.x = Tmp;
      Tmp = Inc.x;
      Inc.x = Inc.y;
      Inc.y = Tmp;
      Slope = TRUE;
   }else   Slope = FALSE;

   Err.x = Dp.y * 2;
   Err.y = ( Dp.y - Dp.x) * 2;
   D = Err.x - Dp.x;

   Ep = Sp;
   dc.MoveTo( Sp);
   while(1){
      if( Sp.x != Ep.x && Sp.y != Ep.y){
         if( Sp.y < Ep.y && Sp.x > Ep.x){
            Cp.x = Sp.x;
            Cp.y = Ep.y;
         }else if( Sp.y < Ep.y && Sp.x < Ep.x){
            Cp.x = Sp.x;
            Cp.y = Ep.y;
         }else if( Sp.y > Ep.y && Sp.x > Ep.x){
            Cp.y = Sp.y;
            Cp.x = Ep.x;
         }else{
            Cp.y = Sp.y;
            Cp.x = Ep.x;
         }
         dc.LineTo( Cp);
         dc.LineTo( Ep);
         P1 = Cp;
         P2 = Ep;
         m_pointArray.Add( P1);
         m_pointArray.Add( P2);
      }else if( Sp.x != Ep.x || Sp.y != Ep.y){
         dc.LineTo( Ep);
         P1 = Ep;

         m_pointArray.Add( P1);
      }
      Sp.x = Ep.x;
      Sp.y = Ep.y;
      
      if( Ep.x == Fp.x && Ep.y == Fp.y)
         break;
      if( Slope){
         Tmp = Ep.x;
         Ep.x = Ep.y;
         Ep.y = Tmp;
      }
      Ep.x += Inc.x;
      if( D < 0)
         D += Err.x;
      else{
         Ep.y += Inc.y;
         D += Err.y;
      }
      if( Slope){
         Tmp = Ep.x;
         Ep.x = Ep.y;
         Ep.y = Tmp;
      }
   }
   dc.SelectObject( OldPen);
   dc.SetROP2( OldMode);
}

/****************************************/
/*             */
/* Move Rectangle       */
/*             */
/****************************************/
void
CRefrWnd::MoveRectangle(
CPoint   point)
{
   CDC   dc;

   dc.Attach( ::GetDC( NULL));
   
   dc.PatBlt( point.x - m_ptMouse.x, point.y - m_ptMouse.y,
         MoveRect.Width(), 2, PATINVERT);

   dc.PatBlt( point.x - m_ptMouse.x + MoveRect.Width(),
         point.y - m_ptMouse.y, 2, MoveRect.Height(), PATINVERT);

   dc.PatBlt( point.x - m_ptMouse.x, point.y - m_ptMouse.y
       + MoveRect.Height(), MoveRect.Width() + 2, 2, PATINVERT);

   dc.PatBlt( point.x - m_ptMouse.x, point.y - m_ptMouse.y + 2, 2,
         MoveRect.Height() - 2, PATINVERT);

   ::ReleaseDC( NULL, dc.Detach());
}

/****************************************/
/*             */
/* COMMAND  "Close Ref"    */
/*             */
/****************************************/
void
CRefrWnd::OnClickClose()
{
   AfxGetMainWnd()->SendMessage( WM_COMMAND, ID_REFFER_CLOSE, 0);
}

/****************************************/
/*             */
/* MESSAGE  "WM_KEYDOWN"      */
/*             */
/****************************************/
void
CRefrWnd::OnKeyDown(
UINT  nChar,
UINT  nRepCnt,
UINT  nFlags)
{
   if( nChar == VK_ESCAPE){
      if( RectVisible){
         RectVisible = FALSE;
         this->Invalidate(FALSE);
         this->UpdateWindow();
      }
   }else    CMDIChildWnd::OnKeyDown(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by eudcedit.rc
//
#define IDR_MAINFRAME                   2
#define IDR_EUDCTYPE                    3
#define ID_PALETTEPEN                   103
#define ID_PALETTESLOPE                 104
#define ID_PALETTERECT                  105
#define IDD_REFERENCE                   105
#define ID_PALETTERECTFILL              106
#define IDC_BUTTOMFONT                  106
#define ID_PALETTECIRCLE                107
#define IDD_CUSTOMCODE                  107
#define ID_PALETTECIRCLEFILL            108
#define ID_PALETTERECTBAND              109
#define IDC_EDITCODE                    109
#define IDC_PENCIL                      109
#define IDC_EDITCHAR                    110
#define IDC_EDITFONT                    111
#define IDW_STATICSTYLE                 111
#define IDW_STATIC                      112
#define IDC_STATIC1                     113
#define IDC_BRUSH                       113
#define IDC_STATICC                     113
#define IDC_COMPUS                      114
#define IDC_STATIC3                     115
#define IDC_STATICF                     115
#define ID_REFERCODE                    116
#define IDB_CLOSE_REF                   118
#define IDD_INPUTFILE                   120
#define IDD_ASSOCIATION                 121
#define IDC_CUSTOMEDIT                  122
#define IDC_CODECUST                    123
#define IDC_CUSTOMCHR                   125
#define IDD_IMEREGISTDLG                125
#define IDD_IMPORT                      126
#define IDI_ROTATE90                    127
#define IDI_ROTATE180                   128
#define IDI_ROTATE270                   129
#define IDI_FLIPHOR                     130
#define IDI_FLIPVER                     131
#define IDD_ROTATECHAR                  132
#define IDC_STATICFONT                  133
#define IDC_FONT_NAME                   133
#define IDD_GAGE                        136
#define IDC_SETFONTNAME                 137
#define IDI_TRUETYPE                    137
#define IDB_CLOSEBMP                    138
#define IDC_STATIC5                     139
#define IDB_CLOSEBMPP                   139
#define IDC_EDITFILENAME                140
#define IDW_STATICFILE                  142
#define IDC_STATIC7                     142
#define IDI_WIFEFONT                    142
#define IDC_FILE_NAME                   142
#define IDW_STATICNAME                  143
#define IDC_SETFILENAME                 143
#define IDC_REGISTLIST                  144
#define IDD_LINKBATCH                   145
#define IDC_MODIFY                      146
#define IDD_BROWSE_TTF                  147
#define IDC_CHINARANGE                  157
#define IDC_ERASER                      161
#define IDW_STATICCODE                  162
#define IDC_IMEREGISTEDIT               162
#define IDI_UPRIGHT                     162
#define IDW_STATICCODENUM               163
#define IDC_REMOVE                      167
#define IDC_BMP_IMPUT                   169
#define IDC_FILE_BROWSE                 170
#define IDC_FLIPHOR                     173
#define IDC_FLIPVER                     174
#define IDC_ROTATE90                    175
#define IDC_ROTATE180                   176
#define IDC_ROTATE270                   177
#define IDC_ASSOCIATE_BROWSE            188
#define IDC_GAGE                        196
#define IDC_IMPORT_STATIC               197
#define IDC_SCRIPTCOMBO                 200
#define IDC_STATICSCRIPT                201
#define IDC_STATICRANGE                 202
#define IDC_IMETABLE                    209
#define IDC_BROWSETABLE                 210
#define IDC_CUSTOMLISTFRAME             213
#define IDC_CUSTOMINFOFRAME             214
#define IDC_CUSTOMFRAME                 215
#define IDC_LISTFRAME1                  216
#define IDC_LISTFRAME2                  217
#define IDC_INFOFRAME                   218
#define IDC_CUSTOMFRAME2                219
#define IDC_CUSTOMFRAME3                220
#define IDC_TTFLIST                     221
#define IDC_RADIO_SYSTEM                222
#define IDC_RADIO_DBCS                  223
#define IDC_LIST_SYSTEM                 224
#define IDC_CODE_NAME                   225
#define IDC_ICON_HOR                    226
#define IDC_ICON_VER                    227
#define IDC_ICON_R90                    228
#define IDC_ICON_R180                   229
#define IDC_ICON_R270                   230
#define IDC_STATICS                     231
#define IDC_UPRIGHT                     231
#define IDD_RADICAL                     232
#define IDC_ROTATE_GROUP                234
#define IDC_STANDARD_GROUP              235
#define IDC_DBCS_GROUP                  236
#define IDC_COLUMNHEADING               237
#define IDC_SELECTCHARSET               238
#define IDC_STATICBMP                   240
#define IDC_STATICIMETBL                241
#define ID_STATUS_CHARSET               300
#define ID_STATUS_CODE                  301
#define ID_STATUS_FONT                  302
#define ID_STATUS_FILE                  303
#define IDC_COLUMNHEADINGR              304
#define IDH_EUDC_ASSOCIATE              1010
#define IDH_EUDC_ASSO_STANDARD          1011
#define IDH_EUDC_ASSO_LIST              1012
#define IDH_EUDC_MODIFY                 1013
#define IDH_EUDC_REMOVE                 1014
#define IDH_EUDC_ASSO_TYPEFACE          1015
#define IDH_EUDC_MODFILE                1020
#define IDH_EUDC_SELLIST                1030
#define IDH_EUDC_SELCODE                1031
#define IDH_EUDC_SELFONT                1032
#define IDH_EUDC_SELFILE                1033
#define IDH_EUDC_SELCHAR                1034
#define IDH_EUDC_SELRANGE               1035
#define IDH_EUDC_REFLIST                1040
#define IDH_EUDC_REFCODE                1041
#define IDH_EUDC_REFFONT                1042
#define IDH_EUDC_REFCHAR                1043
#define IDH_EUDC_IMPOBMP                1050
#define IDH_EUDC_FLIPH                  1060
#define IDH_EUDC_FLIPV                  1061
#define IDH_EUDC_ROTA90                 1062
#define IDH_EUDC_ROTA180                1063
#define IDH_EUDC_ROTA270                1064
#define IDH_EUDC_EXAMPLE                1065
#define IDH_EUDC_OK                     1070
#define IDH_EUDC_CANCEL                 1071
#define IDH_EUDC_BROWSE                 1072
#define IDH_EUDC_FONT                   1073
#define IDH_EUDC_BROWSE_TTF             1080
#define IDH_EUDC_LINK_IMELIST           1090
#define IDH_EUDC_BLINK_EDITTBL          1100
#define IDH_EUDC_OUTCAUTION             1200
#define IDH_EUDC_REGLIST                1530
#define IDH_EUDC_REGCODE                1531
#define IDH_EUDC_REGFONT                1532
#define IDH_EUDC_REGFILE                1533
#define IDH_EUDC_REGCHAR                1534
#define IDH_EUDC_REGRANGE               1535
#define IDH_EUDC_CALLLIST               1540
#define IDH_EUDC_CALLCODE               1541
#define IDH_EUDC_CALLFONT               1542
#define IDH_EUDC_CALLCHAR               1543
#define IDW_STYLES                      32771
#define ID_TOOLBAR                      32772
#define ID_REFFERFILE_NEW               32775
#define ID_READ_CHAR                    32776
#define ID_GAIJI_COPY                   32777
#define ID_GAIJI_CUT                    32778
#define ID_GAIJI_PASTE                  32779
#define ID_SAVE_CHARAS                  32780
#define ID_SAVECHAR                     32781
#define ID_GAIJI_UNDO                   32782
#define ID_FIT_CURVE                    32783
#define ID_SELECTFAMILY                 32784
#define ID_PALETTEBRUSH                 32785
#define ID_REFFER_CLOSE                 32788
#define ID_SHOW_GRID                    32789
#define ID_DELETE_EDIT                  32790
#define ID_LINKIME                      32791
#define ID_PALETTEFREEFORM              32794
#define ID_NEXTCODE                     32795
#define ID_PREVCODE                     32796
#define ID_CALL_CHAR                    32797
#define ID_IMPORT_FILE                  32798
#define ID_ROTATE                       32799
#define ID_LINKBATCHMODE                32802
#define ID_PALETTEERASER                32803
#define IDS_APPSELECTION                61216
#define IDS_SELECTCODE_DLGTITLE         61216
#define IDS_APPENTRY                    61217
#define IDS_REGISTAS_DLGTITLE           61217
#define IDS_NOTSELCHARACTER_MSG         61220
#define IDS_REFERENCE_DLGTITLE          61222
#define IDS_ILLEGALCODE_MSG             61223
#define IDS_ILLEGALCODE_TITLE           61224
#define IDS_LINK_DLGTITLE               61226
#define IDS_ILLEGALFILE_MSG             61229
#define IDS_MODIFY_DLGTITLE             61230
#define IDS_NOTEUDCFILE_MSG             61231
#define IDS_NOUSEEUDCFILE_MSG           61232
#define IDS_NOTCREATEEUDC_MSG           61233
#define IDS_SAVEORNOT                   61234
#define IDS_ASSOCIATE_DLGTITLE          61235
#define IDS_NOTSELTYPEFACE_MSG          61236
#define IDS_NOTSELECT_STR               61238
#define IDS_EDIT_STR                    61239
#define IDS_REFERENCE_STR               61240
#define IDS_FONT_STR                    61241
#define IDS_FILE_STR                    61242
#define IDS_MAINFRAMETITLE              61243
#define IDS_INVALIDREAD_MSG             61245
#define IDS_CODE_STR                    61246
#define IDS_MODIFYREAD_MSG              61248
#define IDS_CALL_DLGTITLE               61249
#define IDS_SYSTEMEUDCFONT_STR          61250
#define IDS_WANSUNG_STR                 61251
#define IDS_JOHAB_STR                   61252
#define IDS_BATCHIME_FILTER             61255
#define IDS_FILEHEADER_MSGTITLE         61256
#define IDS_FILEHEADER_MSG              61257
#define IDS_FILESIZE_MSGTITLE           61258
#define IDS_FILESIZE_MSG                61259
#define IDS_INMETHOD_MSGTITLE           61260
#define IDS_INMETHOD_MSG                61261
#define IDS_BANKID_MSGTITLE             61262
#define IDS_BANKID_MSG                  61263
#define IDS_CODEPAGE_MSGTITLE           61264
#define IDS_CODEPAGE_MSG                61265
#define IDS_SIGN_MSGTITLE               61266
#define IDS_SIGN_MSG                    61267
#define IDS_BATCHLNK_DLGTITLE           61268
#define IDS_NOTOPEN_MSG                 61269
#define IDS_BROWSETTF_DLGTITLE          61270
#define IDS_NOTSELECTTTF_MSG            61271
#define IDS_IMPORT_DLGTITLE             61272
#define IDS_NOTUSERFONT_MSG             61273
#define IDS_BROWSEUSER_DLGTITLE         61274
#define IDS_ROTATE_DLGTITLE             61275
#define IDS_BROWSETABLE_DLGTITLE        61276
#define IDS_DEFAULTFILENAME             61277
#define IDS_IMPORT_JAPAN_FILTER         61278
#define IDS_NOTENOUGHMEMORY_ERROR       61279
#define IDS_IMPORT_CHINA_FILTER         61280
#define IDS_INTERNAL_TITLE              61281
#define IDS_INTERNAL_MSG                61282
#define IDS_NOTOPEN_TITLE               61283
#define IDS_UNMATCHED_TITLE             61284
#define IDS_UNMATCHED_MSG               61285
#define IDS_CHINESE_CHAR                61286
#define IDS_QUERY_NOTFINISH             61287
#define IDS_QUERY_REGISTER              61288
#define IDS_NOIME_TITLE                 61289
#define IDS_NOIME_MSG                   61290
#define IDS_NOMEM_TITLE                 61291
#define IDS_NOMEM_MSG                   61292
#define IDS_EUDCTTF_FILTER              61293
#define IDS_SELECTFONT_ERROR            61294
#define IDS_CHARSET_STR                 61295
#define IDS_UNICODE                     61297
#define IDS_SHIFTJIS                    61298
#define IDS_GB2312                      61299
#define IDS_HANGUL                      61300
#define IDS_CHINESEBIG5                 61301
#define IDS_INVALID_CODE_MSG            61302
#define IDS_IMPORTFONT_MSG              61303
#define IDS_OVERWRITEFAIL               61304
#define IDS_ACCESSDENIED                61305
#define IDS_NOTTE                       61306

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        165
#define _APS_NEXT_COMMAND_VALUE         32811
#define _APS_NEXT_CONTROL_VALUE         242
#define _APS_NEXT_SYMED_VALUE           151
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\rotatdlg.cpp ===
/**************************************************/
/*					                              */
/*					                              */
/*	Rotate Bitmap in Edit Window	              */
/*		(Dialog)		                          */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"rotatdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/****************************************/
/*					*/
/*	Default Constructor		*/
/*					*/
/****************************************/
CRotateDlg::CRotateDlg( CWnd* pParent)
	: CDialog(CRotateDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRotateDlg)
	//}}AFX_DATA_INIT
}

/****************************************/
/*					*/
/*	MESSAGE	"WM_INITDIALOG"		*/
/*					*/
/****************************************/
BOOL
CRotateDlg::OnInitDialog()
{
	CString	DlgTitle;

	CDialog::OnInitDialog();

//	Implement "?" in this dialogbox.
	LONG WindowStyle = GetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE);
	WindowStyle |= WS_EX_CONTEXTHELP;
	SetWindowLong( this->GetSafeHwnd(), GWL_EXSTYLE, WindowStyle);

//	Set Dialog title name.
	DlgTitle.LoadString(IDS_ROTATE_DLGTITLE);
	this->SetWindowText( DlgTitle);

	RadioItem = FLIP_HOR;
	this->SendDlgItemMessage( IDC_FLIPHOR, BM_SETCHECK,(WPARAM)1,(LPARAM)0);
	return TRUE;
}

/****************************************/
/*					*/
/*	COMMAND	"IDOK"			*/
/*					*/
/****************************************/
void
CRotateDlg::OnOK()
{
	if( RadioItem == NOTSEL){
		MessageBeep((UINT)-1);
		return;
	}
	CDialog::OnOK();
}

/****************************************/
/*					*/
/*	COMMAND	"FLIP HORIZONTAL"	*/
/*					*/
/****************************************/
void
CRotateDlg::OnFliphor()
{
	RadioItem = FLIP_HOR;
}

/****************************************/
/*					*/
/*	COMMAND	"FLIP VERTICAL"		*/
/*					*/
/****************************************/
void
CRotateDlg::OnFlipver()
{
	RadioItem = FLIP_VER;
}

/****************************************/
/*					*/
/*	COMMAND	"ROTATE 90"		*/
/*					*/
/****************************************/
void CRotateDlg::OnRotate90()
{
	RadioItem = ROTATE_9;
}

/****************************************/
/*					*/
/*	COMMAND	"ROTATE 180"		*/
/*					*/
/****************************************/
void
CRotateDlg::OnRotate180()
{
	RadioItem = ROTATE_18;
}

/****************************************/
/*					*/
/*	COMMAND	"ROTATE 270"		*/
/*					*/
/****************************************/
void CRotateDlg::OnRotate270()
{
	RadioItem = ROTATE_27;
}

static DWORD aIds[] =
{
//	IDC_ROTATE_GROUP, IDH_EUDC_OUTCAUTION,
	IDC_FLIPHOR, IDH_EUDC_FLIPH,
	IDC_ICON_HOR, IDH_EUDC_FLIPH,
	IDC_FLIPVER, IDH_EUDC_FLIPV,
	IDC_ICON_VER, IDH_EUDC_FLIPV,
	IDC_ROTATE90, IDH_EUDC_ROTA90,
	IDC_ICON_R90, IDH_EUDC_ROTA90,
	IDC_ROTATE180, IDH_EUDC_ROTA180,
	IDC_ICON_R180, IDH_EUDC_ROTA180,
	IDC_ROTATE270, IDH_EUDC_ROTA270,
	IDC_ICON_R270, IDH_EUDC_ROTA270,
	IDC_UPRIGHT, IDH_EUDC_EXAMPLE,
//	IDOK, IDH_EUDC_OK,
//	IDCANCEL, IDH_EUDC_CANCEL,
	0,0
};

/****************************************/
/*					*/
/*	Window procedure		*/
/*					*/
/****************************************/
LRESULT
CRotateDlg::WindowProc(
UINT 	message,
WPARAM 	wParam,
LPARAM 	lParam)
{
	if( message == WM_HELP){
		::WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
			HelpPath, HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
		return(0);
	}
	if( message == WM_CONTEXTMENU){
		::WinHelp((HWND)wParam, HelpPath,
			HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)aIds);
		return(0);
	}		
	return CDialog::WindowProc(message, wParam, lParam);
}

BEGIN_MESSAGE_MAP(CRotateDlg, CDialog)
	//{{AFX_MSG_MAP(CRotateDlg)
	ON_BN_CLICKED(IDC_FLIPHOR, OnFliphor)
	ON_BN_CLICKED(IDC_FLIPVER, OnFlipver)
	ON_BN_CLICKED(IDC_ROTATE180, OnRotate180)
	ON_BN_CLICKED(IDC_ROTATE270, OnRotate270)
	ON_BN_CLICKED(IDC_ROTATE90, OnRotate90)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\sources.inc ===
!IF 0

Copyright (c) 1991-2000 Microsoft Corporation.

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF


#
# Fusionized
# 
SXS_ASSEMBLY_NAME=Microsoft.Windows.eudcedit
SXS_ASSEMBLY_VERSION=1.0 
SXS_APPLICATION_MANIFEST=eudcedit.Manifest

TARGETNAME=eudcedit
TARGETPATH=obj
TARGETTYPE=PROGRAM


PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafx.obj

INCLUDES=..

C_DEFINES=-DWINVER=0x0500 -DBUILD_ON_WINNT -DNEWREG

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\ASSOCDLG.CPP \
        ..\BLINKDLG.CPP \
        ..\BMPOPE.CPP   \
        ..\CODE.CPP     \
        ..\CREATE.CPP   \
        ..\DATAIF.CPP   \
        ..\EDITWND.CPP  \
        ..\ETEN.CPP     \
        ..\EUDCDLG.CPP  \
        ..\EUDCEDIT.CPP \
        ..\EUDCLIST.CPP \
        ..\EUDCRANG.CPP \
        ..\FITCONIC.CPP \
        ..\GAGEDLG.CPP  \
        ..\GUIDEBAR.CPP \
        ..\IMEBLINK.C   \
        ..\IMELIST.C    \
        ..\IMPORT.CPP   \
        ..\IMPRTDLG.CPP \
        ..\MAINFRM.CPP  \
        ..\MAKEPOLY.CPP \
        ..\REFRDLG.CPP  \
        ..\REFRLIST.CPP \
        ..\REFRWND.CPP  \
        ..\REGISTRY.CPP \
        ..\ROTATDLG.CPP \
        ..\SMOOTH.CPP   \
        ..\TTFFILE.CPP  \
        ..\UTIL.CPP     \
        ..\VDATA.CPP    \
        ..\W31JBMP.CPP  \
        ..\W31JEUDC.CPP \
        ..\EUDCEDIT.RC

UMTYPE=windows
UMENTRY=winmain

UMLIBS=$(SDK_LIB_PATH)\comdlg32.lib  \
       $(SDK_LIB_PATH)\shell32.lib   \
       $(SDK_LIB_PATH)\gdi32.lib     \
       $(SDK_LIB_PATH)\htmlhelp.lib  \
       $(SDK_LIB_PATH)\imm32.lib     \
       $(SDK_LIB_PATH)\strsafe.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\refrwnd.h ===
/**************************************************/
/*                                           */
/*                                           */
/* MDI Child Window (reference)                */
/*                                           */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include <afxtempl.h>
class CRefrWnd : public CMDIChildWnd
{
   DECLARE_DYNCREATE(CRefrWnd)
public:
   CRefrWnd();       
   BOOL Create( LPCTSTR szTitle, LONG Style, RECT ReffWndRect, CMDIFrameWnd* Parent);
   BOOL UpdateBitmap();
   void CaptionDraw();

private:
   void DrawFreeForm( BOOL MouseSts);
   void SelectFreeForm( BOOL MouseSts);
   BOOL CreateNewBitmap();
   BOOL ClipPickValueInit();
   BOOL InitSelectLogfont();
   BOOL ClipImageCopy();
   BOOL LoadCloseBitmap();
   void DrawGridLine( CDC *dc);
// void CaptionDraw( CDC *dc);
   void RubberBand( BOOL TestFlag);
   void RubberBandPaint( CDC *dc);
   void IllegalRect( PPOINT ptTL, PPOINT ptBR);
   void CorrectMouseDownPt( CPoint point);
   void CorrectMouseUpPt( CPoint point);
   void MoveRectangle( CPoint point);

public:
   BOOL  GridShow;
   WORD  ReferCode;
   BOOL  RectVisible;
   BOOL  bFocus;
   int   SelectItems;

private:
   CBitmapButton  CloseBtm;
   CBitmap  ImageBmp;
   CDC   ImageDC;
   BOOL  IsCapture;
   BOOL  ValidateFlag;
   CPoint   ptStart;
   CPoint   ptEnd;
   CPoint   ptPrev;
   CPoint   m_ptMouse;
   CPoint   m_ptLast;
   int   ZoomRate;
   UINT  ClipboardFormat;
   CRect PickRect;
   CRect MoveRect;
   CRect ReffWndRect;
   CRgn  FreeRgn, PickRgn;
   CArray<CPoint,CPoint>   m_pointArray;
   CArray<CPoint,CPoint>   m_selectArray;
   BOOL  m_bCloseOnLeft;

protected:
   virtual ~CRefrWnd();
   static CMenu NEAR menu;

   //{{AFX_MSG(CRefrWnd)
   afx_msg void OnClickClose();
   afx_msg void OnPaint();
   afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
   afx_msg void OnSize(UINT nType, int cx, int cy);
   afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
   afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
   afx_msg void OnMouseMove(UINT nFlags, CPoint point);
   afx_msg void OnGaijiCopy();   
   afx_msg void OnUpdateGaijiCopy( CCmdUI* pCmdUI);
   afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
   afx_msg void OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd);                          
   afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    //afx_msg void OnActivate( UINT nState, CWnd* pWndOther, BOOL bMinimized );
    //afx_msg int OnMouseActivate( CWnd* pDesktopWnd, UINT nHitTest, UINT message );

   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\registry.cpp ===
/**************************************************/
/*					                              */
/*					                              */
/*	Registry Key Function		                  */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include 	"stdafx.h"
#include 	"eudcedit.h"
#include 	"registry.h"
#include	"util.h"

#define STRSAFE_LIB
#include <strsafe.h>

static TCHAR subkey1[] = TEXT("EUDC");
static TCHAR subkey2[] = TEXT("System\\CurrentControlSet\\control\\Nls\\Codepage\\EUDCCodeRange");
static TCHAR SubKey[MAX_PATH];

#ifdef IN_FONTS_DIR // IsFileUnderWindowsRoot()
LPTSTR
IsFileUnderWindowsRoot(
LPTSTR TargetPath)
{
    TCHAR  WindowsRoot[MAX_PATH+1];
    UINT  WindowsRootLength;

    if (!TargetPath)
    {
        return NULL;
    }
    WindowsRootLength = GetSystemWindowsDirectory(WindowsRoot,MAX_PATH);

    if( lstrcmpi(WindowsRoot,TargetPath) == 0)
        return (TargetPath + WindowsRootLength);

    return NULL;
}

void AdjustTypeFace(WCHAR *orgName, WCHAR *newName,  int nDestLen)
{ 
  HRESULT hresult;

   if ((!orgName) || (!newName))
   {
      return;
   }

  if (!lstrcmpW(orgName, L"\x5b8b\x4f53"))
  {
    //*STRSAFE*     lstrcpy(newName, TEXT("Simsun"));
    hresult = StringCchCopy(newName , nDestLen,  TEXT("Simsun"));
    if (!SUCCEEDED(hresult))
    {
       return ;
    }
  } else if (!lstrcmpW(orgName, L"\x65b0\x7d30\x660e\x9ad4"))
  {
    //*STRSAFE*     lstrcpy(newName, TEXT("PMingLiU"));
    hresult = StringCchCopy(newName , nDestLen,  TEXT("PMingLiU"));
    if (!SUCCEEDED(hresult))
    {
       return ;
    }
  } else if (!lstrcmpW(orgName, L"\xFF2d\xFF33\x0020\xFF30\x30b4\x30b7\x30c3\x30af")) 
  {
    //*STRSAFE*     lstrcpy(newName, TEXT("MS PGothic"));
    hresult = StringCchCopy(newName , nDestLen,  TEXT("MS PGothic"));
    if (!SUCCEEDED(hresult))
    {
       return;
    }
  } else if (!lstrcmpW(orgName, L"\xad74\xb9bc"))
  {
    //*STRSAFE*     lstrcpy(newName, TEXT("Gulim"));
    hresult = StringCchCopy(newName , nDestLen,  TEXT("Gulim"));
    if (!SUCCEEDED(hresult))
    {
       return ;
    }
  } else
  {
    //*STRSAFE*     lstrcpy(newName, orgName);
    hresult = StringCchCopy(newName , nDestLen,  orgName);
    if (!SUCCEEDED(hresult))
    {
       return;
    }
   }
}

#endif // IN_FONTS_DIR

/****************************************/
/*					*/
/*	Inquiry EUDC registry		*/
/*					*/
/****************************************/
BOOL
InqTypeFace(
TCHAR 	*typeface,
TCHAR 	*filename,
INT 	bufsiz)
{
	HKEY 	phkey;
	DWORD 	cb, dwType;
	LONG 	rc;
	TCHAR	FaceName[LF_FACESIZE];
	TCHAR	SysName[LF_FACESIZE];
	HRESULT hresult;
#ifdef BUILD_ON_WINNT // InqTypeFace()
    TCHAR    FileName[MAX_PATH];
#endif // BUILD_ON_WINNT

       if ((!typeface) || (!filename))
       {
          return FALSE;
       }
	GetStringRes(SysName, IDS_SYSTEMEUDCFONT_STR, ARRAYLEN(SysName));
	if( !lstrcmp(typeface, SysName)){
		//*STRSAFE* 		lstrcpy(FaceName,TEXT("SystemDefaultEUDCFont"));
		hresult = StringCchCopy(FaceName , ARRAYLEN(FaceName), TEXT("SystemDefaultEUDCFont"));
		if (!SUCCEEDED(hresult))
		{
		   return FALSE;
		}
  }else {
#ifdef IN_FONTS_DIR
    AdjustTypeFace(typeface, FaceName,ARRAYLEN(FaceName));
#else
    //*STRSAFE*     lstrcpy(FaceName, typeface);
    hresult = StringCchCopy(FaceName , ARRAYLEN(FaceName),  typeface);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
#endif
  }
	if( RegOpenKeyEx( HKEY_CURRENT_USER, (LPCTSTR)SubKey, 0,
	    KEY_ALL_ACCESS, &phkey) != ERROR_SUCCESS){
		return FALSE;
	}

#ifdef IN_FONTS_DIR // InqTypeFace()
	cb = (DWORD)MAX_PATH*sizeof(WORD)/sizeof(BYTE);
	rc = RegQueryValueEx(phkey, FaceName, 0, &dwType, 
		(LPBYTE)FileName, &cb);
	RegCloseKey(phkey);

    /*
     * if there is some error or no data, just return false.
     */
    if ((rc != ERROR_SUCCESS) || (FileName[0] == '\0')) {
        return (FALSE);
    }

    /*
     * expand %SystemRoot% to Windows direcotry.
     */
    ExpandEnvironmentStrings((LPCTSTR)FileName,(LPTSTR)filename,bufsiz);
#else
	cb = (DWORD)bufsiz*sizeof(WORD)/sizeof(BYTE);
	rc = RegQueryValueEx(phkey, (TCHAR *)FaceName, 0, &dwType, 
		(LPBYTE)filename, &cb);
	RegCloseKey(phkey);

	if ((rc != ERROR_SUCCESS) || (filename[0] == '\0')) {
        return (FALSE);
    }
#endif // IN_FONTS_DIR

#ifdef BUILD_ON_WINNT // InqTypeFace()
    /*
     * if this is not 'full path'. Build 'full path'.
     *
     *   EUDC.TTE -> C:\WINNT40\FONTS\EUDC.TTE
     *               0123456...
     *
     * 1. filename should have drive letter.
     * 2. filename should have one '\\' ,at least, for root.
     */
    if ((filename[1] != ':') || (Mytcsstr((const TCHAR *)filename,TEXT("\\")) == NULL)) {
        /* backup original.. */
        //*STRSAFE*         lstrcpy(FileName, (const TCHAR *)filename);
        hresult = StringCchCopy(FileName , ARRAYLEN(FileName),  (const TCHAR *)filename);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }

        /* Get windows directory */
        GetSystemWindowsDirectory((TCHAR *)filename, MAX_PATH);

#ifdef IN_FONTS_DIR // InqTypeFace()
        //*STRSAFE*    lstrcat((TCHAR *)filename, TEXT("\\FONTS\\"));
        hresult = StringCchCat((TCHAR *) filename, ARRAYLEN( filename),  TEXT("\\FONTS\\"));
        if (!SUCCEEDED(hresult))
        {
              return FALSE;
        }                 
#else
         //*STRSAFE*    strcat((char *)filename, "\\");
        hresult = StringCchCatA((char *) filename, sizeof( filename), "\\");
        if (!SUCCEEDED(hresult))
        {
              return FALSE;
        }         
#endif // IN_FONTS_DIR        
        //*STRSAFE*    lstrcat((TCHAR *) filename, FileName);
        hresult = StringCchCat((TCHAR *) filename, ARRAYLEN( filename), FileName);
        if (!SUCCEEDED(hresult))
        {
              return FALSE;
        }
    }
#endif // BUILD_ON_WINNT

#ifdef IN_FONTS_DIR // InqTypeFace()
	return (TRUE);
#else
	return rc == ERROR_SUCCESS && filename[0] != '\0' ? TRUE : FALSE;
#endif
}

/****************************************/
/*					*/
/*	Registry EUDC font and file	*/
/*					*/
/****************************************/
BOOL 
RegistTypeFace(
TCHAR 	*typeface, 
TCHAR	*filename)
{
	HKEY 	phkey;
	LONG 	rc;
	TCHAR	FaceName[LF_FACESIZE];
	TCHAR	SysName[LF_FACESIZE];
	HRESULT hresult;
#ifdef IN_FONTS_DIR // RegistTypeFace()
    LPTSTR   SaveFileName;
    TCHAR    FileName[MAX_PATH];
#endif // IN_FONTS_DIR

       if ((!typeface) || (!filename))
       {
          return FALSE;
       }
	GetStringRes((TCHAR *)SysName, IDS_SYSTEMEUDCFONT_STR, ARRAYLEN(SysName));
	if( !lstrcmp((const TCHAR *)typeface, (const TCHAR *)SysName)){
		//*STRSAFE* 		lstrcpy(FaceName, TEXT("SystemDefaultEUDCFont"));
		hresult = StringCchCopy(FaceName , ARRAYLEN(FaceName),  TEXT("SystemDefaultEUDCFont"));
		if (!SUCCEEDED(hresult))
		{
		   return FALSE;
		}
  }else{
#ifdef IN_FONTS_DIR
    AdjustTypeFace(typeface, FaceName,ARRAYLEN(FaceName));
#else
    //*STRSAFE*     lstrcpy(FaceName, (const TCHAR *)typeface);
    hresult = StringCchCopy(FaceName , ARRAYLEN(FaceName),  (const TCHAR *)typeface);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
#endif
  }
	if( RegOpenKeyEx( HKEY_CURRENT_USER, (LPCTSTR)SubKey, 0,
	    KEY_ALL_ACCESS, &phkey) != ERROR_SUCCESS){
		return FALSE;
	}

#ifdef IN_FONTS_DIR // RegistTypeFace()
    /*
     * if registry data contains full path, and the file is under windows
     * directory, replace the hardcodeed path with %SystemRoot%....
     */
    if( (SaveFileName = IsFileUnderWindowsRoot((LPTSTR)filename)) != NULL) {
        //*STRSAFE*         lstrcpy(FileName, TEXT("%SystemRoot%"));
        hresult = StringCchCopy(FileName , ARRAYLEN(FileName),  TEXT("%SystemRoot%"));
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        //*STRSAFE*         if( *SaveFileName != '\\' ) lstrcat(FileName, TEXT("\\"));
        if( *SaveFileName != '\\' ) {        	
           hresult = StringCchCat(FileName , ARRAYLEN(FileName),  TEXT("\\"));
           if (!SUCCEEDED(hresult))
           {
              return FALSE;
           }
        }
        //*STRSAFE*         lstrcat(FileName, SaveFileName );
        hresult = StringCchCat(FileName , ARRAYLEN(FileName),  SaveFileName );
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
    } else {
        //*STRSAFE*         lstrcpy(FileName, (TCHAR *)filename );
        hresult = StringCchCopy(FileName , ARRAYLEN(FileName),  (TCHAR *)filename );
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
    }
	rc = RegSetValueEx( phkey, (LPCTSTR)FaceName, 0,
		REG_SZ, (const BYTE *)FileName, (lstrlen((LPCTSTR)FileName)+1)*sizeof(WORD)/sizeof(BYTE));
#else
	rc = RegSetValueEx( phkey, (LPCTSTR)FaceName, 0,
		REG_SZ, (const BYTE *)filename, (lstrlen((LPCTSTR)filename)+1)*sizeof(WORD)/sizeof(BYTE));
#endif // IN_FONTS_DIR
	RegCloseKey(phkey);
	return rc == ERROR_SUCCESS ? TRUE : FALSE;
}

/****************************************/
/*					*/
/*	Delete Registry string		*/
/*					*/
/****************************************/
BOOL 
DeleteReg( 
TCHAR	*typeface)
{
	HKEY phkey;
	LONG rc;
	TCHAR	FaceName[LF_FACESIZE];
	TCHAR	SysName[LF_FACESIZE];
	HRESULT hresult;

        if (!typeface)
       {
          return FALSE;
       }
	GetStringRes((TCHAR *)SysName, IDS_SYSTEMEUDCFONT_STR, ARRAYLEN(SysName));
	if( !lstrcmp((const TCHAR *)typeface, (const TCHAR *)SysName)){		
		 //*STRSAFE*     lstrcpy((TCHAR *)FaceName, TEXT("SystemDefaultEUDCFont"));
               hresult = StringCchCopy((TCHAR *)FaceName, ARRAYLEN(FaceName), TEXT("SystemDefaultEUDCFont"));
               if (!SUCCEEDED(hresult))
              {
                  return FALSE;
               }
  }else{
#ifdef IN_FONTS_DIR
    AdjustTypeFace(typeface, FaceName,ARRAYLEN(FaceName));
#else    
     //*STRSAFE*     lstrcpy((TCHAR *)FaceName, (const TCHAR *)typeface);
    hresult = StringCchCopy((TCHAR *)FaceName, ARRAYLEN(FaceName), (const TCHAR *)typeface);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
#endif
  }
	if( RegOpenKeyEx(HKEY_CURRENT_USER, (LPCTSTR)SubKey, 0,
	    KEY_ALL_ACCESS, &phkey) != ERROR_SUCCESS){
		return FALSE;
	}
	rc = RegDeleteValue( phkey, (LPTSTR)FaceName);
	RegCloseKey(phkey);

	return rc == ERROR_SUCCESS ? TRUE : FALSE;
}

/****************************************/
/*					*/
/*	Create Registry Subkey		*/
/*					*/
/****************************************/
BOOL
CreateRegistrySubkey()
{
	HKEY 	phkey;
	DWORD 	dwdisp;
    int	    LocalCP;
	TCHAR	CodePage[10];
	int	result;
	HRESULT hresult;

	/* New Registry	*/
	LocalCP = GetACP();

  	//*STRSAFE*   	wsprintf( CodePage, TEXT("%d"), LocalCP);
  	hresult = StringCchPrintf(CodePage , ARRAYLEN(CodePage),  TEXT("%d"), LocalCP);
  	if (!SUCCEEDED(hresult))
  	{
  	   return FALSE;
  	}
    //*STRSAFE*     lstrcpy(SubKey, subkey1);
    hresult = StringCchCopy(SubKey , ARRAYLEN(SubKey),  subkey1);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
	//*STRSAFE* 	lstrcat(SubKey, TEXT("\\"));
	hresult = StringCchCat(SubKey , ARRAYLEN(SubKey),  TEXT("\\"));
	if (!SUCCEEDED(hresult))
	{
	   return FALSE;
	}
	//*STRSAFE* 	lstrcat(SubKey, CodePage);
	hresult = StringCchCat(SubKey , ARRAYLEN(SubKey),  CodePage);
	if (!SUCCEEDED(hresult))
	{
	   return FALSE;
	}

	if( RegOpenKeyEx( HKEY_CURRENT_USER, (LPCTSTR)SubKey, 0,
	    KEY_ALL_ACCESS, &phkey) != ERROR_SUCCESS){
		result = RegCreateKeyEx(HKEY_CURRENT_USER, 
			(LPCTSTR)SubKey, 0, TEXT(""),
			REG_OPTION_NON_VOLATILE, 
			KEY_ALL_ACCESS, NULL, &phkey, &dwdisp);
		if( result == ERROR_SUCCESS)
			RegCloseKey( phkey);
		else	return FALSE;
	}else 	RegCloseKey(phkey);

	return TRUE;
}

/****************************************/
/*					*/
/*	Inquiry Code range registry	*/
/*					*/
/****************************************/
BOOL 
InqCodeRange( 
TCHAR 	*Codepage, 
BYTE 	*Coderange, 
INT 	bufsiz)
{
	HKEY phkey;
	DWORD cb, dwType;
	LONG rc;

       if ((!Codepage) || (!Coderange))
       {
           return FALSE;
       }
	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCTSTR)subkey2, 0,
	    KEY_READ, &phkey) != ERROR_SUCCESS) {
		return FALSE;
	}
	cb = (DWORD)bufsiz * sizeof(WORD)/sizeof(BYTE);
	rc = RegQueryValueEx(phkey, (TCHAR *)Codepage, 0, &dwType, 
		(LPBYTE)Coderange, &cb);

	RegCloseKey(phkey);

	return rc == ERROR_SUCCESS && Coderange[0] != '\0' ? TRUE : FALSE;
}

BOOL
DeleteRegistrySubkey()
{
	HKEY 	phkey;

	if( RegOpenKeyEx( HKEY_CURRENT_USER, (LPCTSTR)SubKey, 0,
	    KEY_ALL_ACCESS, &phkey) == ERROR_SUCCESS){
		RegCloseKey(phkey);
		return RegDeleteKey(HKEY_CURRENT_USER, (LPCTSTR)SubKey);
	
	}

	return TRUE;
}

BOOL
FindFontSubstitute(TCHAR *orgFontName, TCHAR *sbstFontName, int nDestLen)
{
  static TCHAR fsKey[] = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes");
  HRESULT hresult;
  
  if ((!orgFontName) || (!sbstFontName))
  {
      return FALSE;
  }
  *sbstFontName = 0;
  //*STRSAFE*   lstrcpy(sbstFontName, orgFontName);
  hresult = StringCchCopy(sbstFontName , nDestLen,  orgFontName);
  if (!SUCCEEDED(hresult))
  {
     return FALSE;
  }
	HKEY phkey;

	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, (LPCTSTR)fsKey, 0,
	    KEY_QUERY_VALUE, &phkey) != ERROR_SUCCESS) {
		return FALSE;
	}

  DWORD valueNameSize = LF_FACESIZE + 50; //should be facename + ',' + codepage
  TCHAR valueName[LF_FACESIZE + 50]; 
  DWORD valueType;
  DWORD valueDataSize = (LF_FACESIZE + 50) * sizeof(TCHAR); //should be facename + ',' + codepage
  BYTE  valueData[(LF_FACESIZE + 50) * sizeof(TCHAR)];
  LONG  ret;
  DWORD idx = 0;
  while ((ret = RegEnumValue(phkey, idx, valueName, &valueNameSize, 0, 
                        &valueType, valueData, &valueDataSize)) != ERROR_NO_MORE_ITEMS)
  {
    if (ret != ERROR_SUCCESS)
    {
      RegCloseKey(phkey);
      return FALSE;
    }
    Truncate(valueName, _T(','));
    if (!lstrcmpi(valueName, orgFontName))
    {
      Truncate((TCHAR *)valueData, _T(','));
      //*STRSAFE*       lstrcpy(sbstFontName, (TCHAR *)valueData);
      hresult = StringCchCopy(sbstFontName , nDestLen,  (TCHAR *)valueData);
      if (!SUCCEEDED(hresult))
      {
         return FALSE;
      }
      break;
    }
    idx ++;
    valueNameSize = LF_FACESIZE + 50;
    valueDataSize = (LF_FACESIZE + 50) * sizeof(TCHAR); 
  } 
  
  RegCloseKey(phkey);
  return TRUE;
}

void Truncate(TCHAR *str, TCHAR delim)
{
  TCHAR *pchr = _tcschr(str, delim);
  if (pchr)
    *pchr = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\registry.h ===
/**************************************************/	
/*					                              */
/*					                              */
/*	Regist functions		                      */
/*					                              */
/*					                              */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

BOOL InqTypeFace(TCHAR *typeface, TCHAR *filename, INT bufsiz);
BOOL RegistTypeFace(TCHAR *typeface, TCHAR *filename);
BOOL DeleteReg(TCHAR *typeface);
BOOL CreateRegistrySubkey();
BOOL InqCodeRange(TCHAR *Codepage, BYTE *Coderange, INT bufsiz);
BOOL DeleteRegistrySubkey();
BOOL FindFontSubstitute(TCHAR *orgFontName, TCHAR *sbstFontName, int nDestLen);
void Truncate(TCHAR *str, TCHAR delim);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\smooth.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//

#include	"stdafx.h"

#include	"vdata.h"
#include	"extfunc.h"
#include	"ttfstruc.h"

/* Smooth sort */
#define		SMOOTH		0x8000
#define		NOSMOOTH	0x4000
#define		BACKWARD	0x2000		/* NOSMOOTH is forward vector */
#define		FOREWARD	0x1000		/* NOSMOOTH is backward vector*/

/* Curve Type */
#define		SPLINE_ATR	0x0001

/* Smoothing anchor Point */
#define		SMOOTHANCHOR	0x0080
	/* Smoothing anchor point is based 90degree Rule */
/* for turning */
#define		TURN_OU		1		/*  */
#define		TURN_TOTSU	2		/*  */

#define		sign(n)		(n < 0 ? 1 : 0)

#define		LONGMIN		5


int  SmoothVector(int  lstHdl,int  tmpLst,int  xinMesh,int yinMesh, int  outMesh,struct  SMOOTHPRM *prm,int  fp);
static int  BindVector(int  inLst,int  outLst);
static int  BindPoint(int  inLst,int  outLst);
static int  DetectNoSmooth(int  lsthdl);
static void  turnsort(struct  VDATA *vp);
static void  generalsmooth(struct  VDATA *vp);
static int  isturn(struct  VDATA *vp);
static int  islong(struct  VDATA *vp);
static void  longline(struct  VDATA *vp);
static int  ZoomPoint(int  lstHdl,int  xinMesh,int yinMesh, int  outMesh,int  uFp);
static int  preproc1(int  inLst,int  outLst);
static int  diveachside(struct  VDATA *vp,int  outLst);
static int  divoneside(struct  VDATA *vp,int  outLst);
static int divVec( int ilst, int olst, int divN);
static int  Smooth1(int  inLst,int  outLst,int  weight1,int  weight2,int  weight3);
static int  Smooth2(int  inLst,int  outLst);
int  searchanchor(int  sn,struct  VDATA *sp,struct  VDATA * *ep,int  lim);
static int  smooth1sub(struct  VDATA *vp,int  np,int  outLst,int  w1,int  w2,int  w3);
static int  smooth2sub(struct  VDATA *vp,int  np,int  outLst);
int  RemoveFp(int  lstHdl,int  outMesh,int  uFp);
static int  BindLinears(int  inLst,int  outLst);
static int  DelZeroVec(int  inLst,int  outLst);
int  toTTFFrame(int  lstH,struct  BBX *bbx);
static int  lightSub(int  inLst,int  outLst);
int  SmoothLight(int  ioLst,int  tmpLst,int  width,int height, int  oWidth,int  ufpVal);
int  ConvMesh(int  lstH,int  inMesh,int  outMesh);
static int
straightCurve( int iLst, int oLst)
{
struct VHEAD	*vhd;
struct VDATA	*vp;
struct vecdata	rel, nxtrel;
	int	np;
	int	sts;
struct vecdata	svd;

	if ( (sts = VDGetHead( iLst, &vhd))!=0)
		goto	RET;
	VDNew(oLst);

	while ( vhd->next!=NIL) {
		/* No point data is not Allowed */
		/* Set Origin */
		vp = vhd->headp;
		if ((sts = VDSetData(oLst, &vp->vd))!=0)
			goto	RET;
		vp=vp->next;
		for ( np = 1; np < vhd->nPoints; np++,vp = vp->next) {
			if ( vp->vd.atr & SPLINE_ATR) {
				rel.x = vp->vd.x - vp->prev->vd.x;
				rel.y = vp->vd.y - vp->prev->vd.y;
				nxtrel.x= vp->next->vd.x - vp->vd.x;
				nxtrel.y= vp->next->vd.y - vp->vd.y;
				if ((long)rel.x*nxtrel.y==(long)rel.y*nxtrel.x){
					vp = vp->next;
					np++;
					svd = vp->vd;
					svd.atr &= ~SPLINE_ATR;
					if ((sts = VDSetData(oLst, &svd))!=0)
						goto	RET;
				}
				else {
					if ((sts = VDSetData(oLst, &vp->vd))!=0)
						goto	RET;
					vp = vp->next;
					np++;
					if ( np >= vhd->nPoints)
						break;
					if ((sts = VDSetData(oLst, &vp->vd))!=0)
						goto	RET;
				}
			}
			else {
				if ((sts = VDSetData(oLst, &vp->vd))!=0)
					goto	RET;
			}
		}
		if(VDClose( oLst))
			goto	RET;
		vhd = vhd->next;
	}
	return 0;
RET:
	return -1;
}
/***********************************************************************
 *	Smoothing Main
 */
/* */	int
/* */	SmoothVector(
/* */		int	lstHdl,
/* */		int	tmpLst,
/* */		int	xinMesh,	/* Input Mesh Size*/
/* */		int 	yinMesh,
/* */		int	outMesh,	/* Output Mesh size */
/* */	struct SMOOTHPRM *prm,
/* */		int	fp)		/* Fixed Point sft-val */
/*
 *	reuturns : 0, -1
 *	Remarks : ̃W[̓͂́A֊sǒʂ̃xN^
 *		@_ƂB
 *		@o͂́Ao̓bVɍ킹邪A_͍ŁA
 *		@x[XCAxAO͒Ȃ
 ***********************************************************************/
{
	int	sts;

       if (!prm)
       {
            sts = -1;
            goto	RET;
       }
	if ( (sts = BindPoint( lstHdl, tmpLst))<0)
		goto	RET;

	if ( (sts = DetectNoSmooth( tmpLst))<0)
		goto	RET;

	if ( (sts = ZoomPoint( tmpLst, xinMesh, yinMesh, outMesh, fp))<0)
		goto	RET;

	if ( (sts = preproc1( tmpLst, lstHdl))<0)
		goto	RET;
	/* */
	if ( prm->UseConic) {
		if ( sts = divVec( lstHdl, tmpLst, 2))
			goto	RET;
		if ( (sts = Smooth1( tmpLst, lstHdl, 1, 2, 1))<0)
			goto	RET;
		
		if ( (sts = Smooth2(  lstHdl, tmpLst))<0)
			goto	RET;
		
		if ( sts = FitConic(tmpLst,lstHdl, prm->SmoothLevel, fp))
			goto	RET;
	}
	else {
		if ( (sts = Smooth1( lstHdl, tmpLst, 1, 2, 1))<0)
			goto	RET;
		if ( (sts = Smooth2( tmpLst, lstHdl))<0)
			goto	RET;
	}
	if ( (sts = DelZeroVec( lstHdl, tmpLst))<0)
		goto	RET;

	if ( (sts = straightCurve( tmpLst, lstHdl))<0)
		goto	RET;

	if ( (sts = DelZeroVec( lstHdl, tmpLst))<0)
		goto	RET;
	sts = BindLinears( tmpLst, lstHdl);


RET:
	return  sts;
}
/***********************************************************************
 *	Bind Same Direction Unit Vector
 */
/* */	static int
/* */	BindVector(
/* */		int inLst, 	/* Absolute Coordinate */
/* */		int outLst)	/* Relative one */
/*
 *	reuturns : 0, -1
 ***********************************************************************/
{
struct VHEAD	*vhd;
struct VDATA	*vp;
struct vecdata	rel, nxtrel;
	int	np;
	int	sts;

	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	VDNew(outLst);

	nxtrel.atr = 1;
	while ( vhd->next!=NIL) {
		/* No point data is not Allowed */
		/* Set Origin */
		vp = vhd->headp;
		if ((sts = VDSetData(outLst, &vp->vd))!=0)
			goto	RET;
		rel.x = rel.y = 0;
		for ( np = 0; np < vhd->nPoints; np++,vp = vp->next) {
			nxtrel.x = vp->next->vd.x - vp->vd.x;
			nxtrel.y = vp->next->vd.y - vp->vd.y;
			if ( rel.x==0 && rel.y ==0)
				rel = nxtrel;
			else  {
				if ( rel.y==0 && nxtrel.y==0)
					rel.x += nxtrel.x;
				else if ( rel.x == 0 && nxtrel.x==0)
					rel.y += nxtrel.y;
				else {
					if ((sts=VDSetData(outLst, &rel))!=0)
						goto	RET;
					rel = nxtrel;
				}
			}
		}
		if ( rel.x!=0 || rel.y!=0) {
			if ((sts=VDSetData(outLst, &rel))!=0)
				goto	RET;
		}
		vhd = vhd->next;
		if ((sts = VDClose(outLst))!=0)
			goto	RET;
	}
RET:
	return( sts);
	
}
/***********************************************************************
 *	Bind Same Direction Unit Vector(Absolute Coodinate Version)
 *		Only for short vector ( dont care SPLINE )
 */
/* */	static int
/* */	BindPoint(
/* */		int inLst, 	/* Absolute Coordinate */
/* */		int outLst)	/* .. */
/*
 *	reuturns : 0, -1
 ***********************************************************************/
{
struct VHEAD	*vhd;
struct VDATA	*vp;
struct vecdata	lastvd;
	int	np;
	int	sts;

	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	VDNew(outLst);

	while ( vhd->next!=NIL) {
		/* No point data is not Allowed */
		/* Set Origin */
		vp = vhd->headp;
		if ((sts = VDSetData(outLst, &vp->vd))!=0)
			goto	RET;
		lastvd = vp->vd;
		for ( np = 0; np < vhd->nPoints; np++,vp = vp->next) {
			if (vp->next->vd.x != lastvd.x && vp->next->vd.y != lastvd.y) {
				if ((sts=VDSetData(outLst, &vp->vd))!=0)
					goto	RET;
				lastvd = vp->vd;
			}
		}
		vhd = vhd->next;
		if ((sts = VDClose(outLst))!=0)
			goto	RET;
	}
RET:
	return( sts);
	
}
/***********************************************************************
 *	Detect Corner and edge
 */
/* */	static int
/* */	DetectNoSmooth(
/* */		int lsthdl)	/* Absolute Coordinate */
/*
 *	returns : 0, -1
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*vp;
	int	np;


	if ( (sts = VDGetHead( lsthdl, &vhd))!=0)
		goto	RET;
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		for ( np = 0; np < vhd->nPoints; np++, vp = vp->next) {
			if (  isturn( vp) )
				turnsort(vp);
			else if (islong (vp))
				longline( vp);
			else	/* based on general rule */
				generalsmooth(vp);
		}
		vhd = vhd->next;
	}
RET:
	return sts;
}
/***********************************************************************
 *	Judge smooth or not at Turning Part
 */
/* */	static void
/* */	turnsort(
/* */		struct VDATA *vp)
/*
 *	returns : none
 ***********************************************************************/
{
struct vecdata	cur, prev1, prev2, next1, next2;

       if (!vp)
       {
           return;
       }
	cur.x = vp->vd.x-vp->prev->vd.x;
	cur.y = vp->vd.y-vp->prev->vd.y;
	prev1.x = vp->prev->vd.x-vp->prev->prev->vd.x;
	prev1.y = vp->prev->vd.y-vp->prev->prev->vd.y;
	prev2.x = vp->prev->prev->vd.x-vp->prev->prev->prev->vd.x;
	prev2.y = vp->prev->prev->vd.y-vp->prev->prev->prev->vd.y;
	next1.x = vp->next->vd.x - vp->vd.x;
	next1.y = vp->next->vd.y - vp->vd.y;
	next2.x = vp->next->next->vd.x - vp->next->vd.x;
	next2.y = vp->next->next->vd.y - vp->next->vd.y;

	if ( cur.x) {
		if ( abs(next1.y) > 1)
			vp->vd.atr |= NOSMOOTH ;
		else if ( sign( cur.x) == sign( next2.x))
			vp->vd.atr |= SMOOTH | BACKWARD;
		else
			vp->vd.atr |= NOSMOOTH;
		if ( abs(prev1.y) > 1)
			vp->prev->vd.atr |= NOSMOOTH ;
		else if (sign(cur.x)==sign(prev2.x))
			vp->prev->vd.atr |= SMOOTH | FOREWARD;
		else
			vp->prev->vd.atr |= NOSMOOTH ;
	}
	else {
		if ( abs(next1.x) > 1)
			vp->vd.atr |= NOSMOOTH ;
		else if ( sign( cur.y) == sign( next2.y))
			vp->vd.atr |= SMOOTH | BACKWARD;
		else
			vp->vd.atr |= NOSMOOTH;
		if ( abs(prev1.x) > 1)
			vp->prev->vd.atr |= NOSMOOTH ;
		else if (sign(cur.y)==sign(prev2.y))
			vp->prev->vd.atr |= SMOOTH | FOREWARD;
		else
			vp->prev->vd.atr |= NOSMOOTH;
	}
	return;
}
/***********************************************************************
 *	Judge Smooth or not with general rule
 */
/* */	static void
/* */	generalsmooth( struct VDATA *vp)
/*
 *	returns : none
 ***********************************************************************/
{
struct vecdata	prev2, prev1, cur, next1, next2, next3;

       if (!vp)
       {
          return;
       }

	cur.x = vp->vd.x- vp->prev->vd.x;
	cur.y = vp->vd.y- vp->prev->vd.y;
	prev1.x = vp->prev->vd.x - vp->prev->prev->vd.x;
	prev1.y = vp->prev->vd.y - vp->prev->prev->vd.y;
	prev2.x = vp->prev->prev->vd.x - vp->prev->prev->prev->vd.x;
	prev2.y = vp->prev->prev->vd.y - vp->prev->prev->prev->vd.y;
	next1.x = vp->next->vd.x - vp->vd.x;
	next1.y = vp->next->vd.y - vp->vd.y;
	next2.x = vp->next->next->vd.x - vp->next->vd.x;
	next2.y = vp->next->next->vd.y - vp->next->vd.y;
	next3.x = vp->next->next->next->vd.x - vp->next->next->vd.x;
	next3.y = vp->next->next->next->vd.y - vp->next->next->vd.y;

	if ( cur.y) {
		if ( abs(next1.x)>1 && abs(cur.y)>1) {
			if ( sign(cur.y) == sign(next1.x)
			   && abs(next2.y)==1
			   && abs(prev1.x)==1
			   && sign(cur.y)==sign(prev2.y)
			   && sign(next1.x)==sign( next3.x))
				;
			else
				vp->vd.atr |= NOSMOOTH;
		}
	}
	else {
		if ( abs(next1.y)>1 && abs(cur.x)>1) {
			if ( sign(cur.x) != sign(next1.y)
			   && abs(next2.x)==1
			   && abs(prev1.y)==1
			   && sign(cur.x)==sign(prev2.x)
			   && sign(next1.y)==sign( next3.y))
				;
			else
				vp->vd.atr |= NOSMOOTH;
		}
	}
	return;
}
/***********************************************************************
 *	Judge turning
 */
/* */	static int
/* */	isturn( struct VDATA	*vp)		/* Absolute */
/*
 *	retuns
 ***********************************************************************/
{
	int	turnSort=0;
struct vecdata	prev, cur, next;

        if (!vp)
       {
          return turnSort;
       }
	prev.x = vp->prev->vd.x - vp->prev->prev->vd.x;
	prev.y = vp->prev->vd.y - vp->prev->prev->vd.y;
	cur.x = vp->vd.x - vp->prev->vd.x;
	cur.y = vp->vd.y - vp->prev->vd.y;
	next.x = vp->next->vd.x - vp->vd.x;
	next.y = vp->next->vd.y - vp->vd.y;

	if ( prev.x !=0) {
		if ( sign(prev.x )!=sign(next.x )) {
			if (sign(next.x ) ==sign(cur.y))
				turnSort = TURN_TOTSU;
			else
				turnSort = TURN_OU;
		}
		else	turnSort = 0;
	}
	else {
		if ( sign(prev.y )!=sign(next.y )) {
			if (sign(next.y ) ==sign(cur.x))
				turnSort = TURN_OU;
			else
				turnSort = TURN_TOTSU;
		}
		else	turnSort = 0;
	}
	return	turnSort;
}

/***********************************************************************
 *	judge Long Line or Not
 */
/* */	static int
/* */	islong( struct VDATA *vp)
/*
 *	returns : 0, 1
 ***********************************************************************/
{
struct vecdata	cur, prev1, prev2, next1, next2;
	int	sts;

       if (!vp)
       {
          return (0);
       }
	cur.x = vp->vd.x - vp->prev->vd.x;
	cur.y = vp->vd.y - vp->prev->vd.y;
	if ( abs(cur.x)<= LONGMIN && abs(cur.y) <= LONGMIN)
		return( 0);
	prev2.x = vp->prev->prev->vd.x - vp->prev->prev->prev->vd.x;
	prev2.y = vp->prev->prev->vd.y - vp->prev->prev->prev->vd.y;
	prev1.x = vp->prev->vd.x - vp->prev->prev->vd.x;
	prev1.y = vp->prev->vd.y - vp->prev->prev->vd.y;
	next1.x = vp->next->vd.x - vp->vd.x;
	next1.y = vp->next->vd.y - vp->vd.y;
	next2.x = vp->next->next->vd.x - vp->next->vd.x;
	next2.y = vp->next->next->vd.y - vp->next->vd.y;
	if ( cur.x) {
		if ( (sign(cur.x) != sign(next2.x)
			|| abs(next1.y)>1
			|| ( abs(next1.y)==1 && abs(cur.x)/2 > abs(next2.x)))
		 && (sign(cur.x) != sign(prev2.x)
			|| abs(prev1.y)>1
			|| ( abs(prev1.y)==1 && abs(cur.x)/2 > abs(prev2.x))))
			sts = 1;
		/* 94.11.09 */
                else if ( abs(cur.x) > 2 && (abs(next1.y)>2 || abs(prev1.y)>2))
			sts = 1;
		/* */
		else	sts = 0;
	}
	else {
		if ( (sign(cur.y) != sign(next2.y)
			|| abs(next1.x)>1
			|| ( abs(next1.x)==1 && abs(cur.y)/2 > abs(next2.y)))
		 && (sign(cur.y) != sign(prev2.y)
			|| abs(prev1.x)>1
			|| ( abs(prev1.x)==1 && abs(cur.y)/2 > abs(prev2.y))))
			sts = 1;
		/* 94.11.09 */
                else if ( abs(cur.y) > 2 && (abs(next1.x)>2 || abs(prev1.x)>2))
			sts = 1;
		/* */
		else	sts = 0;
	}
	return sts;
}
/***********************************************************************
 *	judge Long Line or Not
 */
/* */	static void
/* */	longline( struct VDATA *vp)
/*
 *	returns : 0, 1
 ***********************************************************************/
{
struct vecdata	cur, prev1, prev2, next1, next2;

       if (!vp)
       {
          return;
       }
	prev2.x = vp->prev->prev->vd.x - vp->prev->prev->prev->vd.x;
	prev2.y = vp->prev->prev->vd.y - vp->prev->prev->prev->vd.y;
	prev1.x = vp->prev->vd.x - vp->prev->prev->vd.x;
	prev1.y = vp->prev->vd.y - vp->prev->prev->vd.y;
	cur.x = vp->vd.x - vp->prev->vd.x;
	cur.y = vp->vd.y - vp->prev->vd.y;
	next1.x = vp->next->vd.x - vp->vd.x;
	next1.y = vp->next->vd.y - vp->vd.y;
	next2.x = vp->next->next->vd.x - vp->next->vd.x;
	next2.y = vp->next->next->vd.y - vp->next->vd.y;

	if ( cur.x) {
		/* O */
		if ( abs(next1.y)!=1 || sign(cur.x)!=sign(next2.x))
			vp->vd.atr |= NOSMOOTH;
		else if ( abs( next2.x) ==1 && sign(cur.x)==sign(next1.y))
			vp->vd.atr |= NOSMOOTH;
		else
			vp->vd.atr |= NOSMOOTH | BACKWARD;
		/*  */
		if ( abs(prev1.y)!=1 || sign(cur.x)!=sign(prev2.x))
			vp->prev->vd.atr |= NOSMOOTH;
		else if ( abs( prev2.x) ==1&& sign(cur.x)!=sign(prev1.y))
			vp->prev->vd.atr |= NOSMOOTH;
		else
			vp->prev->vd.atr |= NOSMOOTH | FOREWARD;
	}
	else {
		/* O */
		if ( abs(next1.x)!=1 || sign(cur.y)!=sign(next2.y))
			vp->vd.atr |= NOSMOOTH;
		else if ( abs( next2.y) ==1 && sign(cur.y)!=sign(next1.x))
			vp->vd.atr |= NOSMOOTH;
		else
			vp->vd.atr |= NOSMOOTH | BACKWARD;
		/*  */
		if ( abs(prev1.x)!=1 || sign(cur.y)!=sign(prev2.y))
			vp->prev->vd.atr |= NOSMOOTH;
		else if ( abs( prev2.y) ==1&& sign(cur.y)==sign(prev1.x))
			vp->prev->vd.atr |= NOSMOOTH;
		else
			vp->prev->vd.atr |= NOSMOOTH | FOREWARD;
	}
}
/***********************************************************************
 *	Zoom for fixed point
 */
/* */	static int
/* */	ZoomPoint(
/* */		int	lstHdl,		/* List Handle to proccess */
/* */		int	xinMesh,	/* INPut Dot Mesh */
/* */		int	yinMesh,
/* */		int	outMesh,	/* output mesh (256) */
/* */		int	uFp)		/* Under Fixed Point Value */
/*
 *	returns : none
 *	remarks : ʂ̍WńA(128,128)[=outMesh/2]_ɈړA
 *		@UFp|lł
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*vp;
	int	np;
	int	center;

	center = outMesh/2*uFp;

	if ( (sts = VDGetHead( lstHdl, &vhd))!=0)
		goto	RET;
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		for ( np = 0; np < vhd->nPoints; np++, vp = vp->next) {
			vp->vd.x =(short)((long)vp->vd.x*outMesh*uFp/xinMesh)-center;
			vp->vd.y =(short)((long)vp->vd.y*outMesh*uFp/yinMesh)-center;
		}
		vhd = vhd->next;
	}
RET:
	return	sts;
}
/***********************************************************************
 *	Pre-Proc1 of smoothing( divide long vector )
 */
/* */	static int
/* */	preproc1( int inLst, int outLst)
/*
 *	returns : 0. -1
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*vp;
	int	np;
struct vecdata	vd;

	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	VDNew( outLst);
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		for ( np = 0; np < vhd->nPoints; ) {
			if ( vp->vd.atr & FOREWARD) {
				if ( vp->next->vd.atr& BACKWARD) {
					if ((sts = diveachside( vp, outLst))<0)
						goto	RET;
					np++;
					vp = vp->next;
				}
				else {
					if ((sts=divoneside(vp, outLst))<0)
						goto	RET;
				}
			}
			else if ((vp->vd.atr & BACKWARD)
				&& (vp->prev->vd.atr & FOREWARD)==0){

				if ( (sts = divoneside( vp, outLst))<0)
					goto	RET;

			}
			else {	/* only copy */
				vd = vp->vd;
				if ( vp->vd.atr & NOSMOOTH)
					vd.atr = SMOOTHANCHOR;
				if ((sts=VDSetData( outLst, &vd))<0)
					goto	RET;

			}
			np++;
			vp = vp->next;
		}

		if ( (sts = VDClose( outLst))<0)
			break;

		vhd = vhd->next;
	}
RET:
	return sts;
}
/***********************************************************************
 *	Divide Vector from each side( for PreProc)
 */
/* */	static int
/* */	diveachside( struct VDATA *vp, int outLst)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
struct vecdata	prev, cur, next1, next2, next3;
struct vecdata	div1, div2;
	int	sts=0;

       if (!vp)
       {
          goto RET;
       }
	prev.x = vp->prev->vd.x - vp->prev->prev->vd.x;
	prev.y = vp->prev->vd.y - vp->prev->prev->vd.y;
	cur.x = vp->vd.x - vp->prev->vd.x;
	cur.y = vp->vd.y - vp->prev->vd.y;
	next1.x = vp->next->vd.x - vp->vd.x;
	next1.y = vp->next->vd.y - vp->vd.y;
	next2.x = vp->next->next->vd.x - vp->next->vd.x;
	next2.y = vp->next->next->vd.y - vp->next->vd.y;
	next3.x = vp->next->next->next->vd.x - vp->next->next->vd.x;
	next3.y = vp->next->next->next->vd.y - vp->next->next->vd.y;
	sts = 0;
	if ( next1.x) {
		if ( (sts = VDSetData( outLst, &vp->vd))<0)
			goto	RET;
		div1.y = vp->vd.y;
		div2.y = vp->vd.y;
		div1.atr = SMOOTHANCHOR;
		div2.atr = SMOOTHANCHOR;
		if ( abs(prev.x) + abs( next3.x) <= abs(next1.x)) {
			div1.x = vp->vd.x + prev.x;
			if ( (sts = VDSetData( outLst, &div1))<0)
				goto	RET;
			div2.x = vp->next->vd.x - next3.x;
			if ( (sts = VDSetData( outLst, &div2))<0)
				goto	RET;
			if ( (sts = VDSetData( outLst, &vp->next->vd))<0)
				goto	RET;
		}
		else {
			div1.x = (short)((long)next1.x*abs(prev.x)/abs(prev.x + next3.x));
			if ( div1.x != 0) {
				div1.x += vp->vd.x;
				if ( (sts = VDSetData( outLst, &div1))<0)
					goto	RET;
				if ( (sts = VDSetData( outLst, &vp->next->vd))<0)
					goto	RET;
			}
			else {
				div1.x = vp->next->vd.x;
				div1.y = vp->next->vd.y;
				if ( (sts = VDSetData( outLst, &div1))<0)
					goto	RET;
			}
		}
	}
	else {
		div1.x = vp->vd.x;
		div2.x = vp->vd.x;
		div1.atr = SMOOTHANCHOR;
		div2.atr = SMOOTHANCHOR;
		if ( (sts = VDSetData( outLst, &vp->vd))<0)
			goto	RET;
		if ( abs(prev.y) + abs( next3.y) <= abs(next1.y)) {
//			div1.y = vp->vd.y + prev.y;
			div1.y = vp->vd.y + prev.y/2;
			if ( (sts = VDSetData( outLst, &div1))<0)
				goto	RET;
//			div2.y = vp->next->vd.y - next3.y;
			div2.y = vp->next->vd.y - next3.y/2;
			if ( (sts = VDSetData( outLst, &div2))<0)
				goto	RET;
			if ( (sts = VDSetData( outLst, &vp->next->vd))<0)
				goto	RET;
		}
		else {
			div1.y = (short)((long)next1.y*abs(prev.y)/abs(prev.y + next3.y));
			if ( div1.y!=0) {
				div1.y += vp->vd.y;
				if ( (sts = VDSetData( outLst, &div1))<0)
					goto	RET;
				if ( (sts = VDSetData( outLst, &vp->next->vd))<0)
					goto	RET;
			}
			else {
				div1.x = vp->next->vd.x;
				div1.y = vp->next->vd.y;
				if ( (sts = VDSetData( outLst, &div1))<0)
					goto	RET;
			}
		}
	}
RET:
	return( sts);
}
/***********************************************************************
 *
 */
/* */	static int
/* */	divoneside(
/* */	struct VDATA	*vp,
/* */		int	outLst)
/*
 *
 ***********************************************************************/
{
struct vecdata	prev, cur, next1, next2;
struct vecdata	div1;
	int	sts;

	sts = 0;

       if (!vp)
       {
          goto RET;
       }
	div1.atr = SMOOTHANCHOR;
	if ( vp->vd.atr & FOREWARD) {
		if ( (sts = VDSetData( outLst, &vp->vd))<0)
			goto	RET;
		prev.x = vp->prev->vd.x - vp->prev->prev->vd.x;
		prev.y = vp->prev->vd.y - vp->prev->prev->vd.y;
		cur.x = vp->vd.x - vp->prev->vd.x;
		cur.y = vp->vd.y - vp->prev->vd.y;
		next1.x = vp->next->vd.x - vp->vd.x;
		next1.y = vp->next->vd.y - vp->vd.y;

		if ( vp->vd.x == vp->prev->vd.x) {
			if ( abs(prev.x) < abs(next1.x)) {
				div1.y = vp->vd.y;
//				div1.x = vp->vd.x + prev.x;
				div1.x = vp->vd.x + prev.x/2;
				if ( (sts = VDSetData( outLst, &div1))<0)
					goto	RET;
			}
		}
		else {
			if ( abs(prev.y) < abs(next1.y)) {
				div1.x = vp->vd.x;
//				div1.y = vp->vd.y + prev.y;
				div1.y = vp->vd.y + prev.y/2;
				if ( (sts = VDSetData( outLst, &div1))<0)
					goto	RET;
			}
		}
	}
	else {
		cur.x = vp->vd.x - vp->prev->vd.x;
		cur.y = vp->vd.y - vp->prev->vd.y;
		next2.x = vp->next->next->vd.x - vp->next->vd.x;
		next2.y = vp->next->next->vd.y - vp->next->vd.y;
		if ( vp->vd.x == vp->next->vd.x) {
			if ( abs(cur.x) > abs(next2.x)) {
//				div1.x = vp->vd.x - next2.x;
				div1.x = vp->vd.x - next2.x/2;
				div1.y = vp->vd.y;
				if ( (sts = VDSetData( outLst, &div1))<0)
					goto	RET;
			}
		}
		else {
			if ( abs(cur.y) > abs(next2.y)) {
				div1.x = vp->vd.x;
//				div1.y = vp->vd.y - next2.y;
				div1.y = vp->vd.y - next2.y/2;
				if ( (sts = VDSetData( outLst, &div1))<0)
					goto	RET;
			}
		}
		if ( (sts = VDSetData( outLst, &vp->vd))<0)
			goto	RET;
	}
RET:
	return( sts);
}
/***********************************************************************
 *	Smoothing 1
 */
/* */	static int
/* */	Smooth1( int	inLst,
/* */		int	outLst,
/* */		int	weight1,		/* Waight of Smoothing Form.*/
/* */		int	weight2,
/* */		int	weight3	)
/*
 *	returns : 0,  -1
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*svp, *evp;
	int	sp, ep;

	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	VDNew( outLst);
	while ( vhd->next != NIL) {
	    svp = vhd->headp;
	    if ((sp=searchanchor(0,svp,&svp,vhd->nPoints))<vhd->nPoints){
			
		while(sp <vhd->nPoints) {
			ep = searchanchor(sp+1, svp->next,&evp, vhd->nPoints);
			if ((sts=smooth1sub( svp, ep-sp,outLst,weight1, weight2, weight3))<0)
				goto	RET;
			if ( ep >= vhd->nPoints)
				break;
			sp = ep;
			svp = evp;
		}
	    }
	    vhd = vhd->next;
	    if ( (sts = VDClose( outLst)) < 0)
		break;
	}
RET:
	return	sts;
}
/***********************************************************************
 *	Smoothing 2 ( mabiki)
 */
/* */	static int
/* */	Smooth2( int inLst, int outLst )
/*
 *	returns : 0,  -1
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*svp, *evp;
	int	sp, ep;

	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	VDNew( outLst);
	while ( vhd->next != NIL) {
	    svp = vhd->headp;
	    if ((sp=searchanchor(0,svp,&svp,vhd->nPoints))<vhd->nPoints){
			
		while(sp <vhd->nPoints) {
			ep = searchanchor(sp+1, svp->next,&evp, vhd->nPoints);
			if ((sts=smooth2sub( svp, ep-sp,outLst))<0)
				goto	RET;
			if ( ep >= vhd->nPoints)
				break;
			sp = ep;
			svp = evp;
		}
	    }
	    vhd = vhd->next;
	    if ( (sts = VDClose( outLst)) < 0)
		break;
	}
RET:
	return	sts;
}
/***********************************************************************
 *	Search Smoothing Anchor Point
 */
/* */	int
/* */	searchanchor(
/* */		int	sn,
/* */	struct VDATA	*sp,
/* */	struct VDATA	**ep,
/* */		int	lim)
/*
 *
 ***********************************************************************/
{
      if ( (!sp) || (!ep))
      {
          return 0;
      }
	while ( lim-- > 0) {
		if (sp->vd.atr & SMOOTHANCHOR) {
			*ep = sp;
			return	sn;
		}
		sp = sp->next;
		sn++;
	}
	return( sn);
}
/***********************************************************************
 *	Smooth1 body
 */
/* */	static int
/* */	smooth1sub(
/* */	struct VDATA	*vp,
/* */		int	np,
/* */		int	outLst,
/* */		int	w1,		/* Waight of Smoothing Form.*/
/* */		int	w2,
/* */		int	w3)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	int	pcnt,
		sts=-1;
struct vecdata	vd;
	int	base;

       if (!vp)
       {
          goto	RET;;
       }
	if ( (sts = VDSetData( outLst, &vp->vd))<0)
		goto	RET;
	np--;
	vp = vp->next;
	base = w1 + w2 + w3;
	for ( pcnt = 0; pcnt < np; pcnt++, vp= vp->next) {
		vd.x = (vp->prev->vd.x*w1 + vp->vd.x*w2 + vp->next->vd.x*w3)/base;
		vd.y = (vp->prev->vd.y*w1 + vp->vd.y*w2 + vp->next->vd.y*w3)/base;
		vd.atr = vp->vd.atr;
		if ( (sts = VDSetData( outLst, &vd))<0)
			break;
	}
RET:
	return( sts);
}
/***********************************************************************
 *	Smooth2 body ( mabiki body)
 */
/* */	static int
/* */	smooth2sub(
/* */	struct VDATA	*vp,
/* */		int	np,
/* */		int	outLst)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	int	pcnt,
		sts=-1;
       
       if (!vp)
       {
          goto	RET;;
       }
      
	if ( (sts = VDSetData( outLst, &vp->vd))<0)
		goto	RET;
	np--;
	vp = vp->next;
	for ( pcnt = 0; pcnt < np; pcnt++, vp= vp->next) {
		if ( np < 3 || pcnt % 2 == 0) {
			if ( (sts = VDSetData( outLst, &vp->vd))<0)
				break;
		}
	}
RET:
	return( sts);
}
/***********************************************************************
 *	Remove Fixed Point
 */
/* */	int
/* */	RemoveFp(
/* */		int	lstHdl,		/* List Handle to proccess */
/* */		int	outMesh,	/* output mesh */
/* */		int	uFp)		/* Under Fixed Point Value */
/*
 *	returns : none
 *	remarks : X[YBȌʂ̍WńAUFpŊČ_
 *		  (128,128) [=outMesh/2]Ɉړlł
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*vp;
	int	center;
	int	np;

	center = outMesh/2;

	if ( (sts = VDGetHead( lstHdl, &vhd))!=0)
		goto	RET;
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		for ( np = 0; np < vhd->nPoints; np++, vp = vp->next) {
			vp->vd.x = vp->vd.x / uFp+center;
			if ( vp->vd.x < 0)	vp->vd.x = 0;
			else if  ( vp->vd.x >= outMesh)	vp->vd.x = outMesh-1;

			vp->vd.y = vp->vd.y / uFp+center;
			if ( vp->vd.y < 0)	vp->vd.y = 0;
			else if  ( vp->vd.y >= outMesh)	vp->vd.y = outMesh-1;
		}
		vhd = vhd->next;
	}
RET:
	return sts;
}

/***********************************************************************
 *	Bind same direction vector
 */
/* */	static int
/* */	BindLinears( int inLst, int outLst)
/*
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*vp;
	int	np;
struct vecdata	rel1, rel2;

	VDNew( outLst);
	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		/* Origin */
		if ( (sts = VDSetData( outLst, &vp->vd))<0)
			goto	RET;
		vp = vp->next;
		for ( np = 1; np < vhd->nPoints; np++, vp = vp->next) {
			if ( np+1 >= vhd->nPoints) {
				if ((sts=VDSetData( outLst, &vp->vd))<0)
					goto	RET;
				break;
			}
			else if ( vp->vd.atr&SPLINE_ATR) {

				if ((sts=VDSetData( outLst, &vp->vd))<0)
					goto	RET;
				/* End Point */
				vp = vp->next;
				np++;
				if ( np >= vhd->nPoints)
					break;
				if ( (sts = VDSetData( outLst, &vp->vd))<0)
					goto	RET;
			}
			else {
			    rel1.x = vp->next->vd.x - vp->vd.x;
			    rel1.y = vp->next->vd.y - vp->vd.y;
			    rel2.x = vp->vd.x - vp->prev->vd.x;
			    rel2.y = vp->vd.y - vp->prev->vd.y;
			    if ( (vp->next->vd.atr & SPLINE_ATR )
				|| (long)rel1.x*rel2.y != (long)rel1.y*rel2.x) {
				if ( (sts = VDSetData( outLst, &vp->vd))<0)
					goto	RET;
			    }
			}
		}
		if ( (sts = VDClose( outLst))<0)
			goto	RET;
		vhd = vhd->next;
	}
RET:
	return( sts);
}
/***********************************************************************
 *	Deleate Zero Vector ( about Non Curve Part)
 */
/* */	static int
/* */	DelZeroVec( int inLst, int outLst)
/*
 ***********************************************************************/
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*vp;
	int	np;

	VDNew( outLst);
	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		/* Origin */
		if ( (sts = VDSetData( outLst, &vp->vd))<0)
			goto	RET;
		vp = vp->next;
		for ( np = 1; np < vhd->nPoints; np++, vp = vp->next) {
			if ( vp->vd.atr&SPLINE_ATR) {
				/* Control Point */
				if ( (sts = VDSetData( outLst, &vp->vd))<0)
					goto	RET;
				/* End Point */
				vp = vp->next;
				np++;
				if ( np >= vhd->nPoints)
					break;
				if ( (sts = VDSetData( outLst, &vp->vd))<0)
					goto	RET;
			}
			else {
				if ( vp->vd.x != vp->prev->vd.x
					   || vp->vd.y != vp->prev->vd.y) {
					if ((sts=VDSetData( outLst, &vp->vd))<0)
						goto	RET;
				}
			}
		}
		if ( (sts = VDClose( outLst))<0)
			goto	RET;
		vhd = vhd->next;
	}
RET:
	return( sts);
}
/*		X			  |Y
 *	O------------		     	+-|------+
 *	|	|			| |	 |
 *	|	|	---> 		| |	 |
 *	|	|		     -----+-------------X
 *	|-------+			O-|------+
 *	|Y				  |
 */
int
toTTFFrame( int lstH, struct BBX *bbx)
{
struct VHEAD	*vhd;
struct VDATA	*vp;
	int	np;
	int	sts=-1;
	short	mesh;

       if (!bbx)
       {
           goto	RET;
       }
       
	if ( (sts = VDGetHead( lstH, &vhd))!=0)
		goto	RET;
	if ( (sts = VDGetNCont( lstH))<=0)
		goto	RET;
	mesh = bbx->xMax - bbx->xMin+1;
	if ( mesh > bbx->yMax - bbx->yMin)
		mesh = bbx->yMax - bbx->yMin+1;
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		np = vhd->nPoints;
		while ( np-->0) {
			vp->vd.x += (short)bbx->xMin;
			vp->vd.y = (mesh - 1) - vp->vd.y + bbx->yMin;
			/* Limit in BBX */
			if ( vp->vd.x > bbx->xMax)
				vp->vd.x = (short)bbx->xMax;
			else if (vp->vd.x < bbx->xMin)
				vp->vd.x = (short)bbx->xMin;
			if ( vp->vd.y > bbx->yMax)
				vp->vd.y = (short)bbx->yMax;
			else if (vp->vd.y < bbx->yMin)
				vp->vd.y = (short)bbx->yMin;
			vp = vp->next;
		}
		vhd = vhd->next;
	}
	sts = 0;
RET:
	return sts;
}
static int
lightSub( int inLst, int outLst)
{
struct VHEAD	*vhd;
	int	sts;
struct VDATA	*svp, *evp;
	int	sp, ep;
	if ( (sts = VDGetHead( inLst, &vhd))!=0)
		goto	RET;
	VDNew( outLst);
	while ( vhd->next != NIL) {
	    svp = vhd->headp;
	    if ((sp=searchanchor(0,svp,&svp,vhd->nPoints))<vhd->nPoints){
			
		while(sp <vhd->nPoints) {
			ep = searchanchor(sp+1, svp->next,&evp, vhd->nPoints);
			if ((sts=smooth1sub( svp, ep-sp,outLst,1, 2, 1))<0)
				goto	RET;
			if ( ep >= vhd->nPoints)
				break;
			sp = ep;
			svp = evp;
		}
	    }
	    vhd = vhd->next;
	    if ( (sts = VDClose( outLst)) < 0)
		break;
	}
RET:
	return	sts;
}
static int
divVec( int ilst, int olst, int divN)
{
struct VHEAD	*vhd;
struct VDATA	*vp;
struct vecdata	rel, vd;
	int	np;
	int	n;

	if ( VDGetHead( ilst, &vhd)!=0)
		goto	RET;
	VDNew( olst);
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		np = vhd->nPoints;
		while ( np-->0) {
			if (VDSetData(olst, &vp->vd))
				goto	RET;
			rel.x = vp->next->vd.x - vp->vd.x;
			rel.y = vp->next->vd.y - vp->vd.y;
			vd.atr = 0;
			for ( n=1; n<divN; n++) {
				vd.x = vp->vd.x+rel.x*n/divN;
				vd.y = vp->vd.y+rel.y*n/divN;
				if (VDSetData(olst, &vd))
					goto	RET;
			}
			vp = vp->next;
		}
		vhd = vhd->next;
		VDClose( olst);
	}
	return 0;
RET:
	return -1;
}
int
SmoothLight( int ioLst, int tmpLst, int width, int height, int oWidth, int ufpVal)
{
	int	sts;

	if ( (sts = BindPoint( ioLst, tmpLst))<0)
		goto	RET;
	if ( (sts = DetectNoSmooth( tmpLst))<0)
		goto	RET;
	if ( (sts = ZoomPoint( tmpLst, width, height, oWidth, ufpVal))<0)
		goto	RET;
	if ( (sts = preproc1( tmpLst, ioLst))<0)
		goto	RET;


	if ( sts = divVec( ioLst, tmpLst, 2))
		goto	RET;
	if ( lightSub( tmpLst, ioLst))
		goto	RET;
	if ( lightSub( ioLst, tmpLst))
		goto	RET;

	if ( RemoveFp( tmpLst, oWidth, ufpVal))
		goto	RET;
	if ( (sts = DelZeroVec( tmpLst, ioLst))<0)
		goto	RET;
	return 0;
RET:
	return -1;
}
int
ConvMesh( int lstH, int inMesh, int outMesh)
{
struct VHEAD	*vhd;
struct VDATA	*vp;
	int	np;
	int	sts;
	if ( inMesh==outMesh)
		return 0;
	if ( (sts = VDGetHead( lstH, &vhd))!=0)
		goto	RET;
	if ( (sts = VDGetNCont( lstH))<=0)
		goto	RET;
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		np = vhd->nPoints;
		while ( np-->0) {
			vp->vd.x = (int)((long)vp->vd.x*outMesh/inMesh);
			vp->vd.y = (int)((long)vp->vd.y*outMesh/inMesh);
			vp = vp->next;
		}
		vhd = vhd->next;
	}
	sts = 0;
RET:
	return sts;
}
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\rotatdlg.h ===
/**************************************************/
/*					                              */
/*					                              */
/*	Rotate bimap in Edit window	                  */
/*					                              */
/*					                              */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#define		NOTSEL		0
#define		FLIP_HOR	1
#define		FLIP_VER	2
#define		ROTATE_9	3
#define		ROTATE_18	4
#define		ROTATE_27	5

class CRotateDlg : public CDialog
{
public:
	CRotateDlg(CWnd* pParent = NULL);   // standard constructor

	//{{AFX_DATA(CRotateDlg)
	enum { IDD = IDD_ROTATECHAR };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	//{{AFX_VIRTUAL(CRotateDlg)
	protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

public:
	int	RadioItem;

protected:

	//{{AFX_MSG(CRotateDlg)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnFliphor();
	afx_msg void OnFlipver();
	afx_msg void OnRotate180();
	afx_msg void OnRotate270();
	afx_msg void OnRotate90();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\stdafx.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//
#include <afxwin.h>         // MFC core and standard components
#include <afxcmn.h>         // for tooltips
#include <afxext.h>         // MFC extensions (including VB)
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxpriv.h>
#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\vdata.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//

#define		LISTDATAMAX	4
#define		NIL		((void *)0)
struct vecdata	{
	short	x, y, atr, dummy;
	};

struct VDATA	{
	struct VDATA	*next, *prev;
	struct vecdata	vd;
	};

struct VHEAD	{
	struct VHEAD	*next, *prev;
	struct VDATA	*headp;
	int		nPoints;
	};
struct VCNTL	{
	struct VHEAD	*rootHead;
	struct VHEAD	*currentHead;
	int		nCont;
	struct VDATA	*cvp;
	int	mendp;
	void	*memroot;
	void	*cmem;
	};


int  VDInit(void);
void  VDTerm(void);
void  VDNew(int  lsthdl);
int  VDClose(int  lsthdl);
int  VDSetData(int  lsthdl,struct  vecdata *pnt);
int  VDGetHead(int  lsthdl,struct  VHEAD * *vhd);
int  VDGetNCont(int  lsthdl);
int  VDReverseList(int  lsthdl);
int  VDCopy(int  srcH, int dstH);

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\ttfstruc.h ===
/*
 *	TrueType File Format Structure Definitions
 *
 * Copyright (c) 1997-1999 Microsoft Corporation.
 */
/*  Whole :
	+-----------------------+
	| Header		|
	+-----------------------+
	| Tables		|
	|			|
		    |
	|			|
	+-----------------------+
    Header :
	----------------------------------------------------------
	  Fixed		sfnt version	0x00010000
	  ushort	numTables	Number of tables
	  ushort	searchRange	(n^2 <= numtables)*16
	  ushort	entrySelector	Log2(n^2<=numTables)
	  ushort	rangeShift	NumTables*16-searchRange
	     Table Directory Entries
	----------------------------------------------------------
    Table Directory:
	----------------------------------------------------------
	  ulong		tag		4-byte idetifier
	  ulong		checkSum	CheckSum for this table
	  ulong		offset		offset from beginning of
					TrueType font file
	  ulong		length		Length of this table
	----------------------------------------------------------

    Tables:
	----------------------------------------------------------
	  cmap		character to glyph mapping
	  glyf		glyph data
	  head		font header
	  hhea		horizontal header
	  hmtx		hosizontal metrics
	  loca		index to location
	  maxp		maximum profile
	  name		naming table
	  post		PostScript information
	  OS/2		OS/2 and Windows specific metrics
		--------------------------
	  cvt		Control Value Table
	  fpgm		font program
	  hdmx		hosizontal device metrics
	  kern		kerning
	  LTSH		Linear threshold table
	  prep		CVT Program
	  WIN 		(reserved)
	  VDMX		Vertical Device Metrics table
	  FOCA		Reserved for IBM Font Object Content Architecture data
	  PCLT		PCL 5 table
	  mort		glyph metamorphosis table
		--------------------------
	  vhea		Vertical Header table
	  vmtx		Vertical metrics table
	----------------------------------------------------------
*/
#define		TAGSIZ	4
struct TTFHeader {
	char	sfnt_version[4];
	short	numTables;
	short	searchRange;
	short	entrySelector;
	short	rangeShift;
	};
struct TableEntry {
	char	tagName[TAGSIZ];
	unsigned long	checkSum;
	long	ofs;
	long	siz;
	};


/***
 *	cmap
 ***/
struct CmapHead {
	short	version;
	short	nTbls;
	};

struct CmapEncodingTbl {
	short	PlatformID;
	short	PlatformSpecEncID;
	long	ofs;
	};

struct CmapSubtable {
	short	format;
	short	length;
	short	version;
	short	segCnt2;
	short	searchRange;
	short	rangeShift;
	short	endCnt[2];
	short	reservedPad;
	short	startCnt[2];
	short	idDelta[2];
	short	idRangeOfs[2];
	};
/***
 *	maxp
 ***/
struct MaxpTbl {
	char	version[4];
	short	numGlyph;
	short	maxPoints;
	short	maxContours;
	short	maxCompositePoints;
	short	maxCompositeContours;
	short	maxZones;
	short	maxTwilightPoints;
	short	maxStorage;
	short	maxFunctionDefs;
	short	maxInstructiondefs;
	short	maxStackElements;
	short	maxSizeOfInstructions;
	short	maxComponentElements;
	short	maxComponentDepth;
	};
/***
 *	name
 ***/
struct NamingTable {
	short	FormSel;
	short	NRecs;
	short	OfsToStr;
	/* Following NameRecords */
	};
struct NameRecord {
	short	PlatformID;
	short	PlatformSpecEncID;
	short	LanguageID;
	short	NameID;
	short	StringLength;
	short	StringOfs;
	};
/***
 *	head
 ***/
struct HeadTable {
	char	version[4];		/* 0x00010000 */
	char	revision[4];
	unsigned long	chkSum;
	unsigned long	magicNumber;	/* 0x5F0F3CF5 */
	short	flags;
	short	unitsPerEm;
	char	createdDate[8];
	char	updatedDate[8];
	short	xMin;
	short	yMin;
	short	xMax;
	short	yMax;
	short	macStyle;
	short	lowestRecPPEM;
	short	fontDirectionHint;
	short	indexToLocFormat;
	short	glyphDataFormat;	/* 0*/
	};
/***
 *	hhea
 ***/
struct HheaTable	{
	char	version[4];
	short	Ascender;
	short	Descender;
	short	LineGap;
	short	advanceWidthMax;
	short	minLeftSideBearing;
	short	minRightSideBearing;
	short	xMaxExtent;
	short	caretSlopeRise;
	short	caretSlopeRun;
	short	reserved[5];
	short	metricDataFormat;
	short	numberOfHMetrics;
	};
/***
 *	hmtx
 ***/
 struct HMetrics {
	short	advanceWidth;
	short	leftSideBearing;
	};
/***
 *	vhea
 ***/
struct VheaTable	{
	char	version[4];
	short	Ascender;
	short	Descender;
	short	LineGap;
	short	advanceHeightMax;
	short	minTopSideBearing;
	short	minBottomSideBearing;
	short	yMaxExtent;
	short	caretSlopeRise;
	short	caretSlopeRun;
	short	caretOffset;
	short	reserved[4];
	short	metricDataFormat;
	short	numOfLongVerMetrics;
	};
/***
 *	vmtx
 ***/
 struct VMetrics {
	short	advanceHeight;
	short	topSideBearing;
	};
/***
 *	post
 ***/
struct postTable {
	char	FormatType[4];	/* 00030000 */
	long	italicAngle;
	short	underlinePosition;
	short	underlineThickness;
	unsigned long	isFixedPitch;
	unsigned long	minMemType42;
	unsigned long	maxMemType42;
	unsigned long	minMemType1;
	unsigned long	maxMemType1;
	};
/***
 *	OS/2
 ***/
/*
typedef struct {
	char	bFamily;
	char	bSerifStyle;
	char	bWeight;
	char	bProportion;
	char	bContrast;
	char	bStrokeVariation;
	char	bArmStyle;
	char	bLetterform;
	char	bMidline;
	char	bXHeight;
	} PANOSE;
*/
struct OS2Table {
	unsigned short	version;
	short	xAvgCharWidth;
	unsigned short	usWeightClass;
	unsigned short	usWidthClass;
	short	fsType;
	short	ySubscriptXSize;
	short	ySubscriptYSize;
	short	ySubscriptXOffset;
	short	ySubscriptYOffset;
	short	ySuperscriptXSize;
	short	ySuperscriptYSize;
	short	ySuperscriptXOffset;
	short	ySuperscriptYOffset;
	short	yStrikeoutSize;
	short	yStrikeoutPosition;
	short	sFamilyClass;
	PANOSE	panose;
	unsigned long	ulCharRange[4];
	char	achVendID[4];
	unsigned short	fsSelection;
	unsigned short	usFirstCharIndex;
	unsigned short	usLastCharIndex;
	short	sTypoAscender;
	short	sTypoDescender;
	short	sTypoLineGap;
	unsigned short	usWinAscent;
	unsigned short	usWinDescent;
	};
/***
 *	glyf
 ***/
struct glyfHead {
	short	numberOfContour;
	short	xMin, yMin;
	short	xMax, yMax;
	};
/** glyf data flag definition **/
	
#define	GLYF_ON_CURVE	0x01
#define	GLYF_X_SHORT	0x02	/* x is short */
#define	GLYF_Y_SHORT	0x04	/* y is short */
#define	GLYF_X_SHORT_N	0x02	/* x is short & negative */
#define	GLYF_Y_SHORT_N	0x04	/* y is short & negative */
#define	GLYF_X_SHORT_P	0x12	/* x is short & positive */
#define	GLYF_Y_SHORT_P	0x24	/* y is short & positive */
#define	GLYF_REPEAT	0x08
#define	GLYF_X_SAME	0x10
#define	GLYF_Y_SAME	0x20

/***
 *	Bounding Box ( Not for file structure )
 ***/
struct BBX	{
	int	xMin, yMin;
	int	xMax, yMax;
	};

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\stdafx.cpp ===
/**************************************************/
/*					                              */
/*		For MFC			                          */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\util.cpp ===
/**************************************************/
/*					                              */
/*					                              */
/*	EudcEditor Utillity funcs	                  */
/*					                              */
/*                                                */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

#include	"stdafx.h"
#include	"eudcedit.h"
#include	"util.h"

#define STRSAFE_LIB
#include <strsafe.h>

/****************************************/
/*					*/
/*	Output Message function		*/
/*					*/
/****************************************/
int 
OutputMessageBox(
HWND	hWnd,
UINT 	TitleID,
UINT	MessgID,
BOOL	OkFlag)
{
	CString	TitleStr, MessgStr;
	int	mResult;

	TitleStr.LoadString( TitleID);
	MessgStr.LoadString( MessgID);
	if( OkFlag){
		mResult = ::MessageBox( hWnd, MessgStr, TitleStr,
			MB_OK | MB_ICONEXCLAMATION);
	}else{
		mResult = ::MessageBox( hWnd, MessgStr, TitleStr,
			MB_YESNOCANCEL | MB_ICONQUESTION);
	}
	return mResult;
}

#ifdef BUILD_ON_WINNT
int 
OutputMessageBoxEx(
HWND	hWnd,
UINT 	TitleID,
UINT	MessgID,
BOOL	OkFlag,
        ...)
{
	CString	TitleStr, MessgStr;
	int	mResult = 0;
    va_list argList;
    LPTSTR  MessageBody;

    va_start(argList, OkFlag);
	TitleStr.LoadString( TitleID);
	MessgStr.LoadString( MessgID);

    ::FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_STRING,
                     MessgStr,0,0,(LPTSTR)&MessageBody,0,&argList);

    if( MessageBody ) {
    	if( OkFlag){
    		mResult = ::MessageBox( hWnd, MessageBody, TitleStr,
    			MB_OK | MB_ICONEXCLAMATION);
    	}else{
    		mResult = ::MessageBox( hWnd, MessageBody, TitleStr,
    			MB_YESNOCANCEL | MB_ICONQUESTION);
    	}
        ::LocalFree(MessageBody);
    }
	return mResult;
}
#endif // BUILD_ON_WINNT


/****************************************/
/*					*/
/*   	Get String from resource	*/
/*					*/
/****************************************/
void 
GetStringRes( 
LPTSTR 	lpStr, 
UINT 	sID,
int           nLength)
{
	CString	cStr;
	int	StrLength;
	TCHAR 	*Swap;	
       HRESULT hresult;
       
       if (!lpStr)
       {
           return;
       }

	cStr.LoadString( sID);
	StrLength = cStr.GetLength();
	Swap = cStr.GetBuffer(StrLength + 1);
	//*STRSAFE* 	lstrcpy( lpStr, Swap);
	hresult =StringCchCopy(lpStr , nLength,  Swap);
       if (!SUCCEEDED(hresult))
	{	   
	}
	cStr.ReleaseBuffer();
	return;
}

/****************************************/
/*					*/
/*   	Convert String from resource	*/
/*					*/
/****************************************/
void 
ConvStringRes( 
LPTSTR 	lpStr, 
CString	String,
int          nDestSize
)
{
	TCHAR 	*Swap;
	HRESULT hresult;

	int StrLength = String.GetLength();
	Swap = String.GetBuffer(StrLength + 1);
	//*STRSAFE* 	lstrcpy( lpStr, Swap);
	hresult = StringCchCopy(lpStr , nDestSize,  Swap);
	if (!SUCCEEDED(hresult))
	{	   
	}
	String.ReleaseBuffer();
	return;
}

#ifndef UNICODE
char * Mystrrchr(char *pszString, char ch)
{
	CHAR *p1, *p2;
       
       p1 = NULL; 
       if (!pszString)
       {
           return (p1);
       }
	
	for (p2 = pszString; *p2; p2=CharNext(p2))
	{
		if (*p2 == ch)
		{
			p1 = p2;
		}
	}
	return (p1);
}

char * Mystrchr(char *pszString, char ch)
{
	CHAR *p;

       if (!pszString)
       {
           return (NULL);
       }	
	for (p = pszString; *p; p=CharNext(p))
	{
		if (*p == ch)
		{
			return (p);
		}
	}
	return (NULL);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\ttffile.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#include	"stdafx.h"
#include	"eudcedit.h"
#include    "util.h"

#pragma		pack(2)


#include	"vdata.h"
#include	"ttfstruc.h"
#include	"extfunc.h"


#define STRSAFE_LIB
#include <strsafe.h>
/*
 *	TrueType File I/F
 */
#define		GLYPHBUFSIZ	0xFFFFL
#define		RWBUFSIZ	16384

#define		EUDCCODEBASE	((unsigned short)0xE000) /* 0xe000  uni-code */
#define		NUMTABLES	15

#define		NAMEBUFSIZ	1024
#define		NUMOFNAMEREC	8


static void  initDirEntry(struct  TableEntry *e,int  num);
static int  setDirEntry(struct  TableEntry *e,char  *tag);
void  smtoi(short  *sval);
void  lmtoi(long  *lval);
void  sitom(short  *sval);
void  litom(long  *lval);
static int  align32(int  siz);
static unsigned long  calchksum(char  *buf,int  siz);
static int  copyblk(HDC  hDC,char  *tag,int  ofHdl,long  siz,char  *buf,int  bufsiz,unsigned long  *cs);
static int  mergeblock(HDC  hDC,struct  TableEntry *entry,int  ofHdl);
static int  tableChkSum(int  fH,struct  TableEntry *te);
static int  codeToGID(unsigned short  code);
int  TTFReadHdr(HANDLE  fHdl,struct  TTFHeader *hdr);
int  TTFWriteHdr(HANDLE  fHdl,struct  TTFHeader *hdr);
int  TTFReadDirEntry(HANDLE  fHdl,struct  TableEntry *entry,int  eCnt);
int  TTFWriteDirEntry(HANDLE  fHdl,struct  TableEntry *entry,int  eCnt);
static struct  TableEntry *searchEntry(struct  TableEntry *entry,int  eCnt,char  *tag);
int  TTFGetTableEntry(HANDLE  fH,struct  TableEntry *entry,char  *tag);
int  TTFReadTable(HANDLE  fH,struct  TableEntry *entry,void  *buf,int  bufsiz);
int  TTFReadFixedTable(HANDLE  fH,char  *buf,int  bufsiz,char  *tag);
int  TTFReadVarTable(HANDLE  fH,char  * *buf,unsigned int  *bufsiz,char  *tag);
int  TTFWriteTable(HANDLE  fH,struct  TableEntry *entry,void  *buf,int  bufsiz);
int  TTFAppendTable(HANDLE  fH,struct  TableEntry *entry,void  *buf,int  siz);
static int  TTFMergeTable(HDC  hDC,HANDLE  nfh,char  *tag,struct  TableEntry *nte);
#ifdef BUILD_ON_WINNT
static int __cdecl compentry(const void  *e1,const void  *e2);
#else
static int  compentry(const void  *e1,const void  *e2);
#endif // BUILD_ON_WINNT
static void  SortEntry(struct  TableEntry *ebuf,int  num);
static int  fileChkSum(HANDLE  fh,struct  TableEntry *entry,int  numEntry,struct  TTFHeader *hdr,struct  HeadTable *head);
static void  makeTTFHeader(struct  TTFHeader *hdr,int  nTbl);
static int  makeGlyphData(int  lstH,struct  BBX *bbx,char  *glyphData,int  bufsiz,int  *gdatsiz);
static void  initsetgbuf(char  *b,int  lim);
static int  setgbuf(char  *dat,int  siz,char  * *np);
static int  termbuf(void);
static int  strwlen(char  *s);
static void  strwcat(char  *s1,char  *s2);
static void  setnamebuf(char  *buf,int  *siz, short EncodingID);
static void  modifyOS2(char  *buf);
static void  modifyhead(struct  HeadTable *head);
static void  setVhea(struct  VheaTable *vhea,struct  HheaTable *hhea,struct  BBX *bbx);
static int  updateMaxp(struct  MaxpTbl *maxp,int  lstHdl);
static int  TTFGetOrgTableEntry(HDC  hDC,struct  TableEntry *entry,char  *tag);
int  TTFReadOrgFixedTable(HDC  hDC,char  *buf,int  bufsiz,char  *tag);
int  TTFReadOrgVarTable(HDC  hDC,char  * *buf,unsigned int  *bufsiz,char  *tag);
static void  setCountryData(short EncodingID);
static int  WIFEOS2(HDC  hDC,char  * *os2buf,int  *os2TblSiz,struct  BBX *bbx);
static void  WIFEhhea(struct  HheaTable *hhea,struct  BBX *bbx);
static void  WIFEhead(struct  HeadTable *head,struct  BBX *bbx);
static void  WIFEpost(struct  postTable *post);
int  TTFCreate(HDC  hDC,TCHAR  *newf,struct  BBX *bbx,int  lstHdl,int  fontType);
int  TTFGetBBX(HDC  hDC,struct  BBX *bbx,short  *uPEm);
int  TTFTmpPath(TCHAR  *path,TCHAR  *tmpPath);
static int  copyTable(HANDLE iFh,HANDLE oFh,struct  TableEntry *te,int  nEntry,char  *tag);
static int  copyfblock(HANDLE  iFh,HANDLE oFh,unsigned long  siz,unsigned long  *cs);
static int  mergeGlyph(HANDLE  iFh,HANDLE oFh,struct  TableEntry *tep,char  *locabuf,int  glyphID,char  *glyphData,int  glyphSiz);
static void  frebuf(void);
int  TTFOpen(TCHAR  *path);
int  TTFClose(void);
int  TTFGetEUDCBBX(TCHAR  *path,struct  BBX *bbx,short  *upem);
static void  makeMetrics(int  lsthdl,struct  HMetrics *hM,struct  VMetrics *vM,struct  BBX *bbx);
int  TTFAppend(unsigned short  code,struct  BBX *bbx,int  lsthdl);
int  TTFImpCopy(TCHAR  *sPath,TCHAR  *dPath);
int  TTFImpGlyphCopy(HANDLE sFh,int  glyphID);
int  TTFImpGlyphWrite(int  glyphID, char *buf, int siz);
int  TTFLastError();
/**
 * static variables
 **/
static struct TableEntry *et;
static int	entryNum;
static int	entryCnt;

static int	numOfGlyph=0;
static int	lastErr = 0;
/**
 * static table data
 **/
static char	cvtdata[] = {0, 0};
static char	fpgmdata[]={ (char)0xb0, (char)0x00, (char)0x2c, (char)0x2d};
static char	prepdata[]={(char)0xb8, 0x1, (char)0xff, (char)0x85,
				(char)0xb0, (char)0x01, (char)0x8d};
static char	maxpdata[]={	/* JPN */
			0x00, 0x01, 0x00, 0x00,
			(char)0x07, (char)0x5a,	/* 1882  numGlyph of JPN */
			0, 4, 0, 1 ,  		/* maxP, maxC(nullGlyf value)*/
			0, 0,  0, 0,		/* maxCom*2*/
			0, 1,  0, 0,		   /* maxZones, maxTw*/
			0, 0,  0, 1,		   /* maxStorage, maxFunc*/
			0, 0,  0, 1,		   /* maxI, maxStack */
			0, 1,  0, 1,  0, 1
			};
static char	cmapdata[] = {
			0, 0,  0, 1,
			0, 3,  0, 1,
			0, 0,  0, 12,
			0, 4,  0, 32,  0, 0,  0, 4,  0, 4,  0, 1, 0, 0,
			(char)0xe7, (char)0x57, (char) 0xff,(char) 0xff, 	/* last code */
			0, 0,
			(char)0xe0, (char)0x00,  (char)0xff,(char) 0xff,
			0x20, 0x02,  0x00, 0x01,
			0, 0,  0, 0
			};

static char	namerecstr[NUMOFNAMEREC][16] ={
			{ 0, '0', 0, '0', 0, 0},
			{ 0,'E', 0,'U', 0, 'D',0,'C', 0,0},
			{ 0,'R', 0, 'e', 0,'g', 0,'u', 0,'l', 0,'a', 0,'r',0,0},
			{ 0, '0', 0,'0', 0, 0},
			{ 0,'E', 0,'U', 0, 'D',0,'C', 0,0},
			{ 0, '0', 0,'0', 0, 0},
			{ 0, '0',  0,'0',0, 0},
			{ 0, '0',  0,'0',0, 0}
		};


static void
initDirEntry( struct TableEntry *e, int num)
{
	et = e;
	entryNum = num;
	entryCnt = 0;
}
static int
setDirEntry(struct TableEntry *e, char *tag)
{
       if ((!e) || (!tag))
       {
           return -1;
       }
	if ( entryCnt >= entryNum)
		return -1;
	memcpy( e->tagName, tag, TAGSIZ);
	*(et+entryCnt) = *e;
	entryCnt++;

	return 0;
}
void
smtoi( short *sval)
{
	short	retval;
	unsigned char	*cp;

       if (!sval)
       {
          return;
       }
	
	cp = (unsigned char *)sval;
	retval = *cp++;
	retval <<=8;
	retval += *cp;
	*sval = retval;
}
void
lmtoi( long *lval)
{
	long	retval;
	unsigned char	*cp;
	int	i;
      
       if (!lval)
       {
           return;
       }
	cp = (unsigned char *)lval;
	retval = (long)*cp++;
	for(i=0; i<3; i++) {
		retval <<=8;
		retval |= (long)*cp++;
	}
	*lval = retval;
}
void
sitom( short	*sval)
{
	unsigned char *cp;
	short	setval;

       if (!sval)
       {
          return;
       }
	setval = *sval;
	cp = (unsigned char *)sval;
	*cp++ = (unsigned char)((setval>>8)&0xff);
	*cp++ = (unsigned char)(setval&0xff);
}
void
litom( long	*lval)
{
	long	setval;
	int	i;
	unsigned char	*cp;

       if (!lval)
       {
           return;
       }
	setval = *lval;
	cp = (unsigned char *)lval;
	cp += 3;
	for ( i = 0; i<4; i++) {
		*cp--=(char )(setval&0xff);
		setval >>=8;
	}
}
static int
align32( int siz)
{
	siz = (siz + 3)/4 * 4;
	return siz;
}
static unsigned long
calchksum( char *buf, int siz)
{
	unsigned long	*csp;
	unsigned long	chksum;
	unsigned long	lval;
	unsigned char	pad[4];
	int	i;
	int	padsiz;
	unsigned char	*cp;
	int	csc;

      
	csp = (unsigned long *)buf;
	csc = siz/4;
	chksum = 0;
       if (!buf)
       {
           return chksum;
       }
	while ( csc-->0) {
		lval = *csp++;
		lmtoi( (long *)&lval);
		chksum += lval;
	}	
	padsiz = (siz+3)/4*4 - siz;

	if ( padsiz) {
		cp = (unsigned char *)csp;
		i = 0;
		while (padsiz++<4)
			pad[i++]=*cp++;
		csp = (unsigned long *)pad;
		lval = *csp;
		lmtoi( (long *)&lval);
		chksum += lval;
	}
	return	chksum;
}
static int
copyblk(HDC hDC, char *tag, HANDLE ofHdl, long siz, char *buf, int bufsiz, unsigned long *cs)
{
	int	rwsiz;
	int	filsiz;
	int	aligne;
	unsigned long	chksum;
	long	ofs;
	DWORD	dwTable, nByte;

       if (  (!tag) || ( ofHdl==INVALID_HANDLE_VALUE)  || (!buf) ||  (!cs))
       {
           goto ERET;
       }
	dwTable = *(DWORD *)tag;
	filsiz = (int)(siz % 4);
	if ( filsiz)	filsiz = 4-filsiz;
	ofs = 0L;
	aligne =0;
	chksum = 0;
	while ( siz > 0) {
		if ( siz > bufsiz)
			rwsiz = bufsiz;
		else	{
			rwsiz = (int)siz;
			if ( filsiz)
				aligne =1;
		}
		if ( GetFontData(hDC, dwTable, (DWORD)ofs, buf,(DWORD)rwsiz )
			!= (DWORD)rwsiz)
			goto	ERET;

		if ( aligne ) {
			memset( buf+siz, 0, filsiz);
			rwsiz += filsiz;
		}
		chksum += calchksum( buf, rwsiz);

		BOOL res =  WriteFile( ofHdl, buf, (unsigned int)rwsiz, &nByte, NULL);
		if (!res || nByte !=(unsigned int)rwsiz)
			goto	ERET;
		siz -= rwsiz;
		ofs += rwsiz;
	}
	*cs = chksum;
	return 0;
ERET:
	return -1;
}
static int
mergeblock( HDC hDC, struct TableEntry *entry, HANDLE ofHdl)
{
	long	ofs;
	char	*mem=NULL;
	unsigned long	cs;	/* CheckSum value */

       if (  ( ofHdl == INVALID_HANDLE_VALUE ) || (!entry))
       {
           return -1;
       }
	mem = (char *)malloc((size_t) RWBUFSIZ);
	if ( mem==(char *)0)
		return -1;
	/* Obtain start offset of Output table */
	ofs = SetFilePointer( ofHdl, 0L, NULL, FILE_CURRENT);

	if (copyblk( hDC, entry->tagName, ofHdl, entry->siz, mem, RWBUFSIZ, &cs))
		goto	ERET;
	entry->ofs = ofs;
	entry->checkSum = cs;
	free( mem);
	return	0;
ERET:       
	free( mem);
	return -1;
}
static int
tableChkSum( HANDLE fH, struct TableEntry *te)
{
	char	*rwbuf;
	unsigned long	cs;
	long	lsiz;
	int	rwsiz;

       if ( (fH == INVALID_HANDLE_VALUE ) ||(!te))
       {
           return -1;
       }
	if ( te->siz==0)
		return 0;
	if ((rwbuf = (char *)malloc( (size_t)RWBUFSIZ))==(char *)0)
		return -1;
	if ( (long) SetFilePointer( fH, te->ofs, NULL, FILE_BEGIN)!=te->ofs)
		goto	ERET;
	cs = 0;
	lsiz = te->siz;
	while ( lsiz > 0) {
		if (lsiz > RWBUFSIZ)
			rwsiz = RWBUFSIZ;
		else	rwsiz = (int)lsiz;
		lsiz -= rwsiz;
		cs += calchksum( rwbuf, rwsiz);
	}
	te->checkSum = cs;
	free( rwbuf);
	return 0;
ERET:
	free( rwbuf);
	return -1;
}
static int
codeToGID( unsigned short code)
{
	return	(int)( code - (unsigned short)EUDCCODEBASE +2);
}
int
TTFReadHdr ( HANDLE fHdl, struct TTFHeader *hdr)
{
	DWORD nBytesRead;
       if ( ( fHdl == INVALID_HANDLE_VALUE ) ||(!hdr))
       {
           return -1;
       }
	SetFilePointer( fHdl, 0L, NULL, FILE_BEGIN);
	BOOL res=ReadFile( fHdl, hdr, sizeof(struct TTFHeader),&nBytesRead, NULL);
	if (!res || nBytesRead !=sizeof(struct TTFHeader)) {
		return -1;
	}
	smtoi( &hdr->numTables);
	smtoi( &hdr->searchRange);
	smtoi( &hdr->entrySelector);
	smtoi( &hdr->rangeShift);
	return	0;
}
int
TTFWriteHdr ( HANDLE fHdl, struct TTFHeader *hdr)
{
	struct TTFHeader whdr;
       if ( (fHdl == INVALID_HANDLE_VALUE ) || (!hdr))
       {
           return -1;
       }

	whdr = *hdr;
	sitom( &whdr.numTables);
	sitom( &whdr.searchRange);
	sitom( &whdr.entrySelector);
	sitom( &whdr.rangeShift);

	if (SetFilePointer( fHdl, 0L, NULL,  FILE_BEGIN)!=0L)
		return -1;

	DWORD nByte;
	BOOL res = WriteFile( fHdl, (BYTE *) &whdr, sizeof(struct TTFHeader), &nByte, NULL);
	if (!res || nByte !=sizeof(struct TTFHeader))
		return -1;

	return	0;
}
int
TTFReadDirEntry( HANDLE fHdl, struct TableEntry *entry, int eCnt)
{
	long	ofs;
	DWORD nByte;
	BOOL res;

       if (( fHdl== INVALID_HANDLE_VALUE ) ||(!entry))
       {
           return -1;
       }
	ofs = sizeof (struct TTFHeader);
	if ( (long) SetFilePointer( fHdl, ofs, NULL, FILE_BEGIN)!=ofs)
		return -1;
	res = ReadFile( fHdl, entry, (unsigned int)(sizeof(struct TableEntry)*eCnt), &nByte, NULL);
	if (!res || nByte !=(unsigned int)sizeof(struct TableEntry)*eCnt)
		return -1;
	while ( eCnt-->0) {
		lmtoi((long *)&entry->checkSum);
		lmtoi(&entry->ofs);
		lmtoi(&entry->siz);
		entry++;
	}
	return	0;
}
int
TTFWriteDirEntry( HANDLE fHdl, struct TableEntry *entry, int eCnt)
{
	long	ofs;
struct TableEntry wentry;
	DWORD nByte;
	BOOL res;

       if (( fHdl == INVALID_HANDLE_VALUE) || (!entry))
       {
           return -1;
       }
	ofs = sizeof (struct TTFHeader);
	if ( (long) SetFilePointer( fHdl, ofs, NULL, FILE_BEGIN)!=ofs)
		return -1;

	/* Write Entries */
	while ( eCnt-->0) {
		wentry = *entry++;
		litom((long *)&wentry.checkSum);
		litom(&wentry.ofs);
		litom(&wentry.siz);
		res = WriteFile( fHdl,(char *) &wentry, sizeof wentry, &nByte, NULL);
		if (!res || nByte !=sizeof wentry) {
			return -1;
		}
	}
	return	0;
}
static struct TableEntry *
searchEntry(struct TableEntry *entry, int eCnt, char *tag)
{
       if ( (!entry) || (!tag))
       {
           return (struct TableEntry *)0;
       }
	while ( eCnt-->0) {
		if (memcmp( entry->tagName, tag, TAGSIZ)==0)
			return entry;
		entry++;
	}
	return (struct TableEntry *)0;
}
int
TTFGetTableEntry( HANDLE fH, struct TableEntry *entry, char *tag)
{
struct TTFHeader	hdr;
struct TableEntry	*te, *rte;
	int	msiz;
       te = 0;
       if ( ( fH == INVALID_HANDLE_VALUE ) || (!entry) || (!tag))
       {
           goto ERET;
       }
	
	/* Read TTF Header to get numTables */
	if (TTFReadHdr( fH, &hdr))
		goto	ERET;
	msiz = sizeof(struct TableEntry)*hdr.numTables;
	if ( (te = (struct TableEntry *)malloc((size_t)msiz))==(struct TableEntry *)0)
		goto	ERET;

	/* Read entry whole */
	if ( TTFReadDirEntry( fH, te, hdr.numTables))
		goto	ERET;

	/* Search for entry with tag */
	if ((rte = searchEntry(te, (int)hdr.numTables, tag))==0)
		goto	ERET;
	*entry = *rte;
	free(te);
	return 0;
ERET:
	if (te)	free(te);
	return -1;
}
/***********************************************************************
 *	Read Table at once with entry data
 */
/* */	int
/* */	TTFReadTable(
/* */		HANDLE fH,
/* */	struct TableEntry *entry,
/* */		void	*buf,
/* */		int	bufsiz)
/*
 *	returns :  read size
 ***********************************************************************/
{
	unsigned int	rdsiz;
	DWORD nByte;
	BOOL res;

       if ( ( fH == INVALID_HANDLE_VALUE ) || (!entry) || (!buf))
       {
           goto ERET;
       }
       
	if ((long) SetFilePointer( fH, entry->ofs, NULL, FILE_BEGIN)!=entry->ofs)
		goto	ERET;
	rdsiz = bufsiz >= (int)entry->siz ? (unsigned int)entry->siz
						: (unsigned int)bufsiz;
	res = ReadFile( fH, buf, rdsiz, &nByte, NULL);
	if (!res || nByte!=rdsiz)
		goto	ERET;
	if ( rdsiz < (unsigned int)bufsiz)
		memset((unsigned char *)buf + rdsiz, 0, bufsiz - rdsiz);
	return (int)rdsiz;
ERET:
	return -1;
}
/***********************************************************************
 *	Read Fixed Size Table at onece with tag
 */
/* */	int
/* */	TTFReadFixedTable(
/* */		HANDLE	fH,
/* */		char	*buf,
/* */		int	bufsiz,
/* */		char	*tag)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
struct TableEntry	te;


       if ( ( fH == INVALID_HANDLE_VALUE ) || (!buf) || (!tag))
       {
           goto ERET;
       }
	if (TTFGetTableEntry( fH, &te, tag))
		goto	ERET;
	if ( TTFReadTable( fH, &te, buf, bufsiz )!=bufsiz)
		goto	ERET;
	return 0;
ERET:
	return -1;
}

/***********************************************************************
 *	Read Variable Size Table at onece with tag
 */
/* */	int
/* */	TTFReadVarTable(
/* */		HANDLE	fH,
/* */		char	**buf,		/* Buffer pointer (be set) */
/* */		unsigned int	*bufsiz,	/* Buffer Size ( be set) */
/* */		char	*tag)		/* Tag name */
/*
 *	returns : 0, -1
 *	remarks : allocated memory must be free by caller
 ***********************************************************************/
{
struct TableEntry	te;
    char    *mem = NULL;

       if ( ( fH == INVALID_HANDLE_VALUE ) || (!buf) || (!bufsiz) || (!tag))
       {
           goto ERET;
       }
	if (TTFGetTableEntry( fH, &te, tag))
		goto	ERET;
	if ((mem = (char *)malloc( (size_t)te.siz))==(char *)0)
		goto	ERET;
	if ( TTFReadTable( fH, &te, mem, (int)te.siz )!=(int)te.siz)
		goto	ERET;
	*buf = mem;
	*bufsiz = (unsigned int)te.siz;

	return 0;
ERET:
    if (mem)
    {
        free(mem);
    }
    return -1;
}

/***********************************************************************
 *	Write Table
 */
/* */	int
/* */	TTFWriteTable(
/* */		HANDLE	fH,
/* */	struct TableEntry *entry,
/* */		void	*buf,
/* */		int	bufsiz)
/*
 *	returns :  written size
 *	remarks : update checksum
 ***********************************************************************/
{
	int	wsiz;
	DWORD nByte;
	BOOL res;


       if ( ( fH == INVALID_HANDLE_VALUE ) || (!entry) || ( !buf))
       {
           goto ERET;
       }       
	if ((long) SetFilePointer( fH, entry->ofs, NULL, FILE_BEGIN)!=entry->ofs)
		goto	ERET;
	wsiz = bufsiz >= (int)entry->siz ? (int)entry->siz : bufsiz;
	res = WriteFile( fH, (char *)buf, (unsigned int)wsiz, &nByte, NULL);
	if (!res || nByte !=(unsigned int)wsiz)
		goto	ERET;
	entry->checkSum = calchksum( (char *)buf, bufsiz);
	return wsiz;
ERET:
	return -1;
}
/***********************************************************************
 *	Write Table
 */
/* */	int
/* */	TTFAppendTable(
/* */		HANDLE	fH,
/* */	struct TableEntry *entry, 	/* value be set */
/* */		void	*buf,
/* */		int	siz)
/*
 *	returns : 0, -1
 *	remarks : enttry->siz  not aligned 32bit
 ***********************************************************************/
{
	long	ofs;
	BYTE	pad[4];
	int	padsiz;
	DWORD nByte;
	BOOL res;

       if ( ( fH == INVALID_HANDLE_VALUE ) || (!entry) || ( !buf))
       {
           goto ERET;
       }       
	if ( (ofs=(long) SetFilePointer( fH, 0L, NULL, FILE_CURRENT))<0L)
		goto	ERET;

	res = WriteFile( fH, buf, (unsigned int)siz, &nByte, NULL);
	if (!res || nByte !=(unsigned int)siz)
		goto	ERET;
	
	/* 32 bit Word aligne */
	if ( siz % 4) {
		padsiz = 4 - siz%4;
		memset(pad,0,4);
		res = WriteFile(fH,pad, (unsigned int)padsiz, &nByte, NULL);
		if (!res || nByte !=(unsigned int)padsiz)
			goto	ERET;
	}
	entry->ofs = ofs;
	entry->siz = siz;
	entry->checkSum = calchksum((char *) buf, siz);
	return 0;
ERET:
	return -1;
}
/***********************************************************************
 *	Merge Table
 */
/* */	static int
/* */	TTFMergeTable(
/* */		HDC	hDC,
/* */		HANDLE	nfh,
/* */		char	tag[4],
/* */	struct TableEntry	*nte)
/*
 *	returns : 0
 ***********************************************************************/
{
       if ( ( nfh == INVALID_HANDLE_VALUE )  || (!nte))
       {
           return -1;
       }
	if (TTFGetOrgTableEntry( hDC, nte, tag))
		return -1;
	if (mergeblock( hDC, nte, nfh))
		return -1;
	return 0;
}
int
#ifdef BUILD_ON_WINNT
__cdecl
#endif // BUILD_ON_WINNT
compentry( const void *e1, const void *e2)
{
struct TableEntry *te1, *te2;
       if ( (!e1) || (!e2))
       {
           return -1;
       }
	te1 = (struct TableEntry *)e1;
	te2 = (struct TableEntry *)e2;
	return memcmp(te1->tagName, te2->tagName,4);
}
static void
SortEntry(struct TableEntry *ebuf, int num)
{
       if ((!ebuf))
       {
          return;
       }
	if ( num <=0)	return;
	qsort( ebuf, num, sizeof(struct TableEntry), compentry);
}
static int
fileChkSum(
	HANDLE fh,
	struct TableEntry *entry,
	int numEntry,
	struct TTFHeader *hdr,
	struct HeadTable *head)
{
	unsigned long	lval, cs;
	unsigned long	*lp;
	struct TableEntry *e;
	int	n;
	struct TableEntry	*headp;
	DWORD nByte;
	BOOL res;

       if (( fh == INVALID_HANDLE_VALUE) || (!entry) || (!hdr) || (!head))
       {
           goto	ERET;
       }
	e = entry;
	n = numEntry;
	cs = 0;
	head->chkSum = 0;
	headp = 0;
	while ( n-->0) {
		lp = (unsigned long *)e->tagName;
		if (memcmp( e->tagName,"head", 4)==0)
			headp = e;
		lval = *lp;
		lmtoi( (long *)&lval);
		cs += lval;
		cs += e->checkSum;
		cs += e->checkSum;
		cs += e->ofs;
		cs += e->siz;
		e++;
	}
	if (headp==0)
		return -1;

	cs += calchksum( (char *)hdr, sizeof(struct TTFHeader) );

	if ((long) SetFilePointer( fh, headp->ofs, NULL, FILE_BEGIN)!=headp->ofs)
		goto	ERET;
	head->chkSum = (unsigned long)0xb1b0afbaL - cs;
	litom( (long *)&head->chkSum);
	res = WriteFile(fh,(char *)head,sizeof(struct HeadTable), &nByte, NULL);
	if (!res || nByte !=sizeof(struct HeadTable))
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static void
makeTTFHeader( struct TTFHeader *hdr, int nTbl)
{
	int	po;
	int	n;
	int	ponum;

       if (!hdr)
       {
           return;
       }
	po = 0;
	n = nTbl;
	ponum = 1;
	while ( n>=2) {
		n /= 2;
		po++;
		ponum*=2;
	}
	hdr->sfnt_version[0]= hdr->sfnt_version[2]= hdr->sfnt_version[3]= 0;
	hdr->sfnt_version[1]= 0x01;
	hdr->numTables = (short)nTbl;
	hdr->searchRange = (short)ponum*16;
	hdr->entrySelector = (short)po;
	hdr->rangeShift = (short)( nTbl*16)-hdr->searchRange;

	return ;
}
/***********************************************************************
 *	make GlyphData from lst
 */
/* */	static int
/* */	makeGlyphData(
/* */		int lstH,
/* */		struct BBX *bbx,	/* Set value to header */
/* */		char	*glyphData,
/* */		int	bufsiz,
/* */		int	*gdatsiz)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	char	*flgp, *sflgp;
	char	flag;
	char	*dummyp;
struct VHEAD	*vhd,
		*svhd;
struct glyfHead	ghdr;
	int	nCnt;
struct VDATA	*vp;
	int	nPnt;
	int	pntSum;
	int	cnt;
	short	sval;
	short	px, py;
	short	relx, rely;
	char	cval;

       if ((!bbx) || (!glyphData) || (!gdatsiz))
       {
           goto ERET;
       }
	initsetgbuf ( glyphData, bufsiz);
	if( ( nCnt = VDGetNCont( lstH))<0)
		goto	ERET;

	else  if (nCnt == 0) {	/* Space Character */
			*gdatsiz = 0;
			return	0;
	
	}

	ghdr.numberOfContour = (short)nCnt;
	sitom( &ghdr.numberOfContour );
	ghdr.xMin = (short)bbx->xMin;
	sitom( &ghdr.xMin);
	ghdr.yMin = (short)bbx->yMin;
	sitom( &ghdr.yMin);
	ghdr.xMax = (short)bbx->xMax;
	sitom( &ghdr.xMax);
	ghdr.yMax = (short)bbx->yMax;
	sitom( &ghdr.yMax);
	if (setgbuf( (char *)&ghdr, sizeof ghdr, &flgp))
		goto	ERET2;
	if (VDGetHead( lstH, &vhd))
		goto	ERET;
	pntSum = 0;
	svhd = vhd;
	/* Set each Contour Last point number */
	for ( cnt = 0; cnt < nCnt; cnt++) {
		pntSum +=  vhd->nPoints;
		sval = pntSum-1;
		sitom( &sval);
		if ( setgbuf((char *)&sval, sizeof( short), &flgp))
			goto	ERET2;
		vhd = vhd->next;
	}
	/* Toatal number of instructions */
	sval = 0;
	if ( setgbuf((char *)&sval, sizeof( short), &flgp))
		goto	ERET2;

	/* Set flags */
	vhd = svhd;
	px = py = 0;
	for ( cnt = 0; cnt < nCnt; cnt++) {
		vp = vhd->headp;
		nPnt = vhd->nPoints;
		while ( nPnt-->0) {
			flag = (vp->vd.atr&1)==0 ? (char)GLYF_ON_CURVE :(char)0;
			relx = vp->vd.x - px;
			rely = vp->vd.y - py;
			if ( relx == 0)
				flag |= GLYF_X_SAME;
			else if ( relx > 0 && relx < 256)
				flag |= GLYF_X_SHORT_P;
			else if ( relx < 0 && relx > -256)
				flag |= GLYF_X_SHORT_N;
			if ( rely == 0)
				flag |= GLYF_Y_SAME;
			else if ( rely > 0 && rely < 256)
				flag |= GLYF_Y_SHORT_P;
			else if ( rely < 0 && rely > -256)
				flag |= GLYF_Y_SHORT_N;

			if (setgbuf((char *) &flag, 1, &dummyp))
				goto	ERET2;
			px = vp->vd.x;
			py = vp->vd.y;
			vp = vp->next;
		}
		vhd = vhd->next;
	}
	/* set X */
	vhd = svhd;
	sflgp = flgp;
	px = 0;
	for ( cnt = 0; cnt < nCnt; cnt++) {
		vp = vhd->headp;
		nPnt = vhd->nPoints;
		while ( nPnt-->0) {
			relx = vp->vd.x - px;
			if ( *flgp & GLYF_X_SHORT) {
				if ( (*flgp & GLYF_X_SAME)==0)
					relx = -relx;
				cval = (char)relx;
				if ( setgbuf( &cval, 1, &dummyp))
					goto	ERET2;
			}
			else if ( *flgp & GLYF_X_SAME)
				;
			else {
				sitom( &relx);
				if ( setgbuf( (char *)&relx, 2, &dummyp))
					goto	ERET2;
			}
			flgp++;
			px = vp->vd.x;
			vp = vp->next;
		}
		vhd = vhd->next;
	}
	/* set Y */
	vhd = svhd;
	flgp = sflgp;
	py = 0;
	for ( cnt = 0; cnt < nCnt; cnt++) {
		vp = vhd->headp;
		nPnt = vhd->nPoints;
		while ( nPnt-->0) {
			rely = vp->vd.y - py;
			if ( *flgp & GLYF_Y_SHORT) {
				if ( (*flgp & GLYF_Y_SAME)==0)
					rely = -rely;
				cval = (char)rely;
				if ( setgbuf( &cval, 1, &dummyp))
					goto	ERET2;
			}
			else if ( *flgp & GLYF_Y_SAME)
				;
			else {
				sitom( &rely);
				if ( setgbuf((char *)&rely, 2, &dummyp))
					goto	ERET2;
			}
			flgp++;
			py = vp->vd.y;
			vp = vp->next;
		}
		vhd = vhd->next;
	}

	*gdatsiz = termbuf();
	return 0;
ERET:
	return -1;
ERET2:
	return -2;
}
static char	*sbuf;
static int	limcnt;
static char	*setp;
static int	bcnt;
static void
initsetgbuf( char *b, int lim)
{      
	setp = sbuf = b;
	limcnt = lim;
	bcnt = lim;	/* decremental counter */
	return;
}
static int
setgbuf( char *dat, int siz, char **np)
{
       if ((!dat) || (!np))
       {
           return -1;
       }
	if ( siz > bcnt)	return -1;
	memcpy( setp, dat, siz);
	setp += siz;
	bcnt -= siz;
	*np = setp;
	return 0;
}
static int
termbuf( )
{
	int	siz;

	siz = limcnt - bcnt;
	siz = siz % 4;
	if ( siz) {
		while ( siz++<4) {
			*setp++=0;
			bcnt--;
		}
	}
	return limcnt - bcnt;
}
static int
strwlen( char *s)
{
	int	len;
       if (!s)
       {
          return 0;
       }
	len = 0;
	while (*s ||  *(s+1)) {
		s+=2;
		len++;
	}
	return len*2;
}
static void
strwcat( char *s1, char *s2)
{
       if ((!s1) || (!s2))
       {
           return;
       }
	while (*s1 || *(s1+1))
		s1+=2;

	while ( *s2 || *(s2+1)) {
		*s1++ = *s2++;
		*s1++ = *s2++;
	}
	*s1++ = 0;
	*s1++ = 0;
	
	return;
}
static void
setnamebuf( char *buf, int *siz, short EncodingID)
{
	int	strsiz;
	short	strofs;
	char	*strp;
struct NamingTable	*nt;
struct NameRecord	*nr;
	int	rec;
	int	slen;
       
       if ((!buf) || (!siz))
       {
           return;
       }

	strofs = sizeof(struct NamingTable)
		+ sizeof(struct NameRecord)*NUMOFNAMEREC;
	strsiz = 0;
	strp = buf +strofs;
	*strp=(char)0;
	*(strp+1)=(char)0;
	nt = (struct NamingTable *)buf;
	nt->OfsToStr = strofs;
	sitom( &nt->OfsToStr);
	nr = (struct NameRecord *)(buf + sizeof(struct NamingTable));
	/* Set name record */
	strofs = 0;
	for ( rec = 0; rec<NUMOFNAMEREC; rec++, nr++) {
		nr ->PlatformID = 3;
		sitom(&nr ->PlatformID);

		nr ->PlatformSpecEncID = EncodingID;
		sitom(&nr ->PlatformSpecEncID);

		nr ->LanguageID = (short)CountryInfo.LangID;
		sitom(&nr ->LanguageID);

		nr ->NameID = (short)rec;
		sitom(&nr ->NameID);

		strwcat( strp,namerecstr[rec]);
		slen = strwlen(namerecstr[rec]);

		nr -> StringLength = (short)slen;
		sitom(&nr -> StringLength );
		strsiz += slen;

		nr -> StringOfs = strofs;
		sitom(&nr -> StringOfs);
		strofs += (short)slen;
	}
	nt->FormSel = 0;
	nt->NRecs = NUMOFNAMEREC;
	sitom( &nt->NRecs);
	*siz = strsiz+ sizeof(struct NamingTable)
			+ sizeof(struct NameRecord)*NUMOFNAMEREC;
}
static void
modifyOS2( char *buf)
{
       if (!buf)
       {
           return;
       }
	/* Allow all license */
	*(buf+9) = (char)0x00;
	/* Set aulUnicodeRange  Privete Use Area bit*/
	*(buf+0x31) |= 0x31;
}
static void
modifyhead( struct HeadTable *head)
{
       if (!head)
       {
           return;
       }
	head->chkSum=0L;
	memset( head->createdDate, 0, 8);
	memset( head->updatedDate, 0, 8);
	head->indexToLocFormat = 1;
	head->glyphDataFormat = 0;
	sitom( &head->indexToLocFormat );
	sitom( &head->glyphDataFormat);
}
/*
 *	Set Vertical Header with Horizontal Header and Bounding Box
 */
static void
setVhea( struct VheaTable *vhea, struct HheaTable *hhea, struct BBX *bbx)
{

       if ( (!vhea) || (!hhea) || (!bbx))
       {
           return;
       }
	memcpy( vhea, hhea, sizeof(struct HheaTable));
	vhea->minTopSideBearing = 0;
	vhea->minBottomSideBearing = 0;
	vhea->caretSlopeRise = 0;
	vhea->caretSlopeRun = 1;
	sitom( &vhea->caretSlopeRun );
	vhea->numOfLongVerMetrics = (short)numOfGlyph;
	sitom( &vhea->numOfLongVerMetrics );
}
static int
updateMaxp( struct MaxpTbl *maxp, int lstHdl)
{
struct VHEAD	*vhd;
	short	sval;
	int	nCnt;
	int	ttlPnt;
	int	updflg;
       
       if (!maxp)
       {
            goto ERET;
       }
	updflg = 0;	
	if ( (nCnt = VDGetNCont( lstHdl))<0)
		goto	ERET;
	else if ( nCnt ==0)
		goto	RET;

	sval = maxp->maxContours;
	smtoi( &sval);
	if ( sval < nCnt) {
		sval = (short)nCnt;
		sitom(&sval);
		maxp->maxContours = sval;
		updflg = 1;	
	}
	if (VDGetHead( lstHdl, &vhd))
		goto	ERET;
	ttlPnt = 0;
	while ( nCnt-->0) {
		ttlPnt += vhd->nPoints;
		vhd = vhd->next;
	}
	sval = maxp->maxPoints;
	smtoi( &sval);
	if ( sval < ttlPnt) {
		sval = (short)ttlPnt;
		sitom(&sval);
		maxp->maxPoints = sval;
		updflg = 1;	
	}
RET:
	return updflg;
ERET:
	return -1;
}
/***********************************************************************
 *	Obtain Original TTF Table Size
 */
/* */	static int
/* */	TTFGetOrgTableEntry(
/* */		HDC	hDC,
/* */		struct TableEntry	*entry,
/* */		char	*tag)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	DWORD dwTable;	/* Metric Table to request */
	DWORD 	siz;

       if ( (!entry) || (!tag))
       {
          return -1;
       }
	dwTable = *(DWORD *)tag;
	siz = GetFontData(hDC, dwTable, (DWORD)0, (char *)0, (DWORD)0);
	if ( siz == GDI_ERROR)	return -1;
	else {
		memcpy( entry->tagName, tag, TAGSIZ);
		entry->siz = (long)siz;
		return 0;
	}
}
/***********************************************************************
 *	Read Original TTF Table
 */
/* */	int
/* */	TTFReadOrgFixedTable (
/* */		HDC	hDC,		/* Handle to DC */
/* */		char	*buf,		/* Read Buffer */
/* */		int	bufsiz,		/* Buffer Siz */
/* */		char	*tag)		/* TagName */
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	DWORD dwTable;	/* Metric Table to request */
	DWORD	siz;

       if ( (!buf) || (!tag))
       {
           return -1;
       }
	dwTable = *(DWORD *)tag;
	siz = GetFontData(hDC, dwTable, (DWORD)0, buf,(DWORD)bufsiz );
	if ( (int)siz != bufsiz)
		return -1;
	else	return 0;
}
/***********************************************************************
 *	Read Variable Size Table at onece with tag
 */
/* */	int
/* */	TTFReadOrgVarTable(
/* */		HDC	hDC,
/* */		char	**buf,		/* Buffer pointer (be set) */
/* */		unsigned int	*bufsiz,	/* Buffer Size ( be set) */
/* */		char	*tag)		/* Tag name */
/*
 *	returns : 0, -1
 *	remarks : allocated memory must be free by caller
 ***********************************************************************/
{
struct TableEntry	te;
    char    *mem = NULL;

       if ( (!buf) || (!bufsiz) || (!tag))
       {
           goto	ERET;
       }
	if (TTFGetOrgTableEntry( hDC, &te, tag))
		goto	ERET;
	if ((mem = (char *)malloc( (size_t)te.siz))==(char *)0)
		goto	ERET;
	if ( TTFReadOrgFixedTable ( hDC, mem,(int)te.siz , tag))
		goto	ERET;
	*buf = mem;
	*bufsiz = (unsigned int)te.siz;

	return 0;
ERET:
    if (mem)
    {
        free(mem);
    }
    return -1;
}
static void
setCountryData(short EncodingID)
{
	unsigned short lastCode;

	makeUniCodeTbl();

	lastCode = getMaxUniCode();

	numOfGlyph = lastCode - EUDCCODEBASE +1 + 2; /* +null, +missing */

	cmapdata[6] = (char)((EncodingID>>8)&(unsigned short)0xff);
	cmapdata[7] = (char)(EncodingID&(unsigned short)0xff);
	cmapdata[26] = (char)((lastCode>>8)&(unsigned short)0xff);
	cmapdata[27] = (char)(lastCode&(unsigned short)0xff);

	maxpdata[4] = (char)((numOfGlyph>>8)&(unsigned short)0xff);
	maxpdata[5] = (char)(numOfGlyph&(unsigned short)0xff);
}
static int
WIFEOS2( HDC hDC, char **os2buf, int *os2TblSiz, struct BBX *bbx)
{
	struct OS2Table *os2tbl;
	int	siz;
	TEXTMETRIC	tm;
static PANOSE	msminPanose= { (char)2, (char)2, (char)6, (char)9, (char)4,
			(char)2, (char)5, (char)8, (char)3, (char)4};

       if ( (!os2buf) || (!os2TblSiz) || (!bbx))
       {
           goto	ERET;
       }
	if ( GetTextMetrics( hDC, &tm)==0)
		goto	ERET;
	siz = sizeof( struct OS2Table);
	if ((os2tbl = (struct OS2Table *)malloc(sizeof(struct OS2Table)))==0)
		goto	ERET;
	memset( os2tbl, 0, sizeof(struct OS2Table));

	os2tbl->version = 1;
	sitom( (short *)&os2tbl->version);
	os2tbl->xAvgCharWidth = bbx->xMax+1;
	sitom( &os2tbl->xAvgCharWidth );
	os2tbl->usWeightClass = tm.tmWeight? (unsigned short)tm.tmWeight : 500;
	sitom( (short *)&os2tbl->usWeightClass );
	os2tbl->usWidthClass = 5; /* Medium */
	sitom( (short *)&os2tbl->usWidthClass );
	os2tbl->fsType = 0x0000; /* Allow all liscence */
	sitom( &os2tbl->fsType );

	os2tbl->ySubscriptXSize = (bbx->xMax+1)/2;	/* 1/4kaku */
	sitom( &os2tbl->ySubscriptXSize );
	os2tbl->ySubscriptYSize = (bbx->yMax+1)/2;	/* 1/4kaku */
	sitom( &os2tbl->ySubscriptYSize );
	os2tbl->ySubscriptXOffset = 0;			/* 1/4kaku */
	sitom( &os2tbl->ySubscriptXOffset );
	os2tbl->ySubscriptYOffset = 0;			/* 1/4kaku */
	sitom( &os2tbl->ySubscriptYOffset );

	os2tbl->ySuperscriptXSize = (bbx->xMax+1)/2;	/* 1/4kaku */
	sitom( &os2tbl->ySuperscriptXSize );
	os2tbl->ySuperscriptYSize = (bbx->yMax+1)/2;	/* 1/4kaku */
	sitom( &os2tbl->ySuperscriptYSize );
	os2tbl->ySuperscriptXOffset = (bbx->xMax+1)/2;	/* 1/4kaku */
	sitom( &os2tbl->ySuperscriptXOffset );
	os2tbl->ySuperscriptYOffset = (bbx->yMax+1)/2;	/* 1/4kaku */
	sitom( &os2tbl->ySuperscriptYOffset );

	os2tbl->yStrikeoutSize = bbx->yMax/20;		/* 5% */
	sitom( &os2tbl->yStrikeoutSize );
	os2tbl->yStrikeoutPosition = bbx->yMax/4;	/* 25% */
	sitom( &os2tbl->yStrikeoutPosition );

	os2tbl->sFamilyClass = 0;	/* no classification */
	sitom( &os2tbl->sFamilyClass );
	os2tbl->panose = msminPanose;

	os2tbl->fsSelection = 0x40;
	sitom( (short *)&os2tbl->fsSelection );

	os2tbl->usFirstCharIndex = 0x20;
	sitom( (short *)&os2tbl->usFirstCharIndex );
	os2tbl->usLastCharIndex = 0xffe5;
	sitom( (short *)&os2tbl->usLastCharIndex );
	os2tbl->sTypoAscender = bbx->yMax+1;
	sitom( &os2tbl->sTypoAscender );
	os2tbl->sTypoDescender = -(bbx->yMax/8);
	sitom( &os2tbl->sTypoDescender );
	os2tbl->sTypoLineGap = 0;
	sitom( &os2tbl->sTypoLineGap );

	os2tbl->usWinAscent = bbx->yMax+1;
	sitom( (short *)&os2tbl->usWinAscent );
	os2tbl->usWinDescent = bbx->yMax/8;
	sitom( (short *)&os2tbl->usWinDescent );
	*os2TblSiz = sizeof( struct OS2Table);
	*os2buf = (char *)os2tbl;
	return 0;
ERET:
	return -1;
}
static void
WIFEhhea( struct HheaTable *hhea, struct BBX *bbx)
{
       if ( (!hhea) || (!bbx))
       {
           return;
       }
	memset( hhea, 0, sizeof(struct HheaTable));

	hhea->version[1] = (char)1;
	hhea->Ascender = bbx->yMax+1;
	sitom( &hhea->Ascender);
	hhea->Descender = -(bbx->yMax/8);
	sitom( &hhea->Descender);
	hhea->LineGap =  0;
	sitom( &hhea->LineGap);

	hhea->advanceWidthMax =  bbx->xMax+1;
	sitom( &hhea->advanceWidthMax);
	hhea->minLeftSideBearing =  0;
	sitom( &hhea->minLeftSideBearing);
	hhea->minRightSideBearing = 0;
	sitom( &hhea->minRightSideBearing);

	hhea->xMaxExtent =  bbx->xMax+1;
	sitom( &hhea->xMaxExtent);
	hhea->caretSlopeRise = 1;
	sitom( &hhea->caretSlopeRise);
	hhea->caretSlopeRun = 0;
	sitom( &hhea->caretSlopeRun);

	hhea->numberOfHMetrics = (short)numOfGlyph;
	sitom( &hhea->numberOfHMetrics);

}
static void
WIFEhead( struct HeadTable *head, struct BBX *bbx)
{
       if ( (!head) || (!bbx))
       {
            return;
       }
	memset( head, 0, sizeof( struct HeadTable));

	head->version[1] = 0x1;
	head->magicNumber=0x5f0F3CF5L;
	litom((long *)&head->magicNumber);
	head->flags = 0;
	sitom( &head->flags);
	head->unitsPerEm = bbx->xMax - bbx->xMin+1;
	head->unitsPerEm = ((bbx->xMax - bbx->xMin+1)*9+4)/8;
	sitom( &head->unitsPerEm);

	head->xMin = (short)bbx->xMin;
	sitom( &head->xMin);
	head->xMax = (short)bbx->xMax;
	sitom( &head->xMax);
//	head->yMin = (short)bbx->yMin;
	head->yMin = -(bbx->yMax/8);
	sitom( &head->yMin);
	head->yMax = (short)bbx->yMax;
	sitom( &head->yMax);

	head->lowestRecPPEM = 25;
	sitom( &head->lowestRecPPEM);
	head->fontDirectionHint = 1;
	sitom( &head->fontDirectionHint);
	head->indexToLocFormat = 1;
	sitom( &head->indexToLocFormat);

}
static void
WIFEpost( struct postTable *post)
{
       if (!post)
       {
           return;
       }
	memset( post, 0, sizeof( struct postTable));
	post->FormatType[1]=0x3;
	post->underlineThickness = 12;
	sitom( &post->underlineThickness);
	post->isFixedPitch = 1;
	litom( (long *)&post->isFixedPitch);
}
static short
getEncID( HDC hDC, int fontType)
{
	if ( CountryInfo.LangID==EUDC_KRW)
		return (short)1;
	else	return (short)1;
}
/***********************************************************************
 *	Create TTF
 */
/* */	int
/* */	TTFCreate(
/* */		HDC hDC, 		/* Handle to DC */
/* */		TCHAR *newf,		/* Create TTF Path */
/* */		struct BBX	*bbx,	/* the same as original 'head'*/
/* */					/* but minX should be 0 */
/* */		int	lstHdl,		/* missing glyf list */
/* */					/* bbx, hM, LstHdl is for Missing Glyf*/
/* */		int	fontType)	/* 0:TrueType, 1:WIFE */
/*
 *	returns : 0, -1
 ***********************************************************************/
{
    HANDLE  nfh = INVALID_HANDLE_VALUE;	
struct TTFHeader	hdr;
struct TableEntry	*te,		/* Directory Entry */
			nte;
	char		*nameBuf;
	int		nameBufSiz;
struct HheaTable	hhea;
struct VheaTable	vhea;
struct HeadTable	head;
struct HMetrics		*hmet;
struct VMetrics		*vmet;
	long		*loca;
	long		ofs;
	char	*glyphData;
	int	gdatsiz;
	int	i;
	char	*os2buf;
	int	os2siz;
struct BBX	cbbx;		/* bounding box for each glyph*/
struct HMetrics		hM;	/* horizontal metrics for each glyph */
struct VMetrics		vM;	/* Vertical one */
struct postTable	postTbl; /* post table */
	short	EncodingID;
	DWORD nByte;
	BOOL res;

//	nfh = -1;
	te =  0;
	nameBuf = 0;
	hmet = 0;
	loca = 0;
	glyphData = 0;
	os2buf = 0;

       if (  (!newf) || (!bbx) )
       {
          goto ERET;
       }
	/* Determin PlatformSpcificEncodingID */
	if ((EncodingID = getEncID( hDC, fontType))<(short)0)
		goto	ERET;
	/* Set cmapdata,maxpdata,numOfGlyph,lastCode */
	setCountryData(EncodingID);

	/* Open files */
	nfh = CreateFile(newf,
					GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_DELETE,
					NULL,
					CREATE_ALWAYS,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( nfh  == INVALID_HANDLE_VALUE)
		goto	ERET;
	
	/* Write header */
	makeTTFHeader( &hdr, NUMTABLES);
	if ( TTFWriteHdr( nfh, &hdr))
		goto	ERET;

	/* Allocate dir entry area */
	if ( (te =(struct TableEntry *)malloc((size_t)sizeof(struct TableEntry)*NUMTABLES))==0)
		goto	ERET;

	/*
	 * DirEntry Dummy Write
	 */
	memset( te, 0, sizeof(struct TableEntry)*NUMTABLES);
	res = WriteFile( nfh, te, sizeof(struct TableEntry)*NUMTABLES, &nByte, NULL);
	if (!res || nByte != sizeof(struct TableEntry)*NUMTABLES)
		goto	ERET;

	initDirEntry(te, NUMTABLES );

	/*
	 * 'cvt ' Write
	 */
	if (TTFAppendTable( nfh, &nte, cvtdata, sizeof cvtdata))
		goto	ERET;
	if ( setDirEntry( &nte, "cvt "))
		goto	ERET;
	/*
	 * 'fpgm' Write
	 */
	if (TTFAppendTable( nfh, &nte, fpgmdata, sizeof fpgmdata))
		goto	ERET;
	if ( setDirEntry( &nte, "fpgm"))
		goto	ERET;
	/*
	 * 'prep' write
	 */
	if (TTFAppendTable( nfh, &nte, prepdata, sizeof prepdata))
		goto	ERET;
	if ( setDirEntry( &nte, "prep"))
		goto	ERET;
	/*
	 * 'name' write
	 */
	if ( (nameBuf = (char *)malloc((size_t)NAMEBUFSIZ))==0)
		goto	ERET;
	setnamebuf(nameBuf, &nameBufSiz, EncodingID);
	if (TTFAppendTable( nfh, &nte, nameBuf, nameBufSiz))
		goto	ERET;
	free( nameBuf);
	nameBuf = 0;
	if ( setDirEntry( &nte, "name"))
		goto	ERET;

	/*
	 * 'cmap' Write
	 */
	if (TTFAppendTable( nfh, &nte, cmapdata, sizeof cmapdata))
		goto	ERET;
	if ( setDirEntry( &nte, "cmap"))
		goto	ERET;
	/*
	 * 'OS/2' Copy -> modify
	 */
	if ( fontType==0) {
		if ( TTFReadOrgVarTable( hDC, &os2buf, (unsigned int *)&os2siz,
						"OS/2"))
			goto	ERET;
		modifyOS2( os2buf);
	}
	else {
		if (WIFEOS2( hDC, &os2buf, &os2siz, bbx))
			goto	ERET;
	}
	if (TTFAppendTable( nfh, &nte, os2buf,  os2siz))
		goto	ERET;
	if ( setDirEntry( &nte, "OS/2"))
		goto	ERET;
	free( os2buf);
	/*
	 * 'post' Copy
	 */
	if ( fontType==0) {
		if ( TTFMergeTable( hDC, nfh, "post", &nte))
			goto	ERET;
	}
	else {
		WIFEpost( &postTbl);
		if (TTFAppendTable( nfh,&nte, (char *)&postTbl,sizeof(struct postTable)))
			goto	ERET;
	}
	if ( setDirEntry( &nte, "post"))
		goto	ERET;
	/*
	 * 'hhea' Read,modify and write
	 */
	if ( fontType==0) {
		if (TTFReadOrgFixedTable( hDC, (char *)&hhea, sizeof hhea,"hhea"))
			goto	ERET;

		hhea.metricDataFormat = 0;
		hhea.numberOfHMetrics = (short)numOfGlyph;
		sitom( &hhea.numberOfHMetrics );
	}
	else {
		WIFEhhea( &hhea, bbx);
	}
	if (TTFAppendTable( nfh, &nte, &hhea, sizeof hhea))
		goto	ERET;
	if ( setDirEntry( &nte, "hhea"))
		goto	ERET;

	/*
	 * 'vhea'
	 */
	setVhea( &vhea, &hhea, bbx);
	if (TTFAppendTable( nfh, &nte, &vhea, sizeof vhea))
		goto	ERET;
	if ( setDirEntry( &nte, "vhea"))
		goto	ERET;
	/* Make metrics for missing Glyph */	
	cbbx = *bbx;
	makeMetrics( lstHdl, &hM, &vM, &cbbx);

	/*
	 * 'vmtx'
	 */
	if ((vmet=(struct VMetrics *)malloc( (size_t)sizeof(struct VMetrics)*numOfGlyph))==0)
		goto	ERET;
	memset(vmet, 0, sizeof(struct VMetrics)*numOfGlyph);

	/* for missing Glyph */

	*vmet = vM;
	sitom(&vmet->advanceHeight );
	sitom(&vmet->topSideBearing );

	/* for null Glyph */
	(vmet+1)->advanceHeight = 0;
	(vmet+1)->topSideBearing = 0;

	if (TTFAppendTable( nfh,&nte,vmet,sizeof(struct VMetrics)*numOfGlyph))
		goto	ERET;
	if ( setDirEntry( &nte, "vmtx"))
		goto	ERET;
	free( vmet);
	vmet = 0;

	/*
	 * head Read,modify and write
	 */
	if ( fontType==0) {
		if (TTFReadOrgFixedTable( hDC,(char *)&head, sizeof head,"head"))
			goto	ERET;
		modifyhead( &head);
	}
	else {
		WIFEhead( &head, bbx);
	}
	if (TTFAppendTable( nfh, &nte, &head, sizeof head))
		goto	ERET;
	if ( setDirEntry( &nte, "head"))
		goto	ERET;

	/*
	 * make hmtx
	 */
	if ((hmet=(struct HMetrics *)malloc( (size_t)sizeof(struct HMetrics)*numOfGlyph))==0)
		goto	ERET;
	memset(hmet, 0, sizeof(struct HMetrics)*numOfGlyph);
	/* for missing Glyph */
	*hmet = hM;
	sitom(&hmet->advanceWidth );
	sitom(&hmet->leftSideBearing);

	/* for null Glyph */
	(hmet+1)->advanceWidth = 0;
	(hmet+1)->leftSideBearing = 0;

	if (TTFAppendTable( nfh,&nte,hmet,sizeof(struct HMetrics)*numOfGlyph))
		goto	ERET;
	if ( setDirEntry( &nte, "hmtx"))
		goto	ERET;
	free( hmet);
	hmet = 0;

	if ((glyphData = (char *)malloc((size_t)GLYPHBUFSIZ))==0)
		goto	ERET;
	if (makeGlyphData( lstHdl, &cbbx, glyphData, GLYPHBUFSIZ, &gdatsiz ))
		goto	ERET;
	/*
	 * 'loca' make
	 */
	if ((loca = (long *)malloc( (size_t)sizeof(unsigned long)*(numOfGlyph+1)))==(long *)0)
		goto	ERET;
	*loca = 0;
	ofs = gdatsiz;
	litom(&ofs);
	for ( i = 1; i< numOfGlyph+1; i++)
		*(loca + i)=ofs;

	if (TTFAppendTable( nfh,&nte,loca,sizeof( long)*(numOfGlyph+1)))
		goto	ERET;
	if ( setDirEntry( &nte, "loca"))
		goto	ERET;
	free( loca);
	loca = 0;

	/*
	 * 'maxp' write
	 */
	if (TTFAppendTable( nfh,&nte,maxpdata,sizeof(maxpdata)))
		goto	ERET;
	if ( setDirEntry( &nte, "maxp"))
		goto	ERET;

	/*
	 * 'glyf' Write (missing glyph )
	 */
	if (TTFAppendTable( nfh, &nte, glyphData, gdatsiz))
		goto	ERET;
	if ( setDirEntry( &nte, "glyf"))
		goto	ERET;
	free( glyphData);
	glyphData = 0;
	/* Sort dir entry table */
	SortEntry( te, NUMTABLES);

	/* Write dir entry */
	if (TTFWriteDirEntry( nfh, te, NUMTABLES))
		goto	ERET;

	/* Set Check sum of file whole to head */
	if (fileChkSum( nfh, te, NUMTABLES, &hdr, &head))
		goto	ERET;
	CloseHandle( nfh);
	if ( te)	free( te);
	return 0;
ERET:
	if ( nfh != INVALID_HANDLE_VALUE)	CloseHandle( nfh);
	if ( te)	free( te);
	if ( nameBuf)	free( nameBuf);
	if ( hmet)	free( hmet);
	if ( loca)	free( loca);
	if ( os2buf)	free( os2buf);
	if ( glyphData)	free( glyphData);
	return -1;
}
/***********************************************************************
 *	Obtain BoundingBox ( from 'head' xMin, xMax, yMin, yMax)
 */
/* */	int
/* */	TTFGetBBX(
/* */		HDC	hDC,
/* */		struct BBX	*bbx,
/* */		short		*uPEm)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
struct	HeadTable	head;
	DWORD	dwTable;	/* tagName to request */
	DWORD	siz, s;

       if ( (!bbx) || (!uPEm))
       {
           return -1;
       }
	memcpy( &dwTable, "head", TAGSIZ);
	siz = (DWORD)sizeof( struct HeadTable);

	
	if ((s=GetFontData(hDC, dwTable, (DWORD)0, &head,(DWORD)siz))!=siz){
		DWORD err = GetLastError();
		return -1;
	}
	smtoi( &head.xMin);
	smtoi( &head.xMax);
	smtoi( &head.yMin);
	smtoi( &head.yMax);
	smtoi( &head.unitsPerEm);
	bbx->xMin = head.xMin;
	bbx->xMax = head.xMax;
	bbx->yMin = head.yMin;
	bbx->yMax = head.yMax;
	*uPEm = head.unitsPerEm;
	if ( bbx->xMin < 0 )
		bbx->xMin = 0;
	return 0;
}
int
TTFTmpPath( TCHAR *path, TCHAR *tmpPath)
{
	TCHAR	*p1;
	TCHAR	dirPath[MAX_PATH];
	HRESULT hresult;

       if ((!path) || (!tmpPath))
       {
           return -1;
       }
	//*STRSAFE* 	lstrcpy( dirPath, path);
	hresult = StringCchCopy(dirPath , ARRAYLEN(dirPath),  path);
	if (!SUCCEEDED(hresult))
	{
	   return -1;
	}
	p1 = Mytcsrchr( dirPath, '\\');
	if ( p1==(TCHAR *)0) {
		p1 = Mytcsrchr( dirPath, ':');
		if (p1==(TCHAR *)0)
			*dirPath=(TCHAR)0;
		else
			*(p1+1)=0;
	}
	else
		*p1=0;
	if (GetTempFileName( dirPath, TEXT("TTE"), 0, tmpPath)==0)
		return -1;
	else
		return 0;

}
static int
copyTable( HANDLE iFh,HANDLE oFh, struct TableEntry *te, int nEntry, char *tag)
{
struct TableEntry *tep;
	char	*buf = NULL;

       if ((iFh == INVALID_HANDLE_VALUE) || ( oFh == INVALID_HANDLE_VALUE) || (!te) || (!tag))
       {
          goto	ERET;
       }     
	if ((tep = searchEntry(te, nEntry, tag))==(struct TableEntry *)0)
		goto	ERET;
	if ((buf = (char *)malloc((size_t)tep->siz))==(char *)0)
		goto	ERET;
	if ( (TTFReadTable( iFh,tep, buf, (int)tep->siz)!=(int)tep->siz) )
		goto	ERET;
	if ( (TTFWriteTable( oFh,tep, buf, (int)tep->siz)!=(int)tep->siz) )
		goto	ERET;
	free(buf);
	return 0;
ERET:
	if (buf)	free(buf);
	return -1;
	
}
static int
copyfblock( HANDLE iFh, HANDLE oFh, unsigned long siz, unsigned long *cs)
{
	int	rwsiz;
	int	filsiz;
	int	aligne;
	unsigned long	chksum;
	char	*buf=NULL;

       if ((  iFh == INVALID_HANDLE_VALUE) || (oFh == INVALID_HANDLE_VALUE) || (!cs))
       {
          goto	ERET;
       }
	if ((buf = (char *)malloc((size_t) RWBUFSIZ))==(char *)0)
		goto	ERET;

	filsiz = (int)(siz % 4);
	if ( filsiz)	filsiz = 4-filsiz;
	aligne =0;
	chksum = 0;
	while ( siz > 0) {
		if ( siz > RWBUFSIZ)
			rwsiz = RWBUFSIZ;
		else	{
			rwsiz = (int)siz;
			if ( filsiz)
				aligne =1;
		}
		DWORD nByte;
		BOOL res = ReadFile(iFh, buf,(unsigned int)rwsiz, &nByte, NULL );
		if (!res || nByte != (unsigned int)rwsiz)
			goto	ERET;

		if ( aligne ) {
			memset( buf+siz, 0, filsiz);
			rwsiz += filsiz;
		}
		chksum += calchksum( buf, rwsiz);

		res = WriteFile ( oFh, buf, (unsigned int)rwsiz, &nByte, NULL);
		if (!res || nByte !=(unsigned int)rwsiz)
			goto	ERET;
		siz -= rwsiz;
	}
	*cs = chksum;
	free(buf);
	return 0;
ERET:
	if(buf)	free(buf);
	return -1;
}
static int
mergeGlyph(
	HANDLE	iFh,
	HANDLE	oFh,
	struct TableEntry *tep,
	char	*locabuf,
	int	glyphID,
	char	*glyphData,
	int	glyphSiz)
{
	long	*locp;
	long	nloc, cloc;
	long	iofs;
	long	tail;
	long	siz;
	int	gid;
	long	delta;
	unsigned long	cs;
	int	filsiz;
	long	lval;

       if ((iFh == INVALID_HANDLE_VALUE) || (oFh == INVALID_HANDLE_VALUE) || (!tep) || (!locabuf) || (!glyphData))
       {
          goto ERET;
       }
	locp = (long *)locabuf;

	cs = 0;
	/* copy leading */
	cloc = *locp;
	lmtoi( &cloc);
	iofs = (unsigned long)tep->ofs+cloc;
	if ((long) SetFilePointer( iFh, iofs, NULL, FILE_BEGIN) != iofs)
		goto	ERET;
	if ((long) SetFilePointer( oFh, iofs, NULL, FILE_BEGIN) != iofs)
		goto	ERET;
	cloc = *(locp + glyphID);
	lmtoi( &cloc);
	nloc = *(locp + glyphID+1);
	lmtoi( &nloc);
	siz = nloc - cloc;

	if (copyfblock( iFh, oFh, cloc, &cs))
		goto	ERET;
	/* write glyphData */
	if ( glyphSiz>0L) {
		filsiz = glyphSiz % 4;
		if ( filsiz) {
			filsiz = 4 - filsiz;
			memset( glyphData+glyphSiz, 0, filsiz);
			glyphSiz += filsiz;
		}
		DWORD nByte;
		BOOL res = WriteFile( oFh, glyphData, (unsigned int)glyphSiz, &nByte, NULL);
		if (!res || nByte !=(unsigned int)glyphSiz)
			goto	ERET;
		cs += calchksum( glyphData, glyphSiz);
	}
	iofs = nloc + tep->ofs;
	/* copy trailer */
	if ((long) SetFilePointer( iFh, iofs, NULL, FILE_BEGIN) != iofs)
		goto	ERET;
	tail = *(locp+numOfGlyph);
	lmtoi(&tail);
	siz = tail - nloc;
	if (copyfblock( iFh, oFh, siz, &cs))
		goto	ERET;
	/* update loca */
	delta = glyphSiz - (nloc - cloc);
	for ( gid = glyphID+1; gid<=numOfGlyph; gid++) {
		lval = *(locp+gid);
		lmtoi(&lval);
		lval += delta;
		litom(&lval);
		*(locp+gid)=lval;
	}
	tep->siz = tail+delta;
	return 0;
ERET:
	return -1;
}
/***********************************************************************
 *	Add EUDC Font
 */
/* */	int
/* */	TTFAddEUDCChar(
/* */		TCHAR	*path,	/* EUDC FontFile path */
/* */		unsigned short	code, /* Charcode */
/* */	struct BBX	*bbx,	/* Bounding Box */
/* */		int	lstH) /* List Handle for glyph */
/*
 *	returns :0, -1
 ***********************************************************************/
{
struct TTFHeader	hdr;
struct HeadTable	head;
struct MaxpTbl		maxp;
	HANDLE	fH=INVALID_HANDLE_VALUE;
	HANDLE	tmpFh = INVALID_HANDLE_VALUE;
struct TableEntry	*te;
struct TableEntry	*tep;
struct TableEntry	*maxpTep;
struct TableEntry	*locaTep;
	int		glyphID;
struct HMetrics		hmet;
struct VMetrics		vmet;
	int		nEntry;
	char		*updbuf;
	char		*glyphData;
	int		bufsiz;
	int		gdatsiz;
	short		sval;
struct BBX	cbbx;
	TCHAR	tmpPath[MAX_PATH];
	TCHAR	savPath[MAX_PATH];
	int	sts;
  HINSTANCE hInst = AfxGetInstanceHandle();
  TCHAR szMessage[256];

     

	lastErr = 0;
	te = ( struct TableEntry *)0;
	updbuf = (char *)0;
	glyphData = (char *)0;

      if ((!path) || (!bbx))
      {
          goto	ERET;
      }

	fH = CreateFile(path,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fH == INVALID_HANDLE_VALUE)
		goto	ERET;

	TTFTmpPath( path, tmpPath);
	if ( tmpPath[0] == NULL )
		goto ERET;
	
	tmpFh = CreateFile(tmpPath,
					GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
					NULL,
					CREATE_ALWAYS,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( tmpFh == INVALID_HANDLE_VALUE)
		goto	ERET;

	if ( TTFReadHdr( fH, &hdr))
		goto	ERET;
	if ( TTFWriteHdr( tmpFh, &hdr))
		goto	ERET;
	nEntry = hdr.numTables;
	glyphID = codeToGID( code);

	/* Read Table entries */
	if ( (te = (struct TableEntry *)malloc((size_t)sizeof(struct TableEntry)*NUMTABLES))==0)
		goto	ERET;

	if (TTFReadDirEntry( fH, te, nEntry))
		goto	ERET;
	if (TTFWriteDirEntry( tmpFh, te, nEntry))
		goto	ERET;
	if (copyTable( fH, tmpFh, te, nEntry, "cvt "))
		goto	ERET;
	if (copyTable( fH, tmpFh, te, nEntry, "fpgm"))
		goto	ERET;
	if (copyTable( fH, tmpFh, te, nEntry, "prep"))
		goto	ERET;
	if (copyTable( fH, tmpFh, te, nEntry, "name"))
		goto	ERET;
	if (copyTable( fH, tmpFh, te, nEntry, "cmap"))
		goto	ERET;
	if (copyTable( fH, tmpFh, te, nEntry, "OS/2"))
		goto	ERET;
	if (copyTable( fH, tmpFh, te, nEntry, "post"))
		goto	ERET;
	if (copyTable( fH, tmpFh, te, nEntry, "hhea"))
		goto	ERET;
	if (copyTable( fH, tmpFh, te, nEntry, "vhea"))
		goto	ERET;

	/* Read maxp Table */
	if ((maxpTep = searchEntry(te, nEntry, "maxp"))==0)
		goto	ERET;
	if ( TTFReadTable( fH, maxpTep, &maxp, sizeof maxp)!=(sizeof maxp) )
		goto	ERET;
	
	sval = maxp.numGlyph;	
	smtoi( &sval);
	numOfGlyph = sval;

	// Glyph is out of TTE file range, Win9x upgrade
	if (glyphID >= numOfGlyph) 
	    goto ERET;

	bufsiz = sizeof(struct HMetrics)*(numOfGlyph);
	bufsiz = align32( bufsiz);
	if ( (updbuf = (char *)malloc( (size_t)bufsiz))==0)
		goto	ERET;

	/* make metrics for the glyph */
	cbbx = *bbx;
	makeMetrics( lstH, &hmet, &vmet, &cbbx);

	/* make glyph data */
	if ((glyphData = (char *)malloc((size_t)GLYPHBUFSIZ))==0)
		goto	ERET;
	if (sts=makeGlyphData(lstH, &cbbx, glyphData, GLYPHBUFSIZ, &gdatsiz)) {
		lastErr = sts;
		goto	ERET;
	}
	/* set hmetrics */
	sitom( &hmet.advanceWidth);
	sitom( &hmet.leftSideBearing);
	if ((tep = searchEntry(te, nEntry, "hmtx"))==0)
		goto	ERET;
	if ( TTFReadTable( fH, tep, updbuf, bufsiz)<=0)
		goto	ERET;
	*((struct HMetrics *)updbuf + glyphID) = hmet;
	if ( TTFWriteTable( tmpFh, tep, updbuf, bufsiz)<=0)
		goto	ERET;
	free( updbuf);
	updbuf = 0;

	/* Update 'vmtx' */
	bufsiz = sizeof(struct VMetrics)*(numOfGlyph);
	bufsiz = align32( bufsiz);
	if ( (updbuf = (char *)malloc( (size_t)bufsiz))==0)
		goto	ERET;

	/* set vmetrics */
	sitom( &vmet.advanceHeight);
	sitom( &vmet.topSideBearing);
	if ((tep = searchEntry(te, nEntry, "vmtx"))==0)
		goto	ERET;
	if ( TTFReadTable( fH, tep, updbuf, bufsiz)<=0)
		goto	ERET;
	*((struct VMetrics *)updbuf + glyphID) = vmet;
	if ( TTFWriteTable( tmpFh, tep, updbuf, bufsiz)<=0)
		goto	ERET;
	free( updbuf);
	updbuf = 0;

	/* Read loca */
	bufsiz = sizeof(long )*(numOfGlyph+1);
	bufsiz = align32( bufsiz);
	if ( (updbuf = (char *)malloc((size_t)bufsiz)) ==(char *)0)
		goto	ERET;
	if ((locaTep = searchEntry(te, nEntry, "loca"))==0)
		goto	ERET;
	if ( TTFReadTable( fH, locaTep, updbuf, bufsiz)<=0)
		goto	ERET;

	/* move glyf data */
	if ((tep = searchEntry(te, nEntry, "glyf"))==0)
		goto	ERET;
	if (mergeGlyph( fH, tmpFh, tep, updbuf, glyphID, glyphData, gdatsiz ))
		goto	ERET;
	/* read and cal checkSum of 'glyf' */
	if (tableChkSum( tmpFh, tep))
		goto	ERET;

	free( glyphData);
	glyphData =(char *)0;
	/* write loca */
	if ( TTFWriteTable( tmpFh, locaTep, updbuf, bufsiz)<=0)
		goto	ERET;

	/* update maxp */
	if ( updateMaxp( &maxp,  lstH) < 0)
		goto	ERET;
	if (TTFWriteTable(tmpFh, maxpTep, &maxp, sizeof maxp)!=(sizeof maxp))
		goto	ERET;

	/* update directory entry */
	if (TTFWriteDirEntry( tmpFh, te, nEntry))
		goto	ERET;

	/* Set Check sum of file whole to head */
	if ((tep = searchEntry(te, nEntry, "head"))==0)
		goto	ERET;
	if ( TTFReadTable( fH, tep, &head, sizeof head)<=0)
		goto	ERET;
	tep->checkSum = 0L;
	if ( TTFWriteTable( tmpFh, tep, &head, sizeof head)<=0)
		goto	ERET;
	if (fileChkSum(tmpFh , te, nEntry, &hdr, &head))
		goto	ERET;
	if ( TTFWriteTable( tmpFh, tep, &head, sizeof head)<=0)
		goto	ERET;

	CloseHandle( fH);
	CloseHandle( tmpFh);

//	fH = tmpFh = -1;

  TTFTmpPath( path, savPath); 
  if( DeleteFile( savPath)==0) {
    TCHAR szTitle[256];
    LoadString(hInst, IDS_MAINFRAMETITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
    LoadString(hInst, IDS_NOMEM_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));
    MessageBox( AfxGetMainWnd()->GetSafeHwnd(), szMessage, szTitle, MB_OK);
		goto	ERET2;
  }
	if( MoveFile( path, savPath)==0) {
    TCHAR szTitle[256];
    LoadString(hInst, IDS_MAINFRAMETITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
    LoadString(hInst, IDS_NOMEM_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));
    MessageBox( AfxGetMainWnd()->GetSafeHwnd(), szMessage, szTitle, MB_OK);
    goto	ERET2;
	}
  if( MoveFile( tmpPath, path)==0) {
    TCHAR szTitle[256];
    LoadString(hInst, IDS_MAINFRAMETITLE, szTitle, sizeof(szTitle) / sizeof(TCHAR));
    LoadString(hInst, IDS_NOMEM_MSG, szMessage, sizeof(szMessage) / sizeof(TCHAR));
    MessageBox( AfxGetMainWnd()->GetSafeHwnd(), szMessage, szTitle, MB_OK);
		goto	ERET2;
  }
  if ( DeleteFile( savPath) ==0) {
    DeleteFile(path);
    MoveFile(savPath, path);
	  if ( te)	free(te);
    if ( updbuf)	free(updbuf);
	  if ( glyphData)	free(glyphData);
    return -3; //tte file is being used by another process
  }

  free( te);
	free( updbuf);
	return 0;

ERET:
	if ( fH != INVALID_HANDLE_VALUE)	CloseHandle(fH);
	if ( tmpFh != INVALID_HANDLE_VALUE)	CloseHandle(tmpFh);
	if ( te)	free(te);
	if ( updbuf)	free(updbuf);
	if ( glyphData)	free(glyphData);
	return -1;

ERET2:
	if ( fH != INVALID_HANDLE_VALUE)	CloseHandle(fH);
	if ( tmpFh != INVALID_HANDLE_VALUE)	CloseHandle(tmpFh);
	if ( te)	free(te);
	if ( updbuf)	free(updbuf);
	if ( glyphData)	free(glyphData);
	if ( tmpPath) DeleteFile( tmpPath);
	return -1;
}


/***********************************************************************
 *	For Import
 */
static HANDLE eudcFh;
static char *locaBuf = 0;
static char *maxpBuf = 0;
static char	*hmtxBuf = 0;
static char	*vmtxBuf = 0;
static char	*glyphBuf = 0;

static void
frebuf()
{
	if ( locaBuf) {
		free( locaBuf);
		locaBuf = 0;
	}
	if ( maxpBuf) {
		free( maxpBuf);
		maxpBuf = 0;
	}
	if ( vmtxBuf) {
		free( vmtxBuf);
		vmtxBuf = 0;
	}
	if ( hmtxBuf) {
		free( hmtxBuf);
		hmtxBuf = 0;
	}
	if ( glyphBuf) {
		free( glyphBuf);
		glyphBuf = 0;
	}
	if ( et) {
		free( et);
		glyphBuf = 0;
	}
	return;
}
int
TTFOpen( TCHAR *path)
{
struct TTFHeader	hdr;
unsigned int	bufsiz;
unsigned short	sval;
      
      if (!path)
      {
          eudcFh = INVALID_HANDLE_VALUE;
          goto	ERET;
      }
       
	et = 0;
	eudcFh = CreateFile(path,
					GENERIC_READ | GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( eudcFh == INVALID_HANDLE_VALUE)
		goto	ERET;

	if (TTFReadHdr(eudcFh,&hdr))
		goto	ERET;

	if ((et = (struct TableEntry *)malloc( sizeof (struct TableEntry)*hdr.numTables))
			==0)
		goto	ERET;
	entryNum = hdr.numTables;
	if (TTFReadDirEntry(eudcFh, et, hdr.numTables))
		goto	ERET;

	if (TTFReadVarTable( eudcFh, &maxpBuf, &bufsiz, "maxp"))
		goto	ERET;
	sval = ((struct MaxpTbl *)maxpBuf) ->numGlyph;
	smtoi( (short *)&sval);
	numOfGlyph = sval;

	if (TTFReadVarTable( eudcFh, &locaBuf, &bufsiz, "loca"))
		goto	ERET;
	if (TTFReadVarTable( eudcFh, &hmtxBuf, &bufsiz, "hmtx"))
		goto	ERET;
	if (TTFReadVarTable( eudcFh, &vmtxBuf, &bufsiz, "vmtx"))
		goto	ERET;
	if ((glyphBuf = (char *)malloc( GLYPHBUFSIZ))==0)
		goto	ERET;
	return 0;
ERET:
	if ( eudcFh != INVALID_HANDLE_VALUE) {
		CloseHandle( eudcFh);
		eudcFh = INVALID_HANDLE_VALUE;
	}
	frebuf();
	return -1;
}
int
TTFClose()
{
struct TableEntry	*tep;
struct HeadTable	head;
struct TTFHeader	hdr;
	long		ofs;
	if ( eudcFh == INVALID_HANDLE_VALUE)
		return -1;
	if (TTFReadHdr( eudcFh, &hdr))
		goto	ERET;
	/* obtain glyph table size */
	ofs = SetFilePointer( eudcFh, 0L, NULL, FILE_END);

	/* Update Glyph checkSum */
	if ((tep = searchEntry(et, entryNum, "glyf"))==0)
		goto	ERET;
	tep->siz = ofs - tep->ofs;

	/* read and cal checkSum of 'glyf' */
	if (tableChkSum( eudcFh, tep))
		goto	ERET;

	if ((tep = searchEntry(et, entryNum, "maxp"))==0)
		goto	ERET;

	if (TTFWriteTable( eudcFh, tep, maxpBuf, (int)tep->siz)!=(int)tep->siz)
		goto	ERET;

	if ((tep = searchEntry(et, entryNum, "loca"))==0)
		goto	ERET;

	if (TTFWriteTable( eudcFh, tep, locaBuf, (int)tep->siz)!=(int)tep->siz)
		goto	ERET;
	
	if ((tep = searchEntry(et, entryNum, "hmtx"))==0)
		goto	ERET;
	if (TTFWriteTable( eudcFh, tep, hmtxBuf, (int)tep->siz)!=(int)tep->siz)
		goto	ERET;
	if ((tep = searchEntry(et, entryNum, "vmtx"))==0)
		goto	ERET;
	if (TTFWriteTable( eudcFh, tep, vmtxBuf, (int)tep->siz)!=(int)tep->siz)
		goto	ERET;
	if ((tep = searchEntry(et, entryNum, "head"))==0)
		goto	ERET;

	if ( TTFReadTable(eudcFh, tep, &head, sizeof(head))!=sizeof(head))
		goto	ERET;

	if ( fileChkSum(eudcFh, et, entryNum, &hdr, &head))
		goto	ERET;

	if ( TTFWriteDirEntry( eudcFh, et, entryNum))
		goto	ERET;
	CloseHandle( eudcFh);
	frebuf();
	return 0;
ERET:
	CloseHandle( eudcFh);
	frebuf();
	return -1;
}
int
TTFGetEUDCBBX(TCHAR *path, struct BBX *bbx, short *upem)
{
struct	HeadTable	head;
	HANDLE	fH=INVALID_HANDLE_VALUE;

       if ((!path) || (!bbx) || (!upem))
       {
           goto	ERET;
       }
	fH = CreateFile(path,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fH == INVALID_HANDLE_VALUE)
		goto	ERET;

	if ( TTFReadFixedTable(fH, (char *)&head,sizeof head,"head"))
		goto	ERET;
	smtoi( &head.xMin);
	smtoi( &head.xMax);
	smtoi( &head.yMin);
	smtoi( &head.yMax);
	smtoi( &head.unitsPerEm);
	bbx->xMin = head.xMin;
	bbx->xMax = head.xMax;
	bbx->yMin = head.yMin;
	bbx->yMax = head.yMax;
	*upem = head.unitsPerEm;
	if ( bbx->xMin < 0 )
		bbx->xMin = 0;
	CloseHandle( fH);
	return 0;
ERET:
	if (fH!=INVALID_HANDLE_VALUE)
		CloseHandle( fH);
	return -1;
}
static void
makeMetrics(int lsthdl, struct HMetrics *hM, struct VMetrics *vM, struct BBX *bbx)
{
struct VHEAD	*vhd;
struct VDATA	*vp;
	int	np;
	int	sts;
	int	xmin, ymin, xmax, ymax;

       if ((!hM) || (!vM) || (!bbx))
       {
           return;
       }
	if ( (sts = VDGetHead( lsthdl, &vhd))!=0)
		goto	RET;
	if ( (sts = VDGetNCont( lsthdl))<=0)
		goto	SPACE_CHAR;
	xmin = xmax = vhd->headp->vd.x;
	ymin = ymax = vhd->headp->vd.y;
	while ( vhd->next != NIL) {
		vp = vhd->headp;
		np = vhd->nPoints;
		while ( np-->0) {
			if (vp->vd.x > xmax)
				xmax = vp->vd.x;
			else if(vp->vd.x < xmin)
				xmin = vp->vd.x;
			if (vp->vd.y > ymax)
				ymax = vp->vd.y;
			else if(vp->vd.y < ymin)
				ymin = vp->vd.y;
			vp = vp->next;
		}
		vhd = vhd->next;
	}
//	if ( xmin < 0)
//		xmin = 0;
	hM->leftSideBearing = (short)xmin;
  hM->advanceWidth = bbx->xMax - bbx->xMin;
  {
    int hmw = hM->advanceWidth + 1;
    int ii = 0;
    while (hmw >> 1)
      {
        hmw >>= 1;
        ii++;
      }
    hmw = 1;
    while (ii--) hmw *= 2;
    int gap1 = hM->advanceWidth - hmw;
    int gap2 = hmw*2 - hM->advanceWidth;
    hmw = gap1 > gap2 ? hmw * 2 : hmw;
    hM->advanceWidth = (short)hmw;
  } 
	vM->topSideBearing = bbx->yMax - ymax;
	if (vM->topSideBearing < 0)
		vM->topSideBearing = 0;
	vM->advanceHeight = bbx->yMax - bbx->yMin;
	bbx->xMin = xmin;
	bbx->yMin = ymin;
	bbx->xMax = xmax;
	bbx->yMax = ymax;
	return;
RET:

SPACE_CHAR:
	hM->leftSideBearing = (short)bbx->xMax;
	hM->advanceWidth = bbx->xMax - bbx->xMin;
	vM->topSideBearing = bbx->yMax - bbx->yMin;
	vM->advanceHeight = bbx->yMax - bbx->yMin;
	bbx->xMin = bbx->xMax;
	bbx->yMax = bbx->yMin;
	return;
}

int
TTFAppend( unsigned short code,  struct BBX *bbx, int lsthdl)
{
	int	glyphID;
struct HMetrics	hmet;
struct VMetrics	vmet;
	int	updflg;
	int	gdatsiz;
struct BBX	cbbx;
	int	sts;

       if (!bbx)
       {
          goto ERET;
       }
	glyphID = codeToGID( code);
	lastErr = 0;
	/* make metrics */
	cbbx = *bbx;
	makeMetrics( lsthdl, &hmet, &vmet, &cbbx);

	/* make glyph data */
	if (sts =makeGlyphData(lsthdl, &cbbx, glyphBuf, GLYPHBUFSIZ, &gdatsiz)) {
		lastErr = sts;
		goto	ERET;
	}
	/* set hmetrics */
	sitom( &hmet.advanceWidth);
	sitom( &hmet.leftSideBearing);
	*((struct HMetrics *)hmtxBuf + glyphID) = hmet;

	/* Update 'vmtx' */
	sitom( &vmet.advanceHeight);
	sitom( &vmet.topSideBearing);
	*((struct VMetrics *)vmtxBuf + glyphID) = vmet;

	/* write glyf data */
	if (TTFImpGlyphWrite( glyphID, glyphBuf, gdatsiz))
		goto	ERET;
	/* update maxp */
	if ((updflg = updateMaxp( (struct MaxpTbl *)maxpBuf,  lsthdl)) < 0)
		goto	ERET;
	return 0;
ERET:
	return -1;
}
/*
 * Copy
 */
int
TTFImpCopy( TCHAR *sPath, TCHAR *dPath)
{
	HANDLE	sFh, dFh;
struct TTFHeader	hdr;
struct TableEntry	*te;
	int		tblSiz;
	int		ntbl;
	int		tcnt;
	char	*buf;
	int	bufsiz;

	sFh = dFh = INVALID_HANDLE_VALUE;
	te = 0;
	buf  = 0;

       if ( (!sPath) || (!dPath))
       {
           goto	ERET;
       }

  /* Open src */
	sFh = CreateFile(sPath,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);
	if (sFh == INVALID_HANDLE_VALUE)
		goto	ERET;
	/* create open destination*/
	dFh = CreateFile(dPath,
					GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
					NULL,
					CREATE_ALWAYS,
					FILE_ATTRIBUTE_NORMAL,
					NULL);
	if (dFh == INVALID_HANDLE_VALUE)
		goto	ERET;
	
	/* read header */
	if ( TTFReadHdr( sFh, &hdr))
		goto	ERET;
	ntbl = (int)hdr.numTables;
	/* write header */
	if ( TTFWriteHdr( dFh, &hdr))
		goto	ERET;
	
	/* read directory entry */
	tblSiz = sizeof( struct TableEntry)*ntbl;
	if ((te = (struct TableEntry *)malloc(tblSiz))==(struct TableEntry *)0)
		goto	ERET;

	if ( TTFReadDirEntry(sFh, te, ntbl))
		goto	ERET;

	/* write directory entry */
	if ( TTFWriteDirEntry(dFh, te, ntbl))
		goto	ERET;

	/* copy each table (except glyph)*/
	for ( tcnt = 0; tcnt < ntbl; tcnt++) {
		if ( memcmp((te+tcnt)->tagName,"glyf", 4)) {
			bufsiz = (int)(te+tcnt)->siz;
			buf = (char *)malloc((int)(te+tcnt)->siz);
			if (TTFReadTable( sFh, te+tcnt, buf, bufsiz)!=bufsiz)
				goto	ERET;
			if (TTFWriteTable( dFh, te+tcnt, buf, bufsiz)!=bufsiz)
				goto	ERET;
			free( buf);
			buf = 0;
		}
	}
	/* close */
	CloseHandle( sFh);
	CloseHandle( dFh);
	free( te);
	return 0;
ERET:
  if (sFh != INVALID_HANDLE_VALUE) CloseHandle(sFh);
  if (dFh != INVALID_HANDLE_VALUE) CloseHandle(dFh);
	if (te)
		free( te);
	if ( buf)	free( buf);
	return -1;
}
int
TTFImpGlyphCopy(
	HANDLE	sFh,
	int	glyphID)
{
struct TableEntry *tep;
	long	*locap;
	long	cloc, nloc;
	long	siz;
	long	ofs;
	long	wofs;
	char	*buf;
	DWORD	nByte;

	buf = 0;
	if ((tep = searchEntry( et, entryNum, "glyf"))==0)
		goto	ERET;
	locap = (long *)locaBuf;
	cloc = *(locap+glyphID);
	lmtoi( &cloc);
	nloc = *(locap+glyphID+1);
	lmtoi( &nloc);
	siz = nloc - cloc;
	ofs = tep->ofs + cloc;

	if ( (long) SetFilePointer( sFh, ofs, NULL, FILE_BEGIN) != ofs)
		goto	ERET;

	wofs = SetFilePointer( eudcFh, 0L, NULL, FILE_END);
	wofs -= tep->ofs;
	litom( &wofs);
	*(locap+glyphID) = wofs;
	if ( siz) {
		if ( (buf = (char *)malloc((int)siz))==(char *)0)
			goto	ERET;

		BOOL res = ReadFile( sFh, buf, (unsigned int)siz, &nByte, NULL);
		if (!res ||	nByte !=(unsigned int)siz)
			goto	ERET;

		res = WriteFile( eudcFh, buf,(unsigned int)siz, &nByte, NULL);
		if (!res ||	nByte !=(unsigned int)siz)
			goto	ERET;
	}
	free( buf);
	return 0;
ERET:
	if ( buf)	free( buf);

	return -1;
}
int
TTFImpGlyphWrite(
	int	glyphID, char *glyph, int siz)
{
struct TableEntry *tep;
	long	ofs;
	long	wofs;
	long	*locap;
	DWORD	nByte;

	if ( glyphID >= numOfGlyph)
		return -1;
	if ((tep = searchEntry( et, entryNum, "glyf"))==0)
		goto	ERET;
	
	wofs =  SetFilePointer( eudcFh, 0L, NULL, FILE_END);
	ofs = wofs - tep->ofs;
	litom( &ofs);
	locap = (long *)locaBuf;
	*(locap+glyphID) = ofs;
	if ( siz) {
		BOOL res = WriteFile(eudcFh, glyph, (unsigned int)siz, &nByte, NULL);
		if (!res || nByte !=(unsigned int)siz)
			goto	ERET;
	}
	return 0;
ERET:
	return -1;
}

int
TTFImpTerm(HANDLE orgFh, int glyphID)
{
struct TableEntry *tep;
	
	long	ofs;
	long	wofs;
	long	*locap;
	int		gid;
	
      if (orgFh == INVALID_HANDLE_VALUE)  
      {
           return -1;
      }
	//
	// copy the rest of the glyph data over.
	//
	for ( gid = glyphID; gid < numOfGlyph; gid++)
	{
		if (TTFImpGlyphCopy(orgFh, gid))
			return -1;
	}

	if ((tep = searchEntry( et, entryNum, "glyf"))==0)
		return -1;
	locap = (long *)locaBuf;
	wofs =  SetFilePointer( eudcFh, 0L,NULL, FILE_END);
	ofs = wofs - tep->ofs;
	litom( &ofs);
	*(locap + numOfGlyph) = ofs;
	tep->siz = wofs - tep->ofs;

	return 0;

}
int
TTFLastError()
{
	return lastErr;
}
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\util.h ===
/**************************************************/
/*					                              */
/*					                              */
/*	EudcEditor Utillity funcs	                  */
/*					                              */
/*					                              */
/* Copyright (c) 1997-1999 Microsoft Corporation. */
/**************************************************/

int  OutputMessageBox( HWND hWnd, UINT TitleID, UINT MessgID, BOOL OkFlag);
#ifdef BUILD_ON_WINNT
int  OutputMessageBoxEx( HWND hWnd, UINT TitleID, UINT MessgID, BOOL OkFlag, ...);
#endif // BUILD_ON_WINNT
void GetStringRes( LPTSTR lpStr, UINT sID, int nLength);
void ConvStringRes( LPTSTR lpStr, CString String, int nDestSize);

#ifdef UNICODE
#define Mytcsrchr wcsrchr
#define Mytcschr wcschr
#define Mytcstok wcstok
#define Mytcstol wcstol
#define Mytcsstr wcsstr
#define Myttoi _wtoi
#else
char * Mystrrchr(char *pszString, char ch);
char * Mystrchr(char *pszString, char ch);
#define Mytcsrchr Mystrrchr
#define Mytcschr Mystrchr
#define Mytcstok strtok
#define Mytcstol strtol
#define Mytcsstr strstr
#define Myttoi atoi
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\vdata.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//

#include	"stdafx.h"


#define		LISTDATAMAX	4

#define		NIL	(void *)0

struct vecdata	{
	short	x, y, atr;
	};

struct VDATA	{
	struct VDATA	*next, *prev;
	struct vecdata	vd;
	};

struct VHEAD	{
	struct VHEAD	*next, *prev;
	struct VDATA	*headp;
	int		nPoints;
	};
struct VCNTL	{
	struct VHEAD	*rootHead;
	struct VHEAD	*currentHead;
	int		nCont;
	struct VDATA	*cvp;
	int	mendp;
	void	*memroot;
	void	*cmem;
	};


int  VDInit(void);
void  VDTerm(void);
void  VDNew(int  lsthdl);
int  VDClose(int  lsthdl);
int  VDSetData(int  lsthdl,struct  vecdata *pnt);
int  VDGetData(int  lsthdl,int  contN,int  pn,struct  vecdata *pnt);
int  VDGetHead(int  lsthdl,struct  VHEAD * *vhd);
static void  *getmem(int  lsthdl,int  siz);
int  VDGetNCont(int  lstHdl);
int  VDReverseList(int  lstHdl);
int  VDCopy(int  srcH,int  dstH);

struct VCNTL	VCntlTbl[LISTDATAMAX];
#define		ALLOCMEMUNIT	2048

static int	init=0;
/***********************************************************************
 *	initialize data
 */
/* */	int
/* */	VDInit()
/*
 *	returns : 0, -1( out of memory)
 ***********************************************************************/
{
	int	lsthdl;
	void	*mem;

	if ( init)
		return( 0);
	for( lsthdl = 0; lsthdl < LISTDATAMAX; lsthdl++) {
		/* Allocate First memory */
		mem = (void *)malloc( ALLOCMEMUNIT);
		if ( mem==NIL)	
			return( -1);
		*((void **)mem) = NIL;
		VCntlTbl[lsthdl].memroot = mem;
		VDNew(lsthdl);
	}

	init = 1;
	return( 0);
}
/***********************************************************************
 *	Terminate
 */
/* */	void
/* */	VDTerm()
/*
 *	returns : none
 ***********************************************************************/
{
	void	*mem, *nextmem;
	int	lsthdl;
	if ( init) {
		for( lsthdl = 0; lsthdl < LISTDATAMAX; lsthdl++) {
			mem = VCntlTbl[lsthdl].memroot;
			do {
				nextmem = *((void * *)mem);
				free( mem);
				mem = nextmem;
			} while ( mem!=NIL);
		}
		init = 0;
	}
	return;
}
/***********************************************************************
 *	New Data
 */
/* */	void
/* */	VDNew(int lsthdl)
/*
 *	returns : none
 ***********************************************************************/
{
struct VCNTL	*vc;

	vc = VCntlTbl+lsthdl;
	vc->cmem = vc->memroot;
	vc->mendp  =  sizeof( void *);
	vc->currentHead = vc->rootHead = (struct VHEAD *)((char *)(vc->cmem)+vc->mendp);
	vc->mendp += sizeof( struct VHEAD);

	vc->currentHead->prev = (struct VHEAD *)NIL;
	vc->currentHead->next = (struct VHEAD *)NIL;
	vc->currentHead->headp = (struct VDATA *)NIL;
	vc->currentHead->nPoints = 0;
	vc->cvp = (struct VDATA *)NIL;
	vc->nCont = 0;

}
/***********************************************************************
 *	Close Contour
 */
/* */	int
/* */	VDClose(int lsthdl)
/*
 *	returns : none
 ***********************************************************************/
{
struct VHEAD	*vh;
struct VCNTL	*vc;

	vc = VCntlTbl+lsthdl;

	vc->cvp->next = vc->currentHead->headp;
	vc->currentHead->headp->prev = vc->cvp;
	vh = (struct VHEAD *)getmem( lsthdl, sizeof(struct VHEAD));
	if ( vh == NIL)	return( -1);
	vc->currentHead->next = vh;
	vh->prev = vc->currentHead;
	vh->next = (struct VHEAD *)NIL;
	vh->headp = (struct VDATA *)NIL;
	vh->nPoints = 0;
	vc->currentHead = vh;
	vc->cvp = (struct VDATA *)NIL;
	vc->nCont++;

	return (0);
}
/***********************************************************************
 *	Set Data
 */
/* */	int
/* */	VDSetData ( 
/* */		int lsthdl,
/* */	struct vecdata	*pnt)
/*
 *	return : 0, -1 ( no memory)
 ***********************************************************************/
{
	void	*mem;
struct VCNTL	*vc;

       
       if (!pnt)
       {
           return -1;
       }
	vc = VCntlTbl+lsthdl;

	mem = getmem( lsthdl,sizeof(  struct VDATA));
	if ( mem == NIL) {
		return -1;
	}
	if ( vc->cvp== NIL) {	/* Contour First Point*/
		vc->cvp = vc->currentHead->headp = (struct VDATA *)mem;
		vc->cvp->vd = *pnt;
		vc->cvp->next = vc->cvp->prev= (struct VDATA *)NIL;
	}
	else {
		vc->cvp->next = (struct VDATA *)mem;
		vc->cvp->next->prev = vc->cvp;
		vc->cvp = vc->cvp->next;
		vc->cvp->vd = *pnt;
		vc->cvp->next =(struct VDATA *) NIL;
	}
	vc->currentHead->nPoints++;
	return  0;
}
/***********************************************************************
 *	Get Data
 */
/* */	int
/* */	VDGetData( 
/* */	int	lsthdl, 
/* */	int	contN, 
/* */	int	pn, 
/* */	struct  vecdata *pnt)
/*
 *	returns : 0, -1 ( Illeagal Coontour Number)
 ***********************************************************************/
{
struct VHEAD	*vhd;
struct VDATA	*cvd;


       if (!pnt)
       {
           return -1;
       }
	if ( lsthdl <0 ||lsthdl >= LISTDATAMAX) 
		return -1;
	if ((vhd = VCntlTbl[lsthdl].rootHead)==NIL)
		return -1;
	while ( contN-->0)
		vhd = vhd->next;
	cvd = vhd->headp;
	while ( pn-->0)
		cvd = cvd->next;

	*pnt = cvd->vd;

	return	0;
}
/***********************************************************************
 *	Get Data Head
 */
/* */	int
/* */	VDGetHead( 
/* */	int	lsthdl, 
/* */	struct VHEAD	**vhd)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
       if (!vhd)
       {
           return -1;
       }
	if ( lsthdl >= 0 && lsthdl < LISTDATAMAX) {
		*vhd = VCntlTbl[lsthdl].rootHead;
		return( 0);
	}
	else
		return( -1);
}
/***********************************************************************
 *	Get Memory
 */
/* */	static void *
/* */	getmem(	int lsthdl, int	siz)
/*
 *	returns : 0, -1
 ***********************************************************************/
{
	void	*mem;
struct VCNTL	*vc;

	vc = VCntlTbl+lsthdl;

	if ( vc->mendp + siz >= ALLOCMEMUNIT) {
		mem = *((void **)vc->cmem);
		if ( mem == NIL ) {
			mem = (void *)malloc(ALLOCMEMUNIT);
			if ( mem == NIL)
				return( NIL);
			*((void * *)mem) = NIL;
			*((void * *)vc->cmem) = mem; /* */
			vc->cmem = mem;
		}
		else
			vc->cmem  = mem;
		vc->mendp = sizeof(void *); 
	}
	mem = (void *)((char *)(vc->cmem) + vc->mendp);
	vc->mendp += siz;
	return(mem );
}
/***********************************************************************
 *	Get Number of COntours
 */
/* */	int
/* */	VDGetNCont( int lstHdl)
/*
 *	returns : Number of Contour
 ***********************************************************************/
{
	if ( lstHdl >= 0 && lstHdl < LISTDATAMAX)
		return VCntlTbl[lstHdl].nCont;
	else
		return( -1);
}
/***********************************************************************
 *	Reverse List
 */
/* */	int
/* */	VDReverseList(  int lstHdl)
/*
 *	returns : 0, -1 ( handle No )
 ***********************************************************************/
{
	int	cont;
	int	np;
struct VHEAD	*vh;
struct VDATA	*vp, *nvp;

	if ( lstHdl < 0 || lstHdl >= LISTDATAMAX)
		return -1;
	vh = VCntlTbl[lstHdl].rootHead;
	for ( cont = 0; cont < VCntlTbl[lstHdl].nCont; cont++ ) {
		vp = vh ->headp;
		np = vh->nPoints;
		while ( np-->0) {
			nvp = vp->next;
			vp->next = vp->prev;
			vp->prev = nvp;
			vp = nvp;
		}
		vh = vh->next;
	}
	return 0;
}
/***********************************************************************
 *	Copy Data
 */
/* */	int
/* */	VDCopy( int srcH, int dstH)
/*
 *	returns : 0, -1(Invalid Handle)
 ***********************************************************************/
{
	int	cont;
	int	np;
struct VHEAD	*vh;
struct VDATA	*vp;

	if ( srcH < 0 || srcH >= LISTDATAMAX
	  || dstH < 0 || dstH >= LISTDATAMAX)
		return -1;

	VDNew( dstH);

	vh = VCntlTbl[srcH].rootHead;
	for ( cont = 0; cont < VCntlTbl[srcH].nCont; cont++ ) {
		vp = vh ->headp;
		np = vh->nPoints;
		while ( np-->0) {
			if ( VDSetData( dstH, &vp->vd))
				return -1;
			vp = vp->next;
		}
		vh = vh->next;
		VDClose( dstH);
	}
	return 0;
}
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\w31jbmp.cpp ===
/*
 *	Win3.1J EUDC fontfile i/o ( MS-Code base)
 *
 * Copyright (c) 1997-1999 Microsoft Corporation.
 */


#include	"stdafx.h"
#pragma		pack(2)

#include	"extfunc.h"
/*
 File Structure */

struct W31_Header {
	char	identify[72];
	short	segCnt;		/* ??? */
unsigned short	sCode,
		eCode;
	short	cCnt;
	long	ofsCmap;
	short	sizCmap;
	long	ofsFil;
	short	sizFil;
	long	ofsStbl;	/* search tbl*/
	short	sizStbl;
	long	ofsBdatSub;
	};

struct BDatSubTbl {
	long	tail;
	long	ptrOfs;
	long	head;
	short	filler2;
	/* Following Pointer tbl. */
	};
struct BMPHeader {
	long	bitmapSiz;
	short	xsiz, ysiz;
	};

#define		EUDCCODEBASE	((unsigned short)0xe000)


int  OpenW31JBMP(TCHAR  *path,int  omd);
int  CloseW31JBMP(void);
int  isW31JEUDCBMP(TCHAR  *path);
int  GetW31JBMPnRecs(int *nRec, int *nGlyph, int *xsiz, int *ysiz);
int  GetW31JBMPMeshSize( int *xsiz, int *ysiz);
static int  readcmap(void);
static int  rectocode(int  rec,unsigned short  *code);
static int  searchCode(unsigned short  code);
int  GetW31JBMP(unsigned short  code,LPBYTE buf,int  bufsiz,int  *xsiz,int  *ysiz);
int  GetW31JBMPRec(int  rec,LPBYTE buf,int  bufsiz,int  *xsiz,int  *ysiz,unsigned short  *code);
int  PutW31JBMPRec(int  rec,LPBYTE buf,int  xsiz,int  ysiz);
static int  ReadBMPHdr(HANDLE hdl,long  ofs,struct  BMPHeader *bhdr);
static int  WriteBMPHdr(HANDLE hdl,long  ofs,struct  BMPHeader *bhdr);

static int	init = 0;
static HANDLE	fHdl;
struct W31_Header hdr;
struct BDatSubTbl bdTbl;
static int	rwmode = 0;
static long	*ofstbl=0;
static unsigned short	*cmap=0;
static int	*recordTbl=0;
/***************************************************************
 *	Initialize
 */
/* */	int
/* */	OpenW31JBMP( TCHAR *path, int omd)
/*
 *	returns : 0, -1
 ***************************************************************/
{
	int	msiz;
	DWORD nByte;
	BOOL res;

       if ( !path)
       {
           return -1;
       }
	/* open EUDC Font File */
	rwmode = omd ? 1 : 0;
	fHdl = CreateFile(path,
					omd==0 ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fHdl == INVALID_HANDLE_VALUE)
		return -1;

	/* Read Header */
	res = ReadFile( fHdl, (LPBYTE)&hdr, sizeof(struct W31_Header), &nByte, NULL);
	if (!res || nByte !=sizeof(struct W31_Header))
		goto	ERET;

    //
    // WinSE #13986, 
    // In Win9x, character number could be well over 1880,
    // EUDC EUF file will be trashed if we limit character number to 1880
    //    
    /*
	if( hdr.cCnt > 1880)
		hdr.cCnt = 1880;
    */

	/* allocate ofs. tbl. */
	msiz = hdr.cCnt*sizeof(long);
	if ((ofstbl = (long *)malloc( msiz))==(long *)0)
		goto	ERET;

	/* Read Ofs. tbl.*/
	if ( (long) SetFilePointer( fHdl, hdr.ofsBdatSub, NULL, FILE_BEGIN)!=hdr.ofsBdatSub)
		goto	ERET;
	res = ReadFile( fHdl, (LPBYTE)&bdTbl, sizeof(bdTbl), &nByte, NULL);
	if (!res || nByte !=sizeof(bdTbl))
		goto	ERET;

	res = ReadFile( fHdl, (LPBYTE)ofstbl, (unsigned int)msiz, &nByte, NULL);
	if (!res || nByte !=(unsigned int)msiz)
		goto	ERET;

	init = 1;
/*	
  if (fHdl != INVALID_HANDLE_VALUE)
  {
    CloseHandle(fHdl);
    fHdl = INVALID_HANDLE_VALUE;
  }
*/
	return	0;
ERET:
	if (fHdl != INVALID_HANDLE_VALUE)
  {
		CloseHandle (fHdl);
    fHdl = INVALID_HANDLE_VALUE;
  }

	if (ofstbl)
  {
		free( ofstbl);
    ofstbl = 0;
  }
	return -1;
}
/***************************************************************
 *	Terminate Close
 */
/* */	int
/* */	CloseW31JBMP()
/*
 *	returns : none
 ***************************************************************/
{
	unsigned int	siz;
	DWORD nByte;
	BOOL res;

	if ( rwmode>=1) {
		/* update ofstbl*/
		if ((long) SetFilePointer( fHdl, hdr.ofsBdatSub, NULL, FILE_BEGIN)!=hdr.ofsBdatSub)
			goto	ERET;
		res = WriteFile( fHdl, (LPBYTE)&bdTbl, sizeof( bdTbl), &nByte, NULL);
		if (!res || nByte !=sizeof(bdTbl))
			goto	ERET;
		siz = (unsigned int)hdr.cCnt*sizeof(long);
		res = WriteFile( fHdl, (LPBYTE)ofstbl, siz, &nByte, NULL);
		if (!res || nByte !=siz)
			goto	ERET;
	}
	if ( fHdl !=INVALID_HANDLE_VALUE) {
		CloseHandle( fHdl);
		fHdl = INVALID_HANDLE_VALUE;
	}
	if ( ofstbl) {
		free(ofstbl);
		ofstbl = 0;
	}
	if ( cmap) {
		free(cmap);
		cmap = 0;
	}
	if ( recordTbl) {
		free(recordTbl);
		recordTbl = 0;
	}

	init = 0;
	return 0;
ERET:
	return -1;
}
/***************************************************************
 *	is Win3.1J EUDC bitmap
 */
/* */	int
/* */	isW31JEUDCBMP( TCHAR *path)
/*
 *	returns : 0 (other), 1 (EUDC bitmap), -1(error)
 ***************************************************************/
{
	HANDLE fhdl;
struct W31_Header hdr31;
	DWORD nByte;
	BOOL res;

       if (!path)
       {
           return -1;
       }
	fhdl = CreateFile(path,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fhdl == INVALID_HANDLE_VALUE)
		return -1;
	res = ReadFile( fhdl, (LPBYTE)&hdr31, sizeof(hdr31), &nByte, NULL);
	if (!res || nByte !=sizeof(hdr31))
		goto	NO_WIN31J;
	CloseHandle( fhdl);
  fhdl = INVALID_HANDLE_VALUE;

	/* compare idendify leading 16 byte, sCode, eCode and cCnt*/
	if (memcmp( hdr31.identify, "WINEUDC2Standard", 16))
		goto	NO_WIN31J;
#if 0
	if ( hdr31.sCode != 0x40f0 || hdr31.eCode != 0xfcf9 || hdr31.cCnt != 1880)
#endif
	if( hdr31.sCode != 0x40f0)
		goto	NO_WIN31J;
	return 1;

NO_WIN31J:
  if (fhdl != INVALID_HANDLE_VALUE)
  {
    CloseHandle(fhdl);
    fhdl = INVALID_HANDLE_VALUE;
  }
	return 0;
}
/***************************************************************
 *	Get number of records
 */
/* */	int
/* */	GetW31JBMPnRecs( int *nRec, int *nGlyph, int *xsiz, int *ysiz)
/*
 *	returns : 0, -1
 ***************************************************************/
{
struct BMPHeader	fhdr;
	long	ofs;
	BOOL	bFirst;
	int	rec;
	int	gc;
	DWORD nByte;
	BOOL res;

       if ((!nRec) || (!nGlyph) || (!xsiz) || (!ysiz))
       {
          return -1;
       }
	bFirst = FALSE;
	if ( init==0 || fHdl == INVALID_HANDLE_VALUE)
		return -1;
	else {
		gc = 0;
		for ( rec = 0; rec < (int)hdr.cCnt; rec++) {
			if( *(ofstbl+rec)){
				if( !bFirst){
					ofs = *(ofstbl+rec);
					ofs += hdr.ofsBdatSub;
					if ( (DWORD) SetFilePointer( fHdl,ofs, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
          {
            DWORD dwErr = GetLastError();
						goto	ERET;
          }

					res = ReadFile( fHdl, (LPBYTE)&fhdr,
					     sizeof(struct BMPHeader), &nByte, NULL);
					if (!res || nByte != sizeof( struct BMPHeader))
						goto	ERET;

					bFirst = TRUE;
				}
				gc++;
			}
		}
		*nRec = (int)hdr.cCnt;
		*nGlyph = gc;
		*xsiz = fhdr.xsiz;
		*ysiz = fhdr.ysiz;
		return 0;
	}
ERET:
	return( -1);
}
static int
readcmap()
{
	unsigned int	msiz;
	DWORD nByte;
	BOOL res;
	msiz = (unsigned int)hdr.cCnt*sizeof(unsigned short);
	if ((cmap = (unsigned short*)malloc(msiz))==(unsigned short *)0)
		goto	ERET;
	if ((long) SetFilePointer( fHdl, hdr.ofsCmap, NULL, FILE_BEGIN)!=hdr.ofsCmap)
		goto	ERET;
	res = ReadFile( fHdl, (LPBYTE)cmap, msiz, &nByte, NULL);
	if (!res || nByte !=msiz)
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static int
rectocode( int rec, unsigned short *code)
{
	if ( cmap==0) {
		if (readcmap())
			return -1;
	}
	*code = *(cmap+rec);
	return 0;
}
static int
searchCode( unsigned short code)
{
	int	high, low, mid;

	if ( cmap==(unsigned short *)0) {
		if (readcmap())
			goto	ERET;
	}
	high = hdr.cCnt-1;
	low = 0;
	while ( high >= low) {
		mid = (high+low)/2;
		if ( *(cmap+mid)==code)
			return mid;
		else if ( *(cmap+mid)>code)
			high = mid-1;
		else
			low = mid+1;
	}
ERET:
	return -1;
}
/***************************************************************
 *	Read Bitmap by code number
 */
/* */	int
/* */	GetW31JBMP(
/* */		unsigned short	code,	/* code Number */
/* */		LPBYTE buf,	/* buffer to set bitmap */
/* */		int	bufsiz,	/* Buffer Size */
/* */		int	*xsiz,	/* Bitmap X,Ysiz */
/* */		int	*ysiz)
/*
 *	returns : >=0, -1
 ***************************************************************/
{
	int	rec;
	int	sts;
	unsigned short	rcode;
	/* search code */
	if ( (rec = searchCode( code)) <0)
		return -1;
	else {
		sts = GetW31JBMPRec( rec, buf, bufsiz, xsiz, ysiz, &rcode);
		return sts;
	}
}
/****************************************/
/*					*/
/*	Get W31JEUDC's Bmp Mesh Size	*/
/*					*/
/****************************************/
int
GetW31JBMPMeshSize(
int	*xsiz,
int	*ysiz)
{
	long	ofs;
struct BMPHeader	fhdr;
	int	bmpsiz;
	DWORD nByte;
	BOOL res;

       if ( (!xsiz) || (!ysiz))
       {
           goto ERET;;
       }
	if (init==0)
		return -1;

	ofs = *(ofstbl);
	if ( ofs==0L)	
		return 0;
	ofs += hdr.ofsBdatSub;

	if ( (long) SetFilePointer(fHdl, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ERET;
	res = ReadFile( fHdl, (LPBYTE)&fhdr, sizeof(struct BMPHeader), &nByte, NULL);
	if (!res || nByte != sizeof( struct BMPHeader))
		goto	ERET;

	*xsiz = fhdr.xsiz;
	*ysiz = fhdr.ysiz;
	bmpsiz = ((int)fhdr.xsiz+15)/16 *2 * (int)fhdr.ysiz;

	return bmpsiz;
ERET:
	return (-1);
}
/***************************************************************
 *	Read Bitmap by record number
 */
/* */	int
/* */	GetW31JBMPRec(
/* */		int	rec,	/* Record Number */
/* */		LPBYTE buf,	/* buffer to set bitmap */
/* */		int	bufsiz,	/* Buffer Size */
/* */		int	*xsiz,	/* Bitmap X,Ysiz */
/* */		int	*ysiz,
/* */		unsigned short	*code)
/*
 *	returns : bitmapsiz >=0, -1
 ***************************************************************/
{
	long	ofs;
struct BMPHeader	fhdr;
	int	bmpsiz;
	int	rdsiz;
	DWORD nByte;
	BOOL res;

       if ( (!buf) || (!xsiz) || (!ysiz) || (!code) )
       {
           goto ERET;;
       }
	if (init==0)
		return -1;

	ofs = *(ofstbl+rec);
	if ( ofs==0L)	
		return 0;
	ofs += hdr.ofsBdatSub;

	/* read Bitmap Header
		bitmap is Word aligned */
	if ( (long) SetFilePointer( fHdl, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ERET;
	res = ReadFile( fHdl, (LPBYTE)&fhdr, sizeof(struct BMPHeader), &nByte, NULL);
	if (!res || nByte != sizeof( struct BMPHeader))
		goto	ERET;

	bmpsiz = ((int)fhdr.xsiz+15)/16 *2 * (int)fhdr.ysiz;
	/* Read Bitmap Body */
	rdsiz = bmpsiz > bufsiz ? bufsiz : bmpsiz;
	if ( rdsiz > 0) {
		res = ReadFile( fHdl, buf, (unsigned int)rdsiz, &nByte, NULL);
		if (!res || nByte !=(unsigned int)rdsiz)
			goto	ERET;
	}
	*xsiz = fhdr.xsiz;
	*ysiz = fhdr.ysiz;
	if ( rectocode( rec, code))
		goto	ERET;
	return bmpsiz;
ERET:
	return -1;
}
/***************************************************************
 *	Write Bitmap by record number
 */
/* */	int
/* */	PutW31JBMPRec(
/* */		int	rec,	/* Record Number */
/* */		 LPBYTE buf,	/* buffer to set bitmap */
/* */		int	xsiz,	/* Bitmap X,Ysiz */
/* */		int	ysiz)
/*
 *	returns : 0, -1
 ***************************************************************/
{
	long	ofs;
struct BMPHeader	fhdr;
	int	bmpsiz;
	unsigned int	wbmpsiz;
	DWORD nByte;
	BOOL res;

       if (!buf)
       {
          goto ERET;
       }
	if (init==0)
		return -1;
	else if ( rwmode==0)
		return -1;
	rwmode = 2;
	wbmpsiz = (unsigned int) ((xsiz+15)/16 *2 * ysiz);
	ofs = *(ofstbl+rec);
	if ( ofs != 0L) {
		/* read Bitmap Header
			bitmap is Word aligned */
		if ( ReadBMPHdr( fHdl, ofs, &fhdr))
			goto	ERET;

		bmpsiz = ((int)fhdr.xsiz+15)/16 *2 * (int)fhdr.ysiz;
		if ( bmpsiz<(int)wbmpsiz)
			ofs = 0L;
	}
	if ( ofs == 0L)
		ofs = bdTbl.tail;

	/* Write Bitmap Header */
	fhdr.xsiz = (short)xsiz;
	fhdr.ysiz = (short)ysiz;
	fhdr.bitmapSiz = wbmpsiz+sizeof(fhdr);

	if ( WriteBMPHdr( fHdl, ofs, &fhdr))
		goto	ERET;

	/* Write Bitmap Body */
	res = WriteFile( fHdl, buf, wbmpsiz, &nByte, NULL);
	if (!res || nByte !=wbmpsiz)
		goto	ERET;

	/* write bitmap ptr on subTable */
	*(ofstbl+rec) = ofs;

	bdTbl.tail = ofs + wbmpsiz+sizeof(fhdr);

	return 0;
ERET:
	return -1;
}
static int
ReadBMPHdr( HANDLE hdl, long ofs, struct BMPHeader *bhdr)
{
	DWORD nByte;
	BOOL res;

       if ((hdl == INVALID_HANDLE_VALUE) ||  (!bhdr))
       {
           goto ERET;;
       }
	ofs += hdr.ofsBdatSub;
	if ( (long) SetFilePointer( hdl, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ERET;
	res = ReadFile( hdl, (LPBYTE) bhdr, sizeof( struct BMPHeader), &nByte, NULL);
	if (!res || nByte !=sizeof( struct BMPHeader))
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static int
WriteBMPHdr( HANDLE hdl, long ofs, struct BMPHeader *bhdr)
{
	DWORD nByte;
	BOOL res;
       if ((  hdl== INVALID_HANDLE_VALUE) || ( !bhdr))
       {
           goto ERET;;
       }
	ofs += hdr.ofsBdatSub;
	if ( (long) SetFilePointer( hdl, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ERET;
	res = WriteFile(hdl, (LPBYTE )bhdr, sizeof( struct BMPHeader), &nByte, NULL);
	if (!res || nByte !=sizeof( struct BMPHeader))
		goto	ERET;
	return 0;
ERET:
	return -1;
}

int
W31JrecTbl( int **recTbl, BOOL bIsWin95EUDC)
{
	int	rec;
	int	*tp;
	unsigned short code;
       if ( !recTbl)
       {
           return -1;
       }
	if ( cmap==0) {
		if (readcmap())
			return -1;
	}
	if ( (tp = (int *)malloc( sizeof(int)*hdr.cCnt))==(int *)0)
		return -1;
	for ( rec = 0; rec < hdr.cCnt; rec++) {
		if ( *(ofstbl + rec)!=0L) {

			code = *(cmap+rec);
			if (!bIsWin95EUDC)
				code = sjisToUniEUDC( code);
			tp[(int)(code - EUDCCODEBASE)] = rec;
		}
		else	
			tp[rec] = -1;
	}
	*recTbl = recordTbl = tp;

	return 0;
}
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\cncttapi\cncttapi.h ===
/*	File: D:\WACKER\cncttapi\cncttapi.h (Created: 23-Feb-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 2/05/99 3:19p $
 */

/* --- Function Prototypes --- */

INT_PTR CALLBACK NewPhoneDlg(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\cncttapi\cnctdrv.hh ===
/*	File: D:\WACKER\cncttapi\cnctdrv.hh (Created: 08-Feb-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:01p $
 */

THIS FILE NO LONGER USED!!!
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\w31jeudc.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#ifdef BUILD_ON_WINNT
/*
 * To avoid multipule definition, this is already defined in w31jeudc.cpp
 */
#else
/*
 File Structure */

struct W31_Header {
	char	identify[72];
	short	segCnt;		/* ??? */
unsigned short	sCode,
		eCode;
	short	cCnt;
	long	ofsCmap;
	short	sizCmap;
	long	ofsFil;
	short	sizFil;
	long	ofsStbl;	/* search tbl*/
	short	sizStbl;
	long	ofsBdatSub;
	};

struct BDatSubTbl {
	long	tail;
	long	ptrOfs;
	long	head;
	short	filler2;
	/* Following Pointer tbl. */
	};
struct BMPHeader {
	long	bitmapSiz;
	short	xsiz, ysiz;
	};
#endif // BUILD_ON_WINNT

extern int OpenW31JEUDC( TCHAR *path);
extern void CloseW31JEUDC();
extern int  GetW31JEUDCFont(int  rec, LPBYTE buf,int  bufsiz,int  *xsiz,int  *ysiz);
extern int  PutW31JEUDCFont(int  rec, LPBYTE buf,int  xsiz,int  ysiz);
/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\eudcedit\w31jeudc.cpp ===
//
// Copyright (c) 1997-1999 Microsoft Corporation.
//
#include	"stdafx.h"
#pragma		pack(2)

#include	"vdata.h"
#include	"ttfstruc.h"
#include	"extfunc.h"
#define STRSAFE_LIB
#include <strsafe.h>
/*
 *	Win3.1J EUDC fontfile i/o
 */
#define		EUDCCODEBASE	((unsigned short)0xe000)
/*
 File Structure */

struct W31_Header {
	char	identify[72];
	short	segCnt;		/* ??? */
unsigned short	sCode,
		eCode;
	short	cCnt;
	long	ofsCmap;
	short	sizCmap;
	long	ofsFil;
	short	sizFil;
	long	ofsStbl;	/* search tbl*/
	short	sizStbl;
	long	ofsBdatSub;
	};

struct BDatSubTbl {
	long	tail;
	long	filler1;
	long	head;
	short	filler2;
	/* Following Pointer tbl. */
	};
struct BMPHeader {
	long	bitmapSiz;
	short	xsiz, ysiz;
	};


static int  ReadBdatSub(HANDLE hdl,long  ofs,struct  BDatSubTbl *tbl);
static int  WriteBdatSub(HANDLE  hdl,long  ofs,struct  BDatSubTbl *tbl);
static int  ReadBDatEntry(HANDLE  hdl,long  *ofs,long  rec);
static int  WriteBDatEntry(HANDLE  hdl,long  ofs,long  rec);
static int  ReadBMPHdr(HANDLE  hdl,long  ofs,struct  BMPHeader *hdr);
static int  WriteBMPHdr(HANDLE  hdl,long  ofs,struct  BMPHeader *hdr);


static int	init = 0;
static long	bdathead;
static long	bdatptr;
static int	maxRec;
static TCHAR fpath[128];

/***************************************************************
 *	Initialize
 */
/* */	int
/* */	OpenW31JEUDC( TCHAR *path)
/*
 *	returns : 0, -1
 ***************************************************************/
{
	HANDLE fHdl;
struct W31_Header hdr;
	DWORD nByte;
	BOOL res;
	HRESULT hresult;
       
       if (!path)
       {
           return -1;
       }
	makeUniCodeTbl();
	//*STRSAFE* 	lstrcpy( fpath, path);
	hresult = StringCchCopy(fpath , ARRAYLEN(fpath),  path);
	if (!SUCCEEDED(hresult))
	{
	   return -1;
	}
	/* open EUDC Font File */
	fHdl = CreateFile(path,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fHdl == INVALID_HANDLE_VALUE)
		return -1;

	/* Read Header */
	res = ReadFile( fHdl, &hdr, sizeof(struct W31_Header), &nByte, NULL);
	if (!res || nByte !=sizeof(struct W31_Header))
  {
    CloseHandle(fHdl);
		return -1;
  }
	bdathead = hdr.ofsBdatSub;
	bdatptr = hdr.ofsBdatSub + sizeof(struct BDatSubTbl);
	maxRec = hdr.cCnt-1;

	/* close Font File */
	CloseHandle( fHdl);
	init = 1;
	return	0;
}
/***************************************************************
 *	Terminate Close
 */
/* */	void
/* */	CloseW31JEUDC()
/*
 *	returns : none
 ***************************************************************/
{
	init = 0;
	return;
}
static int
codeToRec( unsigned short code, BOOL bUnicode)
{
	return (int)((bUnicode ? code : sjisToUniEUDC(code)) - EUDCCODEBASE);
}
/***************************************************************
 *	Read Bitmap
 */
/* */	int
/* */	GetW31JEUDCFont(
/* */		unsigned short	code,	/*  native-code */
/* */		LPBYTE buf,	/* buffer to set bitmap */
/* */		int	bufsiz,	/* Buffer Size */
/* */		int	*xsiz,	/* Bitmap X,Ysiz */
/* */		int	*ysiz,
/* */       BOOL bUnicode)
/*
 *	returns : >=0, -1
 ***************************************************************/
{
	HANDLE	fHdl;
	long	ofs;
struct BMPHeader	fhdr;
	int	bmpsiz;
	int	rdsiz;
	int	rec;
	DWORD nByte;
	BOOL res;

       if ( (! buf) || (!xsiz) || (!ysiz))
       {
          return -1;
       }
	rec = codeToRec( code, bUnicode);
	if (init==0)
		return -1;
	else if ( maxRec < rec || rec < 0)
		return -1;

	/* Open Font File */
	fHdl = CreateFile(fpath,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fHdl == INVALID_HANDLE_VALUE)
		return	-1;
	/* read bitmap ptr on subTable */
	ofs = bdatptr + sizeof(long)*rec;
	if ( (long) SetFilePointer( fHdl, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ECLOSE_RET;
	res = ReadFile( fHdl, &ofs, sizeof(long), &nByte, NULL);
	if (!res || nByte !=sizeof(long))
		goto	ECLOSE_RET;
	if ( ofs==0L)	
		goto	ECLOSE_RET;
	ofs += bdathead;

	/* read Bitmap Header
		bitmap is Word aligned */
	if ( (long) SetFilePointer( fHdl, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ECLOSE_RET;
	res = ReadFile( fHdl, &fhdr, sizeof(struct BMPHeader), &nByte, NULL);
	if (!res || nByte != sizeof( struct BMPHeader))
		goto	ECLOSE_RET;

	bmpsiz = ((int)fhdr.xsiz+15)/16 *2 * (int)fhdr.ysiz;
	/* Read Bitmap Body */
	rdsiz = bmpsiz > bufsiz ? bufsiz : bmpsiz;

	res = ReadFile( fHdl, buf, (unsigned short)rdsiz, &nByte, NULL);
	if (!res || nByte !=(unsigned short)rdsiz)
		goto	ECLOSE_RET;
	rdsiz = bmpsiz > bufsiz ? bmpsiz - bufsiz : 0;
	*xsiz = fhdr.xsiz;
	*ysiz = fhdr.ysiz;

	CloseHandle (fHdl);
	return rdsiz;
ECLOSE_RET:
	CloseHandle (fHdl);
	return -1;
}
/***************************************************************
 *	Write Bitmap
 */
/* */	int
/* */	PutW31JEUDCFont(
/* */		unsigned short code,	/* native code */
/* */		LPBYTE buf,	/* buffer to set bitmap */
/* */		int	xsiz,	/* Bitmap X,Ysiz */
/* */		int	ysiz,
/* */       BOOL bUnicode)
/*
 *	returns : 0, -1
 ***************************************************************/
{
	HANDLE fHdl;
	long	ofs;
struct BMPHeader	fhdr;
	int	bmpsiz;
	int	wbmpsiz;
struct BDatSubTbl subTbl;
	int	rec;
	DWORD nByte;
	BOOL res;

       if (!buf)
       {
           return -1;
       }
	rec = codeToRec( code, bUnicode);

	if (init==0)
		return -1;
	else if ( maxRec < rec || rec < 0)
		return -1;
	/* Open Font File */
	fHdl = CreateFile(fpath,
					GENERIC_READ | GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fHdl == INVALID_HANDLE_VALUE)
		return	-1;

	/* read bitmap ptr on subTable */
	if (ReadBDatEntry( fHdl, &ofs, rec))
		goto	ECLOSE_RET;

	wbmpsiz = (xsiz+15)/16 *2 * ysiz;
	if ( ofs != 0L) {
		/* read Bitmap Header
			bitmap is Word aligned */
		if ( ReadBMPHdr( fHdl, ofs, &fhdr))
			goto	ECLOSE_RET;

		bmpsiz = ((int)fhdr.xsiz+15)/16 *2 * (int)fhdr.ysiz;
		if ( bmpsiz<wbmpsiz)
			ofs = 0L;
	}
	if ( ReadBdatSub( fHdl, bdathead, &subTbl))
		goto	ECLOSE_RET;
	if ( ofs == 0L) {
		ofs = subTbl.tail;
		subTbl.tail += wbmpsiz+sizeof(fhdr);
	}
	/* Write Bitmap Header */
	fhdr.xsiz = (short)xsiz;
	fhdr.ysiz = (short)ysiz;
	fhdr.bitmapSiz = wbmpsiz+sizeof(fhdr);
	if ( WriteBMPHdr( fHdl, ofs, &fhdr))
		goto	ECLOSE_RET;

	/* Write Bitmap Body */
	res = WriteFile( fHdl, buf, (unsigned short)wbmpsiz, &nByte, NULL);
	if (!res || nByte !=(unsigned short)wbmpsiz)
		goto	ECLOSE_RET;

	/* write bitmap ptr on subTable */
	if (WriteBDatEntry( fHdl, ofs, rec))
		goto	ECLOSE_RET;

	/* write subTable */
	if ( WriteBdatSub( fHdl, bdathead, &subTbl))
		goto	ECLOSE_RET;
	CloseHandle (fHdl);

	return 0;
ECLOSE_RET:
	CloseHandle (fHdl);
	return -1;
}
static int
ReadBdatSub( HANDLE hdl, long ofs, struct BDatSubTbl *tbl)
{
	DWORD nByte;
	BOOL res;
       
       if ((hdl == INVALID_HANDLE_VALUE) || (!tbl))
       {
           return -1;
       }
	if ( (long) SetFilePointer( hdl, ofs, NULL, FILE_BEGIN)!= ofs)
		goto	ERET;

	res = ReadFile( hdl, tbl, sizeof (struct BDatSubTbl), &nByte, NULL);
	if (!res || nByte !=sizeof (struct BDatSubTbl))
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static int
WriteBdatSub( HANDLE hdl, long ofs, struct BDatSubTbl *tbl)
{
	DWORD nByte;
	BOOL res;
  
       if (( hdl == INVALID_HANDLE_VALUE) || (!tbl))
       {
           return -1;
       }
	if ( (long) SetFilePointer( hdl, ofs, NULL, FILE_BEGIN)!= ofs)
		goto	ERET;

	res = WriteFile( hdl, (char *)tbl, sizeof (struct BDatSubTbl), &nByte, NULL);
	if (!res || nByte !=sizeof (struct BDatSubTbl))
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static int
ReadBDatEntry( HANDLE hdl, long *ofs, long rec)
{
	DWORD nByte;
	BOOL res;
	long	ofsofs;
       
       if (( hdl == INVALID_HANDLE_VALUE) || (!ofs))
       {
           return -1;
       }
	ofsofs = bdatptr+(long)sizeof(long)*rec;
	if ( (long) SetFilePointer( hdl, ofsofs, NULL, FILE_BEGIN)!=ofsofs)
		goto	ERET;
	res = ReadFile( hdl, ofs, sizeof (long), &nByte, NULL);
	if (!res || nByte != sizeof (long))
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static int
WriteBDatEntry( HANDLE hdl, long ofs, long rec)
{
	long	ofsofs;
	DWORD nByte;
	BOOL res;
       if (hdl == INVALID_HANDLE_VALUE) 
       {
           goto ERET;
       }
	ofsofs = bdatptr+(long)sizeof(long)*rec;
	if ( (long) SetFilePointer( hdl, ofsofs, NULL, FILE_BEGIN)!=ofsofs)
		goto	ERET;
	res = WriteFile( hdl, (char *)&ofs, sizeof(long), &nByte, NULL);
	if (!res || nByte != sizeof(long))
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static int
ReadBMPHdr( HANDLE hdl, long ofs, struct BMPHeader *hdr)
{
	DWORD nByte;
	BOOL res;

       if (( hdl== INVALID_HANDLE_VALUE) || (!hdr))
       {
           return -1;
       }
	ofs += bdathead;
	if ( (long) SetFilePointer( hdl, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ERET;
	res = ReadFile( hdl, hdr, sizeof( struct BMPHeader), &nByte, NULL);
	if (!res || nByte !=sizeof( struct BMPHeader))
		goto	ERET;
	return 0;
ERET:
	return -1;
}
static int
WriteBMPHdr( HANDLE hdl, long ofs, struct BMPHeader *hdr)
{
	DWORD nByte;
	BOOL res;
 
       if (( hdl== INVALID_HANDLE_VALUE) || (!hdr))
       {
           return -1;
       }

	ofs += bdathead;
	if ( (long) SetFilePointer( hdl, ofs, NULL, FILE_BEGIN)!=ofs)
		goto	ERET;
	res = WriteFile( hdl, (char *)hdr, sizeof( struct BMPHeader), &nByte, NULL);
	if (!res || nByte !=sizeof( struct BMPHeader))
		goto	ERET;
	return 0;
ERET:
	return -1;
}

/***************************************************************
 *	is Win95 EUDC bitmap
 */
/* */	int
/* */   IsWin95EUDCBmp(LPTSTR szBmpPath)
/*
 *	returns : 0 (other), 1 (EUDC bitmap), -1(error)
 ***************************************************************/
{
	HANDLE fhdl;
struct W31_Header hdr;
	DWORD nByte;
	BOOL res;

       if (!szBmpPath)
       {
           return -1;
       }
	fhdl = CreateFile(szBmpPath,
					GENERIC_READ,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					NULL,
					OPEN_EXISTING,
					FILE_ATTRIBUTE_NORMAL,
					NULL);

	if ( fhdl == INVALID_HANDLE_VALUE)
    {
		return -1;
    }
	res = ReadFile( fhdl, (LPBYTE)&hdr, sizeof(hdr), &nByte, NULL);
	CloseHandle( fhdl);
	if (!res || nByte !=sizeof(hdr)){
		return 0;
	}	

	/* compare idendify leading 16 byte, sCode, eCode and cCnt*/
	if (memcmp( hdr.identify, "Windows95 EUDC", 14))
    {
		return 0;
    }
	if(hdr.sCode != 0x00e0){
		return 0;
	}
	return 1;
}
/* EOF */

////////////////////////////////////////////////////////////////////
//
// To work-around font linking in "Select Code" and "Save Char As".
// so that a typeface specific font does not show any glyph it does
// not have (from EUDC.TTE)
//
//     path   = *.euf
//     pGlyph = an array of 800 byte for 6400 EUDC chars
//
////////////////////////////////////////////////////////////////////
BOOL
GetGlyph(TCHAR *Path, BYTE* pGlyph)
{
	HANDLE fHdl;
    struct W31_Header hdr;
	DWORD  nByte;
    long   Offset;
    WORD   wc;
    long   lptr;
    TCHAR *pChar;
    TCHAR  PathEUF[MAX_PATH];
	BOOL   bRet = FALSE;
    HRESULT hresult;

    if ((!Path) || (!pGlyph))
    {
       return FALSE;
    }
    //*STRSAFE*     lstrcpy(PathEUF, Path);
    hresult = StringCchCopy(PathEUF , ARRAYLEN(PathEUF),  Path);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    pChar = PathEUF + lstrlen(PathEUF) - 3;
    *pChar = 0;
    //*STRSAFE*     lstrcat(PathEUF, TEXT("EUF"));
    hresult = StringCchCat(PathEUF , ARRAYLEN(PathEUF),  TEXT("EUF"));
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }

	fHdl = CreateFile(PathEUF,
                      GENERIC_READ,
                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);
    if(fHdl == INVALID_HANDLE_VALUE) return FALSE;

    bRet = ReadFile( fHdl, &hdr, sizeof(struct W31_Header), &nByte, NULL);
    if(!bRet && nByte !=sizeof(struct W31_Header)) goto Done;

    lptr = hdr.ofsBdatSub + sizeof(struct BDatSubTbl);
    if((long)SetFilePointer(fHdl, lptr, NULL, FILE_BEGIN) != lptr) goto Done;

    memset(pGlyph, 0, 800);

    for(wc = 0; wc < hdr.cCnt; wc++)
    {
        bRet = ReadFile( fHdl, &Offset, sizeof(long), &nByte, NULL);
        if(!bRet) goto Done;
        if(Offset == 0L || nByte !=sizeof(long)) continue;

        pGlyph[wc>>3] |= (0x80>>(wc%8));
    }

Done:
    CloseHandle(fHdl);
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\cncttapi\cncttapi.c ===
/*  File: D:\WACKER\cncttapi\cncttapi.c (Created: 08-Feb-1994)
 *
 *  Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *  All rights reserved
 *
 *      $Revision: 53 $
 *      $Date: 7/12/02 9:06a $
 */

#define TAPI_CURRENT_VERSION 0x00010004     // cab:11/14/96 - required!

#include <tapi.h>
#include <unimodem.h>
#pragma hdrstop

//#define DEBUGSTR

#include <time.h>

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\statusbr.h>
#include <tdll\tdll.h>
#include <tdll\misc.h>
#include <tdll\mc.h>
#include <tdll\assert.h>
#include <tdll\errorbox.h>
#include <tdll\cnct.h>
#include <tdll\globals.h>
#include <tdll\sf.h>
#include <tdll\sess_ids.h>
#include <tdll\com.h>
#include <tdll\comdev.h>
#include <tdll\com.hh>
#include <tdll\htchar.h>
#include <tdll\cloop.h>
#include <emu\emu.h>
#include <term\res.h>
#include "cncttapi.h"
#include "cncttapi.hh"
#include <tdll\XFER_MSC.HH>     // XD_TYPE
#include <tdll\XFER_MSC.H>      // xfrGetDisplayWindow(), xfrDoTransfer()
#include "tdll\XFDSPDLG.H"      // XFR_SHUTDOWN

static int DoNewModemWizard(HWND hWnd, int iTimeout);
static int tapiReinit(const HHDRIVER hhDriver);
static int tapiReinitMessage(const HHDRIVER hhDriver);
static int DoDelayedCall(const HHDRIVER hhDriver);

const TCHAR *g_achApp = TEXT("HyperTerminal");

static HHDRIVER gbl_hhDriver;	// see LINEDEVSTATE for explaination.

#if 0
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvEntry
 *
 * DESCRIPTION:
 *  Currently, just initializes the C-Runtime library but may be used
 *  for other things later.
 *
 * ARGUMENTS:
 *  hInstDll    - Instance of this DLL
 *  fdwReason   - Why this entry point is called
 *  lpReserved  - reserved
 *
 * RETURNS:
 *  BOOL
 *
 */
BOOL WINAPI cnctdrvEntry(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
	{
	hInstance = hInstDll;
	return _CRT_INIT(hInstDll, fdwReason, lpReserved);
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvCreate
 *
 * DESCRIPTION:
 *  Initializes the connection driver and returns a handle to the driver
 *  if successful.
 *
 * ARGUMENTS:
 *  hCnct   - public connection handle
 *
 * RETURNS:
 *  Handle to driver if successful, else 0.
 *
 */
HDRIVER WINAPI cnctdrvCreate(const HCNCT hCnct, const HSESSION hSession)
	{
	HHDRIVER hhDriver;

	if (hCnct == 0)
		{
		assert(FALSE);
		return 0;
		}

	hhDriver = malloc(sizeof(*hhDriver));

	if (hhDriver == 0)
		{
		assert(FALSE);
		return 0;
		}

	gbl_hhDriver = hhDriver;
	memset(hhDriver, 0, sizeof(*hhDriver));

	InitializeCriticalSection(&hhDriver->cs);

	hhDriver->hCnct = hCnct;
	hhDriver->hSession = hSession;
	hhDriver->iStatus  = CNCT_STATUS_FALSE;
	hhDriver->dwLine   = (DWORD)-1;

	cnctdrvInit(hhDriver);
	return (HDRIVER)hhDriver;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvDestroy
 *
 * DESCRIPTION:
 *  Destroys a connection driver handle.
 *
 * ARGUMENTS:
 *  hhDriver - private driver handle.
 *
 * RETURNS:
 *  0 or error code
 *
 */
int WINAPI cnctdrvDestroy(const HHDRIVER hhDriver)
	{
	if (hhDriver == 0)
		{
		assert(FALSE);
		return CNCT_BAD_HANDLE;
		}

	// Disconnect if we're connected or in the process.
	// Note: cnctdrvDisconnect should terminate the thread.

	cnctdrvDisconnect(hhDriver, DISCNCT_NOBEEP);

	if (hhDriver->hLine)
		{
		lineClose(hhDriver->hLine);
		memset(&hhDriver->stCallPar, 0, sizeof(hhDriver->stCallPar));
		hhDriver->stCallPar.dwTotalSize = sizeof(hhDriver->stCallPar);
		hhDriver->stCallPar.dwMediaMode = LINEMEDIAMODE_DATAMODEM;
		hhDriver->stCallPar.dwCallParamFlags = LINECALLPARAMFLAGS_IDLE;
		hhDriver->stCallPar.dwBearerMode = 0;

		hhDriver->hLine = 0;
		}

	if (hhDriver->hLineApp)
		{
		LONG lLineShutdown = lineShutdown(hhDriver->hLineApp);

		if (lLineShutdown == LINEERR_NOMEM)
			{
			//
			// We are in a low memory state, so wait for a while,
			// then try to shutdown the line again. REV: 5/1/2002
			//
			Sleep(500);
			lLineShutdown = lineShutdown(hhDriver->hLineApp);
			}

		if (lLineShutdown != 0)
			{
			assert(FALSE);
			}

		hhDriver->hLineApp = 0;
		}

	if (IsWindow(hhDriver->hwndCnctDlg))
		EndModelessDialog(hhDriver->hwndCnctDlg);

	if (IsWindow(hhDriver->hwndTAPIWindow))
		{
		DestroyWindow(hhDriver->hwndTAPIWindow);
		}

	/* --- Cleanup --- */

	DeleteCriticalSection(&hhDriver->cs);
	free(hhDriver);
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvLock
 *
 * DESCRIPTION:
 *  Locks the connection driver's critical section semaphore.
 *
 * ARGUMENTS:
 *  hhDriver    - private driver handle
 *
 * RETURNS:
 *  void
 *
 */
void cnctdrvLock(const HHDRIVER hhDriver)
	{
	EnterCriticalSection(&hhDriver->cs);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvUnlock
 *
 * DESCRIPTION:
 *  Unlocks the connection driver's critical section semaphore.
 *
 * ARGUMENTS:
 *  hhDriver    - private driver handle
 *
 * RETURNS:
 *  void
 *
 */
void cnctdrvUnlock(const HHDRIVER hhDriver)
	{
	LeaveCriticalSection(&hhDriver->cs);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctdrvInit
 *
 * DESCRIPTION:
 *	Initializes the connection handle.	Can be called to reinitialize
 *	the handle.  Does an implicit disconnect.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *
 * RETURNS:
 *	0
 *
 */
int WINAPI cnctdrvInit(const HHDRIVER hhDriver)
	{
	long  lRet;
	int   id = 0;
    int   iReturn = 0;

	// Make sure we're disconnected.
	//
	cnctdrvDisconnect(hhDriver, DISCNCT_NOBEEP);

   	// ----------------------------------------------------------------
	// Need to shut down hLineApp and reinitialize everytime we read
	// new data file so that TAPI starts out in a clean and initialized
	// state.  Otherwise, we might inherit values from the previous
	// session.
	// ----------------------------------------------------------------
	if (hhDriver->hLineApp)
		{
		LONG lLineShutdown = lineShutdown(hhDriver->hLineApp);

		if (lLineShutdown == LINEERR_NOMEM)
			{
			//
			// We are in a low memory state, so wait for a while,
			// then try to shutdown the line again. REV: 5/1/2002
			//
			Sleep(500);
			lLineShutdown = lineShutdown(hhDriver->hLineApp);
			}

		if (lLineShutdown != 0)
			{
			assert(FALSE);
			hhDriver->hLineApp = 0;
			return -2;
			}
		}

	hhDriver->hLineApp = 0;

	// Try to get a new LineApp handle now.
	//
	lRet = lineInitialize(&hhDriver->hLineApp, glblQueryDllHinst(),
			              lineCallbackFunc, g_achApp, &hhDriver->dwLineCnt);

	if (lRet != 0)
		{
        iReturn = -3;
		switch (lRet)
			{
		case LINEERR_INIFILECORRUPT:
			id = IDS_ER_TAPI_INIFILE;
			break;

		case LINEERR_NODRIVER:
			id = IDS_ER_TAPI_NODRIVER;
			break;

		case LINEERR_NOMULTIPLEINSTANCE:
			id = IDS_ER_TAPI_NOMULTI;
			break;

#if 0   // rev:08/05/99 We are now printing the lineInitialize() error.
        // rev:08/26/98 We need to make sure there was no error reported.
        //
        case LINEERR_INVALAPPNAME:
        case LINEERR_OPERATIONFAILED:
        case LINEERR_RESOURCEUNAVAIL:
        case LINEERR_INVALPOINTER:
        case LINEERR_REINIT:
        case LINEERR_NODEVICE:
        case LINEERR_NOMEM:
            id = IDS_ER_CNCT_TAPIFAILED;
            break;
#endif

        case LINEERR_OPERATIONUNAVAIL:
            //rev: 08-05-99 If TAPI has not been installed, then return a
            //              unique error code (since it will be handled
            //              differently than other TAPI errors).
            //
            iReturn = -4;

		#if ((NT_EDITION && !NDEBUG) || !NT_EDITION)
            // Run the new Modem wizard if we have not prompted before.
            //
            DoNewModemWizard(sessQueryHwnd(hhDriver->hSession),
                             sessQueryTimeout(hhDriver->hSession));
		#endif // ((NT_EDITION && !NDEBUG) || !NT_EDITION)

            break;

        default:
			id = IDS_ER_TAPI_UNKNOWN;
			break;
			}

		//
		// Only display these errors if in Debug mode in NT_EDITION.
		//
		#if ((NT_EDITION && !NDEBUG) || !NT_EDITION)
		if ( id )
			{
			TCHAR ach[256];
			TCHAR achMessage[256];

			LoadString(glblQueryDllHinst(), id, ach, sizeof(ach) / sizeof(TCHAR));
            if (id == IDS_ER_TAPI_UNKNOWN)
                {
                wsprintf(achMessage, ach, lRet);
                }
            else
                {
                lstrcpy(achMessage, ach);
                }

			TimedMessageBox(sessQueryHwnd(hhDriver->hSession),
							achMessage, NULL, MB_OK | MB_ICONSTOP,
							sessQueryTimeout(hhDriver->hSession));
			}
		#endif //((NT_EDITION && !NDEBUG) || !NT_EDITION)

        return iReturn;
		}

	hhDriver->iStatus			= CNCT_STATUS_FALSE;
	hhDriver->dwLine			= (DWORD)-1;
	hhDriver->dwCountryID		= (DWORD)-1;
	hhDriver->dwPermanentLineId = (DWORD)-1;
	hhDriver->achDest[0]		= TEXT('\0');
	hhDriver->achAreaCode[0]	= TEXT('\0');
	hhDriver->achLineName[0]	= TEXT('\0');
	hhDriver->fUseCCAC			= TRUE;

	/* --- This guy will set defaults --- */

	EnumerateTapiLocations(hhDriver, 0, 0);
	
#if defined(INCL_WINSOCK)
	hhDriver->iPort = 23;
	hhDriver->achDestAddr[0] = TEXT('\0');
#endif

#ifdef INCL_CALL_ANSWERING	
    hhDriver->fAnswering = FALSE;
    hhDriver->fRestoreSettings = FALSE;
    hhDriver->nSendCRLF = 0;
    hhDriver->nLocalEcho = 0;
    hhDriver->nAddLF = 0;
    hhDriver->nEchoplex = 0;
    hhDriver->pvUnregister = 0;
#endif

	return iReturn;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctdrvLoad
 *
 * DESCRIPTION:
 *  Reads the session file to get stuff connection driver needs.
 *
 * ARGUMENTS:
 *  hhDriver    - private driver handle
 *
 * RETURNS:
 *  0=OK, else error
 *
 */
int WINAPI cnctdrvLoad(const HHDRIVER hhDriver)
	{
    LPVARSTRING pvs;
	unsigned long ul;
	const SF_HANDLE sfhdl = sessQuerySysFileHdl(hhDriver->hSession);

	hhDriver->dwCountryID = (DWORD)-1;
	ul = sizeof(hhDriver->dwCountryID);
	sfGetSessionItem(sfhdl, SFID_CNCT_CC, &ul, &hhDriver->dwCountryID);

	hhDriver->achAreaCode[0] = TEXT('\0');
	ul = sizeof(hhDriver->achAreaCode);
	sfGetSessionItem(sfhdl, SFID_CNCT_AREA, &ul, hhDriver->achAreaCode);

	hhDriver->achDest[0] = TEXT('\0');
	ul = sizeof(hhDriver->achDest);
	sfGetSessionItem(sfhdl, SFID_CNCT_DEST, &ul, hhDriver->achDest);

	hhDriver->dwPermanentLineId = 0;
	ul = sizeof(hhDriver->dwPermanentLineId);
	sfGetSessionItem(sfhdl, SFID_CNCT_LINE, &ul, &hhDriver->dwPermanentLineId);

	hhDriver->fUseCCAC = 1;
	ul = sizeof(hhDriver->fUseCCAC);
	sfGetSessionItem(sfhdl, SFID_CNCT_USECCAC, &ul, &hhDriver->fUseCCAC);

    hhDriver->fRedialOnBusy = 1;
    ul = sizeof(hhDriver->fRedialOnBusy);
    sfGetSessionItem(sfhdl, SFID_CNCT_REDIAL, &ul, &hhDriver->fRedialOnBusy);

#if defined (INCL_WINSOCK)
	hhDriver->iPort = 23;
    ul = sizeof(hhDriver->iPort);
    sfGetSessionItem(sfhdl, SFID_CNCT_IPPORT, &ul, &hhDriver->iPort);

	hhDriver->achDestAddr[0] = TEXT('\0');
	ul = sizeof(hhDriver->achDestAddr);
	sfGetSessionItem(sfhdl, SFID_CNCT_IPDEST, &ul, hhDriver->achDestAddr);
#endif

    hhDriver->fCarrierDetect = FALSE;
    ul = sizeof(hhDriver->fCarrierDetect);
    sfGetSessionItem(sfhdl, SFID_CNCT_CARRIERDETECT, &ul, &hhDriver->fCarrierDetect);


	if ( IsNT() )
		{
		hhDriver->achComDeviceName[0] = TEXT('\0');
		ul = sizeof(hhDriver->achComDeviceName);
		sfGetSessionItem(sfhdl, SFID_CNCT_COMDEVICE, &ul, hhDriver->achComDeviceName);
		}

   	// ----------------------------------------------------------------
	// Need to shut down hLineApp and reinitialize everytime we read
	// new data file so that TAPI starts out in a clean and initialized
	// state.  Otherwise, we might inherit values from the previous
	// session.
	// ----------------------------------------------------------------

	if (hhDriver->hLineApp)
		{
		LONG lLineShutdown = lineShutdown(hhDriver->hLineApp);

		if (lLineShutdown == LINEERR_NOMEM)
			{
			//
			// We are in a low memory state, so wait for a while,
			// then try to shutdown the line again. REV: 5/1/2002
			//
			Sleep(500);
			lLineShutdown = lineShutdown(hhDriver->hLineApp);
			}

		if (lLineShutdown != 0)
			{
			assert(FALSE);
			hhDriver->hLineApp = 0;
			return -2;
			}

		hhDriver->hLineApp = 0;

		if (lineInitialize(&hhDriver->hLineApp, glblQueryDllHinst(),
				lineCallbackFunc, g_achApp, &hhDriver->dwLineCnt))
			{
			assert(FALSE);
			return -3;
			}
		}

	// EnumerateLines() will set the hhDriver->fMatchedPermanentLineID
	// guy if it finds a match for our saved dwPermanentLineId guy
	//
	if ( IsNT() )
		{
		EnumerateLinesNT(hhDriver, 0);
		}
	else
		{
		EnumerateLines(hhDriver, 0);
		}
	
	/* --- If we saved a tapi configuration, restore it. --- */

	if (sfGetSessionItem(sfhdl, SFID_CNCT_TAPICONFIG, &ul, 0) != 0)
		return 0; // Ok, might not be there.

	if ((pvs = malloc(ul)) == 0)
		{
		assert(FALSE);
		return -4;
		}

	if (sfGetSessionItem(sfhdl, SFID_CNCT_TAPICONFIG, &ul, pvs) == 0)
		{
		if (hhDriver->fMatchedPermanentLineID)
			{
			LPVOID pv = (BYTE *)pvs + pvs->dwStringOffset;

			if (lineSetDevConfig(hhDriver->dwLine, pv,
			        pvs->dwStringSize, DEVCLASS) != 0)
				{
                // This error prevented a user from even opening a session
                // file if the file contained TAPI info and the user had
                // never installed a modem. We modified the error that appears
                // when you actually try to USE a non-existant modem so that
                // we could suppress the display of this error  jkh 8/3/98
#if 0
                TCHAR ach[FNAME_LEN];

                LoadString(glblQueryDllHinst(), IDS_OPEN_FAILED, ach,
				    sizeof(ach) / sizeof(TCHAR));

				TimedMessageBox(sessQueryHwnd(hhDriver->hSession), ach, NULL,
					            MB_OK | MB_ICONINFORMATION,
								sessQueryTimeout(hhDriver->hSession));

                                free(pvs);
                                pvs = NULL;
                                return -5;
#endif
                                }
			}
		}

        free(pvs);
        pvs = NULL;
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvSave
 *
 * DESCRIPTION:
 *  Saves connection settings to the session file
 *
 * ARGUMENTS:
 *  hhDriver    - private driver handle
 *
 * RETURNS:
 *  0=OK, else error
 *
 */
int WINAPI cnctdrvSave(const HHDRIVER hhDriver)
	{
	DWORD dwSize;
	unsigned long ul;
	LPVARSTRING pvs = NULL;
	const SF_HANDLE sfhdl = sessQuerySysFileHdl(hhDriver->hSession);

	sfPutSessionItem(sfhdl, SFID_CNCT_CC, sizeof(hhDriver->dwCountryID),
		&hhDriver->dwCountryID);

	sfPutSessionItem(sfhdl, SFID_CNCT_AREA,
		(lstrlen(hhDriver->achAreaCode) + 1) * sizeof(TCHAR),
			hhDriver->achAreaCode);

	sfPutSessionItem(sfhdl, SFID_CNCT_DEST,
		(lstrlen(hhDriver->achDest) + 1) * sizeof(TCHAR), hhDriver->achDest);

	sfPutSessionItem(sfhdl, SFID_CNCT_LINE, sizeof(hhDriver->dwPermanentLineId),
		&hhDriver->dwPermanentLineId);

	sfPutSessionItem(sfhdl, SFID_CNCT_USECCAC, sizeof(hhDriver->fUseCCAC),
		&hhDriver->fUseCCAC);

	sfPutSessionItem(sfhdl, SFID_CNCT_REDIAL, sizeof(hhDriver->fRedialOnBusy),
		&hhDriver->fRedialOnBusy);

#if defined (INCL_WINSOCK)
	sfPutSessionItem(sfhdl, SFID_CNCT_IPPORT, sizeof(hhDriver->iPort),
		&hhDriver->iPort);

	sfPutSessionItem(sfhdl, SFID_CNCT_IPDEST,
		(lstrlen(hhDriver->achDestAddr) + 1) * sizeof(TCHAR),
			hhDriver->achDestAddr);
#endif

	/* --- Usual lines of code to use TAPI --- */

	if (hhDriver->hLineApp && hhDriver->dwLine != (DWORD)-1 &&
			!IN_RANGE(hhDriver->dwPermanentLineId, DIRECT_COM1, DIRECT_COM4) &&
            hhDriver->dwPermanentLineId != DIRECT_COM_DEVICE &&
            hhDriver->dwPermanentLineId != DIRECT_COMWINSOCK)
		{
		if ((pvs = malloc(sizeof(VARSTRING))) == 0)
			{
			assert(FALSE);
			return 0;
			}
		
		memset( pvs, 0, sizeof(VARSTRING) );
		pvs->dwTotalSize = sizeof(VARSTRING);

		if (lineGetDevConfig(hhDriver->dwLine, pvs, DEVCLASS) != 0)
			{
			assert(FALSE);
            free(pvs);
            pvs = NULL;
			return 0;
			}

		if (pvs->dwNeededSize > pvs->dwTotalSize)
			{
			dwSize = pvs->dwNeededSize;
			free(pvs);
                        pvs = NULL;

			if ((pvs = malloc(dwSize)) == 0)
				{
				assert(FALSE);
				return 0;
				}

			memset( pvs, 0, dwSize );
			pvs->dwTotalSize = dwSize;

			if (lineGetDevConfig(hhDriver->dwLine, pvs, DEVCLASS) != 0)
				{
				assert(FALSE);
                free(pvs);
                pvs = NULL;
				return 0;
				}
			}

		/* --- Store the whole structure --- */

		ul = pvs->dwTotalSize;
		sfPutSessionItem(sfhdl, SFID_CNCT_TAPICONFIG, ul, pvs);
                free(pvs);
                pvs = NULL;
		}

	if ( IsNT() && hhDriver->dwPermanentLineId == DIRECT_COM_DEVICE)
		{
		ul = sizeof(hhDriver->achComDeviceName);

		sfPutSessionItem(sfhdl, SFID_CNCT_COMDEVICE, ul,
			hhDriver->achComDeviceName);
		}

	sfPutSessionItem(sfhdl, SFID_CNCT_CARRIERDETECT, sizeof(hhDriver->fCarrierDetect),
	&hhDriver->fCarrierDetect);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvQueryStatus
 *
 * DESCRIPTION:
 *  Returns the current connection status as defined in <tdll\cnct.h>
 *
 * ARGUMENTS:
 *  hhDriver - private driver handle
 *
 * RETURNS:
 *  connection status or error code
 *
 */
int WINAPI cnctdrvQueryStatus(const HHDRIVER hhDriver)
	{
	int iStatus = CNCT_STATUS_FALSE;

	if (hhDriver == 0)
		{
		assert(FALSE);
		iStatus = CNCT_BAD_HANDLE;
		}
	else
		{
		cnctdrvLock(hhDriver);
		iStatus = hhDriver->iStatus;   //* hard-code for now.
		cnctdrvUnlock(hhDriver);
		}

	return iStatus;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  SetStatus
 *
 * DESCRIPTION:
 *  There's actually more to setting the connection status than just
 *  setting the status variable as the code below indicates.  Dumb
 *  question:  Why aren't there any locks in this code.  Dumb Answer:
 *  This function is only called from the ConnectLoop thread context
 *  which has already locked things down.
 *
 * ARGUMENTS:
 *  hhDriver    - private driver handle
 *  iStatus     - new status
 *
 * RETURNS:
 *  void
 *
 */
void SetStatus(const HHDRIVER hhDriver, const int iStatus)
	{
	HCLOOP	hCLoop;
	/* --- Don't do things twice --- */

	const HWND hwndToolbar = sessQueryHwndToolbar(hhDriver->hSession);

	cnctdrvLock(hhDriver);

	if (iStatus == hhDriver->iStatus)
		{
		if (iStatus == CNCT_STATUS_TRUE || iStatus == CNCT_STATUS_FALSE)
			{
			hCLoop = sessQueryCLoopHdl(hhDriver->hSession);
			if (hCLoop)
				CLoopSndControl(hCLoop, CLOOP_RESUME, CLOOP_SB_CNCTDRV);
            }

		cnctdrvUnlock(hhDriver);
		return;
		}

	/* --- Set the status, an exciting new adventure game --- */

	switch (iStatus)
		{
	case CNCT_STATUS_TRUE:
            hCLoop = sessQueryCLoopHdl(hhDriver->hSession);
          #ifdef INCL_CALL_ANSWERING
            // If we are going from answering to connected, that means
            // we have answered a call. So tweak the ASCII settings so
            // that they make chatting possible. - cab:11/20/96
            //
            if (hhDriver->fAnswering)
                {
                // Store old ASCII settings, and set the new ones.
                //
                hhDriver->nSendCRLF = CLoopGetSendCRLF(hCLoop);
                hhDriver->nLocalEcho = CLoopGetLocalEcho(hCLoop);
                hhDriver->nAddLF = CLoopGetAddLF(hCLoop);
                hhDriver->nEchoplex = CLoopGetEchoplex(hCLoop);

                CLoopSetSendCRLF(hCLoop, TRUE);
                CLoopSetLocalEcho(hCLoop, TRUE);
                CLoopSetAddLF(hCLoop, TRUE);
                CLoopSetEchoplex(hCLoop, TRUE);

                hhDriver->fRestoreSettings = TRUE;
                }
          #endif
            hhDriver->iStatus = CNCT_STATUS_TRUE;
            assert(hCLoop);
            if (hCLoop)
                {
                CLoopRcvControl(hCLoop, CLOOP_RESUME, CLOOP_RB_CNCTDRV);
                CLoopSndControl(hCLoop, CLOOP_RESUME, CLOOP_SB_CNCTDRV);
                }

            NotifyClient(hhDriver->hSession, EVENT_CONNECTION_OPENED, 0);
            sessBeeper(hhDriver->hSession);
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_DIAL, FALSE);
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_HANGUP, TRUE);
            break;

	case CNCT_STATUS_CONNECTING:
            hhDriver->iStatus = CNCT_STATUS_CONNECTING;
            DialingMessage(hhDriver, IDS_DIAL_OFFERING); // temp
            NotifyClient(hhDriver->hSession, EVENT_CONNECTION_INPROGRESS, 0);
            EnableDialNow(hhDriver->hwndCnctDlg, FALSE);
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_DIAL, FALSE);
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_HANGUP, TRUE);
            break;

	case CNCT_STATUS_DISCONNECTING:
            hhDriver->iStatus = CNCT_STATUS_DISCONNECTING;
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_DIAL, FALSE);
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_HANGUP, FALSE);
            break;

	case CNCT_STATUS_FALSE:
		hCLoop = sessQueryCLoopHdl(hhDriver->hSession);
          #ifdef INCL_CALL_ANSWERING
            // Since this is called when we disconnect we need to restore
            // any ASCII Settings here. - cab:11/20/96
            //
            if ( hhDriver->fRestoreSettings && hCLoop ) //mpt: so that we don't reference a null pointer
                {
                CLoopSetSendCRLF(hCLoop, hhDriver->nSendCRLF);
                CLoopSetLocalEcho(hCLoop, hhDriver->nLocalEcho);
                CLoopSetAddLF(hCLoop, hhDriver->nAddLF);
                CLoopSetEchoplex(hCLoop, hhDriver->nEchoplex);
                hhDriver->fRestoreSettings = FALSE;
                }
            hhDriver->fAnswering = FALSE;
          #endif
            hhDriver->iStatus = CNCT_STATUS_FALSE;
            if (hCLoop)
                {
                CLoopRcvControl(hCLoop, CLOOP_RESUME, CLOOP_RB_CNCTDRV);
                CLoopSndControl(hCLoop, CLOOP_RESUME, CLOOP_SB_CNCTDRV);
                }
            NotifyClient(hhDriver->hSession, EVENT_CONNECTION_CLOSED, 0);
            EnableDialNow(hhDriver->hwndCnctDlg, TRUE);
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_DIAL, TRUE);
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_HANGUP, FALSE);
            break;

        case CNCT_STATUS_ANSWERING:
          #ifdef INCL_CALL_ANSWERING
            hhDriver->fAnswering = TRUE;
            hhDriver->iStatus = CNCT_STATUS_ANSWERING;
            NotifyClient(hhDriver->hSession, EVENT_CONNECTION_INPROGRESS, 0);
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_DIAL, FALSE);
			ToolbarEnableButton(hwndToolbar, IDM_ACTIONS_HANGUP, TRUE);
          #endif
            break;

	default:
		assert(FALSE);
		break;
		}

	cnctdrvUnlock(hhDriver);

	/* --- Notify status bar so it can update it's display --- */

	PostMessage(sessQueryHwndStatusbar(hhDriver->hSession), SBR_NTFY_REFRESH,
		(WPARAM)SBR_CNCT_PART_NO, 0);

	return;
	}

#ifdef INCL_CALL_ANSWERING
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  WaitForCRcallback
 *
 * DESCRIPTION:
 *  This function gets registered as a callback with the cloop.  Every
 *  character that the cloop gets, is passed back to this function.  When
 *  this function finds a CR, it indicates that a connection has been
 *  established.  Note that this applies only to an answer mode connection,
 *  in the direct connect driver.
 *
 * ARGUMENTS:
 *  ECHAR   ech  -   The character returned from cloop.
 *  void    *p   -   A void pointer passed back from cloop.  This is
 *                   the enternal connection driver handle.
 *
 * RETURNS:
 *  CLOOP_DISCARD unless the character is a CR where is returns CLOOP_KEEP.
 *
 * AUTHOR: C. Baumgartner, 11/20/96 (ported from HAWin32)
 */
int WaitForCRcallback(ECHAR ech, void *p)
    {
    int   iRet = CLOOP_DISCARD; // Discard all characters except the CR.
    TCHAR chC = (TCHAR) ech;
    const HHDRIVER hhDriver = (HHDRIVER)p;

    if (chC == TEXT('\r'))
        {
        CLoopUnregisterRmtInputChain(hhDriver->pvUnregister);
        hhDriver->pvUnregister = 0;

        // Okay, we are connected now.
        //
        SetStatus(hhDriver, CNCT_STATUS_TRUE);

        iRet = CLOOP_KEEP;
        }

    return iRet;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  WaitForCRinit
 *
 * DESCRIPTION:
 *  This function is called to register a new string match function
 *  with the cloop.  It unregisters a previously registered function
 *  if necessary. It basically will cause us to wait for a carriage
 *  return.
 *
 * ARGUMENTS:
 *  HHDRIVER    hhDriver    -   The internal connection handle.
 *
 * RETURNS:
 *  0 if successful, otherwise -1.
 *
 * AUTHOR: C. Baumgartner, 11/20/96 (ported from HAWin32)
 */
static int WaitForCRinit(const HHDRIVER hhDriver)
    {
    const HCLOOP hCLoop = sessQueryCLoopHdl(hhDriver->hSession);

    if (!hCLoop)
        {
        return -1;
        }

    // If we are already registered, unregister.
    //
    if (hhDriver->pvUnregister != 0)
        {
        CLoopUnregisterRmtInputChain(hhDriver->pvUnregister);
        hhDriver->pvUnregister = 0;
        }

    // We need to un-block CLoop so we can look at the
    // characters as they come in.
    //
	CLoopRcvControl(hCLoop, CLOOP_RESUME, CLOOP_RB_CNCTDRV);

    // Register the match function with the cloop.
    //
    hhDriver->pvUnregister = CLoopRegisterRmtInputChain(hCLoop,
        WaitForCRcallback, hhDriver);

    if (hhDriver->pvUnregister == 0)
        {
        return -1;
        }

    return 0;
    }
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvComEvent
 *
 * DESCRIPTION:
 *  Com routines call the this to notify connection routines that some
 *  significant event has happened (ie. carrier lost).  The connetion
 *  driver decides what it is interested in knowing however by
 *  querying the com drivers for the specific data.
 *
 * ARGUMENTS:
 *  hhDriver - private connection driver handle
 *  event    - the com event we are being notified of
 *
 * RETURNS:
 *  0
 *
 */
int WINAPI cnctdrvComEvent(const HHDRIVER hhDriver, const enum COM_EVENTS event)
	{
	int		iRet;
	TCHAR 	ach[MAX_PATH];
#if defined(INCL_WINSOCK)
	char	achMsg[512];
#endif
	HCOM	hCom;

	if (hhDriver == 0)
		{
		assert(FALSE);
		return CNCT_BAD_HANDLE;
		}

    if (event == CONNECT)
        {
		#if defined (INCL_WINSOCK)
	    // If we are connected via Winsock, there will be some ComEvents
	    // that we have to handle
	    if (hhDriver->dwPermanentLineId == DIRECT_COMWINSOCK)
		    {
		    hCom = sessQueryComHdl(hhDriver->hSession);
		    iRet = ComDriverSpecial(hCom, "Query ISCONNECTED", ach, MAX_PATH);

		    if (iRet == COM_OK)
			    {
				int iPortOpen = atoi(ach);
			    // Do we want to initiate a disconnect?  Only if we're
			    // connected.
			    if (iPortOpen == COM_PORT_NOT_OPEN)
				    {
				    if (hhDriver->iStatus == CNCT_STATUS_TRUE)
					    {
                        // If we are already connected, then beep when
                        // we disconnect. - cab:12/06/96
                        //
						//mpt:10-28-97 added exit upon disconnect feature
						NotifyClient(hhDriver->hSession, EVENT_LOST_CONNECTION,
							         CNCT_LOSTCARRIER | (sessQueryExit(hhDriver->hSession) ? DISCNCT_EXIT :  0 ));
					    }
				    else if (hhDriver->iStatus == CNCT_STATUS_CONNECTING)
					    {
					    NotifyClient(hhDriver->hSession, EVENT_LOST_CONNECTION,
							         CNCT_LOSTCARRIER | DISCNCT_NOBEEP);

					    LoadString(glblQueryDllHinst(), IDS_ER_TCPIP_BADADDR, ach, MAX_PATH);
					    wsprintf(achMsg, ach, hhDriver->achDestAddr, hhDriver->iPort);
					    TimedMessageBox(sessQueryHwnd(hhDriver->hSession),
                                        achMsg, NULL, MB_OK | MB_ICONINFORMATION,
										sessQueryTimeout(hhDriver->hSession));
					    }
				    }
			    else if (iPortOpen == COM_PORT_OPEN)
				    {
				    SetStatus(hhDriver, CNCT_STATUS_TRUE);
				    }
			    }
		    }
		else
		#endif // defined (INCL_WINSOCK)
        if (IN_RANGE(hhDriver->dwPermanentLineId, DIRECT_COM1, DIRECT_COM4) ||
            hhDriver->dwPermanentLineId == DIRECT_COM_DEVICE)
            {
			// Checking the status of DCD before disconnecting
			// is a good idea, prevents us hanging up whenever we
			// get any event while connected
			// - mpt:08-26-97
			hCom = sessQueryComHdl(hhDriver->hSession);
			iRet = ComDriverSpecial(hCom, "Query DCD_STATUS", ach, MAX_PATH);

		    if (iRet == COM_OK)
			    {
				int iPortOpen = atoi(ach);
			    // Do we want to initiate a disconnect?  Only if we're
			    // connected.
			    if (iPortOpen == COM_PORT_NOT_OPEN)
				    {
				    if (hhDriver->iStatus == CNCT_STATUS_TRUE)
					    {
						// If we are direct cabled, and we're connected, then
						// the other end just disconnected, so disconnect now.
						// - cab:11/20/96
						//
						// Note: We must disconnect by posting a message to
						// thread one. This is because if we get here, we were
						// called from the context of the com thread, which
						// will not exit properly if cnctdrvDisconnect is called.
						// - cab:11/21/96
						//
						//
                        // If we are already connected, then beep when
                        // we disconnect. - cab:12/06/96
                        //
						//mpt:10-28-97 added exit upon disconnect feature
						NotifyClient(hhDriver->hSession, EVENT_LOST_CONNECTION,
							         CNCT_LOSTCARRIER | (sessQueryExit(hhDriver->hSession) ? DISCNCT_EXIT :  0 ));
					    }
					#if defined(INCL_CALL_ANSWERING)
				    else if (hhDriver->iStatus == CNCT_STATUS_CONNECTING ||
						     hhDriver->iStatus == CNCT_STATUS_ANSWERING)
					#else // defined(INCL_CALL_ANSWERING)
				    else if (hhDriver->iStatus == CNCT_STATUS_CONNECTING)
					#endif // defined(INCL_CALL_ANSWERING)
					    {
					    NotifyClient(hhDriver->hSession, EVENT_LOST_CONNECTION,
							         CNCT_LOSTCARRIER | DISCNCT_NOBEEP);

						LoadString(glblQueryDllHinst(), IDS_ER_CNCT_PORTFAILED, ach, MAX_PATH);
					    wsprintf(achMsg, ach, hhDriver->achComDeviceName);
					    TimedMessageBox(sessQueryHwnd(hhDriver->hSession),
                                        achMsg, NULL, MB_OK | MB_ICONINFORMATION,
										sessQueryTimeout(hhDriver->hSession));
					    }
				    }
				else if (iPortOpen == COM_PORT_OPEN &&
					     hhDriver->iStatus != CNCT_STATUS_ANSWERING)
					{
					SetStatus(hhDriver, CNCT_STATUS_TRUE);
					}
			    }
			#if defined(INCL_CALL_ANSWERING)
            if (hhDriver->iStatus == CNCT_STATUS_ANSWERING)
                {
                // If we are a direct cabled connection, and we are waiting
                // for a call, connect when we see a carriage return.
                //
                WaitForCRinit(hhDriver);
                }
			#endif // defined(INCL_CALL_ANSWERING)
            }
        }
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  DoAnswerCall
 *
 * DESCRIPTION:
 *  Sets up TAPI to answer the next data modem call.
 *
 * ARGUMENTS:
 *  hhDriver - private driver handle
 *
 * RETURNS:
 *  0 or error
 *
 * AUTHOR:  C. Baumgartner, 11/25/96 (ported from HAWin32)
 */
int DoAnswerCall(const HHDRIVER hhDriver)
    {
	TCHAR ach[256];

    // Believe it or not, this is all one has to do to setup and
    // answer a call.  Quite a contrast to placing a call.
    //
    if (TRAP(lineOpen(hhDriver->hLineApp, hhDriver->dwLine, &hhDriver->hLine,
        hhDriver->dwAPIVersion, 0, (DWORD_PTR)hhDriver, LINECALLPRIVILEGE_OWNER,
        LINEMEDIAMODE_DATAMODEM, 0)) != 0)
        {
        assert(0);
	    LoadString(glblQueryDllHinst(), IDS_ER_CNCT_TAPIFAILED, ach, sizeof(ach) / sizeof(TCHAR));
	    TimedMessageBox(sessQueryHwnd(hhDriver->hSession), ach, NULL,
			            MB_OK | MB_ICONINFORMATION | MB_TASKMODAL,
						sessQueryTimeout(hhDriver->hSession));
        return -1;
        }

    // The the line app priority for compliance with TAPI specifications.
    // mrw:9/18/96
    //
	LoadString(glblQueryDllHinst(), IDS_GNRL_APPNAME, ach, sizeof(ach) / sizeof(TCHAR));
    TRAP(lineSetAppPriority(ach, LINEMEDIAMODE_DATAMODEM, 0, 0, 0, 1));

    // Set line notifications we want to receive
    //
    TRAP(lineSetStatusMessages(hhDriver->hLine, LINEDEVSTATE_RINGING, 0));

    SetStatus(hhDriver, CNCT_STATUS_ANSWERING);
    return 0;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  DoMakeCall
 *
 * DESCRIPTION:
 *  Performs the neccessary TAPI rituals to place an outbound call.
 *
 * ARGUMENTS:
 *  hhDriver - private driver handle
 *  uFlags   - connection flags
 *
 * RETURNS:
 *  0 or error
 *
 * AUTHOR:  C. Baumgartner, 11/25/96 (ported from cnctdrvConnect)
 */
int DoMakeCall(const HHDRIVER hhDriver, const unsigned int uFlags)
    {
    unsigned int  uidErr = 0;
    int           iRet = 0;
    LINEDEVSTATUS stLnDevStat;
    TCHAR         ach[256];
    BOOL          msgFlag = FALSE;
    
	tapiReinit(hhDriver);

    //
    // Set the line settings.
    //
    if (cncttapiSetLineConfig(hhDriver->dwLine, sessQueryComHdl(hhDriver->hSession)) != 0)
        {
        assert(0);
        uidErr = IDS_ER_CNCT_TAPIFAILED;
        iRet = -1;
        msgFlag = TRUE;
        goto ERROR_EXIT;
        }

	/* --- Open the line, pass driver handle for data reference --- */

	if (TRAP(lineOpen(hhDriver->hLineApp, hhDriver->dwLine,
	        &hhDriver->hLine, hhDriver->dwAPIVersion, 0, (DWORD_PTR)hhDriver,
				LINECALLPRIVILEGE_NONE, 0, 0)) != 0)
            {
            assert(0);
            uidErr = IDS_ER_CNCT_TAPIFAILED;
            iRet = -1;
            msgFlag = TRUE;
            goto ERROR_EXIT;
            }

	/* --- Set line notifications we want to receive, mrw,2/28/95 --- */

	TRAP(lineSetStatusMessages(hhDriver->hLine,
		LINEDEVSTATE_INSERVICE | LINEDEVSTATE_OUTOFSERVICE, 0));

	/* --- Check if our device is in service, mrw,2/28/95 --- */

	stLnDevStat.dwTotalSize = sizeof(stLnDevStat);
	TRAP(lineGetLineDevStatus(hhDriver->hLine, &stLnDevStat));

	if ((stLnDevStat.dwDevStatusFlags & LINEDEVSTATUSFLAGS_INSERVICE) == 0)
            {
            if (DialogBoxParam(glblQueryDllHinst(),
			MAKEINTRESOURCE(IDD_CNCT_PCMCIA),
                        sessQueryHwnd(hhDriver->hSession), PCMCIADlg,
                        (LPARAM)hhDriver) == FALSE)
                {
                iRet = -2;
                goto ERROR_EXIT;
                }
            }

	/* --- Launch the dialing dialog, or go right into passthrough mode. --- */

	if ((uFlags & CNCT_PORTONLY) == 0)
            {
            if (!IsWindow(hhDriver->hwndCnctDlg))
                {
                hhDriver->hwndCnctDlg = DoModelessDialog(glblQueryDllHinst(),
				MAKEINTRESOURCE(IDD_DIALING), sessQueryHwnd(hhDriver->hSession),
                                DialingDlg, (LPARAM)hhDriver);
                }
            }

	/* --- Make the call (oooh, how exciting!) --- */

	memset(&hhDriver->stCallPar, 0, sizeof(hhDriver->stCallPar));
	hhDriver->stCallPar.dwTotalSize = sizeof(hhDriver->stCallPar);
	hhDriver->stCallPar.dwMediaMode = LINEMEDIAMODE_DATAMODEM;
	hhDriver->stCallPar.dwCallParamFlags = LINECALLPARAMFLAGS_IDLE;

	if (uFlags & CNCT_PORTONLY)
		hhDriver->stCallPar.dwBearerMode = LINEBEARERMODE_PASSTHROUGH;

	if ((hhDriver->lMakeCallId = lineMakeCall(hhDriver->hLine,
			&hhDriver->hCall, hhDriver->achDialableDest,
                        hhDriver->dwCountryCode, &hhDriver->stCallPar)) < 0)
            {
            #if defined(_DEBUG)
            char ach[50];
            wsprintf(ach, "lineMakeCall returned %x", hhDriver->lMakeCallId);
            MessageBox (0, ach, "debug", MB_OK);
            #endif

            switch (hhDriver->lMakeCallId)
                {
				case LINEERR_BEARERMODEUNAVAIL:
				case LINEERR_INVALBEARERMODE:
                    uidErr = IDS_ER_CNCT_PASSTHROUGH;
                    iRet   = -6;
                    msgFlag = TRUE;
					goto ERROR_EXIT;

                case LINEERR_RESOURCEUNAVAIL:
                case LINEERR_CALLUNAVAIL:
                    uidErr = IDS_ER_CNCT_CALLUNAVAIL;
                    iRet   = -3;
                    msgFlag = TRUE;
                    goto ERROR_EXIT;

                case LINEERR_DIALDIALTONE:
                case LINEERR_DIALPROMPT:
                    if (DoDelayedCall(hhDriver) != 0)
                        {
                        iRet = -4;
                        msgFlag = TRUE;
                        goto ERROR_EXIT;
                        }

                    break;

                default:
                    iRet = -5;
                    msgFlag = TRUE;
                    goto ERROR_EXIT;
                    }
                }

	SetStatus(hhDriver, CNCT_STATUS_CONNECTING);
	return 0;

	/* --- Error exit --- */

ERROR_EXIT:

        // Change this so that the dialog is destroyed before the
        // error message is displayed. Otherwise, the timer that
        // handled redials continued to pump a redial message once
        // every second, causing HT to go into a very nasty loop. mpt 02SEP98

        if (IsWindow(hhDriver->hwndCnctDlg))
            {
            EndModelessDialog(hhDriver->hwndCnctDlg);
            hhDriver->hwndCnctDlg = 0;
            }

        if ( msgFlag )
            {
            LoadString(glblQueryDllHinst(), uidErr, ach, sizeof(ach) / sizeof(TCHAR));

            TimedMessageBox(sessQueryHwnd(hhDriver->hSession), ach, NULL,
				            MB_OK | MB_ICONINFORMATION | MB_TASKMODAL,
            sessQueryTimeout(hhDriver->hSession));
            }

	return iRet;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvConnect
 *
 * DESCRIPTION:
 *  Attempts to dial the modem.
 *
 * ARGUMENTS:
 *  hhDriver - private driver handle
 *  uFlags   - connection flags
 *
 * RETURNS:
 *  0 or error
 *
 */
int WINAPI cnctdrvConnect(const HHDRIVER hhDriver, const unsigned int uFlags)
	{
	TCHAR 	ach[FNAME_LEN];
	#if defined(INCL_WINSOCK)
	//
	// MAX_IP_ADDR_LEN+11+1 = buffer size of hhDriver->achDestAddr +
	// settings string "SET IPADDR=" + 1 for the terminating NULL
	// character.  REV 09/20/2000
	//
	TCHAR	szInstruct[MAX_IP_ADDR_LEN+11+1]; // Used only for WinSock
	TCHAR   szResult[MAX_IP_ADDR_LEN+11+1];   // Used only for WinSock
	int     iNumChars;
	#endif //defined (INCL_WINSOCK)
	TCHAR	achNewCnct[FNAME_LEN];
	TCHAR	achCom[MAX_PATH];
	BOOL	fGetNewName = FALSE;
	HICON	hIcon;
	HCOM	hCom;
	int 	hIconId;
	int 	fFlag;
	unsigned int uidErr = IDS_ER_CNCT_TAPIFAILED;

	if (hhDriver == 0)
		{
		assert(FALSE);
		return CNCT_BAD_HANDLE;
		}

	/* --- Makes for easier referencing --- */

	hCom = sessQueryComHdl(hhDriver->hSession);

	/* --- Check to see we're not already connected --- */

	if (cnctdrvQueryStatus(hhDriver) != CNCT_STATUS_FALSE)
		return CNCT_ERROR;

	// JMH 05-29-96 This is needed to prevent CLoop from processing
	// activity on the terminal window while TAPI is connecting.
	//
	CLoopRcvControl(sessQueryCLoopHdl(hhDriver->hSession),
				    CLOOP_SUSPEND,
					CLOOP_RB_CNCTDRV);
	CLoopSndControl(sessQueryCLoopHdl(hhDriver->hSession),
					CLOOP_SUSPEND,
					CLOOP_SB_CNCTDRV);

	/* --- Just on the off chance we still have an open line --- */

	if (hhDriver->hLineApp && hhDriver->hLine)
		{
		lineClose(hhDriver->hLine);
		memset(&hhDriver->stCallPar, 0, sizeof(hhDriver->stCallPar));
		hhDriver->stCallPar.dwTotalSize = sizeof(hhDriver->stCallPar);
		hhDriver->stCallPar.dwMediaMode = LINEMEDIAMODE_DATAMODEM;
		hhDriver->stCallPar.dwCallParamFlags = LINECALLPARAMFLAGS_IDLE;
		hhDriver->stCallPar.dwBearerMode = 0;
		hhDriver->hLine = 0;
		}

	if (hhDriver->hLineApp && hhDriver->dwLineCnt == 0 &&
            (uFlags & CNCT_PORTONLY) == 0)
		{
    	DoNewModemWizard(sessQueryHwnd(hhDriver->hSession),
                         sessQueryTimeout(hhDriver->hSession));
		}

	/* --- Ask for new session name only if needed  --- */

	sessQueryName(hhDriver->hSession, ach, sizeof(ach));

	achNewCnct[0] = TEXT('\0');
	LoadString(glblQueryDllHinst(),	IDS_GNRL_NEW_CNCT, achNewCnct,
		sizeof(achNewCnct) / sizeof(TCHAR));

	if (ach[0] == TEXT('\0') || lstrcmp(achNewCnct, ach) == 0)
		{
		// This can only happen if the user double-clicks on the term.exe or
		// there is no session name given on the command line.
		// In this case give the "New Connection" name to the session.
		//
		sessSetName(hhDriver->hSession, achNewCnct);

		if (!(uFlags & CNCT_PORTONLY))
            fGetNewName = TRUE;
		}
	else if (uFlags & CNCT_NEW)
		{
		// This can only happen if the user selects 'File | New Connection'
		// from the menus.
		//
		sessSetName(hhDriver->hSession, achNewCnct);
		sessSetIsNewSession(hhDriver->hSession, TRUE);
		}
	#if defined (INCL_WINSOCK)
	else if (uFlags & CNCT_WINSOCK)
		{
		//
		// Make sure we don't overwrite the buffer. If the string
		// is too long, then truncate to the hhDriver->achDestAddr
		// size of MAX_AP_ADDR_LEN.  REV 09/20/2000 
		//
		StrCharCopyN(hhDriver->achDestAddr, ach, MAX_IP_ADDR_LEN);
		hhDriver->achDestAddr[MAX_IP_ADDR_LEN - 1] = TEXT('\0');
		hhDriver->dwPermanentLineId = DIRECT_COMWINSOCK;
		}
	#endif // defined (INCL_WINSOCK)

	if (fGetNewName || (uFlags & CNCT_NEW))
		{
		if (DialogBoxParam(glblQueryDllHinst(), MAKEINTRESOURCE(IDD_NEWCONNECTION),
			sessQueryHwnd(hhDriver->hSession), NewConnectionDlg,
				(LPARAM)hhDriver->hSession) == FALSE)
			{
			if (uFlags & CNCT_NEW)
				{
				sessQueryOldName(hhDriver->hSession, ach, sizeof(ach));
				sessSetName(hhDriver->hSession, ach);
				sessSetIsNewSession(hhDriver->hSession, FALSE);
				}
			goto ERROR_EXIT;
			}
		else
			{
			if (uFlags & CNCT_NEW)
				{
				sessQueryName(hhDriver->hSession, ach, sizeof(ach));
				hIcon = sessQueryIcon(hhDriver->hSession);
				hIconId = sessQueryIconID(hhDriver->hSession);

				ReinitializeSessionHandle(hhDriver->hSession, FALSE);
				CLoopSndControl(sessQueryCLoopHdl(hhDriver->hSession),
                                CLOOP_SUSPEND,
                                CLOOP_SB_CNCTDRV);

				sessSetName(hhDriver->hSession, ach);
				sessSetIconID(hhDriver->hSession, hIconId);
				}
			}
		}

	/* --- Load the Standard Com  drivers --- */

	ComLoadStdcomDriver(hCom);

	// There are a bunch of conditions that can trigger the
	// phone dialog.
	//
	fFlag = FALSE;

	// If no phone number, bring up new phone dialog here
	// Unless we have a direct to com port selected
    //
    // Don't display the dialog if we are answering, because
    // we don't need a phone number. - cab:11/19/96
    //
	
	if (!IN_RANGE(hhDriver->dwPermanentLineId, DIRECT_COM1, DIRECT_COM4) &&
            hhDriver->dwPermanentLineId != DIRECT_COM_DEVICE &&
			!(uFlags & (CNCT_PORTONLY | CNCT_ANSWER)))
		{
		#ifdef INCL_WINSOCK
        // If the driver is WinSock, then check for a
        // destination IP address. - cab:11/19/96
        //
        if (hhDriver->dwPermanentLineId == DIRECT_COMWINSOCK &&
                hhDriver->achDestAddr[0] == TEXT('\0'))
            {
            fFlag = TRUE;
            }
		#endif // defined (INCL_WINSOCK)
        // If the driver isn't WinSock, then we must be using
        // TAPI, so check for a destination phone number. - cab:11/19/96
        //
        if (hhDriver->dwPermanentLineId != DIRECT_COMWINSOCK &&
                (hhDriver->achDest[0] == TEXT('\0') || 
				 hhDriver->achDialableDest[0] == TEXT('\0') ||
				 hhDriver->achCanonicalDest[0] == TEXT('\0')))
            {
            fFlag = TRUE;
            }
		}

	// New connections trigger this dialog
	//
	if (uFlags & CNCT_NEW)
		fFlag = TRUE;

	// If the modem/port we saved no longer exists
	//
	//if (!hhDriver->fMatchedPermanentLineID)
	//	fFlag = TRUE;

	// Note:  Passing the property sheet page here because property
	//        sheets use same code and don't have access directly
	//        to the private driver handle.  Upper wacker will have
	//        to address the problem differently - mrw.

	if (fFlag)
		{
		PROPSHEETPAGE psp;

		// Before you go and critize this goto target come talk to
		// me.	There are enough things going on here that a goto
		// is warranted in my humble opinion. - mrw

NEWPHONEDLG:

		psp.lParam = (LPARAM)hhDriver->hSession;

		if (DialogBoxParam(glblQueryDllHinst(),
			MAKEINTRESOURCE(IDD_CNCT_NEWPHONE),
				sessQueryHwnd(hhDriver->hSession), NewPhoneDlg,
					(LPARAM)&psp) == FALSE)
			{
			goto ERROR_EXIT;
			}
		else if (IN_RANGE(hhDriver->dwPermanentLineId, DIRECT_COM1, DIRECT_COM4) ||
				(IsNT() && hhDriver->dwPermanentLineId == DIRECT_COM_DEVICE))
			{
			//
			// See if the "Configure..." button has already been clicked
			// and the ComDeviceDialog() function has already been called
			// for this COM device.
			//
			TCHAR szPortName[MAX_PATH];

			ComGetPortName(hCom, szPortName, MAX_PATH);

			if (StrCharCmp(szPortName, hhDriver->achComDeviceName) != 0 )
				{
				/* --- Bring up the port configure dialog --- */
				if (hhDriver->dwPermanentLineId == DIRECT_COM_DEVICE)
					{
					ComSetPortName(hCom, hhDriver->achComDeviceName);
					}
				else
					{
					wsprintf(ach, TEXT("COM%d"),
							 hhDriver->dwPermanentLineId - DIRECT_COM1 + 1);
					ComSetPortName(hCom, ach);
					}

				//
				// Get the current defaults for the serial port.
				//
				if (ComDriverSpecial(hCom, "GET Defaults", NULL, 0) != COM_OK)
					{
					if (ComDeviceDialog(hCom, sessQueryHwnd(hhDriver->hSession))
							!= COM_OK)
						{
						goto ERROR_EXIT;
						}
					}

				if (ComDeviceDialog(hCom, sessQueryHwnd(hhDriver->hSession))
						!= COM_OK)
					{
					// User canceled
					//  --jcm 3-2-95
					//return CNCT_BAD_HANDLE;
					}
				}
			}
		#if defined(INCL_WINSOCK) // mrw:3/5/96
        else if (hhDriver->dwPermanentLineId == DIRECT_COMWINSOCK)
            {
            if (hhDriver->achDestAddr[0] == TEXT('\0'))
                {
				LoadString(glblQueryDllHinst(), IDS_ER_TCPIP_MISSING_ADDR,
					ach, sizeof(ach) / sizeof(TCHAR));

        		TimedMessageBox(sessQueryHwnd(hhDriver->hSession), ach, NULL,
		        	MB_OK | MB_ICONINFORMATION,
                        sessQueryTimeout(hhDriver->hSession));

                goto NEWPHONEDLG;
                }
            }
		#endif
        else
            {
            // mrw: Check that we have valid data.
            //
            if (hhDriver->achDest[0] == TEXT('\0'))
                {
		        LoadString(glblQueryDllHinst(), IDS_ER_CNCT_BADADDRESS, ach,
    			    sizeof(ach) / sizeof(TCHAR));

        		TimedMessageBox(sessQueryHwnd(hhDriver->hSession), ach, NULL,
		        	MB_OK | MB_ICONINFORMATION,
                        sessQueryTimeout(hhDriver->hSession));

                // goto ERROR_EXIT; // mrw:3/5/96
                goto NEWPHONEDLG;   // mrw:3/5/96
                }
            }
		}

	/* --- Enumerate lines, picks default (set in hhDriver->dwLine) --- */

	if ( IsNT() )
		{
		if (EnumerateLinesNT(hhDriver, 0) != 0)
			{
			assert(FALSE);
			goto MSG_EXIT;
			}
		}
	else
		{
		if (EnumerateLines(hhDriver, 0) != 0)
			{
			assert(FALSE);
			goto MSG_EXIT;
			}
		}


	/* --- If we don't match any TAPI lines, go back to new phone --- */

	if (hhDriver->dwLine == (DWORD)-1)
		{
		//
		// If this is not a modem (it is a COM port), then display the modem
		// wizard, otherwise just go back to the new phone. REV: 11/1/2001
		//
		if (!IN_RANGE(hhDriver->dwPermanentLineId, DIRECT_COM1, DIRECT_COM4) &&
		    hhDriver->dwPermanentLineId != DIRECT_COM_DEVICE )
			{
			DoNewModemWizard(sessQueryHwnd(hhDriver->hSession),
							 sessQueryTimeout(hhDriver->hSession));
			}

		goto NEWPHONEDLG;
		}

	/* --- Redraw window now so dialogs don't overlap ---- */

	UpdateWindow(sessQueryHwnd(hhDriver->hSession));

 	/* --- Check if we're doing a direct connect or using passthrough mode --- */

	if (IsNT() && hhDriver->dwPermanentLineId == DIRECT_COM_DEVICE)
		{
        int iActivatePortReturn = IDS_ER_CNCT_PORTFAILED;
		if (TRAP(ComSetPortName(hCom, hhDriver->achComDeviceName)) != COM_OK ||
			(iActivatePortReturn = TRAP(ComActivatePort(hCom, 0))) != COM_OK)
			{
            if (iActivatePortReturn == COM_PORT_IN_USE)
                {
				LoadString(glblQueryDllHinst(), IDS_ER_CNCT_CALLUNAVAIL,
					ach, sizeof(ach) / sizeof(TCHAR));
                }
            else
                {
				LoadString(glblQueryDllHinst(), IDS_ER_CNCT_PORTFAILED,
					achNewCnct, sizeof(achNewCnct) / sizeof(TCHAR));

				wsprintf(ach, achNewCnct, hhDriver->achComDeviceName);
                }

			TimedMessageBox(sessQueryHwnd(hhDriver->hSession), ach, NULL,
				MB_OK | MB_ICONINFORMATION,
					sessQueryTimeout(hhDriver->hSession));

			return -1;
			}
		else
			{
            if (uFlags & CNCT_ANSWER)
                {
                SetStatus(hhDriver, CNCT_STATUS_ANSWERING);
                }
            else
                {
			    SetStatus(hhDriver, CNCT_STATUS_CONNECTING);
                }
			}

		//
		// Allow PASSTHROUGH on serial ports as well so that the session
		// will not be disconnected with loss of carrier. REV: 11/6/2001
		//
		if (uFlags & CNCT_PORTONLY)
			{
			hhDriver->stCallPar.dwBearerMode = LINEBEARERMODE_PASSTHROUGH;
			}

		cnctdrvComEvent(hhDriver, CONNECT);

		return COM_OK;
		}
	else if (IN_RANGE(hhDriver->dwPermanentLineId, DIRECT_COM1, DIRECT_COM4))
		{
        int iActivatePortReturn = IDS_ER_CNCT_PORTFAILED;
		wsprintf(achCom, TEXT("COM%d"), hhDriver->dwPermanentLineId -
			DIRECT_COM1 + 1);

        if (TRAP(ComSetPortName(hCom, achCom)) != COM_OK ||
			(iActivatePortReturn = TRAP(ComActivatePort(hCom, 0))) != COM_OK)
			{
            if (iActivatePortReturn == COM_PORT_IN_USE)
                {
				LoadString(glblQueryDllHinst(), IDS_ER_CNCT_CALLUNAVAIL,
					ach, sizeof(ach) / sizeof(TCHAR));
                }
            else
                {
				LoadString(glblQueryDllHinst(), IDS_ER_CNCT_PORTFAILED,
					achNewCnct, sizeof(achNewCnct) / sizeof(TCHAR));

			    wsprintf(ach, achNewCnct, achCom);
                }

			TimedMessageBox(sessQueryHwnd(hhDriver->hSession), ach, NULL,
				MB_OK | MB_ICONINFORMATION,
					sessQueryTimeout(hhDriver->hSession));

			return -1;
			}

		else
			{
            if (uFlags & CNCT_ANSWER)
                {
                SetStatus(hhDriver, CNCT_STATUS_ANSWERING);
                }
            else
                {
			    SetStatus(hhDriver, CNCT_STATUS_CONNECTING);
                }
			}

		//
		// Allow PASSTHROUGH on serial ports as well so that the session
		// will not be disconnected with loss of carrier. REV: 11/6/2001
		//
		if (uFlags & CNCT_PORTONLY)
			{
			hhDriver->stCallPar.dwBearerMode = LINEBEARERMODE_PASSTHROUGH;
			}

		cnctdrvComEvent(hhDriver, CONNECT);

		return COM_OK;
		}
	#if defined(INCL_WINSOCK)
	else if (hhDriver->dwPermanentLineId == DIRECT_COMWINSOCK)
		{
		int iPort;

		/* --- Load the Winsock Com  drivers --- */
		ComLoadWinsockDriver(hCom);

        // Baud rate, etc. are meaningless for TCP/IP connections
        //
        ComSetAutoDetect(hCom, FALSE);
		iPort = sessQueryTelnetPort(hhDriver->hSession);
		if (iPort != 0)
			hhDriver->iPort = iPort;
        PostMessage(sessQueryHwndStatusbar(hhDriver->hSession),
            SBR_NTFY_REFRESH, (WPARAM)SBR_COM_PART_NO, 0);

#if 0   //DEADWOOD:jmh 3/24/97 Yes, we really want auto-detection, even in telnet!
        // Auto-detection of emulator type is redundant, since we tell
        // the telnet host what type we want. Seems like ANSI is the
        // most likely choice.
        hEmu = sessQueryEmuHdl(hhDriver->hSession);
        if (emuQueryEmulatorId(hEmu) == EMU_AUTO)
            {
            emuLoad(hEmu, EMU_VT100);
			#if defined(INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID)
            // Make sure the telnet terminal id is correct. - cab:11/18/96
            //
            emuLoadDefaultTelnetId(hEmu);
			#endif // defined(INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID)
            PostMessage(sessQueryHwndStatusbar(hhDriver->hSession),
                SBR_NTFY_REFRESH, (WPARAM)SBR_EMU_PART_NO, 0);
            }
#endif  // 0

		#if defined(INCL_CALL_ANSWERING)
        if (uFlags & CNCT_ANSWER)
            {
            wsprintf(szInstruct, "SET ANSWER=1");
            }
        else
            {
            wsprintf(szInstruct, "SET ANSWER=0");
            }
        ComDriverSpecial(hCom, szInstruct, szResult, sizeof(szResult) / sizeof(TCHAR));
		#endif // defined(INCL_CALL_ANSWERING)
		/* --- Do ComDriverSpecial calls to send the IP address &  port number
			   to the comm driver */

		//
		// Make sure we don't overwrite the buffer. If the string
		// is too long, then truncate to the hhDriver->achDestAddr
		// size of MAX_AP_ADDR_LEN.  REV 09/20/2000 
		//
		StrCharCopyN(szInstruct, TEXT("SET IPADDR="), sizeof(szInstruct) / sizeof(TCHAR));
		iNumChars = StrCharGetStrLength(szInstruct);
		StrCharCopyN(&szInstruct[iNumChars], hhDriver->achDestAddr,
			         sizeof(szInstruct)/sizeof(TCHAR) - iNumChars);

		//
		// Make sure the string is null terminated.
		//
		szInstruct[sizeof(szInstruct)/sizeof(TCHAR) - 1]=TEXT('\0');
		ComDriverSpecial(hCom, szInstruct, szResult,
					  sizeof(szResult) / sizeof(TCHAR));

		wsprintf(szInstruct, "SET PORTNUM=%ld", hhDriver->iPort);
		ComDriverSpecial(hCom, szInstruct,
					  szResult, sizeof(szResult) / sizeof(TCHAR));

		#if defined(INCL_CALL_ANSWERING)
        if (uFlags & CNCT_ANSWER)
            {
            SetStatus(hhDriver, CNCT_STATUS_ANSWERING);
            }
        else
            {
		    SetStatus(hhDriver, CNCT_STATUS_CONNECTING);
            }
		#else // defined(INCL_CALL_ANSWERING)
		SetStatus(hhDriver, CNCT_STATUS_CONNECTING);
		#endif // defined(INCL_CALL_ANSWERING)

		/* --- Activate the port  ---*/
		if (ComActivatePort(hCom, 0) != COM_OK)
			{
			LoadString(glblQueryDllHinst(), IDS_ER_TCPIP_FAILURE,
			achNewCnct, sizeof(achNewCnct) / sizeof(TCHAR));

			TimedMessageBox(sessQueryHwnd(hhDriver->hSession), ach, NULL,
				MB_OK | MB_ICONINFORMATION,
				sessQueryTimeout(hhDriver->hSession));

			return -1;
			}

		else
			{
			return COM_OK;
			}
		}
	#endif // defined(INCL_WINSOCK)

	/* --- Display confimation dialog if requested --- */

	if ((uFlags & (CNCT_PORTONLY | CNCT_DIALNOW | CNCT_ANSWER)) == 0)
		{
		if (DialogBoxParam(glblQueryDllHinst(),
			MAKEINTRESOURCE(IDD_CNCT_CONFIRM),
				sessQueryHwnd(hhDriver->hSession), ConfirmDlg,
					(LPARAM)hhDriver) == FALSE)
			{
			goto ERROR_EXIT;
			}
		}

    // Either make the call or wait for a call.
    //
    if (uFlags & CNCT_ANSWER)
        {
        if (DoAnswerCall(hhDriver) != 0)
            {
            goto ERROR_EXIT;
            }
        }
    else
        {
        if (DoMakeCall(hhDriver, uFlags) != 0)
            {
            goto ERROR_EXIT;
            }
        }

    ComSetAutoDetect(hCom, FALSE);
    PostMessage(sessQueryHwndStatusbar(hhDriver->hSession),
        SBR_NTFY_REFRESH, (WPARAM)SBR_COM_PART_NO, 0);

    return 0;

	/* --- Message exit --- */

MSG_EXIT:
	LoadString(glblQueryDllHinst(), uidErr, ach, sizeof(ach) / sizeof(TCHAR));

	TimedMessageBox(sessQueryHwnd(hhDriver->hSession), ach,
		            NULL, MB_OK | MB_ICONINFORMATION | MB_TASKMODAL,
					sessQueryTimeout(hhDriver->hSession));

	/* --- Error exit --- */

ERROR_EXIT:
	if (hhDriver->hLineApp && hhDriver->hLine)
		{
		lineClose(hhDriver->hLine);
		memset(&hhDriver->stCallPar, 0, sizeof(hhDriver->stCallPar));
		hhDriver->stCallPar.dwTotalSize = sizeof(hhDriver->stCallPar);
		hhDriver->stCallPar.dwMediaMode = LINEMEDIAMODE_DATAMODEM;
		hhDriver->stCallPar.dwCallParamFlags = LINECALLPARAMFLAGS_IDLE;
		hhDriver->stCallPar.dwBearerMode = 0;
		hhDriver->hLine = 0;
		}

	SetStatus(hhDriver, CNCT_STATUS_FALSE);
    return CNCT_ERROR;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DoDelayedCall
 *
 * DESCRIPTION:
 *	Check the section under Delayed Dialing in the programmers guide to
 *	TAPI.  Basicly, if the service provider does not provide dialtone
 *	support, then we have to break of the dialable string format into
 *	pieces and prompt the user.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle.
 *
 * RETURNS:
 *	0=OK, else error.
 *
 * AUTHOR: Mike Ward, 20-Apr-1995
 */
static int DoDelayedCall(const HHDRIVER hhDriver)
	{
	TCHAR ach[256];
	TCHAR ach2[256];
	TCHAR *pach;
	long  lDialRet;

	#define DIAL_DELIMITERS "Ww@$?"

	hhDriver->lMakeCallId = -1;
	lstrcpy(ach, hhDriver->achDialableDest);

	if ((pach = strtok(ach, DIAL_DELIMITERS)) == 0)
		return -1;

	while (pach)
		{
		lstrcpy(ach2, pach);

		// If this is the last segment of the string, don't append the
		// semicolon.
		//
		if ((pach = strtok(NULL, DIAL_DELIMITERS)) != 0)
			lstrcat(ach2, ";");

		if (hhDriver->lMakeCallId < 0)
			{
			// By appending a semicolon to the dialable string, we're
			// telling lineMakeCall that more is on the way.
			//
			if ((hhDriver->lMakeCallId = lineMakeCall(hhDriver->hLine,
				&hhDriver->hCall, ach2, hhDriver->dwCountryCode,
					&hhDriver->stCallPar)) < 0)
				{
				#if defined(_DEBUG)
				char ach[50];
				wsprintf(ach, "DoDelayedCall returned %x", hhDriver->lMakeCallId);
				MessageBox(GetFocus(), ach, "debug", MB_OK);
				#endif

				return -3;
				}
			}

		else
			{
			// Once we have a call handle we have to use lineDial to complete
			// the call.
			//
			if ((lDialRet = lineDial(hhDriver->hCall, ach2,
				hhDriver->dwCountryCode)) < 0)
				{
				#if defined(_DEBUG)
				char ach[50];
				wsprintf(ach, "lineDial returned %x", lDialRet);
				MessageBox(GetFocus(), ach, "debug", MB_OK);
				#endif

				return -4;
				}
			}

		// The user has to tell us when the we can continue dialing
		//
		if (pach != 0)
			{
			LoadString(glblQueryDllHinst(), IDS_CNCT_DELAYEDDIAL, ach2,
			sizeof(ach2) / sizeof(TCHAR));

			if (TimedMessageBox(hhDriver->hwndCnctDlg, ach2, NULL,
				                MB_OKCANCEL | MB_ICONINFORMATION | MB_TASKMODAL,
								sessQueryTimeout(hhDriver->hSession)) != IDOK)
				{
				return -4;
				}
			}
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvDisconnect
 *
 * DESCRIPTION:
 *  Signals a disconnect
 *
 * ARGUMENTS:
 *  hhDriver - private driver handle
 *  uFlags   - disconnect flags
 *
 * RETURNS:
 *  0 or error
 *
 */
int WINAPI cnctdrvDisconnect(const HHDRIVER hhDriver, const unsigned int uFlags)
	{
	LONG      lLineDropId;
    #if defined(INCL_REDIAL_ON_BUSY)
    HKEY      hKey;
    DWORD     dwSize;
    BYTE      ab[20];
    #endif
    XD_TYPE*  pX;
    int       nReturnVal = 0;
    TCHAR     ach[256];

	if (hhDriver == 0)
		{
		assert(FALSE);
		return CNCT_BAD_HANDLE;
		}

    //
    // Cancel any active file transfers that are currently executing.
    // REV: 02/01/2001
    //
	pX = (XD_TYPE*)sessQueryXferHdl(hhDriver->hSession);

    if (pX != NULL && pX->hwndXfrDisplay != NULL &&
        IsWindow(pX->hwndXfrDisplay) && pX->nDirection != XFER_NONE)
        {
        int nCancelTransfer = IDYES;


        if (uFlags & CNCT_XFERABORTCONFIRM)
            {
            //
            // Prompt to cancel the file transfer. REV: 02/16/2001
            //
            LoadString(glblQueryDllHinst(), IDS_ER_CNCT_ACTIVETRANSFER, ach, sizeof(ach) / sizeof(TCHAR));

            nCancelTransfer = TimedMessageBox(pX->hwndXfrDisplay, ach, NULL,
                                              MB_YESNO | MB_ICONEXCLAMATION | MB_TASKMODAL,
			                                  sessQueryTimeout(hhDriver->hSession));

            }

        if (nCancelTransfer == IDYES || nCancelTransfer == -1)
            {
            unsigned int uNewFlags = uFlags;

            if (uFlags & CNCT_LOSTCARRIER)
                {
                //
                // NOTE:  We should only have to tell the XFER to abort here.
                //        It should not be dependent on a message to a dialog.
                //
                PostMessage(pX->hwndXfrDisplay, WM_COMMAND, XFER_LOST_CARRIER, 0L);
                }
            else if (uFlags & CNCT_XFERABORTCONFIRM)
                {
                //
                // NOTE:  We should only have to tell the XFER to abort here.
                //        It should not be dependent on a message to a dialog.
                //
                PostMessage(pX->hwndXfrDisplay, WM_COMMAND, XFR_SHUTDOWN, 0L);
                }

            //
            // We can't exit until the file transfer exits, so post a
            // message to try to disconnect again.  Make sure to turn
            // of the CNCT_XFERABORTCONFIRM flag as we don't want to
            // prompt the kill the transfer again.
            //
            uNewFlags &= ~CNCT_XFERABORTCONFIRM;

            //
            // We must post a message to disconnect because we are
            // waiting for the file transfer to cancel.  We have to
            // post a message otherwise we will get into a deadlock
            // situation.  This is not the best way to accomplish
            // this as we may be posting a lot of messages to the
            // session window and there is a potential for the
            // file transfer to not respond quickly causing the
            // disconnect to loop.  Eventually, the file transfer
            // will cancel, or will timeout and cancel, so we will
            // not get into an endless loop. REV: 06/22/2001
            //

			//
			// Wait half a second before posting this message so we don't
			// flood ourselves with disconnect messages. REV: 4/25/2002
			//
			Sleep(500);
            PostDisconnect(hhDriver, uNewFlags);
            }

        //
        // Return an status that the current file transfer must be
        // canceled (or is in the process of being canceled).  We
        // cannot disconnect until the transfer is complete.
        //
        return XFR_SHUTDOWN;
        }

#ifdef INCL_CALL_ANSWERING
    // Unregister our cloop callback.
    //
    if (hhDriver->pvUnregister)
        {
        CLoopUnregisterRmtInputChain(hhDriver->pvUnregister);
        hhDriver->pvUnregister = 0;
        }
#endif

	ComDeactivatePort(sessQueryComHdl(hhDriver->hSession));

	if (hhDriver->hCall)
		{
		SetStatus(hhDriver, CNCT_STATUS_DISCONNECTING);

		if ((lLineDropId = lineDrop(hhDriver->hCall, 0, 0)) < 0)
			assert(FALSE);

		hhDriver->hCall = 0;

		// If the drop is completing asychronously, save the flags and
		// wait for the call status to go idle.
		//
		if (lLineDropId > 0)
			{
			hhDriver->uDiscnctFlags = uFlags;
			return 0;
			}
		}

	SetStatus(hhDriver, CNCT_STATUS_FALSE);

	if ((uFlags & DISCNCT_NOBEEP) == 0)
		sessBeeper(hhDriver->hSession);

	//mpt:10-28-97 added exit upon disconnect feature
	if ((uFlags & DISCNCT_EXIT))
		PostMessage(sessQueryHwnd(hhDriver->hSession), WM_CLOSE, 0, 0);

	if (hhDriver->hLine)
		{
		lineClose(hhDriver->hLine);
		memset(&hhDriver->stCallPar, 0, sizeof(hhDriver->stCallPar));
		hhDriver->stCallPar.dwTotalSize = sizeof(hhDriver->stCallPar);
		hhDriver->stCallPar.dwMediaMode = LINEMEDIAMODE_DATAMODEM;
		hhDriver->stCallPar.dwCallParamFlags = LINECALLPARAMFLAGS_IDLE;
		hhDriver->stCallPar.dwBearerMode = 0;
		hhDriver->hLine = 0;
		}

	if (uFlags & CNCT_DIALNOW)
		{
        #if defined(INCL_REDIAL_ON_BUSY)
        if (hhDriver->fRedialOnBusy && hhDriver->iRedialCnt > 0)
            {
			hhDriver->uDiscnctFlags = uFlags;
            hhDriver->iRedialSecsRemaining = 2;

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                "SOFTWARE\\Microsoft\\HyperTerminal\\TimeToRedial", 0, KEY_READ,
                    &hKey) == ERROR_SUCCESS)
                {
                dwSize = sizeof(ab);

                if (RegQueryValueEx(hKey, "", 0, 0, ab, &dwSize) == ERROR_SUCCESS)
                    hhDriver->iRedialSecsRemaining = atoi(ab);

                RegCloseKey(hKey);
                }

            SetTimer(hhDriver->hwndCnctDlg, 1, 1000, 0);
            }

        else
            {
		    PostMessage(sessQueryHwnd(hhDriver->hSession), WM_CNCT_DIALNOW,
			    uFlags, 0);
            }

        #else
		PostMessage(sessQueryHwnd(hhDriver->hSession), WM_CNCT_DIALNOW,
			uFlags, 0);
        #endif
		}

    else
        {
        // If we're not auto redialing, reset the dial count. - mrw:10/10/95
        //
        hhDriver->iRedialCnt = 0;
        }

	return nReturnVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  lineCallbackFunc
 *
 * DESCRIPTION:
 *  Function TAPI calls to handle asynchronous events
 *
 * ARGUMENTS:
 *  see TAPI.H
 *
 * RETURNS:
 *  void
 *
 */
void CALLBACK lineCallbackFunc(DWORD hDevice, DWORD dwMsg, DWORD_PTR dwCallback,
							   DWORD_PTR dwParm1, DWORD_PTR dwParm2, DWORD_PTR dwParm3)
	{
	const HHDRIVER hhDriver = (HHDRIVER)dwCallback;
	int id;
    unsigned int uFlags;

	#if 0
	{
	char ach[256];
	wsprintf(ach,"%x %x", dwMsg, dwParm1);
	MessageBox(NULL, ach, "debug", MB_OK);
	}
	#endif

	switch (dwMsg)
		{
	case LINE_REPLY:
		if ((LONG)dwParm1 == hhDriver->lMakeCallId)
			{
			hhDriver->lMakeCallId = 0;

			if ((LONG)dwParm2 != 0) // zero indicates success
				{
				switch (dwParm2)
					{
				case LINEERR_CALLUNAVAIL:
					id = IDS_DIAL_NODIALTONE;
					break;

				default:
					id = IDS_DIAL_DISCONNECTED;
					break;
					}

				cnctdrvDisconnect(hhDriver, 0);
				DialingMessage(hhDriver, id);
				}
			}
		break;

	case LINE_LINEDEVSTATE:
		DbgOutStr("LINEDEVSTATE_DISCONNECTED 0x%x\r\n", dwParm1, 0, 0, 0, 0);

		switch (dwParm1)
			{
        case PHONESTATE_CAPSCHANGE:
            //
            // If we are currently disconnected, then reset.
            //
            if (hhDriver != NULL && hhDriver->iStatus != CNCT_STATUS_FALSE)
                break;

		case LINEDEVSTATE_REINIT:
        case PHONESTATE_REINIT:
			if (hhDriver == 0)
				{
				// Until we open a line, we don't have a driver handle
				// since we can't pass one during lineInitialize().
				// This turns out to be a good time to reinit if we get
				// notified to do so however, so it has use.
				//
				if (tapiReinit(gbl_hhDriver) != 0)
					tapiReinitMessage(gbl_hhDriver);
				}

			else
				{
				tapiReinitMessage(hhDriver);
				}
			break;

		case LINEDEVSTATE_INSERVICE:
			// If we are showing our PCMCIA dialog prompting the user
			// to insert the card, we post a message to dismiss the
			// dialog once they insert it. - mrw,2/28/95
			//
			if (IsWindow(hhDriver->hwndPCMCIA))
				{
				PostMessage(hhDriver->hwndPCMCIA, WM_COMMAND,
					MAKEWPARAM(IDOK, 0), (LPARAM)hhDriver->hwndPCMCIA);
				}
			break;

		case LINEDEVSTATE_OUTOFSERVICE:
			// Means they yanked the PCMCIA card - mrw,2/28/95
			//
			cnctdrvDisconnect(hhDriver, 0);
			break;

        case LINEDEVSTATE_RINGING:
            // When the current ring count (as told by dwParam3) equals
            // or exceeds the rings to answer on then we'll do the answer
            // using the hhdriver->hCall handle we cached during the
            // LINECALLSTATE_BURNTOFFERING notification. - rjk. 07-31-96
            //
            if ((hhDriver->lMakeCallId = lineAnswer(hhDriver->hCall,0,0)) >= 0)
                {
                SetStatus(hhDriver, CNCT_STATUS_CONNECTING);
                }
            break;

        case LINEDEVSTATE_CLOSE:
        case PHONESTATE_DISCONNECTED:
            //
            // Another application has disconnected this device. REV: 04/27/2001
            //
            uFlags = CNCT_DIALNOW | CNCT_NOCONFIRM;
            id = IDS_DIAL_DISCONNECTED;
			PostDisconnect(hhDriver, uFlags);
			DialingMessage(hhDriver, id);
            break;

		default:
			break;
			}
		break; // case LINE_LINEDEVSTATE

	case LINE_CREATE:	// Sent when new modem is added
		assert(0);		// So I know it happened

		// A remote possibilility exists that if two modems were created
		// back to back, that the LINE_CREATE's would come out of order.
		// T. Nixon suggests that we bump the line count by the dwParm1
		// parameter plus one only when it is greater than or equal to
		// the current line count. - mrw
		//
		if (dwParm1 >= gbl_hhDriver->dwLineCnt)
			gbl_hhDriver->dwLineCnt = (DWORD)(dwParm1 + 1);

		break;

	case LINE_CALLSTATE:
		DbgOutStr("LINECALLSTATE 0x%x\r\n", dwParm1, 0, 0, 0, 0);
		switch ((LONG)dwParm1)
			{
		case LINECALLSTATE_OFFERING:
			DialingMessage(hhDriver, IDS_DIAL_OFFERING);
            // Windows sends us this message only one time while receiving
            // a call and that is on the very first ring.  See the code
            // that responds to the LINEDEVSTATE_RINGING to see how the call
            // gets answered. - rjk. 07-31-96
            //
            hhDriver->hCall = (HCALL)hDevice;
			break;

		case LINECALLSTATE_DIALTONE:
			DialingMessage(hhDriver, IDS_DIAL_DIALTONE);
			break;

		case LINECALLSTATE_DIALING:
			DialingMessage(hhDriver, IDS_DIAL_DIALING);
			break;

		case LINECALLSTATE_RINGBACK:
			DialingMessage(hhDriver, IDS_DIAL_RINGBACK);
			break;

		case LINECALLSTATE_BUSY:
			DialingMessage(hhDriver, IDS_DIAL_BUSY);
			EnableDialNow(hhDriver->hwndCnctDlg, TRUE);
            uFlags = DISCNCT_NOBEEP;

            #if defined(INCL_REDIAL_ON_BUSY)
            if (hhDriver->fRedialOnBusy && hhDriver->iRedialCnt++ < REDIAL_MAX)
                uFlags = CNCT_DIALNOW | CNCT_NOCONFIRM | DISCNCT_NOBEEP;
            #endif

			PostDisconnect(hhDriver, uFlags);
			break;

		case LINECALLSTATE_CONNECTED:
			DialingMessage(hhDriver, IDS_DIAL_CONNECTED);

			if (Handoff(hhDriver) != 0)
				{
				PostDisconnect(hhDriver, 0);
				}
			else
				{
                if (IsWindow(hhDriver->hwndCnctDlg))
                    {
                    // Closes the dialing dialog
				    PostMessage(hhDriver->hwndCnctDlg, WM_USER+0x100, 0, 0);
                    }
				SetStatus(hhDriver, CNCT_STATUS_TRUE);
				}

			break;

		case LINECALLSTATE_DISCONNECTED:
			DbgOutStr("LINECALLSTATE_DISCONNECTED 0x%x\r\n", dwParm2, 0, 0, 0, 0);
			uFlags = 0;

			if (dwParm2 & LINEDISCONNECTMODE_BUSY)
                {
				id = IDS_DIAL_BUSY;

                #if defined(INCL_REDIAL_ON_BUSY)
                if (hhDriver->fRedialOnBusy &&
                    hhDriver->iRedialCnt++ < REDIAL_MAX)
                    {
                    // Wait to let slower phone systems catchup - mrw 2/29/96
                    //
                    uFlags |= CNCT_DIALNOW|CNCT_NOCONFIRM|DISCNCT_NOBEEP;
                    }
                #endif
                }

			else if (dwParm2 & LINEDISCONNECTMODE_NOANSWER)
				id = IDS_DIAL_NOANSWER;

			else if (dwParm2 & LINEDISCONNECTMODE_NODIALTONE)
				id = IDS_DIAL_NODIALTONE;

			else
				{
				id = IDS_DIAL_DISCONNECTED;
				//mpt:10-28-97 added exit upon disconnect feature
				uFlags |= ( sessQueryExit(hhDriver->hSession) ? DISCNCT_EXIT : 0 );
				}

			PostDisconnect(hhDriver, uFlags);
			DialingMessage(hhDriver, id);
			break;

		case LINECALLSTATE_IDLE:
			cnctdrvDisconnect(hhDriver, hhDriver->uDiscnctFlags);
			break;

		default:
			break;
			}

	default:
		break;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	Handoff
 *
 * DESCRIPTION:
 *	Hands TAPI's com handle to the Wacker's com routines.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *
 * RETURNS:
 *	0=OK
 *
 */
int Handoff(const HHDRIVER hhDriver)
	{
	LPVARSTRING pVarstr;
	HANDLE hdl;
	DWORD dwSize;
	int i;

	pVarstr = malloc(sizeof(VARSTRING));

	if (pVarstr == 0)
		{
		assert(FALSE);
		return 1;
		}

    memset( pVarstr, 0, sizeof(VARSTRING) );
	pVarstr->dwTotalSize = sizeof(VARSTRING);

	if (lineGetID(hhDriver->hLine, hhDriver->dwLine, hhDriver->hCall,
                        LINECALLSELECT_CALL, pVarstr, DEVCLASS) != 0)
		{
		assert(FALSE);
        free(pVarstr);
        pVarstr = NULL;
		return 2;
		}

	if (pVarstr->dwNeededSize > pVarstr->dwTotalSize)
		{
		dwSize = pVarstr->dwNeededSize;
		free(pVarstr);
        pVarstr = NULL;
        pVarstr = malloc(dwSize);

		if (pVarstr == 0)
			{
			assert(FALSE);
			return 3;
			}

        memset( pVarstr, 0, dwSize );
		pVarstr->dwTotalSize = dwSize;

		if (TRAP(lineGetID(hhDriver->hLine, hhDriver->dwLine, hhDriver->hCall,
                                LINECALLSELECT_CALL, pVarstr, DEVCLASS)) != 0)
			{
			assert(FALSE);
			free(pVarstr);
            pVarstr = NULL;
            return 4;
			}
		}

	if (pVarstr->dwStringSize == 0)
		{
		assert(FALSE);
		free(pVarstr);
        pVarstr = NULL;
        return 5;
		}

	hdl = *(HANDLE *)((BYTE *)pVarstr + pVarstr->dwStringOffset);

	// Set comm buffers to 32K
	//
	if (SetupComm(hdl, 32768, 32768) == FALSE)
		{
		DWORD dwLastError = GetLastError();
		assert(0);
		}

	if ((i = ComActivatePort(sessQueryComHdl(hhDriver->hSession),
			(DWORD_PTR)hdl)) != COM_OK)
		{
        #if !defined(NDEBUG)
		char ach[256];
		wsprintf(ach, "hdl=%x, i=%d", hdl, i);
		MessageBox(NULL, ach, "debug", MB_OK);
        #endif

		assert(FALSE);
		free(pVarstr);
        pVarstr = NULL;
        return 6;
		}

    if(pVarstr)
        {
        free(pVarstr);
        pVarstr = NULL;
        }

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	PostDisconnect
 *
 * DESCRIPTION:
 *	Work around to TAPI bug that does not allow us to call lineShutDown()
 *	from with the TAPI callback
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *
 * RETURNS:
 *	void
 *
 */
void PostDisconnect(const HHDRIVER hhDriver, const unsigned int uFlags)
	{
	PostMessage(sessQueryHwnd(hhDriver->hSession), WM_DISCONNECT,
		uFlags, 0);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	tapiReinitMessage
 *
 * DESCRIPTION:
 *	Displays a messagebox showing TAPI needs to be reinitialized.
 *
 * ARGUMENTS:
 *	hhDriver    - private driver handle
 *
 * RETURNS:
 *  0=OK, <0=error
 *
 */
static int tapiReinitMessage(const HHDRIVER hhDriver)
    {
	TCHAR ach[512], achTitle[256];

	if (hhDriver == 0)
        {
        assert(FALSE);
        return -1;
		}

	LoadString(glblQueryDllHinst(), IDS_ER_TAPI_REINIT, ach, sizeof(ach) / sizeof(TCHAR));

	LoadString(glblQueryDllHinst(), IDS_ER_TAPI_REINIT2, achTitle,
		sizeof(achTitle) / sizeof(TCHAR));

	lstrcat(ach, achTitle);

	TimedMessageBox(sessQueryHwnd(hhDriver->hSession), ach, NULL,
		            MB_OK | MB_ICONINFORMATION | MB_TASKMODAL,
					sessQueryTimeout(hhDriver->hSession));

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	tapiReinit
 *
 * DESCRIPTION:
 *	Attempts to reinit tapi.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *
 * RETURNS:
 *	0=OK,else error
 *
 */
static int tapiReinit(const HHDRIVER hhDriver)
	{
	int i;
	LPVARSTRING pvs = 0;
    DWORD dwSize;
	const SF_HANDLE sfhdl = sessQuerySysFileHdl(hhDriver->hSession);

    if (hhDriver == 0)
        {
        assert(FALSE);
        return -1;
        }

    if (hhDriver->hLineApp)
        {
        /* --- Get current config so we can restore it --- */

        if (hhDriver->dwLine != (DWORD)-1)
            {
            if ((pvs = malloc(sizeof(VARSTRING))) == 0)
                {
                assert(FALSE);
                goto SHUTDOWN;
                }

			memset( pvs, 0, sizeof(VARSTRING) );
            pvs->dwTotalSize = sizeof(VARSTRING);

            if (lineGetDevConfig(hhDriver->dwLine, pvs, DEVCLASS) != 0)
                {
                assert(FALSE);
                free(pvs);
                pvs = NULL;
                hhDriver->dwLine = (DWORD)-1;
                goto SHUTDOWN;
                }

            if (pvs->dwNeededSize > pvs->dwTotalSize)
                {
                dwSize = pvs->dwNeededSize;
                free(pvs);
                pvs = NULL;

                if ((pvs = malloc(dwSize)) == 0)
                    {
                    assert(FALSE);
                    hhDriver->dwLine = (DWORD)-1;
                    goto SHUTDOWN;
                    }

				memset( pvs, 0, dwSize );
                pvs->dwTotalSize = dwSize;

                if (lineGetDevConfig(hhDriver->dwLine, pvs, DEVCLASS) != 0)
                    {
                    assert(FALSE);
                    free(pvs);
                    pvs = NULL;
                    hhDriver->dwLine = (DWORD)-1;
                    goto SHUTDOWN;
                    }
                }
            }

        SHUTDOWN:

		{
		LONG lLineShutdown = lineShutdown(hhDriver->hLineApp);

		if (lLineShutdown == LINEERR_NOMEM)
			{
			//
			// We are in a low memory state, so wait for a while,
			// then try to shutdown the line again. REV: 5/1/2002
			//
			Sleep(500);
			lLineShutdown = lineShutdown(hhDriver->hLineApp);
			}

		if (lLineShutdown != 0)
            {
            assert(FALSE);
            return -6;
            }
		}

        hhDriver->hLineApp = 0;

        // Wait for 10 seconds, if nothing happens, return an error
        //
        for (i=0 ;; ++i)
            {
            if (lineInitialize(&hhDriver->hLineApp, glblQueryDllHinst(),
                            lineCallbackFunc, g_achApp, &hhDriver->dwLineCnt) != 0)
                {
                if (i > 10)
                    {
                    assert(0);
                    return -7;
                    }

                Sleep(1000);    // sleep 1 second
                continue;
                }

            break;
            }
        }

    /* --- Ok, we've reintialized, put settings back now --- */

    if (pvs)
        {
    	LPVOID pv = (BYTE *)pvs + pvs->dwStringOffset;

        if (lineSetDevConfig(hhDriver->dwLine, pv, pvs->dwStringSize,
                             DEVCLASS) != 0)
            {
            assert(FALSE);
            free(pvs);
            pvs = NULL;
            return -8;
            }

        free(pvs);
        pvs = NULL;
        }

    return 0;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  cnctdrvSetDestination
 *
 * DESCRIPTION:
 *	Sets the destination (in this case phone number).
 *
 * ARGUMENTS:
 *	hhDriver    - private driver handle
 *	ach			- string to set
 *	cb			- number of chars in ach
 *
 * RETURNS:
 *  0=OK, <0=error
 *
 */
int WINAPI cnctdrvSetDestination(const HHDRIVER hhDriver, TCHAR * const ach,
								 const size_t cb)
	{
	int len;

	if (hhDriver == 0 || ach == 0 || cb == 0)
		{
		assert(FALSE);
		return -1;
		}

	len = (int) min(cb, sizeof(hhDriver->achDest));
	strncpy(hhDriver->achDest, ach, len);
	hhDriver->achDest[len-1];

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DoNewModemWizard
 *
 * DESCRIPTION:
 *	Calls up the new modem wizard
 *
 * ARGUMENTS:
 *	hhDriver    - private driver handle
 *  iTimeout    - The timeout length
 *
 * RETURNS:
 *	0=OK,else error
 *
 */
static int DoNewModemWizard(HWND hWnd, int iTimeout)
	{
	PROCESS_INFORMATION stPI;
	STARTUPINFO 		stSI;
    TCHAR               ach[256];
    int                 returnVal = 0;

	// Initialize the PROCESS_INFORMATION structure for CreateProcess
	//
	memset( &stPI, 0, sizeof( PROCESS_INFORMATION ) );

	// Initialize the STARTUPINFO structure for CreateProcess
	//
	memset(&stSI, 0, sizeof(stSI));
	stSI.cb = sizeof(stSI);
	stSI.dwFlags = STARTF_USESHOWWINDOW;
	stSI.wShowWindow = SW_SHOW;

    // See if we should run the New modem wizard.
    //
    if(mscAskWizardQuestionAgain())
        {
		LoadString(glblQueryDllHinst(), IDS_ER_CNCT_BADLINE, ach, sizeof(ach) / sizeof(TCHAR));

		if (TimedMessageBox(hWnd, ach, NULL, MB_YESNO | MB_ICONEXCLAMATION, iTimeout) == IDYES)
			{
            TCHAR  systemDir[MAX_PATH];
            TCHAR  executeString[MAX_PATH * 3];
            TCHAR *pParams = TEXT("\\control.exe\" modem.cpl,,Add");
            UINT   numChars = 0;

            TCHAR_Fill(systemDir, TEXT('\0'), MAX_PATH);
            TCHAR_Fill(executeString, TEXT('\0'), MAX_PATH * 3);
            numChars = GetSystemDirectory(systemDir, MAX_PATH);
            
            if (numChars == 0 || StrCharGetStrLength(systemDir) == 0)
                {
                returnVal = -3;
                }
            else
                {
                if (StrCharGetStrLength(systemDir) + StrCharGetStrLength(pParams) + sizeof(TEXT("\"")) / sizeof(TCHAR) >
                    sizeof(executeString) / sizeof(TCHAR))
                    {
                    returnVal = -2;
                    }
                else
                    {
                    StrCharCopyN(executeString, TEXT("\""), sizeof(executeString) / sizeof(TCHAR));
                    StrCharCat(executeString, systemDir);
                    StrCharCat(executeString, pParams);

                    //
	                // Launch the new modem wizard with the command below.
	                //

	                //if (CreateProcess(0, "rundll sysdm.cpl,InstallDevice_Rundll modem,,",
	                //		  0, 0, 0, 0, 0, 0, &stSI, &stPI) == FALSE)
	                //if (CreateProcess(0, "control.exe modem.cpl,,Add",
                    //    0, 0, 0, 0, 0, 0, &stSI, &stPI) == FALSE)
                    if (CreateProcess(NULL, executeString,
 			            NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS,
                        NULL, systemDir, &stSI, &stPI) == FALSE)
		                {
		                #if defined(_DEBUG)
			                {
			                char ach[100];
			                DWORD dw = GetLastError();

			                wsprintf(ach,"CreateProcess (%s, %d) : %x",__FILE__,__LINE__,dw);
			                MessageBox(NULL, ach, "Debug", MB_OK);
			                }
		                #endif

		                returnVal = -1;
		                }
		            else
			            {
			            mscUpdateRegistryValue();

						//
						// Close the handles.
						//
						CloseHandle(stPI.hProcess);
						CloseHandle(stPI.hThread);
			            }
                    }
			    }
            }
        }
	return returnVal;
	}

int cncttapiGetLineConfig( const DWORD dwLineId, VOID ** ppvs )
    {
    DWORD dwSize;
    LPVARSTRING pvs = (LPVARSTRING)*ppvs;

    if (pvs != NULL)
        {
        assert(FALSE);
        free(pvs);
        pvs = NULL;
        }

    if ((pvs = malloc(sizeof(VARSTRING))) == 0)
    	{
    	assert(FALSE);
    	return -3;
    	}

	memset(pvs, 0, sizeof(VARSTRING));
    pvs->dwTotalSize = sizeof(VARSTRING);
	pvs->dwNeededSize = 0;

    if (lineGetDevConfig(dwLineId, pvs, DEVCLASS) != 0)
    	{
    	assert(FALSE);
    	free(pvs);
  		pvs = NULL;
    	return -4;
    	}

    if (pvs->dwNeededSize > pvs->dwTotalSize)
    	{
    	dwSize = pvs->dwNeededSize;
    	free(pvs);
  		pvs = NULL;

    	if ((pvs = malloc(dwSize)) == 0)
    		{
    		assert(FALSE);
    		return -5;
    		}

		memset(pvs, 0, dwSize);
    	pvs->dwTotalSize = dwSize;

    	if (lineGetDevConfig(dwLineId, pvs, DEVCLASS) != 0)
    		{
    		assert(FALSE);
    		free(pvs);
  			pvs = NULL;
    		return -6;
    		}
    	}

    *ppvs = (VOID *)pvs;
    return 0;
    }

int cncttapiSetLineConfig(const DWORD dwLineId, const HCOM hCom)
    {
    int         retValue = 0;
    LPVARSTRING pvs = NULL;
    PUMDEVCFG   pDevCfg = NULL;
    int         iBaudRate;
    int         iDataBits;
    int         iParity;
    int         iStopBits;
    LONG        lLineReturn;

    retValue = cncttapiGetLineConfig( dwLineId, (VOID **) &pvs);

    if (retValue != 0)
        {
        retValue = retValue;
        }

    if (retValue == 0 && pvs == NULL)
        {
        retValue = -7;
        }

    // The structure of the DevConfig block is as follows
    //
    //	VARSTRING
    //	UMDEVCFGHDR
    //	COMMCONFIG
    //	MODEMSETTINGS
    //
    // The UMDEVCFG structure used below is defined in the
    // UNIMODEM.H provided in the platform SDK (in the nih
    // directory for HTPE). REV: 12/01/2000 
    //
    if (retValue == 0)
        {
        pDevCfg = (UMDEVCFG *)((BYTE *)pvs + pvs->dwStringOffset);
        if (pDevCfg == NULL)
            {
            retValue = -8;
            }
        }

    if (retValue == 0 && (hCom == NULL || ComValidHandle(hCom) == FALSE))
        {
        retValue = -9;
        }

    //
    // commconfig struct has a DCB structure we dereference for the
    // com settings.
    //

    //
    // The baud rate should be stored with the COM settings for
    // TAPI devices, but we may want to use the current TAPI device
    // baud rate instead.  We should find a better solution for this.
    // TODO:REV 05/01/2001
    //
    if (retValue == 0 && ComGetBaud(hCom, &iBaudRate) != COM_OK)
        {
		#if defined(TODO)
        retValue = -10;
		#endif // TODO
        }
	else if (retValue == 0)
		{
		ComSetBaud(hCom, pDevCfg->commconfig.dcb.BaudRate);
		}

    if (retValue == 0 && ComGetDataBits(hCom, &iDataBits) != COM_OK)
        {
        retValue = -11;
        }

    if (retValue == 0 && ComGetParity(hCom, &iParity) != COM_OK)
        {
        retValue = -12;
        }

    if (retValue == 0 && ComGetStopBits(hCom, &iStopBits) != COM_OK)
        {
        retValue = -13;
        }

    if (retValue != 0)
        {
        free(pvs);
        pvs = NULL;
        return retValue;
        }

    #if defined(TODO)
    pDevCfg->commconfig.dcb.BaudRate = iBaudRate;
    #endif // TODO
	pDevCfg->commconfig.dcb.ByteSize = (BYTE)iDataBits;
	pDevCfg->commconfig.dcb.Parity = (BYTE)iParity;
	pDevCfg->commconfig.dcb.StopBits = (BYTE)iStopBits;

    if (iDataBits != 8 && iParity != NOPARITY && iStopBits != ONESTOPBIT)
        {
        ComSetAutoDetect(hCom, FALSE);
        }

    //
    // Actually set the TAPI device's COM settings.
    //
    lLineReturn = lineSetDevConfig(dwLineId, pDevCfg, pvs->dwStringSize, DEVCLASS);

    free(pvs);
    pvs = NULL;

    if (lLineReturn < 0)
        {
		assert(FALSE);
		return lLineReturn;
        }

    retValue = cncttapiGetLineConfig( dwLineId, (VOID **) &pvs);

    if (retValue != 0)
        {
        retValue = retValue - 100;
        }

    //
    // Make sure the port settings get updated.
    //
    retValue = ComConfigurePort(hCom);

    //
    // Make sure the status bar contains the correct settings.
    //
    PostMessage(sessQueryHwndStatusbar(hCom->hSession),
                SBR_NTFY_REFRESH, (WPARAM)SBR_COM_PART_NO, 0);

    if (pvs == NULL)
        {
        return -14;
        }

    // The structure of the DevConfig block is as follows
    //
    //	VARSTRING
    //	UMDEVCFGHDR
    //	COMMCONFIG
    //	MODEMSETTINGS
    //
    // The UMDEVCFG structure used below is defined in the
    // UNIMODEM.H provided in the platform SDK (in the nih
    // directory for HTPE). REV: 12/01/2000 
    //
    if (retValue == 0)
        {
        pDevCfg = (UMDEVCFG *)((BYTE *)pvs + pvs->dwStringOffset);

        if (pDevCfg == NULL)
            {
            retValue = -15;
            }
        }

    if (retValue == 0 && (
        #if defined(TODO)
        pDevCfg->commconfig.dcb.BaudRate != iBaudRate ||
        #endif // TODO
	    pDevCfg->commconfig.dcb.ByteSize != iDataBits ||
	    pDevCfg->commconfig.dcb.Parity != iParity ||
	    pDevCfg->commconfig.dcb.StopBits != iStopBits))
        {

        //
        // If this is NT and we are currently connected with
        // a modem, we must disconnect and attempt to redial
        // so that the COM settings are set properly for the
        // modem since this can not be done once a connection
        // has been made. REV: 06/05/2001
        //
        if (IsNT())
            {
            HCNCT hCnct = sessQueryCnctHdl(hCom->hSession);
            if (hCnct)
                {
                int iStatus = cnctQueryStatus(hCnct);

                if (iStatus != CNCT_STATUS_FALSE &&
                    iStatus != CNCT_BAD_HANDLE &&
                    cnctIsModemConnection(hCnct) == 1)
                    {
                    int nDisconnect = IDYES;

                    //
                    // Don't prompt if this is NT_EDITION, just do the
                    // disconnection quietly and attempt to reconnect.
                    //
                    #if !defined(NT_EDITION)
                    TCHAR ach[256];

                    TCHAR_Fill(ach, TEXT('\0'), sizeof(ach) / sizeof(TCHAR));

                    //
                    // Prompt to disconnect current connection due to TAPI
                    // device needing to be reset. REV: 05/31/2001
                    //
                    LoadString(glblQueryDllHinst(), IDS_ER_TAPI_NEEDS_RESET, ach, sizeof(ach) / sizeof(TCHAR));

                    nDisconnect =
                        TimedMessageBox(sessQueryHwnd(hCom->hSession), ach, NULL,
                                        MB_YESNO | MB_ICONEXCLAMATION | MB_TASKMODAL,
                                        sessQueryTimeout(hCom->hSession));
                    #endif //NT_EDITION

                    if (nDisconnect == IDYES || nDisconnect == -1)
                        {
                        retValue = -16;
                        }
                    }
                } // hCnct
            } // IsNT()
        }

    free(pvs);
    pvs = NULL;

    return retValue;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\cncttapi\cncttapi.hh ===
/*	File: D:\WACKER\cncttapi\cncttapi.hh (Created: 10-Feb-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 13 $
 *	$Date: 5/15/02 4:24p $
 */

 #include <unimodem.h>

typedef struct stCnctDrvPrivate *HHDRIVER;

/* --- Macros --- */

#define TAPI_VER (MAKELONG(4,1))

// Required in lineGetDevConfig calls
//

#if !defined(szUMDEVCLASS_COMM_DATAMODEM)
//
// The following define is from unimodem.h
//
#define szUMDEVCLASS_COMM_DATAMODEM          TEXT("comm/datamodem")
#endif // !defined(szUMDEVCLASS_COMM_DATAMODEM)

#define DEVCLASS		szUMDEVCLASS_COMM_DATAMODEM
#define REDIAL_MAX      40

// Essentially, I picked what I hope is a permanent line ID a TAPI
// service provider would never use.  My odds are pretty good since
// UNIMODEM numbers them from 1. - mrw
//
#define DIRECT_COM1		    0x5A2175D1
#define DIRECT_COM2		    (DIRECT_COM1+1)
#define DIRECT_COM3		    (DIRECT_COM1+2)
#define DIRECT_COM4		    (DIRECT_COM1+3)
#define DIRECT_COMWINSOCK	(DIRECT_COM1+4)
#define DIRECT_COM_DEVICE   (DIRECT_COM1 - 1)

#if defined(INCL_WINSOCK)
#define MAX_IP_ADDR_LEN		128
#endif

// Trap is similar to assert except it displays the error return code.
//
#if defined(NDEBUG)
#define TRAP(x) x
#else
#define TRAP(x) tapiTrap(x, __FILE__, __LINE__)
#endif

// Connection driver handle

struct stCnctDrvPrivate
	{
	HCNCT	 hCnct; 		// public connection handle passed to create func
	HSESSION hSession;		// public session handle passed to create func

	CRITICAL_SECTION cs;	// critical section semaphore

	int 	 iStatus;		// connection status

	HLINEAPP hLineApp;		// returned for lineInitialize(), main TAPI handle
	HLINE	 hLine; 		// handle to line we're using from lineOpen()
	HCALL	 hCall; 		// handle returned by lineMakeCall()
	LONG	 lMakeCallId;	// ID returned by lineMakeCall() used in callback
	DWORD	 dwLineCnt; 	// number of available lines from lineInitialize
	DWORD	 dwLine;		// current line we're using
	DWORD	 dwAPIVersion;	// current api version
	DWORD	 dwCountryID;	// internal TAPI ID for selected country
	DWORD	 dwCountryCode; // set in TranslateAddress()
	DWORD	 dwPermanentLineId; // identifies the modem as saved

	BOOL	 fMatchedPermanentLineID,
			 fHotPhone; 	// TAPI for is it Direct Connect

	TCHAR	 achDest[(TAPIMAXDESTADDRESSSIZE/2)+1],	// local portion of phone num.
			 achAreaCode[10],
			 achDefaultAreaCode[10],// As reported from TAPI
			 achDialableDest[TAPIMAXDESTADDRESSSIZE+1],
			 achDisplayableDest[TAPIMAXDESTADDRESSSIZE+1],
			 achCanonicalDest[TAPIMAXDESTADDRESSSIZE+1];

	TCHAR	 achLineName[100];	// used in dialing dialog
    TCHAR    achComDeviceName[256]; // used with enumerated ports.

	HWND	 hwndCnctDlg;		// connection dialog handle
	HWND	 hwndTAPIWindow;	// TAPI reinit
	HWND	 hwndPCMCIA;		// valid only when PCMCIA dialog showing.

	LINECALLPARAMS 	stCallPar;	// Call params used for lineMakeCall()
	
	BOOL	 fUseCCAC;			// Use country code & area code flag.
	unsigned int uDiscnctFlags;	// Used for asychronous disconnects.

    int      iRedialCnt;        // Counter for redials.
    int      fRedialOnBusy;     // TRUE, we redial
    int      iRedialSecsRemaining; // seconds remaining to redial

#if defined(INCL_WINSOCK)
	int		 iPort;

	TCHAR	 achDestAddr[MAX_IP_ADDR_LEN];
#endif

#ifdef INCL_CALL_ANSWERING
	int  fAnswering;		// Are we answering?
	int  fRestoreSettings;	// Do we need to restore our ASCII settings?
	int	 nSendCRLF;			// Temporary storage for ASCII setting.
	int  nLocalEcho;		// Temporary storage for ASCII setting.
	int  nAddLF;			// Temporary storage for ASCII setting.
	int  nEchoplex;			// Temporary storage for ASCII setting.
	void *pvUnregister;		// Un-registration data for CLoop callback.
#endif

	BOOL fCarrierDetect;	// Are we detecting loss of carrier?
	};

/* --- Line id struct used to store info in combo boxes	--- */

struct _stLineIds
	{
	DWORD dwLineId;
	DWORD dwPermanentLineId;
	};

typedef	struct _stLineIds * PSTLINEIDS;

/* --- Function Prototypes --- */

void cnctdrvLock(const HHDRIVER hhDriver);
void cnctdrvUnlock(const HHDRIVER hhDriver);
INT_PTR CALLBACK ConfirmDlg(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar);
int CplConfigDlg(const HWND hwnd, const int ordinal);
int EnumerateCountryCodes(const HHDRIVER hhDriver, const HWND hwndCB);
int EnumerateAreaCodes(const HHDRIVER hhDriver, const HWND hwndCB);
int EnumerateLines(const HHDRIVER hhDriver, const HWND hwndCB);
int EnumerateLinesNT(const HHDRIVER hhDriver, const HWND hwndCB);
long TranslateAddress(const HHDRIVER hhDriver);
INT_PTR CALLBACK DialingDlg(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar);
void DialingMessage(const HHDRIVER hhDriver, const int resID);
void CALLBACK lineCallbackFunc(DWORD hDevice, DWORD dwMsg, DWORD_PTR dwCallback,
                               DWORD_PTR dwParm1, DWORD_PTR dwParm2, DWORD_PTR dwParm3);

void PostDisconnect(const HHDRIVER hhDriver, const unsigned int uFlags);
int Handoff(const HHDRIVER hhDriver);
void SetStatus(const HHDRIVER hhDriver, const int iStatus);
int DoLineGetCountry(const DWORD dwCountryID, const DWORD dwAPIVersion,
    LPLINECOUNTRYLIST *ppcl);

int EnumerateTapiLocations(const HHDRIVER hhDriver, const HWND hwndCB,
								  const HWND hwndTB);

int CheckHotPhone(const HHDRIVER hhDriver, const DWORD dwLine, int *pfHotPhone);
DWORD tapiTrap(const DWORD dw, const TCHAR *file, const int line);
void EnableDialNow(const HWND hwndDlg, const int fEnable);
#if defined(DEADWOOD)
int fCountryUsesAreaCode(const DWORD dwCountryId, const DWORD dwAPIVersion);
#endif // defined(DEADWOOD)
INT_PTR CALLBACK PCMCIADlg(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar);
int fIsStringEmpty(LPTSTR ach);
void EnableDial(const HWND hwndDlg, const BOOL fEnable);
int cncttapiGetCOMSettings( const DWORD dwLineId, LPTSTR pachStr, const size_t cb );
int cncttapiGetLineConfig( const DWORD dwLineId, VOID** ppvs );
int cncttapiSetLineConfig( const DWORD dwLineId, const HCOM hCom );

#if defined(INCL_WINSOCK)
BOOL CALLBACK cnctwsNewPhoneDlg(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar);
#endif

/* --- Driver entry points --- */

HDRIVER WINAPI cnctdrvCreate(const HCNCT hCnct, const HSESSION hSession);
int WINAPI cnctdrvDestroy(const HHDRIVER hhDriver);
int WINAPI cnctdrvInit(const HHDRIVER hhDriver);
int WINAPI cnctdrvLoad(const HHDRIVER hhDriver);
int WINAPI cnctdrvSave(const HHDRIVER hhDriver);

int WINAPI cnctdrvSetDestination(const HHDRIVER hhDriver, TCHAR * const ach,
								 const size_t cb);

int WINAPI cnctdrvQueryStatus(const HHDRIVER hhDriver);
int WINAPI cnctdrvConnect(const HHDRIVER hhDriver, const unsigned int uFlags);
int WINAPI cnctdrvDisconnect(const HHDRIVER hhDriver, const unsigned int uFlags);
int WINAPI cnctdrvComEvent(const HHDRIVER hhDriver, const enum COM_EVENTS event);

int cnctdrvGetComSettingsString(const HHDRIVER hhDriver, LPTSTR pachStr,
								const size_t cb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\cncttapi\pcmcia.c ===
/*	File: D:\WACKER\cncttapi\pcmcia.c (Created: 28-Feb-1995)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 2/25/02 1:17p $
 */

#define TAPI_CURRENT_VERSION 0x00010004     // cab:11/14/96 - required!

#include <tapi.h>
#pragma hdrstop

#include <prsht.h>
#include <time.h>

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\misc.h>
#include <tdll\cnct.h>

#include "cncttapi.h"
#include "cncttapi.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ConfirmDlg
 *
 * DESCRIPTION:
 *	PCMCIADlg pops up when a hotplug modem is specified but
 *	not inservice.
 *
 * AUTHOR: Mike Ward, 28-Feb-1995
 */
INT_PTR CALLBACK PCMCIADlg(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar)
	{
	HHDRIVER hhDriver;

	switch (uMsg)
		{
	case WM_INITDIALOG:
		SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)lPar);
		hhDriver = (HHDRIVER)lPar;
		hhDriver->hwndPCMCIA = hwnd;
		mscCenterWindowOnWindow(hwnd, sessQueryHwnd(hhDriver->hSession));
		break;

	case WM_COMMAND:
		switch (LOWORD(wPar))
			{
		case IDOK:
			// There is no OK button.  Instead, when the user plugs the
			// modem in, the tapi callback function will send a message.
			//
			EndDialog(hwnd, TRUE);
			break;

		case IDCANCEL:
			EndDialog(hwnd, FALSE);
			break;

		default:
			break;
			}
		break;

	case WM_DESTROY:
		hhDriver = (HHDRIVER)GetWindowLongPtr(hwnd, DWLP_USER);

		if (hhDriver)
			hhDriver->hwndPCMCIA = 0;

		break;

	default:
		return FALSE;
		}

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\cncttapi\dialdlg.c ===
/*	File: D:\WACKER\cncttapi\dialdlg.c (Created: 23-Mar-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 2/25/02 1:17p $
 */

#define TAPI_CURRENT_VERSION 0x00010004     // cab:11/14/96 - required!

#include <tapi.h>
#pragma hdrstop

#include <time.h>

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\tdll.h>
#include <tdll\misc.h>
#include <tdll\assert.h>
#include <tdll\cnct.h>
#include <tdll\globals.h>
#include <term\res.h>

#include "cncttapi.hh"
#include "cncttapi.h"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DialingDlg
 *
 * DESCRIPTION:
 *	Dialing dialog.
 *
 * ARGUMENTS:
 *	Standard dialog arguments
 *
 * RETURNS:
 *	BOOL
 *
 */
INT_PTR CALLBACK DialingDlg(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar)
	{
	#define TB_SESSION	  103
	#define TB_TELEPHONE  104
	#define TB_MODEM	  105
	#define TB_DIALICON   101
	#define TB_STATUS	  110

	HHDRIVER hhDriver;
	TCHAR ach[256];
    TCHAR achFmt[100];

	switch (uMsg)
		{
	case WM_INITDIALOG:
		SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)lPar);
		hhDriver = (HHDRIVER)lPar;
		mscCenterWindowOnWindow(hwnd, sessQueryHwnd(hhDriver->hSession));

		SendDlgItemMessage(hwnd, TB_DIALICON, STM_SETICON,
				(WPARAM)sessQueryIcon(hhDriver->hSession), 0);

		sessQueryName(hhDriver->hSession, ach, sizeof(ach));
		SetDlgItemText(hwnd, TB_SESSION, ach);

		SetDlgItemText(hwnd, TB_TELEPHONE, hhDriver->achDisplayableDest);
		SetDlgItemText(hwnd, TB_MODEM, hhDriver->achLineName);
		break;

	case WM_SHOWWINDOW:
		if (wPar == TRUE)
			EnableDialNow(hwnd, FALSE);
		break;

	case WM_USER+0x100: // Got connection.  Close the dialog.
		EndModelessDialog(hwnd);
		break;

	case WM_USER+0x101: // Dialing message.  Display requested string in status.
		hhDriver = (HHDRIVER)GetWindowLongPtr(hwnd, DWLP_USER);

		if (LoadString(glblQueryDllHinst(), (UINT)wPar, ach,
				sizeof(ach) / sizeof(TCHAR)) == 0)
			{
			assert(FALSE);
            break;
			}

        DbgOutStr("%s\r\n", ach, 0, 0, 0, 0);
		SetDlgItemText(hhDriver->hwndCnctDlg, TB_STATUS, ach);

		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDOK: // Dial Now
			hhDriver = (HHDRIVER)GetWindowLongPtr(hwnd, DWLP_USER);
            hhDriver->iRedialCnt = 0;
            KillTimer(hwnd, 1);

			cnctdrvDisconnect(hhDriver,
				CNCT_DIALNOW | CNCT_NOCONFIRM | DISCNCT_NOBEEP);

			break;

		case IDCANCEL:
			hhDriver = (HHDRIVER)GetWindowLongPtr(hwnd, DWLP_USER);
			cnctdrvDisconnect(hhDriver, DISCNCT_NOBEEP);
			EndModelessDialog(hwnd);
			hhDriver->hwndCnctDlg = 0;	// important, so we create another
            KillTimer(hwnd, 1);
			break;

		default:
			return FALSE;
			}
		break;

    case WM_TIMER:
		hhDriver = (HHDRIVER)GetWindowLongPtr(hwnd, DWLP_USER);

        if (--hhDriver->iRedialSecsRemaining > 0)
            {
    		LoadString(glblQueryDllHinst(), IDS_DIAL_REDIAL_IN, achFmt,
	    	    sizeof(achFmt) / sizeof(TCHAR));

            wsprintf(ach, achFmt, hhDriver->iRedialSecsRemaining);
          	SetDlgItemText(hhDriver->hwndCnctDlg, TB_STATUS, ach);
            }

        else
            {
		    PostMessage(sessQueryHwnd(hhDriver->hSession), WM_CNCT_DIALNOW,
			    hhDriver->uDiscnctFlags, 0);
            }

        break;
	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DialingMessage
 *
 * DESCRIPTION:
 *	Gets the given string ID from term's resource file and displays it
 *	in the dialing dialog.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *	resID		- ID of resource.
 *
 * RETURNS:
 *	void
 *
 */
void DialingMessage(const HHDRIVER hhDriver, const int resID)
	{
	if (!IsWindow(hhDriver->hwndCnctDlg))
		return;

	PostMessage(hhDriver->hwndCnctDlg, WM_USER+0x101, (WPARAM)resID, 0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EnableDialNow
 *
 * DESCRIPTION:
 *	Enables/Disables dial now button.
 *
 * ARGUMENTS:
 *	hwndDlg - dial dialog window handle
 *	fEnable - TRUE/FALSE
 *
 * RETURNS:
 *	void
 *
 */
void EnableDialNow(const HWND hwndDlg, const int fEnable)
	{
	if (IsWindow(hwndDlg))
		{
		EnableWindow(GetDlgItem(hwndDlg, IDOK), fEnable);

		if (fEnable == FALSE)
			SetFocus(GetDlgItem(hwndDlg,IDCANCEL));
		else
			SetFocus(GetDlgItem(hwndDlg, IDOK));
		}

	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\cncttapi\cnfrmdlg.c ===
/*      File: D:\WACKER\cncttapi\cnfrmdlg.c (Created: 23-Mar-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 16 $
 *	$Date: 7/08/02 6:30p $
 */

#define TAPI_CURRENT_VERSION 0x00010004     // cab:11/14/96 - required!

#include <tapi.h>
#pragma hdrstop

#include <prsht.h>
#include <time.h>

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\tdll.h>
#include <tdll\misc.h>
#include <tdll\mc.h>
#include <tdll\assert.h>
#include <tdll\errorbox.h>
#include <tdll\cnct.h>
#include <tdll\hlptable.h>
#include <tdll\globals.h>
#include <tdll\property.h>
#include <term\res.h>
#include <tdll\statusbr.h>
#include <tdll\htchar.h>

#include "cncttapi.hh"
#include "cncttapi.h"

static void InitConfirmDlg(const HWND hwnd, const HHDRIVER hhDriver);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ConfirmDlg
 *
 * DESCRIPTION:
 *	Displays dialog confirming user's choices for the requested connect.
 *	Assumes that EnumerateLines() and TranslateAddress() have been called.
 *
 * ARGUMENTS:
 *	Standard dialog
 *
 * RETURNS:
 *	Standard dialog
 *
 */
INT_PTR CALLBACK ConfirmDlg(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar)
	{
	#define IDC_TF_LOCATION 107
	#define CB_LOCATION 	108
	#define PB_EDIT_NEW 	109
    #define IDI_ICON        102
    #define IDC_TF_PHONE    104
	#define TB_PHONE		105
	#define TB_CARD 		110
	#define IDC_TF_CARD     111
	#define TB_SESSNAME 	103
	#define PB_MODIFY		106
	#define PB_DIAL			117

    TCHAR   ach[128];
	int i;
	long lRet;
	LRESULT lr;
	HHDRIVER hhDriver;
	static	DWORD aHlpTable[] = {	CB_LOCATION,	 IDH_TERM_DIAL_LOCATION,
									IDC_TF_LOCATION, IDH_TERM_DIAL_LOCATION,
									IDC_TF_PHONE,	 IDH_TERM_DIAL_PHONENUMBER,
									TB_PHONE,		 IDH_TERM_DIAL_PHONENUMBER,
									TB_CARD,		 IDH_TERM_DIAL_CALLING_CARD,
									IDC_TF_CARD,	 IDH_TERM_DIAL_CALLING_CARD,
									PB_MODIFY,		 IDH_TERM_DIAL_MODIFY,
									PB_EDIT_NEW,	 IDH_TERM_DIAL_EDITNEW,
									PB_DIAL,		 IDH_TERM_DIAL_DIAL,
                                    IDCANCEL,        IDH_CANCEL,
									0,0};
	switch (uMsg)
		{
	case WM_INITDIALOG:
		SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)lPar);
		hhDriver = (HHDRIVER)lPar;
		mscCenterWindowOnWindow(hwnd, sessQueryHwnd(hhDriver->hSession));

		if ((lRet = TranslateAddress(hhDriver)) != 0)
			{
			if (lRet == LINEERR_INIFILECORRUPT)
				{
				PostMessage(hwnd, WM_COMMAND,
					MAKEWPARAM(PB_EDIT_NEW, BN_CLICKED), (LPARAM)hwnd);
				}
			}

		InitConfirmDlg(hwnd, hhDriver);

		EnumerateTapiLocations(hhDriver, GetDlgItem(hwnd, CB_LOCATION),
			GetDlgItem(hwnd, TB_CARD));

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (LOWORD(wPar))
			{
		case PB_DIAL:
            GetDlgItemText(hwnd, TB_PHONE, ach, sizeof(ach)/sizeof(TCHAR));

			if (strcmp(ach, TEXT("")) != 0)
				{
				hhDriver = (HHDRIVER)GetWindowLongPtr(hwnd, DWLP_USER);

				if (hhDriver->achDialableDest[0] != TEXT('\0') &&
				    hhDriver->achCanonicalDest[0] != TEXT('\0') )
					{
					EndDialog(hwnd, TRUE);
					}
				else
					{
    				LoadString(glblQueryDllHinst(), IDS_ER_CNCT_BADADDRESS,
							   ach, sizeof(ach)/sizeof(TCHAR));
					MessageBox(hwnd, ach, NULL, MB_OK);
					}
				}
            else
                {
    			LoadString(glblQueryDllHinst(), 40808, ach,
					       sizeof(ach)/sizeof(TCHAR));
                MessageBox(hwnd, ach, NULL, MB_OK);
                }

			break;

		case IDCANCEL:
			EndDialog(hwnd, FALSE);
			break;

		case PB_EDIT_NEW:
			hhDriver = (HHDRIVER)GetWindowLongPtr(hwnd, DWLP_USER);

			lineTranslateDialog(hhDriver->hLineApp, hhDriver->dwLine,
				TAPI_VER, hwnd, hhDriver->achCanonicalDest);

			EnumerateTapiLocations(hhDriver, GetDlgItem(hwnd, CB_LOCATION),
				GetDlgItem(hwnd, TB_CARD));

			if (TranslateAddress(hhDriver) == 0)
				InitConfirmDlg(hwnd, hhDriver);

			break;

		case PB_MODIFY:
			hhDriver = (HHDRIVER)GetWindowLongPtr(hwnd, DWLP_USER);

			EnableWindow(GetDlgItem(hwnd, PB_MODIFY), FALSE);
			DoInternalProperties(hhDriver->hSession,
				hwnd);

			// Fix for the statusbar was not updating when the
			// session's properties were modified when the
			// Dial Confirm dialog.  We now update the statusbar
			// when we return from DoInternalProperties() so that
			// the status bar is correct. REV: 11/08/2000
			//
			PostMessage(sessQueryHwndStatusbar(hhDriver->hSession), SBR_NTFY_REFRESH,
				(WPARAM)SBR_ALL_PARTS, 0);

			if ( IsNT() )
				{
				EnumerateLinesNT(hhDriver, 0);
				}
			else
				{
				EnumerateLines(hhDriver, 0);
				}

			lRet = TranslateAddress(hhDriver);
			if (lRet == 0 || lRet == LINEERR_INVALADDRESS)
				{
				InitConfirmDlg(hwnd, hhDriver);
				}

			EnableWindow(GetDlgItem(hwnd, PB_MODIFY), TRUE);
            SetFocus(GetDlgItem(hwnd, PB_MODIFY));
			break;

		case CB_LOCATION:
			if (HIWORD(wPar) == CBN_SELENDOK)
				{
				hhDriver = (HHDRIVER)GetWindowLongPtr(hwnd, DWLP_USER);

				if ((i = (int)SendDlgItemMessage(hwnd, CB_LOCATION, CB_GETCURSEL,
						0, 0)) != CB_ERR)
					{
					lr = SendDlgItemMessage(hwnd, CB_LOCATION, CB_GETITEMDATA,
						(WPARAM)i, 0);

					if (lr != CB_ERR)
						{
						if (lineSetCurrentLocation(hhDriver->hLineApp,
								(DWORD)lr) == 0)
							{
							// Leave the hwndCB (second paramater) zero.
							// Otherwise we go into and infinite message loop

							EnumerateTapiLocations(hhDriver, 0,
								GetDlgItem(hwnd, TB_CARD));

							if (TranslateAddress(hhDriver) == 0)
								InitConfirmDlg(hwnd, hhDriver);
							}
						}
					}
				}
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	InitConfirmDlg
 *
 * DESCRIPTION:
 *	Used to initialize some fields in the Confirmation dialog.
 *
 * ARGUMENTS:
 *	hwnd		- confirmation dialog
 *	hhDriver	- private driver handle.
 *
 * RETURNS:
 *	void
 *
 */
static void InitConfirmDlg(const HWND hwnd, const HHDRIVER hhDriver)
	{
	TCHAR ach[512];

	SendDlgItemMessage(hwnd, 101, STM_SETICON,
			(WPARAM)sessQueryIcon(hhDriver->hSession), 0);

	sessQueryName(hhDriver->hSession, ach, sizeof(ach));
	mscModifyToFit(GetDlgItem(hwnd, TB_SESSNAME), ach, SS_WORDELLIPSIS);
	SetDlgItemText(hwnd, TB_SESSNAME, ach);

	if (hhDriver->achDialableDest[0] == TEXT('\0'))
		{
		// We need to disable the Dial button here if there is not
		// a valid dialable destination.  REV: 10/23/2000
		//
		EnableDial(hwnd, FALSE);

		LoadString(glblQueryDllHinst(), IDS_ER_CNCT_BADADDRESS2, ach,
    		       sizeof(ach)/sizeof(TCHAR));
		SetDlgItemText(hwnd, TB_PHONE, ach);
		}
	else
		{
		EnableDial(hwnd, TRUE);
		SetDlgItemText(hwnd, TB_PHONE, hhDriver->achDisplayableDest);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	TranslateAddress
 *
 * DESCRIPTION:
 *	Translates the country code, area code, phone number into canonical
 *	format and then lets tapi translate it into the final dialable format.
 *	What is canonical format you say?
 *
 *	+Country Code SPACE [Area Code] SPACE Subscriber Number
 *
 *	Assumes EnumerateLines() has been called and a default device was
 *	selected.
 *
 * ARGUMENTS:
 *	hhDriver	- private connection driver handle
 *
 * RETURNS:
 *	0=OK
 *
 */
long TranslateAddress(const HHDRIVER hhDriver)
	{
	LONG lRet = 1;
	DWORD dwSize;
	TCHAR ach[100];
	LPLINECOUNTRYLIST pcl=NULL;
	LPLINECOUNTRYENTRY pce;
	LINETRANSLATEOUTPUT *pLnTransOutput;

	if (hhDriver == 0)
		{
		assert(FALSE);
		return -1;
		}

	if (CheckHotPhone(hhDriver, hhDriver->dwLine, &hhDriver->fHotPhone) != 0)
		return -1;	// error message displayed already.

	// Hot Phone is TAPI terminology for Direct Connects
	// We don't need to do address translation since we
	// not going to use it.

	if (hhDriver->fHotPhone)
		{
		hhDriver->achDialableDest[0] = TEXT('\0');
		hhDriver->achDisplayableDest[0] = TEXT('\0');
		return 0;
		}

	ach[0] = TEXT('\0'); // initialize the string!

	// If we not using the country code or area code, we don't want
	// or need TAPI's line translation.	 Just copy the destination
	// as the user entered it in the phonenumber field.
	//
	if (hhDriver->fUseCCAC)
		{
		/* --- Do lineGetCountry to get extension --- */

		if (DoLineGetCountry(hhDriver->dwCountryID, hhDriver->dwAPIVersion,
			&pcl) != 0)
			{
			assert(FALSE);
			return 2;
			}

		if ((pce = (LPLINECOUNTRYENTRY)
			((BYTE *)pcl + pcl->dwCountryListOffset)) == 0)
			{
			assert(FALSE);
			return 3;
			}

		/* --- Put country code in now --- */

		wsprintf(ach, "+%u ", pce->dwCountryCode);
		free(pcl);
		pcl = NULL;

		/* --- Area code ---*/

		#if defined(DEADWOOD) // mrw:4/20/95 (see phonedlg.c)
		if (hhDriver->achAreaCode[0])  &&
			fCountryUsesAreaCode(hhDriver->dwCountryID,
			hhDriver->dwAPIVersion))
		#endif // defined(DEADWOOD)
			if (!fIsStringEmpty(hhDriver->achAreaCode))
			{
			StrCharCat(ach, TEXT("("));
			StrCharCat(ach, hhDriver->achAreaCode);
			StrCharCat(ach, TEXT(") "));
			}
		}

	StrCharCat(ach, hhDriver->achDest);

	/* --- Allocate some space --- */

	pLnTransOutput = malloc(sizeof(LINETRANSLATEOUTPUT));

	if (pLnTransOutput == 0)
		{
		assert (FALSE);
		return 4;
		}

	pLnTransOutput->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

	/* --- Now that we've got the line address, translate it --- */

	if ((lRet = TRAP(lineTranslateAddress(hhDriver->hLineApp,
			hhDriver->dwLine, TAPI_VER, ach, 0,
				LINETRANSLATEOPTION_CANCELCALLWAITING,
					pLnTransOutput))) != 0)
		{
		free(pLnTransOutput);
		pLnTransOutput = NULL;
		return lRet;
		}

	if (pLnTransOutput->dwTotalSize < pLnTransOutput->dwNeededSize)
		{
		dwSize = pLnTransOutput->dwNeededSize;
		free(pLnTransOutput);
		pLnTransOutput = NULL;

		if ((pLnTransOutput = malloc(dwSize)) == 0)
			{
			assert(FALSE);
			return 5;
			}

		pLnTransOutput->dwTotalSize = dwSize;

		if ((lRet = TRAP(lineTranslateAddress(hhDriver->hLineApp,
				hhDriver->dwLine, TAPI_VER, ach, 0,
					LINETRANSLATEOPTION_CANCELCALLWAITING,
						pLnTransOutput))) != 0)
			{
			assert(FALSE);
			free(pLnTransOutput);
			pLnTransOutput = NULL;
			return lRet;
			}
		}

	/* --- At last, some strings to throw at the modem --- */

	StrCharCopyN(hhDriver->achDialableDest,
		(LPSTR)pLnTransOutput + pLnTransOutput->dwDialableStringOffset,
		TAPIMAXDESTADDRESSSIZE+1);

	StrCharCopyN(hhDriver->achDisplayableDest,
		(LPSTR)pLnTransOutput + pLnTransOutput->dwDisplayableStringOffset,
		TAPIMAXDESTADDRESSSIZE+1);

	hhDriver->dwCountryCode = pLnTransOutput->dwDestCountry;
	StrCharCopyN(hhDriver->achCanonicalDest, ach, TAPIMAXDESTADDRESSSIZE+1);

	free(pLnTransOutput);
	pLnTransOutput = NULL;
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CheckHotPhone
 *
 * DESCRIPTION:
 *	Checks to see if the selected line is a hot phone (ie. direct connect
 *	that requires no dialing).
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle.
 *	dwLine		- line to test
 *	pfHotPhone	- result
 *
 * RETURNS:
 *	0=OK
 *
 */
int CheckHotPhone(const HHDRIVER hhDriver, const DWORD dwLine, int *pfHotPhone)
	{
	DWORD	dw;
	LPLINEADDRESSCAPS pac = 0;

	if (hhDriver == 0)
		return -6;

	/* --- Get Address caps to determine line type --- */

	if ((pac = (LPLINEADDRESSCAPS)malloc(sizeof(*pac))) == 0)
		{
		return -1;
		}

	pac->dwTotalSize = sizeof(*pac);

	if (lineGetAddressCaps(hhDriver->hLineApp, dwLine, 0, TAPI_VER, 0,
			pac) != 0)
		{
		free(pac);
		pac = NULL;
		return -2;
		}

	if (pac->dwNeededSize > pac->dwTotalSize)
		{
		dw = pac->dwNeededSize;
		free(pac);
		pac = NULL;

		if ((pac = (LPLINEADDRESSCAPS)malloc(dw)) == 0)
			{
			return -3;
			}

		pac->dwTotalSize = dw;

		if (lineGetAddressCaps(hhDriver->hLineApp, dwLine,
				0, TAPI_VER, 0, pac) != 0)
			{
			free(pac);
			pac = NULL;
			return -4;
			}
		}

	*pfHotPhone = !(pac->dwAddrCapFlags & LINEADDRCAPFLAGS_DIALED);
	free(pac);
	pac = NULL;
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EnableDial
 *
 * DESCRIPTION:
 *	Enables/Disables Dial button.
 *
 * ARGUMENTS:
 *	hwndDlg - dial dialog window handle
 *	fEnable - TRUE/FALSE
 *
 * RETURNS:
 *	void
 *
 */
void EnableDial(const HWND hwndDlg, const BOOL fEnable)
	{
	if (IsWindow(hwndDlg))
		{
		EnableWindow(GetDlgItem(hwndDlg, PB_DIAL), fEnable);

		if (fEnable == FALSE)
			{
			SetFocus(GetDlgItem(hwndDlg,PB_MODIFY));
			}
		else
			{
			SetFocus(GetDlgItem(hwndDlg, PB_DIAL));
			}
		}

	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\cncttapi\phonedlg.c ===
/*      File: D:\WACKER\cncttapi\phonedlg.c (Created: 23-Mar-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 40 $
 *	$Date: 7/12/02 8:08a $
 */

#define TAPI_CURRENT_VERSION 0x00010004     // cab:11/14/96 - required!

#undef MODEM_NEGOTIATED_DCE_RATE

#include <tapi.h>
#include <unimodem.h>
#pragma hdrstop

#include <prsht.h>
#include <shlobj.h>
#include <time.h>
#include <limits.h>

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\tdll.h>
#include <tdll\misc.h>
#include <tdll\mc.h>
#include <tdll\com.h>
#include <tdll\assert.h>
#include <tdll\errorbox.h>
#include <tdll\cnct.h>
#include <tdll\hlptable.h>
#include <tdll\globals.h>
#include <tdll\property.h>
#include <tdll\htchar.h>
#include <term\res.h>
#if defined(INCL_MINITEL)
#include "emu\emu.h"
#endif // INCL_MINITEL

#include "cncttapi.hh"
#include "cncttapi.h"

STATIC_FUNC int     tapi_SAVE_NEWPHONENUM(HWND hwnd);
STATIC_FUNC LRESULT tapi_WM_NOTIFY(const HWND hwnd, const int nId);
STATIC_FUNC void    EnableCCAC(const HWND hwnd);
STATIC_FUNC void    ModemCheck(const HWND hwnd);
static int          ValidatePhoneDlg(const HWND hwnd);
static int          CheckWindow(const HWND hwnd, const int id, const UINT iErrMsg);
static int          VerifyAddress(const HWND hwnd);
#if defined(INCL_WINSOCK)
static int          VerifyHost(const HWND hwnd);
#endif //INCL_WINSOCK
STATIC_FUNC int     wsck_SAVE_NEWIPADDR(HWND hwnd);

// Local structure...
// Put in whatever else you might need to access later
//
typedef struct SDS
	{

	HSESSION 	hSession;
	HDRIVER		hDriver;

	// Store these so that we can restore the values if the user cancels
	// the property sheet.
	//
	TCHAR		acSessNameCopy[256];
	int			nIconID;
	HICON		hIcon;
	//HICON 	  hLittleIcon;

	} SDS, *pSDS;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	NewPhoneDlg
 *
 * DESCRIPTION:
 *	Displays dialog for getting new connection phone number and info.
 *
 *  NOTE:  Since this dialog proc is also called by the property sheet's
 *	phone number tab dialog it has to assume that the lPar contains the
 *	LPPROPSHEETPAGE.
 *
 * ARGUMENTS:
 *	Standard dialog
 *
 * RETURNS:
 *	Standard dialog
 *
 */
INT_PTR CALLBACK NewPhoneDlg(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar)
	{
	/*
	 * NOTE: these defines must match the templates in both places, here and
	 *       int term\dialogs.rc
	 */
	#define IDC_TF_CNTRYCODES	113
	#define IDC_TF_AREACODES    106
	#define IDC_TF_MODEMS       110
	#define IDC_TF_PHONENUM     108
	
	#define IDC_IC_ICON			101
	#define IDC_CB_CNTRYCODES   114
	#define IDC_EB_AREACODE		107
	#define IDC_EB_PHONENUM 	109
	#define IDC_CB_MODEMS		111
	
	#define IDC_TB_NAME 		103
	#define IDC_PB_EDITICON 	117
	#define IDC_PB_CONFIGURE	115
	#define IDC_XB_USECCAC		116
    #define IDC_XB_REDIAL       119
    #define IDC_XB_CDPROMPT     120

    #define IDC_EB_HOSTADDR     214
    #define IDC_TF_PHONEDETAILS 105
    #define IDC_TF_TCPIPDETAILS 205
    #define IDC_TF_HOSTADDR     213
    #define IDC_TF_PORTNUM      206
    #define IDC_EB_PORTNUM      207
    #define IDC_TF_ACPROMPT     118

	HWND	    hWindow;
	HHDRIVER    hhDriver;
	TCHAR	    ach[256];
	TCHAR 	    acNameCopy[256];
	int 	    i;
	PSTLINEIDS  pstLineIds = NULL;
    TCHAR       achSettings[100];

	static 	 DWORD aHlpTable[] = {IDC_CB_CNTRYCODES, IDH_TERM_NEWPHONE_COUNTRY,
								  IDC_TF_CNTRYCODES, IDH_TERM_NEWPHONE_COUNTRY,
								  IDC_EB_AREACODE,	 IDH_TERM_NEWPHONE_AREA,
								  IDC_TF_AREACODES,  IDH_TERM_NEWPHONE_AREA,
								  IDC_EB_PHONENUM,	 IDH_TERM_NEWPHONE_NUMBER,
								  IDC_TF_PHONENUM,   IDH_TERM_NEWPHONE_NUMBER,
								  IDC_PB_CONFIGURE,  IDH_TERM_NEWPHONE_CONFIGURE,
								  IDC_TF_MODEMS,     IDH_TERM_NEWPHONE_DEVICE,
								  IDC_CB_MODEMS,	 IDH_TERM_NEWPHONE_DEVICE,
								  IDC_PB_EDITICON,	 IDH_TERM_PHONEPROP_CHANGEICON,
                                  IDC_XB_USECCAC,    IDH_TERM_NEWPHONE_USECCAC,
                                  IDC_XB_REDIAL,     IDH_TERM_NEWPHONE_REDIAL,
								  IDC_EB_HOSTADDR,   IDH_TERM_NEWPHONE_HOSTADDRESS,
								  IDC_TF_HOSTADDR,   IDH_TERM_NEWPHONE_HOSTADDRESS,
								  IDC_EB_PORTNUM,    IDH_TERM_NEWPHONE_PORTNUMBER,
								  IDC_TF_PORTNUM,    IDH_TERM_NEWPHONE_PORTNUMBER,
								  IDC_XB_CDPROMPT,   IDH_TERM_NEWPHONE_CARRIERDETECT,
                                  IDCANCEL,                           IDH_CANCEL,
                                  IDOK,                               IDH_OK,
								  0,0,
								  };
	pSDS	 pS = NULL;

	switch (uMsg)
		{
	case WM_INITDIALOG:
		pS = (SDS *)malloc(sizeof(SDS));

		if (pS == (SDS *)0)
			{
			assert(FALSE);
			EndDialog(hwnd, FALSE);
			break;
			}

		// In the effort to keep the internal driver handle internal
		// we are passing the session handle from the property sheet tab
		// dialog.
		//
		pS->hSession = (HSESSION)(((LPPROPSHEETPAGE)lPar)->lParam);

		pS->hDriver = cnctQueryDriverHdl(sessQueryCnctHdl(pS->hSession));
		hhDriver = (HHDRIVER)(pS->hDriver);

		SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pS);

		// In order to center the property sheet we need to center the parent
		// of the hwnd on top of the session window.
		// If the parent of hwnd is the session window then this dialog has
		// not been called from the property sheet.
		//
		hWindow = GetParent(hwnd);

		if (hWindow != sessQueryHwnd(pS->hSession))
			{
			mscCenterWindowOnWindow(hWindow, sessQueryHwnd(pS->hSession));
			}
		else
			{
			mscCenterWindowOnWindow(hwnd, sessQueryHwnd(pS->hSession));
			}

		// Display the session icon...
		//
		pS->nIconID = sessQueryIconID(hhDriver->hSession);
		pS->hIcon = sessQueryIcon(hhDriver->hSession);
		//pS->hLittleIcon = sessQueryLittleIcon(hhDriver->hSession);

		SendDlgItemMessage(hwnd, IDC_IC_ICON, STM_SETICON,
			(WPARAM)pS->hIcon, 0);

		/* --- Need to initialize TAPI if not already done --- */

		if (hhDriver->hLineApp == 0)
			{
            extern const TCHAR *g_achApp;

			if (lineInitialize(&hhDriver->hLineApp, glblQueryDllHinst(),
					lineCallbackFunc, g_achApp, &hhDriver->dwLineCnt))
				{
				assert(FALSE);
				}
			}

		SendDlgItemMessage(hwnd, IDC_EB_PHONENUM, EM_SETLIMITTEXT,
			sizeof(hhDriver->achDest)-1, 0);

		SendDlgItemMessage(hwnd, IDC_EB_AREACODE, EM_SETLIMITTEXT,
			sizeof(hhDriver->achAreaCode)-1, 0);

		if (hhDriver->achDest[0])
			SetDlgItemText(hwnd, IDC_EB_PHONENUM, hhDriver->achDest);

#if defined(INCL_WINSOCK)
		SendDlgItemMessage(hwnd, IDC_EB_HOSTADDR, EM_SETLIMITTEXT,
			sizeof(hhDriver->achDestAddr)-1, 0);

		if (hhDriver->achDestAddr[0])
			SetDlgItemText(hwnd, IDC_EB_HOSTADDR, hhDriver->achDestAddr);

		SetDlgItemInt(hwnd, IDC_EB_PORTNUM, hhDriver->iPort, FALSE);
		//
		// Since the port must be numeric currently and the max size is
		// USHRT_MAX, we only need 5 characters here.
		//
		SendDlgItemMessage(hwnd, IDC_EB_PORTNUM, EM_LIMITTEXT, 5, 0);
#endif

		TCHAR_Fill(pS->acSessNameCopy, TEXT('\0'),
			sizeof(pS->acSessNameCopy) / sizeof(TCHAR));

		sessQueryName(hhDriver->hSession, pS->acSessNameCopy,
			sizeof(pS->acSessNameCopy));

		TCHAR_Fill(ach, TEXT('\0'), sizeof(ach) / sizeof(TCHAR));
		StrCharCopyN(ach, pS->acSessNameCopy, sizeof(ach) / sizeof(TCHAR));
		mscModifyToFit(GetDlgItem(hwnd, IDC_TB_NAME), ach, SS_WORDELLIPSIS);
		SetDlgItemText(hwnd, IDC_TB_NAME, ach);

		EnumerateCountryCodes(hhDriver, GetDlgItem(hwnd, IDC_CB_CNTRYCODES));
		EnumerateAreaCodes(hhDriver, GetDlgItem(hwnd, IDC_EB_AREACODE));

		hWindow = GetDlgItem(hwnd, IDC_CB_MODEMS);

		if (hWindow)
			{
			if ( IsNT() )
				{
				EnumerateLinesNT(hhDriver, hWindow);
				}
			else
				{	
				EnumerateLines(hhDriver, hWindow);
				}

			//mpt 6-23-98 disable the port list drop-down if we are connected
			EnableWindow(hWindow, cnctdrvQueryStatus(hhDriver) == CNCT_STATUS_FALSE);

			//
			// Set Extended UI functionality for the "Connect Using:"
			// dropdown list. REV: 2/1/2002
			//
			SendMessage(hWindow, CB_SETEXTENDEDUI, TRUE, 0);

			//
			// Set the width of the dropdown list for the "Connect Using:"
			// dropdown list. TODO:REV: 2/1/2002
			//
			}

		if (hhDriver->fUseCCAC) 	// Use country code and area code?
			{
			CheckDlgButton(hwnd, IDC_XB_USECCAC, TRUE);
			SetFocus(GetDlgItem(hwnd, IDC_EB_PHONENUM));
			}

        #if defined(INCL_REDIAL_ON_BUSY)
        if (hhDriver->fRedialOnBusy)
            {
			CheckDlgButton(hwnd, IDC_XB_REDIAL, TRUE);
			SetFocus(GetDlgItem(hwnd, IDC_EB_PHONENUM));
            }
        #endif

		if (hhDriver->fCarrierDetect)
			{
			CheckDlgButton(hwnd, IDC_XB_CDPROMPT, TRUE);
			}

		// Call after Use CCAC checkbox checked or unchecked.
		//
		EnableCCAC(hwnd);


		#if DEADWOOD //This is now done in ModemCheck(). REV: 11/9/2001
		/* --- Pick which control to give focus too --- */

		if (hhDriver->fUseCCAC)		// Use country code and area code?
			{
			
			if (SendDlgItemMessage(hwnd, IDC_CB_CNTRYCODES, CB_GETCURSEL,
					0, 0) == CB_ERR)
				{
				SetFocus(GetDlgItem(hwnd, IDC_CB_CNTRYCODES));
				}

			else if (GetDlgItemText(hwnd, IDC_EB_AREACODE, ach,
					sizeof(ach) / sizeof(TCHAR)) == 0)
				{
				SetFocus(GetDlgItem(hwnd, IDC_EB_AREACODE));
				}
			}
		#endif // DEADWOOD

		// If we have an old session and we have not matched our stored
		// permanent line id, then pop-up a message saying the TAPI
		// configuration has changed.
		//
		if (hhDriver->fMatchedPermanentLineID == FALSE &&
			hhDriver->dwPermanentLineId != (DWORD)-1 &&
			hhDriver->dwPermanentLineId != DIRECT_COMWINSOCK)
			{
			LoadString(glblQueryDllHinst(), IDS_ER_TAPI_CONFIG,
				ach, sizeof(ach) / sizeof(TCHAR));

			TimedMessageBox(hwnd, ach, NULL, MB_OK | MB_ICONHAND, 0);
			}
		else if (hhDriver->fMatchedPermanentLineID == FALSE)
			{
			LRESULT lr;
			#if defined(INCL_WINSOCK)
			if (hhDriver->dwPermanentLineId == DIRECT_COMWINSOCK)
				{
				if (LoadString(glblQueryDllHinst(), IDS_WINSOCK_SETTINGS_STR,
					ach, sizeof(ach) / sizeof(TCHAR)) == 0)
					{
					assert(FALSE);
					// The loading of the string has failed from the resource,
					// so add the non-localized string here (I don't believe
					// this string is ever translated). REV 8/13/99
					//
					StrCharCopyN(ach, TEXT("TCP/IP (Winsock)"),
						         sizeof(ach) / sizeof(TCHAR));
					}

				lr = SendMessage(GetDlgItem(hwnd, IDC_CB_MODEMS),
					             CB_FINDSTRING, (WPARAM) -1,
								 (LPARAM) ach);

				//
				// The existing permanent line id TCP/IP (WinSock),
				// so set the combobox to the TCP/IP (WinSock) item
				// or the first item in the list if TCP/IP (WinSock)
				// is not found.  REV: 11/1/2001
				//
				lr = SendMessage(GetDlgItem(hwnd, IDC_CB_MODEMS),
					             CB_SETCURSEL, (lr == CB_ERR) ? 0 : lr,
								 (LPARAM)0);
				}
			else
			#endif //defined(INCL_WINSOCK)
				{
				//
				// No existing permanent line id has been located, so set the
				// combobox to the first item in the list. REV: 10/31/2001
				//
				lr = SendMessage(GetDlgItem(hwnd, IDC_CB_MODEMS),
								 CB_SETCURSEL, (WPARAM)0, (LPARAM)0);
				}
			}

		ModemCheck(hwnd);

		return 0;

	case WM_CONTEXTMENU:
        doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_DESTROY:
		// OK, now we know that we are actually leaving the dialog for good, so
		// free the storage...
		//
		pS = (pSDS)GetWindowLongPtr(hwnd, DWLP_USER);
		if (pS)
			{
			free(pS);
			pS = NULL;
			}

		mscResetComboBox(GetDlgItem(hwnd, IDC_CB_MODEMS));
		break;

	case WM_NOTIFY:
		//
		// Property sheet messages are being channeled through here...
		//
		return tapi_WM_NOTIFY(hwnd, (int)((NMHDR *)lPar)->code);

	case WM_COMMAND:
		switch (LOWORD(wPar))
			{
		case IDC_CB_CNTRYCODES:
			if (HIWORD(wPar) == CBN_SELENDOK)
				{
				EnableCCAC(hwnd);
				}

			break;

		case IDC_CB_MODEMS:
			{
			INT message = HIWORD(wPar);

			if (message == CBN_SELENDOK ||
				message == CBN_KILLFOCUS ||
				message == CBN_CLOSEUP)
				{
				ModemCheck(hwnd);
				}
			}

			break;

		//
		// Property sheet's TAB_PHONENUMBER dialog is using this dialog proc
		// also, the following two buttons appear only in this tabbed dialog
		// template.
		//
		case IDC_PB_EDITICON:
			{
			pS = (pSDS)GetWindowLongPtr(hwnd, DWLP_USER);

			sessQueryName(pS->hSession, acNameCopy, sizeof(acNameCopy));

			if (DialogBoxParam(glblQueryDllHinst(),
				MAKEINTRESOURCE(IDD_NEWCONNECTION),
					hwnd, NewConnectionDlg,
						(LPARAM)pS->hSession) == FALSE)
				{
				return 0;
				}

			SetFocus(GetDlgItem(hwnd, IDC_PB_EDITICON));
			ach[0] = TEXT('\0');
			sessQueryName(pS->hSession, ach, sizeof(ach));
			mscModifyToFit(GetDlgItem(hwnd, IDC_TB_NAME), ach, SS_WORDELLIPSIS);
			SetDlgItemText(hwnd, IDC_TB_NAME, ach);

			SendDlgItemMessage(hwnd, IDC_IC_ICON, STM_SETICON,
				(WPARAM)sessQueryIcon(pS->hSession), 0);

			// The user may have changed the name of the session.
			// The new name should be reflected in the property sheet title
			// and in the app title.
			//
			propUpdateTitle(pS->hSession, hwnd, acNameCopy);
			}
			break;

		case IDC_PB_CONFIGURE:
			pS = (pSDS)GetWindowLongPtr(hwnd, DWLP_USER);
			hhDriver = (HHDRIVER)(pS->hDriver);

			if ((i = (int)SendDlgItemMessage(hwnd, IDC_CB_MODEMS, CB_GETCURSEL,
					0, 0)) != CB_ERR)
				{
				if (((LRESULT)pstLineIds = SendDlgItemMessage(hwnd,
						IDC_CB_MODEMS,  CB_GETITEMDATA, (WPARAM)i, 0))
							!= CB_ERR)
					{
					if (pstLineIds != NULL &&
						(LRESULT)pstLineIds != CB_ERR)
						{
						BOOL fIsSerialPort = FALSE;

						// I've "reserved" 4 permanent line ids to indentify
						// the direct to com port lines.
						//
						if (IN_RANGE(pstLineIds->dwPermanentLineId,
								DIRECT_COM1, DIRECT_COM4))
							{
							if (pstLineIds != NULL)
								{
								wsprintf(ach, TEXT("COM%d"),
									pstLineIds->dwPermanentLineId - DIRECT_COM1 + 1);
								}
							fIsSerialPort = TRUE;
							}
                        else if ( IsNT() && pstLineIds->dwPermanentLineId == DIRECT_COM_DEVICE)
							{
							// Get device from combobox... mrw:6/5/96
							//
							SendDlgItemMessage(hwnd, IDC_CB_MODEMS,
								CB_GETLBTEXT, (WPARAM)i,(LPARAM)ach);

							fIsSerialPort = TRUE;
							}

						if (fIsSerialPort == TRUE)
							{
							HCOM  hCom = sessQueryComHdl(pS->hSession);
							TCHAR szPortName[MAX_PATH];

							ComGetPortName(hCom, szPortName, MAX_PATH);

							if (StrCharCmp(szPortName, ach) != 0 )
								{
								ComSetPortName(hCom, ach);

								// mrw: 2/20/96 - Set AutoDetect off if user clicks
								// OK in this dialog.
								//
								if (ComDriverSpecial(hCom, "GET Defaults", NULL, 0) != COM_OK)
									{
									assert(FALSE);
									}
								ComSetAutoDetect(hCom, FALSE);
								ComConfigurePort(hCom);

								ComSetPortName(sessQueryComHdl(pS->hSession), ach);
								}
							}

						// mrw: 2/20/96 - Set AutoDetect off if user clicks
						// OK in this dialog.
						//
						if (fIsSerialPort == TRUE &&
							ComDeviceDialog(sessQueryComHdl(pS->hSession), hwnd) == COM_OK)
							{
							ComSetAutoDetect(sessQueryComHdl(pS->hSession), FALSE);
							ComConfigurePort(sessQueryComHdl(pS->hSession));
							}
						else
							{
#if RESET_DEVICE_SETTINGS
                            LPVARSTRING pvs = NULL;
                            int         lReturn;
                            LPVOID      pv = NULL;
                            
                            lReturn = cncttapiGetLineConfig( pstLineIds->dwLineId, (VOID **) &pvs );

                            if (lReturn != 0)
                                {
                                if (pvs != NULL)
                                    {
                                    free(pvs);
                                    pvs = NULL;
                                    }

                                return FALSE;
                                }
#endif
                            //
                            // Get the current settings.
                            //
                            cncttapiGetCOMSettings(pstLineIds->dwLineId,
                                                   ach,
                                                   sizeof(ach) / sizeof(TCHAR));
							//
                            // rev: 11/30/00 - Set AutoDetect off if user clicks
							// OK in this dialog.
							//

							lineConfigDialog(pstLineIds->dwLineId,
								             hwnd, DEVCLASS);
                            
                            //
                            // Get the new settings.
                            //
                            cncttapiGetCOMSettings(pstLineIds->dwLineId,
                                                   achSettings,
                                                   sizeof(achSettings) / sizeof(TCHAR));

#if RESET_DEVICE_SETTINGS
                            //
                            // Return the settings back to what they were before our dialog was displayed.
                            //
			                if (pvs != NULL)
                                {
                                pv = (BYTE *)pvs + pvs->dwStringOffset;

                                lReturn = lineSetDevConfig(pstLineIds->dwLineId, pv,
                                                           pvs->dwStringSize, DEVCLASS);
                                free(pvs);
                                pvs = NULL;

                                if (lReturn != 0)
    		                        {
    		                        assert(FALSE);
    		                        return FALSE;
    		                        }
                                }
#endif
                            
                            //
                            // See if the settings have changed.  If so, then turn off
                            // AutoDetect. REV: 12/01/2000 
                            //
                            if (StrCharCmpi(ach, achSettings) != 0)
                                {
								ComSetAutoDetect(sessQueryComHdl(pS->hSession), FALSE);
                                }
							}
						}
					}
				}

			else
				{
				mscMessageBeep(MB_ICONHAND);
				}

			break;

		case IDC_XB_USECCAC:
			EnableCCAC(hwnd);
			break;

		case IDOK:
			if (ValidatePhoneDlg(hwnd) == 0 &&
				tapi_SAVE_NEWPHONENUM(hwnd) == 0)
				{
				EndDialog(hwnd, TRUE);
				}

			break;

		case IDCANCEL:
			EndDialog(hwnd, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  tapi_WM_NOTIFY
 *
 * DESCRIPTION:
 *  Process Property Sheet Notification messages.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
STATIC_FUNC LRESULT tapi_WM_NOTIFY(const HWND hDlg, const int nId)
	{
	pSDS	pS;
	LRESULT lReturn = FALSE;

	switch (nId)
		{
		default:
			break;

		case PSN_APPLY:
			pS = (pSDS)GetWindowLongPtr(hDlg, DWLP_USER);
			if (pS)
				{
				//
				// Do whatever saving is necessary
				//

				if (ValidatePhoneDlg(hDlg) != 0 || tapi_SAVE_NEWPHONENUM(hDlg) != 0)
					{
					SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LONG_PTR)TRUE);
					lReturn = TRUE;
					}
				}
			break;

		case PSN_RESET:
			pS = (pSDS)GetWindowLongPtr(hDlg, DWLP_USER);
			if (pS)
				{
				//
				// If the user cancels make sure the old session name and its
				// icon are restored.
				//
				sessSetName(pS->hSession, pS->acSessNameCopy);
				sessSetIconID(pS->hSession, pS->nIconID);
				sessUpdateAppTitle(pS->hSession);

				SendMessage(sessQueryHwnd(pS->hSession), WM_SETICON,
					(WPARAM)TRUE, (LPARAM)pS->hIcon);
				}
			break;
#if 0
		case PSN_HASHELP:
			// For now gray the help button...
			//
			SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LONG_PTR)FALSE);
			break;
#endif
		case PSN_HELP:
			// Display help in whatever way is appropriate
			break;
		}

	return lReturn;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  tapi_SAVE_NEWPHONENUM
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
STATIC_FUNC int tapi_SAVE_NEWPHONENUM(HWND hwnd)
	{
	pSDS		pS;
	HHDRIVER	hhDriver;
	LRESULT		lr, lrx;
	PSTLINEIDS	pstLineIds = NULL;
    #if defined(INCL_MINITEL)
    HCOM    hCom;
    BOOL    fAutoDetect = FALSE;
    #endif // INCL_MINITEL

	pS = (pSDS)GetWindowLongPtr(hwnd, DWLP_USER);
	hhDriver = (HHDRIVER)(pS->hDriver);

	/* --- Get selected modem --- */

	lrx = SendDlgItemMessage(hwnd, IDC_CB_MODEMS, CB_GETCURSEL, 0, 0);

	if (lrx != CB_ERR)
		{
		lr = SendDlgItemMessage(hwnd, IDC_CB_MODEMS, CB_GETLBTEXT, (WPARAM)lrx,
			(LPARAM)hhDriver->achLineName);

		if (lr != CB_ERR)
			{
			pstLineIds = (PSTLINEIDS)SendDlgItemMessage(hwnd, IDC_CB_MODEMS,
				CB_GETITEMDATA, (WPARAM)lrx, 0);

			if ((LRESULT)pstLineIds != CB_ERR)
				{
				hhDriver->dwPermanentLineId = pstLineIds->dwPermanentLineId;
				hhDriver->dwLine = pstLineIds->dwLineId;

				if ( IsNT() )
					{
					if (hhDriver->dwPermanentLineId == DIRECT_COM_DEVICE)
						{
						SendDlgItemMessage(hwnd, IDC_CB_MODEMS,
							CB_GETLBTEXT, (WPARAM)lrx,
							(LPARAM)hhDriver->achComDeviceName);
						}
					}
				}
			else
				{
				assert(FALSE);
				}
			}
		else
			{
			assert(FALSE);
			}
		}
	else
		{
		//
		// Invalid port number.
		//
		TCHAR acBuffer[256];
		TCHAR acFormat[256];

		//
		// Display an error message.
		//
		if (LoadString(glblQueryDllHinst(), IDS_ER_TAPI_CONFIG, acFormat, 256) == 0)
			{
			acBuffer[0] = TEXT('\0');
			}

		//
		// Set the focus to the invalid control and display an error.
		//
		SetFocus(GetDlgItem(hwnd, IDC_CB_MODEMS));

		TimedMessageBox(hwnd, acBuffer, NULL, MB_OK | MB_ICONEXCLAMATION, 0);

		return 1;
		}

	/* --- Get Country Code --- */

	if (IsWindowEnabled(GetDlgItem(hwnd, IDC_CB_CNTRYCODES)))
		{
		lr = SendDlgItemMessage(hwnd, IDC_CB_CNTRYCODES, CB_GETCURSEL, 0, 0);

		if (lr != CB_ERR)
			{
			lr = SendDlgItemMessage(hwnd, IDC_CB_CNTRYCODES, CB_GETITEMDATA,
				(WPARAM)lr, 0);

			if (lr != CB_ERR)
				{
				hhDriver->dwCountryID = (DWORD)lr;
				}
			else
				{
				assert(FALSE);
				}
			}
		}

	/* --- Get area code --- */

	if (IsWindowEnabled(GetDlgItem(hwnd, IDC_EB_AREACODE)))
		{
		GetDlgItemText(hwnd, IDC_EB_AREACODE, hhDriver->achAreaCode,
			sizeof(hhDriver->achAreaCode) / sizeof(TCHAR));
		}

	/* --- Get phone number --- */

	if (IsWindowEnabled(GetDlgItem(hwnd, IDC_EB_PHONENUM)))
		{
		GetDlgItemText(hwnd, IDC_EB_PHONENUM, hhDriver->achDest,
			sizeof(hhDriver->achDest) / sizeof(TCHAR));
		}

    #if defined(INCL_WINSOCK)
    if (IsWindowEnabled(GetDlgItem(hwnd, IDC_EB_HOSTADDR)))
        {
        GetDlgItemText(hwnd, IDC_EB_HOSTADDR, hhDriver->achDestAddr,
			sizeof(hhDriver->achDestAddr) / sizeof(TCHAR));
        }

    if (IsWindowEnabled(GetDlgItem(hwnd, IDC_EB_PORTNUM)))
        {
		BOOL fTranslated = FALSE;
		int  nValue = GetDlgItemInt(hwnd, IDC_EB_PORTNUM, &fTranslated, TRUE);

		//
		// NOTE:  The values for the port must is set based upon the
		// struct sockaddr_in sin_port (which is defined as unsigned short)
		// and values accepted by connect(). REV: 4/11/2002
		//
		if (fTranslated && nValue <= USHRT_MAX)
			{
			hhDriver->iPort = nValue;
			}
		else
			{
			//
			// Invalid port number.
			//
			TCHAR acBuffer[256];
			TCHAR acFormat[256];

			//
			// Display an error message.
			//
			if (LoadString(glblQueryDllHinst(), IDS_ER_INVALID_PORT, acFormat, 256) == 0)
				{
				StrCharCopyN(acFormat,
					         TEXT("Invalid port number.  Port number must be between %d and %d."),
							 256);
				}

			//
			// The port must be between 0 and USHRT_MAX.
			//

			wsprintf(acBuffer, acFormat, 0, USHRT_MAX);

			//
			// Set the focus to the invalid control and display an error.
			//
			SetFocus(GetDlgItem(hwnd, IDC_EB_PORTNUM));

			TimedMessageBox(hwnd, acBuffer, NULL, MB_OK | MB_ICONEXCLAMATION, 0);

			return 1;
			}
        }
    #endif  // defined(INCL_WINSOCK)

	/* --- Get Use country code, area code info --- */

	if (IsWindowEnabled(GetDlgItem(hwnd, IDC_XB_USECCAC)))
		{
		hhDriver->fUseCCAC = (IsDlgButtonChecked(hwnd, IDC_XB_USECCAC) == BST_CHECKED);
		}

    #if defined(INCL_REDIAL_ON_BUSY)
	/* --- Get Redial on Busy setting --- */

	if (IsWindowEnabled(GetDlgItem(hwnd, IDC_XB_REDIAL)))
        {
		hhDriver->fRedialOnBusy =
		    (IsDlgButtonChecked(hwnd, IDC_XB_REDIAL) == BST_CHECKED);
        }
    #endif

	if (IsWindowEnabled(GetDlgItem(hwnd, IDC_XB_CDPROMPT)))
		{
		hhDriver->fCarrierDetect = (IsDlgButtonChecked(hwnd, IDC_XB_CDPROMPT) == BST_CHECKED);

		if (!hhDriver->fCarrierDetect)
			{
			hhDriver->stCallPar.dwBearerMode = 0;
			}
		else if (cnctdrvQueryStatus(hhDriver) != CNCT_STATUS_FALSE)
			{
			NotifyClient(hhDriver->hSession, EVENT_LOST_CONNECTION,
						 CNCT_LOSTCARRIER | (sessQueryExit(hhDriver->hSession) ? DISCNCT_EXIT :  0 ));
			}
		}

    #if defined (INCL_MINITEL)
    hCom = sessQueryComHdl(pS->hSession);

    if (hCom && ComValidHandle(hCom) &&
        ComGetAutoDetect(hCom, &fAutoDetect) == COM_OK &&
        fAutoDetect == TRUE)
        {
        HEMU hEmu = sessQueryEmuHdl(pS->hSession);

        if (hEmu && emuQueryEmulatorId(hEmu) == EMU_MINI)
            {
            //
            // Set to seven bit, even parity, and 1 stop bit (7E1),
            // This is only done when the Minitel emulator is selected.
            // The user can change the COM settings manually after this
            // point.
            //
            ComSetDataBits(hCom, 7);
            ComSetParity(hCom, EVENPARITY);
            ComSetStopBits(hCom, ONESTOPBIT);
            ComSetAutoDetect(hCom, FALSE);
            cncttapiSetLineConfig(hhDriver->dwLine, hCom);
            }
        }
    #endif //INCL_MINITEL

    return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EnableCCAC
 *
 * DESCRIPTION:
 *	Enables/disables controls associated with the Use Country Code,
 *	Area Code control
 *
 * ARGUMENTS:
 *	hwnd	- dialog window
 *
 * RETURNS:
 *	void
 *
 */
STATIC_FUNC void EnableCCAC(const HWND hwnd)
	{
	BOOL				fUseCCAC = TRUE;
	BOOL				fUseAC = TRUE;
	DWORD				dwCountryId;
	pSDS				pS;
	HHDRIVER			hhDriver;
	LRESULT 			lr;

	// Different templates use this same dialog proc.  If this window
	// is not there, don't do the work.  Also, selection of the direct
	// connect stuff can disable the control.

	if (IsWindowEnabled(GetDlgItem(hwnd, IDC_XB_USECCAC)))
		{
		fUseCCAC = (IsDlgButtonChecked(hwnd, IDC_XB_USECCAC) == BST_CHECKED);
		EnableWindow(GetDlgItem(hwnd, IDC_CB_CNTRYCODES), fUseCCAC);
		}

	// We want to enable the area code only if both the use Country
	// code, Area code checkbox is checked and the country in
	// question uses area codes. - mrw, 2/12/95
	//
	pS = (pSDS)GetWindowLongPtr(hwnd, DWLP_USER);
	hhDriver = (HHDRIVER)(pS->hDriver);

	// Country code from dialog
	//
	lr = SendDlgItemMessage(hwnd, IDC_CB_CNTRYCODES, CB_GETCURSEL, 0, 0);

	if (lr != CB_ERR)
		{
		lr = SendDlgItemMessage(hwnd, IDC_CB_CNTRYCODES, CB_GETITEMDATA,
			(WPARAM)lr, 0);

		if (lr != CB_ERR)
			dwCountryId = (DWORD)lr;

		#if defined(DEADWOOD)
		fUseAC = fCountryUsesAreaCode(dwCountryId, hhDriver->dwAPIVersion);
		#else // defined(DEADWOOD)
		fUseAC = TRUE; // Microsoft changed its mind on this one -mrw:4/20/95
		#endif // defined(DEADWOOD)
		}

	EnableWindow(GetDlgItem(hwnd, IDC_EB_AREACODE), fUseCCAC && fUseAC);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ModemCheck
 *
 * DESCRIPTION:
 *	Checks if the currently selected "modem" is one of the Direct to Com?
 *	selections.  If it is, it disables the country code, area code, phone
 *	number, and Use country code area code check box.
 *
 * ARGUMENTS:
 *	hwnd	- dialog window handle
 *
 * RETURNS:
 *	void
 *
 */
STATIC_FUNC void ModemCheck(const HWND hwnd)
	{
	int fModem;
	int fHotPhone;
    int fWinSock;
	LRESULT lr;
	PSTLINEIDS	pstLineIds = NULL;
	HHDRIVER hhDriver;
	const pSDS pS = (pSDS)GetWindowLongPtr(hwnd, DWLP_USER);
	const HWND hwndCB = GetDlgItem(hwnd, IDC_CB_MODEMS);
    HWND hwndTmp;

	if (!IsWindow(hwndCB))
		return;

	if ((lr = SendMessage(hwndCB, CB_GETCURSEL, 0, 0)) != CB_ERR)
		{
		pstLineIds = (PSTLINEIDS)SendMessage(hwndCB, CB_GETITEMDATA, lr, 0);

		if ((LRESULT)pstLineIds != CB_ERR)
			{
			fModem = TRUE;
            fWinSock = FALSE;

			if ((IN_RANGE(pstLineIds->dwPermanentLineId,
				          DIRECT_COM1, DIRECT_COM4)) ||
				(IsNT() &&
				 pstLineIds->dwPermanentLineId == DIRECT_COM_DEVICE))
				{
				fModem = FALSE;
				}

#if defined(INCL_WINSOCK)
			else if (pstLineIds->dwPermanentLineId == DIRECT_COMWINSOCK)
			    {
			    fModem = FALSE;
			    fWinSock = TRUE;
			    }
#endif

			// Also check if we have a hotphone
			//
			if (fModem == TRUE && pS)
				{
				hhDriver = (HHDRIVER)(pS->hDriver);

				if (hhDriver)
					{
					if (CheckHotPhone(hhDriver, pstLineIds->dwLineId,
							&fHotPhone) == 0)
						{
						fModem = !fHotPhone;
						}
					}
				}

            // Swap between phone number and host address prompts
            if ((hwndTmp = GetDlgItem(hwnd, IDC_TF_PHONEDETAILS)))
                {
                ShowWindow(hwndTmp, fWinSock ? SW_HIDE : SW_SHOW);
                EnableWindow(hwndTmp, fModem);
                }

            if ((hwndTmp = GetDlgItem(hwnd, IDC_TF_TCPIPDETAILS)))
                {
                ShowWindow(hwndTmp, fWinSock ? SW_SHOW : SW_HIDE);
                }

            if ((hwndTmp = GetDlgItem(hwnd, IDC_TF_ACPROMPT)))
                {
                ShowWindow(hwndTmp, fWinSock ? SW_HIDE : SW_SHOW);
                EnableWindow(hwndTmp, fModem);
                }

            // Swap between Country code and Host address static text
            if (hwndTmp = GetDlgItem(hwnd, IDC_TF_CNTRYCODES))
				{
				ShowWindow(hwndTmp, fWinSock ? SW_HIDE : SW_SHOW);
				//
				// Changed from ! fWinSock to fModem. REV: 11/7/2001
				//
				EnableWindow(hwndTmp, fModem);
				}

            if (hwndTmp = GetDlgItem(hwnd, IDC_TF_HOSTADDR))
				{
				ShowWindow(hwndTmp, fWinSock ? SW_SHOW : SW_HIDE);
				EnableWindow(hwndTmp, fWinSock || fModem);
				}

            // Swap between country code and host address edit boxes
            if (hwndTmp = GetDlgItem(hwnd, IDC_CB_CNTRYCODES))
				{
				ShowWindow(hwndTmp, fWinSock ? SW_HIDE : SW_SHOW);
				EnableWindow(hwndTmp, fModem);
				}
            if (hwndTmp = GetDlgItem(hwnd, IDC_EB_HOSTADDR))
				{
				ShowWindow(hwndTmp, fWinSock ? SW_SHOW : SW_HIDE);
				EnableWindow(hwndTmp, fWinSock);
				}

            // Swap between area code and port number static text
            if (hwndTmp = GetDlgItem(hwnd, IDC_TF_AREACODES))
				{
				ShowWindow(hwndTmp, fWinSock ? SW_HIDE : SW_SHOW);
				//
				// Changed from ! fWinSock to fModem. REV: 11/7/2001
				//
				EnableWindow(hwndTmp, fModem);
				}

			if (hwndTmp = GetDlgItem(hwnd, IDC_TF_PORTNUM))
				{
				ShowWindow(hwndTmp, fWinSock ? SW_SHOW : SW_HIDE);
				EnableWindow(hwndTmp, fWinSock);
				}

            // Swap between area code and port number edit boxes
            if (hwndTmp = GetDlgItem(hwnd, IDC_EB_AREACODE))
				{
				ShowWindow(hwndTmp, fWinSock ? SW_HIDE : SW_SHOW);
				EnableWindow(hwndTmp, fModem);
				}

			if (hwndTmp = GetDlgItem(hwnd, IDC_EB_PORTNUM))
				{
				ShowWindow(hwndTmp, fWinSock ? SW_SHOW : SW_HIDE);
				EnableWindow(hwndTmp, fWinSock);
				}

            if (hwndTmp = GetDlgItem(hwnd, IDC_TF_PHONENUM))
				{
				ShowWindow(hwndTmp, ! fWinSock);
				//
				// Changed from ! fWinSock to fModem. REV: 11/7/2001
				//
				EnableWindow(hwndTmp, fModem);
				}

			if (hwndTmp = GetDlgItem(hwnd, IDC_EB_PHONENUM))
				{
				ShowWindow(hwndTmp, ! fWinSock);
				EnableWindow(hwndTmp, fModem);
				}

            if ((hwndTmp = GetDlgItem(hwnd, IDC_XB_USECCAC)))
                {
                ShowWindow(hwndTmp, ! fWinSock);
                EnableWindow(hwndTmp, fModem);
                }

            if ((hwndTmp = GetDlgItem(hwnd, IDC_PB_CONFIGURE)))
                {
                ShowWindow(hwndTmp, !fWinSock);
                EnableWindow(hwndTmp, !fWinSock);
                if (pS)
					{
				    EnableWindow(hwndTmp, cnctdrvQueryStatus((HHDRIVER)(pS->hDriver)) == CNCT_STATUS_FALSE);
					}
                }

            if ((hwndTmp = GetDlgItem(hwnd, IDC_XB_CDPROMPT)))
                {
                ShowWindow(hwndTmp, !fWinSock);
                EnableWindow(hwndTmp, !fWinSock);
                }


            // Set focus to modem combo when direct connect selected.
            // mrw:11/3/95
            //
            if (fWinSock == TRUE)
                {
				hwndTmp = GetDlgItem(hwnd,IDC_EB_HOSTADDR);
                }
			else if (fModem == TRUE)
				{
				hwndTmp = GetDlgItem(hwnd, IDC_EB_PHONENUM);
				}
			else
				{
				hwndTmp = GetDlgItem(hwnd, IDC_PB_CONFIGURE);
				}

            SetFocus(hwndTmp ? hwndTmp : hwndCB);

			#if defined(INCL_REDIAL_ON_BUSY)
			if ((hwndTmp = GetDlgItem(hwnd, IDC_XB_REDIAL)))
				{
				ShowWindow(hwndTmp, ! fWinSock);
				EnableWindow(hwndTmp, fModem);
				}
			#endif

			if (fModem == TRUE)
				{
				EnableCCAC(hwnd);
				}
			}
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	ValidatePhoneDlg
 *
 * DESCRIPTION:
 *	Checks phone dialog entries for proper values.	This mostly means
 *	checking for blank entry fields.
 *
 * ARGUMENTS:
 *	hwnd		- phone dialog
 *
 * RETURNS:
 *	0=OK,else error
 *
 */
static int ValidatePhoneDlg(const HWND hwnd)
	{
	int return_value = 0;

	if (CheckWindow(hwnd, IDC_CB_CNTRYCODES, IDS_GNRL_NEED_COUNTRYCODE) != 0)
		{
		return_value = -1;
		}
	#if DEADWOOD //- mrw:4/20/95
	else if (CheckWindow(hwnd, IDC_EB_AREACODE, IDS_GNRL_NEED_AREACODE) != 0)
		{
		return_value = -2;
		}
	#endif // DEADWOOD
	#if DEADWOOD // Removed per MHG discussions - MPT 12/21/95
	else if (CheckWindow(hwnd, IDC_EB_PHONENUM, IDS_GNRL_NEED_PHONENUMBER) != 0)
		{
		return_value = -3;
		}
	#endif // DEADWOOD
	else if (CheckWindow(hwnd, IDC_CB_MODEMS, IDS_GNRL_NEED_CONNECTIONTYPE) != 0)
		{
		return_value = -4;
		}
	else if (VerifyAddress(hwnd) != 0)
		{
		return_value = -5;
		}
	#if defined(INCL_WINSOCK)
	else if (VerifyHost(hwnd) != 0)
		{
		return_value = -6;
		}
	#endif //INCL_WINSOCK

	return return_value;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CheckWindow
 *
 * DESCRIPTION:
 *	Since the dialog only enables windows that require entries, it just
 *	needs to check if an enabled window has text.  This function sets
 *	the focus to the offending field and beeps.
 *
 * ARGUMENTS:
 *	hwnd	- dialog window
 *	id		- control id
 *	iErrMsg - id of error message to display if field is empty
 *
 * RETURNS:
 *	0=OK, else not ok.
 *
 */
static int CheckWindow(const HWND hwnd, const int id, const UINT iErrMsg)
	{
	TCHAR ach[256];

	if (IsWindowEnabled(GetDlgItem(hwnd, id)))
		{
		if (GetDlgItemText(hwnd, id, ach, 256) == 0)
			{
			if (iErrMsg != 0)
				{
				//
				// Added the warning dlg with a warning instead of just
				// a warning. rde 31 Oct 01
				//
				LoadString(glblQueryDllHinst(), iErrMsg, ach, 256);
				TimedMessageBox(hwnd, ach, NULL, MB_OK | MB_ICONHAND, 0);
				}

			SetFocus(GetDlgItem(hwnd, id));
			return -1;
			}
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	VerifyAddress
 *
 * DESCRIPTION:
 *	I can't believe how much code it takes to verify a stinking address.
 *
 * ARGUMENTS:
 *	hwnd	- dialog window handle.
 *
 * RETURNS:
 *	0=OK
 *
 */
static int VerifyAddress(const HWND hwnd)
	{
	pSDS		pS;
	HHDRIVER	hhDriver;
	LRESULT		lr, lrx;
	PSTLINEIDS	pstLineIds = NULL;
	int   fHotPhone;
	int   fUseCCAC;
	long  lRet;
	DWORD dwSize;
	DWORD dwLine;
	DWORD dwCountryID;
	DWORD dwPermanentLineId;
	TCHAR achAreaCode[10];
	TCHAR achDest[(TAPIMAXDESTADDRESSSIZE/2)+1];
	TCHAR ach[256];
	LPLINECOUNTRYLIST pcl;
	LPLINECOUNTRYENTRY pce;
	LINETRANSLATEOUTPUT *pLnTransOutput;

	pS = (pSDS)GetWindowLongPtr(hwnd, DWLP_USER);
	hhDriver = (HHDRIVER)(pS->hDriver);

	/* --- Get selected modem --- */

	lrx = SendDlgItemMessage(hwnd, IDC_CB_MODEMS, CB_GETCURSEL, 0, 0);

	if (lrx != CB_ERR)
		{
		pstLineIds = (PSTLINEIDS)SendDlgItemMessage(hwnd, IDC_CB_MODEMS,
			CB_GETITEMDATA, (WPARAM)lrx, 0);

		if ((LRESULT)pstLineIds != CB_ERR)
			{
			dwPermanentLineId = pstLineIds->dwPermanentLineId;
			dwLine = pstLineIds->dwLineId;
			}
		}

	else
		{
		return 0;
		}

	/* --- Get Country Code --- */

	if (IsWindowEnabled(GetDlgItem(hwnd, IDC_CB_CNTRYCODES)))
		{
		lr = SendDlgItemMessage(hwnd, IDC_CB_CNTRYCODES, CB_GETCURSEL, 0, 0);

		if (lr != CB_ERR)
			{
			lr = SendDlgItemMessage(hwnd, IDC_CB_CNTRYCODES, CB_GETITEMDATA,
				(WPARAM)lr, 0);

			if (lr != CB_ERR)
				dwCountryID = (DWORD)lr;
			}
		}

	else
		{
		return 0;
		}

	/* --- Get area code --- */

	achAreaCode[0] = TEXT('\0');
	GetDlgItemText(hwnd, IDC_EB_AREACODE, achAreaCode,
		           sizeof(achAreaCode) / sizeof(TCHAR));

	/* --- Get phone number --- */

	achDest[0] = TEXT('\0');
	GetDlgItemText(hwnd, IDC_EB_PHONENUM, achDest,
		           sizeof(achDest) / sizeof(TCHAR));

	/* --- Get Use country code, area code info --- */

	fUseCCAC = TRUE;

	if (IsWindowEnabled(GetDlgItem(hwnd, IDC_XB_USECCAC)))
		fUseCCAC = (IsDlgButtonChecked(hwnd, IDC_XB_USECCAC) == BST_CHECKED);

	/* --- Try to translate --- */

	if (CheckHotPhone(hhDriver, dwLine, &fHotPhone) != 0)
		{
		assert(0);
		return 0;  // error message displayed already.
		}

	// Hot Phone is TAPI terminology for Direct Connects
	// We don't need to do address translation since we
	// not going to use it.

	if (fHotPhone)
		{
		return 0;
		}

	ach[0] = TEXT('\0');

	// If we not using the country code or area code, we still need to
	// pass a dialable string format to TAPI so that we get the
	// pulse/tone dialing modifiers in the dialable string.
	//
	if (fUseCCAC)
		{
		/* --- Do lineGetCountry to get extension --- */

		if (DoLineGetCountry(dwCountryID, TAPI_VER, &pcl) != 0)
			{
			assert(FALSE);
			return 0;
			}

		if ((pce = (LPLINECOUNTRYENTRY)
				((BYTE *)pcl + pcl->dwCountryListOffset)) == 0)
			{
			assert(FALSE);
			return 0;
			}

		/* --- Put country code in now --- */

		wsprintf(ach, "+%u ", pce->dwCountryCode);
		free(pcl);
		pcl = NULL;

		if (!fIsStringEmpty(achAreaCode))
			{
			StrCharCat(ach, "(");
			StrCharCat(ach, achAreaCode);
			StrCharCat(ach, ") ");
			}
		}

	StrCharCat(ach, achDest);

	/* --- Allocate some space --- */

	pLnTransOutput = malloc(sizeof(LINETRANSLATEOUTPUT));

	if (pLnTransOutput == 0)
		{
		assert(FALSE);
		return 0;
		}

	pLnTransOutput->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

	/* --- Now that we've satisifed the clergy, translate it --- */

	if (TRAP(lRet = lineTranslateAddress(hhDriver->hLineApp,
			dwLine, TAPI_VER, ach, 0,
				LINETRANSLATEOPTION_CANCELCALLWAITING,
					pLnTransOutput)) != 0)
		{
		free(pLnTransOutput);
		pLnTransOutput = NULL;

		if (lRet == LINEERR_INVALADDRESS)
			{
			goto MSG_EXIT;
			}

		return 0;
		}

	if (pLnTransOutput->dwTotalSize < pLnTransOutput->dwNeededSize)
		{
		dwSize = pLnTransOutput->dwNeededSize;
		free(pLnTransOutput);
		pLnTransOutput = NULL;

		if ((pLnTransOutput = malloc(dwSize)) == 0)
			{
			assert(FALSE);
			return 0;
			}

		pLnTransOutput->dwTotalSize = dwSize;

		if ((lRet = lineTranslateAddress(hhDriver->hLineApp,
				dwLine, TAPI_VER, ach, 0,
					LINETRANSLATEOPTION_CANCELCALLWAITING,
						pLnTransOutput)) != 0)
			{
			assert(FALSE);
			free(pLnTransOutput);
			pLnTransOutput = NULL;

			if (lRet == LINEERR_INVALADDRESS)
				{
				goto MSG_EXIT;
				}
			}
		}

	free(pLnTransOutput);
	pLnTransOutput = NULL;
	return 0;

	MSG_EXIT:
		hhDriver->achDialableDest[0] = TEXT('\0');
		hhDriver->achDisplayableDest[0] = TEXT('\0');
		hhDriver->achCanonicalDest[0] = TEXT('\0');

		LoadString(glblQueryDllHinst(), IDS_ER_CNCT_BADADDRESS, ach,
			sizeof(ach) / sizeof(TCHAR));

		TimedMessageBox(hwnd, ach, NULL, MB_OK | MB_ICONINFORMATION, 0);

#if defined (NT_EDITION)
		//
		// TODO:REV 5/17/2002 If we want to not exit the property page when
		// there is an error with the phone number, then we should change the
		// LINEERR_INVALADDRESS to 0 in the line below.
		//
		if (lRet != LINEERR_INVALADDRESS)
			{
			return -2;
			}
#endif

		// per MHG discussion - MPT 12/21/95
		return 0;
	}

#if defined(INCL_WINSOCK)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	VerifyHost
 *
 * DESCRIPTION:
 *	Verify the Host Address is valid.
 *
 * ARGUMENTS:
 *	hwnd	- dialog window handle.
 *
 * RETURNS:
 *	0=OK
 *
 */
static int VerifyHost(const HWND hwnd)
	{
	int return_value = 0;

	if (CheckWindow(hwnd, IDC_EB_HOSTADDR, IDS_ER_TCPIP_MISSING_ADDR) != 0)
		{
		return_value = -1;
		}
	else if (CheckWindow(hwnd, IDC_EB_PORTNUM, IDS_ER_TCPIP_MISSING_PORT) != 0)
		{
		return_value = -2;
		}

	return return_value;
	}
#endif // INCL_WINSOCK

#if defined(DEADWOOD)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	fCountryUsesAreaCode
 *
 * DESCRIPTION:
 *	Checks if the specified country uses area codes.
 *
 * ARGUMENTS:
 *	hwnd	- window handle of dialog.
 *
 * RETURNS:
 *	TRUE/FALSE, <0=error
 *
 * AUTHOR: Mike Ward, 26-Jan-1995
 */
int fCountryUsesAreaCode(const DWORD dwCountryID, const DWORD dwAPIVersion)
	{
	LPTSTR pachLongDistDialRule;
	LPLINECOUNTRYLIST pcl;
	LPLINECOUNTRYENTRY pce;

	// Get country information
	//
	if (DoLineGetCountry(dwCountryID, TAPI_VER, &pcl) != 0)
		{
		assert(0);
		return -1;
		}

	// Find offset to country info.
	//
	if ((pce = (LPLINECOUNTRYENTRY)
			((BYTE *)pcl + pcl->dwCountryListOffset)) == 0)
		{
		assert(0);
		return -1;
		}

	// Get long distance dialing rule
	//
	pachLongDistDialRule = (BYTE *)pcl + pce->dwLongDistanceRuleOffset;

	// If dial rule has an 'F', we need the area code.
	//
	if (strchr(pachLongDistDialRule, TEXT('F')))
		return TRUE;

	return FALSE;
	}
#endif // defined(DEADWOOD)

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	fIsStringEmpty
 *
 * DESCRIPTION:
 *	Used for checking if areacode is just blanks.  lineTranslateAddress
 *	pukes badly if you give it a string of blanks for the area code.
 *
 * ARGUMENTS:
 *	ach 	- areacode string (can be NULL)
 *
 * RETURNS:
 *	1=emtpy, 0=not empty
 *
 * AUTHOR: Mike Ward, 20-Apr-1995
 */
int fIsStringEmpty(LPTSTR ach)
	{
	int i;

	if (ach == 0)
		return 1;

	if (ach[0] == TEXT('\0'))
		return 1;

	for (i = lstrlen(ach) - 1 ; i >= 0 ; --i)
		{
		if (ach[i] != TEXT(' '))
			return 0;
		}

	return 1;
	}


int cncttapiGetCOMSettings( const DWORD dwLineId, LPTSTR pachStr, const size_t cb )
    {
    static CHAR  acParity[] = "NOEMS";  // see com.h
    static CHAR *pachStop[] = {"1", "1.5", "2"};

    TCHAR       ach[100];
    DWORD       dwSize;
    LPVARSTRING pvs;
    int         fAutoDetect = FALSE;
    long        lBaud = 0;
    int         iDataBits = 0;
    int         iParity = 0;
    int         iStopBits = 0;
    int         lReturn = 0;

    LPCOMMPROP pComProp = 0;

	#if defined(MODEM_NEGOTIATED_DCE_RATE) // TODO:REV 5/29/2002 
	long         lNegBaud = 0;
	#endif // defined(MODEM_NEGOTIATED_DCE_RATE)


    // Check the parameters
    //
    if (pachStr == 0 || cb == 0)
    	{
    	assert(0);
    	return -2;
    	}

    ach[0] = TEXT('\0');

    if ((pvs = malloc(sizeof(VARSTRING))) == 0)
    	{
    	assert(FALSE);
    	return -3;
    	}

	memset(pvs, 0, sizeof(VARSTRING));
    pvs->dwTotalSize = sizeof(VARSTRING);
	pvs->dwNeededSize = 0;

    if (lineGetDevConfig(dwLineId, pvs, DEVCLASS) != 0)
    	{
    	assert(FALSE);
    	free(pvs);
  		pvs = NULL;
    	return -4;
    	}

    if (pvs->dwNeededSize > pvs->dwTotalSize)
    	{
    	dwSize = pvs->dwNeededSize;
    	free(pvs);
  		pvs = NULL;

    	if ((pvs = malloc(dwSize)) == 0)
    		{
    		assert(FALSE);
    		return -5;
    		}

		memset(pvs, 0, dwSize);
    	pvs->dwTotalSize = dwSize;

    	if (lineGetDevConfig(dwLineId, pvs, DEVCLASS) != 0)
    		{
    		assert(FALSE);
    		free(pvs);
  			pvs = NULL;
    		return -6;
    		}
    	}

    // The structure of the DevConfig block is as follows
    //
    //	VARSTRING
    //	UMDEVCFGHDR
    //	COMMCONFIG
    //	MODEMSETTINGS
    //
    // The UMDEVCFG structure used below is defined in the
    // UNIMODEM.H provided in the platform SDK (in the nih
    // directory for HTPE). REV: 12/01/2000 
    //
    {
    PUMDEVCFG pDevCfg = NULL;
    
    pDevCfg = (UMDEVCFG *)((BYTE *)pvs + pvs->dwStringOffset);

	if (pDevCfg)
		{
		// commconfig struct has a DCB structure we dereference for the
		// com settings.
		//
		lBaud = pDevCfg->commconfig.dcb.BaudRate;
		iDataBits = pDevCfg->commconfig.dcb.ByteSize;
		iParity = pDevCfg->commconfig.dcb.Parity;
		iStopBits = pDevCfg->commconfig.dcb.StopBits;

		#if defined(MODEM_NEGOTIATED_DCE_RATE) // TODO:REV 5/29/2002 
		//
		// See if this is a modem connection and connected, then get
		// the negotiated baud rate instead of the default max rate
		// the modem is set up for. -- REV: 5/29/2002
		//
		if (pDevCfg->commconfig.dwProviderSubType == PST_MODEM)
			{
			MODEMSETTINGS * pModemSettings = (MODEMSETTINGS *)pDevCfg->commconfig.wcProviderData;

			if (pModemSettings)
				{
				lNegBaud = pModemSettings->dwNegotiatedDCERate;
				}
			}
		#endif // defined(MODEM_NEGOTIATED_DCE_RATE)
        }

	#if defined(MODEM_NEGOTIATED_DCE_RATE) // TODO:REV 5/29/2002 
	if (lNegBaud > 0)
		{
		wsprintf(ach, "%ld %d-%c-%s", lNegBaud, iDataBits,
				 acParity[iParity], pachStop[iStopBits]);
		}
	else
		{
		wsprintf(ach, "%ld %d-%c-%s", lBaud, iDataBits,
				 acParity[iParity], pachStop[iStopBits]);
		}
	#else // defined(MODEM_NEGOTIATED_DCE_RATE)
	wsprintf(ach, "%ld %d-%c-%s", lBaud, iDataBits,
				 acParity[iParity], pachStop[iStopBits]);
	#endif //defined(MODEM_NEGOTIATED_DCE_RATE)
#if 0	//DEADWOOD:jkh 9/9/98
    wsprintf(ach, "%u %d-%c-%s", pDevCfg->commconfig.dcb.BaudRate,
    	pDevCfg->commconfig.dcb.ByteSize,
    	acParity[pDevCfg->commconfig.dcb.Parity],
    	pachStop[pDevCfg->commconfig.dcb.StopBits]);
#endif
    }

    StrCharCopyN(pachStr, ach, cb);
    pachStr[cb-1] = TEXT('\0');
    free(pvs);
    pvs = NULL;

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\cncttapi\tapidlgs.c ===
/*	File: D:\WACKER\cncttapi\tapidlgs.c (Created: 13-Feb-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:55p $
 */

Nope, can't use this anymore...
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\cncttapi\enum.c ===
/*      File: D:\WACKER\cncttapi\enum.c (Created: 23-Mar-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 29 $
 *	$Date: 7/02/02 8:27a $
 */

#define TAPI_CURRENT_VERSION 0x00010004     // cab:11/14/96 - required!

#undef MODEM_NEGOTIATED_DCE_RATE

#include <tapi.h>
#include <unimodem.h>
#include <limits.h>
#pragma hdrstop

#include <time.h>
#include <string.h>

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\tdll.h>
#include <tdll\mc.h>
#include <tdll\assert.h>
#include <tdll\errorbox.h>
#include <tdll\cnct.h>
#include <tdll\hlptable.h>
#include <tdll\globals.h>
#include <tdll\com.h>
#include <term\res.h>
#include <tdll\htchar.h>
#include <tdll\misc.h>

#include "cncttapi.hh"
#include "cncttapi.h"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EnumerateTapiLocations
 *
 * DESCRIPTION:
 *	Enumerates tapi locations and puts them in the given combo box.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *	hwndCB		- window handle of combo box
 *	hwndTB		- calling card text window
 *
 * RETURNS:
 *	0 on success, else error
 *
 */
int EnumerateTapiLocations(const HHDRIVER hhDriver, const HWND hwndCB,
    					   const HWND hwndTB)
    {
    DWORD i, dwSize;
    LRESULT lr;
    TCHAR *pach = NULL;
    TCHAR ach[256];
    DWORD dwPreferredCardID = (DWORD)-1;
    DWORD dwCountryID = 1;
    LINETRANSLATECAPS *pLnTransCap = NULL;
    LINELOCATIONENTRY *pLnLocEntry = NULL;
    LINECARDENTRY *pLnCardEntry = NULL;

    /* --- Enumerate locations --- */

    if (hhDriver == 0)
        {
        return -1;
        }

    if ((pLnTransCap = malloc(sizeof(LINETRANSLATECAPS))) == 0)
    	{
    	assert(FALSE);
    	return -2;
    	}

    dwSize = 0; // used in this loop to call the dialog only once.

    do	{
    	memset(pLnTransCap, 0, sizeof(LINETRANSLATECAPS)); //* temp
    	pLnTransCap->dwTotalSize = sizeof(LINETRANSLATECAPS); //* temp

    	if ((i = TRAP(lineGetTranslateCaps(hhDriver->hLineApp, TAPI_VER,
    			pLnTransCap))) != 0)
    		{
    		if ( i == LINEERR_INIFILECORRUPT )
    			{
    			// Unfortunately, lineTranslateDialog does not return
    			// a failure code if the user clicks cancel.  So if
    			// we fail the second time on lineGetTranslateCaps()
    			// don't bother to do anything else.
    			//
    			if (dwSize == 0)
    				{
    				LoadString(glblQueryDllHinst(), IDS_ER_TAPI_NEEDS_INFO,
    					ach, sizeof(ach) / sizeof(TCHAR));

    				TimedMessageBox(sessQueryHwnd(hhDriver->hSession), ach,
    					            NULL, MB_OK | MB_ICONINFORMATION, 0);

    		        free(pLnTransCap);
  		            pLnTransCap = NULL;
    				return -3;
    				}

    			if (TRAP(lineTranslateDialog(hhDriver->hLineApp, 0,
    					TAPI_VER, sessQueryHwnd(hhDriver->hSession), 0))
    						== 0)
    				{
    				dwSize = 1;
    				continue;
    				}
    			}

    		free(pLnTransCap);
  		    pLnTransCap = NULL;
    		return -4;
    		}
    	}
    while (i);	// end of do.

    if (pLnTransCap->dwNeededSize > pLnTransCap->dwTotalSize)
    	{
    	dwSize = pLnTransCap->dwNeededSize;
    	free(pLnTransCap);
  	    pLnTransCap = NULL;

    	if ((pLnTransCap = malloc(dwSize)) == 0)
    		{
    		assert(FALSE);
    		return -5;
    		}

    	pLnTransCap->dwTotalSize = dwSize;

    	if (TRAP(lineGetTranslateCaps(hhDriver->hLineApp, TAPI_VER,
    			pLnTransCap)) != 0)
    		{
            free(pLnTransCap);
  		    pLnTransCap = NULL;
    		return -6;
    		}
    	}

    /* --- Clear combo box --- */

    if (IsWindow(hwndCB))
    	SendMessage(hwndCB, CB_RESETCONTENT, 0, 0);

    /* --- Setup pointer to entry structure and enumerate --- */

    pLnLocEntry = (LINELOCATIONENTRY *)
    	((LPSTR)pLnTransCap + pLnTransCap->dwLocationListOffset);

    for (i = 0 ; i < pLnTransCap->dwNumLocations ; ++i)
    	{
    	if (pLnLocEntry->dwLocationNameSize == 0)
    		continue;

    	pach = (LPSTR)pLnTransCap + pLnLocEntry->dwLocationNameOffset;
        if (pLnLocEntry->dwLocationNameSize)   		
            MemCopy(ach, pach, pLnLocEntry->dwLocationNameSize);
    	ach[pLnLocEntry->dwLocationNameSize] = TEXT('\0');

    	if (IsWindow(hwndCB))
    		{
    		lr = SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM)ach);

    		if (lr != CB_ERR)
    			{
    			SendMessage(hwndCB, CB_SETITEMDATA, (WPARAM)lr,
    				(LPARAM)pLnLocEntry->dwPermanentLocationID);
    			}

    		else
    			{
    			assert(FALSE);
    			}
    		}

    	// Make sure we have a default by setting the first valid entry
    	// we ecounter to the default.	Later in the enumeration, if we
    	// encounter another ID as the default, we can reset it.

    	if (pLnLocEntry->dwPermanentLocationID ==
    			pLnTransCap->dwCurrentLocationID
    				|| dwPreferredCardID == (DWORD)-1)
    		{
    		dwPreferredCardID = pLnLocEntry->dwPreferredCardID;

    		if (hhDriver->dwCountryID == (DWORD)-1)
    			dwCountryID = pLnLocEntry->dwCountryID;

    		/* --- Get default location area code if not specified --- */

    		if (pLnLocEntry->dwCityCodeSize)
    			{
    			pach = (LPSTR)pLnTransCap +
    				pLnLocEntry->dwCityCodeOffset;

   				if (pLnLocEntry->dwCityCodeSize)
                    MemCopy(hhDriver->achDefaultAreaCode, pach, pLnLocEntry->dwCityCodeSize);

    			hhDriver->achDefaultAreaCode[pLnLocEntry->dwCityCodeSize] =
    				TEXT('\0');
    			}
    		}

    	pLnLocEntry += 1;
    	}

    // If we don't have a country code loaded for this session, then
    // use the country code of the current location.
    //
    if (hhDriver->dwCountryID == (DWORD)-1)
    	hhDriver->dwCountryID = dwCountryID;

    /* --- Select the default location --- */
    	
    if (IsWindow(hwndCB))
    	{
    	// mrw,2/13/95 - changed so that selection is made by quering
    	// the combo box rather than saving the index which proved
    	// unreliable.
    	//
    	for (i = 0 ; i < pLnTransCap->dwNumLocations ; ++i)
    		{
    		lr = SendMessage(hwndCB, CB_GETITEMDATA, (WPARAM)i, 0);

    		if (lr != CB_ERR)
    			{
    			if ((DWORD)lr == pLnTransCap->dwCurrentLocationID)
    				SendMessage(hwndCB, CB_SETCURSEL, i, 0);
    			}
    		}
    	}

    /* --- Now find the card entry --- */

    if (dwPreferredCardID != (DWORD)-1)
    	{
    	pLnCardEntry = (LINECARDENTRY *)
    		((LPSTR)pLnTransCap + pLnTransCap->dwCardListOffset);

    	for (i = 0 ; i < pLnTransCap->dwNumCards ; ++i)
    		{
    		if (pLnCardEntry->dwPermanentCardID == dwPreferredCardID)
    			{
    			if (pLnCardEntry->dwCardNameSize == 0)
    				break;

    			pach = (LPSTR)pLnTransCap + pLnCardEntry->dwCardNameOffset;
   				if (pLnCardEntry->dwCardNameSize)
                    MemCopy(ach, pach, pLnCardEntry->dwCardNameSize);
    			ach[pLnCardEntry->dwCardNameSize] = TEXT('\0');

    			if (IsWindow(hwndTB))
    				SetWindowText(hwndTB, ach);

    			break;
    			}

    		pLnCardEntry += 1;
    		}
    	}

    free(pLnTransCap);
    pLnTransCap = NULL;
    return 0;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EnumerateCountryCodes
 *
 * DESCRIPTION:
 *	Enumerates available country codes.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *	hwndCB		- combobox to fill
 *
 * RETURNS:
 *	0=success, else error code.
 *
 */
int EnumerateCountryCodes(const HHDRIVER hhDriver, const HWND hwndCB)
    {
    int iIdx;
    DWORD dw;
    DWORD dwID;
    DWORD dwSize;
    TCHAR ach[100];
    LPLINECOUNTRYLIST pcl = NULL;
    LPLINECOUNTRYENTRY pce;

    if (hhDriver == 0)
        goto ERROR_EXIT;

    /* --- Usual junk to make a TAPI call --- */

    if ((pcl = (LPLINECOUNTRYLIST)malloc(sizeof(LINECOUNTRYLIST))) == 0)
        {
        assert(0);
        goto ERROR_EXIT;
        }

	memset( pcl, 0, sizeof(LINECOUNTRYLIST) );
    pcl->dwTotalSize = sizeof(LINECOUNTRYLIST);

    // Get the country list all at once.
    //
    if (lineGetCountry(0, TAPI_VER, pcl) != 0)
        {
        assert(0);
        goto ERROR_EXIT;
        }

    if (pcl->dwNeededSize > pcl->dwTotalSize)
        {
        dwSize = pcl->dwNeededSize;
        free(pcl);
  	    pcl = NULL;

        if ((pcl = (LPLINECOUNTRYLIST)malloc(dwSize)) == 0)
            {
            assert(0);
            goto ERROR_EXIT;
            }

		memset( pcl, 0, dwSize );
        pcl->dwTotalSize = dwSize;

        if (lineGetCountry(0, TAPI_VER, pcl) != 0)
            {
            assert(0);
            goto ERROR_EXIT;
            }
        }

    // Empty contents of combo box.
    //
    if (hwndCB)
        SendMessage(hwndCB, CB_RESETCONTENT, 0, 0);

    // Country List array starts here...
    //
    pce = (LPLINECOUNTRYENTRY)((BYTE *)pcl + pcl->dwCountryListOffset);

    // Loop thru list of countries and insert into combo box.
    //
    for (dw = 0 ; dw < pcl->dwNumCountries ; ++dw, ++pce)
        {
        // Format so country name is first.
        //
        wsprintf(ach, "%s (%d)", (BYTE *)pcl + pce->dwCountryNameOffset,
            pce->dwCountryCode);

        // Add to combo box
        //
    	iIdx = (int)SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM)ach);

        if (iIdx != CB_ERR)
            {
        	SendMessage(hwndCB, CB_SETITEMDATA, (WPARAM)iIdx,
    			    (LPARAM)pce->dwCountryID);
            }
        }

    // Find the current ID and select it.
    //
    for (dw = 0 ; dw < pcl->dwNumCountries ; ++dw)
        {
    	dwID = (DWORD)SendMessage(hwndCB, CB_GETITEMDATA, (WPARAM)dw, 0);

        if (dwID == hhDriver->dwCountryID)
            {
            SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)dw, 0);
            break;
            }
        }

    // Clean up and exit
    //
    free(pcl);
    pcl = NULL;
    return 0;

    /*==========*/
ERROR_EXIT:
    /*==========*/
    if (pcl)
        {
        free(pcl);
  	    pcl = NULL;
        }

    return -1;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EnumerateAreaCodes
 *
 * DESCRIPTION:
 *	Lists last 10 area codes used.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *	hwndCB		- combobox to fill
 *
 * RETURNS:
 *	0=success, else error.
 *
 */
int EnumerateAreaCodes(const HHDRIVER hhDriver, const HWND hwndCB)
    {
    if (hhDriver == 0)
    	{
    	assert(FALSE);
    	return -1;
    	}

    if (hhDriver->achAreaCode[0] == TEXT('\0'))
        {
    	StrCharCopyN(hhDriver->achAreaCode, hhDriver->achDefaultAreaCode,
            sizeof(hhDriver->achAreaCode) / sizeof(TCHAR));
        }

    SetWindowText(hwndCB, hhDriver->achAreaCode);
    return 0;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EnumerateLines
 *
 * DESCRIPTION:
 *	Enumerates available lines.  If hwndCB is non-zero, loads names.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *	hwndCB		- combo box
 *
 * RETURNS:
 *	0=success, -1=error
 *
 */
int EnumerateLines(const HHDRIVER hhDriver, const HWND hwndCB)
    {
    int             fHotPhone;
    int             fRet;
    DWORD           i;
    DWORD           dwSize;
    DWORD           dwAPIVersion;
    LINEEXTENSIONID LnExtId;
    LPLINEDEVCAPS   pLnDevCaps = NULL;
    PSTLINEIDS	    pstLineIds = NULL;
    TCHAR *         pachLine;
    TCHAR           achLine[256];
    TCHAR           ach[256];
    LRESULT         lr;

    if (hhDriver == 0)
        {
        return -1;
        }

    // This call knows to free the itemdata associated with this combo.
    //
    mscResetComboBox(hwndCB);

    /* --- Initialize stuff --- */

    pLnDevCaps = 0;
    hhDriver->dwLine = (DWORD)-1;
    hhDriver->fMatchedPermanentLineID = FALSE;

    /* --- Enumerate the devices --- */

    for (i = 0 ; i < hhDriver->dwLineCnt ; ++i)
    	{
    	if (lineNegotiateAPIVersion(hhDriver->hLineApp, i, TAPI_VER,
    			TAPI_VER, &dwAPIVersion, &LnExtId) != 0)
    		{
            // Could be a 1.3 driver, we continue.
    		continue;
    		}

        fRet = CheckHotPhone(hhDriver, i, &fHotPhone);
        if (fRet < 0)
            {
    		assert(0);
            continue;
            }
        else if (fRet == 0 && fHotPhone)
            {
    		continue;
    		}

    	if ((pLnDevCaps = malloc(sizeof(LINEDEVCAPS))) == 0)
    		{
    		assert(0);
    		continue;
    		}

    	// TAPI says its too small if we just allocate sizeof(LINEDEVCAPS)
    	//
    	memset( pLnDevCaps, 0, sizeof(LINEDEVCAPS) );
		pLnDevCaps->dwTotalSize = sizeof(LINEDEVCAPS);

    	/* --- Make call to find out how much we need for this device --- */

    	if (TRAP(lineGetDevCaps(hhDriver->hLineApp, i, dwAPIVersion, 0,
    			pLnDevCaps)) != 0)
    		{
    		assert(0);
    		continue;
    		}

    	/* --- Find out how big structure really needs to be --- */

    	if (pLnDevCaps->dwNeededSize > pLnDevCaps->dwTotalSize)
    		{
    		dwSize = pLnDevCaps->dwNeededSize;
    		free(pLnDevCaps);
  		    pLnDevCaps = NULL;

    		pLnDevCaps = malloc(dwSize);

    		if (pLnDevCaps == 0)
    			{
    			assert(FALSE);
    			continue;
    			}

    		pLnDevCaps->dwTotalSize = dwSize;

    		/* --- Try again --- */

    	    if (lineGetDevCaps(hhDriver->hLineApp, i, dwAPIVersion, 0,
    			    pLnDevCaps) != 0)
    			{
    			assert(FALSE);
    			free(pLnDevCaps);
                pLnDevCaps = NULL;
    			continue;
    			}
    		}

    	/* --- Check the information we're interested in --- */

        //mpt:03-19-98 added a MaxRate check to eliminate the MS VPN adapter
        //             from the list of available devices.
    	//mpt 06-23-98 added a MaxNumActiveCalls check to eliminate the
    	//             H323 and Line0 devices from showing up in our list
        if (pLnDevCaps->dwLineNameSize == 0 ||
    		(pLnDevCaps->dwMaxRate == 0 || pLnDevCaps->dwMaxRate >= 1048576) ||
    		(pLnDevCaps->dwMaxNumActiveCalls > 1 && pLnDevCaps->dwMaxNumActiveCalls != 32768) )
    		{
    		free(pLnDevCaps);
  		    pLnDevCaps = NULL;
    		continue;
    		}

    	pachLine = (BYTE *)pLnDevCaps + pLnDevCaps->dwLineNameOffset;
   		if (pLnDevCaps->dwLineNameSize)
            MemCopy(achLine, pachLine, pLnDevCaps->dwLineNameSize);
    	achLine[pLnDevCaps->dwLineNameSize] = TEXT('\0');

    	/* --- Put name in combo box if given one --- */

    	if (IsWindow(hwndCB))
    		{
    		// I need to associate two pieces of data with each
    		// item (permanent line id and relative line id).  Both
    		// are double words and CB_SETITEMDATA only stores a
    		// a double word.  So malloc a structure to hold both
    		// ids and store a pointer to the memory in the combobox.
    		// Call the mscResetComboBox() defined in the file to reset
    		// the contents of the combobox and free the associated
    		// memory.  mscResetComboBox() is also called in the dialog
    		// destroy.
    		//
    		pstLineIds = malloc(sizeof(*pstLineIds));

    		if (pstLineIds == 0)
    			{
    			assert(FALSE);
    			free(pLnDevCaps);
                pLnDevCaps = NULL;
    			continue;
    			}

    		pstLineIds->dwLineId = i;
    		pstLineIds->dwPermanentLineId = pLnDevCaps->dwPermanentLineID;

    		// Add the name to the combobox.  Since names are sorted,
    		// the index of the item is returned from SendMessage and
    		// stored in lr.  Save this index for use below.
    		//
    		lr = SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM)achLine);

    		if (lr != CB_ERR)
    			{
    			// Note: lr was set above CB_ADDSTRING call.
    			//
    			if (SendMessage(hwndCB, CB_SETITEMDATA, (WPARAM)lr,
    					(LPARAM)pstLineIds) == CB_ERR)
    				{
    				assert(FALSE);
    				free(pstLineIds);
    				free(pLnDevCaps);
  				    pstLineIds = NULL;
  				    pLnDevCaps = NULL;
    				continue;
    				}
    			}

    		else
    			{
    			free(pstLineIds);
    			free(pLnDevCaps);
  			    pstLineIds = NULL;
  			    pLnDevCaps = NULL;
    			continue;
    			}
    		}

		//
		// Only set the Modem as a match if the line device's
		// dwPermanentLineID is the same as the drivers dwPermanentLineId.
		//
		// NOTE: We will set the default in the property page if a match
		// is not found in this function. REV: 11/5/2001
		//
    	if (pLnDevCaps->dwPermanentLineID == hhDriver->dwPermanentLineId) //||
    			//hhDriver->dwLine == (DWORD)-1)
    		{
    		hhDriver->dwLine = i;
    		hhDriver->dwAPIVersion = dwAPIVersion;
    		StrCharCopyN(hhDriver->achLineName, achLine,
                sizeof(hhDriver->achLineName) / sizeof(TCHAR));

    		if (IsWindow(hwndCB))
    			{
    			// Note: lr was set above CB_ADDSTRING call.
    			//
    			SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)lr, 0);
    			}

    		if (pLnDevCaps->dwPermanentLineID == hhDriver->dwPermanentLineId)
				{
    			hhDriver->fMatchedPermanentLineID = TRUE;
				}
    		}

    	/* --- Free allocated space --- */

    	free(pLnDevCaps);
  	    pLnDevCaps = NULL;
    	}

    // Load the direct to com port stuff first

    if (LoadString(glblQueryDllHinst(), IDS_CNCT_DIRECTCOM, achLine,
    	    sizeof(achLine) / sizeof(TCHAR)) == 0)
        {
        assert(FALSE);
        // The loading of the string has failed from the resource, so
        // add the non-localized string here (I don't believe this string
        // is ever translated). REV 8/13/99
        //
        StrCharCopyN(achLine, TEXT("Direct to Com%d"), sizeof(achLine) / sizeof(TCHAR));
        //return -1;
        }

    // Another nasty bug, DIRECT_COM4 is defined as 0x5A2175d4, which
    // makes this one heck of a loop. I think we only want to do this
    // four times (as opposed to 1.5 billion). - cab:11/14/96
    //
    // for (i = 0 ; i < DIRECT_COM4 ; ++i)
    //
    for( i = 0; i < 4; i++ )
        {
    	wsprintf(ach, achLine, i+1);

    	if (IsWindow(hwndCB))
            {
    	    lr = SendMessage(hwndCB, CB_INSERTSTRING, (WPARAM)-1,
    		    (LPARAM)ach);

    	    pstLineIds = malloc(sizeof(*pstLineIds));

    	    if (pstLineIds == 0)
    		    {
    		    assert(FALSE);
    		    continue;
    		    }

    	    // We don't use a line id here, only a permanent line id.
    	    //
    	    pstLineIds->dwPermanentLineId = DIRECT_COM1+i;

    		// Note: lr was set above CB_INSERTSTRING call.
    	    //
    	    if (SendMessage(hwndCB, CB_SETITEMDATA, (WPARAM)lr,
    			    (LPARAM)pstLineIds) == CB_ERR)
    		    {
    		    assert(FALSE);
    		    free(pstLineIds);
                pstLineIds = NULL;
    		    continue;
    		    }
            }

    	// If this is what was saved in the data file, then set
    	// the line ids.
        //
		// Only set the serial port as a match if the drivers
		// dwPermanentLineId is equal to DIRECT_COM1+i.
		//
		// Since dwPermanentLineId is unique on Win9.x so we don't need to
		// set the driver's name to the serial port's name. REV: 4/15/2002
		//
		// NOTE: We will set the default in the property page if a match
		// is not found in this function. REV: 11/5/2001
		//
   		if ((DIRECT_COM1+i) == hhDriver->dwPermanentLineId) //||
    			//hhDriver->dwLine == (DWORD)-1)
			{
    		hhDriver->dwLine = 0;
    		StrCharCopyN(hhDriver->achLineName, ach,
				sizeof(hhDriver->achLineName) / sizeof(TCHAR));

			if (IsWindow(hwndCB))
    			{
    			// Note: lr was set above CB_ADDSTRING call.
    			//
    			SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)lr, 0);
    			}

			hhDriver->fMatchedPermanentLineID = TRUE;
			}
    	}

#if defined(INCL_WINSOCK)
    // This is causing a syntax error, so I am fixing it. Why nobody
    // found this sooner, I have no idea. - cab:11/14/96
    //
    //if (LoadString(glblQueryDllHinst(), IDS_WINSOCK_SETTINGS_STR, ach,
    //    sizeof(ach));
    //
    if (LoadString(glblQueryDllHinst(), IDS_WINSOCK_SETTINGS_STR, ach,
            sizeof(ach) / sizeof(TCHAR)) == 0)
        {
        assert(FALSE);
        // The loading of the string has failed from the resource, so
        // add the non-localized string here (I don't believe this string
        // is ever translated). REV 8/13/99
        //
        StrCharCopyN(ach, TEXT("TCP/IP (Winsock)"), sizeof(ach) / sizeof(TCHAR));
        //return -1;
        }

    if (IsWindow(hwndCB))
        {
    	lr = SendMessage(hwndCB, CB_INSERTSTRING, (WPARAM)-1,
    		(LPARAM)ach);

    	pstLineIds = malloc(sizeof(*pstLineIds));

    	if (pstLineIds == 0)
    		{
    		assert(FALSE);
    		free(pstLineIds);
  		    pstLineIds = NULL;
    		return 0;
    		}

    	// We don't use a line id here, only a permanent line id.
    	//
    	pstLineIds->dwPermanentLineId = DIRECT_COMWINSOCK;

    	// Note: lr was set above CB_INSERTSTRING call.
    	//
    	if (SendMessage(hwndCB, CB_SETITEMDATA, (WPARAM)lr,
    			(LPARAM)pstLineIds) == CB_ERR)
    		{
    		assert(FALSE);
    		}
        }

    // Check to see if the current connection is winsock. - cab:11/15/96
    //
	// Only set the Winsock(TCP/IP) as a match if the drivers
	// dwPermanentLineId is DIRECT_COMWSOCK.
	//
	// NOTE: We will set the default in the property page if a match
	// is not found in this function. REV: 11/5/2001
	//
    if (DIRECT_COMWINSOCK == hhDriver->dwPermanentLineId) //||
    	//hhDriver->dwLine == (DWORD)-1)
    	{
    	hhDriver->dwLine = 0;
    	StrCharCopyN(hhDriver->achLineName, ach, sizeof(hhDriver->achLineName) / sizeof(TCHAR));

    	if (IsWindow(hwndCB))
    		{
    		// Note: lr was set above CB_INSERTSTRING call.
    		//
    		SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)lr, 0);
    		}

    	if (DIRECT_COMWINSOCK == hhDriver->dwPermanentLineId)
            {
    		hhDriver->fMatchedPermanentLineID = TRUE;
            }

        // Don't free the pstLineIds since it will be freed in the
  	    // mscResetComboBox() function.  We were previously freeing the
  	    // memory twice causing a crash with the MSVC 6.0 runtime DLL's.
  	    // I'm suprised this did not present itself earlier. REV 8/17/98
  	    //
        //free(pstLineIds);
        }
#endif

    return 0;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EnumerateLinesNT
 *
 * DESCRIPTION:
 *	Enumerates available lines.  This function is similar to EnumerateLines, but
 *  we use different methods to enumerate the ports under Windows NT.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *	hwndCB		- combo box
 *
 * RETURNS:
 *	0=success, -1=error
 *
 */
int EnumerateLinesNT(const HHDRIVER hhDriver, const HWND hwndCB)
    {
    int             fHotPhone;
    int             fRet;
    DWORD           i;
    DWORD           dwSize;
    DWORD           dwAPIVersion;
    LINEEXTENSIONID LnExtId;
    LPLINEDEVCAPS   pLnDevCaps = NULL;
    PSTLINEIDS	    pstLineIds = NULL;
    TCHAR *         pachLine;
    TCHAR           achLine[256];
    TCHAR           ach[256];
    TCHAR           ab[256];
    LRESULT         lr;
    LRESULT         nNumberItemInList = 0;
    HKEY            hKey;
    LONG            retval;
    DWORD           dwType;
    DWORD           dwSizeBuf;
    DWORD           iMaxComPortEnum = SHRT_MAX;   // Make sure we have a
                                                  // limit on the number of
                                                  // ports we enumerate so
                                                  // that we don't get into
                                                  // an endless loop.  SHRT_MAX
                                                  // is the scroll bar maximum
                                                  // used in the combo box
                                                  // dropdown list.
                                                  // REV: 11/14/2000.
    if (hhDriver == 0)
        {
        return -1;
        }

    // This call knows to free the itemdata associated with this combo.
    //
    mscResetComboBox(hwndCB);

    /* --- Initialize stuff --- */

    pLnDevCaps = 0;
    if ( StrCharCmp(hhDriver->achLineName, "") == 0 )
        {
        hhDriver->dwLine = (DWORD)-1;
        }
    else
        {
        hhDriver->dwLine = 0;
        }

    hhDriver->fMatchedPermanentLineID = FALSE;

    /* --- Enumerate the devices --- */

    for (i = 0 ; i < hhDriver->dwLineCnt ; ++i)
    	{
    	if (retval = lineNegotiateAPIVersion(hhDriver->hLineApp, i, TAPI_VER,
    			TAPI_VER, &dwAPIVersion, &LnExtId) != 0)
    		{
            // Could be a 1.3 driver, we continue.
    		continue;
    		}

        fRet = CheckHotPhone(hhDriver, i, &fHotPhone);
        if (fRet < 0)
            {
    		assert(0);
            continue;
            }
        else if (fRet == 0 && fHotPhone)
            {
    		continue;
    		}

    	if ((pLnDevCaps = malloc(sizeof(LINEDEVCAPS))) == 0)
    		{
    		assert(0);
    		continue;
    		}

        if (hhDriver->hLineApp == 0)
            {
    		assert(FALSE);
            continue;
            }

    	// TAPI says its too small if we just allocate sizeof(LINEDEVCAPS)
    	//
    	pLnDevCaps->dwTotalSize = sizeof(LINEDEVCAPS);

    	/* --- Make call to find out how much we need for this device --- */

    	if (TRAP(lineGetDevCaps(hhDriver->hLineApp, i, dwAPIVersion, 0,
    			pLnDevCaps)) != 0)
    		{
    		assert(0);
    		continue;
    		}

    	/* --- Find out how big structure really needs to be --- */

    	if (pLnDevCaps->dwNeededSize > pLnDevCaps->dwTotalSize)
    		{
    		dwSize = pLnDevCaps->dwNeededSize;
    		free(pLnDevCaps);
  		    pLnDevCaps = NULL;

    		pLnDevCaps = malloc(dwSize);

    		if (pLnDevCaps == 0)
    			{
    			assert(FALSE);
    			continue;
    			}

    		pLnDevCaps->dwTotalSize = dwSize;

    		/* --- Try again --- */

    		if (lineGetDevCaps(hhDriver->hLineApp, i, dwAPIVersion, 0,
    				pLnDevCaps) != 0)
    			{
    			assert(FALSE);
    			continue;
    			}
    		}

    	/* --- Check the information we're interested in --- */

        //mpt:03-19-98 added a MaxRate check to eliminate the MS VPN adapter
        //             from the list of available devices.
    	//mpt 06-23-98 added a MaxNumActiveCalls check to eliminate the
    	//             H323 and Line0 devices from showing up in our list
        if (pLnDevCaps->dwLineNameSize == 0 ||
    		(pLnDevCaps->dwMaxRate == 0 || pLnDevCaps->dwMaxRate >= 1048576) ||
    		(pLnDevCaps->dwMaxNumActiveCalls > 1 && pLnDevCaps->dwMaxNumActiveCalls != 32768) )
    		{
    		free(pLnDevCaps);
  		    pLnDevCaps = NULL;
    		continue;
    		}

    	pachLine = (BYTE *)pLnDevCaps + pLnDevCaps->dwLineNameOffset;
   		if (pLnDevCaps->dwLineNameSize)
            MemCopy(achLine, pachLine, pLnDevCaps->dwLineNameSize);
    	
        achLine[pLnDevCaps->dwLineNameSize] = TEXT('\0');

    	/* --- Put name in combo box if given one --- */

    	if (IsWindow(hwndCB))
    		{
    		// I need to associate two pieces of data with each
    		// item (permanent line id and relative line id).  Both
    		// are double words and CB_SETITEMDATA only stores a
    		// a double word.  So malloc a structure to hold both
    		// ids and store a pointer to the memory in the combobox.
    		// Call the mscResetComboBox() defined in the file to reset
    		// the contents of the combobox and free the associated
    		// memory.  mscResetComboBox() is also called in the dialog
    		// destroy.
    		//
    		pstLineIds = malloc(sizeof(*pstLineIds));

    		if (pstLineIds == 0)
    			{
    			assert(FALSE);
    			free(pLnDevCaps);
  			    pLnDevCaps = NULL;
    			continue;
    			}

    		pstLineIds->dwLineId = i;
    		pstLineIds->dwPermanentLineId = pLnDevCaps->dwPermanentLineID;

    		// Add the name to the combobox.  Since names are sorted,
    		// the index of the item is returned from SendMessage and
    		// stored in lr.  Save this index for use below.
    		//
    		lr = SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM)achLine);

    		if (lr != CB_ERR && lr != CB_ERRSPACE)
    			{
                nNumberItemInList++;

    			// Note: lr was set above CB_ADDSTRING call.
    			//
    			if (SendMessage(hwndCB, CB_SETITEMDATA, (WPARAM)lr,
    					(LPARAM)pstLineIds) == CB_ERR)
    				{
    				assert(FALSE);
    				free(pstLineIds);
    				free(pLnDevCaps);
  				    pstLineIds = NULL;
  				    pLnDevCaps = NULL;
    				continue;
    				}
    			}

    		else
    			{
    			free(pstLineIds);
    			free(pLnDevCaps);
  			    pstLineIds = NULL;
  			    pLnDevCaps = NULL;
    			continue;
    			}
    		}

		//
		// Only set the Modem as a match if the line device's
		// dwPermanentLineID is the same as the drivers dwPermanentLineId.
		//
		// NOTE: We will set the default in the property page if a match
		// is not found in this function. REV: 11/5/2001
		//
    	if (pLnDevCaps->dwPermanentLineID == hhDriver->dwPermanentLineId) //||
    		//hhDriver->dwLine == (DWORD)-1)
    		{
    		hhDriver->dwLine = i;
    		hhDriver->dwAPIVersion = dwAPIVersion;
    		StrCharCopyN(hhDriver->achLineName, achLine,
                sizeof(hhDriver->achLineName) / sizeof(TCHAR));

    		if (IsWindow(hwndCB))
    			{
    			// Note: lr was set above CB_ADDSTRING call.
    			//
    			SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)lr, 0);
    			}

    		if (pLnDevCaps->dwPermanentLineID == hhDriver->dwPermanentLineId)
    			hhDriver->fMatchedPermanentLineID = TRUE;
    		}

    	/* --- Free allocated space --- */

    	free(pLnDevCaps);
  	    pLnDevCaps = NULL;
    	}

    // Load the direct to com port stuff first

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
    	             TEXT("hardware\\devicemap\\serialcomm"),
					 0, KEY_READ, &hKey) != ERROR_SUCCESS)
    	{
    	assert(FALSE);
        // We used to return FALSE here which would mean the TCP/IP
        // would not be in the enumerated connection methods (modem,
        // COM port or Winsock) in the "Connect Using:" dropdown
        // combobox in the properties for the entries.  Since the
        // return value was never checked, we can just continue on
        // to finish the enumerations for the combobox.  Now we just
        // set the number of COM ports to enumerate to 0. REV 8/13/99.
        //
        //return FALSE;
        iMaxComPortEnum = 0;
    	}

    // Make sure we don't enumerate mar than the maximum number of ports
    // minus the number of TAPI devices.  If we are including WINSOCK, then
    // subtract 1 for the TCP/IP (WinSock) combobox item.

    #if defined(INCL_WINSOCK)
    iMaxComPortEnum = iMaxComPortEnum - (DWORD)nNumberItemInList - 1;
    #else
    iMaxComPortEnum = iMaxComPortEnum - (DWORD)nNumberItemInList;
    #endif


    // We now use a variable for the number of drives to enumerate.
    // We have set the number of COM ports to enumerate in a variable
    // above (iMaxComPortEnum == 0 if no COM ports installed). REV 8/13/99.
    //
    for (i = 0 ; i < iMaxComPortEnum ; ++i)
        {
        dwSizeBuf = sizeof(ab) / sizeof(TCHAR);
        dwSize = sizeof(ach) / sizeof(TCHAR);

        // Enumerate devices under our serialcomm key
        //
        if (RegEnumValue(hKey, i, ach, &dwSize, 0, &dwType, ab,
            &dwSizeBuf) != ERROR_SUCCESS)
            {
            break;
            }

        // Ignore anything that isn't a string.
        //
        if (dwType != REG_SZ)
            continue;

    	if (IsWindow(hwndCB))
            {
    	    lr = SendMessage(hwndCB, CB_INSERTSTRING, (WPARAM)-1,
    		    (LPARAM)ab);

            //
            // See if an error occured due to out of memory.  If so,
            // then don't enumerate any more ports.  REV: 11/15/2000
            //
            if( lr == CB_ERRSPACE || lr == CB_ERR )
                {
                break;
                }

            nNumberItemInList++;

    	    pstLineIds = malloc(sizeof(*pstLineIds));

    	    if (pstLineIds == 0)
    		    {
    		    assert(FALSE);
    		    continue;
    		    }

    	    // We don't use a line id here, only a permanent line id.
    	    //
            pstLineIds->dwPermanentLineId = DIRECT_COM_DEVICE;

    	    // Note: lr was set above CB_INSERTSTRING call.
    	    //
    	    if (SendMessage(hwndCB, CB_SETITEMDATA, (WPARAM)lr,
    			    (LPARAM)pstLineIds) == CB_ERR)
    		    {
    		    assert(FALSE);
    		    free(pstLineIds);
                pstLineIds = NULL;
    		    continue;
    		    }
            }

        //
		// Only set the serial port as a match if the drivers
		// dwPermanentLineId is equal to DIRECT_COM_DEVICE or
		// in the range from DIRECT_COM1 to DIRECT_COM4 and the
		// driver's name is the same as the serial port's name.
		//
		// NOTE: We will set the default in the property page if a match
		// is not found in this function. REV: 11/5/2001
		//
        if ( hhDriver->fMatchedPermanentLineID == FALSE &&
    	     StrCharCmp(hhDriver->achComDeviceName, ab) == 0 &&
			 ( //hhDriver->dwPermanentLineId == (DWORD)-1 ||
               IN_RANGE(hhDriver->dwPermanentLineId, DIRECT_COM1, DIRECT_COM4) ||
               hhDriver->dwPermanentLineId == DIRECT_COM_DEVICE ) )
            {
    		hhDriver->dwLine = 0;
    		StrCharCopyN(hhDriver->achLineName, ab,
                sizeof(hhDriver->achLineName) / sizeof(TCHAR));

    		if (IsWindow(hwndCB))
    			{
    			// Note: lr was set above CB_ADDSTRING call.
    			//
    			SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)lr, 0);
    			}

    		hhDriver->fMatchedPermanentLineID = TRUE;
            }
    	}

#if defined(INCL_WINSOCK)
    // This is causing a syntax error, so I am fixing it. Why nobody
    // found this sooner, I have no idea. - cab:11/14/96
    //
    //if (LoadString(glblQueryDllHinst(), IDS_WINSOCK_SETTINGS_STR, ach,
    //    sizeof(ach));
    //
    if (LoadString(glblQueryDllHinst(), IDS_WINSOCK_SETTINGS_STR, ach,
            sizeof(ach) / sizeof(TCHAR)) == 0)
        {
        assert(FALSE);
        // The loading of the string has failed from the resource, so
        // add the non-localized string here (I don't believe this string
        // is ever translated). REV 8/13/99
        //
        StrCharCopyN(ach, TEXT("TCP/IP (Winsock)"), sizeof(ach) / sizeof(TCHAR));
        //return -1;
        }

    if (IsWindow(hwndCB))
        {
    	lr = SendMessage(hwndCB, CB_INSERTSTRING, (WPARAM)-1,
    		(LPARAM)ach);

        //
        // See if an error occured due to out of memory.  If so,
        // then delete the last COM port added so there is room
        // for the TCP/IP (Winsock) item.  REV: 11/15/2000
        //
        if( lr == CB_ERRSPACE )
            {
            lr = SendMessage(hwndCB, CB_DELETESTRING, (WPARAM)nNumberItemInList - 1,
                (LPARAM)0);

    	    lr = SendMessage(hwndCB, CB_INSERTSTRING, (WPARAM)-1,
    		    (LPARAM)ach);
            }

        if (lr != CB_ERR && lr != CB_ERRSPACE)
            {
    	    pstLineIds = malloc(sizeof(*pstLineIds));

    	    if (pstLineIds == 0)
    		    {
    		    assert(FALSE);
    		    free(pstLineIds);
                pstLineIds = NULL;
    		    return 0;
    		    }

            // We don't use a line id here, only a permanent line id.
            //
            pstLineIds->dwPermanentLineId = DIRECT_COMWINSOCK;

            // Note: lr was set above CB_INSERTSTRING call.
            //
            if (SendMessage(hwndCB, CB_SETITEMDATA, (WPARAM)lr,
    		        (LPARAM)pstLineIds) == CB_ERR)
    	        {
    	        assert(FALSE);
    	        }
            }
        }


    // Check to see if the current connection is winsock. - cab:11/15/96
    //
	// Only set the Winsock(TCP/IP) as a match if the drivers
	// dwPermanentLineId is DIRECT_COMWSOCK.
	//
	// NOTE: We will set the default in the property page if a match
	// is not found in this function. REV: 11/5/2001
	//
    if (DIRECT_COMWINSOCK == hhDriver->dwPermanentLineId) //||
    	//hhDriver->dwLine == (DWORD)-1)
    	{
    	hhDriver->dwLine = 0;
    	StrCharCopyN(hhDriver->achLineName, ach,
            sizeof(hhDriver->achLineName) / sizeof(TCHAR));

    	if (IsWindow(hwndCB))
    		{
    		// Note: lr was set above CB_INSERTSTRING call.
    		//
    		SendMessage(hwndCB, CB_SETCURSEL, (WPARAM)lr, 0);
    		}

    	if (DIRECT_COMWINSOCK == hhDriver->dwPermanentLineId)
            {
    		hhDriver->fMatchedPermanentLineID = TRUE;
            }

        // Don't free the pstLineIds since it will be freed in the
  	    // mscResetComboBox() function.  We were previously freeing the
  	    // memory twice causing a crash with the MSVC 6.0 runtime DLL's.
  	    // I'm suprised this did not present itself earlier. REV 8/17/98
  	    //
  	    //free(pstLineIds);
        }
#endif

    return 0;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DoLineGetCountry
 *
 * DESCRIPTION:
 *	Wrapper indended to query for a single country.  The caller must
 *	free the pcl when finished.
 *
 * ARGUMENTS:
 *	dwCountryID - ID of country
 *	dwApiVersion - Api version (no longer used)
 *	ppcl		- pointer to a LPLINECOUNTRYLIST
 *
 * RETURNS:
 *	0=OK
 *
 */
int DoLineGetCountry(const DWORD dwCountryID, const DWORD dwAPIVersion,
        LPLINECOUNTRYLIST *ppcl)
    {
    DWORD dwSize;
    LPLINECOUNTRYLIST pcl = NULL;

    if ((pcl = malloc(sizeof(LINECOUNTRYLIST))) == 0)
    	{
    	assert(FALSE);
    	return -1;
    	}

    pcl->dwTotalSize = sizeof(LINECOUNTRYLIST);

    if (lineGetCountry(dwCountryID, TAPI_VER, pcl) != 0)
    	{
    	assert(FALSE);
    	free(pcl);
  	    pcl = NULL;
    	return -1;
    	}

    if (pcl->dwNeededSize > pcl->dwTotalSize)
    	{
    	dwSize = pcl->dwNeededSize;
    	free(pcl);
  	    pcl = NULL;

    	if ((pcl = malloc(dwSize)) == 0)
    		{
    		assert(FALSE);
    		return -1;
    		}

    	pcl->dwTotalSize = dwSize;

    	if (lineGetCountry(dwCountryID, TAPI_VER, pcl) != 0)
    		{
    		assert(FALSE);
    		free(pcl);
  		    pcl = NULL;
    		return -1;
    		}
    	}

    *ppcl = pcl;
    return 0;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	cnctdrvGetComSettingsString
 *
 * DESCRIPTION:
 *	Retrieves a string formatted for display on the status line.
 *
 * ARGUMENTS:
 *	hhDriver	- private driver handle
 *	pachStr 	- buffer to store string
 *	cb			- size of buffer
 *
 * RETURNS:
 *	0=OK,else error
 *
 */
int cnctdrvGetComSettingsString(const HHDRIVER hhDriver, LPTSTR pachStr,
    							const size_t cb)
    {
    static CHAR acParity[] = "NOEMS";  // see com.h
    static CHAR *pachStop[] = {"1", "1.5", "2"};
    HCOM         hCom;
    TCHAR        ach[100];
    LPVARSTRING  pvs = NULL;
    int          fAutoDetect = FALSE;
    long         lBaud = 0;
    int          iDataBits = 8;
    int          iParity = 0;
    int          iStopBits = 0;
	#if defined(MODEM_NEGOTIATED_DCE_RATE) // TODO:REV 5/29/2002 
	long         lNegBaud = 0;
	#endif // defined(MODEM_NEGOTIATED_DCE_RATE)

    // Check the parameters
    //
    if (hhDriver == 0)
    	{
    	assert(0);
    	return -1;
    	}

    if (pachStr == 0 || cb == 0)
    	{
    	assert(0);
    	return -2;
    	}

    ach[0] = TEXT('\0');

    if ((hCom = sessQueryComHdl(hhDriver->hSession)) == 0)
    	return -7;

//	//MPT:11-01-98 Microsoft made these changes to fix a bug relating
//	//             to working with multiple connection devices.
//	if (ComGetAutoDetect(hCom, &fAutoDetect) == COM_OK && fAutoDetect)
//		{
//		LoadString(glblQueryDllHinst(), IDS_STATUSBR_AUTODETECT, ach,
//			sizeof(ach) / sizeof(TCHAR));
//		}
#if defined(INCL_WINSOCK)
    /*else*/ if (hhDriver->dwPermanentLineId == DIRECT_COMWINSOCK)
        {
        // Baud rate, data bits, parity, stop bits don't make sense in
        // TCP/IP. Load an alternate string.
        //
        LoadString(glblQueryDllHinst(), IDS_STATUSBR_COM_TCPIP, ach,
            sizeof(ach) / sizeof(TCHAR));
        }
#endif
    else if (IN_RANGE(hhDriver->dwPermanentLineId, DIRECT_COM1, DIRECT_COM4)
            || hhDriver->dwPermanentLineId == DIRECT_COM_DEVICE)
    	{
    	ComGetBaud(hCom, &lBaud);
    	ComGetDataBits(hCom, &iDataBits);
    	ComGetParity(hCom, &iParity);
    	ComGetStopBits(hCom, &iStopBits);

    	wsprintf(ach, "%ld %d-%c-%s", lBaud, iDataBits,
    			acParity[iParity], pachStop[iStopBits]);
    	}

    // Usual lines of code for a TAPI call
    //
    else if (hhDriver->dwLine != (DWORD)-1)
    	{
        int   retValue = 0;

        iDataBits = 8;
        iParity = NOPARITY;
        iStopBits = ONESTOPBIT;

        retValue = cncttapiGetLineConfig( hhDriver->dwLine, (VOID **) &pvs);

        if (retValue != 0)
            {
            return retValue;
            }
        else
    	    {
            // The structure of the DevConfig block is as follows
            //
            //	VARSTRING
            //	UMDEVCFGHDR
            //	COMMCONFIG
            //	MODEMSETTINGS
            //
            // The UMDEVCFG structure used below is defined in the
            // UNIMODEM.H provided in the platform SDK (in the nih
            // directory for HTPE). REV: 12/01/2000 
            //
    	    PUMDEVCFG pDevCfg = NULL;
        
            pDevCfg = (UMDEVCFG *)((BYTE *)pvs + pvs->dwStringOffset);

    		// commconfig struct has a DCB structure we dereference for the
    		// com settings.
    		//
			lBaud = pDevCfg->commconfig.dcb.BaudRate;
			iDataBits = pDevCfg->commconfig.dcb.ByteSize;
			iParity = pDevCfg->commconfig.dcb.Parity;
			iStopBits = pDevCfg->commconfig.dcb.StopBits;

			#if defined(MODEM_NEGOTIATED_DCE_RATE) // TODO:REV 5/29/2002 
			//
			// See if this is a modem connection and connected, then get
			// the negotiated baud rate instead of the default max rate
			// the modem is set up for. -- REV: 5/29/2002
			//
			if (pDevCfg->commconfig.dwProviderSubType == PST_MODEM)
				{
				MODEMSETTINGS * pModemSettings = (MODEMSETTINGS *)pDevCfg->commconfig.wcProviderData;

				if (pModemSettings)
					{
					lNegBaud = pModemSettings->dwNegotiatedDCERate;
					}
				}
			#endif // defined(MODEM_NEGOTIATED_DCE_RATE)
            }

		#if defined(MODEM_NEGOTIATED_DCE_RATE) // TODO:REV 5/29/2002 
		if (lNegBaud > 0)
			{
			wsprintf(ach, "%ld %d-%c-%s", lNegBaud, iDataBits,
					 acParity[iParity], pachStop[iStopBits]);
			}
		else
			{
			wsprintf(ach, "%ld %d-%c-%s", lBaud, iDataBits,
					 acParity[iParity], pachStop[iStopBits]);
			}
		#else // defined(MODEM_NEGOTIATED_DCE_RATE)
		wsprintf(ach, "%ld %d-%c-%s", lBaud, iDataBits,
					 acParity[iParity], pachStop[iStopBits]);
		#endif //defined(MODEM_NEGOTIATED_DCE_RATE)
    	}

	// Moved this test to last so any change from 8N1 will not show auto-detect jkh 9/9/98
    if (iDataBits == 8 && iParity == NOPARITY && iStopBits == ONESTOPBIT &&
			ComGetAutoDetect(hCom, &fAutoDetect) == COM_OK && fAutoDetect)
    	{
    	LoadString(glblQueryDllHinst(), IDS_STATUSBR_AUTODETECT, ach,
    		sizeof(ach) / sizeof(TCHAR));
    	}

    StrCharCopyN(pachStr, ach, cb);
    pachStr[cb-1] = TEXT('\0');
    free(pvs);
    pvs = NULL;

    return 0;
    }

#if !defined(NDEBUG)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	tapiTrap
 *
 * DESCRIPTION:
 *	Trap TAPI error conditions.
 *
 * ARGUMENTS:
 *	dw	- result code from tapi
 *	file - file where error occured
 *	line - line where error occured
 *
 * RETURNS:
 *	dw
 *
 */
DWORD tapiTrap(const DWORD dw, const TCHAR *file, const int line)
    {
    char ach[256];

    if (dw != 0)
    	{
    	wsprintf(ach, "TAPI returned %x on line %d of file %s", dw, line, file);
    	MessageBox(NULL, ach, "TAPI Trap", MB_OK | MB_ICONINFORMATION);
    	}

    return dw;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\comstd\comstd.c ===
/*  File: D:\WACKER\comstd\comstd.c (Created: 08-Dec-1993)
 *
 *  Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *  All rights reserved
 *
 *  $Revision: 35 $
 *  $Date: 7/12/02 8:06a $
 */
#define TAPI_CURRENT_VERSION 0x00010004     // cab:11/14/96 - required!

#include <windows.h>
#include <tapi.h>
#include <unimodem.h>
#include <time.h>
#pragma hdrstop

//#define     DEBUGSTR
//#define DEBUG_CHARDUMP

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\mc.h>
#include <tdll\sf.h>
#include <tdll\timers.h>
#include <tdll\com.h>
#include <tdll\comdev.h>
#include "comstd.hh"
#if defined(INCL_WINSOCK)
#include <comwsock\comwsock.hh>
#endif  // defined(INCL_WINSOCK)
#include <tdll\assert.h>
#include <tdll\statusbr.h>
#include <tdll\com.hh>
#include "rc_id.h"
#include <tdll\misc.h>  // IsNT()
#include <tdll\htchar.h>
#include <tdll\cnct.h>
#include <tdll\cnct.hh>
#include <cncttapi\cncttapi.h>
#include <cncttapi\cncttapi.hh>
#if defined(DEBUG_CHARDUMP)
    #include <stdio.h>
	FILE *pfDbgR = NULL;
    FILE *pfDbgC = NULL;
#endif

BOOL WINAPI ComStdEntry(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);
BOOL WINAPI _CRT_INIT(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);
static void DeviceBreakTimerProc(void *pvData, long ulSince); //mrw:6/15/95

HINSTANCE hinstDLL = (HINSTANCE)0;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *      very temporary - mrw
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int GetAutoDetect(ST_STDCOM *pstPrivate)
    {
    return pstPrivate->stWorkSettings.fAutoDetect;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  ComStdEntry
 *
 * DESCRIPTION:
 *  Currently, just initializes the C-Runtime library but may be used
 *  for other things later.
 *
 * ARGUMENTS:
 *  hInstDll    - Instance of this DLL
 *  fdwReason   - Why this entry point is called
 *  lpReserved  - reserved
 *
 * RETURNS:
 *  BOOL
 *
 */
BOOL WINAPI ComStdEntry(HINSTANCE hInst, DWORD fdwReason, LPVOID lpReserved)
    {
    hinstDLL = hInst;
    return _CRT_INIT(hInst, fdwReason, lpReserved);
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: DeviceInitialize
 *
 * DESCRIPTION:
 *  Called whenever the driver is being loaded
 *
 * ARGUMENTS:
 *  hCom               -- A copy of the com handle. Can be used in the
 *                          driver code to call com services
 *  usInterfaceVersion -- A version number identifying the version of the
 *                          driver interface
 *  ppvDriverData      -- A place to put the pointer to our private data.
 *                          This value will be passed back to us in all
 *                          subsequent calls.
 *
 * RETURNS:
 *  COM_OK if all is hunky dory
 *  COM_DEVICE_VERSION_ERROR if HA/Win expects a different interface version.
 *  COM_NOT_ENOUGH_MEMORY
 *  COM_DEVICE_ERROR if anything else goes wrong
 */
int WINAPI DeviceInitialize(HCOM hCom,
    unsigned nInterfaceVersion,
    void **ppvDriverData)
    {
    int        iRetVal = COM_OK;
    int        ix;
    ST_STDCOM *pstPrivate = NULL;

    //              Check version number and compatibility

    if (nInterfaceVersion != COM_VERSION)
        {
        // This error is reported by Com Routines. We cannot report errors
        // until after DeviceInitialize has completed.
        return COM_DEVICE_VERSION_ERROR;
        }

    if (*ppvDriverData)
        {
        pstPrivate = *ppvDriverData;
        }
    else
        {
        // Allocate our private storage structure
        if ((pstPrivate = malloc(sizeof(*pstPrivate))) == NULL)
			{
            return COM_NOT_ENOUGH_MEMORY;
			}

        *ppvDriverData = pstPrivate;

        // These members are common to both com drivers
        //
        pstPrivate->hCom = hCom;
        pstPrivate->fNotifyRcv = TRUE;
        pstPrivate->dwEventMask = 0;
        pstPrivate->fSending = FALSE;
        pstPrivate->lSndTimer = 0L;
        pstPrivate->lSndLimit = 0L;
        pstPrivate->lSndStuck = 0L;
        pstPrivate->hwndEvents = (HWND)0;
        pstPrivate->nRBufrSize = SIZE_INQ;
        pstPrivate->pbBufrStart = NULL;
        pstPrivate->fHaltThread = TRUE;

        InitializeCriticalSection(&pstPrivate->csect);
        for (ix = 0; ix < EVENT_COUNT; ++ix)
            {
            pstPrivate->ahEvent[ix] = CreateEvent(NULL,
												  TRUE,		// must be manually reset
												  FALSE,	// create unsignalled
												  NULL);	// unnamed
            if (pstPrivate->ahEvent[ix] == NULL)
                {
                iRetVal = COM_FAILED;
				//
				// Make sure to initialize the rest of the event handles to NULL;
				//
				for (++ix; ix < EVENT_COUNT; ++ix)
					{
					pstPrivate->ahEvent[ix] = NULL;
					}
                }
            }
        }

    // These members are specific to the stdcom driver
    //
    pstPrivate->bLastMdmStat = 0;
    pstPrivate->pbSndBufr = NULL;
    pstPrivate->nParityErrors = 0;
    pstPrivate->nFramingErrors = 0;
    pstPrivate->nOverrunErrors = 0;
    pstPrivate->nOverflowErrors = 0;

    pstPrivate->hWinComm = INVALID_HANDLE_VALUE;
    pstPrivate->fBreakSignalOn = FALSE;
    // Setup up reasonable default device values in case this type of
    //  device has not been used in a session before
    pstPrivate->stWorkSettings.lBaud          = 2400L;
    //pstPrivate->stWorkSettings.lBaud          = 9600L;
    pstPrivate->stWorkSettings.nDataBits      = 8;
    pstPrivate->stWorkSettings.nStopBits      = ONESTOPBIT;
    pstPrivate->stWorkSettings.nParity        = NOPARITY;
    pstPrivate->stWorkSettings.afHandshake    = HANDSHAKE_RCV_RTS | HANDSHAKE_SND_CTS;
    pstPrivate->stWorkSettings.chXON          = 0x11;
    pstPrivate->stWorkSettings.chXOFF         = 0x13;
    pstPrivate->stWorkSettings.nBreakDuration = 750;
    pstPrivate->stWorkSettings.fAutoDetect    = TRUE;
    pstPrivate->stFileSettings = pstPrivate->stWorkSettings;

    pstPrivate->fADRunning = FALSE;
    pstPrivate->nADTotal = 0;
    pstPrivate->nADMix = 0;
    pstPrivate->nAD7o1 = 0;
    pstPrivate->nADHighBits = 0;
    pstPrivate->nADBestGuess = AD_DONT_KNOW;
    pstPrivate->chADLastChar = '\0';
    pstPrivate->fADToggleParity = FALSE;
    pstPrivate->fADReconfigure = FALSE;

    pstPrivate->hComstdThread = NULL;

    if (iRetVal != COM_OK)
        {
        if (pstPrivate)
			{
            free(pstPrivate);
			pstPrivate = NULL;
			}
        }

    return iRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: DeviceClose
 *
 * DESCRIPTION:
 *  Called when HA/Win is done with this driver and is about to release .DLL
 *
 * ARGUMENTS:
 *  pstPrivate -- Pointer to our private data structure
 *
 * RETURNS:
 *  COM_OK
 */
int WINAPI DeviceClose(ST_STDCOM *pstPrivate)
    {
    int ix;

    // Driver is about to be let go, do any cleanup
    // Port should have been deactivated before we are called, but
    //  check anyway.
    PortDeactivate(pstPrivate);

    for (ix = 0; ix < EVENT_COUNT; ++ix)
        {
		if (pstPrivate->ahEvent[ix])
			{
			ResetEvent(pstPrivate->ahEvent[ix]);
			CloseHandle(pstPrivate->ahEvent[ix]);
			pstPrivate->ahEvent[ix] = NULL;
			}
        }

    DeleteCriticalSection(&pstPrivate->csect);
    // Free our private data area
    free(pstPrivate);
	pstPrivate = NULL;

    return COM_OK;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  ComLoadStdcomDriver
 *
 * DESCRIPTION:
 *  Loads the COM handle with pointers to the stdcom driver functions
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *  COM_OK		if successful
 *	COM_FAILED	otherwise
 *
 * AUTHOR:
 * mcc 12/26/95
 */
int ComLoadStdcomDriver(HCOM pstCom)
	{
	int	iRetVal = COM_OK;

	if ( !pstCom )
		return COM_FAILED;

	pstCom->pfPortActivate   = PortActivate;
	pstCom->pfPortDeactivate = PortDeactivate;
	pstCom->pfPortConnected  = PortConnected;
	pstCom->pfRcvRefill 	 = RcvRefill;
	pstCom->pfRcvClear		 = RcvClear;
	pstCom->pfSndBufrSend	 = SndBufrSend;
	pstCom->pfSndBufrIsBusy  = SndBufrIsBusy;
	pstCom->pfSndBufrClear	 = SndBufrClear;
	pstCom->pfSndBufrQuery	 = SndBufrQuery;
	pstCom->pfDeviceSpecial	 = DeviceSpecial;
	pstCom->pfPortConfigure	 = PortConfigure;
    pstCom->pfDeviceDialog   = DeviceDialog;

	return iRetVal;
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: DeviceDialog
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
/*lint ARGSUSED*/
int WINAPI DeviceDialog(ST_STDCOM *pstPrivate, HWND hwndParent)
    {
    int iRetValue = COM_OK;
    COMMCONFIG stCC;
    TCHAR szPortName[COM_MAX_PORT_NAME];

    memset(&stCC, 0, sizeof(stCC));
    stCC.dwSize = sizeof(stCC);
    stCC.wVersion = 1;
    stCC.dwProviderSubType = PST_RS232;
    ComGetPortName(pstPrivate->hCom, szPortName, COM_MAX_PORT_NAME);
    ComstdSettingsToDCB(&pstPrivate->stWorkSettings, &stCC.dcb);

    if (CommConfigDialog(szPortName, hwndParent, &stCC))
        {
        ComstdDCBToSettings(&stCC.dcb, &pstPrivate->stWorkSettings);
        }
    else
        {
        iRetValue = COM_CANCELLED;
		//DbgShowLastError();
        }

    return iRetValue;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: DeviceGetCommon
 *
 * DESCRIPTION:
 *  Gets user settings common to all drivers
 *
 * ARGUMENTS:
 *  pstPrivate -- Our private data structure
 *  pstcommon  -- Pointer to structure of type ST_COMMON to be filled in
 *                  with the desired settings
 *
 * RETURNS:
 *  Always returns COM_OK
 */
int WINAPI DeviceGetCommon(ST_STDCOM *pstPrivate, ST_COMMON *pstCommon)
    {
    pstCommon->afItem = (COM_BAUD |
             COM_DATABITS |
             COM_STOPBITS |
                         COM_PARITY |
                         COM_AUTO);
    pstCommon->lBaud           = pstPrivate->stWorkSettings.lBaud;
    pstCommon->nDataBits   = pstPrivate->stWorkSettings.nDataBits;
    pstCommon->nStopBits   = pstPrivate->stWorkSettings.nStopBits;
    pstCommon->nParity         = pstPrivate->stWorkSettings.nParity;
    pstCommon->fAutoDetect = pstPrivate->stWorkSettings.fAutoDetect;

    return COM_OK;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: DeviceSetCommon
 *
 * DESCRIPTION:
 *  Passes common user settings to driver for use and storage.
 *
 * ARGUMENTS:
 *  pstPrivate
 *  pstCommon  -- Structure containing common user settings to be used
 *                by driver
 *
 * RETURNS:
 *  Always returns COM_OK
 */
int WINAPI DeviceSetCommon(ST_STDCOM *pstPrivate, ST_COMMON *pstCommon)
    {
    if (bittest(pstCommon->afItem, COM_BAUD))
        pstPrivate->stWorkSettings.lBaud     = pstCommon->lBaud;
    if (bittest(pstCommon->afItem, COM_DATABITS))
        pstPrivate->stWorkSettings.nDataBits = pstCommon->nDataBits;
    if (bittest(pstCommon->afItem, COM_STOPBITS))
        pstPrivate->stWorkSettings.nStopBits = pstCommon->nStopBits;
    if (bittest(pstCommon->afItem, COM_PARITY))
        pstPrivate->stWorkSettings.nParity   = pstCommon->nParity;
    if (bittest(pstCommon->afItem, COM_AUTO))
        pstPrivate->stWorkSettings.fAutoDetect = pstCommon->fAutoDetect;

    return COM_OK;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: DeviceSpecial
 *
 * DESCRIPTION:
 *  The means for others to control any special features in this driver
 *  that are not supported by all drivers.
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *  COM_NOT_SUPPORTED if the instruction string was not recognized
 *  otherwise depends on instruction string
 */
/*ARGSUSED*/
int WINAPI DeviceSpecial(ST_STDCOM *pstPrivate,
    const TCHAR *pszInstructions,
    TCHAR *pszResult,
    int   nBufrSize)
    {

    int           iRetVal = COM_NOT_SUPPORTED;
    HSESSION      hSession;
#if 0           //* do port of this later
    unsigned      usMask = 0;
    unsigned long ulSetVal;
    TCHAR        *pszEnd;
	//
	// MAX_IP_ADDR_LEN+11+1 = buffer size of pstPrivate->szRemoteAddr +
	// settings string "SET IPADDR=" + 1 for the terminating NULL
	// character.  REV 09/20/2000
	//
    TCHAR         achInstructions[MAX_IP_ADDR_LEN+11+1]; // John: decide how you want to handle
    TCHAR        *pszToken = achInstructions;
    int           iIndex;
    TCHAR         szResult[MAX_IP_ADDR_LEN+11+1];

    static TCHAR *apszItems[] =
    {
    "HANDSHAKE_RCV_X",
    "HANDSHAKE_RCV_DTR",
    "HANDSHAKE_RCV_RTS",
    "HANDSHAKE_SND_X",
    "HANDSHAKE_SND_CTS",
    "HANDSHAKE_SND_DSR",
    "HANDSHAKE_SND_DCD",
    "XON_CHAR",
    "XOFF_CHAR",
    "BREAK_DURATION",
    "CTS_STATUS",
    "DSR_STATUS",
    "DCD_STATUS",
    "DTR_STATE",
    "RTS_STATE",
    "MODIFIED",     // remove when real temporary settings are in
    NULL
    };

    // supported instruction strings:
    // "Set xxx=vv"
    // "Query xxx"

    if (!pszInstructions || !*pszInstructions)
        return COM_FAILED;
    if (sizeof(achInstructions) < (size_t)(StrCharGetStrLength(pszInstructions) + 1))
        return COM_NOT_SUPPORTED;

    strcpy(achInstructions, pszInstructions);

    if (pszResult)
        *pszResult = TEXT('\0');

    pszToken = strtok(achInstructions, " ");
    if (!pszToken)
        return COM_NOT_SUPPORTED;

    if (StrCharCmpi(pszToken, "SET") == 0)
        {
        iRetVal = COM_OK;
        pszToken = strtok(NULL, " =");
        if (!pszToken)
            pszToken = TEXT('\0');

        // Look up the item to set
        for (iIndex = 0; apszItems[iIndex]; ++iIndex)
            if (StrCharCmpi(pszToken, apszItems[iIndex]) == 0)
                break;

        // Isolate the new value to be set
        pszToken = strtok(NULL, "\n");

        if (pszToken && *pszToken)
            {
            // Several items take numeric values
            ulSetVal = strtoul(pszToken, &pszEnd, 0);

            switch(iIndex)
                {
            case 0: // RCV_X
                usMask = HANDSHAKE_RCV_X;
                break;

            case 1: // RCV_DTR
                usMask = HANDSHAKE_RCV_DTR;
                break;

            case 2: // RCV_RTS
                usMask = HANDSHAKE_RCV_RTS;
                break;

            case 3: // SND_X
                usMask = HANDSHAKE_SND_X;
                break;

            case 4: // SND_CTS
                usMask = HANDSHAKE_SND_CTS;
                break;

            case 5: // SND_DSR
                usMask = HANDSHAKE_SND_DSR;
                break;

            case 6: // SND_DCD
                usMask = HANDSHAKE_SND_DCD;
                break;

            case 7: // XON_CHAR
                if (!*pszEnd && ulSetVal <= UCHAR_MAX)
                    pstPrivate->stWorkSettings.chXON = (TCHAR)ulSetVal;
                else
                    iRetVal = COM_FAILED;
                break;

            case 8: // XOFF_CHAR
                if (!*pszEnd && ulSetVal <= UCHAR_MAX)
                    pstPrivate->stWorkSettings.chXOFF = (TCHAR)ulSetVal;
                else
                    iRetVal = COM_FAILED;
                break;

            case 9: // BREAK_DURATION
                if (!*pszEnd && ulSetVal <= USHRT_MAX)
                    pstPrivate->stWorkSettings.nBreakDuration = (USHORT)ulSetVal;
                else
                    iRetVal = COM_FAILED;
                break;

            case 13: // DTR_STATE
                if (pstPrivate->hWinComm != INVALID_HANDLE_VALUE)
                    {
                    switch (ulSetVal)
                        {
                    case 0:
                        EscapeCommFunction(pstPrivate->hWinComm, CLRDTR);
                        break;

                    case 1:
                        EscapeCommFunction(pstPrivate->hWinComm, SETDTR);
                        break;

                    default:
                        iRetVal = COM_FAILED;
                        break;
                        }
                    }
                else
                    iRetVal = COM_PORT_NOT_OPEN;

                break;

            case 14: // RTS_STATE
                if (pstPrivate->hWinComm != INVALID_HANDLE_VALUE)
                    {
                    switch (ulSetVal)
                        {
                    case 0:
                        EscapeCommFunction(pstPrivate->hWinComm, CLRRTS);
                        break;

                    case 1:
                        EscapeCommFunction(pstPrivate->hWinComm, SETRTS);
                        break;

                    default:
                        iRetVal = COM_FAILED;
                        break;
                        }
                    }
                else
                    iRetVal = COM_PORT_NOT_OPEN;

                break;

                // TODO: remove when real temp settings are implemented
            case 15: // MODIFIED
                break;

            default:  // Who was that masked man?
                iRetVal = COM_FAILED;
                break;
                }

            if (usMask != 0)
                {
                // Must have been a handshake setting
                if (strcmp(pszToken, "1") == 0)
                    bitset(pstPrivate->stWorkSettings.afHandshake, usMask);
                else if (strcmp(pszToken, "0") == 0)
                    bitclear(pstPrivate->stWorkSettings.afHandshake,usMask);
                else
                    {
                    iRetVal = COM_FAILED;
                    }
                }
            }
        else    // if (pszToken && *pszToken)
            {
            iRetVal = COM_NOT_SUPPORTED;
            }
        }
    else if (StrCharCmpi(pszToken, "QUERY") == 0)
        {
        iRetVal = COM_OK;
        pszToken = strtok(NULL, "\n");
        szResult[0] = TEXT('\0');

        // Look up the item to query
        for (iIndex = 0; apszItems[iIndex]; ++iIndex)
            if (StrCharCmpi(pszToken, apszItems[iIndex]) == 0)
                break;

        if (*pszToken)
            {
            switch(iIndex)
                {
            case 0: // RCV_X
                usMask = HANDSHAKE_RCV_X;
                break;

            case 1: // RCV_DTR
                usMask = HANDSHAKE_RCV_DTR;
                break;

            case 2: // RCV_RTS
                usMask = HANDSHAKE_RCV_RTS;
                break;

            case 3: // SND_X
                usMask = HANDSHAKE_SND_X;
                break;

            case 4: // SND_CTS
                usMask = HANDSHAKE_SND_CTS;
                break;

            case 5: // SND_DSR
                usMask = HANDSHAKE_SND_DSR;
                break;

            case 6: // SND_DCD
                usMask = HANDSHAKE_SND_DCD;
                break;

            case 7: // XON_CHAR
                wsprintf(szResult, "%u", pstPrivate->stWorkSettings.chXON);
                break;

            case 8: // XOFF_CHAR
                wsprintf(szResult, "%u", pstPrivate->stWorkSettings.chXOFF);
                break;

            case 9: // BREAK_DURATION
                wsprintf(szResult, "%u", pstPrivate->stWorkSettings.nBreakDuration);
                break;

            case 10: // CTS_STATUS
                strcpy(szResult, bittest(*pbMdmStat, MDMSTAT_CTS) ? "1" : "0");
                break;

            case 11: // DSR_STATUS
                strcpy(szResult, bittest(*pbMdmStat, MDMSTAT_DSR) ? "1" : "0");
                break;

            case 12: // DCD_STATUS
                strcpy(szResult, bittest(*pbMdmStat, MDMSTAT_DCD) ? "1" : "0");
                break;

            case 15: // MODIFIED
                strcpy(szResult, "0");
                break;

            default:  // Who was that masked man?
                iRetVal = COM_FAILED;
                break;
                }

            if (usMask != 0)
                {
                // Must have been a handshake setting
                strcpy(szResult,
                    bittest(pstPrivate->stWorkSettings.afHandshake, usMask) ? "1" : "0");
                }

            if (szResult[0])
                {
                if (!pszResult || strlen(szResult) > uiBufrSize)
                    iRetVal = COM_FAILED;
                else
                    strcpy(pszResult, szResult);
                }
            }
        }
    else if (StrCharCmpi(pszToken, "SEND") == 0)
        {
        pszToken = strtok(NULL, "\n");
        if (StrCharCmpi(pszToken, "BREAK") == 0)
            {
            if (pstPrivate->hWinComm != INVALID_HANDLE_VALUE && !pstPrivate->fBreakSignalOn)
                {
                SndBufrClear(pstPrivate);
                SetCommBreak(pstPrivate->hWinComm);
                ComGetSession(pstPrivate->hCom, &hSession);

                if (TimerCreate(hSession,
                                &pstPrivate->hTmrBreak,
								pstPrivate->stWorkSettings.nBreakDuration,
								MakeProcInstance((FARPROC)DeviceBreakTimerProc, hinstDLL),
								(DWORD)pstPrivate) != TIMER_OK)
                    {
                    //* DeviceReportError(pstPrivate, SID_ERR_NOTIMER, 0, TRUE);
                    iRetVal = COM_DEVICE_ERROR;
                    }

                pstPrivate->fBreakSignalOn = TRUE;
                iRetVal = COM_OK;
                }
            }
        }
#else
	if (pszResult && nBufrSize > 0)
        {
        *pszResult = TEXT('\0');
        }
#endif
    // Implement only the Break function.  All other comm functions handled
    // through TAPI. - mrw:6/15/95
    //
    if (StrCharCmpi(pszInstructions, "Send Break") == 0)
        {
        if (pstPrivate->hWinComm != INVALID_HANDLE_VALUE && !pstPrivate->fBreakSignalOn)
            {
            SndBufrClear(pstPrivate);
            SetCommBreak(pstPrivate->hWinComm);
            ComGetSession(pstPrivate->hCom, &hSession);

            if (TimerCreate(hSession,
				            &pstPrivate->hTmrBreak,
							pstPrivate->stWorkSettings.nBreakDuration,
							DeviceBreakTimerProc,
							pstPrivate) != TIMER_OK)
                {
                //* DeviceReportError(pstPrivate, SID_ERR_NOTIMER, 0, TRUE);
                iRetVal = COM_DEVICE_ERROR;
                }

            pstPrivate->fBreakSignalOn = TRUE;
            iRetVal = COM_OK;
            }
        }
    //
    // This is necessary to detect loss of carrier on COM ports. REV: 08/22/2001
    //
    else if (StrCharCmpi(pszInstructions, "Query DCD_STATUS") == 0)
        {
        iRetVal = COM_OK;
		if (pszResult && nBufrSize > 0)
			{
			_itoa(PortConnected(pstPrivate), pszResult, 10);
			}
        }
    //
    // This is necessary to get the default settings on COM ports. REV: 08/22/2001
    //
    else if (StrCharCmpi(pszInstructions, "GET Defaults") == 0)
        {
		iRetVal = PortDefaultSettings(pstPrivate);
        }

    return iRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  DeviceLoadHdl
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *  pstPrivate  -- driver data structure
 *
 * RETURNS:
 *
 */
int WINAPI DeviceLoadHdl(ST_STDCOM *pstPrivate, SF_HANDLE sfHdl)
    {
    unsigned long ul;

    // Load comm settings from the session file. If we connect via TAPI,
    // several of these settings will be inherited from TAPI and these
    // values will not be used.
    ul = sizeof(pstPrivate->stWorkSettings.lBaud);
    sfGetSessionItem(sfHdl, SFID_COMSTD_BAUD, &ul,
            &pstPrivate->stWorkSettings.lBaud);

    ul = sizeof(pstPrivate->stWorkSettings.nDataBits);
    sfGetSessionItem(sfHdl, SFID_COMSTD_DATABITS, &ul,
            &pstPrivate->stWorkSettings.nDataBits);

    ul = sizeof(pstPrivate->stWorkSettings.nStopBits);
    sfGetSessionItem(sfHdl, SFID_COMSTD_STOPBITS, &ul,
            &pstPrivate->stWorkSettings.nStopBits);

    ul = sizeof(pstPrivate->stWorkSettings.nParity);
    sfGetSessionItem(sfHdl, SFID_COMSTD_PARITY, &ul,
            &pstPrivate->stWorkSettings.nParity);

    ul = sizeof(pstPrivate->stWorkSettings.afHandshake);
    sfGetSessionItem(sfHdl, SFID_COMSTD_HANDSHAKING, &ul,
            &pstPrivate->stWorkSettings.afHandshake);

    ul = sizeof(pstPrivate->stWorkSettings.fAutoDetect);
    sfGetSessionItem(sfHdl, SFID_COMSTD_AUTODETECT, &ul,
        &pstPrivate->stWorkSettings.fAutoDetect);

    return SF_OK;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  DeviceSaveHdl
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *  pstPrivate  -- driver data structure
 *
 * RETURNS:
 *
 */
int WINAPI DeviceSaveHdl(ST_STDCOM *pstPrivate, SF_HANDLE sfHdl)
    {
    // Save settings in session file space. Many of these values may be
    // overwritten by TAPI settings but are used by direct connect.
    sfPutSessionItem(sfHdl, SFID_COMSTD_BAUD,
            sizeof(pstPrivate->stWorkSettings.lBaud),
            &pstPrivate->stWorkSettings.lBaud);

    sfPutSessionItem(sfHdl, SFID_COMSTD_DATABITS,
            sizeof(pstPrivate->stWorkSettings.nDataBits),
            &pstPrivate->stWorkSettings.nDataBits);

    sfPutSessionItem(sfHdl, SFID_COMSTD_STOPBITS,
            sizeof(pstPrivate->stWorkSettings.nStopBits),
            &pstPrivate->stWorkSettings.nStopBits);

    sfPutSessionItem(sfHdl, SFID_COMSTD_PARITY,
            sizeof(pstPrivate->stWorkSettings.nParity),
            &pstPrivate->stWorkSettings.nParity);

    sfPutSessionItem(sfHdl, SFID_COMSTD_HANDSHAKING,
            sizeof(pstPrivate->stWorkSettings.afHandshake),
            &pstPrivate->stWorkSettings.afHandshake);

    sfPutSessionItem(sfHdl, SFID_COMSTD_AUTODETECT,
        sizeof(pstPrivate->stWorkSettings.fAutoDetect),
        &pstPrivate->stWorkSettings.fAutoDetect);

    return SF_OK;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: PortActivate
 *
 * DESCRIPTION:
 *  Called to activate the port and open it for use
 *
 * ARGUMENTS:
 *  pstPrivate  -- driver data structure
 *  pszPortName -- the name of the port to activate
 *
 * RETURNS:
 *  COM_OK if port is successfully activated
 *  COM_NOT_ENOUGH_MEMORY if there in insufficient memory for data storage
 *  COM_NOT_FOUND if named port cannot be opened
 *  COM_DEVICE_ERROR if API errors are encountered
 */
int WINAPI PortActivate(ST_STDCOM *pstPrivate,
    TCHAR *pszPortName,
    DWORD_PTR dwMediaHdl)
    {
    TCHAR           szFullPortName[MAX_PATH];
    int             iRetVal = COM_OK;
    ST_COM_CONTROL *pstComCntrl;
    DWORD           dwThreadID;

    //
    // Free the send bufers prior to setting to malloc so we don't
    // have a memory leak.  REV: 02/27/2001.
    //
    if (pstPrivate->pbBufrStart)
        {
        free(pstPrivate->pbBufrStart);
        pstPrivate->pbBufrStart = NULL;
        }

    // Make sure we can get enough memory for buffers before opening device
    pstPrivate->pbBufrStart = malloc((size_t)pstPrivate->nRBufrSize);

    if (pstPrivate->pbBufrStart == NULL)
        {
        iRetVal = COM_NOT_ENOUGH_MEMORY;
        //* DeviceReportError(pstPrivate, SID_ERR_NOMEM, 0, TRUE);
        goto checkout;
        }

    //
    // Free the send bufers prior to setting to malloc so we don't
    // have a memory leak.  REV: 02/27/2001.
    //
    if (pstPrivate->pbSndBufr)
        {
        free(pstPrivate->pbSndBufr);
        pstPrivate->pbSndBufr = NULL;
        }

    pstPrivate->pbSndBufr = malloc((size_t) SIZE_OUTQ);
    if (pstPrivate->pbSndBufr == 0)
        {
        iRetVal = COM_NOT_ENOUGH_MEMORY;
        free(pstPrivate->pbBufrStart);
        pstPrivate->pbBufrStart = NULL;
        goto checkout;
        }

    pstPrivate->pbBufrEnd = pstPrivate->pbBufrStart + pstPrivate->nRBufrSize;
    pstPrivate->pbReadEnd = pstPrivate->pbBufrStart;
    pstPrivate->pbComStart = pstPrivate->pbComEnd = pstPrivate->pbBufrStart;
    pstPrivate->fBufrEmpty = TRUE;

#if defined(DEBUG_CHARDUMP)
	if (!pfDbgR)
		pfDbgR = fopen("comreads.dbg", "wt");
	fprintf(pfDbgR, "Port opened, internal buffer = 0x%p to 0x%p\n",
			pstPrivate->pbBufrStart, pstPrivate->pbBufrEnd - 1);
	if (!pfDbgC)
		pfDbgC = fopen("comused.dbg", "wt");
	fprintf(pfDbgC, "Port opened, internal buffer = 0x%p to 0x%p\n",
			pstPrivate->pbBufrStart, pstPrivate->pbBufrEnd - 1);
#endif

    pstPrivate->dwSndOffset = 0;
    pstPrivate->dwBytesToSend = 0;

    if (dwMediaHdl)
        {
        pstPrivate->hWinComm = (HANDLE)dwMediaHdl;

        if (PortExtractSettings(pstPrivate) != COM_OK)
            iRetVal = COM_DEVICE_ERROR;
        }

    else
        {
        // Win32 internally maps ports COM1 to COM9 to
        // \\.\COMx. We need to add this for ports COMxx,
        // and for special com devices in the registry.
        //
        StrCharCopyN(szFullPortName, TEXT("\\\\.\\"), sizeof(szFullPortName) / sizeof(TCHAR));
        StrCharCat(szFullPortName, pszPortName);
        pstPrivate->hWinComm = CreateFile(szFullPortName,
                   GENERIC_READ | GENERIC_WRITE,
                   0,
                   (LPSECURITY_ATTRIBUTES)NULL,
                   OPEN_EXISTING,
                   FILE_FLAG_OVERLAPPED,
                   (HANDLE)NULL);


        if (pstPrivate->hWinComm == INVALID_HANDLE_VALUE)
            {
            //* Figure out which errors to report specifically

            DWORD dwError = GetLastError();

            if( dwError == ERROR_NOT_ENOUGH_MEMORY ||
                dwError == ERROR_OUTOFMEMORY ||
                dwError == ERROR_OUT_OF_STRUCTURES ||
                dwError == ERROR_INSUFFICIENT_BUFFER ||
                dwError == ERROR_COMMITMENT_LIMIT ||
                dwError == ERROR_NOT_ENOUGH_QUOTA)
                {
                iRetVal = COM_NOT_ENOUGH_MEMORY;
                }
            else if(dwError == ERROR_ACCESS_DENIED ||
                    dwError == ERROR_SHARING_VIOLATION ||
                    dwError == ERROR_LOCK_VIOLATION ||
                    dwError == ERROR_OPEN_FAILED ||
                    dwError == ERROR_IRQ_BUSY ||
                    dwError == ERROR_DEVICE_IN_USE)
                {
                iRetVal = COM_PORT_IN_USE;
                }
            else
                {
                iRetVal = COM_NOT_FOUND;
                }
            }
        }

    if (iRetVal == COM_OK)
        {
		// Major bug in Win95 - If you call SetupComm() for a standard
		// comm handle (not one given to us by TAPI) the WriteFile
        // call fails and locks the system. - mrw:2/29/96
		//
		if (IsNT() && SetupComm(pstPrivate->hWinComm, 8192, 8192) == FALSE)
			{
			assert(0);
			}
        }

    if (iRetVal == COM_OK)
        {
        iRetVal = PortConfigure(pstPrivate);
        }

    if (iRetVal == COM_OK)
        {
        pstComCntrl = (ST_COM_CONTROL *)pstPrivate->hCom;
        pstComCntrl->puchRBData = pstPrivate->pbBufrStart;
        pstComCntrl->puchRBDataLimit = pstPrivate->pbBufrStart;

        pstPrivate->dwEventMask = EV_ERR | EV_RLSD;
        pstPrivate->fNotifyRcv = TRUE;
        pstPrivate->fBufrEmpty = TRUE;

        if (!SetCommMask(pstPrivate->hWinComm, pstPrivate->dwEventMask))
            iRetVal = COM_DEVICE_ERROR;

        // Clear error counts on new connection
        pstPrivate->nParityErrors = 0;
        pstPrivate->nFramingErrors = 0;
        pstPrivate->nOverrunErrors = 0;
        pstPrivate->nOverflowErrors = 0;

        // Start thread to handle Reading, Writing (& 'rithmetic) & events
        pstPrivate->fHaltThread = FALSE;
        DBG_THREAD("DBG_THREAD: Calling CreateThread\r\n",0,0,0,0,0);
        pstPrivate->hComstdThread = CreateThread((LPSECURITY_ATTRIBUTES)0,
                    2000, ComstdThread, pstPrivate, 0, &dwThreadID);

        if (pstPrivate->hComstdThread)
            {
            SetThreadPriority(pstPrivate->hComstdThread,
                    THREAD_PRIORITY_ABOVE_NORMAL);
                    //THREAD_PRIORITY_TIME_CRITICAL); // - mrw:7/8/96
            }

        DBG_THREAD("DBG_THREAD: CreateThread returned %08X\r\n",
            pstPrivate->hComstdThread,0,0,0,0);
        }

checkout:
    if (iRetVal != COM_OK)
        PortDeactivate(pstPrivate);

    return iRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: PortDeactivate
 *
 * DESCRIPTION:
 *  Deactivates and closes an open port
 *
 * ARGUMENTS:
 *  pstPrivate -- Driver data structure
 *
 * RETURNS:
 *  COM_OK
 */
int WINAPI PortDeactivate(ST_STDCOM *pstPrivate)
    {
    int iRetVal = COM_OK;

    if (pstPrivate->hComstdThread)
        {
		DWORD dwResult = 0L;

        // Halt the thread by setting a flag for the thread to detect and then
        // forcing WaitCommEvent to return by changing the event mask
        DBG_THREAD("DBG_THREAD: Shutting down comstd thread\r\n", 0,0,0,0,0);
        pstPrivate->fHaltThread = TRUE;
        SetCommMask(pstPrivate->hWinComm, pstPrivate->dwEventMask);
        PurgeComm(pstPrivate->hWinComm,
            PURGE_TXABORT | PURGE_RXABORT);  // Abort any calls in progress

        // thread should exit now, it's handle will signal when it has exited
		if (pstPrivate->hComstdThread)
			{
			dwResult = WaitForSingleObject(pstPrivate->hComstdThread, 5000);

			if (dwResult != WAIT_OBJECT_0)
				{
				if (dwResult == WAIT_FAILED)
					{
					dwResult = GetLastError();
					}
				assert(FALSE);
				}
			}

        if (pstPrivate->hComstdThread)
			{
			CloseHandle(pstPrivate->hComstdThread);
			pstPrivate->hComstdThread = NULL;
			DBG_THREAD("DBG_THREAD: Comstd thread has shut down\r\n", 0,0,0,0,0);
			}
        }

    if (pstPrivate->pbBufrStart)
        {
        free(pstPrivate->pbBufrStart);
        pstPrivate->pbBufrStart = NULL;
        }

    if (pstPrivate->pbSndBufr)
        {
        free(pstPrivate->pbSndBufr);
        pstPrivate->pbSndBufr = 0;
        }

    if (pstPrivate->hWinComm != INVALID_HANDLE_VALUE)
        {
        //* As of 2/9/94, this PurgeComm call caused the program to hang
        //   or reboot
        // PurgeComm(pstPrivate->hWinComm,
        //        PURGE_TXABORT | PURGE_RXABORT);  // Flush transmit queue

        CloseHandle(pstPrivate->hWinComm);
        }

    pstPrivate->hWinComm = INVALID_HANDLE_VALUE;

    return iRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: PortConfigure
 *
 * DESCRIPTION:
 *  Configures an open port with the current set of user settings
 *
 * ARGUMENTS:
 *  pstPrivate -- The driver data structure
 *
 * RETURNS:
 *  COM_OK if port is configured successfully
 *  COM_DEVICE_ERROR if API errors are encountered
 *  COM_DEVICE_INVALID_SETTING if some user settings are not valid
 */
int WINAPI PortConfigure(ST_STDCOM *pstPrivate)
    {
    int          iRetVal = COM_OK;
    unsigned     uOverrides = 0;
    DWORD        dwError;
    DWORD        dwStructSize;
    DCB         *pstDcb;
    COMMCONFIG   stCommConfig;
    COMMTIMEOUTS stCT;

    dwStructSize = sizeof(stCommConfig);
    stCommConfig.dwSize = sizeof(stCommConfig);

    if (!GetCommConfig(pstPrivate->hWinComm, &stCommConfig, &dwStructSize))
        {
        //* DeviceReportError(pstPrivate, SID_ERR_WINDRIVER, 0, TRUE);
        iRetVal = COM_DEVICE_ERROR;
        }
    else
        {
        pstDcb = &stCommConfig.dcb;
        ComstdSettingsToDCB(&pstPrivate->stWorkSettings, pstDcb);

        // Check for overrides
        ComQueryOverride(pstPrivate->hCom, &uOverrides);

        if (bittest(uOverrides, COM_OVERRIDE_8BIT))
            {
            pstDcb->ByteSize = 8;
            pstDcb->Parity = NOPARITY;
            }

        // If we need to receive all 256 chars., we need to override
        //   XON/XOFF during sending since it will strip XON & XOFF from
        //   the incoming stream if enabled
        if (bittest(uOverrides, COM_OVERRIDE_RCVALL))
            pstDcb->fOutX = 0;

        stCommConfig.dwSize = sizeof(stCommConfig);

        if (!SetCommConfig(pstPrivate->hWinComm, &stCommConfig,
            dwStructSize))
            {
            dwError = GetLastError();

            //* Use GetLastError to figure out what went wrong, but
            //*  docs don't specify which error to check for.

            // At this point SOME setting in the DCB is bad but there is
            // no way to find out which. Since the baud rate is a likely
            // candidate. Try reissuing the command with a common baud
            // rate to see if the problem goes away
            //
            pstDcb->BaudRate = 1200;

            if (!SetCommConfig(pstPrivate->hWinComm, &stCommConfig,
                sizeof(stCommConfig)))
                {
                // If its still no good them some other setting is bad
                //* DeviceReportError(pstPrivate, SID_ERR_BADSETTING, 0, TRUE);
                }
            else
                {
                // Changing baud rate to 1200 worked, so the user's baud
                // rate must be what the driver is refusing
                //* DeviceReportError(pstPrivate, SID_ERR_BADBAUD, 0, TRUE);
                }
            iRetVal = COM_DEVICE_INVALID_SETTING;
            }
        else
            {
            stCT.ReadIntervalTimeout = 10;
            stCT.ReadTotalTimeoutMultiplier = 0;
            stCT.ReadTotalTimeoutConstant = 0;
            stCT.WriteTotalTimeoutMultiplier = 0;
            stCT.WriteTotalTimeoutConstant = 5000;
            if (!SetCommTimeouts(pstPrivate->hWinComm, &stCT))
                {
                assert(FALSE);
                iRetVal = COM_DEVICE_INVALID_SETTING;
                }
            }
        }
    return iRetVal;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  PortExtactSettings
 *
 * DESCRIPTION:
 *  Extracts current Com settings from the Windows Com driver. This is
 *  needed when we are passed an existing Com handle by something like TAPI
 *
 * ARGUMENTS:
 *  pstPrivate -- The driver data structure
 *
 * RETURNS:
 *  COM_OK if port is configured successfully
 *  COM_DEVICE_ERROR if API errors are encountered
 */
int PortExtractSettings(ST_STDCOM *pstPrivate)
    {
    int        iRetVal;
    DWORD      dwError;
    DWORD      dwSize;
    COMMCONFIG stCommConfig;

    dwSize = sizeof(stCommConfig);
    if (!GetCommConfig(pstPrivate->hWinComm, &stCommConfig, &dwSize))
        {
        dwError = GetLastError();
        //* DeviceReportError(pstPrivate, SID_ERR_WINDRIVER, 0, TRUE);
        iRetVal = COM_DEVICE_ERROR;
        }
    else
        {
        // Unload appropriate values from DCB to our settings structure
        ComstdDCBToSettings(&stCommConfig.dcb, &pstPrivate->stWorkSettings);

        // Don't leave autodetect on if user has already set something
        // other than 8N1
        DBG_AD("DBG_AD: fAutoDetect = %d\r\n",
            pstPrivate->stWorkSettings.fAutoDetect, 0,0,0,0);
        if (pstPrivate->stWorkSettings.fAutoDetect)
            {
            if (pstPrivate->stWorkSettings.nDataBits != 8 ||
                    pstPrivate->stWorkSettings.nParity != NOPARITY ||
                    pstPrivate->stWorkSettings.nStopBits != ONESTOPBIT)
                {
                DBG_AD("DBG_AD: Turning fAutoDetect off due to non 8N1\r\n",
                    0,0,0,0,0);
                pstPrivate->stWorkSettings.fAutoDetect = FALSE;
                }
            }

        iRetVal = COM_OK;
        }

    return iRetVal;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  PortDefaultSettings
 *
 * DESCRIPTION:
 *  Extracts current Com settings from the Windows Com driver. This is
 *  needed when we are passed an existing Com handle by something like TAPI
 *
 * ARGUMENTS:
 *  pstPrivate -- The driver data structure
 *
 * RETURNS:
 *  COM_OK if port is configured successfully
 *  COM_DEVICE_ERROR if API errors are encountered
 */
int PortDefaultSettings(ST_STDCOM *pstPrivate)
    {
    int        iRetVal;
    DWORD      dwError;
    COMMCONFIG stCommConfig;
    DWORD      dwSize = sizeof(stCommConfig);
    TCHAR      szPortName[COM_MAX_PORT_NAME];

	if (pstPrivate == NULL  || pstPrivate->hCom == NULL)
		{
		iRetVal = COM_INVALID_HANDLE;
		}
    else
		{
		ComGetPortName(pstPrivate->hCom, szPortName, COM_MAX_PORT_NAME);

		if (StrCharGetStrLength(szPortName) == 0 || StrCharCmp(szPortName, "\0") == 0)
			{
			iRetVal = COM_DEVICE_ERROR;
			}
		else
			{
			if (!GetDefaultCommConfig(szPortName, &stCommConfig, &dwSize))
				{
				dwError = GetLastError();
				//* DeviceReportError(pstPrivate, SID_ERR_WINDRIVER, 0, TRUE);
				iRetVal = COM_DEVICE_ERROR;
				}
			else
				{
				// Unload appropriate values from DCB to our settings structure
				ComstdDCBToSettings(&stCommConfig.dcb,
					                &pstPrivate->stWorkSettings);

				// Don't leave autodetect on if user has already set something
				// other than 8N1
				DBG_AD("DBG_AD: fAutoDetect = %d\r\n",
					pstPrivate->stWorkSettings.fAutoDetect, 0,0,0,0);
				if (pstPrivate->stWorkSettings.fAutoDetect)
					{
					if (pstPrivate->stWorkSettings.nDataBits != 8 ||
							pstPrivate->stWorkSettings.nParity != NOPARITY ||
							pstPrivate->stWorkSettings.nStopBits != ONESTOPBIT)
						{
						DBG_AD("DBG_AD: Turning fAutoDetect off due to non 8N1\r\n",
							0,0,0,0,0);
						pstPrivate->stWorkSettings.fAutoDetect = FALSE;
						}
					}
				}
			}

        iRetVal = COM_OK;
        }

    return iRetVal;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: PortConnected
 *
 * DESCRIPTION:
 *  Determines whether the driver is currently connected to a host system.
 *  In the case of this driver, the presence of the carrier signal determines
 *  when we are connected.
 *
 * ARGUMENTS:
 *  pstPrivate -- Our private data structure
 *
 * RETURNS:
 *  TRUE if carrier is present
 *  FALSE if carrier is off
 */
int WINAPI PortConnected(ST_STDCOM *pstPrivate)
    {
    int   iRetVal = COM_PORT_NOT_OPEN;
    DWORD dwModemStat;

    if (GetCommModemStatus(pstPrivate->hWinComm, &dwModemStat))
		{
        if (bittest(dwModemStat, MS_RLSD_ON))
			{
			iRetVal = COM_PORT_OPEN;
			}
		}

	if (iRetVal == COM_PORT_NOT_OPEN)
		{
		const HCOM hCom = pstPrivate->hCom;

		if (hCom != NULL && ComValidHandle(hCom))
			{
			const HHCNCT hhCnct = (HHCNCT)sessQueryCnctHdl(hCom->hSession);
			
			if (hhCnct != NULL)
				{
				const HHDRIVER hhDriver = (HHDRIVER)hhCnct->hDriver;

				if (hhDriver != NULL)
					{
					if (!hhDriver->fCarrierDetect ||
						bittest(hhDriver->stCallPar.dwBearerMode, LINEBEARERMODE_PASSTHROUGH))
						{
						iRetVal = COM_PORT_OPEN;
						}
					}
				}
			}
		}

    return iRetVal;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: RcvRefill
 *
 * DESCRIPTION:
 *  Called when the receive buffer is empty to refill it. This routine
 *  should attempt to refill the buffer and return the first character.
 *  It is important that this function be implemented efficiently.
 *
 * ARGUMENTS:
 *  pstPrivate -- the driver data structure
 *
 * RETURNS:
 *  TRUE if data is put in the receive buffer
 *  FALSE if there is no new incoming data
 */
int WINAPI RcvRefill(ST_STDCOM *pstPrivate)
    {
    int fRetVal = FALSE;
    ST_COM_CONTROL *pstComCntrl;
	HCOM hCom;

    EnterCriticalSection(&pstPrivate->csect);

    pstPrivate->pbComStart = (pstPrivate->pbComEnd == pstPrivate->pbBufrEnd) ?
                              pstPrivate->pbBufrStart :
	                          pstPrivate->pbComEnd;
    pstPrivate->pbComEnd = (pstPrivate->pbReadEnd >= pstPrivate->pbComStart) ?
                            pstPrivate->pbReadEnd :
	                        pstPrivate->pbBufrEnd;
    DBG_READ("DBG_READ: Refill ComStart==%x, ComEnd==%x (ReadEnd==%x)\r\n",
        pstPrivate->pbComStart, pstPrivate->pbComEnd,
        pstPrivate->pbReadEnd, 0,0);
    if (pstPrivate->fBufrFull)
        {
        DBG_READ("DBG_READ: Refill Signalling EVENT_READ\r\n", 0,0,0,0,0);
        SetEvent(pstPrivate->ahEvent[EVENT_READ]);
        }
    if (pstPrivate->pbComStart == pstPrivate->pbComEnd)
        {
        DBG_READ("DBG_READ: Refill setting fBufrEmpty = TRUE\r\n", 0,0,0,0,0);
        pstPrivate->fBufrEmpty = TRUE;

		hCom = pstPrivate->hCom;
        LeaveCriticalSection(&pstPrivate->csect);
        ComNotify(hCom, NODATA);
        EnterCriticalSection(&pstPrivate->csect);
        }
    else
        {
        pstComCntrl = (ST_COM_CONTROL *)pstPrivate->hCom;
        pstComCntrl->puchRBData = pstPrivate->pbComStart;
        pstComCntrl->puchRBDataLimit = pstPrivate->pbComEnd;

#if defined(DEBUG_CHARDUMP)
		{
        int iAvail;
        int iCnt;

        iAvail = (int) pstComCntrl->puchRBDataLimit - pstComCntrl->puchRBData;
		fprintf(pfDbgC,
			"Consumed -- %d bytes 0x%p to 0x%p:",
				iAvail,
                pstComCntrl->puchRBData,
				pstComCntrl->puchRBDataLimit - 1);
		for (iCnt = 0; iCnt < iAvail; ++iCnt)
			{
			if ((iCnt % 16) == 0)
				fputs("\n", pfDbgC);
			fprintf(pfDbgC, "%02X ", pstComCntrl->puchRBData[iCnt]);
			}
		fputs("\n", pfDbgC);
		}
#endif

        // If this com driver were being used to make the connection, we
        //  would have to check here to see whether we were connected before
        //  we called AutoDetect. Since TAPI takes care of making the
        //  connection for this app, we can just start auto detecting
        //  whenever we get control
        if (pstPrivate->stWorkSettings.fAutoDetect)
            {
            AutoDetectAnalyze(pstPrivate,
                (int)(pstPrivate->pbComEnd - pstPrivate->pbComStart),
                pstPrivate->pbComStart);
            }
        fRetVal = TRUE;
        }

    LeaveCriticalSection(&pstPrivate->csect);
    return fRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: RcvClear
 *
 * DESCRIPTION:
 *  Clears the receiver of all received data.
 *
 * ARGUMENTS:
 *  hCom -- a comm handle returned by an earlier call to ComCreateHandle
 *
 * RETURNS:
 *  COM_OK if data is cleared
 *  COM_DEVICE_ERROR if Windows com device driver returns an error
 */
int WINAPI RcvClear(ST_STDCOM *pstPrivate)
    {
    int iRetVal = COM_OK;
    ST_COM_CONTROL *pstComCntrl;

    EnterCriticalSection(&pstPrivate->csect);

	pstComCntrl = (ST_COM_CONTROL *)pstPrivate->hCom;

    // Set buffer pointers to clear out any data we might have queued
    pstComCntrl->puchRBData = pstPrivate->pbBufrStart;
	pstComCntrl->puchRBDataLimit = pstPrivate->pbBufrStart;
    pstPrivate->pbReadEnd = pstPrivate->pbBufrStart;
    pstPrivate->pbComStart = pstPrivate->pbBufrStart;
	pstPrivate->pbComEnd = pstPrivate->pbBufrStart;

    if (!PurgeComm(pstPrivate->hWinComm, PURGE_RXCLEAR | PURGE_RXABORT))
        iRetVal = COM_DEVICE_ERROR;

    LeaveCriticalSection(&pstPrivate->csect);
    return iRetVal;
    }



//          Buffered send routines


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: SndBufrSend
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int WINAPI SndBufrSend(ST_STDCOM *pstPrivate, void *pvBufr, int  nSize)
    {
    int   iRetVal = COM_OK;
    DWORD dwBytesWritten;
    DWORD dwError;
	HCOM  hCom;

    assert(pvBufr != (void *)0);
    assert(nSize <= SIZE_OUTQ);

    if (nSize > 0)
        {
        EnterCriticalSection(&pstPrivate->csect);

        // If Auto Detection is on, we may need to manually alter the
        // parity of the output
        if (pstPrivate->stWorkSettings.fAutoDetect)
			{
            AutoDetectOutput(pstPrivate, pvBufr, nSize);
			}

		hCom = pstPrivate->hCom;
        LeaveCriticalSection(&pstPrivate->csect);
        ComNotify(hCom, SEND_STARTED);

		#if defined(DEADWOOD)
		// We had a bug that caused the session to stop displaying new characters when
		// you used auto-connect to start typing to a modem on Win 95. I tracked it down
		// to this point in the code by moving a debug trace statement around. Put it
		// just before this EnterCriticalSection and the bug goes away. Put it just after
		// and the bug comes back. I discovered that replacing the DbgOutStr with a Sleep(0)
		// had the same effect. This is a cheap fix but seems to work. We may want to
		// spend the time to figure out exactly what is going on sometime in the future.
		//jkh 9/9/98

        Sleep(0);

        //
        // JohnFu 2/13/02, the EnterCriticalSection was just below this Sleep(0) now 
        //  moved to top of the if statement. It was possible for other threads to 
        //  modify the members of pstPrivate anytime between the above three statements.
        //  That may be the original cause of the bug described above. The reason the Sleep(0)
        //  fixed that bug further proves that possibility. There should be no need to
        //  place the Sleep here any longer.

		// I added the sleep back in to see if the file transfer issues we
		// were seeing with large file transfers would be corrected by adding
		// the sleep back in. REV: 4/8/2002
		//
		// Made this Sleep(0) as deadwood since this may cause the deadlock
		// to reappear.  This did not correct the large file transfer problem
		// we were seeing.  REV: 7/11/2002
		//
		#endif // defined(DEADWOOD)

        EnterCriticalSection(&pstPrivate->csect);
        assert(pstPrivate->dwBytesToSend == 0);
        assert(pstPrivate->dwSndOffset == 0);
		assert((pstPrivate->dwSndOffset + nSize) <= SIZE_OUTQ);

		#if defined(TODO)
		//
		// TODO:REV 7/11/2002 this is where the Ymodem-G is having problems and we are
		// getting retries in file transfers.  When the pstPrivate->dwBytesToSend is != 0,
		// or the pstPrivate->dwSndOffset != 0, then we are overwriting the character
		// that is existing in the buffer.  We need to make sure we don't overwrite the
		// buffer and/or clobber existing data in the buffer.
		//
		MemCopy(&pstPrivate->pbSndBufr[pstPrivate->dwSndOffset], (BYTE*) pvBufr, nSize);
        pstPrivate->dwBytesToSend += nSize;
        //pstPrivate->dwSndOffset = 0;
		#else // defined(TODO)
		MemCopy(pstPrivate->pbSndBufr, (BYTE*) pvBufr, nSize);
        pstPrivate->dwBytesToSend = nSize;
        pstPrivate->dwSndOffset = 0;
		#endif // defined(TODO)

        pstPrivate->stWriteOv.Offset = pstPrivate->stWriteOv.OffsetHigh = 0;
        pstPrivate->stWriteOv.hEvent = pstPrivate->ahEvent[EVENT_WRITE];

        DBG_WRITE("DBG_WRITE: %d WriteFile nSize==%d 0x%x\r\n", GetTickCount(),nSize,pstPrivate->hWinComm,0,0);
        // jmh:01-12-96 When the OVERLAPPED structure is passed to WriteFile,
        // there is character loss. Thorough investigation indicates a problem
        // within Win32 comm. Documentation says behavior is undefined when
        // this structure is not passed, but it works.
        if (WriteFile(pstPrivate->hWinComm, pstPrivate->pbSndBufr, (DWORD)nSize,
            &dwBytesWritten, &pstPrivate->stWriteOv)) // mrw:12/6/95 restored stWriteOv
            {
            assert(dwBytesWritten == (DWORD)nSize);
            DBG_WRITE("DBG_WRITE: %d WriteFile completed synchronously\r\n",GetTickCount(),0,0,0,0);

            hCom = pstPrivate->hCom;
            LeaveCriticalSection(&pstPrivate->csect);
            ComNotify(hCom, SEND_DONE);
            EnterCriticalSection(&pstPrivate->csect);
            pstPrivate->dwBytesToSend = 0;
            }
        else
            {
            dwError = GetLastError();
            if (dwError == ERROR_IO_PENDING)
                {
                pstPrivate->fSending = TRUE;
                }
            else
                {
                iRetVal = COM_FAILED;
                DBG_WRITE("DBG_WRITE: %d WriteFile failed %d 0x%x\r\n", GetTickCount(),dwError,pstPrivate->hWinComm,0,0);
                }
            }

		LeaveCriticalSection(&pstPrivate->csect);
        }

    return iRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: SndBufrIsBusy
 *
 * DESCRIPTION:
 *  Determines whether the driver is available to transmit a buffer of
 *  data or not.
 *
 * ARGUMENTS:
 *  pstPrivate -- address of com driver's data structure
 *
 * RETURNS:
 *  COM_OK   if data can be transmitted
 *  COM_BUSY if driver is still working on a previous buffer
 */
int WINAPI SndBufrIsBusy(ST_STDCOM *pstPrivate)
    {
    int  iRetVal = COM_OK;

    EnterCriticalSection(&pstPrivate->csect);

    if (pstPrivate->fBreakSignalOn || pstPrivate->fSending)
        {
        iRetVal = COM_BUSY;
        }

    LeaveCriticalSection(&pstPrivate->csect);

    return iRetVal;
    }



/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: SndBufrQuery
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int WINAPI SndBufrQuery(ST_STDCOM *pstPrivate,
    unsigned *pafStatus,
    long *plHandshakeDelay)
    {
    int     iRetVal = COM_OK;
    DWORD   dwErrors;
    COMSTAT stComStat;

    assert(pafStatus != NULL);

    *pafStatus = 0;

    //* temporary
    if (!SndBufrIsBusy(pstPrivate))
        {
        // If no send is in progress, return clear status
        *pafStatus = 0;
        if (plHandshakeDelay)
            *plHandshakeDelay = 0L;
        }
    else
        {
        if (ClearCommError(pstPrivate->hWinComm, &dwErrors, &stComStat))
            {
            if (stComStat.fXoffHold)
                bitset(*pafStatus, COMSB_WAIT_XON);
            if (stComStat.fCtsHold)
                bitset(*pafStatus, COMSB_WAIT_CTS);
            if (stComStat.fDsrHold)
                bitset(*pafStatus, COMSB_WAIT_DSR);
            if (stComStat.fRlsdHold)
                bitset(*pafStatus, COMSB_WAIT_DCD);
            if (stComStat.fXoffSent)
                bitset(*pafStatus, COMSB_WAIT_BUSY);

            if (*pafStatus && pstPrivate->lSndStuck == -1L)
                pstPrivate->lSndStuck = (long)startinterval();

            if (plHandshakeDelay)
                *plHandshakeDelay =
                (pstPrivate->lSndStuck == -1L ?
                0L : (long)interval(pstPrivate->lSndStuck));
            }
        }

    return iRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: SndBufrClear
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int WINAPI SndBufrClear(ST_STDCOM *pstPrivate)
    {
    int iRetVal = COM_OK;

    EnterCriticalSection(&pstPrivate->csect);
    if (SndBufrIsBusy(pstPrivate))
        {
        if (!PurgeComm(pstPrivate->hWinComm, PURGE_TXCLEAR | PURGE_TXABORT))
            iRetVal = COM_DEVICE_ERROR;
        }
    LeaveCriticalSection(&pstPrivate->csect);

    return iRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: ComstdThread
 *
 * DESCRIPTION:
 *	This thread services three events, reads, writes and rithmatic, uh
 *	no, I mean comm events.  It uses overlapped I/O to accomplish this
 *	task which simplifies the task since thread contention between the
 *	different events is eliminated.
 *
 * ARGUMENTS:
 *	pvData - pointer to private comm handle
 *
 * RETURNS:
 *	Eventually
 *
 */
DWORD WINAPI ComstdThread(void *pvData)
    {
    ST_STDCOM *pstPrivate =  (ST_STDCOM *)pvData;
    DWORD      dwResult = WAIT_OBJECT_0;
    DWORD      dwError;
    DWORD      dwBytes;
    DWORD      dwComEvent = 0;
    long       lBytesRead;
    long       lReadSize;
    BYTE      *pbReadFrom;
    OVERLAPPED stReadOv;
    OVERLAPPED stEventOv;
    COMSTAT    stComStat;
    HANDLE      *pEvents;
    HCOM        hCom;
#if defined(DEBUG_CHARDUMP)
	int        iCnt;
#endif
	DWORD      dwEvents;

    DBG_THREAD("DBG_THREAD: ComstdThread starting\r\n",0,0,0,0,0);
    EnterCriticalSection(&pstPrivate->csect);

    // Set Read event to signaled to get the first Read operation going
    //
    pstPrivate->fBufrFull = TRUE;
    SetEvent(pstPrivate->ahEvent[EVENT_READ]);

    // Set ComEvent event to signaled to to get the first WaitCommEvent
    // started
    //
    SetEvent(pstPrivate->ahEvent[EVENT_COMEVENT]);

    // Clear any set state left by a previous connection.
    //
    ResetEvent(pstPrivate->ahEvent[EVENT_WRITE]);

    for ( ; ; )
        {
		dwEvents = DIM(pstPrivate->ahEvent);
        pEvents = pstPrivate->ahEvent;
        
        LeaveCriticalSection(&pstPrivate->csect);
        DBG_THREAD("DBG_THREAD: Waiting\r\n", 0,0,0,0,0);

        dwResult = WaitForMultipleObjects(dwEvents, pEvents,
            FALSE, INFINITE);

        DBG_THREAD("DBG_THREAD: WaitForMultipleObjects returned %d\r\n",
            dwResult,0,0,0,0);

        EnterCriticalSection(&pstPrivate->csect);

        // To get this thread to exit, the deactivate routine forces a
        // fake com event by calling SetCommMask
        //
        if (pstPrivate->fHaltThread)
            {
            LeaveCriticalSection(&pstPrivate->csect);
            DBG_THREAD("DBG_THREAD: ComStd exiting thread\r\n",0,0,0,0,0);
            ExitThread(0);
            }

        switch (dwResult)
            {
        case WAIT_OBJECT_0 + EVENT_READ:
            if (pstPrivate->fBufrFull)
                {
                DBG_READ("DBG_READ: Thread -- fBufrFull = FALSE\r\n",
                    0,0,0,0,0);

                pstPrivate->fBufrFull = FALSE;
                }
            else
                {
                if (GetOverlappedResult(pstPrivate->hWinComm, &stReadOv,
                    (DWORD *)&lBytesRead, FALSE))
                    {

                    pstPrivate->pbReadEnd += lBytesRead;
#if defined(DEBUG_CHARDUMP)
					if (lBytesRead > 0)
						{
						fprintf(pfDbgR,
							"Overlapped Read -- %d bytes 0x%p to 0x%p:",
								lBytesRead, pbReadFrom,
								pstPrivate->pbReadEnd - 1);
						for (iCnt = 0; iCnt < lBytesRead; ++iCnt)
							{
							if ((iCnt % 16) == 0)
								fputs("\n", pfDbgR);
							fprintf(pfDbgR, "%02X ", pbReadFrom[iCnt]);
							}
						fputs("\n", pfDbgR);
						}
#endif

                    if (pstPrivate->pbReadEnd >= pstPrivate->pbBufrEnd)
						{
                        pstPrivate->pbReadEnd = pstPrivate->pbBufrStart;
						}

                    DBG_READ("DBG_READ: Thread -- got %ld, ReadEnd==%x\r\n",
                        lBytesRead, pstPrivate->pbReadEnd,0,0,0);

                    if (pstPrivate->fBufrEmpty)
                        {
                        DBG_READ("DBG_READ: Thread -- fBufrEmpty = FALSE\r\n",
                            0,0,0,0,0);

                        pstPrivate->fBufrEmpty = FALSE;

                        hCom = pstPrivate->hCom;
                        LeaveCriticalSection(&pstPrivate->csect);
                        ComNotify(hCom, DATA_RECEIVED);
                        EnterCriticalSection(&pstPrivate->csect);
                        }
                    }
                else
					{
					switch (GetLastError())
						{
					case ERROR_OPERATION_ABORTED:
						// Operations can be aborted by calls to PurgeComm()
						// Allow setup for another read request.
						// mrw:12/14/95
						//
						break;

					default:
						// Com is failing for some reason.  Exit thread
						// so that we don't tie-up resources.
						//
	                    DBG_EVENTS("DBG_EVENTS: GetOverlappedResult "
                            "failed!\r\n",0,0,0,0,0);

						LeaveCriticalSection(&pstPrivate->csect);
						ExitThread(0);
						}
					}
                }

            // Do reads until we fill the buffer or we get an overlapped read
			//
            for ( ; ; )
                {
				// Check for wrap around in circular buffer
				//
                pbReadFrom = (pstPrivate->pbReadEnd >= pstPrivate->pbBufrEnd) ?
                             pstPrivate->pbBufrStart :
				             pstPrivate->pbReadEnd;

#if 0   // mrw:10/7/96 - enabled shiva fix for NT 4.0 Service Pack
        // Enabled for NT 4.0 release. Per Microsoft, leave this bug
        // in, so US and international versions are identical. It was
        // found between US and international releases.
        //
                // This was causing bad packets in Zmodem transfers when
                // using Shiva's LanRover, which appeared at baud rates
                // of 57600 or higher, and using TCP/IP to connect to the
                // LanRover. lReadSize in this code would not leave an
                // unused byte at the end of the buffer if pbComStart was
                // pointing to the beginning of the buffer.
                // - jmh 07-31-96
                lReadSize = (pbReadFrom < pstPrivate->pbComStart) ?
                    (pstPrivate->pbComStart - pbReadFrom - 1) :
                    (pstPrivate->pbBufrEnd - pbReadFrom);
#else
                // Determine the extent to which we're allowed to fill the
                // buffer. pbComStart points to the start of where the buffer
                // is "reserved", waiting to be emptied from. We make sure we
                // leave the byte before pbComStart empty. - jmh 07-31-96
                //
                if (pbReadFrom < pstPrivate->pbComStart)
					{
                    lReadSize = (long)(pstPrivate->pbComStart - pbReadFrom - 1);
					}
                else
                    {
                    lReadSize = (long)(pstPrivate->pbBufrEnd - pbReadFrom);
                    // The circular buffer code was written so that the address
                    // pointed to by pbBufrEnd is equated with pbBufrStart. We
                    // also need to make sure that if we've just calculated
                    // that we can read to the end of the buffer (aka the
                    // *start* of the buffer), and pbComStart is pointing to
                    // the start of the buffer, there's still an empty byte
                    // before pbComStart. - jmh 07-31-96
                    //
                    if (pstPrivate->pbComStart == pstPrivate->pbBufrStart)
                        lReadSize -= 1;
                    }
#endif

                if (lReadSize > MAX_READSIZE)
					{
                    lReadSize = MAX_READSIZE;
					}

                if (lReadSize == 0)
                    {
                    DBG_READ("DBG_READ: Thread -- fBufrFull = TRUE, "
                        "unsignalling EVENT_READ\r\n",0,0,0,0,0);

                    pstPrivate->fBufrFull = TRUE;
                    ResetEvent(pstPrivate->ahEvent[EVENT_READ]);
                    break;
                    }
                else
                    {
                    // Set up to do an overlapped read. From what I can make
                    // of the documenation, this may or may not complete
                    // immediately. So, to be safe, I will code it to expect
                    // either result.
                    //
                    stReadOv.Offset = stReadOv.OffsetHigh = 0;
                    stReadOv.hEvent = pstPrivate->ahEvent[EVENT_READ];

                    DBG_READ("DBG_READ: Thread -- ReadFile started, "
                        "ReadFrom==%x, ReadSize==%ld\r\n",
                        pbReadFrom, lReadSize, 0,0,0);

					// ReadFile resets the read event semaphore
					//
                    if (ReadFile(pstPrivate->hWinComm, pbReadFrom,
                        (DWORD)lReadSize, (DWORD *)&lBytesRead,
                        &stReadOv))
                        {
                        pstPrivate->pbReadEnd += lBytesRead;

#if defined(DEBUG_CHARDUMP)
						fprintf(pfDbgR,
							"Overlapped Read -- %d bytes 0x%p to 0x%p:",
								lBytesRead, pbReadFrom,
								pstPrivate->pbReadEnd - 1);
						for (iCnt = 0; iCnt < lBytesRead; ++iCnt)
							{
							if ((iCnt % 16) == 0)
								fputs("\n", pfDbgR);
							fprintf(pfDbgR, "%02X ", pbReadFrom[iCnt]);
							}
						fputs("\n", pfDbgR);
#endif

                        if (pstPrivate->pbReadEnd >= pstPrivate->pbBufrEnd)
                            pstPrivate->pbReadEnd = pstPrivate->pbBufrStart;

                        DBG_READ("DBG_READ: Thread -- ReadFile completed "
                            "synchronously, lBytesRead==%ld, ReadEnd==%x\r\n",
                            lBytesRead, pstPrivate->pbReadEnd,0,0,0);

                        if (pstPrivate->fBufrEmpty)
                            {
                            DBG_READ("DBG_READ: Thread -- fBufrEmpty = "
                                "FALSE\r\n", 0,0,0,0,0);

                            pstPrivate->fBufrEmpty = FALSE;

							hCom = pstPrivate->hCom;
                            LeaveCriticalSection(&pstPrivate->csect);
                            ComNotify(hCom, DATA_RECEIVED);
                            EnterCriticalSection(&pstPrivate->csect);
                            }
                        }
					else
						{
						switch (GetLastError())
							{
						case ERROR_IO_PENDING:
							break;

						case ERROR_OPERATION_ABORTED:
							// PurgeComm can do this.  Setup for another read.
							// mrw:12/14/95
							// But clear errors or the read may fail from
                            // now to eternity! We're in an infinite for-loop,
                            // after all. jmh:06-12-96
                            ClearCommError(pstPrivate->hWinComm, &dwError, &stComStat);
							continue;

						default:
							// Com is failing for some reason.  Exit thread
							// so that we don't tie-up resources.
							//
		                    DBG_READ("DBG_READ: ReadFile failed!\r\n",
                                0,0,0,0,0);

							LeaveCriticalSection(&pstPrivate->csect);
							ExitThread(0);
							}

						break;  // Come back when event signals
						}
                    }
                }
            break;

        case WAIT_OBJECT_0 + EVENT_WRITE:
            if (GetOverlappedResult(pstPrivate->hWinComm,
                &pstPrivate->stWriteOv, &dwBytes, FALSE) == FALSE)
                {
                dwError = GetLastError();
                DBG_WRITE("DBG_WRITE: %d Overlapped WriteFile failed: errno=%d\n",
                    GetTickCount(), dwError, 0, 0, 0);
                }
            else if (dwBytes < pstPrivate->dwBytesToSend && dwBytes != 0)
                {
                // ResetEvent(pstPrivate->ahEvent[EVENT_WRITE]);

                DBG_WRITE("DBG_WRITE: %d Write result -- dwBytes==%d\r\n",
                    GetTickCount(),dwBytes,0,0,0);

                // There's more to write. Seems kinda silly, but WriteFile
                // will return a success code, and dwBytes will show
                // there's still stuff to write. So we make another call
                // to WriteFile for what's remaining. Perhaps the write
                // timeout is too short. This happens for slower baud rates
                //
                pstPrivate->dwBytesToSend -= dwBytes;
                pstPrivate->dwSndOffset += dwBytes;

                pstPrivate->stWriteOv.Offset = pstPrivate->stWriteOv.OffsetHigh = 0;
                pstPrivate->stWriteOv.hEvent = pstPrivate->ahEvent[EVENT_WRITE];

                DBG_WRITE("DBG_WRITE: %d WriteFile(2) nSize==%d 0x%x\r\n",
                    GetTickCount(), pstPrivate->dwBytesToSend, pstPrivate->hWinComm, 0, 0);
                if (WriteFile(pstPrivate->hWinComm,
                    &pstPrivate->pbSndBufr[pstPrivate->dwSndOffset],
                    pstPrivate->dwBytesToSend,
                    &dwBytes, &pstPrivate->stWriteOv))
                    {
                    assert(dwBytes == pstPrivate->dwBytesToSend);
                    DBG_WRITE("DBG_WRITE: %d WriteFile(2) completed synchronously\r\n", GetTickCount(),0,0,0,0);
                    }
                else
                    {
                    dwError = GetLastError();
                    if (dwError == ERROR_IO_PENDING)
                        {
                        break;  // This is what we expect
                        }
                    else
                        {
                        DBG_WRITE("DBG_WRITE: %d WriteFile(2) failed %d 0x%x\r\n", GetTickCount(),dwError,pstPrivate->hWinComm,0,0);
                        }
                    }
                }
            else
                {
                // The write semaphore must be reset after the call to
                // GetOverlappedResult, because it checks the semaphore
                // to see if there's an outstanding write call. jmh 01-10-96
                //
                ResetEvent(pstPrivate->ahEvent[EVENT_WRITE]);
                }

            DBG_WRITE("DBG_WRITE: %d Write result -- dwBytes==%d\r\n",
                GetTickCount(),dwBytes,0,0,0);

            pstPrivate->dwBytesToSend = 0;
            pstPrivate->dwSndOffset = 0;

            pstPrivate->fSending = FALSE;

			hCom = pstPrivate->hCom;
            LeaveCriticalSection(&pstPrivate->csect);
            ComNotify(hCom, SEND_DONE);
            EnterCriticalSection(&pstPrivate->csect);
            break;

        case WAIT_OBJECT_0 + EVENT_COMEVENT:
            // WaitCommEvent is returning an event flag
            //
            ResetEvent(pstPrivate->ahEvent[EVENT_COMEVENT]);

            switch (dwComEvent)
                {
            case EV_ERR:
                ClearCommError(pstPrivate->hWinComm, &dwError, &stComStat);

                DBG_EVENTS("DBG_EVENTS: EV_ERR dwError==%x\r\n",
                    dwError,0,0,0,0);

                //* need code here to record errors, handle HHS stuck etc.
                break;

            case EV_RLSD: // receive-line-signal-detect changed state.
				hCom = pstPrivate->hCom;
                LeaveCriticalSection(&pstPrivate->csect);
                ComNotify(hCom, CONNECT);
                EnterCriticalSection(&pstPrivate->csect);
                DBG_EVENTS("DBG_EVENTS: EV_RLSD\r\n", 0,0,0,0,0);
                break;

            default:
                DBG_EVENTS("DBG_EVENTS: EV_??? (dwComEvent==%x)\r\n",
                    dwComEvent,0,0,0,0);
                break;
                }

            // Start up another overlapped WaitCommEvent to get the
            // next event
            //
            stEventOv.Offset = stEventOv.OffsetHigh = (DWORD)0;
            stEventOv.hEvent = pstPrivate->ahEvent[EVENT_COMEVENT];

            if (WaitCommEvent(pstPrivate->hWinComm, &dwComEvent, &stEventOv))
                {
                // Call completed synchronously, re-signal our event object
                //
                DBG_EVENTS("DBG_EVENTS: WaitCommEvent completed "
                    "synchronously\r\n",0,0,0,0,0);

                SetEvent(pstPrivate->ahEvent[EVENT_COMEVENT]);
                }

            else
                {
				switch (GetLastError())
					{
				case ERROR_IO_PENDING:
                    break;

				case ERROR_OPERATION_ABORTED:
                    // Not sure this can happen but we'll code it like
                    // the read. - mrw:12/14/95
                    //
                    DBG_EVENTS("DBG_EVENTS: WaitCommEvent - "
                        "ERROR_OPERATION_ABORTED\r\n",0,0,0,0,0);

                    SetEvent(pstPrivate->ahEvent[EVENT_COMEVENT]);
					break;

				default:
					// Com is failing for some reason.  Exit thread
					// so that we don't tie-up resources.
					//
                    DBG_EVENTS("DBG_EVENTS: WaitCommEvent failed!\r\n",
                        0,0,0,0,0);

					LeaveCriticalSection(&pstPrivate->csect);
					ExitThread(0);
					}
                }
            break;

        default:
            break;
            }
        }

	LeaveCriticalSection(&pstPrivate->csect);
    DBG_THREAD("DBG_THREAD: ComstdThread exiting\r\n",0,0,0,0,0);

    return (DWORD)0;
    }


/* --- AUTO DETECT ROUTINES --- */

static int Nibble[] = {0,1,1,0,1,0,0,1,1,0,0,1,0,1,1,0}; // 1=odd, 0=even
#define OddBits(b) (Nibble[(b) / 16] ^ Nibble[(b) % 16])

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  AutoDetectAnalyze
 *
 * DESCRIPTION:
 *  Analyzes incoming data to determine the char size, parity type and
 *  stop bits
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void AutoDetectAnalyze(ST_STDCOM *pstPrivate, int nBytes, char *pchBufr)
    {
    char *pchScan = pchBufr;
    char *pszMsg;
    int fForceTo7Bits = FALSE;
    int iCnt = nBytes;

    if (!pstPrivate->fADRunning)
		{
        AutoDetectStart(pstPrivate);

		// This was a temporary fix I used while debugging a 7E1 problem that I decided
		// to leave in because it may help in some situations and shouldn't hurt.
		// In my case, when a GVC Fax 11400 V.42bis/MNP5 modem was installed as
		// "Standard Modem", an initial 8N1 CRLF from the modem negotiation got through
		// even when connecting to a 7E1 host. This made auto detect decide the whole
		// connection was 8N1. I fixed it with this little patch. Once I reinstalled the
		// modem as itself, it worked without the patch. This is not a rigourous fix
		// because there is no guarantee that there will be only two extraneous characters
		// or that they will be read all by themselves -- but this will fix the problems
		// in some typical cases and will do no harm.	jkh 9/9/98
		if (iCnt <= 2)	
			return;
		}

    if (pstPrivate->nFramingErrors > 0)
        {
        DBG_AD("DBG_AD: Got Framing Errors: shutting down\r\n", 0,0,0,0,0);
        AutoDetectStop(pstPrivate);
        // MessageBox(NULL,
        //            "Would use Wizard code here. Either wrong baud rate "
        //            "is set or unusual settings have been encountered. "
        //            "Finished code may be able to handle some cases included here.",
        //             "Auto Detection Wizard", MB_OK);
        return;
        }

    pstPrivate->nADTotal += iCnt;

    // for each byte, determine whether the lower 7 bits contain an odd
    //  number of 1 bits, then determine whether the byte would be a valid
    //  7e1 character.
    while (iCnt--)
        {
        if (OddBits(*pchScan & 0x7F))
            ++pstPrivate->nADMix;
        if (OddBits(*pchScan))
            ++pstPrivate->nAD7o1;
        if (*pchScan & 0x80)
            ++pstPrivate->nADHighBits;
        ++pchScan;
        }

    // See whether we can make any decision with what we've got
    if (pstPrivate->nADMix > 0 && pstPrivate->nADMix < pstPrivate->nADTotal)
        {
        // We now have both kinds of characters: those with an even and
        //  an odd number of bits in the lower 7 bits - so we can make
        //  a guess.
        if (pstPrivate->nAD7o1 == pstPrivate->nADTotal)
            pstPrivate->nADBestGuess = AD_7O1;
        else if (pstPrivate->nAD7o1 == 0)
            pstPrivate->nADBestGuess = AD_7E1;
        else
            pstPrivate->nADBestGuess = AD_8N1;
        }

    DBG_AD("DBG_AD: Cnt=%3d, Mix=%3d, 7o1=%3d, HB=%3d BG=%d\r\n",
        pstPrivate->nADTotal, pstPrivate->nADMix,
        pstPrivate->nAD7o1,   pstPrivate->nADHighBits,
        pstPrivate->nADBestGuess);

    // See whether we've checked a sufficient sample to determine settings
    if (pstPrivate->nADBestGuess != AD_8N1 &&
    (pstPrivate->nADTotal < MIN_AD_TOTAL ||
        pstPrivate->nADMix < MIN_AD_MIX ||
        (pstPrivate->nADTotal - pstPrivate->nADMix) < MIN_AD_MIX))
        {
        // Data sample is insufficient to draw a conclusion.
        // For now, let the data display as 7-bit data and wait for more
        fForceTo7Bits = TRUE;
        }
    else
        {
        // We have enough data to make a decision
        if (pstPrivate->nAD7o1 == 0)
            {
            // Data is 7-even-1
            pstPrivate->stWorkSettings.nDataBits = 7;
            pstPrivate->stWorkSettings.nParity = EVENPARITY;
            fForceTo7Bits = TRUE;
            pstPrivate->fADReconfigure = TRUE;
            pszMsg = "Establishing settings of 7-Even-1";
            }
        else if (pstPrivate->nAD7o1 == pstPrivate->nADTotal)
            {
            // Data is 7-odd-1
            pstPrivate->stWorkSettings.nDataBits = 7;
            pstPrivate->stWorkSettings.nParity = ODDPARITY;
            fForceTo7Bits = TRUE;
            pstPrivate->fADReconfigure = TRUE;
            pszMsg = "Establishing settings of 7-Odd-1";
            }
        else
            {
            // Data is most likely 8-none-1. But if the high bit was
            //  set on all the received data, it may have been 7-mark-1 or
            //  some other odd setting
            pstPrivate->stWorkSettings.nDataBits = 8;
            pstPrivate->stWorkSettings.nParity = NOPARITY;
            if (pstPrivate->nADHighBits == pstPrivate->nADTotal)
                pszMsg = "Settings are either 8-none-1 or something quite "
                "odd like 7-mark-one. A wizard would pop up here"
                "asking the user if the data looked correct and"
                "offering suggestions if it did not.";
            else
                pszMsg = "Establishing settings of 8-none-1";
            }

        // Decision has been made, so turn auto detect off
        DBG_AD("DBG_AD: %s\r\n", pszMsg, 0,0,0,0);
        AutoDetectStop(pstPrivate);
        if (pstPrivate->fADReconfigure)
            {
            DBG_AD("DBG_AD: Reconfiguring port\r\n", 0,0,0,0,0);
            PortConfigure(pstPrivate);
            }
        // MessageBox(NULL, pszMsg, "Auto Detection Done", MB_OK);
        }

    if (fForceTo7Bits)
        {
        while (nBytes--)
            {
            *pchBufr = (char)(*pchBufr & 0x7F);
            ++pchBufr;
            }
        }
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  AutoDetectOutput
 *
 * DESCRIPTION:
 *  Checks state of auto detection and alters outgoing characters to
 *  reflect the best guess of their parity status.
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void AutoDetectOutput(ST_STDCOM *pstPrivate, void *pvBufr, int nSize)
    {
    char *pch  = (char *)pvBufr;

    if (!pstPrivate->fADRunning)
        AutoDetectStart(pstPrivate);

    switch (pstPrivate->nADBestGuess)
        {
    case AD_8N1:
        // Do nothing
        break;

    case AD_7E1:
        // Make output look like 7e1
        DBG_AD("DBG_AD: Converting %d output char(s) to 7E1\r\n",
            nSize, 0,0,0,0);
        while (nSize--)
            {
            if (OddBits(*pch & 0x7F))
                *pch |= 0x80;
            ++pch;
            }
        break;

    case AD_7O1:
        // Make output look like 7o1
        DBG_AD("DBG_AD: Converting %d output char(s) to 7O1\r\n",
            nSize, 0,0,0,0);
        while (nSize--)
            {
            if (!OddBits(*pch & 0x7F))
                *pch |= 0x80;
            ++pch;
            }
        break;

    case AD_DONT_KNOW:
        // As long as the same single character is being sent
        //  out repeatedly, toggle the parity bit every other time

        //
        // This additional comment added. REV: 06/15/2001
        //
        // Some host systems that are 7-Even-1 or 7-Odd-1 require
        // specific characters to be received in order to connect
        // When HT is in AutoDetect mode, it is sending 8-None-1
        // data, so the character that is sent will not be the
        // character required to connect.  In order to connect to
        // the 7-Even-1 or 7-Odd-1 system, we must set the parity
        // bit on the outbound character *pch = (*pch ^ (char)0x80);
        // which will display a garbage character in HT.  By setting
        // the parity bit HT is now sending 7-Even-1 or 7-Odd-1 data
        // depending on the character.
        //
        // An example is a 7E1 Genie systems require the user to
        // enter <Ctrl>u or <Return> multiple times in order to
        // connect.
        //

        if (nSize != 1)
            {
            pstPrivate->chADLastChar = '\0';
            pstPrivate->fADToggleParity = FALSE;
            }
        else
            {
            if (*pch != pstPrivate->chADLastChar)
                {
                pstPrivate->chADLastChar = *pch;
                pstPrivate->fADToggleParity = FALSE;
                }
            else
                {
                if (pstPrivate->fADToggleParity)
                    *pch = (*pch ^ (char)0x80);
                pstPrivate->fADToggleParity = !pstPrivate->fADToggleParity;
                }
            }
        break;

    default:
        assert(FALSE);
        break;
        }
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  AutoDetectStart
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void AutoDetectStart(ST_STDCOM *pstPrivate)
    {
    DBG_AD("DBG_AD: AutoDetectStart\r\n", 0,0,0,0,0);
    pstPrivate->nADTotal = 0;
    pstPrivate->nADMix = 0;
    pstPrivate->nAD7o1 = 0;
    pstPrivate->nADHighBits = 0;
    pstPrivate->nADBestGuess = AD_DONT_KNOW;
    pstPrivate->fADRunning = TRUE;
    pstPrivate->chADLastChar = '\0';
    pstPrivate->fADToggleParity = FALSE;
    pstPrivate->fADReconfigure = FALSE;
    pstPrivate->nFramingErrors = 0;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  AutoDetectStop
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void AutoDetectStop(ST_STDCOM *pstPrivate)
    {
    HSESSION hSession;

    DBG_AD("DBG_AD: AutoDetectStop\r\n", 0,0,0,0,0);
    pstPrivate->stWorkSettings.fAutoDetect = FALSE;
    pstPrivate->fADRunning = FALSE;

    ComGetSession(pstPrivate->hCom, &hSession);

    PostMessage(sessQueryHwndStatusbar(hSession),
        SBR_NTFY_REFRESH, (WPARAM)SBR_COM_PART_NO, 0);
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  ComstdGetAutoDetectResults
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int ComstdGetAutoDetectResults(void *pvData, BYTE *bByteSize,
    BYTE *bParity, BYTE *bStopBits)
    {
    ST_STDCOM *pstPrivate =  (ST_STDCOM *)pvData;

    assert(bByteSize);
    assert(bParity);
    assert(bStopBits);

    if (pstPrivate->fADReconfigure)
        {
        *bByteSize = (BYTE)pstPrivate->stWorkSettings.nDataBits;
        *bParity   = (BYTE)pstPrivate->stWorkSettings.nParity;
        *bStopBits = (BYTE)pstPrivate->stWorkSettings.nStopBits;
        }
    DBG_AD("DBG_AD: ComstdGetAutoDetectResults returning %d\r\n",
        pstPrivate->fADReconfigure, 0,0,0,0);
    DBG_AD("   (bits = %d, parity = %d, stops = %d)\r\n",
        *bByteSize, *bParity, *bStopBits, 0,0);
    return pstPrivate->fADReconfigure;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *      ComstdSettingsToDCB
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
static void ComstdSettingsToDCB(ST_STDCOM_SETTINGS *pstSettings, DCB *pstDcb)
    {
    unsigned         afHandshake;

    afHandshake = pstSettings->afHandshake;

    // fill in device control block
    pstDcb->BaudRate = (DWORD)pstSettings->lBaud;
    pstDcb->fBinary = 1;
    pstDcb->fParity = 1;
    pstDcb->fOutxCtsFlow = (BYTE)((bittest(afHandshake, HANDSHAKE_SND_CTS)) ? 1 : 0);
    pstDcb->fOutxDsrFlow = (BYTE)(bittest(afHandshake, HANDSHAKE_SND_DSR) ? 1 : 0);
    pstDcb->fDtrControl = bittest(afHandshake, HANDSHAKE_RCV_DTR) ?
        DTR_CONTROL_HANDSHAKE : DTR_CONTROL_ENABLE;
    pstDcb->fDsrSensitivity = 0;
    pstDcb->fTXContinueOnXoff = TRUE;
    pstDcb->fOutX = (BYTE)(bittest(afHandshake, HANDSHAKE_SND_X) ? 1 :0);
    pstDcb->fInX =  (BYTE)(bittest(afHandshake, HANDSHAKE_RCV_X) ? 1 :0);
    pstDcb->fErrorChar = 0;
    pstDcb->fNull = 0;
    pstDcb->fRtsControl = bittest(afHandshake, HANDSHAKE_RCV_RTS) ?
        RTS_CONTROL_HANDSHAKE : RTS_CONTROL_ENABLE;
    pstDcb->fAbortOnError = 1;      // so we can count all errors
    pstDcb->XonLim = 80;
    pstDcb->XoffLim = 200;
    pstDcb->ByteSize = (BYTE)pstSettings->nDataBits;
    pstDcb->Parity   = (BYTE)pstSettings->nParity;
    pstDcb->StopBits = (BYTE)pstSettings->nStopBits;
    pstDcb->XonChar = pstSettings->chXON;
    pstDcb->XoffChar = pstSettings->chXOFF;

    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *      ComstdDCBToSettings
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
static void ComstdDCBToSettings(DCB *pstDcb, ST_STDCOM_SETTINGS *pstSettings)
    {
    pstSettings->lBaud = (long)pstDcb->BaudRate;
    pstSettings->afHandshake = 0;
    if (pstDcb->fOutxCtsFlow)
        bitset(pstSettings->afHandshake, HANDSHAKE_SND_CTS);
    if (pstDcb->fOutxDsrFlow)
        bitset(pstSettings->afHandshake, HANDSHAKE_SND_DSR);
    if (pstDcb->fDtrControl == DTR_CONTROL_HANDSHAKE)
        bitset(pstSettings->afHandshake, HANDSHAKE_RCV_DTR);
    if (pstDcb->fOutX)
        bitset(pstSettings->afHandshake, HANDSHAKE_SND_X);
    if (pstDcb->fInX)
        bitset(pstSettings->afHandshake, HANDSHAKE_RCV_X);
    if (pstDcb->fRtsControl == RTS_CONTROL_HANDSHAKE)
        bitset(pstSettings->afHandshake, HANDSHAKE_RCV_RTS);
    pstSettings->nDataBits = pstDcb->ByteSize;
    pstSettings->nParity = pstDcb->Parity;
    pstSettings->nStopBits = pstDcb->StopBits;
    pstSettings->chXON = pstDcb->XonChar;
    pstSettings->chXOFF = pstDcb->XoffChar;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: DeviceBreakTimerProc
 *
 * DESCRIPTION:
 *  Called when the break timer goes off. A timer is started whenever we
 *  set the break signal on. It goes off after the break signal duration.
 *  This function clears the break signal and destroys the timer
 *
 * ARGUMENTS:
 *  dwData  -- A value stored when the timer is created. Contains pstPrivate
 *
 * RETURNS:
 *
 */
static void DeviceBreakTimerProc(void *pvData, long ulSince)
    {
    ST_STDCOM *pstPrivate = (ST_STDCOM *)pvData;

	if (pstPrivate)
		{
		TimerDestroy(&pstPrivate->hTmrBreak);       // this is a one-shot op
		ClearCommBreak(pstPrivate->hWinComm);    // have Win comm driver do it
		pstPrivate->fBreakSignalOn = FALSE;
		}

	return;
    }

#if 0
void StdcomRecordErrors(ST_STDCOM *pstPrivate, int iErrorBits)
    {
    if (bittest(iErrorBits, CE_FRAME | CE_OVERRUN | CE_RXOVER | CE_RXPARITY))
        {
        if (bittest(iErrorBits, CE_FRAME))
            ++pstPrivate->nFramingErrors;

        if (bittest(iErrorBits, CE_OVERRUN))
            ++pstPrivate->nOverrunErrors;

        if (bittest(iErrorBits, CE_RXOVER))
            ++pstPrivate->nOverflowErrors;

        if (bittest(iErrorBits, CE_RXPARITY))
            ++pstPrivate->nParityErrors;
        }
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: DeviceReportError
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void DeviceReportError(ST_STDCOM *pstPrivate, UINT uiStringID,
    LPSTR pszOptInfo, BOOL fFirstOnly)
    {
    CHAR szFmtString[250];
    CHAR szErrString[250];

    if (LoadString(hinstDLL, uiStringID, szFmtString, sizeof(szFmtString) / sizeof(TCHAR)) > 0)
        {
        wsprintf(szErrString, szFmtString, pszOptInfo);
        ComReportError(pstPrivate->hCom, 0, szErrString, fFirstOnly);
        }
    }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\comstd\rc_id.h ===
/* rc_id.hh -- Private header file for stdcom communications driver module
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:02p $
 */

/* --- Resource IDs --- */

// Dialog control IDs
#define ID_CB_XSENDING	101
#define ID_CB_XRECVING	102
#define ID_CMB_XON		103
#define ID_CMB_XOFF 	104
#define ID_RB_RX_NONE	105
#define ID_RB_RX_RTS	106
#define ID_RB_RX_DTR	107
#define ID_RB_TX_NONE	108
#define ID_RB_TX_CTS	109
#define ID_RB_TX_DSR	110
#define ID_CMB_BREAK_DUR 111
#define ID_TEXT_PARITY	 112
#define ID_TEXT_FRAMING  113
#define ID_TEXT_OVERFLOW 114
#define ID_TEXT_OVERRUN  115


// String IDs
#define SID_DEVICE_NAME 	1
#define SID_ERR_VERSION 	2
#define SID_ERR_NOMEM		3
#define SID_ERR_NOPORT		4
#define SID_ERR_NOOPEN		5
#define SID_ERR_NOTIMER 	6
#define SID_ERR_WINDRIVER	7
#define SID_ERR_BADSETTING	8
#define SID_ERR_BADBAUD 	9
#define SID_ERR_BADCHARVAL	10
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\comstd\comstd.hh ===
/* comstd.hh -- Private header file for stdcom communications driver module
 *
 *  Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *  All rights reserved
 *
 *  $Revision: 6 $
 *  $Date: 1/18/02 4:59p $
 */

// -=-=-=-=-=-=-=-=-=-=-=-=-=- DEBUG CONTROL -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

// These constants are used to turn on various types of debug display
//#define DEBUG_THREAD 	  // Thread startup and shutdown
//#define DEBUG_READ		  // Read operations, main & thread
//#define DEBUG_WRITE		  // Write operations, main & thread
//#define DEBUG_EVENTS       // Com Events handled in thread
//#define DEBUG_AD           // Auto Detect

#if defined(DEBUG_THREAD)
    #define DEBUGSTR
    #define DBG_THREAD(s,a1,a2,a3,a4,a5) DbgOutStr(s,a1,a2,a3,a4,a5)
#else
    #define DBG_THREAD(s,a1,a2,a3,a4,a5)
#endif

#if defined(DEBUG_READ)
    #define DEBUGSTR
    #define DBG_READ(s,a1,a2,a3,a4,a5) DbgOutStr(s,a1,a2,a3,a4,a5)
#else
    #define DBG_READ(s,a1,a2,a3,a4,a5)
#endif

#if defined(DEBUG_WRITE)
    #define DEBUGSTR
    #define DBG_WRITE(s,a1,a2,a3,a4,a5) DbgOutStr(s,a1,a2,a3,a4,a5)
#else
    #define DBG_WRITE(s,a1,a2,a3,a4,a5)
#endif

#if defined(DEBUG_EVENTS)
    #define DEBUGSTR
    #define DBG_EVENTS(s,a1,a2,a3,a4,a5) DbgOutStr(s,a1,a2,a3,a4,a5)
#else
    #define DBG_EVENTS(s,a1,a2,a3,a4,a5)
#endif

#if defined(DEBUG_AD)
    #define DEBUGSTR
    #define DBG_AD(s,a1,a2,a3,a4,a5) DbgOutStr(s,a1,a2,a3,a4,a5)
#else
    #define DBG_AD(s,a1,a2,a3,a4,a5)
#endif


// -=-=-=-=-=-=-=-=-=-=-=-=-=- DEFINITIONS -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

#define SIZE_INQ     1152
#define SIZE_OUTQ    2048
#define MAX_READSIZE 80L

// Set these values to make auto detection work
#define MIN_AD_TOTAL 15
#define MIN_AD_MIX   6

// Values for nBestGuess
#define AD_DONT_KNOW 0
#define AD_8N1       1
#define AD_7O1       2
#define AD_7E1       3

// Flag values in afHandshake
#define HANDSHAKE_RCV_X     0x0001
#define HANDSHAKE_RCV_DTR   0x0002
#define HANDSHAKE_RCV_RTS   0x0004
#define HANDSHAKE_SND_X     0x0008
#define HANDSHAKE_SND_CTS   0x0010
#define HANDSHAKE_SND_DSR   0x0020
#define HANDSHAKE_SND_DCD   0x0040

#define MDMSTAT_CTS 0x10
#define MDMSTAT_DSR 0x20
#define MDMSTAT_DCD 0x80

#define STDCOM struct s_stdcom *

// System value item IDs

#define SFID_COMSTD_BAUD          0x1011
#define SFID_COMSTD_DATABITS      0x1012
#define SFID_COMSTD_STOPBITS      0x1013
#define SFID_COMSTD_PARITY        0x1014
#define SFID_COMSTD_HANDSHAKING   0x1015
#define SFID_COMSTD_XON           0x1016
#define SFID_COMSTD_XOFF          0x1017
#define SFID_COMSTD_BREAK         0x1018
#define SFID_COMSTD_AUTODETECT    0x1019

// Identifiers for events in ahEvents
#define EVENT_COMEVENT  0
#define EVENT_READ      1
#define EVENT_WRITE     2
#define EVENT_COUNT     3

#if defined(INCL_WINSOCK)
// Size of receive circular buffer
#define WSOCK_SIZE_INQ       	1500

// Size of send circular bufffer. Don't make too big or status displays
//  during file transfers will act oddly.
#define WSOCK_SIZE_OUTQ      	3000

#define WSOCK_MAX_READSIZE 	1500L
#define IP_ADDR_LEN     128

// Note: This was once "HA/WinSock" however this would cause HyperTerminal
// to crash if HAWin16 was running and using WinSock. Since this was an
// obvious cut-and-paste job, I have changed this to be unique for
// HyperTerminal. - cab:12/06/96
//
#define	WINSOCK_EVENT_WINDOW_CLASS	"HyperTrm/WinSock"

#define	WM_WINSOCK_NOTIFY	(WM_USER+133)
#define	WM_WINSOCK_RESOLVE	(WM_USER+134)
#define WM_WINSOCK_STARTUP  (WM_USER+135)

#define MODE_MAX    5
#endif  // defined(INCL_WINSOCK)

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-= TYPES =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

typedef struct s_stdcom_settings
    {
    long     lBaud;
    int      nDataBits;
    int      nStopBits;
    int      nParity;
    unsigned afHandshake;
    TCHAR    chXON;
    TCHAR    chXOFF;
    int      nBreakDuration;
    int      fAutoDetect;
    } ST_STDCOM_SETTINGS;

#if defined(INCL_WINSOCK)
struct stOptionStateData
	{
	int option;
	int us;
	int usq;
	int him;
	int himq;
	};
typedef struct stOptionStateData STOPT;
typedef STOPT FAR * PSTOPT;
#endif  // defined(INCL_WINSOCK)

typedef struct s_stdcom
    {
    // Configuration details
    ST_STDCOM_SETTINGS stFileSettings;
    ST_STDCOM_SETTINGS stWorkSettings;

    // These are control variables private to the stdcom driver
    HCOM     hCom;                 // access to com routines
    HANDLE   hWinComm;             // handle to windows comm device
    HTIMER   hTmrBreak;            // Timer to control break duration
    int      fBreakSignalOn;       // TRUE while sending break signal
    int      fNotifyRcv;           // TRUE if driver should send notification
    DWORD    dwEventMask;          // Mask used in Set/GetCommEventmask
    int      fSending;             // TRUE if we've sent a buffer of data
    long     lSndTimer;            // started when we issue a WriteComm
    long     lSndLimit;            // amt. of time to wait for send
    long     lSndStuck;            // amt. of time we've been waiting for
                                   //   handshaking
    HWND     hwndEvents;           // window to process event messages
                                   //  generate messages for us
    BYTE     bLastMdmStat;
    OVERLAPPED stWriteOv;

    // Control fields for receiving
    int     nRBufrSize;            // Size of receive buffer
    BYTE   *pbBufrStart;           // Address of receive buffer
    BYTE   *pbBufrEnd;
    BYTE   *pbReadEnd;             // Where read thread left off
    BYTE   *pbComStart;            // Marks area being unloaded by main Com
    BYTE   *pbComEnd;
    int     fBufrFull;             // True when driver buffers are full
    int     fBufrEmpty;            // True when driver buffers are empty

    // Control fields for sending
    DWORD   dwBytesToSend;          // Number of bytes pending for write
    DWORD   dwSndOffset;            // Offset into send buffer for write
    BYTE   *pbSndBufr;              // Buffer used by pending write calls

    // Error counts
    int     nParityErrors;
    int     nFramingErrors;
    int     nOverrunErrors;
    int     nOverflowErrors;

    // Auto detection fields
    int  fADRunning;
    int  nADTotal;
    int  nADMix;
    int  nAD7o1;
    int  nADHighBits;
    int  nADBestGuess;
    char chADLastChar;
    int  fADToggleParity;
    int  fADReconfigure;

    HANDLE  hComstdThread;         // Thread to handle ongoing activity
    int     fHaltThread;           // To control when thread shuts down

    // Data access control
    CRITICAL_SECTION csect;        // To synchronize access to driver vars.
    HANDLE  ahEvent[EVENT_COUNT];  // To control scheduling

#if defined(INCL_WINSOCK)
    // Configuration details
	// These are control variables private to the tcpip comm driver
	SOCKET          hSocket;            // connected socket
	int             fConnected;         // COM_PORT_UNINITIALIZED initially,
	                                    // COM_PORT_NOT_OPEN if init'd,
										// COM_PORT_OPEN connected
	TCHAR           szRemoteAddr[IP_ADDR_LEN];// IP address
	short           nPort;              // Port number
	unsigned long   ulCompatibility;    // to pass flags into dialogs

	ULONG  ulAddr;

	// These are control variables private to the stdcom driver
	int		 fSndBreak;		   	   // emulate a break sequence

    // Control fields for receiving
	BYTE	*pbSendBufr;			// Pointer to data passed to SndBufrSend
	int	    nSendBufrLen;			// Amount of data to send
	BYTE	abSndBufr[WSOCK_SIZE_OUTQ*2];	// Buffer to send when Winsock is ready
	BYTE    *pbSndPtrEnd;			// Current offset in auchSndBufr

    HANDLE  hComReadThread;        	// Thread to handle reading from network
    HANDLE  hComWriteThread;       	// Thread to handle writing to network
    HANDLE  hComConnectThread;      // Thread to handle connecting to host
	int		fClearSendBufr;			// flag to signal send buffer to be cleared
	int		fEscapeFF;				// We are escaping FF characters (by doubling)
	int		fSeenFF;				// We have just encountered and FF character

    union {                                     // JYF: 29-Sep-2000, fix alignment fault
        HOSTENT stHostBuf;                      // used by WSAGetHostByName
        BYTE    pcharHostBuf[MAXGETHOSTSTRUCT]; // for allocating MAXGETHOSTSTRUCT bytes
        };

    struct sockaddr_in  stHost;

    // Pointers to socket library functions (porting note: these are just pasted in from winsock.h
    // with the function pointer declaration fixed up)
    int (PASCAL * FAR accept)( int, struct sockaddr *, int * );
    int (PASCAL * FAR bind)( int, struct sockaddr *, int );
    int (PASCAL * FAR connect)( int, struct sockaddr *, int );
    int (PASCAL * FAR gethostid)(void);
    int (PASCAL * FAR listen)( int, int);
    int (PASCAL * FAR recv)( int, char *, int, int );
    int (PASCAL * FAR send)( int, char *, int, int );
    int (PASCAL * FAR sock_init)( void );
    int (PASCAL * FAR sock_errno)( void );
    int (PASCAL * FAR socket)( int, int, int );
    int (PASCAL * FAR soclose)( int );
    int (PASCAL * FAR shutdown)(int, int);
    int (PASCAL * FAR setsockopt)( int, int, int, char *, int );

    // from netdb.h
    struct hostent * (PASCAL * FAR gethostbyname)( char * );

    // from netinet/in.h
    unsigned long (PASCAL * FAR inet_addr)(char *);

    // from utils.h
    unsigned short (PASCAL * FAR bswap)(unsigned short);

    // Telnet emulation data
    int         NVTstate;       // Current state of Network Virtual Terminal
    STOPT       stMode[MODE_MAX];

#ifdef INCL_CALL_ANSWERING
	// Answer mode variables - cab:11/19/96
	//
	int	fAnswer;			// Are we waiting for a call?
#endif
	
#endif  // defined(INCL_WINSOCK)
    } ST_STDCOM;


// -=-=-=-=-=-=-=-=-=-=-=- Globals -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
extern   HINSTANCE hinstDLL;



// -=-=-=-=-=-=-=-=-=-=-=- EXPORTED PROTOTYPES -=-=-=-=-=-=-=-=-=-=-=-=-=-=-

int    WINAPI DeviceInitialize(HCOM hCom, unsigned usInterfaceVersion,
                    void **ppvDriverData);
int    WINAPI DeviceClose(ST_STDCOM *pstPrivate);
int    WINAPI DeviceDialog(ST_STDCOM *pstPrivate, HWND hwndParent);
int    WINAPI DeviceGetCommon(ST_STDCOM *pstPrivate, ST_COMMON *pstCommon);
int    WINAPI DeviceSetCommon(ST_STDCOM *pstPrivate, ST_COMMON *pstCommon);
int    WINAPI DeviceSpecial(ST_STDCOM *pstPrivate,
                    const TCHAR *pszInstructions,
                    TCHAR *pszResult,
                    int   nBufrSize);
int    WINAPI DeviceLoadHdl(ST_STDCOM *pstPrivate, SF_HANDLE sfHdl);
int    WINAPI DeviceSaveHdl(ST_STDCOM *pstPrivate, SF_HANDLE sfHdl);
int    WINAPI PortConfigure(ST_STDCOM *pstPrivate);
int    WINAPI PortActivate(ST_STDCOM *pstPrivate,
                    TCHAR *pszPortName,
                    DWORD_PTR dwMediaHdl);
int    WINAPI PortDeactivate(ST_STDCOM *pstPrivate);
int    WINAPI PortConnected(ST_STDCOM *pstPrivate);
int           PortExtractSettings(ST_STDCOM *pstPrivate);
int           PortDefaultSettings(ST_STDCOM *pstPrivate);

int    WINAPI RcvRefill(ST_STDCOM *pstPrivate);
int    WINAPI RcvClear(ST_STDCOM *pstPrivate);

int    WINAPI SndBufrSend(ST_STDCOM *pstPrivate, void *pvBufr,
                      int nSize);
int    WINAPI SndBufrIsBusy(ST_STDCOM *pstPrivate);
int    WINAPI SndBufrQuery(ST_STDCOM *pstPrivate, unsigned *pafStatus,
                      long *plHandshakeDelay);
int    WINAPI SndBufrClear(ST_STDCOM *pstPrivate);
DWORD  WINAPI ComstdThread(void *pvData);
void          AutoDetectAnalyze(ST_STDCOM *pstPrivate, int nBytes, char *pchBufr);
void          AutoDetectOutput(ST_STDCOM *pstPrivate, void *pvBufr, int nSize);
void          AutoDetectStart(ST_STDCOM *pstPrivate);
void          AutoDetectStop(ST_STDCOM *pstPrivate);
void          ComstdSettingsToDCB(ST_STDCOM_SETTINGS *pstSettings, DCB *pstDcb);
void          ComstdDCBToSettings(DCB *pstDcb, ST_STDCOM_SETTINGS *pstSettings);

// Temporary til TAPI lets us change media handle settings correctly
int           ComstdGetAutoDetectResults(void *pvData, BYTE *bByteSize,
                BYTE *bParity, BYTE *bStopBits);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\comwsock\comwsock.c ===
/*  File: D:\WACKER\comwsock\comwsock.c (Created: 12/26/95)
 *
 *  Copyright 1996 by Hilgraeve Inc. -- Monroe, MI
 *  All rights reserved
 *
 *  $Revision: 22 $
 *  $Date: 7/08/02 6:31p $
 *
 *  $Log: /Products/wacker/Comwsock/Comwsock.c $
 * 
 * 22    7/08/02 6:31p Dans
 * Replaced StrCharCopy to StrCharCopyN to protect against buffer
 * overruns.
 * 
 * 21    5/31/02 3:48p Ronv
 * fAnswer is a flag i n the ST_STDCOM structure.  This revision makes
 * sure the value is set to FALSE (this did not cause any problems in the
 * past since FALSE is defined as 0 on Windows).
 * 
 * 19    4/30/02 4:02p Ronv
 * Handles to events should not use INVALID_HANDLE_VALUE since that is
 * just a value to be used for file handles.
 * 
 * 18    4/16/02 2:36p Ronv
 * No need to register the window class again if it is already registered.
 * 
 * 17    4/10/02 3:12p Ronv
 * Now using INVALID_HANDLE_VALUE to make sure the Com handles (event
 * handles) are released and freed correctly.
 * 
 * 16    4/05/02 4:26p Ronv
 * Cleaned up some logic in WsckSndBufrSend() to release the critical
 * section as soon as possible so that we don't get into a thread lock.
 * 
 * 15    3/22/02 1:53p Ronv
 * 
 * 14    3/20/02 11:45a Ronv
 * Revisions per MS to cleaning up the use of handles outside of crital
 * locks (MS security review).
 * 
 * 13    2/25/02 1:17p Ronv
 * 02-19-2002 MS Source Code Drop
 * 
 * 12    1/18/02 4:59p Ronv
 * Made sure the serial port defaults are used when the serial port is
 * selected for the first time, or the serial port selected is not the
 * same as what is currently set in the session.
 * 
 * Also, changed to using the StrCharxxx() functions in HTCHAR.H for
 * maintainability.
 * 
 * 11    11/08/01 11:05a Ronv
 * Revisions to use the COM_PORT defines for the states of the connection
 * to be consistent with serial and other TAPI devices.
 * 
 * 10    5/09/01 4:43p Ronv
 * Changed tcahr.h to htchar.h per MS request to resolve some build
 * issues.  Also other misc. #include revisions.
 * 
 * 9     3/22/01 11:26a Ronv
 * Removed previous revisions needed (include shfusion.h) for Windows XP
 * Themeing.
 * 
 * 8     2/27/01 5:45p Ronv
 * Revisions needed (include shfusion.h) for Windows XP Themeing.
 * 
 * 7     2/16/01 4:01p Ronv
 * Fix for not dereferencing a null pointer.
 * 
 * 6     12/21/00 11:15a Ronv
 * Corrected usage of sizeof().
 * 
 * 5     11/07/00 12:06p Ronv
 * Fix for setting character in a TCHAR array to correct NULL character.
 * 
 * Fix for setting character in a TCHAR array to correct NULL character.
 * 
 * Using StrCharCopyN() instead of StrCharCopy() to make sure there is not
 * a buffer overrun.
 * 
 * 
 * 4     9/20/00 4:54p Ronv
 * Fix for buffer overrun in with WINSOCK sessions when the URL was > 116
 * characters.  We will now truncate the URL to 127 characters to make
 * sure we don't overwrite the buffer allocated for the URL.
 * 
 * 3     11/16/99 9:56a Johnh
 * Fixed bug reported by IBM that isolated, unsupported NVT control
 * sequences (when sent alone) caused cursor movement.
 * 
 * 2     2/05/99 3:20p Supervisor
 * 64-bit changes and bug fixes for Microsoft
 *
 * 1     10/05/98 1:02p Supervisor
 * Revision 1.16  1998/09/11  11:41:41  JKH
 * none
 *
 * Revision 1.15  1998/09/10  14:54:58  bld
 * none
 *
 * Revision 1.14  1998/09/10  11:04:39  bld
 * none
 *
 * Revision 1.13  1998/09/09  16:15:37  rev
 * none
 *
 * Revision 1.12  1998/08/28  15:24:13  rev
 * none
 *
 * Revision 1.11  1998/08/28  10:31:23  bld
 * none
 *
 * Revision 1.10  1998/06/17  16:04:17  JKH
 * none
 *
 * Revision 1.9  1998/03/10  15:49:00  bld
 * none
 *
 * Revision 1.8  1997/03/24  09:53:07  JKH
 * Added Telnet break and command line telnet port selection
 *
 * Revision 1.7  1997/02/26  09:34:37  dmn
 * none
 *
 * Revision 1.6  1996/11/21  14:15:43  cab
 * Added call answering
 *
 * Revision 1.5  1996/02/22  14:24:07  jmh
 * Winsock com driver now uses same private data structure as standard com.
 *
 * Revision 1.4  1996/02/22  11:22:39  mcc
 * none
 *
 * Revision 1.3  1996/02/22  10:20:19  mcc
 * none
 *
 * Revision 1.2  1996/02/05  14:17:12  mcc
 * none
 *
 * Revision 1.1  1996/01/31  15:52:15  mcc
 * Winsock Comm driver
 *

 *Design Overview =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

    This module would do Dr. Frankenstein proud ... it's basic structure is
	taken from WACKER's COMSTD module, but the internal logic is taken from
	HAWIN.  (I tried to port NPORT's OS/2 code but there is apparently some
	flaw in Win95's support for threaded Winsock apps, anyway I could not
	get it to work). This code is preserved here (controlled by #ifdef
	MULTITHREAD), it would be interesting to see if it works under Windows NT.
	
	A few random bits from NPORT are stitched in too ...
	
	This driver gets its remote address and port number settings from the
	connection driver via DeviceSpecial calls.  It stores nothing in
	the session file, so those load/save calls are stubs.
	
	Tidbits of possibly useful information:
	
		Sometimes a send() appears to succeed but no data appears at the other
		end. It appears that sometimes Winsock is internally waiting forever
		for something to happen, and never actually sends the data.  This
		might be caused by a recv() call outstanding that asks for
		a large amount of data, and maybe the send() call can't get enough
		memory until it completes (but it never WILL complete because the
		other system is waiting for data).  Also, I've seen this happening
		with the MULTITHREAD code, possibly due to a Winsock bug
		under Win95.
		
		The EscFF business is because Telnet (a protocol on top of TCP/IP
		that we will often encounter) uses FF as a command character,
		and sends FF FF as a literal FF.  Thus, file transfers to
		a system running Telnet must escape FF characters in a file
		by doubling them.
		
		The STDCOM drivers work by activating the port then sending
		data out to dial the modem, thus there is no ComConnect
		call in the high-level Com API.  For better or worse, TCP/IP
		requires that the IP address and Port number be supplied
		by the CNCT driver (via ComDeviceSpecial calls) before
		ComActivatePort is called so that activating the port actually
		establishes the link to the other system. In this kinda kludgy
		non-threaded implementation, ComActivatePort cannot block, so
		it will return success if it can successfully send out a
		connection request.  If the request ultimately fails, this
		driver will call ComNotify to let the CNCT driver know that there
		is a connection status change, and it must pick up the pieces.
		
		

*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-*/

//#define DEBUGSTR

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>

#if defined(INCL_WINSOCK)

#include <tdll\session.h>
#include <tdll\mc.h>
#include <tdll\sf.h>
#include <tdll\timers.h>
#include <tdll\com.h>
#include <tdll\comdev.h>
#include <comstd\comstd.hh>
#include "comwsock.hh"
#include <tdll\assert.h>
#include <tdll\statusbr.h>
#include <tdll\htchar.h>
#include <tdll\com.hh>

BOOL WINAPI _CRT_INIT(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);
int wsckResolveAddress(TCHAR *pszRemote, unsigned long *pulAddr);
LRESULT FAR PASCAL WndSockWndProc(HWND hWnd, UINT uiMsg, WPARAM uiPar1, LPARAM lPar2);
BOOL WinSockCreateEventWindow (ST_STDCOM *pstPrivate);
int FAR PASCAL sndQueueAppend(ST_STDCOM *pstPrivate,
						VOID FAR *pvBufr, int nBytesToAppend);
int WinSockConnectSpecial(ST_STDCOM *pstPrivate);
int WinSockAnswerSpecial(ST_STDCOM *pstPrivate);

LONG WinSockConnectEvent(ST_STDCOM* pstPrivate, LPARAM lPar);
LONG WinSockReadEvent(ST_STDCOM* pstPrivate, LPARAM lPar);
LONG WinSockWriteEvent(ST_STDCOM*pstPrivate, LPARAM lPar);
LONG WinSockResolveEvent(ST_STDCOM* pstPrivate, LPARAM lPar);
LONG WinSockCloseEvent(ST_STDCOM* pstPrivate, LPARAM lPar);
LONG WinSockAcceptEvent(ST_STDCOM*pstPrivate, LPARAM lPar);

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  ComLoadWinsockDriver
 *
 * DESCRIPTION:
 *  Loads the COM handle with pointers to the Winsock driver functions
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *  COM_OK		if successful
 *	COM_FAILED	otherwise
 *
 * AUTHOR:
 * mcc 12/26/95
 */
int ComLoadWinsockDriver(HCOM pstCom)
	{

	int	iRetVal = COM_OK;

	if ( !pstCom )
		return COM_FAILED;

	pstCom->pfPortActivate   = WsckPortActivate;
	pstCom->pfPortDeactivate = WsckPortDeactivate;
	pstCom->pfPortConnected  = WsckPortConnected;
	pstCom->pfRcvRefill 	 = WsckRcvRefill;
	pstCom->pfRcvClear		 = WsckRcvClear;
	pstCom->pfSndBufrSend	 = WsckSndBufrSend;
	pstCom->pfSndBufrIsBusy  = WsckSndBufrIsBusy;
	pstCom->pfSndBufrClear	 = WsckSndBufrClear;
	pstCom->pfSndBufrQuery	 = WsckSndBufrQuery;
	pstCom->pfDeviceSpecial	 = WsckDeviceSpecial;
	pstCom->pfPortConfigure	 = WsckPortConfigure;

	return iRetVal;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  WsckComWinsockEntry
 *
 * DESCRIPTION:
 *  Currently, just initializes the C-Runtime library but may be used
 *  for other things later.
 *
 * ARGUMENTS:
 *  hInstDll    - Instance of this DLL
 *  fdwReason   - Why this entry point is called
 *  lpReserved  - reserved
 *
 * RETURNS:
 *  BOOL
 *
 * AUTHOR:
 * mcc 12/26/95
 */
BOOL WINAPI WsckComWinsockEntry(HINSTANCE hInst, DWORD fdwReason, LPVOID lpReserved)
    {
    hinstDLL = hInst;
    return _CRT_INIT(hInst, fdwReason, lpReserved);
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckDeviceInitialize
 *
 * DESCRIPTION:
 *  Called whenever the driver is being loaded
 *
 * ARGUMENTS:
 *  hCom               -- A copy of the com handle. Can be used in the
 *                          driver code to call com services
 *  usInterfaceVersion -- A version number identifying the version of the
 *                          driver interface
 *  ppvDriverData      -- A place to put the pointer to our private data.
 *                          This value will be passed back to us in all
 *                          subsequent calls.
 *
 * RETURNS:
 *  COM_OK if all is hunky dory
 *  COM_DEVICE_VERSION_ERROR if Wacker expects a different interface version.
 *  COM_NOT_ENOUGH_MEMORY
 *  COM_DEVICE_ERROR if anything else goes wrong
 *
 * AUTHOR:
 * mcc 12/26/95
 */
int WINAPI WsckDeviceInitialize(HCOM hCom,
    unsigned nInterfaceVersion,
    void **ppvDriverData)
    {
    int        iRetVal = COM_OK;
    int        ix;
    ST_STDCOM *pstPrivate = NULL;

    //              Check version number and compatibility

    if (nInterfaceVersion != COM_VERSION)
        {
        // This error is reported by Com Routines. We cannot report errors
        // until after DeviceInitialize has completed.
        return COM_DEVICE_VERSION_ERROR;
        }

    if (*ppvDriverData)
        {
        pstPrivate = (ST_STDCOM*) *ppvDriverData;
        }
    else
        {
        // Allocate our private storage structure
        if ((pstPrivate = malloc(sizeof(*pstPrivate))) == NULL)
			{
            return COM_NOT_ENOUGH_MEMORY;
			}

        *ppvDriverData = pstPrivate;

        // These members are common to both com drivers
        //
	    pstPrivate->hCom = hCom;
        pstPrivate->fNotifyRcv = TRUE;
	    pstPrivate->dwEventMask = 0;
	    pstPrivate->fSending = FALSE;
        pstPrivate->lSndTimer = 0L;
        pstPrivate->lSndLimit = 0L;
        pstPrivate->lSndStuck = 0L;
        pstPrivate->hwndEvents = (HWND)0;
        pstPrivate->nRBufrSize = WSOCK_SIZE_INQ;
        pstPrivate->pbBufrStart = NULL;
        pstPrivate->fHaltThread = TRUE;

        InitializeCriticalSection(&pstPrivate->csect);
        for (ix = 0; ix < EVENT_COUNT; ++ix)
            {
            pstPrivate->ahEvent[ix] = CreateEvent(NULL,
												  TRUE,		// must be manually reset
												  FALSE,	// create unsignalled
												  NULL);	// unnamed
            if (pstPrivate->ahEvent[ix] == NULL)
                {
                iRetVal = COM_FAILED;
				//
				// Make sure to initialize the rest of the event handles to NULL;
				//
				for (++ix; ix < EVENT_COUNT; ++ix)
					{
					pstPrivate->ahEvent[ix] = NULL;
					}
                }
            }
        }

    // Setup up reasonable default device values in case this type of
    //  device has not been used in a session before
	pstPrivate->hSocket = INVALID_SOCKET;
	pstPrivate->nPort = 23;
	pstPrivate->fConnected = COM_PORT_NOT_OPEN;
    pstPrivate->hComReadThread = NULL;
    pstPrivate->hComWriteThread = NULL;
	pstPrivate->fEscapeFF = TRUE;
	#ifdef INCL_CALL_ANSWERING
    pstPrivate->fAnswer = FALSE;
	#endif

    if (iRetVal != COM_OK)
        {
        if (pstPrivate)
			{
            free(pstPrivate);
			pstPrivate = NULL;
			}
        }

    return iRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckDeviceClose
 *
 * DESCRIPTION:
 *  Called when Wacker is done with this driver and is about to release .DLL
 *
 * ARGUMENTS:
 *  pstPrivate -- Pointer to our private data structure
 *
 * RETURNS:
 *  COM_OK
 *
 * AUTHOR:
 * mcc 01/19/96
 */
int WINAPI WsckDeviceClose(void *pvPrivate)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int ix;

    // Driver is about to be let go, do any cleanup
    // Port should have been deactivated before we are called, but
    //  check anyway.
    WsckPortDeactivate(pstPrivate);

    for (ix = 0; ix < EVENT_COUNT; ++ix)
        {
		if (pstPrivate->ahEvent[ix])
			{
			CloseHandle(pstPrivate->ahEvent[ix]);
			pstPrivate->ahEvent[ix] = NULL;
			}
        }
    DeleteCriticalSection(&pstPrivate->csect);
    // Free our private data area
    free(pstPrivate);
	pstPrivate = NULL;

	DbgOutStr("WsckDeviceClose complete", 0,0,0,0,0);

    return COM_OK;
    }



/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckDeviceSpecial
 *
 * DESCRIPTION:
 *  The means for others to control any special features in this driver
 *  that are not supported by all drivers.
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *  COM_NOT_SUPPORTED if the instruction string was not recognized
 *  otherwise depends on instruction string
 *
 * AUTHOR:
 * mcc 12/26/95	(ported from NPORT)
 */
int WINAPI WsckDeviceSpecial(void *pvPrivate, const TCHAR *pszInstructions,
							 TCHAR *pszResult, int   nBufrSize)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
	int				iRetVal = COM_NOT_SUPPORTED;
	unsigned long   ulSetVal;
	TCHAR			*pszEnd;
	//
	// MAX_IP_ADDR_LEN+11+1 = buffer size of pstPrivate->szRemoteAddr +
	// settings string "SET IPADDR=" + 1 for the terminating NULL
	// character.  REV 09/20/2000
	//
	TCHAR			achInstructions[MAX_IP_ADDR_LEN+11+1];
	TCHAR			*pszToken = achInstructions;
	int				iIndex;
	TCHAR			szResult[MAX_IP_ADDR_LEN+11+1];
	//ULONG			dwThreadID;

	static TCHAR *apszItems[] =
		{
		"IPADDR",
		"PORTNUM",
		"ISCONNECTED",
		"ESC_FF",					/* 3 */
        "ANSWER",
		NULL
		};

	// supported instruction strings:
	// "Set xxx=vv"
	// "Query xxx"


	if (!pszInstructions || !*pszInstructions)
		return COM_FAILED;

	//DbgOutStr("DevSpec: %s", pszInstructions, 0,0,0,0);

	if (sizeof(achInstructions)/sizeof(TCHAR) < (size_t)(StrCharGetStrLength(pszInstructions) + 1))
		return COM_NOT_SUPPORTED;

	StrCharCopyN(achInstructions, (LPTSTR)pszInstructions, MAX_IP_ADDR_LEN+11+1);

	if (pszResult)
		*pszResult = TEXT('\0');

	pszToken = strtok(achInstructions, " ");
	if (!pszToken)
		return COM_NOT_SUPPORTED;

	EnterCriticalSection(&pstPrivate->csect);

	if (StrCharCmpi(pszToken, "SET") == 0)
		{
		iRetVal = COM_OK;
		pszToken = strtok(NULL, " =");
		if (!pszToken)
			pszToken = "";

		// Look up the item to set.
		for (iIndex = 0; apszItems[iIndex]; ++iIndex)
			if (StrCharCmpi(pszToken, apszItems[iIndex]) == 0)
				break;

		// Isolate the new value to be set
		pszToken = strtok(NULL, "\n");

		if (pszToken && *pszToken)
			{
			// Several items take numeric values
			ulSetVal = strtoul(pszToken, &pszEnd, 0);

			switch(iIndex)
				{
			case 0: // IPADDR
				ulSetVal = (unsigned) StrCharGetByteCount(pszToken);
				if ( ulSetVal < sizeof(pstPrivate->szRemoteAddr))
					{
					StrCharCopyN(pstPrivate->szRemoteAddr, pszToken, IP_ADDR_LEN);
					iRetVal = 0;
					}
				else
					iRetVal = -1;
				break;

			case 1: // PORTNUM
				pstPrivate->nPort = (short) ulSetVal;
				iRetVal = 0;
				break;

			case 3: // ESC_FF
				pstPrivate->fEscapeFF = (int) atoi(pszToken);
				//DbgOutStr("set fEscapeFF = %d (%d) %s %d",
				//pstPrivate->fEscapeFF,ulSetVal,pszToken,
				//(int) atoi(pszToken),0);
				break;

            case 4: // ANSWER
				#ifdef INCL_CALL_ANSWERING
                pstPrivate->fAnswer = ulSetVal;
                iRetVal = 0;
				#else
                iRetVal = COM_FAILED;
				#endif
                break;

			default:
				iRetVal = COM_FAILED;
				//DbgOutStr("DevSpec: Unrecognized instructions!", 0,0,0,0,0);
				break;
				}
			}
		else	// if (pszToken && *pszToken)
			{
			assert(0);
			iRetVal = COM_NOT_SUPPORTED;
			}
		}
	else if (StrCharCmpi(pszToken, "QUERY") == 0)
		{
		iRetVal = COM_OK;
		pszToken = strtok(NULL, "\n");
		szResult[0] = TEXT('\0');

		// Look up the item to query
		for (iIndex = 0; apszItems[iIndex]; ++iIndex)
			if (StrCharCmpi(pszToken, apszItems[iIndex]) == 0)
				break;

		if (*pszToken)
			{
			switch(iIndex)
				{
			case 0: // IPADDR
				StrCharCopyN(szResult, pstPrivate->szRemoteAddr, (sizeof(szResult)/sizeof(TCHAR)));
				szResult[sizeof(szResult)/sizeof(TCHAR) - 1] = TEXT('\0');
				iRetVal = 0;
				break;

			case 1: // PORTNUM
				wsprintf(szResult, "%d", pstPrivate->nPort);
				iRetVal = 0;
				break;

			case 2: // ISCONNECTED
				wsprintf(szResult, "%d", pstPrivate->fConnected);
				iRetVal = 0;
				break;

            case 4: // ANSWER
				#ifdef INCL_CALL_ANSWERING
                wsprintf(szResult, "%d", pstPrivate->fAnswer);
                iRetVal = 0;
				#else
                iRetVal = COM_FAILED;
				#endif
                break;

			default:
				iRetVal = COM_FAILED;
				break;
				}

			if ( iRetVal == 0 && StrCharGetByteCount(szResult) < nBufrSize )
				{
				StrCharCopyN(pszResult, szResult, nBufrSize);
				}
			else
				{
				iRetVal = COM_FAILED;
				}
			}
		}
     else if (StrCharCmpi(pszInstructions, "Send Break") == 0)
        {
        // This is the telent "Break" key processing.  When
        // the user presses Ctrl-Break on the terminal sreen
        // with a WinSOck connection, we arrive here.
        //
        // Please refer to RFC 854 for specifics on this
        // implementation.  Basically, we need to..
        // send the IAC BREAK signal (0xFF 0xF3)
        unsigned char ach[2];

        ach[0] = IAC;
        ach[1] = BREAK;

		if (send(pstPrivate->hSocket, ach,	2, 0) != 2)
            {
            assert(0);
            }

        iRetVal = COM_OK;
        }
   else if (StrCharCmpi(pszInstructions, "Send IP") == 0)
        {
        // This is the telent Interrupt Process.  When
        // the user presses Alt-Break on the terminal sreen
        // with a WinSock connection, we arrive here.
        //
        // Please refer to RFC 854 for specifics on this
        // implementation.  Basically, we need to..
        //
        // Send the Telnet IP (Interrupt Processs)
        // sequence (0xFF 0xF4).
        //
        // Send the Telnet SYNC sequence.  That is,
        // send the Data Mark (DM) as the only character
        // is a TCP urgent mode send operation (the mode
        // flag MSG_OOB does this for us).
        //
        unsigned char ach[2];

        SndBufrClear(pstPrivate);

        ach[0] = IAC;
        ach[1] = IP;

		if (send(pstPrivate->hSocket, ach,	2, 0) != 2)
            {
            assert(0);
            }

        ach[0] = IAC;
        ach[1] = DM;

        if (send(pstPrivate->hSocket, ach,	2, MSG_OOB) != 2)
            {
            assert(0);
            }


        iRetVal = COM_OK;
        }
	else if (StrCharCmpi(pszInstructions, "Update Terminal Size") == 0)
        {
		// The dimensions of the terminal have changed. If we have negotiated
		// to use the Telnet NAWS option, (Negotiate About Terminal Size), then
		// we must send the new terminal size to the server. This method will
		// only send data out if the option has been enabled.
		WinSockSendNAWS( pstPrivate );
		}

	//
    // This is necessary to get the default settings on COM ports. REV: 08/22/2001
    //
    else if (StrCharCmpi(pszInstructions, "GET Defaults") == 0)
        {
		iRetVal = PortDefaultSettings(pstPrivate);
        }

	LeaveCriticalSection(&pstPrivate->csect);

	return iRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  WsckDeviceLoadHdl
 *
 * DESCRIPTION:
 *	We need a function that appears to load/save to the session file,
 *  returning SF_OK, but actually doing nothing since this driver saves
 *  no settings.
 *
 * ARGUMENTS:
 *  pstPrivate  -- dummy (not used)
 *  sfHdl       -- dummy (not used)
 *
 * RETURNS:
 *
 * AUTHOR:
 * mcc 01/19/95
 */
int WINAPI WsckDeviceLoadHdl(void *pvPrivate, SF_HANDLE sfHdl)
    {
    return SF_OK;
    }/*lint !e715 */


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  WsckDeviceSaveStub
 *
 * DESCRIPTION:
 *	We need a function that appears to Save/save to the session file,
 *  returning SF_OK, but actually doing nothing since this driver saves
 *  no settings.
 *
 * ARGUMENTS:
 *  pstPrivate  -- dummy (not used)
 *  sfHdl       -- dummy (not used)
 *
 * RETURNS:
 *
 * AUTHOR:
 * mcc 01/19/95
 */
int WINAPI WsckDeviceSaveHdl(void *pvPrivate, SF_HANDLE sfHdl)
    {
    return SF_OK;
    }/*lint !e715 */



/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckDeviceStub
 *
 * DESCRIPTION:
 *  Stub that returns COM_OK (unlike default stubs)
 *
 * ARGUMENTS:
 *  pstPrivate -- not used
 *
 * RETURNS:
 *  COM_OK if port is configured successfully
 *
 * AUTHOR:
 * mcc 12/26/95
 */
int WINAPI WsckDeviceStub(void *pvPrivate)
    {
    int          iRetVal = COM_OK;

    return iRetVal;
    } /*lint !e715 */


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckPortConfigure
 *
 * DESCRIPTION:
 *  Configures an open port with the current set of user settings
 *
 * ARGUMENTS:
 *  pstPrivate -- The driver data structure
 *
 * RETURNS:
 *  COM_OK if port is configured successfully
 *  COM_DEVICE_ERROR if API errors are encountered
 *  COM_DEVICE_INVALID_SETTING if some user settings are not valid
 */
int WINAPI WsckPortConfigure(void *pvPrivate)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int          iRetVal = COM_OK;
    unsigned     uOverrides = 0;

    // Check for overrides
    ComQueryOverride(pstPrivate->hCom, &uOverrides);
    if (bittest(uOverrides, COM_OVERRIDE_8BIT))
        {
    	DbgOutStr("Requesting binary Telnet mode\n", 0,0,0,0,0);
		// Ask the other side to send binary data (default
		// is 7-bit ASCII), and inform them that we will
		// be sending binary data.
		WinSockSendMessage(pstPrivate, DO, TELOPT_BINARY);
		WinSockSendMessage(pstPrivate, WILL, TELOPT_BINARY);
    }

    return iRetVal;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckPortConnected
 *
 * DESCRIPTION:
 *  Determines whether the driver is currently connected to a host system.
 *	(Sort of like having a "carrier" in the STDCOM drivers)
 *
 * ARGUMENTS:
 *  pstPrivate -- Our private data structure
 *
 * RETURNS:
 *  TRUE if we have an active connection
 *  FALSE otherwise
 *
 * AUTHOR:
 * mcc 01/19/96
*/
int WINAPI WsckPortConnected(void *pvPrivate)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;

    return pstPrivate->fConnected;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckSndBufrIsBusy
 *
 * DESCRIPTION:
 *  Determines whether the driver is available to transmit a buffer of
 *  data or not.
 *
 * ARGUMENTS:
 *  pstPrivate -- address of com driver's data structure
 *
 * RETURNS:
 *  COM_OK   if data can be transmitted
 *  COM_BUSY if driver is still working on a previous buffer
 *
 * AUTHOR:
 * mcc 12/26/95
 */
int WINAPI WsckSndBufrIsBusy(void *pvPrivate)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int  iRetVal = COM_OK;

    EnterCriticalSection(&pstPrivate->csect);

    if (pstPrivate->fSending)
		{
        iRetVal = COM_BUSY;
		}

    LeaveCriticalSection(&pstPrivate->csect);

    // DBG_WRITE((iRetVal==COM_BUSY)?"Snd Bufr Busy\r\n":"Snd Bufr Ready\r\n",
		// 0,0,0,0,0);

    return iRetVal;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	WsckSndBufrQuery
 *
 * DESCRIPTION:
 *	A stub; I'm not really sure what else it COULD do in TCP/IP
 *
 * ARGUMENTS:
 *	ignored
 *
 * RETURNS:
 *	COM_OK
 *
 * AUTHOR:
 * 	mcc 12/26/95
 */	
int WINAPI WsckSndBufrQuery(void *pvPrivate,
    unsigned *pafStatus,
    long *plHandshakeDelay)
    {
    int     iRetVal = COM_OK;

    return iRetVal;
    }


#if !defined(MULTITHREAD)
	// WINSOCK the way we know and love it from Win3.1 days

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckPortActivate
 *
 * DESCRIPTION:
 *  Called to activate the port and connect to destination
 *
 * ARGUMENTS:
 *  pstPrivate  -- driver data structure
 *  pszPortName -- not used
 *  dwMediaHdl  -- not used (stub used only by TAPI-aware drivers)
 *
 * RETURNS:
 *  COM_OK if port is successfully activated
 *  COM_NOT_ENOUGH_MEMORY if there in insufficient memory for data storage
 *  COM_NOT_FOUND if named port cannot be opened
 *  COM_DEVICE_ERROR if API errors are encountered
 *
 * AUTHOR:
 * 	mcc 12/26/95
 */
int WINAPI WsckPortActivate(void *pvPrivate,
                            TCHAR *pszPortName,
                            DWORD_PTR dwMediaHdl)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int             iRetVal = COM_OK;
	WNDCLASSEX wc;
    ST_COM_CONTROL *pstComCntrl;

    // Make sure we can get enough memory for buffers before opening device
    pstPrivate->pbBufrStart = malloc((size_t)pstPrivate->nRBufrSize);

    if (pstPrivate->pbBufrStart == NULL)
        {
        iRetVal = COM_NOT_ENOUGH_MEMORY;
        //* DeviceReportError(pstPrivate, SID_ERR_NOMEM, 0, TRUE);
        goto checkout;
        }

    pstPrivate->pbBufrEnd = pstPrivate->pbBufrStart + pstPrivate->nRBufrSize;
    pstPrivate->pbReadEnd = pstPrivate->pbBufrStart;
    pstPrivate->pbComStart = pstPrivate->pbComEnd = pstPrivate->pbBufrStart;
    pstPrivate->fBufrEmpty = TRUE;
	pstPrivate->nSendBufrLen = 0;


    if (iRetVal == COM_OK)
        {
        pstComCntrl = (ST_COM_CONTROL *)pstPrivate->hCom;
        pstComCntrl->puchRBData =
            pstComCntrl->puchRBDataLimit =
            pstPrivate->pbBufrStart;

        pstPrivate->dwEventMask = EV_ERR | EV_RLSD;
        pstPrivate->fNotifyRcv = TRUE;
        pstPrivate->fBufrEmpty = TRUE;
		}

	memset(&wc, 0, sizeof(WNDCLASSEX));
	wc.cbSize = sizeof(WNDCLASSEX);

	if (GetClassInfoEx(hinstDLL, WINSOCK_EVENT_WINDOW_CLASS, &wc) == FALSE)
		{
		// Register event window class to handle Winsock asynchronous
		// notifications
		wc.style         = CS_GLOBALCLASS;
		wc.lpfnWndProc   = WndSockWndProc;
		wc.cbClsExtra    = 0;
		wc.cbWndExtra    = sizeof(ST_STDCOM*);
		wc.hInstance     = hinstDLL;
		wc.hIcon         = NULL;
		wc.hCursor       = NULL;
		wc.hbrBackground = NULL;
		wc.lpszMenuName  = NULL;
		wc.lpszClassName = WINSOCK_EVENT_WINDOW_CLASS;
		wc.hIconSm       = NULL;

		// Register the class, we don't check for failure because the driver
		//  can operate without it if it has to
		RegisterClassEx(&wc);
		}
		
	WinSockCreateNVT(pstPrivate);
		
		
	if (!WinSockCreateEventWindow(pstPrivate))
		{
		iRetVal = COM_DEVICE_ERROR;
		goto checkout;
		}

	// Kick off Winsock processing
	PostMessage(pstPrivate->hwndEvents, WM_WINSOCK_STARTUP,
				0, 0L);


checkout:
    if (iRetVal != COM_OK)
        WsckPortDeactivate(pstPrivate);

    return iRetVal;
    }  /*lint !e715 */


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckPortDeactivate
 *
 * DESCRIPTION:
 *  Deactivates and closes an open port
 *
 * ARGUMENTS:
 *  pstPrivate -- Driver data structure
 *
 * RETURNS:
 *  COM_OK
 *
 * AUTHOR:
 * 	mcc 12/26/95
 */
int WINAPI WsckPortDeactivate(void *pvPrivate)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int iRetVal = COM_OK;


	// Shut down socket and WINSOCK
	shutdown(pstPrivate->hSocket, 2);
	closesocket(pstPrivate->hSocket);
	WSACleanup();
	pstPrivate->hSocket = INVALID_SOCKET;
	
	// Destroy the WINSOCK event window
	if (pstPrivate->hwndEvents)
		{
		DestroyWindow(pstPrivate->hwndEvents);
		pstPrivate->hwndEvents = 0;
		}
		
	// Destroy the read buffer		
    if (pstPrivate->pbBufrStart)
        {
        free(pstPrivate->pbBufrStart);
        pstPrivate->pbBufrStart = NULL;
        }

    return iRetVal;
    }

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckRcvRefill
 *
 * DESCRIPTION:
 *  Called when the receive buffer is empty to refill it. This routine
 *  should attempt to refill the buffer and return the first character.
 *  It is important that this function be implemented efficiently.
 *
 * ARGUMENTS:
 *  pstPrivate -- the driver data structure
 *
 * RETURNS:
 *  TRUE if data is put in the receive buffer
 *  FALSE if there is no new incoming data
 *
 * AUTHOR:
 * 	mcc 01/18/95 (from HAWIN)
 */
int WINAPI WsckRcvRefill(void *pvPrivate)
	{
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
	int nIndx;
	int iBytesRead = 0;
	int nNVTRes;
	int nBytesCopied;
	ST_COM_CONTROL FAR *pstComCntrl;
    int iReturn = TRUE;

	if (pstPrivate->fConnected == COM_PORT_NOT_OPEN)
		return FALSE;

	//for (nIndx = 0; nIndx < (int)pstPrivate->usRBufrSize; nIndx += 1)
		//pstPrivate->puchRBufr[nIndx] = 0;

	// Read up to pstPrivate->usRBufrSize bytes into pstPrivate->puchRBufr
	// and set iBytesRead to the number read.
	iBytesRead = 0;
	iBytesRead = recv(pstPrivate->hSocket,
						(LPSTR)pstPrivate->pbBufrStart,
						(int)pstPrivate->nRBufrSize,
						0);
	if (iBytesRead == SOCKET_ERROR)
		{
		int iErr;

		iBytesRead = 0;
		iErr = WSAGetLastError();
		if (iErr != WSAEWOULDBLOCK)
			DbgOutStr("Refill: error %d reading %d bytes on socket %d\n", iErr,
			pstPrivate->nRBufrSize,
				pstPrivate->hSocket,0,0);
		}

	if (iBytesRead == 0)
		{
		ComNotify(pstPrivate->hCom, NODATA);
		return FALSE;
		}
		

	// update the com handle with info on new data. This is implemented
	// this way to allow HA to access these characters quickly
	nBytesCopied = 0;
	for (nIndx = 0; nIndx < iBytesRead; nIndx++)
		{

        if (pstPrivate->pbBufrStart == NULL)
            {
            return FALSE;
            }

		// If we have an FF or we are in the middle of a Telnet
		// command, run this character thru the NVT.  Unless the
		// says to discard the character, we then copy it to the
		// output position.
		if (pstPrivate->pbBufrStart[nIndx] == 0xFF ||
            pstPrivate->NVTstate != NVT_THRU)
			{
			nNVTRes = WinSockNetworkVirtualTerminal(
				(ECHAR) pstPrivate->pbBufrStart[nIndx],
				(void far *) pstPrivate);
			//DbgOutStr("NVT returns %d\n", nNVTRes, 0,0,0,0);		
			}
		else
			nNVTRes = NVT_KEEP;
		
		if (nNVTRes != NVT_DISCARD)
			{
			pstPrivate->pbBufrStart[nBytesCopied] = pstPrivate->pbBufrStart[nIndx];
			nBytesCopied++;
			}
		}

	// if we got no data (perhaps because data were "eaten" by NVT),
	// make sure we return -1
	if (nBytesCopied == 0)
        {
		*(pstPrivate->pbBufrStart) = (char) -1;
        iReturn = FALSE;
        }

	pstComCntrl = (ST_COM_CONTROL *)pstPrivate->hCom;
	pstComCntrl->puchRBData = pstPrivate->pbBufrStart;
	pstComCntrl->puchRBDataLimit = pstPrivate->pbBufrStart + nBytesCopied;

	return iReturn;
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckRcvClear
 *
 * DESCRIPTION:
 *  Clears the receiver of all received data.
 *
 * ARGUMENTS:
 *  hCom -- a comm handle returned by an earlier call to ComCreateHandle
 *
 * RETURNS:
 *  COM_OK if data is cleared
 *  COM_DEVICE_ERROR if Windows com device driver returns an error
 *
 * AUTHOR:
 * mcc 01/18/96	(taken almost entirely from HAWIN)
 */
int WINAPI WsckRcvClear(void *pvPrivate)
	{
	CHAR ch[128];
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    ST_COM_CONTROL *pstComCntrl = (ST_COM_CONTROL *)pstPrivate->hCom;

	if (pstPrivate->fConnected == COM_PORT_NOT_OPEN)
		return COM_DEVICE_ERROR;

	pstComCntrl->puchRBData = pstComCntrl->puchRBDataLimit =
			pstPrivate->pbBufrStart;

	// Do whatever is necessary to remove any buffered data from the com port

	while (recv(pstPrivate->hSocket, ch, 128, 0) != SOCKET_ERROR)
			{
			}

	return COM_OK;
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckSndBufrSend
 *
 * DESCRIPTION:
 *	Transmits a buffer of characters. This routine need only queue up a
 *	buffer to be transmitted. If the com device supports interrupt-driven
 *	or hardware-controlled transmission, this function should start the
 *	process but should not wait until all the data has actually been sent.
 *
 * ARGUMENTS:
 *	pstPrivate -- Pointer to driver data structure
 *	pvBufr	   -- Pointer to data to send
 *	nSize	   -- Number of bytes to send
 *
 * RETURNS:
 *	COM_OK
 *	or appropriate error code
 *
 * AUTHOR:
 * 	mcc 01/19/96
 */
int WINAPI WsckSndBufrSend(void *pvPrivate, void *pvBufr, int  nBytesToSend)
	{
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
	int 	nCount;
	int 	nError;
	int	 	nSize;		 	// num bytes to send during this pass
	int		usReturnValue = COM_OK;
	unsigned char *pszPtr = (unsigned char *)pvBufr;
  	unsigned char *pcThisPassData;
	int		fGotFF = FALSE;	// TRUE if last char detected was an FF
	int		nOffset;
	LPSTR   puchRemains;
	int		fQueueing = FALSE;

	assert(pvBufr != (VOID FAR *)0);
	assert(nBytesToSend <= WSOCK_SIZE_OUTQ);
	
	if (pstPrivate->fSending)
		{
		DbgOutStr("SBS: Busy = %d\n", pstPrivate->fSending, 0,0,0,0);
		return COM_BUSY;
		}
		
	assert(pstPrivate->nSendBufrLen == 0);

	if (pstPrivate->fConnected == COM_PORT_NOT_OPEN)	
		return COM_DEVICE_ERROR;


	// If we are escaping FF characters by sending them as FFFF,
	// things are a bit tricky because we have no extra room in the buffer
	// for the doubled characters.  The idea here is to send the buffer
	// in several passes; if an FF character is found, it is sent once
	// at the end of one pass and again at the beginning of the next
	// At the end of each pass, we decrement nBytesToSend by the
	// number of bytes sent during the pass (nSize), and keep looping
	// until all the data are sent
	nOffset = 0;
	ComNotify(pstPrivate->hCom, SEND_STARTED);						
	while (nBytesToSend > 0 && usReturnValue == COM_OK)
		{
		if (pstPrivate->fEscapeFF)
			{
			pcThisPassData = &pszPtr[nOffset];
			
			// If we are processing an FF that was found on the
			// last pass, send it out again by itself.	Otherwise,
			// search for the next FF and send everything up to and
			// including it.
			if (fGotFF)
				{
				//DbgOutStr("SndBufrSend: 2nd FF\n", 0,0,0,0,0);
				nSize = 1;
				nOffset++;
				fGotFF = FALSE;
				}
			else
				{
				nSize = 0;
				while (pszPtr[nOffset] != 0xFF && nOffset < nBytesToSend)
					{
					nSize++, nOffset++;
					}
				
				// If no FF's were found, send everything
				if (nOffset >= nBytesToSend)	
					{
					nBytesToSend = 0;
					fGotFF = 0;
					}
				// otherwise, send data up to and including FF
				else
					{
					nSize++;  		// include the FF!
					fGotFF = TRUE;	// Send the 2nd FF on next pass
					//DbgOutStr("SndBufrSend: 1st FF ...", 0,0,0,0,0);
					}
				}										
			}
		else  // send everything in one pass
			{
			nSize = nBytesToSend;
			nBytesToSend = 0;
			pcThisPassData = pvBufr;
			}
		// If we already have data queued, don't try to send directly, since
		// it might get out before the queued data do.	
		if (fQueueing)
			{
			DbgOutStr("SBS queueing output.  Queueing %d bytes\n",
						nSize,0,0,0,0);
			if (sndQueueAppend(pstPrivate,pcThisPassData,nSize) != COM_OK)
						usReturnValue = COM_DEVICE_ERROR;
			}
		else
			{
			// Pass data to TCP/IP
			nCount = 0;
			nCount = send(pstPrivate->hSocket,
							pcThisPassData,	(int)nSize,	0);
								
			// If we got a "would block" error, copy the data to send
			// to pstPrivate->auchSndBufr.  (Since the FF processing may
			// cause this block of code to be executed multiple times in
			// one SndBufrSend call, we will append new data to existing
			// data in the buffer).
			if (nCount == SOCKET_ERROR)
				{								
				nError = WSAGetLastError();

				if (nError == WSAEWOULDBLOCK)
					{
					// Winsock won't accept data, so queue it up for
					// WinSockWriteEvent to handle.  Also, lock the handle
					// until we are done so that WinSockWriteEvent can't get in
					// there.
					fQueueing = TRUE;

					DbgOutStr("SBS would block.  Queueing %d bytes\n",
						nSize,0,0,0,0);
					EnterCriticalSection(&pstPrivate->csect);

					if (sndQueueAppend(pstPrivate,pcThisPassData,nSize) != COM_OK)
						{
						usReturnValue = COM_DEVICE_ERROR;
						}
					LeaveCriticalSection(&pstPrivate->csect);
					}
				else
					{
					DbgOutStr("WinSock send error %d\r\n", nError, 0,0,0,0);
					//DeviceReportError(pstPrivate, (UINT)nError, 0, FALSE);
					usReturnValue = COM_DEVICE_ERROR;
					DbgOutStr("SBS: Bad error\n", 0,0,0,0,0);
					}
				}
			else
				{
   				ComNotify(pstPrivate->hCom, SEND_DONE);
				if (nCount < (int)nSize)
					{
					/*
					 * Set stuff up for next time through
					 */
					DbgOutStr("SBS send incomplete..  Queueing %d bytes\n",
						(int)nSize-nCount,0,0,0,0);
			
					// Get pointer to remaining data and queue it up		
					puchRemains = pcThisPassData + nCount;
					if (sndQueueAppend(pstPrivate, puchRemains,
							(nSize - nCount)) != COM_OK)
						{
						usReturnValue = COM_DEVICE_ERROR;
						DbgOutStr("SBS: Bad error\n", 0,0,0,0,0);
						}
					}
				}
			}
   		}

	return usReturnValue;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: sndQueueAppend
 *
 * DESCRIPTION:
 *  Appends new data to any data that have been queued up for
 *  re-transmission by WinSockWriteEvent
 *
 * ARGUMENTS:
 *	pstPrivate 		-- address of com driver's data structure
 *  pvBufr      	-- address of new data block to queue up
 *  nBytesToAppend	-- size of new data	block to append
 *
 * RETURNS:
 *	COM_OK	 if data can be transmitted
 *	COM_BUSY if no more room for data to queue up
 *
 * AUTHOR:
 * 	mcc 01/19/96 (from HAWIN)
 */

int FAR PASCAL sndQueueAppend(ST_STDCOM* pstPrivate,
						VOID FAR *pvBufr, int nBytesToAppend)
						
	{					
	LPSTR	puchEnd;
	USHORT  usReturns = COM_OK;

	assert( pstPrivate != NULL );
	assert( pvBufr != NULL );

	//jkh 9/11/98 to avoid memcpy with invalid params
	if ( pstPrivate && pvBufr && nBytesToAppend > 0 )
		{
		if (pstPrivate->nSendBufrLen + nBytesToAppend >
				(int) sizeof(pstPrivate->abSndBufr))
			{
			DbgOutStr("SQAPP: buffer full", 0,0,0,0,0);
			return COM_BUSY;
			}
	
		// Set the flag that SndBufrIsBusy looks at; we are
		// in the middle of a send until the buffer is cleared
		// by WinSockWriteEvent
		pstPrivate->fSending = TRUE;
		
		pstPrivate->pbSendBufr = pstPrivate->abSndBufr;			
		puchEnd = pstPrivate->pbSendBufr + pstPrivate->nSendBufrLen;

		DbgOutStr("sQA: appending %d bytes to addr = %lx.  Existing buffer is %d bytes at %lx\n",
			nBytesToAppend,	puchEnd, pstPrivate->nSendBufrLen, pstPrivate->pbSendBufr,0);
		pstPrivate->nSendBufrLen += nBytesToAppend;
		MemCopy(puchEnd, (LPSTR) pvBufr, (unsigned) nBytesToAppend);
		}

	DbgOutStr("sQA: copy done\n", 0,0,0,0,0);
	return usReturns;
	}




/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckSndBufrClear
 *
 * DESCRIPTION:
 *	Clear any data waiting to be transmitted
 *
 * ARGUMENTS:
 *	pstPrivate -- pointer to driver data structure
 *
 * RETURNS:
 *	COM_OK
 *	or appropriate error code
 *
 * AUTHOR
 * 	mcc 01/19/96 (from HAWIN)
 */
int WINAPI WsckSndBufrClear(ST_STDCOM *pstPrivate)
	{
	USHORT usReturnValue = COM_OK;

	DbgOutStr("SndBufrClear called", 0,0,0,0,0);

	if (WsckSndBufrIsBusy(pstPrivate))
		{
		pstPrivate->nSendBufrLen = 0;
		pstPrivate->pbSendBufr = 0;
		}

	// Call SndBufrIsBusy again to clear flags, timers, etc.
	WsckSndBufrIsBusy(pstPrivate);
	return usReturnValue;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WndSockWndProc
 *
 * DESCRIPTION:
 *	This is the window procedure for the window that is used to receive event
 *	messages from the WinSock interface.  It uses this to get around the pesky
 *	problem of blocking vs. non-blocking requirements and expectations.
 *
 * ARGUEMENTS:
 *	The usual stuff for a window procedure.
 *
 * RETURNS:
 *	The usual stuff for a window procedure.
 *
 * AUTHOR
 * 	mcc 01/19/96 (from HAWIN)
 */
LRESULT FAR PASCAL WndSockWndProc(HWND hWnd, UINT uiMsg, WPARAM uiPar1, LPARAM lPar2)
	{
	ST_STDCOM*pstPrivate;
	WORD wVersion;
	WSADATA stWsaData;

	switch (uiMsg)
		{
		case WM_WINSOCK_STARTUP:
			pstPrivate = (ST_STDCOM*)GetWindowLongPtr(hWnd, 0);
			if (pstPrivate == (ST_STDCOM*)0)
				break;

			DbgOutStr("Calling WSAStartup\n", 0,0,0,0,0);
			/*
			 * Initialize the Windows Socket DLL
			 */
			wVersion = 0x0101;			// The version of WinSock that we want
			if (WSAStartup(wVersion, &stWsaData) != 0)
				{
				/* No DLL was available */
				return COM_DEVICE_ERROR;
				}
			DbgOutStr("Done calling WSAStartup\n", 0,0,0,0,0);
		   //	pstPrivate->fActive = TRUE;

			/* Confirm that the Windows Socket DLL supports 1.1. */
			/* Note that if the DLL supports versions greater    */
			/* than 1.1 in addition to 1.1, it will still return */
			/* 1.1 in wVersion since that is the version we      */
			/* requested                                         */
			if ((LOBYTE(stWsaData.wVersion) != 1) &&
				(HIBYTE(stWsaData.wVersion) != 1))
				{
				/* No acceptable DLL was available */
				return COM_DEVICE_ERROR;
				}

			/*
			 * Create a socket for later use.
			 */
			DbgOutStr("Calling socket\n", 0,0,0,0,0);
			
			pstPrivate->hSocket = socket(PF_INET, SOCK_STREAM, 0);
			if (pstPrivate->hSocket == INVALID_SOCKET)
				{
				return COM_DEVICE_ERROR;
				}
			DbgOutStr("Done calling socket\n", 0,0,0,0,0);

			#ifdef INCL_CALL_ANSWERING			
            if (pstPrivate->fAnswer)
                {
			    WinSockAnswerSpecial(pstPrivate);
                }
            else
                {
			    WinSockConnectSpecial(pstPrivate);
                }
			#else
			WinSockConnectSpecial(pstPrivate);
			#endif
			break;
			
		case WM_WINSOCK_NOTIFY:
			{
			pstPrivate = (ST_STDCOM*)GetWindowLongPtr(hWnd, 0);
			if (pstPrivate == (ST_STDCOM*)0)
				break;

			switch(LOWORD(lPar2))
				{
				case FD_READ:
					return WinSockReadEvent(pstPrivate, lPar2);

				case FD_WRITE:
					return WinSockWriteEvent(pstPrivate, lPar2);

				case FD_CLOSE:
					//DbgOutStr("FD_CLOSE\r\n", 0,0,0,0,0);
					return WinSockCloseEvent(pstPrivate, lPar2);

				case FD_CONNECT:
					//DbgOutStr("FD_CONNECT\r\n", 0,0,0,0,0);
					return WinSockConnectEvent(pstPrivate, lPar2);

				case FD_ACCEPT:
					//DbgOutStr("FD_ACCEPT\r\n", 0,0,0,0,0);
					return WinSockAcceptEvent(pstPrivate, lPar2);

				default:
					break;
				}
			}
			break;

		case WM_WINSOCK_RESOLVE:
			{
			/* We get here after a call to WSAAsyncGetHostByName */
			pstPrivate = (ST_STDCOM*)GetWindowLongPtr(hWnd, 0);
			if (pstPrivate == (ST_STDCOM*)0)
				break;

			return WinSockResolveEvent(pstPrivate, lPar2);
			}

		default:
			break;
		}

	return DefWindowProc(hWnd, uiMsg, uiPar1, lPar2);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WndSockCreateEventWindow
 *
 * DESCRIPTION:
 *	Creates the event window used to process messages sent by the WinSock DLL.
 *
 * ARGUMENTS:
 *	pstPrivate		pointer to private data structure; attach to window
 *
 * RETURNS:
 *	TRUE if everything is OK, otherwise FALSE.
 *
 * AUTHOR
 * 	mcc 01/19/96 (from HAWIN)
 */
BOOL WinSockCreateEventWindow (ST_STDCOM *pstPrivate)
	{
	BOOL fRetVal = TRUE;

	if (fRetVal)
		{
		pstPrivate->hwndEvents = CreateWindow(
										WINSOCK_EVENT_WINDOW_CLASS,
										TEXT(""),
										WS_OVERLAPPEDWINDOW,
										0, 0, 0, 0,
										HWND_DESKTOP,
										NULL,
										hinstDLL,
										NULL);
		fRetVal = (pstPrivate->hwndEvents != (HWND)0);
		}

	if (fRetVal)
		{
		SetWindowLongPtr(pstPrivate->hwndEvents, 0, (LONG_PTR)pstPrivate);
		}

	return fRetVal;
	}
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	WinSockSendBreak
 *
 * DESCRIPTION:
 *	This function attempts to send a break condition to the NVT on the other
 *	end of the connection.  See RFC854 for details and good luck.
 *
 * PARAMETERS:
 *	pstPrivate		Driver's private data structure
 *
 * RETURNS:
 *
 * AUTHOR
 * 	mcc 01/19/96 (from HAWIN)
 */
VOID WinSockSendBreak(ST_STDCOM*pstPrivate)
	{
	UCHAR acSendBreak[2];

	//DbgOutStr("WinSockSendBreak\r\n", 0,0,0,0,0);

	acSendBreak[0] = 255;
	acSendBreak[1] = 243;
	send(pstPrivate->hSocket, acSendBreak, 2, 0);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
USHORT WinSockSendBreakSpecial(ST_STDCOM *pstPrivate,
							LPSTR pszData,
							UINT uiSize)
	{
	if (pstPrivate->nSendBufrLen > 0)
		{
		/* Can't do it now, wait until next time */
		pstPrivate->fSndBreak = TRUE;
		}
	else
		{
		WinSockSendBreak(pstPrivate);
		}

	return 0;
	} /*lint !e715 */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 * AUTHOR
 * 	mcc 01/19/96 (from HAWIN)
 */
int WinSockConnectSpecial(ST_STDCOM*pstPrivate)
	{
	USHORT usRetVal;
	int nIndx;
	int nError;
	unsigned long ulAddr;
	struct sockaddr_in	srv_addr;
	struct sockaddr_in	cli_addr;
	HANDLE  hReturn;

	usRetVal = COM_OK;

	cli_addr.sin_family = AF_INET;
	cli_addr.sin_addr.s_addr = INADDR_ANY;
	cli_addr.sin_port = 0;

	// Bind the socket to any internet address.  Ignore errors;
	// real ones will be detected later, and this WILL fail
	// if the socket is already bound.
	usRetVal = (USHORT)bind(pstPrivate->hSocket, (LPSOCKADDR)&cli_addr,
			sizeof(cli_addr));
	DbgOutStr("Socket %d bind returns %d\n", pstPrivate->hSocket, usRetVal, 0,0,0);

	// See if the remote address has been entered in numeric form.  If not,
	// we will have to call WSAAsynchGetHostByName to translate it; in that
	// case, the EventWindow handler will call connect.
	ulAddr = inet_addr(pstPrivate->szRemoteAddr);
	if ((ulAddr == INADDR_NONE) || (ulAddr == 0))
		{
		DbgOutStr("WSCnctSp: calling WSA...HostByName\n", 0,0,0,0,0);
		/* We take the long way around */
		hReturn = WSAAsyncGetHostByName(
							pstPrivate->hwndEvents,
							WM_WINSOCK_RESOLVE,
							pstPrivate->szRemoteAddr,
							(char *) &pstPrivate->stHostBuf,
							MAXGETHOSTSTRUCT);
		
		if (hReturn == 0)
			nError = WSAGetLastError();
		else
			nError = 0 ;		
		DbgOutStr("WSAAsynchGetHostByName returns %lx (err = %d)\n", hReturn,
				nError,0,0,0);
		goto WSCSexit;
		}

	/*
	 * This is the alternate pathway for the connect.  We go thru here if
	 * the address was in the form of a 123.456.789.123 address.
	 */
	srv_addr.sin_family = AF_INET;
	srv_addr.sin_addr.s_addr = ulAddr;
	srv_addr.sin_port = htons((USHORT)pstPrivate->nPort);

	nIndx = WSAAsyncSelect(pstPrivate->hSocket,
							pstPrivate->hwndEvents,
							WM_WINSOCK_NOTIFY,
							FD_CONNECT | FD_READ | FD_WRITE | FD_CLOSE
							);

	if (nIndx != 0)
		{
		/* Oops, something goofed */
		usRetVal = COM_DEVICE_ERROR;
		DbgOutStr("WSAAsyncSelect failed\n", 0,0,0,0,0);
		goto WSCSexit;
		}

	if (connect(pstPrivate->hSocket,
							(LPSOCKADDR)&srv_addr,
							sizeof(srv_addr)) == SOCKET_ERROR)
		{
		nIndx = WSAGetLastError();
		if (nIndx != WSAEWOULDBLOCK)
			{
			usRetVal = COM_DEVICE_ERROR;
			//DeviceReportError(pstPrivate, (UINT)nIndx, 0, FALSE);
			DbgOutStr("Connect failed (err = %d)\n", nIndx, 0,0,0,0);
			goto WSCSexit;
			}
		}

WSCSexit:
	//DbgOutStr(" returns %d\r\n", usRetVal, 0,0,0,0);
	if (usRetVal != COM_OK)
		{
	   closesocket(pstPrivate->hSocket);
		}

	return usRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  WinSockAnswerSpecial
 *
 * DESCRIPTION:
 *  Sets up WinSock to answer a call.
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 * AUTHOR:  C. Baumgartner, 11/19/96 (ported from HAWin16)
 */
int WinSockAnswerSpecial(ST_STDCOM*pstPrivate)
	{
	int                nError = 0;
	USHORT             usRetVal = COM_OK;
	struct sockaddr_in host_addr;

    // Create our local internet address.
    //
	host_addr.sin_family = AF_INET;
	host_addr.sin_addr.s_addr = INADDR_ANY;
	host_addr.sin_port = htons((USHORT)pstPrivate->nPort);

    // Bind the socket to our local address.
    //
    nError = bind(pstPrivate->hSocket, (LPSOCKADDR)&host_addr,
        sizeof(host_addr));
    DbgOutStr("Socket %d bind returns %d\n", pstPrivate->hSocket, nError, 0,0,0);

	if (nError != 0)
		{
		usRetVal = COM_DEVICE_ERROR;
		goto WSASexit;
		}

    // Tell the socket to notify us of events that we are interested
    // in (like when somebody connects to us).
    //
	nError = WSAAsyncSelect(pstPrivate->hSocket, pstPrivate->hwndEvents,
        WM_WINSOCK_NOTIFY, FD_ACCEPT | FD_READ | FD_WRITE | FD_CLOSE);

    if (nError != 0)
        {
        usRetVal = COM_DEVICE_ERROR;
        goto WSASexit;
        }

    // Tell the socket to wait for incoming calls.
    //
	if (listen(pstPrivate->hSocket, 1) != 0)
		{
		usRetVal = COM_DEVICE_ERROR;
		goto WSASexit;
		}

WSASexit:
	if (usRetVal != COM_OK)
		{
		closesocket(pstPrivate->hSocket);
		}

	return usRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 * AUTHOR
 * 	mcc 01/19/96 (from HAWIN)
USHORT WinSockDisconnectSpecial(ST_STDCOM*pstPrivate,
							LPSTR pszData,
							UINT uiSize)
	{

	if (pstPrivate->hSocket != INVALID_SOCKET)
		{
		closesocket(pstPrivate->hSocket);
		pstPrivate->hSocket = INVALID_SOCKET;
		}

	pstPrivate->fConnected = COM_PORT_NOT_OPEN;

	return COM_OK;
	} /*lint !e715 */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 * AUTHOR
 * 	mcc 01/19/96 (from HAWIN)
 */
LONG WinSockCloseEvent(ST_STDCOM*pstPrivate, LPARAM lPar)
	{
	pstPrivate->fConnected = COM_PORT_NOT_OPEN;
	ComNotify(pstPrivate->hCom, CONNECT);

	return 0;
	}  /*lint !e715 */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *	pstPrivate		Driver's private data structure
 *  lPar			status code from Winsock
 *
 * RETURNS:
 */
LONG WinSockConnectEvent(ST_STDCOM*pstPrivate, LPARAM lPar)
	{
	int status;
	status = (int)HIWORD(lPar);
	if (status)
		{
		pstPrivate->fConnected = COM_PORT_NOT_OPEN;
		ComNotify(pstPrivate->hCom, CONNECT);
		}
	else
		{
		pstPrivate->fConnected = COM_PORT_OPEN;
		ComNotify(pstPrivate->hCom, CONNECT);
		}
	return 0;
	}	/*lint !e715 */


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  WinSockAcceptEvent
 *
 * DESCRIPTION:
 *  Accepts an incoming call.
 *
 * PARAMETERS:
 *	pstPrivate		Driver's private data structure
 *  lPar			status code from Winsock
 *
 * RETURNS:
 *
 * AUTHOR:  C. Baumgartner, 11/19/96 (ported from HAWin16)
 */
LONG WinSockAcceptEvent(ST_STDCOM*pstPrivate, LPARAM lPar)
	{
	int    status = HIWORD(lPar);
	SOCKET hAnswer = INVALID_SOCKET;
    SOCKET hOldSocket = INVALID_SOCKET;

    // We aren't connected yet.
    //
	pstPrivate->fConnected = COM_PORT_NOT_OPEN;

    // Attempt to accept the call.
    //
	hAnswer = accept(pstPrivate->hSocket, NULL, 0);

	if (hAnswer != INVALID_SOCKET)
		{
        // Now we are connected.
        //
		pstPrivate->fConnected = COM_PORT_OPEN;

        // Get the newly accepted socket.
        //
        hOldSocket = pstPrivate->hSocket;
		pstPrivate->hSocket = hAnswer;

        // Now close the old socket because we don't want to
        // be listening when we are connected.
        //
        closesocket(hOldSocket);
		}

    // Let the rest of the world know that we are connected.
    //
	ComNotify(pstPrivate->hCom, CONNECT);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *	pstPrivate		Driver's private data structure
 *  lPar			status code from Winsock
 *
 * RETURNS:
 *
 * AUTHOR
 * 	mcc 01/19/96 (from HAWIN)
 */
LONG WinSockReadEvent(ST_STDCOM*pstPrivate, LPARAM lPar)
	{

	ComNotify(pstPrivate->hCom, DATA_RECEIVED);
	return 0;
	}   /*lint !e715 */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	WinSockWriteEvent
 *
 * DESCRIPTION:
 *	Called back by Winsock when write completes; updates data structures
 *	to allow another write to take place
 *
 * PARAMETERS:
 *	pstPrivate		Driver's private data structure
 *  lPar			status code from Winsock
 *
 * RETURNS:
 *	
 * AUTHOR
 * 	mcc 01/19/96 (from HAWIN)
 */
LONG WinSockWriteEvent(ST_STDCOM *pstPrivate, LPARAM lPar)
	{
	int nCount;
	int nError;


	DbgOutStr("WinSockWriteEvent called to handle %d bytes ...",
      		pstPrivate->nSendBufrLen,0,0,0,0);
	
	if (pstPrivate->fConnected == COM_PORT_NOT_OPEN)
		return 0;

	if (pstPrivate->fSndBreak)
		{
		WinSockSendBreak(pstPrivate);
		pstPrivate->fSndBreak = FALSE;
		}

	if (pstPrivate->nSendBufrLen)
		{
		// This is done to keep the "main thread" from updating the buffer
		//  while we send it.  OK, I think, since send won't block.
	    EnterCriticalSection(&pstPrivate->csect);

		nCount = send(pstPrivate->hSocket,
								pstPrivate->pbSendBufr,
								(int)pstPrivate->nSendBufrLen,
								0);
	    LeaveCriticalSection(&pstPrivate->csect);


		// DbgOutStr("WinSock send returned %d\r\n", nCount, 0,0,0,0);

		// assert((int)pstPrivate->SendBufrLen == nCount);

		if (nCount == SOCKET_ERROR)
			{
			nError = WSAGetLastError();

			if (nError == WSAEWOULDBLOCK)
				{
				DbgOutStr("  still blocked\n", 0,0,0,0,0);
				/*
				 * Nothing to do in this case
				 */
				}
			else
				{
				// Got some weird error.  Notify interested parties
				// that our connection is suspect
				DbgOutStr(" got error %d\r\n", nError, 0,0,0,0);
				pstPrivate->nSendBufrLen = 0;
				pstPrivate->pbSendBufr = 0;
				ComNotify(pstPrivate->hCom, CONNECT);
				}
			}
		else
			{
			DbgOutStr("%d bytes sent.\n", nCount, 0,0,0,0);
	
			if (nCount < (int)pstPrivate->nSendBufrLen)
				{
				pstPrivate->nSendBufrLen -= (USHORT)nCount;
				pstPrivate->pbSendBufr += nCount;
				}
			else
				{
				pstPrivate->nSendBufrLen = 0;
				pstPrivate->pbSendBufr = 0;
				}
			}
		}

	if (pstPrivate->nSendBufrLen == 0)
		{
		pstPrivate->fSending = FALSE;


		//DbgOutStr("Sending WM_COM_SEND_DONE in WinSockWriteEvent\n",0,0,0,0,0);
   		ComNotify(pstPrivate->hCom, SEND_DONE);
		}

	return 0;
	}   /*lint !e715 */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	WinSockResolveEvent
 *
 * DESCRIPTION:
 *	Called once WSAAsynchGetHostByName has done its dirty work to actually
 *  generate a connect call
 *
 * PARAMETERS:
 *	pstPrivate		Driver's private data structure
 *  lPar			returned from previous Winsock call
 *
 * RETURNS:
 *	0
 *
 * AUTHOR
 *	mcc 01/18/96 (borrowed from HAWIN)
 */
LONG WinSockResolveEvent(ST_STDCOM *pstPrivate, LPARAM lPar)
	{
	int nError;
	struct sockaddr_in	srv_addr;
	LPHOSTENT			pstHost;
	ULONG				*pulAddress;

	DbgOutStr("WinSockResolveEvent called\n", 0,0,0,0,0);

	nError = HIWORD(lPar);
	if (nError)
		{
		// Notify the connection driver that a change in status may
		// have taken place.  It will follow up and display
		// an appropriate message
		DbgOutStr("Resolve: hiword of lpar = %d\n", nError,0,0,0,0);
		
		ComNotify(pstPrivate->hCom, CONNECT);
		pstPrivate->fConnected = COM_PORT_NOT_OPEN;
		
		return 0;
		}

	pstHost = (LPHOSTENT) &pstPrivate->stHostBuf;
	pulAddress = (ULONG FAR *)*(pstHost->h_addr_list);

	nError = WSAAsyncSelect(pstPrivate->hSocket,
							pstPrivate->hwndEvents,
							WM_WINSOCK_NOTIFY,
							FD_CONNECT | FD_READ | FD_WRITE | FD_CLOSE
							);

	if (nError != 0)
		{
		DbgOutStr("Resolve: WSAAsyncSelect failed\n", 0,0,0,0,0);
		ComNotify(pstPrivate->hCom, CONNECT);
		return 0;
		}


	srv_addr.sin_family = AF_INET;
	srv_addr.sin_addr.s_addr = *pulAddress;
	srv_addr.sin_port = (short) htons(pstPrivate->nPort);

 	if (connect(pstPrivate->hSocket,
							(LPSOCKADDR)&srv_addr,
							sizeof(srv_addr)) == SOCKET_ERROR)
		{
		nError = WSAGetLastError();
		if (nError != WSAEWOULDBLOCK)
			{
			DbgOutStr("Resolve: connect failed, code = %d\n", nError,
					0,0,0,0);
			//DeviceReportError(pstPrivate, (UINT)nError, 0, FALSE);
			ComNotify(pstPrivate->hCom, CONNECT);
			}
		}

	return 0;
	}
	
	
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	WinSockSendMessage
 *
 * DESCRIPTION:
 *	Used to send a Telnet option message. This calls send() directly so
 *	that data can go out while SndBufrSend is reporting COM_BUSY.
 *
 * PARAMETERS:
 *	pstPrivate		Com driver private data
 *	nMsg			The message number , e.g. DO, WILL, WONT, (see comwsock.hh)
 *	nChar			The message data, e.g. TELOPT_BINARY (see comwsock.hh)
 *
 * RETURNS:
 *	void
 *
 * AUTHOR
 *	mcc 02/06/96
 */
VOID WinSockSendMessage(ST_STDCOM * pstPrivate, INT nMsg, INT nChar)
    {
	unsigned char 	acMsg[3];

	#if defined(_DEBUG)
	char *nNames[] = {"WILL", "WONT", "DO", "DONT"};
	assert( nMsg >= WILL && nMsg <= DONT );
	DbgOutStr("Send %s: %lx\r\n", nNames[nMsg - WILL], nChar,0,0,0);
	#endif
	acMsg[0] = IAC;
	acMsg[1] = (UCHAR) nMsg;
	acMsg[2] = (UCHAR) nChar;
			
	
	WinSockSendBuffer(pstPrivate, 3, acMsg);
	
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	WinSockSendBuffer
 *
 * DESCRIPTION:
 *	Used to send an arbitrary string of data (e.g., a terminal type)
 *  during Telnet option negotiation
 *
 * PARAMETERS:
 *	pstPrivate		Winsock Com driver private data
 *	nSize			Number of bytes to send
 *	pszBuffer		Pointer to data to send
 *
 * RETURNS:
 *	void
 *
 * AUTHOR
 *	mcc 02/06/96
 */
VOID WinSockSendBuffer(ST_STDCOM * pstPrivate, INT nSize, LPSTR pszBuffer)
	{
	int nCount, nError;
	
	nCount = send(pstPrivate->hSocket, pszBuffer, nSize,0);
						
	if (nCount == SOCKET_ERROR)
		{								
		nError = WSAGetLastError();

		if (nError == WSAEWOULDBLOCK)
			{
			DbgOutStr("WSSB would block.  Queueing 3 bytes\n",
				0,0,0,0,0);
			if (sndQueueAppend(pstPrivate,pszBuffer, 3) != COM_OK)
				ComNotify(pstPrivate->hCom, CONNECT);
			}
		else
			ComNotify(pstPrivate->hCom, CONNECT);
		
		}
	else
		{
		int i;
		DbgOutStr("%4d >> ", nCount,0,0,0,0);
    	for (i = 0; i < nCount; i++)
    	DbgOutStr("%x ", pszBuffer[i],0,0,0,0);
		DbgOutStr("\n", 0,0,0,0,0);	
		}	
	}

	

#endif // !defined(MULTITHREAD)



#ifdef MULTITHREAD
	// This is essentially the NPORT TCPCOM driver ported to
	// Win32.  It uses different threads for reading and
	// writing to the TCP socket.
	// This code is deadwood at the moment, but might prove
	// useful in Upper Wacker if someone can figure out
	// why it does not work reliably under Win95. (send() calls
	// would often appear to work but no data would come out
	// over the socket.)

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckPortActivate
 *
 * DESCRIPTION:
 *  Called to activate the port and connect to destination
 *
 * ARGUMENTS:
 *  pstPrivate  -- driver data structure
 *  pszPortName -- not used
 *
 * RETURNS:
 *  COM_OK if port is successfully activated
 *  COM_NOT_ENOUGH_MEMORY if there in insufficient memory for data storage
 *  COM_NOT_FOUND if named port cannot be opened
 *  COM_DEVICE_ERROR if API errors are encountered
 *
 * AUTHOR:
 * mcc 12/26/95
 */
int WINAPI WsckPortActivate(void *pvPrivate,
    TCHAR *pszPortName,
    DWORD_PTR dwMediaHdl)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int             iRetVal = COM_OK;
    ST_COM_CONTROL *pstComCntrl;
    DWORD           dwThreadID;
	WORD wVersion;
	WSADATA stWsaData;
	struct sockaddr_in	cli_addr;



	/*
	 * Initialize the Windows Socket DLL
	 */
	wVersion = 0x0101;			// The version of WinSock that we want
	if (WSAStartup(wVersion, &stWsaData) != 0)
		{
		/* No DLL was available */
		iRetVal = COM_DEVICE_ERROR;
        goto checkout;
		}
	DbgOutStr("Done calling WSAStartup\n", 0,0,0,0,0);

	/* Confirm that the Windows Socket DLL supports 1.1. */
	/* Note that if the DLL supports versions greater    */
	/* than 1.1 in addition to 1.1, it will still return */
	/* 1.1 in wVersion since that is the version we      */
	/* requested                                         */
	if ((LOBYTE(stWsaData.wVersion) != 1) &&
		(HIBYTE(stWsaData.wVersion) != 1))
		{
		/* No acceptable DLL was available */
		iRetVal = COM_DEVICE_ERROR;
        goto checkout;
		}

	/*
	 * Create a socket for later use.
	 */
	pstPrivate->hSocket = socket(PF_INET, SOCK_STREAM, 0);
	if (pstPrivate->hSocket == INVALID_SOCKET)
		{
		iRetVal = WSAGetLastError();
		DbgOutStr("Error %d creating socket\n", iRetVal, 0,0,0,0);
		iRetVal = COM_DEVICE_ERROR;
		goto checkout;
		}
	DbgOutStr("Done creating socket %d \n", pstPrivate->hSocket,0,0,0,0);




	cli_addr.sin_family = AF_INET;
	cli_addr.sin_addr.s_addr = INADDR_ANY;
	cli_addr.sin_port = 0;

	// Bind the socket to any internet address.  Ignore errors;
	// real ones will be detected later, and this WILL fail
	// if the socket is already bound.
	iRetVal = bind(pstPrivate->hSocket, (LPSOCKADDR)&cli_addr,
			sizeof(cli_addr));
	DbgOutStr("Socket %d bind returns %d\n", pstPrivate->hSocket, iRetVal, 0,0,0);

    // Make sure we can get enough memory for buffers before opening device
    pstPrivate->pbBufrStart = malloc((size_t)pstPrivate->nRBufrSize);

    if (pstPrivate->pbBufrStart == NULL)
        {
        iRetVal = COM_NOT_ENOUGH_MEMORY;
        //* DeviceReportError(pstPrivate, SID_ERR_NOMEM, 0, TRUE);
        goto checkout;
        }

    pstPrivate->pbBufrEnd = pstPrivate->pbBufrStart + pstPrivate->nRBufrSize;
    pstPrivate->pbReadEnd = pstPrivate->pbBufrStart;
    pstPrivate->pbComStart = pstPrivate->pbComEnd = pstPrivate->pbBufrStart;
    pstPrivate->fBufrEmpty = TRUE;


    if (iRetVal == COM_OK)
        {
        pstComCntrl = (ST_COM_CONTROL *)pstPrivate->hCom;
        pstComCntrl->puchRBData =
            pstComCntrl->puchRBDataLimit =
            pstPrivate->pbBufrStart;

        pstPrivate->dwEventMask = EV_ERR | EV_RLSD;
        pstPrivate->fNotifyRcv = TRUE;
        pstPrivate->fBufrEmpty = TRUE;


        // Start thread to handle Reading, Writing (& 'rithmetic) & events
        pstPrivate->fHaltThread = FALSE;
        pstPrivate->hComReadThread = CreateThread((LPSECURITY_ATTRIBUTES)0,
                    16384, WsckComReadThread, pstPrivate, 0, &dwThreadID);
		DBG_THREAD("CreateThread (Read Thread)  returned %08X %08X\r\n",
            pstPrivate->hComReadThread,0,0,0,0);

        pstPrivate->hComWriteThread = CreateThread((LPSECURITY_ATTRIBUTES)0,
                    16384, WsckComWriteThread, pstPrivate, 0, &dwThreadID);
        DBG_THREAD("CreateThread  (Write Thread) returned %08X %08X\r\n",
            pstPrivate->hComWriteThread,0,0,0,0);
			
		// TODO discuss with JKH what thread priorities should be

		// Make sure that we have a valid address to connect to
		if ( wsckResolveAddress(pstPrivate->szRemoteAddr, &pstPrivate->ulAddr) != COM_OK )
			{
			pstPrivate->fConnected = COM_PORT_NOT_OPEN;
			ComNotify(pstPrivate->hCom, CONNECT);
			iRetVal = COM_NOT_FOUND;
			goto checkout;
			}

		// Connect to the specified host
		pstPrivate->stHost.sin_family = AF_INET;
		pstPrivate->stHost.sin_addr.s_addr = pstPrivate->ulAddr;
		pstPrivate->stHost.sin_port = htons(pstPrivate->nPort);
		//DbgOutStr("About to call connect", 0,0,0,0,0);
		iRetVal = connect(pstPrivate->hSocket,
					  (struct sockaddr *) &pstPrivate->stHost,
					  sizeof(pstPrivate->stHost));
		if ( iRetVal == COM_OK )
			{
			pstPrivate->fConnected = COM_PORT_OPEN;
			// Turn loose the read thread
			DbgOutStr("connect OK", 0,0,0,0,0);
			SetEvent(pstPrivate->ahEvent[EVENT_READ]);
			SetEvent(pstPrivate->ahEvent[EVENT_WRITE]);
			}
		else
			{
			iRetVal = WSAGetLastError();
			DbgOutStr(" connect() failed, rc = %d",iRetVal, 0,0,0,0);
			iRetVal = COM_NOT_FOUND;
			pstPrivate->fConnected = COM_PORT_NOT_OPEN;
			ComNotify(pstPrivate->hCom, CONNECT);
			}
        }

checkout:
    if (iRetVal != COM_OK)
        WsckPortDeactivate(pstPrivate);

    return iRetVal;
    }  /*lint !e715 */


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckPortDeactivate
 *
 * DESCRIPTION:
 *  Deactivates and closes an open port
 *
 * ARGUMENTS:
 *  pstPrivate -- Driver data structure
 *
 * RETURNS:
 *  COM_OK
 *
 * AUTHOR:
 * mcc 12/26/95
 */
int WINAPI WsckPortDeactivate(void *pvPrivate)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int iRetVal = COM_OK;
	
	if (pstPrivate->hComReadThread || pstPrivate->hComWriteThread)
        {
        // Halt the thread by setting a flag for the thread to detect and then
        // forcing WaitCommEvent to return by changing the event mask
        DBG_THREAD("DBG_THREAD: Shutting down ComWinsock thread\r\n", 0,0,0,0,0);
        pstPrivate->fHaltThread = TRUE;

        // Read thread should exit now, it's handle will signal when it has exited
        CloseHandle(pstPrivate->hComReadThread);
		WaitForSingleObject(pstPrivate->hComReadThread, 5000);

        pstPrivate->hComReadThread = NULL;
        DBG_THREAD("DBG_THREAD: ComWinsock thread has shut down\r\n", 0,0,0,0,0);

		// Write thread should exit now, it's handle will signal when it has exited
        CloseHandle(pstPrivate->hComWriteThread);
		WaitForSingleObject(pstPrivate->hComWriteThread, 5000);

        pstPrivate->hComWriteThread = NULL;
        DBG_THREAD("DBG_THWrite: ComWriteThread has shut down\r\n", 0,0,0,0,0);
		}

    if (pstPrivate->pbBufrStart)
        {
        free(pstPrivate->pbBufrStart);
        pstPrivate->pbBufrStart = NULL;
        }


	// Shut down socket and WINSOCK
	closesocket(pstPrivate->hSocket);


	WSACleanup();

	pstPrivate->hSocket = INVALID_SOCKET;

    return iRetVal;
    }



/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckRcvRefill
 *
 * DESCRIPTION:
 *  Called when the receive buffer is empty to refill it. This routine
 *  should attempt to refill the buffer and return the first character.
 *  It is important that this function be implemented efficiently.
 *
 * ARGUMENTS:
 *  pstPrivate -- the driver data structure
 *
 * RETURNS:
 *  TRUE if data is put in the receive buffer
 *  FALSE if there is no new incoming data
 *
 * AUTHOR:
 * mcc 12/26/95	(taken almost entirely from comstd.c)
 */
int WINAPI WsckRcvRefill(void *pvPrivate)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int fRetVal = FALSE;
    ST_COM_CONTROL *pstComCntrl;

    EnterCriticalSection(&pstPrivate->csect);

    pstPrivate->pbComStart = (pstPrivate->pbComEnd == pstPrivate->pbBufrEnd) ?
                             pstPrivate->pbBufrStart :
	                         pstPrivate->pbComEnd;
    pstPrivate->pbComEnd = (pstPrivate->pbReadEnd >= pstPrivate->pbComStart) ?
                           pstPrivate->pbReadEnd :
	                       pstPrivate->pbBufrEnd;
    DBG_READ("DBG_READ: Refill ComStart==%x, ComEnd==%x (ReadEnd==%x)\r\n",
        pstPrivate->pbComStart, pstPrivate->pbComEnd,
        pstPrivate->pbReadEnd, 0,0);
    if (pstPrivate->fBufrFull)
        {
        DBG_READ("DBG_READ: Refill Signalling EVENT_READ\r\n", 0,0,0,0,0);
        SetEvent(pstPrivate->ahEvent[EVENT_READ]);
        }
    if (pstPrivate->pbComStart == pstPrivate->pbComEnd)
        {
        DBG_READ("DBG_READ: Refill setting fBufrEmpty = TRUE\r\n", 0,0,0,0,0);
        pstPrivate->fBufrEmpty = TRUE;
        ComNotify(pstPrivate->hCom, NODATA);
        }
    else
        {
        pstComCntrl = (ST_COM_CONTROL *)pstPrivate->hCom;
        pstComCntrl->puchRBData = pstPrivate->pbComStart;
        pstComCntrl->puchRBDataLimit = pstPrivate->pbComEnd;
        fRetVal = TRUE;
        }

    LeaveCriticalSection(&pstPrivate->csect);
    return fRetVal;
    }


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckRcvClear
 *
 * DESCRIPTION:
 *  Clears the receiver of all received data.
 *
 * ARGUMENTS:
 *  hCom -- a comm handle returned by an earlier call to ComCreateHandle
 *
 * RETURNS:
 *  COM_OK if data is cleared
 *  COM_DEVICE_ERROR if Windows com device driver returns an error
 *
 * AUTHOR:
 * mcc 12/26/95	(taken almost entirely from comstd.c)
 */
int WINAPI WsckRcvClear(void *pvPrivate)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int iRetVal = COM_OK;
    ST_COM_CONTROL *pstComCntrl;

    EnterCriticalSection(&pstPrivate->csect);
    pstComCntrl = (ST_COM_CONTROL *)pstPrivate->hCom;

    // Set buffer pointers to clear out any data we might have queued
    pstComCntrl->puchRBData = pstPrivate->pbBufrStart;
	pstComCntrl->puchRBDataLimit = pstPrivate->pbBufrStart;
    pstPrivate->pbReadEnd = pstPrivate->pbBufrStart;
    pstPrivate->pbComStart = pstPrivate->pbBufrStart;
	pstPrivate->pbComEnd = pstPrivate->pbBufrStart;

    LeaveCriticalSection(&pstPrivate->csect);
    return iRetVal;
    }



//          Buffered send routines


/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckSndBufrSend
 *
 * DESCRIPTION:
 *	Sends a buffer over the socket
 *
 * ARGUMENTS:
 *	pstPrivate		Driver's private data structure
 *  pvBufr			Pointer to data to send
 *	nSize			Number of bytes to send
 *
 * RETURNS:
 *	COM_OK			if successful
 *  COM_FAILED		otherwise
 *
 *
 * AUTHOR:
 * mcc 12/26/95	
 */
int WINAPI WsckSndBufrSend(void *pvPrivate, void *pvBufr, int  nSize)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int  iRetVal = COM_OK;
	int  iCode;

    assert(pvBufr != (void *)0);
    assert(nSize <= WSOCK_SIZE_OUTQ);

	if (pstPrivate->fSending)
		{
		DbgOutStr("SBS: Busy", 0,0,0,0,0);
		return COM_BUSY;
		}
    else if (nSize > 0)
        {
        ComNotify(pstPrivate->hCom, SEND_STARTED);
        EnterCriticalSection(&pstPrivate->csect);
		pstPrivate->pbSendBufr = pvBufr;
		pstPrivate->nSendBufrLen = nSize;
		pstPrivate->fSending = TRUE;


		LeaveCriticalSection(&pstPrivate->csect);
		
		// Tell the write thread to run
		iCode = SetEvent(pstPrivate->ahEvent[EVENT_WRITE]);
		DbgOutStr("SBS: %d bytes in buffer. SetEvent returns %d", nSize,
				iCode,0,0,0);

        }

    return iRetVal;
    }





/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckSndBufrClear
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 * AUTHOR:
 * mcc 12/26/95
 */
int WINAPI WsckSndBufrClear(void *pvPrivate)
    {
	ST_STDCOM *pstPrivate = (ST_STDCOM *) pvPrivate;
    int iRetVal = COM_OK;

    EnterCriticalSection(&pstPrivate->csect);
    if (WsckSndBufrIsBusy(pstPrivate))
        {
		pstPrivate->fClearSendBufr = TRUE;
        }
    LeaveCriticalSection(&pstPrivate->csect);

    return iRetVal;
    }



/*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckComWriteThread
 *
 * DESCRIPTION:
 *  One of the "main" threads of the comm driver ...
 *  Waits on an "anything to write?" semaphore
 *  When awakened, writes the write buffer in the driver data structure
 *  to the comm port and resets the semaphore
 *
 * ARGUMENTS
 *  pvData		Address of driver data structure
 *
 *
 * RETURNS:
 *  Nothing
 *
 * AUTHOR
 *	mcc 12/27/95 (stolen from Northport)
 */
DWORD  WINAPI WsckComWriteThread(void *pvData)
	{
	ST_STDCOM		*pstPrivate =  (ST_STDCOM *)pvData;
	int				nBytesWritten;
	unsigned		uSize, nBytesToSend, nBytesSent;
	int				fRunning = TRUE;
	DWORD			iResult = COM_OK;
	char			*pchData;
	int				iCode;



	DBG_THREAD("DBG_THREAD: ComWriteThread starting",0,0,0,0,0);

	// Initialize the "Something to write" semaphore to Reset, so that
	// we will wait for SndBufrSend to hand something to us
	if (! ResetEvent(pstPrivate->ahEvent[EVENT_WRITE]))
		{
		assert(0);
		}

	while (fRunning)
		{
		// Wait on a semaphore for something to write
		iCode = WaitForSingleObject(pstPrivate->ahEvent[EVENT_WRITE],
			(unsigned long) 60000);

		DBG_WRITE("WrThread: Got EVENT_WRITE %d\n", iCode,0,0,0,0);

		// Has anybody told us to shut down?
		//
		if (pstPrivate->fHaltThread)
			{
			DBG_WRITE("  WrThread: fHaltThread==TRUE, shutting down", 0,0,0,0,0);
			ExitThread(0);
			}

		else
			{
			iResult = COM_OK;
			EnterCriticalSection(&pstPrivate->csect);
			pchData = pstPrivate->pbSendBufr;
			nBytesToSend = (unsigned) pstPrivate->nSendBufrLen;

			nBytesSent = 0;
			if (nBytesToSend > 0)
				{
				DbgOutStr("WriteThrd: %d to send\n", nBytesToSend, 0,0,0,0);

				// Loop until we send all the requested data
				while ( fRunning && nBytesSent < nBytesToSend )
					{
					uSize = nBytesToSend - nBytesSent;
					LeaveCriticalSection(&pstPrivate->csect);
					assert(uSize > 0 && uSize < 32767);
					nBytesWritten = send(pstPrivate->hSocket,
						pchData,(int) uSize, 0);
					DbgOutStr("WriteThrd: %d bytes of %d sent. 1st 3 = %x %x %x\n",
							nBytesWritten, uSize, pchData[0], pchData[1], pchData[2]);

					// We have an error -- probably the connection got dropped
					// report it to the various interested parties
					if ( nBytesWritten == -1 )
						{
						iResult = (unsigned) WSAGetLastError();
						DbgOutStr("WriteThrd: error %d sending %d bytes (%d - %d). Byebye.\n",
							iResult, (int) uSize, nBytesToSend,nBytesSent,0);
						ComNotify(pstPrivate->hCom, CONNECT);
						pstPrivate->fConnected = COM_PORT_NOT_OPEN;
						fRunning = 0;
						}
					nBytesSent += (unsigned) nBytesWritten;
					if (nBytesSent < nBytesToSend  )
						{
						DbgOutStr("WrtThrd: can't send all data to socket\n",
							 0,0,0,0,0);
						pchData += nBytesWritten;
						}
					}
				EnterCriticalSection(&pstPrivate->csect);
				//DbgOutStr("  WrThread: Wrote %u bytes, %lu written, ret=%lu\n",
				//uSize, nBytesWritten, 0, 0, 0);

				// We've sent the buffer, so clear the Sending flag
				pstPrivate->fSending = FALSE;

				pstPrivate->nSendBufrLen = 0;
				pstPrivate->pbSendBufr = NULL;
				pstPrivate->fClearSendBufr = FALSE;
				
				//DBG_WRITE("  WrThread: posting EVENT_SENT", 0,0,0,0,0);
				// TOCO:mcc 12/29/95 SetEvent(pstPrivate->ahEvent[EVENT_SENT]);
				}
			if (pstPrivate->fHaltThread)
				{
				DBG_WRITE("  WrThread: fHaltThread==TRUE, shutting down", 0,0,0,0,0);
				ExitThread(0);
				}
			DbgOutStr("  WrThread: setting fSending=FALSE, resetting EVENT_WRITE\n",
				0,0,0,0,0);
			if (!ResetEvent(pstPrivate->ahEvent[EVENT_WRITE]))
				{
				assert(0);
				}
			LeaveCriticalSection(&pstPrivate->csect);
			ComNotify(pstPrivate->hCom, SEND_DONE);
			}
		}

	DbgOutStr("WriteThread exiting ...", 0,0,0,0,0);
	ExitThread(0);
	return (iResult);
	}

/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: WsckComReadThread
 *
 * DESCRIPTION:
 *  One of the main threads of the comm driver ...
 *  Reads data from the comm port as long as we have a place to put it
 *  If the buffer fills up, go to sleep until RcvRefill takes some data
 *  out of the buffer
 *
 *
 * ARGUMENTS:
 *  pvData		 address of our private data structure
 *
 * RETURNS:
 *  nothing
 *
 * AUTHOR
 *	mcc 12/27/95 (stolen from Northport)
 */
DWORD  WINAPI WsckComReadThread(void *pvData)
	{
	ST_STDCOM			*pstPrivate =  (ST_STDCOM *)pvData;
	int					fRunning = TRUE;
	int					fReading = TRUE;
	char				*pbReadFrom, *pOut;
	unsigned			nReadSize;
	long				lBytesRead, nFFs;
	int					iResult;
	int					nIndx;
	DWORD				rc;


	DBG_THREAD("DBG_THREAD: ComtcpReadThread starting",0,0,0,0,0);
	EnterCriticalSection(&pstPrivate->csect);

	// Set Read event to reset so we don't read until the connection is up
	// By setting fBufrFull TRUE, the thread will think it is being
	// reawakened from a full buffer condition when PortActivate posts the
	// semaphore
	pstPrivate->fBufrFull = TRUE;
	ResetEvent(pstPrivate->ahEvent[EVENT_READ]);
	LeaveCriticalSection(&pstPrivate->csect);

	pstPrivate->fSeenFF = 0;
	while ( fRunning )
		{

		// Wait for a wakeup call if we put ourself to sleep
		//DbgOutStr("ReadThread: Waiting for EVENT_READ", 0,0,0,0,0);
		rc = WaitForSingleObject(pstPrivate->ahEvent[EVENT_READ], 60000);
		if ( rc != 0 )
			{
			DbgOutStr("ReadThread: EVENT_READ timed out. fBufFull=%d",
				pstPrivate->fBufrFull,0,0,0,0);
			}
		else
			{
			//DbgOutStr("ReadThread: Got EVENT_READ.", 0,0,0,0,0);
			}

		// To get this thread to exit, the deactivate routine forces a
		// fake com event by posting EVENT_READ
		if (pstPrivate->fHaltThread)
			{
			DBG_THREAD("DBG_THREAD: Comtcp exiting thread",0,0,0,0,0);
			fRunning = FALSE;
			}
		else
			{
			EnterCriticalSection(&pstPrivate->csect);
			if (pstPrivate->fBufrFull)
				{
				//DbgOutStr("ReadThread: fBufrFull = FALSE", 0,0,0,0,0);
				pstPrivate->fBufrFull = FALSE;
				fReading = TRUE;
				}
			LeaveCriticalSection(&pstPrivate->csect);

			// Do reads until we fill the buffer
			while (fReading && fRunning)
				{
				// Check for wrap around in circular buffer
                pbReadFrom = (pstPrivate->pbReadEnd >= pstPrivate->pbBufrEnd) ?
                    pstPrivate->pbBufrStart : pstPrivate->pbReadEnd;

                nReadSize = (unsigned) (pbReadFrom < pstPrivate->pbComStart) ?
                    (unsigned) (pstPrivate->pbComStart - pbReadFrom - 1) :
                    (unsigned) (pstPrivate->pbBufrEnd - pbReadFrom);

                if (nReadSize > WSOCK_MAX_READSIZE)
                    nReadSize = WSOCK_MAX_READSIZE;

                if (!nReadSize)
                    {
                    DBG_READ("Read Thread -- fBufrFull = TRUE, unsignalling EVENT_READ\r\n",
                        0,0,0,0,0);
                    pstPrivate->fBufrFull = TRUE;
                    ResetEvent(pstPrivate->ahEvent[EVENT_READ]);
                    break;
                    }
                else
                    {
					DBG_READ("ReadThread posting a recv\n", 0,0,0,0,0);
					lBytesRead = recv(pstPrivate->hSocket, pbReadFrom,
													  (int)nReadSize, 0);
                    if (lBytesRead > 0)
                        {
                        pstPrivate->pbReadEnd += lBytesRead;

                        if (pstPrivate->pbReadEnd >= pstPrivate->pbBufrEnd)
                            pstPrivate->pbReadEnd = pstPrivate->pbBufrStart;

                        DBG_READ("DBG_READ: Thread -- recv completed synchronously,"
                            " lBytesRead==%ld, ReadEnd==%x\r\n",
                            lBytesRead, pstPrivate->pbReadEnd,0,0,0);

                        if (pstPrivate->fBufrEmpty)
                            {
                            DBG_READ("DBG_READ: Thread -- fBufrEmpty = FALSE\r\n", 0,0,0,0,0);
                            pstPrivate->fBufrEmpty = FALSE;
                            ComNotify(pstPrivate->hCom, DATA_RECEIVED);
                            }

						if (pstPrivate->fEscapeFF)
							{
							// The sender escaped FF characters by doubling
							// them.  Copy the received data buffer onto itself,
							// skipping every other FF
							pOut = pbReadFrom;
							nFFs = 0;
							for (nIndx = 0; nIndx < lBytesRead; nIndx += 1)
								{
								if (pstPrivate->fSeenFF)
									{
									if (pbReadFrom[nIndx] == 0xFF)
										{
										// Skip this one
										nFFs++;
										}
									else
										{
										// This should not happen, but copy
										// anyway
										*pOut = pbReadFrom[nIndx];
										pOut++;
										}
									pstPrivate->fSeenFF = FALSE;
									}
								else
									{
									// Test to see if this is an FF; copy
									// input to output.
									if (pbReadFrom[nIndx] == 0xFF)
										{
										pstPrivate->fSeenFF = TRUE;
										}
									*pOut = pbReadFrom[nIndx];
									pOut++;
									}
								}
							// Decrement the number of bytes read by the
							// number of duplicate FF's we tossed.
							lBytesRead -= nFFs;
							}

						// Notify application that we got some data
						// if buffer had been empty
						EnterCriticalSection(&pstPrivate->csect);
						if (pstPrivate->fBufrEmpty)
							{
							DBG_READ("DBG_READ: Thread -- fBufrEmpty = FALSE", 0,0,0,0,0);
							pstPrivate->fBufrEmpty = FALSE;
							}
						LeaveCriticalSection(&pstPrivate->csect);
						ComNotify(pstPrivate->hCom, DATA_RECEIVED);

						}
					else
						{

						// 0 value from recv indicates that the connection is closed;
						// -1 indicates another error.  Notify CNCT driver.
						// (re-set the connection status
						// if the error code indicates that the connection is down)
						iResult = WSAGetLastError();
						DbgOutStr("ReadThread: Got no data, err=%d", iResult, 0,0,0,0);
						EnterCriticalSection(&pstPrivate->csect);
						if ( lBytesRead == 0 ||
							iResult == WSAENETDOWN ||
							iResult == WSAENOTCONN ||
							iResult == WSAEHOSTDOWN ||
							iResult == WSAETIMEDOUT)
							{
							// Wait until we are told to shut down; don't try to read
							// anymore!
							ResetEvent(pstPrivate->ahEvent[EVENT_READ]);
							pstPrivate->fConnected = COM_PORT_NOT_OPEN;
							}

						LeaveCriticalSection(&pstPrivate->csect);
						ComNotify(pstPrivate->hCom, DATA_RECEIVED);

						}

					}


				if (pstPrivate->fHaltThread)
					{
					DBG_THREAD("DBG_THREAD: Comtcp exiting thread",0,0,0,0,0);
					fRunning = FALSE;
					}
				}  // end of fReading && fRunning
			}

		}  // end of fRunning loop

	EnterCriticalSection(&pstPrivate->csect);
	pstPrivate->hComReadThread = 0;
	LeaveCriticalSection(&pstPrivate->csect);
	DbgOutStr("ReadThread exiting ...", 0,0,0,0,0);
	ExitThread(0);

	return(0);
	}
	
	
/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	wsckResolveAddress
 *
 * DESCRIPTION:
 *	Takes a numeric or symbolic net address string and returns
 *  a valid binary internet address.
 *
 * ARGUMENTS:
 *  pszRemote		The remote system's address as a string
 *  pulAddr			Pointer to binary internet address
 *
 * RETURNS:
 *  COM_OK			If successful
 *	COM_NOT_FOUND	If the address is invalid
 *
 * AUTHOR
 *	mcc 01/09/96 (stolen from Northport)
 */
int wsckResolveAddress(TCHAR *pszRemote, unsigned long *pulAddr)
	{
	int				iRetVal = COM_NOT_FOUND;
	struct hostent  *pstHost;

	assert(pszRemote);
	assert(pulAddr);
	
	if (pszRemote && pulAddr)
		{

		// Convert pszRemote to an internet address.  If not successful,
		// assume that the string is a host NAME and try to turn
		// that into an address
		*pulAddr = inet_addr(pszRemote);
		if ((*pulAddr == INADDR_NONE) || (*pulAddr == 0))
			{
			// If not a valid network address, it should be a name, so
			// look that up (in the hosts file or via a name server)
			pstHost = gethostbyname(pszRemote);
			if ( pstHost)
				*pulAddr = *((unsigned long *)pstHost->h_addr);
			}
		if ((*pulAddr != INADDR_NONE) && (*pulAddr != 0))
			iRetVal = COM_OK;
		else
			iRetVal = COM_NOT_FOUND;
		}

	return iRetVal;
	}


#endif // MULTITHREAD
#endif // INCL_WINSOCK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\comwsock\comwsock.hh ===
/* comwsock.hh -- Private header file for winsock communications driver module
 *
 *  Copyright 1996 by Hilgraeve Inc. -- Monroe, MI
 *  All rights reserved
 *
 *  $Revision: 3 $
 *  $Date: 9/20/00 4:54p $
 */

// -=-=-=-=-=-=-=-=-=-=-=- EXPORTED PROTOTYPES -=-=-=-=-=-=-=-=-=-=-=-=-=-=-

int    WINAPI WsckDeviceInitialize(HCOM hCom, unsigned usInterfaceVersion,
                    void **ppvDriverData);
int    WINAPI WsckDeviceClose(void *pstPrivate);
int    WINAPI WsckDeviceDialog(void *pstPrivate, HWND hwndParent);
int    WINAPI WsckDeviceSpecial(void *pstPrivate,
                    const TCHAR *pszInstructions,
                    TCHAR *pszResult,
                    int   nBufrSize);
int    WINAPI WsckDeviceLoadHdl(void *pstPrivate, SF_HANDLE sfHdl);
int    WINAPI WsckDeviceSaveHdl(void *pstPrivate, SF_HANDLE sfHdl);
int    WINAPI WsckDeviceStub(void *pstPrivate);
int    WINAPI WsckPortActivate(void *pstPrivate,
                    TCHAR *pszPortName,
                    DWORD_PTR dwMediaHdl);
int    WINAPI WsckPortDeactivate(void *pstPrivate);
int    WINAPI WsckPortConnected(void *pstPrivate);


int    WINAPI WsckRcvRefill(void *pstPrivate);
int    WINAPI WsckRcvClear(void *pstPrivate);

int    WINAPI WsckSndBufrSend(void *pstPrivate, void *pvBufr,
                      int nSize);
int    WINAPI WsckSndBufrIsBusy(void *pstPrivate);
int    WINAPI WsckSndBufrQuery(void *pstPrivate, unsigned *pafStatus,
                      long *plHandshakeDelay);
int    WINAPI WsckSndBufrClear(void *pstPrivate);
int    WINAPI WsckPortConfigure(void *pstPrivate);
DWORD  WINAPI WsckComConnectThread(void *pvData);
DWORD  WINAPI WsckComReadThread(void *pvData);
DWORD  WINAPI WsckComWriteThread(void *pvData);


#if defined(INCL_WINSOCK)
/*
 * This block of defines is used by the Telnet / NVT code,
 * and is taken from RFC1143
 */
#define NO              1
#define YES             2
#define WANTNO          3
#define WANTYES         4

#define EMPTY           1
#define OPPOSITE        2
#define NONE            3

#define NVT_THRU        0
#define NVT_IAC         1
#define NVT_WILL        2
#define NVT_WONT        3
#define NVT_DO          4
#define NVT_DONT        5

#define NVT_SB          6
#define NVT_SB_TT       7
#define NVT_SB_TT_S     8
#define NVT_SB_TT_S_I   9

#define ECHO_MODE   0
#define SGA_MODE    1
#define TTYPE_MODE  2
#define BINARY_MODE 3
#define NAWS_MODE   4
// If any new modes are added, be sure to update MODE_MAX in comstd.

#define NVT_DISCARD 1
#define NVT_KEEP    2

/*
 * Definitions for the TELNET protocol.
 */
#define IAC     255     /* interpret as command: */
#define DONT    254     /* you are not to use option */
#define DO      253     /* please, you use option */
#define WONT    252     /* I won't use option */
#define WILL    251     /* I will use option */
#define SB      250     /* interpret as subnegotiation */
#define GA      249     /* you may reverse the line */
#define EL      248     /* erase the current line */
#define EC      247     /* erase the current character */
#define AYT     246     /* are you there */
#define AO      245     /* abort output--but let prog finish */
#define IP      244     /* interrupt process--permanently */
#define BREAK   243     /* break */
#define DM      242     /* data mark--for connect. cleaning */
#define NOP     241     /* nop */
#define SE      240     /* end sub negotiation */
#define EOR     239     /* end of record (transparent mode) */

#define SYNCH   242     /* for telfunc calls */

/* telnet options */
#define TELOPT_BINARY   0   /* 8-bit data path */
#define TELOPT_ECHO     1   /* echo */
#define TELOPT_RCP      2   /* prepare to reconnect */
#define TELOPT_SGA      3   /* suppress go ahead */
#define TELOPT_NAMS     4   /* approximate message size */
#define TELOPT_STATUS   5   /* give status */
#define TELOPT_TM       6   /* timing mark */
#define TELOPT_RCTE     7   /* remote controlled transmission and echo */
#define TELOPT_NAOL     8   /* negotiate about output line width */
#define TELOPT_NAOP     9   /* negotiate about output page size */
#define TELOPT_NAOCRD   10  /* negotiate about CR disposition */
#define TELOPT_NAOHTS   11  /* negotiate about horizontal tabstops */
#define TELOPT_NAOHTD   12  /* negotiate about horizontal tab disposition */
#define TELOPT_NAOFFD   13  /* negotiate about formfeed disposition */
#define TELOPT_NAOVTS   14  /* negotiate about vertical tab stops */
#define TELOPT_NAOVTD   15  /* negotiate about vertical tab disposition */
#define TELOPT_NAOLFD   16  /* negotiate about output LF disposition */
#define TELOPT_XASCII   17  /* extended ascic character set */
#define TELOPT_LOGOUT   18  /* force logout */
#define TELOPT_BM       19  /* byte macro */
#define TELOPT_DET      20  /* data entry terminal */
#define TELOPT_SUPDUP   21  /* supdup protocol */
#define TELOPT_SUPDUPOUTPUT 22  /* supdup output */
#define TELOPT_SNDLOC   23  /* send location */
#define TELOPT_TTYPE    24  /* terminal type */
#define TELOPT_EOR      25  /* end or record */
#define TELOPT_TACACS   26  /* TACACS user identification */
#define TELOPT_OUTMARK  27  /* output marking */
#define TELOPT_TERMLOC  28  /* terminal location number */
#define TELOPT_X3_PAD   30
#define TELOPT_NAWS     31  /* negotiate about terminal size */
#define TELOPT_SPEED    32  /* negotiate terminal speed */
#define TELOPT_TOGGLEFLOW 33    /* toggle flow control */
#define TELOPT_XDISPLOC 35  /* X display location */
#define TELOPT_EXOPL    255 /* extended-options-list */

/* sub-option qualifiers */
#define TELQUAL_IS      0   /* option is... */
#define TELQUAL_SEND    1   /* send option */
#define TELQUAL_OFF     0   /* turn off option */
#define TELQUAL_ON      1   /* turn on option */

#define MAX_IP_ADDR_LEN		128


/* --- These implement the Telnet NVT(network virtual terminal) --- */

VOID WinSockCreateNVT(ST_STDCOM * pstWS);
VOID WinSockReleaseNVT(ST_STDCOM * pstWS);
int FAR PASCAL WinSockNetworkVirtualTerminal(ECHAR mc, void *pD);

VOID WinSockSendMessage(ST_STDCOM * pstWS, INT nMsg, INT nChar);
VOID WinSockSendBuffer(ST_STDCOM * pstWS, INT nSize, LPSTR pszBuffer);

VOID WinSockGotDO  (ST_STDCOM * pstWS, const PSTOPT pstO);
VOID WinSockGotWILL(ST_STDCOM * pstWS, const PSTOPT pstO);
VOID WinSockGotDONT(ST_STDCOM * pstWS, const PSTOPT pstO);
VOID WinSockGotWONT(ST_STDCOM * pstWS, const PSTOPT pstO);

VOID WinSockSendNAWS( ST_STDCOM * hhDriver );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\ansi.c ===
/*	File: D:\WACKER\emu\ansi.c (Created: 08-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 12/20/00 5:28p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\chars.h>
#include <tdll\session.h>
#include <tdll\mc.h>
#include <tdll\assert.h>

#include "emu.h"
#include "emu.hh"
#include "ansi.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ansi_setmode
 *
 * DESCRIPTION:
 *	 Sets a mode for ANSI emulator
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ansi_setmode(const HHEMU hhEmu)
	{
	int mode_id, i;

	for (i = 0; i <= hhEmu->selector_cnt; i++)
		{
		mode_id = hhEmu->selector[i];
		switch (mode_id)
			{
		case 0x02:
			break;
		case 0x04:
			break;
		case 0x07:
			break;
		case 0x10:
			break;
		case 0x12:
			break;
		case 0x18:
			break;
		case 0x19:
			break;
		case 0x20:
			break;
		case 0xF1:
			break;
		case 0xF2:
			break;
		case 0xF3:
			break;
		case 0xF4:
			break;
		case 0xF5:
			break;
		case 0xF6:
		case 0xD7:
		case 0xF7:
			hhEmu->mode_AWM = SET;
			break;
		case 0xF8:
			/* select auto repeat mode */
			break;
		case 0xF18:
			break;
		case 0xF19:
			break;
		default:
			commanderror(hhEmu);
			break;
			}
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ansi_resetmode
 *
 * DESCRIPTION:
 *	 Resets a mode for the ANSI emulator.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ansi_resetmode(const HHEMU hhEmu)
	{
	int mode_id, i;

	for (i = 0; i <= hhEmu->selector_cnt; i++)
		{
		mode_id = hhEmu->selector[i];
		switch (mode_id)
			{
		case 0x02:
			break;
		case 0x04:
			break;
		case 0x07:
			break;
		case 0x10:
			break;
		case 0x12:
			break;
		case 0x18:
			break;
		case 0x19:
			break;
		case 0x20:
			break;
		case 0xF1:
			break;
		case 0xF2:
			break;
		case 0xF3:
			break;
		case 0xF4:
			break;
		case 0xF5:
			break;
		case 0xF6:
		case 0xD7:
		case 0xF7:
			hhEmu->mode_AWM = RESET; break;
		case 0xF8:
			/* select auto repeat mode */
			break;
		case 0xF18:
			break;
		case 0xF19:
			break;
		default:
			commanderror(hhEmu); break;
			}
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ansi_savecursor
 *
 * DESCRIPTION:
 *	 Saves the current cursor postion
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ansi_savecursor(const HHEMU hhEmu)
	{
	const PSTANSIPRIVATE pstPRI = (PSTANSIPRIVATE)hhEmu->pvPrivate;

	// Save or restor the cursor position.
	//
	if (hhEmu->emu_code == ETEXT('s'))
		(*hhEmu->emu_getcurpos)
			(hhEmu, &pstPRI->iSavedRow, &pstPRI->iSavedColumn);
	else		
		(*hhEmu->emu_setcurpos)
			(hhEmu, pstPRI->iSavedRow, pstPRI->iSavedColumn);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ansi_kbdin
 *
 * DESCRIPTION:
 *	 Processes local keyboard keys for the ANSI emulator.
 *
 * ARGUMENTS:
 *	 key -- key to process
 *
 * RETURNS:
 *	 nothing
 */
int ansi_kbdin(const HHEMU hhEmu, int key, const int fTest)
	{
	int index;

	/* -------------- Check Backspace & Delete keys ------------- */

	if (hhEmu->stUserSettings.fReverseDelBk && ((key == VK_BACKSPACE) ||
			(key == DELETE_KEY) || (key == DELETE_KEY_EXT)))
		{
		key = (key == VK_BACKSPACE) ? DELETE_KEY : VK_BACKSPACE;
		}

	if (hhEmu->stUserSettings.nTermKeys == EMU_KEYS_SCAN)
		{
		if ((index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl2)) != -1)
			{
			if (!fTest)
				emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl2);
			}

		else
			{
			index = std_kbdin(hhEmu, key, fTest);
			}
		}

	else if ((index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl);
		}

	else
		{
		index = std_kbdin(hhEmu, key, fTest);
		}

	return index;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DoorwayMode
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void DoorwayMode(const HHEMU hhEmu)
	{
	static INT iOldUseTermKeys;
	ECHAR ccode = hhEmu->emu_code;

	if (hhEmu->num_param[hhEmu->num_param_cnt] != 255)
		return;

	if (ccode == ETEXT('h'))
		{
		iOldUseTermKeys = hhEmu->stUserSettings.nTermKeys;
		hhEmu->stUserSettings.nTermKeys = EMU_KEYS_SCAN;
		}

	else if (ccode == ETEXT('l'))
		{
		hhEmu->stUserSettings.nTermKeys = iOldUseTermKeys;
		}

	NotifyClient(hhEmu->hSession, EVENT_EMU_SETTINGS, 0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuAnsiUnload
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuAnsiUnload(const HHEMU hhEmu)
	{
	assert(hhEmu);

	if (hhEmu->pvPrivate)
		{
		free(hhEmu->pvPrivate);
		hhEmu->pvPrivate = NULL;
		}

	emuKeyTableFree(&hhEmu->stEmuKeyTbl);
	emuKeyTableFree(&hhEmu->stEmuKeyTbl2);

	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\comwsock\comnvt.c ===
/*  File: D:\WACKER\comwsock\comnvt.c (Created: 14-Feb-1996)
 *
 *  Copyright 1996 by Hilgraeve Inc. -- Monroe, MI
 *  All rights reserved
 *
 *	$Revision: 6 $
 *	$Date: 3/26/02 5:05p $
 */


//#define DEBUGSTR

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>

#if defined (INCL_WINSOCK)

#include <tdll\session.h>
#include <tdll\com.h>
#include <tdll\comdev.h>
#include <comstd\comstd.hh>
#include "comwsock.hh"
#include <tdll\assert.h>
#include <tdll\htchar.h>
#include <emu\emu.h>

static PSTOPT LookupOption( ST_STDCOM *hhDriver, ECHAR mc );


	// This is the "Network Virtual Terminal" emulation, i.e., the code
	// that handles Telnet option negotiations.  WinSockNetworkVirtualTerminal
	// is called to check incoming data to see if there is
	// a Telnet command in there.
	
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  WinSockCreateNVT
 *
 * DESCRIPTION:
 *  This function is called to create the necessary hooks and stuff to create
 *  a Telnet NVT(network virtual terminal).
 *
 * PARAMETERS:
 *  hhDriver    -- private connection handle
 *
 * RETURNS:
 *  Nothing.
 *
 * AUTHOR
 *  mcc 01/09/96 (Ported from NPORT)
 */
VOID WinSockCreateNVT(ST_STDCOM * hhDriver)
	{
	int ix;
    DbgOutStr("WinSockCreateNVT\r\n", 0,0,0,0,0);

	hhDriver->NVTstate = NVT_THRU;

	hhDriver->stMode[ECHO_MODE].option   = TELOPT_ECHO;
    hhDriver->stMode[SGA_MODE].option    = TELOPT_SGA;
    hhDriver->stMode[TTYPE_MODE].option  = TELOPT_TTYPE;
    hhDriver->stMode[BINARY_MODE].option = TELOPT_BINARY;
    hhDriver->stMode[NAWS_MODE].option   = TELOPT_NAWS;

	for (ix = 0; ix < MODE_MAX; ++ix)	//jkh 6/18/98
		{
		hhDriver->stMode[ix].us  = hhDriver->stMode[ix].him  = NO;
		hhDriver->stMode[ix].usq = hhDriver->stMode[ix].himq = EMPTY;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  WinSockReleaseNVT
 *
 * DESCRIPTION:
 *  This function is currently a stub
 *
 * PARAMETERS:
 *  hhDriver    -- private connection handle
 *
 * RETURNS:
 *  Nothing.
 */
VOID WinSockReleaseNVT(ST_STDCOM * hhDriver)
	{

	DbgOutStr("WS releaseNVT\r\n", 0,0,0,0,0);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  WinSockGotDO
 *
 * DESCRIPTION:
 *  Handles the case of us agreeing that the other side should enable an option
 *
 * PARAMETERS:
 *  hhDriver    --  private handle for this connection driver
 *  pstO        --  Telnet options data structure
 *
 * RETURNS:
 *  nothing
 *
 * AUTHOR:
 *  mcc 01/09/96 (Ported from NPORT)
 */
VOID WinSockGotDO  (ST_STDCOM * hhDriver, const PSTOPT pstO)
	{

	DbgOutStr("Got DO: %lx\r\n", pstO->option, 0,0,0,0);
	switch (pstO->us)
		{
	case NO:
		// We were off, but server want's us on so we agree and respond
		pstO->us = YES;
		WinSockSendMessage(hhDriver, WILL, pstO->option);
		break;

	case YES:
		// Ignore, we're already enabled
		break;

	case WANTNO:
		// This is an error,we had sent a WON'T and they responded with DO
		if (pstO->usq == EMPTY)
			pstO->us = NO;	// leave option as WE wanted it
		else if (pstO->usq == OPPOSITE) // we were going to enable anyway so turn us on
			pstO->us = YES;
		pstO->usq = EMPTY;
		break;

	case WANTYES:
		// They're agreeing with our earlier WILL
		if (pstO->usq == EMPTY)
			{
			pstO->us = YES;	// all done negotiating
			}
		else if (pstO->usq == OPPOSITE)
			{
			// we changed our mind while negotiating, renegotiate for WONT
			pstO->us = WANTNO;
			pstO->usq = EMPTY;
			WinSockSendMessage(hhDriver, WONT, pstO->option);
			}
		break;

	default:
		assert(FALSE);
		break;
		}

	// If the NAWS option was just turned on, we must respond with our terminal size
	// right away. (The WinsockSendNAWS function will check whether the option is now
	// on or off).
	if ( pstO->option == TELOPT_NAWS )
		WinSockSendNAWS( hhDriver );
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
* FUNCTION:
*   WinSockGotWILL
*
* DESCRIPTION:
*   Handles the case of getting a WILL response from the remote Telnet,
*   indicating that an option will be enabled
*
* PARAMETERS:
*  hhDriver --  private handle for this connection driver
*  pstO     --  Telnet options data structure
*
* RETURNS:
*  nothing
*
* AUTHOR:
*  mcc 01/09/96 (Ported from NPORT)
*/
VOID WinSockGotWILL(ST_STDCOM * hhDriver, const PSTOPT pstO)
	{
	DbgOutStr("Got WILL: %lx\r\n", pstO->option, 0,0,0,0);
	switch(pstO->him)
		{
	case NO:
		// He was off but want's to be on so agree and respond
		pstO->him = YES;
		WinSockSendMessage(hhDriver, DO, pstO->option);
		break;

	case YES:
		// He was already on so do nothing
		break;

	case WANTNO:
		// Error: he responded to our DONT with a WILL
		if (pstO->himq == EMPTY)
			pstO->him = NO;
		else if (pstO->himq == OPPOSITE)
			pstO->him = YES;
		pstO->himq = EMPTY;
		break;

	case WANTYES:
		// He responded to our DO with a WILL (life is good!)
		if (pstO->himq == EMPTY)
			{
			pstO->him = YES;
			}
		else if (pstO->himq == OPPOSITE)
			{
			// He agreed to our DO, but we changed our mind -- renegotiate
			pstO->him = WANTNO;
			pstO->himq = EMPTY;
			WinSockSendMessage(hhDriver, DONT, pstO->option);
			}
		break;

	default:
		assert(FALSE);
		break;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  WinSockGotDONT
 *
 * DESCRIPTION:
 *  Handles the case of getting a DONT option from the remote Telnet,
 *  indicating a request not to implement a particular option
 *
 * PARAMETERS:
 *  hhDriver    Private driver handle
 *  pstO
 *
 * RETURNS:
 *  nothing
 */
VOID WinSockGotDONT(ST_STDCOM * hhDriver, const PSTOPT pstO)
	{
	DbgOutStr("Got DONT: %lx\r\n", pstO->option, 0,0,0,0);
	switch (pstO->us)
		{
	case NO:
		// Got a DONT while we were already off, just ignore
		break;

	case YES:
		// Got a DONT while we were on, agree and respond
		pstO->us = NO;
		WinSockSendMessage(hhDriver, WONT, pstO->option);
		break;

	case WANTNO:
		// He responded to our WONT with a DONT (how appropriate)
		if (pstO->usq == EMPTY)
			{
			pstO->us = NO;
			}
		else if (pstO->usq == OPPOSITE)
			{
			// He agreed to our earlier WONT but we changed our mind
			pstO->us = WANTYES;
			pstO->usq = EMPTY;
			WinSockSendMessage(hhDriver, WILL, pstO->option);
			}
		break;

	case WANTYES:
		// He responded to our WILL with a DONT, so leave it off
		if (pstO->usq == EMPTY)
			{
			pstO->us = NO;
			}
		else if (pstO->usq == OPPOSITE)
			{
			// If he'd agreed to our WILL, we'd have immediately asked for WONT
			// but since he didn't agree, we already got what we wanted
			pstO->us = NO;
			pstO->usq = EMPTY;
			}
		break;

	default:
		assert(FALSE);
		break;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 */
VOID WinSockGotWONT(ST_STDCOM * hhDriver, const PSTOPT pstO)
	{
	DbgOutStr("Got WONT: %lx\r\n", pstO->option, 0,0,0,0);
	switch (pstO->him)
		{
	case NO:
		// Got a WONT while he was already off, just ignore
		break;

	case YES:
		// He wants to change from on to off, agree and respond
		pstO->him = NO;
		WinSockSendMessage(hhDriver, DONT, pstO->option);
		break;

	case WANTNO:
		// He responded to our DONT with a WONT (how agreeable of him)
		if (pstO->himq == EMPTY)
			{
			pstO->him = NO;
			}
		else if (pstO->himq == OPPOSITE)
			{
			// He agreed to our DONT but we changed our mind while waiting
			pstO->him = WANTYES;
			pstO->himq = EMPTY;
			WinSockSendMessage(hhDriver, DO, pstO->option);
			}
		break;

	case WANTYES:
		// He responded to our DO with a WONT -- let the wimp have his way
		if (pstO->himq == EMPTY)
			{
			pstO->him = NO;
			}
		else if (pstO->himq == OPPOSITE)
			{
			// If he'd agreed to our DO, we'd have asked for a DONT so
			// now we're happy anyway
			pstO->him = NO;
			pstO->himq = EMPTY;
			}
		break;

	default:
		assert(FALSE);
		break;
		}
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  WinSockNetworkVirtualTerminal
 *
 * DESCRIPTION:
 *  called from CLoop to handle Telnet option negotiation
 *
 * PARAMETERS:
 *	mc		The current character being processed
 *	pD		Pointer to Winsock connection driver private handle
 *
 * RETURNS:
 *	NVT_DISCARD		if mc is to be discarded
 *	NVT_KEEP			if mc is to be processed further
 *
 * AUTHOR
 *	mcc  01/09/96 (mostly from NPORT)
 */
int FAR PASCAL WinSockNetworkVirtualTerminal(ECHAR mc, void *pD)
	{
	ST_STDCOM * hhDriver = (ST_STDCOM *)pD;
#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
    STEMUSET stEmuSet;
#else
	int nTtype;
#endif
	LPSTR pszPtr;
	UCHAR acTerm[64];
	HEMU  hEmu;
	HSESSION hSession;
	PSTOPT pstTelnetOpt;

	assert(hhDriver);
	
	//DbgOutStr("NVT %d %c(0x%x = %d)\n", hhDriver->NVTstate,
		// ((mc == 0)? ' ': mc), mc, mc,0);

	switch (hhDriver->NVTstate)
		{
	case NVT_THRU:
		if (mc == IAC)
			{
			hhDriver->NVTstate = NVT_IAC;
			return NVT_DISCARD ;
			}
		return NVT_KEEP ;

	case NVT_IAC:
		switch (mc)
			{
		case IAC:
			hhDriver->NVTstate = NVT_THRU;       // Got a doubled IAC, keep one
			return  NVT_KEEP ;
		case DONT:
			hhDriver->NVTstate = NVT_DONT;
			return  NVT_DISCARD ;
		case DO:
			hhDriver->NVTstate = NVT_DO;
			return  NVT_DISCARD ;
		case WONT:
			hhDriver->NVTstate = NVT_WONT;
			return  NVT_DISCARD ;
		case WILL:
			hhDriver->NVTstate = NVT_WILL;
			return  NVT_DISCARD ;
		case SB:
			hhDriver->NVTstate = NVT_SB;
			return  NVT_DISCARD ;
		case GA:
		case EL:
		case EC:
		case AYT:
		case AO:
		case IP:
		case BREAK:
		case DM:
		case SE:
			//mscMessageBeep((UINT)-1);
			hhDriver->NVTstate = NVT_THRU;
			return  NVT_DISCARD ;	// ignore all these
		case NOP:
		default:
			hhDriver->NVTstate = NVT_THRU;
			return NVT_KEEP;
			}

	case NVT_WILL:
		pstTelnetOpt = LookupOption( hhDriver, mc );
		if ( pstTelnetOpt )
			WinSockGotWILL( hhDriver, pstTelnetOpt ); // We support the option, negotiate
		else
			WinSockSendMessage( hhDriver, DONT, mc ); // We don't support it, decline	

		hhDriver->NVTstate = NVT_THRU;
		return  NVT_DISCARD ;

	case NVT_WONT:
		pstTelnetOpt = LookupOption( hhDriver, mc );
		if ( pstTelnetOpt )
			WinSockGotWONT( hhDriver, pstTelnetOpt ); // We support the option, negotiate

		// Since we don't support this option, it is always off, and we never respond
		// when the other side tries to set a state that already exists

		hhDriver->NVTstate = NVT_THRU;
		return  NVT_DISCARD ;

	case NVT_DO:
		pstTelnetOpt = LookupOption( hhDriver, mc );
		if ( pstTelnetOpt )
			WinSockGotDO( hhDriver, pstTelnetOpt ); // We support the option, negotiate
		else
			WinSockSendMessage( hhDriver, WONT, mc ); // We don't support it, decline

		hhDriver->NVTstate = NVT_THRU;
		return  NVT_DISCARD ;

	case NVT_DONT:
		pstTelnetOpt = LookupOption( hhDriver, mc );
		if ( pstTelnetOpt )
			WinSockGotDONT( hhDriver, pstTelnetOpt ); // We support the option, negotiate

		// Since we don't support this option, it is always off, and we never respond
		// when the other side tries to set a state that already exists

		hhDriver->NVTstate = NVT_THRU;
		return  NVT_DISCARD ;

	case NVT_SB:
		/* At this time we only handle one sub-negotiation */
		switch (mc)
			{
		case TELOPT_TTYPE:
			hhDriver->NVTstate = NVT_SB_TT;
			return  NVT_DISCARD ;
		default:
			break;
			}
		hhDriver->NVTstate = NVT_THRU;
		return NVT_KEEP;

	case NVT_SB_TT:
		switch (mc)
			{
		case TELQUAL_SEND:
			hhDriver->NVTstate = NVT_SB_TT_S;
			return NVT_DISCARD ;
		default:
			break;
			}
		hhDriver->NVTstate = NVT_THRU;
		return NVT_KEEP;

	case NVT_SB_TT_S:
		switch (mc)
			{
		case IAC:
			hhDriver->NVTstate = NVT_SB_TT_S_I;
			return NVT_DISCARD ;
		default:
			break;
			}
		hhDriver->NVTstate = NVT_THRU;
		return NVT_KEEP;

	case NVT_SB_TT_S_I:
		switch (mc)
			{
		case SE:
			memset(acTerm, 0, sizeof(acTerm));
			pszPtr = (LPSTR)acTerm;
			*pszPtr++ = (UCHAR)IAC;
			*pszPtr++ = (UCHAR)SB;
			*pszPtr++ = (UCHAR)TELOPT_TTYPE;
			*pszPtr++ = (UCHAR)TELQUAL_IS;

			ComGetSession(hhDriver->hCom, &hSession);
			assert(hSession);

			hEmu = sessQueryEmuHdl(hSession);
			assert(hEmu);

#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
            // The telnet terminal ids are no longer hard-coded. We
            // are now using the terminal id that is supplied by the
            // user in the "Settings" properties page. - cab:11/18/96
            //
            emuQuerySettings(hEmu, &stEmuSet);
            strcpy(pszPtr, stEmuSet.acTelnetId);
#else
			nTtype = emuQueryEmulatorId(hEmu);
			switch (nTtype)
				{
			case EMU_ANSI:
				strcpy(pszPtr, "ANSI");
				break;
			case EMU_TTY:
				strcpy(pszPtr, "TELETYPE-33");
				break;
			case EMU_VT52:
				strcpy(pszPtr, "DEC-VT52");
				break;
			case EMU_VT100:
                // strcpy(pszPtr, "VT100");
                strcpy(pszPtr, "DEC-VT100");
				break;
#if defined(INCL_VT220)
			case EMU_VT220:
                // strcpy(pszPtr, "VT220");
                strcpy(pszPtr, "DEC-VT220");
				break;
#endif
#if defined(INCL_VT320)
			case EMU_VT220:
                // strcpy(pszPtr, "VT320");
                strcpy(pszPtr, "DEC-VT320");
				break;
#endif

#if defined(INCL_VT100PLUS)
			case EMU_VT100PLUS:
                // strcpy(pszPtr, "VT100");
                strcpy(pszPtr, "DEC-VT100");
				break;
#endif

#if defined(INCL_VTUTF8)
			case EMU_VTUTF8:
                strcpy(pszPtr, "VT-UTF8");
				break;
#endif

			default:
                strcpy(pszPtr, "DEC-VT100"); // "UNKNOWN");
				break;
				}
#endif

			DbgOutStr("NVT: Terminal=%s", pszPtr, 0,0,0,0);
			pszPtr = pszPtr + strlen(pszPtr);
			*pszPtr++ = (UCHAR)IAC;
			*pszPtr++ = (UCHAR)SE;

			WinSockSendBuffer(hhDriver,
				(INT)(pszPtr - (LPSTR)acTerm),
				(LPSTR)acTerm);
			hhDriver->NVTstate = NVT_THRU;
			return NVT_DISCARD ;
		default:
			break;
			}
		hhDriver->NVTstate = NVT_THRU;
		return NVT_KEEP;

	default:
		hhDriver->NVTstate = NVT_THRU;
		return NVT_KEEP;
		}

	}


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// FUNCTION:    WinSockSendNAWS
//
// DESCRIPTION: Sends our terminal dimensions according to the Telnet NAWS option
//              specification. NAWS stands for Negotiate About Window Size. It is
//              defined in RFC 1073, "Telnet Window Size Option". If a telnet server
//              enables this capability by sending us an IAC DO NAWS sequence, we
//              will agree to it by responding with IAC WILL NAWS and then sending
//              the number of rows and columns in a sub-option negotiation sequence
//              as implemented here. We also send the sub-option sequence whenever
//              our terminal size changes.
//
// ARGUMENTS:   hhDriver -- pointer to our com driver
//
// RETURNS:     void
//
// AUTHOR:      John Hile, 6/17/98
//
VOID WinSockSendNAWS( ST_STDCOM *hhDriver )
	{
	HEMU	 hEmu;
	HSESSION hSession;
	int		 iRows;
	int		 iCols;
	UCHAR    achOutput[9];	// exact size

	// We've been asked to send our terminal size to the server. We're only
	// allowed to do so if we have successfully enabled the NAWS option with
	// the server.
	if ( hhDriver->stMode[NAWS_MODE].us == YES)
		{
		// OK, option has been turned on. Send
		//  "IAC SB NAWS WIDTH[1] WIDTH[0] HEIGHT[1] HEIGHT[0] IAC SE" to server

		// Get actual terminal size (not menu settings) from emulator
		ComGetSession(hhDriver->hCom, &hSession);
		assert(hSession);

		hEmu = sessQueryEmuHdl(hSession);
		assert(hEmu);
		emuQueryRowsCols( hEmu, &iRows, &iCols );
		achOutput[0] = (UCHAR)IAC;
		achOutput[1] = (UCHAR)SB;
		achOutput[2] = (UCHAR)TELOPT_NAWS;
		achOutput[3] = (UCHAR)(iCols / 0xFF);
		achOutput[4] = (UCHAR)(iCols % 0xFF);
		achOutput[5] = (UCHAR)(iRows / 0xFF);
		achOutput[6] = (UCHAR)(iRows % 0xFF);
		achOutput[7] = (UCHAR)IAC;
		achOutput[8] = (UCHAR)SE;

		WinSockSendBuffer(hhDriver, sizeof(achOutput), (LPSTR)achOutput);
		}
	}


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// FUNCTION:    LookupTelnetOption
//
// DESCRIPTION: Searches our table of telnet option management structures to
//              see whether we support the option coded by character mc.
//
// ARGUMENTS:   hhDriver -- our comm driver handle
//              mc       -- the character that defines the option we're looking up
//
// RETURNS:     Pointer to the option management structure if found or NULL otherwise
//
// AUTHOR:      John Hile, 6/17/98
//
static PSTOPT LookupOption( ST_STDCOM *hhDriver, ECHAR mc )
	{
	int ix;

	for (ix = 0; ix < MODE_MAX; ix++)
	if (hhDriver->stMode[ix].option == mc)
		return &hhDriver->stMode[ix];

	return (PSTOPT)0;
	}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\ansi.hh ===
/*	File: D:\WACKER\emu\ansi.hh (Created: 21-July-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

// Private emulator data for ANSI.
//
typedef struct stPrivateANSI
	{
	int iSavedRow,
		iSavedColumn;

	} ANSIPRIVATE;

typedef ANSIPRIVATE *PSTANSIPRIVATE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\csb.h ===
/*	File: D:\WACKER\emu\csb.h (Created: 27-Dec-1993)
 *
 *	Copyright 1989 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:27p $
 */


/* Display rows for receive screen */

#define CR_DR_RCV_FILE	1
#define CR_DR_VIR_SCAN	1
#define CR_DR_STORING	2
#define CR_DR_ERR_CHK	3
#define CR_DR_PACKET	4
#define CR_DR_RETRIES	4
#define CR_DR_TOTAL_RET 4
#define CR_DR_LAST_ERR	5
#define CR_DR_AMT_RCVD	5
#define CR_DR_BOTM_LINE 7

/* Display rows for send screen */
#define CS_DR_SND_FILE	1
#define CS_DR_ERR_CHK	2
#define CS_DR_PACKET	3
#define CS_DR_RETRIES	3
#define CS_DR_TOTAL_RET 3
#define CS_DR_LAST_ERR	4
#define CS_DR_AMT_RCVD	4
#define CS_DR_VUF		7
#define CS_DR_BOTM_LINE 10

extern USHORT csb_rcv(BOOL attended, BOOL single_file);
extern USHORT csb_snd(BOOL attended, unsigned nfiles, long nbytes);

/* for export to emulator */
extern VOID   CsbENQ(VOID);
extern VOID   CsbAdvanceSetup(VOID);
extern VOID   CsbInterrogate(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\ansiinit.c ===
/*	File: D:\WACKER\emu\ansiinit.c (Created: 08-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 7/23/01 6:57p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\cloop.h>
#include <tdll\mc.h>
#include <tdll\assert.h>
#include <tdll\backscrl.h>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"
#include "ansi.hh"
#include "keytbls.h"


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuAnsiInit
 *
 * DESCRIPTION:
 *	 Sets up and installs the ANSI state table. Defines the ANSI
 *	 keyboard. Either resets the emulator completely or redefines emulator
 *	 conditions as they were when last saved.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *	 nothing
 */
void emuAnsiInit(const HHEMU hhEmu)
	{
	PSTANSIPRIVATE pstPRI;

	static struct trans_entry const ansi_tbl[] =
		{
		{NEW_STATE, 0, 0, 0}, // State 0
#if !defined(FAR_EAST)
		{0, ETEXT('\x20'),	ETEXT('\xFF'),	emuStdGraphic}, 	// Space - All
#else
		{0, ETEXT('\x20'),	0xFFFF,			emuStdGraphic}, 	// Space - All
#endif
		{1, ETEXT('\x1B'),	ETEXT('\x1B'),	nothing},			// Esc
		{0, ETEXT('\x05'),	ETEXT('\x05'),	vt100_answerback},	// Ctrl-E
		{0, ETEXT('\x07'),	ETEXT('\x07'),	emu_bell},			// Ctrl-G
		{0, ETEXT('\x08'),	ETEXT('\x08'),	backspace}, 		// Backspace
		{0, ETEXT('\x09'),	ETEXT('\x09'),	tabn},				// Tab
		{0, ETEXT('\x0A'),	ETEXT('\x0B'),	emuLineFeed},		// NL - VT
		{0, ETEXT('\x0C'),	ETEXT('\x0C'),	AnsiFormFeed},		// Form Feed
		{0, ETEXT('\x0D'),	ETEXT('\x0D'),	carriagereturn},	// CR
		{3, ETEXT('\x18'),	ETEXT('\x18'),	EmuStdChkZmdm}, 	// Ctrl-X
		{0, ETEXT('\x00'),	ETEXT('\x1F'),	emuStdGraphic}, 	// All Ctrl's

		{NEW_STATE, 0, 0, 0}, // State 1						// Esc
		{2, ETEXT('\x5B'),	ETEXT('\x5B'),	ANSI_Pn_Clr},		// [
		{0, ETEXT('\x44'),	ETEXT('\x44'),	ANSI_IND},			// D
		{0, ETEXT('\x45'),	ETEXT('\x45'),	ANSI_NEL},			// E
		{0, ETEXT('\x48'),	ETEXT('\x48'),	ANSI_HTS},			// H
		{0, ETEXT('\x4D'),	ETEXT('\x4D'),	ANSI_RI},			// M

		{NEW_STATE, 0, 0, 0}, // State 2						// Esc[
		{2, ETEXT('\x30'),	ETEXT('\x39'),	ANSI_Pn},			// 0 - 9
		{2, ETEXT('\x3B'),	ETEXT('\x3B'),	ANSI_Pn_End},		// ;
		{5, ETEXT('\x3D'),	ETEXT('\x3D'),	nothing},			// =
		{2, ETEXT('\x3A'),	ETEXT('\x3F'),	ANSI_Pn},			// : - ?
		{0, ETEXT('\x41'),	ETEXT('\x41'),	ANSI_CUU},			// A
		{0, ETEXT('\x42'),	ETEXT('\x42'),	ANSI_CUD},			// B
		{0, ETEXT('\x43'),	ETEXT('\x43'),	ANSI_CUF},			// C
		{0, ETEXT('\x44'),	ETEXT('\x44'),	ANSI_CUB},			// D
		{0, ETEXT('\x48'),	ETEXT('\x48'),	ANSI_CUP},			// H
		{0, ETEXT('\x4A'),	ETEXT('\x4A'),	ANSI_ED},			// J
		{0, ETEXT('\x4B'),	ETEXT('\x4B'),	ANSI_EL},			// K
		{0, ETEXT('\x4C'),	ETEXT('\x4C'),	ANSI_IL},			// L
		{0, ETEXT('\x4D'),	ETEXT('\x4D'),	ANSI_DL},			// M
		{0, ETEXT('\x50'),	ETEXT('\x50'),	ANSI_DCH},			// P
        {0, ETEXT('\x5A'),  ETEXT('\x5A'),  ANSI_CBT},          // Z (Back tab (CBT))
		{0, ETEXT('\x66'),	ETEXT('\x66'),	ANSI_CUP},			// f
		{0, ETEXT('\x67'),	ETEXT('\x67'),	ANSI_TBC},			// g
		{0, ETEXT('\x68'),	ETEXT('\x68'),	ansi_setmode},		// h
		{0, ETEXT('\x69'),	ETEXT('\x69'),	vt100PrintCommands},// i
		{0, ETEXT('\x6C'),	ETEXT('\x6C'),	ansi_resetmode},	// l
		{0, ETEXT('\x6D'),	ETEXT('\x6D'),	ANSI_SGR},			// m
		{0, ETEXT('\x6E'),	ETEXT('\x6E'),	ANSI_DSR},			// n
		{0, ETEXT('\x70'),	ETEXT('\x70'),	nothing},			// p
		{0, ETEXT('\x72'),	ETEXT('\x72'),	vt_scrollrgn},		// r
		{0, ETEXT('\x73'),	ETEXT('\x73'),	ansi_savecursor},	// s
		{0, ETEXT('\x75'),	ETEXT('\x75'),	ansi_savecursor},	// u

		{NEW_STATE, 0, 0, 0}, // State 3						// Ctrl-X
		{3, ETEXT('\x00'),	ETEXT('\xFF'),	EmuStdChkZmdm}, 	// all codes

		{NEW_STATE, 0, 0, 0}, // State 4						// Ctrl-A
		{4, ETEXT('\x00'),	ETEXT('\xFF'),	nothing},			// all codes

		{NEW_STATE, 0, 0, 0}, // State 5						// Esc[=
		{5, ETEXT('\x32'),	ETEXT('\x32'),	ANSI_Pn},			// 2
		{5, ETEXT('\x35'),	ETEXT('\x35'),	ANSI_Pn},			// 5
		{0, ETEXT('\x68'),	ETEXT('\x68'),	DoorwayMode},		// h
		{0, ETEXT('\x6C'),	ETEXT('\x6C'),	DoorwayMode},		// l
		};

	emuInstallStateTable(hhEmu, ansi_tbl, DIM(ansi_tbl));

	// Allocate space for and initialize data that is used only by the
	// ANSI emulator.
	//
	hhEmu->pvPrivate = malloc(sizeof(ANSIPRIVATE));

	if (hhEmu->pvPrivate == 0)
		{
		assert(FALSE);
		return;
		}

	pstPRI = (PSTANSIPRIVATE)hhEmu->pvPrivate;

	memset(pstPRI, 0, sizeof(ANSIPRIVATE));

	// Initialize standard handle items.
	//
	hhEmu->emuResetTerminal = emuAnsiReset;

	emuKeyTableLoad(hhEmu, AnsiKeyTable, 
					 sizeof(AnsiKeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl);
	emuKeyTableLoad(hhEmu, IBMPCKeyTable, 
					 sizeof(IBMPCKeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl2);

	hhEmu->emu_kbdin = ansi_kbdin;
	hhEmu->emu_deinstall = emuAnsiUnload;
	emuAnsiReset(hhEmu, FALSE);

#if !defined(FAR_EAST)
	hhEmu->emu_highchar = (TCHAR)0xFF;
#else
	hhEmu->emu_highchar = (TCHAR)0xFFFF;
#endif

	backscrlSetShowFlag(sessQueryBackscrlHdl(hhEmu->hSession), TRUE);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuAnsiReset
 *
 * DESCRIPTION:
 *	 Resets the ANSI emulator.
 *
 * ARGUMENTS:
 *	fHostRequest	-	TRUE if result of codes from host
 *
 * RETURNS:
 *	 nothing
 */
int emuAnsiReset(const HHEMU hhEmu, const int fHostRequest)
	{
	hhEmu->mode_KAM = hhEmu->mode_IRM = hhEmu->mode_VEM =
	hhEmu->mode_HEM = hhEmu->mode_LNM = hhEmu->mode_DECCKM =
	hhEmu->mode_DECOM  = hhEmu->mode_DECCOLM  = hhEmu->mode_DECPFF =
	hhEmu->mode_DECPEX = hhEmu->mode_DECSCNM =
	hhEmu->mode_25enab = hhEmu->mode_protect =
	hhEmu->mode_block = hhEmu->mode_local = RESET;

	hhEmu->mode_SRM = hhEmu->mode_DECTCEM = SET;

	hhEmu->mode_AWM = hhEmu->stUserSettings.fWrapLines;

	if (fHostRequest)
		{
		ANSI_Pn_Clr(hhEmu);
		ANSI_SGR(hhEmu);
		ANSI_RIS(hhEmu);
		}

	return 0;
	}

/* end of ansiinit.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\emu.c ===
/*	File: D:\WACKER7\emu\emu.c (Created: 08-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 11 $
 *	$Date: 7/08/02 6:32p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\assert.h>
#include <tdll\mc.h>
#include <tdll\com.h>
#include <tdll\cloop.h>
#include <tdll\capture.h>
#include <tdll\session.h>
#include <tdll\load_res.h>
#include <tdll\globals.h>
#include <tdll\print.h>
#include <tdll\statusbr.h>
#include <tdll\htchar.h>
#include <search.h>
#include <tdll\update.h>
#include <term\res.h>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"

#if defined(INCL_VTUTF8)
extern BOOL DoUTF8;
#endif

static int FFstrlen(const BYTE *);
int _cdecl KeyCmp(const void *, const void *);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	char_pn
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void char_pn(const HHEMU hhEmu) 	 /* interpret a character as a numeric param */
	{
	if (hhEmu->emu_code < ETEXT(' '))
		hhEmu->emu_code = ETEXT(' ');

	hhEmu->selector[hhEmu->selector_cnt] =
	hhEmu->num_param[hhEmu->num_param_cnt] = hhEmu->emu_code - ETEXT(' ') + 1;

	hhEmu->num_param[++hhEmu->num_param_cnt] = 0;

	hhEmu->selector[++hhEmu->selector_cnt] = 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	commanderror
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void commanderror(const HHEMU hhEmu)
	{
	hhEmu->state = 0;
	ANSI_Pn_Clr(hhEmu);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuAutoDetectLoad
 *
 * DESCRIPTION:
 *	if auto dection is on, loads the given emulator ID and sets auto
 *	detection off.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle
 *	EmuID	- id of emulator to load
 *
 * RETURNS:
 *	void
 *
 */
void emuAutoDetectLoad(const HHEMU hhEmu, const int nEmuID)
	{
	if (hhEmu->stUserSettings.nEmuId != EMU_AUTO)
		return;

	if (hhEmu->stUserSettings.nEmuId != nEmuID)
		{
		emuLock((HEMU)hhEmu);
		hhEmu->stUserSettings.nAutoAttempts = 0;
#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
        // Load the default telnet terminal id for this emulator. - cab:11/18/96
        //
        emuQueryDefaultTelnetId(nEmuID, hhEmu->stUserSettings.acTelnetId,
            EMU_MAX_TELNETID);
#endif
		emuUnlock((HEMU)hhEmu);

		emuLoad((HEMU)hhEmu, nEmuID);
		}
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuStdGraphic
 *
 * DESCRIPTION:
 *	This function is called to display the normal range of characters
 *	for the emulators.	It handles insertion modes, end of line wrapping,
 *	and cursor positioning.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuStdGraphic(const HHEMU hhEmu)
	{
	ECHAR ccode;
	ECHAR echBuf[10];
	int iCharsToMove;

	int 	iRow = hhEmu->emu_currow;
	int 	iCol = hhEmu->emu_curcol;

	ECHAR	*tp = hhEmu->emu_apText[hhEmu->emu_imgrow];
	PSTATTR ap = hhEmu->emu_apAttr[hhEmu->emu_imgrow];

	ccode = hhEmu->emu_code;

	// Is the emulator in insert mode?
	//
	if (hhEmu->mode_IRM == SET)
		{
		iCharsToMove = hhEmu->emu_aiEnd[hhEmu->emu_imgrow] - iCol;

		if (iCharsToMove + iCol >= hhEmu->emu_maxcol)
			iCharsToMove -= 1;

		if (iCharsToMove > 0)
			{
			memmove(&tp[iCol+1], &tp[iCol], (unsigned)iCharsToMove * sizeof(ECHAR));
			memmove(&ap[iCol+1], &ap[iCol], (unsigned)iCharsToMove * sizeof(ECHAR));
			hhEmu->emu_aiEnd[hhEmu->emu_imgrow] =
				min(hhEmu->emu_aiEnd[hhEmu->emu_imgrow] + 1,
					hhEmu->emu_maxcol - 1);
			}
		}

	// Our competetor's are eating the NULL's.	DOS ANSI doesn't.
	// For now we'll try it their way... - mrw
	//
	if (ccode == (ECHAR)0)
		return;

	// Place the character and the current attribute into the image.
	//
	if ((hhEmu->stUserSettings.nEmuId == EMU_VT100) &&
			ccode < sizeof(hhEmu->dspchar))
			ccode = hhEmu->dspchar[ccode];

	tp[iCol] = ccode;
	ap[iCol] = hhEmu->emu_charattr;

#if !defined(CHAR_NARROW)
	
	if ((hhEmu->stUserSettings.nEmuId == EMU_AUTO) ||
		(hhEmu->stUserSettings.nEmuId == EMU_ANSIW))
		{
		// Process Double Byte Characters
		//		
		if (QueryCLoopMBCSState(sessQueryCLoopHdl(hhEmu->hSession)))
			{
			if (isDBCSChar(ccode))
				{
				int iColPrev = iCol;

				ap[iCol].wilf = 1;
				ap[iCol].wirt = 0;

				// Update the end of row index if necessary.
				//
				if (iCol > hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
					hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = iCol;

				// Update the image.
				//
				updateChar(sessQueryUpdateHdl(hhEmu->hSession),
							iRow,
							iCol,
							hhEmu->mode_IRM ?
							hhEmu->emu_maxcol :
							hhEmu->emu_aiEnd[hhEmu->emu_imgrow]);

				iCol = min(iCol+1, hhEmu->emu_maxcol);

				tp[iCol] = ccode;
				ap[iCol] = ap[iColPrev];
				ap[iCol].wilf = 0;
				ap[iCol].wirt = 1;
				}
			}

#if 0
        //mpt:1-23-98 handles the case when an incoming character
        //            (single or double byte) overwrites the first half of
        //            a double byte character
	    if ( iCol < hhEmu->emu_maxcol )
		    {
		    //if we orphaned a right half of a dbcs char
		    if (hhEmu->emu_apAttr[iRow][iCol + 1].wirt == TRUE)
			    {
			    //slide characters and attribs to left
			    iCharsToMove = hhEmu->emu_aiEnd[hhEmu->emu_imgrow] - iCol + 1;
			    if (iCol + 2 < hhEmu->emu_maxcol && iCharsToMove > 0)
				    {
				    memmove(&tp[iCol + 1],
                            &tp[iCol + 2],
                            (unsigned)iCharsToMove * sizeof(ECHAR));

				    memmove(&ap[iCol + 1],
                            &ap[iCol + 2],
                            (unsigned)iCharsToMove * sizeof(ECHAR));
				    }
			
			
				//move end of row since we removed a character
                hhEmu->emu_aiEnd[hhEmu->emu_imgrow] -= 1;

                //update the image
                updateChar(sessQueryUpdateHdl(hhEmu->hSession),
				        hhEmu->emu_imgrow,
				        hhEmu->emu_aiEnd[hhEmu->emu_imgrow] + 1,
						hhEmu->mode_IRM ?
						hhEmu->emu_maxcol :
						hhEmu->emu_aiEnd[hhEmu->emu_imgrow] + 1);

                }	
    		}
#endif
        }
#endif //CHAR_NARROW

	// Update the end of row index if necessary.
	//
	if (iCol > hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = iCol;

	// Update the image.
	//
	updateChar(sessQueryUpdateHdl(hhEmu->hSession),
				iRow,
				iCol,
				hhEmu->mode_IRM ?
				hhEmu->emu_maxcol :
				hhEmu->emu_aiEnd[hhEmu->emu_imgrow]);

	// Move the position of the cursor ahead of the last character
	// displayed, checking for end of line wrap.
	//
	iCol++;
	if (iCol > hhEmu->emu_maxcol)
		{
		if (hhEmu->mode_AWM)
			{
			// This code was added, but not enabled because we did not
			// want to introduce this without proper testing.  If line
			// wrap on capture to printer not working is reported as a
			// bug, enable this code.
			#if 0
			printEchoChar(hhEmu->hPrintEcho, ETEXT('\r'));
			printEchoChar(hhEmu->hPrintEcho, ETEXT('\n'));
			#endif
			printEchoString(hhEmu->hPrintEcho, tp, emuRowLen(hhEmu, iRow));
			CnvrtMBCStoECHAR(echBuf, sizeof(echBuf), TEXT("\r\n"),
							 StrCharGetByteCount(TEXT("\r\n")));

			printEchoString(hhEmu->hPrintEcho,
								echBuf,
								sizeof(ECHAR) * 2);

			CaptureLine(sessQueryCaptureFileHdl(hhEmu->hSession),
								CF_CAP_LINES,
								tp,
								emuRowLen(hhEmu, iRow));

			if (iRow == hhEmu->bottom_margin)
				(*hhEmu->emu_scroll)(hhEmu, 1, TRUE);
			else
				iRow += 1;

			iCol = 0;
			}
		else
			{
			iCol = hhEmu->emu_maxcol;
			}
		}

	// Finally, set the cursor position.  This wil reset emu_currow
	// and emu_curcol.
	//
	(*hhEmu->emu_setcurpos)(hhEmu, iRow, iCol);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emu_cleartabs
 *
 * DESCRIPTION:
 *	 Clears one or all tab stops.
 *
 * ARGUMENTS:
 *	 selector -- 0 clears tab at current cursor position
 *			  -- 3 clears all tabs in current line
 *
 * RETURNS:
 *	 nothing
 */
void emu_cleartabs(const HHEMU hhEmu, int selecter)
	{
	int col;

	switch (selecter)
		{
	case 0:
		hhEmu->tab_stop[hhEmu->emu_curcol] = FALSE;
		break;

	case 3:
		for (col = 0; col <= hhEmu->emu_maxcol; ++col)
			hhEmu->tab_stop[col] = FALSE;
		break;

	default:
		commanderror(hhEmu);
		break;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuSendKeyString
 *
 * DESCRIPTION:
 *	 Sends the specified string.
 *
 * ARGUMENTS:
 *	hhEmu		- The internal emulator handle.
 *	nIndex		- Position of key in keytable array.
 *	pstKeyTbl	- Address of key strings table.

 *
 * RETURNS:
 *	 nothing
 */
void emuSendKeyString(const HHEMU hhEmu,
						const nIndex,
						const PSTKEYTABLE pstKeyTbl)
	{
	ECHAR  str[80];
	PSTKEY pstKey;
	TCHAR *pszTemp;
	
	memset(str, ETEXT('\0'), sizeof(str));

	assert(nIndex >= 0 && nIndex < pstKeyTbl->iMaxKeys);

	pstKey = pstKeyTbl->pstKeys + nIndex;

	pszTemp = pstKey->fPointer ? pstKey->u.pachKeyStr : pstKey->u.achKeyStr;
	CnvrtMBCStoECHAR(str, sizeof(str), pszTemp,
					 StrCharGetByteCount(pszTemp));

    emuSendString(hhEmu, str, pstKey->uLen);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuSendString
 *
 * DESCRIPTION:
 *	 Sends the specified string.
 *
 * ARGUMENTS:
 *	 str -- address of string
 *	 strlen -- length of string
 *
 * RETURNS:
 *	 nothing
 */
void emuSendString(const HHEMU hhEmu, ECHAR *str, int nLen)
	{
	TCHAR *pchMBCS = NULL;
	TCHAR *pchTemp = NULL;
	unsigned long ulSize = 0;
	unsigned int i = 0;
    unsigned long ulDestSize = nLen + 1;

	// This probably allocates way to many bytes, but if the incomming
	// string is all MBC's we are safe.
	pchMBCS = malloc((unsigned long)ulDestSize * sizeof(TCHAR));
	if (pchMBCS == NULL)
		{
		assert(FALSE);
		return;
		}
    TCHAR_Fill(pchMBCS, TEXT('\0'), nLen + 1);

    #if defined(INCL_VTUTF8)
    if (!DoUTF8)
        {
	    ulSize = (unsigned long)CnvrtECHARtoMBCS(pchMBCS, (unsigned long)ulDestSize * sizeof(TCHAR),
											     str, (unsigned long)nLen * sizeof(ECHAR));
        }
    else
        {
        while (nLen > (int)ulSize)
            {
            pchMBCS[ulSize++] = (str[ulSize] & 0x00FF);
            }
        }
    #else
	ulSize = (unsigned long)CnvrtECHARtoMBCS(pchMBCS, (unsigned long)ulDestSize * sizeof(TCHAR),
											 str, (unsigned long)nLen * sizeof(ECHAR));
    #endif
    //
    // Make sure the string is NULL terminated.  REV: 07/23/2001
    //
    pchMBCS[ulDestSize - 1] = TEXT('\0');
    pchTemp = pchMBCS;    
    ulSize = StrCharGetStrLength(pchTemp);

#if 0	//DEADWOOD:jkh, 12/12/1996
	// Some systems mistake something like ESC 0 D  if the codes
	// are sent in separate packets. This now sends such sequences
	// in a single socket write which should usually put them in
	// the same packet (though it doesn't guarantee to do so.

	// Loop through the # of bytes in the string
	for (i = 0 ; i < ulSize ; ++i)
		CLoopCharOut(sessQueryCLoopHdl(hhEmu->hSession), *pchTemp++);
#endif

	CLoopBufrOut(sessQueryCLoopHdl(hhEmu->hSession), pchTemp, ulSize);

	free(pchMBCS);
	pchMBCS = NULL;
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emu_reverse_image
 *
 * DESCRIPTION:
 *	 Reverses the foreground and background colors for the entire virtual
 *	 image.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emu_reverse_image(const HHEMU hhEmu)
	{
	int 	nRow, nCol;
	STATTR	stOldAttr;
	PSTATTR pstAttr;

	// Set reverse screen mode for both clear and character attributes.
	//
	hhEmu->attrState[CSCLEAR_STATE].revvid =
		!hhEmu->attrState[CSCLEAR_STATE].revvid;

	hhEmu->emu_clearattr_sav =
		hhEmu->emu_clearattr = hhEmu->attrState[CSCLEAR_STATE];

	hhEmu->attrState[CS_STATE].revvid =
		!hhEmu->attrState[CS_STATE].revvid;

	hhEmu->emu_charattr = hhEmu->attrState[CS_STATE];

	for (nRow = 0; nRow < (hhEmu->emu_maxrow+1); nRow++)
		{
		pstAttr = hhEmu->emu_apAttr[nRow];

		for (nCol = 0 ; nCol <= hhEmu->emu_maxcol ; ++nCol, ++pstAttr)
			{
			stOldAttr = *pstAttr;
			pstAttr->txtclr = stOldAttr.bkclr;
			pstAttr->bkclr	= stOldAttr.txtclr;
			}
		}

	updateLine(sessQueryUpdateHdl(hhEmu->hSession), 0, hhEmu->emu_maxrow);
	NotifyClient(hhEmu->hSession, EVENT_EMU_CLRATTR, 0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emu_is25lines
 *
 * DESCRIPTION:
 *	 Tells the calling function if the emulator is using the 25th line.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 TRUE if the emulator is using the 25th line
 */
int emu_is25lines(const HHEMU hhEmu)
	{
	return (hhEmu->mode_25enab ? TRUE : FALSE);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emu_kbdlocked
 *
 * DESCRIPTION:
 *	 Replacement kbdin that ignores all keys passed to it.
 *
 * ARGUMENTS:
 *	 key -- key to process
 *
 * RETURNS:
 *	 nothing
 */
/* ARGSUSED */
int emu_kbdlocked(const HHEMU hhEmu, int key, const int fTest)
	{
	return -1;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	nothing
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
/* ARGSUSED */
void nothing(const HHEMU hhEmu)
	{
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuKbdKeyLookup
 *
 * DESCRIPTION:
 *	Main keyboard translation routine for all emulators.  Note, this
 *	routine will not lookup keys unless the iUseTermKeys flag is set.
 *
 * ARGUMENTS:
 *	UINT	key - lower byte is char or virtual key, upper byte has flags
 *
 * RETURNS:
 *	Index if translated, else minus one.
 *
 */
int emuKbdKeyLookup(const HHEMU hhEmu,
					const int uKey,
					const PSTKEYTABLE pstKeyTbl)
	{
	PSTKEY pstKey;

	if (hhEmu->stUserSettings.nTermKeys == EMU_KEYS_ACCEL)
		return -1;

	pstKey = bsearch(&uKey,
					pstKeyTbl->pstKeys,
					(unsigned)pstKeyTbl->iMaxKeys,
					sizeof(KEY), KeyCmp);

	if (pstKey)
		return (int)(pstKey - pstKeyTbl->pstKeys);

	return -1;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuKeyTableLoad
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
/* ARGSUSED */
int emuKeyTableLoad(const HHEMU hhEmu,
					const KEYTBLSTORAGE pstKeySource[],
					const int nNumKeys,
					PSTKEYTABLE const pstKeyTbl)
	{
	int 	l;
	int 	nLoop = 0;
	PSTKEY	pstKeys;

	if (nNumKeys == 0)
		return FALSE;

	emuKeyTableFree(pstKeyTbl); // free previous instance

	if ((pstKeyTbl->pstKeys = malloc((unsigned)(nNumKeys * (int)sizeof(KEY))))
			== 0)
		{
		assert(0);
		return FALSE;
		}

	memset(pstKeyTbl->pstKeys, 0, (unsigned)(nNumKeys * (int)sizeof(KEY)));

	if (pstKeyTbl->pstKeys)
		{
		for (pstKeys = pstKeyTbl->pstKeys; nLoop < nNumKeys ; pstKeys++, nLoop++)
			{
			pstKeys->key = pstKeySource[nLoop].KeyCode;

			l = FFstrlen(pstKeySource[nLoop].achKeyStr);

			if ( l	<= (int)sizeof(LPTSTR) )
				{
				pstKeys->fPointer = FALSE;

				// Because of the goofy resource compiler, it was
				// necessary to define a "\xff" in the resource data,
				// when what we really wanted was a "\x00\xff".  So,
				// now we determine when this case occurs, and load the
				// \x00 value manually.  Note that there is an additional
				// test for this below when determining the length of the
				// the data.
				//
				if (l != 0)
					{
					MemCopy(pstKeys->u.achKeyStr, pstKeySource[nLoop].achKeyStr, (unsigned)l);
					}

				else
					{
					pstKeys->u.achKeyStr[0] = '\x00';
					}
				}
			else
				{
				pstKeys->fPointer = TRUE;
				pstKeys->u.pachKeyStr = malloc((unsigned)(l+1));

				if (!pstKeys->u.pachKeyStr)
					{
					emuKeyTableFree(pstKeyTbl);
					break;
					}

				MemCopy(pstKeys->u.pachKeyStr, pstKeySource[nLoop].achKeyStr, (unsigned)l);
				}

			// Here's the special case test, again.
			//
			if (l !=0 )
				pstKeys->uLen = (int)l;
			else
				pstKeys->uLen = 1;

			pstKeyTbl->iMaxKeys += 1;
			}
		}

	if (pstKeyTbl->iMaxKeys)
		{
		qsort(pstKeyTbl->pstKeys,
					(unsigned)pstKeyTbl->iMaxKeys,
					sizeof(KEY),
					KeyCmp);
		}

	return (int)pstKeyTbl->iMaxKeys;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuKeyTableFree
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuKeyTableFree(PSTKEYTABLE const pstKeyTbl)
	{
	int i;

	for (i = 0 ; i < pstKeyTbl->iMaxKeys ; i++)
		{
		if (pstKeyTbl->pstKeys[i].fPointer)
			{
			free(pstKeyTbl->pstKeys[i].u.pachKeyStr);
			pstKeyTbl->pstKeys[i].u.pachKeyStr = NULL;
			}
		}

	pstKeyTbl->iMaxKeys = 0;

	if (pstKeyTbl->pstKeys)
		{
		free(pstKeyTbl->pstKeys);
		pstKeyTbl->pstKeys = (KEY *)0;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	FFstrlen
 *
 * DESCRIPTION:
 *	Local version of strlen that uses '\ff' as a string terminator
 *
 * ARGUMENTS:
 *	CHAR FAR *s - '\ff' terminated string.
 *
 * RETURNS:
 *	length
 *
 */
static int FFstrlen(const BYTE *s)
	{
	int i = 0;

	while (*s++ != 0xFF)
		i += 1;

	return i;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * KeyCmp
 *
 * DESCRIPTION: Compare function for qsort.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int _cdecl KeyCmp(PSTKEY pstKey1, PSTKEY pstKey2)
	{
	if (pstKey1->key > pstKey2->key)
		return 1;

	if (pstKey1->key < pstKey2->key)
		return -1;

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * emuInstallStateTable
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuInstallStateTable(const HHEMU hhEmu, struct trans_entry const *e, int size)
	{
	struct state_entry *state_pntr = 0;
	int nStateCnt = 0;
	int nTransCnt = 0;

	while (size--)
		{
		if (e->next_state == NEW_STATE) 	/* start a new state */
			{
			assert(nStateCnt < MAX_STATE);
			hhEmu->state_tbl[nStateCnt].first_trans = &hhEmu->trans_tbl[nTransCnt];
			state_pntr = &hhEmu->state_tbl[nStateCnt++];
			state_pntr->number_trans = 0;
			}
		else							/* add a transition */
			{
			assert(nTransCnt < MAX_TRANSITION);
			assert(state_pntr);
			if (state_pntr)
				{
				++state_pntr->number_trans;
				}
			hhEmu->trans_tbl[nTransCnt++] = *e;
			}
		++e;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuCreateTextAttrBufs
 *
 * DESCRIPTION:
 *	This one took a while to decipher but here is the bottom line.
 *	emu_maxrow and emu_maxcol refer to the last row and column from
 *	offset 0 (ZERO)!  The emulator image has 2 (two) more columns for the
 *	the stuff unknown to me at the present time.  This function wants
 *	the total number of rows and columns, so emu_maxrow = 23 means the
 *	the argument nRows is 24.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int emuCreateTextAttrBufs(const HEMU hEmu, const size_t nRows, size_t nCols)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	register size_t i, ndx;
	PSTATTR pstAttr;

    if (hhEmu == NULL)
        {
        return FALSE;
        }

	if (hhEmu->emu_apText && hhEmu->emu_apAttr && hhEmu->emu_aiEnd)
		return (TRUE);
	else
		emuDestroyTextAttrBufs(hEmu);

	nCols += 2; // Emulators need two extra columns.

	// Allocate the text buffer.
	//
	if ((hhEmu->emu_apText = (ECHAR **)calloc(nRows, sizeof(ECHAR *))) == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	for (i = 0 ; i < nRows ; ++i)
		{
		if ((hhEmu->emu_apText[i] = (ECHAR *)calloc(nCols, sizeof(ECHAR))) == 0)
			{
			assert(FALSE);
			emuDestroyTextAttrBufs(hEmu);
			return FALSE;
			}

		ECHAR_Fill(hhEmu->emu_apText[i], EMU_BLANK_CHAR, nCols);
		}

	// Allocate the array to hold the rightmost character column number
	// for each row.
	//
	if ((hhEmu->emu_aiEnd = (int *)calloc(nRows, sizeof(int))) == 0)
		{
		assert(FALSE);
		emuDestroyTextAttrBufs(hEmu);
		return FALSE;
		}

	for (ndx = 0;  ndx < nRows; ++ndx)
			hhEmu->emu_aiEnd[ndx] = EMU_BLANK_LINE;

	// Allocate the attribute buffer.
	//
	if ((hhEmu->emu_apAttr = (PSTATTR *)calloc(nRows, sizeof(LPTSTR))) == 0)
		{
		assert(FALSE);
		emuDestroyTextAttrBufs(hEmu);
		return FALSE;
		}

	for (i = 0 ; i < nRows ; ++i)
		{
		if ((hhEmu->emu_apAttr[i] = calloc(nCols, sizeof(STATTR))) == 0)
			{
			assert(FALSE);
			emuDestroyTextAttrBufs(hEmu);
			return FALSE;
			}

		for (ndx = 0, pstAttr = hhEmu->emu_apAttr[i] ; ndx < nCols ; ++ndx)
			pstAttr[ndx] = hhEmu->emu_clearattr;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuDestroyTextAttrBufs
 *
 * DESCRIPTION:
 *	Destroys any allocated buffers for text and attributes.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void emuDestroyTextAttrBufs(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	register int i;

    if (hEmu == NULL || hhEmu == NULL)
        {
        return;
        }

	if (hhEmu->emu_apText)
		{
        //
        // Fixed memory leak  hhEmu->emu_maxrow != MAX_EMUROWS
        // MAX_EMUROWS was what was allocated. REV: 12/20/2000
        //
		for (i = 0 ; i < MAX_EMUROWS ; ++i)
			{
			if (hhEmu->emu_apText[i])
				{
				free(hhEmu->emu_apText[i]);
				hhEmu->emu_apText[i] = NULL;
				}
			if (hhEmu->emu_apAttr[i])
				{
				free(hhEmu->emu_apAttr[i]);
				hhEmu->emu_apAttr[i] = NULL;
				}
			}

        free(hhEmu->emu_apText);
		hhEmu->emu_apText = 0;

        free(hhEmu->emu_apAttr);
		hhEmu->emu_apAttr = 0;
		}

	if (hhEmu->emu_aiEnd)
		{
		free(hhEmu->emu_aiEnd);
		hhEmu->emu_aiEnd = 0;
		}

	if (hhEmu->emu_apAttr)
		{
		for (i = 0 ; i <= hhEmu->emu_maxrow ; ++i)
			{
			if (hhEmu->emu_apAttr[i])
				{
				free(hhEmu->emu_apAttr[i]);
				hhEmu->emu_apAttr[i] = NULL;
				}
			}

		free(hhEmu->emu_apAttr);
		hhEmu->emu_apAttr = 0;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuCreateNameTable
 *
 * DESCRIPTION:
 *	Loads the Emulator Names into a table
 *
 * ARGUMENTS:
 *	HHEMU hhEmu	-	Emulator Handle
 *
 * RETURNS:
 *	Success/Failure
 *
 */
int emuCreateNameTable(const HHEMU hhEmu)
	{
	int 	iLen, idx, iRet;
	TCHAR	achText[256];

	iRet = TRUE;

	emuLock((HEMU)hhEmu);

	if (hhEmu->pstNameTable)
		{
		free(hhEmu->pstNameTable);
		hhEmu->pstNameTable = NULL;
		}

	if ((hhEmu->pstNameTable = malloc(sizeof(STEMUNAMETABLE) * NBR_EMULATORS)) == 0)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	// Load the emulator name table.  It simply contains the name and id of
	// all of the supported emulators.
	//

	// EMU_AUTO
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_AUTO, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx = 0;
	StrCharCopyN(hhEmu->pstNameTable[idx].acName, achText, EMU_MAX_NAMELEN);
	hhEmu->pstNameTable[idx].nEmuId = EMU_AUTO;

	// EMU_ANSI
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_ANSI, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopyN(hhEmu->pstNameTable[idx].acName, achText, EMU_MAX_NAMELEN);
	hhEmu->pstNameTable[idx].nEmuId = EMU_ANSI;

	// EMU_ANSIW
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_ANSIW, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopyN(hhEmu->pstNameTable[idx].acName, achText, EMU_MAX_NAMELEN);
	hhEmu->pstNameTable[idx].nEmuId = EMU_ANSIW;

	// EMU_MIMI
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_MINI, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopyN(hhEmu->pstNameTable[idx].acName, achText, EMU_MAX_NAMELEN);
	hhEmu->pstNameTable[idx].nEmuId = EMU_MINI;

	// EMU_VIEW
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_VIEW, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopyN(hhEmu->pstNameTable[idx].acName, achText, EMU_MAX_NAMELEN);
	hhEmu->pstNameTable[idx].nEmuId = EMU_VIEW;


	// EMU_TTY
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_TTY, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopyN(hhEmu->pstNameTable[idx].acName, achText, EMU_MAX_NAMELEN);
	hhEmu->pstNameTable[idx].nEmuId = EMU_TTY;

	// EMU_VT100
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_VT100, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopyN(hhEmu->pstNameTable[idx].acName, achText, EMU_MAX_NAMELEN);
	hhEmu->pstNameTable[idx].nEmuId = EMU_VT100;

	// EMU_VT52
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_VT52, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopyN(hhEmu->pstNameTable[idx].acName, achText, EMU_MAX_NAMELEN);
	hhEmu->pstNameTable[idx].nEmuId = EMU_VT52;

	// EMU_VT100J
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_VT100J, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopyN(hhEmu->pstNameTable[idx].acName, achText, EMU_MAX_NAMELEN);
	hhEmu->pstNameTable[idx].nEmuId = EMU_VT100J;

#if defined(INCL_VT220)
	// EMU_VT220
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_VT220, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopyN(hhEmu->pstNameTable[idx].acName, achText, EMU_MAX_NAMELEN);
	hhEmu->pstNameTable[idx].nEmuId = EMU_VT220;
#endif

#if defined(INCL_VT320)
	// EMU_VT320
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_VT320, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopyN(hhEmu->pstNameTable[idx].acName, achText, EMU_MAX_NAMELEN);
	hhEmu->pstNameTable[idx].nEmuId = EMU_VT320;
#endif

#if defined(INCL_VT100PLUS)
	// EMU_VT100+
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_VT100PLUS, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopyN(hhEmu->pstNameTable[idx].acName, achText, EMU_MAX_NAMELEN);
	hhEmu->pstNameTable[idx].nEmuId = EMU_VTUTF8;
#endif

#if defined(INCL_VTUTF8)
	// EMU_VTUTF8
	//
	iLen = LoadString(glblQueryDllHinst(), IDS_EMUNAME_VTUTF8, achText, sizeof(achText) / sizeof(TCHAR));

	if (iLen >= EMU_MAX_NAMELEN)
		{
		assert(FALSE);
		iRet = FALSE;
		goto LoadExit;
		}

	idx++;
	StrCharCopyN (hhEmu->pstNameTable[idx].acName, achText, EMU_MAX_NAMELEN);
	hhEmu->pstNameTable[idx].nEmuId = EMU_VTUTF8;
#endif

	LoadExit:

	emuUnlock((HEMU)hhEmu);
	return(iRet);

	}


/* end of emu.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\emu.h ===
/*	File: D:\WACKER\emu\emu.h (Created: 08-Dec-1993)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 7 $
 *	$Date: 12/27/01 11:13a $
 */

#include "..\tdll\features.h"
/* Emulator ID's */

// Don't ever change emulator id numbers.  They are stored in session files
// and as such are cast in stone. - mrw,4/13/95
//
#define EMU_AUTO						100
#define EMU_ANSI						101
#define EMU_MINI						102
#define EMU_VIEW						109
#define EMU_TTY 						110
#define EMU_VT100						111
#define EMU_VT220						112	// rde:23 Jan 98
#define EMU_VT320						113	// rde:23 Jan 98
#define EMU_VT52						115
#define EMU_VT100J						116
#define EMU_ANSIW						117
#define EMU_VT100PLUS					118 // REV: 02/28/2001 
#define EMU_VTUTF8                      119 // REV: 02/28/2001 

#define NBR_EMULATORS					13

/* Emulator constants  */

// Note: if you change MAX_EMUROWS or MAX_EMUCOLS also change
//		 TERM_ROWS and TERM_COLS in term.hh to match - mrw
// Note: Can't find TERM_ROWS and TERM_COLS. rde 10 Jun 98

#define MAX_EMUROWS 	50		// Largest vertical size for emulator.
#define MAX_EMUCOLS 	132		// Largest horizontal size for emulator.
#define MIN_EMUROWS 	10		// Smallest allowable value for rows,
#define MIN_EMUCOLS 	20		// and columns.

#define EMU_DEFAULT_COLS			80
#define EMU_DEFAULT_ROWS			24

#define EMU_OK						0
#define TRM_NUMSTRIPCHARS			3
#define EMU_MAX_NAMELEN 			15
#define EMU_MAX_AUTODETECT_ATTEMPTS 10
#define EMU_MAX_TELNETID            256

// JCM should remove the two defines below.
//
#define EMU_DEFAULT_MAXCOL			79
#define EMU_DEFAULT_MAXROW			23

#define EMU_KEYS_ACCEL		0
#define EMU_KEYS_TERM		1
#define EMU_KEYS_SCAN		2

#define EMU_CURSOR_BLOCK	1
#define EMU_CURSOR_LINE 	2
#define EMU_CURSOR_NONE 	3

#define EMU_CHARSET_ASCII			0
#define EMU_CHARSET_UK				1
#define EMU_CHARSET_SPECIAL			2
#define EMU_CHARSET_MULTINATIONAL	3
#define EMU_CHARSET_FRENCH			4
#define EMU_CHARSET_FRENCHCANADIAN	5
#define EMU_CHARSET_GERMAN			6

#define EMU_EVENT_CONNECTED 	1
#define EMU_EVENT_DISCONNECTED	2
#define EMU_EVENT_CONNECTING	3

#define EMU_BKSPKEYS_CTRLH		1
#define EMU_BKSPKEYS_DEL		2
#define EMU_BKSPKEYS_CTRLHSPACE 3

// 8 bits just ain't enough anymore.  Going to bit fields to handle
// things like text marking, blinking, underlining, etc.  Also can
// handle more colors this way if we want.	For now though stick to
// original scheme of 4 bits for foreground color and 4 bits for
// background color.

struct stAttribute
	{
	unsigned int txtclr : 4;		// text or foreground color index.
	unsigned int bkclr	: 4;		// background color index.
	unsigned int txtmrk : 1;		// true if text is 'marked'.
	unsigned int undrln : 1;		// underline
	unsigned int hilite : 1;		// foreground intensity
	unsigned int bklite : 1;		// background intensity
	unsigned int blink	: 1;		// soon to be famous blink attribute
	unsigned int revvid : 1;		// reverse video
	unsigned int blank	: 1;		// blank attribute
	unsigned int dblwilf: 1;		// double wide left
	unsigned int dblwirt: 1;		// double wide right
	unsigned int dblhilo: 1;		// double height top half
	unsigned int dblhihi: 1;		// double height bottom half
    unsigned int protect: 1;        // protected bit for DEC emulators.
	unsigned int symbol:  1;		// use symbol font
	unsigned int wilf	: 1;		// wide left
	unsigned int wirt	: 1;		// wide right
	};

typedef struct stAttribute STATTR;
typedef STATTR *PSTATTR;

// Note: This structure is now used only internally to the program--it is
// no longer used to load in and save out data in the session file. 
// Consequently, it is safe to add and remove items at will. rde 8 Jun 98
struct emuSettings
	{
	int 	nEmuId, 			// 100 = EMU_AUTO
								// 101 = EMU_ANSI
								// 102 = EMU_MINI
								// 109 = EMU_VIEW
								// 110 = EMU_TTY
								// 111 = EMU_VT100
								// 112 = EMU_VT220
								// 113 = EMU_VT320
								// 115 = EMU_VT52
								// 116 = EMU_VT100J
                                // 117 = EMU_ANSIW
								// 118 = EMU_VT100PLUS
								// 119 = EMU_VTUTF8
								//
			nTermKeys,			// 0 = EMU_KEYS_ACCEL
								// 1 = EMU_KEYS_TERM
								// 2 = EMU_KEYS_SCAN
								//
			nCursorType,		// 1 = EMU_CURSOR_BLOCK
								// 2 = EMU_CURSOR_LINE
	        					// 3 = EMU_CURSOR_NONE
								//
			nCharacterSet,		// 0 = EMU_CHARSET_ASCII
								// 1 = EMU_CHARSET_UK
								// 2 = EMU_CHARSET_SPECIAL
								//
			nAutoAttempts,		// Count of connections using the Auto
								// Detect Emulator.  At
								// EMU_MAX_AUTODETECT_ATTEMPTS, we switch
								// to Ansi emulation.  Note, this may
								// get moved into a Statictics Handle
								// if we ever develop one.
								//
			fCursorBlink,		// Blinking cursor. 			True\False.
			fMapPFkeys, 		// PF1-PF4 to top row of keypad.True\False.
			fAltKeypadMode, 	// Alternate keypad mode.		True\False.
			fKeypadAppMode, 	// Keypad application mode. 	True\False.
			fCursorKeypadMode,	// Cursor keypad mode.			True\Fales.
			fReverseDelBk,		// Reverse Del and Backsp.		True\False.
			f132Columns,		// 132 column display.			True\False.
			fDestructiveBk, 	// Destructive backspace.		True\False.
			fWrapLines, 		// Wrap lines.					True\False.
			fLbSymbolOnEnter,	// Send # symbol on Enter.		True\False.

	// Note: The following two variables were added for the VT220/320. rde:24 Jan 98
            fUse8BitCodes,      // 8-bit control codes          True\False.
            fAllowUserKeys;     // User defined keys allowed    True\False.

#if defined(INCL_PRINT_PASSTHROUGH)
    // Note: The following variable was added for VT100/220/320. mpt:5-18-00
	int     fPrintRaw;  		// Do not use windows print drv True\False.
#endif // INCL_PRINT_PASSTHROUGH

#ifdef INCL_TERMINAL_SIZE_AND_COLORS
	// The following four variables were added for user settable
	// terminal screen size and colors. rde 1 Jun 98
	int		nTextColor,			// Default text color.			0 thru 15.
			nBackgroundColor,	// Default background color.	0 thru 15.
			nUserDefRows,		// Number of terminal rows.		12 thru 50.
			nUserDefCols;		// Number of terminal columns.	40 thru 132.
#endif

    // Note: The following two variables are only used if the "Include
    // User Defined Backspace and Telnet Terminal Id" feature is enabled.
    // There is no compile switch here because this entire structure gets
    // written to the session file in one large chunk. Using a compile
    // switch could potentially cause version problems later on down
    // the road. - cab:11/15/96
    //
    int     nBackspaceKeys;     // 1 = EMU_BKSPKEYS_CTRLH
                                // 2 = EMU_BKSPKEYS_DEL
                                // 3 = EMU_BKSPKEYS_CTRLHSPACE

    TCHAR   acTelnetId[EMU_MAX_TELNETID];   // Telnet terminal ID
	};

typedef struct emuSettings STEMUSET;
typedef STEMUSET *PSTEMUSET;


/* emuhdl.c */
HEMU	emuCreateHdl(const HSESSION hSession);
int 	emuDestroyHdl(const HEMU hEmu);
int 	emuLoad(const HEMU hEmu, const int nEmuId);
void	emuLock(const HEMU hEmu);
void	emuUnlock(const HEMU hEmu);
ECHAR	**emuGetTxtBuf(const HEMU hEmu);
PSTATTR *emuGetAttrBuf(const HEMU hEmu);
int 	emuKbdIn(const HEMU hEmu, KEY_T key, const int fTest);
int 	emuDataIn(const HEMU hEmu, const ECHAR ccode);
int 	emuComDone(const HEMU hEmu);
int 	emuTrackingNotify(const HEMU hEmu);
int 	emuIsEmuKey(const HEMU hEmu, KEY_T key);
int 	emuQueryClearAttr(const HEMU hemu, PSTATTR pstClearAttr);
int 	emuQueryCurPos(const HEMU hEmu, int *row, int *col);
HPRINT	emuQueryPrintEchoHdl(const HEMU hEmu);
int 	emuQueryRowsCols(const HEMU hEmu, int *piRows, int *piCols);
int 	emuQueryEmulatorId(const HEMU hEmulator);
int 	emuNotify(const HEMU hEmu, const int nEvent);
int 	emuQueryCursorType(const HEMU hEmu);
int 	emuQueryName(const HEMU hEmu, TCHAR *achBuffer, int nSize);
int 	emuSetSettings(const HEMU hEmu, const PSTEMUSET pstSettings);
int 	emuQuerySettings(const HEMU hEmu, PSTEMUSET pstSettings);
int 	emuInitializeHdl(const HEMU hEmu);
int 	emuSaveHdl(const HEMU hEmu);
int 	emuHomeHostCursor(const HEMU hEmu);
int 	emuEraseTerminalScreen(const HEMU hEmu);

void	emuMinitelSendKey(const HEMU hEmu, const int iCmd); // minitel.c
int 	emuGetIdFromName(const HEMU hEmu, TCHAR *achEmuName);

int     emuQueryDefaultTelnetId(const int nEmuId, TCHAR *achTelnetId, int nSize);
int     emuLoadDefaultTelnetId(const HEMU hEmu);

/*	colors indexes */

#define VC_BLACK		0
#define VC_BLUE 		1
#define VC_GREEN		2
#define VC_CYAN 		3
#define VC_RED			4
#define VC_MAGENTA		5
#define VC_BROWN		6
#define VC_WHITE		7
#define VC_GRAY 		8
#define VC_BRT_BLUE 	9
#define VC_BRT_GREEN	10
#define VC_BRT_CYAN 	11
#define VC_BRT_RED		12
#define VC_BRT_MAGENTA	13
#define VC_BRT_YELLOW	14
#define VC_BRT_WHITE	15
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\emudlgs.c ===
/*	File: D:\WACKER\emu\emudlg.c (Created: 14-Feb-1994)
 *
 *	Copyright 1991, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 21 $
 *	$Date: 5/15/02 4:43p $
 */

#include <windows.h>
#pragma hdrstop

#include <commctrl.h>

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\assert.h>
#include <tdll\session.h>
#include <tdll\statusbr.h>
#include <tdll\misc.h>
#include <term\res.h>
#include <tdll\globals.h>
#include <tdll\load_res.h>
#include <tdll\htchar.h>
#include <tdll\hlptable.h>

#include "emu.h"
#include "emuid.h"
#include "emudlgs.h"

#include <tdll\term.hh> // This must be after emu.h

// Static function prototypes...
//
STATIC_FUNC void emudlgInitCursorSettings  (HWND hDlg,
									  		PSTEMUSET	pstEmuSettings,
									  		INT  ID_UNDERLINE,
									  		INT  ID_BLOCK,
									  		INT  ID_BLINK);
#if DEADWOOD
STATIC_FUNC void emudlgInitCharSetSetting(HWND  hDlg,
											PSTEMUSET pstEmuSettings,
											int nCharSetTableID,
											int nDefaultCharSetID);
STATIC_FUNC BOOL emudlgFindCharSetName(HWND  hDlg,
										BYTE *pbCharSetTable,
										int nCharSetID,
										LPTSTR *ppszCharSetName,
										BOOL fTellDlg);
#endif // DEADWOOD

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
STATIC_FUNC void emudlgInitRowsCols(HWND hDlg, PSTEMUSET pstEmuSettings);
STATIC_FUNC void emudlgGetRowColSettings(HWND hDlg, PSTEMUSET pstEmuSettings);
STATIC_FUNC void emudlgCreateUpDownControl(HWND hDlg,
										PSTEMUSET pstEmuSettings);
STATIC_FUNC int emudlgValidateEntryFieldSetting(HWND hDlg,
										int nIDC,
										int nMinVal,
										int nMaxVal);
#endif

// Defines...
//
#define IDC_KEYPAD_MODE					104
#define IDC_CURSOR_MODE					106
#define IDC_132_COLUMN					107
#define IDC_TF_CHARACTER_SET			109
#define IDC_CHARACTER_SET				110
#define IDC_BLOCK_CURSOR				112
#define IDC_UNDERLINE_CURSOR			113
#define IDC_BLINK_CURSOR				114
#define IDC_DESTRUCTIVE_BKSP			116
#define IDC_ALT_MODE					117
#define IDC_SEND_POUND_SYMBOL			122
#define IDC_HIDE_CURSOR					119
#define IDC_GR_CURSOR					111
#define IDC_GR_TERMINAL_MODES			118
#define IDC_USE_8_BIT_CODES				120
#define	IDC_ALLOW_USERDEFINED_KEYS		121
#define IDC_GR_SCREEN					130
#define IDC_TF_ROWS						131
#define	IDC_NUMBER_OF_ROWS				132
#define IDC_TF_COLUMNS					133
#define	IDC_NUMBER_OF_COLS				134
#define	IDC_PRINT_RAW					135

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuSettingsDlg
 *
 * DESCRIPTION:
 *	Decide which emulator settings dialog to call.
 *
 * ARGUMENTS:
 *  hSession 	   - the session handle.
 *  nEmuId		   - emulator id.
 *  pstEmuSettings - settings structure to fill in.  It should be initialized
 *					 up above.
 *
 * RETURNS:
 *	fResult - return value from the DoDialog().
 *
 */
BOOL emuSettingsDlg(const HSESSION hSession, const HWND hwndParent,
					const int nEmuId, PSTEMUSET pstEmuSettings)
	{
	BOOL		fResult = FALSE;

	assert(hSession && hwndParent);

	switch (nEmuId)
		{
	case EMU_ANSIW:
	case EMU_ANSI:
		fResult = (BOOL)DoDialog(glblQueryDllHinst(),
								 MAKEINTRESOURCE(IDD_ANSI_SETTINGS),
								 hwndParent,
								 (DLGPROC)emuANSI_SettingsDlgProc,
								 (LPARAM)pstEmuSettings);
		break;

	case EMU_TTY:
		fResult = (BOOL)DoDialog(glblQueryDllHinst(),
								 MAKEINTRESOURCE(IDD_TTY_SETTINGS),
								 hwndParent,
								 (DLGPROC)emuTTY_SettingsDlgProc,
								 (LPARAM)pstEmuSettings);
		break;

	case EMU_VT52:
		fResult = (BOOL)DoDialog(glblQueryDllHinst(),
								 MAKEINTRESOURCE(IDD_VT52_SETTINGS),
								 hwndParent,
								 (DLGPROC)emuVT52_SettingsDlgProc,
								 (LPARAM)pstEmuSettings);
		break;

	case EMU_VT100:
	case EMU_VT100J:
#if defined(INCL_VTUTF8)
	case EMU_VTUTF8:
#endif
#if defined(INCL_VT100PLUS)
	case EMU_VT100PLUS:
#endif
		fResult = (BOOL)DoDialog(glblQueryDllHinst(),
								 MAKEINTRESOURCE(IDD_VT100_SETTINGS),
								 hwndParent,
								 (DLGPROC)emuVT100_SettingsDlgProc,
								 (LPARAM)pstEmuSettings);
		break;

#if defined(INCL_VT220) || defined(INCL_VT320)
#if defined(INCL_VT220)
	case EMU_VT220:
#endif // defined(INCL_VT320)
#if defined(INCL_VT320)
	case EMU_VT320:
#endif // defined(INCL_VT320)
		fResult = (BOOL)DoDialog(glblQueryDllHinst(),
								 MAKEINTRESOURCE(IDD_VT220_SETTINGS),
								 hwndParent,
								 (DLGPROC)emuVT220_SettingsDlgProc,
								 (LPARAM)pstEmuSettings);
		break;
#endif // defined(INCL_VT220) || defined(INCL_VT320)

	case EMU_MINI:
		fResult = (BOOL)DoDialog(glblQueryDllHinst(),
								 MAKEINTRESOURCE(IDD_MINITEL_SETTINGS),
								 hwndParent,
								 (DLGPROC)emuMinitel_SettingsDlgProc,
								 (LPARAM)pstEmuSettings);
		break;

	case EMU_VIEW:
		fResult = (BOOL)DoDialog(glblQueryDllHinst(),
								 MAKEINTRESOURCE(IDD_VIEWDATA_SETTINGS),
								 hwndParent,
								 (DLGPROC)emuViewdata_SettingsDlgProc,
								 (LPARAM)pstEmuSettings);
		break;

	default:
		break;
		}

	return fResult;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuANSI_SettingsDlgProc
 *
 * DESCRIPTION:
 *	ANSI Settings dialog proc.
 *
 * ARGUMENTS:
 *	Standard window proc parameters.
 *
 * RETURNS:
 *	Standerd return value.
 *
 */
INT_PTR CALLBACK emuANSI_SettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	PSTEMUSET	pstEmuSettings;
	static		DWORD aHlpTable[] =
		{
		IDC_BLOCK_CURSOR,		IDH_TERM_EMUSET_CURSOR,
		IDC_UNDERLINE_CURSOR,	IDH_TERM_EMUSET_CURSOR,
		IDC_BLINK_CURSOR,		IDH_TERM_EMUSET_CURSOR,
		IDC_GR_CURSOR,			IDH_TERM_EMUSET_CURSOR,
        IDCANCEL,                           IDH_CANCEL,
        IDOK,                               IDH_OK,
		0,						0};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pstEmuSettings = (PSTEMUSET)lPar;
		SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pstEmuSettings);
		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
		/* -------------- Screen rows and columns ------------- */

		emudlgInitRowsCols(hDlg, pstEmuSettings);
#endif

		/* -------------- Cursor characteristics ------------- */

		emudlgInitCursorSettings(hDlg, pstEmuSettings, IDC_UNDERLINE_CURSOR,
			IDC_BLOCK_CURSOR, IDC_BLINK_CURSOR);

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
		doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDOK:
			pstEmuSettings = (PSTEMUSET)GetWindowLongPtr(hDlg, GWLP_USERDATA);

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
			/* -------------- Screen rows and columns ------------- */

			emudlgGetRowColSettings(hDlg, pstEmuSettings);
#endif
			/* -------------- Cursor type ------------- */

			pstEmuSettings->nCursorType =
				(int)(IsDlgButtonChecked(hDlg, IDC_BLOCK_CURSOR) == BST_CHECKED) ?
					EMU_CURSOR_BLOCK : EMU_CURSOR_LINE;

			/* -------------- Cursor Blink ------------- */

			pstEmuSettings->fCursorBlink =
				(int)(IsDlgButtonChecked(hDlg, IDC_BLINK_CURSOR) == BST_CHECKED);

			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuTTY_SettingsDlgProc
 *
 * DESCRIPTION:
 *	TTY Settings dialog proc.
 *
 * ARGUMENTS:
 *	Standard window proc parameters.
 *
 * RETURNS:
 *	Standerd return value.
 *
 */
INT_PTR CALLBACK emuTTY_SettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	PSTEMUSET	pstEmuSettings;
	static		DWORD aHlpTable[] = {IDC_DESTRUCTIVE_BKSP,	IDH_TERM_EMUSET_DESTRUCTIVE,
									 IDC_BLOCK_CURSOR,		IDH_TERM_EMUSET_CURSOR,
									 IDC_UNDERLINE_CURSOR,	IDH_TERM_EMUSET_CURSOR,
									 IDC_BLINK_CURSOR,		IDH_TERM_EMUSET_CURSOR,
									 IDC_GR_CURSOR, 		IDH_TERM_EMUSET_CURSOR,
                                     IDCANCEL,                           IDH_CANCEL,
                                     IDOK,                               IDH_OK,
									 0, 					0};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pstEmuSettings = (PSTEMUSET)lPar;
		SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pstEmuSettings);
		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
		/* -------------- Screen rows and columns ------------- */

		emudlgInitRowsCols(hDlg, pstEmuSettings);
#endif

		/* -------------- Destructive Backspace ------------- */

		SendDlgItemMessage(hDlg, IDC_DESTRUCTIVE_BKSP, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fDestructiveBk, 0);

		/* -------------- Cursor characteristics ------------- */

		emudlgInitCursorSettings(hDlg, pstEmuSettings, IDC_UNDERLINE_CURSOR,
			IDC_BLOCK_CURSOR, IDC_BLINK_CURSOR);

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDOK:
			pstEmuSettings = (PSTEMUSET)GetWindowLongPtr(hDlg, GWLP_USERDATA);

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
			/* -------------- Screen rows and columns ------------- */

			emudlgGetRowColSettings(hDlg, pstEmuSettings);
#endif
			/* -------------- Destructive Backspace ------------- */

			pstEmuSettings->fDestructiveBk =
				(int)(IsDlgButtonChecked(hDlg, IDC_DESTRUCTIVE_BKSP) == BST_CHECKED);

			/* -------------- Cursor type ------------- */

			pstEmuSettings->nCursorType =
				(int)(IsDlgButtonChecked(hDlg, IDC_BLOCK_CURSOR) == BST_CHECKED) ?
					EMU_CURSOR_BLOCK : EMU_CURSOR_LINE;

			/* -------------- Cursor Blink ------------- */

			pstEmuSettings->fCursorBlink =
				(int)(IsDlgButtonChecked(hDlg, IDC_BLINK_CURSOR) == BST_CHECKED);

			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuVT52_SettingsDlgProc
 *
 * DESCRIPTION:
 *	VT52 Settings dialog proc.
 *
 * ARGUMENTS:
 *	Standard window proc parameters.
 *
 * RETURNS:
 *	Standerd return value.
 *
 */
INT_PTR CALLBACK emuVT52_SettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	PSTEMUSET	pstEmuSettings;
	static 		DWORD aHlpTable[] = {IDC_ALT_MODE,		   IDH_TERM_EMUSET_ALTMODE,
									 IDC_BLOCK_CURSOR,	   IDH_TERM_EMUSET_CURSOR,
									 IDC_UNDERLINE_CURSOR, IDH_TERM_EMUSET_CURSOR,
									 IDC_BLINK_CURSOR,	   IDH_TERM_EMUSET_CURSOR,
									 IDC_GR_CURSOR, 	   IDH_TERM_EMUSET_CURSOR,
                                     IDCANCEL,                           IDH_CANCEL,
                                     IDOK,                               IDH_OK,
									 0, 					0};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pstEmuSettings = (PSTEMUSET)lPar;
		SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pstEmuSettings);
		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
		/* -------------- Screen rows and columns ------------- */

		emudlgInitRowsCols(hDlg, pstEmuSettings);
#endif

		/* -------------- Alternate keypad mode ------------- */

		SendDlgItemMessage(hDlg, IDC_ALT_MODE, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fAltKeypadMode, 0);

		/* -------------- Cursor characteristics ------------- */

		emudlgInitCursorSettings(hDlg, pstEmuSettings, IDC_UNDERLINE_CURSOR,
			IDC_BLOCK_CURSOR, IDC_BLINK_CURSOR);

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDOK:
			pstEmuSettings = (PSTEMUSET)GetWindowLongPtr(hDlg, GWLP_USERDATA);

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
			/* -------------- Screen rows and columns ------------- */

			emudlgGetRowColSettings(hDlg, pstEmuSettings);
#endif
			/* -------------- Alternate keypad mode ------------- */

			pstEmuSettings->fAltKeypadMode =
				(int)(IsDlgButtonChecked(hDlg, IDC_ALT_MODE) == BST_CHECKED);

			/* -------------- Cursor type ------------- */

			pstEmuSettings->nCursorType =
				(int)(IsDlgButtonChecked(hDlg, IDC_BLOCK_CURSOR) == BST_CHECKED) ?
					EMU_CURSOR_BLOCK : EMU_CURSOR_LINE;

			/* -------------- Cursor Blink ------------- */

			pstEmuSettings->fCursorBlink =
				(int)(IsDlgButtonChecked(hDlg, IDC_BLINK_CURSOR) == BST_CHECKED);

			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuVT100_SettingsDlgProc
 *
 * DESCRIPTION:
 *	VT100 Settings dialog proc.
 *
 * ARGUMENTS:
 *	Standard window proc parameters.
 *
 * RETURNS:
 *	Standerd return value.
 *
 */
INT_PTR CALLBACK emuVT100_SettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	int			nIndex;
	PSTEMUSET	pstEmuSettings;
	static 		DWORD aHlpTable[] = {IDC_KEYPAD_MODE,	   IDH_TERM_EMUSET_KEYPADMODE,
									 IDC_CURSOR_MODE,	   IDH_TERM_EMUSET_CURSORMODE,
									 IDC_132_COLUMN,	   IDH_TERM_EMUSET_132COLUMNS,
									 IDC_GR_TERMINAL_MODES,IDH_TERM_EMUSET_MODES,
									 #if DEADWOOD
									 IDC_CHARACTER_SET,	   IDH_TERM_EMUSET_CHARSETS,
									 IDC_TF_CHARACTER_SET, IDH_TERM_EMUSET_CHARSETS,
									 #endif // DEADWOOD
									 IDC_BLOCK_CURSOR,	   IDH_TERM_EMUSET_CURSOR,
									 IDC_UNDERLINE_CURSOR, IDH_TERM_EMUSET_CURSOR,
									 IDC_BLINK_CURSOR,	   IDH_TERM_EMUSET_CURSOR,
									 IDC_GR_CURSOR, 	   IDH_TERM_EMUSET_CURSOR,
									 #if defined(INCL_TERMINAL_SIZE_AND_COLORS)
									 IDC_GR_SCREEN,			IDH_TERM_EMUSET_ROWSANDCOLS,	
									 IDC_TF_ROWS,			IDH_TERM_EMUSET_ROWSANDCOLS,	
									 IDC_NUMBER_OF_ROWS,	IDH_TERM_EMUSET_ROWSANDCOLS,
									 IDC_TF_COLUMNS,		IDH_TERM_EMUSET_ROWSANDCOLS,
									 IDC_NUMBER_OF_COLS,	IDH_TERM_EMUSET_ROWSANDCOLS,
									 #endif // defined(INCL_TERMINAL_SIZE_AND_COLORS)
									 IDC_USE_8_BIT_CODES,		IDH_TERM_EMUSET_8BITCODES,			
									 IDC_ALLOW_USERDEFINED_KEYS,IDH_TERM_EMUSET_USERDEFKEYS,
									 IDC_PRINT_RAW,				IDH_TERM_EMUSET_PRINTRAW,
                                     IDCANCEL,                           IDH_CANCEL,
                                     IDOK,                               IDH_OK,
									 0, 					0};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pstEmuSettings = (PSTEMUSET)lPar;
		SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pstEmuSettings);
		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

		#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
		/* -------------- Screen rows and columns ------------- */

		emudlgInitRowsCols(hDlg, pstEmuSettings);
		#endif

		/* -------------- Keypad application mode ------------- */

		SendDlgItemMessage(hDlg, IDC_KEYPAD_MODE, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fKeypadAppMode, 0);

		/* -------------- Cursor keypad mode ------------- */

		SendDlgItemMessage(hDlg, IDC_CURSOR_MODE, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fCursorKeypadMode, 0);

		#if !defined(INCL_TERMINAL_SIZE_AND_COLORS)
		/* -------------- 132 Column Mode ------------- */

		SendDlgItemMessage(hDlg, IDC_132_COLUMN, BM_SETCHECK,
			(unsigned int)pstEmuSettings->f132Columns, 0);
		#endif

		#if defined(INCL_PRINT_PASSTHROUGH)
        /* -------------- Host Print Mode ------------- */

		// mpt;04-22-00 added interface to control host-controlled printing
		SendDlgItemMessage(hDlg, IDC_PRINT_RAW, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fPrintRaw, 0);
		#endif // INCL_PRINT_PASSTHROUGH

		/* -------------- Cursor characteristics ------------- */

		emudlgInitCursorSettings(hDlg, pstEmuSettings, IDC_UNDERLINE_CURSOR,
			IDC_BLOCK_CURSOR, IDC_BLINK_CURSOR);

		/* -------------- VT100 Character Sets ------------- */

		#if DEADWOOD
		emudlgInitCharSetSetting(hDlg, pstEmuSettings,
				IDT_EMU_VT100_CHAR_SETS, EMU_CHARSET_ASCII);
		#endif // DEADWOOD

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
		doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDOK:
			pstEmuSettings = (PSTEMUSET)GetWindowLongPtr(hDlg, GWLP_USERDATA);

			#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
			/* -------------- Screen rows and columns ------------- */

			emudlgGetRowColSettings(hDlg, pstEmuSettings);
			#endif
			/* -------------- Keypad Application mode ------------- */

			pstEmuSettings->fKeypadAppMode =
				(int)(IsDlgButtonChecked(hDlg, IDC_KEYPAD_MODE) == BST_CHECKED);

			/* -------------- Cursor Keypad Mode ------------- */

			pstEmuSettings->fCursorKeypadMode =
				(int)(IsDlgButtonChecked(hDlg, IDC_CURSOR_MODE) == BST_CHECKED);

			#if !defined(INCL_TERMINAL_SIZE_AND_COLORS)
			/* -------------- 132 Column Mode ------------- */

			pstEmuSettings->f132Columns =
				(int)(IsDlgButtonChecked(hDlg, IDC_132_COLUMN) == BST_CHECKED);
			#endif

			#if defined(INCL_PRINT_PASSTHROUGH)
            /* -------------- Host Print Mode ------------- */

			//mpt:04-22-00
			pstEmuSettings->fPrintRaw =
				(int)(IsDlgButtonChecked(hDlg, IDC_PRINT_RAW) == BST_CHECKED);
			#endif // INCL_PRINT_PASSTHROUGH

			/* -------------- Cursor type ------------- */

			pstEmuSettings->nCursorType =
				(int)(IsDlgButtonChecked(hDlg, IDC_BLOCK_CURSOR) == BST_CHECKED) ?
					EMU_CURSOR_BLOCK : EMU_CURSOR_LINE;

			/* -------------- Cursor Blink ------------- */

			pstEmuSettings->fCursorBlink =
				(int)(IsDlgButtonChecked(hDlg, IDC_BLINK_CURSOR) == BST_CHECKED);

			/* -------------- VT100 Character Set ------------- */

            nIndex = (int)SendDlgItemMessage(hDlg, IDC_CHARACTER_SET, CB_GETCURSEL, 0, 0);
            assert(nIndex != CB_ERR);

            //JMH 01-09-97 Get the nCharacterSet value associated with this entry
            //
            pstEmuSettings->nCharacterSet =
                (int)SendDlgItemMessage(hDlg, IDC_CHARACTER_SET, CB_GETITEMDATA,
                    (WPARAM) nIndex, (LPARAM) 0);
            assert(pstEmuSettings->nCharacterSet != CB_ERR);

			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

#if defined(INCL_VT220)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuVT220_SettingsDlgProc
 *
 * DESCRIPTION:
 *	VT220 Settings dialog proc.
 *
 * ARGUMENTS:
 *	Standard window proc parameters.
 *
 * RETURNS:
 *	Standerd return value.
 *
 */
INT_PTR CALLBACK emuVT220_SettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	PSTEMUSET	pstEmuSettings;
	int			nIndex;
	static 		DWORD aHlpTable[] = {IDC_KEYPAD_MODE,	   IDH_TERM_EMUSET_KEYPADMODE,
									 IDC_CURSOR_MODE,	   IDH_TERM_EMUSET_CURSORMODE,
									 IDC_132_COLUMN,	   IDH_TERM_EMUSET_132COLUMNS,
									 IDC_GR_TERMINAL_MODES,IDH_TERM_EMUSET_MODES,
									 #if DEADWOOD
									 IDC_CHARACTER_SET,	   IDH_TERM_EMUSET_CHARSETS,
									 IDC_TF_CHARACTER_SET, IDH_TERM_EMUSET_CHARSETS,
									 #endif // DEADWOOD
									 IDC_BLOCK_CURSOR,	   IDH_TERM_EMUSET_CURSOR,
									 IDC_UNDERLINE_CURSOR, IDH_TERM_EMUSET_CURSOR,
									 IDC_BLINK_CURSOR,	   IDH_TERM_EMUSET_CURSOR,
									 IDC_GR_CURSOR, 	   IDH_TERM_EMUSET_CURSOR,
									 #if defined(INCL_TERMINAL_SIZE_AND_COLORS)
									 IDC_GR_SCREEN,			IDH_TERM_EMUSET_ROWSANDCOLS,	
									 IDC_TF_ROWS,			IDH_TERM_EMUSET_ROWSANDCOLS,	
									 IDC_NUMBER_OF_ROWS,	IDH_TERM_EMUSET_ROWSANDCOLS,
									 IDC_TF_COLUMNS,		IDH_TERM_EMUSET_ROWSANDCOLS,
									 IDC_NUMBER_OF_COLS,	IDH_TERM_EMUSET_ROWSANDCOLS,
									 #endif // defined(INCL_TERMINAL_SIZE_AND_COLORS)
									 IDC_USE_8_BIT_CODES,		IDH_TERM_EMUSET_8BITCODES,			
									 IDC_ALLOW_USERDEFINED_KEYS,IDH_TERM_EMUSET_USERDEFKEYS,
									 IDC_PRINT_RAW,				IDH_TERM_EMUSET_PRINTRAW,
                                     IDCANCEL,                           IDH_CANCEL,
                                     IDOK,                               IDH_OK,
									 0, 					0};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pstEmuSettings = (PSTEMUSET)lPar;
		SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pstEmuSettings);
		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

		#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
		/* -------------- Screen rows and columns ------------- */

		emudlgInitRowsCols(hDlg, pstEmuSettings);
		#endif
		/* -------------- Keypad application mode ------------- */

		SendDlgItemMessage(hDlg, IDC_KEYPAD_MODE, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fKeypadAppMode, 0);

		/* -------------- Cursor keypad mode ------------- */

		SendDlgItemMessage(hDlg, IDC_CURSOR_MODE, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fCursorKeypadMode, 0);

		#if !defined(INCL_TERMINAL_SIZE_AND_COLORS)
		/* -------------- 132 Column Mode ------------- */

		SendDlgItemMessage(hDlg, IDC_132_COLUMN, BM_SETCHECK,
			(unsigned int)pstEmuSettings->f132Columns, 0);
		#endif

		#if defined(INCL_PRINT_PASSTHROUGH)
		/* -------------- Host Print Mode ------------- */

		SendDlgItemMessage(hDlg, IDC_PRINT_RAW, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fPrintRaw, 0);
		#endif // INCL_PRINT_PASSTHROUGH

		/* -------------- Cursor characteristics ------------- */

		emudlgInitCursorSettings(hDlg, pstEmuSettings, IDC_UNDERLINE_CURSOR,
			IDC_BLOCK_CURSOR, IDC_BLINK_CURSOR);

		/* -------------- 8 bit codes mode ------------- */

		SendDlgItemMessage(hDlg, IDC_USE_8_BIT_CODES, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fUse8BitCodes, 0);

		/* -------------- User defined keys ------------- */

		SendDlgItemMessage(hDlg, IDC_ALLOW_USERDEFINED_KEYS, BM_SETCHECK,
			(unsigned int)pstEmuSettings->fAllowUserKeys, 0);

		/* -------------- VT220 Character Sets ------------- */

		#if DEADWOOD
		emudlgInitCharSetSetting(hDlg, pstEmuSettings,
				IDT_EMU_VT220_CHAR_SETS, EMU_CHARSET_MULTINATIONAL);
		#endif // DEADWOOD

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
		doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDOK:
			pstEmuSettings = (PSTEMUSET)GetWindowLongPtr(hDlg, GWLP_USERDATA);

			#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
			/* -------------- Screen rows and columns ------------- */

			emudlgGetRowColSettings(hDlg, pstEmuSettings);
			#endif
			/* -------------- Keypad Application mode ------------- */

			pstEmuSettings->fKeypadAppMode =
				(int)(IsDlgButtonChecked(hDlg, IDC_KEYPAD_MODE) == BST_CHECKED);

			/* -------------- Cursor Keypad Mode ------------- */

			pstEmuSettings->fCursorKeypadMode =
				(int)(IsDlgButtonChecked(hDlg, IDC_CURSOR_MODE) == BST_CHECKED);

			#if !defined(INCL_TERMINAL_SIZE_AND_COLORS)
			/* -------------- 132 Column Mode ------------- */

			pstEmuSettings->f132Columns =
				(int)(IsDlgButtonChecked(hDlg, IDC_132_COLUMN) == BST_CHECKED);
			#endif

			#if defined(INCL_PRINT_PASSTHROUGH)
            /* -------------- Host Print Mode ------------- */

			pstEmuSettings->fPrintRaw =
				(int)(IsDlgButtonChecked(hDlg, IDC_PRINT_RAW) == BST_CHECKED);
			#endif // INCL_PRINT_PASSTHROUGH

			/* -------------- Cursor type ------------- */

			pstEmuSettings->nCursorType =
				(int)(IsDlgButtonChecked(hDlg, IDC_BLOCK_CURSOR) == BST_CHECKED) ?
					EMU_CURSOR_BLOCK : EMU_CURSOR_LINE;

			/* -------------- Cursor Blink ------------- */

			pstEmuSettings->fCursorBlink =
				(int)(IsDlgButtonChecked(hDlg, IDC_BLINK_CURSOR) == BST_CHECKED);

			/* -------------- 8 bit codes mode ------------- */

			pstEmuSettings->fUse8BitCodes =
					(int)(IsDlgButtonChecked(hDlg, IDC_USE_8_BIT_CODES) == BST_CHECKED);

			/* -------------- User defined keys ------------- */

			pstEmuSettings->fAllowUserKeys =
					(int)(IsDlgButtonChecked(hDlg, IDC_ALLOW_USERDEFINED_KEYS) == BST_CHECKED);

			/* -------------- VT220 Character Set ------------- */

            nIndex = SendDlgItemMessage(hDlg, IDC_CHARACTER_SET, CB_GETCURSEL, 0, 0);
            assert(nIndex != CB_ERR);

            //JMH 01-09-97 Get the nCharacterSet value associated with this entry
            //
            pstEmuSettings->nCharacterSet =
                SendDlgItemMessage(hDlg, IDC_CHARACTER_SET, CB_GETITEMDATA,
                    (WPARAM) nIndex, (LPARAM) 0);
            assert(pstEmuSettings->nCharacterSet != CB_ERR);

			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuMinitel_SettingsDlgProc
 *
 * DESCRIPTION:
 *	TTY Settings dialog proc.
 *
 * ARGUMENTS:
 *	Standard window proc parameters.
 *
 * RETURNS:
 *	Standerd return value.
 *
 */
INT_PTR CALLBACK emuMinitel_SettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	PSTEMUSET	pstEmuSettings;
	static 		DWORD aHlpTable[] = {IDC_DESTRUCTIVE_BKSP, IDH_TERM_EMUSET_DESTRUCTIVE,
									 IDC_BLOCK_CURSOR,	   IDH_TERM_EMUSET_CURSOR,
									 IDC_UNDERLINE_CURSOR, IDH_TERM_EMUSET_CURSOR,
									 IDC_BLINK_CURSOR,	   IDH_TERM_EMUSET_CURSOR,
									 IDC_GR_CURSOR, 	   IDH_TERM_EMUSET_CURSOR,
                                     IDCANCEL,             IDH_CANCEL,
                                     IDOK,                 IDH_OK,
									 0, 					0};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pstEmuSettings = (PSTEMUSET)lPar;
		SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pstEmuSettings);
		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

		/* -------------- Cursor characteristics ------------- */

		emudlgInitCursorSettings(hDlg, pstEmuSettings, IDC_UNDERLINE_CURSOR,
			IDC_BLOCK_CURSOR, IDC_BLINK_CURSOR);

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDOK:
			pstEmuSettings = (PSTEMUSET)GetWindowLongPtr(hDlg, GWLP_USERDATA);

			/* -------------- Cursor type ------------- */

			pstEmuSettings->nCursorType =
				(int)(IsDlgButtonChecked(hDlg, IDC_BLOCK_CURSOR) == BST_CHECKED) ?
					EMU_CURSOR_BLOCK : EMU_CURSOR_LINE;

			/* -------------- Cursor Blink ------------- */

			pstEmuSettings->fCursorBlink =
				(int)(IsDlgButtonChecked(hDlg, IDC_BLINK_CURSOR) == BST_CHECKED);

			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuViewdata_SettingsDlgProc
 *
 * DESCRIPTION:
 *	TTY Settings dialog proc.
 *
 * ARGUMENTS:
 *	Standard window proc parameters.
 *
 * RETURNS:
 *	Standerd return value.
 *
 */
INT_PTR CALLBACK emuViewdata_SettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	PSTEMUSET	pstEmuSettings;
	static 		DWORD aHlpTable[] = {IDC_DESTRUCTIVE_BKSP,  IDH_TERM_EMUSET_DESTRUCTIVE,
									 IDC_BLOCK_CURSOR,	    IDH_TERM_EMUSET_CURSOR,
									 IDC_UNDERLINE_CURSOR,  IDH_TERM_EMUSET_CURSOR,
									 IDC_BLINK_CURSOR,	    IDH_TERM_EMUSET_CURSOR,
									 IDC_GR_CURSOR, 	    IDH_TERM_EMUSET_CURSOR,
							         IDC_SEND_POUND_SYMBOL, IDH_TERM_SETTING_ENTER,
                                     IDC_HIDE_CURSOR,       IDH_TERM_SETTING_HIDE_CURSOR,
                                     IDCANCEL,              IDH_CANCEL,
                                     IDOK,                  IDH_OK,
		                             0,0};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pstEmuSettings = (PSTEMUSET)lPar;
		SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pstEmuSettings);
		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
		/* -------------- Screen rows and columns ------------- */

		emudlgInitRowsCols(hDlg, pstEmuSettings);
#endif
		/* -------------- Hide cursor ------------- */

		SendDlgItemMessage(hDlg, IDC_HIDE_CURSOR, BM_SETCHECK,
			(pstEmuSettings->nCursorType == EMU_CURSOR_NONE) ? 1 : 0,
			0);

		/* -------------- Enter key sends # ------------- */

		SendDlgItemMessage(hDlg, IDC_SEND_POUND_SYMBOL, BM_SETCHECK,
			(pstEmuSettings->fLbSymbolOnEnter == TRUE) ? 1 : 0, 0);

		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDOK:
			pstEmuSettings = (PSTEMUSET)GetWindowLongPtr(hDlg, GWLP_USERDATA);

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
			/* -------------- Screen rows and columns ------------- */

			emudlgGetRowColSettings(hDlg, pstEmuSettings);
#endif
			/* -------------- Hide cursor ------------- */

			pstEmuSettings->nCursorType =
				(int)(IsDlgButtonChecked(hDlg, IDC_HIDE_CURSOR) == BST_CHECKED) ?
					EMU_CURSOR_NONE : EMU_CURSOR_LINE;
			
			/* -------------- Enter key sends # ------------- */

			pstEmuSettings->fLbSymbolOnEnter =
				(int)(IsDlgButtonChecked(hDlg, IDC_SEND_POUND_SYMBOL) == BST_CHECKED);

			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emudlgInitCursorSettings
 *
 * DESCRIPTION:
 *	Initialize cursor settings.
 *
 * ARGUMENTS:
 * 	hDlg - dialog window.
 *	pstEmuSettings 	- pointer to the emulator settings structure.
 *
 * RETURNS:
 *	void.
 *
 */
STATIC_FUNC void emudlgInitCursorSettings(HWND  hDlg,
									      PSTEMUSET pstEmuSettings,
									      INT  ID_UNDERLINE,
									      INT  ID_BLOCK,
									      INT  ID_BLINK)
	{
	int i;

	switch (pstEmuSettings->nCursorType)
		{
	case EMU_CURSOR_LINE:   i = ID_UNDERLINE;	break;
	case EMU_CURSOR_BLOCK: 	i = ID_BLOCK;		break;
	default:				i = ID_UNDERLINE;	break;
		}

	SendDlgItemMessage(hDlg, i, BM_SETCHECK, 1, 0);

	SendDlgItemMessage(hDlg, ID_BLINK, BM_SETCHECK,
		(unsigned int)pstEmuSettings->fCursorBlink, 0);

	if (IsTerminalServicesEnabled())
		{
		EnableWindow(GetDlgItem(hDlg, ID_BLINK), FALSE);
		}

	return;
	}

#if DEADWOOD
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emudlgInitCharSetSetting
 *
 * DESCRIPTION:
 *	Initialize the character set setting.
 *
 * ARGUMENTS:
 * 	hDlg - dialog window.
 *	pstEmuSettings 	- pointer to the emulator settings structure.
 *
 * RETURNS:
 *	void.
 *
 * AUTHOR: Bob Everett - 3 Jun 98
 */
STATIC_FUNC void emudlgInitCharSetSetting(HWND  hDlg,
											PSTEMUSET pstEmuSettings,
											int nCharSetTableID,
											int nDefaultCharSetID)
	{
	BOOL	fResult = TRUE;
	DWORD	nLen;
	int     nIndex;
	BYTE   *pb, *pbSel;

	if (resLoadDataBlock(glblQueryDllHinst(), nCharSetTableID,
			(LPVOID *)&pb, &nLen))
		{
		assert(FALSE);
		}
	else
		{
		if (!emudlgFindCharSetName(hDlg, pb, pstEmuSettings->nCharacterSet,
				(LPTSTR *)&pbSel, TRUE))
			{
			// Couldn't find the current character set in the table of
			// characters sets. This happens when switching from one
			// terminal type to another that doesn't contain the char
			// set.	Use the default character set.
			pstEmuSettings->nCharacterSet = nDefaultCharSetID;
			if (!emudlgFindCharSetName(hDlg, pb, pstEmuSettings->nCharacterSet,
					(LPTSTR *)&pbSel, FALSE))
				{
				// We've got problems.
				fResult = FALSE;
				assert(FALSE);
				}
			}

		if (fResult)
			{
			//JMH 01-09-97 Now select the string corresponding to
			// nCharacterSet.
	        nIndex = (int)SendDlgItemMessage(hDlg, IDC_CHARACTER_SET,
					CB_SELECTSTRING, 0, (LPARAM)(LPTSTR)pbSel);
			assert(nIndex != CB_ERR);
			}
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emudlgFindCharSetName
 *
 * DESCRIPTION:
 *	Finds the appropriate character set settings.
 *
 * ARGUMENTS:
 *	hDlg - dialog window handle
 * 	pbCharSetTable - address of the emu's table of character sets
 *	pszCharSetName - address at which to put the char set name
 *	fTellDlg - TRUE if the dialog should be made aware of the table
 *
 * RETURNS:
 *	TRUE if successful, FALSE if not.
 *
 * AUTHOR: Bob Everett - 3 Jun 98
 */
STATIC_FUNC BOOL emudlgFindCharSetName(HWND  hDlg,
										BYTE *pbCharSetTable,
										int nCharSetID,
										LPTSTR *ppszCharSetName,
										BOOL fTellDlg)
	{
	BOOL	fRetVal = FALSE;
	int		nCnt, nLen, nEmuCount, nIndex, nCharSet;
	BYTE	*pb = pbCharSetTable;

	nEmuCount = *(RCDATA_TYPE *)pb;
	pb += sizeof(RCDATA_TYPE);

	for (nCnt = 0 ; nCnt < nEmuCount; nCnt++)
		{
		nLen = StrCharGetByteCount((LPTSTR)pb) + (int)sizeof(BYTE);

		if (fTellDlg)
			{
			nIndex = (int)SendDlgItemMessage(hDlg, IDC_CHARACTER_SET, CB_ADDSTRING, 0,
					(LPARAM)(LPTSTR)pb);
			assert(nIndex != CB_ERR);
			}

		#if FALSE	// DEADWOOD:rde 10 Mar 98
        //JMH 01-09-97 Because this list gets sorted, we have to store the
        // table index with each entry, or else the selection index we get
        // when OK is pressed won't mean much.
        //
        nIndex = SendDlgItemMessage(hDlg, IDC_CHARACTER_SET, CB_SETITEMDATA,
            (WPARAM) nIndex, (LPARAM) i);
        assert(nIndex != CB_ERR);
		#endif
		// Save the real char set id with the string. rde 10 Mar 98
		nCharSet = *((RCDATA_TYPE *)(pb + nLen));

		if (fTellDlg)
			{
			nIndex = (int)SendDlgItemMessage(hDlg, IDC_CHARACTER_SET, CB_SETITEMDATA,
					(WPARAM)nIndex, (LPARAM)nCharSet);
			assert(nIndex != CB_ERR);
			}

		// Must match the char set id to nCharacterSet, not the order in
		// which they're listed in the resource data block. rde 10 Mar 98
		//if (i == pstEmuSettings->nCharacterSet)
		if (nCharSet == nCharSetID)
            {
            //JMH 01-09-97 Store a pointer to the string corresponding to
            // nCharacterSet, so we can select the appropriate entry after
            // they've all been sorted.
            //
            *ppszCharSetName = (LPTSTR)pb;
			fRetVal = TRUE;
            }

		pb += (nLen + (int)sizeof(RCDATA_TYPE));
		}

	return fRetVal;
	}
#endif // DEADWOOD

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emudlgInitRowsCols
 *
 * DESCRIPTION:
 *  Sets up the row and column fields.
 *
 * ARGUMENTS:
 *  hDlg - edit control window.
 *	pstEmuSettings - address of emulator settings structure.
 *
 * RETURNS:
 *  void.
 *
 * AUTHOR: Bob Everett - 22 Jun 1998
 */
STATIC_FUNC void emudlgInitRowsCols(HWND hDlg, PSTEMUSET pstEmuSettings)
	{
	TCHAR		achString[20];
	TCHAR		achFormat[20];

	//
	// Since the number of columns can only be numeric and has a size
	// between MIN_EMUROWS(10) and MAX_EMUROWS(50), limit to 2 characters.
	//
	SendDlgItemMessage(hDlg, IDC_NUMBER_OF_ROWS, EM_LIMITTEXT, 2, FALSE);

	LoadString(glblQueryDllHinst(), IDS_XD_INT, achFormat,
			sizeof(achFormat) / sizeof(TCHAR));
	TCHAR_Fill(achString, TEXT('\0'), sizeof(achString) / sizeof(TCHAR));
	wsprintf(achString, achFormat, pstEmuSettings->nUserDefRows);
	SendDlgItemMessage(hDlg, IDC_NUMBER_OF_ROWS, WM_SETTEXT, 0,
			(LPARAM)(LPTSTR)achString);

	//
	// Since the number of columns can only be numeric and has a size
	// between MIN_EMUCOLS(20) and MAX_EMUCOLS(132), limit to 3 characters.
	//
	SendDlgItemMessage(hDlg, IDC_NUMBER_OF_COLS, EM_LIMITTEXT, 3, FALSE);

	LoadString(glblQueryDllHinst(), IDS_XD_INT, achFormat,
			sizeof(achFormat) / sizeof(TCHAR));
	TCHAR_Fill(achString, TEXT('\0'), sizeof(achString) / sizeof(TCHAR));
	wsprintf(achString, achFormat, pstEmuSettings->nUserDefCols);
	SendDlgItemMessage(hDlg, IDC_NUMBER_OF_COLS, WM_SETTEXT, 0,
			(LPARAM)(LPTSTR)achString);

	// Put the spin buttons on the row and column fields.
	emudlgCreateUpDownControl(hDlg, pstEmuSettings);
	}
#endif

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emudlgCreateUpDownControl
 *
 * DESCRIPTION:
 *  Gets the final row and column settings.
 *
 * ARGUMENTS:
 *  hDlg - edit control window.
 *	pstEmuSettings - address of emulator settings structure.
 *
 * RETURNS:
 *  void.
 *
 * AUTHOR: Bob Everett - 22 Jun 1998
 */
STATIC_FUNC void emudlgGetRowColSettings(HWND hDlg, PSTEMUSET pstEmuSettings)
	{
	pstEmuSettings->nUserDefRows = emudlgValidateEntryFieldSetting(hDlg,
			IDC_NUMBER_OF_ROWS, MIN_EMUROWS, MAX_EMUROWS);

	pstEmuSettings->nUserDefCols = emudlgValidateEntryFieldSetting(hDlg,
			IDC_NUMBER_OF_COLS, MIN_EMUCOLS, MAX_EMUCOLS);

	pstEmuSettings->f132Columns =
			(pstEmuSettings->nUserDefCols == 132 ? TRUE : FALSE);
	}
#endif

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emudlgCreateUpDownControl
 *
 * DESCRIPTION:
 *  This function puts an up-down control on the edit field for the row and
 *	column fields. This gives us bounds checking for free... just set the
 *	appropriate parameters in the CreateUpDownControl call.
 *
 *	NOTE: This is a duplicate of CreateUpDownControl
 *
 * ARGUMENTS:
 *  hDlg - edit control window.
 *
 * RETURNS:
 *  void.
 *
 * AUTHOR: Bob Everett - 8 Jun 1998
 */
STATIC_FUNC void emudlgCreateUpDownControl(HWND hDlg, PSTEMUSET pstEmuSettings)
	{
	RECT	rc;
	int		nHeight, nWidth;
	DWORD	dwFlags;
	HWND	hwndChild;

    // Draw a spin control for the rows field.
    GetClientRect(GetDlgItem(hDlg, IDC_NUMBER_OF_ROWS), &rc);
	nHeight = rc.top - rc.bottom;
	nWidth = (nHeight / 3) * 2;

	dwFlags = WS_CHILD       | WS_VISIBLE |
			  UDS_ALIGNRIGHT | UDS_ARROWKEYS | UDS_SETBUDDYINT;

	hwndChild = CreateUpDownControl(
					dwFlags,			// create window flags
					rc.right,			// left edge
					rc.top,				// top edge
					nWidth,				// width
					nHeight,			// height
					hDlg,				// parent window
					IDC_EDIT_ROWS,
					(HINSTANCE)GetWindowLongPtr(hDlg, GWLP_HINSTANCE),
					GetDlgItem(hDlg, IDC_NUMBER_OF_ROWS),
					MAX_EMUROWS,
					MIN_EMUROWS,
					pstEmuSettings->nUserDefRows);

    // Repeat for the columns field.
    GetClientRect(GetDlgItem(hDlg, IDC_NUMBER_OF_COLS), &rc);
	nHeight = rc.top - rc.bottom;
	nWidth = (nHeight / 3) * 2;

	hwndChild = CreateUpDownControl(
					dwFlags,			// create window flags
					rc.right,			// left edge
					rc.top,				// top edge
					nWidth,				// width
					nHeight,			// height
					hDlg,				// parent window
					IDC_EDIT_COLUMNS,
					(HINSTANCE)GetWindowLongPtr(hDlg, GWLP_HINSTANCE),
					GetDlgItem(hDlg, IDC_NUMBER_OF_COLS),
					MAX_EMUCOLS,
					MIN_EMUCOLS,
					pstEmuSettings->nUserDefCols);    			

    assert(hwndChild);
	}
#endif

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emudlgValidateEntryFieldSetting
 *
 * DESCRIPTION:
 *  If the user entered a value outside of the range we support force the
 *	value into the range.
 *
 *	Note: copied from propValidateBackscrlSize.
 *
 * ARGUMENTS:
 *  hDlg - dialog window handle.
 *
 * RETURNS:
 *  nNewValue - number of lines to keep in the backscrol buffer.
 *
 * AUTHOR: Bob Everett - 8 Jun 1998
 */
STATIC_FUNC int emudlgValidateEntryFieldSetting(HWND hDlg,
										int nIDC,
										int nMinVal,
										int nMaxVal)
	{
	int		nValue = 0, nNewValue = 0;
	TCHAR	achStrEntered[20], achFormat[20];

	TCHAR_Fill(achStrEntered, TEXT('\0'),
		       sizeof(achStrEntered) / sizeof(TCHAR));
	GetDlgItemText(hDlg, nIDC, achStrEntered,
		           sizeof(achStrEntered) / sizeof(TCHAR));

	nNewValue = nValue = atoi(achStrEntered);
	if (nValue > nMaxVal)
		nNewValue = nMaxVal;
	else if (nValue < nMinVal)
		nNewValue = nMinVal;

	if (nNewValue != nValue)
		{
		LoadString(glblQueryDllHinst(),
					IDS_XD_INT,
					achFormat,
					sizeof(achFormat) / sizeof(TCHAR));
		TCHAR_Fill(achStrEntered,
					TEXT('\0'),
					sizeof(achStrEntered) / sizeof(TCHAR));
		wsprintf(achStrEntered, achFormat, nNewValue);
		SendDlgItemMessage(hDlg,
					nIDC,
					WM_SETTEXT,
					0,
					(LPARAM)(LPTSTR)achStrEntered);
		}

	return (nNewValue);
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\autoinit.c ===
/*	File: D:\WACKER\emu\autoinit.c (Created: 28-Feb-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\cloop.h>
#include <tdll\assert.h>
#include <tdll\mc.h>
#include <tdll\backscrl.h>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"
#include "ansi.hh"
#include "viewdata.hh"
#include "minitel.hh"
#include "keytbls.h"


static void emuAutoNothingVT52(const HHEMU hhEmu);
static void emuAutoVT52toAnsi(const HHEMU hhEmu);
static void emuAutoAnsiEdVT52(const HHEMU hhEmu);
static void emuAutoAnsiElVT52(const HHEMU hhEmu);
static void emuAutoCharPnVT52(const HHEMU hhEmu);
static void emuAutoNothingVT100(const HHEMU hhEmu);
static void emuAutoScs1VT100(const HHEMU hhEmu);
static void emuAutoSaveCursorVT100(const HHEMU hhEmu);
static void emuAutoAnsiPnEndVT100(const HHEMU hhEmu);
static void emuAutoResetVT100(const HHEMU hhEmu);
static void emuAutoAnsiDaVT100(const HHEMU hhEmu);
static void emuAutoReportVT100(const HHEMU hhEmu);
static void emuAutoNothingViewdata(const HHEMU hhEmu);
static void emuAutoSetAttrViewdata(const HHEMU hhEmu);
static void emuAutoNothingAnsi(const HHEMU hhEmu);
static void emuAutoScrollAnsi(const HHEMU hhEmu);
static void emuAutoSaveCurAnsi(const HHEMU hhEmu);
static void emuAutoPnAnsi(const HHEMU hhEmu);
static void emuAutoDoorwayAnsi(const HHEMU hhEmu);
static void emuAutoNothingMinitel(const HHEMU hhEmu);
static void emuAutoMinitelCharAttr(const HHEMU hhEmu);
static void emuAutoMinitelFieldAttr(const HHEMU hhEmu);
static void emuAutoMinitelCursorReport(const HHEMU hhEmu);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuAutoInit
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *	 nothing
 */
void emuAutoInit(const HHEMU hhEmu)
	{
	PSTANSIPRIVATE pstPRI;

	static struct trans_entry const astfAutoAnsiTable[] =
		{
		// State 0
		//
		// Ansi emulation occupies all of state 0 codes.
		//
		{NEW_STATE, 0, 0, 0},
#if !defined(FAR_EAST)
		{0, ETEXT('\x20'),	ETEXT('\xFF'),	emuStdGraphic}, 	// Space - All
#else
		{0, ETEXT('\x20'),	0xFFFF,			emuStdGraphic}, 	// Space - All
#endif
		{1, ETEXT('\x1B'),	ETEXT('\x1B'),	nothing},			// Esc
		{0, ETEXT('\x05'),	ETEXT('\x05'),	vt100_answerback},	// Ctrl-E
		{0, ETEXT('\x07'),	ETEXT('\x07'),	emu_bell},			// Ctrl-G
		{0, ETEXT('\x08'),	ETEXT('\x08'),	backspace}, 		// Backspace
		{0, ETEXT('\x09'),	ETEXT('\x09'),	tabn},				// Tab
		{0, ETEXT('\x0A'),	ETEXT('\x0B'),	emuLineFeed},		// NL - VT
		{0, ETEXT('\x0C'),	ETEXT('\x0C'),	AnsiFormFeed},		// Form Feed
		{0, ETEXT('\x0D'),	ETEXT('\x0D'),	carriagereturn},	// CR
		{3, ETEXT('\x18'),	ETEXT('\x18'),	EmuStdChkZmdm}, 	// Ctrl-X
		{0, ETEXT('\x00'),	ETEXT('\x1F'),	emuStdGraphic}, 	// All Ctrl's
		//
		// State 1
		// At this point, an ESC has been seen.
		//
		{NEW_STATE, 0, 0, 0},										// Esc
		{2, ETEXT('\x5B'),	ETEXT('\x5B'),	ANSI_Pn_Clr},			// [
		{0, ETEXT('\x44'),	ETEXT('\x44'),	ANSI_IND},				// D
		{0, ETEXT('\x45'),	ETEXT('\x45'),	ANSI_NEL},				// E
		{0, ETEXT('\x48'),	ETEXT('\x48'),	ANSI_HTS},				// H
		{0, ETEXT('\x4D'),	ETEXT('\x4D'),	ANSI_RI},				// M
		//
		// Autodetect sequences for for VT52, State 1.
		//
		{2, ETEXT('\x59'),	ETEXT('\x59'),	emuAutoNothingVT52},	// Y
		{0, ETEXT('\x3C'),	ETEXT('\x3C'),	emuAutoVT52toAnsi}, 	// <
		{0, ETEXT('\x4A'),	ETEXT('\x4A'),	emuAutoAnsiEdVT52}, 	// J
		{0, ETEXT('\x4B'),	ETEXT('\x4B'),	emuAutoAnsiElVT52}, 	// K
		//
		// Autodetect sequences for for VT100, State 1.
		//
#if !defined(INCL_MINITEL)
		{3, ETEXT('\x23'),	ETEXT('\x23'),	emuAutoNothingVT100},	// #
#endif
		{4, ETEXT('\x28'),	ETEXT('\x29'),	emuAutoScs1VT100},		// ( - )
		{0, ETEXT('\x38'),	ETEXT('\x38'),	emuAutoSaveCursorVT100},// 8
#if !defined(INCL_MINITEL)
		{1, ETEXT('\x3B'),	ETEXT('\x3B'),	emuAutoAnsiPnEndVT100}, // ;
#endif
		{0, ETEXT('\x63'),	ETEXT('\x63'),	emuAutoResetVT100}, 	// c
		//
		// Autodetect sequences for for Viewdata, State 1.
		//
#if defined(INCL_VIEWDATA)
		{0, ETEXT('\x31'),	ETEXT('\x34'),	emuAutoNothingViewdata},// 1 - 4
#endif
		//
		// Autodetect sequences for for Minitel, State 1.
		//
#if defined(INCL_MINITEL)
		//{1, ETEXT('\x00'),  ETEXT('\x00'),  emuAutoNothingMinitel},
		//{14,ETEXT('\x25'),  ETEXT('\x25'),  emuAutoNothingMinitel},
		//{13,ETEXT('\x35'),  ETEXT('\x37'),  emuAutoNothingMinitel},	  // eat ESC,35-37,X sequences
		//{6, ETEXT('\x39'),  ETEXT('\x39'),  emuAutoNothingMinitel},	  // PROT1, p134
		{7, ETEXT('\x3A'),	ETEXT('\x3A'),	emuAutoNothingMinitel}, 	// PROT2, p134
		{0, ETEXT('\x40'),	ETEXT('\x43'),	emuAutoMinitelCharAttr},	// forground color, flashing
		//{0, ETEXT('\x4C'),  ETEXT('\x4C'),  emuAutoMinitelCharAttr},	  // char width & height
		//{0, ETEXT('\x4E'),  ETEXT('\x4E'),  emuAutoMinitelCharAttr},	  // char width & height
		//{0, ETEXT('\x4F'),  ETEXT('\x4F'),  emuAutoMinitelCharAttr},	  // char width & height
		//{0, ETEXT('\x50'),  ETEXT('\x59'),  emuAutoMinitelFieldAttr},   // background, underlining
		//{0, ETEXT('\x5F'),  ETEXT('\x5F'),  emuAutoMinitelFieldAttr},   // reveal display
		//{0, ETEXT('\x5C'),  ETEXT('\x5D'),  emuAutoMinitelCharAttr},	  // inverse
		//{0, ETEXT('\x61'),  ETEXT('\x61'),  emuAutoMinitelCursorReport},
#endif
		//
		// State 2
		//
		{NEW_STATE, 0, 0, 0},										// Esc[
		{2, ETEXT('\x30'),	ETEXT('\x39'),	ANSI_Pn},				// 0 - 9
		{2, ETEXT('\x3B'),	ETEXT('\x3B'),	ANSI_Pn_End},			// ;
		{5, ETEXT('\x3D'),	ETEXT('\x3D'),	nothing},				// =
		{2, ETEXT('\x3A'),	ETEXT('\x3F'),	ANSI_Pn},				// : - ?
		{0, ETEXT('\x41'),	ETEXT('\x41'),	ANSI_CUU},				// A
		{0, ETEXT('\x42'),	ETEXT('\x42'),	ANSI_CUD},				// B
		{0, ETEXT('\x43'),	ETEXT('\x43'),	ANSI_CUF},				// C
		{0, ETEXT('\x44'),	ETEXT('\x44'),	ANSI_CUB},				// D
		{0, ETEXT('\x48'),	ETEXT('\x48'),	ANSI_CUP},				// H
		{0, ETEXT('\x4A'),	ETEXT('\x4A'),	ANSI_ED},				// J
		{0, ETEXT('\x4B'),	ETEXT('\x4B'),	ANSI_EL},				// K
		{0, ETEXT('\x4C'),	ETEXT('\x4C'),	ANSI_IL},				// L
		{0, ETEXT('\x4D'),	ETEXT('\x4D'),	ANSI_DL},				// M
		{0, ETEXT('\x50'),	ETEXT('\x50'),	ANSI_DCH},				// P
		{0, ETEXT('\x66'),	ETEXT('\x66'),	ANSI_CUP},				// f
		{0, ETEXT('\x67'),	ETEXT('\x67'),	ANSI_TBC},				// g
		{0, ETEXT('\x68'),	ETEXT('\x68'),	ansi_setmode},			// h
		{0, ETEXT('\x69'),	ETEXT('\x69'),	vt100PrintCommands},	// i
		{0, ETEXT('\x6C'),	ETEXT('\x6C'),	ansi_resetmode},		// l
		{0, ETEXT('\x6D'),	ETEXT('\x6D'),	ANSI_SGR},				// m
		{0, ETEXT('\x6E'),	ETEXT('\x6E'),	ANSI_DSR},				// n
		{0, ETEXT('\x70'),	ETEXT('\x70'),	emuAutoNothingAnsi},	// p
		{0, ETEXT('\x72'),	ETEXT('\x72'),	emuAutoScrollAnsi}, 	// r
		{0, ETEXT('\x73'),	ETEXT('\x73'),	emuAutoSaveCurAnsi},	// s
		{0, ETEXT('\x75'),	ETEXT('\x75'),	ansi_savecursor},		// u
		//
		//Autodetect sequences for for VT52, State 2.
		//
		{3, ETEXT('\x20'),	ETEXT('\x20'),	emuAutoCharPnVT52}, 	// Space 
		{3, ETEXT('\x22'),	ETEXT('\x22'),	emuAutoCharPnVT52}, 	// "
		{3, ETEXT('\x24'),	ETEXT('\x2F'),	emuAutoCharPnVT52}, 	// $ - /
		//
		// Autodetect sequences for for VT100, State 2.
		//
		{0, ETEXT('\x63'),	ETEXT('\x63'),	emuAutoAnsiDaVT100},	// c
		{0, ETEXT('\x71'),	ETEXT('\x71'),	emuAutoNothingVT100},	// q
		{0, ETEXT('\x78'),	ETEXT('\x78'),	emuAutoReportVT100},	// x
		//
		// State 3
		//
		{NEW_STATE, 0, 0, 0},
		{3, ETEXT('\x00'),	ETEXT('\xFF'),	EmuStdChkZmdm}, 		// All
		//
		// State 4
		//
		{NEW_STATE, 0, 0, 0},
		{4, ETEXT('\x00'),	ETEXT('\xFF'),	nothing},				// All
		//
		// State 5
		//
		{NEW_STATE, 0, 0, 0},
		{5, ETEXT('\x32'),	ETEXT('\x32'),	emuAutoPnAnsi}, 		// 2
		{5, ETEXT('\x35'),	ETEXT('\x35'),	emuAutoPnAnsi}, 		// 5
		{0, ETEXT('\x68'),	ETEXT('\x68'),	emuAutoDoorwayAnsi},	// h
		{0, ETEXT('\x6C'),	ETEXT('\x6C'),	emuAutoDoorwayAnsi},	// l
		//
		// Autodetect sequences for for VT100, State 5.
		//
		{0, ETEXT('\x70'),	ETEXT('\x70'),	emuAutoNothingVT100},	// p
		//
		// Autodetect sequences for for VT52, State 5.
		//
		{0, ETEXT('\x00'),	ETEXT('\xFF'),	EmuStdChkZmdm}, 		// All
		//
		// State 6
		//
		{NEW_STATE, 0, 0, 0},
		//
		// Autodetect sequences for for VT52, VT100, State 6.
		//
		{6, ETEXT('\x00'),	ETEXT('\xFF'),	nothing},				// All
		//
		// State 7
		//
		// Autodetect sequences for for VT100, State 7.
		//
		{NEW_STATE, 0, 0, 0},
		{7, ETEXT('\x00'),	ETEXT('\xFF'),	EmuStdChkZmdm}, 		// All
		//
		// State 8
		//
		// Autodetect sequences for for VT100, State 8.
		//
		{NEW_STATE, 0, 0, 0},
		{8, ETEXT('\x00'),	ETEXT('\xFF'),	nothing},				// All
		};

	emuInstallStateTable(hhEmu, astfAutoAnsiTable, DIM(astfAutoAnsiTable));

	// Allocate space for and initialize data that is used only by the
	// Auto ANSI emulator.
	//
	hhEmu->pvPrivate = malloc(sizeof(ANSIPRIVATE));

	if (hhEmu->pvPrivate == 0)
		{
		assert(FALSE);
		return;
		}

	pstPRI = (PSTANSIPRIVATE)hhEmu->pvPrivate;

	memset(pstPRI, 0, sizeof(ANSIPRIVATE));

	hhEmu->emuResetTerminal = emuAnsiReset;

	// The Auto Detect emulator is ANSI based.	So, do the same
	// stuff we do when initializing the ANSI emulator.
	//
	emuKeyTableLoad(hhEmu, AnsiKeyTable, 
					 sizeof(AnsiKeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl);
	emuKeyTableLoad(hhEmu, IBMPCKeyTable, 
					 sizeof(IBMPCKeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl2);

	hhEmu->emu_kbdin = ansi_kbdin;
	hhEmu->emu_deinstall = emuAnsiUnload;
	emuAnsiReset(hhEmu, FALSE);
#if !defined(FAR_EAST)
	hhEmu->emu_highchar = (ECHAR)0xFF;
#else
	hhEmu->emu_highchar = (ECHAR)0xFFFF;
#endif

	backscrlSetShowFlag(sessQueryBackscrlHdl(hhEmu->hSession), TRUE);
	return;
	}

// Ansi Auto Detect Functions.
//
void emuAutoNothingAnsi(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
	emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
	nothing(hhEmu);
	return;
	}

void emuAutoScrollAnsi(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
	emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
	vt_scrollrgn(hhEmu);
	return;
	}

void emuAutoSaveCurAnsi(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
	emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
	ansi_savecursor(hhEmu);
	return;
	}

void emuAutoPnAnsi(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
	emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
	ANSI_Pn(hhEmu);
	return;
	}

void emuAutoDoorwayAnsi(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
	emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
	DoorwayMode(hhEmu);
	return;
	}

// VT52 Auto Detect Functions.
//
void emuAutoNothingVT52(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_VT52);
	return;
	}

void emuAutoVT52toAnsi(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_VT52);
	vt52_toANSI(hhEmu);
	return;
	}

void emuAutoAnsiEdVT52(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_VT52);
	ANSI_ED(hhEmu);
	return;
	}

void emuAutoAnsiElVT52(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_VT52);
	ANSI_EL(hhEmu);
	return;
	}

void emuAutoCharPnVT52(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_VT52);
	char_pn(hhEmu);
	return;
	}

// VT100 Auto Detect Functions.
//
void emuAutoNothingVT100(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_VT100);
#else
	emuAutoDetectLoad(hhEmu, EMU_VT100J);
#endif
	return;
	}

void emuAutoScs1VT100(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_VT100);
#else
	emuAutoDetectLoad(hhEmu, EMU_VT100J);
#endif
	vt_scs1(hhEmu);
	return;
	}

void emuAutoSaveCursorVT100(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_VT100);
#else
	emuAutoDetectLoad(hhEmu, EMU_VT100J);
#endif
	vt100_savecursor(hhEmu);
	return;
	}

void emuAutoAnsiPnEndVT100(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_VT100);
#else
	emuAutoDetectLoad(hhEmu, EMU_VT100J);
#endif
	ANSI_Pn_End(hhEmu);
	return;
	}

void emuAutoResetVT100(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_VT100);
#else
	emuAutoDetectLoad(hhEmu, EMU_VT100J);
#endif
	vt100_hostreset(hhEmu);
	return;
	}

void emuAutoAnsiDaVT100(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_VT100);
#else
	emuAutoDetectLoad(hhEmu, EMU_VT100J);
#endif
	ANSI_DA(hhEmu);
	return;
	}

void emuAutoReportVT100(const HHEMU hhEmu)
	{
#if !defined(FAR_EAST)
	emuAutoDetectLoad(hhEmu, EMU_VT100);
#else
	emuAutoDetectLoad(hhEmu, EMU_VT100J);
#endif
	vt100_report(hhEmu);
	return;
	}

#if defined(INCL_VIEWDATA)
// Viewdata Auto Detect Functions.
//
void emuAutoNothingViewdata(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_VIEW);
	return;
	}

void emuAutoSetAttrViewdata(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_VIEW);
	EmuViewdataSetAttr(hhEmu);
	return;
	}
#endif // INCL_VIEWDATA

#if defined(INCL_MINITEL)

void emuAutoNothingMinitel(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_MINI);
	return;
	}

void emuAutoMinitelCharAttr(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_MINI);
	emuMinitelCharAttr(hhEmu);
	return;
	}

void emuAutoMinitelFieldAttr(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_MINI);
	emuMinitelFieldAttr(hhEmu);
	return;
	}

void emuAutoMinitelCursorReport(const HHEMU hhEmu)
	{
	emuAutoDetectLoad(hhEmu, EMU_MINI);
	minitelCursorReport(hhEmu);
	return;
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\emudlgs.h ===
/*	File: D:\WACKER\emu\emudlgs.h (Created: 14-Feb-1994)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 4 $
 *	$Date: 12/28/01 4:27p $
 */

// Function prototypes...

BOOL emuSettingsDlg(const HSESSION hSession, const HWND hwndParent,
					const int nEmuId, PSTEMUSET pstEmuSettings);
INT_PTR CALLBACK emuTTY_SettingsDlgProc	     (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK emuANSI_SettingsDlgProc	 (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK emuVT52_SettingsDlgProc	 (HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK emuVT100_SettingsDlgProc 	 (HWND, UINT, WPARAM, LPARAM);
#if defined(INCL_VT220) || defined(INCL_VT320)
INT_PTR CALLBACK emuVT220_SettingsDlgProc 	 (HWND, UINT, WPARAM, LPARAM);
#endif
INT_PTR CALLBACK emuMinitel_SettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar);
INT_PTR CALLBACK emuViewdata_SettingsDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar);

#if defined(INCL_TERMINAL_SIZE_AND_COLORS)
int emuColorSettingsDlg(const HSESSION hSession, 
						const HWND hwndParent,
						PSTEMUSET pstEmuSettings);
INT_PTR CALLBACK emuColorSettingsDlgProc(HWND hDlg, 
										UINT wMsg, 
										WPARAM wPar, 
										LPARAM lPar);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\emudec.hh ===
/*	File: \wacker\emu\emudec.hh (Created: 29-Jan-1998)
 *
 *	Copyright 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 7/20/01 5:56p $
 */

// The maximum number of user defined keys.  Used by the VT220 and VT320.
//
#define MAX_UDK_KEYS    15
#define MAX_KEY_SPACE   256

// These constants are state table states used when processing user
// defined keys for the VT220 and VT320.
//
#define KEY_NUMBER_NEXT     0
#define KEY_DIGIT2_NEXT     1
#define SLASH_NEXT          2
#define CHAR_DIGIT1_NEXT    3
#define CHAR_DIGIT2_NEXT    4
#define ESC_SEEN            5

// The following key data structures are used only for user-defined
// keys in HTPE. But in shared code, they completely replace all 
// key data structures. In shared code, these definitios are in 
// \shared\emulator\emu.hh

// Key table structure definitions.  These are conditionally defined
// so the debug version of the program can supply additional information
// for testing.  In the debug version, when the user
// presses the F1 key, we can output the name of the key "HVK_F1" and
// the sequence that is assigned to that key.  The KEYDEF macro defined
// below is used in the initialization of the emulator key tables, found
// in each emulator's initialize function.  See John Masters for more
// details.
//
#if defined(_DEBUG)

typedef struct
    {
    KEYDEF Key;
    TCHAR * pSequence;
    unsigned int iSequenceLen;
    TCHAR * pszKeyName;
    } STEMUKEYDATA;

    #define EMUKEY(K, V, C, A, S, E, SEQ, L) \
        { K | (V ? VIRTUAL_KEY : 0) | (C ? CTRL_KEY : 0) | \
        (A ? ALT_KEY : 0) | (S ? SHIFT_KEY : 0) | (E ? EXTENDED_KEY : 0), \
        { TEXT(SEQ) }, {L}, {#K} }
//{ {K, V, C, A, S, E}, { TEXT(SEQ) }, {L}, {#K} }

#else

typedef struct
    {
    KEYDEF Key;
    TCHAR * pSequence;
    unsigned int iSequenceLen;
    } STEMUKEYDATA;

    #define EMUKEY(K, V, C, A, S, E, SEQ, L) \
        { K | (V ? VIRTUAL_KEY : 0) | (C ? CTRL_KEY : 0) | \
        (A ? ALT_KEY : 0) | (S ? SHIFT_KEY : 0) | (E ? EXTENDED_KEY : 0), \
        { TEXT(SEQ) }, {L} }
//{ {K, V, C, A, S, E}, { TEXT(SEQ) }, {L} }

#endif

typedef STEMUKEYDATA const * PSTCEMUKEYDATA;
typedef STEMUKEYDATA * PSTEMUKEYDATA;

// Private emulator data for DEC Terminals.
//
typedef struct stPrivateDEC
	{
	int sv_row,
		sv_col,
		sv_state,
		sv_AWM,
		sv_DECOM,
		sv_protectmode,
		fAttrsSaved,
		len_s,
		len_t,
		nState,
		gn,
		old_gl,
		gl,
		gr,
		sv_gr,
		sv_gl,
		fDecColHold,
		*aiLineAttr;

	ECHAR	storage[40],
			vt_charset[4],
			vt_sv_charset[4],
			terminate[4],
			*pntr;

	STATTR sv_attr;

#if defined(INCL_VT220)
    PSTCEMUKEYDATA  pstcEmuKeyTbl1,
                    pstcEmuKeyTbl2,
                    pstcEmuKeyTbl3,
                    pstcEmuKeyTbl4,
                    pstcEmuKeyTbl5,
                    pstcEmuKeyTbl6;

    int             iKeyTable1Entries,
                    iKeyTable2Entries,
                    iKeyTable3Entries,
                    iKeyTable4Entries,
                    iKeyTable5Entries,
                    iKeyTable6Entries;

	// A pointer to a table of user defined keys,
	//
	PSTEMUKEYDATA  pstUDK;

	int     iUDKTableEntries;

	// This variable is a state variable used in the processing of
	// user defined keys in the VT220 and VT320.
	//
	int     iUDKState,
			iUDKTableIndex,
			iUDKSequenceLen;

	// A flag that is used identify the locked or unlocked status
	// of the UDK's, after they are defined.  See emuDecClearUDK.
	//
	int     fUnlockedUDK;

	// A temporary buffer to collect the user defined key sequence as
	// it is being processed.
	//
	TCHAR   acUDKSequence[MAX_KEY_SPACE];

	TCHAR   chUDKAssignment;

	TCHAR   const *pacUDKSelectors;
#endif
#if defined(INCL_VTUTF8)
	ECHAR	echUTF8CodeInProgress;
#endif
	} DECPRIVATE;

typedef DECPRIVATE *PSTDECPRIVATE;

// From vt220ini.c
void vt220_init(const HHEMU hhEmu);

// From vt220.c
void    vt220_DA(const HHEMU hhEmu);
void    vt220_hostreset(const HHEMU hhEmu);
void    vt100_printcmnds(const HHEMU hhEmu);
void    emuDecClearUDK(const HHEMU hhEmu);
void    vt220_softreset(const HHEMU hhEmu);
void    vt220_2ndDA(const HHEMU hhEmu);
void    vt220_definekey(const HHEMU hhEmu);
void    vt220_level(const HHEMU hhEmu);
void    vt220_protmode(const HHEMU hhEmu);
int     vt220_reset(const HHEMU hhEmu, const int host_request);
void    vt220mode_reset(const HHEMU hhEmu);
void    vt220_savekeys(const HHEMU hhEmu, const int iSave);
void    emuDecSendKeyString(const HHEMU hhEmu,
                        const int iIndex,
                        PSTCEMUKEYDATA pstcKeyTbl,
                        const int iMaxEntries);

void    emuDecDefineUDK(const HHEMU hhEmu);
int     emuDecStoreUDK(const HHEMU hhEmu);
int		emuDecKeyboardIn(const HHEMU hhEmu, int Key, 
				const int fTest);
int		emuDecKbdKeyLookup(const HHEMU hhEmu,
                const KEYDEF Key, PSTCEMUKEYDATA pstKeyTbl,
                const int iMaxEntries);
void	emuDecSendKeyString(const HHEMU hhEmu, const int iIndex,
                PSTCEMUKEYDATA pstcKeyTbl, const int iMaxEntries);
void	emuVT220SendKeyString(const HHEMU hhEmu,
                const int iIndex, PSTCEMUKEYDATA pstcKeyTbl,
                const int iMaxEntries);
void	emuDecEL(const HHEMU hhEmu);
void	emuDecClearLine(const HHEMU hhEmu, const int iClearSelect);
void	emuVT220ED(const HHEMU hhEmu);
void	emuDecEraseScreen(const HHEMU hhEmu, const int iClearSelect);
void	emuDecClearImageRowSelective(const HHEMU hhEmu, const int iImageRow);
void	emuDecUnload(const HHEMU hhEmu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\emuid.h ===
/*	File: D:\WACKER\emu\emuid.h (Created: 08-Dec-1993)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 4/30/02 4:03p $
 */

#define IDT_BASE 0xD00 // = 3328 in decimal

// Table identifiers should be prefixed with "IDT" meaning ID Table.
// Interestingly, the RC compiler won't do integer math on RCDATA
// indentifiers so I have to hard code the numbers.  Actually, its
// worse than that, it can't even read 0x000 format numbers!  They
// have to be decimal.

//#define IDT_EMU_NAMES 			  3328

#define IDT_EMU_VT100_CHAR_SETS 	3383
#define IDT_EMU_NAT_CHAR_SETS		3384

#define IDT_ANSI_KEYS				3385

#define IDT_VT_MAP_PF_KEYS			3386

#define IDT_VT52_KEYS				3387
#define IDT_VT52_KEYPAD_APP_MODE	3388

#define IDT_VT100_KEYS				3389
#define IDT_VT100_CURSOR_KEY_MODE	3390
#define IDT_VT100_KEYPAD_APP_MODE	3391

#define IDT_VT220_KEYS				3392
#define IDT_VT220_CURSOR_KEY_MODE	3393
#define IDT_VT220_KEYPAD_APP_MODE	3394
#define IDT_VT220_MAP_PF_KEYS_MODE	3395

#define IDT_TV950_KEYS				3396
#define IDT_TV950_FKEYS 			3397
#define IDT_WANG_KEYS				3398
#define IDT_IBM3278_KEYS			3399
#define IDT_RENX3278_KEYS			3400
#define IDT_IBM3101_KEYS			3401
#define IDT_IBMPC_KEYS				3402

#define IDT_MINITEL_KEYS			3403

#define IDT_EMU_VT220_CHAR_SETS 	3404
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\emuhdl.c ===
/*	File: D:\WACKER\emu\emuhdl.c (Created: 10-Dec-1993)
 *
 *	Copyright 1994-2001 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 22 $
 *	$Date: 7/08/02 6:33p $
 */

#include <windows.h>
#pragma hdrstop
// #define DEBUGSTR

#include <time.h>
#include <tapi.h>

#include <tdll\stdtyp.h>
#include <tdll\mc.h>
#include <tdll\assert.h>
#include <tdll\sf.h>
#include <tdll\sess_ids.h>
#include <tdll\session.h>
#include <tdll\capture.h>
#include <tdll\cloop.h>
#include <tdll\term.h>
#include <tdll\print.h>
#include <tdll\update.h>
#include <tdll\load_res.h>
#include <tdll\globals.h>
#include <tdll\statusbr.h>
#include <tdll\cnct.h>
#include <tdll\cnct.hh>
#include <tdll\htchar.h>
#include <tdll\com.h>
#include <tdll\errorbox.h>      // TimedMessageBox()
#include <cncttapi\cncttapi.hh> // cncttapiSetLineConfig()
#include <term\res.h>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"
#include "viewdata.hh"
#include "minitel.hh"
#include "emudec.hh"
#include "keytbls.h"

// Function prototypes...
//
STATIC_FUNC int emuLoadSettings(const HHEMU hhEmu, 
								const unsigned int uiId,
								unsigned long ulDataSize,
								void *pvData);
STATIC_FUNC void emuCheckSettings(struct stEmuBaseSFSettings *pstBaseSettings);

// Keytable declarations
//
const KEYTBLSTORAGE AnsiKeyTable[MAX_ANSI_KEYS] =
    {
	{VK_UP		| VIRTUAL_KEY,	{"\x1B[A\xff"}},
	{VK_DOWN 	| VIRTUAL_KEY,	{"\x1B[B\xff"}},
	{VK_RIGHT	| VIRTUAL_KEY,	{"\x1B[C\xff"}},
	{VK_LEFT 	| VIRTUAL_KEY,	{"\x1B[D\xff"}},

	// Added 27 Aug 98 rde
    {VK_HOME    | VIRTUAL_KEY,	{"\x1B[H\xff"}},
    {VK_END     | VIRTUAL_KEY,	{"\x1B[K\xff"}},

	//VK_UP 	  | VIRTUAL_KEY | CTRL_KEY,  "\x1BOx\xff",
	//VK_DOWN	  | VIRTUAL_KEY | CTRL_KEY,  "\x1BOr\xff",
	//VK_RIGHT	  | VIRTUAL_KEY | CTRL_KEY,  "\x1BOv\xff",
	//VK_LEFT	  | VIRTUAL_KEY | CTRL_KEY,  "\x1BOt\xff",

	//VK_HOME	  | VIRTUAL_KEY,  "\x1B[H\xff",
	//VK_END	  | VIRTUAL_KEY,  "\x1B[K\xff",

	//VK_HOME	  | VIRTUAL_KEY | CTRL_KEY,  "\x1BOw\xff",
	//VK_END	  | VIRTUAL_KEY | CTRL_KEY,  "\x1BOq\xff",

	//VK_PRIOR	  | VIRTUAL_KEY,  "\x1B[M\xff",
	//VK_NEXT	  | VIRTUAL_KEY,  "\x1B[H\x1B[2J\xff",

	//VK_PRIOR	  | VIRTUAL_KEY | CTRL_KEY,  "\x1BOy\xff",
	//VK_NEXT	  | VIRTUAL_KEY | CTRL_KEY,  "\x1BOs\xff",

	//VK_RETURN   | VIRTUAL_KEY,  "\x0D\xff",
	//VK_RETURN   | VIRTUAL_KEY | CTRL_KEY,  "\x1BOM\xff",

	//VK_INSERT   | VIRTUAL_KEY | CTRL_KEY,  "\x1BOp\xff",

	/* -------------- Function keys ------------- */

	{VK_F1		| VIRTUAL_KEY,	{"\x1BOP\xff"}},
	{VK_F2		| VIRTUAL_KEY,	{"\x1BOQ\xff"}},
	{VK_F3		| VIRTUAL_KEY,	{"\x1BOR\xff"}},
	{VK_F4		| VIRTUAL_KEY,	{"\x1BOS\xff"}},

	/* -------------- Gray keys, (extended edit pad) ------------- */

	{VK_UP		| VIRTUAL_KEY | EXTENDED_KEY,  {"\x1B[A\xff"}},
	{VK_DOWN 	| VIRTUAL_KEY | EXTENDED_KEY,  {"\x1B[B\xff"}},
	{VK_RIGHT	| VIRTUAL_KEY | EXTENDED_KEY,  {"\x1B[C\xff"}},
	{VK_LEFT 	| VIRTUAL_KEY | EXTENDED_KEY,  {"\x1B[D\xff"}},

	// Added 27 Aug 98 rde
	{VK_HOME 	| VIRTUAL_KEY | EXTENDED_KEY,  {"\x1B[H\xff"}},
	{VK_END 	| VIRTUAL_KEY | EXTENDED_KEY,  {"\x1B[K\xff"}},

	//VK_HOME	  | VIRTUAL_KEY | EXTENDED_KEY,  "\x1B[H\xff",
	//VK_END	  | VIRTUAL_KEY | EXTENDED_KEY,  "\x1B[K\xff",

	//VK_PRIOR	  | VIRTUAL_KEY | EXTENDED_KEY,  "\x1B[M\xff",
	//VK_NEXT	  | VIRTUAL_KEY | EXTENDED_KEY,  "\x1B[H\x1B[2J\xff",

	{VK_TAB		| VIRTUAL_KEY | SHIFT_KEY,{"\x1B\x5B\x5A\xff"}},  /* KT_SHIFT + KN_TAB */


    };

/* Also for ANSI emulator */
const KEYTBLSTORAGE IBMPCKeyTable[MAX_IBMPC_KEYS] =
	{
	{VK_BACK,				   {"\x08\xff"}},		/* KN_BS */
	{VK_DELETE	| VIRTUAL_KEY, {"\x00\x53\xff"}},	/* KN_DEL */
	{VK_DOWN 	| VIRTUAL_KEY, {"\x00\x50\xff"}},	/* KN_DOWN */
	{VK_END		| VIRTUAL_KEY, {"\x00\x4F\xff"}},	/* KN_END */
	{VK_RETURN,				   {"\x0D\xff"}},		/* KN_ENTER */
	{VK_ESCAPE,				   {"\x1B\xff"}},		/* KN_ESC */
	{VK_F1		| VIRTUAL_KEY, {"\x00\x3B\xff"}},	/* KN_F1 */
	{VK_F2		| VIRTUAL_KEY, {"\x00\x3C\xff"}},	/* KN_F2 */
	{VK_F3		| VIRTUAL_KEY, {"\x00\x3D\xff"}},	/* KN_F3 */
	{VK_F4		| VIRTUAL_KEY, {"\x00\x3E\xff"}},	/* KN_F4 */
	{VK_F5		| VIRTUAL_KEY, {"\x00\x3F\xff"}},	/* KN_F5 */
	{VK_F6		| VIRTUAL_KEY, {"\x00\x40\xff"}},	/* KN_F6 */
	{VK_F7		| VIRTUAL_KEY, {"\x00\x41\xff"}},	/* KN_F7 */
	{VK_F8		| VIRTUAL_KEY, {"\x00\x42\xff"}},	/* KN_F8 */
	{VK_F9		| VIRTUAL_KEY, {"\x00\x43\xff"}},	/* KN_F9 */
	{VK_F10		| VIRTUAL_KEY, {"\x00\x44\xff"}},	/* KN_F10 */
	{VK_F11		| VIRTUAL_KEY, {"\x00\x85\xff"}},	/* KN_F11 */
	{VK_F12		| VIRTUAL_KEY, {"\x00\x86\xff"}},	/* KN_F12 */
	{VK_HOME 	| VIRTUAL_KEY, {"\x00\x47\xff"}},	/* KN_HOME */
	{VK_INSERT	| VIRTUAL_KEY, {"\x00\x52\xff"}},	/* KN_INS */
	{VK_LEFT 	| VIRTUAL_KEY, {"\x00\x4B\xff"}},	/* KN_LEFT */
	{VK_NEXT 	| VIRTUAL_KEY, {"\x00\x51\xff"}},	/* KN_PGDN */
	{VK_PRIOR	| VIRTUAL_KEY, {"\x00\x49\xff"}},	/* KN_PGUP */
	{VK_RIGHT	| VIRTUAL_KEY, {"\x00\x4D\xff"}},	/* KN_RIGHT */
	{VK_TAB, 				   {"\x09\xff"}},		/* KN_TAB */
	{VK_UP		| VIRTUAL_KEY, {"\x00\x48\xff"}},	/* KN_UP */

	{VK_BACK 	| VIRTUAL_KEY | CTRL_KEY, {"\x7F\xff"}},	   /* KT_CTRL + KN_BS */
	{VK_DELETE	| VIRTUAL_KEY | CTRL_KEY, {"\x00\x93\xff"}},  /* KT_CTRL + KN_DEL */
	{VK_DOWN 	| VIRTUAL_KEY | CTRL_KEY, {"\x00\x91\xff"}},  /* KT_CTRL + KN_DOWN */
	{VK_END		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x75\xff"}},  /* KT_CTRL + KN_END */
	{VK_RETURN	| VIRTUAL_KEY | CTRL_KEY, {"\x0A\xff"}},	   /* KT_CTRL + KN_ENTER */

	{VK_F1		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x5E\xff"}},  /* KT_CTRL + KN_F1 */
	{VK_F10		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x67\xff"}},  /* KT_CTRL + KN_F10 */
	{VK_F11		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x89\xff"}},  /* KT_CTRL + KN_F11 */
	{VK_F12		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x8A\xff"}},  /* KT_CTRL + KN_F12 */
	{VK_F2		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x5F\xff"}},  /* KT_CTRL + KN_F2 */
	{VK_F3		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x60\xff"}},  /* KT_CTRL + KN_F3 */
	{VK_F4		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x61\xff"}},  /* KT_CTRL + KN_F4 */
	{VK_F5		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x62\xff"}},  /* KT_CTRL + KN_F5 */
	{VK_F6		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x63\xff"}},  /* KT_CTRL + KN_F6 */
	{VK_F7		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x64\xff"}},  /* KT_CTRL + KN_F7 */
	{VK_F8		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x65\xff"}},  /* KT_CTRL + KN_F8 */
	{VK_F9		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x66\xff"}},  /* KT_CTRL + KN_F9 */
	{VK_HOME 	| VIRTUAL_KEY | CTRL_KEY, {"\x00\x77\xff"}},  /* KT_CTRL + KN_HOME */
	{VK_INSERT	| VIRTUAL_KEY | CTRL_KEY, {"\x00\x92\xff"}},  /* KT_CTRL + KN_INS */
	{VK_LEFT 	| VIRTUAL_KEY | CTRL_KEY, {"\x00\x73\xff"}},  /* KT_CTRL + KN_LEFT */
	{VK_F1		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x8F\xff"}},  /* KT_CTRL + KN_MID */
	{VK_PRIOR	| VIRTUAL_KEY | CTRL_KEY, {"\x00\x76\xff"}},  /* KT_CTRL + KN_PGDN */
	{VK_NEXT 	| VIRTUAL_KEY | CTRL_KEY, {"\x00\x84\xff"}},  /* KT_CTRL + KN_PGUP */
	{VK_PRINT	| VIRTUAL_KEY | CTRL_KEY, {"\x00\x72\xff"}},  /* KT_CTRL + KN_PRTSC */
	{VK_RIGHT	| VIRTUAL_KEY | CTRL_KEY, {"\x00\x74\xff"}},  /* KT_CTRL + KN_RIGHT */
	{VK_TAB		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x94\xff"}},  /* KT_CTRL + KN_TAB */
	{VK_UP		| VIRTUAL_KEY | CTRL_KEY, {"\x00\x8D\xff"}},  /* KT_CTRL + KN_UP */
														 
	{VK_F1		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x54\xff"}},  /* KT_SHIFT + KN_F1 */
	{VK_F10		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x5D\xff"}},  /* KT_SHIFT + KN_F10 */
	{VK_F11		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x87\xff"}},  /* KT_SHIFT + KN_F11 */
	{VK_F12		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x88\xff"}},  /* KT_SHIFT + KN_F12 */
	{VK_F2		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x55\xff"}},  /* KT_SHIFT + KN_F2 */
	{VK_F3		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x56\xff"}},  /* KT_SHIFT + KN_F3 */
	{VK_F4		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x57\xff"}},  /* KT_SHIFT + KN_F4 */
	{VK_F5		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x58\xff"}},  /* KT_SHIFT + KN_F5 */
	{VK_F6		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x59\xff"}},  /* KT_SHIFT + KN_F6 */
	{VK_F7		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x5A\xff"}},  /* KT_SHIFT + KN_F7 */
	{VK_F8		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x5B\xff"}},  /* KT_SHIFT + KN_F8 */
	{VK_F9		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x5C\xff"}},  /* KT_SHIFT + KN_F9 */
	{VK_TAB		| VIRTUAL_KEY | SHIFT_KEY,{"\x00\x0F\xff"}},  /* KT_SHIFT + KN_TAB */

	{0x5C | ALT_KEY | VIRTUAL_KEY, {"\x00\x28\xff"}},  /* KT_ALT + '\'' */
	{0x2C | ALT_KEY | VIRTUAL_KEY, {"\x00\x33\xff"}},  /* KT_ALT + ',' */
	{0x2D | ALT_KEY | VIRTUAL_KEY, {"\x00\x82\xff"}},  /* KT_ALT + '-' */
	{0x2E | ALT_KEY | VIRTUAL_KEY, {"\x00\x34\xff"}},  /* KT_ALT + '.' */
	{0x2F | ALT_KEY | VIRTUAL_KEY, {"\x00\x35\xff"}},  /* KT_ALT + '/' */
	{0x30 | ALT_KEY | VIRTUAL_KEY, {"\x00\x81\xff"}},  /* KT_ALT + '0' */
	{0x31 | ALT_KEY | VIRTUAL_KEY, {"\x00\x78\xff"}},  /* KT_ALT + '1' */
	{0x32 | ALT_KEY | VIRTUAL_KEY, {"\x00\x79\xff"}},  /* KT_ALT + '2' */
	{0x33 | ALT_KEY | VIRTUAL_KEY, {"\x00\x7A\xff"}},  /* KT_ALT + '3' */
	{0x34 | ALT_KEY | VIRTUAL_KEY, {"\x00\x7B\xff"}},  /* KT_ALT + '4' */
	{0x35 | ALT_KEY | VIRTUAL_KEY, {"\x00\x7C\xff"}},  /* KT_ALT + '5' */
	{0x36 | ALT_KEY | VIRTUAL_KEY, {"\x00\x7D\xff"}},  /* KT_ALT + '6' */
	{0x37 | ALT_KEY | VIRTUAL_KEY, {"\x00\x7E\xff"}},  /* KT_ALT + '7' */
	{0x38 | ALT_KEY | VIRTUAL_KEY, {"\x00\x7F\xff"}},  /* KT_ALT + '8' */
	{0x39 | ALT_KEY | VIRTUAL_KEY, {"\x00\x80\xff"}},  /* KT_ALT + '9' */
	{0x3B | ALT_KEY | VIRTUAL_KEY, {"\x00\x27\xff"}},  /* KT_ALT + ';' */
	{0x3D | ALT_KEY | VIRTUAL_KEY, {"\x00\x83\xff"}},  /* KT_ALT + '=' */
	{0x41 | ALT_KEY | VIRTUAL_KEY, {"\x00\x1E\xff"}},  /* KT_ALT + 'A' */
	{0x42 | ALT_KEY | VIRTUAL_KEY, {"\x00\x30\xff"}},  /* KT_ALT + 'B' */
	{0x43 | ALT_KEY | VIRTUAL_KEY, {"\x00\x2E\xff"}},  /* KT_ALT + 'C' */
	{0x44 | ALT_KEY | VIRTUAL_KEY, {"\x00\x20\xff"}},  /* KT_ALT + 'D' */
	{0x45 | ALT_KEY | VIRTUAL_KEY, {"\x00\x12\xff"}},  /* KT_ALT + 'E' */
	{0x46 | ALT_KEY | VIRTUAL_KEY, {"\x00\x21\xff"}},  /* KT_ALT + 'F' */
	{0x47 | ALT_KEY | VIRTUAL_KEY, {"\x00\x22\xff"}},  /* KT_ALT + 'G' */
	{0x48 | ALT_KEY | VIRTUAL_KEY, {"\x00\x23\xff"}},  /* KT_ALT + 'H' */
	{0x49 | ALT_KEY | VIRTUAL_KEY, {"\x00\x17\xff"}},  /* KT_ALT + 'I' */
	{0x4A | ALT_KEY | VIRTUAL_KEY, {"\x00\x24\xff"}},  /* KT_ALT + 'J' */
	{0x4B | ALT_KEY | VIRTUAL_KEY, {"\x00\x25\xff"}},  /* KT_ALT + 'K' */
	{0x4C | ALT_KEY | VIRTUAL_KEY, {"\x00\x26\xff"}},  /* KT_ALT + 'L' */
	{0x4D | ALT_KEY | VIRTUAL_KEY, {"\x00\x32\xff"}},  /* KT_ALT + 'M' */
	{0x4E | ALT_KEY | VIRTUAL_KEY, {"\x00\x31\xff"}},  /* KT_ALT + 'N' */
	{0x4F | ALT_KEY | VIRTUAL_KEY, {"\x00\x18\xff"}},  /* KT_ALT + 'O' */
	{0x50 | ALT_KEY | VIRTUAL_KEY, {"\x00\x19\xff"}},  /* KT_ALT + 'P' */
	{0x51 | ALT_KEY | VIRTUAL_KEY, {"\x00\x10\xff"}},  /* KT_ALT + 'Q' */
	{0x52 | ALT_KEY | VIRTUAL_KEY, {"\x00\x13\xff"}},  /* KT_ALT + 'R' */
	{0x53 | ALT_KEY | VIRTUAL_KEY, {"\x00\x1F\xff"}},  /* KT_ALT + 'S' */
	{0x54 | ALT_KEY | VIRTUAL_KEY, {"\x00\x14\xff"}},  /* KT_ALT + 'T' */
	{0x55 | ALT_KEY | VIRTUAL_KEY, {"\x00\x16\xff"}},  /* KT_ALT + 'U' */
	{0x56 | ALT_KEY | VIRTUAL_KEY, {"\x00\x2F\xff"}},  /* KT_ALT + 'V' */
	{0x57 | ALT_KEY | VIRTUAL_KEY, {"\x00\x11\xff"}},  /* KT_ALT + 'W' */
	{0x58 | ALT_KEY | VIRTUAL_KEY, {"\x00\x2D\xff"}},  /* KT_ALT + 'X' */
	{0x59 | ALT_KEY | VIRTUAL_KEY, {"\x00\x15\xff"}},  /* KT_ALT + 'Y' */
	{0x5A | ALT_KEY | VIRTUAL_KEY, {"\x00\x2C\xff"}},  /* KT_ALT + 'Z' */
	{0x5B | ALT_KEY | VIRTUAL_KEY, {"\x00\x1A\xff"}},  /* KT_ALT + '[' */
	{0x5D | ALT_KEY | VIRTUAL_KEY, {"\x00\x1B\xff"}},  /* KT_ALT + ']' */
	{0x60 | ALT_KEY | VIRTUAL_KEY, {"\x00\x29\xff"}},  /* KT_ALT + '`' */
								   				  
	{VK_BACK 	| VIRTUAL_KEY | ALT_KEY, {"\x00\x0E\xff"}},  /* KT_ALT + KN_BS */
	{VK_RETURN	| VIRTUAL_KEY | ALT_KEY, {"\x00\x1C\xff"}},  /* KT_ALT + KN_ENTER */
	{VK_ESCAPE	| VIRTUAL_KEY | ALT_KEY, {"\x00\x01\xff"}},  /* KT_ALT + KN_ESC */
	{VK_F1		| VIRTUAL_KEY | ALT_KEY, {"\x00\x68\xff"}},  /* KT_ALT + KN_F1 */
	{VK_F10		| VIRTUAL_KEY | ALT_KEY, {"\x00\x71\xff"}},  /* KT_ALT + KN_F10 */
	{VK_F11		| VIRTUAL_KEY | ALT_KEY, {"\x00\x8B\xff"}},  /* KT_ALT + KN_F11 */
	{VK_F12		| VIRTUAL_KEY | ALT_KEY, {"\x00\x8C\xff"}},  /* KT_ALT + KN_F12 */
	{VK_F2		| VIRTUAL_KEY | ALT_KEY, {"\x00\x69\xff"}},  /* KT_ALT + KN_F2 */
	{VK_F3		| VIRTUAL_KEY | ALT_KEY, {"\x00\x6A\xff"}},  /* KT_ALT + KN_F3 */
	{VK_F4		| VIRTUAL_KEY | ALT_KEY, {"\x00\x6B\xff"}},  /* KT_ALT + KN_F4 */
	{VK_F5		| VIRTUAL_KEY | ALT_KEY, {"\x00\x6C\xff"}},  /* KT_ALT + KN_F5 */
	{VK_F6		| VIRTUAL_KEY | ALT_KEY, {"\x00\x6D\xff"}},  /* KT_ALT + KN_F6 */
	{VK_F7		| VIRTUAL_KEY | ALT_KEY, {"\x00\x6E\xff"}},  /* KT_ALT + KN_F7 */
	{VK_F8		| VIRTUAL_KEY | ALT_KEY, {"\x00\x6F\xff"}},  /* KT_ALT + KN_F8 */
	{VK_F9		| VIRTUAL_KEY | ALT_KEY, {"\x00\x70\xff"}},  /* KT_ALT + KN_F9 */
	{VK_TAB		| VIRTUAL_KEY | ALT_KEY, {"\x00\xA5\xff"}},  /* KT_ALT + KN_TAB */
										 
	{VK_RETURN | EXTENDED_KEY,	{"\x00\xE0\x0D\xff"}},  /* KT_KP + KN_ENTER */

	{0x2F | EXTENDED_KEY,   {"\x00\xE0\x2F\xff"}},	/* KT_KP + '/' */

	{VK_MULTIPLY | VIRTUAL_KEY,	  {"\x2A\xff"}},	   /* KT_KP + '*' */
	{VK_ADD		| VIRTUAL_KEY,	  {"\x2B\xff"}},	   /* KT_KP + '+' */
	{VK_SUBTRACT | VIRTUAL_KEY,	  {"\x2D\xff"}},	   /* KT_KP + '-' */
	{VK_DECIMAL | VIRTUAL_KEY,	  {"\x2E\xff"}},	   /* KT_KP + '.' */
	{VK_NUMPAD0 | VIRTUAL_KEY,	  {"\x30\xff"}},	   /* KT_KP + '0' */
	{VK_NUMPAD1 | VIRTUAL_KEY,	  {"\x31\xff"}},	   /* KT_KP + '1' */
	{VK_NUMPAD2 | VIRTUAL_KEY,	  {"\x32\xff"}},	   /* KT_KP + '2' */
	{VK_NUMPAD3 | VIRTUAL_KEY,	  {"\x33\xff"}},	   /* KT_KP + '3' */
	{VK_NUMPAD4 | VIRTUAL_KEY,	  {"\x34\xff"}},	   /* KT_KP + '4' */
	{VK_NUMPAD5 | VIRTUAL_KEY,	  {"\x35\xff"}},	   /* KT_KP + '5' */
	{VK_NUMPAD6 | VIRTUAL_KEY,	  {"\x36\xff"}},	   /* KT_KP + '6' */
	{VK_NUMPAD7 | VIRTUAL_KEY,	  {"\x37\xff"}},	   /* KT_KP + '7' */
	{VK_NUMPAD8 | VIRTUAL_KEY,	  {"\x38\xff"}},	   /* KT_KP + '8' */
	{VK_NUMPAD9 | VIRTUAL_KEY,	  {"\x39\xff"}},	   /* KT_KP + '9' */
								  
	{VK_MULTIPLY | VIRTUAL_KEY | CTRL_KEY, {"\x00\x96\xff"}},  /* KT_CTRL + KT_KP + '*' */
	{VK_ADD		| VIRTUAL_KEY | CTRL_KEY,  {"\x00\x90\xff"}},  /* KT_CTRL + KT_KP + '+' */
	{VK_SUBTRACT | VIRTUAL_KEY | CTRL_KEY, {"\x00\x8E\xff"}},  /* KT_CTRL + KT_KP + '-' */
	{VK_DIVIDE	| VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY, {"\x00\x95\xff"}},  /* KT_CTRL + KT_KP + '/' */
	{0x0a | EXTENDED_KEY | CTRL_KEY, {"\x0A\xff"}}, 	 /* KT_CTRL+KT_KP+KN_ENTER */

	{VK_MULTIPLY | VIRTUAL_KEY | ALT_KEY,  {"\x00\x37\xff"}},  /* KT_ALT + KT_KP + '*' */
	{VK_ADD		| VIRTUAL_KEY | ALT_KEY,   {"\x00\x4E\xff"}},  /* KT_ALT + KT_KP + '+' */
	{VK_SUBTRACT | VIRTUAL_KEY | ALT_KEY,  {"\x00\x4A\xff"}},  /* KT_ALT + KT_KP + '-' */
	{VK_DIVIDE	| VIRTUAL_KEY | ALT_KEY,   {"\x00\xA4\xff"}},  /* KT_ALT + KT_KP + '/' */
														  
	{0x0d | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY,  {"\x00\xA6\xff"}},  /* KT_ALT + KT_KP +KN_ENTER */

	{VK_DELETE | VIRTUAL_KEY | EXTENDED_KEY, {"\x00\xE0\x53\xff"}},  /* KT_EP +KN_DEL */
	{VK_DOWN   | VIRTUAL_KEY | EXTENDED_KEY, {"\x00\xE0\x50\xff"}},  /* KT_EP +KN_DOWN */
	{VK_END	  | VIRTUAL_KEY | EXTENDED_KEY,  {"\x00\xE0\x4F\xff"}},  /* KT_EP +KN_END */
	{VK_HOME   | VIRTUAL_KEY | EXTENDED_KEY, {"\x00\xE0\x47\xff"}},  /* KT_EP +KN_HOME */
	{VK_INSERT | VIRTUAL_KEY | EXTENDED_KEY, {"\x00\xE0\x52\xff"}},  /* KT_EP +KN_INS */
	{VK_LEFT   | VIRTUAL_KEY | EXTENDED_KEY, {"\x00\xE0\x4B\xff"}},  /* KT_EP +KN_LEFT */
	{VK_NEXT   | VIRTUAL_KEY | EXTENDED_KEY, {"\x00\xE0\x51\xff"}},  /* KT_EP +KN_PGDN */
	{VK_PRIOR  | VIRTUAL_KEY | EXTENDED_KEY, {"\x00\xE0\x49\xff"}},  /* KT_EP +KN_PGUP */
	{VK_RIGHT  | VIRTUAL_KEY | EXTENDED_KEY, {"\x00\xE0\x4D\xff"}},  /* KT_EP +KN_RIGHT */
	{VK_UP	  | VIRTUAL_KEY | EXTENDED_KEY,  {"\x00\xE0\x48\xff"}},  /* KT_EP +KN_UP */

	{VK_DELETE | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY, {"\x00\xE0\x93\xff"}},	/* KT_CTRL + KT_EP +KN_DEL */
	{VK_DOWN   | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY, {"\x00\xE0\x91\xff"}},	/* KT_CTRL + KT_EP +KN_DOWN */
	{VK_END	  | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY,  {"\x00\xE0\x75\xff"}},	/* KT_CTRL + KT_EP +KN_END */
	{VK_HOME   | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY, {"\x00\xE0\x77\xff"}},	/* KT_CTRL + KT_EP +KN_HOME */
	{VK_INSERT | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY, {"\x00\xE0\x92\xff"}},	/* KT_CTRL + KT_EP +KN_INS */
	{VK_LEFT   | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY, {"\x00\xE0\x73\xff"}},	/* KT_CTRL + KT_EP +KN_LEFT */
	{VK_NEXT   | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY, {"\x00\xE0\x76\xff"}},	/* KT_CTRL + KT_EP +KN_PGDN */
	{VK_PRIOR  | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY, {"\x00\xE0\x84\xff"}},	/* KT_CTRL + KT_EP +KN_PGUP */
	{VK_RIGHT  | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY, {"\x00\xE0\x74\xff"}},	/* KT_CTRL + KT_EP +KN_RIGHT */
	{VK_UP	  | VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY,  {"\x00\xE0\x8D\xff"}},	/* KT_CTRL + KT_EP +KN_UP */

	{VK_DELETE | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY, {"\x00\xA3\xff"}},  /* KT_ALT + KT_EP +KN_DEL */
	{VK_DOWN   | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY, {"\x00\xA0\xff"}},  /* KT_ALT + KT_EP +KN_DOWN */
	{VK_END	  | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY,  {"\x00\x9F\xff"}},  /* KT_ALT + KT_EP +KN_END */
	{VK_HOME   | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY, {"\x00\x97\xff"}},  /* KT_ALT + KT_EP +KN_HOME */
	{VK_INSERT | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY, {"\x00\xA2\xff"}},  /* KT_ALT + KT_EP +KN_INS */
	{VK_LEFT   | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY, {"\x00\x9B\xff"}},  /* KT_ALT + KT_EP +KN_LEFT */
	{VK_NEXT   | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY, {"\x00\xA1\xff"}},  /* KT_ALT + KT_EP +KN_PGDN */
	{VK_PRIOR  | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY, {"\x00\x99\xff"}},  /* KT_ALT + KT_EP +KN_PGUP */
	{VK_RIGHT  | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY, {"\x00\x9D\xff"}},  /* KT_ALT + KT_EP +KN_RIGHT */
	{VK_UP	  | VIRTUAL_KEY | EXTENDED_KEY | ALT_KEY,  {"\x00\x98\xff"}},  /* KT_ALT + KT_EP +KN_UP */

	{0x32 | VIRTUAL_KEY | CTRL_KEY, {"\x00\x03\xff"}},	/* KT_CTRL + '@' (NUL) */
	};


/* for VT52 emulator */
const KEYTBLSTORAGE VT52KeyTable[MAX_VT52_KEYS] =
    {
	{VK_UP	  | EXTENDED_KEY | VIRTUAL_KEY,{"\x1B\x41\xff"}},  /* KN_UP */
	{VK_DOWN | EXTENDED_KEY | VIRTUAL_KEY,{"\x1B\x42\xff"}},  /* KN_DOWN */
	{VK_RIGHT| EXTENDED_KEY | VIRTUAL_KEY,{"\x1B\x43\xff"}},  /* KN_RIGHT */
	{VK_LEFT | EXTENDED_KEY | VIRTUAL_KEY,{"\x1B\x44\xff"}},  /* KN_LEFT */
	   
	{VK_UP	 | VIRTUAL_KEY,					{"\x1B\x41\xff"}},  /* KN_UP */
	{VK_DOWN | VIRTUAL_KEY,				{"\x1B\x42\xff"}},  /* KN_DOWN */
	{VK_RIGHT| VIRTUAL_KEY,				{"\x1B\x43\xff"}},  /* KN_RIGHT */
	{VK_LEFT | VIRTUAL_KEY,				{"\x1B\x44\xff"}},  /* KN_LEFT */

	{VK_F1	| VIRTUAL_KEY,					{"\x1BP\xff"}},  /* KN_F1 */
	{VK_F2	| VIRTUAL_KEY,					{"\x1BQ\xff"}},  /* KN_F2 */
	{VK_F3	| VIRTUAL_KEY,					{"\x1BR\xff"}},  /* KN_F3 */
	{VK_F4	| VIRTUAL_KEY,					{"\x1BS\xff"}},  /* KN_F4 */

	{VK_F1	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1BP\xff"}},  /* KN_F1 */
	{VK_F2	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1BQ\xff"}},  /* KN_F2 */
	{VK_F3	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1BR\xff"}},  /* KN_F3 */
	{VK_F4	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1BS\xff"}},  /* KN_F4 */

	{VK_DELETE	| VIRTUAL_KEY,				{"\x7F\xff"}}, 	/* KN_DEL */
	{VK_DELETE	| VIRTUAL_KEY | EXTENDED_KEY,{"\x7F\xff"}}, 	/* KN_DEL */

	{VK_ADD	| VIRTUAL_KEY,					{",\xff"}},
	};

const KEYTBLSTORAGE VT52_Keypad_KeyTable[MAX_VT52_KEYPAD_KEYS] =
    {
	{VK_NUMPAD0 | VIRTUAL_KEY,	 {"\x1B?p\xff"}}, /* KT_KP + '0' (alternate mode) */
	{VK_NUMPAD1 | VIRTUAL_KEY,	 {"\x1B?q\xff"}}, /* KT_KP + '1' (alternate mode) */
	{VK_NUMPAD2 | VIRTUAL_KEY,	 {"\x1B?r\xff"}}, /* KT_KP + '2' (alternate mode) */
	{VK_NUMPAD3 | VIRTUAL_KEY,	 {"\x1B?s\xff"}}, /* KT_KP + '3' (alternate mode) */
	{VK_NUMPAD4 | VIRTUAL_KEY,	 {"\x1B?t\xff"}}, /* KT_KP + '4' (alternate mode) */
	{VK_NUMPAD5 | VIRTUAL_KEY,	 {"\x1B?u\xff"}}, /* KT_KP + '5' (alternate mode) */
	{VK_NUMPAD6 | VIRTUAL_KEY,	 {"\x1B?v\xff"}}, /* KT_KP + '6' (alternate mode) */
	{VK_NUMPAD7 | VIRTUAL_KEY,	 {"\x1B?w\xff"}}, /* KT_KP + '7' (alternate mode) */
	{VK_NUMPAD8 | VIRTUAL_KEY,	 {"\x1B?x\xff"}}, /* KT_KP + '8' (alternate mode) */
	{VK_NUMPAD9 | VIRTUAL_KEY,	 {"\x1B?y\xff"}}, /* KT_KP + '9' (alternate mode) */
	{VK_DECIMAL | VIRTUAL_KEY,	 {"\x1B?n\xff"}}, /* KT_KP + '.' (alternate mode) */

	{VK_ADD		| VIRTUAL_KEY,	 {"\x1B?l\xff"}},	/* KT_KP + '+' (alternate mode) */
	{VK_RETURN	| EXTENDED_KEY,  {"\x1B?M\xff"}},	/* KT_KP + enter  (alternate mode) */
	{VK_SUBTRACT | VIRTUAL_KEY,	 {"\x1B?m\xff"}},	/* KT_KP + '-' (alternate mode) */
	};						  

const KEYTBLSTORAGE VT_PF_KeyTable[MAX_VT_PF_KEYS] =
    {
	{VK_NUMLOCK	| VIRTUAL_KEY | EXTENDED_KEY, {"\x1BP\xff"}},	/* KT_KP + NUMLOCK */
	{0x2F		| EXTENDED_KEY, 			  {"\x1BQ\xff"}},	/* KT_KP + '/' */
	{VK_MULTIPLY | VIRTUAL_KEY,				  {"\x1BR\xff"}},	/* KT_KP + '*' */
	{VK_SUBTRACT | VIRTUAL_KEY,				  {"\x1BS\xff"}},	/* KT_KP + '-' */
	};

/* for VT100 emulator */

const KEYTBLSTORAGE VT100KeyTable[MAX_VT100_KEYS] =
    {
	{VK_UP	 | VIRTUAL_KEY,				{"\x1B[A\xff"}},  /* KN_UP */
	{VK_DOWN | VIRTUAL_KEY,				{"\x1B[B\xff"}},  /* KN_DOWN */
	{VK_RIGHT| VIRTUAL_KEY,				{"\x1B[C\xff"}},  /* KN_RIGHT */
	{VK_LEFT | VIRTUAL_KEY,				{"\x1B[D\xff"}},  /* KN_LEFT */

	{VK_UP	 | EXTENDED_KEY | VIRTUAL_KEY,	{"\x1B[A\xff"}},  /* KN_UP */
	{VK_DOWN | EXTENDED_KEY | VIRTUAL_KEY,{"\x1B[B\xff"}},  /* KN_DOWN */
	{VK_RIGHT| EXTENDED_KEY | VIRTUAL_KEY,{"\x1B[C\xff"}},  /* KN_RIGHT */
	{VK_LEFT | EXTENDED_KEY | VIRTUAL_KEY,{"\x1B[D\xff"}},  /* KN_LEFT */

	{VK_F1	| VIRTUAL_KEY,					{"\x1BOP\xff"}},  /* KN_F1 */
	{VK_F2	| VIRTUAL_KEY,					{"\x1BOQ\xff"}},  /* KN_F2 */
	{VK_F3	| VIRTUAL_KEY,					{"\x1BOR\xff"}},  /* KN_F3 */
	{VK_F4	| VIRTUAL_KEY,					{"\x1BOS\xff"}},  /* KN_F4 */

	{VK_F1	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1BOP\xff"}},  /* KN_F1 */
	{VK_F2	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1BOQ\xff"}},  /* KN_F2 */
	{VK_F3	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1BOR\xff"}},  /* KN_F3 */
	{VK_F4	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1BOS\xff"}},  /* KN_F4 */

	{VK_DELETE | VIRTUAL_KEY,				{"\x7F\xff"}},	/* KN_DEL */
	{VK_DELETE | VIRTUAL_KEY | EXTENDED_KEY,{"\x7F\xff"}},	/* KN_DEL */

	{VK_ADD	| VIRTUAL_KEY,							{",\xff"}},

	{VK_SPACE | VIRTUAL_KEY | CTRL_KEY,				{"\x00\xff"}}, 	  /* CTRL + SPACE */
	{0x32   | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x00\xff"}}, 	/* CTRL + @ */
	{0x32	| VIRTUAL_KEY | CTRL_KEY,				{"\x00\xff"}}, 	/* CTRL + 2 */
	{0x36	| VIRTUAL_KEY | CTRL_KEY,				{"\x1e\xff"}},	/* CTRL + 6 */
	{0xbd	| VIRTUAL_KEY | CTRL_KEY,				{"\x1f\xff"}},	/* CTRL + - */
	};

const KEYTBLSTORAGE VT100_Cursor_KeyTable[MAX_VT100_CURSOR_KEYS] =
    {
	{VK_UP	 | EXTENDED_KEY | VIRTUAL_KEY,	{"\x1BOA\xff"}},  /* KN_UP */
	{VK_DOWN | EXTENDED_KEY | VIRTUAL_KEY,{"\x1BOB\xff"}},  /* KN_DOWN */
	{VK_RIGHT| EXTENDED_KEY | VIRTUAL_KEY,{"\x1BOC\xff"}},  /* KN_RIGHT */
	{VK_LEFT | EXTENDED_KEY | VIRTUAL_KEY,{"\x1BOD\xff"}},  /* KN_LEFT */

	{VK_UP	 | VIRTUAL_KEY,				{"\x1BOA\xff"}},  /* KN_UP */
	{VK_DOWN | VIRTUAL_KEY,				{"\x1BOB\xff"}},  /* KN_DOWN */
	{VK_RIGHT| VIRTUAL_KEY,				{"\x1BOC\xff"}},  /* KN_RIGHT */
	{VK_LEFT | VIRTUAL_KEY,				{"\x1BOD\xff"}},  /* KN_LEFT */
	};

const KEYTBLSTORAGE VT100_Keypad_KeyTable[MAX_VT100_KEYPAD_KEYS] =
    {
	{VK_NUMPAD0 | VIRTUAL_KEY,	 {"\x1BOp\xff"}}, /* KT_KP + '0' (alternate mode) */
	{VK_NUMPAD1 | VIRTUAL_KEY,	 {"\x1BOq\xff"}}, /* KT_KP + '1' (alternate mode) */
	{VK_NUMPAD2 | VIRTUAL_KEY,	 {"\x1BOr\xff"}}, /* KT_KP + '2' (alternate mode) */
	{VK_NUMPAD3 | VIRTUAL_KEY,	 {"\x1BOs\xff"}}, /* KT_KP + '3' (alternate mode) */
	{VK_NUMPAD4 | VIRTUAL_KEY,	 {"\x1BOt\xff"}}, /* KT_KP + '4' (alternate mode) */
	{VK_NUMPAD5 | VIRTUAL_KEY,	 {"\x1BOu\xff"}}, /* KT_KP + '5' (alternate mode) */
	{VK_NUMPAD6 | VIRTUAL_KEY,	 {"\x1BOv\xff"}}, /* KT_KP + '6' (alternate mode) */
	{VK_NUMPAD7 | VIRTUAL_KEY,	 {"\x1BOw\xff"}}, /* KT_KP + '7' (alternate mode) */
	{VK_NUMPAD8 | VIRTUAL_KEY,	 {"\x1BOx\xff"}}, /* KT_KP + '8' (alternate mode) */
	{VK_NUMPAD9 | VIRTUAL_KEY,	 {"\x1BOy\xff"}}, /* KT_KP + '9' (alternate mode) */
	{VK_DECIMAL | VIRTUAL_KEY,	 {"\x1BOn\xff"}}, /* KT_KP + '.' (alternate mode) */

	{VK_ADD		| VIRTUAL_KEY,	 {"\x1BOl\xff"}}, /* KT_KP + '*' (alternate mode) */
	{VK_RETURN	| EXTENDED_KEY,  {"\x1BOM\xff"}}, /* KT_KP + '+' (alternate mode) */
	{VK_SUBTRACT | VIRTUAL_KEY,	 {"\x1BOm\xff"}}, /* KT_KP + '-' (alternate mode) */
	};

#if defined(INCL_MINITEL)
const KEYTBLSTORAGE Minitel_KeyTable[MAX_MINITEL_KEYS] =
	{
	{0x4D		| VIRTUAL_KEY	| CTRL_KEY, 	{"\x0D\xff"}},  /* ctrl-m */

	{VK_RETURN  | VIRTUAL_KEY,					{"\x13\x41\xff"}}, /* Envoi CNTRL-MA*/
	{VK_RETURN	| EXTENDED_KEY,					{"\x13\x41\xff"}}, /* Send CNTRL-MA*/
	{VK_TAB		| VIRTUAL_KEY,					{"\x13\x41\xff"}}, /* Send CNTRL-MA*/
	{VK_F8		| VIRTUAL_KEY,					{"\x13\x41\xff"}}, /* Send CNTRL-MA*/

	{VK_HOME 	| VIRTUAL_KEY,					{"\x13\x46"}}, /* Sommaire CNTRL-MF*/
	{VK_HOME 	| VIRTUAL_KEY	| EXTENDED_KEY, {"\x13\x46\xff"}}, /* Index CNTRL-MF*/
	{VK_F1		| VIRTUAL_KEY,					{"\x13\x46\xff"}}, /* Index CNTRL-MF*/

	{VK_DELETE	| VIRTUAL_KEY,					{"\x13\x45\xff"}}, /* Annulation CNTRL-ME*/
	{VK_DELETE	| VIRTUAL_KEY	| EXTENDED_KEY, {"\x13\x45\xff"}}, /* Cancel CNTRL-ME*/
	{VK_F2		| VIRTUAL_KEY,					{"\x13\x45\xff"}}, /* Cancel CNTRL-ME*/

	{VK_PRIOR	| VIRTUAL_KEY,					{"\x13\x42\xff"}}, /* Retour CNTRL-MB*/
	{VK_PRIOR	| VIRTUAL_KEY	| EXTENDED_KEY, {"\x13\x42\xff"}}, /* Previous CNTRL-MB*/
	{VK_F3		| VIRTUAL_KEY,					{"\x13\x42\xff"}}, /* Previous CNTRL-MB*/

	{VK_INSERT	| VIRTUAL_KEY,					{"\x13\x43\xff"}}, /* Repeat CNTRL-MC*/
	{VK_INSERT	| VIRTUAL_KEY	| EXTENDED_KEY, {"\x13\x43\xff"}}, /* Repeat CNTRL-MC*/
	{VK_F4		| VIRTUAL_KEY,					{"\x13\x43\xff"}}, /* Repeat CNTRL-MC*/
															
	{VK_BACK 	| VIRTUAL_KEY,					{"\x13\x47\xff"}}, /* Correct CNTRL-MG*/
	{VK_F6		| VIRTUAL_KEY,					{"\x13\x47\xff"}}, /* Correct CNTRL-MG*/

	{VK_INSERT	| VIRTUAL_KEY,					{"\x13\x44\xff"}}, /* Guide CNTRL-MD*/
	{VK_INSERT	| VIRTUAL_KEY	| EXTENDED_KEY, {"\x13\x44\xff"}}, /* Guide CNTRL-MD*/
	{VK_F5		| VIRTUAL_KEY,					{"\x13\x44\xff"}}, /* Guide CNTRL-MD*/

	{VK_NEXT 	| VIRTUAL_KEY,					{"\x13\x48\xff"}}, /* Suite CNTRL-MH*/
	{VK_NEXT 	| VIRTUAL_KEY	| EXTENDED_KEY, {"\x13\x48\xff"}}, /* Next CNTRL-MH*/
	{VK_F7		| VIRTUAL_KEY,					{"\x13\x48\xff"}}, /* Next CNTRL-MH*/

	{VK_F9		| VIRTUAL_KEY,					{"\x13\x49\xff"}}, /* Connect (page 123) */

	// Page 124

	{VK_UP		| VIRTUAL_KEY,								   {"\x1B[A\xff"}},
	{VK_UP		| VIRTUAL_KEY | EXTENDED_KEY,				   {"\x1B[A\xff"}},
	
	{VK_UP		| VIRTUAL_KEY | SHIFT_KEY,					   {"\x1B[M\xff"}},
	{VK_UP		| VIRTUAL_KEY | EXTENDED_KEY | SHIFT_KEY,	   {"\x1B[M\xff"}},
																			
	{VK_DOWN 	| VIRTUAL_KEY,								   {"\x1B[B\xff"}},
	{VK_DOWN 	| VIRTUAL_KEY | EXTENDED_KEY,				   {"\x1B[B\xff"}},

	{VK_DOWN 	| VIRTUAL_KEY | SHIFT_KEY,					   {"\x1B[L\xff"}},
	{VK_DOWN 	| VIRTUAL_KEY | SHIFT_KEY | EXTENDED_KEY,	   {"\x1B[L\xff"}},

	{VK_RIGHT	| VIRTUAL_KEY,								   {"\x1B[C\xff"}},
	{VK_RIGHT	| VIRTUAL_KEY | EXTENDED_KEY,				   {"\x1B[C\xff"}},

	/* See minitel kbdin routine on this one - mrw */
	{VK_RIGHT	| VIRTUAL_KEY | SHIFT_KEY,					   {"\x1B[4\xff"}},
	{VK_RIGHT	| VIRTUAL_KEY | SHIFT_KEY | EXTENDED_KEY,	   {"\x1B[4\xff"}},

	{VK_LEFT 	| VIRTUAL_KEY,								   {"\x1B[D\xff"}},
	{VK_LEFT 	| VIRTUAL_KEY | EXTENDED_KEY,				   {"\x1B[D\xff"}},

	{VK_LEFT 	| VIRTUAL_KEY | SHIFT_KEY,					   {"\x1B[P\xff"}},
	{VK_LEFT 	| VIRTUAL_KEY | SHIFT_KEY | EXTENDED_KEY,	   {"\x1B[P\xff"}},
	{VK_LEFT 	| VIRTUAL_KEY | CTRL_KEY,					   {"\x7F\xff"}},	
	{VK_LEFT 	| VIRTUAL_KEY | CTRL_KEY | EXTENDED_KEY,	   {"\x7F\xff"}},	

	/* numpad enter */
	{VK_RETURN	| VIRTUAL_KEY | EXTENDED_KEY,				   {"\x13\x41\xff"}},
	{VK_RETURN	| VIRTUAL_KEY | EXTENDED_KEY | SHIFT_KEY,	   {"\x1B[H\xff"}},
	{VK_RETURN	| VIRTUAL_KEY | EXTENDED_KEY | CTRL_KEY,	   {"\x1B[2J\xff"}},

	// page 118

	{0xA3,	{"\x19\x23\xff"}},		// British pound symbol.
	{0xA7,	{"\x19\x27\xff"}},		// Paragraph symbol.
	{0xA8,	{"\x19\x48\xff"}},		// umluot

	{0xB0,	{"\x19\x30\xff"}},		// degree symbol
	{0xB1,	{"\x19\x31\xff"}},		// plus over minus symbol
	{0xB4,	{"\x19\x42\xff"}},		// accute accent
	{0xBC,	{"\x19\x3C\xff"}},		// 1/4
	{0xBD,	{"\x19\x3D\xff"}},		// 1/2
	{0xBE,	{"\x19\x3E\xff"}},		// 3/4
	{0xB8,	{"\x19\x4B\xff"}},		// beard

	{0xC0,	{"\x19\x2D\xff"}},		// up arrow symbol
	{0xC3,	{"\x19\x2C\xff"}},		// left arrow symbol
	{0xC4,	{"\x19\x2E\xff"}},		// right arrow symbol
	{0xC5,	{"\x19\x2F\xff"}},		// down arrow symbol

	{0xDF,	{"\x19\x7B\xff"}},		// Beta

	{0xE0,	{"\x19\x41\x61\xff"}},	// a grave accent
	{0xE2,	{"\x19\x43\x61\xff"}},	// a circumflex
	{0xE4,	{"\x19\x48\x61\xff"}},	// a umluot
	{0xE7,	{"\x19\x4B\x63\xff"}},	// c with a beard
	{0xE8,	{"\x19\x41\x65\xff"}},	// e grave accent
	{0xE9,	{"\x19\x42\x65\xff"}},	// e accute accent
	{0xEA,	{"\x19\x43\x65\xff"}},	// e circumflex
	{0xEB,	{"\x19\x48\x65\xff"}},	// e umluot
	{0xEE,	{"\x19\x43\x69\xff"}},	// i circumflex
	{0xEF,	{"\x19\x48\x69\xff"}},	// i umluot

	{0xF4,	{"\x19\x43\x6f\xff"}},	// o circumflex
	{0xF5,	{"\x19\x48\x6f\xff"}},	// o umluot
	{0xF7,	{"\x19\x38\xff"}},		// divide-by symbol
	{0xF9,	{"\x19\x41\x75\xff"}},	// u grave accent
	{0xFB,	{"\x19\x43\x75\xff"}},	// u circumflex
	{0xFC,	{"\x19\x48\x75\xff"}},	// u circumflex

	{0x5E,	{"\x19\x43\xff"}},		// circumflex accent (^)
	{0x60,	{"\x19\x41\xff"}},		// grave accent(`)
	{0x8C,	{"\x19\x6A\xff"}},		// big OE
	{0x9C,	{"\x19\x7A\xff"}},		// little oe
	};		
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuCreateHdl
 *
 * DESCRIPTION:
 *	Creates an emulator handle.  The creation of an Emulator handle
 *	includes setting default user settings and loading the ANSI
 *	emulator.
 *
 * ARGUMENTS:
 *	hSession - session handle.
 *
 * RETURNS:
 *	HEMU or zero on error.
 *
 */
HEMU emuCreateHdl(const HSESSION hSession)
	{
	HHEMU hhEmu;

	hhEmu = malloc(sizeof(*hhEmu));

	if (hhEmu == 0)
		{
		assert(FALSE);
		return 0;
		}

	memset(hhEmu, 0, sizeof(*hhEmu));

	InitializeCriticalSection(&hhEmu->csEmu);

	hhEmu->hSession = hSession;

	// Create and load the Emulator Name & Id table.
	//
	if (!emuCreateNameTable(hhEmu))
		{
		assert(FALSE);
		emuDestroyHdl((HEMU)hhEmu);
		hhEmu = NULL;
		return 0;
		}

	// Create the text and attribute buffers.
	//
	if (!emuCreateTextAttrBufs((HEMU)hhEmu, MAX_EMUROWS, MAX_EMUCOLS))
		{
		assert(FALSE);
		emuDestroyHdl((HEMU)hhEmu);
		hhEmu = NULL;
		return 0;
		}

	// Create the Print handle used for Printer Echo.
	//
	hhEmu->hPrintEcho = printCreateHdl(hSession);
	if(hhEmu->hPrintEcho == 0)
		{
		assert(FALSE);
		emuDestroyHdl((HEMU)hhEmu);
		hhEmu = NULL;
		return 0;
		}

	// Create the Print handle used for Host directed printing.
	//
	hhEmu->hPrintHost = printCreateHdl(hSession);
	if (hhEmu->hPrintHost == 0)
		{
		assert(FALSE);
		emuDestroyHdl((HEMU)hhEmu);
		hhEmu = NULL;
		return 0;
		}

	// Initialize the user settings for the emulation handle.
	//
	if (emuInitializeHdl((HEMU)hhEmu) != 0)
		{
		assert(FALSE);
		emuDestroyHdl((HEMU)hhEmu);
		hhEmu = NULL;
		return 0;
		}

	return (HEMU)hhEmu;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuDestroyHdl
 *
 * DESCRIPTION:
 *	Death and destruction of the once noble emulator handle.
 *
 * ARGUMENTS:
 *	hEmu	- external emulator handle.
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int emuDestroyHdl(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hhEmu == 0)
		{
		assert(0);
		return -1;
		}

	if (hhEmu->pstNameTable)
		{
		free(hhEmu->pstNameTable);
		hhEmu->pstNameTable = NULL;
		}

    if (hhEmu->emu_deinstall)
        {
		(*hhEmu->emu_deinstall)(hhEmu);
        }

	printDestroyHdl(hhEmu->hPrintEcho);
	hhEmu->hPrintEcho = NULL;
	printDestroyHdl(hhEmu->hPrintHost);
	hhEmu->hPrintHost = NULL;
	emuDestroyTextAttrBufs(hEmu);
	DeleteCriticalSection(&hhEmu->csEmu);

	if(hhEmu)
		free(hhEmu);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuInitializeHdl
 *
 * DESCRIPTION:
 *	This function initializes the stUserSettings structure of the internal
 *	emulator handle with the values stored in the session file.
 *
 * ARGUMENTS:
 *	HEMU	-	The External Emulator Handle.
 *
 * RETURNS:
 *	0 if successful, otherwise -1
 *
 */
int emuInitializeHdl(const HEMU hEmu)
	{
	int nRet, nReturn;
	struct stEmuBaseSFSettings stBaseSFSettings;

	const HHEMU hhEmu = (HHEMU)hEmu;

	nReturn = -1;

	if (hhEmu == 0)
		{
		assert(FALSE);
		return nReturn;
		}

	emuLock(hEmu);

	hhEmu->emu_maxcol		= EMU_DEFAULT_MAXCOL;
	hhEmu->emu_maxrow		= EMU_DEFAULT_MAXROW;
	hhEmu->bottom_margin	= EMU_DEFAULT_MAXROW;

	hhEmu->mode_vt220 = FALSE;
	hhEmu->mode_vt320 = FALSE;

	// Added for the VT220/320 rde 16 Feb 1998
	hhEmu->fUse8BitCodes = FALSE;
	hhEmu->fAllowUserKeys = FALSE;

#if defined(INCL_PRINT_PASSTHROUGH)
	// Added for VT100/220/320 mpt: 5-19-00
	// hhEmu->fPrintRaw = FALSE;
#endif // INCL_PRINT_PASSTHROUGH

	hhEmu->attrState[0].txtclr =
	hhEmu->attrState[1].txtclr = VC_WHITE;

	hhEmu->attrState[0].bkclr =
	hhEmu->attrState[1].bkclr = VC_BLACK;

	hhEmu->iCurAttrState = CS_STATE;

	std_setcolors(hhEmu, GetNearestColorIndex(GetSysColor(COLOR_WINDOWTEXT)),
							GetNearestColorIndex(GetSysColor(COLOR_WINDOW)));

	// Initialize the user setting default values.
	//
	memset(&stBaseSFSettings, 0, sizeof(stBaseSFSettings));

	stBaseSFSettings.nTermKeys 			= EMU_KEYS_TERM;
	stBaseSFSettings.nCursorType		= EMU_CURSOR_LINE;
	stBaseSFSettings.fCursorBlink		= TRUE;
	stBaseSFSettings.nCharacterSet 		= EMU_CHARSET_ASCII;
	stBaseSFSettings.fMapPFkeys			= FALSE;
	stBaseSFSettings.fAltKeypadMode		= FALSE;
	stBaseSFSettings.fKeypadAppMode		= FALSE;
	stBaseSFSettings.fCursorKeypadMode	= FALSE;
	stBaseSFSettings.fReverseDelBk 		= FALSE;
	stBaseSFSettings.f132Columns		= FALSE;
	stBaseSFSettings.fWrapLines			= TRUE;
 	stBaseSFSettings.fDestructiveBk		= TRUE;
	stBaseSFSettings.fLbSymbolOnEnter	= FALSE;
    stBaseSFSettings.fUse8BitCodes		= FALSE; 
    stBaseSFSettings.fAllowUserKeys		= FALSE;  
	stBaseSFSettings.nEmuId				= EMU_AUTO;
#if defined(INCL_ULTC_VERSION)
	stBaseSFSettings.nEmuId				= EMU_VT220;
	stBaseSFSettings.nCharacterSet 		= EMU_CHARSET_MULTINATIONAL;
#endif
	stBaseSFSettings.nAutoAttempts		= 0;
#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
    // Initialize new user settings. - cab:11/14/96
    //
    stBaseSFSettings.nBackspaceKeys		= EMU_BKSPKEYS_CTRLH;

    // Zero the telnet id string. I am doing this because if there
    // isn't one in the session file, I want to load the default.
    //
    stBaseSFSettings.acTelnetId[0]		= TEXT('\0');

    emuQueryDefaultTelnetId(stBaseSFSettings.nEmuId,
			stBaseSFSettings.acTelnetId, EMU_MAX_TELNETID);
#endif

	// Load the settings if they exist.
	if ((nRet = emuLoadSettings(hhEmu, 
								SFID_EMU_SETTINGS,
								sizeof(stBaseSFSettings),
								&stBaseSFSettings)) == -1)
		{
		nReturn = -1;
		goto InitExit;
		}

	if (nRet > 0)
		{
		// The data was present.
        // Check to see if there is a telnet id. If not, use the default.
        //
		emuCheckSettings(&stBaseSFSettings); 

#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
        if ( stBaseSFSettings.acTelnetId[0] == TEXT('\0') )
            {
            emuQueryDefaultTelnetId(stBaseSFSettings.nEmuId,
					stBaseSFSettings.acTelnetId, EMU_MAX_TELNETID);
            }
#endif
		}

	// Initialize the emu's user settings structure from the data stored
	// in the session file.
	hhEmu->stUserSettings.nEmuId = stBaseSFSettings.nEmuId;
	hhEmu->stUserSettings.nTermKeys = stBaseSFSettings.nTermKeys;	
	hhEmu->stUserSettings.nCursorType = stBaseSFSettings.nCursorType;
	hhEmu->stUserSettings.nCharacterSet = stBaseSFSettings.nCharacterSet;
	hhEmu->stUserSettings.nAutoAttempts = stBaseSFSettings.nAutoAttempts;
	hhEmu->stUserSettings.fCursorBlink = stBaseSFSettings.fCursorBlink;
	hhEmu->stUserSettings.fMapPFkeys = stBaseSFSettings.fMapPFkeys;
	hhEmu->stUserSettings.fAltKeypadMode = stBaseSFSettings.fAltKeypadMode;
	hhEmu->stUserSettings.fKeypadAppMode = stBaseSFSettings.fKeypadAppMode;
	hhEmu->stUserSettings.fCursorKeypadMode = stBaseSFSettings.fCursorKeypadMode;
	hhEmu->stUserSettings.fReverseDelBk = stBaseSFSettings.fReverseDelBk;
	hhEmu->stUserSettings.f132Columns = stBaseSFSettings.f132Columns;
#if defined(INCL_PRINT_PASSTHROUGH)
	//hhEmu->stUserSettings.fPrintRaw = stBaseSFSettings.fPrintRaw;
#endif // INCL_PRINT_PASSTHROUGH
	hhEmu->stUserSettings.fDestructiveBk = stBaseSFSettings.fDestructiveBk;
	hhEmu->stUserSettings.fWrapLines = stBaseSFSettings.fWrapLines;
	hhEmu->stUserSettings.fLbSymbolOnEnter = stBaseSFSettings.fLbSymbolOnEnter;
    hhEmu->stUserSettings.fUse8BitCodes = stBaseSFSettings.fUse8BitCodes;	
    hhEmu->stUserSettings.fAllowUserKeys = stBaseSFSettings.fAllowUserKeys;
    hhEmu->stUserSettings.nBackspaceKeys = stBaseSFSettings.nBackspaceKeys;

    StrCharCopyN(hhEmu->stUserSettings.acTelnetId, stBaseSFSettings.acTelnetId, EMU_MAX_TELNETID);

#ifdef INCL_TERMINAL_SIZE_AND_COLORS
	// Set up the default colors in case the user settings don't exist.
	#if TRUE  
	hhEmu->stUserSettings.nTextColor = 
			GetNearestColorIndex(GetSysColor(COLOR_WINDOWTEXT));
	hhEmu->stUserSettings.nBackgroundColor =
			GetNearestColorIndex(GetSysColor(COLOR_WINDOW));
	#else
	// We've decided not to do this. rde 14 Jul 98
	// Use white (non-bold) on black. rde 8 Jul 98
	hhEmu->stUserSettings.nBackgroundColor = VC_BLACK;
	hhEmu->stUserSettings.nTextColor = VC_WHITE;
	#endif

	// Load the settings if they exist.
	if ((nRet = emuLoadSettings(hhEmu, 
						SFID_EMU_TEXTCOLOR_SETTING,
						sizeof(hhEmu->stUserSettings.nTextColor),
						&hhEmu->stUserSettings.nTextColor)) == -1)
		{
		nReturn = -1;
		goto InitExit;
		}

	if (nRet > 0)
		{
		// The data was present, so use it.
		std_setcolors(hhEmu, 
				hhEmu->stUserSettings.nTextColor,
				hhEmu->stUserSettings.nBackgroundColor);
		}

	if ((nRet = emuLoadSettings(hhEmu, 
						SFID_EMU_BKGRNDCOLOR_SETTING,
						sizeof(hhEmu->stUserSettings.nBackgroundColor),
						&hhEmu->stUserSettings.nBackgroundColor)) == -1)
		{
		nReturn = -1;
		goto InitExit;
		}

	if (nRet > 0)
		{
		// The data was present, so use it.
		std_setcolors(hhEmu, 
				hhEmu->stUserSettings.nTextColor,
				hhEmu->stUserSettings.nBackgroundColor);
		}

	// Set up the default screen size in case the user settings don't exist.
	hhEmu->stUserSettings.nUserDefRows = EMU_DEFAULT_ROWS;
	hhEmu->stUserSettings.nUserDefCols = 
			hhEmu->stUserSettings.f132Columns ? MAX_EMUCOLS : EMU_DEFAULT_COLS;

#if defined(INCL_PRINT_PASSTHROUGH)
	// default host-controlled print mode with regard to windows drivers
	hhEmu->stUserSettings.fPrintRaw = FALSE;
#endif // INCL_PRINT_PASSTHROUGH
	
	// Load the settings if they exist.
	if ((nRet = emuLoadSettings(hhEmu, 
						SFID_EMU_SCRNROWS_SETTING,
						sizeof(hhEmu->stUserSettings.nUserDefRows),
						&hhEmu->stUserSettings.nUserDefRows)) == -1)
		{
		nReturn = -1;
		goto InitExit;
		}

	if ((nRet = emuLoadSettings(hhEmu, 
						SFID_EMU_SCRNCOLS_SETTING,
						sizeof(hhEmu->stUserSettings.nUserDefCols),
						&hhEmu->stUserSettings.nUserDefCols)) == -1)
		{
		nReturn = -1;
		goto InitExit;
		}

#if defined(INCL_PRINT_PASSTHROUGH)
	if ((nRet = emuLoadSettings(hhEmu, 
						SFID_EMU_PRINT_RAW,
						sizeof(hhEmu->stUserSettings.fPrintRaw),
						&hhEmu->stUserSettings.fPrintRaw)) == -1)
		{
		nReturn = -1;
		goto InitExit;
		}
#endif // INCL_PRINT_PASSTHROUGH

	if (nRet > 0)
		{
		// The data was present, so use it.
		hhEmu->stUserSettings.f132Columns = 
				(hhEmu->stUserSettings.nUserDefCols == 132) ? TRUE : FALSE;

#if FALSE	// TODO:rde Is this needed?
		hhEmu->emu_setscrsize = std_setscrsize;
#endif
		}
#endif

	// Load the emulator.
	//
	nReturn = emuLoad((HEMU)hhEmu, hhEmu->stUserSettings.nEmuId);

    //JMH 01-09-97 emuSetSettings() was being called before emuLoad(), but
    // emuLoad() initialized some values that got set by emuSetSettings().
    // (e.g. 132-column mode).
    //
	// Tell the emulator about the user's settings.
	//
	emuSetSettings((HEMU)hhEmu, &hhEmu->stUserSettings);

	// Clear the emulator image.
	//
	//*for (nRow = 0 ; nRow < MAX_EMUROWS ; ++nRow)
	//*    clear_imgrow(hhEmu, nRow);

	//* This breaks the MINITEL bad	- mrw
	//*(hhEmu->emu_setcurpos)(hhEmu, 0, 0);

	InitExit:

	emuUnlock(hEmu);

	NotifyClient(hhEmu->hSession, EVENT_EMU_SETTINGS, 0);
	NotifyClient(hhEmu->hSession, EVENT_TERM_UPDATE, 0);

	if (nReturn < 0)
		nRet = 0;

	return nReturn;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuSaveHdl
 *
 * DESCRIPTION:
 *	This function stores the emulator user settings in the session file.
 *
 *
 * ARGUMENTS:
 *	HEMU	-	The External Emulator Handle.
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int emuSaveHdl(const HEMU hEmu)
	{
	struct stEmuBaseSFSettings stBaseSFSettings;
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hhEmu == 0)
		{
		assert(FALSE);
		return -1;
		}

	// Initialize the base structure that gets saved in the session file.
	stBaseSFSettings.nEmuId = hhEmu->stUserSettings.nEmuId;
	stBaseSFSettings.nTermKeys = hhEmu->stUserSettings.nTermKeys;		
	stBaseSFSettings.nCursorType = hhEmu->stUserSettings.nCursorType;
	stBaseSFSettings.nCharacterSet = hhEmu->stUserSettings.nCharacterSet;
	stBaseSFSettings.nAutoAttempts = hhEmu->stUserSettings.nAutoAttempts;
	stBaseSFSettings.fCursorBlink = hhEmu->stUserSettings.fCursorBlink;
	stBaseSFSettings.fMapPFkeys = hhEmu->stUserSettings.fMapPFkeys;
	stBaseSFSettings.fAltKeypadMode = hhEmu->stUserSettings.fAltKeypadMode;
	stBaseSFSettings.fKeypadAppMode = hhEmu->stUserSettings.fKeypadAppMode;
	stBaseSFSettings.fCursorKeypadMode = hhEmu->stUserSettings.fCursorKeypadMode;
	stBaseSFSettings.fReverseDelBk = hhEmu->stUserSettings.fReverseDelBk;
	stBaseSFSettings.f132Columns = hhEmu->stUserSettings.f132Columns;
	stBaseSFSettings.fDestructiveBk = hhEmu->stUserSettings.fDestructiveBk;
	stBaseSFSettings.fWrapLines = hhEmu->stUserSettings.fWrapLines;
	stBaseSFSettings.fLbSymbolOnEnter = hhEmu->stUserSettings.fLbSymbolOnEnter;
    stBaseSFSettings.fUse8BitCodes = hhEmu->stUserSettings.fUse8BitCodes;
    stBaseSFSettings.fAllowUserKeys = hhEmu->stUserSettings.fAllowUserKeys;
    stBaseSFSettings.nBackspaceKeys = hhEmu->stUserSettings.nBackspaceKeys;

    StrCharCopyN(stBaseSFSettings.acTelnetId, hhEmu->stUserSettings.acTelnetId, EMU_MAX_TELNETID);

	emuLock(hEmu);

	sfPutSessionItem(sessQuerySysFileHdl(hhEmu->hSession),
						SFID_EMU_SETTINGS,
						sizeof(stBaseSFSettings),
						&stBaseSFSettings);

#ifdef INCL_TERMINAL_SIZE_AND_COLORS
	sfPutSessionItem(sessQuerySysFileHdl(hhEmu->hSession),
						SFID_EMU_TEXTCOLOR_SETTING,
						sizeof(hhEmu->stUserSettings.nTextColor),
						&hhEmu->stUserSettings.nTextColor);

	sfPutSessionItem(sessQuerySysFileHdl(hhEmu->hSession),
						SFID_EMU_BKGRNDCOLOR_SETTING,
						sizeof(hhEmu->stUserSettings.nBackgroundColor),
						&hhEmu->stUserSettings.nBackgroundColor);

	sfPutSessionItem(sessQuerySysFileHdl(hhEmu->hSession),
						SFID_EMU_SCRNROWS_SETTING,
						sizeof(hhEmu->stUserSettings.nUserDefRows),
						&hhEmu->stUserSettings.nUserDefRows);

	sfPutSessionItem(sessQuerySysFileHdl(hhEmu->hSession),
						SFID_EMU_SCRNCOLS_SETTING,
						sizeof(hhEmu->stUserSettings.nUserDefCols),
						&hhEmu->stUserSettings.nUserDefCols);
#endif

#if defined(INCL_PRINT_PASSTHROUGH)
	sfPutSessionItem(sessQuerySysFileHdl(hhEmu->hSession),
						SFID_EMU_PRINT_RAW,
						sizeof(hhEmu->stUserSettings.fPrintRaw),
						&hhEmu->stUserSettings.fPrintRaw);
#endif // INCL_PRINT_PASSTHROUGH

	emuUnlock(hEmu);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuLock
 *
 * DESCRIPTION:
 *	Grabs the emulator's critical section semaphore.  Access functions
 *	to the emulator should also call this so we can call emulator
 *	functions from anywhere.
 *
 * ARGUMENTS:
 *	hEmu	- external emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void emuLock(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	EnterCriticalSection(&hhEmu->csEmu);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuUnlock
 *
 * DESCRIPTION:
 *	Releases the emulator's critical section semaphore.
 *
 * ARGUMENTS:
 *	hEmu	- external emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void emuUnlock(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	LeaveCriticalSection(&hhEmu->csEmu);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuGetTxtBuf
 *
 * DESCRIPTION:
 *	Obviously we don't need the handle here but when we do go reentrant,
 *	we only change the guts of this function.  Also, I don't call
 *	emuLock(), emuUnlock() since only termGetUpdate() calls these functions
 *	and at that point the emulator is already locked down.
 *
 * ARGUMENTS:
 *	hEmu	- external emulator handle
 *
 * RETURNS:
 *	pointer to text buf array
 *
 */
ECHAR **emuGetTxtBuf(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hEmu == 0)
		{
		assert(0);
		return 0;
		}

	return hhEmu->emu_apText;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuGetAttrBuf
 *
 * DESCRIPTION:
 *	Obviously we don't need the handle here but when we do go reentrant,
 *	we only change the guts of this function.  Also, I don't call
 *	emuLock(), emuUnlock() since only termGetUpdate() calls these functions
 *	and at that point the emulator is already locked down.
 *
 * ARGUMENTS:
 *	hEmu	- external emulator handle
 *
 * RETURNS:
 *	pointer to attribute buf array
 *
 */
PSTATTR *emuGetAttrBuf(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hEmu == 0)
		{
		assert(0);
		return 0;
		}

	return hhEmu->emu_apAttr;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuKbdIn
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *	0=termkey, -1=not termkey, -2=error
 *
 */
int emuKbdIn(const HEMU hEmu, KEY_T key, const int fTest)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	int iRet;

	if (hEmu == 0)
		{
		assert(0);
		return -2;
		}

	emuLock(hEmu);
	iRet = (*hhEmu->emu_kbdin)(hhEmu, (int)key, fTest);
	emuUnlock(hEmu);
	return iRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuIsEmuKey
 *
 * DESCRIPTION:
 *	Checks to see if the the given key maps to any defined terminal keys.
 *
 * ARGUMENTS:
 *	HEMU hEmu	- External emulator handle.
 *	int key 	- Key to test.
 *
 * RETURNS:
 *	TRUE=termkey, FALSE=not termkey
 *
 */
int emuIsEmuKey(const HEMU hEmu, KEY_T key)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	int iRet;

	if (hEmu == 0)
		{
		assert(0);
		return FALSE;
		}

	if (cnctQueryStatus(sessQueryCnctHdl(hhEmu->hSession)) !=
			CNCT_STATUS_TRUE || IsSessionSuspended(hhEmu->hSession) ||
				hhEmu->stUserSettings.nTermKeys == EMU_KEYS_ACCEL)
		{
		return FALSE;
		}

	emuLock(hEmu);
	iRet = (*hhEmu->emu_kbdin)(hhEmu, (int)key, TRUE);
	emuUnlock(hEmu);
	return (iRet == -1) ? FALSE : TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * emuComDone
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int emuComDone(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hEmu == 0)
		{
		assert(0);
		return -1;
		}

	NotifyClient(hhEmu->hSession, EVENT_TERM_UPDATE, 0L);
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQueryCurPos
 *
 * DESCRIPTION: Returns the row and column position of the current
 *				cursor position.
 *
 * ARGUMENTS:	hEmu	- The External emulator handle.
 *				*row	- A pointer to an integer.
 *				*col	- A pointer to an integer.
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int emuQueryCurPos(const HEMU hEmu, int *row, int *col)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hEmu == 0)
		{
		assert(0);
		return -1;
		}

	emuLock(hEmu);
	*row = hhEmu->emu_currow;
	*col = hhEmu->emu_curcol;
	emuUnlock(hEmu);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQueryCursorType
 *
 * DESCRIPTION:
 *	Returns the current cursor type.
 *
 * ARGUMENTS:
 *	hEmu	- public emulator handle.
 *
 * RETURNS:
 *	The cursor type.
 *
 */
int emuQueryCursorType(const HEMU hEmu)
	{
	int iCurType;
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hEmu == 0)
		{
		assert(0);
		return -1;
		}

	emuLock(hEmu);
	iCurType = hhEmu->iCurType;
	emuUnlock(hEmu);

	return iCurType;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuTrackingNotify
 *
 * DESCRIPTION:
 *	Cloop calls this function when it detects a pause in the data flow.
 *	This allows the client side to track to the cursor position if that
 *	option is enabled.
 *
 * ARGUMENTS:
 *	HEMU hEmu	- External emulator handle.
 *
 * RETURNS:
 *	0
 *
 */
int emuTrackingNotify(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hhEmu == 0)
		{
		assert(FALSE);
		return 0;
		}

	NotifyClient(hhEmu->hSession, EVENT_TERM_TRACK, 0);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQueryClearAttr
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int emuQueryClearAttr(const HEMU hEmu, PSTATTR pstClearAttr)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hhEmu == 0)
		{
		assert(0);
		return -1;
		}

	emuLock(hEmu);
	*pstClearAttr = hhEmu->emu_clearattr_sav;
	emuUnlock(hEmu);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQueryRowsCols
 *
 * DESCRIPTION:
 *	Returns the current number of rows and columns set in the emulator.
 *
 * ARGUMENTS:
 *	hEmu	- public emulator handle
 *	piRows	- pointer to row variable
 *	piCols	- pointer to col variable
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int emuQueryRowsCols(const HEMU hEmu, int *piRows, int *piCols)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hEmu == 0)
		{
		assert(0);
		return -1;
		}

	emuLock(hEmu);
	*piRows = hhEmu->emu_maxrow + 1;
	*piCols = hhEmu->emu_maxcol + 1;

	emuUnlock(hEmu);
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQueryPrintEchoHdl
 *
 * DESCRIPTION: This routine returns the Print handle used for
 *				Printer Echo for the given emulator handle.
 *
 * ARGUMENTS:	hEmu	- The external emulator handle.
 *
 * RETURNS: 	HPRINT	- The External print handle for Printer Echo.
 *
 */
HPRINT emuQueryPrintEchoHdl(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	HPRINT hPrint;

	if (hhEmu == 0)
		{
		assert(FALSE);
		return 0;
		}

	emuLock(hEmu);
	hPrint = hhEmu->hPrintEcho;
	emuUnlock(hEmu);

	return hPrint;
	}

#if 0
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQueryEmuName
 *
 * DESCRIPTION:
 *	Returns the name of the emulator.
 *
 * ARGUMENTS:
 *	hEmu		- The External Emulator Handle.
 *	*acBuffer	- The address of a buffer to receive the information.
 *	nSize		- The size of the buffer.
 *
 * RETURNS:
 *	0=OK else error
 *
 */
int emuQueryName(const HEMU hEmu, TCHAR *achBuffer, int nSize)
	{
	const	HHEMU hhEmu = (HHEMU)hEmu;
	BYTE	*pv;
	BYTE	*temp;
	DWORD	nLen;
	int		indx;
	int		nEmuCount;
	int		nEmuId;

	if (hhEmu == 0)
		{
		*achBuffer = 0;
		assert(FALSE);
		return -1 ;
		}

	emuLock(hEmu);
	nEmuId = hhEmu->stUserSettings.nEmuId;
	emuUnlock(hEmu);

	if (resLoadDataBlock(glblQueryDllHinst(),
							IDT_EMU_NAMES,
							(LPVOID *)&pv, &nLen))
		{
		assert(FALSE);
		return -2;
		}

	nEmuCount = *(RCDATA_TYPE *)pv;
	pv += sizeof(RCDATA_TYPE);

	for (indx = 0 ; indx < nEmuCount ; indx++)
		{
		nLen = (DWORD)StrCharGetByteCount((LPTSTR)pv) + (DWORD)sizeof(BYTE);

		if (nLen == 0)
			{
			assert(FALSE);
			return -3;
			}

		temp = pv + nLen;

		if (*(RCDATA_TYPE *)temp == nEmuId)
			{
			if (StrCharGetByteCount(pv) < nSize)
				{
				StrCharCopyN(achBuffer, pv, nSize);
				break;
				}
			else
				{
				*achBuffer = 0;
				return -4;
				}
			}

		pv += (nLen + (DWORD)sizeof(RCDATA_TYPE));
		}

	return 0;
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQueryEmuName
 *
 * DESCRIPTION:
 *	Returns the name of the emulator.
 *
 * ARGUMENTS:
 *	hEmu		- The External Emulator Handle.
 *	*acBuffer	- The address of a buffer to receive the information.
 *	nSize		- The size of the buffer.
 *
 * RETURNS:
 *	0=OK else error
 *
 */
int emuQueryName(const HEMU hEmu, TCHAR *achBuffer, int nSize)
	{
	const	HHEMU hhEmu = (HHEMU)hEmu;
	TCHAR	achText[256];
	int 	nEmuId,
			nResourceId,
			nLen;

	emuLock(hEmu);
	nEmuId = hhEmu->stUserSettings.nEmuId;
	emuUnlock(hEmu);

	switch(nEmuId)
		{
		case EMU_AUTO:
			nResourceId = IDS_EMUNAME_AUTO;
			break;

		case EMU_ANSI:
			nResourceId = IDS_EMUNAME_ANSI;
			break;

		case EMU_ANSIW:
			nResourceId = IDS_EMUNAME_ANSIW;
			break;

		case EMU_MINI:
			nResourceId = IDS_EMUNAME_MINI;
			break;

		case EMU_VIEW:
			nResourceId = IDS_EMUNAME_VIEW;
			break;

		case EMU_TTY:
			nResourceId = IDS_EMUNAME_TTY;
			break;

		case EMU_VT100:
			nResourceId = IDS_EMUNAME_VT100;
			break;

		case EMU_VT52:
			nResourceId = IDS_EMUNAME_VT52;
			break;

		case EMU_VT100J:
			nResourceId = IDS_EMUNAME_VT100J;
			break;

#if defined(INCL_VT220)
		case EMU_VT220:
			nResourceId = IDS_EMUNAME_VT220;
			break;
#endif

#if defined(INCL_VT320)
		case EMU_VT320:
			nResourceId = IDS_EMUNAME_VT320;
			break;
#endif

#if defined(INCL_VT100PLUS)
		case EMU_VT100PLUS:
			nResourceId = IDS_EMUNAME_VT100PLUS;
			break;
#endif

#if defined(INCL_VTUTF8)
		case EMU_VTUTF8:
			nResourceId = IDS_EMUNAME_VTUTF8;
			break;
#endif

		default:
			assert(FALSE);
			return(-1);
		}

	nLen = LoadString(glblQueryDllHinst(), (unsigned)nResourceId, achText,
		sizeof(achText) / sizeof(TCHAR));

	// Has the caller supplied a large enough buffer.
	//
	if (nSize <= nLen)
		return(-1);

	StrCharCopyN(achBuffer, achText, nSize);

	return(0);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuGetIdFromName
 *
 * DESCRIPTION:
 *	Returns the Id for the supplied emulator name.
 *
 * ARGUMENTS:
 *	hEmu		- The External Emulator Handle.
 *	*acBuffer	- The address of a buffer to receive the information.
 *	nSize		- The size of the buffer.
 *
 * RETURNS:
 *	An emulator ID otherwise (-1) if the function fails.
 *
 */
int emuGetIdFromName(const HEMU hEmu, TCHAR *achEmuName)
	{
	const	HHEMU hhEmu = (HHEMU)hEmu;
	int 	iRet, idx;

	for(idx = 0; idx < NBR_EMULATORS; idx++)
		{
		iRet = StrCharCmp(achEmuName, hhEmu->pstNameTable[idx].acName);

		if (iRet == 0)
			{
			return(hhEmu->pstNameTable[idx].nEmuId);
			}

		}

	return(-1);

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQueryEmulatorId
 *
 * DESCRIPTION:
 *	Returns the oridinal value for the current emulator.  This can be
 *	used through-out the program to write conditional code for emulators.
 *
 * ARGUMENTS:
 *	HEMU	hEmulator - external emulator handle.
 *
 * RETURNS:
 *	ordinal value (>0).
 *
 */
int emuQueryEmulatorId(const HEMU hEmulator)
	{
	const HHEMU hhEmu = (HHEMU)hEmulator;
	int			nEmuId;

	if (hhEmu == 0)
		{
		assert(0);
		return -1;
		}

	emuLock(hEmulator);
	nEmuId = hhEmu->stUserSettings.nEmuId;
	emuUnlock(hEmulator);

	return (nEmuId);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuLoad
 *
 * DESCRIPTION:
 *	 Loads all pertinent tables into memory for the specified emulator.
 *
 * ARGUMENTS:	hEmu	External Emulator Handle.
 *				nEmuId	ID that identifies a specific emulator.
 *				fForceLoad -
 *
 *
 * RETURNS: 	0 if successful.  -1 if nEmuId is invalid.
 *
 */
int emuLoad(const HEMU hEmu, const int nEmuId)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	int col;
	void (*emuInitFunction)(const HHEMU hhEmu);

	if (hEmu == 0)
		{
		assert(0);
		return -2;
		}

	emuLock(hEmu);

	// If the requested emulator is already loaded, return.
	//
	if (hhEmu->nEmuLoaded == nEmuId)
		{
		emuUnlock(hEmu);
		return 0;
		}

	// Validate nEmuId and set set initialization function.

	switch(nEmuId)
		{
		#if defined(INCL_MINITEL)
		case EMU_MINI:
            if (hhEmu->nEmuLoaded == EMU_AUTO && hhEmu->hSession)
                {
                HCOM   hCom = sessQueryComHdl(hhEmu->hSession);
                HCLOOP hCLoop = sessQueryCLoopHdl(hhEmu->hSession);
                HCNCT  hCnct = sessQueryCnctHdl(hhEmu->hSession);

                if (hCom && ComValidHandle(hCom))
                    {
                    int iDataBits = 8;
                    int iParity = NOPARITY;
                    int iStopBits = ONESTOPBIT;
                    ComGetDataBits(hCom, &iDataBits);
                    ComGetParity(hCom, &iParity);
                    ComGetStopBits(hCom, &iStopBits);

                    //
                    // Force the incoming ASCII data to 7 bit.
                    //
                    CLoopSetASCII7(hCLoop, TRUE);

                    if (iDataBits != 7 || iParity != EVENPARITY || iStopBits != ONESTOPBIT)
                        {
                        const HHCNCT hhCnct = (HHCNCT)hCnct;

                        ComSetDataBits(hCom, 7);
                        ComSetParity(hCom, EVENPARITY);
                        ComSetStopBits(hCom, ONESTOPBIT);
                        ComSetAutoDetect(hCom, FALSE);
                        if (hCnct)
                            {
                            HHDRIVER hhDriver = (HHDRIVER)hhCnct->hDriver;

                            if (hhDriver && cncttapiSetLineConfig(hhDriver->dwLine, hCom) == -16)
                                {
                                cnctDisconnect(hCnct, CNCT_DIALNOW | CNCT_XFERABORTCONFIRM);
                                }
                            }
                        }

                    }
                }

			emuInitFunction = emuMinitelInit;
			break;
		#endif

		case EMU_AUTO:
			emuInitFunction = emuAutoInit;
			break;

		case EMU_ANSIW:
		case EMU_ANSI:
			emuInitFunction = emuAnsiInit;
			break;

		case EMU_TTY:
			emuInitFunction = emuAnsiInit;
			break;

		case EMU_VT100J:
		case EMU_VT100:
			emuInitFunction = vt100_init;
			break;

		case EMU_VT52:
			emuInitFunction = vt52_init;
			break;

		#if defined(INCL_VT220)
		case EMU_VT220:
			emuInitFunction = vt220_init;
			break;
		#endif

		#if defined(INCL_VT320)
		case EMU_VT320:
			emuInitFunction = vt220_init;	// The VT320 is the same as the VT220.
			break;
		#endif

		#if defined(INCL_VT100PLUS)
		case EMU_VT100PLUS:
			emuInitFunction = vt100_init;	// The VT100+ is the same as the VT100.
			break;
		#endif

		#if defined(INCL_VTUTF8)
		case EMU_VTUTF8:
			emuInitFunction = vtutf8_init;
			break;
		#endif

		#if defined(INCL_VIEWDATA)
		case EMU_VIEW:
			emuInitFunction = EmuViewdataInit;
			break;
		#endif

		default:
			emuUnlock(hEmu);
			return(-1);
		}

	// Remove the current emulator, if one is loaded.
	//
	if (hhEmu->emu_deinstall)
		(*hhEmu->emu_deinstall)(hhEmu);

	// Save the new emulator Id.
	//
	hhEmu->stUserSettings.nEmuId = nEmuId;
	hhEmu->nEmuLoaded = nEmuId;

	// setup function pointers to standard routines.

	hhEmu->EmuSetCursorType = EmuStdSetCursorType;
	hhEmu->emuResetTerminal = stdResetTerminal;
	hhEmu->emu_graphic 		= emuStdGraphic;
#if defined(EXTENDED_FEATURES)	
	hhEmu->emu_datain 		= emuStdDataIn;
#else
	hhEmu->emu_datain 		= emuDataIn;
#endif
	hhEmu->emu_kbdin 		= std_kbdin;
	hhEmu->emu_getscrsize 	= std_getscrsize;
#ifdef INCL_TERMINAL_SIZE_AND_COLORS
    hhEmu->emu_setscrsize	= std_setscrsize;
#endif
	hhEmu->emu_getscrollcnt = std_getscrollcnt;
	hhEmu->emu_getcurpos 	= std_getcurpos;
	hhEmu->emu_setcurpos 	= std_setcurpos;
	hhEmu->emu_getattr 		= std_getattr;
	hhEmu->emu_setattr 		= std_setattr;
	hhEmu->emu_setcolors 	= std_setcolors;
	hhEmu->emu_getcolors 	= std_getcolors;
	hhEmu->emu_initcolors 	= std_initcolors;
	hhEmu->emu_clearscreen 	= std_clearscreen;
	hhEmu->emu_clearline 	= std_clearline;
	hhEmu->emu_clearrgn 	= std_clearrgn;
	hhEmu->emu_scroll 		= std_scroll;
	hhEmu->emu_deinstall 	= std_deinstall;
	hhEmu->emu_ntfy 		= std_emu_ntfy;
	hhEmu->emuHomeHostCursor= std_HomeHostCursor;

	hhEmu->emu_maxrow 		= EMU_DEFAULT_MAXROW;
	hhEmu->emu_maxcol 		= EMU_DEFAULT_MAXCOL;
    hhEmu->bottom_margin    = hhEmu->emu_maxrow;    // mrw:2/21/96
    hhEmu->top_margin       = 0;                    // mrw:2/21/96

	hhEmu->emu_charattr 	= hhEmu->attrState[CS_STATE];

	hhEmu->emu_clearattr =
	hhEmu->emu_clearattr_sav = hhEmu->attrState[CSCLEAR_STATE];

	// Initialize mode variables.
	//
	hhEmu->mode_KAM = RESET;	   /* Enable Keyboard */
	hhEmu->mode_IRM = RESET;	   /* Replace chars rather than insert */
	hhEmu->mode_VEM = RESET;	   /* Inserting lines scrolls down, not up */
	hhEmu->mode_HEM = RESET;	   /* Inserting chars scrolls right, not left */
	hhEmu->mode_SRM = SET;		   /* Send-Receive. No local character echo */
	hhEmu->mode_LNM = RESET;	   /* LF moves vertically only */
	hhEmu->mode_DECOM = RESET;	   /* Absolute cursor positioning */
	hhEmu->mode_DECPFF = RESET;    /* No form feed after screen prINT */
	hhEmu->mode_DECPEX = RESET;    /* PrINT only scroll rgn. on screen prINT */
	hhEmu->mode_DECSCNM = RESET;   /* Screen mode. RESET=normal vid, SET=reverse vid */
	hhEmu->mode_DECTCEM = SET;	   /* Cursor enable. RESET=hidden, SET=visible */
	hhEmu->mode_25enab = RESET;    /* When true (SET), emulator can use 25th line */
	hhEmu->mode_protect = RESET;   /* When true (SET), protected mode is on */
	hhEmu->mode_block = RESET;	   /* When true (SET), block mode is on */
	hhEmu->mode_local = RESET;	   /* When true (SET), block mode is on */
	hhEmu->print_echo = FALSE;

	// Initialize state table.
	//
	hhEmu->emu_highchar = 0x7F;

	// Set default tab stops to 8.
	//
	//for (col = 0; col <= EMU_DEFAULT_MAXCOL; ++col)
	// Need to define tab stops for the whole screen so received tabs
	// with cursor at column 72 or more will go to the next tab rather
	// than the right edge of the screen. 22 Apr 99 rde
	for (col = 0; col < MAX_EMUCOLS; ++col)
		{
		if (!(col % 8))
			hhEmu->tab_stop[col] = TRUE;
		}

	// Call initialization function for emulator.
	//
	(*emuInitFunction)(hhEmu);

	// Paints every cell with the new attributes...
	//
	std_initcolors(hhEmu);

#ifdef INCL_TERMINAL_SIZE_AND_COLORS
    // Update the screen size.
    //
    hhEmu->emu_setscrsize(hhEmu);
#endif

	// We want the terminal to read the emulator image after loading
	// but we don't want a scroll operation so update each line
	// individually - mrw

	updateLine(sessQueryUpdateHdl(hhEmu->hSession), 0, hhEmu->emu_maxrow);

	NotifyClient(hhEmu->hSession, EVENT_EMU_CLRATTR, 0);
	NotifyClient(hhEmu->hSession, EVENT_EMU_SETTINGS, 0);
	NotifyClient(hhEmu->hSession, EVENT_TERM_UPDATE, 0);

	emuUnlock(hEmu);

	PostMessage(sessQueryHwndStatusbar(hhEmu->hSession),
		SBR_NTFY_REFRESH, (WPARAM)SBR_EMU_PART_NO, 0);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQuerySettings
 *
 * DESCRIPTION:
 *	This function returns a copy of the of the User Settings structure
 *	found in the internal emulator handle.
 *
 * ARGUMENTS:
 *	HEMU		-	The External emulator handle.
 *	PSTEMUSET	-	A pointer to a structure of type STEMUSET
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int emuQuerySettings(const HEMU hEmu, PSTEMUSET pstSettings)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hhEmu == 0)
		{
		assert(0);
		return -1;
		}

	emuLock(hEmu);
	MemCopy(pstSettings, &hhEmu->stUserSettings, sizeof(STEMUSET));
	emuUnlock(hEmu);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuSetSettings
 *
 * DESCRIPTION:
 *	This function stores the Emulator Settings in the internal Emualtor
 *	handle.  This function DOES NOT save the information in the session
 *	file.  The values to be set are validated.  If any values passed
 *	into this routine are invalid, default values will be set.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *	0 if the values passed in are validated.  A number less than 0 will
 *	be returned if any one of the values are invalid.  Note that in the 
 *	case of several invalid settings, the return value will point only
 *	to the last one that was invalid.
 *
 */
int emuSetSettings(const HEMU hEmu, const PSTEMUSET pstSettings)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	int iReturn;

	if (hhEmu == 0)
		{
		assert(0);
		return -1;
		}

	iReturn = 0;

	switch(pstSettings->nEmuId)
		{
		case EMU_AUTO:
		case EMU_ANSI:
		case EMU_ANSIW:
		case EMU_MINI:
		case EMU_VIEW:
		case EMU_TTY:
		case EMU_VT100:
		case EMU_VT100J:
		case EMU_VT52:
		case EMU_VT220:
		case EMU_VT320:
		case EMU_VT100PLUS:
		case EMU_VTUTF8:
			break;
		default:
			pstSettings->nEmuId = EMU_AUTO;
			iReturn = -1;
			assert(FALSE);
			break;
		}

	switch(pstSettings->nTermKeys)
		{
		case EMU_KEYS_ACCEL:
		case EMU_KEYS_TERM:
		case EMU_KEYS_SCAN:
			break;
		default:
			pstSettings->nTermKeys = EMU_KEYS_TERM;
			iReturn = -2;
			assert(FALSE);
			break;
		}

	switch(pstSettings->nCursorType)
		{
		case EMU_CURSOR_BLOCK:
		case EMU_CURSOR_LINE:
		case EMU_CURSOR_NONE:
			break;
		default:
			pstSettings->nCursorType = EMU_CURSOR_LINE;
			iReturn = -3;
			assert(FALSE);
			break;
		}

	switch(pstSettings->nCharacterSet)
		{
		case EMU_CHARSET_ASCII:
		case EMU_CHARSET_UK:
		case EMU_CHARSET_SPECIAL:
#if defined(INCL_VT220)
		case EMU_CHARSET_MULTINATIONAL:	
		case EMU_CHARSET_FRENCH:			
		case EMU_CHARSET_FRENCHCANADIAN:	
		case EMU_CHARSET_GERMAN:			
#endif
			break;
		default:
			pstSettings->nCharacterSet = EMU_CHARSET_ASCII;
			iReturn = -4;
			assert(FALSE);
			break;
		}

	// The values to be set have been validated.  Set the emulator handle
	// values, and the internal emualtor variables that correspond.
	//
	emuLock(hEmu);

#ifdef INCL_TERMINAL_SIZE_AND_COLORS
	if (pstSettings->nTextColor != hhEmu->stUserSettings.nTextColor ||
			pstSettings->nBackgroundColor != hhEmu->stUserSettings.nBackgroundColor)
		{
		// The user defined colors have changed--implement them.
		std_setcolors(hhEmu, 
				pstSettings->nTextColor,
				pstSettings->nBackgroundColor);
		}
#endif

	// When called from emuInitializeHdl, the source and dest pointers
	// for the following call are the same, so there's no need to
	// to do the copy.
	//
	if(&hhEmu->stUserSettings != pstSettings)
		MemCopy(&hhEmu->stUserSettings, pstSettings, sizeof(STEMUSET));

	hhEmu->iCurType = hhEmu->stUserSettings.nCursorType;
	hhEmu->mode_AWM = hhEmu->stUserSettings.fWrapLines;
	hhEmu->mode_DECKPAM = hhEmu->stUserSettings.fKeypadAppMode;
	hhEmu->mode_DECCKM = hhEmu->stUserSettings.fCursorKeypadMode;

	hhEmu->fUse8BitCodes = hhEmu->stUserSettings.fUse8BitCodes;
	hhEmu->fAllowUserKeys = hhEmu->stUserSettings.fAllowUserKeys;

	// Call emuSetDecColumns only if the emulator is a VT100, and
	// there has been change in the user setting of 132 column mode.
	//
	emuSetDecColumns(hhEmu,
						hhEmu->stUserSettings.f132Columns ?
						VT_MAXCOL_132MODE :
						VT_MAXCOL_80MODE,
						FALSE);

#ifdef INCL_TERMINAL_SIZE_AND_COLORS
    // Set the possible new row and column values if
    // the emulator is not about to change.
    //
    hhEmu->emu_setscrsize(hhEmu);
#endif

	emuUnlock(hEmu);

	NotifyClient(hhEmu->hSession, EVENT_EMU_SETTINGS, 0);
    //JMH 01-09-97 These two events also need to be sent, says JCM.
    //
    NotifyClient(hhEmu->hSession, EVENT_TERM_UPDATE, 0);
    NotifyClient(hhEmu->hSession, EVENT_EMU_CLRATTR, 0);

	return(iReturn);
	}

#if defined(EXTENDED_FEATURES)	//TODO:rde 23 mar 98
	// When we're comfortable enough with changing to using a function
	// pointer here, do it for all builds.
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emuDataIn
 *
 * DESCRIPTION:
 *  External entry point for incoming data.
 *
 * ARGUMENTS:
 *  hEmu    - public emulator handle
 *  ccode   - character code
 *
 * RETURNS:
 *  TRUE if displayable
 *
 */
int emuDataIn(const HEMU hEmu, const ECHAR ccode)
    {
	int iRetVal = TRUE;
    const HHEMU hhEmu = (HHEMU)hEmu;

	if (hhEmu == 0)
		{
		assert(FALSE);
		}
	else
		{
    	emuLock(hEmu);

	    CaptureChar(sessQueryCaptureFileHdl(hhEmu->hSession),
					    CPF_MODE_RAW,
					    ccode); //moved from emuStdDataIn 05AUG98 mpt
        emuUnlock(hEmu);

        iRetVal = (*hhEmu->emu_datain)(hhEmu, ccode);
		}

	return iRetVal;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuStdDataIn
 *
 * DESCRIPTION:
 *	 Processes passed in codes through the emulation state tables.
 *
 * ARGUMENTS:
 *	hhEmu	- The internal emulator handle.
 *	ccode	- The character to process.
 *
 * RETURNS:
 *	 TRUE if displayable character
 */
int emuStdDataIn(const HHEMU hhEmu, const ECHAR ccode)
	{
	//ECHAR echCode;
	int ntrans;
	struct trans_entry *tptr;

	emuLock((HEMU)hhEmu);

	hhEmu->emu_code = ETEXT(ccode);

	// Capture raw data.
	//
#if 0 //moved to emuDataIn to prevent characters being captures
      //multiple times due to the re-entrant nature of this function. - mpt 5aug98
    CaptureChar(sessQueryCaptureFileHdl(hhEmu->hSession),
					CPF_MODE_RAW,
					ccode);
#endif
	// Seek next state by finding character range.
	//
	tptr = hhEmu->state_tbl[hhEmu->state].first_trans;
	ntrans = hhEmu->state_tbl[hhEmu->state].number_trans;

	for (; ntrans > 0; ntrans--, ++tptr)
		if (ccode >= tptr->lochar && ccode <= tptr->hichar)
			break;

	if (ntrans <= 0)
		{
		// Added to handle the case of 2 successive ESC chars--just
		// the 1st ESC should be thrown away

		hhEmu->state = 0;
		tptr = hhEmu->state_tbl[hhEmu->state].first_trans;
		ntrans = hhEmu->state_tbl[hhEmu->state].number_trans;

		for (; ntrans > 0; ntrans--, ++tptr)
			{
			if (ccode >= tptr->lochar && ccode <= tptr->hichar)
				break;
			}

		// 6-14-83
		// second condition (below) added to allow emulator to toss invalid
		// escpae sequences (i.e.ESC [ 0v).

		if (ntrans <= 0 || tptr->next_state == 0)
			{
			commanderror(hhEmu);
			goto DataInExit;
			}

		else
			{
			CaptureChar(sessQueryCaptureFileHdl(hhEmu->hSession),
						CF_CAP_CHARS, ccode);
			printEchoChar(hhEmu->hPrintEcho, ccode);
			}
		}

	hhEmu->state = tptr->next_state;
	(*tptr->funct_ptr)(hhEmu);

	// The code has been process through the emulator.	Check for
	// capturing and printing, and reset other emulator values.
	//
	if (hhEmu->state == 0)
		{
		if (IN_RANGE(ccode, ETEXT(' '), hhEmu->emu_highchar) ||
						ccode == ETEXT('\r') ||
						ccode == ETEXT('\n'))
			{
			CaptureChar(sessQueryCaptureFileHdl(hhEmu->hSession),
						CF_CAP_CHARS, ccode);
			printEchoChar(hhEmu->hPrintEcho, ccode);
			}
		hhEmu->num_param_cnt = hhEmu->selector_cnt =
		hhEmu->selector[0] = hhEmu->num_param[0] = 0;

		hhEmu->DEC_private = FALSE;
		}

	DataInExit:

	emuUnlock((HEMU)hhEmu);

	return(TRUE);
	}
//#if FALSE
#else
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDataIn
 *
 * DESCRIPTION:
 *	 Processes passed in codes through the emulation state tables.
 *
 * ARGUMENTS:
 *	hhEmu	- The internal emulator handle.
 *	ccode	- The character to process.
 *
 * RETURNS:
 *	 TRUE if displayable character
 */
int emuDataIn(const HEMU hEmu, const ECHAR ccode)
	{
	//ECHAR echCode;
	int ntrans;
	struct trans_entry *tptr;
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hhEmu == 0)
		{
		assert(FALSE);
		goto DataInExit;
		}

	emuLock(hEmu);

	hhEmu->emu_code = ETEXT(ccode);

	// Capture raw data.
	//
	CaptureChar(sessQueryCaptureFileHdl(hhEmu->hSession),
					CPF_MODE_RAW,
					ccode);

	// Seek next state by finding character range.
	//
	tptr = hhEmu->state_tbl[hhEmu->state].first_trans;
	ntrans = hhEmu->state_tbl[hhEmu->state].number_trans;

	for (; ntrans > 0; ntrans--, ++tptr)
		if (ccode >= tptr->lochar && ccode <= tptr->hichar)
			break;

	if (ntrans <= 0)
		{
		// Added to handle the case of 2 successive ESC chars--just
		// the 1st ESC should be thrown away

		hhEmu->state = 0;
		tptr = hhEmu->state_tbl[hhEmu->state].first_trans;
		ntrans = hhEmu->state_tbl[hhEmu->state].number_trans;

		for (; ntrans > 0; ntrans--, ++tptr)
			{
			if (ccode >= tptr->lochar && ccode <= tptr->hichar)
				break;
			}

		// 6-14-83
		// second condition (below) added to allow emulator to toss invalid
		// escpae sequences (i.e.ESC [ 0v).

		if (ntrans <= 0 || tptr->next_state == 0)
			{
			commanderror(hhEmu);
			goto DataInExit;
			}

		else
			{
			CaptureChar(sessQueryCaptureFileHdl(hhEmu->hSession),
						CF_CAP_CHARS, ccode);
			printEchoChar(hhEmu->hPrintEcho, ccode);
			}
		}

	hhEmu->state = tptr->next_state;
	(*tptr->funct_ptr)(hhEmu);

	// The code has been process through the emulator.	Check for
	// capturing and printing, and reset other emulator values.
	//
	if (hhEmu->state == 0)
		{
		if (IN_RANGE(ccode, ETEXT(' '), hhEmu->emu_highchar) ||
						ccode == ETEXT('\r') ||
						ccode == ETEXT('\n'))
			{
			CaptureChar(sessQueryCaptureFileHdl(hhEmu->hSession),
						CF_CAP_CHARS, ccode);
			printEchoChar(hhEmu->hPrintEcho, ccode);
			}
		hhEmu->num_param_cnt = hhEmu->selector_cnt =
		hhEmu->selector[0] = hhEmu->num_param[0] = 0;

		hhEmu->DEC_private = FALSE;
		}

	DataInExit:

	emuUnlock(hEmu);

	return(TRUE);
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuNotify
 *
 * DESCRIPTION:
 *	A function that can be called to notify the emulators of an event.
 *	As events are identified, they can be added to this function.
 *
 * ARGUMENTS:
 *	hEmu	-	The external emulator handle.
 *	nEvent	-	The event ID.
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int emuNotify(const HEMU hEmu, const int nEvent)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hhEmu == 0)
		{
		assert(FALSE);
		return -1;
		}

	emuLock(hEmu);

	switch(nEvent)
		{
		case EMU_EVENT_CONNECTED:
			hhEmu->fWasConnected = TRUE;
			break;

		case EMU_EVENT_DISCONNECTED:
			if (hhEmu->stUserSettings.nEmuId == EMU_AUTO)
				{
				if (hhEmu->fWasConnected)
					hhEmu->stUserSettings.nAutoAttempts++;

				if (hhEmu->stUserSettings.nAutoAttempts ==
						EMU_MAX_AUTODETECT_ATTEMPTS)
#if !defined(FAR_EAST)
					emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
					emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
				}

			hhEmu->fWasConnected = FALSE;
			break;

		default:
			break;
		}

	(*hhEmu->emu_ntfy)(hhEmu, nEvent);
	emuUnlock(hEmu);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuHomeHostCursor
 *
 * DESCRIPTION:
 *	Homes the cursor.  Needed when we first load a session.  Incidently,
 *	homing the cursor for a minitel places the cursor at 1,0, not 0,0
 *	which is why this function exists.
 *
 * ARGUMENTS:
 *	hEmu	- public emulator handle.
 *
 * RETURNS:
 *	0=OK,else error
 *
 */
int emuHomeHostCursor(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;

	if (hhEmu == 0)
		{
		assert(0);
		return -1;
		}

	return (*hhEmu->emuHomeHostCursor)(hhEmu);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuEraseTerminalScreen
 *
 * DESCRIPTION:
 *	Erases emulator image, doesn't put stuff in the backscroll.
 *
 * ARGUMENTS:
 *	hEmu	- public emulator handle.
 *
 * RETURNS:
 *	0=OK,else error
 *
 */
int emuEraseTerminalScreen(const HEMU hEmu)
	{
	const HHEMU hhEmu = (HHEMU)hEmu;
	int i;

	if (hhEmu == 0)
		{
		assert(0);
		return -1;
		}

	for (i = 0 ; i <= hhEmu->emu_maxrow ; ++i)
		clear_imgrow(hhEmu, i);

	updateLine(sessQueryUpdateHdl(hhEmu->hSession), 0, hhEmu->emu_maxrow);

	// The notify function is used to in minitel to set the state
	// of the screen based on connection status (F or C in upper corner).
	//
	hhEmu->emu_ntfy(hhEmu, 0);
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuQueryDefaultTelnetId
 *
 * DESCRIPTION:
 *	Gets the default telnet terminal id string for the given emulator.
 *
 * ARGUMENTS:
 *	nEmuId	    - id of the emulator (e.g. EMU_ANSI).
 *  achTelnetId - pointer to the buffer for the string.
 *  nSize       - size of the buffer (in characters).
 *
 * RETURNS:
 *	0=OK, else error
 *
 * AUTHOR:  C. Baumgartner, 11/15/96
 */
int emuQueryDefaultTelnetId(const int nEmuId, TCHAR *achTelnetId, int nSize)
    {
    int     iRet = 0;
    TCHAR * pszDefaultId;

    // Note : Since these strings are a part of the telnet
    // protocol, it is okay if they are hard-coded.
    //
    switch(nEmuId)
        {
    case EMU_AUTO:
    case EMU_ANSI:
        pszDefaultId = TEXT("ANSI");
        break;

    case EMU_TTY:
        pszDefaultId = TEXT("TELETYPE-33");
        break;

    case EMU_VT52:
        pszDefaultId = TEXT("VT52");
        break;

#if defined(INCL_VT220)
    case EMU_VT220:
        pszDefaultId = TEXT("VT220");
        break;
#endif

#if defined(INCL_VT320)
    case EMU_VT320:
        pszDefaultId = TEXT("VT320");
        break;
#endif

#if defined(INCL_VT100PLUS)
    case EMU_VT100PLUS:
        pszDefaultId = TEXT("VT100+");
        break;
#endif

#if defined(INCL_VTUTF8)
    case EMU_VTUTF8:
        pszDefaultId = TEXT("VT-UTF8");
        break;
#endif

    case EMU_VT100:
    default:
        pszDefaultId = TEXT("VT100");
        break;
        }

    if ( StrCharGetStrLength(pszDefaultId) < nSize )
        {
        StrCharCopyN(achTelnetId, pszDefaultId, nSize);
        iRet = 0;
        }
    else
        {
        iRet = -1;
        }

    return iRet;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuLoadDefaultTelnetId
 *
 * DESCRIPTION:
 *	Loads the given emulator handle with the default telnet terminal id
 *  string for the current emulator type.
 *
 * ARGUMENTS:
 *	hEmu - A public emulator handle
 *
 * RETURNS:
 *	0=OK, else error
 *
 * AUTHOR:  C. Baumgartner, 11/18/96
 */
int emuLoadDefaultTelnetId(const HEMU hEmu)
    {
    HHEMU hhEmu = (HHEMU)hEmu;

    return emuQueryDefaultTelnetId(hhEmu->stUserSettings.nEmuId,
        hhEmu->stUserSettings.acTelnetId, EMU_MAX_TELNETID);
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuLoadSettings
 *
 * DESCRIPTION:
 *	Loads the given emulator user settings.
 *
 * ARGUMENTS:
 *	hhEmu - an internal emulator handle
 *	uiId - the SFID of the data to load
 *	ulDataSize - the size of the data to load (in bytes)
 *	pvData - address at which to put the data
 *
 * RETURNS:
 *	The size (in bytes) of the data loaded, -1 if an error occured
 *
 * AUTHOR:	Bob Everett - 6 Jun 1998 
 */
STATIC_FUNC int emuLoadSettings(const HHEMU hhEmu, 
								const unsigned int uiId,
								unsigned long ulDataSize,
								void *pvData)
    {
	int iResult = 0;
	int iRetVal = 0;
	unsigned long ulSize = 0;

	// Do the screen color settings exist?
	sfGetSessionItem(sessQuerySysFileHdl(hhEmu->hSession), uiId, &ulSize, 0);

	if (ulSize > 0)
		{
		// The settings exist. Go get them.
		iResult = sfGetSessionItem(sessQuerySysFileHdl(hhEmu->hSession),
				uiId, &ulDataSize, pvData);

		if (iResult != 0)
			iRetVal = -1;
		else
			iRetVal = (int)ulSize;
		}

	return iRetVal;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuCheckSettings
 *
 * DESCRIPTION:
 *	This ugly piece of code checks for a mismatch in settings between versions.
 *	The settings affected are fUse8BitCodes, fAllowUserKeys, nBackspaceKeys,
 *	and acTelnetId. The mismatch occurs when moving an HTPE3 session file to
 *	any newer version. This includes HT98 and HTPE4. 
 *
 * ARGUMENTS:
 *	hhEmu - an internal emulator handle
 *
 * RETURNS:
 *	Nada, zip, not a thing.
 *
 * AUTHOR:	Bob Everett - 8 Jun 1998 
 */
STATIC_FUNC void emuCheckSettings(struct stEmuBaseSFSettings *pstBaseSFSettings) 
    {
	TCHAR *psz = 0;
	TCHAR sz[EMU_MAX_TELNETID];

	if ((pstBaseSFSettings->nBackspaceKeys != EMU_BKSPKEYS_CTRLH) &&
			(pstBaseSFSettings->nBackspaceKeys != EMU_BKSPKEYS_DEL) &&
			(pstBaseSFSettings->nBackspaceKeys != EMU_BKSPKEYS_CTRLHSPACE))
		{
		// This is the best test for this scenario. Move the data.
		psz = (TCHAR *)&pstBaseSFSettings->fAllowUserKeys;
		if (StrCharGetStrLength(psz) < EMU_MAX_TELNETID)
			{
			StrCharCopyN(sz, psz, sizeof(sz) / sizeof(TCHAR));
			StrCharCopyN(pstBaseSFSettings->acTelnetId, sz, EMU_MAX_TELNETID );
			}

		pstBaseSFSettings->nBackspaceKeys = 
				pstBaseSFSettings->fUse8BitCodes;

		// Use the defaults.
		pstBaseSFSettings->fUse8BitCodes = FALSE;
		pstBaseSFSettings->fAllowUserKeys = FALSE;
		}
		
	// Check the data.
	if ((pstBaseSFSettings->fUse8BitCodes != TRUE) &&
			(pstBaseSFSettings->fUse8BitCodes != FALSE))
		pstBaseSFSettings->fUse8BitCodes = FALSE;

	if ((pstBaseSFSettings->fAllowUserKeys != TRUE) &&
			(pstBaseSFSettings->fAllowUserKeys != FALSE))
		pstBaseSFSettings->fAllowUserKeys = FALSE;

	if ((pstBaseSFSettings->nBackspaceKeys != EMU_BKSPKEYS_CTRLH) &&
			(pstBaseSFSettings->nBackspaceKeys != EMU_BKSPKEYS_DEL) &&
			(pstBaseSFSettings->nBackspaceKeys != EMU_BKSPKEYS_CTRLHSPACE))
		{
		pstBaseSFSettings->nBackspaceKeys = EMU_BKSPKEYS_CTRLH;

		// Assume that if nBackspaceKeys is messed up, so is acTelnetId.
	    pstBaseSFSettings->acTelnetId[0] = TEXT('\0');
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\emu_std.c ===
/*	File: D:\WACKER\emu\emu_std.c (Created: 08-Dec-1993)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 5 $
 *	$Date: 5/21/02 10:28a $
 */
#include <windows.h>
#pragma hdrstop

// #define DEBUGSTR

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\assert.h>
#include <tdll\chars.h>
#include <tdll\cloop.h>
#include <tdll\mc.h>
#include <tdll\session.h>
#include <tdll\backscrl.h>
#include <tdll\com.h>
#include <tdll\capture.h>
#include <tdll\print.h>
#include <tdll\update.h>
#include <tdll\htchar.h>
#include <xfer\xfer.h>

#include "emu.h"
#include "emu.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	stdResetTerminal
 *
 * DESCRIPTION:
 *	Had to add a vector for reset terminal.  Reset functions appear to be
 *	in most emulators but not all and were never assigned a function
 *	pointer.  I've done this and have made a standard "stub" function
 *	for those emulators that don't have such a function.
 *
 * ARGUMENTS:
 *	BOOL
 *
 * RETURNS:
 *	0
 *
 */
/* ARGSUSED */
int stdResetTerminal(const HHEMU hhEmu, const int fHost)
	{
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *  hhEmu - Private emulator handle.
 *  kcode - The key to examine.
 *  fTest - TRUE if we only want to test the key.
 *
 * RETURNS:
 *  0 if we can process the key, -1 otherwise.
 *
 */
int std_kbdin(const HHEMU hhEmu, int kcode, const int fTest)
	{
	static const int KeyBreak    = VK_CANCEL|VIRTUAL_KEY|CTRL_KEY;
	static const int KeyExtBreak = VK_CANCEL|VIRTUAL_KEY|CTRL_KEY|EXTENDED_KEY;
	static const int KeyBreakNT	 = VK_CANCEL|EXTENDED_KEY;
	static const int KeyAltBreak = VK_PAUSE |VIRTUAL_KEY|ALT_KEY;

	ECHAR            eChar;
    HCLOOP           hCloop = sessQueryCLoopHdl(hhEmu->hSession);

    if (fTest)
        {
        // The backspace key is a special case. We must convert it to
        // whatever the user has specified in the "Settings" properties
        // page. So, if we are testing for backspace, return 0. This
        // ensures that we get called again with fTest set to FALSE. When
        // this happens we will process the key. - cab:11/18/96
        //
        if (kcode == VK_BACKSPACE)
            {
#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
            return 0;
#else
            return -1;
#endif
            }
        // We also process the break key.
        //
        else if (kcode == KeyBreak || kcode == KeyExtBreak || 
				kcode == KeyAltBreak || kcode == KeyBreakNT)
            {
            return 0;
            }
        else
            {
            return -1;
            }
        }

    // Process the backspace key according to the user setting
    // in the "Settings" properties page. - cab:11/18/96
    //
    if (kcode == VK_BACKSPACE)
        {
#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
		switch(hhEmu->stUserSettings.nBackspaceKeys)
			{
		case EMU_BKSPKEYS_CTRLH:
            CLoopCharOut(hCloop, TEXT('\x08'));
			break;

		case EMU_BKSPKEYS_DEL:
            CLoopCharOut(hCloop, TEXT('\x7F'));
			break;

		case EMU_BKSPKEYS_CTRLHSPACE:
            CLoopCharOut(hCloop, TEXT('\x08'));
            CLoopCharOut(hCloop, TEXT('\x20'));
            CLoopCharOut(hCloop, TEXT('\x08'));
			break;

		default:
			assert(0);
			break;
			}
#endif
		return -1;
        }
    // Process the break key.
    //
    else if (kcode == KeyBreak || kcode == KeyExtBreak || kcode == KeyBreakNT)
        {
		ComDriverSpecial(sessQueryComHdl(hhEmu->hSession), "Send Break", NULL, 0);
		return -1;
		}
	else if (kcode == KeyAltBreak)
		{
		ComDriverSpecial(sessQueryComHdl(hhEmu->hSession), "Send IP", NULL, 0);
		return -1;
        }
    //
    // Processing for the enter key
    //

    else if (kcode == TEXT('\x0D') ||
		     kcode == (VK_RETURN | VIRTUAL_KEY))
        {
        CLoopCharOut(hCloop, TEXT('\x0D'));

		//
		// Make sure to add the line feed ('\n' or '\x0A')
		// with line ends ('\r' or '\x0D') if the ASCII
		// settings are set for this option. REV: 5/16/2002
		//
		if (CLoopGetAddLF(hCloop))
			{
			CLoopCharOut(hCloop, TEXT('\x0A'));
			}
        return (-1);
        }

    //
    // processing for the for the escape key
    //

    else if (kcode == (VK_ESCAPE | VIRTUAL_KEY))
        {
        CLoopCharOut(hCloop, TEXT('\x1B'));
        return (-1);
        }

    //
    // processing for the for the tab key
    //

    else if (kcode == (VK_TAB | VIRTUAL_KEY))
        {
        CLoopCharOut(hCloop, TEXT('\x09'));
        return (-1);
        }

    // Throw away any other virtual keys.
    //
	else if (kcode & VIRTUAL_KEY)
		{
		return -1;
		}

    // Send any other characters out the port.
    //    
	eChar = (ECHAR)kcode;
	CLoopCharOut(hCloop, (UCHAR)(eChar & 0x00FF));
	return -1;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * std_getscrollcnt
 *
 * DESCRIPTION: Tells caller how many lines the screen has scrolled since
 *				the last request.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
int std_getscrollcnt(const HHEMU hhEmu)
	{
	const int retval = hhEmu->scr_scrollcnt;

	hhEmu->scr_scrollcnt = 0;

	return(retval);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void std_getscrsize(const HHEMU hhEmu, int *rows, int *cols)
	{
	*rows = hhEmu->emu_maxrow + 1;
	*cols = hhEmu->emu_maxcol + 1;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void std_getcurpos(const HHEMU hhEmu, int *row, int *col)
	{
	*row = hhEmu->emu_currow;
	*col = hhEmu->emu_curcol;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * std_setcurpos
 *
 * DESCRIPTION:
 *	 Moves the cursor to the specified position on the virtual screen.
 *	 If the cursor is beyond the end of existing text, the virtual screen
 *	 line is filled out with spaces. If the cursor is beyond the edges of
 *	 the video display, the video cursor is placed as close as possible
 *	 to the desired position as the cursor display is changed.
 *
 * ARGUMENTS:
 *	 iRow -- virtual screen row to move cursor to
 *	 iCol -- virtual screen col to move cursor to
 *
 * RETURNS:
 *	 nothing
 */
void std_setcurpos(const HHEMU hhEmu, const int iRow, const int iCol)
	{
	hhEmu->emu_currow = max(min(iRow, hhEmu->emu_maxrow), 0);
	hhEmu->emu_curcol = max(min(iCol, hhEmu->emu_maxcol), 0);

	updateCursorPos(sessQueryUpdateHdl(hhEmu->hSession),
					hhEmu->emu_currow,
					hhEmu->emu_curcol);

	hhEmu->emu_imgrow = row_index(hhEmu, hhEmu->emu_currow);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
STATTR std_getattr(const HHEMU hhEmu)
	{
	return hhEmu->attrState[CS_STATE];
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void std_setattr(const HHEMU hhEmu, PSTATTR pstAttr)
	{
	assert(pstAttr);

	hhEmu->attrState[CS_STATE] = *pstAttr;
	hhEmu->attrState[CSCLEAR_STATE] = *pstAttr;

	hhEmu->emu_charattr = *pstAttr;
	hhEmu->emu_clearattr = *pstAttr;

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void std_setcolors(const HHEMU hhEmu, const int fore, const int back)
	{
	hhEmu->attrState[CSCLEAR_STATE].txtclr = (unsigned)fore;
	hhEmu->attrState[CSCLEAR_STATE].bkclr  = (unsigned)back;
	hhEmu->emu_clearattr = hhEmu->attrState[CSCLEAR_STATE];
	hhEmu->emu_clearattr_sav = hhEmu->emu_clearattr;

	hhEmu->attrState[CS_STATE].txtclr = (unsigned)fore;
	hhEmu->attrState[CS_STATE].bkclr  = (unsigned)back;

	if (hhEmu->iCurAttrState == CS_STATE)
		hhEmu->emu_charattr = hhEmu->attrState[CS_STATE];

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void std_getcolors(const HHEMU hhEmu, int *fore, int *back)
	{
	*fore = hhEmu->attrState[hhEmu->iCurAttrState].txtclr;
	*back = hhEmu->attrState[hhEmu->iCurAttrState].bkclr;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * std_initcolors
 *
 * DESCRIPTION:	Sets the entire attr image to the current colors
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void std_initcolors(const HHEMU hhEmu)
	{
	register int row, col;

	for (row = 0; row < MAX_EMUROWS; row++)
		for (col = 0 ; col <= MAX_EMUCOLS ; ++col)
			{
			hhEmu->emu_apAttr[row][col].txtclr = hhEmu->emu_clearattr.txtclr;
			hhEmu->emu_apAttr[row][col].bkclr = hhEmu->emu_clearattr.bkclr;
			}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void std_restorescreen(const HHEMU hhEmu)
	{
	updateLine(sessQueryUpdateHdl(hhEmu->hSession), 0, hhEmu->emu_maxrow);
	hhEmu->iCurAttrState = CS_STATE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * std_clearscreen
 *
 * DESCRIPTION:
 *	 Erases some or all of the virtual screen image.
 *
 * ARGUMENTS:
 *	 select -- 0 to erase from cursor to end of screen
 *			-- 1 to erase from start of screen to cursor
 *			-- 2 to erase entire screen
 *
 * RETURNS:
 *	 nothing
 */
void std_clearscreen(const HHEMU hhEmu, const int nClearSelect)
	{
	register int r;
	int trow, tcol;
	PSTATTR pstAttr;
	ECHAR aechBuf[10];
	BOOL fSave;

	trow = hhEmu->emu_currow;
	tcol = hhEmu->emu_curcol;

	switch (nClearSelect)
		{
	/* cursor to end of screen */
	case 0:
		fSave = (hhEmu->emu_currow == 0  &&
					hhEmu->emu_curcol == 0) ? TRUE : FALSE;

		for (r = hhEmu->emu_currow + (fSave ? 0 : 1) ; r < MAX_EMUROWS; ++r)
			{
			if (fSave)
				{
				backscrlAdd(sessQueryBackscrlHdl(hhEmu->hSession),
							hhEmu->emu_apText[row_index(hhEmu, r)],
							hhEmu->emu_maxcol+1);

				CaptureLine(sessQueryCaptureFileHdl(hhEmu->hSession),
									CF_CAP_SCREENS,
									hhEmu->emu_apText[row_index(hhEmu, r)],
									emuRowLen(hhEmu, row_index(hhEmu, r)));

				printEchoScreen(hhEmu->hPrintEcho,
									hhEmu->emu_apText[row_index(hhEmu, r)],
									emuRowLen(hhEmu, row_index(hhEmu, r)));

				CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("\r\n"), StrCharGetByteCount(TEXT("\r\n")));
				printEchoScreen(hhEmu->hPrintEcho,
									aechBuf,
									sizeof(ECHAR) * 2);
				}

			clear_imgrow(hhEmu, r);
			}

		// Clear the partial row now.
		//
		ECHAR_Fill(hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow)] +
						hhEmu->emu_curcol,
						EMU_BLANK_CHAR,
						(size_t)(MAX_EMUCOLS - hhEmu->emu_curcol + 1));

		if (hhEmu->emu_curcol <= hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
			hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol - 1;

		pstAttr = hhEmu->emu_apAttr[row_index(hhEmu, hhEmu->emu_currow)];

		for (r = hhEmu->emu_curcol ; r <= MAX_EMUCOLS ; ++r)
			pstAttr[r] = hhEmu->emu_clearattr;

		// Tell the video image what to do.  Use the emuDispRgnScrollUp() call
		// instead of RgnClear so edges of terminal get painted if
		// clear attribute changes.

		updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
						0,
						hhEmu->emu_maxrow,
						hhEmu->emu_maxrow + 1,
						hhEmu->emu_imgtop,
						TRUE);

		(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, hhEmu->emu_curcol);

		// Added a global to save the clear attribute at the time of
		// notification.  This is necessary since the message is posted
		// and a race condition can develop.

		hhEmu->emu_clearattr_sav = hhEmu->emu_clearattr;

		NotifyClient(hhEmu->hSession, EVENT_EMU_CLRATTR, 0);
		break;


	/* start of screen to cursor */

	case 1:
		for (r = 0; r < hhEmu->emu_currow; ++r)
			clear_imgrow(hhEmu, r);

		ECHAR_Fill(hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow)],
					EMU_BLANK_CHAR,
			  		(size_t)(hhEmu->emu_curcol + 1));

		if (hhEmu->emu_curcol >= hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
			hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = EMU_BLANK_LINE;

		pstAttr = hhEmu->emu_apAttr[row_index(hhEmu, hhEmu->emu_currow)];

		for (r = 0 ; r <= hhEmu->emu_curcol ; ++r)
			pstAttr[r] = hhEmu->emu_clearattr;

		(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, hhEmu->emu_curcol);

		updateLine(sessQueryUpdateHdl(hhEmu->hSession), 0, hhEmu->emu_currow);
		break;

	/* Entire screen */
	case 2:
		for (r = 0; r < MAX_EMUROWS; ++r)
			{
			backscrlAdd(sessQueryBackscrlHdl(hhEmu->hSession),
							hhEmu->emu_apText[row_index(hhEmu, r)],
							hhEmu->emu_maxcol+1);

			CaptureLine(sessQueryCaptureFileHdl(hhEmu->hSession),
							CF_CAP_SCREENS,
							hhEmu->emu_apText[row_index(hhEmu, r)],
							emuRowLen(hhEmu, row_index(hhEmu, r)));

			printEchoScreen(hhEmu->hPrintEcho,
							hhEmu->emu_apText[row_index(hhEmu, r)],
							emuRowLen(hhEmu, row_index(hhEmu, r)));

			CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("\r\n"), StrCharGetByteCount(TEXT("\r\n")));
			printEchoScreen(hhEmu->hPrintEcho,
							aechBuf,
							sizeof(ECHAR) * 2);

			clear_imgrow(hhEmu, r);
			}

		updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
						0,
						hhEmu->emu_maxrow,
						hhEmu->emu_maxrow + 1,
						hhEmu->emu_imgtop,
						TRUE);


		// Save the clear attribute at the time of
		// notification.  This is necessary since the message is posted
		// and a race condition can develop.

		hhEmu->emu_clearattr_sav = hhEmu->emu_clearattr;

		NotifyClient(hhEmu->hSession, EVENT_EMU_CLRATTR, 0);
		break;

	default:
		commanderror(hhEmu);
		}

	(*hhEmu->emu_setcurpos)(hhEmu, trow, tcol);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * std_clearline
 *
 * DESCRIPTION:
 *	 Erases some or all of the current virtual screen line and corresponding
 *	 real screen line.
 *
 * ARGUMENTS:
 *	 select -- 0 to erase from cursor to end of line
 *			-- 1 to erase from start of line to cursor
 *			-- 2 to erase entire line
 *
 * RETURNS:
 *	 nothing
 */
void std_clearline(const HHEMU hhEmu, const int nClearSelect)
	{
	register int i;
	PSTATTR pstAttr;

	switch (nClearSelect)
		{

	/* to end of line */
	case 0:
		if (hhEmu->emu_curcol == 0)
			{
			backscrlAdd(sessQueryBackscrlHdl(hhEmu->hSession),
				hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow)],
				hhEmu->emu_maxcol+1);
			}

		updateLine(sessQueryUpdateHdl(hhEmu->hSession),
						hhEmu->emu_currow,
						hhEmu->emu_currow);


		ECHAR_Fill(hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow)] +
					hhEmu->emu_curcol,
					EMU_BLANK_CHAR,
					(size_t)(hhEmu->emu_maxcol - hhEmu->emu_curcol + 1));

		if (hhEmu->emu_curcol <= hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
			hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol - 1;

		pstAttr = hhEmu->emu_apAttr[row_index(hhEmu, hhEmu->emu_currow)];

		for (i = hhEmu->emu_curcol ; i <= hhEmu->emu_maxcol ; ++i)
			pstAttr[i] = hhEmu->emu_clearattr;

		break;

	/* from start of line to cursor */
	case 1:
		updateLine(sessQueryUpdateHdl(hhEmu->hSession),
						hhEmu->emu_currow,
						hhEmu->emu_currow);


		ECHAR_Fill(hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow)],
					EMU_BLANK_CHAR,
					(size_t)(hhEmu->emu_curcol+1));

		if (hhEmu->emu_curcol < hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
			hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol + 1;
		else if (hhEmu->emu_curcol == hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
			hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = EMU_BLANK_LINE;

		pstAttr = hhEmu->emu_apAttr[row_index(hhEmu, hhEmu->emu_currow)];

		for (i = 0 ; i <= hhEmu->emu_curcol ; ++i)
			pstAttr[i] = hhEmu->emu_clearattr;

		break;

	/* Entire line */
	case 2:
		backscrlAdd(sessQueryBackscrlHdl(hhEmu->hSession),
			hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow)],
			hhEmu->emu_maxcol + 1);

		updateLine(sessQueryUpdateHdl(hhEmu->hSession),
						hhEmu->emu_currow,
						hhEmu->emu_currow);

		clear_imgrow(hhEmu, hhEmu->emu_currow);
		break;

	default:
		commanderror(hhEmu);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * std_clearrgn
 *
 * DESCRIPTION:
 *	 Erases a region of the current virtual screen and corresponding
 *	 real screen region.
 *
 * ARGUMENTS:
 *	toprow -- top row of region
 *	leftcol -- column of region's left edge
 *	botmrow -- bottom row of region
 *	rightcol -- column of region's right edge
 *
 * RETURNS:
 *	 nothing
 */
void std_clearrgn(const HHEMU hhEmu,
					int toprow,
					int leftcol,
					int botmrow,
					int rightcol)
	{
	int irow, num, idx;
	PSTATTR pstAttr;

	/* make sure region is within the screen */
	toprow = max(toprow, 0);
	leftcol = max(leftcol, 0);
	botmrow = min(botmrow, hhEmu->emu_maxrow);
	rightcol = min(rightcol, hhEmu->emu_maxcol);

	updateLine(sessQueryUpdateHdl(hhEmu->hSession),
						toprow,
						botmrow);

	num = (rightcol - leftcol) + 1;

	/* copy image to memory */
	for (irow = toprow; irow <= botmrow; irow++)
		{
		ECHAR_Fill(hhEmu->emu_apText[row_index(hhEmu, irow)]+leftcol,
						EMU_BLANK_CHAR,
						(size_t)num);

		// If the current end of line position is within the range
		// being cleared, we need to find the last character in the
		// row array working backwards from position leftcol - 1;
		//
		if (hhEmu->emu_aiEnd[row_index(hhEmu, irow)] >= leftcol &&
				hhEmu->emu_aiEnd[row_index(hhEmu, irow)] <= rightcol)
			{
			idx = min(0, leftcol - 1);
			while (idx >= 0)
				{
				if (*hhEmu->emu_apText[row_index(hhEmu, irow)] + idx != EMU_BLANK_CHAR)
					break;
				idx --;
				}

			hhEmu->emu_aiEnd[row_index(hhEmu, irow)] = idx;
			}


		pstAttr = hhEmu->emu_apAttr[row_index(hhEmu, irow)]+leftcol;

		for (pstAttr = hhEmu->emu_apAttr[row_index(hhEmu, irow)]+leftcol;
				num > 0 ; --num)
			*pstAttr++ = hhEmu->emu_clearattr;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * std_deinstall
 *
 * DESCRIPTION:
 *	 Uninstalls current emulator by freeing used memory.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
/* ARGSUSED */
void std_deinstall(const HHEMU hhEmu)
	{
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * std_scroll
 *
 * DESCRIPTION:
 *	 Scrolls the screen or portions of the screen.
 *
 * ARGUMENTS:
 *	 nlines -- number of lines to scroll
 *	 direction -- TRUE if scroll is up
 *
 * RETURNS:
 *	 nothing
 */
void std_scroll(const HHEMU hhEmu, const int nlines, const BOOL direction)
	{
	if (direction)
		scrollup(hhEmu, nlines);
	else
		scrolldown(hhEmu, nlines);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EmuStdSetCursorType
 *
 * DESCRIPTION:
 *	Sets the cursor type.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void EmuStdSetCursorType(const HHEMU hhEmu, int iCurType)
	{
	hhEmu->iCurType = iCurType;
	NotifyClient(hhEmu->hSession, EVENT_EMU_SETTINGS, 0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuChkChar
 *
 * DESCRIPTION: Called from all of the emulators when codes to process are
 *				outside of the displayable range. If the code translates
 *				to a character in the displayable range, the emulator's
 *				display function is called with the translated character.
 *
 * ARGUMENTS:	none
 *
 * RETURNS: 	nothing
 */
/* ARGSUSED */
void EmuChkChar(const HHEMU hhEmu)
	{
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuStdChkZmdm
 *
 * DESCRIPTION: Called when the current emulator picks up rz/r. Starts
 *				receiving with Zmodem.
 *
 * ARGUMENTS:	none
 *
 * RETURNS: 	nothing
 *
 * GOOD FOR:	nothing
 */
void EmuStdChkZmdm(const HHEMU hhEmu)
	{
	ECHAR old_emu_code;

	switch(hhEmu->iZmodemState++)
		{
	case 0:
		// Got the Ctrl-X
		// DbgOutStr("ZMDM - case 0\r\n", 0, 0, 0, 0, 0);
		DbgOutStr("ZMDM - case 0\r\n", 0, 0, 0, 0, 0);
		break;

	case 1:
		// Got the B?

		//DbgOutStr("ZMDM - case 1(0x%x)(%c)\r\n", emu_code, emu_code, 0, 0, 0);

		if (hhEmu->emu_code != ETEXT('B'))
			{
			hhEmu->state = 0;
			old_emu_code = hhEmu->emu_code;

			if ((hhEmu->stUserSettings.nEmuId == EMU_ANSI) ||
				(hhEmu->stUserSettings.nEmuId == EMU_ANSIW))
				{
				hhEmu->emu_code = CAN;
				(*hhEmu->emu_graphic)(hhEmu);
				}

			hhEmu->emu_code = old_emu_code;
#if defined(EXTENDED_FEATURES)
			(void)(*hhEmu->emu_datain)(hhEmu, old_emu_code);
#else
			(void)(*hhEmu->emu_datain)((HEMU)hhEmu, old_emu_code);
#endif
			hhEmu->iZmodemState = 0;
			}

		break;

	case 2:
		// Got a 0?

		//DbgOutStr("ZMDM - case 2(0x%x)(%c)\r\n", emu_code, emu_code, 0, 0, 0);

		if (hhEmu->emu_code != ETEXT('0'))
			{
			hhEmu->state = 0;
			old_emu_code = hhEmu->emu_code;

			if ((hhEmu->stUserSettings.nEmuId == EMU_ANSI) ||
				(hhEmu->stUserSettings.nEmuId == EMU_ANSIW))
				{
				hhEmu->emu_code = CAN;
				(*hhEmu->emu_graphic)(hhEmu);
				}
			hhEmu->emu_code = ETEXT('B');
			(*hhEmu->emu_graphic)(hhEmu);
			hhEmu->emu_code = old_emu_code;
#if defined(EXTENDED_FEATURES)
            (void)(*hhEmu->emu_datain)(hhEmu, old_emu_code);
#else
            (void)(*hhEmu->emu_datain)((HEMU)hhEmu, old_emu_code);
#endif
			hhEmu->iZmodemState = 0;
			}

		break;

	case 3:
		// Got a 0?

		//DbgOutStr("ZMDM - case 3(0x%x)(%c)\r\n", emu_code, emu_code, 0, 0, 0);

		if (hhEmu->emu_code == ETEXT('0'))
			{
			emuComDone((HEMU)hhEmu);

			NotifyClient(hhEmu->hSession,
						EVENT_HOST_XFER_REQ,
						XF_ZMODEM);
			}
		else
			{
			old_emu_code = hhEmu->emu_code;
			//TODO Put in a better way to display these codes.
			if ((hhEmu->stUserSettings.nEmuId == EMU_ANSI) ||
				(hhEmu->stUserSettings.nEmuId == EMU_ANSIW))
				{
				hhEmu->emu_code = CAN;
				(*hhEmu->emu_graphic)(hhEmu);
				}
			hhEmu->emu_code = ETEXT('B');
			(*hhEmu->emu_graphic)(hhEmu);
			hhEmu->emu_code = ETEXT('0');
			(*hhEmu->emu_graphic)(hhEmu);
			hhEmu->emu_code = old_emu_code;
#if defined(EXTENDED_FEATURES)
            (void)(*hhEmu->emu_datain)(hhEmu, old_emu_code);
#else
            (void)(*hhEmu->emu_datain)((HEMU)hhEmu, old_emu_code);
#endif
			}

		hhEmu->state = 0;
		hhEmu->iZmodemState = 0;
		break;

	default:
		// DbgOutStr("ZMDM - default\r\n", 0, 0, 0, 0, 0);
		hhEmu->state = 0;
		hhEmu->iZmodemState = 0;
		break;
		}
	}

void std_dsptbl(const HHEMU hhEmu, int bit8)
	{
	register INT x;

	for (x = 0; x < 128; ++x)
		hhEmu->dspchar[x] = (UCHAR)x;
	if (bit8)
		for (x = 128; x < 256; ++x)
			hhEmu->dspchar[x] = (UCHAR)x;
	else
		for (x = 128; x < 256; ++x)
			hhEmu->dspchar[x] = (UCHAR)(x - 128);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	std_emu_ntfy
 *
 * DESCRIPTION:
 *	Function called when session notified of a connection.	Place holder
 *	for function pointer.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle
 *
 * RETURNS:
 *	void
 *
 */
/* ARGSUSED */
void std_emu_ntfy(const HHEMU hhEmu, const int nNtfy)
	{
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuHomeHostCursor
 *
 * DESCRIPTION:
 *	Most terminal's home position is 0,0.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	0=OK, else error
 *
 */
int std_HomeHostCursor(const HHEMU hhEmu)
	{
	if (hhEmu == 0)
		{
		assert(0);
		return -1;
		}

	(*hhEmu->emu_setcurpos)(hhEmu, 0, 0);
	return 0;
	}

#ifdef INCL_TERMINAL_SIZE_AND_COLORS
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  std_setscrsize
 *
 * DESCRIPTION:
 *  This function is called from emuSetSettings.  It sets up the emulator
 *  to use the number of rows and columns defined un the user settings
 *  structure of the emulator handle.
 *
 * ARGUMENTS:
 *  hhEmu - The internal emulator handle.
 *
 * RETURNS:
 *  void
 *
 * AUTHOR: Bob Kundrat, 19-Feb-1996
 */
void std_setscrsize(const HHEMU hhEmu)
    {
    register int r, c;
    int iClearRow;
	PSTATTR pstAttr = 0;

    const int iOldRows = hhEmu->emu_maxrow + 1;
    const int iOldCols = hhEmu->emu_maxcol + 1;

    int iRows = hhEmu->stUserSettings.nUserDefRows;
    int iCols = hhEmu->stUserSettings.nUserDefCols;

    // Don't do anything if the values have not changed.
    //
    if (iRows == iOldRows && iCols == iOldCols)
        return;

    // Range check the requested screen size.  A minimum of 2 is
    // used to avoid a divide by zero error in row_index().
    //
    iRows = min(MAX_EMUROWS, iRows);
    iRows = max(iRows, MIN_EMUROWS);

    iCols = min(MAX_EMUCOLS, iCols);
    iCols = max(iCols, MIN_EMUCOLS);

    // Adjust global values to accomodate screen size change.  Remember,
    // most of the globals are zero based.
    //
    hhEmu->emu_maxrow = iRows - 1;
    hhEmu->emu_maxcol = iCols - 1;
    hhEmu->bottom_margin = hhEmu->emu_maxrow;

    // In the case of changing from a larger screen to a smaller one,
    // the cursor may have been at a location that isn't on the new
    // size.  Put it as close as possible on the new screen.
    //
    hhEmu->emu_currow = min(hhEmu->emu_currow, hhEmu->emu_maxrow);
    hhEmu->emu_curcol = min(hhEmu->emu_curcol, hhEmu->emu_maxcol);

    (*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, hhEmu->emu_curcol);

    // If the screen size got smaller, we need to clear the cells out
    // of the part of the buffer that is no longer being used.
    //
    if ((iOldRows - 1) > hhEmu->emu_maxrow)
        {
        for (r = hhEmu->emu_maxrow + 1; r < MAX_EMUROWS; ++r)
            {
            iClearRow = row_index(hhEmu, r);

            pstAttr = hhEmu->emu_apAttr[iClearRow];

            for (c = 0; c < MAX_EMUCOLS; c++)
                pstAttr[c] = hhEmu->emu_clearattr;
            }
        }

    if ((iOldCols - 1) > hhEmu->emu_maxcol)
        {
        for (r = 0; r < MAX_EMUROWS; ++r)
            {
            pstAttr = hhEmu->emu_apAttr[r];

            for (c = hhEmu->emu_maxcol + 1; c < MAX_EMUCOLS ; ++c)
                pstAttr[c] = hhEmu->emu_clearattr;
            }
        }

	// Telnet has a negotiated option to let the server know whenever the
	// terminal size changes. In case it has been enabled, we must let
	// the com driver know about this change.
	ComDriverSpecial(sessQueryComHdl(hhEmu->hSession), "Update Terminal Size", NULL, 0);

    return;
    }
#endif

/* end of emu_std.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\emu_ansi.c ===
/*	File: D:\WACKER\emu\emu_ansi.c (Created: 08-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 4 $
 *	$Date: 7/23/01 6:57p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\session.h>
#include <tdll\cloop.h>
#include <tdll\update.h>
#include <tdll\htchar.h>

#include "emu.h"
#include "emu.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * Function:
 *  ANSI_CBT
 *
 * Description:
 *  Moves the cursor back n tabs.
 *
 * Arguments:
 *  HHEMU hhEmu - Internal emulator handle.
 *
 * Returns:
 *   nothing
 *
 * Author: rde:30 Apr 1997
 */
void ANSI_CBT(const HHEMU hhEmu)
    {
    int nTabs;

    nTabs = hhEmu->num_param[hhEmu->num_param_cnt];
    if (nTabs < 1)
        {
        nTabs = 1;
        }

    while (nTabs)
        {
        backtab(hhEmu);
        nTabs--;
        }
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_CNL
 *
 * DESCRIPTION:
 *	 Moves the cursor to the start of the nth next line. The cursor can not
 *	 move past the end of the scrolling region.
 *
 * ARGUMENTS:
 *	 nline -- number of lines to move the cursor down
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_CNL(const HHEMU hhEmu, int nlines)
	{
	int row;

	if (nlines < 1)
		nlines = 1;

	row = hhEmu->emu_currow;
	row += nlines;

	if (row > hhEmu->bottom_margin)
		{
		(*hhEmu->emu_scroll)(hhEmu, row - hhEmu->bottom_margin, TRUE);
		row = hhEmu->bottom_margin;
		}

	(*hhEmu->emu_setcurpos)(hhEmu, row, 0);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_CUB
 *
 * DESCRIPTION:
 *	 Moves the cursor backwards (to the left) the specified number of
 *	 characters, but stops at the 1st character in the current line.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_CUB(const HHEMU hhEmu)
	{
	int nchars;
	nchars = hhEmu->num_param[hhEmu->num_param_cnt];
	if (nchars < 1)
		nchars = 1;

	(*hhEmu->emu_setcurpos)(hhEmu,
							hhEmu->emu_currow,
							hhEmu->emu_curcol - nchars);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_CUD
 *
 * DESCRIPTION: Moves the cursor down the specified number of lines, but stops
 *				at the bottom of the scrolling region. The column is constant.
 *				If below the scrolling region, it stops at the bottom of the
 *				screen.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_CUD(const HHEMU hhEmu)
	{
	int nlines, row;

	nlines = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nlines < 1)
		nlines = 1;

	row = hhEmu->emu_currow;
	row += nlines;

	if (row > hhEmu->bottom_margin &&
				(hhEmu->emu_currow <= hhEmu->bottom_margin ||
				hhEmu->emu_currow > hhEmu->emu_maxrow))
		row = hhEmu->bottom_margin;

	(*hhEmu->emu_setcurpos)(hhEmu, row, hhEmu->emu_curcol);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_CUF
 *
 * DESCRIPTION:
 *	 Moves the cursor forward the specified number of characters, but stops
 *	 at the last character in the current line.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_CUF(const HHEMU hhEmu)
	{
	int nchars, col;

	nchars = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nchars < 1)
		nchars = 1;

	col = hhEmu->emu_curcol;
	col += nchars;
	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, col);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_CUP
 *
 * DESCRIPTION:
 *	 Positions the cursor at the specified row and column. The row & column
 *	 numbering start at 1. If origin mode is on, the positioning is relative
 *	 to the home of the scrolling region.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_CUP(const HHEMU hhEmu)
	{
	int row, col;

	row = hhEmu->num_param[0];
	col = hhEmu->num_param_cnt > 0 ? hhEmu->num_param[1] : 0;

	if (row <= 1)
		row = 1;

	if (col <= 1)
		col = 1;

	if (hhEmu->mode_DECOM) /* VT100 Origin mode - position rel to margin */
		{
		row += hhEmu->top_margin;
		if (row > hhEmu->bottom_margin + 1)
			row = hhEmu->bottom_margin + 1;
		}
	else			/* Position is one-based from upper left */
		{
		if (row > hhEmu->emu_maxrow + 1)
			row = hhEmu->emu_maxrow + 1;
		}

	if (col > hhEmu->emu_maxcol + 1)
		col = hhEmu->emu_maxcol + 1;

	/* ANSI is one-based, HA zero-based */
	(*hhEmu->emu_setcurpos)(hhEmu, row - 1, col - 1);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_CUU
 *
 * DESCRIPTION: Moves the cursor up the specified number of lines, but stops
 *				at the top of the scrolling region. The column is constant.
 *				If above the scrolling region, it stops at the top of the
 *				screen.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_CUU(const HHEMU hhEmu)
	{
	int nlines, row;

	nlines = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nlines < 1)
		nlines = 1;

	row = hhEmu->emu_currow;
	row -= nlines;

	if (row < hhEmu->top_margin &&
		(hhEmu->emu_currow >= hhEmu->top_margin || hhEmu->emu_currow < 0))
			row = hhEmu->top_margin;

	(*hhEmu->emu_setcurpos)(hhEmu, row, hhEmu->emu_curcol);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_DCH
 *
 * DESCRIPTION:
 *	Deletes the specified number of characters starting at the current
 *	cursor position and moving right. It stops at the end of the current
 *	line.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	nothing
 */
void ANSI_DCH(const HHEMU hhEmu)
	{
	int iChars, iR, i;
	ECHAR *lpStart;
	PSTATTR pstAttr;

	hhEmu->emu_imgrow = row_index(hhEmu, hhEmu->emu_currow);

	// Range check.  Have we been asked to delete more characters than
	// are displayed?  If so, change the number.
	//
	iChars = min(hhEmu->num_param[hhEmu->num_param_cnt],
					(hhEmu->emu_aiEnd[hhEmu->emu_imgrow] -
					hhEmu->emu_curcol) + 1);

	if (iChars < 1)
		iChars = 1;

	if (hhEmu->emu_aiEnd[hhEmu->emu_imgrow] == EMU_BLANK_LINE)
		return;

	// Do a special test for DEC emulation.
	//
	if ((hhEmu->emu_curcol == hhEmu->emu_maxcol) &&
		((hhEmu->stUserSettings.nEmuId == EMU_VT100) ||
		 (hhEmu->stUserSettings.nEmuId == EMU_VT100J)))
		{
		hhEmu->emu_curcol = hhEmu->emu_maxcol - 1;
		}
	else if (hhEmu->emu_curcol > hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
		return;

	// Determine number of character that remain after the delete.
	//
	iR = hhEmu->emu_aiEnd[hhEmu->emu_imgrow] -
			hhEmu->emu_curcol - (iChars - 1);

	// Move the text image if there are remaining characters to
	// display.  Replace iChar characters at end of line with spaces.
	//
	#if 0
	if (iR)
		{
		memmove(hhEmu->emu_apText[hhEmu->emu_imgrow + hhEmu->emu_curcol],
				 &(hhEmu->emu_apText[hhEmu->emu_imgrow + hhEmu->emu_curcol][iChars]),
				 ((size_t)iR * sizeof(ECHAR)));   
		}
	#endif

	if (iR)
		{
		lpStart = hhEmu->emu_apText[hhEmu->emu_imgrow] + hhEmu->emu_curcol;

		memmove(lpStart, (lpStart + iChars), ((size_t)iR * sizeof(ECHAR)));
		}

    ECHAR_Fill(&hhEmu->emu_apText[hhEmu->emu_imgrow][hhEmu->emu_aiEnd[hhEmu->emu_imgrow] - iChars + 1],
				EMU_BLANK_CHAR, (unsigned int)iChars);

	// Move the attributes.  Clear iChar attributes at end of line.
	//
	if (iR)
		{
		pstAttr = hhEmu->emu_apAttr[hhEmu->emu_imgrow] + hhEmu->emu_curcol;
		memmove(pstAttr,
				(pstAttr + iChars),
				(size_t)(sizeof(STATTR)*(unsigned)iR));
		}

	pstAttr = hhEmu->emu_apAttr[hhEmu->emu_imgrow];
	for (i = (hhEmu->emu_aiEnd[hhEmu->emu_imgrow] - iChars) + 1;
			i <= hhEmu->emu_aiEnd[hhEmu->emu_imgrow]; i++)
				pstAttr[i] = hhEmu->emu_clearattr;

	// Note that emu_aiEnd[emu_imgrow] is used before we reset that
	// value.  Remember there may have been some characters and attributes
	// removed from the end of the line.  We need to tell the update stuff
	// to go that far over in the line.
	//
	updateChar(sessQueryUpdateHdl(hhEmu->hSession),
				hhEmu->emu_currow,
				hhEmu->emu_curcol,
				hhEmu->emu_aiEnd[hhEmu->emu_imgrow]);

	// Reset emu_aiEnd.  Note that it is expected and intended
	// that the result of the following calculation may
	// be (-1).
	//
	hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol + (iR - 1);

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_DL
 *
 * DESCRIPTION:
 *	 Deletes the specified number of lines starting at the current
 *	 cursor line and moving down. It stops at the bottom of the scrolling
 *	 region.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_DL(const HHEMU hhEmu)
	{
	int nlines;
	int save_top_margin;

	nlines = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nlines < 1)
		nlines = 1;

	save_top_margin = hhEmu->top_margin;
	hhEmu->top_margin = hhEmu->emu_currow;

	if (hhEmu->top_margin <= hhEmu->bottom_margin)
		(*hhEmu->emu_scroll)(hhEmu, nlines, TRUE);

	hhEmu->top_margin = save_top_margin;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_ED
 *
 * DESCRIPTION:
 *	 Erases some or all of the virtual screen image and corresponding
 *	 real screen.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_ED(const HHEMU hhEmu)
	{
	int nClearSelect;

	nClearSelect = hhEmu->selector[0];
	switch (nClearSelect)
		{
	case 0: 	/* cursor to end of screen */
	case 0x0F:
	case 0xF0:
		(*hhEmu->emu_clearscreen)(hhEmu, 0);
		break;
	case 1: 	/* start of screen to cursor */
	case 0xF1:
		(*hhEmu->emu_clearscreen)(hhEmu, 1);
		break;
	case 2: 	/* Entire screen */
	case 0xF2:
		(*hhEmu->emu_clearscreen)(hhEmu, 2);

		// ANSI terminal homes after clearing.
		// DEC terminals do not
		//
		if ((hhEmu->stUserSettings.nEmuId == EMU_ANSI)  ||
			(hhEmu->stUserSettings.nEmuId == EMU_ANSIW) ||
			(hhEmu->stUserSettings.nEmuId == EMU_AUTO))
			{
			(*hhEmu->emu_setcurpos)(hhEmu, 0,0);
			}

		break;
	default:
		commanderror(hhEmu);
		break;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_EL
 *
 * DESCRIPTION:
 *	 Erases some or all of the current virtual screen line and corresponding
 *	 real screen line.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_EL(const HHEMU hhEmu)
	{
	int nClearSelect;

	nClearSelect = hhEmu->selector[0];
	switch (nClearSelect)
		{
	case 0: 	/* to end of line */
	case 0x0F:
	case 0xF0:
		(*hhEmu->emu_clearline)(hhEmu, 0);
		break;
	case 1: 	/* from start of line to cursor */
	case 0xF1:
		(*hhEmu->emu_clearline)(hhEmu, 1);
		break;
	case 2: 	/* Entire line */
	case 0xF2:
		(*hhEmu->emu_clearline)(hhEmu, 2);
		break;
	default:
		commanderror(hhEmu);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSIFormFeed
 *
 * DESCRIPTION: Scrolls the current screen until its all gone.
 *
 * ARGUMENTS:	none
 *	 none
 *
 * RETURNS: 	nothing
 */
void AnsiFormFeed(const HHEMU hhEmu)
	{
	std_clearscreen(hhEmu, 2);
	(*hhEmu->emu_setcurpos)(hhEmu, 0, 0);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_HTS
 *
 * DESCRIPTION:
 *	 Sets horizontal tab at current cursor position.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_HTS(const HHEMU hhEmu)
	{
	hhEmu->tab_stop[hhEmu->emu_curcol] = TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_ICH
 *
 * DESCRIPTION:
 *	 Inserts the specified number of spaces starting at the current
 *	 cursor position.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_ICH(const HHEMU hhEmu)
	{
	int nspaces, c, oldstate, oldrow, oldcol;
	int tmp_irm = hhEmu->mode_IRM;
	nspaces = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nspaces <= 0)
		nspaces = 1;

	oldstate = hhEmu->iCurAttrState;
	hhEmu->iCurAttrState = CSCLEAR_STATE;
	oldrow = hhEmu->emu_currow;
	oldcol = hhEmu->emu_curcol;
	hhEmu->mode_IRM = SET;

	for (c = 0; c < nspaces; ++c)
		{
		hhEmu->emu_code = ETEXT(' ');
		(*hhEmu->emu_graphic)(hhEmu);
		}

	hhEmu->iCurAttrState = oldstate;
	(*hhEmu->emu_setcurpos)(hhEmu, oldrow, oldcol);

	if ((hhEmu->mode_IRM = tmp_irm) == 0)
		updateChar(sessQueryUpdateHdl(hhEmu->hSession),
					hhEmu->emu_currow,
					hhEmu->emu_curcol,
					hhEmu->emu_maxcol);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_IL
 *
 * DESCRIPTION:
 *	 Inserts the specified number of lines starting at the current
 *	 cursor row.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_IL(const HHEMU hhEmu)
	{
	int nlines;
	int save_top_margin;

	nlines = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nlines < 1)
		nlines = 1;

	save_top_margin = hhEmu->top_margin;
	hhEmu->top_margin = hhEmu->emu_currow;

	if (hhEmu->top_margin < hhEmu->bottom_margin)
		(*hhEmu->emu_scroll)(hhEmu, nlines, FALSE);

	hhEmu->top_margin = save_top_margin;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_IND
 *
 * DESCRIPTION:
 *	 Moves cursor down 1 line and scrolls 1 line if necessary. IND stands
 *	 for index.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_IND(const HHEMU hhEmu)
	{
	if (hhEmu->emu_currow == hhEmu->bottom_margin)
		(*hhEmu->emu_scroll)(hhEmu, 1, TRUE);

	else
		(*hhEmu->emu_setcurpos)(hhEmu,
								hhEmu->emu_currow + 1,
								hhEmu->emu_curcol);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_NEL
 *
 * DESCRIPTION:
 *	 Inserts 1 new line on the line below current row.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_NEL(const HHEMU hhEmu)
	{
	ANSI_CNL(hhEmu, 1);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_Pn
 *
 * DESCRIPTION:
 *	 Saves ANSI style parameters and selectors. The selectors are saved as
 *	 hex and numeric parameters as decimals.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_Pn(const HHEMU hhEmu)
	{
	ECHAR ccode;

	ccode = hhEmu->emu_code;

	if (ccode == ETEXT('?') && hhEmu->selector_cnt == 0)
		hhEmu->DEC_private = TRUE;

	else if (hhEmu->DEC_private && hhEmu->selector[hhEmu->selector_cnt] == 0 && ccode != ETEXT('?'))
		hhEmu->selector[hhEmu->selector_cnt] = 0x0F;

	hhEmu->selector[hhEmu->selector_cnt] = (int)((unsigned)hhEmu->selector[hhEmu->selector_cnt] << 4) +
								ccode - ETEXT('0');
	hhEmu->num_param[hhEmu->num_param_cnt] = 10 * hhEmu->num_param[hhEmu->num_param_cnt] +
								(ccode - ETEXT('0'));
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_Pn_Clr
 *
 * DESCRIPTION:
 *	 Clears all ANSI style parameters and selectors.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_Pn_Clr(const HHEMU hhEmu)
	{
	hhEmu->num_param_cnt = hhEmu->selector_cnt = 0;
	hhEmu->num_param[0] = 0;
	hhEmu->selector[0] = 0;
	hhEmu->DEC_private = FALSE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_Pn_End
 *
 * DESCRIPTION:
 *	 Sets next numeric parameter and selector to 0 to indicate end of
 *	 escape sequence.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_Pn_End(const HHEMU hhEmu)
	{
	hhEmu->num_param[++hhEmu->num_param_cnt] = 0;
	hhEmu->selector[++hhEmu->selector_cnt] = 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_RI
 *
 * DESCRIPTION:
 *	 Moves cursor up 1 line and scrolls 1 line if necessary. RI stands
 *	 for reverse index.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_RI(const HHEMU hhEmu)
	{
	/* If at the scrolling region's top margin, scroll down 1, but
	 * if above the top margin, and below to top edge of the screen,
	 * move the cursor up. If above the top margin and at the top edge of
	 * the screen, do nothing.
	 */
	if (hhEmu->emu_currow == hhEmu->top_margin)
		(*hhEmu->emu_scroll)(hhEmu, 1, FALSE);
	else if (hhEmu->emu_currow == 0)
		;
	else
		(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow - 1, hhEmu->emu_curcol);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_RIS
 *
 * DESCRIPTION:
 *	 Resets terminal emulator to initial state.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_RIS(const HHEMU hhEmu)
	{
	int col;
	int nTab;
	HCLOOP hCLoop;

	DEC_STBM(hhEmu, 0, 0);						/* Set scrolling region */

	(*hhEmu->emu_setcurpos)(hhEmu, 0, 0);		/* Home cursor */
	(*hhEmu->emu_clearscreen)(hhEmu, 0);		/* Clear screen */
	emu_cleartabs(hhEmu, 3);					/* Clear tabs */

	hCLoop = sessQueryCLoopHdl(hhEmu->hSession);

	nTab = CLoopGetTabSizeOut(hCLoop);

	if ( nTab <= 0)
		CLoopSetTabSizeOut(hCLoop, 8);

	for (col = 0; col <= MAX_EMUCOLS; col += nTab)
			hhEmu->tab_stop[col] = TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_SGR
 *
 * DESCRIPTION:
 *	 Sets character display attributes.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 *
 * NOTES:
 *	This function contains Auto Detect code.
 */
void ANSI_SGR(const HHEMU hhEmu)
	{
	STATTR stAttr;
	int fAnsi, sel, i;

	fAnsi = ((hhEmu->stUserSettings.nEmuId == EMU_ANSI)       ||
			 (hhEmu->stUserSettings.nEmuId == EMU_ANSIW)      ||
			 (hhEmu->stUserSettings.nEmuId == EMU_VIEW)       ||
			 (hhEmu->stUserSettings.nEmuId == EMU_AUTO)       ||
			 (hhEmu->stUserSettings.nEmuId == EMU_VT100PLUS)  ||
             (hhEmu->stUserSettings.nEmuId == EMU_VTUTF8)) ? TRUE : FALSE;

	for (i = 0; i <= hhEmu->selector_cnt; i++)
		{
		sel = hhEmu->selector[i];
		stAttr = hhEmu->attrState[CS_STATE];

		switch(sel)
			{
		case 0: /* all attributes off */
			if (hhEmu->stUserSettings.nEmuId == EMU_AUTO)
				{
				// don't mess with color attributes in AutoDetect mode
				// for attribute reset case - mrw, 10/17/94
				//
				stAttr.undrln = 0;
				stAttr.hilite = 0;
				stAttr.bklite = 0;
				stAttr.blink = 0;
				stAttr.revvid = 0;
				stAttr.blank = 0;
				stAttr.dblwilf = 0;
				stAttr.dblwirt = 0;
				stAttr.dblhilo = 0;
				stAttr.dblhihi = 0;
				stAttr.symbol = 0;
				}

			else if (fAnsi)
				{
				memset(&stAttr, 0, sizeof(STATTR));

#if FALSE	// We've decided not to do this. rde 14 Jul 98
//#ifdef INCL_TERMINAL_SIZE_AND_COLORS
				// Reset to the user-defined colors. I'm afraid this may
				// re-introduce the intensity bug referred to below.
				// rde 9 Jun 98
                if (hhEmu->mode_DECSCNM == SET)
                    {
                    stAttr.txtclr = hhEmu->stUserSettings.nBackgroundColor;
                    stAttr.bkclr = hhEmu->stUserSettings.nTextColor;
                    }
                else
                    {
                    stAttr.txtclr = hhEmu->stUserSettings.nTextColor;
                    stAttr.bkclr = hhEmu->stUserSettings.nBackgroundColor;
                    }
#else
                // mrw:2/21/96 - Changed from 15 to 7 to fix bug with
                // intensity.
                //
				stAttr.txtclr = (hhEmu->mode_DECSCNM == SET) ? 0 : 7;
				stAttr.bkclr = (hhEmu->mode_DECSCNM == SET) ? 7 : 0;
#endif

				}
			else
				{
				if (hhEmu->mode_DECSCNM != SET)
					{
#if FALSE	// We've decided not to do this. rde 14 Jul 98
//#ifdef INCL_TERMINAL_SIZE_AND_COLORS
                    stAttr.txtclr = hhEmu->stUserSettings.nTextColor;
                    stAttr.bkclr = hhEmu->stUserSettings.nBackgroundColor;
#endif
					stAttr.undrln = 0;
					stAttr.hilite = 0;
					stAttr.bklite = 0;
					stAttr.blink = 0;
					stAttr.revvid = 0;
					stAttr.blank = 0;
					stAttr.dblwilf = 0;
					stAttr.dblwirt = 0;
					stAttr.dblhilo = 0;
					stAttr.dblhihi = 0;
					stAttr.symbol = 0;
					}
				}
			break;

		case 1: /* bold or increased intensity */
			stAttr.hilite = TRUE;
			break;

		case 2: /* faint */
		case 3:	/* italics */
			/* not supported */
			break;

		case 4: /* underscore */
			stAttr.undrln = TRUE;
			break;

		case 5: /* blink */
			stAttr.blink = TRUE;
			break;

		case 6:	/* rapid blink */
			/* not supported */
			break;

		case 7: /* reverse video */
            // Reverse video should be reverse video for a cell
            // reguardless of the current screen mode.  Changing
            // the following line removed a bug where blocks of
            // text would not get set to reverse video when the
            // screen was also in reverse mode. - rjk:02/04/97
            //
			//stAttr.revvid = (hhEmu->mode_DECSCNM == SET) ? FALSE : TRUE;
			stAttr.revvid = TRUE;
			break;

		case 8: /* invisible display */
			stAttr.blank = TRUE;
			break;

		case 9:	/* rapid blink */
			/* not supported */
			break;

		case 0x22:
			stAttr.hilite = FALSE;
			break;

		case 0x24:
			stAttr.undrln = FALSE;
			break;

		case 0x25:
			stAttr.blink = FALSE;
			break;

		case 0x27:
			stAttr.revvid = FALSE;
			break;

		case 0x30:
		case 0x32:
		case 0x35:
		case 0x37:
#ifndef INCL_VT100COLORS
#if !defined(FAR_EAST)
			emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
			emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
			if (fAnsi)
				{
				if (!stAttr.revvid)
					stAttr.txtclr = (unsigned)sel - 0x30;
				else
					stAttr.bkclr = (unsigned)sel - 0x30;
				}
#else
			stAttr.txtclr = (unsigned)sel - 0x30;
#endif
			break;

		case 0x31:
		case 0x33:
#ifndef INCL_VT100COLORS
#if !defined(FAR_EAST)
			emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
			emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
			if (fAnsi)
				{
				if (!stAttr.revvid)
					stAttr.txtclr = (unsigned)(sel - 0x30) + 3;
				else
					stAttr.bkclr = (unsigned)(sel - 0x30) + 3;
				}
#else
			stAttr.txtclr = (unsigned)(sel - 0x30) + 3;
#endif
			break;

		case 0x34:
		case 0x36:
#ifndef INCL_VT100COLORS
#if !defined(FAR_EAST)
			emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
			emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
			if (fAnsi)
				{
				if (!stAttr.revvid)
					stAttr.txtclr = (unsigned)(sel - 0x30) - 3;
				else
					stAttr.bkclr = (unsigned)(sel - 0x30) - 3;
				}
#else
			stAttr.txtclr = (unsigned)(sel - 0x30) - 3;
#endif
			break;

		case 0x40:
		case 0x42:
		case 0x45:
		case 0x47:
#ifndef INCL_VT100COLORS
#if !defined(FAR_EAST)
			emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
			emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
			if (fAnsi)
				{
				if (!stAttr.revvid)
					stAttr.bkclr = (unsigned)sel - 0x40;
				else
					stAttr.txtclr = (unsigned)sel - 0x40;
				}
#else
			stAttr.bkclr = (unsigned)sel - 0x40;
#endif
			break;

		case 0x41:
		case 0x43:
#ifndef INCL_VT100COLORS
#if !defined(FAR_EAST)
			emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
			emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
			if (fAnsi)
				{
				if (!stAttr.revvid)
					stAttr.bkclr = (unsigned)(sel - 0x40) + 3;
				else
					stAttr.txtclr = (unsigned)(sel - 0x40) + 3;
				}
#else
			stAttr.bkclr = (unsigned)(sel - 0x40) + 3;
#endif
			break;

		case 0x44:
		case 0x46:
#ifndef INCL_VT100COLORS
#if !defined(FAR_EAST)
			emuAutoDetectLoad(hhEmu, EMU_ANSI);
#else
			emuAutoDetectLoad(hhEmu, EMU_ANSIW);
#endif
			if (fAnsi)
				{
				if (!stAttr.revvid)
					stAttr.bkclr = (unsigned)(sel - 0x40) - 3;
				else
					stAttr.txtclr = (unsigned)(sel - 0x40) - 3;
				}
#else
			stAttr.bkclr = (unsigned)(sel - 0x40) - 3;
#endif
			break;

		default:
			/* keep processing--there may be valids codes remaining */
			/* commanderror();*/
			break;
			}

		/* --- commit changes --- */

		hhEmu->emu_charattr =
		hhEmu->attrState[CS_STATE] =
		hhEmu->attrState[CSCLEAR_STATE] = stAttr;

		hhEmu->attrState[CSCLEAR_STATE].revvid = 0;
		hhEmu->attrState[CSCLEAR_STATE].undrln = 0;

		if (fAnsi && hhEmu->attrState[CS_STATE].revvid)
			hhEmu->attrState[CSCLEAR_STATE].revvid =
				hhEmu->attrState[CS_STATE].revvid;

		hhEmu->emu_clearattr = hhEmu->attrState[CSCLEAR_STATE];
		}

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_TBC
 *
 * DESCRIPTION:
 *	 Clears one or all tab stops.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_TBC(const HHEMU hhEmu)
	{
	if (hhEmu->selector[0] == 0 || hhEmu->selector[0] == 3)
		emu_cleartabs(hhEmu, hhEmu->selector[0]);
	else
		commanderror(hhEmu);
	}

// End of ansi.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\emu.hh ===
/*	File: D:\WACKER\emu\emu.hh (Created: 08-Dec-1993)
 *
 *	Copyright 1994-2001 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 13 $
 *	$Date: 7/26/01 1:44p $
 */
typedef struct stEmuInternal *HHEMU;

// Maximum column definitions.
// They're one more than zero base maximums.  Lines won't
// wrap until next char is displayed.
//
#define VT_MAXCOL_80MODE	79
#define VT_MAXCOL_132MODE	131

// Define terminal modes using ANSI terminology.
//
#define SET TRUE
#define RESET FALSE

// Character constants.
//
#define SOH 	001
#define STX 	002
#define ETX 	003
#define EOT 	004
#define ENQ 	005
#define ACK 	006
#define BELL	007
#define BS		010
#define LF		012
#define FF		014
#define RET 	015
#define DLE 	020
#define DC3 	023
#define NAK 	025
#define CAN 	030
#define ESC 	033
#define DEL 	177
#define IND 	204
#define SS3 	217
#define CSI 	233

// Definitions for double high, double wide character processing.
//
#define NO_LINE_ATTR			0
#define DBL_WIDE_HI 			1
#define DBL_WIDE_LO 			2
#define DBL_WIDE_SINGLE_HEIGHT	3

#define MAX_STATE		35	/* Maximum states in FSA */
#define MAX_TRANSITION 200	/* Maximum state-to-state transitions */
#define MAX_NUM_PARAM	10	/* Max # numeric parameters in one cmd */
#define MAX_SELECTOR	10	/* Max # selectors in one terminal command */
#define NEW_STATE	   255	/* Special marker to indicate new state */

#define CLEAR_CURSOR_TO_SCREEN_END      0
#define CLEAR_SCREEN_START_TO_CURSOR    1
#define CLEAR_ENTIRE_SCREEN             2

#define CLEAR_CURSOR_TO_LINE_END		0
#define CLEAR_LINE_START_TO_CURSOR		1
#define CLEAR_ENTIRE_LINE				2

#define CLEAR_TAB_AT_CURSOR             0
#define CLEAR_TABS_IN_LINE              3

#define CS_STATE		 0
#define CSCLEAR_STATE	 1

#define EMU_BLANK_LINE	(-1)
#define EMU_BLANK_CHAR	TEXT('\x20')

// Key table definitions.
//
#define VK_BACKSPACE	(VK_BACK   | VIRTUAL_KEY)
#define DELETE_KEY		(VK_DELETE | VIRTUAL_KEY)
#define DELETE_KEY_EXT	(VK_DELETE | VIRTUAL_KEY | EXTENDED_KEY)

/* -------------- Key Table Transalation ------------- */

typedef struct
	{
	int key;
	int fPointer;	// TRUE means we use the CHAR * portion of the union.
	int uLen;		// length of stored keystring.
	union
		{
		TCHAR	achKeyStr[sizeof(LPTSTR)]; // want real chars here.
		TCHAR  *pachKeyStr; 			  // want real chars here.
		} u;
	} KEY;

typedef KEY * PSTKEY;

typedef struct
	{
	int 	  iMaxKeys;
	PSTKEY	  pstKeys;
	} KEYTABLE;

typedef KEYTABLE * PSTKEYTABLE;

typedef struct KeyTblStorage
    {
	int KeyCode; 
	TCHAR achKeyStr[15];
	} KEYTBLSTORAGE;

typedef struct emuNameTable
	{
	TCHAR	acName[EMU_MAX_NAMELEN];
	int 	nEmuId;
	} STEMUNAMETABLE;

typedef STEMUNAMETABLE * PSTEMUNAMETABLE;

/* Define the Finite State Automaton (FSA) which parses commands.
 * There is an array of states which points into an array of transitions
 * from that state.
 */

struct state_entry
	{
	struct trans_entry *first_trans;	/* Pointer into transition array */
	int number_trans;				  /* Number of paths out of state */
	};

struct trans_entry
	{
	int next_state; 				  /* Next state after match */
	ECHAR lochar, hichar;				/* Match range of input chars */
	void (*funct_ptr)(const HHEMU hhEmu);			 /* Pointer to function */
	};

// The internal Emulator Handle
//
struct stEmuInternal
	{
	CRITICAL_SECTION csEmu; 		// Used to synchronize access

	void *pvPrivate;
						 
	HSESSION hSession;				// Session hdl that created this.

	HPRINT	hPrintEcho, 			// Print hdl for Printer Echo.
			hPrintHost; 			// Print hdl for Host directed printing.

	TCHAR	acAnswerback[21];

	PSTEMUNAMETABLE pstNameTable;

	int 	nEmuLoaded, 			// Identifies the emulator that is
									// currently loaded.  Use in emuLoad
									// to determine if requested emulator
									// is already loaded.
			iCurType,				// cursor type
			fWasConnected;			// used with auto attempts


	STEMUSET	stUserSettings; 	// Contains all the settings made by the 
									// user. They are initilaized from values
									// stored in the session file.

	// Variables for state table processing.
	//
	struct state_entry state_tbl[MAX_STATE];
	struct trans_entry trans_tbl[MAX_TRANSITION];

	int state,						/* State table state			*/
		num_param[MAX_NUM_PARAM],	/* Numeric valued parameters	*/
		num_param_cnt,				/* Number of parameters 		*/
		selector[MAX_SELECTOR], 	/* (Hex) option selectors		*/
		selector_cnt;				/* Number of selectors			*/

	ECHAR	emu_code,				/* current character to process */
			emu_highchar;			/* highest CHAR to bypass state table */

	// Keyboard processing tables and variables.
	//
	KEYTABLE stEmuKeyTbl,					/* the dreaded keytable 		*/
			 stEmuKeyTbl2,					/* modal keytable				*/
			 stEmuKeyTbl3,					/* modal keytable				*/
			 stEmuKeyTbl4,					/* modal keytable 				*/
			 stEmuKeyTbl5;					/* modal keytable 				*/


	// Character attribute state information.
	//
	int iCurAttrState;

	STATTR attrState[2];

	// Virtual image variables
	//
	int emu_maxrow, 			/* maximum virtual row of emulator */
		emu_maxcol, 			/* maximum virtual column of emualtor */
		emu_currow, 			/* emulator's cursor row */
		emu_curcol, 			/* emulator's cursor column */
		emu_imgtop, 			/* line in image array of screen row 0 */
		emu_imgrow, 			/* line in image array of cursor */
		top_margin,
		bottom_margin,
		scr_scrollcnt;			/* Keeps track of screen scrolls */

	// Is the loaded emulator DBCS Enabled
	int	fDBCSSupported;			/* Emulator is DBCS Enabled	True\False. */

	// JFH:2/22/95 TCHAR	dspchar[256];		/* Character display map */
	ECHAR	dspchar[256];		/* Character display map */

	int 	tab_stop[MAX_EMUCOLS + 1],
			print_echo;

	// Pointers to text, attribute and end of line arrays.
	//
	ECHAR	*(*emu_apText);
	PSTATTR *emu_apAttr;
	int 	*emu_aiEnd;

	// Character attribute variables.
	//
	STATTR	emu_clearattr,			 /* current CHAR attribute for clearing */
			emu_clearattr_sav,		 /* Used for HA/Win - mrw */
			emu_charattr;			 /* current physical character attribute */

	// Emulator mode variables
	//
	int mode_KAM,		/* Keyboard Action Mode. RESET=enabled					*/
		mode_IRM,		/* Insertion-Replacement. RESET=replace chars			*/
		mode_VEM,		/* Vertical Editing. RESET=ins/del lines below cursor	*/
		mode_HEM,		/* Horizontal Editing. RESET=ins/del chars after cursor */
		mode_SRM,		/* Send-Receive. RESET=local character echo 			*/
		mode_AWM,		/* AutoWrap (not ANSI). RESET=wrap to next line 		*/
		mode_LNM,		/* Line feed New line. RESET=LF moves vertically only	*/
		mode_DECCKM,	/* cursor key codes. RESET=cursor, SET=application		*/
		mode_DECKPAM,	/* keypad key codeas. RESET=numeric, SET=application	*/
		mode_DECOM, 	/* DEC origin mode. RESET=cursor posn screen relative	*/
		mode_DECCOLM,	/* DEC column mode. RESET=80 column display 			*/
		mode_DECPFF,	/* Print form feed. RESET=OFF							*/
		mode_DECPEX,	/* Print extent. RESET=scroll rgn., SET=full screen 	*/
		mode_DECSCNM,	/* Screen mode. RESET=normal video, SET=reverse video	*/
		mode_DECTCEM,	/* Cursor enable. RESET=hidden, SET=visible 			*/
		mode_25enab,	/* When true (SET), emulator can use 25th line			*/
		mode_protect,	/* When true (SET), protected mode is on				*/
		mode_block, 	/* When true (SET), block mode is on					*/
		mode_local, 	/* When true (SET), local mode is on					*/
		mode_vt220,
		mode_vt280,		/* Acts as a Kanji/Katakana terminal 					*/
		mode_vt320,

        fUse8BitCodes,	// Applies to the VT220/320 emulators.
        fAllowUserKeys,	// Ditto.
#if defined(INCL_PRINT_PASSTHROUGH)
        fPrintRaw,
#endif // INCL_PRINT_PASSTHROUGH

		iZmodemState;	// This variable is used by all of the emulators
						// for processing AutoStart Zmodem codes.

	int DEC_private;   	// Set when '?' is part of sequence

    // Function pointer definitions.  These pointers get assigned to
	// emulator functions during the loading and initialization of a
	// specific emulator...emuLoad().
	//
#if defined(EXTENDED_FEATURES)
	int (*emu_datain)		(const HHEMU hhEmu, const ECHAR ccode);
#else
	int (*emu_datain)		(const HEMU hEmu, const ECHAR ccode);
#endif
	int (*emu_kbdin)		(const HHEMU hhEmu, int kcode, const int fTest);
	int (*emu_getscrollcnt) (const HHEMU hhEmu);
	int (*EmuScreenMode)	(const HHEMU hhEmu, int d);
	int (*emuResetTerminal) (const HHEMU hhEmu, int n);

	void (*emu_graphic) 	(const HHEMU hhEmu);
	void (*emu_setcolors)	(const HHEMU hhEmu, int fore, int back);
	void (*emu_getcolors)	(const HHEMU hhEmu, int *fore, int *back);
	void (*emu_initcolors)	(const HHEMU hhEmu);
	void (*emu_getscrsize)	(const HHEMU hhEmu, int *rows, int *cols);
#ifdef INCL_TERMINAL_SIZE_AND_COLORS
    void (*emu_setscrsize)  (const HHEMU hhEmu);	// Added 10 Jun 98 rde
#endif
	void (*emu_getcurpos)	(const HHEMU hhEmu, int *row, int *col);
	void (*emu_setcurpos)	(const HHEMU hhEmu, int row, int col);
	void (*emu_clearscreen) (const HHEMU hhEmu, int selector);
	void (*emu_clearline)	(const HHEMU hhEmu, int selector);
	void (*emu_setattr) 	(const HHEMU hhEmu, PSTATTR pstAttr);
	void (*emu_scroll)		(const HHEMU hhEmu, int nlines, BOOL direction);
	void (*emu_deinstall)	(const HHEMU hhEmu);
	void (*EmuSetCursorType)(const HHEMU hhEmu, int iCurType);
	void (*emu_ntfy)		(const HHEMU hhEmu, const int nNtfy);
	void (*emu_clearrgn)	(const HHEMU hhEmu,
								int toprow,
								int leftcol,
								int botmrow,
								int rightcol);

	ECHAR (*EmuGetPrnChar)	(const HHEMU hhEmu, ECHAR uch);
	STATTR (*emu_getattr)	(const HHEMU hhEmu);
	int (*emuHomeHostCursor)(const HHEMU hhEmu);
	};

// These are a group of settings saved in the session file as a block. Later
// settings were added to the session file individually rather than in a 
// structure. Do not add or remove any items from this structure!! rde 8 Jun 1998
struct stEmuBaseSFSettings
	{
	int 	nEmuId, 			// 100 = EMU_AUTO
								// 101 = EMU_ANSI
								// 102 = EMU_MINI
								// 109 = EMU_VIEW
								// 110 = EMU_TTY
								// 111 = EMU_VT100
								// 112 = EMU_VT220
								// 113 = EMU_VT320
								// 115 = EMU_VT52
								// 116 = EMU_VT100J
                                // 117 = EMU_ANSIW
								// 118 = EMU_VT100PLUS
								// 119 = EMU_VTUTF8
								//
			nTermKeys,			// 0 = EMU_KEYS_ACCEL
								// 1 = EMU_KEYS_TERM
								// 2 = EMU_KEYS_SCAN
								//
			nCursorType,		// 1 = EMU_CURSOR_BLOCK
								// 2 = EMU_CURSOR_LINE
	        					// 3 = EMU_CURSOR_NONE
								//
			nCharacterSet,		// 0 = EMU_CHARSET_ASCII
								// 1 = EMU_CHARSET_UK
								// 2 = EMU_CHARSET_SPECIAL
								//
			nAutoAttempts,		// Count of connections using the Auto
								// Detect Emulator.  At
								// EMU_MAX_AUTODETECT_ATTEMPTS, we switch
								// to Ansi emulation.  Note, this may
								// get moved into a Statictics Handle
								// if we ever develop one.
								//
			fCursorBlink,		// Blinking cursor. 			True\False.
			fMapPFkeys, 		// PF1-PF4 to top row of keypad.True\False.
			fAltKeypadMode, 	// Alternate keypad mode.		True\False.
			fKeypadAppMode, 	// Keypad application mode. 	True\False.
			fCursorKeypadMode,	// Cursor keypad mode.			True\Fales.
			fReverseDelBk,		// Reverse Del and Backsp.		True\False.
			f132Columns,		// 132 column display.			True\False.
			fDestructiveBk, 	// Destructive backspace.		True\False.
			fWrapLines, 		// Wrap lines.					True\False.
			fLbSymbolOnEnter,	// Send # symbol on Enter.		True\False.

	// Note: The following two variables were added for the VT220/320. rde:24 Jan 98
            fUse8BitCodes,      // 8-bit control codes          True\False.
            fAllowUserKeys;     // User defined keys allowed    True\False.
                                
    // Note: The following two variables are only used if the "Include
    // User Defined Backspace and Telnet Terminal Id" feature is enabled.
    // There is no compile switch here because this entire structure gets
    // written to the session file in one large chunk. Using a compile
    // switch could potentially cause version problems later on down
    // the road. - cab:11/15/96
    //
    int     nBackspaceKeys;     // 1 = EMU_BKSPKEYS_CTRLH
                                // 2 = EMU_BKSPKEYS_DEL
                                // 3 = EMU_BKSPKEYS_CTRLHSPACE

    TCHAR   acTelnetId[EMU_MAX_TELNETID];   // Telnet terminal ID
	};

// This macro returns the virtual image row of the supplied row number.  That is,
// what appears as row 10 on the terminal image may actually be row 5 in the
// virtual image.
//
#define row_index(h, r) (((r) + h->emu_imgtop + MAX_EMUROWS) % (MAX_EMUROWS))

// The emualtor image is an array of characters.  emu_aiEnd is an array that
// contains the column number of the rightmost character in a given row.
// This macro returns the a number representing the length of the image for
// the supplied row, from location 0 to the rightmost column.  It
// simplifies accessing a row of the emulator as though it were a string.
// Remember, the emualtor matrix is zero based, and EMU_BALNK_LINE indicates
// that there are no characters in the row.
//
#define emuRowLen(h, r) ((h->emu_aiEnd[r] == EMU_BLANK_LINE) ? 0 : h->emu_aiEnd[r] + 1)

// from emu_std.c
//
int 	std_kbdin(const HHEMU hhEmu, int kcode, const int fTest);
int 	std_getscrollcnt(const HHEMU hhEmu);
void	std_getscrsize(const HHEMU hhEmu, int *rows, int *cols);
#ifdef INCL_TERMINAL_SIZE_AND_COLORS
void	std_setscrsize(const HHEMU hhEmu);
#endif
void	std_getcurpos(const HHEMU hhEmu, int *row, int *col);
void	std_setcurpos(const HHEMU hhEmu, const int iRow, const int iCol);
STATTR	std_getattr(const HHEMU hhEmu);
void	std_setattr(const HHEMU hhEmu, PSTATTR pstAttr);
void	std_setcolors(const HHEMU hhEmu, const int fore, const int back);
void	std_getcolors(const HHEMU hhEmu, int *fore, int *back);
void	std_initcolors(const HHEMU hhEmu);
void	std_restorescreen(const HHEMU hhEmu);
void	std_clearscreen(const HHEMU hhEmu, const int nClearSelect);
void	std_clearline(const HHEMU hhEmu, const int nClearSelect);
void	std_clearrgn(const HHEMU hhEmu, int toprow, int leftcol, int botmrow, int rightcol);
void	EmuStdSetCursorType(const HHEMU hhEmu, int iCurType);
void	EmuChkChar(const HHEMU hhEmu);
void	EmuStdChkZmdm(const HHEMU hhEmu);
void	std_dsptbl(const HHEMU hhEmu, int bit8);
void	std_scroll(const HHEMU hhEmu, const INT nlines, const BOOL direction);
void	std_deinstall(const HHEMU hhEmu);
void	vt_dsptbl(const HHEMU hhEmu, ECHAR left, ECHAR right);
void	vt_setdtbl(const HHEMU hhEmu, ECHAR tbl[], ECHAR cset);
int 	stdResetTerminal(const HHEMU hhEmu, const int);
void	std_emu_ntfy(const HHEMU hhEmu, const int nNtfy);
int 	std_HomeHostCursor(const HHEMU hhEmu);

// from emu_scr.c
//
void	backspace(const HHEMU hhEmu);
void	carriagereturn(const HHEMU hhEmu);
void	emuLineFeed(const HHEMU hhEmu);
void	emuPrintChars(const HHEMU hhEmu, ECHAR *bufr, int nLen);
void	scrolldown(const HHEMU hhEmu, int nlines);
void	scrollup(const HHEMU hhEmu, int nlines);
void	tab(const HHEMU hhEmu);
void	backtab(const HHEMU hhEmu);
void	tabn(const HHEMU hhEmu);
void	emu_bell(const HHEMU hhEmu);
void	emu_clearword(const HHEMU hhEmu, int fromcol, int tocol);
void	clear_imgrow(const HHEMU hhEmu, int iRow);

// From autoinit.c
//
void emuAutoInit(const HHEMU hhEmu);

// From emu_ansi.c
//
void    ANSI_CBT(const HHEMU hhEmu);
void	ANSI_CNL(const HHEMU hhEmu, int nlines);
void	ANSI_CUB(const HHEMU hhEmu);
void	ANSI_CUD(const HHEMU hhEmu);
void	ANSI_CUF(const HHEMU hhEmu);
void	ANSI_CUP(const HHEMU hhEmu);
void	ANSI_CUU(const HHEMU hhEmu);
void	ANSI_DL(const HHEMU hhEmu);
void	ANSI_ED(const HHEMU hhEmu);
void	ANSI_EL(const HHEMU hhEmu);
void	ANSI_DCH(const HHEMU hhEmu);
void	AnsiFormFeed(const HHEMU hhEmu);
void	ANSI_HTS(const HHEMU hhEmu);
void	ANSI_ICH(const HHEMU hhEmu);
void	ANSI_IL(const HHEMU hhEmu);
void	ANSI_IND(const HHEMU hhEmu);
void	ANSI_NEL(const HHEMU hhEmu);
void	ANSI_Pn(const HHEMU hhEmu);
void	ANSI_Pn_Clr(const HHEMU hhEmu);
void	ANSI_Pn_End(const HHEMU hhEmu);
void	ANSI_RI(const HHEMU hhEmu);
void	ANSI_RIS(const HHEMU hhEmu);
void	ANSI_SGR(const HHEMU hhEmu);
void	ANSI_TBC(const HHEMU hhEmu);

// From emu.c
//
void	nothing(const HHEMU hhEmu);
void	char_pn(const HHEMU hhEmu);
void	commanderror(const HHEMU hhEmu);
void	emuStdGraphic(const HHEMU hhEmu);
int 	emuCreateTextAttrBufs(const HEMU hEmu, const size_t nRows, size_t nCols);
void	emuDestroyTextAttrBufs(const HEMU hEmu);
void	emu_cleartabs(const HHEMU hhEmu, int selector);
void	emu_reverse_image(const HHEMU hhEmu);
int 	emu_is25lines(const HHEMU hhEmu);
int 	emuKbdKeyLookup(const HHEMU hhEmu, const int key, const PSTKEYTABLE pstKeyTbl);
void	emuInstallStateTable(const HHEMU hhEmu, struct trans_entry const *, int iSize);
//int 	emuKeyTableLoad(const HHEMU hhEmu, const int nTableId, PSTKEYTABLE const pstKeyTbl);
int 	emuKeyTableLoad(const HHEMU hhEmu, const KEYTBLSTORAGE pstKeySource[], const int nNumKeys, PSTKEYTABLE const pstKeyTbl);
int 	emu_kbdlocked(const HHEMU hhEmu, int key, const int fTest);
void 	emuSendKeyString(const HHEMU hhEmu, const int index, const PSTKEYTABLE pstKeyTbl);
void	emuSendString(const HHEMU hhEmu, ECHAR *str, int strln);
void	emuKeyTableFree(PSTKEYTABLE const pstKeyTbl);
int		emuSetEmuName(const HEMU hEmu, const int nEmuId);
void	emuAutoDetectLoad(const HHEMU hhEmu, const int nEmuID);

// From vt_xtra.c
//
void	emuSetDecColumns(const HHEMU hhEmu, const int nColumns, const int fClear);
void	ANSI_DSR(const HHEMU hhEmu);
void	vt_scrollrgn(const HHEMU hhEmu);
void	ANSI_RM(const HHEMU hhEmu);
void	ANSI_SM(const HHEMU hhEmu);
void	vt_alt_kpmode(const HHEMU hhEmu);
void	vt_screen_adjust(const HHEMU hhEmu);
void	DEC_STBM(const HHEMU hhEmu, int top, int bottom);
void	vt52_toANSI(const HHEMU hhEmu);
void	vt_DCH(const HHEMU hhEmu);
void	vt_IL(const HHEMU hhEmu);
void	vt_DL(const HHEMU hhEmu);
void	vt_clearline(const HHEMU hhEmu, const int nSelect);
void	vt_clearscreen(const HHEMU hhEmu, const int nSelect);
void	vt_backspace(const HHEMU hhEmu);
void	vt_CUB(const HHEMU hhEmu);
int     DEC_HHC(const HHEMU hhEmu);

// From ansi.c
//
void	ansi_setmode(const HHEMU hhEmu);
void	ansi_resetmode(const HHEMU hhEmu);
int 	ansi_kbdin(const HHEMU hhEmu, int key, const int fTest);
void	ansi_savecursor(const HHEMU hhEmu);
void	DoorwayMode(const HHEMU hhEmu);
void	emuAnsiUnload(const HHEMU hhEmu);

// From ansiinit.c
//
int 	emuAnsiReset(const HHEMU hhEmu, const int fHostRequest);
void	emuAnsiInit(const HHEMU hhEmu);
void	csrv_init(const HHEMU hhEmu, const int new_emu);

// From vt100.c
//
int 	vt100_kbdin(const HHEMU hhEmu, int key, const int fTest);
void	ANSI_DA(const HHEMU hhEmu);
void	vt100_savecursor(const HHEMU hhEmu);
void	vt100_hostreset(const HHEMU hhEmu);
int 	vt100_reset(const HHEMU hhEmu, const int host_request);
int 	fakevt_kbdin(const HHEMU hhEmu, int key, const int fTest);
void	vt100_prnc(const HHEMU hhEmu);
void	vt100PrintCommands(const HHEMU hhEmu);
void	vt100_answerback(const HHEMU hhEmu);
void	vt100_report(const HHEMU hhEmu);
void	emuDecGraphic(const HHEMU hhEmu);
void	emuSetDoubleAttr(const HHEMU hhEmu);
void	emuSetSingleAttrRow(const HHEMU hhEmu);
void	emuSetDoubleAttrRow(const HHEMU hhEmu, const int iLineAttr);
void	emuFromDblToSingle(const HHEMU hhEmu);
void	emuDecTab(const HHEMU hhEmu);
void	emuDecCUF(const HHEMU hhEmu);
void	emuDecCUP(const HHEMU hhEmu);
void	emuDecCUB(const HHEMU hhEmu);
void	emuDecED(const HHEMU hhEmu);
void	emuVT100Unload(const HHEMU hhEmu);
void	emuDecIND(const HHEMU hhEmu);
void	emuDecRI(const HHEMU hhEmu);
void	emuDecCUU(const HHEMU hhEmu);
void	emuDecCUD(const HHEMU hhEmu);
void	emuDecSetCurPos(const HHEMU hhEmu, const int iRow, const int iCol);
void	emuDecClearScreen(const HHEMU hhEmu, const int iSelector);

// From vt100ini.c
//
void	vt100_init(const HHEMU hhEmu);

// From vt_chars.c
//
void	vt_charset_init(const HHEMU hhEmu);
void	vt_charset_save(const HHEMU hhEmu);
void	vt_charset_restore(const HHEMU hhEmu);
void	vt_charshift(const HHEMU hhEmu);
void	vt_scs1(const HHEMU hhEmu);
void	vt_scs2(const HHEMU hhEmu);
#if defined(EXTENDED_FEATURES)
int 	vt_char_emulatecmd(const HHEMU hhEmu, const ECHAR ccode);
#else
int 	vt_char_emulatecmd(const HEMU hEmu, const ECHAR ccode);
#endif

// From vt52.c
//
void	vt52PrintCommands(const HHEMU hhEmu);
void	vt52Print(const HHEMU hhEmu);
void	vt52_id(const HHEMU hhEmu);
void	vt52_CUP(const HHEMU hhEmu);
int 	vt52_kbdin(const HHEMU hhEmu, int key, const BOOL fTest);
void	emuVT52Unload(const HHEMU hhEmu);

// From vt52init.c
//
void	vt52_init(const HHEMU hhEmu);

// From emuhdl.c
int emuCreateNameTable(const HHEMU hhEmu);
int emuStdDataIn(const HHEMU hhEmu, const ECHAR ccode);

// From vtutf8ini.c
//
void vtutf8_init(const HHEMU hhEmu);
int vtUTF8_kbdin(const HHEMU hhEmu, int key, const int fTest);
void vtUTF8FirstDataByte(const HHEMU hhEmu);
void vtUTF8MiddleDataByte(const HHEMU hhEmu);
void vtUTF8LastDataByte(const HHEMU hhEmu);
void emuVTUTF8Unload(const HHEMU hhEmu);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\emu_scr.c ===
/*	File: D:\WACKER\emu\emu_scr.c (Created: 08-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 5 $
 *	$Date: 3/26/02 5:07p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\cloop.h>
#include <tdll\assert.h>
#include <tdll\capture.h>
#include <tdll\session.h>
#include <tdll\backscrl.h>
#include <tdll\print.h>
#include <tdll\update.h>
#include <tdll\htchar.h>
#include "tdll\misc.h"

#include "emu.h"
#include "emu.hh"
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * backspace
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void backspace(const HHEMU hhEmu)
	{
	INT bWide = 1;
	INT	iRow = row_index(hhEmu, hhEmu->emu_currow);
	INT iCol;

	// Move the cursor back.
	//
	if (hhEmu->emu_curcol > 0)
		{
		bWide = hhEmu->emu_apAttr[iRow][hhEmu->emu_curcol - 1].wirt ? 2 : 1;
		bWide = hhEmu->emu_apAttr[iRow][hhEmu->emu_curcol].wirt ? 0 : bWide;

		(*hhEmu->emu_setcurpos)(hhEmu,
								hhEmu->emu_currow,
								hhEmu->emu_curcol - bWide);

		}

	// Now see if we need to get rid of the character.
	//
	if ((hhEmu->stUserSettings.nEmuId == EMU_TTY &&
		hhEmu->stUserSettings.fDestructiveBk) || (bWide == 0))
		{
		if (bWide == 0)
			iCol = hhEmu->emu_curcol - 1;
		else
			iCol = hhEmu->emu_curcol;	// account for wide chars this way

		hhEmu->emu_code = ETEXT(' ');
		
		(*hhEmu->emu_graphic)(hhEmu);

		(*hhEmu->emu_setcurpos)(hhEmu,
								hhEmu->emu_currow,
								iCol); //MPT:12-8-97 hhEmu->emu_curcol - 1);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void carriagereturn(const HHEMU hhEmu)
	{
	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, 0);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *	iRow -- the row to clear
 *		Note: Since this function calls row_index() with iRow, DO NOT call this
 *		function with a row number that was returned by a call to row_index().
 *		You'll clear the wrong row.
 *
 * RETURNS:
 *
 */
void clear_imgrow(const HHEMU hhEmu, int iRow)
	{
	register int i;
	PSTATTR pstAttr;

	iRow = row_index(hhEmu, iRow);

	ECHAR_Fill(hhEmu->emu_apText[iRow], EMU_BLANK_CHAR, (size_t)MAX_EMUCOLS);

	for (i = 0, pstAttr = hhEmu->emu_apAttr[iRow] ; i <= MAX_EMUCOLS ; ++i)
		pstAttr[i] = hhEmu->emu_clearattr;

	hhEmu->emu_aiEnd[iRow] = EMU_BLANK_LINE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuLineFeed(const HHEMU hhEmu)
	{
	ECHAR aechBuf[10];
	int 	iRow = row_index(hhEmu, hhEmu->emu_currow);

	if (hhEmu->print_echo)
		{
		printEchoLine(hhEmu->hPrintEcho,
			hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow)],
			emuRowLen(hhEmu, iRow));

		if (hhEmu->emu_code == ETEXT('\f'))
			{
			CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("\f"), StrCharGetByteCount(TEXT("\f")));
			printEchoLine(hhEmu->hPrintEcho, aechBuf, sizeof(ECHAR));
			}
		}

	if (hhEmu->mode_LNM)
		ANSI_CNL(hhEmu, 1);
	else
		ANSI_IND(hhEmu);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * emu_print
 *
 * DESCRIPTION:
 *	Prints the specified bufr. Opens a print channel if one is not
 *	already open
 *
 * ARGUMENTS:
 *	bufr -- address of bufr to print
 *	length -- number of chars to print from bufr
 *
 * RETURNS:
 *	nothing
 */
void emuPrintChars(const HHEMU hhEmu, ECHAR *bufr, int nLen)
	{
	int nIndex;
	ECHAR *tChar;

	if (nLen == 0 || bufr == 0)
		return;

	for (nIndex = 0; nIndex < nLen; nIndex++)
		{
		tChar = bufr + nIndex;
		printEchoChar(hhEmu->hPrintHost, *tChar);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void scrolldown(const HHEMU hhEmu, int nlines)
	{
	register int row, nrows;
	int toprow, botmrow;
	int nScrlInc;

	if (nlines <= 0)
		return;

	hhEmu->scr_scrollcnt -= nlines;
	nScrlInc = nlines;

	toprow = hhEmu->top_margin;
	botmrow = hhEmu->bottom_margin;

	if (hhEmu->top_margin == 0 && hhEmu->bottom_margin == hhEmu->emu_maxrow)
		{
		hhEmu->emu_imgtop = row_index(hhEmu, -nlines);
		}

	else if (nlines < hhEmu->bottom_margin - hhEmu->top_margin + 1)
		{
		nrows = hhEmu->bottom_margin - hhEmu->top_margin + 1 - nlines;

		for (row = hhEmu->bottom_margin; nrows > 0; --nrows, --row)
			{
			int c;
			PSTATTR pstAttr, pstAttr2;

			memmove(hhEmu->emu_apText[row_index(hhEmu, row)],
				 hhEmu->emu_apText[row_index(hhEmu, row - nlines)],
						(size_t)(hhEmu->emu_maxcol+2));

			hhEmu->emu_aiEnd[row_index(hhEmu, row - nlines)] =
				hhEmu->emu_aiEnd[row_index(hhEmu, row)];

			pstAttr  = hhEmu->emu_apAttr[row_index(hhEmu, row)];
			pstAttr2 = hhEmu->emu_apAttr[row_index(hhEmu, row - nlines)];

			for (c = 0 ; c <= hhEmu->emu_maxcol ; ++c)
				pstAttr[c] = pstAttr2[c];
			}
		}

	for (row = hhEmu->top_margin; nlines > 0; --nlines, ++row)
		clear_imgrow(hhEmu, row);

	hhEmu->emu_imgrow = row_index(hhEmu, hhEmu->emu_currow);

	updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
					toprow, botmrow, -nScrlInc, hhEmu->emu_imgtop, TRUE);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void scrollup(const HHEMU hhEmu, int nlines)
	{
	register INT row;
	INT 	nrows, iLen, iThisRow;
	ECHAR *lp;			/* line pointer */
	ECHAR aechBuf[10];
	INT nScrlInc;		/* needed for call to Vid routine at bottom of func */

	HBACKSCRL hBackscrl = sessQueryBackscrlHdl(hhEmu->hSession);
	HCAPTUREFILE hCapture = sessQueryCaptureFileHdl(hhEmu->hSession);

	if (nlines <= 0)
		return;

	hhEmu->scr_scrollcnt += nlines;
	nScrlInc = nlines = min(nlines,
							hhEmu->bottom_margin - hhEmu->top_margin + 1);

	for (row = hhEmu->top_margin; row < (hhEmu->top_margin + nlines); ++row)
		{
		iThisRow = row_index(hhEmu, row);
		lp = hhEmu->emu_apText[iThisRow];
		iLen = emuRowLen(hhEmu, iThisRow);

		backscrlAdd(hBackscrl, lp, iLen);

		CaptureLine(hCapture, CF_CAP_SCREENS, lp, iLen);

		printEchoScreen(hhEmu->hPrintEcho, lp, iLen);
		CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("\r\n"), StrCharGetByteCount(TEXT("\r\n")));
		printEchoScreen(hhEmu->hPrintEcho, aechBuf, sizeof(ECHAR) * 2);

		clear_imgrow(hhEmu, row);
		}

	if (hhEmu->top_margin == 0 && hhEmu->bottom_margin == hhEmu->emu_maxrow)
		{
		hhEmu->emu_imgtop = row_index(hhEmu, nlines);
		}

	else if (nlines < (hhEmu->bottom_margin - hhEmu->top_margin + 1))
		{
		nrows = hhEmu->bottom_margin - hhEmu->top_margin + 1 - nlines;

		for (row = hhEmu->top_margin; nrows > 0; --nrows, ++row)
			{
			INT c;
			PSTATTR pstAttr, pstAttr2;

			memmove(hhEmu->emu_apText[row_index(hhEmu, row)],
				 hhEmu->emu_apText[row_index(hhEmu, row + nlines)],
				 (size_t)hhEmu->emu_maxcol + 2);

			hhEmu->emu_aiEnd[row_index(hhEmu, row + nlines)] =
				hhEmu->emu_aiEnd[row_index(hhEmu, row)];

			pstAttr  = hhEmu->emu_apAttr[row_index(hhEmu, row)];
			pstAttr2 = hhEmu->emu_apAttr[row_index(hhEmu, row + nlines)];

			for (c = 0 ; c <= hhEmu->emu_maxcol ; ++c)
				pstAttr[c] = pstAttr2[c];
			}

		for (row = hhEmu->bottom_margin; nlines > 0; --nlines, --row)
			clear_imgrow(hhEmu, row);
		}

	hhEmu->emu_imgrow = row_index(hhEmu, hhEmu->emu_currow);

	updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
					hhEmu->top_margin,
					hhEmu->bottom_margin,
					nScrlInc,
					hhEmu->emu_imgtop,
					TRUE);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void tab(const HHEMU hhEmu)
	{
	int col;

	col = hhEmu->emu_curcol;
	while (col <= hhEmu->emu_maxcol)
		if (hhEmu->tab_stop[++col])
			break;

	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, col);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void backtab(const HHEMU hhEmu)
	{
	int col;

	col = hhEmu->emu_curcol;
	while (col > 0)
		{
		if (hhEmu->tab_stop[--col])
            {
			break;
            }
		}

	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, col);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void tabn(const HHEMU hhEmu)
	{
	int iCol;
	int iTabSize;

	iCol = hhEmu->emu_curcol;

	iTabSize = CLoopGetTabSizeIn(sessQueryCLoopHdl(hhEmu->hSession));

	while (iCol <= hhEmu->emu_maxcol)
		{
		if (++iCol % iTabSize == 0)
			break;
		}

	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, iCol);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emu_bell
 *
 * DESCRIPTION:
 *	 Displays the bell code.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emu_bell(const HHEMU hhEmu)
	{
	mscMessageBeep(-1); // Standard Beep
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emu_clearword
 *
 * DESCRIPTION:
 *	 Clears a part of current line.
 *
 * ARGUMENTS:
 *	 fromcol -- virtual image column of 1st character to be cleared
 *   tocol -- virtual image column of last character to be cleared
 *
 * RETURNS:
 *	 nothing
 */
void emu_clearword(const HHEMU hhEmu, int fromcol, int tocol)
	{
	int c;
	STATTR stAttr;
	int old_mode_IRM;

	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, fromcol);
	old_mode_IRM = hhEmu->mode_IRM;
	hhEmu->mode_IRM = RESET;		   /* overwrite, not insert */
	stAttr = hhEmu->attrState[CSCLEAR_STATE];

	for (c = fromcol; c <= tocol; ++c)
		{
		hhEmu->emu_code = ETEXT(' ');
		(*hhEmu->emu_graphic)(hhEmu);
		}

	hhEmu->attrState[CSCLEAR_STATE] = stAttr;
	hhEmu->mode_IRM = old_mode_IRM;
	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, fromcol);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\minitel.c ===
/*	File: D:\wacker\emu\minitel.c (Created: 05-Mar-1994)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 12 $
 *	$Date: 7/12/02 1:25p $
 */

#include <windows.h>
#pragma hdrstop
													
#include <time.h>

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\session.h>
#include <tdll\cloop.h>
#include <tdll\print.h>
#include <tdll\capture.h>
#include <tdll\assert.h>
#include <tdll\mc.h>
#include <tdll\update.h>
#include <tdll\chars.h>
#include <tdll\cnct.h>
#include <tdll\term.h>
#include <tdll\backscrl.h>
#include <tdll\htchar.h>
#include <term\res.h>
#include <tapi.h>
#include <cncttapi\cncttapi.hh>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"
#include "minitel.hh"
#include "keytbls.h"


#if defined(INCL_MINITEL)

static void emuMinitelRedisplayLine(const HHEMU hhEmu,
										const int row,
										const int col);

static int minitel_kbdin(const HHEMU hhEmu, int key, const int fTest);
static ECHAR minitelMapMosaics(const HHEMU hhEmu, ECHAR ch);
static void minitelFullScrnReveal(const HHEMU hhEmu);
static void minitelFullScrnConceal(const HHEMU hhEmu);
static void minitelSS2(const HHEMU hhEmu);
static void minitelSS2Part2(const HHEMU hhEmu);
static void minitelInsMode(const HHEMU hhEmu);
static void minitelPRO1(const HHEMU hhEmu);
static void minitelPRO2Part1(const HHEMU hhEmu);
static void minitelPRO2Part2(const HHEMU hhEmu);
static void minitelStatusReply(const HHEMU hhEmu);

/*
	Here begins the famed and fabled Minitel emulator.	Abandon all hope
	all ye who..., well you get the idea.  The Minitel emulator uses a
	combination of character attributes and field attributes.  See the
	book "minitel 1B" for description of field attributes.	Page numbers
	referenced in this code refer to the before mentioned book. - mrw
*/

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuMinitelInit
 *
 * DESCRIPTION:
 *	Startup routine for the minitel emulator.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void emuMinitelInit(const HHEMU hhEmu)
	{
	int i;
	LOGFONT lf;
	HWND hwndTerm;
	PSTMTPRIVATE pstPRI;

	static struct trans_entry const minitel_tbl[] =
		{
		{NEW_STATE, 0, 0, 0}, // 0
		{0, ETEXT('\x00'), ETEXT('\x01'), nothing},
		{0, ETEXT('\x20'), ETEXT('\x7F'), minitelGraphic},
		{1, ETEXT('\x1B'), ETEXT('\x1B'), nothing},
		{0, ETEXT('\x07'), ETEXT('\x07'), emu_bell},

		{0, ETEXT('\b'),   ETEXT('\b'), minitelBackspace},
		{0, ETEXT('\t'),   ETEXT('\t'),	minitelHorzTab},
		{0, ETEXT('\n'),   ETEXT('\n'),	minitelLinefeed},
		{0, ETEXT('\x0B'), ETEXT('\x0B'), minitelVerticalTab},
		{0, ETEXT('\x0C'), ETEXT('\x0C'), minitelFormFeed},
		{0, ETEXT('\r'),   ETEXT('\r'),	carriagereturn},
		{0, ETEXT('\x0E'), ETEXT('\x0F'), minitelCharSet},  // change char set
		{0, ETEXT('\x11'), ETEXT('\x11'), minitelCursorOn}, // cursor on
		{5, ETEXT('\x12'), ETEXT('\x12'), nothing},		  // repeat
		{12,ETEXT('\x13'), ETEXT('\x13'), nothing},		  // SEP
		{0, ETEXT('\x14'), ETEXT('\x14'), minitelCursorOff},// cursor off
		{20,ETEXT('\x16'), ETEXT('\x16'), nothing},		  // SS2 (undocumented)
		{0, ETEXT('\x18'), ETEXT('\x18'), minitelCancel},   // cancel
		{20,ETEXT('\x19'), ETEXT('\x19'), nothing}, 	  // SS2
		{0, ETEXT('\x1C'), ETEXT('\x1C'), nothing}, // really is nothing.
		{13,ETEXT('\x1D'), ETEXT('\x1D'), nothing}, // SS3,X ingnored, p99, 1.2.7
		{0, ETEXT('\x1E'), ETEXT('\x1E'), minitelRecordSeparator},
		{3, ETEXT('\x1F'), ETEXT('\x1F'), nothing}, // Unit Seperator
		//{0, ETEXT('\x7F'), ETEXT('\x7F'), minitelDel},

		{NEW_STATE, 0, 0, 0}, // 1 - seen ESC
		{1, ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x01'), ETEXT('\x1F'), minitelResync},
		{18,ETEXT('\x23'), ETEXT('\x23'), nothing},
		{14,ETEXT('\x25'), ETEXT('\x25'), nothing},
		{13,ETEXT('\x35'), ETEXT('\x37'), nothing},	// eat ESC,35-37,X sequences
		{6, ETEXT('\x39'), ETEXT('\x39'), nothing},	// PROT1, p134
		{7, ETEXT('\x3A'), ETEXT('\x3A'), nothing},	// PROT2, p134
		{8, ETEXT('\x3B'), ETEXT('\x3B'), nothing},	// PROT3, p134
		{2, ETEXT('\x5B'), ETEXT('\x5B'), ANSI_Pn_Clr},
		{0, ETEXT('\x40'), ETEXT('\x49'), emuMinitelCharAttr}, // forground color, flashing
		{0, ETEXT('\x4C'), ETEXT('\x4F'), emuMinitelCharAttr}, // char width & height
		{0, ETEXT('\x50'), ETEXT('\x5A'), emuMinitelFieldAttr},// background, underlining
		{0, ETEXT('\x5F'), ETEXT('\x5F'), emuMinitelFieldAttr},// reveal display
		{0, ETEXT('\x5C'), ETEXT('\x5D'), emuMinitelCharAttr}, // inverse
		{0, ETEXT('\x61'), ETEXT('\x61'), minitelCursorReport},
		{22,ETEXT('\x20'), ETEXT('\x2F'), nothing}, // p.99 ISO 2022

		{NEW_STATE, 0, 0, 0}, // 2 - seen ESC [
		{2, ETEXT('\x00'), ETEXT('\x00'), nothing},
		{2, ETEXT('\x30'), ETEXT('\x39'), ANSI_Pn},
		{2, ETEXT('\x3B'), ETEXT('\x3B'), ANSI_Pn_End},
		{2, ETEXT('\x3A'), ETEXT('\x3F'), ANSI_Pn},
		{0, ETEXT('\x40'), ETEXT('\x40'), minitelInsChars},
		{0, ETEXT('\x41'), ETEXT('\x41'), minitelCursorUp},
		{0, ETEXT('\x42'), ETEXT('\x42'), ANSI_CUD},
		{0, ETEXT('\x43'), ETEXT('\x43'), ANSI_CUF},
		{0, ETEXT('\x44'), ETEXT('\x44'), ANSI_CUB},
		{0, ETEXT('\x48'), ETEXT('\x48'), minitelCursorDirect},
		{0, ETEXT('\x4A'), ETEXT('\x4A'), minitelClrScrn},
		{0, ETEXT('\x4B'), ETEXT('\x4B'), minitelClrLn},
		{0, ETEXT('\x4C'), ETEXT('\x4C'), minitelInsRows},
		{0, ETEXT('\x4D'), ETEXT('\x4D'), minitelDelRows},
		{0, ETEXT('\x50'), ETEXT('\x50'), minitelDelChars},
		{0, ETEXT('\x68'), ETEXT('\x69'), minitelInsMode},
		{0, ETEXT('\x7A'), ETEXT('\x7B'), nothing}, //* p144 12.2
		{0, ETEXT('\x7D'), ETEXT('\x7D'), nothing}, //* p144 12.2
		{0, ETEXT('\x7F'), ETEXT('\x7F'), minitelResetTerminal}, //* p145, 13.2

		{NEW_STATE, 0, 0, 0}, // 3 - unit separtor character position
		{3, ETEXT('\x00'), ETEXT('\x00'), nothing},
		{4, ETEXT('\x01'), ETEXT('\xFF'), minitelUSRow},

		{NEW_STATE, 0, 0, 0}, // 4 - end of unit separtor character position
		{4, ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x01'), ETEXT('\xFF'), minitelUSCol},

		{NEW_STATE, 0, 0, 0}, // 5 - number of repeats
		{5, ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x40'), ETEXT('\x7F'), minitelRepeat},
		{0, ETEXT('\x00'), ETEXT('\xFF'), minitelResync},

		{NEW_STATE, 0, 0, 0}, // 6 - Protocol 1 sequence (PRO1,X)
		{6, ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x01'), ETEXT('\xFF'), minitelPRO1},

		{NEW_STATE, 0, 0, 0}, // 7 - Protocol 2 sequence (PRO2,X,Y)
		{7, ETEXT('\x00'), ETEXT('\x00'), nothing},
		{8, ETEXT('\x01'), ETEXT('\xFF'), minitelPRO2Part1},

		{NEW_STATE, 0, 0, 0}, // 8 - Protocol 2 sequence (PRO2,X,Y)
		{8, ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x01'), ETEXT('\xFF'), minitelPRO2Part2},

		{NEW_STATE, 0, 0, 0}, // 9 - Protocol 3 sequence (PRO3,X,Y,Z)
		{9, ETEXT('\x00'), ETEXT('\x00'), nothing},
		{10,ETEXT('\x01'), ETEXT('\xFF'), nothing},

		{NEW_STATE, 0, 0, 0}, // 10 - Protocol 3 sequence (PRO3,X,Y,Z)
		{10,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{11,ETEXT('\x01'), ETEXT('\xFF'), nothing},

		{NEW_STATE, 0, 0, 0}, // 11 - Protocol 3 sequence (PRO3,X,Y,Z)
		{11,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x01'), ETEXT('\xFF'), nothing},

		{NEW_STATE, 0, 0, 0}, // 12 - SEP
		{12,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x01'), ETEXT('\xFF'), nothing},

		{NEW_STATE, 0, 0, 0}, // 13 - ESC,35-39,X sequences eaten, p99, 1.2.7
		{13,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x01'), ETEXT('\xFF'), nothing},

		{NEW_STATE, 0, 0, 0}, // 14 - screen transparency mode
		{15,ETEXT('\x1B'), ETEXT('\x1B'), nothing},
		{14,ETEXT('\x00'), ETEXT('\xFF'), nothing},
		{23,ETEXT('\x20'), ETEXT('\x2F'), nothing}, // could be ISO 2022

		{NEW_STATE, 0, 0, 0}, // 15 - screen transparency mode continued, seen ESC
		{16,ETEXT('\x25'), ETEXT('\x25'), nothing},
		{17,ETEXT('\x2F'), ETEXT('\x2F'), nothing},
		{15,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{14,ETEXT('\x00'), ETEXT('\xFF'), nothing},

		{NEW_STATE, 0, 0, 0}, // 16 - screen transparency mode continued, seen ESC \x25
		{0, ETEXT('\x40'), ETEXT('\x40'), nothing},
		{16,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{14,ETEXT('\x00'), ETEXT('\xFF'), nothing},

		{NEW_STATE, 0, 0, 0}, // 17 - screen transparency mode continued, seen ESC \x2F
		{0, ETEXT('\x3F'), ETEXT('\x3F'), nothing},
		{17,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{14,ETEXT('\x00'), ETEXT('\xFF'), nothing},

		{NEW_STATE, 0, 0, 0}, // 18 - Full screen reveal/hide, seen ESC \x23
		{18,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{19,ETEXT('\x20'), ETEXT('\x20'), nothing},
		{23,ETEXT('\x20'), ETEXT('\x2F'), nothing}, // could be ISO 2022

		{NEW_STATE, 0, 0, 0}, // 19 - Full screen reveal/hide, seen ESC \x23 \x20
		{19,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x58'), ETEXT('\x58'), minitelFullScrnConceal},
		{0, ETEXT('\x5F'), ETEXT('\x5F'), minitelFullScrnReveal},

		{NEW_STATE, 0, 0, 0}, // 20 - SS2
		{20,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x00'), ETEXT('\x1F'), minitelResync},
		{21,ETEXT('\x20'), ETEXT('\x7F'), minitelSS2}, // valid SS2

		{NEW_STATE, 0, 0, 0}, // 21 - SS2 part 2
		{21,ETEXT('\x00'), ETEXT('\x00'), nothing},
		{0, ETEXT('\x20'), ETEXT('\x7F'), minitelSS2Part2}, // valid SS2

		{NEW_STATE, 0, 0, 0}, // 22 - p.99 ISO 2022
		{23,ETEXT('\x20'), ETEXT('\x2F'), nothing},
		{0, ETEXT('\x00'), ETEXT('\x1F'), minitelResync},

		{NEW_STATE, 0, 0, 0}, // 23 - p.99 ISO 2022
		{24,ETEXT('\x20'), ETEXT('\x2F'), nothing},
		{0, ETEXT('\x00'), ETEXT('\x1F'), minitelResync},

		{NEW_STATE, 0, 0, 0}, // 24 - p.99 ISO 2022
		{25, ETEXT('\x30'), ETEXT('\x3F'), nothing}, // page 107.
		{0,  ETEXT('\x30'), ETEXT('\x7E'), nothing}, // final character
		{0,  ETEXT('\x00'), ETEXT('\x1F'), minitelResync},

		{NEW_STATE, 0, 0, 0}, // 25 - p.99 ISO 2022
		{0,  ETEXT('\x0D'), ETEXT('\x0D'), nothing}, // page 107. eat CR
		{0,  ETEXT('\x00'), ETEXT('\x7F'), minitelResync},
		};

	if (hhEmu == 0)
		{
		assert(0);
		return;
		}

	emuInstallStateTable(hhEmu, minitel_tbl, DIM(minitel_tbl));

	// Allocate and initialize private data for Minitel emulator.
	//
	if (hhEmu->pvPrivate != 0)
		{
		free(hhEmu->pvPrivate);
		hhEmu->pvPrivate = 0;
		}

	hhEmu->pvPrivate = malloc(sizeof(MTPRIVATE));

	if (hhEmu->pvPrivate == 0)
		{
		assert(FALSE);
		return;
		}

	pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;
	memset(pstPRI, 0, sizeof(MTPRIVATE));

	pstPRI->minitel_last_char = ETEXT(' ');

	/* load key array */

	emuKeyTableLoad(hhEmu, Minitel_KeyTable,
					 sizeof(Minitel_KeyTable)/sizeof(KEYTBLSTORAGE),
					 &hhEmu->stEmuKeyTbl);

	/* --- Allocate attribute buffer for Minitel junk --- */

	pstPRI->apstMT = malloc(MAX_EMUROWS * sizeof(PSTMINITEL));

	if (pstPRI->apstMT == 0)
		{
		assert(FALSE);
		return;
		}

	memset(pstPRI->apstMT, 0, MAX_EMUROWS * sizeof(PSTMINITEL));

	for (i = 0 ; i < MAX_EMUROWS ; ++i)
		{
		pstPRI->apstMT[i] = malloc(MAX_EMUCOLS * sizeof(STMINITEL));

		if (pstPRI->apstMT[i] == 0)
			{
			assert(FALSE);
			return;
			}

		memset(pstPRI->apstMT[i], 0, MAX_EMUCOLS * sizeof(STMINITEL));
		}

	/* --- Setup defaults --- */

	hhEmu->emu_maxrow = 24; 		   // 25 line emulator
	hhEmu->emu_maxcol = 39; 		   // start in 40 column mode
	hhEmu->top_margin = 1;			   // access to row 0 is restricted.
	hhEmu->bottom_margin = hhEmu->emu_maxrow; // this has to equal emu_maxrow which changed

	hhEmu->emu_kbdin = minitel_kbdin;
	hhEmu->emu_graphic = minitelGraphic;
	hhEmu->emu_deinstall = emuMinitelDeinstall;
	hhEmu->emu_ntfy = minitelNtfy;
	hhEmu->emuHomeHostCursor = minitelHomeHostCursor;
#ifdef INCL_TERMINAL_SIZE_AND_COLORS
    hhEmu->emu_setscrsize	= emuMinitelSetScrSize;
#endif
	hhEmu->emu_highchar = (TCHAR)0xFF;

	if (hhEmu->emu_currow == 0)
		(*hhEmu->emu_setcurpos)(hhEmu, 1, hhEmu->emu_curcol - 1);

	// Also, set font to Arial Alternative
	//
	memset(&lf, 0, sizeof(LOGFONT));
	hwndTerm = sessQueryHwndTerminal(hhEmu->hSession);
	termGetLogFont(hwndTerm, &lf);

	if (StrCharCmpi(lf.lfFaceName, "Arial Alternative") != 0)
		{
		StrCharCopyN(lf.lfFaceName, "Arial Alternative", LF_FACESIZE);
        lf.lfWeight = FW_DONTCARE;
        lf.lfItalic = FALSE;
        lf.lfUnderline = FALSE;
        lf.lfStrikeOut = FALSE;
		lf.lfCharSet = DEFAULT_CHARSET;
        lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
        lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
        lf.lfQuality = DEFAULT_QUALITY;
		lf.lfPitchAndFamily = FIXED_PITCH | FF_MODERN;
		termSetLogFont(hwndTerm, &lf);
		}

	// Backscroll not supported in minitel
	//
	backscrlSetUNumLines(sessQueryBackscrlHdl(hhEmu->hSession), 0);

	// Initialize colors for the Minitel.
	//
	std_setcolors(hhEmu, VC_BRT_WHITE, VC_BLACK);

	// Set terminal to power-up state
	//
	minitelResetTerminal(hhEmu);

	// Turn backscroll off for Minitel
	//
	backscrlSetShowFlag(sessQueryBackscrlHdl(hhEmu->hSession), FALSE);

	// Enable Minitel toolbar buttons
	//
	PostMessage(sessQueryHwnd(hhEmu->hSession), WM_SESS_SHOW_SIDEBAR, 0, 0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuMinitelDeinstall
 *
 * DESCRIPTION:
 *	Frees the extra attribute buffer needed to manage serial attributes.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void emuMinitelDeinstall(const HHEMU hhEmu)
	{
	int i;
	PSTMTPRIVATE pstPRI;

	assert(hhEmu);
	pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	if (pstPRI)
		{
		if (pstPRI->apstMT)
			{
			for (i = 0 ; i < MAX_EMUROWS ; ++i)
				{
				if (pstPRI->apstMT[i])
					{
					free(pstPRI->apstMT[i]);
					pstPRI->apstMT[i] = NULL;
					}
				}

			free(pstPRI->apstMT);
			pstPRI->apstMT = 0;
			}

		free(hhEmu->pvPrivate);
		hhEmu->pvPrivate = 0;
		}

	// Hide Minitel toolbar buttons
	//
	ShowWindow(sessQuerySidebarHwnd(hhEmu->hSession), SW_HIDE);

    //
    // Make sure to free the key table that was created when the emulator
    // was loaded, otherwise there is a memory leak. REV: 05/09/2001
    //
	emuKeyTableFree(&hhEmu->stEmuKeyTbl);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelReset
 *
 * DESCRIPTION:
 *	Sets emulator to an initial state.	Used for record and unit
 *	separators.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void minitelReset(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	pstPRI->minitelG1Active = FALSE;

	memset(&hhEmu->emu_charattr, 0, sizeof(hhEmu->emu_charattr));
	hhEmu->emu_charattr.txtclr = VC_BRT_WHITE;
	hhEmu->emu_charattr.bkclr = VC_BLACK;

	pstPRI->apstMT[hhEmu->emu_imgrow][hhEmu->emu_curcol].isattr = 0;

	memset(&pstPRI->stLatentAttr, 0, sizeof(pstPRI->stLatentAttr));
	pstPRI->stLatentAttr.fBkClr = TRUE;

	hhEmu->attrState[CS_STATE] =
		hhEmu->attrState[CSCLEAR_STATE] = hhEmu->emu_charattr;

	hhEmu->emu_clearattr = hhEmu->emu_charattr;
	minitelNtfy(hhEmu, 0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelGraphic
 *
 * DESCRIPTION:
 *	Handles displayable characters.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void minitelGraphic(const HHEMU hhEmu)
	{
	ECHAR ccode;
	ECHAR aechBuf[10];
	int r;
	int row = hhEmu->emu_currow;
	int col = hhEmu->emu_curcol;
	BOOL fRedisplay = FALSE;
    BOOL fDblHi;
	STATTR stAttr;

	ECHAR *tp = hhEmu->emu_apText[hhEmu->emu_imgrow];
	const PSTATTR ap = hhEmu->emu_apAttr[hhEmu->emu_imgrow];
	const HUPDATE hUpdate = sessQueryUpdateHdl(hhEmu->hSession);
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	ccode = hhEmu->emu_code;

	if (ccode == 0)
		return;

	pstPRI->minitel_last_char = ccode;

	if (hhEmu->mode_IRM == SET)
		{
		if (col < hhEmu->emu_maxcol)
			{
			memmove(&tp[col+1], &tp[col],
						(unsigned)(hhEmu->emu_maxcol-col) * sizeof(ECHAR));

			memmove(&ap[col+1], &ap[col],
						(unsigned)(hhEmu->emu_maxcol-col) * sizeof(STATTR));

			memmove(&pstPRI->apstMT[hhEmu->emu_imgrow][col+1],
						&pstPRI->apstMT[hhEmu->emu_imgrow][col],
						(unsigned)(hhEmu->emu_maxcol-col) * sizeof(STMINITEL));
			}
		}

	/* --- check if we are overwriting an attribute space --- */

	if (pstPRI->apstMT[hhEmu->emu_imgrow][col].isattr)
		{
		pstPRI->apstMT[hhEmu->emu_imgrow][col].isattr = FALSE;
		fRedisplay = TRUE;
		}

	/* --- If we receive a space and have latent attributes, validate --- */

	if (ccode == ETEXT('\x20') && pstPRI->stLatentAttr.fModified
			&& pstPRI->minitelG1Active == FALSE)
		{
		r = hhEmu->emu_imgrow;

		// Color
		//
		pstPRI->apstMT[r][col].fbkclr = pstPRI->stLatentAttr.fBkClr;
		pstPRI->apstMT[r][col].bkclr = pstPRI->stLatentAttr.bkclr;

		// Conceal
		//
		pstPRI->apstMT[r][col].conceal = pstPRI->stLatentAttr.conceal;

		// Underline
		//
		pstPRI->apstMT[r][col].undrln = pstPRI->stLatentAttr.undrln;

		pstPRI->apstMT[hhEmu->emu_imgrow][col].isattr  = TRUE;

		// This is truely wierd.  We don't reset the fBkclr, fConceal, or
		// fUndrln fields, only the fModified flag.  Thus if any serial
		// attributes are set, all latent values get updated.  The only
		// guy who appears to be able to turn off an attribute is the
		// mosaic character which validates the background color and sets
		// the fBkClr flag to false.  I can't think of a reason why it
		// should work this way. - mrw
		//
		pstPRI->stLatentAttr.fModified = FALSE;
	    fRedisplay = TRUE;
		}

	/* --- If we switched to G1, map char to location in new font --- */

	if (pstPRI->minitelG1Active)
		ccode = minitelMapMosaics(hhEmu, ccode);

	pstPRI->apstMT[hhEmu->emu_imgrow][col].ismosaic =
		(unsigned)pstPRI->minitelG1Active;

	/* --- If we switched to semigraphic mode, validate the background --- */

	if (pstPRI->minitelG1Active)
		{
		// Guess what?	Latent background color is always adopted for mosaics.
		// This is a major undocumented find.  Basicly, mosaics
		// (semigraphics) always use the latent background color regardless
		// of the validation state.
		//
		ap[col].bkclr = pstPRI->stLatentAttr.bkclr;
		fRedisplay = TRUE;

		// Something tricky here.  Reception of a mosaic validates the
		// background color.  Validate means adopt the color.  It also
		// means that if we shift back to the alpha (G0 char set) and
		// recieve a space, we DON'T validate the background color a
		// second time.  So we keep a seperate flag for the background
		// color validation. - mrw
		//
		pstPRI->stLatentAttr.fBkClr = FALSE;
		}

	/* --- Normal character processing --- */

	tp[col] = ccode;

	// Update the end of row index if necessary.
	//
	if (col > hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = col;

	/* --- Find out this characters current attributes and adjust --- */

	stAttr = GetAttr(hhEmu, row, col);
	ap[col] = hhEmu->emu_charattr;
	ap[col].bkclr = stAttr.bkclr;
	ap[col].blank = stAttr.blank;
	ap[col].undrln = stAttr.undrln;

	if (pstPRI->minitelG1Active)
		ap[col].symbol = 1;

	// Documented: 0x7F (mosaic or alpha) always maps to 0x5F in the G1
	// character set (solid block).
	//
	if (tp[col] == ETEXT('\x7F'))
		{
		tp[col] = ETEXT('\x5F');
		ap[col].symbol = 1;
		}

	/* --- Double high stuff --- */

	if (hhEmu->emu_charattr.dblhilo)
		{
		if (row >= 2)
			{
			r = row_index(hhEmu, row-1);

			hhEmu->emu_apText[r][col] = ccode;
			hhEmu->emu_apAttr[r][col] = ap[col];
			hhEmu->emu_apAttr[r][col].dblhilo = 0;
			hhEmu->emu_apAttr[r][col].dblhihi = 1;
			pstPRI->apstMT[r][col] = pstPRI->apstMT[hhEmu->emu_imgrow][col];
			updateChar(hUpdate, row-1, col, col);
			}
		}

	/* --- Double wide stuff --- */

	if (hhEmu->emu_charattr.dblwilf)
		{
		if (row > 0 && col < hhEmu->emu_maxcol)
			{
			tp[col+1] = ccode;
			ap[col+1] = ap[col];
			ap[col+1].dblwilf = 0;
			ap[col+1].dblwirt = 1;

			// Major league bug.
			//
			pstPRI->apstMT[hhEmu->emu_imgrow][col+1] =
				pstPRI->apstMT[hhEmu->emu_imgrow][col];
			}

		if (hhEmu->emu_charattr.dblhilo)
			{
			r = row_index(hhEmu, row-1);

			hhEmu->emu_apText[r][col+1] = ccode;
			hhEmu->emu_apAttr[r][col+1] = ap[col];
			hhEmu->emu_apAttr[r][col+1].dblwilf = 0;
			hhEmu->emu_apAttr[r][col+1].dblwirt = 1;
			hhEmu->emu_apAttr[r][col+1].dblhilo = 0;
			hhEmu->emu_apAttr[r][col+1].dblhihi = 1;
			pstPRI->apstMT[r][col+1] = pstPRI->apstMT[hhEmu->emu_imgrow][col];
			}
		}

	/* --- Need to use old row and column --- */

	if (fRedisplay)
		emuMinitelRedisplayLine(hhEmu, row, col);

	/* --- Need to bump the column guy an extra notch if double wide --- */

	if (hhEmu->emu_charattr.dblwilf)
		{
		col += 1;
		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = col;
		}

	updateChar(hUpdate, row, hhEmu->emu_curcol, col);

	/* --- bump column position, check for wrap, etc. --- */

	if (++col > hhEmu->emu_maxcol)
		{
		// Escape code 0x18 is referred to as cancel in the minitel doco.
		// It fills from the cursor pos to the end of the row with blanks.
		// Note: Also, it does not force wrap in anyway since
		// the cursor position is not updated.	That's why we have to
		// check here. - mrw:5/3/95
		//
		if (pstPRI->fInCancel || row == 0)
			{
			col = hhEmu->emu_maxcol;
			return;
			}

		printEchoString(hhEmu->hPrintEcho, tp,
			emuRowLen(hhEmu, hhEmu->emu_imgrow));

		CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("\r\n"),
			StrCharGetByteCount(TEXT("\r\n")));

		printEchoString(hhEmu->hPrintEcho, aechBuf, sizeof(ECHAR) * 2);

		CaptureLine(sessQueryCaptureFileHdl(hhEmu->hSession), CF_CAP_LINES,
			tp, emuRowLen(hhEmu, hhEmu->emu_imgrow));

        // Wrap around accounts for double high
		//
		fDblHi = (BOOL)hhEmu->emu_charattr.dblhilo;

		if (row == hhEmu->bottom_margin)
			{
			if (pstPRI->fScrollMode)
				minitel_scrollup(hhEmu, fDblHi ? 2 : 1);

			else
				row = fDblHi ? 2 : 1;
			}

		else if (row != 0)
			{
			row += fDblHi ? 2 : 1;

			if (row > hhEmu->emu_maxrow)
                row = 2;
			}

		col = 0;
		}

	// Finally, set the cursor position.  This will reset emu_currow
	// and emu_curcol.
	//
	(*hhEmu->emu_setcurpos)(hhEmu, row, col);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuMinitelRedisplayLine
 *
 * DESCRIPTION:
 *	The trick to field attributes is when you encounter one, you need to
 *	update the rest of the line that follows since changing or overwriting
 *	an attribute space affects stuff to the right.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *	int row - row to redisplay
 *	int col - start column
 *
 * RETURNS:
 *	void
 *
 */
static void emuMinitelRedisplayLine(const HHEMU hhEmu,
									const int row,
									const int col)
	{
	int i = row_index(hhEmu, row);
    int fDblHi = FALSE;
	const ECHAR *tp = hhEmu->emu_apText[i];
	const PSTATTR ap = hhEmu->emu_apAttr[i];
	const PSTATTR apl = hhEmu->emu_apAttr[row_index(hhEmu, row-1)];
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;
	const PSTMINITEL pstMT = pstPRI->apstMT[i];

	for (i = col ; i <= hhEmu->emu_maxcol ; ++i)
		{
		ap[i] = GetAttr(hhEmu, row, i);

		// Here's a wierd one.  Attribute spaces (as opposed to plain spaces)
		// validate but do not display the underline attribute.  I suspect
		// something similar with seperated mosaics. - mrw

		if (tp[i] == ETEXT('\x20') && pstMT[i].isattr)
			ap[i].undrln = 0;

        // If we're redisplaying a row that has a double hi character,
        // then we have to redisplay the upper-half as well.

        if (ap[i].dblhilo)
            {
            fDblHi = TRUE;
			apl[i] = GetAttr(hhEmu, row-1, i);
            }
		}

	if (fDblHi)
		{
		updateChar(sessQueryUpdateHdl(hhEmu->hSession),
						row-1, col, hhEmu->emu_maxcol);
		}

	updateChar(sessQueryUpdateHdl(hhEmu->hSession),
						row, col, hhEmu->emu_maxcol);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	GetAttr
 *
 * DESCRIPTION:
 *	Walks the current row and builds a composite attribute based on
 *	the encountered attribute spaces.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *	iRow	- logical row
 *	iCol	- logical col
 *
 * RETURNS:
 *	composite attribute.
 *
 */
STATTR GetAttr(const HHEMU hhEmu, const int iRow, const int iCol)
	{
	int i;
	STATTR stAttr;
	const int r = row_index(hhEmu, iRow);
	const PSTATTR ap = hhEmu->emu_apAttr[r];
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;
	const PSTMINITEL pstMT = pstPRI->apstMT[r];

	stAttr = hhEmu->emu_apAttr[r][iCol];
	stAttr.bkclr = 0;
	stAttr.undrln = 0;
	stAttr.blank = 0;

	for (i = 0 ; i <= iCol ; ++i)
		{
        // Mosaics validate the background color.  Do it first however,
        // because an attribute space can change it to something else.

		if (pstMT[i].ismosaic)
			stAttr.bkclr = ap[i].bkclr;

		if (pstMT[i].isattr)
			{
			if (pstMT[i].fbkclr)
				stAttr.bkclr = pstMT[i].bkclr;

			stAttr.undrln = pstMT[i].undrln;
			stAttr.blank = pstMT[i].conceal;
			}

		// Mosaics always cancel underlining.
		//
		if (pstMT[i].ismosaic)
			stAttr.undrln = 0;
		}

	return stAttr;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuMinitelCharAttr
 *
 * DESCRIPTION:
 *	Modifies the current character attribute.  Does not affect field
 *	attributes.
 *
 *	mrw - 11/1/94: Went to high intensity colors to more closely match
 *	the minitel colors.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void emuMinitelCharAttr(const HHEMU hhEmu)
	{
	STATTR stAttr = hhEmu->attrState[CS_STATE];
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	switch (hhEmu->emu_code)
		{
	case ETEXT('\x40'):	 stAttr.txtclr = 0;  break;
	case ETEXT('\x41'):	 stAttr.txtclr = 12; /*4*/	break;
	case ETEXT('\x42'):	 stAttr.txtclr = 10; /*2*/	break;
	case ETEXT('\x43'):	 stAttr.txtclr = 14; /*6*/	break;
	case ETEXT('\x44'):	 stAttr.txtclr = 9;  /*1*/	break;
	case ETEXT('\x45'):	 stAttr.txtclr = 13; /*5*/	break;
	case ETEXT('\x46'):	 stAttr.txtclr = 11; /*3*/	break;
	case ETEXT('\x47'):	 stAttr.txtclr = 15; break;

	case ETEXT('\x48'):	 stAttr.blink  = 1;  break;
	case ETEXT('\x49'):	 stAttr.blink  = 0;  break;

	case ETEXT('\x4C'):			// normal size
		if (pstPRI->minitelG1Active)
			return;

		stAttr.dblhilo = 0;
		stAttr.dblwilf = 0;
		break;

	case ETEXT('\x4D'):			// double height
		if (pstPRI->minitelG1Active || hhEmu->emu_currow <= 1)
			return;

		stAttr.dblhilo= 1;
		stAttr.dblwilf = 0;
		break;

	case ETEXT('\x4E'):			// double width
		if (pstPRI->minitelG1Active || hhEmu->emu_currow < 1)
			return;

		stAttr.dblhilo = 0;
		stAttr.dblwilf	= 1;
		break;

	case ETEXT('\x4F'):			// double size
		if (pstPRI->minitelG1Active || hhEmu->emu_currow <= 1)
			return;

		stAttr.dblhilo = 1;
		stAttr.dblwilf	= 1;
		break;

	case ETEXT(ETEXT('\x5C')):    // normal polarity
		if (pstPRI->minitelG1Active)
			return;

		stAttr.revvid = 0;
		break;

	case ETEXT(ETEXT('\x5D')):    // reverse polarity
		if (pstPRI->minitelG1Active)
			return;

		stAttr.revvid = 1;
		break;

	default:
		break;
		}

	/* --- commit changes --- */

	hhEmu->emu_charattr =
	hhEmu->attrState[CS_STATE] =
	hhEmu->attrState[CSCLEAR_STATE] = stAttr;

	hhEmu->attrState[CSCLEAR_STATE].revvid = 0;
	hhEmu->attrState[CSCLEAR_STATE].undrln = 0;

	hhEmu->emu_clearattr = hhEmu->attrState[CSCLEAR_STATE];
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuMinitelFieldAttr
 *
 * DESCRIPTION:
 *	Dreaded field attributes.  Actually, this routine updates what is
 *	called a Latent Attribute.	The attributes only become effective
 *	when a space is recieved.
 *
 *	mrw - 11/1/94: Went to high intensity colors to more closely match
 *	the minitel colors.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void emuMinitelFieldAttr(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;
	LATENTATTR * const pstLA = &pstPRI->stLatentAttr;

	switch (hhEmu->emu_code)
		{
	case ETEXT('\x50'):	 pstLA->bkclr = 0;	 break;
	case ETEXT('\x51'):	 pstLA->bkclr = 12;  break;
	case ETEXT('\x52'):	 pstLA->bkclr = 10;  break;
	case ETEXT('\x53'):	 pstLA->bkclr = 14;  break;
	case ETEXT('\x54'):	 pstLA->bkclr = 9;	 break;
	case ETEXT('\x55'):	 pstLA->bkclr = 13;  break;
	case ETEXT('\x56'):	 pstLA->bkclr = 11;  break;
	case ETEXT('\x57'):	 pstLA->bkclr = 15;  break;

	case ETEXT('\x58'):	 pstLA->conceal=1;	 break;
	case ETEXT('\x5F'):	 pstLA->conceal=0;	 break;

	case ETEXT('\x59'):	// separated mosaics off
		if (pstPRI->minitelG1Active)
			{
			pstPRI->minitelUseSeparatedMosaics = 0;
			return;
			}

		else
			{
			pstPRI->stLatentAttr.undrln = 0;
			}
		break;

	case ETEXT('\x5A'):	// separated mosaics on
		if (pstPRI->minitelG1Active)
			{
			pstPRI->minitelUseSeparatedMosaics = 1;
			return;
			}

		else
			{
			pstPRI->stLatentAttr.undrln = 1;
			}
		break;

	default:	
	    return;
		}

	// Undocumented: setting any field attribute invalidates the
	// latent color context.
	//
	pstPRI->stLatentAttr.fBkClr = TRUE;

	pstPRI->stLatentAttr.fModified = TRUE;
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * minitel_kbdin
 *
 * DESCRIPTION:
 *	 Processes keys for the minitel emulator.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *	key 	- key to process
 *
 * RETURNS:
 *	 nothing
 */
static int minitel_kbdin(const HHEMU hhEmu, int key, const int fTest)
	{
	int index;
	TCHAR c;
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	if ((index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl)) != -1)
		{
		if (!fTest)
			{
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl);

			// This completes the code sent by emuSendKeyString(), page 124
			//
			if (key == (VK_RIGHT | VIRTUAL_KEY | SHIFT_KEY) ||
				key == (VK_RIGHT | VIRTUAL_KEY | SHIFT_KEY | EXTENDED_KEY))
				{
				c = (pstPRI->minitelSecondDep) ? TEXT('\x6c') : TEXT('\x68');

				CLoopCharOut(sessQueryCLoopHdl(hhEmu->hSession), c);
				}

			// Check for disconnect key.  If hit twice consecutively,
			// it posts a disconnect to the modem guy.
			//
			if (key == (VK_F9 | VIRTUAL_KEY))
				{
				pstPRI->F9 += 1;


				if (pstPRI->F9 == 2)
					{
					PostMessage(sessQueryHwnd(hhEmu->hSession),
						WM_DISCONNECT, 0, 0);
                    pstPRI->F9 = 0;
					}
				}
			}
		}

	else
		{
		// reset F9 counter, must have two consecutive to disconnect
		//
		pstPRI->F9 = 0;
		index = std_kbdin(hhEmu, key, fTest);
		}

	return index;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelCharSet
 *
 * DESCRIPTION:
 *	We don't really switch character sets here.  Since minitel uses
 *	7 bit ASCII, we can user the half of the ASCII table for the
 *	contigous and seperated mosaics that comprise the G1 char set.
 *	Other rule here is that switching the the G1 character set
 *	validates the background color on reception of the first mosaic.
 *	One thing I haven't figured out yet is when a field attribute is
 *	validated, does the latent attribute get reset or retain the last color?
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void minitelCharSet(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	pstPRI->stLatentAttr.undrln = 0;

	if (hhEmu->emu_code == ETEXT(0x0E)) // switch to G1
		{
		pstPRI->minitelG1Active = TRUE;
		pstPRI->minitelUseSeparatedMosaics = FALSE;
		}

	else
		{
		pstPRI->minitelG1Active = FALSE;
		}

	// underline, size and polarity attributes permanently canceled.
	//
	hhEmu->emu_charattr.undrln = 0;
	hhEmu->emu_charattr.dblhihi = 0;
	hhEmu->emu_charattr.dblhilo = 0;
	hhEmu->emu_charattr.dblwilf = 0;
	hhEmu->emu_charattr.dblwirt = 0;
	hhEmu->emu_charattr.revvid = 0;
	hhEmu->emu_charattr.symbol = 0;

	hhEmu->attrState[CS_STATE] =
		hhEmu->attrState[CSCLEAR_STATE] = hhEmu->emu_charattr;

	hhEmu->emu_clearattr = hhEmu->emu_charattr;

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelResetTerminal
 *
 * DESCRIPTION:
 *	Response to a 1B 39 7F sequence.  Puts terminal in power-up state.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void minitelResetTerminal(const HHEMU hhEmu)
	{
	minitelClearScreen(hhEmu, 0);  // clear screen
	(*hhEmu->emu_setcurpos)(hhEmu, 0, 0);

	minitelClearLine(hhEmu, 0);    // clear line 0
	(*hhEmu->emu_setcurpos)(hhEmu, 1, 0);

	minitelReset(hhEmu);		 // reset attributes

	((PSTMTPRIVATE)hhEmu->pvPrivate)->fScrollMode = 0;
	EmuStdSetCursorType(hhEmu, EMU_CURSOR_NONE);
	minitelNtfy(hhEmu, 0);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelCursorOn
 *
 * DESCRIPTION:
 *	Turns minitel cursor on.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void minitelCursorOn(const HHEMU hhEmu)
	{
	EmuStdSetCursorType(hhEmu, EMU_CURSOR_BLOCK);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelCursorOff
 *
 * DESCRIPTION:
 *	Turns minitel cursor off
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void minitelCursorOff(const HHEMU hhEmu)
	{
	#if defined(NDEBUG)
	EmuStdSetCursorType(hhEmu, EMU_CURSOR_NONE);
	#else
	EmuStdSetCursorType(hhEmu, EMU_CURSOR_BLOCK);
	#endif

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	mintelMapMosaics
 *
 * DESCRIPTION:
 *	Maps regular character to a mosaic char for our font only.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *	ch	- character to convert
 *
 * RETURNS:
 *	converted or original character.
 *
 */
static ECHAR minitelMapMosaics(const HHEMU hhEmu, ECHAR ch)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	if (ch >= ETEXT('\x21') && ch <= ETEXT('\x3F'))
		ch += ETEXT('\x1F');

	// Another weird undocumented affect.  Columns 4 and 5 (except 5F)
	// map to columns 6 and 7 (page 101)
    //
	else if (ch >= ETEXT('\x40') && ch <= ETEXT('\x5E'))
		ch += ETEXT('\x20');

	else if (ch >= ETEXT('\x60') && ch <= ETEXT('\x7E'))
		ch += 0;

	if (pstPRI->minitelUseSeparatedMosaics && ch >= ETEXT('\x21') &&
		ch <= ETEXT('\x7F'))
		{
		ch += ETEXT('\x40');
		}

	return ch;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelCursorReport
 *
 * DESCRIPTION:
 *	Return the current cursor location as US row col.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void minitelCursorReport(const HHEMU hhEmu)
	{
	TCHAR ach[40];
	ECHAR aech[40];

	wsprintf(ach, TEXT("US%c%c"), hhEmu->emu_currow, hhEmu->emu_curcol);

	CnvrtMBCStoECHAR(aech, sizeof(aech), ach,
        StrCharGetByteCount(ach) + sizeof(TCHAR));

	emuSendString(hhEmu, aech, StrCharGetEcharByteCount(aech));
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelFullScrnConceal
 *
 * DESCRIPTION:
 *	Just sets the blank bits on all the attributes.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
static void minitelFullScrnConceal(const HHEMU hhEmu)
	{
	int i, j;
	PSTATTR ap;

	for (i = 1 ; i <= hhEmu->emu_maxrow ; ++i)
		{
		ap = hhEmu->emu_apAttr[row_index(hhEmu, i)];

		for (j = 0 ; j <= hhEmu->emu_maxcol ; ++j, ++ap)
			ap->blank = 1;

		updateLine(sessQueryUpdateHdl(hhEmu->hSession),
										1, hhEmu->emu_maxrow);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelFullScrnReveal
 *
 * DESCRIPTION:
 *	Just sets the blank bits on all the attributes.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
static void minitelFullScrnReveal(const HHEMU hhEmu)
	{
	int i, j;
	PSTATTR ap;

	for (i = 1 ; i <= hhEmu->emu_maxrow ; ++i)
		{
		ap = hhEmu->emu_apAttr[row_index(hhEmu, i)];

		for (j = 0 ; j <= hhEmu->emu_maxcol ; ++j, ++ap)
			ap->blank = 0;
		}

	updateLine(sessQueryUpdateHdl(hhEmu->hSession), 1, hhEmu->emu_maxrow);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelResync
 *
 * DESCRIPTION:
 *	Certain codes will cause the emulator to resynchronize, (goto state
 *	zero) and play the character thru.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void minitelResync(const HHEMU hhEmu)
	{
	hhEmu->state = 0;
#if defined(EXTENDED_FEATURES)
	(void)(*hhEmu->emu_datain)(hhEmu, hhEmu->emu_code);
#else
	(void)(*hhEmu->emu_datain)((HEMU)hhEmu, hhEmu->emu_code);
#endif
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelSS2
 *
 * DESCRIPTION:
 *	SS2 is an alternate character set.	It only has about 15 symbols so
 *	we just map them here to ones in our current minitel font.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
static void minitelSS2(const HHEMU hhEmu)
	{
	const int row = hhEmu->emu_currow;
	const int col = hhEmu->emu_curcol;
	BOOL  fNoAdvance = FALSE;
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	/* --- SS2 codes are ignored in semigraphic mode --- */

	if (pstPRI->minitelG1Active)
		{
		hhEmu->state = 0;
		return;
		}

	/* --- Map the character --- */

	switch (hhEmu->emu_code)
		{
	case ETEXT('\x23'):	hhEmu->emu_code = ETEXT('\xA3');  break; // british pound
	case ETEXT('\x24'):	hhEmu->emu_code = ETEXT('\x24');  break; // Dollar sign
	case ETEXT('\x26'):	hhEmu->emu_code = ETEXT('\x23');  break; // pound sign
	case ETEXT('\x27'):	hhEmu->emu_code = ETEXT('\xA7');  break; // integral
	case ETEXT('\x2C'):	hhEmu->emu_code = ETEXT('\xC3');  break; // left arrow
	case ETEXT('\x2D'):	hhEmu->emu_code = ETEXT('\xC0');  break; // up arrow
	case ETEXT('\x2E'):	hhEmu->emu_code = ETEXT('\xC4');  break; // right arrow
	case ETEXT('\x2F'):	hhEmu->emu_code = ETEXT('\xC5');  break; // down arrow
	case ETEXT('\x30'):	hhEmu->emu_code = ETEXT('\xB0');  break; // degree
	case ETEXT('\x31'):	hhEmu->emu_code = ETEXT('\xB1');  break; // plus-minus
	case ETEXT('\x38'):	hhEmu->emu_code = ETEXT('\xF7');  break; // divide
	case ETEXT('\x3C'):	hhEmu->emu_code = ETEXT('\xBC');  break; // 1/4
	case ETEXT('\x3D'):	hhEmu->emu_code = ETEXT('\xBD');  break; // 1/2
	case ETEXT('\x3E'):	hhEmu->emu_code = ETEXT('\xBE');  break; // 3/4
	case ETEXT('\x41'):	hhEmu->emu_code = ETEXT('\x60');  fNoAdvance = TRUE;  break;
	case ETEXT('\x42'):	hhEmu->emu_code = ETEXT('\xB4');  fNoAdvance = TRUE;  break;
	case ETEXT('\x43'):	hhEmu->emu_code = ETEXT('\x5E');  fNoAdvance = TRUE;  break;
	case ETEXT('\x48'):	hhEmu->emu_code = ETEXT('\xA8');  fNoAdvance = TRUE;  break;
	case ETEXT('\x4A'): hhEmu->emu_code = ETEXT('\xB8');  fNoAdvance = TRUE;  break;
	case ETEXT('\x4B'): hhEmu->emu_code = ETEXT('\xB8');  fNoAdvance = TRUE;  break;
	case ETEXT('\x6A'):	hhEmu->emu_code = ETEXT('\x8C');  break;
	case ETEXT('\x7A'):	hhEmu->emu_code = ETEXT('\x9C');  break;
	case ETEXT('\x7B'):	hhEmu->emu_code = ETEXT('\xDF');  break;
	default: hhEmu->emu_code = ETEXT('\x5F');			 break;
		}

	minitelGraphic(hhEmu);

	if (fNoAdvance)
		{
		(*hhEmu->emu_setcurpos)(hhEmu, row, col); // don't advance cursor
		}

	else
		{
		// If we don't advance the cursor, we're done with this SS2
		// sequence and reset the state to 0 - mrw, 2/3/95
		//
		hhEmu->state = 0;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelSS2Part2
 *
 * DESCRIPTION:
 *	The second half a an SS2 code is the vowel portion for the accents
 *	page 90.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
static void minitelSS2Part2(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	switch (hhEmu->emu_code)
		{
	case ETEXT('a'):
		switch (pstPRI->minitel_last_char)
			{
		case ETEXT('\x60'):	hhEmu->emu_code = ETEXT('\xE0');    break;
		case ETEXT('\x5E'):	hhEmu->emu_code = ETEXT('\xE2');    break;
		case ETEXT('\xA8'):	hhEmu->emu_code = ETEXT('\xE4');    break;
		default: break;
			}
		break;

	case ETEXT('e'):
		switch (pstPRI->minitel_last_char)
			{
		case ETEXT('\x60'):	hhEmu->emu_code = ETEXT('\xE8');    break;
		case ETEXT('\xB4'):	hhEmu->emu_code = ETEXT('\xE9');    break;
		case ETEXT('\x5E'):	hhEmu->emu_code = ETEXT('\xEA');    break;
		case ETEXT('\xA8'):	hhEmu->emu_code = ETEXT('\xEB');    break;
		default: break;
			}
		break;

	case ETEXT('i'):
		switch (pstPRI->minitel_last_char)
			{
		case ETEXT('\x5E'):	hhEmu->emu_code = ETEXT('\xEE');    break;
		case ETEXT('\xA8'):	hhEmu->emu_code = ETEXT('\xEF');    break;
		default: break;
			}
		break;

	case ETEXT('o'):
		switch (pstPRI->minitel_last_char)
			{
		case ETEXT('\x5E'):	hhEmu->emu_code = ETEXT('\xF4');    break;
		case ETEXT('\xA8'):	hhEmu->emu_code = ETEXT('\xF6');    break;
		default: break;
			}
		break;

	case ETEXT('u'):
		switch (pstPRI->minitel_last_char)
			{
		case ETEXT('\x60'):	hhEmu->emu_code = ETEXT('\xF9');    break;
		case ETEXT('\x5E'):	hhEmu->emu_code = ETEXT('\xFB');    break;
		case ETEXT('\xA8'):	hhEmu->emu_code = ETEXT('\xFC');    break;
		default: break;
			}
		break;

	case ETEXT('c'):
		switch (pstPRI->minitel_last_char)
			{
		case ETEXT('\xB8'): hhEmu->emu_code = ETEXT('\xE7');	break;
		default: break;
			}
		break;

	default:
		// Docs say if we're not one of the above chars, then overwrite
		// position with current char.
		break;
		}

	minitelGraphic(hhEmu);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelInsMode
 *
 * DESCRIPTION:
 *	Sets or Resets the insert mode depending on received code.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
static void minitelInsMode(const HHEMU hhEmu)
	{
	hhEmu->mode_IRM = (hhEmu->emu_code == ETEXT('\x68')) ? SET : RESET;
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelNtfy
 *
 * DESCRIPTION:
 *	Paints an inverted F or C when connection/disconnection notifications
 *	come in.
 *
 * ARGUMENTS:
 *	hhEmuPass	- change this to hhEmu when reentrancy done.
 *	nNtfyCode	- why it was called, (we don't use)
 *
 * RETURNS:
 *	void
 *
 */
void minitelNtfy(const HHEMU hhEmu, const int nNtfyCode)
	{
	const int r = row_index(hhEmu, 0);
	const int c = hhEmu->emu_maxcol - 1;
	ECHAR chr;
	BOOL  fFlash = FALSE;

	switch (cnctQueryStatus(sessQueryCnctHdl(hhEmu->hSession)))
		{
	case CNCT_STATUS_FALSE:
	default:
		chr = ETEXT('F');
		break;

	case CNCT_STATUS_TRUE:
		chr = ETEXT('C');
		break;

	case CNCT_STATUS_CONNECTING:
		chr = ETEXT('C');
		fFlash = TRUE;
		break;
		}

	hhEmu->emu_apText[r][c] = chr;
	hhEmu->emu_apAttr[r][c].revvid = 1;
	hhEmu->emu_apAttr[r][c].blink = (unsigned)fFlash;
	hhEmu->emu_apAttr[r][c].symbol = 0; // mrw-5/5/95

	hhEmu->emu_aiEnd[r] = c;

	updateChar(sessQueryUpdateHdl(hhEmu->hSession), 0, c, c);
	NotifyClient(hhEmu->hSession, EVENT_TERM_UPDATE, 0);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelPRO1
 *
 * DESCRIPTION:
 *	Handles PRO1 sequences (ESC,39,X).
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle
 *
 * RETURNS:
 *	void
 *
 */
static void minitelPRO1(const HHEMU hhEmu)
	{
	ECHAR aechBuf[35];
	static const TCHAR achID[] = TEXT("\x01\x43r0\x04");

	switch (hhEmu->emu_code)
		{
	case ETEXT('\x7B'): // ENQROM (page 139)
		// See pages 21 & 22.  Basicly we send back an indentification
		// sequence delimited by SOH and EOT
		//
		CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), achID,
            StrCharGetByteCount(achID));

		CLoopSend(sessQueryCLoopHdl(hhEmu->hSession), aechBuf, 5, 0);
		break;

	case ETEXT('\x67'): // Disconnect (page 139)
		PostMessage(sessQueryHwnd(hhEmu->hSession), WM_DISCONNECT, 0, 0);
		break;

	case ETEXT('\x72'):
		minitelStatusReply(hhEmu);
		break;

	default:
		break;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelPRO2Part1
 *
 * DESCRIPTION:
 *	Handles first half of a PRO2 sequence.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
static void minitelPRO2Part1(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	pstPRI->minitel_PRO1 = hhEmu->emu_code;
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelPRO2Part2
 *
 * DESCRIPTION:
 *	Handles the second half of a PRO2 sequence.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle
 *
 * RETURNS:
 *	void
 *
 */
static void minitelPRO2Part2(const HHEMU hhEmu)
	{
	int fUpperCase;
	BYTE abKey[256];
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	switch (hhEmu->emu_code)
		{
	case ETEXT('\x43'):	  // scrolling
		if (pstPRI->minitel_PRO1 == ETEXT('\x69'))
			{
			pstPRI->fScrollMode = TRUE;
			}

		if (pstPRI->minitel_PRO1 == ETEXT('\x6A'))
			{
			pstPRI->fScrollMode = FALSE;
			}

		minitelStatusReply(hhEmu);
		break;

	case ETEXT('\x44'):	  // error correction procedure (not implemented)
		break;

	case ETEXT('\x45'):	  // keyboard upper/lower case
		if (pstPRI->minitel_PRO1 == ETEXT('\x69'))
			{
			fUpperCase = FALSE;
			}
		else if (pstPRI->minitel_PRO1 == ETEXT('\x6A'))
			{
			fUpperCase = TRUE;
			}
		else
			{
			break;
			}

		if (GetKeyboardState(abKey))
			{
			if (fUpperCase)
				{
				abKey[VK_CAPITAL] |= 0x01;
				}
			else
				{
				abKey[VK_CAPITAL] &= 0xfe;
				}

			SetKeyboardState(abKey);
			}
		#if TODO // TODO:REV 3/1/2002 Set the CapLock key state when GetKeyboardState fails.
		else
			{
			SHORT lCapitalKeyState = GetKeyState(VK_CAPITAL);

			if (fUpperCase)
				{
				lCapitalKeyState |= 0x01;
				}
			else
				{
				lCapitalKeyState &= 0xfe;
				}

			if (lCapitalKeyState)
				{
				INPUT lInput;

				lInput.ki = 

				SendInput(1, lInput, sizeof(INPUT));
				}
			}
		#endif // TODO:REV 3/1/2002 

		minitelStatusReply(hhEmu);
		break;

	default:
		break;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelStatusReply
 *
 * DESCRIPTION:
 *	Acknowledgement sequence for some PRO2 sequences and status requests.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 * AUTHOR: Mike Ward, 08-May-1995
 */
static void minitelStatusReply(const HHEMU hhEmu)
	{
	ECHAR ach[10];
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	// The PRO2 sequences \x43 and \x45 all return and acknowledgement
	// of the form PRO2,\x73,status byte.  The format of the status byte
	// is defined in page 143, section 11.2.
	//
	// strcpy(ach, "\x1b\x3A\x73");
	CnvrtMBCStoECHAR(ach, sizeof(ach), TEXT("\x1b\x3A\x73"),
					 StrCharGetByteCount(TEXT("\x1b\x3A\x73")));

	ach[3] = ETEXT('\x40');  // bit 7 is always 1.
	ach[3] |= pstPRI->fScrollMode ? ETEXT('\x02') : ETEXT('\x00');
	ach[3] |=(GetKeyState(VK_CAPITAL) > 0) ? ETEXT('\x00') : ETEXT('\x08');
	ach[4] = ETEXT('\0');
	CLoopSend(sessQueryCLoopHdl(hhEmu->hSession), ach, 4, 0);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuMinitelSendKey
 *
 * DESCRIPTION:
 *	Used by the toolbar to emit the correct minitel sequence for the
 *	specified button.
 *
 * ARGUMENTS:
 *	hEmu	- public emulator handle.
 *	iCmd	- command string to send.
 *
 * RETURNS:
 *	void
 *
 * AUTHOR: Mike Ward, 10-Mar-1995
 */
void emuMinitelSendKey(const HEMU hEmu, const int iCmd)
	{
	TCHAR *pach;
	ECHAR aechBuf[20];
	const HHEMU hhEmu = (HHEMU)hEmu;
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;
    HCNCT hCnct = NULL;
    BOOL  bSendKey = TRUE;
    int   iRet = 0;

	switch (iCmd)
		{
	case IDM_MINITEL_INDEX: 	pach = TEXT("\x13") TEXT("F");	   break;
	case IDM_MINITEL_CANCEL:	pach = TEXT("\x13") TEXT("E");	   break;
	case IDM_MINITEL_PREVIOUS:	pach = TEXT("\x13") TEXT("B");	   break;
	case IDM_MINITEL_REPEAT:	pach = TEXT("\x13") TEXT("C");	   break;
	case IDM_MINITEL_GUIDE: 	pach = TEXT("\x13") TEXT("D");	   break;
	case IDM_MINITEL_CORRECT:	pach = TEXT("\x13") TEXT("G");	   break;
	case IDM_MINITEL_NEXT:		pach = TEXT("\x13") TEXT("H");	   break;
	case IDM_MINITEL_SEND:		pach = TEXT("\x13") TEXT("A");	   break;
	case IDM_MINITEL_CONFIN:
		pach = TEXT("\x13") TEXT("I");
		pstPRI->F9 += 1;
		break;

	default:
		assert(0);
		return;
		}

    //
    // Attempt to make a connection if we are currently disconnected, and
    // we are supposed to initiate a connection.
    //
    hCnct = sessQueryCnctHdl(hhEmu->hSession);

    iRet = cnctQueryStatus(hCnct);
    
    if (iCmd == IDM_MINITEL_CONFIN)
        {
        if (iRet != CNCT_STATUS_TRUE && iRet != CNCT_STATUS_CONNECTING &&
            iRet != CNCT_STATUS_DISCONNECTING)
            {
            if (SendMessageTimeout(sessQueryHwnd(hhEmu->hSession), WM_COMMAND,
                                  IDM_ACTIONS_DIAL, 0,
                                  SMTO_ABORTIFHUNG, 1000, NULL) == 0)
                {
                DWORD dwSendKey = GetLastError();
                bSendKey = FALSE;
                }
            else
                {
                hCnct = sessQueryCnctHdl(hhEmu->hSession);

	            if (!hCnct)
                    {
                    bSendKey = FALSE;
                    }
                else
                    {
                    iRet = cnctQueryStatus(hCnct);
            
                    if (iRet != CNCT_STATUS_TRUE)
                        {
                        bSendKey = FALSE;
                        }
                    }
                }
            }
        else if(iRet != CNCT_STATUS_DISCONNECTING)
            {
		    PostMessage(sessQueryHwnd(hhEmu->hSession), WM_DISCONNECT, 0, 0);
            pstPRI->F9 = 0;
            bSendKey = FALSE;
            }
        }
    else if (iRet != CNCT_STATUS_TRUE)
        {
        bSendKey = FALSE;
        }

    if (bSendKey == TRUE)
        {
	    CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), pach,
		    StrCharGetByteCount(pach) + sizeof(TCHAR));

	    emuSendString((HHEMU)hEmu, aechBuf, StrCharGetEcharByteCount(aechBuf));
        }

	return;
	}											

#ifdef INCL_TERMINAL_SIZE_AND_COLORS
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emuMinitelSetScrSize
 *
 * DESCRIPTION:
 *  Replaces std_setscrsize which was added to allow user settable screen
 *	sizes. However, the Minitel doesn't allow this.
 *
 * ARGUMENTS:
 *  hhEmu - The internal emulator handle.
 *
 * RETURNS:
 *  void
 *
 * AUTHOR:	Bob Everett - 1 Sep 1998
 */
void emuMinitelSetScrSize(const HHEMU hhEmu)
    {
    }
#endif

#endif // INCL_MINITEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\keydef.h ===
/*  File: \shared\emulator\keydef.h (Created: 12/19/95)
 *
 *  Copyright 1995 by Hilgraeve Inc. -- Monroe, MI
 *  All rights reserved
 *
 *  Description:
 *		This header file defines structures and macros for
 *		handling keyboard imput in a plateform independent
 *		fashion.
 *
 *  $Revision: 1 $
 *  $Date: 10/05/98 12:27p $
 */
#if !defined(KEYDEF_INCLUDED)
#define KEYDEF_INCLUDED

// Here it is!  The fame and fabled KEYDEF typedef.  This type is used
// throughout our entire code base to represent a "key".  A key is any
// character data coming from the user thru a local input device (fancy
// way of saying a keyboard).  It contains reserved areas as follows:
//
// bits 00-15   : character or virtual key code.
// bits 16-19   : key state information (ALT, CTRL, SHIFT, EXTENDED)
// bit  23		: controls how bits 00-15 are interpreted (Virtual or char)
//
// This means a KEYDEF has a minimum size of 24 bits.  In practical terms
// KEYDEF should be defined in such way to be at least 32 bits.
//
// Interesting thought:  There is a world standard being proposed that
// use 32 bits to represent a character.  If this ever happens, we would
// have to have a 40 bit value to represent a key.  I suspect that when
// that happens, we'll all be using 64 bit architectures anyways.
//
// Interesting thought two:  We tried to represent a key as a bit-field
// structure but ran into difficulties.  The disadvantages were; needed
// a function to compare KEYDEF values since bit-fields are set in a
// plateform specific way; could not easily create constant KEYDEF values
// that could be used in switch statements.  Using a simply integer type
// makes manipulating and comparing KEYDEF values much easier.
//
typedef unsigned int KEYDEF;   // minimum size is 32 bits.

// Keys are interpreted as follows:
//
// If the VIRTUAL_KEY flag is clear, then the lower word of the value is the
// displayable (usually ASCII) code for the character
//
// If the VIRTUAL_KEY flag is set, then the lower word is the
// HVK key code for the key that was pressed.  In addition, the flags
// for ALT_KEY, CTRL_KEY, SHIFT_KEY, and EXTENDED_KEY are set to the
// correct values.
//
// mrw:3/4/96 - Added the HVIRTUAL_KEY flag.  Needed to do this for
// windows because many of the WM_KEYDOWN sequences in Windows look
// like our HVK_? values.  The VIRTUAL_KEY flag is stilled OR'ed in
// to the HVK_? values to maintain compatibility with our old code.
//
#define HVIRTUAL_KEY		0x01000000
#define VIRTUAL_KEY			0x00800000
#define ALT_KEY				0x00010000
#define CTRL_KEY			0x00020000
#define SHIFT_KEY			0x00040000
#define EXTENDED_KEY		0x00080000

// So just what is an HVK key code?  Virtual keys are representations
// for keys that are independent of the position on the keyboard.  For
// instance, our program deals with the concept of Page-Up.  We don't
// really care that it is one code in OS/2 and another code in Windows.
// Both OS/2 and Windows generate Virtual key codes but they are
// values (and sometimes symbolic names).  To keep our code independent
// of these differences, we translate the system specific virtual key
// code to a HVK key code.  Our code then deals only in HVK virtual key
// codes.  There of course must be function to provide a translation
// layer which is always defined on the project side.
//
// HVK constants are our definitions for virtual keys.  They are plateform
// independent.  Anyone translating keyboard input will need a function to
// map the system specific virtual key code to a HVK key code.
//
#define HVK_BUTTON1			(0x01 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_BUTTON2			(0x02 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_BUTTON3			(0x03 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_BREAK			(0x04 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_BACKSPACE		(0x05 | VIRTUAL_KEY | HVIRTUAL_KEY)   // can't be used in shared code - mrw
#define HVK_TAB				(0x06 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_BACKTAB			(0x07 | VIRTUAL_KEY | HVIRTUAL_KEY)   // can't be used in shared code - mrw
#define HVK_NEWLINE			(0x08 | VIRTUAL_KEY | HVIRTUAL_KEY)   // can't be used in shared code - mrw
#define HVK_SHIFT			(0x09 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_CTRL			(0x0A | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_ALT				(0x0B | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_ALTGRAF			(0x0C | VIRTUAL_KEY | HVIRTUAL_KEY)   // can't be used in shared code - mrw
#define HVK_PAUSE			(0x0D | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_CAPSLOCK		(0x0E | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_ESC				(0x0F | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_SPACE			(0x10 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_PAGEUP			(0x11 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_PAGEDOWN		(0x12 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_END				(0x13 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_HOME			(VK_HOME | VIRTUAL_KEY)
#define HVK_LEFT			(VK_LEFT | VIRTUAL_KEY)
#define HVK_UP				(VK_UP | VIRTUAL_KEY)
#if FALSE
#define HVK_HOME			(0x14 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_LEFT			(0x15 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_UP				(0x16 | VIRTUAL_KEY | HVIRTUAL_KEY)
#endif
#define HVK_RIGHT			(0x17 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_DOWN			(0x18 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_PRINTSCRN		(0x19 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_INSERT			(0x1A | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_DELETE			(0x1B | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_SCRLLOCK		(0x1C | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMLOCK			(0x1D | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_ENTER			(0x1E | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_SYSRQ			(0x1F | VIRTUAL_KEY | HVIRTUAL_KEY)   // can't be used in shared code - mrw
#define HVK_F1				(0x20 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F2				(0x21 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F3				(0x22 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F4				(0x23 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F5				(0x24 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F6				(VK_F6 | VIRTUAL_KEY)
#define HVK_F7				(VK_F7 | VIRTUAL_KEY)
#define HVK_F8				(VK_F8 | VIRTUAL_KEY)
#define HVK_F9				(VK_F9 | VIRTUAL_KEY)
#if FALSE
#define HVK_F6				(0x25 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F7				(0x26 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F8				(0x27 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F9				(0x28 | VIRTUAL_KEY | HVIRTUAL_KEY)
#endif
#define HVK_F10				(0x29 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F11				(0x2A | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F12				(0x2B | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F13				(0x2C | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F14				(0x2D | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F15				(0x2E | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F16				(0x2F | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F17				(0x30 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F18				(0x31 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F19				(0x32 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F20				(0x33 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F21				(0x34 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F22				(0x35 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F23				(0x36 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_F24				(0x37 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_ENDDRAG			(0x38 | VIRTUAL_KEY | HVIRTUAL_KEY)   // can't be used in shared code - mrw
#define HVK_EREOF			(0x3A | VIRTUAL_KEY | HVIRTUAL_KEY)   // can't be used in shared code - mrw
#define HVK_PA1				(0x3B | VIRTUAL_KEY | HVIRTUAL_KEY)

#define HVK_ADD				(0x3D | VIRTUAL_KEY | HVIRTUAL_KEY)   // Identifies key on Numeric Keypad only.
#define HVK_SUBTRACT		(0x3E | VIRTUAL_KEY | HVIRTUAL_KEY)   // Identifies key on Numeric Keypad only.

// These constants represent the keys on the numeric keypad, when
// the Num Lock key is on.  Again, when the Num Lock key is On.
//
#define HVK_NUMPAD0			(0x45 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPAD1			(0x46 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPAD2			(0x47 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPAD3			(0x48 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPAD4			(0x49 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPAD5			(0x64 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPAD6			(0x4A | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPAD7			(0x4B | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPAD8			(0x4C | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPAD9			(0x4D | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_NUMPADPERIOD	(0x53 | VIRTUAL_KEY | HVIRTUAL_KEY)

// These constants represent some of the keys on the numeric keypad, only.
//
#define HVK_DECIMAL			(0x4E | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_RETURN			(0x4F | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_FSLASH			(0x50 | VIRTUAL_KEY | HVIRTUAL_KEY)
#define HVK_MULTIPLY		(0x51 | VIRTUAL_KEY | HVIRTUAL_KEY)

// This constant represents the 5 on the numeric keypad, or the center
// key on the edit pad.  If it's from the edit pad, the extended bit
// will be set.
//
#define HVK_CENTER			(0x52 | VIRTUAL_KEY | HVIRTUAL_KEY)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\vid.h ===
/*	File: D:\WACKER\emu\vid.h (Created: 09-Dec-1993)
 *
 *	Copyright 1993 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:29p $
 */

/* This file is no longer used! --jcm */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\keytbls.h ===
/*	File: D:\LELAND\emu\keytbls.h (Created: 27-Dec-1994)
 *
 *	Copyright 1994-2001 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 6 $
 *	$Date: 10/09/01 4:38p $
 */
// ------------  OS/2 Include Files ------------
#include <windows.h>
#pragma hdrstop
#include <tdll\chars.h>

#define MAX_ANSI_KEYS 17
extern const KEYTBLSTORAGE AnsiKeyTable[MAX_ANSI_KEYS];

#define MAX_IBMPC_KEYS 185
extern const KEYTBLSTORAGE IBMPCKeyTable[MAX_IBMPC_KEYS];

#define MAX_VT52_KEYS 19
extern const KEYTBLSTORAGE VT52KeyTable[MAX_VT52_KEYS];

#define MAX_VT52_KEYPAD_KEYS 14
extern const KEYTBLSTORAGE VT52_Keypad_KeyTable[MAX_VT52_KEYPAD_KEYS];

#define MAX_VT_PF_KEYS 4
extern const KEYTBLSTORAGE VT_PF_KeyTable[MAX_VT_PF_KEYS];

#define MAX_VT100_KEYS 24
extern const KEYTBLSTORAGE VT100KeyTable[MAX_VT100_KEYS];

#define MAX_VT100_CURSOR_KEYS 8
extern const KEYTBLSTORAGE VT100_Cursor_KeyTable[MAX_VT100_CURSOR_KEYS];

#define MAX_VT100_KEYPAD_KEYS 14
extern const KEYTBLSTORAGE VT100_Keypad_KeyTable[MAX_VT100_KEYPAD_KEYS];

#define MAX_MINITEL_KEYS 82
extern const KEYTBLSTORAGE Minitel_KeyTable[MAX_MINITEL_KEYS];

#define MAX_VTUTF8_KEYS	53
extern const KEYTBLSTORAGE VTUTF8KeyTable[MAX_VTUTF8_KEYS];

#define MAX_VTUTF8_CURSOR_KEYS 64
extern const KEYTBLSTORAGE VTUTF8_Cursor_KeyTable[MAX_VTUTF8_CURSOR_KEYS];

#define MAX_VTUTF8_KEYPAD_KEYS 112
extern const KEYTBLSTORAGE VTUTF8_Keypad_KeyTable[MAX_VTUTF8_KEYPAD_KEYS];

#define MAX_VTUTF8_MODIFIED_ALPHA_KEYS	233
extern const KEYTBLSTORAGE VTUTF8ModifiedAlhpaKeyTable[MAX_VTUTF8_MODIFIED_ALPHA_KEYS];

#define MAX_VTUTF8_MODIFIED_KEYS	354
extern const KEYTBLSTORAGE VTUTF8ModifiedKeyTable[MAX_VTUTF8_MODIFIED_KEYS];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\vid.hh ===
/*	File: D:\WACKER\emu\vid.hh (Created: 09-Dec-1993)
 *
 *	Copyright 1993 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:29p $
 */

/* This file is no longer used! --jcm */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\minitel.hh ===
/*	File: D:\wacker\emu\minitel.hh (Created: 05-Mar-1994)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

void emuMinitelInit(const HHEMU hhEmu);
void emuMinitelDeinstall(const HHEMU hhEmu);
void minitelGraphic(const HHEMU hhEmu);
void minitelLinefeed(const HHEMU hhEmu);
void minitelBackspace(const HHEMU hhEmu);
void minitelVerticalTab(const HHEMU hhEmu);
void minitelCursorUp(const HHEMU hhEmu);
void minitelCursorDirect(const HHEMU hhEmu);
void minitelFormFeed(const HHEMU hhEmu);
void minitelClearScreen(const HHEMU hhEmu, const int iHow);
void minitelClrScrn(const HHEMU hhEmu);
void minitelRecordSeparator(const HHEMU hhEmu);
void minitelClearLine(const HHEMU hhEmu, const int iHow);
void minitelClrLn(const HHEMU hhEmu);
void minitelUSCol(const HHEMU hhEmu);
void minitelUSRow(const HHEMU hhEmu);
void minitelReset(const HHEMU hhEmu);
void minitelHorzTab(const HHEMU hhEmu);
void minitelDel(const HHEMU hhEmu);
void minitelRepeat(const HHEMU hhEmu);
void minitelCharSet(const HHEMU hhEmu);
void minitelCharSize(const HHEMU hhEmu);
void minitelCancel(const HHEMU hhEmu);
void minitelResetTerminal(const HHEMU hhEmu);
void minitelCursorOn(const HHEMU hhEmu);
void minitelCursorOff(const HHEMU hhEmu);
void minitelResync(const HHEMU hhEmu);
void minitelDelChars(const HHEMU hhEmu);
void minitelInsChars(const HHEMU hhEmu);
void minitelDelRows(const HHEMU hhEmu);
void minitelInsRows(const HHEMU hhEmu);
void minitelNtfy(const HHEMU hhEmu, const int nNtfyCode);
void minitelCursorReport(const HHEMU hhEmu);
void emuMinitelCharAttr(const HHEMU hhEmu);
void emuMinitelFieldAttr(const HHEMU hhEmu);
int  minitelHomeHostCursor(const HHEMU hhEmu);
void minitel_scrollup(const HHEMU hhEmu, int nlines);
void minitel_scrolldown(const HHEMU hhEmu, int nlines);
void emuMinitelSetScrSize(const HHEMU hhEmu);


STATTR GetAttr(const HHEMU hhEmu, const int iRow, const int iCol);

/* --- minitel latent attribute structure --- */

typedef struct _minitel
	{
	unsigned int bkclr	 : 4;  // background color
	unsigned int conceal : 1;  // conceal
	unsigned int undrln  : 1;  // underline
	unsigned int isattr  : 1;  // true if this is an attribute space
	unsigned int ismosaic: 1;  // TRUE if char is mosaic
	unsigned int fbkclr  : 1;  // This attribute spaces validates color
	} STMINITEL;

// The latent attribute

typedef struct _latent
	{
	unsigned bkclr; 	    // background color
	unsigned conceal;	    // conceal chars
	unsigned undrln;	    // underline
	unsigned fModified; 	// latent attribute changed.
	unsigned fBkClr;		// TRUE if modified and not validated.
	} LATENTATTR;

typedef STMINITEL *PSTMINITEL;

// Private emulator data for Minitel.
//
typedef struct stPrivateMinitel
	{
	// Latent attribute and attribute array used for serial attributes.
	//
	LATENTATTR	stLatentAttr;
	LATENTATTR	saved_stLatentAttr;
	PSTMINITEL	*apstMT;
	ECHAR		minitel_last_char;
	int 		minitelG1Active;
	int 		minitelUseSeparatedMosaics;
	int 		saved_minitelUseSeparatedMosaics;
	int 		minitel_saved_row;
	int 		minitel_saved_col;
	STATTR		minitel_saved_attr;
	int 		minitel_saved_minitelG1Active;
	ECHAR		minitel_PRO1; // first part of a PRO sequence
	int 		us_row_code;  // used for US codes
	int 		minitelSecondDep;
	int 		fScrollMode;
	int 		F9; 		  // two consecutive F9's disconnect.
	int 		fInCancel;	  // used in minitelCancel and minitelGraphic
	} MTPRIVATE;

typedef MTPRIVATE *PSTMTPRIVATE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\minitelf.c ===
/*	File: D:\WACKER\emu\minitelf.c (Created: 12-Apr-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\session.h>
#include <tdll\print.h>
#include <tdll\capture.h>
#include <tdll\assert.h>
#include <tdll\mc.h>
#include <tdll\update.h>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"
#include "minitel.hh"

static void minitel_clear_imgrow(const HHEMU hhEmu, const int row);

#if defined(INCL_MINITEL)
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelLinefeed
 *
 * DESCRIPTION:
 *	Linefeeds work differently in minitel.	In page mode we wrap to line
 *	one (not zero) when at the bottom.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *
 * RETURNS:
 *	void
 *
 */
void minitelLinefeed(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = hhEmu->pvPrivate;
	const ECHAR *tp = hhEmu->emu_apText[hhEmu->emu_imgrow];
	const PSTATTR ap = hhEmu->emu_apAttr[hhEmu->emu_imgrow];

	printEchoString(hhEmu->hPrintEcho, (ECHAR *)tp,
		emuRowLen(hhEmu, hhEmu->emu_currow)); // mrw,3/1/95

	// see page 97, bottom of page
	//
	if (hhEmu->emu_currow == 0)
		{
		hhEmu->emu_charattr = pstPRI->minitel_saved_attr;

		(*hhEmu->emu_setcurpos)(hhEmu, pstPRI->minitel_saved_row,
			pstPRI->minitel_saved_col);

		pstPRI->minitelG1Active = pstPRI->minitel_saved_minitelG1Active;
		pstPRI->stLatentAttr = pstPRI->saved_stLatentAttr;

		pstPRI->minitelUseSeparatedMosaics =
			pstPRI->saved_minitelUseSeparatedMosaics;
		}

	else if (hhEmu->emu_currow == hhEmu->bottom_margin)
		{
		if (pstPRI->fScrollMode)
			minitel_scrollup(hhEmu, 1);

		else
			(*hhEmu->emu_setcurpos)(hhEmu, 1, hhEmu->emu_curcol);
		}

	else
		{
		(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow + 1,
			hhEmu->emu_curcol);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelBackspace
 *
 * DESCRIPTION:
 *	Backspaces are goofy.  They wrap to the previous line.	In scroll mode
 *	they cause scrolling if in line 1
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelBackspace(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = hhEmu->pvPrivate;

	if (hhEmu->emu_curcol > 0)
		{
		(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow,
			hhEmu->emu_curcol-1);
		}

	else if (hhEmu->emu_currow == 1)
		{
		if (pstPRI->fScrollMode)
			{
			minitel_scrolldown(hhEmu, (hhEmu->emu_charattr.dblhilo) ? 2 : 1);
			}

		else
			{
			(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_maxrow,
				hhEmu->emu_maxcol);
			}
		}

	else
		{
		(*hhEmu->emu_setcurpos)(hhEmu,	hhEmu->emu_currow-1,
			hhEmu->emu_maxcol);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelVerticalTab
 *
 * DESCRIPTION:
 *	Vertical tabs work differently.  They move the cursor up and wrap or
 *	scroll depending on the mode.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelVerticalTab(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = hhEmu->pvPrivate;

	// VT sequence not available in row 0
	//
	if (hhEmu->emu_currow == 0)
		return;

	if (hhEmu->emu_currow == 1)
		{
		if (pstPRI->fScrollMode)
			{
			minitel_scrolldown(hhEmu, (hhEmu->emu_charattr.dblhilo) ? 2 : 1);
			}

		else
			{
			(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_maxrow,
				hhEmu->emu_curcol);
			}
		}

	else
		{
		(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow-1,
			hhEmu->emu_curcol);
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelCursorUp
 *
 * DESCRIPTION:
 *	Moves cursor up n rows but not into row 00
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelCursorUp(const HHEMU hhEmu)
	{
	int nlines, row;

	// CSI sequences not available in row 0
	//
	if (hhEmu->emu_currow == 0)
		return;

	nlines = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nlines < 1)
		nlines = 1;

	row = hhEmu->emu_currow;
	row -= nlines;

	if (row < 1)
		row = 1;

	(*hhEmu->emu_setcurpos)(hhEmu, row, hhEmu->emu_curcol);

	ANSI_Pn_Clr(hhEmu);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelCursorDirect
 *
 * DESCRIPTION:
 *	Moves cursor to specified coordinates but not row 00
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelCursorDirect(const HHEMU hhEmu)
	{
	int row, col;

	// CSI functions not available in row 0
	//
	if (hhEmu->emu_currow == 0)
		return;

	row = hhEmu->num_param[0];
	col = hhEmu->num_param_cnt > 0 ? hhEmu->num_param[1] : 0;

	if (row < 1)
		row = 1;

	if (col < 1)
		col = 1;

	if (row > hhEmu->emu_maxrow + 1)
		row = hhEmu->emu_maxrow + 1;

	if (col > hhEmu->emu_maxcol + 1)
		col = hhEmu->emu_maxcol + 1;

	// Again, can't go to row 00 with this call.

	(*hhEmu->emu_setcurpos)(hhEmu, row, col - 1);

	ANSI_Pn_Clr(hhEmu);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelFormFeed
 *
 * DESCRIPTION:
 *	Clears rows 1 thru 24 leaving row 00 alone.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelFormFeed(const HHEMU hhEmu)
	{
	(*hhEmu->emu_setcurpos)(hhEmu, 1, 0);
	minitelClearScreen(hhEmu, 0);
	minitelReset(hhEmu);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelClearScreen
 *
 * DESCRIPTION:
 *	Works similar to the standard function but also has to clear the
 *	latent attribute and all serial attributes.
 *
 * ARGUMENTS:
 *	int iHow	- dirction to clear screen.
 *
 * RETURNS:
 *	void
 *
 */
void minitelClearScreen(const HHEMU hhEmu, const int iHow)
	{
	#define BLACK_MOSAIC ETEXT('\xff')
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	int  i;
	int  r;
	PSTMINITEL pstMT;
	STMINITEL stMT;
	ECHAR *pText;
	PSTATTR pstAttr;
	STATTR	stAttr;

	// CSI sequences not available in row 0
	//
	if (hhEmu->emu_currow == 0)
		return;

	memset(&stMT, 0, sizeof(stMT));
    stMT.ismosaic = 1;

	memset(&stAttr, 0, sizeof(stAttr));
	stAttr.txtclr = VC_BRT_WHITE;
	stAttr.bkclr = VC_BLACK;

	switch (iHow)
		{
	case 0: 	// cursor to end of screen inclusive
	default:
		pstMT = pstPRI->apstMT[hhEmu->emu_imgrow];
		pText = hhEmu->emu_apText[hhEmu->emu_imgrow];
		pstAttr = hhEmu->emu_apAttr[hhEmu->emu_imgrow];

		for (i = hhEmu->emu_curcol ; i < MAX_EMUCOLS ; ++i)
			{
			*pstMT++ = stMT;
			*pText++ = BLACK_MOSAIC;
			*pstAttr++ = stAttr;
			}

		for (r = hhEmu->emu_currow+1 ; r < MAX_EMUROWS ; ++r)
			{
			i = row_index(hhEmu, r);
			pstMT = pstPRI->apstMT[i];
			pText = hhEmu->emu_apText[i];
			pstAttr = hhEmu->emu_apAttr[i];

			for (i = 0 ; i < MAX_EMUCOLS ; ++i)
				{
				*pstMT++ = stMT;
				*pText++ = BLACK_MOSAIC;
				*pstAttr++ = stAttr;
				}
			}

		updateLine(sessQueryUpdateHdl(hhEmu->hSession), hhEmu->emu_currow,
										hhEmu->emu_maxrow);

		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol;
		break;

	case 1: 	// beginning of screen to cursor inclusive
		for (r = 1 ; r < hhEmu->emu_currow ; ++r)
			{
			i = row_index(hhEmu, r);
			pstMT = pstPRI->apstMT[i];
			pText = hhEmu->emu_apText[i];
			pstAttr = hhEmu->emu_apAttr[i];

			for (i = 0 ; i < MAX_EMUCOLS ; ++i)
				{
				*pstMT++ = stMT;
				*pText++ = BLACK_MOSAIC;
				*pstAttr++ = stAttr;
				}
			}

		pstMT = pstPRI->apstMT[hhEmu->emu_imgrow];
		pText = hhEmu->emu_apText[hhEmu->emu_imgrow];
		pstAttr = hhEmu->emu_apAttr[hhEmu->emu_imgrow];

		for (i = 0 ; i <= hhEmu->emu_curcol ; ++i)
			{
			*pstMT++ = stMT;
			*pText++ = BLACK_MOSAIC;
			*pstAttr++ = stAttr;
			}

		updateLine(sessQueryUpdateHdl(hhEmu->hSession),
					0, hhEmu->emu_currow);

		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol + 1;
		break;

	case 2: 	// entire screen (cursor position not changed)
		for (r = 1 ; r < MAX_EMUROWS ; ++r)
			{
			i = row_index(hhEmu, r);
			pstMT = pstPRI->apstMT[i];
			pText = hhEmu->emu_apText[i];
			pstAttr = hhEmu->emu_apAttr[i];

			hhEmu->emu_aiEnd[r] = EMU_BLANK_LINE;

			for (i = 0 ; i < MAX_EMUCOLS ; ++i)
				{
				*pstMT++ = stMT;
				*pText++ = BLACK_MOSAIC;
				*pstAttr++ = stAttr;
				}
			}

		updateLine(sessQueryUpdateHdl(hhEmu->hSession),
									0, hhEmu->emu_maxrow);
		break;
		}

	minitelRecordSeparator(hhEmu);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelClrScrn
 *
 * DESCRIPTION:
 *	Front end for minitelClearScreen() that reads the PSN argument,
 *	converts it, and passes it to minitelClearScreen.  Called from
 *	the state tables.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelClrScrn(const HHEMU hhEmu)
	{
	minitelClearScreen(hhEmu, hhEmu->selector[0]);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelRecordSepartor
 *
 * DESCRIPTION:
 *	Record Separtor has special duties in Minitel.	In general it homes
 *	the cursor and returns the emulator to what's called an SI condition.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelRecordSeparator(const HHEMU hhEmu)
	{
	(*hhEmu->emu_setcurpos)(hhEmu, 1, 0);
	minitelReset(hhEmu);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelClearLine
 *
 * DESCRIPTION:
 *	Handles the various clear line functions like cursor to end, beg to
 *	cursor, etc.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelClearLine(const HHEMU hhEmu, const int iHow)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	int i;
	ECHAR *pText = hhEmu->emu_apText[hhEmu->emu_imgrow];
	PSTMINITEL pstMT = pstPRI->apstMT[hhEmu->emu_imgrow];
	PSTATTR pstAttr = hhEmu->emu_apAttr[hhEmu->emu_imgrow];
	const HUPDATE hUpdate= sessQueryUpdateHdl(hhEmu->hSession);
	STMINITEL stMT;
	STATTR	stAttr;

	// CSI sequences not available in row 0
	//
	if (hhEmu->emu_currow == 0)
		return;

	memset(&stMT, 0, sizeof(stMT));
    stMT.ismosaic = 1;

	memset(&stAttr, 0, sizeof(stAttr));
	stAttr.txtclr = VC_BRT_WHITE;
	stAttr.bkclr = VC_BLACK;

	switch (iHow)
		{
	case 0: 	// cursor to end of line inclusive
	default:
		for (i = hhEmu->emu_curcol ; i < MAX_EMUCOLS ; ++i)
			{
			*pText++ = BLACK_MOSAIC;
			*pstMT++ = stMT;
			*pstAttr++ = stAttr;
			}

		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol - 1;
		updateChar(hUpdate, hhEmu->emu_currow,
					hhEmu->emu_curcol, MAX_EMUCOLS);
		break;

	case 1: 	// beginning of line to cursor inclusive
		for (i = 0 ; i <= hhEmu->emu_curcol ; ++i)
			{
			*pText++ = BLACK_MOSAIC;
			*pstMT++ = stMT;
			*pstAttr++ = stAttr;
			}

		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol + 1;
		updateChar(hUpdate, hhEmu->emu_currow, 0, hhEmu->emu_curcol);
		break;

	case 2: 	// entire line
		for (i = 0 ; i < MAX_EMUCOLS ; ++i)
			{
			*pText++ = BLACK_MOSAIC;
			*pstMT++ = stMT;
			*pstAttr++ = stAttr;
			}

		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = EMU_BLANK_LINE;
		updateLine(hUpdate, hhEmu->emu_currow, hhEmu->emu_currow);
		break;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelClrLn
 *
 * DESCRIPTION:
 *	Driver for minitelClearLine().
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelClrLn(const HHEMU hhEmu)
	{
	minitelClearLine(hhEmu, hhEmu->selector[0]);
	return;
	}

#if 0
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelDel
 *
 * DESCRIPTION:
 *	code 0x7F (Del) deletes the cursor location and moves the cursor
 *	one position right.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelDel(const HHEMU hhEmu)
	{
	hhEmu->emu_apText[hhEmu->emu_imgrow][hhEmu->emu_curcol] = ETEXT('\x5F');
	hhEmu->emu_ap

	if (hhEmu->emu_aiEnd[hhEmu->emu_imgrow] == hhEmu->emu_curcol)
		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol - 1;

	minitelHorzTab(hhEmu);
	return;
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelHorzTab
 *
 * DESCRIPTION:
 *	minitel cursor has some special characteristics.  Minitel is always
 *	in wrap mode, so we wrap to begining of next row when beyond the
 *	last column.  Also, when at bottom, wrap to line 1.  Also, if in
 *	row 0, column 40, ignore.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelHorzTab(const HHEMU hhEmu)
	{
	int row = hhEmu->emu_currow;
	int col = hhEmu->emu_curcol;

	if (col >= hhEmu->emu_maxcol)
		{
		if (hhEmu->emu_currow == 0)
			return;

		if (hhEmu->emu_currow >= hhEmu->emu_maxrow)
			row = 1;

		else
			row += 1;

		col = 0;
		}

	else
		{
		col += 1;
		}

	(*hhEmu->emu_setcurpos)(hhEmu, row, col);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelRepeat
 *
 * DESCRIPTION:
 *	Repeat code displays the last displayed character x number of
 *	times where x is the current emu_code coming in.
 *	I don't think wrapping is effective here.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelRepeat(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	int x;

	// Already did range checking in state table to get here.
	// Repeat number is only the first six significant bits.

	x = max(0, hhEmu->emu_code-0x40);
	hhEmu->emu_code = pstPRI->minitel_last_char;

	while (x-- > 0)
		minitelGraphic(hhEmu);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelCancel
 *
 * DESCRIPTION:
 *	Fills current row from cursor position to end of row with spaces
 *	in the current character set current attributes.  Cursor doesn't move.
 *  Doco says this is not a delimiter.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelCancel(const HHEMU hhEmu)
	{
	int i;
	int iMax;
	int fModified;
	const int row = hhEmu->emu_currow;
	const int col = hhEmu->emu_curcol;
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	hhEmu->emu_code = ETEXT('\x20');

	// Ah, the life of the undocumented.  The documentation says
	// that this guys does not validate, colors, act as a delimiter
	// and fills with spaces.  Wrong.  It does validate the color.
	// As such its a delimiter.  If the the current active char
	// set is G1, then it fills with mosaics, not spaces.
	//
	fModified = pstPRI->stLatentAttr.fModified;

	iMax = hhEmu->emu_maxcol;

	// minitelGraphic checks the InCancel flag and if TRUE suppresses
	// linewrap. mrw:5/3/95
	//
	pstPRI->fInCancel = TRUE;

	for (i = hhEmu->emu_curcol ; i <= iMax ; ++i)
		{
		minitelGraphic(hhEmu);
		}

	pstPRI->fInCancel = FALSE;

	// Ok, even though we validated the background color, we haven't
	// changed the state of the latent attribute (also undocumented).
	// So set it back to whatever is was before we entered this lovely
	// mess of a function - mrw
	//
	pstPRI->stLatentAttr.fModified = fModified;

	(*hhEmu->emu_setcurpos)(hhEmu, row, col);
	hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_maxcol;
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelUSRow
 *
 * DESCRIPTION:
 *	Intermediate function that collects the row number
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelUSRow(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	pstPRI->us_row_code = hhEmu->emu_code;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelUSCol
 *
 * DESCRIPTION:
 *	Interestingly, columns are numbered from 1 to 40.  Unit seperators
 *  are ugly little beasts.  They indicate a row, col combo, but only
 *  if in a certain range.  Also, an obsolite sequence US,3/X,3/Y where
 *  0 < X < 3, 0 < Y < 9 and XY < 24 is not suppose to be used but 
 *  often is.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelUSCol(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	int us_col_code = hhEmu->emu_code;
	int us_col = us_col_code - 0x41;
	int us_row = pstPRI->us_row_code - 0x40;

	if (us_row >= 0 && us_row <= hhEmu->emu_maxrow &&
		us_col >= 0 && us_col <= hhEmu->emu_maxcol)
		{
		if (us_row == 0)
			{
			// p.97, bottom of page
			//
			if (hhEmu->emu_currow != 0)
				{
				pstPRI->minitel_saved_attr = hhEmu->emu_charattr;
				pstPRI->minitel_saved_row = hhEmu->emu_currow;
				pstPRI->minitel_saved_col = hhEmu->emu_curcol;
				pstPRI->saved_stLatentAttr = pstPRI->stLatentAttr;

				pstPRI->minitel_saved_minitelG1Active =
					pstPRI->minitelG1Active;

				pstPRI->saved_minitelUseSeparatedMosaics =
					pstPRI->minitelUseSeparatedMosaics;
				}
			}

		(*hhEmu->emu_setcurpos)(hhEmu, us_row, us_col);
		minitelReset(hhEmu);
		}

	else if (pstPRI->us_row_code >= 0x30 &&
		pstPRI->us_row_code < 0x33 &&
		us_col_code >= 0x30 &&
		us_col_code <= 0x39)
		{
		us_row = ((pstPRI->us_row_code - 0x30) * 10) + (us_col_code - 0x30);

		if (us_row > 24)
			return;

		if (us_row == 0)
            {
			if (hhEmu->emu_currow != 0)
				{
				pstPRI->minitel_saved_attr = hhEmu->emu_charattr;
				pstPRI->minitel_saved_row = hhEmu->emu_currow;
				pstPRI->minitel_saved_col = hhEmu->emu_curcol;
				pstPRI->saved_stLatentAttr = pstPRI->stLatentAttr;

				pstPRI->minitel_saved_minitelG1Active =
					pstPRI->minitelG1Active;

				pstPRI->saved_minitelUseSeparatedMosaics =
					pstPRI->minitelUseSeparatedMosaics;
				}
            }

		(*hhEmu->emu_setcurpos)(hhEmu, us_row, 0);
		minitelReset(hhEmu);
        }

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelDelChars
 *
 * DESCRIPTION:
 *	Deletes n characters from cursor position inclusive.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelDelChars(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;
	int i, n;
	ECHAR *tp = hhEmu->emu_apText[hhEmu->emu_imgrow]+hhEmu->emu_curcol;
	STATTR stAttr;
	PSTATTR ap = hhEmu->emu_apAttr[hhEmu->emu_imgrow]+hhEmu->emu_curcol;
	STMINITEL stMT;
	PSTMINITEL pstMT = pstPRI->apstMT[hhEmu->emu_imgrow];

	// CSI sequences not available in row 0
	//
	if (hhEmu->emu_currow == 0)
		return;

	n = min(hhEmu->emu_maxcol, hhEmu->num_param[0]);
	i = max(0, hhEmu->emu_maxcol - hhEmu->emu_curcol - n);

	/* --- Move characters down --- */

	memmove(tp, tp+n, (unsigned)i * sizeof(ECHAR));
	memmove(ap, ap+n, (unsigned)i * sizeof(STATTR));
	memmove(pstMT, pstMT+n, (unsigned)i * sizeof(STMINITEL));

	hhEmu->emu_aiEnd[hhEmu->emu_imgrow] =
		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] - i;

	/* --- Fill remainder of line --- */

	tp += i;
	ap += i;

	memset(&stAttr, 0, sizeof(stAttr));
	stAttr.txtclr = VC_BRT_WHITE;
	stAttr.bkclr  = VC_BLACK;

	memset(&stMT, 0, sizeof(stMT));
	stMT.ismosaic = (unsigned)pstPRI->minitelG1Active;

	for (n = max(0, hhEmu->emu_maxcol - i) ; n > 0 ; --n)
		{
		*tp++ = EMU_BLANK_CHAR;
		*ap++ = stAttr;
		*pstMT++ = stMT;
		}

	updateChar(sessQueryUpdateHdl(hhEmu->hSession),
				hhEmu->emu_currow,
				hhEmu->emu_curcol,
				hhEmu->emu_maxcol);

	ANSI_Pn_Clr(hhEmu);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelInsChars
 *
 * DESCRIPTION:
 *	Inserts n characters from cursor position inclusive
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelInsChars(const HHEMU hhEmu)
	{
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;
	int i, n;
	ECHAR *tp = hhEmu->emu_apText[hhEmu->emu_imgrow]+hhEmu->emu_curcol;
	STATTR stAttr;
	PSTATTR ap = hhEmu->emu_apAttr[hhEmu->emu_imgrow]+hhEmu->emu_curcol;
	STMINITEL stMT;
	PSTMINITEL pstMT = pstPRI->apstMT[hhEmu->emu_imgrow];

	// CSI sequences not available in row 0
	//
	if (hhEmu->emu_currow == 0)
		return;

	n = min(hhEmu->emu_maxcol, hhEmu->num_param[0]);
	i = max(0, hhEmu->emu_maxcol - hhEmu->emu_curcol - n);

	/* --- Move stuff down --- */

	memmove(tp+n, tp, (unsigned)i * sizeof(ECHAR));
	memmove(ap+n, tp, (unsigned)i * sizeof(STATTR));
	memmove(pstMT+n, pstMT, (unsigned)i * sizeof(STMINITEL));

	hhEmu->emu_aiEnd[hhEmu->emu_imgrow] =
		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] + i;

	/* --- Fill the gap --- */

	memset(&stAttr, 0, sizeof(stAttr));
	stAttr.txtclr = VC_BRT_WHITE;
	stAttr.bkclr  = VC_BLACK;

	memset(&stMT, 0, sizeof(stMT));
	stMT.ismosaic = (unsigned)pstPRI->minitelG1Active;

	while (--i >= 0)
		{
		*tp++ = EMU_BLANK_CHAR;
		*ap++ = stAttr;
		*pstMT++ = stMT;
		}

	updateChar(sessQueryUpdateHdl(hhEmu->hSession),
				hhEmu->emu_currow,
				hhEmu->emu_curcol,
				hhEmu->emu_maxcol);

	ANSI_Pn_Clr(hhEmu);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelDelRows
 *
 * DESCRIPTION:
 *	Deletes n rows from the current row.
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelDelRows(const HHEMU hhEmu)
	{
	int r, r1;
	int c, i, n;
	STATTR stAttr;
	STMINITEL stMT;
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	// CSI sequences not available in row 0
	//
	if (hhEmu->emu_currow == 0)
		return;

	n = min(hhEmu->emu_maxrow, hhEmu->num_param[0]);
	i = max(0, hhEmu->emu_maxrow - hhEmu->emu_currow - n);

	for (i = 0 ; i < n ; ++i)
		{
		if ((hhEmu->emu_currow+i+n) > hhEmu->emu_maxrow)
			break;

		r = row_index(hhEmu, hhEmu->emu_currow+i);
		r1 = row_index(hhEmu, hhEmu->emu_currow+i+n);

		MemCopy(hhEmu->emu_apText[r],
				hhEmu->emu_apText[r1],
				sizeof(ECHAR) * (unsigned)(hhEmu->emu_maxcol+1));

		MemCopy(hhEmu->emu_apAttr[r],
				hhEmu->emu_apAttr[r1],
				sizeof(STATTR) * (unsigned)(hhEmu->emu_maxcol+1));

		MemCopy(pstPRI->apstMT[r],
				pstPRI->apstMT[r1],
				sizeof(STMINITEL) * (unsigned)(hhEmu->emu_maxcol+1));

		hhEmu->emu_aiEnd[r] = hhEmu->emu_aiEnd[r1];
		}

	memset(&stAttr, 0, sizeof(stAttr));
	stAttr.txtclr = VC_BRT_WHITE;
	stAttr.bkclr  = VC_BLACK;

	memset(&stMT, 0, sizeof(stMT));
	stMT.ismosaic = (unsigned)pstPRI->minitelG1Active;

	for (n = max(0, hhEmu->emu_maxrow - i) ; n <= hhEmu->emu_maxrow ; ++n)
		{
		r = row_index(hhEmu, n);

		for (c = 0 ; c <= hhEmu->emu_maxcol ; ++c)
			{
			hhEmu->emu_apText[r][c] = EMU_BLANK_CHAR;
			hhEmu->emu_apAttr[r][c] = stAttr;
			pstPRI->apstMT[r][c] = stMT;
			hhEmu->emu_aiEnd[r] = EMU_BLANK_LINE;
			}
		}

	updateLine(sessQueryUpdateHdl(hhEmu->hSession),
				hhEmu->emu_currow,
				hhEmu->emu_maxrow);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelInsRows
 *
 * DESCRIPTION:
 *	Inserts n rows from current row inclusive
 *
 * ARGUMENTS:
 *	void
 *
 * RETURNS:
 *	void
 *
 */
void minitelInsRows(const HHEMU hhEmu)
	{
	int r, r1;
	int c, i, n;
	STATTR stAttr;
	STMINITEL stMT;
	const PSTMTPRIVATE pstPRI = (PSTMTPRIVATE)hhEmu->pvPrivate;

	if (hhEmu->emu_currow == 0)
		return;

	n = min(hhEmu->emu_maxrow, hhEmu->num_param[0]);
	i = max(0, hhEmu->emu_maxrow - hhEmu->emu_currow - n);

	for (i = 0 ; i < n ; ++i)
		{
		if ((hhEmu->emu_currow+i+n) > hhEmu->emu_maxrow)
			break;

		r = row_index(hhEmu, hhEmu->emu_currow+i);
		r1 = row_index(hhEmu, hhEmu->emu_currow+i+n);

		MemCopy(hhEmu->emu_apText[r1],
				hhEmu->emu_apText[r],
				sizeof(ECHAR) * (unsigned)(hhEmu->emu_maxcol+1));

		MemCopy(hhEmu->emu_apAttr[r1],
				hhEmu->emu_apAttr[r],
				sizeof(STATTR) * (unsigned)(hhEmu->emu_maxcol+1));

		MemCopy(pstPRI->apstMT[r1],
				pstPRI->apstMT[r],
				sizeof(STMINITEL) * (unsigned)(hhEmu->emu_maxcol+1));

		hhEmu->emu_aiEnd[r1] = hhEmu->emu_aiEnd[r];
		}

	memset(&stAttr, 0, sizeof(stAttr));
	stAttr.txtclr = VC_BRT_WHITE;
	stAttr.bkclr  = VC_BLACK;

	memset(&stMT, 0, sizeof(stMT));
	stMT.ismosaic = (unsigned)pstPRI->minitelG1Active;

	for (n = hhEmu->emu_currow ; n < (hhEmu->emu_maxrow - i) ; ++n)
		{
		r = row_index(hhEmu, n);

		for (c = 0 ; c <= hhEmu->emu_maxcol ; ++c)
			{
			hhEmu->emu_apText[r][c] = EMU_BLANK_CHAR;
			hhEmu->emu_apAttr[r][c] = stAttr;
			pstPRI->apstMT[r][c] = stMT;
			hhEmu->emu_aiEnd[r] = EMU_BLANK_LINE;
			}
		}

	updateLine(sessQueryUpdateHdl(hhEmu->hSession),
				hhEmu->emu_currow,
				hhEmu->emu_maxrow);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitelHomeHostCursor
 *
 * DESCRIPTION:
 *	Sets cursor to home position which is 1, 0 in this case.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle
 *
 * RETURNS:
 *	0=OK,else error.
 *
 */
int minitelHomeHostCursor(const HHEMU hhEmu)
	{
	if (hhEmu == 0)
		{
		assert(0);
		return -1;
		}

	(*hhEmu->emu_setcurpos)(hhEmu, 1, 0);
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitel_scrollup
 *
 * DESCRIPTION:
 *	Mintels of course scroll differently.  Actually, its the way they
 *	clear lines that keeps us from using the standard stuff.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle.
 *	nlines	- number of lines to scroll.
 *
 * RETURNS:
 *	void
 *
 */
void minitel_scrollup(const HHEMU hhEmu, int nlines)
	{
	register INT row;
	INT 	nrows, iLen, iThisRow;
	ECHAR *lp;			/* line pointer */
	INT nScrlInc;		/* needed for call to Vid routine at bottom of func */

	if (nlines <= 0)
		return;

	hhEmu->scr_scrollcnt += nlines;
	nScrlInc = nlines = min(nlines,
							hhEmu->bottom_margin - hhEmu->top_margin + 1);

	for (row = hhEmu->top_margin; row < (hhEmu->top_margin + nlines); ++row)
		{
		iThisRow = row_index(hhEmu, row);
		lp = hhEmu->emu_apText[iThisRow];
		iLen = emuRowLen(hhEmu, iThisRow);
		minitel_clear_imgrow(hhEmu, row);
		}

	if (hhEmu->top_margin == 0 && hhEmu->bottom_margin == hhEmu->emu_maxrow)
		{
		hhEmu->emu_imgtop = row_index(hhEmu, nlines);
		}

	else if (nlines < (hhEmu->bottom_margin - hhEmu->top_margin + 1))
		{
		nrows = hhEmu->bottom_margin - hhEmu->top_margin + 1 - nlines;

		for (row = hhEmu->top_margin; nrows > 0; --nrows, ++row)
			{
			INT c;
			PSTATTR pstAttr, pstAttr2;
			PSTMINITEL pstMT, pstMT2;

			memmove(hhEmu->emu_apText[row_index(hhEmu, row)],
				 hhEmu->emu_apText[row_index(hhEmu, row + nlines)],
				 (size_t)hhEmu->emu_maxcol + 2);

			hhEmu->emu_aiEnd[row_index(hhEmu, row + nlines)] =
				hhEmu->emu_aiEnd[row_index(hhEmu, row)];

			pstAttr  = hhEmu->emu_apAttr[row_index(hhEmu, row)];
			pstAttr2 = hhEmu->emu_apAttr[row_index(hhEmu, row + nlines)];

			for (c = 0 ; c <= hhEmu->emu_maxcol ; ++c)
				pstAttr[c] = pstAttr2[c];

			pstMT = ((PSTMTPRIVATE)hhEmu->pvPrivate)->apstMT[row_index(hhEmu, row)];
			pstMT2= ((PSTMTPRIVATE)hhEmu->pvPrivate)->apstMT[row_index(hhEmu, row + nlines)];

			for (c = 0 ; c <= hhEmu->emu_maxcol ; ++c)
				pstMT[c] = pstMT2[c];
			}

		for (row = hhEmu->bottom_margin; nlines > 0; --nlines, --row)
			minitel_clear_imgrow(hhEmu, row);
		}

	hhEmu->emu_imgrow = row_index(hhEmu, hhEmu->emu_currow);

	updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
					hhEmu->top_margin,
					hhEmu->bottom_margin,
					nScrlInc,
					hhEmu->emu_imgtop,
					TRUE);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitel_scrolldown
 *
 * DESCRIPTION:
 *	Minitel of course works differently.  Mostly is has more work to
 *	clear a line.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle
 *	nlines	- number of lines to scroll
 *
 * RETURNS:
 *	void
 *
 */
void minitel_scrolldown(const HHEMU hhEmu, int nlines)
	{
	register int row, nrows;
	int toprow, botmrow;
	int nScrlInc;

	if (nlines <= 0)
		return;

	hhEmu->scr_scrollcnt -= nlines;
	nScrlInc = nlines;

	toprow = hhEmu->top_margin;
	botmrow = hhEmu->bottom_margin;

	if (hhEmu->top_margin == 0 && hhEmu->bottom_margin == hhEmu->emu_maxrow)
		{
		hhEmu->emu_imgtop = row_index(hhEmu, -nlines);
		}

	else if (nlines < hhEmu->bottom_margin - hhEmu->top_margin + 1)
		{
		nrows = hhEmu->bottom_margin - hhEmu->top_margin + 1 - nlines;

		for (row = hhEmu->bottom_margin; nrows > 0; --nrows, --row)
			{
			int c;
			PSTATTR pstAttr, pstAttr2;
			PSTMINITEL pstMT, pstMT2;

			memmove(hhEmu->emu_apText[row_index(hhEmu, row)],
				 hhEmu->emu_apText[row_index(hhEmu, row - nlines)],
						(size_t)(hhEmu->emu_maxcol+2));

			hhEmu->emu_aiEnd[row_index(hhEmu, row - nlines)] =
				hhEmu->emu_aiEnd[row_index(hhEmu, row)];

			pstAttr  = hhEmu->emu_apAttr[row_index(hhEmu, row)];
			pstAttr2 = hhEmu->emu_apAttr[row_index(hhEmu, row - nlines)];

			for (c = 0 ; c <= hhEmu->emu_maxcol ; ++c)
				pstAttr[c] = pstAttr2[c];

			pstMT = ((PSTMTPRIVATE)hhEmu->pvPrivate)->apstMT[row_index(hhEmu, row)];
			pstMT2= ((PSTMTPRIVATE)hhEmu->pvPrivate)->apstMT[row_index(hhEmu, row + nlines)];

			for (c = 0 ; c <= hhEmu->emu_maxcol ; ++c)
				pstMT[c] = pstMT2[c];
			}
		}

	for (row = hhEmu->top_margin; nlines > 0; --nlines, ++row)
		minitel_clear_imgrow(hhEmu, row);

	hhEmu->emu_imgrow = row_index(hhEmu, hhEmu->emu_currow);

	updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
					toprow, botmrow, -nScrlInc, hhEmu->emu_imgtop, TRUE);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	minitel_clear_imgrow
 *
 * DESCRIPTION:
 *	minitel's have to do more work to clear a line.
 *
 * ARGUMENTS:
 *	hhEmu	- private minitel handle.
 *	row 	- row to clear
 *
 * RETURNS:
 *	void
 *
 */
static void minitel_clear_imgrow(const HHEMU hhEmu, const int row)
	{
	const int save_row = hhEmu->emu_currow;
	const int save_imgrow = hhEmu->emu_imgrow;

	hhEmu->emu_currow = row;
	hhEmu->emu_imgrow = row_index(hhEmu, row);

	minitelClearLine(hhEmu, 2);

	hhEmu->emu_currow = save_row;
	hhEmu->emu_imgrow = save_imgrow;

	return;
	}
#endif	// INCL_MINITEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\viewdata.c ===
/*	File: D:\WACKER\emu\viewdata.c (Created: 31-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 5/09/01 4:46p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\session.h>
#include <tdll\chars.h>
#include <tdll\htchar.h>
#include <tdll\print.h>
#include <tdll\update.h>
#include <tdll\assert.h>

#include "emu.h"
#include "emu.hh"
#include "viewdata.hh"

#if defined(INCL_VIEWDATA)

static void EmuViewdataDisplayLine(const HHEMU hhEmu, const int iRow, const int iStartCol);
static STATTR GetAttr(const HHEMU hhEmu, const int iRow, const int iCol);
static ECHAR MapMosaics(const HHEMU hhEmu, ECHAR ch);
static int RowHasDblHigh(const HHEMU hhEmu, const int iRow);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataAnswerback
 *
 * DESCRIPTION:	Sends the answerback message defined on the menus.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataAnswerback(const HHEMU hhEmu)
	{
	TCHAR *sp;
	ECHAR *pech = NULL;

	sp = hhEmu->acAnswerback;

	// If there is nothing to send, there is nothing to send
	if (StrCharGetStrLength(sp) == 0)
		return;

	pech = malloc((unsigned int)StrCharGetByteCount(sp) + sizeof(TCHAR));

	if (pech == NULL)
		{
		assert(FALSE);
		return;
		}

	CnvrtMBCStoECHAR(pech, (unsigned long)StrCharGetByteCount(sp), sp, 
                     (unsigned long)StrCharGetByteCount(sp) + sizeof(TCHAR));

	emuSendString(hhEmu, pech, (int)StrCharGetEcharByteCount(pech));
	free(pech);
	pech = NULL;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataCursorLeft
 *
 * DESCRIPTION:	Moves cursor left one column. If cursor starts at left edge,
 *				it moves cursor to the last column of the line above.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataCursorLeft(const HHEMU hhEmu)
	{
	int iRow, iCol;

	iRow = hhEmu->emu_currow;
	iCol = hhEmu->emu_curcol;

	if (hhEmu->emu_curcol > 0)
		{
		iCol -= 1;
		}

	else if (hhEmu->emu_currow > 0)
		{
		iRow -= 1;
		iCol = hhEmu->emu_maxcol;
		}

	(*hhEmu->emu_setcurpos)(hhEmu, iRow, iCol);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataCursorRight
 *
 * DESCRIPTION:	Moves cursor right one column. If cursor starts at right edge,
 *				it moves cursor to the first column of the line below.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataCursorRight(const HHEMU hhEmu)
	{
	int iRow, iCol;

	iRow = hhEmu->emu_currow;
	iCol = hhEmu->emu_curcol;

	if (hhEmu->emu_curcol < hhEmu->emu_maxcol)
		{
		iCol += 1;
		}

	else if (hhEmu->emu_currow < hhEmu->emu_maxrow)
		{
		iRow += 1;
		iCol = 0;
		}

	(*hhEmu->emu_setcurpos)(hhEmu, iRow, iCol);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataCursorDown
 *
 * DESCRIPTION:	Moves cursor down to the next line while maintaining the same
 *				column. If starting on the bottom line, the cursor moves to
 *				the top line.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataCursorDown(const HHEMU hhEmu)
	{
	int iRow = hhEmu->emu_currow;

	(*hhEmu->emu_setcurpos)(hhEmu,
					(hhEmu->emu_currow < hhEmu->emu_maxrow ? ++iRow : 0),
					hhEmu->emu_curcol);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataCursorUp
 *
 * DESCRIPTION:	Moves cursor up to the next line while maintaining the same
 *				column. If starting on the top line, the cursor moves to
 *				the bottom line.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataCursorUp(const HHEMU hhEmu)
	{
	int iRow = hhEmu->emu_currow;

	(*hhEmu->emu_setcurpos)(hhEmu,
					(hhEmu->emu_currow > 0 ? --iRow : hhEmu->emu_maxrow),
					hhEmu->emu_curcol);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataCursorHome
 *
 * DESCRIPTION:	Moves cursor to upper left corner of screen.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataCursorHome(const HHEMU hhEmu)
	{
	(*hhEmu->emu_setcurpos)(hhEmu, 0,0);
    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataCursorSet
 *
 * DESCRIPTION:	Turns the cursor on and off.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataCursorSet(const HHEMU hhEmu)
	{
	switch(hhEmu->emu_code)
		{
	case ETEXT('\x11'):
		(*hhEmu->EmuSetCursorType)(hhEmu, EMU_CURSOR_BLOCK);
		break;

	case ETEXT('\x14'):
		(*hhEmu->EmuSetCursorType)(hhEmu, EMU_CURSOR_NONE);
		break;

	default:
		break;
		}

    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataMosaicHold
 *
 * DESCRIPTION: Displays the last displayed mosaic TCHAR inn every attribute
 *				space that was defined during mosaic mode. If no mosaic has
 *				been displayed since the last change in alpha/mosaic setting
 *				or normal/double height setting or the last mosaic release,
 *				a space is displayed instead.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataMosaicHold(const HHEMU hhEmu)
	{
	hhEmu->emu_code = ETEXT('\x20');
	EmuViewdataCharDisplay(hhEmu);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataMosaicRelease
 *
 * DESCRIPTION:	Displays a space.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataMosaicRelease(const HHEMU hhEmu)
	{
	/* TODO write this function */
	hhEmu->emu_code = ETEXT('\x20');
	EmuViewdataCharDisplay(hhEmu);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataSetAttr
 *
 * DESCRIPTION:	Sets colors and alpha/mosaic modes.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataSetAttr(const HHEMU hhEmu)
	{
	const ECHAR uch = hhEmu->emu_code;
	const PSTVIEWDATAPRIVATE pstPRI = (PSTVIEWDATAPRIVATE)hhEmu->pvPrivate;

	// For readability.
	//
	PSTVIEWDATA *stAttr = pstPRI->apstVD;
	int iRow = hhEmu->emu_imgrow;
	int iCol = hhEmu->emu_curcol;
	unsigned int *aiColors = pstPRI->aMapColors;

	STATTR charattr;

	hhEmu->emu_code = ETEXT('\x20');

	pstPRI->fSetAttr = TRUE;

	if (uch >= ETEXT('\x41') && uch <= ETEXT('\x47'))  // A thru G
		{
		stAttr[iRow][iCol].attr = ALPHA_ATTR;
		stAttr[iRow][iCol].clr	= aiColors[uch - ETEXT('\x41')];
		}

	else if (uch >= ETEXT('\x51') && uch <= ETEXT('\x57')) // Q thru W
		{
		charattr = GetAttr(hhEmu, hhEmu->emu_currow, hhEmu->emu_curcol);
		stAttr[iRow][iCol].attr = MOSAIC_ATTR;
		stAttr[iRow][iCol].clr	= aiColors[uch - ETEXT('\x51')];
		}

	else
		{
		switch(uch)
			{
		case ETEXT('\x48'): //'H':
			stAttr[iRow][iCol].attr = FLASH_ATTR;
			break;

		case ETEXT('\x49'): //'I':
			stAttr[iRow][iCol].attr = STEADY_ATTR;
			break;

		case ETEXT('\x4C'): //'L':
			stAttr[iRow][iCol].attr = NORMALSIZE_ATTR;
			break;

		case ETEXT('\x4D'): //'M':
			stAttr[iRow][iCol].attr = DOUBLESIZE_ATTR;
			break;

		case ETEXT('\x58'): //'X':
			stAttr[iRow][iCol].attr = CONCEAL_ATTR;
			break;

		case ETEXT('\x59'): //'Y':
			stAttr[iRow][iCol].attr = CONTIGUOUS_ATTR;
			break;

		case ETEXT('\x5A'): //'Z':
			stAttr[iRow][iCol].attr = SEPARATED_ATTR;
			break;

		case ETEXT('\x5C'): //'\\':
			stAttr[iRow][iCol].attr = NEW_BACKGROUND_ATTR;
			stAttr[iRow][iCol].clr	= 0;
			break;

		case ETEXT('\x5D'): //']':
			stAttr[iRow][iCol].attr = NEW_BACKGROUND_ATTR;
			charattr = GetAttr(hhEmu, hhEmu->emu_currow, hhEmu->emu_curcol);
			stAttr[iRow][iCol].clr = charattr.txtclr;
			break;

		default:
			return;
			}
		}

	EmuViewdataCharDisplay(hhEmu);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataCharDisplay
 *
 * DESCRIPTION:	Displays a single character
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void EmuViewdataCharDisplay(const HHEMU hhEmu)
	{
	int  iRow = hhEmu->emu_currow;
	int  iCol = hhEmu->emu_curcol;
	ECHAR *tp = hhEmu->emu_apText[hhEmu->emu_imgrow];
	PSTATTR ap = hhEmu->emu_apAttr[hhEmu->emu_imgrow];
	const PSTVIEWDATAPRIVATE pstPRI = (PSTVIEWDATAPRIVATE)hhEmu->pvPrivate;

    // TODO: Temporary until we get Prestel font

	if (hhEmu->emu_code == ETEXT('\x7F'))
		hhEmu->emu_code = ETEXT('\x5B');

	if (RowHasDblHigh(hhEmu, iRow))
        goto SKIP;

	// Need to GetAtt() before calling MapMosaics() so vars are set right.
	//
	ap[iCol] = GetAttr(hhEmu, iRow, iCol);
	tp[iCol] = MapMosaics(hhEmu, hhEmu->emu_code);

	// Update the end of row index if necessary.
	//
	if (iCol > hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = iCol;

	/* --- check to see if we are overwriting an attribute space --- */

	if (!pstPRI->fSetAttr)
		{
		pstPRI->fSetAttr =
			(BOOL)pstPRI->apstVD[hhEmu->emu_imgrow][hhEmu->emu_curcol].attr;

		pstPRI->apstVD[hhEmu->emu_imgrow][hhEmu->emu_curcol].attr = 0;
		}

    updateChar(sessQueryUpdateHdl(hhEmu->hSession), iRow, iCol, iCol);

    if (ap[iCol].dblhihi)
        {
		const PSTATTR apl =
			hhEmu->emu_apAttr[row_index(hhEmu, hhEmu->emu_currow+1)];

		hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow+1)][iCol] =
			tp[iCol];

        apl[iCol] = ap[iCol];
        apl[iCol].dblhihi = 0;
		apl[iCol].dblhilo = 1;

		pstPRI->fSetAttr = TRUE;	// need to redisplay line to get lower half to show.
        }

	if (pstPRI->fSetAttr)
        {
		EmuViewdataDisplayLine(hhEmu, iRow, iCol);
		pstPRI->fSetAttr = FALSE;
        }

    SKIP:
	if (++iCol > hhEmu->emu_maxcol)
		{
		if (hhEmu->print_echo)
			printEchoLine(hhEmu->hPrintEcho,
							tp,
							emuRowLen(hhEmu, hhEmu->emu_imgrow));

		if (++iRow > hhEmu->emu_maxrow)
			iRow = 0;

		iCol = 0;
		}

	(*hhEmu->emu_setcurpos)(hhEmu, iRow, iCol);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataDisplayLine
 *
 * DESCRIPTION:	Redisplays the specified row from the specified column
 *				using the current emu_charattr and character type up to
 *				the end of the line (the 1st nul) or the next attribute
 *				space (whichever comes first).
 *
 * ARGUMENTS:
 *				sRow -- screen row to redisplay
 *				sCol -- screen column at which to start displaying
 *
 * RETURNS:		nothing
 */
static void EmuViewdataDisplayLine(const HHEMU hhEmu,
									const int iRow,
									const int iStartCol)
	{
	int iCol;
    int fDblHi = FALSE;
	ECHAR *tp = hhEmu->emu_apText[row_index(hhEmu, iRow)];
	PSTATTR ap = hhEmu->emu_apAttr[row_index(hhEmu, iRow)];
	const PSTATTR apl = hhEmu->emu_apAttr[row_index(hhEmu, iRow+1)];

	for (iCol = iStartCol ; iCol <= hhEmu->emu_maxcol ; ++iCol)
		{
		ap[iCol] = GetAttr(hhEmu, iRow, iCol);
		tp[iCol] = MapMosaics(hhEmu, tp[iCol]);

		if (iRow < hhEmu->emu_maxrow && ap[iCol].dblhihi)
            fDblHi = TRUE;
		}

	updateChar(sessQueryUpdateHdl(hhEmu->hSession),
						iRow,
						iStartCol,
						hhEmu->emu_maxcol);

    if (fDblHi)
        {
		for (iCol = 0 ; iCol <= hhEmu->emu_maxcol ; ++iCol)
            {
            apl[iCol].bkclr = ap[iCol].bkclr;

            if (!apl[iCol].dblhilo)
                apl[iCol].blank = 1;
            }

        updateLine(sessQueryUpdateHdl(hhEmu->hSession), iRow+1, iRow+1);
        }

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	GetAttr
 *
 * DESCRIPTION:
 *	Walks the current row and builds a composite attribute based on
 *	the encountered attribute spaces.
 *
 * ARGUMENTS:
 *	iRow	- logical row
 *	iCol	- logical col
 *
 * RETURNS:
 *	composite attribute.
 *
 */
static STATTR GetAttr(const HHEMU hhEmu, const int iRow, const int iCol)
	{
	int i;
	STATTR stAttr;
	const PSTVIEWDATAPRIVATE pstPRI = (PSTVIEWDATAPRIVATE)hhEmu->pvPrivate;
	const PSTVIEWDATA pstVD = pstPRI->apstVD[row_index(hhEmu, iRow)];
	
	memset(&stAttr, 0, sizeof(STATTR));
	stAttr.txtclr = VC_BRT_WHITE;
	stAttr.bkclr  = VC_BLACK;

	pstPRI->fMosaicMode = FALSE;
	pstPRI->fSeperatedMosaic = FALSE;

	for (i = 0 ; i <= iCol ; ++i)
		{
		if (pstVD[i].attr)
			{
			switch (pstVD[i].attr)
				{
			case ALPHA_ATTR:
				pstPRI->fMosaicMode = FALSE;
				stAttr.txtclr = pstVD[i].clr;
				stAttr.symbol = FALSE;
				break;

			case MOSAIC_ATTR:
				pstPRI->fMosaicMode = TRUE;
				stAttr.txtclr = pstVD[i].clr;
				stAttr.symbol = TRUE;
				break;

			case CONTIGUOUS_ATTR:
				pstPRI->fMosaicMode = TRUE;
				pstPRI->fSeperatedMosaic = FALSE;
				stAttr.txtclr = pstVD[i].clr;
				stAttr.symbol = TRUE;
				break;

			case SEPARATED_ATTR:
				pstPRI->fMosaicMode = TRUE;
				pstPRI->fSeperatedMosaic = TRUE;
				stAttr.txtclr = pstVD[i].clr;
				stAttr.symbol = TRUE;
				break;

			case NORMALSIZE_ATTR:
				stAttr.dblhihi = 0;
				break;

			case FLASH_ATTR:
				stAttr.blink = 1;
				break;

			case STEADY_ATTR:
				stAttr.blink = 0;
				break;

			case NEW_BACKGROUND_ATTR:
				stAttr.bkclr = pstVD[i].clr;
				break;

			case DOUBLESIZE_ATTR:
				stAttr.dblhihi = 1;
				break;

			case CONCEAL_ATTR:
				stAttr.blank = 0; // ??
				break;

			default:
				break;
				}
			}
		}

	return stAttr;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	MapMosaics
 *
 * DESCRIPTION:
 *	Since attributes that come before characters affect the character
 *	display (alpha vs. mosaic) we need to map mosaic chars back to their
 *	alpha counterparts and vice-versa at anytime.  Prestel uses 7 bit
 *	ascii so we can map the mosaics to the upper 128 bytes.  This
 *	function just checks the current mode (mosaic/alpha) and if the
 *	character is in the proper range, its converted to its counterpart.
 *	Also converts NULL to a space.	View data doesn't support an end
 *	of line concept and instead always fills to the end of line.
 *
 *	Note:  This function assumes GetAttr() has been called since it
 *		   relies on fMosaic and fSeperatedMosaic to be set.
 *
 * ARGUMENTS:
 *	ch	- character to convert
 *
 * RETURNS:
 *	converted or original character.
 *
 */
static ECHAR MapMosaics(const HHEMU hhEmu, ECHAR ch)
	{
	const PSTVIEWDATAPRIVATE pstPRI = (PSTVIEWDATAPRIVATE)hhEmu->pvPrivate;

	if (pstPRI->fMosaicMode)
		{
		// This is temporary until the fonts get straightend out.
		//
		if (ch > ETEXT('\x21') && ch <= ETEXT('\x3F'))
			ch += ETEXT('\x1F');

		if (pstPRI->fSeperatedMosaic)
			ch += ETEXT('\x80');
		}

	else // convert to equivalent alpha
		{
		if (ch > ETEXT('\x80'))
			ch -= ETEXT('\x80');
		}


	return ch;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EmuViewdataClearScreen
 *
 * DESCRIPTION:
 *	We use AnsiFormFeed() to do most of the work but we have to
 *	clear viewdata's  attribute buffer as well.
 *
 * ARGUMENTS:
 *	none
 *
 * RETURNS:
 *	void
 *
 */
void EmuViewdataClearScreen(const HHEMU hhEmu)
	{
	const PSTVIEWDATAPRIVATE pstPRI = (PSTVIEWDATAPRIVATE)hhEmu->pvPrivate;
	register int i;

	AnsiFormFeed(hhEmu);

	for (i = 0 ; i < hhEmu->emu_maxrow ; ++i)
		memset(pstPRI->apstVD[i],
				0,
				sizeof(STVIEWDATA) * VIEWDATA_COLS_40MODE);

    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataKbd
 *
 * DESCRIPTION:
 *	 Keyboard routine for processing local keys on Viewdata terminal
 *
 * ARGUMENTS:
 *	 kcode	-	Key
 *
 * RETURNS:
 *	 nothing
 */
int EmuViewdataKbd(const HHEMU hhEmu, int kcode, const BOOL fTest)
	{
	switch (kcode)
		{
	case VK_ESCAPE | VIRTUAL_KEY:
		kcode = ETEXT('[') | CTRL_KEY;
		if (fTest)
			return kcode;
		break;

	case VK_TAB | VIRTUAL_KEY:
		kcode = ETEXT('I') | CTRL_KEY;
		if (fTest)
			return kcode;
		break;

	case VK_RETURN | VIRTUAL_KEY | CTRL_KEY:
		kcode = ETEXT('J') | CTRL_KEY;
		if (fTest)
			return kcode;
		break;
	default:
		break;
		}

	return std_kbdin(hhEmu, kcode, fTest);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * RowHasDblHigh
 *
 * DESCRIPTION:
 *  Checks if we are in the second row of a double high sequence. 
 *
 * ARGUMENTS:
 *	 void
 *
 * RETURNS:
 *	 0=FALSE, 1=TRUE
 */
static int RowHasDblHigh(const HHEMU hhEmu, const int iRow)
    {
    int i;
	const int r = row_index(hhEmu, iRow);
	const PSTATTR ap = hhEmu->emu_apAttr[r];

	if (hhEmu->emu_currow != 0)
        {
		for (i = 0 ; i < hhEmu->emu_maxcol ; ++i)
            {
            if (ap[i].dblhilo)
                return 1;
            }
        }

    return 0;
    }

#endif // INCL_VIEWDATA
/************************** end of viewdata.c *****************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\vt100ini.c ===
/*	File: D:\WACKER\emu\vt100ini.c (Created: 27-Dec-1993)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:29p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\assert.h>
#include <tdll\mc.h>
#include <tdll\backscrl.h>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"
#include "emudec.hh"
#include "keytbls.h"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt100_init
 *
 * DESCRIPTION:
 *	 Initializes the VT100 emulator.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *	 nothing
 */
void vt100_init(const HHEMU hhEmu)
	{
	PSTDECPRIVATE pstPRI;
	int iRow;

	static struct trans_entry const vt100_tbl[] =
		{
		{NEW_STATE, 0, 0, 0}, // State 0
#if !defined(FAR_EAST)
		{0, ETEXT('\x20'),	ETEXT('\x7E'),	emuDecGraphic}, 	// Space - ~
#else
		{0, ETEXT('\x20'),	0xFFFF,			emuDecGraphic}, 	// Space - ~
#endif
		{1, ETEXT('\x1B'),	ETEXT('\x1B'),	nothing},			// Esc
		{0, ETEXT('\x05'),	ETEXT('\x05'),	vt100_answerback},	// Ctrl-E
		{0, ETEXT('\x07'),	ETEXT('\x07'),	emu_bell},			// Ctrl-G
		{0, ETEXT('\x08'),	ETEXT('\x08'),	vt_backspace},		// BackSpace
		{0, ETEXT('\x09'),	ETEXT('\x09'),	emuDecTab}, 		// Tab
		{0, ETEXT('\x0A'),	ETEXT('\x0C'),	emuLineFeed},		// NL - FF
		{0, ETEXT('\x0D'),	ETEXT('\x0D'),	carriagereturn},	// CR
		{0, ETEXT('\x0E'),	ETEXT('\x0F'),	vt_charshift},		// Ctrl-N
		{7, ETEXT('\x18'),	ETEXT('\x18'),	EmuStdChkZmdm}, 	// Ctrl-X

		{NEW_STATE, 0, 0, 0}, // State 1						// Esc
		{2, ETEXT('\x5B'),	ETEXT('\x5B'),	ANSI_Pn_Clr},		// [
		{3, ETEXT('\x23'),	ETEXT('\x23'),	nothing},			// #
		{4, ETEXT('\x28'),	ETEXT('\x29'),	vt_scs1},			// ( - )
		{0, ETEXT('\x37'),	ETEXT('\x38'),	vt100_savecursor},	// 7 - 8
		{1, ETEXT('\x3B'),	ETEXT('\x3B'),	ANSI_Pn_End},		// ;
		{0, ETEXT('\x3D'),	ETEXT('\x3E'),	vt_alt_kpmode}, 	// = - >
		{0, ETEXT('\x44'),	ETEXT('\x44'),	emuDecIND}, 		// D
		{0, ETEXT('\x45'),	ETEXT('\x45'),	ANSI_NEL},			// E
		{0, ETEXT('\x48'),	ETEXT('\x48'),	ANSI_HTS},			// H
		{0, ETEXT('\x4D'),	ETEXT('\x4D'),	emuDecRI},			// M
		{0, ETEXT('\x5A'),	ETEXT('\x5A'),	ANSI_DA},			// Z
		{0, ETEXT('\x63'),	ETEXT('\x63'),	vt100_hostreset},	// c

		{NEW_STATE, 0, 0, 0}, // State 2						// Esc[
		{2, ETEXT('\x3B'),	ETEXT('\x3B'),	ANSI_Pn_End},		// ;
		{2, ETEXT('\x30'),	ETEXT('\x3F'),	ANSI_Pn},			// 0 - ?
		{5, ETEXT('\x22'),	ETEXT('\x22'),	nothing},			// "
		{0, ETEXT('\x41'),	ETEXT('\x41'),	emuDecCUU}, 		// A
		{0, ETEXT('\x42'),	ETEXT('\x42'),	emuDecCUD}, 		// B
		{0, ETEXT('\x43'),	ETEXT('\x43'),	emuDecCUF}, 		// C
		{0, ETEXT('\x44'),	ETEXT('\x44'),	emuDecCUB}, 		// D
		{0, ETEXT('\x48'),	ETEXT('\x48'),	emuDecCUP}, 		// H
		{0, ETEXT('\x4A'),	ETEXT('\x4A'),	emuDecED},			// J
		{0, ETEXT('\x4B'),	ETEXT('\x4B'),	ANSI_EL},			// K
		{0, ETEXT('\x4C'),	ETEXT('\x4C'),	vt_IL}, 			// L
		{0, ETEXT('\x4D'),	ETEXT('\x4D'),	vt_DL}, 			// M
		{0, ETEXT('\x50'),	ETEXT('\x50'),	vt_DCH},			// P
		{0, ETEXT('\x63'),	ETEXT('\x63'),	ANSI_DA},			// c
		{0, ETEXT('\x66'),	ETEXT('\x66'),	emuDecCUP}, 		// f
		{0, ETEXT('\x67'),	ETEXT('\x67'),	ANSI_TBC},			// g
		{0, ETEXT('\x68'),	ETEXT('\x68'),	ANSI_SM},			// h
		{0, ETEXT('\x69'),	ETEXT('\x69'),	vt100PrintCommands},// i
		{0, ETEXT('\x6C'),	ETEXT('\x6C'),	ANSI_RM},			// l
		{0, ETEXT('\x6D'),	ETEXT('\x6D'),	ANSI_SGR},			// m
		{0, ETEXT('\x6E'),	ETEXT('\x6E'),	ANSI_DSR},			// n
		{0, ETEXT('\x71'),	ETEXT('\x71'),	nothing},			// q
		{0, ETEXT('\x72'),	ETEXT('\x72'),	vt_scrollrgn},		// r
		{0, ETEXT('\x78'),	ETEXT('\x78'),	vt100_report},		// x

		{NEW_STATE, 0, 0, 0}, // State 3						// Esc#
		{0, ETEXT('\x33'),	ETEXT('\x36'),	emuSetDoubleAttr},	// 3 - 6

		{0, ETEXT('\x38'),	ETEXT('\x38'),	vt_screen_adjust},	// 8

		{NEW_STATE, 0, 0, 0}, // State 4						// Esc ( - )
		{0, ETEXT('\x01'),	ETEXT('\xFF'),	vt_scs2},			// All

		{NEW_STATE, 0, 0, 0}, // State 5						// Esc["
		{0, ETEXT('\x70'),	ETEXT('\x70'),	nothing},			// p

		{NEW_STATE, 0, 0, 0}, // State 6						// Printer control
		{6, ETEXT('\x00'),	ETEXT('\xFF'),	vt100_prnc},		// All

		{NEW_STATE, 0, 0, 0}, // State 7						// Ctrl-X
		{7, ETEXT('\x00'),	ETEXT('\xFF'),	EmuStdChkZmdm}, 	// All

		};

	emuInstallStateTable(hhEmu, vt100_tbl, DIM(vt100_tbl));

	// Allocate space for and initialize data that is used only by the
	// VT100 emulator.
	//
	hhEmu->pvPrivate = malloc(sizeof(DECPRIVATE));

	if (hhEmu->pvPrivate == 0)
		{
		assert(FALSE);
		return;
		}

	pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	memset(pstPRI, 0, sizeof(DECPRIVATE));

	// Allocate an array to hold line attribute values.
	//
	pstPRI->aiLineAttr = malloc(MAX_EMUROWS * sizeof(int) );

	if (pstPRI->aiLineAttr == 0)
		{
		assert(FALSE);
		return;
		}

	for (iRow = 0; iRow < MAX_EMUROWS; iRow++)
		pstPRI->aiLineAttr[iRow] = NO_LINE_ATTR;

	pstPRI->sv_row			= 0;
	pstPRI->sv_col			= 0;
	pstPRI->gn				= 0;
	pstPRI->sv_AWM			= RESET;
	pstPRI->sv_DECOM		= RESET;
	pstPRI->sv_protectmode	= FALSE;
	pstPRI->fAttrsSaved 	= FALSE;
	pstPRI->pntr			= pstPRI->storage;

	// Initialize hhEmu values for VT100.
	//
	hhEmu->emu_kbdin		= vt100_kbdin;
	hhEmu->emuResetTerminal = vt100_reset;
	hhEmu->emu_setcurpos	= emuDecSetCurPos;
	hhEmu->emu_deinstall	= emuVT100Unload;
	hhEmu->emu_clearscreen	= emuDecClearScreen;

#if !defined(FAR_EAST)
	hhEmu->emu_highchar 	= 0x7E;
#else
	hhEmu->emu_highchar 	= 0xFFFF;
#endif
	hhEmu->emu_maxcol		= VT_MAXCOL_80MODE;
	hhEmu->mode_vt220		= FALSE;

	std_dsptbl(hhEmu, TRUE);
	vt_charset_init(hhEmu);

	emuKeyTableLoad(hhEmu, VT100KeyTable, 
					 sizeof(VT100KeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl);

	emuKeyTableLoad(hhEmu, VT100_Keypad_KeyTable, 
					 sizeof(VT100_Keypad_KeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl2);

	emuKeyTableLoad(hhEmu, VT100_Cursor_KeyTable, 
					 sizeof(VT100_Cursor_KeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl3);

	emuKeyTableLoad(hhEmu, VT_PF_KeyTable, 
					 sizeof(VT_PF_KeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl4);

	backscrlSetShowFlag(sessQueryBackscrlHdl(hhEmu->hSession), TRUE);
	return;
	}

/* end of vt100ini.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\vt100.c ===
/*	File: D:\WACKER\emu\vt100.c (Created: 08-Dec-1993)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 11 $
 *	$Date: 3/04/02 12:00p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\htchar.h>
#include <tdll\session.h>
#include <tdll\chars.h>
#include <tdll\com.h>
#include <tdll\cloop.h>
#include <tdll\assert.h>
#include <tdll\print.h>
#include <tdll\capture.h>
#include <tdll\update.h>
#include <tdll\backscrl.h>
#include <tdll\mc.h>

#include "emu.h"
#include "emu.hh"
#include "emudec.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuDecGraphic
 *
 * DESCRIPTION:
 *	This function is called to display the normal range of characters
 *	for the emulators.	It handles insertion modes, end of line wrapping,
 *	and cursor positioning.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuDecGraphic(const HHEMU hhEmu)
	{
	ECHAR ccode = hhEmu->emu_code;
	ECHAR aechBuf[10];
	int iCharsToMove;
	int fDecColHold = FALSE;

	int iRow = hhEmu->emu_currow;
	int iCol = hhEmu->emu_curcol;

	ECHAR	*tp = hhEmu->emu_apText[hhEmu->emu_imgrow];
	PSTATTR ap = hhEmu->emu_apAttr[hhEmu->emu_imgrow];

	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	// Initialize a test flag.	This is used for a special case when
	// emulating a VT100 (and maybe other DEC emulators) and the
	// current column position is the maximum.	When a character is placed
	// at emu_maxcol, instead of advancing the cursor to column 0 of the
	// next line, it is instead placed under that last character.  When the
	// next character arrives, it is placed at column 0 on the next line, and
	// then the cursor is advanced as expected.
	//

	// Special DEC test.
	//
	if (hhEmu->mode_AWM && iCol == hhEmu->emu_maxcol)
		{
		if (pstPRI->fDecColHold)
			{
			fDecColHold = FALSE;

			CaptureLine(sessQueryCaptureFileHdl(hhEmu->hSession),
							CF_CAP_LINES,
							tp,
							emuRowLen(hhEmu, hhEmu->emu_imgrow));

			printEchoString(hhEmu->hPrintEcho,
							tp,
							emuRowLen(hhEmu, hhEmu->emu_imgrow));


			CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("\r\n"),
                             StrCharGetByteCount(TEXT("\r\n")));
			printEchoString(hhEmu->hPrintEcho,
							aechBuf,
							sizeof(ECHAR) * 2);

			if (iRow == hhEmu->bottom_margin)
				(*hhEmu->emu_scroll)(hhEmu, 1, TRUE);
			else
				++iRow;

			iCol = 0;
			(*hhEmu->emu_setcurpos)(hhEmu, iRow, iCol);

			tp = hhEmu->emu_apText[hhEmu->emu_imgrow];
			ap = hhEmu->emu_apAttr[hhEmu->emu_imgrow];
			}

		else
			{
			iCol = hhEmu->emu_maxcol;
			fDecColHold = TRUE;
			}
		}

	// Is the emulator in insert mode?
	//
	if (hhEmu->mode_IRM == SET)
		{
		iCharsToMove = (hhEmu->emu_aiEnd[hhEmu->emu_imgrow] - iCol + 1);

		if (iCharsToMove + iCol >= hhEmu->emu_maxcol)
			iCharsToMove -= 1;

		if (iCharsToMove > 0)
			{
			memmove(&tp[iCol+1],
					&tp[iCol],
					(unsigned)iCharsToMove * sizeof(ECHAR));

			memmove(&ap[iCol+1],
					&ap[iCol],
					(unsigned)iCharsToMove * sizeof(ECHAR));

			hhEmu->emu_aiEnd[hhEmu->emu_imgrow] =
				min(hhEmu->emu_aiEnd[hhEmu->emu_imgrow] + 1,
					hhEmu->emu_maxcol - 1);
			}
		}

	// Our competetor's are eating the NULL's.	DOS ANSI doesn't.
	// For now we'll try it their way... - mrw
	//
	if (ccode == (ECHAR)0)
		return;

	// Place the character and the current attribute into the image.
	//
	if (((hhEmu->stUserSettings.nEmuId == EMU_VT100)            ||
				(hhEmu->stUserSettings.nEmuId == EMU_VT220)     ||
				(hhEmu->stUserSettings.nEmuId == EMU_VT320)     ||
				(hhEmu->stUserSettings.nEmuId == EMU_VT100PLUS) ||
                (hhEmu->stUserSettings.nEmuId == EMU_VTUTF8)) &&
			ccode < sizeof(hhEmu->dspchar))
		ccode = hhEmu->dspchar[ccode];

	tp[iCol] = ccode;
	ap[iCol] = hhEmu->emu_charattr;

	// Check for double high, double wide processing.
	//
	if (pstPRI->aiLineAttr[hhEmu->emu_imgrow] != NO_LINE_ATTR)
		{
		int iColPrev = iCol;

		ap[iCol].dblwilf = 1;
		ap[iCol].dblwirt = 0;
		ap[iCol].dblhihi = (pstPRI->aiLineAttr[hhEmu->emu_imgrow] == DBL_WIDE_HI) ? 1 : 0;
		ap[iCol].dblhilo = (pstPRI->aiLineAttr[hhEmu->emu_imgrow] == DBL_WIDE_LO) ? 1 : 0;

		iCol = min(iCol+1, hhEmu->emu_maxcol);

		tp[iCol] = ccode;
		ap[iCol] = ap[iColPrev];
		ap[iCol].dblwilf = 0;
		ap[iCol].dblwirt = 1;
		}

#ifndef CHAR_NARROW
	// Process Double Byte Characters
	//
	if (QueryCLoopMBCSState(sessQueryCLoopHdl(hhEmu->hSession)))
		{
		if (isDBCSChar(ccode))
			{
			int iColPrev = iCol;

			ap[iCol].wilf = 1;
			ap[iCol].wirt = 0;

			iCol = min(iCol+1, hhEmu->emu_maxcol);

			tp[iCol] = ccode;
			ap[iCol] = ap[iColPrev];
			ap[iCol].wilf = 0;
			ap[iCol].wirt = 1;
			}
#if 0
        //mpt:1-23-98 handles the case when an incoming character
        //            (single or double byte) overwrites the first half of
        //            a double byte character
	    if ( iCol < hhEmu->emu_maxcol )
		    {
		    //if we orphaned a right half of a dbcs char
		    if (hhEmu->emu_apAttr[iRow][iCol + 1].wirt == TRUE)
			    {
			    //slide characters and attribs to left
                iCharsToMove = hhEmu->emu_aiEnd[hhEmu->emu_imgrow] - iCol - 1;
			    if (iCol + 2 < hhEmu->emu_maxcol && iCharsToMove > 0)
				    {
				    memmove(&tp[iCol + 1],
                            &tp[iCol + 2],
                            (unsigned)iCharsToMove * sizeof(ECHAR));

                    memmove(&ap[iCol + 1],
                            &ap[iCol + 2],
                            (unsigned)iCharsToMove * sizeof(ECHAR));
				    }
			    
			    //blank out character at end of line
			    tp[hhEmu->emu_aiEnd[hhEmu->emu_imgrow]] = 32;
			    ap[hhEmu->emu_aiEnd[hhEmu->emu_imgrow]].wirt = 0;
			    
                //move end of row since we removed a character
                hhEmu->emu_aiEnd[hhEmu->emu_imgrow]--;

                //update the image
                updateChar(sessQueryUpdateHdl(hhEmu->hSession),
				    hhEmu->emu_imgrow,
				    hhEmu->emu_aiEnd[hhEmu->emu_imgrow],
				    hhEmu->mode_IRM ?
				    hhEmu->emu_maxcol :
				    hhEmu->emu_aiEnd[hhEmu->emu_imgrow]);
                }	
    		}
#endif
        }
#endif //CHAR_NARROW

	// Update the end of row index if necessary.
	//
	if (iCol > hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
		hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = iCol;

	// Update the image.
	//
	updateChar(sessQueryUpdateHdl(hhEmu->hSession),
				iRow,
				hhEmu->emu_curcol,
				hhEmu->mode_IRM ? hhEmu->emu_maxcol : iCol);

	// Move the position of the cursor ahead of the last character
	// displayed, checking for end of line wrap.
	//
	iCol += 1;

	// Finally, set the cursor position.  This wil reset emu_currow
	// and emu_curcol.
	//
	(*hhEmu->emu_setcurpos)(hhEmu, iRow, iCol);

	// Whenever we call setcurpos, it resets pstPRI->fDecColHold so
	// don't set till after we postion cursor.
	//
	pstPRI->fDecColHold = fDecColHold;
	return;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_DA
 *
 * DESCRIPTION:
 *	 Sends the device attribute (DA) report to the host.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_DA(const HHEMU hhEmu)
	{
	int fOldValue;
	ECHAR ech[15];

	CnvrtMBCStoECHAR(ech, sizeof(ech), TEXT("\033[?1;2c"), 
					 StrCharGetByteCount(TEXT("\033[?1;2c")));

	fOldValue = CLoopGetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession));

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), FALSE);

	emuSendString(hhEmu, ech, (int)StrCharGetEcharByteCount(ech)); 

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), fOldValue);

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt100_savecursor
 *
 * DESCRIPTION:
 *	 Saves the current cursor postion; and, it also
 *	 saves display attributes, character set, wrap mode, and origin mode.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 *
 * NOTES:
 *	This function contains Auto Detect code.
 */
void vt100_savecursor(const HHEMU hhEmu)
	{
	ECHAR sel;
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	sel = hhEmu->emu_code;

	if (sel == ETEXT('7')) /* save cursor & attributes */
		{
		(*hhEmu->emu_getcurpos)(hhEmu, &pstPRI->sv_row, &pstPRI->sv_col);
		pstPRI->sv_state = hhEmu->iCurAttrState;
		pstPRI->sv_attr = hhEmu->attrState[hhEmu->iCurAttrState];
		vt_charset_save(hhEmu);
		pstPRI->sv_AWM = hhEmu->mode_AWM;
		pstPRI->sv_DECOM = hhEmu->mode_DECOM;
		pstPRI->sv_protectmode = hhEmu->mode_protect;
		pstPRI->fAttrsSaved = TRUE;
		}

	else if (sel == ETEXT('8'))	  /* restore cursor and attr. */
		{
		(*hhEmu->emu_setcurpos)(hhEmu, pstPRI->sv_row, pstPRI->sv_col);

		//if (pstPRI->sv_col == hhEmu->emu_maxcol)
		//	  hhEmu->emu_curcol = pstPRI->sv_col;		 /* in order to wrap on next char */

		if (pstPRI->fAttrsSaved)
			{
			hhEmu->iCurAttrState = pstPRI->sv_state;

			hhEmu->attrState[hhEmu->iCurAttrState] = pstPRI->sv_attr;

			hhEmu->emu_charattr = hhEmu->attrState[hhEmu->iCurAttrState];
			}

		vt_charset_restore(hhEmu);

		hhEmu->mode_AWM = pstPRI->sv_AWM;
		hhEmu->mode_DECOM = pstPRI->sv_DECOM;
		hhEmu->mode_protect = pstPRI->sv_protectmode;
		}

	else		/* clear saved conditions */
		{
		pstPRI->sv_row = pstPRI->sv_col = 0;
		pstPRI->sv_state = hhEmu->iCurAttrState;
		pstPRI->sv_AWM = pstPRI->sv_DECOM = RESET;
		pstPRI->sv_protectmode = FALSE;
		pstPRI->fAttrsSaved = FALSE;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt100_answerback
 *
 * DESCRIPTION:
 *	 Sends the answerback message defined on the menus.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void vt100_answerback(const HHEMU hhEmu)
	{
	int fOldValue;
	TCHAR *sp;
	ECHAR *pech = NULL;

	sp = hhEmu->acAnswerback;

	// If there is nothing to send, there is nothing to send
	if (StrCharGetStrLength(sp) == 0)
		return;

	pech = malloc((unsigned int)StrCharGetByteCount(sp));
	if (pech == NULL)
		{
		assert(FALSE);
		return;
		}

	CnvrtMBCStoECHAR(pech, StrCharGetByteCount(sp), sp, StrCharGetByteCount(sp));

	/* to not get recursive answerback's in half duplex */

	fOldValue = CLoopGetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession));

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), FALSE);

	emuSendString(hhEmu, pech, (int)StrCharGetEcharByteCount(pech));
	free(pech);
	pech = NULL;

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), fOldValue);

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt100_hostreset
 *
 * DESCRIPTION:
 *	 Calls vt100_reset() when told to reset by the host.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void vt100_hostreset(const HHEMU hhEmu)
	{
	vt100_reset(hhEmu, TRUE);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt100_reset
 *
 * DESCRIPTION:
 *	 Resets the emulator.
 *
 * ARGUMENTS:
 *	 host_request -- TRUE when told to reset by the host.
 *
 * RETURNS:
 *	 nothing
 */
int vt100_reset(const HHEMU hhEmu, const int host_request)
	{
	hhEmu->mode_KAM = hhEmu->mode_IRM = hhEmu->mode_VEM =
	hhEmu->mode_HEM = hhEmu->mode_LNM = hhEmu->mode_DECCKM =
	hhEmu->mode_DECOM = hhEmu->mode_DECCOLM = hhEmu->mode_DECPFF =
	hhEmu->mode_DECPEX = hhEmu->mode_DECSCNM = hhEmu->mode_25enab =
	hhEmu->mode_protect = hhEmu->mode_block =
	hhEmu->mode_local = RESET;

	hhEmu->mode_SRM = hhEmu->mode_DECTCEM = SET;

	hhEmu->mode_AWM = hhEmu->stUserSettings.fWrapLines;

	vt_charset_init(hhEmu);
	if (host_request)
		{
		ANSI_Pn_Clr(hhEmu);
		ANSI_SGR(hhEmu);
		ANSI_RIS(hhEmu);
		}
	hhEmu->emu_code = ETEXT('>');

	vt_alt_kpmode(hhEmu);

	if (hhEmu->stUserSettings.nEmuId == EMU_ANSI ||
		hhEmu->stUserSettings.nEmuId == EMU_AUTO)
		hhEmu->emu_kbdin = ansi_kbdin;
	else
		hhEmu->emu_kbdin = vt100_kbdin;

	hhEmu->mode_AWM = RESET;
	hhEmu->stUserSettings.fWrapLines = RESET;

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt100_report
 *
 * DESCRIPTION:
 *	 Sends the current terminal parameters specified by the DECREQTPARM.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void vt100_report(const HHEMU hhEmu)
	{
	int sol, i = 0, xspeed = 0;
	TCHAR str[20];
	TCHAR tempstr[4];
	ECHAR ech[20];
	int fOldValue;
	TCHAR *sp;
	long lBaud;
	int nDataBits, nParity;

	HCOM hCom;

	static int baudrates[] = {50, 75, 110, 135, 150, 200, 300, 600, 1200,
								 1800, 2000, 2400, 2600, 4800, 9600, 19200};

	sol = hhEmu->num_param[0];
	if (sol != 0 && sol != 1)
		return;

	wsprintf(str, TEXT("\x01B[%s;"),
				sol == 0 ? (LPTSTR)TEXT("2") : (LPTSTR)TEXT("3"));

	hCom = sessQueryComHdl(hhEmu->hSession);
	ComGetBaud(hCom, &lBaud);
	ComGetDataBits(hCom, &nDataBits);
	ComGetParity(hCom, &nParity);

	// Parity
	//
	if (nParity == 0)		// None
		StrCharCat(str, TEXT("1;"));
	else if (nParity == 1)	// Odd
		StrCharCat(str, TEXT("4;"));
	else 					// Even
		StrCharCat(str, TEXT("5;"));

	// Data bits
	//
	nDataBits == 8 ? StrCharCat(str, TEXT("1;")) : StrCharCat(str, TEXT("2;"));

	while (xspeed < 120)
		{
		if ((long)baudrates[i] >= lBaud)
			break;
		i++;
		xspeed += 8;
		}

	// Recieving speed
	//
	wsprintf(tempstr, "%d", xspeed);
	StrCharCat(str, tempstr);

	// Sending speed
	//
	StrCharCat(str, TEXT(";"));
	StrCharCat(str, tempstr);

	// Bit rate multiplier ; Flags
	//
	StrCharCat(str, TEXT(";1;0x"));

	sp = str;

	CnvrtMBCStoECHAR(ech, sizeof(ech), sp, StrCharGetByteCount(sp));

	/* to not get recursive vt100_report's if half duplex */

	fOldValue = CLoopGetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession));

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), FALSE);

	emuSendString(hhEmu, ech, (int)StrCharGetEcharByteCount(ech));

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), fOldValue);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt100_kbdin
 *
 * DESCRIPTION:
 *	 Processes local keyboard keys for the VT100 emulator.
 *	 Note: mode_DECKPAM is TRUE or SET when in DEC KeyPad Aplication Mode.
 *	 Removed key processing 1/3/92.  Will replace with something resonable
 *	 later - mrw.
 *
 * ARGUMENTS:
 *	 key -- key to process
 *
 * RETURNS:
 *	 nothing
 */
int vt100_kbdin(const HHEMU hhEmu, int key, const int fTest)
	{
	int index = 0;
	/* -------------- Check Backspace & Delete keys ------------- */

	if (hhEmu->stUserSettings.fReverseDelBk && ((key == VK_BACKSPACE) ||
			(key == DELETE_KEY) || (key == DELETE_KEY_EXT)))
		{
		key = (key == VK_BACKSPACE) ? DELETE_KEY : VK_BACKSPACE;
		}

	/* -------------- Mapped PF1-PF4 keys ------------- */

    #if 0 // mrw:11/3/95 - removed because we can't control num-lock
          // in Win95
	else if (hhEmu->stUserSettings.fMapPFkeys &&
			(index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl4)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl4);
		}
    #endif

	/* -------------- Cursor Key Mode ------------- */

	else if (hhEmu->mode_DECCKM == SET &&
			(index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl3)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl3);
		}

	/* -------------- Keypad Application Mode ------------- */

	else if (hhEmu->mode_DECKPAM &&
			(index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl2)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl2);
		}

	/* -------------- Normal keys ------------- */

	else if ((index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl);
		}

	else
		{
		index = std_kbdin(hhEmu, key, fTest);
		}

	return index;
	}

#if FALSE	// Never used in HyperTerminal.
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * fakevt_kbdin
 *
 * DESCRIPTION:
 *	 Processes local keyboard keys for the WANG, IBM3278 & RENX3278 emulators.
 *
 * ARGUMENTS:
 *	 key -- key to process
 *
 * RETURNS:
 *	 nothing
 */
int fakevt_kbdin(const HHEMU hhEmu, int key, const int fTest)
	{
	int index;

	/* -------------- Check Backspace & Delete keys ------------- */

	if (hhEmu->stUserSettings.fReverseDelBk && ((key == VK_BACKSPACE) ||
			(key == DELETE_KEY) || key == DELETE_KEY_EXT))
		{
		key = (key == VK_BACKSPACE) ? DELETE_KEY : VK_BACKSPACE;
		}

	if ((index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl);
		}

	else
		{
		index = std_kbdin(hhEmu, key, fTest);
		}

	return index;
	}
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt100PrintCommands
 *
 * DESCRIPTION:
 *	 Processes VT100 printing commands.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void vt100PrintCommands(const HHEMU hhEmu)
	{
	int line;
	int from;
	int to;
	ECHAR sel;
	ECHAR aechBuf[10];

	sel = (ECHAR)hhEmu->selector[0];

	switch (sel)
		{
		// Auto print on.
		//
		case ETEXT(0xF5):
			hhEmu->print_echo = TRUE;
			printSetStatus(hhEmu->hPrintEcho, TRUE);
			break;

		// Auto print off.
		//
		case ETEXT(0xF4):
			hhEmu->print_echo = FALSE;
			printSetStatus(hhEmu->hPrintEcho, FALSE);
    		printEchoClose(hhEmu->hPrintEcho);

			break;

		// Print screen.
		//
		case ETEXT(0x00):
			if (hhEmu->mode_DECPEX == RESET)
				from = hhEmu->top_margin, to = hhEmu->bottom_margin;
			else
				from = 0, to = EMU_DEFAULT_MAXROW;

			for (line = from; line <= to; ++line)
				printEchoLine(hhEmu->hPrintHost,
								hhEmu->emu_apText[row_index(hhEmu, line)],
								emuRowLen(hhEmu, row_index(hhEmu, line)));

			if (hhEmu->mode_DECPFF == SET)	 /* print form feed */
				{
				CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("0x0C"),
                                 StrCharGetByteCount(TEXT("0x0C")));
				printEchoLine(hhEmu->hPrintHost, aechBuf, sizeof(ECHAR));
				}

			break;

		// Print Cursor line.
		//
		case ETEXT(0xF1):
			printEchoLine(hhEmu->hPrintEcho,
							hhEmu->emu_apText[row_index(hhEmu,
							hhEmu->emu_currow)],
							emuRowLen(hhEmu,
										row_index(hhEmu, hhEmu->emu_currow)));
			break;

		// Enter printer controller mode.  State is hard coded for now...
		// Bad news.
		//
		case ETEXT(0x05):
			hhEmu->state = 6;
			printSetStatus(hhEmu->hPrintHost, TRUE);
			break;

		// Exit printer controller mode.  This is seen when not in
		// controller mode.
		//
		case ETEXT(0x04):
			break;

		default:
			break;
		}
	}

void vt100_prnc(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;
	ECHAR aechBuf[10];
	size_t size;

	*pstPRI->pntr++ = hhEmu->emu_code;
	*pstPRI->pntr = 0;
	++pstPRI->len_s;

	CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("\033[4i"),
                     StrCharGetByteCount(TEXT("\033[4i")));

	size = (size_t)StrCharGetByteCount(TEXT("\033[4i"));
	if ((pstPRI->len_s >= 4) && (memcmp(pstPRI->pntr - 4, aechBuf, size) == 0))
		{
		/* received termination string, wrap it up */
#if defined(INCL_PRINT_PASSTHROUGH)
		if( !hhEmu->stUserSettings.fPrintRaw)
			{
			printEchoRaw(hhEmu->hPrintHost, pstPRI->storage, pstPRI->len_s - ((*(pstPRI->pntr - 3) == (TCHAR)TEXT('\233')) ? 3 : 4));
			}
		else
#endif
			{
    		emuPrintChars(hhEmu, pstPRI->storage, pstPRI->len_s - ((*(pstPRI->pntr - 3) == (TCHAR)TEXT('\233')) ? 3 : 4));
	    	printEchoChar(hhEmu->hPrintHost, ETEXT('\n'));
			}
		
		pstPRI->pntr = pstPRI->storage;
		pstPRI->len_s = 0;
		hhEmu->state = 0;  /* drop out of this routine */

		// Finish-up print job
		DbgOutStr("print-control off\r\n", 0, 0, 0, 0, 0);
		printEchoClose(hhEmu->hPrintHost);
		return;
		}

	/* haven't received termination sequence yet, is storage filled? */
	if (pstPRI->len_s >= (int)(sizeof(pstPRI->storage) - 1))
		{
		/* copy most of string to print buffer */
#if defined(INCL_PRINT_PASSTHROUGH)
		if( !hhEmu->stUserSettings.fPrintRaw )
			{
			printEchoRaw(hhEmu->hPrintHost, pstPRI->storage, pstPRI->len_s - 4);
			}
		else
#endif
			{
			emuPrintChars(hhEmu, pstPRI->storage, pstPRI->len_s - 4);\
			}

		/* move end of string to beginning of storage */
		memmove(pstPRI->storage, &pstPRI->storage[pstPRI->len_s - 4], 4 * sizeof(ECHAR));
		pstPRI->pntr = pstPRI->storage + 4;
		pstPRI->len_s = 4;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuSetDoubleAttr(const HHEMU hhEmu)
	{

	switch(hhEmu->emu_code)
		{
		// Double width, double height, top half.
		//
		case '3':
			emuSetDoubleAttrRow(hhEmu, DBL_WIDE_HI);
			break;

		// Double width double height, bottom half.
		//
		case '4':
			emuSetDoubleAttrRow(hhEmu, DBL_WIDE_LO);
			break;

		// Single width single height.
		//
		case '5':
			emuSetSingleAttrRow(hhEmu);
			break;

		// Double width, single height.
		//
		case '6':
			emuSetDoubleAttrRow(hhEmu, DBL_WIDE_SINGLE_HEIGHT);
			break;

		default:
			break;
		}

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuSetSingleAttrRow(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int iOldRow,
		iOldCol,
		iImgRow;

	// Determine the image row.
	//
	iImgRow = row_index(hhEmu, hhEmu->emu_currow);

	// If the current line attribute is the same as the one we're
	// being asked to change to, get out-a-town.
	//
	if (pstPRI->aiLineAttr[iImgRow] == NO_LINE_ATTR)
		return;

	// Get the current cursor position.
	//
	std_getcurpos(hhEmu, &iOldRow, &iOldCol);

	// Convert the current row.
	//
	emuFromDblToSingle(hhEmu);

	// Update the line.
	//
	updateLine(sessQueryUpdateHdl(hhEmu->hSession),
				hhEmu->emu_currow,
				hhEmu->emu_currow);

	// Put the cursor back to where it was, or at the new rightmost
	// margin, whichever is less.
	//
	iOldCol = iOldCol / 2;
	iOldCol = min(iOldCol, hhEmu->emu_maxcol);
	std_setcurpos(hhEmu, iOldRow, iOldCol);

	// Finally, update this rows line attribute value.
	//
	pstPRI->aiLineAttr[iImgRow] = NO_LINE_ATTR;

	return;

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuSetDoubleAttrRow(const HHEMU hhEmu, const int iLineAttr)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int iChar,
		iImgRow,
		iOldRow,
		iOldCol,
		iUpperAttr,
		iLowerAttr;

	// Determine the image row.
	//
	iImgRow = row_index(hhEmu, hhEmu->emu_currow);

	// If the current line attribute is the same as the one we're
	// being asked to change to, get out-a-town.
	//
	if (pstPRI->aiLineAttr[iImgRow] == iLineAttr)
		return;

	// Get the current cursor position.
	//
	std_getcurpos(hhEmu, &iOldRow, &iOldCol);

	// If the current line attribute is anything but NO_LINE_ATTR, call
	// a routine that will first put the row back into that state.	That
	// is, this routine converts FROM a standard line INTO a double wide
	// line.
	//
	if (pstPRI->aiLineAttr[iImgRow] != NO_LINE_ATTR)
		{
		emuFromDblToSingle(hhEmu);
		iOldCol = iOldCol / 2;
		}

	// Start a shell game!
	//
	iChar = (hhEmu->emu_maxcol+1) / 2;

	// Remember that both of the following values will be zero in the
	// case of processing a DBL_WIDE_SINGLE_HEIGHT	request.
	//
	iUpperAttr = (iLineAttr == DBL_WIDE_HI) ? 1 : 0;
	iLowerAttr = (iLineAttr == DBL_WIDE_LO) ? 1 : 0;

	while (iChar >= 0)
		{
		hhEmu->emu_apText[iImgRow][(iChar * 2) + 1] = hhEmu->emu_apText[iImgRow][iChar];
		hhEmu->emu_apAttr[iImgRow][(iChar * 2) + 1].dblwirt = 1;
		hhEmu->emu_apAttr[iImgRow][(iChar * 2) + 1].dblwilf = 0;
		hhEmu->emu_apAttr[iImgRow][(iChar * 2) + 1].dblhihi = (unsigned)iUpperAttr;
		hhEmu->emu_apAttr[iImgRow][(iChar * 2) + 1].dblhilo = (unsigned)iLowerAttr;

		hhEmu->emu_apText[iImgRow][(iChar * 2)]  = hhEmu->emu_apText[iImgRow][iChar];
		hhEmu->emu_apAttr[iImgRow][(iChar * 2)].dblwirt = 0;
		hhEmu->emu_apAttr[iImgRow][(iChar * 2)].dblwilf = 1;
		hhEmu->emu_apAttr[iImgRow][(iChar * 2)].dblhihi = (unsigned)iUpperAttr;
		hhEmu->emu_apAttr[iImgRow][(iChar * 2)].dblhilo = (unsigned)iLowerAttr;

		iChar--;
		}

	// Null terminate the new text image.
	//
	hhEmu->emu_apText[iImgRow][hhEmu->emu_maxcol + 1] = ETEXT('\0');

	// Update the line.
	//
	updateLine(sessQueryUpdateHdl(hhEmu->hSession),
				hhEmu->emu_currow,
				hhEmu->emu_currow);

	// Put the cursor back to where it was, or at the new rightmost
	// margin, whichever is less.
	//
	iOldCol = iOldCol * 2;
	iOldCol = min(iOldCol, hhEmu->emu_maxcol);
	std_setcurpos(hhEmu, iOldRow, iOldCol);

	// Finally, update this rows line attribute value.
	//
	pstPRI->aiLineAttr[iImgRow] = iLineAttr;

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuFromDblToSingle
 *
 * DESCRIPTION:
 *	Note that this is a utility function and does not update the emulator
 *	image.	The calling function should do this.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuFromDblToSingle(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	register int i;

	int iSource,
		iDest,
		iLastCol,
		iImgRow;

	// Determine the image row.
	//
	iImgRow = row_index(hhEmu, hhEmu->emu_currow);

	// If the current line attribute is the same as the one we're
	// being asked to change to, get out-a-town.
	//
	if (pstPRI->aiLineAttr[iImgRow] == NO_LINE_ATTR)
		return;

	// A new shell game.
	//
	iSource = 0;
	iDest  = 0;

	iLastCol = (hhEmu->emu_maxcol+1) / 2;

	// TODO:  JCM - in two location below, the text buffer is set to
	// spaces, instead of nulls.  Figure out why this is the case.	We
	// should be able to set these to nulls.

	while (iSource <= hhEmu->emu_maxcol)
		{
		if (hhEmu->emu_apText[iImgRow][iSource] == ETEXT('\0'))  // TODO 1:
			hhEmu->emu_apText[iImgRow][iDest] = ETEXT(' ');
		else
			hhEmu->emu_apText[iImgRow][iDest] =
				hhEmu->emu_apText[iImgRow][iSource];

		hhEmu->emu_apAttr[iImgRow][iDest].dblwirt = 0;
		hhEmu->emu_apAttr[iImgRow][iDest].dblwilf = 0;
		hhEmu->emu_apAttr[iImgRow][iDest].dblhihi = 0;
		hhEmu->emu_apAttr[iImgRow][iDest].dblhilo = 0;

		iSource += 2;
		iDest += 1;
		}

	for (i = iLastCol; i < MAX_EMUCOLS ; ++i)
		{
		hhEmu->emu_apText[iImgRow][i] = ETEXT(' ');		  // TODO 2:
		hhEmu->emu_apAttr[iImgRow][i] = hhEmu->emu_clearattr;
		/*
		hhEmu->emu_apAttr[iImgRow][i].dblwirt = 0;
		hhEmu->emu_apAttr[iImgRow][i].dblwilf = 0;
		hhEmu->emu_apAttr[iImgRow][i].dblhihi = 0;
		hhEmu->emu_apAttr[iImgRow][i].dblhilo = 0;
		*/
		}

	pstPRI->aiLineAttr[iImgRow] = NO_LINE_ATTR;

	return;

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
void emuDecTab(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int col;

	col = hhEmu->emu_curcol;

	while (col <= hhEmu->emu_maxcol)
        {
		if (hhEmu->tab_stop[++col])
            {
			break;
            }
        }

	if (pstPRI->aiLineAttr[hhEmu->emu_imgrow] != NO_LINE_ATTR)
		col = (col * 2) - 1;

	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, col);

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecCUF
 *
 * DESCRIPTION:
 *	 Moves the cursor forward the specified number of characters, but stops
 *	 at the last character in the current line.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emuDecCUF(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int nchars, col;

	nchars = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nchars < 1)
		nchars = 1;

	if (pstPRI->aiLineAttr[hhEmu->emu_imgrow])
		nchars = (nchars * 2);

	col = hhEmu->emu_curcol;
	col += nchars;

	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, col);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecCUP
 *
 * DESCRIPTION:
 *	 Positions the cursor at the specified row and column. The row & column
 *	 numbering start at 1. If origin mode is on, the positioning is relative
 *	 to the home of the scrolling region.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emuDecCUP(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int row, col;

	row = hhEmu->num_param[0];
	col = hhEmu->num_param_cnt > 0 ? hhEmu->num_param[1] : 0;

	if (pstPRI->aiLineAttr[row_index(hhEmu, row)] != NO_LINE_ATTR)
		col = (col * 2) - 1;

	if (row <= 1)
		row = 1;

	if (col <= 1)
		col = 1;

	if (hhEmu->mode_DECOM) /* VT100 Origin mode - position rel to margin */
		{
		row += hhEmu->top_margin;
		if (row > hhEmu->bottom_margin + 1)
			row = hhEmu->bottom_margin + 1;
		}
	else				/* Position is one-based from upper left */
		{
		if (row > hhEmu->emu_maxrow + 1)
			row = hhEmu->emu_maxrow + 1;
		}

	if (col > hhEmu->emu_maxcol + 1)
		col = hhEmu->emu_maxcol + 1;

	(*hhEmu->emu_setcurpos)(hhEmu, row - 1, col - 1); /* ANSI is one-based, HA zero-based */
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecCUB
 *
 * DESCRIPTION:	Moves the cursor backwards (to the left) the specified number
 *				of characters, but stops at the 1st character in the current
 *				line. The vt emus need a special function to handle the
 *				virtual column beyond the edge of the screen.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void emuDecCUB(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int nchars;

	nchars = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nchars < 1)
		nchars = 1;

	if (pstPRI->aiLineAttr[hhEmu->emu_imgrow])
		nchars = (nchars * 2);

	(*hhEmu->emu_setcurpos)(hhEmu,
							hhEmu->emu_currow,
							hhEmu->emu_curcol - nchars);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecED
 *
 * DESCRIPTION:
 *	 Erases some or all of the virtual screen image and corresponding
 *	 real screen.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emuDecED(const HHEMU hhEmu)
	{
	int selector = hhEmu->selector[0];

	switch (selector)
		{
	case 0: 	/* cursor to end of screen */
	case 0x0F:
	case 0xF0:
		(*hhEmu->emu_clearscreen)(hhEmu, 0);
		break;

	case 1: 	/* start of screen to cursor */
	case 0xF1:
		(*hhEmu->emu_clearscreen)(hhEmu, 1);
		break;

	case 2: 	/* Entire screen */
	case 0xF2:
		(*hhEmu->emu_clearscreen)(hhEmu, 2);
		break;
	default:
		commanderror(hhEmu);
		break;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecUnload
 *
 * DESCRIPTION:
 *	 Unloads current emulator by freeing used memory.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emuVT100Unload(const HHEMU hhEmu)
	{
	PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	assert(hhEmu);

	if (pstPRI)
		{
		if (pstPRI->aiLineAttr)
			{
			free(pstPRI->aiLineAttr);
			pstPRI->aiLineAttr = 0;
			}

		free(hhEmu->pvPrivate);
		hhEmu->pvPrivate = 0;
		}

    //
    // Make sure to free the key tables that were created when the emulator
    // was loaded, otherwise there is a memory leak. REV: 05/09/2001
    //
	emuKeyTableFree(&hhEmu->stEmuKeyTbl);
	emuKeyTableFree(&hhEmu->stEmuKeyTbl2);
	emuKeyTableFree(&hhEmu->stEmuKeyTbl3);
	emuKeyTableFree(&hhEmu->stEmuKeyTbl4);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecIND
 *
 * DESCRIPTION:
 *	 Moves cursor down 1 line and scrolls 1 line if necessary. IND stands
 *	 for index.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emuDecIND(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int fSourceIsDbl, fDestIsDbl;
	int iCol;

	// If we're at the bottom line, scroll.
	//
	if (hhEmu->emu_currow == hhEmu->bottom_margin)
		{
		(*hhEmu->emu_scroll)(hhEmu, 1, TRUE);
		return;
		}

	fSourceIsDbl = (pstPRI->aiLineAttr[row_index(hhEmu, hhEmu->emu_currow)] == NO_LINE_ATTR)
					? FALSE : TRUE;
	fDestIsDbl = (pstPRI->aiLineAttr[row_index(hhEmu, hhEmu->emu_currow + 1)] == NO_LINE_ATTR)
					? FALSE : TRUE;

	iCol = hhEmu->emu_curcol;

	// If both source and dest are the same, regardless of size, go
	// ahead and make the move.  It only matters if they're different.
	//
	if (fSourceIsDbl == fDestIsDbl) 	// Both the same
		iCol = iCol;
	else if (fSourceIsDbl)				// Source is double, dest is single.
		iCol = iCol / 2;
	else								// Source is singel, dest is double.
		iCol = iCol * 2;

	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow + 1, iCol);

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecRI
 *
 * DESCRIPTION:
 *	 Moves cursor up 1 line and scrolls 1 line if necessary.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emuDecRI(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int fSourceIsDbl, fDestIsDbl;
	int iCol;

	// If we're at the bottom line, scroll.
	//
	if (hhEmu->emu_currow == hhEmu->top_margin)
		{
		(*hhEmu->emu_scroll)(hhEmu, 1, FALSE);
		return;
		}

	fSourceIsDbl = (pstPRI->aiLineAttr[row_index(hhEmu, hhEmu->emu_currow)] == NO_LINE_ATTR)
					? FALSE : TRUE;
	fDestIsDbl = (pstPRI->aiLineAttr[row_index(hhEmu, hhEmu->emu_currow - 1)] == NO_LINE_ATTR)
					? FALSE : TRUE;

	iCol = hhEmu->emu_curcol;

	// If both source and dest are the same, regardless of size, go
	// ahead and make the move.  It only matters if they're different.
	//
	if (fSourceIsDbl == fDestIsDbl) 	// Both the same
		iCol = iCol;
	else if (fSourceIsDbl)				// Source is double, dest is single.
		iCol = iCol / 2;
	else								// Source is singel, dest is double.
		iCol = iCol * 2;

	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow - 1, iCol);

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecCUU
 *
 * DESCRIPTION: Moves the cursor up the specified number of lines, but stops
 *				at the top of the scrolling region. The column is constant.
 *				If above the scrolling region, it stops at the top of the
 *				screen.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emuDecCUU(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int nlines,
		row,
		fSourceIsDbl,
		fDestIsDbl,
		iCol;

	nlines = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nlines < 1)
		nlines = 1;

	row = hhEmu->emu_currow;
	row -= nlines;

	fSourceIsDbl = (pstPRI->aiLineAttr[row_index(hhEmu, hhEmu->emu_currow)] == NO_LINE_ATTR)
					? FALSE : TRUE;
	fDestIsDbl = (pstPRI->aiLineAttr[row_index(hhEmu, hhEmu->emu_currow - nlines)] == NO_LINE_ATTR)
					? FALSE : TRUE;

	iCol = hhEmu->emu_curcol;

	// The following code adjusts the column value for double wide
	// characters.
	//
	if (fSourceIsDbl == fDestIsDbl) 	// Both the same
		iCol = iCol;
	else if (fSourceIsDbl)				// Source is double, dest is single.
		iCol = iCol / 2;
	else								// Source is singel, dest is double.
		iCol = iCol * 2;

	if (row < hhEmu->top_margin && (hhEmu->emu_currow >= hhEmu->top_margin || hhEmu->emu_currow < 0))
		row = hhEmu->top_margin;

	(*hhEmu->emu_setcurpos)(hhEmu, row, iCol);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecCUD
 *
 * DESCRIPTION: Moves the cursor down the specified number of lines, but stops
 *				at the bottom of the scrolling region. The column is constant.
 *				If below the scrolling region, it stops at the bottom of the
 *				screen.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emuDecCUD(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int nlines,
		row,
		fSourceIsDbl,
		fDestIsDbl,
		iCol;

	nlines = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nlines < 1)
		nlines = 1;

	row = hhEmu->emu_currow;
	row += nlines;

	fSourceIsDbl = (pstPRI->aiLineAttr[row_index(hhEmu, hhEmu->emu_currow)] == NO_LINE_ATTR)
					? FALSE : TRUE;
	fDestIsDbl = (pstPRI->aiLineAttr[row_index(hhEmu, hhEmu->emu_currow + nlines)] == NO_LINE_ATTR)
					? FALSE : TRUE;

	iCol = hhEmu->emu_curcol;

	// The following code adjusts the column value for double wide
	// characters.
	//
	if (fSourceIsDbl == fDestIsDbl) 	// Both the same
		iCol = iCol;
	else if (fSourceIsDbl)				// Source is double, dest is single.
		iCol = iCol / 2;
	else								// Source is singel, dest is double.
		iCol = iCol * 2;

	if (row > hhEmu->bottom_margin &&
				(hhEmu->emu_currow <= hhEmu->bottom_margin || hhEmu->emu_currow > hhEmu->emu_maxrow))
		row = hhEmu->bottom_margin;

	(*hhEmu->emu_setcurpos)(hhEmu, row, iCol);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecSetCurPos
 *
 * DESCRIPTION:
 *	 Moves the cursor to the specified position on the virtual screen.
 *	 If the cursor is beyond the end of existing text, the virtual screen
 *	 line is filled out with spaces. If the cursor is beyond the edges of
 *	 the video display, the video cursor is placed as close as possible
 *	 to the desired position as the cursor display is changed.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *	 nothing
 */
void emuDecSetCurPos(const HHEMU hhEmu, const int iRow, const int iCol)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int iTempCol;
	int i;

	// If we  move the cursor, we need to clear the pstPRI->fDecHoldFlag;
	//
	pstPRI->fDecColHold = FALSE;

	hhEmu->emu_currow = max(min(iRow, hhEmu->emu_maxrow), 0);
	hhEmu->emu_curcol = max(min(iCol, hhEmu->emu_maxcol), 0);

	iTempCol = hhEmu->emu_curcol;

	// If the row is a double wide character row, don't ever let the
	// cursor land on an odd column number.  If it's there now, back
	// it up one.
	//
	i = row_index(hhEmu, hhEmu->emu_currow);

	if (pstPRI->aiLineAttr[i])
		{
		if (iTempCol  % 2 == 1)
			{
			iTempCol -= 1;
			}
		}

	updateCursorPos(sessQueryUpdateHdl(hhEmu->hSession), iRow, iTempCol);
	hhEmu->emu_imgrow = row_index(hhEmu, hhEmu->emu_currow);
	return;
#if 0
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	int iTempCol;

	hhEmu->emu_currow = max(min(iRow, hhEmu->emu_maxrow), 0);
	hhEmu->emu_curcol = max(min(iCol, hhEmu->emu_maxcol), 0);

	iTempCol = hhEmu->emu_curcol;

	// Do range checking for DEC emulation.  This prevents the cursor
	// from being displayed in the 81st position, which is a valid
	// internal location, but is not a valid display column.
	//
	if (hhEmu->emu_curcol == hhEmu->emu_maxcol &&
		    (hhEmu->stUserSettings.nEmuId == EMU_VT100 ||
		     hhEmu->stUserSettings.nEmuId == EMU_VT100J))
        {
		iTempCol -= 1;
		}

	// If the row is a double wide character row, don't ever let the
	// cursor land on an odd column number.  If it's there now, back
	// it up one.
	//
	if (pstPRI->aiLineAttr[row_index(hhEmu, hhEmu->emu_currow)])
		{
		if (iTempCol  % 2 == 1)
			{
			iTempCol -= 1;
			}
		}

	updateCursorPos(sessQueryUpdateHdl(hhEmu->hSession), iRow, iTempCol);

	hhEmu->emu_imgrow = row_index(hhEmu, hhEmu->emu_currow);
	return;
#endif
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecClearScreen
 *
 * DESCRIPTION:
 *	 Erases some or all of the virtual screen image.
 *
 * ARGUMENTS:
 *	 select -- 0 to erase from cursor to end of screen
 *			-- 1 to erase from start of screen to cursor
 *			-- 2 to erase entire screen
 *
 * RETURNS:
 *	 nothing
 */
void emuDecClearScreen(const HHEMU hhEmu, const int nClearSelect)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;
	ECHAR aechBuf[10];
	register int r;
	int trow, tcol;
	PSTATTR pstAttr;
	BOOL fSave;

	trow = hhEmu->emu_currow;
	tcol = hhEmu->emu_curcol;

	switch (nClearSelect)
		{
	/* cursor to end of screen */
	case 0:
		fSave = (hhEmu->emu_currow == 0  &&
					hhEmu->emu_curcol == 0) ? TRUE : FALSE;

		for (r = hhEmu->emu_currow + (fSave ? 0 : 1) ; r < MAX_EMUROWS; ++r)
			{
			if (fSave)
				{
				backscrlAdd(sessQueryBackscrlHdl(hhEmu->hSession),
							hhEmu->emu_apText[row_index(hhEmu, r)],
							hhEmu->emu_maxcol+1);

				CaptureLine(sessQueryCaptureFileHdl(hhEmu->hSession),
									CF_CAP_SCREENS,
									hhEmu->emu_apText[row_index(hhEmu, r)],
									emuRowLen(hhEmu, row_index(hhEmu, r)));

				printEchoScreen(hhEmu->hPrintEcho,
									hhEmu->emu_apText[row_index(hhEmu, r)],
									emuRowLen(hhEmu, row_index(hhEmu, r)));

				CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("\r\n"), 
								 StrCharGetByteCount(TEXT("\r\n")));
				printEchoScreen(hhEmu->hPrintEcho,
									aechBuf,
									sizeof(ECHAR) * 2);
				}

			clear_imgrow(hhEmu, r);

			pstPRI->aiLineAttr[row_index(hhEmu, r)] = NO_LINE_ATTR;
			}

		// Clear the partial row now.
		//
		ECHAR_Fill(hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow)] +
						hhEmu->emu_curcol,
						EMU_BLANK_CHAR,
						(size_t)(MAX_EMUCOLS - hhEmu->emu_curcol + 1));

		if (hhEmu->emu_curcol <= hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
			hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = hhEmu->emu_curcol - 1;

		pstAttr = hhEmu->emu_apAttr[row_index(hhEmu, hhEmu->emu_currow)];

		for (r = hhEmu->emu_curcol ; r < MAX_EMUCOLS ; ++r)
			pstAttr[r] = hhEmu->emu_clearattr;

		// Tell the video image what to do.  Use the emuDispRgnScrollUp() call
		// instead of RgnClear so edges of terminal get painted if
		// clear attribute changes.

		updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
						0,
						hhEmu->emu_maxrow,
						hhEmu->emu_maxrow + 1,
						hhEmu->emu_imgtop,
						TRUE);

		(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, hhEmu->emu_curcol);

		// Added a global to save the clear attribute at the time of
		// notification.  This is necessary since the message is posted
		// and a race condition can develop.

		hhEmu->emu_clearattr_sav = hhEmu->emu_clearattr;

		NotifyClient(hhEmu->hSession, EVENT_EMU_CLRATTR, 0);
		break;


	/* start of screen to cursor */

	case 1:
		for (r = 0; r < hhEmu->emu_currow; ++r)
			{
			clear_imgrow(hhEmu, r);

			pstPRI->aiLineAttr[row_index(hhEmu, r)] = NO_LINE_ATTR;
			}

		ECHAR_Fill(hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow)],
					EMU_BLANK_CHAR,
			  		(size_t)(hhEmu->emu_curcol + 1));

		if (hhEmu->emu_curcol >= hhEmu->emu_aiEnd[hhEmu->emu_imgrow])
			hhEmu->emu_aiEnd[hhEmu->emu_imgrow] = EMU_BLANK_LINE;

		pstAttr = hhEmu->emu_apAttr[row_index(hhEmu, hhEmu->emu_currow)];

		for (r = 0 ; r <= hhEmu->emu_curcol ; ++r)
			pstAttr[r] = hhEmu->emu_clearattr;

		(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, hhEmu->emu_curcol);

		updateLine(sessQueryUpdateHdl(hhEmu->hSession), 0, hhEmu->emu_currow);
		break;

	/* Entire screen */
	case 2:
		for (r = 0; r < MAX_EMUROWS; ++r)
			{
			backscrlAdd(sessQueryBackscrlHdl(hhEmu->hSession),
							hhEmu->emu_apText[row_index(hhEmu, r)],
							hhEmu->emu_maxcol+1);

			CaptureLine(sessQueryCaptureFileHdl(hhEmu->hSession),
							CF_CAP_SCREENS,
							hhEmu->emu_apText[row_index(hhEmu, r)],
							emuRowLen(hhEmu, row_index(hhEmu, r)));

			printEchoScreen(hhEmu->hPrintEcho,
							hhEmu->emu_apText[row_index(hhEmu, r)],
							emuRowLen(hhEmu, row_index(hhEmu, r)));

			CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("\r\n"), 
							 StrCharGetByteCount(TEXT("\r\n")));
			printEchoScreen(hhEmu->hPrintEcho,
							aechBuf,
							sizeof(ECHAR) * 2);

			clear_imgrow(hhEmu, r);

			pstPRI->aiLineAttr[r] = NO_LINE_ATTR;
			}

		updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
						0,
						hhEmu->emu_maxrow,
						hhEmu->emu_maxrow + 1,
						hhEmu->emu_imgtop,
						TRUE);


		// Save the clear attribute at the time of
		// notification.  This is necessary since the message is posted
		// and a race condition can develop.

		hhEmu->emu_clearattr_sav = hhEmu->emu_clearattr;

		NotifyClient(hhEmu->hSession, EVENT_EMU_CLRATTR, 0);
		break;

	default:
		commanderror(hhEmu);
		}

	(*hhEmu->emu_setcurpos)(hhEmu, trow, tcol);
	}


/* end of vt100.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\vt100.hh ===
/*	File: D:\WACKER\emu\vt100.hh (Created: 13-July-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

// Private emulator data for DEC Terminals.
//
typedef struct stPrivateDEC
	{
	int sv_row,
		sv_col,
		sv_state,
		sv_AWM,
		sv_DECOM,
		sv_protectmode,
		fAttrsSaved,
		len_s,
		len_t,
		nState,
		gn,
		old_gl,
		gl,
		gr,
		sv_gr,
		sv_gl,
		fDecColHold,
		*aiLineAttr;

	ECHAR	storage[40],
			vt_charset[4],
			vt_sv_charset[4],
			terminate[4],
			*pntr;

	STATTR sv_attr;

	} DECPRIVATE;

typedef DECPRIVATE *PSTDECPRIVATE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\viewdini.c ===
/*	File: D:\WACKER\emu\viewdini.c (Created: 31-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 5/09/01 4:47p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\mc.h>
#include <tdll\assert.h>
#include <tdll\backscrl.h>
#include <tdll\htchar.h>
#include <tdll\term.h>
#include "emu.h"
#include "emu.hh"
#include "viewdata.hh"

#if defined(INCL_VIEWDATA)
#define MAX_ROWS 24

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataInit
 *
 * DESCRIPTION:	Performs the initialization of the Viewdata emulator that
 *              is common to DOS and OS2.
 *
 * ARGUMENTS:   ehdl -- handle the emulator session
 *
 * RETURNS:		nothing
 */
void EmuViewdataInit(const HHEMU hhEmu)
	{
	int i;
	LOGFONT lf;
	HWND hwndTerm;
	PSTVIEWDATAPRIVATE pstPRI;

	static struct trans_entry const astfViewdataTable[] =
	{
	{NEW_STATE, 0, 0, 0}, // State 0
	{0, ETEXT('\x20'),	ETEXT('\x7F'),	EmuViewdataCharDisplay},	// All
	{1, ETEXT('\x1B'),	ETEXT('\x1B'),	nothing},					// Esc
	{0, ETEXT('\x05'),	ETEXT('\x05'),	EmuViewdataAnswerback}, 	// Ctrl-E
	{0, ETEXT('\x08'),	ETEXT('\x08'),	EmuViewdataCursorLeft}, 	// Backspace
	{0, ETEXT('\x09'),	ETEXT('\x09'),	EmuViewdataCursorRight},	// Tab
	{0, ETEXT('\x0A'),	ETEXT('\x0A'),	EmuViewdataCursorDown}, 	// New Line
	{0, ETEXT('\x0B'),	ETEXT('\x0B'),	EmuViewdataCursorUp},		// VT
	{0, ETEXT('\x0C'),	ETEXT('\x0C'),	EmuViewdataClearScreen},	// Form Feed
	{0, ETEXT('\x0D'),	ETEXT('\x0D'),	carriagereturn},			// CR
	{0, ETEXT('\x11'),	ETEXT('\x11'),	EmuViewdataCursorSet},		// Ctrl-Q
	{0, ETEXT('\x14'),	ETEXT('\x14'),	EmuViewdataCursorSet},		// Ctrl-T
	{0, ETEXT('\x1E'),	ETEXT('\x1E'),	EmuViewdataCursorHome}, 	// Ctrl-^
	{0, ETEXT('\x80'),	ETEXT('\xFF'),	EmuChkChar},				// Upper Ascii

	{NEW_STATE, 0, 0, 0}, // State 1								// Esc
	{0, ETEXT('\x31'),	ETEXT('\x37'),	nothing},					// 1 - 7
	{0, ETEXT('\x41'),	ETEXT('\x49'),	EmuViewdataSetAttr},		// A - I
	{0, ETEXT('\x4C'),	ETEXT('\x4D'),	EmuViewdataSetAttr},		// L - M
	{0, ETEXT('\x51'),	ETEXT('\x5A'),	EmuViewdataSetAttr},		// Q - Z
	{0, ETEXT('\x5C'),	ETEXT('\x5D'),	EmuViewdataSetAttr},		// \ - ]
	{0, ETEXT('\x5E'),	ETEXT('\x5E'),	EmuViewdataMosaicHold}, 	// ^
	{0, ETEXT('\x5F'),	ETEXT('\x5F'),	EmuViewdataMosaicRelease},	// _
	};

	emuInstallStateTable(hhEmu, astfViewdataTable, DIM(astfViewdataTable));

	// Allocate and initialize private data for viewdata emulator.
	//
	if (hhEmu->pvPrivate != 0)
		{
		free(hhEmu->pvPrivate);
		hhEmu->pvPrivate = 0;
		}

	hhEmu->pvPrivate = malloc(sizeof(VIEWDATAPRIVATE));

	if (hhEmu->pvPrivate == 0)
		{
		assert(FALSE);
		return;
		}

	pstPRI = (PSTVIEWDATAPRIVATE)hhEmu->pvPrivate;
	pstPRI->aMapColors[0] = 4;
	pstPRI->aMapColors[1] = 2;
	pstPRI->aMapColors[2] = 6;
	pstPRI->aMapColors[3] = 1;
	pstPRI->aMapColors[4] = 5;
	pstPRI->aMapColors[5] = 3;
	pstPRI->aMapColors[6] = 15;

	/* --- Allocate attribute buffer for View Data junk --- */

	pstPRI->apstVD = malloc(MAX_EMUROWS * sizeof(PSTVIEWDATA));

	if (pstPRI->apstVD == 0)
		{
		assert(FALSE);
		return;
		}

	memset(pstPRI->apstVD, 0, MAX_EMUROWS * sizeof(PSTVIEWDATA));

	for (i = 0 ; i < MAX_EMUROWS ; ++i)
		{
		pstPRI->apstVD[i] = malloc(VIEWDATA_COLS_40MODE * sizeof(STVIEWDATA));

		if (pstPRI->apstVD[i] == 0)
			{
			assert(FALSE);
			return;
			}

		memset(pstPRI->apstVD[i], 0, sizeof(STVIEWDATA));
		}

	/* --- functions specific to prestel (viewdata) --- */

	hhEmu->emuResetTerminal = EmuViewdataReset;
	hhEmu->emu_deinstall = EmuViewdataDeinstall;

	hhEmu->emu_kbdin   = EmuViewdataKbd;
	hhEmu->emu_graphic = EmuViewdataCharDisplay;

	hhEmu->emu_highchar = ETEXT('\x7F');
	hhEmu->emu_maxcol = VIEWDATA_COLS_40MODE - 1;

	// Also, set font to Arial Alternative
	//
	memset(&lf, 0, sizeof(LOGFONT));
	hwndTerm = sessQueryHwndTerminal(hhEmu->hSession);
	termGetLogFont(hwndTerm, &lf);

	if (StrCharCmpi(lf.lfFaceName, "Arial Alternative") != 0)
		{
		StrCharCopy(lf.lfFaceName, "Arial Alternative");
		lf.lfCharSet = DEFAULT_CHARSET;
		lf.lfPitchAndFamily = FIXED_PITCH | FF_MODERN;
		termSetLogFont(hwndTerm, &lf);
		}

	EmuViewdataReset(hhEmu, FALSE);
	std_setcolors(hhEmu, VC_BRT_WHITE, VC_BLACK);

	// Turn backscroll off for Prestel
	//
	backscrlSetShowFlag(sessQueryBackscrlHdl(hhEmu->hSession), FALSE);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	EmuViewdataDeinstall
 *
 * DESCRIPTION:
 *	Frees up buffers allocated for view data junk.
 *
 * ARGUMENTS:
 *	fQuitting	- because other funcs have it.
 *
 * RETURNS:
 *	void
 *
 */
void EmuViewdataDeinstall(const HHEMU hhEmu)
	{
	int i;
	const PSTVIEWDATAPRIVATE pstPRI = (PSTVIEWDATAPRIVATE)hhEmu->pvPrivate;
	assert(hhEmu);

	if (pstPRI)
		{
		if (pstPRI->apstVD)
			{
            //
            // Fixed memory leak as this was only freeing 24 rows
            // not the MAX_EMUROWS that was allocated.  REV 05/09/2001.
            //
			for (i = 0 ; i < MAX_EMUROWS ; ++i)
				{
				if (pstPRI->apstVD[i])
					{
					free(pstPRI->apstVD[i]);
					pstPRI->apstVD[i] =NULL;
					}
				}

			free(pstPRI->apstVD);
			pstPRI->apstVD = NULL;
			}

		free(hhEmu->pvPrivate);
		hhEmu->pvPrivate = 0;
		}

    return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * EmuViewdataReset
 *
 * DESCRIPTION:	Sets the viewdata emulator to the proper conditions when
 *				starting up.
 *
 * ARGUMENTS:	ehdl -- emu handle
 *
 * RETURNS:		nothing
 */
/* ARGSUSED */
int EmuViewdataReset(const HHEMU hhEmu, int const fHost)
	{
	hhEmu->top_margin = 0;
	hhEmu->bottom_margin = MAX_ROWS-1;

	hhEmu->mode_KAM = hhEmu->mode_IRM = hhEmu->mode_VEM =
	hhEmu->mode_HEM = hhEmu->mode_DECCKM = hhEmu->mode_DECOM =
	hhEmu->mode_DECCOLM = hhEmu->mode_DECPFF = hhEmu->mode_DECPEX =
	hhEmu->mode_DECSCNM = hhEmu->mode_25enab =
	hhEmu->mode_protect = hhEmu->mode_block = hhEmu->mode_local = RESET;

	hhEmu->mode_SRM = hhEmu->mode_LNM = hhEmu->mode_DECTCEM = SET;

	hhEmu->mode_AWM = TRUE;

	emu_cleartabs(hhEmu, 3);
	return 0;
	}

#endif // INCL_VIEWDATA
/************************* end of viewdini.c **************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\vt220ini.c ===
/*	File: \wacker\emu\vt220ini.c (Created: 24-Jan-1998)
 *
 *	Copyright 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\assert.h>
#include <tdll\mc.h>
#include <tdll\backscrl.h>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"
#include "emudec.hh"
#include "keytbls.h"

#if defined(INCL_VT220)

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt220_init
 *
 * DESCRIPTION:
 *	 Initializes the VT220 emulator.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *	 nothing
 */
void vt220_init(const HHEMU hhEmu)
	{
	PSTDECPRIVATE pstPRI;
	int iRow;

	static struct trans_entry const vt220_tbl[] =
		{
		{NEW_STATE, 0, 0, 0}, // State 0
#if !defined(FAR_EAST)	// Left in from the VT100.
		{0, ETEXT('\x20'),	ETEXT('\x7E'),	emuDecGraphic}, 	// Space - ~
		{0, ETEXT('\xA0'),	ETEXT('\xFF'),	emuDecGraphic}, 	// 
#else
		{0, ETEXT('\x20'),	ETEXT('\x7E'),	emuDecGraphic}, 	// Space - ~
		{0, ETEXT('\xA0'),	0xFFFF,			emuDecGraphic}, 	// 
#endif

		{1, ETEXT('\x1B'),	ETEXT('\x1B'),	nothing},			// Esc
		{2, ETEXT('\x9B'),	ETEXT('\x9B'),	nothing},			// CSI

		// 7 bit control codes
//		{13,TEXT('\x01'),   ETEXT('\x01'),   nothing},			// Ctrl-A
		{0, ETEXT('\x05'),	ETEXT('\x05'),	vt100_answerback},	// Ctrl-E
		{0, ETEXT('\x07'),	ETEXT('\x07'),	emu_bell},			// Ctrl-G
		{0, ETEXT('\x08'),	ETEXT('\x08'),	vt_backspace},		// BackSpace
		{0, ETEXT('\x09'),	ETEXT('\x09'),	emuDecTab}, 		// Tab
		{0, ETEXT('\x0A'),	ETEXT('\x0C'),	emuLineFeed},		// NL - FF
		{0, ETEXT('\x0D'),	ETEXT('\x0D'),	carriagereturn},	// CR
		{0, ETEXT('\x0E'),	ETEXT('\x0F'),	vt_charshift},		// Ctrl-N, Ctrl-O
		{12,ETEXT('\x18'),	ETEXT('\x18'),	EmuStdChkZmdm}, 	// Ctrl-X

		// 8 bit control codes
		{0, ETEXT('\x84'),	ETEXT('\x84'),	emuDecIND}, 		// Index cursor
		{0, ETEXT('\x85'),	ETEXT('\x85'),	ANSI_NEL}, 			// Next line
		{0, ETEXT('\x88'),	ETEXT('\x88'),	ANSI_HTS}, 			// Set Horizontal Tab
		{0, ETEXT('\x8D'),	ETEXT('\x8D'),	emuDecRI}, 			// Reverse index
		{0, ETEXT('\x8E'),	ETEXT('\x8F'),	vt_charshift}, 		// SingleShift G2,G3
		{5, ETEXT('\x90'),	ETEXT('\x90'),	nothing}, 			// Device Control String (DCS)

		// Ignore these codes. They just show what functionality is still missing.
		{0, ETEXT('\x00'),	ETEXT('\x00'),	nothing},			// ignore nuls
		{0, ETEXT('\x1A'),	ETEXT('\x1A'),	nothing},			// ignore Substitute
		{0, ETEXT('\x7F'),	ETEXT('\x7F'),	nothing},			// ignore Delete
		{0, ETEXT('\x9C'),	ETEXT('\x9C'),	nothing},			// ignore String Terminator


		{NEW_STATE, 0, 0, 0},   // State 1						// Esc
		{2, ETEXT('\x5B'),  ETEXT('\x5B'),  ANSI_Pn_Clr},		// '['
		{7, ETEXT('\x20'),  ETEXT('\x20'),  nothing},			// Space
		{3, ETEXT('\x23'),  ETEXT('\x23'),  nothing},			// #
		{4, ETEXT('\x28'),  ETEXT('\x2B'),  vt_scs1},			// ( - +
		{0, ETEXT('\x37'),  ETEXT('\x38'),  vt100_savecursor},  // 8
		{1, ETEXT('\x3B'),  ETEXT('\x3B'),  ANSI_Pn_End},		// ;
		{0, ETEXT('\x3D'),  ETEXT('\x3E'),  vt_alt_kpmode},		// = - >
		{0, ETEXT('\x44'),  ETEXT('\x44'),  emuDecIND},			// D
		{0, ETEXT('\x45'),  ETEXT('\x45'),  ANSI_NEL},			// E
		{0, ETEXT('\x48'),  ETEXT('\x48'),  ANSI_HTS},			// H
		{0, ETEXT('\x4D'),  ETEXT('\x4D'),  emuDecRI},			// M
		{0, ETEXT('\x4E'),  ETEXT('\x4F'),  vt_charshift},		// N - O
		{5, ETEXT('\x50'),  ETEXT('\x50'),  nothing},			// P
		{0, ETEXT('\x5A'),  ETEXT('\x5A'),  vt220_DA},			// Z
		{0, ETEXT('\\'),	ETEXT('\\'),	nothing},			// Backslash
		{0, ETEXT('\x63'),  ETEXT('\x63'),  vt220_hostreset},   // c
		{0, ETEXT('\x6E'),  ETEXT('\x6F'),  vt_charshift},		// n - o
		{0, ETEXT('\x7D'),  ETEXT('\x7E'),  vt_charshift},		// } - ~

		{NEW_STATE, 0, 0, 0},   // State 2						// ESC [
		{8, ETEXT('\x21'),  ETEXT('\x21'),  nothing},			// !
		{2, ETEXT('\x3B'),  ETEXT('\x3B'),  ANSI_Pn_End},		// ;
		{9, ETEXT('\x3E'),  ETEXT('\x3E'),  nothing},			// >
		{2, ETEXT('\x30'),  ETEXT('\x3F'),  ANSI_Pn},			// 0 - ?
		{11,ETEXT('\x22'),  ETEXT('\x22'),  nothing},			// "
//		{16,ETEXT('\x24'),  ETEXT('\x24'),  nothing},			// $
		{2, ETEXT('\x27'),  ETEXT('\x27'),  nothing},			// Eat Esc [ m ; m ; ' z
		{0, ETEXT('\x40'),  ETEXT('\x40'),  ANSI_ICH},			// @
		{0, ETEXT('\x41'),  ETEXT('\x41'),  emuDecCUU},			// A
		{0, ETEXT('\x42'),  ETEXT('\x42'),  emuDecCUD},			// B
		{0, ETEXT('\x43'),  ETEXT('\x43'),  emuDecCUF},			// C
		{0, ETEXT('\x44'),  ETEXT('\x44'),  emuDecCUB},			// D
		{0, ETEXT('\x48'),  ETEXT('\x48'),  emuDecCUP},			// H
		{0, ETEXT('\x4A'),  ETEXT('\x4A'),  emuVT220ED},		// J
		{0, ETEXT('\x4B'),  ETEXT('\x4B'),  emuDecEL},			// K
		{0, ETEXT('\x4C'),  ETEXT('\x4C'),  vt_IL},				// L
		{0, ETEXT('\x4D'),  ETEXT('\x4D'),  vt_DL},				// M
		{0, ETEXT('\x50'),  ETEXT('\x50'),  vt_DCH},			// P
		{0, ETEXT('\x58'),  ETEXT('\x58'),  vt_DCH},			// X
		{0, ETEXT('\x63'),  ETEXT('\x63'),  vt220_DA},			// c
		{0, ETEXT('\x66'),  ETEXT('\x66'),  emuDecCUP},			// f
		{0, ETEXT('\x67'),  ETEXT('\x67'),  ANSI_TBC},			// g
		{0, ETEXT('\x68'),  ETEXT('\x68'),  ANSI_SM},			// h
		{0, ETEXT('\x69'),  ETEXT('\x69'),  vt100PrintCommands},// i
		{0, ETEXT('\x6C'),  ETEXT('\x6C'),  ANSI_RM},			// l
		{0, ETEXT('\x6D'),  ETEXT('\x6D'),  ANSI_SGR},			// m
		{0, ETEXT('\x6E'),  ETEXT('\x6E'),  ANSI_DSR},			// n
		{0, ETEXT('\x71'),  ETEXT('\x71'),  nothing},			// q
		{0, ETEXT('\x72'),  ETEXT('\x72'),  vt_scrollrgn},		// r
		{0, ETEXT('\x75'),  ETEXT('\x75'),  nothing},			// u
		{0, ETEXT('\x79'),  ETEXT('\x79'),  nothing},			// y
		{0, ETEXT('\x7A'),  ETEXT('\x7A'),  nothing},			// z

		{NEW_STATE, 0, 0, 0},   // State 3						// Esc #
		{0, ETEXT('\x33'),  ETEXT('\x36'),  emuSetDoubleAttr},  // 3 - 6
		{0, ETEXT('\x38'),  ETEXT('\x38'),  vt_screen_adjust},  // 8

		{NEW_STATE, 0, 0, 0},   // State 4						// Esc ( - +
		{0, ETEXT('\x01'),  ETEXT('\xFF'),  vt_scs2},			// All

		{NEW_STATE, 0, 0, 0},   // State 5						// Esc P
		{5, ETEXT('\x3B'),  ETEXT('\x3B'),  ANSI_Pn_End},		// ;
		{5, ETEXT('\x30'),  ETEXT('\x3F'),  ANSI_Pn},			// 0 - ?
		{10,ETEXT('\x7C'),  ETEXT('\x7C'),  emuDecClearUDK},	// |

		{NEW_STATE, 0, 0, 0},   // State 6
		{6, ETEXT('\x00'),  ETEXT('\xFF'),  vt100_prnc},		// All

		{NEW_STATE, 0, 0, 0},   // State 7						// Esc Sapce
		{0, ETEXT('\x46'),  ETEXT('\x47'),  nothing},			// F - G

		{NEW_STATE, 0, 0, 0},   // State 8						// Esc [ !
		{0, ETEXT('\x70'),  ETEXT('\x70'),  vt220_softreset},   // p

		{NEW_STATE, 0, 0, 0},   // State 9						// Esc [ >
		{0, ETEXT('\x63'),  ETEXT('\x63'),  vt220_2ndDA},		// c

		{NEW_STATE, 0, 0, 0},   // State 10						// Esc P n;n |
		{10,ETEXT('\x00'),  ETEXT('\xFF'),  emuDecDefineUDK},   // All

		{NEW_STATE, 0, 0, 0},   // State 11						// Esc [ "
		{0, ETEXT('\x70'),  ETEXT('\x70'),  vt220_level},		// p
		{0, ETEXT('\x71'),  ETEXT('\x71'),  vt220_protmode},	// q

		{NEW_STATE, 0, 0, 0},   // State 12						// Ctrl-X
		{12,ETEXT('\x00'),  ETEXT('\xFF'),  EmuStdChkZmdm},		// All

		// States 13-17 are not used in HT but included for reference. 
//		{NEW_STATE, 0, 0, 0},   // State 13						// Ctrl-A
//		{14,ETEXT('\x08'),  ETEXT('\x08'),  emuSerialNbr},		// Backspace
//		{15,ETEXT('\x48'),  ETEXT('\x48'),  EmuStdChkHprP},		// H

//		{NEW_STATE, 0, 0, 0},   // State 14						// Ctrl-A bs
//		{14,ETEXT('\x00'),  ETEXT('\xFF'),  emuSerialNbr},		// All

//		{NEW_STATE, 0, 0, 0},   // State 15						// Ctrl-A H
//		{15,ETEXT('\x00'),  ETEXT('\xFF'),  EmuStdChkHprP},		// All

		// A real VT220/320 does not support the status line sequences.
//		{NEW_STATE, 0, 0, 0},   // State 16								// Esc [ n $
//		{16,ETEXT('\x7E'),  ETEXT('\x7E'),  emuDecSelectStatusLine},	// ~
//		{17,ETEXT('\x7D'),  ETEXT('\x7D'),  emuDecSelectActiveDisplay}, // }

//		{NEW_STATE, 0, 0, 0},   // State 17
//		{17,ETEXT('\x00'),  ETEXT('\xFF'),  emuDecStatusLineToss},  // All

		};

	// The following key tables were copied from \shared\emulator\vt220ini.c  
	// because they support user-defined keys. The tables have been modified 
	// so keydef.h is not needed and to match HT's use of keys. rde 2 Feb 98

	// The following key tables are defined in the order that they
	// are searched.
	//

	// These are the (standard) F1 thru F4 keys on the top and left of the
	// keyboard.  Note that these keys may be mapped to the top row of the
	// numeric keypad.  In that case, these keys (at the standard locations),
	// are not mapped to emulator keys. NOTE: HTPE does not use this mapping.
	//
	// Please note that the sequences defined in this table are the
	// 8-bit versions of the responses.  The function emuDecSendKeyString
	// will convert this sequence to the 7-bit equivalent if necessary.
	//
	static  STEMUKEYDATA const VT220StdPfKeyTable[] =
		{
		EMUKEY(VK_F1,		1, 0, 0, 0, 0,  "\x8F\x50",			2), // P
		EMUKEY(VK_F2,		1, 0, 0, 0, 0,  "\x8F\x51",			2), // Q
		EMUKEY(VK_F3,		1, 0, 0, 0, 0,  "\x8F\x52",			2), // R
		EMUKEY(VK_F4,		1, 0, 0, 0, 0,  "\x8F\x53",			2), // S

		EMUKEY(VK_F1,		1, 0, 0, 0, 1,  "\x8F\x50",			2), // P
		EMUKEY(VK_F2,		1, 0, 0, 0, 1,  "\x8F\x51",			2), // Q
		EMUKEY(VK_F3,		1, 0, 0, 0, 1,  "\x8F\x52",			2), // R
		EMUKEY(VK_F4,		1, 0, 0, 0, 1,  "\x8F\x53",			2), // S
		};

	// When the user has selected the option to map the top 4 keys of the
	// numeric keypad to be the same as F1 thru F4, these key sequences are
	// used. NOTE: This is the mapping HTPE uses.
	//
	// Please note that the sequences defined in this table are the
	// 8-bit versions of the responses.  The function emuDecSendKeyString
	// will convert this sequence to the 7-bit equivalent if necessary.
	//
	static  STEMUKEYDATA const VT220MovedPfKeyTable[] =
		{
		EMUKEY(VK_NUMLOCK,	1, 0, 0, 0, 1,  "\x8F\x50",			2), // P
		EMUKEY(VK_DIVIDE,	1, 0, 0, 0, 1,  "\x8F\x51",			2), // Q
		EMUKEY(VK_MULTIPLY,	1, 0, 0, 0, 1,  "\x8F\x52",			2), // R
		EMUKEY(VK_SUBTRACT,	1, 0, 0, 0, 1,  "\x8F\x53",			2), // S
		};

	// VT220 Keypad Numeric Mode.
	//
	static STEMUKEYDATA const VT220KeypadNumericMode[] =
		{
		// Keypad keys with Numlock off.
		//
		EMUKEY(VK_INSERT,	1, 0, 0, 0, 0,  "\x30",			1), // 0
		EMUKEY(VK_END,		1, 0, 0, 0, 0,  "\x31",			1), // 1
		EMUKEY(VK_DOWN,		1, 0, 0, 0, 0,  "\x32",			1), // 2
		EMUKEY(VK_NEXT,		1, 0, 0, 0, 0,  "\x33",			1), // 3
		EMUKEY(VK_LEFT,		1, 0, 0, 0, 0,  "\x34",			1), // 4
		EMUKEY(VK_NUMPAD5,	1, 0, 0, 0, 0,  "\x35",			1), // 5
		EMUKEY(VK_RIGHT,	1, 0, 0, 0, 0,  "\x36",			1), // 6
		EMUKEY(VK_HOME,		1, 0, 0, 0, 0,  "\x37",			1), // 7
		EMUKEY(VK_UP,		1, 0, 0, 0, 0,  "\x38",			1), // 8
		EMUKEY(VK_PRIOR,	1, 0, 0, 0, 0,  "\x39",			1), // 9
		EMUKEY(VK_DELETE,	1, 0, 0, 0, 0,  "\x2E",			1), // .

		// Keypad keys with Numlock on.
		//
		EMUKEY(VK_NUMPAD0,		1, 0, 0, 0, 0,  "\x30",			1), // 0
		EMUKEY(VK_NUMPAD1,		1, 0, 0, 0, 0,  "\x31",			1), // 1
		EMUKEY(VK_NUMPAD2,		1, 0, 0, 0, 0,  "\x32",			1), // 2
		EMUKEY(VK_NUMPAD3,		1, 0, 0, 0, 0,  "\x33",			1), // 3
		EMUKEY(VK_NUMPAD4,		1, 0, 0, 0, 0,  "\x34",			1), // 4
		EMUKEY(VK_NUMPAD5,		1, 0, 0, 0, 0,  "\x35",			1), // 5
		EMUKEY(VK_NUMPAD6,		1, 0, 0, 0, 0,  "\x36",			1), // 6
		EMUKEY(VK_NUMPAD7,		1, 0, 0, 0, 0,  "\x37",			1), // 7
		EMUKEY(VK_NUMPAD8,		1, 0, 0, 0, 0,  "\x38",			1), // 8
		EMUKEY(VK_NUMPAD9,		1, 0, 0, 0, 0,  "\x39",			1), // 9
		EMUKEY(VK_DECIMAL,		1, 0, 0, 0, 0,  "\x2E",			1), // .

		// Other keypad keys (minus, plus, Enter).
		//
		EMUKEY(VK_SUBTRACT,		1, 0, 0, 0, 0,  "\x2D",			1), // -
		EMUKEY(VK_ADD,			1, 0, 0, 0, 0,  "\x2C",			1), // ,
		EMUKEY(VK_RETURN,		1, 0, 0, 0, 1,  "\x0D",			1), // CR
		};

	// VT220 Keypad Application Mode.
	//
	// Please note that the sequences defined in this table are the
	// 8-bit versions of the responses.  The function emuDecSendKeyString
	// will convert this sequence to the 7-bit equivalent if necessary.
	//
	static STEMUKEYDATA const VT220KeypadApplicationMode[] =
		{
		// Keypad keys with Numlock off.
		//
		EMUKEY(VK_NUMPAD0,		1, 0, 0, 0, 0,  "\x8F\x70",		2), // p
		EMUKEY(VK_NUMPAD1,		1, 0, 0, 0, 0,  "\x8F\x71",		2), // q
		EMUKEY(VK_NUMPAD2,		1, 0, 0, 0, 0,  "\x8F\x72",		2), // r
		EMUKEY(VK_NUMPAD3,		1, 0, 0, 0, 0,  "\x8F\x73",		2), // s
		EMUKEY(VK_NUMPAD4,		1, 0, 0, 0, 0,  "\x8F\x74",		2), // t
		EMUKEY(VK_NUMPAD5,		1, 0, 0, 0, 0,  "\x8F\x75",		2), // u
		EMUKEY(VK_NUMPAD6,		1, 0, 0, 0, 0,  "\x8F\x76",		2), // v
		EMUKEY(VK_NUMPAD7,		1, 0, 0, 0, 0,  "\x8F\x77",		2), // w
		EMUKEY(VK_NUMPAD8,		1, 0, 0, 0, 0,  "\x8F\x78",		2), // x
		EMUKEY(VK_NUMPAD9,		1, 0, 0, 0, 0,  "\x8F\x79",		2), // y
		EMUKEY(VK_DECIMAL,		1, 0, 0, 0, 0,  "\x8F\x6E",		2), // n

		// Keypad keys with Numlock on.
		//
		EMUKEY(VK_NUMPAD0,		1, 0, 0, 0, 0,  "\x8F\x70",		2), // p
		EMUKEY(VK_NUMPAD1,		1, 0, 0, 0, 0,  "\x8F\x71",		2), // q
		EMUKEY(VK_NUMPAD2,		1, 0, 0, 0, 0,  "\x8F\x72",		2), // r
		EMUKEY(VK_NUMPAD3,		1, 0, 0, 0, 0,  "\x8F\x73",		2), // s
		EMUKEY(VK_NUMPAD4,		1, 0, 0, 0, 0,  "\x8F\x74",		2), // t
		EMUKEY(VK_NUMPAD5,		1, 0, 0, 0, 0,  "\x8F\x75",		2), // u
		EMUKEY(VK_NUMPAD6,		1, 0, 0, 0, 0,  "\x8F\x76",		2), // v
		EMUKEY(VK_NUMPAD7,		1, 0, 0, 0, 0,  "\x8F\x77",		2), // w
		EMUKEY(VK_NUMPAD8,		1, 0, 0, 0, 0,  "\x8F\x78",		2), // x
		EMUKEY(VK_NUMPAD9,		1, 0, 0, 0, 0,  "\x8F\x79",		2), // y
		EMUKEY(VK_DECIMAL,		1, 0, 0, 0, 0,  "\x8F\x6E",		2), // n

		// Other keypad keys (minus, plus, Enter).
		//
		EMUKEY(VK_SUBTRACT,		1, 0, 0, 0, 0,  "\x8F\x6D",		2), // m
		EMUKEY(VK_ADD,			1, 0, 0, 0, 0,  "\x8F\x6C",		2), // l
		EMUKEY(VK_RETURN,		1, 0, 0, 0, 1,  "\x8F\x4D",		2), // M
		};

	// VT220 Cursor Key Mode.
	//
	// Please note that the sequences defined in this table are the
	// 8-bit versions of the responses.  The function emuDecSendKeyString
	// will convert this sequence to the 7-bit equivalent if necessary.
	//
	static STEMUKEYDATA const VT220CursorKeyMode[] =
		{
		// Arrow keys on the numeric keypad.  These sequences are used
		// when the emulator is using Cursor Key Mode (Application Keys).
		//
		EMUKEY(VK_UP,		1, 0, 0, 0, 0,  "\x8F\x41",			2), // A
		EMUKEY(VK_DOWN,		1, 0, 0, 0, 0,  "\x8F\x42",			2), // B
		EMUKEY(VK_RIGHT,	1, 0, 0, 0, 0,  "\x8F\x43",			2), // C
		EMUKEY(VK_LEFT,		1, 0, 0, 0, 0,  "\x8F\x44",			2), // D

		// Arrow keys on the edit pad.  These sequences are used
		// when the emulator is using Cursor Key Mode (Application Keys).
		//
		EMUKEY(VK_UP,		1, 0, 0, 0, 1,  "\x8F\x41",			2), // A
		EMUKEY(VK_DOWN,		1, 0, 0, 0, 1,  "\x8F\x42",			2), // B
		EMUKEY(VK_RIGHT,	1, 0, 0, 0, 1,  "\x8F\x43",			2), // C
		EMUKEY(VK_LEFT,		1, 0, 0, 0, 1,  "\x8F\x44",			2), // D
		};

	// VT220 Standard Key Table.
	//
	static STEMUKEYDATA const VT220StandardKeys[] =
		{
		// Some keys on the numeric keypad will respond in the same
		// way the corresponding keys on the edit pad respond.
		//
		EMUKEY(VK_HOME,		1, 0, 0, 0, 0,  "\x9B\x31\x7E",		3), // 1 ~
		EMUKEY(VK_INSERT,	1, 0, 0, 0, 0,  "\x9B\x32\x7E",		3), // 2 ~
		EMUKEY(VK_DELETE,	1, 0, 0, 0, 0,  "\x9B\x33\x7E",		3), // 3 ~
		EMUKEY(VK_END,		1, 0, 0, 0, 0,  "\x9B\x34\x7E",		3), // 4 ~
		EMUKEY(VK_PRIOR,	1, 0, 0, 0, 0,  "\x9B\x35\x7E",		3), // 5 ~
		EMUKEY(VK_NEXT,		1, 0, 0, 0, 0,  "\x9B\x36\x7E",		3), // 6 ~

		// These are the keys on the edit pad.
		//
		EMUKEY(VK_HOME,		1, 0, 0, 0, 1,  "\x9B\x31\x7E",		3), // 1 ~
		EMUKEY(VK_INSERT,	1, 0, 0, 0, 1,  "\x9B\x32\x7E",		3), // 2 ~
		EMUKEY(VK_DELETE,	1, 0, 0, 0, 1,  "\x9B\x33\x7E",		3), // 3 ~
		EMUKEY(VK_END,		1, 0, 0, 0, 1,  "\x9B\x34\x7E",		3), // 4 ~
		EMUKEY(VK_PRIOR,	1, 0, 0, 0, 1,  "\x9B\x35\x7E",		3), // 5 ~
		EMUKEY(VK_NEXT,		1, 0, 0, 0, 1,  "\x9B\x36\x7E",		3), // 6 ~

		// Arrow keys on the numeric keypad.
		//
		EMUKEY(VK_UP,		1, 0, 0, 0, 0,  "\x9B\x41",			2), // A
		EMUKEY(VK_DOWN,		1, 0, 0, 0, 0,  "\x9B\x42",			2), // B
		EMUKEY(VK_RIGHT,	1, 0, 0, 0, 0,  "\x9B\x43",			2), // C
		EMUKEY(VK_LEFT,		1, 0, 0, 0, 0,  "\x9B\x44",			2), // D

		// Arrow keys on the edit pad.
		//
		EMUKEY(VK_UP,		1, 0, 0, 0, 1,  "\x9B\x41",			2), // A
		EMUKEY(VK_DOWN,		1, 0, 0, 0, 1,  "\x9B\x42",			2), // B
		EMUKEY(VK_RIGHT,	1, 0, 0, 0, 1,  "\x9B\x43",			2), // C
		EMUKEY(VK_LEFT,		1, 0, 0, 0, 1,  "\x9B\x44",			2), // D

		// Function keys (F5)F6 thru F10.
		//
#if defined(INCL_ULTC_VERSION)
		EMUKEY(VK_F5,		1, 0, 0, 0, 0,  "\x9B\x31\x36\x7E", 4), // 1 6 ~
#endif
		EMUKEY(VK_F6,		1, 0, 0, 0, 0,  "\x9B\x31\x37\x7E", 4), // 1 7 ~
		EMUKEY(VK_F7,		1, 0, 0, 0, 0,  "\x9B\x31\x38\x7E", 4), // 1 8 ~
		EMUKEY(VK_F8,		1, 0, 0, 0, 0,  "\x9B\x31\x39\x7E", 4), // 1 9 ~
		EMUKEY(VK_F9,		1, 0, 0, 0, 0,  "\x9B\x32\x30\x7E", 4), // 2 0 ~
		EMUKEY(VK_F10,		1, 0, 0, 0, 0,  "\x9B\x32\x31\x7E", 4), // 2 1 ~

#if defined(INCL_ULTC_VERSION)
		EMUKEY(VK_F5,		1, 0, 0, 0, 1,  "\x9B\x31\x36\x7E", 4), // 1 6 ~
#endif
		EMUKEY(VK_F6,		1, 0, 0, 0, 1,  "\x9B\x31\x37\x7E", 4), // 1 7 ~
		EMUKEY(VK_F7,		1, 0, 0, 0, 1,  "\x9B\x31\x38\x7E", 4), // 1 8 ~
		EMUKEY(VK_F8,		1, 0, 0, 0, 1,  "\x9B\x31\x39\x7E", 4), // 1 9 ~
		EMUKEY(VK_F9,		1, 0, 0, 0, 1,  "\x9B\x32\x30\x7E", 4), // 2 0 ~
		EMUKEY(VK_F10,		1, 0, 0, 0, 1,  "\x9B\x32\x31\x7E", 4), // 2 1 ~

		// Function keys F11 thru F20 are invoked by the user pressing
		// Ctrl-F1 thru Ctrl-F10.
		//
		// Function keys Ctrl-F1 thru Ctrl-F10 (Top row).
		//
		EMUKEY(VK_F1,		1, 1, 0, 0, 0,  "\x9B\x32\x33\x7E", 4), // 2 3 ~
		EMUKEY(VK_F2,		1, 1, 0, 0, 0,  "\x9B\x32\x34\x7E", 4), // 2 4 ~
		EMUKEY(VK_F3,		1, 1, 0, 0, 0,  "\x9B\x32\x35\x7E", 4), // 2 5 ~
		EMUKEY(VK_F4,		1, 1, 0, 0, 0,  "\x9B\x32\x36\x7E", 4), // 2 6 ~
		EMUKEY(VK_F5,		1, 1, 0, 0, 0,  "\x9B\x32\x38\x7E", 4), // 2 8 ~
		EMUKEY(VK_F6,		1, 1, 0, 0, 0,  "\x9B\x32\x39\x7E", 4), // 2 9 ~
		EMUKEY(VK_F7,		1, 1, 0, 0, 0,  "\x9B\x33\x31\x7E", 4), // 3 1 ~
		EMUKEY(VK_F8,		1, 1, 0, 0, 0,  "\x9B\x33\x32\x7E", 4), // 3 2 ~
		EMUKEY(VK_F9,		1, 1, 0, 0, 0,  "\x9B\x33\x33\x7E", 4), // 3 3 ~
		EMUKEY(VK_F10,		1, 1, 0, 0, 0,  "\x9B\x33\x34\x7E", 4), // 3 4 ~

		EMUKEY(VK_F1,		1, 1, 0, 0, 1,  "\x9B\x32\x33\x7E", 4), // 2 3 ~
		EMUKEY(VK_F2,		1, 1, 0, 0, 1,  "\x9B\x32\x34\x7E", 4), // 2 4 ~
		EMUKEY(VK_F3,		1, 1, 0, 0, 1,  "\x9B\x32\x35\x7E", 4), // 2 5 ~
		EMUKEY(VK_F4,		1, 1, 0, 0, 1,  "\x9B\x32\x36\x7E", 4), // 2 6 ~
		EMUKEY(VK_F5,		1, 1, 0, 0, 1,  "\x9B\x32\x38\x7E", 4), // 2 8 ~
		EMUKEY(VK_F6,		1, 1, 0, 0, 1,  "\x9B\x32\x39\x7E", 4), // 2 9 ~
		EMUKEY(VK_F7,		1, 1, 0, 0, 1,  "\x9B\x33\x31\x7E", 4), // 3 1 ~
		EMUKEY(VK_F8,		1, 1, 0, 0, 1,  "\x9B\x33\x32\x7E", 4), // 3 2 ~
		EMUKEY(VK_F9,		1, 1, 0, 0, 1,  "\x9B\x33\x33\x7E", 4), // 3 3 ~
		EMUKEY(VK_F10,		1, 1, 0, 0, 1,  "\x9B\x33\x34\x7E", 4), // 3 4 ~

		EMUKEY(VK_F1,		1, 0, 0, 0, 0,	"\x8FP",			2),
		EMUKEY(VK_F2,		1, 0, 0, 0, 0,	"\x8FQ",			2),
		EMUKEY(VK_F3,		1, 0, 0, 0, 0,	"\x8FR",			2),
		EMUKEY(VK_F4,		1, 0, 0, 0, 0,	"\x8FS",			2),

		EMUKEY(VK_F1,		1, 0, 0, 0, 1,	"\x8FP",			2),
		EMUKEY(VK_F2,		1, 0, 0, 0, 1,	"\x8FQ",			2),
		EMUKEY(VK_F3,		1, 0, 0, 0, 1,	"\x8FR",			2),
		EMUKEY(VK_F4,		1, 0, 0, 0, 1,	"\x8FS",			2),

		EMUKEY(VK_DELETE,	1, 0, 0, 0, 0,	"\x7F",				1),	// KN_DEL
		EMUKEY(VK_DELETE,	1, 0, 0, 0, 1,	"\x7F",				1),	// KN_DEL

		EMUKEY(VK_ADD,		1, 0, 0, 0, 0,	",",				1),

		// Ctrl-2.
		// Ctrl-@.
		//
		EMUKEY(0x32,		1, 1, 0, 0, 0,  "\x00",				1),
		EMUKEY(0x32,		1, 1, 0, 1, 0,  "\x00",				1),

		// Ctrl-6.
		// Ctrl-^.
		EMUKEY(0x36,		1, 1, 0, 0, 0,  "\x1E",				1),
		EMUKEY(0x36,		1, 1, 0, 1, 0,  "\x1E",				1),

		// Ctrl-Space
		//
		EMUKEY(VK_SPACE,	1, 1, 0, 0, 0,  "\x00",				1),

		// Ctrl-- key.
		//
		EMUKEY(VK_SUBTRACT,	1, 1, 0, 0, 1,  "\x1F",				1),
		};

	// VT220 User Defined keys.
	static STEMUKEYDATA VT220UserDefinedKeys[MAX_UDK_KEYS] =
		{
		// NOTE: Do not change the order of these user defined entries.
		// emuDecDefineUDK assumes a 1:1 correspondance with this
		// table and the UDKSelector table defined below.
		//
		// Initialize Virtual and Shift flags.
		//
		EMUKEY(VK_F6,		1, 0, 0, 1, 0,  0,					0),
		EMUKEY(VK_F7,		1, 0, 0, 1, 0,  0,					0),
		EMUKEY(VK_F8,		1, 0, 0, 1, 0,  0,					0),
		EMUKEY(VK_F9,		1, 0, 0, 1, 0,  0,					0),
		EMUKEY(VK_F10,		1, 0, 0, 1, 0,  0,					0),

		// Initialize Virtual and Alt flags.
		//
		EMUKEY(VK_F1,		1, 0, 1, 0, 0,  0,					0),
		EMUKEY(VK_F2,		1, 0, 1, 0, 0,  0,					0),
		EMUKEY(VK_F3,		1, 0, 1, 0, 0,  0,					0),
		EMUKEY(VK_F4,		1, 0, 1, 0, 0,  0,					0),
		EMUKEY(VK_F5,		1, 0, 1, 0, 0,  0,					0),
		EMUKEY(VK_F6,		1, 0, 1, 0, 0,  0,					0),
		EMUKEY(VK_F7,		1, 0, 1, 0, 0,  0,					0),
		EMUKEY(VK_F8,		1, 0, 1, 0, 0,  0,					0),
		EMUKEY(VK_F9,		1, 0, 1, 0, 0,  0,					0),
		EMUKEY(VK_F10,		1, 0, 1, 0, 0,  0,					0),
		};

	// NOTE: Do not change the order of these entries.
	// There is a 1:1 correspondance between this table and the
	// user defined key table defined above.
	//
	static TCHAR const acUDKSelectors[MAX_UDK_KEYS] =
		{
		TEXT('\x17'), TEXT('\x18'), TEXT('\x19'), TEXT('\x20'), // F6 -  F9
		TEXT('\x21'), TEXT('\x23'), TEXT('\x24'), TEXT('\x25'), // F10 - F13
		TEXT('\x26'), TEXT('\x28'), TEXT('\x29'), TEXT('\x31'), // F14 - F17
		TEXT('\x32'), TEXT('\x33'), TEXT('\x34'),				// F18 - F20
		};

	emuInstallStateTable(hhEmu, vt220_tbl, DIM(vt220_tbl));

	// Allocate space for and initialize data that is used only by the
	// VT220 emulator.
	//
	hhEmu->pvPrivate = malloc(sizeof(DECPRIVATE));

	if (hhEmu->pvPrivate == 0)
		{
		assert(FALSE);
		return;
		}

	pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	memset(pstPRI, 0, sizeof(DECPRIVATE));

	// NOTE:	The order of these definitions directly correspond to the
	//			search order used by the emuDecKeyboardIn function.
	//			Don't change these.
	//
	// In shared code, these are all part of hhEmu.
	pstPRI->pstcEmuKeyTbl1 = VT220StdPfKeyTable;
	pstPRI->pstcEmuKeyTbl2 = VT220MovedPfKeyTable;
	pstPRI->pstcEmuKeyTbl3 = VT220KeypadNumericMode;
	pstPRI->pstcEmuKeyTbl4 = VT220KeypadApplicationMode;
	pstPRI->pstcEmuKeyTbl5 = VT220CursorKeyMode;
	pstPRI->pstcEmuKeyTbl6 = VT220StandardKeys;

	pstPRI->iKeyTable1Entries = DIM(VT220StdPfKeyTable);
	pstPRI->iKeyTable2Entries = DIM(VT220MovedPfKeyTable);
	pstPRI->iKeyTable3Entries = DIM(VT220KeypadNumericMode);
	pstPRI->iKeyTable4Entries = DIM(VT220KeypadApplicationMode);
	pstPRI->iKeyTable5Entries = DIM(VT220CursorKeyMode);
	pstPRI->iKeyTable6Entries = DIM(VT220StandardKeys);

	// Allocate an array to hold line attribute values.
	//
	pstPRI->aiLineAttr = malloc(MAX_EMUROWS * sizeof(int) );

	if (pstPRI->aiLineAttr == 0)
		{
		assert(FALSE);
		return;
		}

	for (iRow = 0; iRow < MAX_EMUROWS; iRow++)
		pstPRI->aiLineAttr[iRow] = NO_LINE_ATTR;

	pstPRI->sv_row			= 0;
	pstPRI->sv_col			= 0;
	pstPRI->gn				= 0;
	pstPRI->sv_AWM			= RESET;
	pstPRI->sv_DECOM		= RESET;
	pstPRI->sv_protectmode	= FALSE;
	pstPRI->fAttrsSaved 	= FALSE;
	pstPRI->pntr			= pstPRI->storage;

	// Initialize hhEmu values for VT220.
	//
	hhEmu->emu_setcurpos	= emuDecSetCurPos;
	hhEmu->emu_deinstall	= emuDecUnload;
	hhEmu->emu_clearline	= emuDecClearLine;
	hhEmu->emu_clearscreen  = emuDecClearScreen;
	hhEmu->emu_kbdin		= emuDecKeyboardIn;
	hhEmu->emuResetTerminal = vt220_reset;
	hhEmu->emu_graphic		= emuDecGraphic;
//	hhEmu->emu_scroll		= emuDecScroll;

#if !defined(FAR_EAST)
	hhEmu->emu_highchar 	= 0x7E;
#else
	hhEmu->emu_highchar 	= 0xFFFF;
#endif

	hhEmu->emu_maxcol		= VT_MAXCOL_80MODE;
	hhEmu->fUse8BitCodes		= FALSE;
	hhEmu->mode_vt220			= FALSE;
	hhEmu->mode_vt320			= FALSE;
	//hhEmu->vt220_protectmode	= FALSE;
	hhEmu->mode_protect			= FALSE;

	if (hhEmu->nEmuLoaded == EMU_VT220)
		hhEmu->mode_vt220 = TRUE;

	else if (hhEmu->nEmuLoaded == EMU_VT320)
		hhEmu->mode_vt320 = TRUE;

	else
		assert(FALSE);

// UNDO:rde
//	pstPRI->vt220_protimg = 0;

	pstPRI->pstUDK			= VT220UserDefinedKeys;
	pstPRI->iUDKTableEntries= DIM(VT220UserDefinedKeys);

	pstPRI->pacUDKSelectors = acUDKSelectors;
	pstPRI->iUDKState		= KEY_NUMBER_NEXT;

	std_dsptbl(hhEmu, TRUE);
	vt_charset_init(hhEmu);

	switch(hhEmu->stUserSettings.nEmuId)
		{
	case EMU_VT220:
		hhEmu->mode_vt220		= TRUE;
		hhEmu->mode_vt320		= FALSE;
		vt220_reset(hhEmu, FALSE);
		break;

	case EMU_VT320:
		hhEmu->mode_vt220		= FALSE;
		hhEmu->mode_vt320		= TRUE;
		break;

	default:
		assert(FALSE);
		break;
		}

	backscrlSetShowFlag(sessQueryBackscrlHdl(hhEmu->hSession), TRUE);
	return;
	}
#endif // INCL_VT220

/* end of vt220ini.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\viewdata.hh ===
/* viewdata.hh -- Common definitions for HyperACCESS/5 Viewdata
 *					 terminal emualation routines
 *
 *	Copyright 1990 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

/* maxcol definitions */

#define VIEWDATA_COLS_40MODE	40

/* attribute definitions */

#define ALPHA_ATTR		0x01
#define MOSAIC_ATTR 	0x02
#define CONTIGUOUS_ATTR 0x03
#define SEPARATED_ATTR	0x04
#define NORMALSIZE_ATTR 0x05
#define FLASH_ATTR		0x06
#define STEADY_ATTR 	0x07
#define NEW_BACKGROUND_ATTR 0x08
#define DOUBLESIZE_ATTR 0x09
#define CONCEAL_ATTR    0x0A

/* --- view datat attribute structure --- */

typedef struct _viewdata
	{
	unsigned int attr	 : 4;	   // attribute type
	unsigned int clr	 : 4;	   // color if attribute type is color
	unsigned int smosaic : 1;	   // separated mosaics
	unsigned int cmosaic : 1;	   // contigous mosaics
	//unsigned int dblsiz  : 1;	   // double size
	} STVIEWDATA;

typedef STVIEWDATA *PSTVIEWDATA;

// Private emulator data for Viewdata.
//
typedef struct stPrivateViewdata
	{
	PSTVIEWDATA *apstVD;

	int fMosaicMode,
		fSeperatedMosaic,
		fSetAttr;

	unsigned aMapColors[7];

	} VIEWDATAPRIVATE;

typedef VIEWDATAPRIVATE *PSTVIEWDATAPRIVATE;

/* --- viewdini.c --- */

void	  EmuViewdataInit(const HHEMU hhEmu);
void	  EmuViewdataDeinstall(const HHEMU hhEmu);

/* --- viewdata.c --- */
void	  EmuViewdataAnswerback(const HHEMU hhEmu);
void	  EmuViewdataCursorLeft(const HHEMU hhEmu);
void	  EmuViewdataCursorRight(const HHEMU hhEmu);
void	  EmuViewdataCursorDown(const HHEMU hhEmu);
void	  EmuViewdataCursorUp(const HHEMU hhEmu);
void	  EmuViewdataCursorHome(const HHEMU hhEmu);
void	  EmuViewdataCursorSet(const HHEMU hhEmu);
void	  EmuViewdataSetAttr(const HHEMU hhEmu);
void	  EmuViewdataMosaicSet(const HHEMU hhEmu);
void	  EmuViewdataMosaicHold(const HHEMU hhEmu);
void	  EmuViewdataMosaicRelease(const HHEMU hhEmu);
void	  EmuViewdataCharDisplay(const HHEMU hhEmu);
int 	  EmuViewdataReset(const HHEMU hhEmu, int const fHost);

int 	  EmuViewdataKbd(const HHEMU hhEmu, int kcode, const BOOL fTest);
int 	  emuViewdataPadAttrStr(const HHEMU hhEmu, int iRow, const int iCol, const TCHAR tchar);
void	  EmuViewdataClearScreen(const HHEMU hhEmu);

/**************************** end of viewdata.hh ***************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\vt52.hh ===
/*	File: D:\WACKER\emu\vt52.hh (Created: 13-July-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:28p $
 */

/* No Longer is use, replaced by PSTDECPRIVATE
// Private emulator data for VT52.
//

typedef struct stPrivateVT52
	{
	int 	len_t,
			len_s;

	ECHAR	terminate[4],
			storage[40],
			*pntr;

	} VT52PRIVATE;

typedef VT52PRIVATE *PSTVT52PRIVATE;
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\vt52.c ===
/*	File: D:\WACKER\emu\vt52.c (Created: 28-Dec-1993)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 5/09/01 4:47p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\chars.h>
#include <tdll\print.h>
#include <tdll\mc.h>
#include <tdll\htchar.h>
#include <tdll\assert.h>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"
#include "emudec.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt52PrintCommands
 *
 * DESCRIPTION:
 *	 Processes vt52 printing commands.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void vt52PrintCommands(const HHEMU hhEmu)
	{
	int line;
	ECHAR code;
	ECHAR aechBuf[10];

	code = hhEmu->emu_code;
	switch (code)
		{
	case ETEXT('^'): 			  /* auto print on */
		hhEmu->print_echo = TRUE;
		break;

	case ETEXT('_'): 			  /* auto print off */
		hhEmu->print_echo = FALSE;
		break;

	case ETEXT(']'): 			  /* print screen */
		for (line = 0; line < 24; ++line)
			printEchoLine(hhEmu->hPrintHost,
							hhEmu->emu_apText[row_index(hhEmu, line)],
							emuRowLen(hhEmu, row_index(hhEmu, line)));

		CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("0x0C"),
                         StrCharGetByteCount(TEXT("0x0C")));
		printEchoLine(hhEmu->hPrintHost, aechBuf, sizeof(ECHAR));
		break;

	case ETEXT('V'): 			  /* print cursor line */
		printEchoLine(hhEmu->hPrintHost,
				hhEmu->emu_apText[row_index(hhEmu, hhEmu->emu_currow)],
				emuRowLen(hhEmu, row_index(hhEmu, hhEmu->emu_currow)));
		break;

	case ETEXT('W'): 			  /* enter printer controller mode */
		hhEmu->state = 4;		   /* start vt52_prnc() */
		break;

	case ETEXT('X'): 			  /* exit printer controller mode */
		break;
	default:
		break;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt52Print
 *
 * DESCRIPTION:
 *	 Stores character and prints saved string of characters when termination
 *	 character is received.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void vt52Print(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	ECHAR ccode;

	ccode = hhEmu->emu_code;
	*pstPRI->pntr++ = ccode;
	*pstPRI->pntr = 0;
	++pstPRI->len_s;

	if (pstPRI->len_s >= pstPRI->len_t &&
			memcmp(pstPRI->terminate,
					&pstPRI->storage[pstPRI->len_s - pstPRI->len_t], 
					sizeof(pstPRI->terminate)) == 0)
		{
		/* received termination string, wrap it up */
		emuPrintChars(hhEmu, pstPRI->storage, pstPRI->len_s - pstPRI->len_t);
		pstPRI->pntr = pstPRI->storage;
		pstPRI->len_s = 0;
		hhEmu->state = 0;  /* drop out of this routine */

		// Finish-up print job.
		//
		printEchoClose(hhEmu->hPrintHost);
		return;
		}

	/* haven't received termination sequence yet, is storage filled? */
	if ((unsigned)pstPRI->len_s >= (sizeof(pstPRI->storage) - 1))
		{
		/* copy most of string to print buffer */
		emuPrintChars(hhEmu, pstPRI->storage, pstPRI->len_s - pstPRI->len_t);

		/* move end of string to beginning of storage */
		memmove(pstPRI->storage,
					&pstPRI->storage[pstPRI->len_s - pstPRI->len_t],
					(unsigned)pstPRI->len_t);

		pstPRI->pntr = pstPRI->storage + pstPRI->len_t;
		pstPRI->len_s = pstPRI->len_t;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt52_id
 *
 * DESCRIPTION:
 *	 Transmits the VT52 id code--ESC/Z.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void vt52_id(const HHEMU hhEmu)
	{
	TCHAR *sp;
	ECHAR ech[10];

	sp = TEXT("\033/Z");
	CnvrtMBCStoECHAR(ech, sizeof(ech), TEXT("\033/Z"),
                     StrCharGetByteCount(TEXT("\033/Z")));
	emuSendString(hhEmu, ech, (int)StrCharGetStrLength(sp));
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt52_CUP
 *
 * DESCRIPTION:
 *	 Positions the cursor for the VT52 emulator.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void vt52_CUP(const HHEMU hhEmu)
	{
	char_pn(hhEmu);
	(*hhEmu->emu_setcurpos)(hhEmu,
							hhEmu->num_param[0] - 1,
							hhEmu->num_param[1] - 1);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt52_kbdin
 *
 * DESCRIPTION:
 *	 Processes local keyboard keys for the VT52 emulator.
 *
 * ARGUMENTS:
 *	 key -- key to process
 *	 fTest -- if TRUE, just checks if it is an emulator key.
 *
 * RETURNS:
 *	 nothing
 */
int vt52_kbdin(const HHEMU hhEmu, int key, const int fTest)
	{
	int index;
	/* -------------- Check Backspace & Delete keys ------------- */

	if (hhEmu->stUserSettings.fReverseDelBk && ((key == VK_BACKSPACE) ||
			(key == DELETE_KEY) || (key == DELETE_KEY_EXT)))
		{
		key = (key == VK_BACKSPACE) ? DELETE_KEY : VK_BACKSPACE;
		}

	/* -------------- Mapped PF1-PF4 keys ------------- */

	if (hhEmu->stUserSettings.fMapPFkeys &&
			(index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl3)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl3);
		}

	/* -------------- Keypad Application mode ------------- */

	else if (hhEmu->mode_DECKPAM &&
			(index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl2)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl2);
		}

	/* -------------- Normal mode keys ------------- */

	else if ((index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl);
		}

	else
		{
		index = std_kbdin(hhEmu, key, fTest);
		}

	return index;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuVT52Unload
 *
 * DESCRIPTION:
 *	 Unloads current emulator by freeing used memory.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emuVT52Unload(const HHEMU hhEmu)
	{
	assert(hhEmu);

	if (hhEmu->pvPrivate)
		{
		free(hhEmu->pvPrivate);
		hhEmu->pvPrivate = 0;
		}

    //
    // Make sure to free the key tables that were created when the emulator
    // was loaded, otherwise there is a memory leak. REV: 05/09/2001
    //
	emuKeyTableFree(&hhEmu->stEmuKeyTbl);
	emuKeyTableFree(&hhEmu->stEmuKeyTbl2);
	emuKeyTableFree(&hhEmu->stEmuKeyTbl3);

	return;
	}


/* end of vt52.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\vt220.c ===
/*  File: \wacker\emu\vt220.c (Created: 28-Jan-1998)
 *
 *  Copyright 1998 by Hilgraeve Inc. -- Monroe, MI
 *  All rights reserved
 *
 *  $Revision: 8 $
 *  $Date: 5/09/01 4:48p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\htchar.h>
#include <tdll\session.h>
#include <tdll\cloop.h>
#include <tdll\assert.h>
#include <tdll\print.h>
#include <tdll\update.h>
#include <tdll\capture.h>
#include <tdll\backscrl.h>
#include <tdll\chars.h>
#include <tdll\mc.h>

#include "emu.h"
#include "emu.hh"
#include "emudec.hh"

#if defined(INCL_VT220)

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt220_hostreset
 *
 * DESCRIPTION:
 *   Calls vt220_reset() when told by the host to reset.
 *
 * ARGUMENTS:
 *   none
 *
 * RETURNS:
 *   nothing
 */
void vt220_hostreset(const HHEMU hhEmu)
	{
	vt220_reset(hhEmu, TRUE);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt220_reset
 *
 * DESCRIPTION:
 *   Calls vt220_reset() when told by the host to reset.
 *
 * ARGUMENTS:
 *   host_request -- TRUE if told by host to reset
 *
 * RETURNS:
 *   nothing
 */
int vt220_reset(const HHEMU hhEmu, const int host_request)
	{
	hhEmu->mode_KAM = hhEmu->mode_IRM = hhEmu->mode_VEM =
		hhEmu->mode_HEM = hhEmu->mode_LNM = hhEmu->mode_DECCKM =
		hhEmu->mode_DECOM = hhEmu->mode_DECCOLM = hhEmu->mode_DECPFF =
//		hhEmu->mode_DECSCNM = hhEmu->mode_25enab = hhEmu->mode_blank =
		hhEmu->mode_DECSCNM = hhEmu->mode_25enab =
		hhEmu->mode_block = hhEmu->mode_local = RESET;

	hhEmu->mode_SRM = hhEmu->mode_DECPEX = hhEmu->mode_DECTCEM = SET;

	hhEmu->mode_AWM = TRUE;

//	hhEmu->mode_protect = hhEmu->vt220_protectmode = FALSE;
	hhEmu->mode_protect = FALSE;

	if (host_request)
		{
		ANSI_RIS(hhEmu);
		hhEmu->mode_AWM = RESET;
		}

	hhEmu->fUse8BitCodes = FALSE;
	hhEmu->mode_vt220 = TRUE;
	hhEmu->mode_vt320 = FALSE;

	if (hhEmu->nEmuLoaded == EMU_VT320)
		{
		hhEmu->mode_vt320 = TRUE;
		}

	vt_charset_init(hhEmu);

	hhEmu->emu_code = '>';

	vt_alt_kpmode(hhEmu);

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt220_softreset
 *
 * DESCRIPTION:
 *   Does a soft reset.
 *
 * ARGUMENTS:
 *   none
 *
 * RETURNS:
 *   nothing
 */
void vt220_softreset(const HHEMU hhEmu)
	{
	hhEmu->mode_KAM = hhEmu->mode_IRM = hhEmu->mode_DECCKM =
		hhEmu->mode_DECOM = hhEmu->mode_DECKPAM = RESET;

	hhEmu->mode_AWM = RESET;

	DEC_STBM(hhEmu, 0,0);

	ANSI_Pn_Clr(hhEmu);

	ANSI_SGR(hhEmu);

	hhEmu->emu_code = 0;

	vt100_savecursor(hhEmu);

	vt_charset_init(hhEmu);

	hhEmu->emu_code = '>';

	vt_alt_kpmode(hhEmu);

	hhEmu->mode_protect = FALSE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt220mode_reset
 *
 * DESCRIPTION:
 *   Sets the VT220 emulator to the proper conditions when switching
 *  from vt100 mode.
 *
 * ARGUMENTS:
 *   none
 *
 * RETURNS:
 *   nothing
 */
void vt220mode_reset(const HHEMU hhEmu)
	{
	hhEmu->mode_KAM		= hhEmu->mode_IRM		= hhEmu->mode_VEM =
		hhEmu->mode_HEM		= hhEmu->mode_DECCKM	= hhEmu->mode_DECOM =
		hhEmu->mode_25enab  = hhEmu->mode_AWM		= RESET;

	hhEmu->mode_DECPEX = hhEmu-> mode_DECTCEM = SET;

	hhEmu->fUse8BitCodes = FALSE;

	hhEmu->mode_vt220 = TRUE;
	hhEmu->mode_vt320 = FALSE;

	vt_charset_init(hhEmu);

	hhEmu->emu_code = '>';

	vt_alt_kpmode(hhEmu);

	DEC_STBM(hhEmu, 0, hhEmu->emu_maxrow + 1);

	hhEmu->emu_code = 0;

	vt100_savecursor(hhEmu);

	hhEmu->mode_protect = FALSE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt220_DA
 *
 * DESCRIPTION:
 *   Sends the primary device attribute (DA) information to the host.
 *
 * ARGUMENTS:
 *   none
 *
 * RETURNS:
 *   nothing
 */
void vt220_DA(const HHEMU hhEmu)
	{
	int		fOldValue;
	char	achStr[50];
	ECHAR	ech[50];

	//if (emuProjSuppressEmuReporting(hhEmu))
	//		return;

	// Build the 7-bit or 8-bit response.
	//
	if (hhEmu->fUse8BitCodes)
		{
		achStr[0] = '\x9B';
		achStr[1] = '\x00';
		}
	else
		{
		achStr[0] = '\x1B';
		achStr[1] = '[';
		achStr[2] = '\x00';
		}

	// Add the VT220 or VT320 part of the response.
	//
	if (hhEmu->mode_vt320)
		StrCharCat(achStr, TEXT("?63"));
	else
		StrCharCat(achStr, TEXT("?62"));

	// Add the rest of the respnse and send the result.
	//
	StrCharCat(achStr, TEXT(";1;2;6;8;9;14c"));

	CnvrtMBCStoECHAR(ech, sizeof(ech), achStr, 
					 StrCharGetByteCount(achStr));

	fOldValue = CLoopGetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession));

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), FALSE);

	emuSendString(hhEmu, ech, (int)StrCharGetEcharByteCount(ech)); 

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), fOldValue);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt220_2ndDA
 *
 * DESCRIPTION:
 *   Sends the secondary device attribute (DA) information to the host.
 *
 * ARGUMENTS:
 *   none
 *
 * RETURNS:
 *   nothing
 */
void vt220_2ndDA(const HHEMU hhEmu)
	{
	int		fOldValue;
	char	achStr[50];
	ECHAR	ech[50];

	// Build the 7-bit or 8-bit response.
	//
	if (hhEmu->fUse8BitCodes)
		{
		achStr[0] = '\x9B';
		achStr[1] = '\x00';
		}
	else
		{
		achStr[0] = '\x1B';
		achStr[1] = '[';
		achStr[2] = '\x00';
		}

	// Add the VT220 or VT320 part of the response.
	//
	if (hhEmu->mode_vt320)
        {
		StrCharCat(achStr, TEXT(">24;14;0c"));
        }
	else
        {
		StrCharCat(achStr, TEXT(">1;23;0c"));
        }

	CnvrtMBCStoECHAR(ech, sizeof(ech), achStr, 
					 StrCharGetByteCount(achStr));

	fOldValue = CLoopGetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession));

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), FALSE);

	emuSendString(hhEmu, ech, (int)StrCharGetEcharByteCount(ech)); 

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), fOldValue);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emuDecClearUDK
 *
 * DESCRIPTION:
 *  This function clears (frees) all of the user defined key sequences
 *  that may have been previously stored.
 *
 * ARGUMENTS:
 *  HHEMU   hhEmu   -   The internal emulator handle.
 *
 * NOTES:
 *  This function is called in response to the following escape sequence.
 *  Esc Pc;Pl |
 *
 * RETURNS:
 *  void
 *
 * AUTHOR: John Masters, 05-Sep-1995
 */
void emuDecClearUDK(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;
	PSTEMUKEYDATA pstKey = pstPRI->pstUDK;
	int idx;

	// Set a flag that identifies the locked or unlocked status of the
	// UDK's that will be set after the definition of the keys has
	// completed.
	//
	if (hhEmu->selector[1] == 1)
		pstPRI->fUnlockedUDK = 1;   // Keys are unlocked after definition.
	else
		pstPRI->fUnlockedUDK = 0;   // Keys are locked after definition.

	// This function is called in response to an escape sequence that tells
	// the emulator to either clear each key sequence when a new one is
	// defined, or to clear all of the key sequences before any are defined.
	//
	// emuDecStoreUDK always clears the current sequence before assigning
	// a new one.  So, this function will clear all of the keys only
	// if that's what we were asked to do.  If the first selector is Zero,
	// then we will go ahead and clear all of the User Defined Keys.
	//
	if (hhEmu->selector[0] != 0)
		return;

	// Cycle through the user defined key table and free
	// any memory that may have been allocated for sequences.
	//
	if (pstKey)
		{
		for (idx = 0; idx < MAX_UDK_KEYS; idx++, pstKey++)
			{
			if (pstKey->iSequenceLen != 0)
				{
				free(pstKey->pSequence);
				pstKey->iSequenceLen = 0;
				}
			}
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecDefineUDK
 *
 * DESCRIPTION:
 *   Redefines the string output by a key.
 *
 * ARGUMENTS:
 *   none
 *
 * RETURNS:
 *   nothing
 */
void emuDecDefineUDK(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	TCHAR acAscii[16] = {   TEXT('0'), TEXT('1'), TEXT('2'), TEXT('3'),
							TEXT('4'), TEXT('5'), TEXT('6'), TEXT('7'),
							TEXT('8'), TEXT('9'), TEXT('A'), TEXT('B'),
							TEXT('C'), TEXT('D'), TEXT('E'), TEXT('F') };

	unsigned int aiHex[16] = {  0x00, 0x01, 0x02, 0x03,
								0x04, 0x05, 0x06, 0x07,
								0x08, 0x09, 0x0A, 0x0B,
								0x0C, 0x0D, 0x0E, 0x0F };

	int		idx;
	ECHAR   emuCode;

	emuCode = hhEmu->emu_code;

	switch(pstPRI->iUDKState)
		{
	case(KEY_NUMBER_NEXT):
		TCHAR_Fill(pstPRI->acUDKSequence,
			0, sizeof(pstPRI->acUDKSequence) / sizeof(TCHAR));

		pstPRI->iUDKSequenceLen = 0;
		pstPRI->chUDKAssignment = 0;
		pstPRI->iUDKState		= KEY_DIGIT2_NEXT;

		if (IN_RANGE(emuCode,TEXT('1'),TEXT('3')))
			{
			for (idx = 0; idx < 16; idx++)
				{
				if (emuCode == acAscii[idx])
					break;
				}

			pstPRI->chUDKAssignment = (TCHAR)(aiHex[idx] << 4);

			}
		else
			{
			goto UDKexit;
			}

		break;

	case(KEY_DIGIT2_NEXT):
		if (isdigit(emuCode))
			{
			for (idx = 0; idx < 16; idx++)
				{
				if (emuCode == acAscii[idx])
					break;
				}

			pstPRI->chUDKAssignment += (TCHAR)aiHex[idx];

			// The key to which the following sequence will be assigned
			// has been identified.  Lookup  that key in a table and
			// store an index that corresponds to the key table index.
			// See the initialization function for the emulator for
			// further clarification.
			//
			for (idx = 0; idx < MAX_UDK_KEYS; idx++)
				{
				if (pstPRI->chUDKAssignment == pstPRI->pacUDKSelectors[idx])
					break;
				}

			// Process a possible error.
			//
			if (idx >= MAX_UDK_KEYS)
				{
				goto UDKexit;
				}

			// When the sequence is saved in the key table,
			// this index will be used to identify which
			// key in that table will get the user defined sequence.
			//
			pstPRI->iUDKTableIndex  = idx;
			pstPRI->iUDKState		= SLASH_NEXT;
			}
		else
			{
			goto UDKexit;
			}

		break;

	case (SLASH_NEXT):
		if (emuCode == TEXT('/'))
			{
			pstPRI->iUDKState = CHAR_DIGIT1_NEXT;
			}
		else
			{
			goto UDKexit;
			}

		break;

	case (CHAR_DIGIT1_NEXT):
		switch(emuCode)
			{
		case(TEXT(';')):
		case 0x9C:
			if (emuDecStoreUDK(hhEmu) != 0)
				goto UDKexit;

			if (emuCode == TEXT('\x9C'))
				goto UDKexit;

			pstPRI->iUDKState = KEY_NUMBER_NEXT;
			break;

		case(TEXT('\x1B')):
			pstPRI->iUDKState = ESC_SEEN;
			break;

		default:
			if (!isxdigit(emuCode))
				{
				goto UDKexit;
				}

			// Collect the first half of the key comming in.
			//
			for (idx = 0; idx < 16; idx++)
				{
				if (emuCode == acAscii[idx])
					break;
				}

			pstPRI->chUDKAssignment = 0;
			pstPRI->chUDKAssignment = (TCHAR)(aiHex[idx] << 4);
			pstPRI->iUDKState		= CHAR_DIGIT2_NEXT;
			break;
			}

		break;

	case(CHAR_DIGIT2_NEXT):
		if (!isxdigit(emuCode))
			{
			goto UDKexit;
			}

		// This is the second half of the key comming in.
		//
		for (idx = 0; idx < 16; idx++)
			{
			if (emuCode == acAscii[idx])
				break;
			}

		pstPRI->chUDKAssignment += (TCHAR)aiHex[idx];

		if (pstPRI->chUDKAssignment >= 127)
			{
			goto UDKexit;
			}

		pstPRI->acUDKSequence[pstPRI->iUDKSequenceLen] =
			pstPRI->chUDKAssignment;

		pstPRI->iUDKSequenceLen += 1;
		pstPRI->iUDKState = CHAR_DIGIT1_NEXT;

		break;

	case(ESC_SEEN):
		if ((emuCode = TEXT('\\')) == 0)
			{
			goto UDKexit;
			}

		if (emuDecStoreUDK(hhEmu) != 0)
			{
			assert(FALSE);
			}

		// We have completed defining the user defined key sequences.
		// A flag set in emuDecClearUDK was set to identify the locked
		// or unlocked status of the sequences after their definition.
		// Promote that setting up to the variable used by the user
		// interface.
		//
		hhEmu->fAllowUserKeys = pstPRI->fUnlockedUDK;

		goto UDKexit;

	default:
		goto UDKexit;
		}

	// Returning from here allows the state table to pass control
	// back to this function, where the internal state (pstPRI->iUDKState)
	// will be used to control flow through the case statement above.
	//
	return;

UDKexit:
	// The sequence is complete or we're dropping out because of
	// an error.
	//

	// Initialize the UDK state and the emulators state.
	//
	pstPRI->iUDKState = KEY_NUMBER_NEXT;
	hhEmu->state = 0;

	return;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emuDecStoreUDK
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 * Author:  John Masters
 *
 */
int emuDecStoreUDK(const HHEMU hhEmu)
	{
	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	PSTEMUKEYDATA pstKey = pstPRI->pstUDK + pstPRI->iUDKTableIndex;

	// There may be a user settings that disables user defined keys.
	// If this feature in not enabled, get outta town.
	//
	if (!hhEmu->fAllowUserKeys)
		{
		return(0);
		}

	// First, free a previously allocated key for this entry, if
	// necessary.
	//
	if (pstKey->iSequenceLen != 0)
		{
		free(pstKey->pSequence);
		pstKey->iSequenceLen = 0;
		}

	// Now allocate the space for the key sequence.
	//
	pstKey->pSequence = malloc( sizeof(TCHAR) *
		(unsigned int)pstPRI->iUDKSequenceLen);

	if (pstKey->pSequence == 0)
		{
		assert(FALSE);
		return(-1);
		}

	// Now, copy the previously collected sequence into the key table
	// and initialize the length variable.
	//
	MemCopy(pstKey->pSequence,
		pstPRI->acUDKSequence,
		(unsigned int)pstPRI->iUDKSequenceLen);

	pstKey->iSequenceLen = (unsigned int)pstPRI->iUDKSequenceLen;

	return(0);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt220_level
 *
 * DESCRIPTION:
 *   Sets the compatibility level of the VT220.
 *
 * ARGUMENTS:
 *   none
 *
 * RETURNS:
 *   nothing
 */
void vt220_level(const HHEMU hhEmu)
	{
	int term, level;

	term = hhEmu->num_param[0];

	level = hhEmu->num_param_cnt > 0 ? hhEmu->num_param[1] : 0;

	if (level < 1)
		level = 0;

	if (term == 61)
		{
		if (hhEmu->mode_vt220)
			vt100_init(hhEmu);
		}

	else if (term == 62 || term == 63)
		{
		if (!hhEmu->mode_vt220)
			vt220_init(hhEmu);  /* sets mode_vt220 & mode_vt320 */

		if (level == 1)
			hhEmu->fUse8BitCodes = FALSE;

		if (level == 0 || level == 2)
			hhEmu->fUse8BitCodes = TRUE;

		if (term == 62 && hhEmu->mode_vt320)
			hhEmu->mode_vt320 = FALSE;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt220_protmode
 *
 * DESCRIPTION:
 *   Sets up and clears protect mode -- called selective erase on vt220.
 *
 * ARGUMENTS:
 *   none
 *
 * RETURNS:
 *   nothing
 */
void vt220_protmode(const HHEMU hhEmu)
	{
	hhEmu->mode_protect = (hhEmu->num_param[0] == 1);

	hhEmu->emu_charattr.protect = (unsigned int)hhEmu->mode_protect;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emuDecKeyboardIn
 *
 * DESCRIPTION:
 *  This function processes the keyboard keys for all the DEC terminal
 *  emulators.
 *
 *  Please note that both emuSendKeyString, and emuDecSendKeyString are
 *  used in this function.  emuDecSendKeyString is a function that will
 *  convert the 8-bit sequence from the key table to a 7-bit value, if
 *  necessary.
 *
 *  Keys Used to Emulate a DEC Terminal's PF1-PF4 Keys
 *
 *  The keys normally used in HyperACCESS to emulate a DEC terminal's
 *  PF1-PF4 keys are F1-F4. Some people, however, prefer to use the
 *  keys at the top of the PC's numeric keypad (Num Lock, /, *, -),
 *  because these keys' physical location matches that of a DEC
 *  terminal's PF1-PF4 keys. If you prefer using these keys, select
 *  the "PF1-PF4 mapped to top row of keypad" checkbox in the
 *  terminal settings dialog for the DEC terminal you are using.
 *
 *  When "PF1-PF4 mapped to top row of keypad" is checked ...
 *
 *  The keys at the top of the keypad act as PF1-PF4, and F1-F4
 *  revert to performing functions defined by the operating system.
 *  For example, F1 displays help, and Num Lock sends the character
 *  sequence that the DEC terminal associates with PF1. The operating
 *  system will also sense that Num Lock has been pressed, and toggle
 *  the keyboard's Num Lock state. The Num Lock state, however, has
 *  no effect on the behavior of the DEC terminal emulator when
 *  PF1-PF4 are mapped to the top row of the keypad.
 *
 *  When "PF1-PF4 mapped to top row of keypad" is NOT checked...
 *
 *  F1-F4 act as PF1-PF4, and the keys at the top of the keypad (Num
 *  Lock, /, *, -) perform their normal functions. For example, F1
 *  sends the character sequence that the DEC terminal associates
 *  with PF1, and Num Lock toggles the keyboard's Num Lock state.
 *  When Num Lock is on, your PC's keypad (except the top row)
 *  emulates the numeric keypad of a DEC terminal. When Num Lock is
 *  off, your keypad's arrow keys emulate a DEC terminal's arrow
 *  keys. (If your keyboard has a separate set of arrow keys, that
 *  set will always emulate a DEC terminal's arrow keys, regardless
 *  Num Lock's state.)
 *
 * ARGUMENTS:
 *  HHEMU   hhEmu   -   The Internal emulator handle.
 *  int     Key     -   The key to process.
 *  int     fTest   -   Are we testing, or processing the key.
 *
 * RETURNS:
 *  This function returns the index of the table in which the key was
 *  found.
 *
 * AUTHOR: John Masters, 12-Sep-1995
 */
int emuDecKeyboardIn(const HHEMU hhEmu, int Key, const int fTest)
    {
    const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

    int index;
    int fNumlock;
    int fMovedPfKeys;
    int fSearchKeypad;
    int fCursorKeyMode;
    int fKeypadNumeric;
    int fKeypadApplication;
    int fSearchUDK;

    if (!fTest)
        {
#if 0
        DbgOutStr("VT100_KBDIN", 0, 0, 0, 0, 0);
        DbgOutStr("Key: Char     :0x%x", hKey.VKchar, 0, 0, 0, 0);
        DbgOutStr("     Virtual  :%d", hKey.Virtual, 0, 0, 0, 0);
        DbgOutStr("     Ctrl     :%d", hKey.Ctrl, 0, 0, 0, 0);
        DbgOutStr("     Alt      :%d", hKey.Alt, 0, 0, 0, 0);
        DbgOutStr("     Shift    :%d", hKey.Shift, 0, 0, 0, 0);
        DbgOutStr("     Extended :%d", hKey.Extended, 0, 0, 0, 0);
#endif
        }

    // Initialize some locals.  The keypad is either in Numeric Mode,
    // or Application Mode.  So, the first two locals below are mutually
    // exclusive variables.  They have been defined only to improve
    // readability in this code.
    //
    fKeypadApplication  = hhEmu->mode_DECKPAM;
    fKeypadNumeric      = !fKeypadApplication;
    //fMovedPfKeys        = hhEmu->stUserSettings.fMapPFkeys;
    fMovedPfKeys        = FALSE;
    fNumlock            = QUERY_NUMLOCK();
    fSearchKeypad       = (fMovedPfKeys || fNumlock);
    fCursorKeyMode      = (hhEmu->mode_DECCKM == SET) &&
        (hhEmu->nEmuLoaded != EMU_VT52);
    fSearchUDK          = hhEmu->fAllowUserKeys &&
        ((hhEmu->nEmuLoaded == EMU_VT220) ||
        (hhEmu->nEmuLoaded == EMU_VT320));

    assert(fKeypadApplication != fKeypadNumeric);

	/* -------------- Check Backspace & Delete keys ------------- */

	if (hhEmu->stUserSettings.fReverseDelBk && ((Key == VK_BACKSPACE) ||
			(Key == DELETE_KEY) || (Key == DELETE_KEY_EXT)))
		{
		Key = (Key == VK_BACKSPACE) ? DELETE_KEY : VK_BACKSPACE;
		}

    // F1 thru F4 from either function keys on the top of the keyboard,
    // or from the function key pad on the left.  (They have not been
    // mapped to the top row of the numeric keypad).
    //
    if (!fMovedPfKeys && (index = emuDecKbdKeyLookup(hhEmu,
			Key, pstPRI->pstcEmuKeyTbl1, pstPRI->iKeyTable1Entries)) != -1)
        {
        if (!fTest)
            emuDecSendKeyString(hhEmu, index,
					pstPRI->pstcEmuKeyTbl1, pstPRI->iKeyTable1Entries);
        }

    // F1 thru F4, if they have been mapped to the top row of the
    // numeric keypad (Numlock, /, *, -).
    //
    else if (fMovedPfKeys && (index = emuDecKbdKeyLookup(hhEmu,
			Key, pstPRI->pstcEmuKeyTbl2, pstPRI->iKeyTable2Entries)) != -1)
        {
        if (!fTest)
            emuDecSendKeyString(hhEmu, index,
					pstPRI->pstcEmuKeyTbl2, pstPRI->iKeyTable2Entries);
        }

#if FALSE	// HT doesn't know the state of the numlock.
    // Keypad Numeric Mode.
    //
    else if (fSearchKeypad && fKeypadNumeric &&
			(index = emuDecKbdKeyLookup(hhEmu, Key, pstPRI->pstcEmuKeyTbl3,
					pstPRI->iKeyTable3Entries)) != -1)
        {
        if (!fTest)
            emuDecSendKeyString(hhEmu, index,
					pstPRI->pstcEmuKeyTbl3, pstPRI->iKeyTable3Entries);
        }
#endif

    // Keypad Application Mode.
    //
    else if (fSearchKeypad && fKeypadApplication &&
			(index = emuDecKbdKeyLookup(hhEmu, Key, pstPRI->pstcEmuKeyTbl4,
					pstPRI->iKeyTable4Entries)) != -1)
        {
        if (!fTest)
            emuDecSendKeyString(hhEmu, index,
					pstPRI->pstcEmuKeyTbl4, pstPRI->iKeyTable4Entries);
        }

    // Cursor Key Mode.
    //
    else if (fCursorKeyMode &&
			(index = emuDecKbdKeyLookup(hhEmu, Key, pstPRI->pstcEmuKeyTbl5,
					pstPRI->iKeyTable5Entries)) != -1)
        {
        if (!fTest)
            emuDecSendKeyString(hhEmu, index,
					pstPRI->pstcEmuKeyTbl5, pstPRI->iKeyTable5Entries);
        }

    // User defined keys.
    //
    else if (fSearchUDK &&
			(index = emuDecKbdKeyLookup(hhEmu, Key, pstPRI->pstUDK,
					pstPRI->iUDKTableEntries)) != -1)
        {
        if (!fTest)
            emuDecSendKeyString(hhEmu, index, pstPRI->pstUDK,
					pstPRI->iUDKTableEntries);
        }

    // Standard keys.
    //
    else if ((index = emuDecKbdKeyLookup(hhEmu, Key,
			pstPRI->pstcEmuKeyTbl6, pstPRI->iKeyTable6Entries)) != -1)
        {
        if (!fTest)
            {
            emuDecSendKeyString(hhEmu, index,
					pstPRI->pstcEmuKeyTbl6, pstPRI->iKeyTable6Entries);
            }
        }

    // Standard characters.
    //
    else
        {
        //DbgOutStr("VT100Kbdin calling std_kbdin", 0, 0, 0, 0, 0);

        index = std_kbdin(hhEmu, Key, fTest);
        }

    return index;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emuDecKbdKeyLookup
 *
 * DESCRIPTION:
 *  Main keyboard translation routine for all emulators.  Note, this
 *  routine will not lookup keys unless the iUseTermKeys flag is set.
 *
 * ARGUMENTS:
 *  HHEMU hhEmu - Internal emulator handle
 *  UINT    key - lower byte is char or virtual key, upper byte has flags
 *
 * RETURNS:
 *  Index if translated, else minus one.
 *
 */
int emuDecKbdKeyLookup(const HHEMU hhEmu,
                    const KEYDEF Key,
                    PSTCEMUKEYDATA pstKeyTbl,
                    const int iMaxEntries)
    {
    PSTCEMUKEYDATA pstKey = pstKeyTbl;

    int idx,
        iRet;

    // There is no need to look for the key if the user has
    // the terminal set up for accelerator keys.
    //
    if (hhEmu->stUserSettings.nTermKeys == EMU_KEYS_ACCEL)
        {
        return -1;
        }

    // Do a linear search through the supplied table for the given
    // key.  Once it is found, return that index, or return (-1) if
    // the key is not located.
    //
    iRet = (-1);

    // The VT220 and VT320 key tables have user defined key tables
    // that have empty sequence entries in them, unless they have been
    // defined by the host. So, if they're empty, we're not going to
    // report them as keys that have been found.
    //
    for (idx = 0; idx < iMaxEntries; idx++, pstKey++)
        {
        if (pstKey->Key == Key && pstKey->iSequenceLen != 0)
            {
            iRet = idx;
            break;
            }
        }

    return iRet;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecSendKeyString
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *   nothing
 */
void emuDecSendKeyString(const HHEMU hhEmu, const int iIndex,
                        PSTCEMUKEYDATA pstcKeyTbl, const int iMaxEntries)
    {
    PSTCEMUKEYDATA      pstKeyData = pstcKeyTbl + iIndex;
    const PSTDECPRIVATE pstPRI     = (PSTDECPRIVATE)hhEmu->pvPrivate;
    const int           fUDK       = (pstcKeyTbl == pstPRI->pstUDK) ? 1 : 0;
	int iLen;
    unsigned int        iLeadByte;
    TCHAR *             pchLeadChar = NULL;
	ECHAR               str[80];

    if (pstcKeyTbl == 0)
        {
        assert(FALSE);
        return;
        }

 	ECHAR_Fill(str, TEXT('\0'), sizeof(str)/sizeof(ECHAR));

    // If we are processing VT52 or VT100 keys, call the standard
    // send string function.  The VT100 doesn't switch between 7 and 8
    // bit controls.
    //
    if (hhEmu->nEmuLoaded == EMU_VT100 || hhEmu->nEmuLoaded == EMU_VT52)
        {
        emuVT220SendKeyString(hhEmu, iIndex, pstcKeyTbl, iMaxEntries);
        return;
        }

    // 7-bit controls don't apply to the user defined sequences.
    // Also, because empty key sequences are defined in the User Defined
    // Key Table, it is possible that the key sequence value is NULL. So,
    // we'll process the User Defined Key here, checking the sequence
    // before we try to operate on it.
    //
    if (fUDK)
        {
        if (pstKeyData->pSequence)
            {
            emuVT220SendKeyString(hhEmu, iIndex, pstcKeyTbl, iMaxEntries);
            }

        return;
        }

    // If we are are sending 8 bit codes, process the key directly
    // from the key table, as usual.
    //
    if (hhEmu->fUse8BitCodes)
        {
        emuVT220SendKeyString(hhEmu, iIndex, pstcKeyTbl, iMaxEntries);
        return;
        }

    // If we are processing 7 bit codes, the first character in the
    // sequence defined in the key table will be replaced with its 7-bit
    // value, sometimes.
    //
    iLeadByte = *(pstKeyData->pSequence);

    switch(iLeadByte)
        {
    case 0x84:
        // Send Esc - D
        //
        pchLeadChar = TEXT("\x1B\x44\x00");
        break;

    case 0x8F:
        // Send Esc - O
        //
        pchLeadChar = TEXT("\x1B\x4F\x00");
        break;

    case 0x9B:
        // Send Esc - [
        //
        pchLeadChar = TEXT("\x1B\x5B\x00");
        break;

    default:
        // Send sequence as defined in the key table.
        //
        pchLeadChar = TEXT("\x00");
        break;
        }

    // If we are sending a 7-bit version of the sequence, it gets sent out
    // in two pieces, otherwise send the sequence as it is defined
    // in the key table.
    //
    if (*pchLeadChar)
        {
		CnvrtMBCStoECHAR(str, sizeof(str), pchLeadChar,
				         StrCharGetByteCount(pchLeadChar));
		iLen = StrCharGetEcharByteCount(str);
		CnvrtMBCStoECHAR(&str[iLen], sizeof(str) - iLen, 
				         pstKeyData->pSequence + 1, 
				         StrCharGetByteCount(pstKeyData->pSequence + 1));
		emuSendString(hhEmu, str, StrCharGetEcharByteCount(str));
        }
    else
        {
        emuVT220SendKeyString(hhEmu, iIndex, pstcKeyTbl, iMaxEntries);
        }

    return;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuVT220SendKeyString
 *
 * DESCRIPTION:
 *  Sends the specified string.
 *
 *	This is a VT220 specific replacement for emuSendKeyString in emu.c. It's
 *  the emuSendKeyString from \shared\emulator\emu.c.
 *
 * ARGUMENTS:
 *  hhEmu       - The internal emulator handle.
 *  nIndex      - Position of key in keytable array.
 *  pstKeyTbl   - Address of key strings table.
 *
 * RETURNS:
 *  nothing
 *
 */
void emuVT220SendKeyString(const HHEMU hhEmu,
                        const int iIndex,
                        PSTCEMUKEYDATA pstcKeyTbl,
                        const int iMaxEntries)
    {
	ECHAR  str[80];
    PSTCEMUKEYDATA pstKeyData = pstcKeyTbl + iIndex;

 	memset(str, 0, sizeof(str));
	
	if (iIndex < 0 || iIndex >= iMaxEntries)
        {
        assert(FALSE);
        return;
        }

    pstKeyData = pstcKeyTbl + iIndex;

    #if defined(_DEBUG)

    DbgOutStr("%s", pstcKeyTbl[iIndex].pszKeyName, 0, 0, 0, 0);

    #endif

    if (pstKeyData->iSequenceLen > 0)
        {
		CnvrtMBCStoECHAR(str, sizeof(str), pstKeyData->pSequence, 
				         StrCharGetByteCount(pstKeyData->pSequence));
		emuSendString(hhEmu, str, StrCharGetEcharByteCount(str));
        }
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecEL
 *
 * DESCRIPTION:
 *  Erase In Line (EL).  This control function erases characters from
 *  part or all of the current line.  When you erase complete lines, they
 *  become single height and single width, with all character attributes
 *  cleared.
 *
 *  Selective Erase in Display (SED).  This control function lets you
 *  erase some or all of the erasable characters in the display.  DECSED
 *  cam only erase characters defined as erasable by the DECSCA control
 *  function.  A selective erase is controled by the DEC_private flag
 *  in the emulator handle.  This is dealt with in the lower level
 *  function that does the actual erasing.
 *
 * ARGUMENTS:
 *  hhEmu   -   The internal emulator handle.
 *
 * RETURNS:
 *   nothing
 */
void emuDecEL(const HHEMU hhEmu)
    {
    int iClearType;

    switch (hhEmu->selector[0])
        {
    case 0:
    case 0x0F:
    case 0xF0:
        if (hhEmu->emu_curcol == 0)
            iClearType = CLEAR_ENTIRE_LINE;
        else
            iClearType = CLEAR_CURSOR_TO_LINE_END;

        break;

    case 1:
    case 0xF1:
        iClearType = CLEAR_LINE_START_TO_CURSOR;
        break;

    case 2:
    case 0xF2:
        iClearType = CLEAR_ENTIRE_LINE;
        break;

    default:
        commanderror(hhEmu);
        return;
        }

    emuDecClearLine(hhEmu, iClearType);
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuDecClearLine
 *
 * DESCRIPTION:
 *  Erases some or all of the virtual screen image.
 *
 * ARGUMENTS:
 *  HHEMU hhEmu         -   The internal emulator handle.
 *
 *  int iClearSelect    -   CLEAR_CURSOR_TO_LINE_END      0
 *                      -   CLEAR_LINE_START_TO_CURSOR    1
 *                      -   CLEAR_ENTIRE_LINE             2
 *
 *
 * RETURNS:
 *  nothing
 *
 */
void emuDecClearLine(const HHEMU hhEmu, const int iClearSelect)
    {
    register int	iCurrentImgRow, iCol;
	ECHAR	*		pechText = 0;
    PSTATTR			pstCell = 0;

    const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

    iCurrentImgRow = row_index(hhEmu, hhEmu->emu_currow);

    pstCell = hhEmu->emu_apAttr[iCurrentImgRow];
    pechText = hhEmu->emu_apText[iCurrentImgRow];

    switch (iClearSelect)
        {
    case CLEAR_CURSOR_TO_LINE_END:

        // Clear the current line from the current cursor position
        // through the end of the user's maximum screen width.
        //
        for(iCol = hhEmu->emu_curcol; iCol <= hhEmu->emu_maxcol; iCol++)
            {
            // If we're in DEC private mode and the character is
            // protected, don't do anything with it.
            //
            if (hhEmu->DEC_private && pstCell[iCol].protect)
                {
                continue;
                }

            // OK, clear the character and it's attribute at this column
            // location.
            //
			pechText[iCol] = (ECHAR)EMU_BLANK_CHAR;
            pstCell[iCol] = hhEmu->emu_clearattr;
            }

        // Adjust the array that contains the column number of the last
        // character in this row.
        //
        if (hhEmu->emu_curcol <= hhEmu->emu_aiEnd[iCurrentImgRow])
            {
            hhEmu->emu_aiEnd[iCurrentImgRow] = max(hhEmu->emu_curcol - 1, 0);
            }

        break;

    case CLEAR_LINE_START_TO_CURSOR:

        // Clear the range from the beginning of the line, through the
        // current cursor position.
        //
        for(iCol = 0; iCol <= hhEmu->emu_curcol; iCol++)
            {
            // If we're in DEC private mode and the character is
            // protected, don't do anything with it.
            //
            if (hhEmu->DEC_private && pstCell[iCol].protect)
                {
                continue;
                }

            // OK, clear the character and it's attribute at this column
            // location.
            //
			pechText[iCol] = (ECHAR)EMU_BLANK_CHAR;
            pstCell[iCol] = hhEmu->emu_clearattr;
            }

        // Adjust the array value that contains the column number
        // of the last character in this row.
        //
        if (hhEmu->emu_curcol >= hhEmu->emu_aiEnd[iCurrentImgRow])
            {
            hhEmu->emu_aiEnd[iCurrentImgRow] = EMU_BLANK_LINE;
            }

        break;

    case CLEAR_ENTIRE_LINE:

        // The entire line needs to be cleared, but we only want
        // to put the user defined size of the emulator into the
        // backscroll buffer.
        //
		backscrlAdd(sessQueryBackscrlHdl(hhEmu->hSession),
						pechText, hhEmu->emu_maxcol + 1);

        if (hhEmu->DEC_private)
            emuDecClearImageRowSelective(hhEmu, hhEmu->emu_currow);
        else
            clear_imgrow(hhEmu, hhEmu->emu_currow);

        pstPRI->aiLineAttr[iCurrentImgRow] = NO_LINE_ATTR;

        break;

    default:
        commanderror(hhEmu);
        }

    (*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, hhEmu->emu_curcol);

    // Added a global to save the clear attribute at the time of
    // notification.  This is necessary since the message is posted
    // and a race condition can develop.
    //
    hhEmu->emu_clearattr_sav = hhEmu->emu_clearattr;

	updateLine(sessQueryUpdateHdl(hhEmu->hSession), 0, hhEmu->emu_currow);
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuVT220ED
 *
 * DESCRIPTION:
 *  Erase In Display (ED).  This control function erases characters from
 *  part or all of the display.  When you erase complete lines, they
 *  become single height and single width, with all character attributes
 *  cleared.
 *
 *  Selective Erase in Display (SED).  This control function lets you
 *  erase some or all of the erasable characters in the display.  DECSED
 *  cam only erase characters defined as erasable by the DECSCA control
 *  function.  A selective erase is controled by the DEC_private flag
 *  in the emulator handle.  This is dealt with in the lower level
 *  function that does the actual erasing.
 *
 * ARGUMENTS:
 *  hhEmu   -   The internal emulator handle.
 *
 * RETURNS:
 *   nothing
 */
void emuVT220ED(const HHEMU hhEmu)
    {
    int iClearType;

    switch (hhEmu->selector[0])
        {
    case 0:
    case 0x0F:
    case 0xF0:
        if (hhEmu->emu_currow == 0  && hhEmu->emu_curcol == 0)
            iClearType = CLEAR_ENTIRE_SCREEN;
        else
            iClearType = CLEAR_CURSOR_TO_SCREEN_END;

        break;

    case 1:
    case 0xF1:
        iClearType = CLEAR_SCREEN_START_TO_CURSOR;
        break;

    case 2:
    case 0xF2:
        iClearType = CLEAR_ENTIRE_SCREEN;
        break;

    default:
        commanderror(hhEmu);
        return;
        }

    emuDecEraseScreen(hhEmu, iClearType);
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *  emuDecEraseScreen
 *
 * DESCRIPTION:
 *  Erases some or all of the virtual screen image.
 *
 * ARGUMENTS:
 *  HHEMU hhEmu         -   The internal emulator handle.
 *
 *  int iClearSelect    -   CLEAR_CURSOR_TO_SCREEN_END      0
 *                      -   CLEAR_SCREEN_START_TO_CURSOR    1
 *                      -   CLEAR_ENTIRE_SCREEN             2
 *
 *
 * RETURNS:
 *  nothing
 *
 */
void emuDecEraseScreen(const HHEMU hhEmu, const int iClearSelect)
    {
    register int	iRow;
    int				trow,
					iStartRow, iEndRow,
					tcol,
					iVirtualRow,
					iLineLen;
	ECHAR			aechBuf[10];

	ECHAR	*		pechText = 0;
    PSTATTR			pstCell = 0;


    const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

    trow = hhEmu->emu_currow;
    tcol = hhEmu->emu_curcol;

    switch (iClearSelect)
        {
    case CLEAR_CURSOR_TO_SCREEN_END:

        // Note that the calling function (emuDecED) changes iClearSelect
        // to CLEAR_ENTIRE_SCREEN if CLEAR_CURSOR_TO_SCREEN_END was
        // issued with a current cursor position at (0,0).  Clearing
        // the entire screen pushes the screen image into the backscroll
        // buffer, the capture file, and to the printer.  Anything less
        // than that simply gets cleared from the display.  Now...

        // Clear the range from one line below the current cursor position
        // through the end of the user's maximum screen size.
        //
        for (iRow = hhEmu->emu_currow + 1; iRow <= hhEmu->emu_maxrow; iRow++)
            {
            if (hhEmu->DEC_private)
                emuDecClearImageRowSelective(hhEmu, iRow);
            else
                clear_imgrow(hhEmu, iRow);
            }

        // Now clear the characters and attributes from the partial
        // row that the cursor was on.
        //
		emuDecClearLine(hhEmu, CLEAR_CURSOR_TO_LINE_END);

        // Identify the range of line attributes that need to be cleared,
        // and clear them.
        //
        if (hhEmu->emu_curcol == 0)
            iStartRow = hhEmu->emu_currow;
        else
            iStartRow = hhEmu->emu_currow + 1;

        iStartRow = min(iStartRow, hhEmu->emu_maxrow);

        iEndRow = hhEmu->emu_maxrow;

        if (iStartRow >= 0)
            {
            for(iRow = iStartRow; iRow <= iEndRow; iRow++)
                pstPRI->aiLineAttr[iRow] = NO_LINE_ATTR;
            }

        // Finally, update the image.
        //
		updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
						0,
						hhEmu->emu_maxrow,
						hhEmu->emu_maxrow + 1,
						hhEmu->emu_imgtop,
						TRUE);

        (*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, hhEmu->emu_curcol);

        // Added a global to save the clear attribute at the time of
        // notification.  This is necessary since the message is posted
        // and a race condition can develop.
        //
        hhEmu->emu_clearattr_sav = hhEmu->emu_clearattr;

		NotifyClient(hhEmu->hSession, EVENT_EMU_CLRATTR, 0);

        break;

    case CLEAR_SCREEN_START_TO_CURSOR:

        // Clear the range from the first row, to one row above the
        // current cursor position.
        //
        for (iRow = 0; iRow < hhEmu->emu_currow; iRow++)
            {
            if (hhEmu->DEC_private)
                emuDecClearImageRowSelective(hhEmu, iRow);
            else
                clear_imgrow(hhEmu, iRow);
            }

        // Now clear the partial (current) row.
        //
		emuDecClearLine(hhEmu, CLEAR_LINE_START_TO_CURSOR);

        // Identify the range of line attributes that need to be cleared,
        // and clear them.
        //
        iStartRow = 0;

        if (hhEmu->emu_curcol == hhEmu->emu_maxcol)
            iEndRow = hhEmu->emu_currow;
        else
            iEndRow = hhEmu->emu_currow - 1;

        iEndRow = max(iEndRow, 0);

        if (iStartRow >= 0)
            {
            for(iRow = iStartRow; iRow <= iEndRow; iRow++)
                pstPRI->aiLineAttr[iRow] = NO_LINE_ATTR;
            }

        (*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow, hhEmu->emu_curcol);

		updateLine(sessQueryUpdateHdl(hhEmu->hSession), 0, hhEmu->emu_currow);

        break;

    case CLEAR_ENTIRE_SCREEN:

        // The entire buffer needs to be cleared, but we only want
        // to put the user defined size of the emualtor into the
        // backscroll buffer, capture file and print file.
        //
        for (iRow = 0; iRow < MAX_EMUROWS; iRow++)
            {
            if (iRow <= hhEmu->emu_maxrow)
                {
                iVirtualRow = row_index(hhEmu, iRow);
                iLineLen    = emuRowLen(hhEmu, iVirtualRow);
                pechText    = hhEmu->emu_apText[iVirtualRow];

				backscrlAdd(sessQueryBackscrlHdl(hhEmu->hSession),
						pechText, iLineLen);

				CaptureLine(sessQueryCaptureFileHdl(hhEmu->hSession),
						CF_CAP_SCREENS, pechText, iLineLen);

				printEchoScreen(hhEmu->hPrintEcho, pechText, iVirtualRow);

				CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT("\r\n"), 
						         StrCharGetByteCount(TEXT("\r\n")));

				printEchoScreen(hhEmu->hPrintEcho, aechBuf, sizeof(ECHAR) * 2);

                if (hhEmu->DEC_private)
                    emuDecClearImageRowSelective(hhEmu, iRow);
                else
                    clear_imgrow(hhEmu, iRow);
                }
            else
                {
                clear_imgrow(hhEmu, iRow);
                }

            pstPRI->aiLineAttr[iRow] = NO_LINE_ATTR;
            }

        // Scroll the imgae.
        //
		updateScroll(sessQueryUpdateHdl(hhEmu->hSession),
						0,
						hhEmu->emu_maxrow,
						hhEmu->emu_maxrow + 1,
						hhEmu->emu_imgtop,
						TRUE);

        // Added a global to save the clear attribute at the time of
        // notification.  This is necessary since the message is posted
        // and a race condition can develop.

        hhEmu->emu_clearattr_sav = hhEmu->emu_clearattr;

		NotifyClient(hhEmu->hSession, EVENT_EMU_CLRATTR, 0);
        break;

    default:
        commanderror(hhEmu);
        }

    (*hhEmu->emu_setcurpos)(hhEmu, trow, tcol);
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  emuDecClearImageRowSelective
 *
 * DESCRIPTION:
 *  This function clears the characters and attributes from the supplied
 *  row, taking into account the protected bit in the character
 *  attributes.  It only clears those characters that are NOT protected.
 *
 * ARGUMENTS:
 *  HHEMU hhEmu         -   The internal emulator handle.
 *
 *  int iRow            -   The row to clear.
 *
 * RETURNS:
 *  nothing
 */
void emuDecClearImageRowSelective(const HHEMU hhEmu, const int iImageRow)
    {
    register int i, iRow;
	ECHAR	*pechText = 0;
    PSTATTR  pstCell = 0;

    iRow = row_index(hhEmu, iImageRow);

    pstCell = hhEmu->emu_apAttr[iRow];
    pechText = hhEmu->emu_apText[iRow];

    // Clear only the characters (and attributes) of the non-protected
    // characters.
    //
    for (i = 0; i < MAX_EMUCOLS; i++)
        {
        if ( pstCell[i].protect == 0 )
            {
            pstCell[i] = hhEmu->emu_clearattr;
			pechText[i] = EMU_BLANK_CHAR;
            }

        if (pechText[i] != EMU_BLANK_CHAR)
            hhEmu->emu_aiEnd[iRow] = i;
        }

    return;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuDecUnload
 *
 * DESCRIPTION:
 *   Unloads current emulator by freeing used memory.
 *
 * ARGUMENTS:
 *   none
 *
 * RETURNS:
 *   nothing
 */
void emuDecUnload(const HHEMU hhEmu)
    {
    const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

    PSTEMUKEYDATA pstKey = pstPRI->pstUDK;

    int idx;

    if (pstPRI)
        {
        // Clear the line attribute array.
        //
        if (pstPRI->aiLineAttr)
            {
            free(pstPRI->aiLineAttr);
            pstPRI->aiLineAttr = 0;
            }

        // Cycle through the user defined key table and free
        // any memory that may have been allocated for sequences.
        //
        if (pstKey)
            {
            for (idx = 0; idx < MAX_UDK_KEYS; idx++, pstKey++)
                {
                if (pstKey->iSequenceLen != 0)
                    {
                    free(pstKey->pSequence);
                    pstKey->iSequenceLen = 0;
                    }
                }
            }

        free(pstPRI);
        //pstPRI = NULL; //mpt:12-21-98 cannot modify a const object

        hhEmu->pvPrivate = NULL;
        }

    return;
    }
#endif // INCL_VT220

/* end of VT220.C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\vt52init.c ===
/*	File: D:\WACKER\emu\vt52init.c (Created: 28-Dec-1993)
 *
 *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 5/09/01 4:48p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\assert.h>
#include <tdll\mc.h>
#include <tdll\backscrl.h>
#include <tdll\htchar.h>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"
#include "emudec.hh"
#include "keytbls.h"

static void vt52char_reset(const HHEMU hhEmu);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt52_init
 *
 * DESCRIPTION:
 *	 Loads and initializes the VT52 emulator.
 *
 * ARGUMENTS:
 *	 new_emu -- TRUE if emulating a power up on the real thing.
 *
 * RETURNS:
 *	 nothing
 */
void vt52_init(const HHEMU hhEmu)
	{
	PSTDECPRIVATE pstPRI;

	static struct trans_entry const vt52_tbl[] =
		{
		{NEW_STATE, 0, 0, 0}, // State 0
		{0, ETEXT('\x20'),	ETEXT('\x7E'),	emuStdGraphic}, 	// Space - ~
		{1, ETEXT('\x1B'),	ETEXT('\x1B'),	nothing},			// Esc
		{0, ETEXT('\x07'),	ETEXT('\x07'),	emu_bell},			// Ctrl-G
		{0, ETEXT('\x08'),	ETEXT('\x08'),	vt_backspace},		// Backspace
		{0, ETEXT('\x09'),	ETEXT('\x09'),	tabn},				// Tab
		{0, ETEXT('\x0A'),	ETEXT('\x0A'),	emuLineFeed},		// New Line
		{0, ETEXT('\x0D'),	ETEXT('\x0D'),	carriagereturn},	// CR
		{5, ETEXT('\x18'),	ETEXT('\x18'),	EmuStdChkZmdm}, 	// Ctrl-X

		{NEW_STATE, 0, 0, 0}, // State 1						// Esc
		{2, ETEXT('\x59'),	ETEXT('\x59'),	nothing},			// Y
		{0, ETEXT('\x3C'),	ETEXT('\x3C'),	vt52_toANSI},		// <
		{0, ETEXT('\x3D'),	ETEXT('\x3E'),	vt_alt_kpmode}, 	// = - >
		{0, ETEXT('\x41'),	ETEXT('\x41'),	ANSI_CUU},			// A
		{0, ETEXT('\x42'),	ETEXT('\x42'),	ANSI_CUD},			// B
		{0, ETEXT('\x43'),	ETEXT('\x43'),	ANSI_CUF},			// C
		{0, ETEXT('\x44'),	ETEXT('\x44'),	vt_CUB},			// D
		{0, ETEXT('\x46'),	ETEXT('\x47'),	vt_charshift},		// F - G
		{0, ETEXT('\x48'),	ETEXT('\x48'),	ANSI_CUP},			// H
		{0, ETEXT('\x49'),	ETEXT('\x49'),	ANSI_RI},			// I
		{0, ETEXT('\x4A'),	ETEXT('\x4A'),	ANSI_ED},			// J
		{0, ETEXT('\x4B'),	ETEXT('\x4B'),	ANSI_EL},			// K
		{0, ETEXT('\x56'),	ETEXT('\x56'),	vt52PrintCommands}, // V
		{4, ETEXT('\x57'),	ETEXT('\x57'),	nothing},			// W
		{0, ETEXT('\x58'),	ETEXT('\x58'),	nothing},			// X
		{0, ETEXT('\x5A'),	ETEXT('\x5A'),	vt52_id},			// Z
		{0, ETEXT('\x5D'),	ETEXT('\x5D'),	vt52PrintCommands}, // ]
		{0, ETEXT('\x5E'),	ETEXT('\x5E'),	vt52PrintCommands}, // ^
		{0, ETEXT('\x5F'),	ETEXT('\x5F'),	vt52PrintCommands}, // _

		{NEW_STATE, 0, 0, 0}, // State 2						// EscY
		// Accept all data--CUP will set the limits. Needed for more than 24 rows.
		{3, ETEXT('\x00'),	ETEXT('\xFF'),	char_pn},			// Space - 8
//		{3, ETEXT('\x20'),	ETEXT('\x38'),	char_pn},			// Space - 8

		{NEW_STATE, 0, 0, 0}, // State 3						// EscYn
		// Accept all data--CUP will set the limits. Needed for more than 80 columns.
		{0, ETEXT('\x00'),	ETEXT('\xFF'),	vt52_CUP},			// Space - o
//		{0, ETEXT('\x20'),	ETEXT('\x6F'),	vt52_CUP},			// Space - o

		{NEW_STATE, 0, 0, 0}, // State 4						// EscW
		{4, ETEXT('\x00'),	ETEXT('\xFF'),	vt52Print}, 		// All

		{NEW_STATE, 0, 0, 0}, // State 5						// Ctrl-X
		{5, ETEXT('\x00'),	ETEXT('\xFF'),	EmuStdChkZmdm}, 	// All

		};

	emuInstallStateTable(hhEmu, vt52_tbl, DIM(vt52_tbl));

	// Allocate space for and initialize data that is used only by the
	// VT52 emulator.
	//
	if (hhEmu->pvPrivate != 0)
		{
		free(hhEmu->pvPrivate);
		hhEmu->pvPrivate = 0;
		}

	hhEmu->pvPrivate = malloc(sizeof(DECPRIVATE));

	if (hhEmu->pvPrivate == 0)
		{
		assert(FALSE);
		return;
		}

	pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;
	CnvrtMBCStoECHAR(pstPRI->terminate, sizeof(pstPRI->terminate), TEXT("\033X"),
                     StrCharGetByteCount(TEXT("\033X")));
	pstPRI->len_t = 2;
	pstPRI->pntr = pstPRI->storage;
	pstPRI->len_s = 0;

	// Initialize standard hhEmu values.
	//
	hhEmu->emu_kbdin 	= vt52_kbdin;
	hhEmu->emu_highchar = 0x7E;
	hhEmu->emu_deinstall = emuVT52Unload;	
	
	vt52char_reset(hhEmu);

//	emuKeyTableLoad(hhEmu, IDT_VT52_KEYS, &hhEmu->stEmuKeyTbl);
//	emuKeyTableLoad(hhEmu, IDT_VT52_KEYPAD_APP_MODE, &hhEmu->stEmuKeyTbl2);
//	emuKeyTableLoad(hhEmu, IDT_VT_MAP_PF_KEYS, &hhEmu->stEmuKeyTbl3);
	emuKeyTableLoad(hhEmu, VT52KeyTable, 
					 sizeof(VT52KeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl);
	emuKeyTableLoad(hhEmu, VT52_Keypad_KeyTable, 
					 sizeof(VT52_Keypad_KeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl2);
	emuKeyTableLoad(hhEmu, VT_PF_KeyTable, 
					 sizeof(VT_PF_KeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl3);

	backscrlSetShowFlag(sessQueryBackscrlHdl(hhEmu->hSession), TRUE);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt52char_reset
 *
 * DESCRIPTION:
 *	 Sets the VT52 emulator character set to its RESET conditions.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
static void vt52char_reset(const HHEMU hhEmu)
	{
	// Set up US ASCII character set as G0 and DEC graphics as G1
	//
	vt_charset_init(hhEmu);
	hhEmu->emu_code = ETEXT(')');
	vt_scs1(hhEmu);
	hhEmu->emu_code = (ECHAR)0;
	vt_scs2(hhEmu);
	}

/* end of vt52init.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\vtemu.hh ===
/*	File: D:\WACKER\emu\vtemu.hh (Created: 08-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 4 $
 *	$Date: 5/21/01 4:34p $
 */

/* maxcol definitions */
/* they're one more than normal, line won't wrap until next CHAR to display */
#define VT_MAXCOL_80MODE	80
#define VT_MAXCOL_132MODE	132

/* from autoinit.c */
void emuAutoInit(void);

/* from ansiinit.c */
void emuAnsiInit(void);
void csrv_init(const int new_emu);
int emuAnsiReset(const int);

/* from ansi.c */
VOID ansi_setmode(VOID);
VOID ansi_resetmode(VOID);
VOID ansi_savecursor(VOID);
int ansi_kbdin(int key, const int fTest);

/* from vt52init.c */
void vt52_init(void);

/* from vt52.c */
VOID vt52PrintCommands(VOID);
void vt52Print(void);
VOID vt52_id(VOID);
VOID vt52_CUP(VOID);
INT  vt52_kbdin(int key, const BOOL fTest);

/* from vt100.c */
VOID ANSI_DA(VOID);
VOID vt100_savecursor(VOID);
VOID vt100_answerback(VOID);
VOID vt100_hostreset(VOID);
int  vt100_reset(const int);
VOID vt100_report(VOID);
int  vt100_kbdin(int key, const int);
int  fakevt_kbdin(int key, const int);

/* from vt100ini.c */
VOID wang_init(BOOL new_emu);
VOID ibm3278_init(BOOL new_emu);
VOID renx_init(BOOL new_emu);
void vt100_init(void);

/* from vt220ini.c */
VOID vt220_init(BOOL new_emu);
VOID vt220_savekeys(BOOL save_ptrs);

/* from vtutf8ini.c */
void vtutf8_init(const HHEMU hhEmu);

/* from vt220.c */
VOID vt220_hostreset(VOID);
UINT vt220_reset(BOOL host_request);
VOID vt220_softreset(VOID);
VOID vt220mode_reset(VOID);
VOID vt220_DA(VOID);
VOID vt220_2ndDA(VOID);
VOID vt220_clearkey(VOID);
VOID vt220_definekey(VOID);
VOID vt220_level(VOID);
int  vt220_kbdin(int key, const BOOL fTest);
VOID vt220_protectinsert(BOOL line_only);
VOID vt220_protectdelete(BOOL line_only);
VOID vt220_protmode(VOID);
VOID vt220_protect_IL(int toprow);
VOID vt220_protect_DL(int toprow);
VOID vt220_clearprotect(INT fromrow, INT fromcol, INT torow, INT tocol);
BOOL vt220_isprotected(INT row, INT col);
VOID vt220_deinstall(BOOL quitting);
VOID vt220_scroll(INT nlines, BOOL direction);
VOID vt220_scrollup(INT nlines);
VOID vt220_scrolldown(INT nlines);

/* from vt_chars.c */
VOID vt_charset_init(VOID);
VOID vt_charset_save(VOID);
VOID vt_charset_restore(VOID);
VOID vt_scs1(VOID);
VOID vt_scs2(VOID);
VOID vt_charshift(VOID);
#if defined(EXTENDED_FEATURES)
int  vt_char_emulatecmd(const HHEMU hhEmu, const ECHAR ccode);
#else
int  vt_char_emulatecmd(const HEMU hEmu, const ECHAR ccode);
#endif

/* from vt_xtra.c */
VOID ANSI_DSR(VOID);
VOID ANSI_RM(VOID);
VOID ANSI_SM(VOID);
VOID vt_alt_kpmode(VOID);
VOID vt_screen_adjust(VOID);
VOID vt_shiftscreen(INT key);
VOID vt_kbdlocked(INT key);
VOID vt_scrollrgn(VOID);
VOID DEC_STBM(INT top, INT bottom);
VOID vt52_toANSI(VOID);
VOID vt_DCH(VOID);
VOID vt_IL(VOID);
VOID vt_DL(VOID);
void vt_clearline(const int);
void vt_clearscreen(const int);
VOID vt_graphic(VOID);
VOID vt_backspace(VOID);
VOID vt_CUB(VOID);

// From vt100.c
//
void vt100PrintCommands(void);
VOID vt100_prnc(VOID);

extern TCHAR *vt220_protimg;	/* address of protected bytes map */

/* end of vtemu.hh */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\ext\fspage.c ===
/*	File: D:\wacker\ext\fspage.c (Created: 01-Mar-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 2/05/99 3:20p $
 */

#define _INC_OLE		// WIN32, get ole2 from windows.h
#define CONST_VTABLE

#include <windows.h>
#pragma hdrstop

#include <windowsx.h>
//#include <shell2.h>
#include <shlobj.h>

#include <tdll\stdtyp.h>
#include <tdll\globals.h>
#include <tdll\tdll.h>
#include <term\res.h>
#include <tdll\assert.h>
#include <tdll\mc.h>

#include "pageext.hh"

#include <tdll\session.h>
#include <tdll\sf.h>
#include <tdll\property.h>
#include <cncttapi\cncttapi.h>

//
// Function prototype
//
UINT CALLBACK FSPage_ReleasePage(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE psp);

//---------------------------------------------------------------------------
//
// FSPage_AddPages
//
//  This function is called from CSamplePageExt::AddPages(). It add a page
// if the data object contains file system objects.
//
//---------------------------------------------------------------------------
void FSPage_AddPages(LPDATAOBJECT pdtobj,
		     LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
	{
    //
    // Call IDataObject::GetData asking for a CF_HDROP (i.e., HDROP).
    //
    FORMATETC fmte = {
        	CF_HDROP,
        	(DVTARGETDEVICE FAR *)NULL,
			//DVASPECT_SHORTNAME,
			DVASPECT_CONTENT,
        	-1,
			TYMED_HGLOBAL};
    STGMEDIUM medium;
    HRESULT hres = pdtobj->lpVtbl->GetData(pdtobj, &fmte, &medium);

    if (SUCCEEDED(hres))
		{
		//
		//	We need to make a copy of hdrop, because we can't hang on
		// to this medium.
		//
		UINT cbDrop = (UINT)GlobalSize(medium.hGlobal);
		HDROP hdrop = GlobalAlloc(GPTR, cbDrop);
		HSESSION hSession;

		hSession = CreateSessionHandle(NULL);

		if ((hdrop != NULL) && (hSession != NULL))
			{
			PROPSHEETPAGE psp;
			HPROPSHEETPAGE hpage;
			char szFile[MAX_PATH];

   			if (cbDrop)
                MemCopy((LPSTR)hdrop, GlobalLock(medium.hGlobal), cbDrop);

            GlobalUnlock(medium.hGlobal);

			/*
			 * We need to get a session handle that we can pass along to
			 * the property sheet dialogs.  This may take a little bit of
			 * work because the routines to create a session handle usually
			 * expect that there will be a session window.  Not in this case.
			 */

			DragQueryFile(hdrop, 0, szFile, sizeof(szFile));
			InitializeSessionHandle(hSession, NULL, NULL);

			sfOpenSessionFile(sessQuerySysFileHdl(hSession), szFile);
			sessLoadSessionStuff(hSession);

			//
			//	Create a property sheet page object from a dialog box.
			//
			//	We store the hdrop (a copy of medium.hGlobal) in lParam,
			// because it is the only instance data we need.
			//
			//	If the page needs more instance data, you can append
			// arbitrary size of data at the end of this structure,
			// and pass it to the CreatePropSheetPage. In such a case,
			// the size of entire data structure (including page specific
			// data) must be stored in the dwSize field.
			//
			psp.dwSize		= sizeof(psp);	// no extra data.
			psp.dwFlags 	= PSP_USEREFPARENT | PSP_USECALLBACK;
			psp.hInstance	= glblQueryDllHinst();
			psp.pszTemplate = MAKEINTRESOURCE(IDD_TAB_PHONENUMBER);
			psp.pfnDlgProc	= NewPhoneDlg;
			psp.pcRefParent = &g_cRefThisDll;
			psp.pfnCallback = FSPage_ReleasePage;
			psp.lParam		= (LPARAM)hSession;

			hpage = CreatePropertySheetPage(&psp);

			if (hpage)
				{
				if (!lpfnAddPage(hpage, lParam))
					DestroyPropertySheetPage(hpage);
				}

			// Do the terminal page now

			psp.dwSize		= sizeof(psp);	// no extra data.
			psp.dwFlags 	= PSP_USEREFPARENT;
			psp.hInstance	= glblQueryDllHinst();
			psp.pszTemplate = MAKEINTRESOURCE(IDD_TAB_TERMINAL);
			psp.pfnDlgProc	= TerminalTabDlg;
			psp.pcRefParent = &g_cRefThisDll;
			psp.pfnCallback = 0;
			psp.lParam		= (LPARAM)hSession;

			hpage = CreatePropertySheetPage(&psp);

			if (hpage)
				{
				if (!lpfnAddPage(hpage, lParam))
					DestroyPropertySheetPage(hpage);
				}

            /* Make sure we free this up here */
			GlobalFree(hdrop);
			}


		//
		// HACK: We are supposed to call ReleaseStgMedium. This is a temporary
		//	hack until OLE 2.01 for Chicago is released.
		//
		if (medium.pUnkForRelease)
			{
			medium.pUnkForRelease->lpVtbl->Release(medium.pUnkForRelease);
			}
		else
			{
			GlobalFree(medium.hGlobal);
			}
		}
	}

//
//
//
UINT CALLBACK FSPage_ReleasePage(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE psp)
	{
	HSESSION hSession;
	SF_HANDLE  hsf;

	switch (uMsg)
		{
		case PSPCB_RELEASE:
			hSession = (HSESSION)psp->lParam;
			hsf = sessQuerySysFileHdl(hSession);

			sessSaveSessionStuff(hSession);
			sfFlushSessionFile(hsf);
			DestroySessionHandle(hSession);
			hSession = NULL;

			break;
		}

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\ext\defclsf.c ===
/*	File: D:\wacker\ext\defclsf.c (Created: 02-Mar-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 2/05/99 3:20p $
 */

//
// This file contains the implementation of SHCreateDefClassObject
//

#define _INC_OLE		// WIN32, get ole2 from windows.h
#define CONST_VTABLE

#include <windows.h>
#pragma hdrstop

#include <windowsx.h>
#include <shellapi.h>
#include <shlobj.h>
#include "pageext.hh"

// Helper macro for C programmers

#define _IOffset(class, itf)         ((UINT_PTR)&(((class *)0)->itf))
#define IToClass(class, itf, pitf)   ((class  *)(((LPSTR)pitf)-_IOffset(class, itf)))
#define IToClassN(class, itf, pitf)  IToClass(class, itf, pitf)

#if 0
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	IsEqualGUID
 *
 * DESCRIPTION:
 *	By using this function, we keep from linking into OLE32.DLL.
 *
 */
STDAPI_(BOOL) IsEqualGUID(REFGUID guid1, REFGUID guid2)
	{
        return !memcmp(guid1, guid2, sizeof(GUID));
	}
#endif

//=========================================================================
// CDefClassFactory class
//=========================================================================

STDMETHODIMP CDefClassFactory_QueryInterface(IClassFactory FAR * pcf, REFIID riid, LPVOID FAR* ppvObj);
ULONG STDMETHODCALLTYPE CDefClassFactory_AddRef(IClassFactory FAR * pcf);
ULONG STDMETHODCALLTYPE CDefClassFactory_Release(IClassFactory FAR * pcf);
STDMETHODIMP CDefClassFactory_CreateInstance(IClassFactory FAR * pcf, LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              LPVOID FAR* ppvObject);
STDMETHODIMP CDefClassFactory_LockServer(IClassFactory FAR * pcf, BOOL fLock);

//
// CDefClassFactory: Class definition
//
//#pragma data_seg(DATASEG_READONLY)
static IClassFactoryVtbl c_vtblAppUIClassFactory =
	{
	CDefClassFactory_QueryInterface,
	CDefClassFactory_AddRef,
	CDefClassFactory_Release,
	CDefClassFactory_CreateInstance,
	CDefClassFactory_LockServer
	};

typedef struct
	{
    IClassFactory      cf;		
    UINT               cRef;		// Reference count
	LPFNCREATEINSTANCE lpfnCI;		// CreateInstance callback entry
    UINT FAR *         pcRefDll;	// Reference count of the DLL
	const IID FAR *    riidInst;	// Optional interface for instance
	} CDefClassFactory;

//
// CDefClassFactory::QueryInterface
//
STDMETHODIMP CDefClassFactory_QueryInterface(IClassFactory FAR * pcf, REFIID riid, LPVOID FAR* ppvObj)
	{
	register CDefClassFactory * this=IToClass(CDefClassFactory, cf, pcf);

    if (IsEqualIID(riid, &IID_IClassFactory)
			|| IsEqualIID(riid, &IID_IUnknown))
		{
		(LPCLASSFACTORY)*ppvObj = &this->cf;
		this->cRef++;
        return NOERROR;
		}

    return ResultFromScode(E_NOINTERFACE);
	}

//
// CDefClassFactory::AddRef
//
ULONG STDMETHODCALLTYPE CDefClassFactory_AddRef(IClassFactory FAR * pcf)
	{
	register CDefClassFactory * this=IToClass(CDefClassFactory, cf, pcf);
    return (++this->cRef);
	}

//
// CDefClassFactory::Release
//
ULONG STDMETHODCALLTYPE CDefClassFactory_Release(IClassFactory FAR * pcf)
	{
	register CDefClassFactory * this=IToClass(CDefClassFactory, cf, pcf);

    if (--this->cRef > 0)
		return this->cRef;

	if (this->pcRefDll)
		{
		(*this->pcRefDll)--;
		}

	LocalFree((HLOCAL)this);
    return 0;
	}

//
// CDefClassFactory::CDefClassFactory
//
STDMETHODIMP CDefClassFactory_CreateInstance(IClassFactory FAR * pcf, LPUNKNOWN pUnkOuter,
							  REFIID riid,
                              LPVOID FAR* ppvObject)
	{
	register CDefClassFactory * this=IToClass(CDefClassFactory, cf, pcf);

    //
    // We don't support aggregation at all.
	//
    if (pUnkOuter)
		return ResultFromScode(CLASS_E_NOAGGREGATION);

    //
    // if this->riidInst is specified, they should match.
    //
	if (this->riidInst==NULL || IsEqualIID(riid, this->riidInst)
			|| IsEqualIID(riid, &IID_IUnknown))
		{
		return this->lpfnCI(pUnkOuter, riid, ppvObject);
		}

    return ResultFromScode(E_NOINTERFACE);
	}

//
// CDefClassFactory::LockServer
//
STDMETHODIMP CDefClassFactory_LockServer(IClassFactory FAR * pcf, BOOL fLock)
	{
    // REVIEW: Is this appropriate?
    return ResultFromScode(E_NOTIMPL);
	}


//
// CDefClassFactory constructor
//
CDefClassFactory * NEAR PASCAL CDefClassFactory_Create(
		LPFNCREATEINSTANCE lpfnCI, UINT FAR * pcRefDll, REFIID riidInst)
	{
	register CDefClassFactory * pacf;

	pacf = (CDefClassFactory *)LocalAlloc(LPTR, sizeof(CDefClassFactory));
    if (pacf)
		{
		pacf->cf.lpVtbl = &c_vtblAppUIClassFactory;
		pacf->cRef++;  // pacf->cRef=0; (generates smaller code)
		pacf->pcRefDll = pcRefDll;
		pacf->lpfnCI = lpfnCI;
		pacf->riidInst = riidInst;

		if (pcRefDll)
			(*pcRefDll)++;

		}
    return pacf;
	}

//
// creates a simple default implementation of IClassFactory
//
// Parameters:
//  riid     -- Specifies the interface to the class object
//  ppv      -- Specifies the pointer to LPVOID where the class object pointer
//               will be returned.
//  lpfnCI   -- Specifies the callback entry for instanciation.
//  pcRefDll -- Specifies the address to the DLL reference count (optional)
//  riidInst -- Specifies the interface to the instance (optional).
//
// Notes:
//   The riidInst will be specified only if the instance of the class
//  support only one interface.
//
STDAPI SHCreateDefClassObject(REFIID riid, LPVOID FAR* ppv,
			 LPFNCREATEINSTANCE lpfnCI, UINT FAR * pcRefDll,
			 REFIID riidInst)
	{
	// The default class factory supports only IClassFactory interface

    if (IsEqualIID(riid, &IID_IClassFactory))
		{
		CDefClassFactory *pacf =
			CDefClassFactory_Create(lpfnCI, pcRefDll, riidInst);

		if (pacf)
			{
			(IClassFactory FAR *)*ppv = &pacf->cf;
			return NOERROR;
			}

		return ResultFromScode(E_OUTOFMEMORY);
		}

    return ResultFromScode(E_NOINTERFACE);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\ext\iconext.c ===
/*	File: D:\WACKER\ext\iconext.c (Created: 11-Mar-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 11/07/00 10:44a $
 */


#define _INC_OLE		// WIN32, get ole2 from windows.h
#define CONST_VTABLE
#define INITGUID

#include <windows.h>
#pragma hdrstop

#include <term\res.h>
//
// Initialize GUIDs (should be done only and at-least once per DLL/EXE)
//
#pragma data_seg(".text")
#include <objbase.h>
#include <initguid.h>
//#include <coguid.h>
//#include <oleguid.h>
#include <shlguid.h>
#include <shlobj.h>
#include "pageext.hh"
#pragma data_seg()

//
// Function prototypes
//
HRESULT CALLBACK PageExt_CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR*);
BOOL WINAPI TDllEntry(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);
BOOL WINAPI _CRT_INIT(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);

//
// Global variables
//
UINT g_cRefThisDll = 0; 	// Reference count of this DLL.
HINSTANCE hInstanceDll;

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	IconEntry
 *
 * DESCRIPTION:
 *	Currently, just initializes the C-Runtime library but may be used
 *	for other things later.
 *
 * ARGUMENTS:
 *	hInstDll	- Instance of this DLL
 *	fdwReason	- Why this entry point is called
 *	lpReserved	- reserved
 *
 * RETURNS:
 *	BOOL
 *
 */
BOOL WINAPI IconEntry(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
	{
	hInstanceDll = hInstDll;

	// You need to initialize the C runtime if you use any C-Runtime
	// functions.  Currently this is not the case execpt for memcmp
	// used in IsEqualGUID().  However, if we're compiling for release
	// we get the inline version of memcmp and so we don't need the
	// C-Runtime.

	#if defined(NDEBUG)
	return TRUE;
	#else
	return _CRT_INIT(hInstDll, fdwReason, lpReserved);
	#endif
	}

//---------------------------------------------------------------------------
// DllCanUnloadNow
//---------------------------------------------------------------------------

STDAPI DllCanUnloadNow(void)
	{
    return ResultFromScode((g_cRefThisDll==0) ? S_OK : S_FALSE);
	}

//---------------------------------------------------------------------------
//
// DllGetClassObject
//
//  This is the entry of this DLL, which all the In-Proc server DLLs should
// export. See the description of "DllGetClassObject" of OLE 2.0 reference
// manual for detail.
//
//---------------------------------------------------------------------------

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppvOut)
	{
    //
	// This DLL has only one class (CLSID_SampleIconExt). If a DLL supports
    // multiple classes, it should have either multiple if-statements or
    // efficient table lookup code.
	//

	if (IsEqualIID(rclsid, &CLSID_SampleIconExt))
		{
		//
		// We are supposed return the class object for this class. Instead
		// of fully implementing it in this DLL, we just call a helper
		// function in the shell DLL which creates a default class factory
		// object for us. When its CreateInstance member is called, it
		// will call back our create instance function (IconExt_CreateInstance).
		//
		return SHCreateDefClassObject(
			riid,
			ppvOut,
		    IconExt_CreateInstance, // callback function
			&g_cRefThisDll, 		// reference count of this DLL
		    &IID_IPersistFile	    // init interface
		    );
		}

    return ResultFromScode(CLASS_E_CLASSNOTAVAILABLE);
	}

//---------------------------------------------------------------------------
//
// CSampleIconExt class
//
// In C++:
//  class CSampleIconExt : protected IExtractIcon, protected IPersistFile
//  {
//  protected:
//      int          _cRef;
//      LPDATAOBJECT _pdtobj;
//	HKEY	     _hkeyProgID;
//  public:
//      CSampleIconExt() _cRef(1), _pdtobj(NULL), _hkeyProgID(NULL) {};
//      ...
//  };
//
//---------------------------------------------------------------------------
typedef struct _CSampleIconExt	// smx
	{
	IExtractIcon	_ctm;			// 1st base class
	IPersistFile	_sxi;			// 2nd base class
	int 			_cRef;			// reference count
    char	    _szFile[MAX_PATH];	//
	} CSampleIconExt, * PSAMPLEICONEXT;

#define SMX_OFFSETOF(x)	        ((UINT_PTR)(&((PSAMPLEICONEXT)0)->x))
#define PVOID2PSMX(pv,offset)   ((PSAMPLEICONEXT)(((LPBYTE)pv)-offset))
#define PCTM2PSMX(pctm)	        PVOID2PSMX(pctm, SMX_OFFSETOF(_ctm))
#define PSXI2PSMX(psxi)	        PVOID2PSMX(psxi, SMX_OFFSETOF(_sxi))

//
// Vtable prototype
//
extern IExtractIconVtbl     c_SampleIconExt_CTMVtbl;
extern IPersistFileVtbl 	c_SampleIconExt_SXIVtbl;

//---------------------------------------------------------------------------
//
// IconExt_CreateInstance
//
//  This function is called back from within IClassFactory::CreateInstance()
// of the default class factory object, which is created by SHCreateClassObject.
//
//---------------------------------------------------------------------------

HRESULT CALLBACK IconExt_CreateInstance(LPUNKNOWN punkOuter,
				        REFIID riid, LPVOID FAR* ppvOut)
	{
    HRESULT hres;
    PSAMPLEICONEXT psmx;

    //
    // Shell extentions typically does not support aggregation.
    //
	if (punkOuter)
		return ResultFromScode(CLASS_E_NOAGGREGATION);

    //
    // in C++:
    //  psmx = new CSampleIconExt();
    //
	psmx = LocalAlloc(LPTR, sizeof(CSampleIconExt));

	if (!psmx)
		return ResultFromScode(E_OUTOFMEMORY);

    psmx->_ctm.lpVtbl = &c_SampleIconExt_CTMVtbl;
    psmx->_sxi.lpVtbl = &c_SampleIconExt_SXIVtbl;
    psmx->_cRef = 1;
    g_cRefThisDll++;

    //
    // in C++:
    //  hres = psmx->QueryInterface(riid, ppvOut);
    //  psmx->Release();
    //
    // Note that the Release member will free the object, if QueryInterface
    // failed.
    //
    hres = c_SampleIconExt_CTMVtbl.QueryInterface(&psmx->_ctm, riid, ppvOut);
    c_SampleIconExt_CTMVtbl.Release(&psmx->_ctm);

    return hres;	// S_OK or E_NOINTERFACE
	}

//---------------------------------------------------------------------------
// CSampleIconExt::Load (IPersistFile override)
//---------------------------------------------------------------------------
STDMETHODIMP IconExt_GetClassID(LPPERSISTFILE pPersistFile, LPCLSID lpClassID)
	{
    return ResultFromScode(E_FAIL);
	}

STDMETHODIMP IconExt_IsDirty(LPPERSISTFILE pPersistFile)
	{
    return ResultFromScode(E_FAIL);
	}

STDMETHODIMP IconExt_Load(LPPERSISTFILE pPersistFile, LPCOLESTR lpszFileName, DWORD grfMode)
	{
	PSAMPLEICONEXT this = PSXI2PSMX(pPersistFile);
	int iRet = 0;

#if 1
	iRet = WideCharToMultiByte(
			CP_ACP, 			// CodePage
			0,					// dwFlags
			lpszFileName,		// lpWideCharStr
			-1, 				// cchWideChar
			this->_szFile,		// lpMultiByteStr
			sizeof(this->_szFile),	// cchMultiByte,
			NULL,				// lpDefaultChar,
			NULL				// lpUsedDefaultChar
			);
#endif
//
// WideCharToMultiByte does not work on build 84.
//
#if 1
    if (iRet==0)
    {
	LPSTR psz=this->_szFile;
	while(*psz++ = (char)*lpszFileName++);
    }
#endif
    return NOERROR;
	}

STDMETHODIMP IconExt_Save(LPPERSISTFILE pPersistFile, LPCOLESTR lpszFileName, BOOL fRemember)
	{
    return ResultFromScode(E_FAIL);
	}

STDMETHODIMP IconExt_SaveCompleted(LPPERSISTFILE pPersistFile, LPCOLESTR lpszFileName)
	{
    return ResultFromScode(E_FAIL);
	}

STDMETHODIMP IconExt_GetCurFile(LPPERSISTFILE pPersistFile, LPOLESTR FAR* lplpszFileName)
	{
    return ResultFromScode(E_FAIL);
	}


/*
 * At the time I write this, the only known documentation for these next two
 * functions is in SHLOBJ.H.  Please take the time to read it.
 */

STDMETHODIMP IconExt_GetIconLocation(LPEXTRACTICON pexic,
		     UINT   uFlags,
		     LPSTR  szIconFile,
		     UINT   cchMax,
		     int  FAR * piIndex,
		     UINT FAR * pwFlags)
	{
	PSAMPLEICONEXT this = PCTM2PSMX(pexic);

    if (this->_szFile[0])
		{
		HANDLE hFile;
		DWORD dw;
		DWORD dwSize;
		DWORD dwIdx;
		int nIndex = 0;
		int nRet = 0;

		GetModuleFileName(hInstanceDll, szIconFile, cchMax);

		hFile = CreateFile(this->_szFile, GENERIC_READ, FILE_SHARE_READ,
			0, OPEN_EXISTING, 0, 0);

		if ( hFile != INVALID_HANDLE_VALUE ) //mpt:4-29-98 we weren't checking for failure here
			{
			// Skip past header.  First ID will be the icon number.
			// (IDs are shorts).  Size field follows (DWORD)

			if (SetFilePointer(hFile, 256+sizeof(SHORT), 0,
					FILE_BEGIN) != (DWORD)-1)
				{
				if (ReadFile(hFile, &dwSize, sizeof(DWORD), &dw, 0))
					{
					dwIdx = 0;

					if (ReadFile(hFile, &dwIdx, min(sizeof(DWORD), dwSize),
							&dw, 0))
						{
						nIndex = (int)dwIdx;
						nIndex -= IDI_PROG;
						}
					}
				}

			CloseHandle(hFile);
			}

		*piIndex = nIndex;
		}

    *pwFlags = 0;
    return NOERROR;
	}

STDMETHODIMP IconExt_Extract(LPEXTRACTICON pexic,
			   LPCSTR pszFile,
		       UINT	  nIconIndex,
		       HICON  FAR *phiconLarge,
		       HICON  FAR *phiconSmall,
		       UINT   nIcons)
	{
    // Force default extraction.
	return ResultFromScode(S_FALSE);
	}

//---------------------------------------------------------------------------
// CSampleIconExt::AddRef (IExtractIcon override)
//---------------------------------------------------------------------------

STDMETHODIMP_(UINT) IconExt_CTM_AddRef(LPEXTRACTICON pctm)
	{
    PSAMPLEICONEXT this = PCTM2PSMX(pctm);
    return ++this->_cRef;
	}


//---------------------------------------------------------------------------
// CSampleIconExt::AddRef (IPersistFile override)
//---------------------------------------------------------------------------

STDMETHODIMP_(UINT) IconExt_SXI_AddRef(LPPERSISTFILE psxi)
	{
    PSAMPLEICONEXT this = PSXI2PSMX(psxi);
    return ++this->_cRef;
	}

//---------------------------------------------------------------------------
// CSampleIconExt::Release (IExtractIcon override)
//---------------------------------------------------------------------------

STDMETHODIMP_(UINT) IconExt_CTM_Release(LPEXTRACTICON pctm)
{
    UINT cRef;
	PSAMPLEICONEXT this = PCTM2PSMX(pctm);

#if DBG==1
    if( 0 == this->_cRef )
    {
        DebugBreak();   // ref counting problem
    }
#endif
    cRef = InterlockedDecrement(&this->_cRef);
	if ( 0 == cRef )
    {
        LocalFree((HLOCAL)this);
        g_cRefThisDll--;
    }
    return cRef;
}

//---------------------------------------------------------------------------
// CSampleIconExt::Release (IPersistFile thunk)
//---------------------------------------------------------------------------

STDMETHODIMP_(UINT) IconExt_SXI_Release(LPPERSISTFILE psxi)
	{
    PSAMPLEICONEXT this = PSXI2PSMX(psxi);
    return IconExt_CTM_Release(&this->_ctm);
	}

//---------------------------------------------------------------------------
// CSampleIconExt::QueryInterface (IExtractIcon override)
//---------------------------------------------------------------------------

STDMETHODIMP IconExt_CTM_QueryInterface(LPEXTRACTICON pctm, REFIID riid, LPVOID FAR* ppvOut)
	{
	PSAMPLEICONEXT this = PCTM2PSMX(pctm);

	if (IsEqualIID(riid, &IID_IExtractIcon) ||
			IsEqualIID(riid, &IID_IUnknown))
		{
        (LPEXTRACTICON)*ppvOut=pctm;
        this->_cRef++;
        return NOERROR;
		}

    if (IsEqualIID(riid, &IID_IPersistFile))
		{
        (LPPERSISTFILE)*ppvOut=&this->_sxi;
        this->_cRef++;
        return NOERROR;
		}

    return ResultFromScode(E_NOINTERFACE);
	}

//---------------------------------------------------------------------------
// CSampleIconExt::QueryInterface (IPersistFile thunk)
//---------------------------------------------------------------------------

STDMETHODIMP IconExt_SXI_QueryInterface(LPPERSISTFILE psxi, REFIID riid, LPVOID FAR* ppv)
	{
    PSAMPLEICONEXT this = PSXI2PSMX(psxi);
    return IconExt_CTM_QueryInterface(&this->_ctm, riid, ppv);
	}

//---------------------------------------------------------------------------
// CSampleIconExt class : Vtables
//---------------------------------------------------------------------------

#pragma data_seg(".text")
IExtractIconVtbl c_SampleIconExt_CTMVtbl =
	{
    IconExt_CTM_QueryInterface,
    IconExt_CTM_AddRef,
    IconExt_CTM_Release,
    IconExt_GetIconLocation,
	IconExt_Extract,
	};

IPersistFileVtbl c_SampleIconExt_SXIVtbl =
	{
    IconExt_SXI_QueryInterface,
    IconExt_SXI_AddRef,
    IconExt_SXI_Release,
    IconExt_GetClassID,
    IconExt_IsDirty,
    IconExt_Load,
    IconExt_Save,
    IconExt_SaveCompleted,
    IconExt_GetCurFile
	};
#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\ext\pageext.c ===
/*	File: D:\wacker\ext\pageext.c (Created: 01-Mar-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 3/25/02 3:52p $
 */

#define _INC_OLE		// WIN32, get ole2 from windows.h
#define CONST_VTABLE
#define INITGUID

#include <windows.h>
#pragma hdrstop
//
// Initialize GUIDs (should be done only and at-least once per DLL/EXE)
//
#pragma data_seg(".text")
#include <objbase.h>
#include <initguid.h>
//#include <coguid.h>
//#include <oleguid.h>
#include <shlguid.h>
#include <shlobj.h>
#include "pageext.hh"
#pragma data_seg()

//
// Function prototypes
//
HRESULT CALLBACK PageExt_CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR*);

//
// Global variables
//
UINT g_cRefThisDll = 0;		// Reference count of this DLL.

//---------------------------------------------------------------------------
// DllCanUnloadNow
//---------------------------------------------------------------------------

STDAPI DllCanUnloadNow(void)
	{
    return ResultFromScode((g_cRefThisDll==0) ? S_OK : S_FALSE);
	}

//---------------------------------------------------------------------------
//
// DllGetClassObject
//
//  This is the entry of this DLL, which all the In-Proc server DLLs should
// export. See the description of "DllGetClassObject" of OLE 2.0 reference
// manual for detail.
//
//---------------------------------------------------------------------------

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppvOut)
	{
    //
    //  This DLL has only one class (CLSID_SamplePageExt). If a DLL supports
    // multiple classes, it should have either multiple if-statements or
    // efficient table lookup code.
	//

// We need to put the icon handler in a separate DLL so when CAB32.EXE
// calls it we don't implicitly link to TAPI and other system DLL's.
// This is mostly for speed and to work around a bug in the Chicago
// beta 1.	Of course, we want to keep one source.	So the main DLL
// will link to the icon DLL to get icons, and the SHCreateDefClassObject(),
// etc.  Sorry for the complexity but its in the interest of system
// performance. - mrw

    if (IsEqualIID(rclsid, &CLSID_SamplePageExt))
		{
	//
	// We are supposed return the class object for this class. Instead
	// of fully implementing it in this DLL, we just call a helper
	// function in the shell DLL which creates a default class factory
	// object for us. When its CreateInstance member is called, it
	// will call back our create instance function (PageExt_CreateInstance).
	//
	return SHCreateDefClassObject(
			riid,
			ppvOut,
		    PageExt_CreateInstance, // callback function
			&g_cRefThisDll, 		// reference count of this DLL
		    &IID_IShellExtInit	    // init interface
			);

		}

    return ResultFromScode(CLASS_E_CLASSNOTAVAILABLE);
	}


//---------------------------------------------------------------------------
//
// CSamplePageExt class
//
// In C++:
//  class CSamplePageExt : protected IShellPropSheetExt, protected IShellExtInit
//  {
//  protected:
//      UINT         _cRef;
//      LPDATAOBJECT _pdtobj;
//	HKEY	     _hkeyProgID;
//  public:
//      CSamplePageExt() _cRef(1), _pdtobj(NULL), _hkeyProgID(NULL) {};
//      ...
//  };
//
//---------------------------------------------------------------------------
typedef struct _CSamplePageExt	// smx
	{
    IShellPropSheetExt	_spx;           // 1st base class
    IShellExtInit   	_sxi;	    	// 2nd base class
    UINT            	_cRef;          // reference count
	LPDATAOBJECT		_pdtobj;		// data object
	HKEY			_hkeyProgID;		// reg. database key to ProgID
	} CSamplePageExt, * PSAMPLEPAGEEXT;

//
// Useful macros, which casts interface pointers to class pointers.
//
#define SMX_OFFSETOF(x)	        ((UINT_PTR)(&((PSAMPLEPAGEEXT)0)->x))
#define PVOID2PSMX(pv,offset)   ((PSAMPLEPAGEEXT)(((LPBYTE)pv)-offset))
#define PSPX2PSMX(pspx)	        PVOID2PSMX(pspx, SMX_OFFSETOF(_spx))
#define PSXI2PSMX(psxi)	        PVOID2PSMX(psxi, SMX_OFFSETOF(_sxi))

//
// Vtable prototype
//
extern IShellPropSheetExtVtbl   c_SamplePageExt_SPXVtbl;
extern IShellExtInitVtbl    	c_SamplePageExt_SXIVtbl;

//---------------------------------------------------------------------------
//
// PageExt_CreateInstance
//
//  This function is called back from within IClassFactory::CreateInstance()
// of the default class factory object, which is created by Shell_CreateClassObject.
//
//---------------------------------------------------------------------------

HRESULT CALLBACK PageExt_CreateInstance(LPUNKNOWN punkOuter,
				        REFIID riid, LPVOID FAR* ppvOut)
	{
    HRESULT hres;
    PSAMPLEPAGEEXT psmx;

    //
    // Shell extentions typically does not support aggregation.
    //
	if (punkOuter)
		return ResultFromScode(CLASS_E_NOAGGREGATION);

    //
    // in C++:
    //  psmx = new CSamplePageExt();
    //
	psmx = LocalAlloc(LPTR, sizeof(CSamplePageExt));

	if (!psmx)
		return ResultFromScode(E_OUTOFMEMORY);

    psmx->_spx.lpVtbl = &c_SamplePageExt_SPXVtbl;
    psmx->_sxi.lpVtbl = &c_SamplePageExt_SXIVtbl;
    psmx->_cRef = 1;
    psmx->_pdtobj = NULL;
    psmx->_hkeyProgID = NULL;
    g_cRefThisDll++;

    //
    // in C++:
    //  hres = psmx->QueryInterface(riid, ppvOut);
    //  psmx->Release();
    //
    // Note that the Release member will free the object, if QueryInterface
    // failed.
    //
    hres = c_SamplePageExt_SPXVtbl.QueryInterface(&psmx->_spx, riid, ppvOut);
    c_SamplePageExt_SPXVtbl.Release(&psmx->_spx);

    return hres;	// S_OK or E_NOINTERFACE
	}


//---------------------------------------------------------------------------
// CSamplePageExt::Initialize (IShellExtInit override)
//
//  The shell always calls this member function to initialize this object
// immediately after creating it (by calling CoCreateInstance).
//
// Arguments:
//  pdtobj -- Specifies one or more objects for which the shell is about to
//           open the property sheet. Typically, they are selected objects
//           in the explorer. If they are file system objects, it supports
//           CF_FILELIST; if they are network resource objects, it supports
//	     "Net Resource" clipboard format.
//  hkeyProgID -- Specifies the program ID of the primary object (typically
//	     the object which has the focus in the explorer's content pane).
//
// Comments:
//   The extension should "duplicate" the parameters if it needs them later.
//  Call AddRef() member function for the pdtobj and RegOpenKeyEx() API for the
//  hkeyProgID.
//---------------------------------------------------------------------------
STDMETHODIMP PageExt_Initialize(LPSHELLEXTINIT psxi,
				LPCITEMIDLIST pidlFolder,
				LPDATAOBJECT pdtobj, HKEY hkeyProgID)
	{
    PSAMPLEPAGEEXT this = PSXI2PSMX(psxi);

    //
    // Initialize can be called more than once.
    //
	if (this->_pdtobj)
		{
		this->_pdtobj->lpVtbl->Release(this->_pdtobj);
		this->_pdtobj = NULL;
		}

	if (this->_hkeyProgID)
		{
		RegCloseKey(this->_hkeyProgID);
		this->_hkeyProgID = NULL;
		}

    //
    // Duplicate the pdtobj pointer
    //
	if (pdtobj)
		{
		this->_pdtobj = pdtobj;
		pdtobj->lpVtbl->AddRef(pdtobj);
		}

    //
    // Duplicate the handle (althogh we don't use it in this sample)
    //
	if (hkeyProgID)
		RegOpenKeyEx(hkeyProgID, 0, 0, KEY_READ, &this->_hkeyProgID);

    return NOERROR;
	}


//---------------------------------------------------------------------------
// CSamplePageExt::AddPages (IShellPropSheetExt override)
//---------------------------------------------------------------------------
STDMETHODIMP PageExt_AddPages(LPSHELLPROPSHEETEXT pspx,
				  LPFNADDPROPSHEETPAGE lpfnAddPage,
			      LPARAM lParam)
	{
    PSAMPLEPAGEEXT this = PSPX2PSMX(pspx);
    //
    //  This is the place where this extension may add pages to the property
    // sheet the shell is about to create. In this example, we add the
    // "FSPage" if the selected objects are file system objects and add
    // the "NETPage" if the selected objects are file system objects.
    //
    //  Typically, a shell extension is registered either file system object
    // class or network resource classe, and does not need to deal with two
    // different kinds of objects.
    //
    FSPage_AddPages(this->_pdtobj, lpfnAddPage, lParam);
	//NETPage_AddPages(this->_pdtobj, lpfnAddPage, lParam);

    return NOERROR;
	}

//---------------------------------------------------------------------------
// CSamplePageExt::AddRef (IShellPropSheetExt override)
//---------------------------------------------------------------------------

STDMETHODIMP_(UINT) PageExt_SPX_AddRef(LPSHELLPROPSHEETEXT pspx)
	{
    PSAMPLEPAGEEXT this = PSPX2PSMX(pspx);
    return ++this->_cRef;
	}


//---------------------------------------------------------------------------
// CSamplePageExt::AddRef (IShellExtInit override)
//---------------------------------------------------------------------------

STDMETHODIMP_(UINT) PageExt_SXI_AddRef(LPSHELLEXTINIT psxi)
	{
    PSAMPLEPAGEEXT this = PSXI2PSMX(psxi);
    return ++this->_cRef;
	}

//---------------------------------------------------------------------------
// CSamplePageExt::Release (IShellPropSheetExt override)
//---------------------------------------------------------------------------

STDMETHODIMP_(UINT) PageExt_SPX_Release(LPSHELLPROPSHEETEXT pspx)
	{
	PSAMPLEPAGEEXT this = PSPX2PSMX(pspx);

	if (--this->_cRef)
		return this->_cRef;

	if (this->_pdtobj)
		this->_pdtobj->lpVtbl->Release(this->_pdtobj);

	if (this->_hkeyProgID)
		RegCloseKey(this->_hkeyProgID);

    LocalFree((HLOCAL)this);
    g_cRefThisDll--;

    return 0;
	}

//---------------------------------------------------------------------------
// CSamplePageExt::Release (IShellExtInit thunk)
//---------------------------------------------------------------------------

STDMETHODIMP_(UINT) PageExt_SXI_Release(LPSHELLEXTINIT psxi)
	{
    PSAMPLEPAGEEXT this = PSXI2PSMX(psxi);
    return PageExt_SPX_Release(&this->_spx);
	}

//---------------------------------------------------------------------------
// CSamplePageExt::QueryInterface (IShellPropSheetExt override)
//---------------------------------------------------------------------------

STDMETHODIMP PageExt_SPX_QueryInterface(LPSHELLPROPSHEETEXT pspx, REFIID riid, LPVOID FAR* ppvOut)
	{
    PSAMPLEPAGEEXT this = PSPX2PSMX(pspx);

	if (IsEqualIID(riid, &IID_IShellPropSheetExt) ||
			IsEqualIID(riid, &IID_IUnknown))
		{
        (LPSHELLPROPSHEETEXT)*ppvOut=pspx;
        this->_cRef++;
        return NOERROR;
		}

    if (IsEqualIID(riid, &IID_IShellExtInit))
		{
        (LPSHELLEXTINIT)*ppvOut=&this->_sxi;
        this->_cRef++;
        return NOERROR;
		}

    *ppvOut=NULL;
    return ResultFromScode(E_NOINTERFACE);
	}


//---------------------------------------------------------------------------
// CSamplePageExt::QueryInterface (IShellExtInit thunk)
//---------------------------------------------------------------------------

STDMETHODIMP PageExt_SXI_QueryInterface(LPSHELLEXTINIT psxi, REFIID riid, LPVOID FAR* ppv)
	{
    PSAMPLEPAGEEXT this = PSXI2PSMX(psxi);
    return PageExt_SPX_QueryInterface(&this->_spx, riid, ppv);
	}


//---------------------------------------------------------------------------
// CSamplePageExt class : Vtables
//
//  VTables should be placed in the read only section unless we need to alter
// them at runtime.
//---------------------------------------------------------------------------

#pragma data_seg(".text")
IShellPropSheetExtVtbl c_SamplePageExt_SPXVtbl =
	{
    PageExt_SPX_QueryInterface,
    PageExt_SPX_AddRef,
    PageExt_SPX_Release,
    PageExt_AddPages
	};

IShellExtInitVtbl c_SamplePageExt_SXIVtbl =
	{
    PageExt_SXI_QueryInterface,
    PageExt_SXI_AddRef,
    PageExt_SXI_Release,
    PageExt_Initialize
	};
#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\vt_xtra.c ===
/*	File: D:\WACKER\emu\vt100.c (Created: 09-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 5 $
 *	$Date: 5/21/01 4:38p $
 */

#include <windows.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
#include <tdll\tdll.h>
#include <tdll\session.h>
#include <tdll\assert.h>
#include <tdll\cloop.h>
#include <tdll\print.h>
#include <tdll\capture.h>
#include <tdll\update.h>
#include <tdll\htchar.h>

#include "emu.h"
#include "emu.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_DSR
 *
 * DESCRIPTION:
 *	 Reports the current cursor position to the host.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_DSR(const HHEMU hhEmu)
	{
	int sel, fOldValue;
	TCHAR achTemp[10];
	ECHAR s[10];
	ECHAR *sp;

	memset(s, 0, sizeof(s));

	sel = hhEmu->selector[0];
	if (sel == 5)
		CnvrtMBCStoECHAR(s, sizeof(s), TEXT("\033[0n"),
                         StrCharGetByteCount(TEXT("\033[0n")));

	else if (sel == 6)
		{
		wsprintf(achTemp, TEXT("\033[%d;%dR"), hhEmu->emu_currow + 1,
				 (hhEmu->emu_curcol == hhEmu->emu_maxcol + 1) ?
				 hhEmu->emu_curcol : hhEmu->emu_curcol + 1);
		CnvrtMBCStoECHAR(s, sizeof(s), achTemp, StrCharGetByteCount(achTemp));
		}

			/* 1st str is printer not ready */
	else if (sel == 0x0F25) /* are user-defined keys locked? */
		CnvrtMBCStoECHAR(s, sizeof(s), TEXT("\033[?20n"),
                         StrCharGetByteCount(TEXT("\033[?20n")));

	else if (sel == 0x0F26) /* what is the keyboard language? */
		CnvrtMBCStoECHAR(s, sizeof(s), TEXT("\033[?27;1n"),
                         StrCharGetByteCount(TEXT("\033[?27;1n")));

	else
		{
		commanderror(hhEmu);
		return;
		}
	sp = s;

	/* to not get recursive ANSI_DSR's if half duplex */

	fOldValue = CLoopGetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession));

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), FALSE);

	emuSendString(hhEmu, sp, StrCharGetEcharByteCount(sp));

	CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), fOldValue);

	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_RM
 *
 * DESCRIPTION:
 *	 Sets character display attributes.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_RM(const HHEMU hhEmu)
	{
	int mode_id, i;
	HCLOOP	hCLoop = (HCLOOP)0;

	for (i = 0; i <= hhEmu->selector_cnt; i++)
		{
		mode_id = hhEmu->selector[i];
		switch (mode_id)
			{
		case 0x02:
			hhEmu->mode_KAM = RESET;
			hhEmu->emu_kbdin = vt100_kbdin;
			break;
		case 0x04:
			hhEmu->mode_IRM = RESET;
			break;
		case 0x07:
			hhEmu->mode_VEM = RESET;
			break;
		case 0x10:
			hhEmu->mode_HEM = RESET;
			break;
		case 0x12:
			hhEmu->mode_SRM = RESET;
			CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), TRUE);
			break;
		case 0x18:	/* actually ?18, but ? gets shifted out */
			hhEmu->mode_DECPFF = RESET;
			break;
		case 0x19:	/* acutally ?19, see above */
			hhEmu->mode_DECPEX = RESET;
			break;
		case 0x20:
			hhEmu->mode_LNM = RESET;
			/* also affects transmission of RET key */
            hCLoop = sessQueryCLoopHdl(hhEmu->hSession);
			CLoopSetAddLF(hCLoop, FALSE);
			CLoopSetSendCRLF(hCLoop, FALSE);
			break;
		case 0xF1:
			hhEmu->mode_DECCKM = RESET;
			break;
		case 0xF2:
			emuLoad((HEMU)hhEmu, EMU_VT52);
			break;
		case 0xF3:
			// Switch to 80 column mode.
			//
			emuSetDecColumns(hhEmu, VT_MAXCOL_80MODE, TRUE);
			break;
		case 0xF4:
			/* select jump scroll */
			/* we're always in jump scroll, just ignore */
			break;
		case 0xf5:
			if (hhEmu->mode_DECSCNM == SET)
				{
				emu_reverse_image(hhEmu);
				hhEmu->mode_DECSCNM = RESET;
				}
			break;
		case 0xf6:
			hhEmu->mode_DECOM = RESET;

			// This command homes the cursor. Added 16 Mar 98 rde
			ANSI_Pn_Clr(hhEmu);
			ANSI_CUP(hhEmu);
			
			break;
		case 0xd7:	/* for ANSI */
		case 0xf7:
			hhEmu->mode_AWM = RESET;
			break;
		case 0xF8:
			/* turn off auto repeat */
			break;
		case 0xF18:
			hhEmu->mode_DECPFF = RESET;
			break;
		case 0xF19:
			hhEmu->mode_DECPEX = RESET;
			break;
		case 0xF25:
			hhEmu->mode_DECTCEM = RESET;
			EmuStdSetCursorType(hhEmu, EMU_CURSOR_NONE);
			break;
		default:
			commanderror(hhEmu);
			break;
			}
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * ANSI_SM
 *
 * DESCRIPTION:
 *	 Sets a mode for current terminal emulator.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void ANSI_SM(const HHEMU hhEmu)
	{
	int mode_id, i;
	HCLOOP	hCLoop = (HCLOOP)0;

	for (i = 0; i <= hhEmu->selector_cnt; i++)
		{
		mode_id = hhEmu->selector[i];
		switch (mode_id)
			{
		case 0x02:
			hhEmu->mode_KAM = SET;
			hhEmu->emu_kbdin = emu_kbdlocked;
			break;
		case 0x04:
			hhEmu->mode_IRM = SET;
			break;
		case 0x07:
			hhEmu->mode_VEM = SET;
			break;
		case 0x10:
			hhEmu->mode_HEM = SET;
			break;
		case 0x12:
			hhEmu->mode_SRM = SET;
			CLoopSetLocalEcho(sessQueryCLoopHdl(hhEmu->hSession), FALSE);
			break;
		case 0x18:	/* actually ?18, but ? gets shifted out */
			hhEmu->mode_DECPFF = SET;
			break;
		case 0x19:	/* acutally ?19, see above */
			hhEmu->mode_DECPEX = SET;
			break;
		case 0x20:
			hhEmu->mode_LNM = SET;
			/* also affects sending of RET key */
            hCLoop = sessQueryCLoopHdl(hhEmu->hSession);
			CLoopSetAddLF(hCLoop, TRUE);
			CLoopSetSendCRLF(hCLoop, TRUE);
			break;
		case 0xF1:
			hhEmu->mode_DECCKM = SET;
			break;
		case 0xF2:
			vt52_toANSI(hhEmu);
			break;
		case 0xF3:
			// Set 132 column mode.
			//
			emuSetDecColumns(hhEmu, VT_MAXCOL_132MODE, TRUE);
			break;
		case 0xF4:
			/* set smooth scrolling (not implemented) */
			break;
		case 0xF5:
			if (hhEmu->mode_DECSCNM == RESET)
				{
				emu_reverse_image(hhEmu);
				hhEmu->mode_DECSCNM = SET;
				}
			break;
		case 0xF6:
			hhEmu->mode_DECOM = SET;

			// This command homes the cursor. Added 16 Mar 98 rde
			ANSI_Pn_Clr(hhEmu);
			ANSI_CUP(hhEmu);
			
			break;
		case 0xD7:
		case 0xF7:
			hhEmu->mode_AWM = SET;
			break;
		case 0xF8:
			/* select auto repeat mode */
			break;
		case 0xF18:
			hhEmu->mode_DECPFF = SET;
			break;
		case 0xF19:
			hhEmu->mode_DECPEX = SET;
			break;
		case 0xF25:
			hhEmu->mode_DECTCEM = SET;
			EmuStdSetCursorType(hhEmu, hhEmu->stUserSettings.nCursorType);
			break;
		default:
			commanderror(hhEmu); break;
			}
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt_alt_kpmode
 *
 * DESCRIPTION:
 *	 Sets up emulator for alternate keypad mode.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void vt_alt_kpmode(const HHEMU hhEmu)
	{
	if (hhEmu->emu_code == ETEXT('='))
		hhEmu->mode_DECKPAM = SET;
	else if (hhEmu->emu_code == ETEXT('>'))
		hhEmu->mode_DECKPAM = RESET;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt_screen_adjust
 *
 * DESCRIPTION:
 *	 Fills the screen with E's.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void vt_screen_adjust(const HHEMU hhEmu)
	{
	register int i, row, cols;
	PSTATTR pstAttr;

	cols = hhEmu->mode_DECCOLM ? 132 : 80;

	for (row = 0; row < MAX_EMUROWS; ++row)
		{
		ECHAR_Fill(hhEmu->emu_apText[row], TEXT('E'), (unsigned)MAX_EMUCOLS);

		hhEmu->emu_aiEnd[row] = cols - 1;

		pstAttr = hhEmu->emu_apAttr[row];

		for (i = 0 ; i <= MAX_EMUCOLS; ++i)
			pstAttr[i] = hhEmu->emu_clearattr;

		updateChar(sessQueryUpdateHdl(hhEmu->hSession),
					row,
					0,
					hhEmu->emu_maxcol);
		}

	(*hhEmu->emu_setcurpos)(hhEmu, 0, 0);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt_scrollrgn
 *
 * DESCRIPTION:
 *	 Sets up a scrolling region
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void vt_scrollrgn(const HHEMU hhEmu)
	{
	int toprow, botmrow;

	toprow = hhEmu->num_param[0];
	botmrow = hhEmu->num_param_cnt > 0 ? hhEmu->num_param[1] : 0;
	DEC_STBM(hhEmu, toprow, botmrow);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * DEC_STBM
 *
 * DESCRIPTION:
 *	 Sets up a scrolling region
 *
 * ARGUMENTS:
 *	 top -- screen row to be top row of scrolling region
 *	 bottom -- screen row to be bottom row of scrolling region
 *				 NOTE - the top row of screen is row 1
 *
 * RETURNS:
 *	 nothing
 */
void DEC_STBM(const HHEMU hhEmu, int top, int bottom)
	{
	if (top < 1)
		top = 1;

	if (bottom < 1 || bottom > (hhEmu->emu_maxrow+1))
		bottom = (hhEmu->emu_maxrow+1);

	if (top >= bottom)
		{
		commanderror(hhEmu);
		return;
		}

	hhEmu->top_margin = top - 1;   /* convert one-based to zero-based */
	hhEmu->bottom_margin = bottom - 1;
	ANSI_Pn_Clr(hhEmu);
	ANSI_CUP(hhEmu);		 /* home cursor after setting */
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt52_to_ANSI
 *
 * DESCRIPTION:
 *	 Switches from VT52 mode to ANSI mode
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void vt52_toANSI(const HHEMU hhEmu)
	{
	#if FALSE	//DEADWOOD:rde 9 Mar 98
	emuLoad((HEMU)hhEmu, EMU_VT100);
	#endif

	if (!hhEmu)
		assert(FALSE);
	else
		{
		// Return to the original emu, not necessarily the VT100.
		if (hhEmu->mode_vt320)
			emuLoad((HEMU)hhEmu, EMU_VT320);
		else if (hhEmu->mode_vt220)
			emuLoad((HEMU)hhEmu, EMU_VT220);
		else
			emuLoad((HEMU)hhEmu, EMU_VT100);
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt_DCH
 *
 * DESCRIPTION:
 *	 Deletes the specified number of characters starting at the current
 *	 cursor position and moving right. It stops at the end of the current line.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void vt_DCH(const HHEMU hhEmu)
	{
	int nchars;
	BOOL old_mode_protect;
	STATTR old_emu_charattr;

	nchars = hhEmu->num_param[hhEmu->num_param_cnt];
	if (nchars < 1)
		nchars = 1;
	if (hhEmu->emu_code == ETEXT('P'))	 /* delete & shift line left */
		{
		ANSI_DCH(hhEmu);
		}
	else					/* emu_code == 'X', just delete */
		{
		old_mode_protect = hhEmu->mode_protect;
		old_emu_charattr = hhEmu->emu_charattr;
		hhEmu->mode_protect = FALSE;
		hhEmu->emu_charattr.undrln = hhEmu->emu_charattr.blink = 0;
		emu_clearword(hhEmu, hhEmu->emu_curcol, hhEmu->emu_curcol + nchars - 1);
		hhEmu->mode_protect = old_mode_protect;
		hhEmu->emu_charattr = old_emu_charattr;
		}

	updateChar(sessQueryUpdateHdl(hhEmu->hSession),
					hhEmu->emu_currow,
					hhEmu->emu_curcol,
					hhEmu->emu_maxcol);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt_IL
 *
 * DESCRIPTION:
 *	 Inserts the specified number of lines starting at the current
 *	 cursor row.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void vt_IL(const HHEMU hhEmu)
	{
	int nlines;

	nlines = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nlines < 1)
		nlines = 1;

	ANSI_IL(hhEmu);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt_DL
 *
 * DESCRIPTION:
 *	 Deletes the specified number of lines starting at the current
 *	 cursor line and moving down. It stops at the bottom of the scrolling
 *	 region.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void vt_DL(const HHEMU hhEmu)
	{
	int nlines;

	nlines = hhEmu->num_param[hhEmu->num_param_cnt];

	if (nlines < 1)
		nlines = 1;

	ANSI_DL(hhEmu);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt_clearline
 *
 * DESCRIPTION:
 *	 Erases some or all of the current virtual screen line and corresponding
 *	 real screen line.
 *
 * ARGUMENTS:
 *	 select -- 0 to erase from cursor to end of line
 *			-- 1 to erase from start of line to cursor
 *			-- 2 to erase entire line
 *
 * RETURNS:
 *	 nothing
 */
void vt_clearline(const HHEMU hhEmu, const int nSelect)
	{
	std_clearline(hhEmu, nSelect);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt_clearscreen
 *
 * DESCRIPTION:
 *	 Erases some or all of the virtual screen image.
 *
 * ARGUMENTS:
 *	 select -- 0 to erase from cursor to end of screen
 *			-- 1 to erase from start of screen to cursor
 *			-- 2 to erase entire screen
 *
 * RETURNS:
 *	 nothing
 */
void vt_clearscreen(const HHEMU hhEmu, const int nSelect)
	{
	std_clearscreen(hhEmu, nSelect);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt_backspace
 *
 * DESCRIPTION:	Moves the cursor backwards (to the left) 1 column, but stops
 *				at the 1st character in the current	line. The vt emus need
 *				a special function to handle the virtual column beyond the
 *				edge of the screen.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void vt_backspace(const HHEMU hhEmu)
	{
	INT bWide = 1;
	INT	iRow = row_index(hhEmu, hhEmu->emu_currow);
	INT iCol;

	//if (hhEmu->emu_curcol > 0)
	//	{
	//	(*hhEmu->emu_setcurpos)(hhEmu, hhEmu->emu_currow,
	//		hhEmu->emu_curcol - 1);
	//	}
	if (hhEmu->emu_curcol > 0)
		{
		bWide = hhEmu->emu_apAttr[iRow][hhEmu->emu_curcol - 1].wirt ? 2 : 1;
		bWide = hhEmu->emu_apAttr[iRow][hhEmu->emu_curcol].wirt ? 0 : bWide;

		(*hhEmu->emu_setcurpos)(hhEmu,
								hhEmu->emu_currow,
								hhEmu->emu_curcol - bWide);
		}

	if ((hhEmu->stUserSettings.nEmuId == EMU_TTY &&
		hhEmu->stUserSettings.fDestructiveBk) || (bWide == 0))
		{
		if (bWide == 0)
			iCol = hhEmu->emu_curcol - 1;
		else
			iCol = hhEmu->emu_curcol;	// account for wide chars this way

		hhEmu->emu_code = ETEXT(' ');
		
		(*hhEmu->emu_graphic)(hhEmu);

		(*hhEmu->emu_setcurpos)(hhEmu,
								hhEmu->emu_currow,
								iCol); //MPT:12-8-97 hhEmu->emu_curcol - 1);
		}

		
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vt_CUB
 *
 * DESCRIPTION:	Moves the cursor backwards (to the left) the specified number
 *				of characters, but stops at the 1st character in the current
 *				line. The vt emus need a special function to handle the
 *				virtual column beyond the edge of the screen.
 *
 * ARGUMENTS:	none
 *
 * RETURNS:		nothing
 */
void vt_CUB(const HHEMU hhEmu)
	{
	int nchars;

	nchars = hhEmu->num_param[hhEmu->num_param_cnt];
	if (nchars < 1)
		nchars = 1;

	(*hhEmu->emu_setcurpos)(hhEmu,
			hhEmu->emu_currow, (hhEmu->emu_curcol - nchars));
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	emuSetDecColumns
 *
 * DESCRIPTION:
 *	For DEC emulators only, this function sets either 80 or 132 columns.
 *
 * ARGUMENTS:
 *	hhEmu		-	The internal emualtor handle.
 *	nColumns	-	The number of columns to set.  This may be either...
 *					VT_MAXCOL_80MODE, or
 *					VT_MAXCOL_132MODE.
 *	fClear		-	clear screen if TRUE
 *
 * RETURNS:
 *	void
 *
 */
void emuSetDecColumns(const HHEMU hhEmu, const int nColumns, const int fClear)
	{
	if ((hhEmu->stUserSettings.nEmuId == EMU_VT100)     ||
		(hhEmu->stUserSettings.nEmuId == EMU_VT220)     ||
		(hhEmu->stUserSettings.nEmuId == EMU_VT320)     ||
	    (hhEmu->stUserSettings.nEmuId == EMU_VT100J)    ||
        (hhEmu->stUserSettings.nEmuId == EMU_VT100PLUS) ||
        (hhEmu->stUserSettings.nEmuId == EMU_VTUTF8))
		;
	else
		return;

	switch(nColumns)
		{
		case VT_MAXCOL_80MODE:
			hhEmu->mode_DECCOLM = RESET;
			hhEmu->emu_maxcol = VT_MAXCOL_80MODE;

			if (fClear)
				{
				DEC_STBM(hhEmu, 0, hhEmu->emu_maxrow + 1);
				(*hhEmu->emu_clearscreen)(hhEmu, 2);
				}

			NotifyClient(hhEmu->hSession, EVENT_EMU_SETTINGS, 0);
			break;

		case VT_MAXCOL_132MODE:
			hhEmu->mode_DECCOLM = SET;
			hhEmu->emu_maxcol = VT_MAXCOL_132MODE;

			if (fClear)
				{
				DEC_STBM(hhEmu, 0, hhEmu->emu_maxrow + 1);
				(*hhEmu->emu_clearscreen)(hhEmu, 2);
				}

			NotifyClient(hhEmu->hSession, EVENT_EMU_SETTINGS, 0);
			break;

		default:
			return;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DEC_HHC
 *
 * DESCRIPTION:
 *	Sets cursor to home position which is 1, 0 in this case.
 *
 * ARGUMENTS:
 *	hhEmu	- private emulator handle
 *
 * RETURNS:
 *	0=OK,else error.
 *
 */
int DEC_HHC(const HHEMU hhEmu)
	{
	if (hhEmu == 0)
		{
		assert(0);
		return -1;
		}

	(*hhEmu->emu_setcurpos)(hhEmu, 0, 0);
	return 0;
	}

/* end of vt_xtra.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\vt_chars.c ===
/*	File: D:\WACKER\emu\vt_chars.c (Created: 27-Dec-1993)
     *
     *	Copyright 1994, 1998 by Hilgraeve Inc. -- Monroe, MI
     *	All rights reserved
     *
     *	$Revision: 3 $
     *	$Date: 5/07/02 1:25p $
     */
    
    #include <windows.h>
    #pragma hdrstop
    
	#include <tdll\assert.h>
    #include <tdll\stdtyp.h>
    #include <tdll\session.h>
    #include <tdll\print.h>
    #include <tdll\capture.h>
    #include <tdll\mc.h>
    
    #include "emu.h"
    #include "emu.hh"
    #include "emudec.hh"
    
    /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
     * vt_charset
     *
     * DESCRIPTION: initialize character set mappings for VT terms
     *
     * ARGUMENTS:
     *
     * RETURNS:
     *
     */
    void vt_charset_init(const HHEMU hhEmu)
    	{
    	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;
    
    	if (hhEmu->mode_vt220 || hhEmu->mode_vt320)
    		/* started as a 320 or 220 even if now 100 */
    		{
    		pstPRI->vt_charset[0] = pstPRI->vt_charset[1] = ETEXT('B');	  /* ASCII char set */
    		pstPRI->vt_charset[2] = pstPRI->vt_charset[3] = ETEXT('<');	  /* DEC supplemental char set */
    		pstPRI->gl = 0;
    		pstPRI->gr = 2;
    		}
    	else if (hhEmu->mode_vt280)
    		/* Kanji or Katakana terminal support */
    		{
    		pstPRI->vt_charset[0] = ETEXT('B');	  /* ASCII char set */
    		pstPRI->vt_charset[1] = ETEXT('B');	  /* ASCII char set */
    		pstPRI->vt_charset[2] = ETEXT('B');	  /* ASCII char set */
    		pstPRI->vt_charset[3] = ETEXT('0');	  /* DEC special graphics set */
    		pstPRI->gl = 0;
    		pstPRI->gr = 2;
    		}
    	else
    		{
    		pstPRI->vt_charset[0] = ETEXT('B');	  /* ASCII char set */
    		pstPRI->vt_charset[1] = ETEXT('0');	  /* DEC special graphics set */
    		pstPRI->gl = 0;
    		pstPRI->gr = 1;
    		}
    	vt_dsptbl(hhEmu, pstPRI->vt_charset[pstPRI->gl], pstPRI->vt_charset[pstPRI->gr]);
    	}
    
    /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
     * vt_charset
     *
     * DESCRIPTION:
     *
     * ARGUMENTS:
     *
     * RETURNS:
     *
     */
    void vt_charset_save(const HHEMU hhEmu)
    	{
    	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;
    
   		MemCopy(pstPRI->vt_sv_charset, pstPRI->vt_charset, sizeof(pstPRI->vt_sv_charset));
    
    	pstPRI->sv_gl = pstPRI->gl;
    	pstPRI->sv_gr = pstPRI->gr;
    	}
    
    /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
     * vt_charset_restore
     *
     * DESCRIPTION:
     *
     * ARGUMENTS:
     *
     * RETURNS:
     *
     */
    void vt_charset_restore(const HHEMU hhEmu)
    	{
    	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;
    
   		MemCopy(pstPRI->vt_charset, pstPRI->vt_sv_charset, sizeof(pstPRI->vt_charset));
    
    	pstPRI->gl = pstPRI->sv_gl;
    	pstPRI->gr = pstPRI->sv_gr;
    
    	vt_dsptbl(hhEmu, pstPRI->vt_charset[pstPRI->gl], pstPRI->vt_charset[pstPRI->gr]);
    	}
    
    /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
     * vt_scs1
     *
     * DESCRIPTION:
     *	 Sets up the type of character set to be loaded next.
     *
     * ARGUMENTS:
     *	 none
     *
     * RETURNS:
     *	 nothing
     */
    void vt_scs1(const HHEMU hhEmu)
    	{
    	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;
    
    	switch (hhEmu->emu_code)
    		{
    	case ETEXT('(') :
    		pstPRI->gn = 0;
    		break;
    	case ETEXT(')') :
    		pstPRI->gn = 1;
    		break;
    	case ETEXT('*') :
    		pstPRI->gn = 2;
    		break;
    	case ETEXT('+') :
    		pstPRI->gn = 3;
    		break;
    	default:
    		break;
    		}
    	}
    
    /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
     * vt_scs2
     *
     * DESCRIPTION:
     *	 Loads another character set.
     *
     * ARGUMENTS:
     *	 none
     *
     * RETURNS:
     *	 nothing
     */
    void vt_scs2(const HHEMU hhEmu)
    	{
    	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;
    
    	pstPRI->vt_charset[pstPRI->gn] = hhEmu->emu_code;
    
    	vt_dsptbl(hhEmu,
    				pstPRI->vt_charset[pstPRI->gl],
    				pstPRI->vt_charset[pstPRI->gr]);
    	}
    
    /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
     * vt_setkanji
     *
     * DESCRIPTION:
     *	 Sets the display mode to Kanji/Katakana
     *
     * ARGUMENTS:
     *	 
     *
     * RETURNS:
     *	 nothing
     */
    void vt_setkanji(const HHEMU hhEmu, const int nSetKanji)
    	{
    	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;
    
    	if (nSetKanji)
    		{
    		pstPRI->vt_charset[0] = ETEXT('B');	  /* ASCII char set */
    		pstPRI->vt_charset[1] = ETEXT('0');	  /* DEC special graphics set */
    		pstPRI->vt_charset[2] = ETEXT('B');	  /* ASCII char set */
    		pstPRI->vt_charset[3] = ETEXT('Y');	  /* Kanji char set */
    		pstPRI->gl = 0;
    		pstPRI->gr = 2;
    		}
    	else
    		{
    		pstPRI->vt_charset[0] = ETEXT('B');	  /* ASCII char set */
    		pstPRI->vt_charset[1] = ETEXT('B');	  /* ASCII char set */
    		pstPRI->vt_charset[2] = ETEXT('B');	  /* ASCII char set */
    		pstPRI->vt_charset[3] = ETEXT('0');	  /* DEC special graphics set */
    		pstPRI->gl = 0;
    		pstPRI->gr = 2;
    		}
    
    	}
    
    /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
     * vt_charshift
     *
     * DESCRIPTION:
     *	 Loads another character set.
     *
     * ARGUMENTS:
     *	 none
     *
     * RETURNS:
     *	 nothing
     */
    void vt_charshift(const HHEMU hhEmu)
    	{
    	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;
    
    	switch(hhEmu->emu_code)
    		{
    	case 0x0F : 			/* LS0 */
    	case ETEXT('G') :		/* vt52 use ASCII */
    		pstPRI->gl = 0;
    		break;
    	case 0x0E : 			/* LS1 */
    	case ETEXT('F') :		/* vt52 use graphics */
    		pstPRI->gl = 1;
    		break;
    	case ETEXT('~') :		/* LS1R */
    		pstPRI->gr = 1;
    		break;
    	case ETEXT('n') :		/* LS2 */
    		pstPRI->gl = 2;
    		break;
    	case ETEXT('}') :		/* LS2R */
    		pstPRI->gr = 2;
    		break;
    	case ETEXT('o') :		/* LS3 */
    		pstPRI->gl = 3;
    		break;
    	case ETEXT('|') :		/* LS3R */
    		pstPRI->gr = 3;
    		break;
    	case 0x8E : 			/* SS2 */
    	case ETEXT('N')	:		/* ESC N */
    		pstPRI->old_gl = pstPRI->gl;
    		pstPRI->gl = 2;
    		hhEmu->emu_datain = vt_char_emulatecmd;
    		break;
    	case 0x8F : 			/* SS3 */
    	case ETEXT('O')	:		/* ESC O */
    		pstPRI->old_gl = pstPRI->gl;
    		pstPRI->gl = 3;
    		hhEmu->emu_datain = vt_char_emulatecmd;
    		break;
    	default:
    		break;
    		}
    
    	vt_dsptbl(hhEmu,
    				pstPRI->vt_charset[pstPRI->gl],
    				pstPRI->vt_charset[pstPRI->gr]);
    	}
    
    /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
     * vt_char_emulatecmd
     *
     * DESCRIPTION:
     *
     * ARGUMENTS:
     *
     * RETURNS:
     *
     */
  #if defined(EXTENDED_FEATURES)
  int vt_char_emulatecmd(const HHEMU hhEmu, const ECHAR ccode)
  	{
  	struct trans_entry *tptr;
  	int ntrans;
  
  #else
    int vt_char_emulatecmd(const HEMU hEmu, const ECHAR ccode)
    	{
    	struct trans_entry *tptr;
    	int ntrans;
    
    	const HHEMU hhEmu = (HHEMU)hEmu;
  #endif
    	const PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;
    
    	emuLock((HEMU)hhEmu);
    
    	hhEmu->emu_code = ccode;
    
    	if (hhEmu->state == 0)
    		{
    		if (IN_RANGE(ccode, ETEXT(' '), 0x7F) || IN_RANGE(ccode, 0xA0, 0xFF))
    			{
    			(*hhEmu->emu_graphic)(hhEmu);
    			CaptureChar(sessQueryCaptureFileHdl(hhEmu->hSession),
    						CF_CAP_CHARS, ccode);
    			printEchoChar(hhEmu->hPrintEcho, ccode);
    			goto reset;
    			}
    		if (ccode == ETEXT('\r'))
    			{
    			carriagereturn(hhEmu);
    			CaptureChar(sessQueryCaptureFileHdl(hhEmu->hSession),
    						CF_CAP_CHARS, ccode);
    			printEchoChar(hhEmu->hPrintEcho, ccode);
    			emuUnlock((HEMU)hhEmu);
    			return(0);
    			}
    		if (ccode == ETEXT('\n'))
    			{
    			emuLineFeed(hhEmu);
    			CaptureChar(sessQueryCaptureFileHdl(hhEmu->hSession),
    						CF_CAP_CHARS, ccode);
    			printEchoChar(hhEmu->hPrintEcho, ccode);
    			emuUnlock((HEMU)hhEmu);
    			return(0);
    			}
    		}
    
    	/* Seek next state by finding character range */
    	tptr = hhEmu->state_tbl[hhEmu->state].first_trans;
    
    	ntrans = hhEmu->state_tbl[hhEmu->state].number_trans;
    
    	for (; ntrans > 0; ntrans--, ++tptr)
    		if (ccode >= tptr->lochar && ccode <= tptr->hichar)
    			break;
    
    	if (ntrans <= 0)
    		{
    		commanderror(hhEmu);
    		CaptureChar(sessQueryCaptureFileHdl(hhEmu->hSession),
    					CF_CAP_CHARS, ccode);
    		printEchoChar(hhEmu->hPrintEcho, ccode);
    		emuUnlock((HEMU)hhEmu);
    		return (0);
    		}
    
    	hhEmu->state = tptr->next_state;
    	(*tptr->funct_ptr)(hhEmu);
    
    	if (hhEmu->state == 0)
    		{
    		hhEmu->num_param_cnt = hhEmu->selector_cnt = hhEmu->selector[0] =
    		hhEmu->num_param[0] = 0;
    
    		hhEmu->DEC_private = FALSE;
    		}
    
    	if (tptr->funct_ptr != hhEmu->emu_graphic)
			{
    		emuUnlock((HEMU)hhEmu);
    		return(0);
			}
    
    	reset:
    #if defined(EXTENDED_FEATURES)	
    	hhEmu->emu_datain = emuStdDataIn;
    #else
    	hhEmu->emu_datain = emuDataIn;
    #endif
    	pstPRI->gl = pstPRI->old_gl;
    
    	// Restore the character set.
    	//
    	vt_dsptbl(hhEmu,
    				pstPRI->vt_charset[pstPRI->gl],
    				pstPRI->vt_charset[pstPRI->gr]);
    
    	emuUnlock((HEMU)hhEmu);
    
    	return (0);
    	}
    
    void vt_dsptbl(const HHEMU hhEmu, ECHAR left, ECHAR right)
    	{
    	// Copy the appropriate characters into the display character table.
    	//
		// The 2nd arg was changed from FALSE to TRUE to allow UTF8 to
		// display extended ASCII. I don't think it should cause any 
		// problems 7 May 2002 RDE
    	std_dsptbl(hhEmu, TRUE);						/* start off from known condition */
    	vt_setdtbl(hhEmu, &hhEmu->dspchar[0], left);	/* install gl chars. */
    	vt_setdtbl(hhEmu, &hhEmu->dspchar[128], right); /* install gr chars. */
    	}
    
    /* ARGSUSED*/
    void vt_setdtbl(const HHEMU hhEmu, ECHAR tbl[], ECHAR cset)
    	{
    	switch (cset)
    		{
    	case ETEXT('A'):	/* British */
    		tbl[0x23]=0x9C; /* replace # with British pound sign */
    		break;
    	case ETEXT('R'):	/* French */
    		tbl[0x23]=0x9C; tbl[0x40]=0x85; tbl[0x5B]=0xF8; tbl[0x5C]=0x87;
    		tbl[0x5D]=0x15; tbl[0x7B]=0x82; tbl[0x7C]=0x97; tbl[0x7D]=0x8A;
    		tbl[0x7E]=0xF9;
    		break;
    	case ETEXT('Q'):	/* French Canadian */
    		tbl[0x40]=0x85; tbl[0x5B]=0x83; tbl[0x5C]=0x87; tbl[0x5D]=0x88;
    		tbl[0x5E]=0x8C; tbl[0x60]=0x93; tbl[0x7B]=0x82; tbl[0x7C]=0x97;
    		tbl[0x7D]=0x8A; tbl[0x7E]=0x96;
    		break;
    	case ETEXT('K'):	/* German */
    		tbl[0x40]=0x15; tbl[0x5B]=0x8E; tbl[0x5C]=0x99; tbl[0x5D]=0x9A;
    		tbl[0x7B]=0x84; tbl[0x7C]=0x94; tbl[0x7D]=0x81; tbl[0x7E]=0xE1;
    		break;
    	case ETEXT('0'):	/* DEC special graphics */
    		tbl[0x5F]=' ';
    		tbl[0x60]=0x04; tbl[0x61]=0xB1; tbl[0x62]='H';	tbl[0x63]='F';
    		tbl[0x64]='R';	tbl[0x65]='L';	tbl[0x66]=0xF8; tbl[0x67]=0xF1;
    		tbl[0x68]='N';	tbl[0x69]='V';	tbl[0x6A]=0xD9; tbl[0x6B]=0xBF;
    		tbl[0x6C]=0xDA; tbl[0x6D]=0xC0; tbl[0x6E]=0xC5; tbl[0x6F]=0xC4;
    		tbl[0x70]=0xC4; tbl[0x71]=0xC4; tbl[0x72]=0xC4; tbl[0x73]=0xC4;
    		tbl[0x74]=0xC3; tbl[0x75]=0xB4; tbl[0x76]=0xC1; tbl[0x77]=0xC2;
    		tbl[0x78]=0xB3; tbl[0x79]=0xF3; tbl[0x7A]=0xF2; tbl[0x7B]=0xE3;
    		tbl[0x7C]=0xF0; tbl[0x7D]=0x9C; tbl[0x7E]=0xFA;
    		break;
    	case ETEXT('<'):	/* DEC supplemental graphics */
    		tbl[0x20]=' ';	tbl[0x21]=0xAD; tbl[0x22]=0x9B; tbl[0x23]=0x9C;
    		tbl[0x24]=' ';	tbl[0x25]=0x9D; tbl[0x26]=' ';	tbl[0x27]=0x15;
    		tbl[0x28]=0x0F; tbl[0x29]='C';	tbl[0x2A]=0xA6; tbl[0x2B]=0xAE;
    		tbl[0x2C]=' ';	tbl[0x2D]=' ';	tbl[0x2E]=' ';	tbl[0x2F]=' ';
    		tbl[0x30]=0xF8; tbl[0x31]=0xF1; tbl[0x32]=0xFD; tbl[0x33]='3';
    		tbl[0x34]=' ';	tbl[0x35]=0xE6; tbl[0x36]=0x14; tbl[0x37]=0xFA;
    		tbl[0x38]=' ';	tbl[0x39]='1';	tbl[0x3A]=0xA7; tbl[0x3B]=0xAF;
    		tbl[0x3C]=0xAC; tbl[0x3D]=0xAB; tbl[0x3E]=' ';	tbl[0x3F]=0xA8;
    		tbl[0x40]='A';	tbl[0x41]='A';	tbl[0x42]='A';	tbl[0x43]='A';
    		tbl[0x44]=0x8E; tbl[0x45]=0x8F; tbl[0x46]=0x92; tbl[0x47]=0x80;
    		tbl[0x48]='E';	tbl[0x49]=0x90; tbl[0x4A]='E';	tbl[0x4B]='E';
    		tbl[0x4C]='I';	tbl[0x4D]='I';	tbl[0x4E]='I';	tbl[0x4F]='I';
    		tbl[0x50]=' ';	tbl[0x51]=0xA5; tbl[0x52]='O';	tbl[0x53]='O';
    		tbl[0x54]='O';	tbl[0x55]='O';	tbl[0x56]=0x99; tbl[0x57]='O';
    		tbl[0x58]=0xED; tbl[0x59]='U';	tbl[0x5A]='U';	tbl[0x5B]='U';
    		tbl[0x5C]=0x9A; tbl[0x5D]='Y';	tbl[0x5E]=' ';	tbl[0x5F]=0xE1;
    		tbl[0x60]=0x85; tbl[0x61]=0xA0; tbl[0x62]=0x83; tbl[0x63]='a';
    		tbl[0x64]=0x84; tbl[0x65]=0x86; tbl[0x66]=0x91; tbl[0x67]=0x87;
    		tbl[0x68]=0x8A; tbl[0x69]=0x82; tbl[0x6A]=0x88; tbl[0x6B]=0x89;
    		tbl[0x6C]=0x8D; tbl[0x6D]=0xA1; tbl[0x6E]=0x8C; tbl[0x6F]=0x8B;
    		tbl[0x70]=' ';	tbl[0x71]=0xA4; tbl[0x72]=0x95; tbl[0x73]=0xA2;
    		tbl[0x74]=0x93; tbl[0x75]='o' ; tbl[0x76]=0x94; tbl[0x77]='o';
    		tbl[0x78]='o';	tbl[0x79]=0x97; tbl[0x7A]=0xA3; tbl[0x7B]=0x96;
    		tbl[0x7C]=0x81; tbl[0x7D]=0x98; tbl[0x7E]=' ';	tbl[0x7F]=' ';
    		break;
    	case ETEXT('B'):	/* normal ASCII */
    	case ETEXT('Y') :	/* KANJI */
    	default :	/* unimplemented */
    		break;	/* leave as is */
    		}
    	}
    
    /* end of vt_chars.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\ext\pageext.hh ===
/*	File: D:\wacker\ext\pageext.hh (Created: 01-Mar-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:27p $
 */

//
// The class ID of this page extension class.
//	"{1B53F360-9A1B-1069-930C-00AA0030EBC8}"
//
// The class ID of the icon handleer
//
// {88895560-9AA2-1069-930E-00AA0030EBC8}

DEFINE_GUID(CLSID_SamplePageExt, 0x1B53F360, 0x9A1B, 0x1069, 0x93,0x0C,0x00,0xAA,0x00,0x30,0xEB,0xC8);
DEFINE_GUID(CLSID_SampleIconExt, 0x88895560, 0x9AA2, 0x1069, 0x93,0x0E,0x00,0xAA,0x00,0x30,0xEB,0xC8);

typedef HRESULT (CALLBACK FAR * LPFNCREATEINSTANCE)(LPUNKNOWN pUnkOuter,
	REFIID riid, LPVOID FAR* ppvObject);


void FSPage_AddPages(LPDATAOBJECT pdtobj,
			LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

void NETPage_AddPages(LPDATAOBJECT pdtobj,
		    LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

STDAPI SHCreateDefClassObject(REFIID riid, LPVOID FAR* ppv,
			 LPFNCREATEINSTANCE lpfnCI, UINT FAR * pcRefDll,
			 REFIID riidInst);

HRESULT CALLBACK IconExt_CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR*);

extern UINT g_cRefThisDll;		// Reference count of this DLL.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\ext2\makefile.inc ===
$(O)\pageext.c : ..\ext\pageext.c
    copy $? $@

$(O)\defclsf.c : ..\ext\defclsf.c
    copy $? $@

$(O)\fspage.c : ..\ext\fspage.c
    copy $? $@

$(O)\pageext.hh : ..\ext\pageext.hh
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\htrn_jis\htrn_jis.h ===
/*	File: D:\WACKER\htrn_jis\htrn_jis.h (Created: 24-Aug-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:06p $
 */

/*
 * Return codes
 */

#define	TRANS_OK			(0)

#define	TRANS_NO_SPACE		(-1)


/*
 * Function prototypes
 */

VOID *transCreateHandle(HSESSION hSession);

int transInitHandle(VOID *pHdl);

int transLoadHandle(VOID *pHdl);

int transSaveHandle(VOID *pHdl);

int transDestroyHandle(VOID *pHdl);

int transDoDialog(HWND hDLg, VOID *pHdl);

/*
 * These two functtions work about the same.  The caller stuffs character
 * after character into them and eventually gets some characters back.
 */
int transCharIn(VOID *pHdl,
				TCHAR cIn,
				int *nReady,
				int nSize,
				TCHAR *cReady);

int transCharOut(VOID *pHdl,
				TCHAR cOut,
				int *nReady,
				int nSize,
				TCHAR *cReady);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\htrn_jis\htrn_jis.hh ===
/*	File: D:\WACKER\htrn_jis\htrn_jis.hh (Created: 24-Aug-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 1:06p $
 */

/*
 * The following are the currently defined modes for input and output
 * character translation
 */
#define	PASS_THRU_MODE				1
#define	JIS_TO_SHIFT_MODE			2
#define	SHIFT_TO_JIS_MODE			3
#define	SHIFT_TO_EUC_MODE			4
#define	EUC_TO_SHIFT_MODE			5

/*
 * The following structures are used to translate the character stream
 * between Shift-JIS and JIS.
 */
struct stShiftToJis
	{
	int nInTwoByteMode;			/* already sent a mode shift sequence */
	int nLeadByteSeen;			/* previous char was a lead byte */
	int nHalfWidthKanaSeen;		/* previous char was a half width katakana */
	TCHAR chPrev;				/* the previous char */
	};

struct stJisToShift
	{
	int nInTwoByteMode;			/* already seen a mode shift sequence */
	int nSeenFirstCharacter;	/* already picked up one character */
	int nHalfWidthKanaSeen;		/* previous char was a half width katakana */
	TCHAR chPrev;				/* the character we picked up */
	int nSeenEscape;			/* we are collecting an escape sequence */
	int nEscSeqCount;			/* how many characters have we collected */
	TCHAR acBuffer[8];			/* if we exceed this, then we are lost */
	};

union uConvert
	{
	struct stShiftToJis stSTJ;
	struct stJisToShift stJTS;
	};

/*
 * The following in the internal data structure used to maintain state
 * information about the data stream and the translation mode
 */
struct stInternalCharacterTranslation
	{
	HSESSION hSession;		/* Needed by the load and dialog functions */
	int nInputMode;
	union uConvert uIn;		/* State information for input conversion */
	int nOutputMode;
	union uConvert uOut;	/* State information for output conversion */
	};

typedef	struct stInternalCharacterTranslation stICT;
typedef stICT *pstICT;

/*
 * The following macros come from the book "Understanding Japanese
 * Information Processing" by Ken Lunde.
 */

#define	SJIS1(A)	(((A >= 129) && (A <= 159)) || ((A >= 224) && (A <= 239)))
#define	SJIS2(A)	((A >= 64) && (A <= 252))
#define	HANKATA(A)	((A >= 161) && (A <= 223))
#define	ISEUC(A)	((A >= 161) && (A <= 254))

#define	ISMARU(A)	((A >= 202) && (A <= 206))
#define	ISNIGORI(A)	(((A >= 182) && (A <= 196)) || ((A >= 202) && (A <= 206)) || (A == 179))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\htrn_jis\makefile.inc ===
$(O)\verjis.rc : ..\term\verjis.rc
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\htrn_jis\htrn_jis.c ===
/*	File: D:\WACKER\htrn_jis\htrn_jis.c (Created: 28-Aug-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 8 $
 *	$Date: 5/15/02 4:42p $
 */
#include <windows.h>
#include <stdlib.h>
#pragma hdrstop

#include <tdll\stdtyp.h>
// Smart Heap has a problem with manually loaded DLL's
// so we are not using it in here.
//#include <tdll\mc.h>

#include <tdll\features.h>
#include <tdll\translat.h>
#include <tdll\session.h>
#include <tdll\globals.h>
#include <tdll\hlptable.h>
#include <tdll\sf.h>
#include <tdll\sess_ids.h>
#if defined(CHARACTER_TRANSLATION)
#include <tdll\translat.hh>
#endif
#include "htrn_jis.h"
#include "htrn_jis.hh"

#define IDS_GNRL_HELPFILE  		102
#if defined(INCL_USE_HTML_HELP)
#define IDS_HTML_HELPFILE		114
#endif

static TCHAR szHelpFileName[FNAME_LEN];

BOOL WINAPI _CRT_INIT(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);

INT_PTR CALLBACK EncodeSelectDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	transJisEntry
 *
 * DESCRIPTION:
 *	Currently, just initializes the C-Runtime library but may be used
 *	for other things later.
 *
 * ARGUMENTS:
 *	hInstDll	- Instance of this DLL
 *	fdwReason	- Why this entry point is called
 *	lpReserved	- reserved
 *
 * RETURNS:
 *	BOOL
 *
 */

static HINSTANCE hInstanceDll;

BOOL WINAPI transJisEntry(HINSTANCE hInstDll,
						DWORD fdwReason,
						LPVOID lpReserved)
	{
	hInstanceDll = hInstDll;

	// You need to initialize the C runtime if you use any C-Runtime
	// functions.

	#if defined(NDEBUG)
	return TRUE;
	#else
	return _CRT_INIT(hInstDll, fdwReason, lpReserved);
	#endif
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
VOID *transCreateHandle(HSESSION hSession)
	{
	pstICT pstI;

	pstI = malloc(sizeof(stICT));
	if (pstI)
		{
 		memset(pstI, 0, sizeof(stICT));
		pstI->hSession = hSession;
		transInitHandle(pstI);
		}
	return (VOID *)pstI;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int transInitHandle(VOID *pHdl)
	{
	pstICT pstI;

	pstI = (pstICT)pHdl;

	if (pstI)
		{
		pstI->nInputMode  = PASS_THRU_MODE;
		pstI->nOutputMode = PASS_THRU_MODE;
		}

	return TRANS_OK;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int transLoadHandle(VOID *pHdl)
	{
	pstICT pstI;
	SF_HANDLE hSF;
	long lSize;

	pstI = (pstICT)pHdl;

	if (pstI)
		{
		hSF = sessQuerySysFileHdl(pstI->hSession);
		if (hSF)
			{
			lSize = sizeof(int);
			sfGetSessionItem(hSF,
							SFID_TRANS_FIRST,
							&lSize,
							&pstI->nInputMode);
			lSize = sizeof(int);
			sfGetSessionItem(hSF,
							SFID_TRANS_FIRST + 1,
							&lSize,
							&pstI->nOutputMode);
			}
		}

	return TRANS_OK;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int transSaveHandle(VOID *pHdl)
	{
	pstICT pstI;
	SF_HANDLE hSF;

	pstI = (pstICT)pHdl;

	if (pstI)
		{
		hSF = sessQuerySysFileHdl(pstI->hSession);
		if (hSF)
			{
			sfPutSessionItem(hSF,
							SFID_TRANS_FIRST,
							sizeof(int),
							&pstI->nInputMode);
			sfPutSessionItem(hSF,
							SFID_TRANS_FIRST + 1,
							sizeof(int),
							&pstI->nOutputMode);
			}
		}

	return TRANS_OK;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int transDestroyHandle(VOID *pHdl)
	{
	pstICT pstI;

	pstI = (pstICT)pHdl;

	if (pstI)
		{
		free(pstI);
		pstI = NULL;
		}

	return TRANS_OK;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int transDoDialog(HWND hDlg, VOID *pHdl)
	{
	pstICT pstI;

	pstI = (pstICT)pHdl;

	if (pstI)
		{
		DialogBoxParam(
					hInstanceDll,
					"IDD_TRANSLATE",
					hDlg,
					EncodeSelectDlg,
					(LPARAM)pstI->hSession
					);
		}

	return TRANS_OK;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
static void transPumpOutString(TCHAR *cReady, int *nReady, TCHAR *cOut)
	{
	TCHAR *pszPtr;

	pszPtr = cReady + *nReady;

	while (*cOut != TEXT('\0'))
		{
		*pszPtr++ = *cOut++;
		*nReady += 1;
		}
	}
static void transPumpOutChar(TCHAR *cReady, int *nReady, TCHAR cOut)
	{
	TCHAR *pszPtr;

	pszPtr = cReady + *nReady;

	*pszPtr = cOut;
	*nReady += 1;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
static void transShiftToJisOut(struct stShiftToJis *pstS,
								TCHAR *cReady,
								int *nReady,
								TCHAR cOne,
								TCHAR cTwo)
	{
	unsigned int adjust;
	unsigned int rowOffset;
	unsigned int cellOffset;

	if (!pstS->nInTwoByteMode)
		{
		transPumpOutString(cReady,
							nReady,
							TEXT("\x1B$B"));
		pstS->nInTwoByteMode = TRUE;
		}

	adjust     = cTwo < 159;
	rowOffset  = (cOne < 160) ? 112 : 176;
	cellOffset = adjust ? ((cTwo > 127) ? 32 : 31) : 126;
	cOne = (TCHAR)(((cOne - rowOffset) << 1) - adjust);
	cTwo -= (TCHAR)cellOffset;
	transPumpOutChar(cReady, nReady, cOne);
	transPumpOutChar(cReady, nReady, cTwo);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
static void transShiftToEucOut(struct stShiftToJis *pstS,
								TCHAR *cReady,
								int *nReady,
								TCHAR cOne,
								TCHAR cTwo)
	{
	unsigned int adjust;
	unsigned int rowOffset;
	unsigned int cellOffset;

	adjust     = cTwo < 159;
	rowOffset  = (cOne < 160) ? 112 : 176;
	cellOffset = adjust ? ((cTwo > 127) ? 32 : 31) : 126;
	cOne = (TCHAR)(((cOne - rowOffset) << 1) - adjust);
	cOne |= 0x80;
	cTwo -= (TCHAR)cellOffset;
	cTwo |= 0x80;
	transPumpOutChar(cReady, nReady, cOne);
	transPumpOutChar(cReady, nReady, cTwo);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
static void transJisToShiftOut(struct stJisToShift *pstJ,
								TCHAR *cReady,
								int *nReady,
								TCHAR cOne,
								TCHAR cTwo)
	{
	unsigned int rowOffset;
	unsigned int cellOffset;

	rowOffset = (cOne < 95) ? 112 : 176;
	cellOffset = (cOne % 2) ? ((cTwo > 95) ? 32 : 31) : 126;

	cOne = (TCHAR)(((cOne + 1) >> 1) + rowOffset);
	cTwo += (TCHAR)cellOffset;
	transPumpOutChar(cReady, nReady, cOne);
	transPumpOutChar(cReady, nReady, cTwo);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
static void transEucToShiftOut(struct stJisToShift *pstJ,
								TCHAR *cReady,
								int *nReady,
								TCHAR cOne,
								TCHAR cTwo)
	{
	unsigned int rowOffset;
	unsigned int cellOffset;

	cOne &= 0x7F;
	cTwo &= 0x7F;

	rowOffset = (cOne < 95) ? 112 : 176;
	cellOffset = (cOne % 2) ? ((cTwo > 95) ? 32 : 31) : 126;

	cOne = (TCHAR)(((cOne + 1) >> 1) + rowOffset);
	cTwo += (TCHAR)cellOffset;
	transPumpOutChar(cReady, nReady, cOne);
	transPumpOutChar(cReady, nReady, cTwo);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *	cOne	-- the half width katakana character
 *	cTwo	-- the next character, maybe a MARU or NIGORI
 *
 * RETURNS:
 *	TRUE means that both characters were processed, no further action needed.
 *	FALSE means that the second character still needs to be processed.
 *
 */
static int transHalfToFullKatakana(struct stShiftToJis *pstS,
									TCHAR *cReady,
									int *nReady,
									int fJisOut,
									TCHAR cOne,
									TCHAR cTwo)
	{
	int nRet = TRUE;
	int nigori = FALSE;
	int maru = FALSE;
	int tmp;
	/*
	 * The data structure for mapping half width katakana characters to
	 * full width characters in the Shift-JIS encoding scheme.
	 */
	int mtable[][2] = {
		{129,66},{129,117},{129,118},{129,65},{129,69},{131,146},{131,64},
		{131,66},{131,68},{131,70},{131,72},{131,131},{131,133},{131,135},
		{131,98},{129,91},{131,65},{131,67},{131,69},{131,71},{131,73},
		{131,74},{131,76},{131,78},{131,80},{131,82},{131,84},{131,86},
		{131,88},{131,90},{131,92},{131,94},{131,96},{131,99},{131,101},
		{131,103},{131,105},{131,106},{131,107},{131,108},{131,109},
		{131,110},{131,113},{131,116},{131,119},{131,122},{131,125},
		{131,126},{131,128},{131,129},{131,130},{131,132},{131,134},
		{131,136},{131,137},{131,138},{131,139},{131,140},{131,141},
		{131,143},{131,147},{129,74},{129,75}
		};

	if (cTwo == 222)			/* Is it a nigori mark ? */
		{
		if (ISNIGORI(cOne))		/* Can it be modified with a NIGORI ? */
			nigori = TRUE;
		else
			nRet = FALSE;
		}
	else if (cTwo == 223)		/* Is it a maru mark ? */
		{
		if (ISMARU(cOne))		/* Can it be modified with a MARU ? */
			maru = TRUE;
		else
			nRet = FALSE;
		}
	else
		{
		/* Wasn't a nigori or a maru */
		nRet = FALSE;
		}

	tmp = cOne;

	cOne = (TCHAR)mtable[tmp - 161][0];
	cTwo = (TCHAR)mtable[tmp - 161][1];

	if (nigori)
		{
		/*
		 * Transform a kana into a kana with nigori
		 */
		if (((cTwo >= 74) && (cTwo <= 103)) ||
			((cTwo >= 110) && (cTwo <= 122)))
			{
			cTwo += 1;
			}
		else if ((cOne == 131) && (cTwo == 69))
			{
			cTwo = (TCHAR)148;
			}
		}
	if (maru)
		{
		/*
		 * Transform a kana into a kana with maru
		 */
		if ((cTwo >= 110) && (cTwo <= 122))
			{
			cTwo += 2;
			}
		}

	if (fJisOut)
		{
		transShiftToJisOut(pstS,
						cReady,
						nReady,
						cOne,
						cTwo);
		}
	else
		{
		transShiftToEucOut(pstS,
						cReady,
						nReady,
						cOne,
						cTwo);
		}

	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int transCharIn(VOID *pHdl,
				TCHAR cIn,
				int *nReady,
				int nSize,
				TCHAR *cReady)
	{
	int nOK;
	int nTemp;
	TCHAR cTest;
	pstICT pstI;
	struct stJisToShift *pstJ;

	*nReady = 0;
											
	pstI = (pstICT)pHdl;

	if (pstI)
		{
		switch(pstI->nInputMode)
			{
			case PASS_THRU_MODE:
				if (nSize > 0)
					{
					*cReady = cIn;
					*nReady = 1;
					}
				break;
			case JIS_TO_SHIFT_MODE:
				/*
				 * This code is a modified version of the code found in the
				 * book "Understanding Japanese Information Processing" by
				 * Ken Lunde.  See page 171, "Seven- to Eight-bit Conversion".
				 */
				pstJ = (struct stJisToShift *)&pstI->uIn;
				if (cIn == TEXT('\x1B'))
					{
					/* The magical escape sequence */
					nTemp = pstJ->nInTwoByteMode;
					memset(pstJ, 0, sizeof(struct stJisToShift));
					pstJ->nInTwoByteMode = nTemp;
					pstJ->nSeenEscape = TRUE;
					}
				else if (pstJ->nSeenEscape)
					{
					/*
					 * OK, this is the messy place.  Just hang on and we will
					 * get thru without too many injuries.
					 *
					 * This will need to be rewritten if the escape sequences
					 * that we look for are changed.
					 *
					 * Currently we accept:
					 *	<esc> $ B	to shift into 2 byte mode
					 *	<esc> ( J	to shift out of 2 byte mode
					 *
					 * added codes as of 18-Jan-95:
					 *	<esc> $ @	to shift into 2 byte mode
					 *	<esc> ( H	to shift out of 2 byte mode
					 *	<esc> ( B	to shift out of 2 byte mode
					 */
					pstJ->acBuffer[pstJ->nEscSeqCount] = cIn;
					pstJ->nEscSeqCount += 1;
					nOK = TRUE;
					switch(pstJ->nEscSeqCount)
						{
						case 1:
							cTest = pstJ->acBuffer[0];
							if ((cTest == TEXT('$')) || (cTest == TEXT('(')))
								break;	/* OK */
							nOK = FALSE;
							break;
						case 2:
							cTest = pstJ->acBuffer[0];
							switch (cTest)
								{
								case TEXT('$'):
									cTest = pstJ->acBuffer[1];
									switch (cTest)
										{
									case TEXT('B'):
									case TEXT('@'):
										/*
										 * Shift to two byte mode
										 */
										if (!pstJ->nInTwoByteMode)
											{
											memset(pstJ, 0,
												sizeof(struct stJisToShift));
											pstJ->nInTwoByteMode = TRUE;
											}
										break;
									default:
										nOK = FALSE;
										break;
										}
									break;
								case TEXT('('):
									cTest = pstJ->acBuffer[1];
									switch (cTest)
										{
									case TEXT('J'):
									case TEXT('H'):
									case TEXT('B'):
										/*
										 * Shift from two byte mode
										 */
										if (pstJ->nInTwoByteMode)
											{
											memset(pstJ, 0,
												sizeof(struct stJisToShift));
											pstJ->nInTwoByteMode = FALSE;
											}
										break;
									default:
										nOK = FALSE;
										break;
										}
									break;
								default:
									nOK = FALSE;
									break;
								}
							break;
						default:
							nOK = FALSE;
							break;
						}
					if (!nOK)
						{
						pstJ->acBuffer[pstJ->nEscSeqCount] = TEXT('\0');
						/*
						 * Dump out whatever it is we have seen
						 */
						if (pstJ->nSeenEscape)
							{
							transPumpOutChar(cReady, nReady, TEXT('\x1B'));
							}
						transPumpOutString(cReady,
											nReady,
											pstJ->acBuffer);
						/*
						 * For now, preserve the state of nInTwoByteMode
						 */
						nTemp = pstJ->nInTwoByteMode;
						memset(pstJ, 0, sizeof(struct stJisToShift));
						pstJ->nInTwoByteMode = nTemp;
						}
					}
				else if (pstJ->nSeenFirstCharacter)
					{
					/*
					 * Got two characters to convert and pump out
					 */
					transJisToShiftOut(pstJ,
										cReady,
										nReady,
										pstJ->chPrev,
										cIn);
					pstJ->nSeenFirstCharacter = FALSE;
					pstJ->chPrev = TEXT('\0');
					}
				else if ((cIn == TEXT('\n')) || (cIn == TEXT('\r')))
					{
					/*
					 * Switch out of two byte mode
					 */
					pstJ->nInTwoByteMode = FALSE;
					pstJ->nSeenFirstCharacter = FALSE;
					pstJ->chPrev = TEXT('\0');
					transPumpOutChar(cReady, nReady, cIn);
					}
				else
					{
					if (pstJ->nInTwoByteMode)
						{
						pstJ->nSeenFirstCharacter = TRUE;
						pstJ->chPrev = cIn;
						}
					else
						{
						/*
						 * Nothing going on, just pump out the character
						 */
						transPumpOutChar(cReady, nReady, cIn);
						}
					}
				break;
			case EUC_TO_SHIFT_MODE:
				pstJ = (struct stJisToShift *)&pstI->uOut;

				if (pstJ->nSeenFirstCharacter)
					{
					if (ISEUC(cIn))
						{
						transEucToShiftOut(pstJ,
											cReady,
											nReady,
											pstJ->chPrev,
											cIn);
						}
					else
						{
						transPumpOutChar(cReady, nReady, pstJ->chPrev);
						transPumpOutChar(cReady, nReady, cIn);
						}
					pstJ->nSeenFirstCharacter = FALSE;
					pstJ->chPrev = 0;
					}
				else if (pstJ->nHalfWidthKanaSeen)
					{
					/*
					 * Handle result of the previous case
					 */
					transPumpOutChar(cReady, nReady, cIn);
					pstJ->nHalfWidthKanaSeen = FALSE;
					pstJ->chPrev = TEXT('\0');
					}
				else if (cIn == 0x8E)
					{
					/*
					 * Set up to convert next character to half width katakana
					 */
					pstJ->nHalfWidthKanaSeen = TRUE;
					pstJ->chPrev = cIn;
					}
				else if (ISEUC(cIn))
					{
					pstJ->nSeenFirstCharacter = TRUE;
					pstJ->chPrev = cIn;
					}
				else
					{
					transPumpOutChar(cReady, nReady, cIn);
					}
				break;
			case SHIFT_TO_JIS_MODE:
			default:
				break;
			}
		}

	return TRANS_OK;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
int transCharOut(VOID *pHdl,
				TCHAR cOut,
				int *nReady,
				int nSize,
				TCHAR *cReady)
	{
	pstICT pstI;
	struct stShiftToJis *pstS;
	int nFinished;

	*nReady = 0;

	pstI = (pstICT)pHdl;

restart:
	if (pstI)
		{
		switch(pstI->nOutputMode)
			{
			case PASS_THRU_MODE:
				if (nSize > 0)
					{
					*cReady = cOut;
					*nReady = 1;
					}
				break;
			case SHIFT_TO_JIS_MODE:
				/*
				 * This code is a modified version of the code found in the
				 * book "Understanding Japanese Information Processing" by
				 * Ken Lunde.  See page 170, "Eight- to Seven-bit Conversion".
				 */
				pstS = (struct stShiftToJis *)&pstI->uOut;
				if ((cOut == TEXT('\r')) || (cOut == TEXT('\n')))
					{
					if (pstS->nInTwoByteMode)
						{
						/* Output the escape to one bye sequence */
						transPumpOutString(cReady,
											nReady,
											TEXT("\x1B(J"));
					
						pstS->nInTwoByteMode = FALSE;
						}
					/* Output the end of line character */
					transPumpOutChar(cReady, nReady, cOut);
					}
				else if (pstS->nLeadByteSeen)
					{
					/* Already seen a lead byte last time thru */
					transShiftToJisOut(pstS,
									cReady,
									nReady,
									pstS->chPrev,
									cOut);

					pstS->nLeadByteSeen = FALSE;
					pstS->chPrev = TEXT('\0');
					}
				else if (pstS->nHalfWidthKanaSeen)
					{
					nFinished = transHalfToFullKatakana(pstS,
														cReady,
														nReady,
														TRUE,
														pstS->chPrev,
														cOut);
					pstS->nHalfWidthKanaSeen = FALSE;
					pstS->chPrev = TEXT('\0');
					if (!nFinished)
						goto restart;
					}
				else if (SJIS1(cOut))
					{
					/* If the character is a DBCS lead byte */
					pstS->nLeadByteSeen = TRUE;
					pstS->chPrev = cOut;
					}
				else if (HANKATA(cOut))
					{
					/* If the character is a half width katakana character */
					pstS->nHalfWidthKanaSeen = TRUE;
					pstS->chPrev = cOut;
					}
				else
					{
					if (pstS->nInTwoByteMode)
						{
						/* Output the escape to one bye sequence */
						transPumpOutString(cReady,
											nReady,
											TEXT("\x1B(J"));
						pstS->nInTwoByteMode = FALSE;
						}

					/* Output the character */
					transPumpOutChar(cReady, nReady, cOut);
					}
				break;
			case SHIFT_TO_EUC_MODE:
				/*
				 */
				pstS = (struct stShiftToJis *)&pstI->uOut;
				if (pstS->nLeadByteSeen)
					{
					/* Already seen a lead byte last time thru */
					transShiftToEucOut(pstS,
									cReady,
									nReady,
									pstS->chPrev,
									cOut);
					pstS->nLeadByteSeen = FALSE;
					pstS->chPrev = TEXT('\0');
					}
				else if (pstS->nHalfWidthKanaSeen)
					{
					nFinished = transHalfToFullKatakana(pstS,
														cReady,
														nReady,
														FALSE,
														pstS->chPrev,
														cOut);
					pstS->nHalfWidthKanaSeen = FALSE;
					pstS->chPrev = TEXT('\0');
					if (!nFinished)
						goto restart;
					}
				else if (SJIS1(cOut))
					{
					/* If the character is a DBCS lead byte */
					pstS->nLeadByteSeen = TRUE;
					pstS->chPrev = cOut;
					}
				else if (HANKATA(cOut))
					{
					/* If the character is a half width katakana character */
					transPumpOutChar(cReady, nReady, (TCHAR)0x8E);
					transPumpOutChar(cReady, nReady, cOut);
					}
				else
					{
					transPumpOutChar(cReady, nReady, cOut);
					}
				break;
			case JIS_TO_SHIFT_MODE:
			default:
				break;
			}
		}

	return TRANS_OK;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * DESCRIPTION:
 *	Header stuff for the dialog procedure that follows.
 *
 * NOTE:
 *	Most of this stuff was copied from TDLL\GENRCDLG.C along with the
 *	framework code for the dialog procedure.
 */

#if !defined(DlgParseCmd)
#define DlgParseCmd(i,n,c,w,l) i=LOWORD(w);n=HIWORD(w);c=(HWND)l;
#endif

struct stSaveDlgStuff
	{
	/*
	 * Put in whatever else you might need to access later
	 */
	HSESSION hSession;
	};

typedef	struct stSaveDlgStuff SDS;

// Dialog control defines...

#define	IDC_GR_TRANSLATION		101
#define	IDC_RB_SHIFT_JIS		102
#define	IDC_RB_STANDARD_JIS		103
#define IDC_PB_HELP				8

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:	EncodeSelectDlg
 *
 * DESCRIPTION: Dialog manager stub
 *
 * ARGUMENTS:	Standard Windows dialog manager
 *
 * RETURNS: 	Standard Windows dialog manager
 *
 */
INT_PTR CALLBACK EncodeSelectDlg(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	HWND	hwndChild;
	INT		nId;
	INT		nNtfy;
	SDS    *pS;
	static  aHlpTable[] = {IDC_GR_TRANSLATION,		IDH_HTRN_DIALOG,
							IDC_RB_SHIFT_JIS,		IDH_HTRN_SHIFTJIS,
							IDC_RB_STANDARD_JIS,	IDH_HTRN_JIS,
		                    IDCANCEL,               IDH_CANCEL,
		                    IDOK,                   IDH_OK,
							0,						0};

#if defined(CHARACTER_TRANSLATION)
	HHTRANSLATE hTrans = NULL;
	pstICT pstI;
#endif

	switch (wMsg)
		{
	case WM_INITDIALOG:
		pS = (SDS *)malloc(sizeof(SDS));
		if (pS == (SDS *)0)
			{
	   		/* TODO: decide if we need to display an error here */
			EndDialog(hDlg, FALSE);
			break;
			}

		SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pS);

		// mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

		pS->hSession = (HSESSION)lPar;
#if defined(CHARACTER_TRANSLATION)
		hTrans = (HHTRANSLATE)sessQueryTranslateHdl(pS->hSession);

		if (hTrans)
			{
			pstI = (pstICT)hTrans->pDllHandle;

			if (pstI == NULL || (pstI && pstI->nInputMode == PASS_THRU_MODE))
				{
				CheckDlgButton(hDlg, IDC_RB_SHIFT_JIS, TRUE);
				}
			else
				{
				CheckDlgButton(hDlg, IDC_RB_STANDARD_JIS, TRUE);
				}
			}
#endif

		break;

	case WM_DESTROY:
		break;

	case WM_CONTEXTMENU:
        if ( ((LPHELPINFO)lPar)->iCtrlId == IDOK || ((LPHELPINFO)lPar)->iCtrlId == IDCANCEL )
            {
			WinHelp(((LPHELPINFO)lPar)->hItemHandle,
				TEXT("windows.hlp"),
				HELP_CONTEXTMENU,
				(DWORD_PTR)(LPTSTR)aHlpTable);
            }
        else
            {
			LoadString(hInstanceDll, IDS_GNRL_HELPFILE, szHelpFileName,
						sizeof(szHelpFileName) / sizeof(TCHAR));

			WinHelp((HWND)wPar,
				szHelpFileName,
				HELP_CONTEXTMENU,
				(DWORD_PTR)(LPTSTR)aHlpTable);
			}
		break;

	case WM_HELP:
        if ( ((LPHELPINFO)lPar)->iCtrlId == IDOK || ((LPHELPINFO)lPar)->iCtrlId == IDCANCEL )
            {
			WinHelp(((LPHELPINFO)lPar)->hItemHandle,
				TEXT("windows.hlp"),
				HELP_WM_HELP,
				(DWORD_PTR)(LPTSTR)aHlpTable);
            }
        else
            {
			LoadString(hInstanceDll, IDS_GNRL_HELPFILE, szHelpFileName,
						sizeof(szHelpFileName) / sizeof(TCHAR));

			WinHelp(((LPHELPINFO)lPar)->hItemHandle,
				szHelpFileName,
				HELP_WM_HELP,
				(DWORD_PTR)(LPTSTR)aHlpTable);
			}
		break;

	case WM_COMMAND:

		/*
		 * Did we plan to put a macro in here to do the parsing ?
		 */
		DlgParseCmd(nId, nNtfy, hwndChild, wPar, lPar);

		switch (nId)
			{
		case IDOK:
			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			/*
			 * Do whatever saving is necessary
			 */
#if defined(CHARACTER_TRANSLATION)
			hTrans = (HHTRANSLATE)sessQueryTranslateHdl(pS->hSession);

			if (hTrans)
				{
				pstI = (pstICT)hTrans->pDllHandle;

				if (pstI)
					{
					if (IsDlgButtonChecked(hDlg, IDC_RB_SHIFT_JIS) == BST_CHECKED)
						{
						pstI->nInputMode  = PASS_THRU_MODE;
						pstI->nOutputMode = PASS_THRU_MODE;
						}
					else
						{
						pstI->nInputMode  = JIS_TO_SHIFT_MODE;
						pstI->nOutputMode = SHIFT_TO_JIS_MODE;
						}
					}
				}
#endif

			/* Free the storeage */
			free(pS);
			pS = (SDS *)0;
			EndDialog(hDlg, TRUE);
			break;

		case IDCANCEL:
			pS = (SDS *)GetWindowLongPtr(hDlg, DWLP_USER);
			/* Free the storeage */
			free(pS);
			pS = (SDS *)0;
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: transQueryMode
 *
 * DESCRIPTION:
 *	
 * ARGUMENTS:
 *
 * RETURNS:
 */
int transQueryMode(VOID *pHdl)
	{
	pstICT pstI;
	int nReturn;

	pstI = (pstICT)pHdl;

	if(pstI->nInputMode	== PASS_THRU_MODE)
	   {
	   nReturn = 0;
	   }
	else
	   {
	   nReturn = 1;
	   }
	return(nReturn);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: transSetMode
 *
 * DESCRIPTION:
 *	
 * ARGUMENTS:
 *
 * RETURNS:
 */
int transSetMode(VOID *pHdl,
                 int   nMode)
   {

	pstICT pstI;


	pstI = (pstICT)pHdl;

	if (nMode == 0)
	   {
	   pstI->nInputMode  = PASS_THRU_MODE;
	   pstI->nOutputMode = PASS_THRU_MODE;
	   }
	else
	   {
	   pstI->nInputMode  = JIS_TO_SHIFT_MODE;
	   pstI->nOutputMode = SHIFT_TO_JIS_MODE;
	   }
	
	return(1);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\asciidlg.c ===
/*	File: D:\WACKER\tdll\asciidlg.c (Created: 21-Feb-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 11 $
 *	$Date: 5/17/02 2:25p $
 */
#include <windows.h>
#pragma hdrstop

#include <tchar.h>
#include <limits.h>

#include "assert.h"
#include "stdtyp.h"
#include "misc.h"
#include "globals.h"
#include "session.h"
#include "hlptable.h"
#include "..\emu\emu.h"
#include "property.hh"

#include "htchar.h"
#include "errorbox.h"
#include "..\term\res.h"

// Function prototypes...
//
INT_PTR CALLBACK asciiSetupDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar);

#define IDC_GR_ASCII_SENDING		    400
#define IDC_ASCII_SEND_LINE 		    401
#define IDC_ASCII_SEND_ECHO 		    402
#define IDC_GR_ASCII_RECEIVING		    403
#define IDC_ASCII_REC_APPEND		    404
#define IDC_ASCII_REC_FORCE 		    405
#define IDC_ASCII_REC_WRAP			    406
#define IDC_ASCII_SEND_LINE_DELAY_LABEL 407
#define IDC_ASCII_SEND_LINE_DELAY	    408
#define IDC_ASCII_SEND_LINE_DELAY_MSECS 409
#define IDC_ASCII_SEND_CHAR_DELAY_LABEL 410
#define IDC_ASCII_SEND_CHAR_DELAY	    411
#define IDC_ASCII_SEND_CHAR_DELAY_MSECS 412


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
INT_PTR CALLBACK asciiSetupDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	static DWORD aHlpTable[] =
			{
			IDC_ASCII_SEND_LINE,		        IDH_TERM_ASCII_SEND_LINE,
			IDC_ASCII_SEND_ECHO,		        IDH_TERM_ASCII_SEND_ECHO,
			IDC_GR_ASCII_SENDING,		        IDH_TERM_ASCII_SENDING,
			IDC_GR_ASCII_RECEIVING, 	        IDH_TERM_ASCII_RECEIVING,
			IDC_ASCII_REC_APPEND,		        IDH_TERM_ASCII_REC_APPEND,
			IDC_ASCII_REC_FORCE,		        IDH_TERM_ASCII_REC_FORCE,
			IDC_ASCII_REC_WRAP, 		        IDH_TERM_ASCII_REC_WRAP,
            IDC_ASCII_SEND_CHAR_DELAY_LABEL,    IDH_TERM_ASCII_CHAR_DELAY,
			IDC_ASCII_SEND_CHAR_DELAY,	        IDH_TERM_ASCII_CHAR_DELAY,
            IDC_ASCII_SEND_CHAR_DELAY_MSECS,    IDH_TERM_ASCII_CHAR_DELAY,
            IDC_ASCII_SEND_LINE_DELAY_LABEL,    IDH_TERM_ASCII_LINE_DELAY,
			IDC_ASCII_SEND_LINE_DELAY,	        IDH_TERM_ASCII_LINE_DELAY,
            IDC_ASCII_SEND_LINE_DELAY_MSECS,    IDH_TERM_ASCII_LINE_DELAY,
            IDCANCEL,                           IDH_CANCEL,
            IDOK,                               IDH_OK,
			0,							0
			};

	switch (wMsg)
		{
	case WM_INITDIALOG:
		{
		BOOL isVTUTF8;
		pSDS pS = (SDS *)lPar;

		if (pS == NULL)
			{
			assert(FALSE);
			return FALSE;
			}

		SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pS);

		mscCenterWindowOnWindow(hDlg, GetParent(hDlg));

		// Initialize various controls...
		//
        isVTUTF8 = (pS->stEmuSettings.nEmuId == EMU_VTUTF8);

        EnableWindow(GetDlgItem(hDlg, IDC_ASCII_SEND_LINE), !isVTUTF8);

		SendDlgItemMessage(hDlg, IDC_ASCII_SEND_LINE, BM_SETCHECK,
                           (isVTUTF8) ? 0 : pS->stAsciiSettings.fsetSendCRLF, 0);

		SendDlgItemMessage(hDlg, IDC_ASCII_SEND_ECHO, BM_SETCHECK,
			               pS->stAsciiSettings.fsetLocalEcho, 0);

        EnableWindow(GetDlgItem(hDlg, IDC_ASCII_REC_APPEND), !isVTUTF8);

		SendDlgItemMessage(hDlg, IDC_ASCII_REC_APPEND, BM_SETCHECK,
                           (isVTUTF8) ? 0 : pS->stAsciiSettings.fsetAddLF, 0);

        EnableWindow(GetDlgItem(hDlg, IDC_ASCII_REC_FORCE), !isVTUTF8);

		SendDlgItemMessage(hDlg, IDC_ASCII_REC_FORCE, BM_SETCHECK,
                           (isVTUTF8) ? 0 : pS->stAsciiSettings.fsetASCII7, 0);

		SendDlgItemMessage(hDlg, IDC_ASCII_REC_WRAP, BM_SETCHECK,
			               pS->stEmuSettings.fWrapLines, 0);

		SetDlgItemInt(hDlg, IDC_ASCII_SEND_LINE_DELAY,
			          pS->stAsciiSettings.iLineDelay, FALSE);

		//
		// Since the send line delay can only be numeric and has a
		// size between 0 and INT_MAX(2147483647), limit to 10 characters.
		//
		SendDlgItemMessage(hDlg, IDC_ASCII_SEND_LINE_DELAY,
			               EM_LIMITTEXT, 10, 0);

		//
		// Since the send character delay can only be numeric and has a
		// size between 0 and INT_MAX(2147483647), limit to 10 characters.
		//
		SetDlgItemInt(hDlg, IDC_ASCII_SEND_CHAR_DELAY,
			pS->stAsciiSettings.iCharDelay, FALSE);

		SendDlgItemMessage(hDlg, IDC_ASCII_SEND_CHAR_DELAY,
			               EM_LIMITTEXT, 10, 0);
		}

		break;

	case WM_DESTROY:
		break;

	case WM_CONTEXTMENU:
		doContextHelp(aHlpTable, wPar, lPar, TRUE, TRUE);
		break;

	case WM_HELP:
        doContextHelp(aHlpTable, wPar, lPar, FALSE, FALSE);
		break;

	case WM_COMMAND:
		switch (wPar)
			{
		case IDOK:
			{
			BOOL fTranslated = FALSE;
			UINT uiMessage = 0;
			pSDS pS = (pSDS)GetWindowLongPtr(hDlg, GWLP_USERDATA);

			if (pS == NULL)
				{
				assert(FALSE);
				}
			else
				{
				pSTASCIISET pstAsciiSet = (pSTASCIISET)&pS->stAsciiSettings;
				PSTEMUSET   pstEmuSet = (PSTEMUSET)&pS->stEmuSettings;

				assert(pstAsciiSet);
				assert(pstEmuSet);

				if (pstAsciiSet)
					{
					int nVal = 0;

					pstAsciiSet->fsetSendCRLF =
						(IsDlgButtonChecked(hDlg, IDC_ASCII_SEND_LINE) == BST_CHECKED);
					pstAsciiSet->fsetLocalEcho =
						(IsDlgButtonChecked(hDlg, IDC_ASCII_SEND_ECHO) == BST_CHECKED);
					pstAsciiSet->fsetAddLF =
						(IsDlgButtonChecked(hDlg, IDC_ASCII_REC_APPEND) == BST_CHECKED);
					pstAsciiSet->fsetASCII7 =
						(IsDlgButtonChecked(hDlg, IDC_ASCII_REC_FORCE) == BST_CHECKED);

					//
					// NOTE: since the edit boxes are marked as ES_NUMBER, we don't
					// have to worry that a negative number will be returned for
					// the IDC_ASCII_SEND_LINE_DELAY editbox control. REV: 3/27/2002
					//
					nVal = GetDlgItemInt(hDlg, IDC_ASCII_SEND_LINE_DELAY, &fTranslated, TRUE);

					if (!fTranslated)
						{
						uiMessage = IDS_ER_LINE_DELAY_SIZE;

						SetFocus(GetDlgItem(hDlg, IDC_ASCII_SEND_LINE_DELAY));
						}
					else
						{
						pstAsciiSet->iLineDelay = nVal;
						//
						// NOTE: since the edit boxes are marked as ES_NUMBER, we don't
						// have to worry that a negative number will be returned for
						// the IDC_ASCII_SEND_CHAR_DELAY editbox control. REV: 3/27/2002
						//
						nVal = GetDlgItemInt(hDlg, IDC_ASCII_SEND_CHAR_DELAY, &fTranslated, TRUE);

						if (!fTranslated)
							{
							uiMessage = IDS_ER_CHAR_DELAY_SIZE;
							SetFocus(GetDlgItem(hDlg, IDC_ASCII_SEND_CHAR_DELAY));
							}
						else
							{
							pstAsciiSet->iCharDelay = nVal;
							}
						}
					}

				if (pstEmuSet)
					{
					pstEmuSet->fWrapLines =
						(IsDlgButtonChecked(hDlg, IDC_ASCII_REC_WRAP) == BST_CHECKED);
					}
				}

			if (uiMessage != 0)
				{
				TCHAR acBuffer[256];
				TCHAR acFormat[256];

				//
				// Display an error message.
				//
				if (LoadString(glblQueryDllHinst(), uiMessage, acFormat, 256) == 0)
					{
					if (uiMessage == IDS_ER_LINE_DELAY_SIZE)
						{
						StrCharCopyN(acFormat,
									 TEXT("Invalid line delay time.  Line delay time must be between %d and %d milliseconds."),
									 256);
						}
					else if (uiMessage == IDS_ER_CHAR_DELAY_SIZE)
						{
						StrCharCopyN(acFormat,
							         TEXT("Invalid character delay time.  Character delay time must be between %d and %d milliseconds."),
									 256);
						}
					}

				wsprintf(acBuffer, acFormat, 0, INT_MAX);

				TimedMessageBox(hDlg, acBuffer, NULL,
					            MB_OK | MB_ICONEXCLAMATION, 0);
				break;
				}

			EndDialog(hDlg, fTranslated);
			}

			break;

		case IDCANCEL:
			EndDialog(hDlg, FALSE);
			break;

		default:
			return FALSE;
			}
		break;

	default:
		return FALSE;
		}

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\aboutdlg.c ===
/*	File: D:\WACKER\tdll\aboutdlg.c (Created: 04-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 21 $
 *	$Date: 4/16/02 2:36p $
 */

#include <windows.h>
#pragma hdrstop

#include <commctrl.h>
#include <term\res.h>

#include "banner.h"
#include "globals.h"
#include "features.h"
#include "misc.h"
#include "upgrddlg.h"
#include "registry.h"

#if !defined(NT_EDITION)
#if defined(INCL_PRIVATE_EDITION_BANNER)
#include "stdtyp.h"
#include <emu\emu.h>
#include "term.hh" // This must be after emu.h
INT_PTR CALLBACK AboutDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar);
LRESULT CALLBACK BannerAboutProc(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar);

DWORD CALLBACK EditStreamCallback(DWORD dwCookie, LPBYTE pbBuff,
    LONG cb, LONG *pcb);
#endif
#endif

static const TCHAR g_achHyperTerminalRegKey[] =
    TEXT("SOFTWARE\\Hilgraeve Inc\\HyperTerminal PE\\3.0");
static const TCHAR g_achSerial[] = TEXT("Registered");

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	AboutDlg
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *	hwnd	- session window handle
 *
 * RETURNS:
 *	void
 *
 */
void AboutDlg(HWND hwndSession)
	{
	#if defined(NT_EDITION)
	TCHAR	  ach1[100];
	TCHAR     ach2[100];
	HINSTANCE hInst = glblQueryDllHinst();
	HICON     lTermIcon = extLoadIcon(MAKEINTRESOURCE(IDI_HYPERTERMINAL));
	int       lReturn;

	LoadString(hInst, IDS_GNRL_APPNAME, ach1,
		sizeof(ach1) / sizeof(TCHAR));
	LoadString(hInst, IDS_GNRL_HILGRAVE_COPYRIGHT, ach2,
		sizeof(ach2) / sizeof(TCHAR));

	lReturn = ShellAbout(hwndSession,
		                 ach1,
						 ach2,
						 lTermIcon);
	#else // NT_EDITION
    #if defined(INCL_PRIVATE_EDITION_BANNER)
    DialogBox(glblQueryDllHinst(), MAKEINTRESOURCE(IDD_ABOUT_DLG),
        hwndSession, AboutDlgProc);

    #else
	TCHAR	  ach1[100];
	HWND	  hwndAbout;

	LoadString(glblQueryDllHinst(), IDS_GNRL_APPNAME, ach1,
		sizeof(ach1) / sizeof(TCHAR));

	hwndAbout = CreateWindow(BANNER_DISPLAY_CLASS,
								ach1,
								WS_CHILD | WS_VISIBLE,
								0,
								0,
								100,
								100,
								hwndSession,
								NULL,
								glblQueryDllHinst(),
								NULL);

	UpdateWindow(hwndAbout);
    #endif
	#endif // NT_EDITION
	return;
	}

// ----------------- Private edition about dialog routines ------------------
//
#if !defined(NT_EDITION)
#if defined(INCL_PRIVATE_EDITION_BANNER)
#define BANNER_ABOUT_CLASS "Banner About Class"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	AboutDlgProc
 *
 * DESCRIPTION:
 *
 */
INT_PTR CALLBACK AboutDlgProc(HWND hDlg, UINT wMsg, WPARAM wPar, LPARAM lPar)
    {
    #define IDPB_UPGRADE 100

    HWND hwndAbout;

    switch (wMsg)
        {
    case WM_INITDIALOG:
	    hwndAbout = CreateWindow(BANNER_ABOUT_CLASS,
								NULL,
								WS_CHILD | WS_VISIBLE,
								0,
								0,
								100,
								100,
								hDlg,
								NULL,
								glblQueryDllHinst(),
								NULL);
        break;

    case WM_COMMAND:
        switch (wPar)
            {
        case IDOK:
        case IDCANCEL:
			EndDialog(hDlg, TRUE);
            break;

        case IDPB_UPGRADE:
            DoUpgradeDialog(hDlg);
            break;

        default:
            break;
            }
        break;

    default:
        return FALSE;
        }

    return TRUE;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:	RegisterBannerAboutClass
 *
 * DESCRIPTION:
 *	This function registers the window class for the banner window.
 *
 * ARGUEMENTS:
 *	The task instance handle.
 *
 * RETURNS:
 * The usual TRUE/FALSE from a registration function.
 *
 */
BOOL RegisterBannerAboutClass(HANDLE hInstance)
	{
	ATOM bRet = TRUE;
	WNDCLASSEX wnd;

	memset(&wnd, 0, sizeof(WNDCLASSEX));
	wnd.cbSize = sizeof(WNDCLASSEX);

	if (GetClassInfoEx(hInstance, BANNER_ABOUT_CLASS, &wnd) == FALSE)
		{
		wnd.style			= CS_HREDRAW | CS_VREDRAW;
		wnd.lpfnWndProc 	= BannerAboutProc;
		wnd.cbClsExtra		= 0;
		wnd.cbWndExtra		= sizeof(HANDLE);
		wnd.hInstance		= hInstance;
		wnd.hIcon			= extLoadIcon(MAKEINTRESOURCE(IDI_HYPERTERMINAL));
		wnd.hCursor			= LoadCursor(NULL, IDC_ARROW);
		wnd.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
		wnd.lpszMenuName	= NULL;
		wnd.lpszClassName	= BANNER_ABOUT_CLASS;
		wnd.hIconSm         = extLoadIcon(MAKEINTRESOURCE(IDI_HYPERTERMINAL));

		bRet = RegisterClassEx(&wnd);
		}

	return bRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	AboutDlgProc
 *
 * DESCRIPTION:
 *  Pops up the about dialog.  In the private edition, this is an actual
 *  dialog of some complexity.
 *
 */
LRESULT CALLBACK BannerAboutProc(HWND hwnd, UINT uMsg, WPARAM wPar, LPARAM lPar)
    {
	RECT	    rc;
	HBITMAP	    hBitmap = (HBITMAP)0;
	BITMAP	    bm;
	INT 	    x, y, cx, cy;
   	HDC			hDC;
   	PAINTSTRUCT ps;
   	LOGFONT 	lf;
   	HFONT		hFont;
    TCHAR       atchSerialNumber[MAX_PATH * 2];
    DWORD       dwSize = sizeof(atchSerialNumber);

    switch (uMsg)
        {
    case WM_CREATE:
		//mpt:03-12-98 Changed the bitmap and avi to use system colors
		//hBitmap = LoadBitmap(glblQueryDllHinst(), MAKEINTRESOURCE(IDD_BM_BANNER));
		hBitmap = (HBITMAP)LoadImage(glblQueryDllHinst(),
			MAKEINTRESOURCE(IDD_BM_BANNER),
			IMAGE_BITMAP,
			0,
			0,
			LR_CREATEDIBSECTION | LR_LOADTRANSPARENT | LR_LOADMAP3DCOLORS);

		SetWindowLongPtr(hwnd, 0, (LONG_PTR)hBitmap);

    	GetObject(hBitmap, sizeof(BITMAP), (LPTSTR)&bm);

    	SetRect(&rc, 0, 0, bm.bmWidth, bm.bmHeight);
    	AdjustWindowRect(&rc, WS_CHILD | WS_VISIBLE, FALSE);

    	cx = rc.right - rc.left;
    	cy = rc.bottom - rc.top;

        GetClientRect(GetParent(hwnd), &rc);

    	x = (rc.right - cx) / 2;
    	y = (rc.bottom - cy) / 3;

    	MoveWindow(hwnd, x, y, cx, cy, TRUE);

        #if defined(INCL_SPINNING_GLOBE)
        // Create an animation control and play spinning globe.
        //
            {
            HWND    hwndAnimate;
			//mpt:03-12-98 Changed the bitmap and avi to use system colors
            hwndAnimate = Animate_Create(hwnd, 100,
                WS_VISIBLE | WS_CHILD | ACS_TRANSPARENT,
                glblQueryDllHinst());

            MoveWindow(hwndAnimate, 177, 37, 118, 101, TRUE);
            Animate_Open(hwndAnimate, MAKEINTRESOURCE(IDR_GLOBE_AVI));
			if (!IsTerminalServicesEnabled())
				{
				Animate_Play(hwndAnimate, 0, -1, 1);
				}
            }
        #endif
        break;

    case WM_PAINT:
    	hDC = BeginPaint(hwnd, &ps);
    	hBitmap = (HBITMAP)GetWindowLongPtr(hwnd, 0);

    	if (hBitmap)
    		utilDrawBitmap((HWND)0, hDC, hBitmap, 0, 0);

        // In the HTPE 3 banner, the version # and lot # are now in the
        // lower left corner of the bitmap. - cab:11/29/96
        //
//    #if !defined(USE_PRIVATE_EDITION_3_BANNER)
    	// Here's a mean trick.  The HwndFrame guy doesn't get set until
    	// long after the banner goes up.  Since we don't want the version
    	// number on the opening banner but do want it in the about portion
    	// this works. - mrw:3/17/95
    	//
    	if (glblQueryHwndFrame())
    		{
			memset(&lf, 0, sizeof(LOGFONT));

			lf.lfHeight = 14;
			lf.lfCharSet = ANSI_CHARSET;
			//lf.lfWeight = FW_SEMIBOLD;
			strcpy(lf.lfFaceName, "Arial");

			hFont = CreateFontIndirect(&lf);

			if (hFont)
				{
				hFont = SelectObject(hDC, hFont);
				//SetBkColor(hDC, RGB(0,255,0));
				SetBkMode( hDC, TRANSPARENT );
				TextOut(hDC, 19, 230, "Build Date", 10);
				TextOut(hDC, 19, 242, __DATE__, strlen(__DATE__));
				TextOut(hDC, 225, 230, "Copyright 2001", 15);
				TextOut(hDC, 225, 242, "Hilgraeve Inc.", 14);
				DeleteObject(SelectObject(hDC, hFont));

			    // Draw in the version number
			    //
			    if ( htRegQueryValue(HKEY_CURRENT_USER,
                                     g_achHyperTerminalRegKey,
                                     g_achSerial,
                                     atchSerialNumber,
                                     &dwSize) == 0 )
				    {

    			    hFont = SelectObject(hDC, hFont);
    			    SetBkColor(hDC, GetSysColor(COLOR_BTNFACE));
    			    TextOut(hDC, 15, 12, atchSerialNumber, strlen(atchSerialNumber));
    			    DeleteObject(SelectObject(hDC, hFont));
    			    }
				}
	   		}
//    #endif

    	EndPaint(hwnd, &ps);
        break;

    case WM_LBUTTONDOWN:
        DoUpgradeDialog(hwnd);
        break;

    default:
        break;
        }

	return DefWindowProc(hwnd, uMsg, wPar, lPar);
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:	UnregisterBannerAboutClass
 *
 * DESCRIPTION:
 *	This function registers the window class for the banner window.
 *
 * ARGUEMENTS:
 *	The task instance handle.
 *
 * RETURNS:
 * The usual TRUE/FALSE from a registration function.
 *
 */
BOOL UnregisterBannerAboutClass(HANDLE hInstance)
	{
	return UnregisterClass(BANNER_ABOUT_CLASS, hInstance);
	}

#endif //INCL_PRIVATE_EDITION_BANNER
#endif //!NT_EDITION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\assert.c ===
/*	File: D:\WACKER\tdll\assert.c (Created: 30-Nov-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 4 $
 *	$Date: 4/17/02 5:13p $
 */

#include <windows.h>
#pragma hdrstop

#include <stdarg.h>
#include "assert.h"
#include "misc.h"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DoAssertDebug
 *
 * DESCRIPTION:
 *	Our own home-grown assert function.
 *
 * ARGUMENTS:
 *	file	- file where it happened
 *	line	- line where is happened
 *
 * RETURNS:
 *	void
 *
 */
void DoAssertDebug(TCHAR *file, int line)
	{
#if !defined(NDEBUG)
	int retval;
	TCHAR buffer[256];

	wsprintf(buffer,
			TEXT("Assert error in file %s on line %d.\n")
			TEXT("Press YES to continue, NO to call CVW, CANCEL to exit.\n"),
			file, line);

	retval = MessageBox(NULL, buffer, TEXT("Assert"),
		                MB_ICONEXCLAMATION | MB_YESNOCANCEL | MB_SETFOREGROUND);

	switch (retval)
		{
		case IDYES:
			return;

		case IDNO:
			DebugBreak();
			return;

		case IDCANCEL:
			mscMessageBeep(MB_ICONHAND);
			ExitProcess(1);
			break;

		default:
			break;
		}

	return;
#endif
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DoDbgOutStr
 *
 * DESCRIPTION:
 *	Used to output a string to a debug monitor.  Use the macros defined
 *	in ASSERT.H to access this function.
 *
 * ARGUMENTS:
 *	LPTSTR	achFmt	- printf style format string.
 *	... 			- arguments used in formating list.
 *
 * RETURNS:
 *	VOID
 *
 */
VOID __cdecl DoDbgOutStr(TCHAR *achFmt, ...)
	{
#if !defined(NDEBUG)
	va_list valist;
	TCHAR	achBuf[256];

	va_start(valist, achFmt);

	wvsprintf(achBuf, achFmt, valist);
	OutputDebugString(achBuf);

	va_end(valist);
	return;
#endif
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	DoShowLastError
 *
 * DESCRIPTION:
 * 	Does a GetLastError() and displays it.  Similar to assert.
 *
 * ARGUMENTS:
 *	file	- file where it happened
 *	line	- line where it happened
 *
 * RETURNS:
 *	void
 *
 */
void DoShowLastError(const TCHAR *file, const int line)
	{
#if !defined(NDEBUG)
	int retval;
	TCHAR ach[256];
	const DWORD dwErr = GetLastError();

	if (dwErr == 0)
		return;

	wsprintf(ach, TEXT("GetLastError=0x%x in file %s, on line %d\n")
				  TEXT("Press YES to continue, NO to call CVW, CANCEL to exit.\n"),
				  dwErr, file, line);

	retval = MessageBox(NULL, ach, TEXT("GetLastError"),
		                MB_ICONEXCLAMATION | MB_YESNOCANCEL | MB_SETFOREGROUND);

	switch (retval)
		{
		case IDYES:
			return;

		case IDNO:
			DebugBreak();
			return;

		case IDCANCEL:
			mscMessageBeep(MB_ICONHAND);
			ExitProcess(1);
			break;

		default:
			break;
		}

	return;
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\autosave.c ===
/*	File: D:\WACKER\tdll\autosave.c (Created: 19-Mar-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 19 $
 *	$Date: 7/12/02 1:06p $
 */

#include <windows.h>
#pragma hdrstop

#include "features.h"

#include "stdtyp.h"
#include "sf.h"
#include "mc.h"
#include "term.h"
#include "assert.h"
#include "globals.h"
#include "sess_ids.h"
#include "load_res.h"
#include "open_msc.h"
#include "file_msc.h"
#include <term\res.h>
#include "session.h"
#include "session.hh"
#include "errorbox.h"
#include "tdll.h"
#include "htchar.h"
#include "misc.h"
#include <emu\emu.h>

//
// Static function prototypes...
//
STATIC_FUNC BOOL asCreateFullFileName(const HSESSION hSession,
									  const int iSize,
									  LPTSTR acFile,
									  BOOL fExplicit);
STATIC_FUNC int  asOverwriteExistingFile(HWND hwnd, LPTSTR pacName);
STATIC_FUNC void asBadSessionFileMsg(HSESSION hSession, LPTSTR pacName);

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	SilentSaveSession
 *
 * DESCRIPTION:
 *	This function is called whenever the user selects SAVE from the menus.
 *	We will prompt to overwrite if a file with same name already exists.
 *  If the file doen't exist, save it in the defult directory, with the file
 *  name corresponding to the session name the user gave us.
 *	NOTE: This function can also be called from SaveSession to do the
 *	saving work.
 *
 * ARGUEMENTS:
 *	hSession 	-- the session handle
 *	hwnd     	-- handle of parent window
 *	fExplicit 	-- TRUE if the user selected "Save", false otherwise.
 *
 * RETURNS:
 *	Nothing.
 *
 */
void SilentSaveSession(const HSESSION hSession, HWND hwnd, BOOL fExplicit)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
	TCHAR acName[FNAME_LEN];
	TCHAR acOldFile[FNAME_LEN];
	BOOL  fNameChanged = FALSE;

	if (hhSess == NULL)
		{
		assert(hhSess);
		return;
		}

	// We don't want to silent save the default session.  This can happen
	// wen the user cancels the first New Connection Dialog, then quits
	// the program.  jcm 2-22-95
	//
	if (fExplicit == 0)
		{
		acName[0] = TEXT('\0');
		sessQueryName(hSession, acName, sizeof(acName) / sizeof(TCHAR));
		if (sessIsSessNameDefault(acName))
			return;
		}

	acName[0] = TEXT('\0');

	sfGetSessionFileName(hhSess->hSysFile,
							sizeof(acName) / sizeof(TCHAR), acName);

	acOldFile[0] = TEXT('\0');

	if (StrCharCmp(hhSess->achOldSessName, hhSess->achSessName) != 0)
		{
		StrCharCopyN(acOldFile, acName, FNAME_LEN);
		fNameChanged = TRUE;
		}

	// This file hasn't been saved yet or the user has changed the session
	// name, in either case we will need to come up with the new fully
	// qualified file name.
	//
	if (acName[0] == TEXT('\0') || fNameChanged)
		{
		if (!asCreateFullFileName(hSession,
				sizeof(acName) / sizeof(TCHAR), acName, fExplicit))
			{
			// If asCreateFullFileName failed, it is because the fully qualified
			// file name is too long.  In this case, call save as, and let the
			// common dialog in that routine restrict the users name length.
			//
			SaveAsSession(hSession, hwnd);
			return;
			}

		sfReleaseSessionFile(hhSess->hSysFile);
		hhSess->hSysFile = CreateSysFileHdl();
		assert(hhSess->hSysFile);
		sfOpenSessionFile(hhSess->hSysFile, acName);

		if (!asOverwriteExistingFile(hwnd, acName))
			{
			SaveAsSession(hSession, hwnd);
		    return;
	   		}
		}

	// Now we have the user's OK and a correct path/file name so
	// let's save it.
	//
	sessSaveSessionStuff(hSession);					// Commit changes if any
	sfFlushSessionFile(hhSess->hSysFile);			// Write info to disk

	// Make sure the name is shadowed, before this was handled by re-reading
	// the session file back in, now we don't do that.
	//
 	StrCharCopyN(hhSess->achOldSessName, hhSess->achSessName, FNAME_LEN+1);

	if (hhSess->fIsNewSession)
		hhSess->fIsNewSession = 0;
	else
		{
		if (acOldFile[0] != TEXT('\0') && fNameChanged)
			{
			// If the user changed the file name for an existing session
			// now is the time to delete the old one... since we have already
			// saved the new one.
			//
			DeleteFile(acOldFile);
			}
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	SaveSession
 *
 * DESCRIPTION:
 *	This function is called whenever the user selects "New Connection", "Open",
 *	"Exit" from the menus or closed the app.  If this session has never been
 *	saved before then we will warn the user and prompt them to save.  Otherwise
 *	save the current settings silently.
 *
 * ARGUEMENTS:
 *	hSession -- the session handle
 *	hwnd     -- handle of parent window
 *
 * RETURNS:
 *	TRUE  - if all went ok with saving or the user didn't want to save.
 *	FALSE - if the user canceled the operation that brought this to action.
 *
 */
BOOL SaveSession(const HSESSION hSession, HWND hwnd)
	{
	TCHAR	achText[MAX_PATH],
			achSessName[MAX_PATH],
			ach[MAX_PATH * 2];

	int 	nRet;

	if (sessQueryIsNewSession(hSession) == TRUE)
		{
		TCHAR_Fill(achSessName, TEXT('\0'), sizeof(achSessName) / sizeof(TCHAR));
		TCHAR_Fill(achText, TEXT('\0'), sizeof(achText) / sizeof(TCHAR));

		LoadString(glblQueryDllHinst(), IDS_GNRL_CNFRM_SAVE, achText,
			sizeof(achText) / sizeof(TCHAR));

		sessQueryName(hSession, achSessName, sizeof(achSessName));
		if (sessIsSessNameDefault(achSessName))
			{
			// For now ignore sessions with a default name...
			//
			return TRUE;
			}

		wsprintf(ach, achText, TEXT("\""), achSessName, TEXT("\""));

		// Warn the user that they haven't saved the session...
		//
		LoadString(glblQueryDllHinst(), IDS_MB_TITLE_WARN, achText,
			sizeof(achText) / sizeof(TCHAR));

		if ((nRet = TimedMessageBox(hwnd, ach, achText,
			MB_YESNOCANCEL | MB_ICONEXCLAMATION, 0)) != IDYES)
			return (nRet == IDNO);
		}

	SilentSaveSession(hSession, hwnd, FALSE);
	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	OpenSession
 *
 * DESCRIPTION:
 *	This function will open a session file.
 *  If there is an opened, unsaved, new session then the user will be prompted
 *  to save it, otherwise the opened session will be saved silently only after
 *  the user has pressed the OK button.
 *  
 * ARGUEMENTS:
 *	hSession -- the session handle
 *	hwnd     -- handle of parent window
 *
 * RETURNS:
 *	Nothing.
 *
 */
int OpenSession(const HSESSION hSession, HWND hwnd)
	{
    int iRet = 0;
	const HHSESSION hhSess = VerifySessionHandle(hSession);
	LPTSTR 			pszStr;
	TCHAR 			acMask[64], acTitle[64];
	TCHAR 			acDir[FNAME_LEN], acName[FNAME_LEN];


	TCHAR_Fill(acMask,  TEXT('\0'), sizeof(acMask)  / sizeof(TCHAR));
	TCHAR_Fill(acName,  TEXT('\0'), sizeof(acName)  / sizeof(TCHAR));
	TCHAR_Fill(acTitle, TEXT('\0'), sizeof(acTitle) / sizeof(TCHAR));

	resLoadFileMask(glblQueryDllHinst(), IDS_CMM_HAS_FILES1, 2, acMask,
		sizeof(acMask) / sizeof(TCHAR));

	LoadString(glblQueryDllHinst(), IDS_CMM_LOAD_SESS, acTitle,
		sizeof(acTitle) / sizeof(TCHAR));

#ifdef NT_EDITION
	//mpt:07-30-97 
	if ( IsNT() )
#endif
		GetUserDirectory(acDir, FNAME_LEN);
#ifdef NT_EDITION
	else
		{
		GetModuleFileName(glblQueryHinst(), acDir, FNAME_LEN);
		mscStripName(acDir);
		}
#endif

	pszStr = gnrcFindFileDialog(hwnd, acTitle, acDir, acMask);

	if (pszStr)
		{
		// If a session is opened then prompt to save it now or just 
		// save silently in SaveSession()
		//
		if (SaveSession(hSession, hwnd))
			{
			if (ReinitializeSessionHandle(hSession, TRUE) == FALSE)
				{
				assert(0);
				free(pszStr);
				pszStr = NULL;
				return -1;
				}

			StrCharCopyN(acName, pszStr, FNAME_LEN);
			free(pszStr);
			pszStr = NULL;
			}
		else
			{
			free(pszStr);
			pszStr = NULL;
		    return -2;
			}
		}

	else
		{
		return -4; // mrw:4/21/95
		}

	if (StrCharGetByteCount(acName) > 0)
		{
		if (fTestOpenOldTrmFile(hhSess, acName) != 0)
			{
			if (sfOpenSessionFile(hhSess->hSysFile, acName) < SF_OK)
				{
				asBadSessionFileMsg(hSession, acName);
				return -3;
				}

			// If there was a command line we should get rid of it.
			//
			TCHAR_Fill(hhSess->achSessCmdLn,
				TEXT('\0'),
				sizeof(hhSess->achSessCmdLn) / sizeof(TCHAR));

			if (sessLoadSessionStuff(hSession) == FALSE)
                iRet = -4;

			emuHomeHostCursor(hhSess->hEmu);
			emuEraseTerminalScreen(hhSess->hEmu);
			hhSess->fIsNewSession = FALSE;
			}		

		sessUpdateAppTitle(hSession);

		PostMessage(hhSess->hwndSess, WM_SETICON, (WPARAM)TRUE,
			(LPARAM)hhSess->hIcon);
		}

	return iRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	SaveAsSession
 *
 * DESCRIPTION:
 *	This function is called whenever the user selects SAVEAS from the menus.
 *
 * ARGUEMENTS:
 *	hSession -- the session handle
 *	hwnd     -- handle of parent window
 *
 * RETURNS:
 *	Nothing.
 *
 */
void SaveAsSession(const HSESSION hSession, HWND hwnd)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
	long 			lValue = -1;
	unsigned long   lSize = 0;
	LPTSTR 			pszStr;
	TCHAR 			acMask[64];
	TCHAR 			acTitle[64];
	TCHAR			acFileName[FNAME_LEN * 2];
	TCHAR           acDir[FNAME_LEN];
	TCHAR           ach[FNAME_LEN];

	if (hhSess == NULL)
		{
		assert(hhSess);
		return;
		}

	resLoadFileMask(glblQueryDllHinst(), IDS_CMM_HAS_FILES1, 1,	acMask,
		sizeof(acMask) / sizeof(TCHAR));

	LoadString(glblQueryDllHinst(),  IDS_CMM_SAVE_AS, acTitle,
	 	sizeof(acTitle) / sizeof(TCHAR));

	if (sfGetSessionFileName(sessQuerySysFileHdl(hSession),
			FNAME_LEN * 2, acFileName) != SF_OK ||
			sfGetSessionFileName(sessQuerySysFileHdl(hSession),
			FNAME_LEN,	acDir) != SF_OK)
		{
		acFileName[0] = TEXT('\0');

		if (asCreateFullFileName(hSession,
								FNAME_LEN * 2,
								acFileName,
								TRUE) == TRUE)
			{
			StrCharCopyN(acDir, acFileName, FNAME_LEN);
            acDir[FNAME_LEN - 1] = TEXT('\0');
			mscStripName(acDir);
			}
		else
			{
			//Changed from current directory to user directory - mpt 8-18-99
			if ( !GetUserDirectory(acDir, FNAME_LEN) )
				{
				GetCurrentDirectory(FNAME_LEN, acDir);
				}
			sessQueryName(hSession, acFileName, FNAME_LEN * 2);
			}
		}
    else
        {
        mscStripName(acDir);
        }

	pszStr = StrCharLast(acDir);

	// Remove trailing backslash from the directory name if there is one.
	//
	if (pszStr && *pszStr == TEXT('\\'))
		{
		*pszStr = TEXT('\0');
		}

	pszStr = gnrcSaveFileDialog(hwnd, acTitle, acDir, acMask, acFileName);

	if (pszStr)
		{
		sfReleaseSessionFile(hhSess->hSysFile);
		hhSess->hSysFile = CreateSysFileHdl();
        sfOpenSessionFile(hhSess->hSysFile, pszStr);

        // In the "SaveAs" operation we take the file name and make it the
		// session name.
		//
		TCHAR_Fill(ach, TEXT('\0'), sizeof(ach) / sizeof(TCHAR));
		StrCharCopyN(ach, pszStr, FNAME_LEN);
		StrCharCopyN(hhSess->achSessName, mscStripExt(mscStripPath(ach)),
                     FNAME_LEN+1);
		StrCharCopyN(hhSess->achOldSessName, hhSess->achSessName,
                     FNAME_LEN+1);

		/* A "SaveAs" operation requires that the file actually be saved.
		 * To do this, we fiddle with a special reserve item in the file. DLW
		 */
		if (sfGetSessionItem(hhSess->hSysFile, SFID_INTERNAL_TAG, &lSize, &lValue) != 0 ||
            lValue == (-1))
			{
			lValue = 0x12345678;
			/* We only write it if we don't have it */
			sfPutSessionItem(hhSess->hSysFile, SFID_INTERNAL_TAG,
				sizeof(long), &lValue);
			}

		// Save the new session file...
		//
 		sessSaveSessionStuff(hSession);					// Commit changes if any
		sfFlushSessionFile(hhSess->hSysFile);			// Write info to disk
		sessUpdateAppTitle(hSession);					// Show name in title

		// Since we just saved it's not a new session anymore...
		//
		hhSess->fIsNewSession = FALSE;
        }

	free(pszStr);
	pszStr = NULL;

    return;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  asCreateFullFileName
 *
 * DESCRIPTION:
 *  This function will either make up a fully qualified session name using
 *  the current directory and the session name for NEW sessions, or change
 *  the existing file name to the user given file name.
 *
 * ARGUMENTS:
 *	hSession	- the session handle.
 *	iSize		- the size of the following buffer.
 *  acFile   	- the old file path and name.
 *  fExplicit	- TRUE if the user selected "Save" from the menus.
 *
 * RETURNS:
 *  void
 *
 */
STATIC_FUNC BOOL asCreateFullFileName(const HSESSION hSession,
											const int iSize,
											LPTSTR acFile,
											BOOL fExplicit)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);

	TCHAR			acSessName[FNAME_LEN],
					acDir[MAX_PATH],
					acExt[FNAME_LEN];

	LPTSTR			pszStr;

	int 			iDirLen,
					iNameLen,
					iExtLen;

    acDir[0] = TEXT('\0');

	if (acFile[0] == TEXT('\0'))
		{
		// This is a brand new session.
		//

#ifdef NT_EDITION
		// mpt:07-30-97
		if ( IsNT() )
#endif
			GetUserDirectory(acDir, MAX_PATH);
#ifdef NT_EDITION	
		else
			{
			GetModuleFileName(glblQueryHinst(), acDir, MAX_PATH);
			mscStripName(acDir);
			}
#endif
		}
	else
		{
		// The user has changed the session name.
		//
		StrCharCopyN(acDir, acFile, MAX_PATH);
		mscStripName(acDir);
		}

	// See if we need to append a trailing backslash to the
	// directory name.
	//
	pszStr = StrCharLast(acDir);

	if (pszStr && *pszStr != TEXT('\\'))
		{
		StrCharCat(acDir, TEXT("\\"));
		}

	// Save the length of the path information.  We'll use this below.
	//
	iDirLen = StrCharGetByteCount(acDir);

	// Get the session name given by the user...
	//
	acSessName[0] = TEXT('\0');

	sessQueryName(hSession, acSessName, sizeof(acSessName));

	if (sessIsSessNameDefault(acSessName))
		{
		// We ignore a session with a default name if the user hasn't
		// explicitly selected "Save" off of the menus.
		//
		if (!fExplicit)
			return FALSE;

		// This seems little odd from the user's perspective, maybe a whole
		// new dialog would make more sense?
		//
		if (DialogBoxParam(glblQueryDllHinst(),
						   MAKEINTRESOURCE(IDD_NEWCONNECTION),
						   sessQueryHwnd(hSession),
						   NewConnectionDlg, (LPARAM)hSession) == FALSE)
			{
			return FALSE;
			}

		sessQueryName(hSession, acSessName, sizeof(acSessName));
		}

	iNameLen = StrCharGetByteCount(acSessName);

	// Get the extension we are using from the resource file.
	//
	acExt[0] = TEXT('\0');

	LoadString(glblQueryDllHinst(), IDS_GNRL_HAS, acExt, sizeof(acExt) / sizeof(TCHAR));

	iExtLen =  StrCharGetByteCount(acExt);

	// We're about to put a fully qualified file name together.  Let's make
	// sure that the combined component length is valid.
	//
	if ( (iDirLen + iNameLen + iExtLen) > 254)
		{
		return(FALSE);
		}

	if ( (iDirLen + iNameLen + iExtLen) > iSize)
		{
		assert(FALSE);
		return(FALSE);
		}

	// Put the pieces together, now that we know it's going to work.
	//
	StrCharCopyN(acFile, acDir, iDirLen);
	StrCharCat(acFile, acSessName);
	StrCharCat(acFile, acExt);

	sfSetSessionFileName(hhSess->hSysFile, acFile);

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  asOverwriteExistingFile
 *
 * DESCRIPTION:
 *	If a file exists prompt the user to overwrite the file.
 *
 * ARGUMENTS:
 *  pacName  - the session file name.
 *
 * RETURNS:
 *  TRUE 	- if file doesn't exist or it's ok to overwrite.
 *	FALSE 	- if the user doesn't want to overwrite.
 *
 */
STATIC_FUNC int asOverwriteExistingFile(HWND hwnd, LPTSTR pacName)
	{
	TCHAR 	ach[256], achTitle[256], achText[256];
	int 	nRet = 0;

	if (GetFileSizeFromName(pacName, NULL))
		{
		// Warn the user that a file with that name already exists...
		//
		LoadString(glblQueryDllHinst(), IDS_GNRL_CNFRM_OVER, achText,
			sizeof(achText) / sizeof(TCHAR));
		wsprintf(ach, achText, pacName);

		LoadString(glblQueryDllHinst(), IDS_MB_TITLE_WARN, achTitle,
			sizeof(achTitle) / sizeof(TCHAR));

		nRet = TimedMessageBox(hwnd, ach, achTitle,
			MB_YESNO | MB_ICONEXCLAMATION, 0);

		return (nRet == IDYES);
		}

	return 1;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  asBadSessionFileMsg
 *
 * DESCRIPTION:
 *  Display a message if a bad session file is found.
 *
 * ARGUMENTS:
 *	hSession - the session handle.
 *  pacName  - the session file name.
 *
 * RETURNS:
 *  TRUE 	- if file doesn't exist or it's ok to overwrite.
 *	FALSE 	- if the user doesn't want to overwrite.
 *
 */
STATIC_FUNC void asBadSessionFileMsg(HSESSION hSession, LPTSTR pacName)
	{
	const HHSESSION hhSess = VerifySessionHandle(hSession);
	TCHAR acFormat[64], acTitle[256], ach[256];

	TCHAR_Fill(acFormat, TEXT('\0'), sizeof(acFormat) / sizeof(TCHAR));
	TCHAR_Fill(acTitle, TEXT('\0'), sizeof(acTitle) / sizeof(TCHAR));

	LoadString(glblQueryDllHinst(), IDS_CMM_LOAD_SESS, acTitle,
		sizeof(acTitle) / sizeof(TCHAR));
	LoadString(glblQueryDllHinst(),	IDS_ER_BAD_SESSION, acFormat,
		sizeof(acFormat) / sizeof(TCHAR));
	wsprintf(ach, acFormat, pacName);

	TimedMessageBox(sessQueryHwnd(hSession), ach, acTitle,
		MB_OK | MB_ICONEXCLAMATION, sessQueryTimeout(hSession));

	sfSetSessionFileName(hhSess->hSysFile, TEXT(""));
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\assert.h ===
/*	File: D:\WACKER\tdll\assert.h (Created: 30-Nov-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:40p $
 */

/*
This file is slated for destruction.  Well not exactly.  It will be
renamed to something else (possibly debug.h).  Anyways, here are 
some rules for the road.  The nature of these functions are such that
they go away in the production version.  To "communicate" this idea
to the casual reader, we are prefixing the name of the macro with
Dbg to denote that this is a debug thingy.  Assert will reamain assert
since its meaning and intention are well known to C programmers.  Also,
make sure the function in assert.c compiles to an empty function in
when built as a production version.  Other functions in assert.c already
do this do look to them for an example. - mrw
*/

#if !defined(INCL_ASSERT)
#define INCL_ASSERT

void DoAssertDebug(TCHAR *file, int line);
void __cdecl DoDbgOutStr(TCHAR *achFmt, ...);
void DoShowLastError(const TCHAR *file, const int line);

#if !defined(NDEBUG)
	#define assert(X) if (!(X)) DoAssertDebug(TEXT(__FILE__), __LINE__)

	#if defined(DEBUGSTR)
		#define DbgOutStr(A,B,C,D,E,F) DoDbgOutStr(A,B,C,D,E,F)

	#else
		#define DbgOutStr(A,B,C,D,E,F)

	#endif

	#define DbgShowLastError()	DoShowLastError(TEXT(__FILE__), __LINE__)

#else
	#define assert(X)
	#define DbgOutStr(A,B,C,D,E,F)
	#define DbgShowLastError()

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\banner.h ===
/*	File: \wacker\tdll\banner.h (created 16-Mar-94)
 *
 *	Copyright 1994 by Hilgraeve, Inc -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:35p $
 */

#define	BANNER_DISPLAY_CLASS	"BannerDisplayClass"
#define WACKER_VERSION			"0.10"
#define BANNER_TIME 			4000

#define BANNER_WINDOW_STYLE  WS_POPUP | WS_VISIBLE

BOOL bannerRegisterClass(HANDLE hInstance);
HWND bannerCreateBanner(HANDLE hInstance, LPTSTR pszTitle);
LPTSTR bnrBuildLotNum(LPTSTR);
VOID FAR PASCAL utilDrawBitmap(HWND hWnd, HDC hDC, HBITMAP hBitmap, SHORT xStart, SHORT yStart);

extern const TCHAR *achVersion;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\backscrl.hh ===
/*	File: D:\WACKER\tdll\backscrl.hh (Created: 10-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:41p $
 */

#if !defined(INCL_HHBACKSCRL)
#define INCL_HHBACKSCRL

typedef struct stBackscrlPage * HBKPAGE;
typedef struct stBackscrl	  * HHBACKSCRL;

struct stBackscrl
	{
	HBKPAGE 	*hBkPages;			// where the pages live (array of ptrs).
	int 		 iPages,			// number of backscroll pages.
				 iCurrPage, 		// current page
				 iOffset,			// offset into current page.
				 iLines,			// total number of lines in all pages
				 iChanged,			// backscrl has changed since last
									// backscrlResetChangeFlag() call

				 iUserLines,		// User set number of backscroll lines to save
				 iUserLinesSave;	// Starting value

	int 		 fShowBackscrl; 	// Turns backscroll display on/off
	HSESSION	 hSession;
	};

/* --- Macros --- */

#define BACKSCRL_PAGESIZE (1024)
#define BACKSCRL_MAXPAGES (INT_MAX / (int)sizeof(HBKPAGE))

struct stBackscrlPage
	{
	int 	 iLines;					// number of lines stored in this page
	ECHAR	 *pachPage;					// text buffer for page.
	};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\bv_text.h ===
/*	File: C:|WACKER\TDLL\BV_TEXT.H (Created: 11-JAN-1994)
 *	Created from:
 *	File: C:\HA5G\ha5g\s_text.h (Created: 27-SEP-1991)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 10/27/00 1:23p $
 */

#define WM_STXT_SET_BK			(WM_USER+0x380)
#define WM_STXT_SET_TXT 		(WM_USER+0x381)
#define WM_STXT_SET_UE			(WM_USER+0x382)
#define WM_STXT_SET_LE			(WM_USER+0x383)
#define WM_STXT_SET_DEPTH		(WM_USER+0x384)
#define WM_STXT_OWNERDRAW		(WM_USER+0x385)

#define STXT_DEF_DEPTH	   2

extern BOOL RegisterBeveledTextClass(HANDLE hInstance);

extern LONG CALLBACK BeveledTextWndProc(HWND hWnd,
									  UINT wMsg,
									  WPARAM wPar,
									  LPARAM lPar);

extern BOOL UnregisterBeveledTextClass(HANDLE hInstance);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\bv_text.hh ===
/*	File: C:|WACKER\TDLL\BV_TEXT.HH (Created: 11-JAN-1994)
 *	Created from:
 *	File: C:\HA5G\ha5g\s_text.h (Created: 27-SEP-1991)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:37p $
 */

typedef VOID (CALLBACK *STXT_OWNERDRAW)(HWND, HDC);

struct s_text
	{
	ULONG	ulCheck;			/* Validity check field */
	ULONG	cBackGround;		/* Fill color for background */
	ULONG	cTextColor; 		/* Color to use for text display */
	ULONG	cUpperEdge; 		/* Upper and left edge 3D border color */
	ULONG	cLowerEdge; 		/* Lower and right edge 3D border color */
	USHORT	usDepth;
	LPTSTR	pszText;			/* Text to be displayed */
	HFONT	hFont;				/* Text font used to draw text */
	INT 	iFontHeight;		/* Used for vertical centering */
	STXT_OWNERDRAW fpOwnerDraw; /* pointer to ownerdraw proc. */
	};

#define STEXT_VALID 	0x78745374

typedef struct s_text STEXT;
typedef STEXT *LPSTEXT;

#define STEXT_OK(x) 	((x!=NULL)&&(x->ulCheck==STEXT_VALID))

extern VOID stxtDrawBeveledText(
								HDC 	   hdc,
								HFONT	   hNewFont,
								LPRECT	   lpRc,
								USHORT	   usWidth,
								DWORD	   dwStyle,
								ULONG FAR *pulColors,
								LPTSTR	   pszText
							   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\backscrl.c ===
/*	File: D:\WACKER\tdll\backscrl.c (Created: 10-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 9 $
 *	$Date: 8/27/01 9:00a $
 */

#include <windows.h>
#pragma hdrstop

#include <stdlib.h>
#include <limits.h>

#include "stdtyp.h"
#include "tdll.h"
#include "mc.h"
#include "assert.h"
#include "session.h"
#include "session.hh"
#include <emu\emu.h>
#include <emu\emu.hh>
#include "update.h"
#include "backscrl.h"
#include "backscrl.hh"
#include "sess_ids.h"
#include "htchar.h"
#include "term.h"
#include "sf.h"
#include <term\res.h>

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	backscrlCreate
 *
 * DESCRIPTION:
 *	Creates a server (now wudge) backsroll handle include the backscroll
 *	region itself.
 *
 * ARGUMENTS:
 *	Size of the backscoll region in bytes.
 *
 * RETURNS:
 *	Handle to a backscroll structure on success, else (HBACKSCRL)0.
 *
 */
HBACKSCRL backscrlCreate(const HSESSION hSession, const int iBytes)
	{
	int 		 i;
	HHBACKSCRL	 hBk;

	assert(hSession);

	hBk = (HHBACKSCRL)malloc(sizeof(struct stBackscrl));

	if (hBk == 0)
		{
		assert(FALSE);
		return 0;
		}

	memset(hBk, 0, sizeof(struct stBackscrl));

	hBk->hSession = hSession;
	hBk->iPages = (iBytes / BACKSCRL_PAGESIZE) + 1;

	if (hBk->iPages > BACKSCRL_MAXPAGES)
		{
		assert(FALSE);
		free(hBk);
		hBk = NULL;
		return 0;
		}

	hBk->hBkPages = (HBKPAGE *)malloc((size_t)hBk->iPages * sizeof(HBKPAGE));

	if (hBk->hBkPages == 0)
		{
		assert(FALSE);
		free(hBk);
		hBk = NULL;
		return (HBACKSCRL)0;
		}

	for (i = 0 ; i < hBk->iPages ; ++i)
		{
		hBk->hBkPages[i] = (HBKPAGE)malloc(sizeof(struct stBackscrlPage));

		if (hBk->hBkPages[i] == (HBKPAGE)0)
			{
			assert(FALSE);
			goto ERROROUT;
			}

		hBk->hBkPages[i]->pachPage =
			(ECHAR *)malloc(BACKSCRL_PAGESIZE * sizeof(ECHAR));

		if (hBk->hBkPages[i]->pachPage == 0)
			{
			assert(FALSE);
			goto ERROROUT;
			}

		ECHAR_Fill(hBk->hBkPages[i]->pachPage, EMU_BLANK_CHAR, BACKSCRL_PAGESIZE);
		hBk->hBkPages[i]->iLines = 0;
		}

	hBk->iCurrPage = 0;
	hBk->iOffset = 0;
	hBk->iLines = 0;

	// Set this to some default...
	//
	hBk->iUserLines = hBk->iUserLinesSave = BKSCRL_USERLINES_DEFAULT_MAX;

	hBk->hBkPages[hBk->iCurrPage]->iLines = 0;

	return (HBACKSCRL)hBk;

	// Fanstastic error recovery.

	ERROROUT:

	while (--i > 0)
		{
		free(hBk->hBkPages[i]->pachPage);
		hBk->hBkPages[i]->pachPage = NULL;
		free(hBk->hBkPages[i]);
		hBk->hBkPages[i] = NULL;
		}

	free(hBk->hBkPages);
	hBk->hBkPages = NULL;
	free(hBk);
	hBk = NULL;
	return (HBACKSCRL)0; // caller does error message
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	backscrlDestroy
 *
 * DESCRIPTION:
 *	Routine to free memory associated with the given backscoll handle.
 *
 * ARGUMENTS:
 *	HBACKSCRL	hBackscrl	- handle to free.
 *
 * RETURNS:
 *	nothing.
 *
 */
VOID backscrlDestroy(const HBACKSCRL hBackscrl)
	{
	int i;
	const HHBACKSCRL hBk = (HHBACKSCRL)hBackscrl;

	if (hBk == 0)
		{
		assert(0);
		return;
		}

	if (hBk->hBkPages)
		{
		for (i = 0 ; i < hBk->iPages ; ++i)
			{
			if (hBk->hBkPages[i]->pachPage)
				{
				free(hBk->hBkPages[i]->pachPage);
				hBk->hBkPages[i]->pachPage = NULL;
				}

			free(hBk->hBkPages[i]);
			hBk->hBkPages[i] = NULL;
			}

		free(hBk->hBkPages);
		hBk->hBkPages = NULL;
		}

	free(hBk);
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	backscrlAdd
 *
 * DESCRIPTION:
 *	Adds a new line to the backscoll handle.  The affect is to scroll the
 *	preceding lines up by one and to add the given string to the bottom
 *	of the backscroll region.
 *
 * ARGUMENTS:
 *	HBACKSCRL	hBackscrl	- as usual
 *	LPTSTR		pachBuf 	- string to add
 *	int 	 usLen		 - length of the string.
 *
 * RETURNS:
 *	TRUE always.
 *
 */
BOOL backscrlAdd(const HBACKSCRL hBackscrl,
				 const ECHAR	 *pachBuf,
				 const int		 iLen
				)
	{
	register int i;
	ECHAR *pachBackscrl;
	const HHBACKSCRL hBk = (HHBACKSCRL)hBackscrl;

	if (hBk == 0)
		{
		assert(0);
		return FALSE;
		}

	if (hBk->iUserLines == 0)
		return TRUE;

	// The following test has been removed because the emualtors no
	// longer use a '\0' to delimit the end of a line.	5/16/94 --jcm

	// Never let '\0's into the backscroll buffer!	Avoid this like the
	// plague since they display as wierd characters depending on the
	// font selected on the CLIENT side.  The wierd part is you can't
	// always depend on the emulators putting a '\0' in the the buffer
	// so we need to check for trailing space as well.

	for (i = 0 ; i < iLen ; ++i)
		{
		if (pachBuf[i] == (ECHAR)0)
			break;
		}

	// remove trailing whitespace.

	while (i)
		{
		if (pachBuf[i - 1] != ETEXT(' '))
			break;

		i -= 1;
		}

	DbgOutStr("%d-", i, 0, 0, 0, 0);

	// check to see if there is room on the current page.

	if (hBk->iOffset >= BACKSCRL_PAGESIZE ||
			((int)BACKSCRL_PAGESIZE - hBk->iOffset) <= i)
		{
		// pad rest of page with blanks so we know that this part of
		// the buffer is empty.

		if ((pachBackscrl = hBk->hBkPages[hBk->iCurrPage]->pachPage) == 0)
			{
			assert(0);
			return FALSE;
			}

		ECHAR_Fill(pachBackscrl+hBk->iOffset, EMU_BLANK_CHAR,
			(size_t)(BACKSCRL_PAGESIZE - hBk->iOffset));

		hBk->iCurrPage += 1;

		if (hBk->iCurrPage >= hBk->iPages)
			hBk->iCurrPage = 0;

		hBk->iOffset = 0;

		// If we have wrapped, subtract the number of lines previously in
		// this page from the total line count.  Since the line count is
		// intialized to 0 (see backscrlCreate()) I can always subract this
		// amount without checking for wrapping since it will only be
		// non-zero if we have wrapped.

		hBk->iLines -= hBk->hBkPages[hBk->iCurrPage]->iLines;
		hBk->hBkPages[hBk->iCurrPage]->iLines = 0;
		}

	// Assign a pointer for speed and clarity

	if ((pachBackscrl = hBk->hBkPages[hBk->iCurrPage]->pachPage) == 0)
		{
		assert(0);
		return FALSE;
		}

    // JYF 26-Mar-1999 limit the size so we don't overrun
    //  the buffer.

    if (i)
        {
        MemCopy (pachBackscrl + hBk->iOffset,
                 pachBuf,
                 (size_t)min(BACKSCRL_PAGESIZE - hBk->iOffset, i) * sizeof(ECHAR));
        }

    hBk->iOffset += min(BACKSCRL_PAGESIZE - hBk->iOffset - 1, i);

	pachBackscrl[hBk->iOffset++] = ETEXT('\n');

	// Here's an interesting problem.  We really can't reference more than
	// a signed-integer's worth of lines, but we may have megabytes of
	// backscroll memory.  The answer is simple in this case.  Never allow
	// the line count to exceed the signed int max.  This has the affect
	// of spilling off the top lines in the buffer. - mrw

	hBk->iLines = min(hBk->iLines+1, INT_MAX);
	hBk->hBkPages[hBk->iCurrPage]->iLines += 1;
	hBk->iChanged = TRUE;
	updateBackscroll(sessQueryUpdateHdl(hBk->hSession), 1);
	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	backscrlGetBkLines
 *
 * DESCRIPTION:
 *	Retrieves specifed lines from the backscoll.  This function is
 *	complicated by the fact the backscoll memory is paged.	A request
 *	might cross one or more page boundaries.  Thus only a portion of
 *	the request may be satisfied.  The client knows this and makes new
 *	requests based on what it got from the server.
 *
 * ARGUMENTS:
 *	hBackscrl	- the usual
 *	yBeg		- begining line in backscroll to get.
 *	sWant		- number of lines requested.
 *	psGot		- number of lines retrived.
 *	lpststrTxt	- handle to backscrl memory page retrived.
 *	pwOffset	- offset into retrieved page (in TCHAR units).
 *
 * RETURNS:
 *	BOOL
 *
 */
BOOL backscrlGetBkLines(const HBACKSCRL hBackscrl,
						const int	yBeg,
						const int	sWant,
						int 	   *psGot,
						ECHAR	   **lptstrTxt,
						int 	   *pwOffset
						)
	{
	register int	 i, j, k;
	ECHAR			 *pachText;
	const HHBACKSCRL hBk = (HHBACKSCRL)hBackscrl;

	assert(sWant > 0);

	// Check to see if we are requesting beyond the end of the
	// backscroll buffer.

	if (abs(yBeg) > hBk->iLines)
		return FALSE;

	k = hBk->iCurrPage;
	j = 0;
	i = 0;

	// Find the backscoll page that has the requested text
	//
	for (;;)
		{
		if ((j -= hBk->hBkPages[k]->iLines) <= yBeg)
			break;

		k = (hBk->iPages + k - 1) % hBk->iPages;

		if (++i >= hBk->iPages)
			return FALSE;
		}


	// Found the page.
	//
	*lptstrTxt = hBk->hBkPages[k]->pachPage;

	// Now find offset into page where first line of requested text begins
	//
	for (pachText = hBk->hBkPages[k]->pachPage ; j < yBeg ; ++j)
		{
		while (*pachText != ETEXT('\n'))
			{
			pachText += 1;
			}

		pachText += 1;
		}

	*pwOffset = (DWORD)(pachText - hBk->hBkPages[k]->pachPage);

	// Found offset.  Now grab what we can and return it.
	//
	for (i = 1 ; i <= sWant ; ++i)
		{
		while ((pachText - hBk->hBkPages[k]->pachPage) < BACKSCRL_PAGESIZE
				&& *pachText != ETEXT('\n'))
			{
			pachText += 1;
			}

		if ((pachText - hBk->hBkPages[k]->pachPage) >= BACKSCRL_PAGESIZE)
			break;

		*psGot = i;
		pachText += 1; // blow past newline
		}

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	backscrlGetNumLines
 *
 * DESCRIPTION:
 *	Returns the number of lines in the backscrl which is zero if the
 *	backscroll is off, and the maximum is always the user set value.
 *
 * ARGUMENTS:
 *	HBACKSCRL hBackscrl 	- external backscrl handle
 *
 * RETURNS:
 *	Returns the uLines member.
 */
int backscrlGetNumLines(const HBACKSCRL hBackscrl)
	{
	const HHBACKSCRL hBk = (HHBACKSCRL)hBackscrl;
	assert(hBk);
	return (hBk->fShowBackscrl) ? min(hBk->iUserLines, hBk->iLines) : 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	backscrlUSetNumLines
 *
 * DESCRIPTION:
 *	Returns the iUserLines member.
 *
 * ARGUMENTS:
 *	HBACKSCRL hBackscrl 	- external backscrl handle
 *
 * RETURNS:
 *	void
 */
int backscrlSetUNumLines(const HBACKSCRL hBackscrl, const int iUserLines)
	{
	const HHBACKSCRL hBk = (HHBACKSCRL)hBackscrl;

	if (hBk == 0)
		{
		assert(0);
		return -1;
		}

	if (iUserLines != hBk->iUserLines)
		{
		backscrlChanged(hBackscrl);
		hBk->iUserLines = iUserLines;

		// If we're setting the number of lines to zero, we're essentially
		// disabling the backscroll.  Flushing clears the screen as well.
		//
		if (iUserLines == 0)
            {
            HHSESSION hhSession = (HHSESSION)hBk->hSession;
			// REV: 07/26/2001 posted message to clear the backscroll
            // otherwise a deadlock could occur as we may not be thread 0.
            // backscrlFlush(hBackscrl);
            PostMessage(hhSession->hwndSess, WM_COMMAND, IDM_CLEAR_BACKSCROLL, (LPARAM)0);
            }

		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	backscrlGetUNumLines
 *
 * DESCRIPTION:
 *	Returns the iUserLines member.
 *
 * ARGUMENTS:
 *	HBACKSCRL hBackscrl 	- external backscrl handle
 *
 * RETURNS:
 *	Returns the iUserLines member.
 */
int backscrlGetUNumLines(const HBACKSCRL hBackscrl)
	{
	const HHBACKSCRL hBk = (HHBACKSCRL)hBackscrl;
	return hBk->iUserLines;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	backscrlRead
 *
 * DESCRIPTION:
 *  Read the number of backscrol lines to keep as entered by the user.
 *	NOTE: This should be put in the backscrlInitializeHdl() when this function
 *	gets written.
 *
 * ARGUMENTS:
 *	HBACKSCRL hBackscrl 	- external backscrl handle
 *
 * RETURNS:
 */
void backscrlRead(const HBACKSCRL hBackscrl)
	{
	const HHBACKSCRL hBk = (HHBACKSCRL)hBackscrl;
	unsigned long ulSize;

	ulSize = sizeof(hBk->iUserLines);
	hBk->iUserLines = BKSCRL_USERLINES_DEFAULT_MAX;
	sfGetSessionItem(sessQuerySysFileHdl(hBk->hSession),
						SFID_BKSC_ULINES,
						&ulSize,
						&hBk->iUserLines);
	hBk->iUserLinesSave = hBk->iUserLines;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	backscrlSave
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *	HBACKSCRL hBackscrl 	- external backscrl handle
 *
 * RETURNS:
 */
void backscrlSave(const HBACKSCRL hBackscrl)
	{
	const HHBACKSCRL hBk = (HHBACKSCRL)hBackscrl;
	unsigned long ulSize;

	if (hBk->iUserLines != hBk->iUserLinesSave)
		{
		ulSize = sizeof(int);
		sfPutSessionItem(sessQuerySysFileHdl(hBk->hSession),
						SFID_BKSC_ULINES,
						ulSize,
						&(hBk->iUserLines));
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	backscrlFlush
 *
 * DESCRIPTION:
 *	Empties the backscroll buffer and notifies the terminal so it can
 *	update it's display.
 *
 *	Note: Because this function calls RefreshTermWindow() it should only
 *		  be called from the main thread. - mrw
 *
 * ARGUMENTS:
 *	hBackscrl	- public backscroll handle
 *
 * RETURNS:
 *	void
 *
 */
void backscrlFlush(const HBACKSCRL hBackscrl)
	{
	int i;
	const HHBACKSCRL hBk = (HHBACKSCRL)hBackscrl;
	ECHAR aechBuf[10];

	assert(hBk);

	/* --- Shouldn't need this unless this is called while on line --- */

	emuLock(sessQueryEmuHdl(hBk->hSession));

	/* --- Force the update records to have something in them --- */

	CnvrtMBCStoECHAR(aechBuf, sizeof(aechBuf), TEXT(" "),
                     StrCharGetByteCount(TEXT(" ")));
	backscrlAdd(hBackscrl, aechBuf, 1);

	/* --- Empty all pages --- */

	for (i = 0 ; i < hBk->iPages ; ++i)
		hBk->hBkPages[i]->iLines = 0;

	hBk->iLines = 0;
	hBk->iOffset = 0; //mrw:6/19/95

	emuUnlock(sessQueryEmuHdl(hBk->hSession));

	/* --- Let the terminal update now --- */

	NotifyClient(hBk->hSession, EVENT_TERM_UPDATE, 0);
	RefreshTermWindow(sessQueryHwndTerminal(hBk->hSession));
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	backscrlChanged
 *
 * DESCRIPTION:
 *	Returns iChanged member which is set whenever anything is added
 *	to the backscroll buffer.  It can be cleared by calling
 *	backscrlResetChangedFlag().
 *
 * ARGUMENTS:
 *	hBackscrl	- public backscroll handle
 *
 * RETURNS:
 *	BOOL
 *
 */
BOOL backscrlChanged(const HBACKSCRL hBackscrl)
	{
	const HHBACKSCRL hBk = (HHBACKSCRL)hBackscrl;
	assert(hBk);
	return hBk->iChanged;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	backscrlResetChangedFlag
 *
 * DESCRIPTION:
 *	Resets the iChanged member to 0.  Subsequent calls to backscrlAdd()
 *	will set the flag to 1.
 *
 * ARGUMENTS:
 *	hBackscrl	- public backscrl handle
 *
 * RETURNS:
 *	void
 *
 */
void backscrlResetChangedFlag(const HBACKSCRL hBackscrl)
	{
	const HHBACKSCRL hBk = (HHBACKSCRL)hBackscrl;
	assert(hBk);
	hBk->iChanged = 0;
	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	backscrlSetShowFlag
 *
 * DESCRIPTION:
 *	The show flag controls whether or not the session will show/display
 *	an antive backscrl.
 *
 * ARGUMENTS:
 *	hBackscrl	- public backscrl handle.
 *	fFlag		- TRUE=show, FALSE=hide
 *
 * RETURNS:
 *	void
 *
 */
void backscrlSetShowFlag(const HBACKSCRL hBackscrl, const int fFlag)
	{
	const HHBACKSCRL hBk = (HHBACKSCRL)hBackscrl;

	assert(hBk);
	hBk->fShowBackscrl = fFlag;
	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\backscrl.h ===
/*	File: D:\WACKER\tdll\backscrl.h (Created: 10-Dec-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:34p $
 */

#if !defined(INCL_HBACKSCRL)
#define INCL_HBACKSCRL

// Defines

#define BKPOS_THUMBPOS	1
#define BKPOS_ABSOLUTE	2

#define BKSCRL_USERLINES_DEFAULT_MAX	500
#define BKSCRL_USERLINES_DEFAULT_MIN	0

// This macro use to calculate bytes needed to save ul lines.
// The value is approximate.
//
#define BK_LINES_TO_BYTES(i)   (i * 80)

/* --- Function prototypes --- */

void		backscrlDestroy 	(const HBACKSCRL hBackscrl);

BOOL		backscrlAdd 		(const HBACKSCRL hBackscrl,
								 const ECHAR	 *pachBuf,
								 const int		 iLen
								);

HBACKSCRL	backscrlCreate		(const HSESSION hSession, const int iBytes);

BOOL		backscrlGetBkLines	(const HBACKSCRL hBackscrl,
								 const int yBeg,
								 const int iWant,
								 int	  *piGot,
								 ECHAR    **lpstrTxt,
								 int	  *piOffset
								);

int 		backscrlGetNumLines (const HBACKSCRL hBackscrl);
void 		backscrlSave(const HBACKSCRL hBackscrl);
void		backscrlFlush(const HBACKSCRL hBackscrl);
BOOL		backscrlChanged(const HBACKSCRL hBackscrl);
void		backscrlResetChangedFlag(const HBACKSCRL hBackscrl);
void 		backscrlRead(const HBACKSCRL hBackscrl);
int 		backscrlSetUNumLines (const HBACKSCRL hBackscrl, const int iUserLines);
int 		backscrlGetUNumLines (const HBACKSCRL hBackscrl);
void		backscrlSetShowFlag(const HBACKSCRL hBackscrl, const int fFlag);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\emu\vtutf8ini.c ===
/*	File: \WACKER\emu\vtutf8ini.c (Created: 2001)
 *
 *	Copyright 2001 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 17 $
 *	$Date: 5/07/02 1:25p $
 */

#include <windows.h>
#include <mbctype.h>
#include <locale.h>
#include <stdio.h>
#pragma hdrstop

//#define DEBUGSTR

#include <tdll\stdtyp.h>
#include <tdll\session.h>
#include <tdll\assert.h>
#include <tdll\mc.h>
#include <tdll\backscrl.h>
#include <tdll\com.h>
#include <tdll\cloop.h>

#include "emu.h"
#include "emu.hh"
#include "emuid.h"
#include "emudec.hh"
#include "keytbls.h"

#if defined(INCL_VTUTF8)

#define UTF8_1ST_OF_2_BYTES_CODE	0x00C0
#define UTF8_2ND_OF_2_BYTES_CODE	0x0080
#define UTF8_1ST_OF_3_BYTES_CODE	0x00E0
#define UTF8_2ND_OF_3_BYTES_CODE	0x0080
#define UTF8_3RD_OF_3_BYTES_CODE	0x0080
#define UTF8_2_BYTES_HIGHEST_5_BITS	0x07C0
#define UTF8_2_BYTES_LOWEST_6_BITS	0x003F
#define UTF8_3_BYTES_HIGHEST_4_BITS	0xF000
#define UTF8_3_BYTES_MIDDLE_6_BITS	0x0FC0
#define UTF8_3_BYTES_LOWEST_6_BITS	0x003F
#define FIRST_4_BITS				0x000F
#define FIRST_5_BITS				0x001F
#define FIRST_6_BITS				0x003F
#define UTF8_TYPE_MASK				0x00E0

const KEYTBLSTORAGE VTUTF8KeyTable[MAX_VTUTF8_KEYS] =
    {
	{VK_UP	 | VIRTUAL_KEY,				{"\x1B[A\xff"}},  /* KN_UP */
	{VK_DOWN | VIRTUAL_KEY,				{"\x1B[B\xff"}},  /* KN_DOWN */
	{VK_RIGHT| VIRTUAL_KEY,				{"\x1B[C\xff"}},  /* KN_RIGHT */
	{VK_LEFT | VIRTUAL_KEY,				{"\x1B[D\xff"}},  /* KN_LEFT */

	{VK_HOME 	| VIRTUAL_KEY,			{"\x1Bh\xff"}},/* KN_HOME */
	{VK_INSERT	| VIRTUAL_KEY,			{"\x1B+\xff"}},	/* KN_INS */
	{VK_DELETE	| VIRTUAL_KEY,			{"\x1B-\xff"}},	/* KN_DEL */
	{VK_NEXT 	| VIRTUAL_KEY,			{"\x1B/\xff"}},	/* KN_PGDN */
	{VK_PRIOR	| VIRTUAL_KEY,			{"\x1B?\xff"}},	/* KN_PGUP */
	{VK_END		| VIRTUAL_KEY,			{"\x1Bk\xff"}}, /* KN_END */

	{VK_UP	 | EXTENDED_KEY | VIRTUAL_KEY,{"\x1B[A\xff"}},  /* KN_UP */
	{VK_DOWN | EXTENDED_KEY | VIRTUAL_KEY,{"\x1B[B\xff"}},  /* KN_DOWN */
	{VK_RIGHT| EXTENDED_KEY | VIRTUAL_KEY,{"\x1B[C\xff"}},  /* KN_RIGHT */
	{VK_LEFT | EXTENDED_KEY | VIRTUAL_KEY,{"\x1B[D\xff"}},  /* KN_LEFT */

	{VK_HOME 	| EXTENDED_KEY | VIRTUAL_KEY, {"\x1Bh\xff"}}, /* KN_HOME */
	{VK_INSERT	| EXTENDED_KEY | VIRTUAL_KEY, {"\x1B+\xff"}}, /* KN_INS */
	{VK_DELETE	| EXTENDED_KEY | VIRTUAL_KEY, {"\x1B-\xff"}}, /* KN_DEL */
	{VK_NEXT 	| EXTENDED_KEY | VIRTUAL_KEY, {"\x1B/\xff"}}, /* KN_PGDN */
	{VK_PRIOR	| EXTENDED_KEY | VIRTUAL_KEY, {"\x1B?\xff"}}, /* KN_PGUP */
	{VK_END		| EXTENDED_KEY | VIRTUAL_KEY, {"\x1Bk\xff"}}, /* KN_END */

	{VK_F1	| VIRTUAL_KEY,					{"\x1B\x31\xff"}},  /* KN_F1 */
	{VK_F2	| VIRTUAL_KEY,					{"\x1B\x32\xff"}},  /* KN_F2 */
	{VK_F3	| VIRTUAL_KEY,					{"\x1B\x33\xff"}},  /* KN_F3 */
	{VK_F4	| VIRTUAL_KEY,					{"\x1B\x34\xff"}},  /* KN_F4 */
	{VK_F5	| VIRTUAL_KEY,					{"\x1B\x35\xff"}},	/* KN_F5 */
	{VK_F6	| VIRTUAL_KEY,					{"\x1B\x36\xff"}},	/* KN_F6 */
	{VK_F7	| VIRTUAL_KEY,					{"\x1B\x37\xff"}},	/* KN_F7 */
	{VK_F8	| VIRTUAL_KEY,					{"\x1B\x38\xff"}},	/* KN_F8 */
	{VK_F9	| VIRTUAL_KEY,					{"\x1B\x39\xff"}},	/* KN_F9 */
	{VK_F10	| VIRTUAL_KEY,					{"\x1B\x30\xff"}},	/* KN_F10 */
	{VK_F11	| VIRTUAL_KEY,					{"\x1B!\xff"}},	/* KN_F11 */
	{VK_F12	| VIRTUAL_KEY,					{"\x1B@\xff"}},	/* KN_F12 */

	{VK_F1	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1B\x31\xff"}},  /* KN_F1 */
	{VK_F2	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1B\x32\xff"}},  /* KN_F2 */
	{VK_F3	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1B\x33\xff"}},  /* KN_F3 */
	{VK_F4	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1B\x34\xff"}},  /* KN_F4 */
	{VK_F5	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1B\x35\xff"}},	/* KN_F5 */
	{VK_F6	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1B\x36\xff"}},	/* KN_F6 */
	{VK_F7	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1B\x37\xff"}},	/* KN_F7 */
	{VK_F8	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1B\x38\xff"}},	/* KN_F8 */
	{VK_F9	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1B\x39\xff"}},	/* KN_F9 */
	{VK_F10	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1B\x30\xff"}},	/* KN_F10 */
	{VK_F11	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1B!\xff"}},	/* KN_F11 */
	{VK_F12	| EXTENDED_KEY | VIRTUAL_KEY,	{"\x1B@\xff"}},	/* KN_F12 */

	{VK_TAB		| VIRTUAL_KEY | SHIFT_KEY,  {"\x1B\x5B\x5A\xff"}},  /* KT_SHIFT + KN_TAB */

	{0x2F	| EXTENDED_KEY, {"\x2F\xff"}}, /* number pad / */
    {VK_ADD	| VIRTUAL_KEY, {",\xff"}},
	{VK_RETURN | EXTENDED_KEY | VIRTUAL_KEY, {"\x0D\xff"}}, /* number pad Enter */

	{VK_SPACE | VIRTUAL_KEY | CTRL_KEY,				{"\x00\xff"}}, 	  /* CTRL + SPACE */
	{0x32   | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x00\xff"}}, 	/* CTRL + @ */
	{0x32	| VIRTUAL_KEY | CTRL_KEY,				{"\x00\xff"}}, 	/* CTRL + 2 */
	{0x36	| VIRTUAL_KEY | CTRL_KEY,				{"\x1e\xff"}},	/* CTRL + 6 */
	{0xbd	| VIRTUAL_KEY | CTRL_KEY,				{"\x1f\xff"}},	/* CTRL + - */
	};

const KEYTBLSTORAGE VTUTF8_Cursor_KeyTable[MAX_VTUTF8_CURSOR_KEYS] =
    {
	{VK_UP	 | VIRTUAL_KEY,				{"\x1BOA\xff"}},  /* KN_UP */
	{VK_DOWN | VIRTUAL_KEY,				{"\x1BOB\xff"}},  /* KN_DOWN */
	{VK_RIGHT| VIRTUAL_KEY,				{"\x1BOC\xff"}},  /* KN_RIGHT */
	{VK_LEFT | VIRTUAL_KEY,				{"\x1BOD\xff"}},  /* KN_LEFT */

	{VK_UP	 | EXTENDED_KEY | VIRTUAL_KEY,	{"\x1BOA\xff"}},  /* KN_UP */
	{VK_DOWN | EXTENDED_KEY | VIRTUAL_KEY,{"\x1BOB\xff"}},  /* KN_DOWN */
	{VK_RIGHT| EXTENDED_KEY | VIRTUAL_KEY,{"\x1BOC\xff"}},  /* KN_RIGHT */
	{VK_LEFT | EXTENDED_KEY | VIRTUAL_KEY,{"\x1BOD\xff"}},  /* KN_LEFT */

	// Shift key
	{VK_UP	 | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOA\xff"}}, /* KN_UP */
	{VK_DOWN | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOB\xff"}}, /* KN_DOWN */
	{VK_RIGHT| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOC\xff"}}, /* KN_RIGHT */
	{VK_LEFT | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOD\xff"}}, /* KN_LEFT */

	{VK_UP	 | EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOA\xff"}}, /* KN_UP */
	{VK_DOWN | EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOB\xff"}}, /* KN_DOWN */
	{VK_RIGHT| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOC\xff"}}, /* KN_RIGHT */
	{VK_LEFT | EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOD\xff"}}, /* KN_LEFT */

	// Ctrl key
	{VK_UP	 | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOA\xff"}}, /* KN_UP */
	{VK_DOWN | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOB\xff"}}, /* KN_DOWN */
	{VK_RIGHT| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOC\xff"}}, /* KN_RIGHT */
	{VK_LEFT | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOD\xff"}}, /* KN_LEFT */

	{VK_UP	 | EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOA\xff"}}, /* KN_UP */
	{VK_DOWN | EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOB\xff"}}, /* KN_DOWN */
	{VK_RIGHT| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOC\xff"}}, /* KN_RIGHT */
	{VK_LEFT | EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOD\xff"}}, /* KN_LEFT */

	// Alt key
	{VK_UP	 | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOA\xff"}}, /* KN_UP */
	{VK_DOWN | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOB\xff"}}, /* KN_DOWN */
	{VK_RIGHT| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOC\xff"}}, /* KN_RIGHT */
	{VK_LEFT | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOD\xff"}}, /* KN_LEFT */

	{VK_UP	 | EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOA\xff"}}, /* KN_UP */
	{VK_DOWN | EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOB\xff"}}, /* KN_DOWN */
	{VK_RIGHT| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOC\xff"}}, /* KN_RIGHT */
	{VK_LEFT | EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOD\xff"}}, /* KN_LEFT */

	// Shift Ctrl key
	{VK_UP	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOA\xff"}}, /* KN_UP */
	{VK_DOWN | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOB\xff"}}, /* KN_DOWN */
	{VK_RIGHT| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOC\xff"}}, /* KN_RIGHT */
	{VK_LEFT | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOD\xff"}}, /* KN_LEFT */

	{VK_UP	 | EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOA\xff"}}, /* KN_UP */
	{VK_DOWN | EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOB\xff"}}, /* KN_DOWN */
	{VK_RIGHT| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOC\xff"}}, /* KN_RIGHT */
	{VK_LEFT | EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOD\xff"}}, /* KN_LEFT */

	// Shift Alt key
	{VK_UP	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOA\xff"}}, /* KN_UP */
	{VK_DOWN | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOB\xff"}}, /* KN_DOWN */
	{VK_RIGHT| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOC\xff"}}, /* KN_RIGHT */
	{VK_LEFT | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOD\xff"}}, /* KN_LEFT */

	{VK_UP	 | EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOA\xff"}}, /* KN_UP */
	{VK_DOWN | EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOB\xff"}}, /* KN_DOWN */
	{VK_RIGHT| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOC\xff"}}, /* KN_RIGHT */
	{VK_LEFT | EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOD\xff"}}, /* KN_LEFT */

	// Ctrl Alt key
	{VK_UP	 | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOA\xff"}}, /* KN_UP */
	{VK_DOWN | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOB\xff"}}, /* KN_DOWN */
	{VK_RIGHT| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOC\xff"}}, /* KN_RIGHT */
	{VK_LEFT | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOD\xff"}}, /* KN_LEFT */

	{VK_UP	 | EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOA\xff"}}, /* KN_UP */
	{VK_DOWN | EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOB\xff"}}, /* KN_DOWN */
	{VK_RIGHT| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOC\xff"}}, /* KN_RIGHT */
	{VK_LEFT | EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOD\xff"}}, /* KN_LEFT */

	// Shift Ctrl Alt key
	{VK_UP	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOA\xff"}}, /* KN_UP */
	{VK_DOWN | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOB\xff"}}, /* KN_DOWN */
	{VK_RIGHT| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOC\xff"}}, /* KN_RIGHT */
	{VK_LEFT | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOD\xff"}}, /* KN_LEFT */

	{VK_UP	 | EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOA\xff"}}, /* KN_UP */
	{VK_DOWN | EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOB\xff"}}, /* KN_DOWN */
	{VK_RIGHT| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOC\xff"}}, /* KN_RIGHT */
	{VK_LEFT | EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOD\xff"}}, /* KN_LEFT */

	};

const KEYTBLSTORAGE VTUTF8_Keypad_KeyTable[MAX_VTUTF8_KEYPAD_KEYS] =
    {
	{VK_NUMPAD0 | VIRTUAL_KEY,	 {"\x1BOp\xff"}}, /* KT_KP + '0' (alternate mode) */
	{VK_NUMPAD1 | VIRTUAL_KEY,	 {"\x1BOq\xff"}}, /* KT_KP + '1' (alternate mode) */
	{VK_NUMPAD2 | VIRTUAL_KEY,	 {"\x1BOr\xff"}}, /* KT_KP + '2' (alternate mode) */
	{VK_NUMPAD3 | VIRTUAL_KEY,	 {"\x1BOs\xff"}}, /* KT_KP + '3' (alternate mode) */
	{VK_NUMPAD4 | VIRTUAL_KEY,	 {"\x1BOt\xff"}}, /* KT_KP + '4' (alternate mode) */
	{VK_NUMPAD5 | VIRTUAL_KEY,	 {"\x1BOu\xff"}}, /* KT_KP + '5' (alternate mode) */
	{VK_NUMPAD6 | VIRTUAL_KEY,	 {"\x1BOv\xff"}}, /* KT_KP + '6' (alternate mode) */
	{VK_NUMPAD7 | VIRTUAL_KEY,	 {"\x1BOw\xff"}}, /* KT_KP + '7' (alternate mode) */
	{VK_NUMPAD8 | VIRTUAL_KEY,	 {"\x1BOx\xff"}}, /* KT_KP + '8' (alternate mode) */
	{VK_NUMPAD9 | VIRTUAL_KEY,	 {"\x1BOy\xff"}}, /* KT_KP + '9' (alternate mode) */
	{VK_DECIMAL | VIRTUAL_KEY,	 {"\x1BOn\xff"}}, /* KT_KP + '.' (alternate mode) */

	{VK_ADD		| VIRTUAL_KEY,	 {"\x1BOl\xff"}}, /* KT_KP + '*' (alternate mode) */
	{VK_RETURN	| EXTENDED_KEY,  {"\x1BOM\xff"}}, /* KT_KP + '+' (alternate mode) */
	{VK_SUBTRACT | VIRTUAL_KEY,	 {"\x1BOm\xff"}}, /* KT_KP + '-' (alternate mode) */

	// Shift key
	{VK_NUMPAD0 | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOp\xff"}}, /* KT_KP + '0' (alternate mode) */
	{VK_NUMPAD1 | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOq\xff"}}, /* KT_KP + '1' (alternate mode) */
	{VK_NUMPAD2 | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOr\xff"}}, /* KT_KP + '2' (alternate mode) */
	{VK_NUMPAD3 | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOs\xff"}}, /* KT_KP + '3' (alternate mode) */
	{VK_NUMPAD4 | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOt\xff"}}, /* KT_KP + '4' (alternate mode) */
	{VK_NUMPAD5 | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOu\xff"}}, /* KT_KP + '5' (alternate mode) */
	{VK_NUMPAD6 | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOv\xff"}}, /* KT_KP + '6' (alternate mode) */
	{VK_NUMPAD7 | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOw\xff"}}, /* KT_KP + '7' (alternate mode) */
	{VK_NUMPAD8 | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOx\xff"}}, /* KT_KP + '8' (alternate mode) */
	{VK_NUMPAD9 | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOy\xff"}}, /* KT_KP + '9' (alternate mode) */
	{VK_DECIMAL | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOn\xff"}}, /* KT_KP + '.' (alternate mode) */
	{VK_ADD		| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOl\xff"}}, /* KT_KP + '*' (alternate mode) */
	{VK_SUBTRACT| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOm\xff"}}, /* KT_KP + '-' (alternate mode) */
	{VK_RETURN	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1BOM\xff"}}, /* KT_KP + '+' (alternate mode) */

	// Ctrl key
	{VK_NUMPAD0 | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOp\xff"}}, /* KT_KP + '0' (alternate mode) */
	{VK_NUMPAD1 | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOq\xff"}}, /* KT_KP + '1' (alternate mode) */
	{VK_NUMPAD2 | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOr\xff"}}, /* KT_KP + '2' (alternate mode) */
	{VK_NUMPAD3 | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOs\xff"}}, /* KT_KP + '3' (alternate mode) */
	{VK_NUMPAD4 | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOt\xff"}}, /* KT_KP + '4' (alternate mode) */
	{VK_NUMPAD5 | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOu\xff"}}, /* KT_KP + '5' (alternate mode) */
	{VK_NUMPAD6 | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOv\xff"}}, /* KT_KP + '6' (alternate mode) */
	{VK_NUMPAD7 | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOw\xff"}}, /* KT_KP + '7' (alternate mode) */
	{VK_NUMPAD8 | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOx\xff"}}, /* KT_KP + '8' (alternate mode) */
	{VK_NUMPAD9 | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOy\xff"}}, /* KT_KP + '9' (alternate mode) */
	{VK_DECIMAL | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOn\xff"}}, /* KT_KP + '.' (alternate mode) */
	{VK_ADD		| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOl\xff"}}, /* KT_KP + '*' (alternate mode) */
	{VK_SUBTRACT| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOm\xff"}}, /* KT_KP + '-' (alternate mode) */
	{VK_RETURN	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1BOM\xff"}}, /* KT_KP + '+' (alternate mode) */

	// Alt key
	{VK_NUMPAD0 | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOp\xff"}}, /* KT_KP + '0' (alternate mode) */
	{VK_NUMPAD1 | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOq\xff"}}, /* KT_KP + '1' (alternate mode) */
	{VK_NUMPAD2 | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOr\xff"}}, /* KT_KP + '2' (alternate mode) */
	{VK_NUMPAD3 | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOs\xff"}}, /* KT_KP + '3' (alternate mode) */
	{VK_NUMPAD4 | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOt\xff"}}, /* KT_KP + '4' (alternate mode) */
	{VK_NUMPAD5 | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOu\xff"}}, /* KT_KP + '5' (alternate mode) */
	{VK_NUMPAD6 | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOv\xff"}}, /* KT_KP + '6' (alternate mode) */
	{VK_NUMPAD7 | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOw\xff"}}, /* KT_KP + '7' (alternate mode) */
	{VK_NUMPAD8 | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOx\xff"}}, /* KT_KP + '8' (alternate mode) */
	{VK_NUMPAD9 | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOy\xff"}}, /* KT_KP + '9' (alternate mode) */
	{VK_DECIMAL | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOn\xff"}}, /* KT_KP + '.' (alternate mode) */
	{VK_ADD		| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOl\xff"}}, /* KT_KP + '*' (alternate mode) */
	{VK_SUBTRACT| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOm\xff"}}, /* KT_KP + '-' (alternate mode) */
	{VK_RETURN	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1BOM\xff"}}, /* KT_KP + '+' (alternate mode) */

	// Shift Ctrl key
	{VK_NUMPAD0 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOp\xff"}}, /* KT_KP + '0' (alternate mode) */
	{VK_NUMPAD1 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOq\xff"}}, /* KT_KP + '1' (alternate mode) */
	{VK_NUMPAD2 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOr\xff"}}, /* KT_KP + '2' (alternate mode) */
	{VK_NUMPAD3 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOs\xff"}}, /* KT_KP + '3' (alternate mode) */
	{VK_NUMPAD4 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOt\xff"}}, /* KT_KP + '4' (alternate mode) */
	{VK_NUMPAD5 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOu\xff"}}, /* KT_KP + '5' (alternate mode) */
	{VK_NUMPAD6 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOv\xff"}}, /* KT_KP + '6' (alternate mode) */
	{VK_NUMPAD7 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOw\xff"}}, /* KT_KP + '7' (alternate mode) */
	{VK_NUMPAD8 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOx\xff"}}, /* KT_KP + '8' (alternate mode) */
	{VK_NUMPAD9 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOy\xff"}}, /* KT_KP + '9' (alternate mode) */
	{VK_DECIMAL | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOn\xff"}}, /* KT_KP + '.' (alternate mode) */
	{VK_ADD		| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOl\xff"}}, /* KT_KP + '*' (alternate mode) */
	{VK_SUBTRACT| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOm\xff"}}, /* KT_KP + '-' (alternate mode) */
	{VK_RETURN	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1BOM\xff"}}, /* KT_KP + '+' (alternate mode) */

	// Shift Alt key
	{VK_NUMPAD0 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOp\xff"}}, /* KT_KP + '0' (alternate mode) */
	{VK_NUMPAD1 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOq\xff"}}, /* KT_KP + '1' (alternate mode) */
	{VK_NUMPAD2 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOr\xff"}}, /* KT_KP + '2' (alternate mode) */
	{VK_NUMPAD3 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOs\xff"}}, /* KT_KP + '3' (alternate mode) */
	{VK_NUMPAD4 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOt\xff"}}, /* KT_KP + '4' (alternate mode) */
	{VK_NUMPAD5 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOu\xff"}}, /* KT_KP + '5' (alternate mode) */
	{VK_NUMPAD6 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOv\xff"}}, /* KT_KP + '6' (alternate mode) */
	{VK_NUMPAD7 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOw\xff"}}, /* KT_KP + '7' (alternate mode) */
	{VK_NUMPAD8 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOx\xff"}}, /* KT_KP + '8' (alternate mode) */
	{VK_NUMPAD9 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOy\xff"}}, /* KT_KP + '9' (alternate mode) */
	{VK_DECIMAL | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOn\xff"}}, /* KT_KP + '.' (alternate mode) */
	{VK_ADD		| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOl\xff"}}, /* KT_KP + '*' (alternate mode) */
	{VK_SUBTRACT| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOm\xff"}}, /* KT_KP + '-' (alternate mode) */
	{VK_RETURN	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1BOM\xff"}}, /* KT_KP + '+' (alternate mode) */

	// Ctrl Alt key
	{VK_NUMPAD0 | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOp\xff"}}, /* KT_KP + '0' (alternate mode) */
	{VK_NUMPAD1 | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOq\xff"}}, /* KT_KP + '1' (alternate mode) */
	{VK_NUMPAD2 | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOr\xff"}}, /* KT_KP + '2' (alternate mode) */
	{VK_NUMPAD3 | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOs\xff"}}, /* KT_KP + '3' (alternate mode) */
	{VK_NUMPAD4 | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOt\xff"}}, /* KT_KP + '4' (alternate mode) */
	{VK_NUMPAD5 | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOu\xff"}}, /* KT_KP + '5' (alternate mode) */
	{VK_NUMPAD6 | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOv\xff"}}, /* KT_KP + '6' (alternate mode) */
	{VK_NUMPAD7 | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOw\xff"}}, /* KT_KP + '7' (alternate mode) */
	{VK_NUMPAD8 | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOx\xff"}}, /* KT_KP + '8' (alternate mode) */
	{VK_NUMPAD9 | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOy\xff"}}, /* KT_KP + '9' (alternate mode) */
	{VK_DECIMAL | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOn\xff"}}, /* KT_KP + '.' (alternate mode) */
	{VK_ADD		| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOl\xff"}}, /* KT_KP + '*' (alternate mode) */
	{VK_SUBTRACT| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOm\xff"}}, /* KT_KP + '-' (alternate mode) */
	{VK_RETURN	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1BOM\xff"}}, /* KT_KP + '+' (alternate mode) */

	// Shift Ctrl Alt key
	{VK_NUMPAD0 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOp\xff"}}, /* KT_KP + '0' (alternate mode) */
	{VK_NUMPAD1 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOq\xff"}}, /* KT_KP + '1' (alternate mode) */
	{VK_NUMPAD2 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOr\xff"}}, /* KT_KP + '2' (alternate mode) */
	{VK_NUMPAD3 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOs\xff"}}, /* KT_KP + '3' (alternate mode) */
	{VK_NUMPAD4 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOt\xff"}}, /* KT_KP + '4' (alternate mode) */
	{VK_NUMPAD5 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOu\xff"}}, /* KT_KP + '5' (alternate mode) */
	{VK_NUMPAD6 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOv\xff"}}, /* KT_KP + '6' (alternate mode) */
	{VK_NUMPAD7 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOw\xff"}}, /* KT_KP + '7' (alternate mode) */
	{VK_NUMPAD8 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOx\xff"}}, /* KT_KP + '8' (alternate mode) */
	{VK_NUMPAD9 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOy\xff"}}, /* KT_KP + '9' (alternate mode) */
	{VK_DECIMAL | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOn\xff"}}, /* KT_KP + '.' (alternate mode) */
	{VK_ADD		| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOl\xff"}}, /* KT_KP + '*' (alternate mode) */
	{VK_SUBTRACT| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1BOm\xff"}}, /* KT_KP + '-' (alternate mode) */
	{VK_RETURN	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03x1B\x01\x1BOM\xff"}}, /* KT_KP + '+' (alternate mode) */
	};

const KEYTBLSTORAGE VTUTF8ModifiedKeyTable[MAX_VTUTF8_MODIFIED_KEYS] =
    {
	// Shift keys
	{VK_UP		| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B[A\xff"}}, /* KN_UP */
	{VK_DOWN	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B[B\xff"}}, /* KN_DOWN */
	{VK_RIGHT	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B[C\xff"}}, /* KN_RIGHT */
	{VK_LEFT	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B[D\xff"}}, /* KN_LEFT */
	{VK_HOME	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1Bh\xff"}}, /* KN_HOME */
	{VK_INSERT	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B+\xff"}},  /* KN_INS */
	{VK_DELETE	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B-\xff"}},  /* KN_DEL */
	{VK_NEXT 	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B/\xff"}},  /* KN_PGDN */
	{VK_PRIOR	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B?\xff"}},  /* KN_PGUP */
	{VK_END		| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1Bk\xff"}}, /* KN_END */
	{VK_BACKSPACE|VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x08\xff"}},	/* KN_BACKSPACE */
	{VK_ESCAPE	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\xff"}},	/* KN_ESC */

	{VK_UP		| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B[A\xff"}}, /* KN_UP */
	{VK_DOWN	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B[B\xff"}}, /* KN_DOWN */
	{VK_RIGHT	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B[C\xff"}}, /* KN_RIGHT */
	{VK_LEFT	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B[D\xff"}}, /* KN_LEFT */
	{VK_HOME 	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1Bh\xff"}}, /* KN_HOME */
	{VK_INSERT	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B+\xff"}},  /* KN_INS */
	{VK_DELETE	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B-\xff"}},  /* KN_DEL */
	{VK_NEXT 	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B/\xff"}},  /* KN_PGDN */
	{VK_PRIOR	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B?\xff"}},  /* KN_PGUP */
	{VK_END		| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1Bk\xff"}},  /* KN_END */

	{0x2F	| EXTENDED_KEY | SHIFT_KEY, {"\x1B\x13\x2F\xff"}}, /* number pad / */
	{VK_RETURN| EXTENDED_KEY, {"\x1B\x13\x0D\xff"}}, /* number pad / */

	{VK_F1	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x31\xff"}}, /* KN_F1 */
	{VK_F2	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x32\xff"}}, /* KN_F2 */
	{VK_F3	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x33\xff"}}, /* KN_F3 */
	{VK_F4	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x34\xff"}}, /* KN_F4 */
	{VK_F5	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x35\xff"}}, /* KN_F5 */
	{VK_F6	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x36\xff"}}, /* KN_F6 */
	{VK_F7	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x37\xff"}}, /* KN_F7 */
	{VK_F8	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x38\xff"}}, /* KN_F8 */
	{VK_F9	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x39\xff"}}, /* KN_F9 */
	{VK_F10	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x30\xff"}}, /* KN_F10 */
	{VK_F11	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B!\xff"}},	  /* KN_F11 */
	{VK_F12	| VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B@\xff"}},	  /* KN_F12 */

	{VK_F1	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x31\xff"}}, /* KN_F1 */
	{VK_F2	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x32\xff"}}, /* KN_F2 */
	{VK_F3	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x33\xff"}}, /* KN_F3 */
	{VK_F4	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x34\xff"}}, /* KN_F4 */
	{VK_F5	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x35\xff"}}, /* KN_F5 */
	{VK_F6	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x36\xff"}}, /* KN_F6 */
	{VK_F7	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x37\xff"}}, /* KN_F7 */
	{VK_F8	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x38\xff"}}, /* KN_F8 */
	{VK_F9	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x39\xff"}}, /* KN_F9 */
	{VK_F10	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B\x30\xff"}}, /* KN_F10 */
	{VK_F11	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B!\xff"}},	 /* KN_F11 */
	{VK_F12	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY, {"\x1B\x13\x1B@\xff"}},	 /* KN_F12 */

	// Ctrl keys
	{VK_UP		| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B[A\xff"}}, /* KN_UP */
	{VK_DOWN	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B[B\xff"}}, /* KN_DOWN */
	{VK_RIGHT	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B[C\xff"}}, /* KN_RIGHT */
	{VK_LEFT	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B[D\xff"}}, /* KN_LEFT */
	{VK_HOME	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1Bh\xff"}}, /* KN_HOME */
	{VK_INSERT	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B+\xff"}},  /* KN_INS */
	{VK_DELETE	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B-\xff"}},  /* KN_DEL */
	{VK_NEXT 	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B/\xff"}},  /* KN_PGDN */
	{VK_PRIOR	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B?\xff"}},  /* KN_PGUP */
	{VK_END		| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1Bk\xff"}}, /* KN_END */
	{VK_TAB		| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x09\xff"}},   /* KN_TAB */
	{VK_BACKSPACE|VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x08\xff"}},	/* KN_BACKSPACE */
	{VK_ESCAPE	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\xff"}},	/* KN_ESC */

	{VK_UP		| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B[A\xff"}}, /* KN_UP */
	{VK_DOWN	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B[B\xff"}}, /* KN_DOWN */
	{VK_RIGHT	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B[C\xff"}}, /* KN_RIGHT */
	{VK_LEFT	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B[D\xff"}}, /* KN_LEFT */
	{VK_HOME 	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1Bh\xff"}}, /* KN_HOME */
	{VK_INSERT	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B+\xff"}},  /* KN_INS */
	{VK_DELETE	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B-\xff"}},  /* KN_DEL */
	{VK_NEXT 	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B/\xff"}},  /* KN_PGDN */
	{VK_PRIOR	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B?\xff"}},  /* KN_PGUP */
	{VK_END		| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1Bk\xff"}}, /* KN_END */

	{VK_DIVIDE	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x2F\xff"}}, /* number pad / */
	{VK_MULTIPLY			   | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03*\xff"}}, /* number pad * */
	{VK_SUBTRACT			   | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03-\xff"}}, /* number pad - */
	{VK_ADD					   | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03,\xff"}}, /* number pad + */
	{0x0A       | EXTENDED_KEY, {"\x0A\xff"}}, /* number pad Enter */

	{VK_F1	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x31\xff"}}, /* KN_F1 */
	{VK_F2	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x32\xff"}}, /* KN_F2 */
	{VK_F3	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x33\xff"}}, /* KN_F3 */
	{VK_F4	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x34\xff"}}, /* KN_F4 */
	{VK_F5	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x35\xff"}}, /* KN_F5 */
	{VK_F6	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x36\xff"}}, /* KN_F6 */
	{VK_F7	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x37\xff"}}, /* KN_F7 */
	{VK_F8	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x38\xff"}}, /* KN_F8 */
	{VK_F9	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x39\xff"}}, /* KN_F9 */
	{VK_F10	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x30\xff"}}, /* KN_F10 */
	{VK_F11	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B!\xff"}},	 /* KN_F11 */
	{VK_F12	| VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B@\xff"}},	 /* KN_F12 */

	{VK_F1	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x31\xff"}}, /* KN_F1 */
	{VK_F2	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x32\xff"}}, /* KN_F2 */
	{VK_F3	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x33\xff"}}, /* KN_F3 */
	{VK_F4	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x34\xff"}}, /* KN_F4 */
	{VK_F5	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x35\xff"}}, /* KN_F5 */
	{VK_F6	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x36\xff"}}, /* KN_F6 */
	{VK_F7	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x37\xff"}}, /* KN_F7 */
	{VK_F8	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x38\xff"}}, /* KN_F8 */
	{VK_F9	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x39\xff"}}, /* KN_F9 */
	{VK_F10	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B\x30\xff"}}, /* KN_F10 */
	{VK_F11	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B!\xff"}},	/* KN_F11 */
	{VK_F12	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY, {"\x1B\x03\x1B@\xff"}},	/* KN_F12 */

	// Alt keys
	{VK_UP		| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B[A\xff"}}, /* KN_UP */
	{VK_DOWN	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B[B\xff"}}, /* KN_DOWN */
	{VK_RIGHT	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B[C\xff"}}, /* KN_RIGHT */
	{VK_LEFT	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B[D\xff"}}, /* KN_LEFT */
	{VK_HOME	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1Bh\xff"}}, /* KN_HOME */
	{VK_INSERT	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B+\xff"}},  /* KN_INS */
	{VK_DELETE	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B-\xff"}},  /* KN_DEL */
	{VK_NEXT 	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B/\xff"}},  /* KN_PGDN */
	{VK_PRIOR	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B?\xff"}},  /* KN_PGUP */
	{VK_END		| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1Bk\xff"}}, /* KN_END */
	{VK_TAB		| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x09\xff"}},   /* KN_TAB */
	{VK_BACKSPACE|VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x08\xff"}},	  /* KN_BACKSPACE */
	{VK_ESCAPE	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\xff"}},	  /* KN_ESC */

	{VK_UP		| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B[A\xff"}}, /* KN_UP */
	{VK_DOWN	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B[B\xff"}}, /* KN_DOWN */
	{VK_RIGHT	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B[C\xff"}}, /* KN_RIGHT */
	{VK_LEFT	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B[D\xff"}}, /* KN_LEFT */
	{VK_HOME 	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1Bh\xff"}}, /* KN_HOME */
	{VK_INSERT	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B+\xff"}},  /* KN_INS */
	{VK_DELETE	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B-\xff"}},  /* KN_DEL */
	{VK_NEXT 	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B/\xff"}},  /* KN_PGDN */
	{VK_PRIOR	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B?\xff"}},  /* KN_PGUP */
	{VK_END		| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1Bk\xff"}}, /* KN_END */

	{0x2F	| EXTENDED_KEY | ALT_KEY, {"\x1B\x01\x2F\xff"}}, /* number pad / */
	{VK_RETURN  | EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x0D\xff"}}, /* number pad Enter */

	{VK_F1	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x31\xff"}}, /* KN_F1 */
	{VK_F2	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x32\xff"}}, /* KN_F2 */
	{VK_F3	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x33\xff"}}, /* KN_F3 */
	{VK_F4	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x34\xff"}}, /* KN_F4 */
	{VK_F5	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x35\xff"}},	/* KN_F5 */
	{VK_F6	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x36\xff"}},	/* KN_F6 */
	{VK_F7	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x37\xff"}},	/* KN_F7 */
	{VK_F8	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x38\xff"}},	/* KN_F8 */
	{VK_F9	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x39\xff"}},	/* KN_F9 */
	{VK_F10	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x30\xff"}},	/* KN_F10 */
	{VK_F11	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B!\xff"}},	/* KN_F11 */
	{VK_F12	| VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B@\xff"}},	/* KN_F12 */

	{VK_F1	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x31\xff"}}, /* KN_F1 */
	{VK_F2	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x32\xff"}}, /* KN_F2 */
	{VK_F3	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x33\xff"}}, /* KN_F3 */
	{VK_F4	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x34\xff"}}, /* KN_F4 */
	{VK_F5	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x35\xff"}}, /* KN_F5 */
	{VK_F6	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x36\xff"}}, /* KN_F6 */
	{VK_F7	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x37\xff"}}, /* KN_F7 */
	{VK_F8	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x38\xff"}}, /* KN_F8 */
	{VK_F9	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x39\xff"}}, /* KN_F9 */
	{VK_F10	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B\x30\xff"}}, /* KN_F10 */
	{VK_F11	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B!\xff"}},	   /* KN_F11 */
	{VK_F12	| EXTENDED_KEY | VIRTUAL_KEY | ALT_KEY, {"\x1B\x01\x1B@\xff"}},	   /* KN_F12 */

	// Shift Ctrl keys
	{VK_UP		| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B[A\xff"}}, /* KN_UP */
	{VK_DOWN	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B[B\xff"}}, /* KN_DOWN */
	{VK_RIGHT	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B[C\xff"}}, /* KN_RIGHT */
	{VK_LEFT	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B[D\xff"}}, /* KN_LEFT */
	{VK_HOME	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1Bh\xff"}}, /* KN_HOME */
	{VK_INSERT	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B+\xff"}},  /* KN_INS */
	{VK_DELETE	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B-\xff"}},  /* KN_DEL */
	{VK_NEXT 	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B/\xff"}},  /* KN_PGDN */
	{VK_PRIOR	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B?\xff"}},  /* KN_PGUP */
	{VK_END		| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1Bk\xff"}},  /* KN_END */
	{VK_TAB		| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x03\x5B\x5A\xff"}},   /* KN_TAB */
	{VK_BACKSPACE|VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x08\xff"}},	/* KN_BACKSPACE */
	{VK_ESCAPE	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\xff"}},	/* KN_ESC */

	{VK_UP		| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B[A\xff"}}, /* KN_UP */
	{VK_DOWN	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B[B\xff"}}, /* KN_DOWN */
	{VK_RIGHT	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B[C\xff"}}, /* KN_RIGHT */
	{VK_LEFT	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B[D\xff"}}, /* KN_LEFT */
	{VK_HOME 	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1Bh\xff"}}, /* KN_HOME */
	{VK_INSERT	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B+\xff"}},  /* KN_INS */
	{VK_DELETE	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B-\xff"}},  /* KN_DEL */
	{VK_NEXT 	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B/\xff"}},  /* KN_PGDN */
	{VK_PRIOR	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B?\xff"}},  /* KN_PGUP */
	{VK_END		| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1Bk\xff"}},  /* KN_END */

	{VK_DIVIDE	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x2F\xff"}}, /* number pad / */
	{VK_MULTIPLY			   | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03*\xff"}}, /* number pad * */
	{VK_SUBTRACT			   | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03-\xff"}}, /* number pad - */
	{VK_ADD					   | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03,\xff"}}, /* number pad + */
	{VK_RETURN  | EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x0D\xff"}}, /* number pad Enter */

	{VK_F1	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x31\xff"}}, /* KN_F1 */
	{VK_F2	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x32\xff"}}, /* KN_F2 */
	{VK_F3	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x33\xff"}}, /* KN_F3 */
	{VK_F4	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x34\xff"}}, /* KN_F4 */
	{VK_F5	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x35\xff"}}, /* KN_F5 */
	{VK_F6	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x36\xff"}}, /* KN_F6 */
	{VK_F7	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x37\xff"}}, /* KN_F7 */
	{VK_F8	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x38\xff"}}, /* KN_F8 */
	{VK_F9	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x39\xff"}}, /* KN_F9 */
	{VK_F10	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x30\xff"}}, /* KN_F10 */
	{VK_F11	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B!\xff"}},	  /* KN_F11 */
	{VK_F12	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B@\xff"}},	  /* KN_F12 */

	{VK_F1	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x31\xff"}}, /* KN_F1 */
	{VK_F2	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x32\xff"}}, /* KN_F2 */
	{VK_F3	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x33\xff"}}, /* KN_F3 */
	{VK_F4	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x34\xff"}}, /* KN_F4 */
	{VK_F5	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x35\xff"}}, /* KN_F5 */
	{VK_F6	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x36\xff"}}, /* KN_F6 */
	{VK_F7	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x37\xff"}}, /* KN_F7 */
	{VK_F8	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x38\xff"}}, /* KN_F8 */
	{VK_F9	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x39\xff"}}, /* KN_F9 */
	{VK_F10	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B\x30\xff"}}, /* KN_F10 */
	{VK_F11	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B!\xff"}},	 /* KN_F11 */
	{VK_F12	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY, {"\x1B\x13\x1B\x03\x1B@\xff"}},	 /* KN_F12 */

	// Shift Alt keys
	{VK_UP		| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B[A\xff"}}, /* KN_UP */
	{VK_DOWN	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B[B\xff"}}, /* KN_DOWN */
	{VK_RIGHT	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B[C\xff"}}, /* KN_RIGHT */
	{VK_LEFT	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B[D\xff"}}, /* KN_LEFT */
	{VK_HOME	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1Bh\xff"}}, /* KN_HOME */
	{VK_INSERT	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B+\xff"}},  /* KN_INS */
	{VK_DELETE	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B-\xff"}},  /* KN_DEL */
	{VK_NEXT 	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B/\xff"}},  /* KN_PGDN */
	{VK_PRIOR	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B?\xff"}},  /* KN_PGUP */
	{VK_END		| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1Bk\xff"}},  /* KN_END */
	{VK_TAB		| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x01\x5B\x5A\xff"}},   /* KN_TAB */
	{VK_BACKSPACE|VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x08\xff"}},	/* KN_BACKSPACE */
	{VK_ESCAPE	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\xff"}},	/* KN_ESC */

	{VK_UP		| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B[A\xff"}}, /* KN_UP */
	{VK_DOWN	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B[B\xff"}}, /* KN_DOWN */
	{VK_RIGHT	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B[C\xff"}}, /* KN_RIGHT */
	{VK_LEFT	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B[D\xff"}}, /* KN_LEFT */
	{VK_HOME 	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1Bh\xff"}}, /* KN_HOME */
	{VK_INSERT	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B+\xff"}},  /* KN_INS */
	{VK_DELETE	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B-\xff"}},  /* KN_DEL */
	{VK_NEXT 	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B/\xff"}},  /* KN_PGDN */
	{VK_PRIOR	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B?\xff"}},  /* KN_PGUP */
	{VK_END		| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1Bk\xff"}},  /* KN_END */

	{0x2F	| EXTENDED_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x01\x2F\xff"}}, /* number pad / */
	{VK_RETURN  | EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x01\x0D\xff"}}, /* number pad Enter */

	{VK_F1	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x31\xff"}}, /* KN_F1 */
	{VK_F2	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x32\xff"}}, /* KN_F2 */
	{VK_F3	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x33\xff"}}, /* KN_F3 */
	{VK_F4	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x34\xff"}}, /* KN_F4 */
	{VK_F5	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x35\xff"}}, /* KN_F5 */
	{VK_F6	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x36\xff"}}, /* KN_F6 */
	{VK_F7	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x37\xff"}}, /* KN_F7 */
	{VK_F8	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x38\xff"}}, /* KN_F8 */
	{VK_F9	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x39\xff"}}, /* KN_F9 */
	{VK_F10	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x30\xff"}}, /* KN_F10 */
	{VK_F11	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B!\xff"}},	  /* KN_F11 */
	{VK_F12	| VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B@\xff"}},	  /* KN_F12 */

	{VK_F1	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x31\xff"}}, /* KN_F1 */
	{VK_F2	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x32\xff"}}, /* KN_F2 */
	{VK_F3	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x33\xff"}}, /* KN_F3 */
	{VK_F4	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x34\xff"}}, /* KN_F4 */
	{VK_F5	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x35\xff"}}, /* KN_F5 */
	{VK_F6	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x36\xff"}}, /* KN_F6 */
	{VK_F7	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x37\xff"}}, /* KN_F7 */
	{VK_F8	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x38\xff"}}, /* KN_F8 */
	{VK_F9	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x39\xff"}}, /* KN_F9 */
	{VK_F10	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B\x30\xff"}}, /* KN_F10 */
	{VK_F11	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B!\xff"}},	 /* KN_F11 */
	{VK_F12	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x1B@\xff"}},	 /* KN_F12 */

	// Ctrl Alt keys
	{VK_UP		| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B[A\xff"}}, /* KN_UP */
	{VK_DOWN	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B[B\xff"}}, /* KN_DOWN */
	{VK_RIGHT	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B[C\xff"}}, /* KN_RIGHT */
	{VK_LEFT	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B[D\xff"}}, /* KN_LEFT */
	{VK_HOME	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1Bh\xff"}}, /* KN_HOME */
	{VK_INSERT	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B+\xff"}},  /* KN_INS */
	{VK_DELETE	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B-\xff"}},  /* KN_DEL */
	{VK_NEXT 	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B/\xff"}},  /* KN_PGDN */
	{VK_PRIOR	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B?\xff"}},  /* KN_PGUP */
	{VK_END		| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1Bk\xff"}},  /* KN_END */
	{VK_TAB		| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x09\xff"}},   /* KN_TAB */
	{VK_BACKSPACE|VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x08\xff"}},	/* KN_BACKSPACE */
	{VK_ESCAPE	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\xff"}},	/* KN_ESC */

	{VK_UP		| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B[A\xff"}}, /* KN_UP */
	{VK_DOWN	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B[B\xff"}}, /* KN_DOWN */
	{VK_RIGHT	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B[C\xff"}}, /* KN_RIGHT */
	{VK_LEFT	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B[D\xff"}}, /* KN_LEFT */
	{VK_HOME 	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1Bh\xff"}}, /* KN_HOME */
	{VK_INSERT	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B+\xff"}},  /* KN_INS */
	{VK_DELETE	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B-\xff"}},  /* KN_DEL */
	{VK_NEXT 	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B/\xff"}},  /* KN_PGDN */
	{VK_PRIOR	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B?\xff"}},  /* KN_PGUP */
	{VK_END		| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1Bk\xff"}},  /* KN_END */

	{VK_DIVIDE	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x2F\xff"}}, /* number pad / */
	{VK_MULTIPLY			   | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x01*\xff"}}, /* number pad * */
	{VK_SUBTRACT			   | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x01-\xff"}}, /* number pad - */
	{VK_ADD     			   | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x01,\xff"}}, /* number pad + */
	{VK_RETURN  | EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x01\x0D\xff"}}, /* number pad Enter */

	{VK_F1	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x31\xff"}}, /* KN_F1 */
	{VK_F2	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x32\xff"}}, /* KN_F2 */
	{VK_F3	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x33\xff"}}, /* KN_F3 */
	{VK_F4	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x34\xff"}}, /* KN_F4 */
	{VK_F5	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x35\xff"}}, /* KN_F5 */
	{VK_F6	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x36\xff"}}, /* KN_F6 */
	{VK_F7	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x37\xff"}}, /* KN_F7 */
	{VK_F8	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x38\xff"}}, /* KN_F8 */
	{VK_F9	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x39\xff"}}, /* KN_F9 */
	{VK_F10	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x30\xff"}}, /* KN_F10 */
	{VK_F11	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B!\xff"}},	 /* KN_F11 */
	{VK_F12	| VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B@\xff"}},	 /* KN_F12 */

	{VK_F1	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x31\xff"}}, /* KN_F1 */
	{VK_F2	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x32\xff"}}, /* KN_F2 */
	{VK_F3	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x33\xff"}}, /* KN_F3 */
	{VK_F4	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x34\xff"}}, /* KN_F4 */
	{VK_F5	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x35\xff"}}, /* KN_F5 */
	{VK_F6	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x36\xff"}}, /* KN_F6 */
	{VK_F7	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x37\xff"}}, /* KN_F7 */
	{VK_F8	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x38\xff"}}, /* KN_F8 */
	{VK_F9	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x39\xff"}}, /* KN_F9 */
	{VK_F10	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B\x30\xff"}}, /* KN_F10 */
	{VK_F11	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B!\xff"}},	/* KN_F11 */
	{VK_F12	| EXTENDED_KEY | VIRTUAL_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x1B@\xff"}},	/* KN_F12 */

	// Shift Ctrl Alt keys
	{VK_UP		| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B[A\xff"}}, /* KN_UP */
	{VK_DOWN	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B[B\xff"}}, /* KN_DOWN */
	{VK_RIGHT	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B[C\xff"}}, /* KN_RIGHT */
	{VK_LEFT	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B[D\xff"}}, /* KN_LEFT */
	{VK_HOME	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1Bh\xff"}}, /* KN_HOME */
	{VK_INSERT	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B+\xff"}},  /* KN_INS */
	{VK_DELETE	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B-\xff"}},  /* KN_DEL */
	{VK_NEXT 	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B/\xff"}},  /* KN_PGDN */
	{VK_PRIOR	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B?\xff"}},  /* KN_PGUP */
	{VK_END		| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1Bk\xff"}},  /* KN_END */
	{VK_TAB		| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x03\x1B\x01\x5B\x5A\xff"}},   /* KN_TAB */
	{VK_BACKSPACE|VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x08\xff"}},	/* KN_BACKSPACE */
	{VK_ESCAPE	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\xff"}},	/* KN_ESC */

	{VK_UP		| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B[A\xff"}}, /* KN_UP */
	{VK_DOWN	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B[B\xff"}}, /* KN_DOWN */
	{VK_RIGHT	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B[C\xff"}}, /* KN_RIGHT */
	{VK_LEFT	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B[D\xff"}}, /* KN_LEFT */
	{VK_HOME 	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1Bh\xff"}}, /* KN_HOME */
	{VK_INSERT	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B+\xff"}},  /* KN_INS */
	{VK_DELETE	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B-\xff"}},  /* KN_DEL */
	{VK_NEXT 	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B/\xff"}},  /* KN_PGDN */
	{VK_PRIOR	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B?\xff"}},  /* KN_PGUP */
	{VK_END		| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1Bk\xff"}},  /* KN_END */

	{VK_DIVIDE	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x2F\xff"}}, /* number pad / */
	{VK_MULTIPLY			   | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01*\xff"}}, /* number pad * */
	{VK_SUBTRACT			   | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01-\xff"}}, /* number pad - */
	{VK_ADD     			   | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01,\xff"}}, /* number pad + */
	{VK_RETURN  | EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x0D\xff"}}, /* number pad Enter */

	{VK_F1	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x31\xff"}}, /* KN_F1 */
	{VK_F2	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x32\xff"}}, /* KN_F2 */
	{VK_F3	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x33\xff"}}, /* KN_F3 */
	{VK_F4	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x34\xff"}}, /* KN_F4 */
	{VK_F5	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x35\xff"}}, /* KN_F5 */
	{VK_F6	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x36\xff"}}, /* KN_F6 */
	{VK_F7	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x37\xff"}}, /* KN_F7 */
	{VK_F8	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x38\xff"}}, /* KN_F8 */
	{VK_F9	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x39\xff"}}, /* KN_F9 */
	{VK_F10	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x30\xff"}}, /* KN_F10 */
	{VK_F11	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B!\xff"}},	 /* KN_F11 */
	{VK_F12	| VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B@\xff"}},	 /* KN_F12 */

	{VK_F1	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x31\xff"}}, /* KN_F1 */
	{VK_F2	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x32\xff"}}, /* KN_F2 */
	{VK_F3	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x33\xff"}}, /* KN_F3 */
	{VK_F4	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x34\xff"}}, /* KN_F4 */
	{VK_F5	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x35\xff"}}, /* KN_F5 */
	{VK_F6	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x36\xff"}}, /* KN_F6 */
	{VK_F7	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x37\xff"}}, /* KN_F7 */
	{VK_F8	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x38\xff"}}, /* KN_F8 */
	{VK_F9	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x39\xff"}}, /* KN_F9 */
	{VK_F10	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B\x30\xff"}}, /* KN_F10 */
	{VK_F11	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B!\xff"}},	/* KN_F11 */
	{VK_F12	| EXTENDED_KEY | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY, {"\x1B\x13\x1B\x03\x1B\x01\x1B@\xff"}},	/* KN_F12 */

	};

const KEYTBLSTORAGE VTUTF8ModifiedAlhpaKeyTable[MAX_VTUTF8_MODIFIED_ALPHA_KEYS] =
    {
	// Alt keys
	{0x20				   | ALT_KEY,	{"\x1B\x01\x20\xff"}},  /* space */
	{0x21	 			   | ALT_KEY,	{"\x1B\x01\x21\xff"}},  /* ! */
	{0x22	 			   | ALT_KEY,	{"\x1B\x01\x22\xff"}},  /* " */
	{0x23	 			   | ALT_KEY,	{"\x1B\x01\x23\xff"}},  /* # */
	{0x24	 			   | ALT_KEY,	{"\x1B\x01\x24\xff"}},  /* $ */
	{0x25	 			   | ALT_KEY,	{"\x1B\x01\x25\xff"}},  /* % */
	{0x26	 			   | ALT_KEY,	{"\x1B\x01\x26\xff"}},  /* & */
	{0x27	 			   | ALT_KEY,	{"\x1B\x01\x27\xff"}},  /* ' */
	{0x28	 			   | ALT_KEY,	{"\x1B\x01\x28\xff"}},  /* ( */
	{0x29	 			   | ALT_KEY,	{"\x1B\x01\x29\xff"}},  /* ) */
	{0x2A	 			   | ALT_KEY,	{"\x1B\x01\x2A\xff"}},  /* * */
	{0x2B	 			   | ALT_KEY,	{"\x1B\x01\x2B\xff"}},  /* + */
	{0x2C	 			   | ALT_KEY,	{"\x1B\x01\x2C\xff"}},  /* , */
	{0x2D	 			   | ALT_KEY,	{"\x1B\x01\x2D\xff"}},  /* - */
	{0x2E	 			   | ALT_KEY,	{"\x1B\x01\x2E\xff"}},  /* . */
	{0x2F	 			   | ALT_KEY,	{"\x1B\x01\x2F\xff"}},  /* / */
	{0x30	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x30\xff"}},  /* 0 */
	{0x31	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x31\xff"}},  /* 1 */
	{0x32	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x32\xff"}},  /* 2 */
	{0x33	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x33\xff"}},  /* 3 */
	{0x34	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x34\xff"}},  /* 4 */
	{0x35	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x35\xff"}},  /* 5 */
	{0x36	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x36\xff"}},  /* 6 */
	{0x37	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x37\xff"}},  /* 7 */
	{0x38	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x38\xff"}},  /* 8 */
	{0x39	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x39\xff"}},  /* 9 */
	{0x3A				   | ALT_KEY,	{"\x1B\x01\x3A\xff"}},  /* : */
	{0x3B	 			   | ALT_KEY,	{"\x1B\x01\x3B\xff"}},  /* ; */
	{0x3C	  			   | ALT_KEY,	{"\x1B\x01\x3C\xff"}},  /* < */
	{0x3D	  			   | ALT_KEY,	{"\x1B\x01\x3D\xff"}},  /* = */
	{0x3E	  			   | ALT_KEY,	{"\x1B\x01\x3E\xff"}},  /* > */
	{0x3F	  			   | ALT_KEY,	{"\x1B\x01\x3F\xff"}},  /* ? */
	{0x40	 			   | ALT_KEY,	{"\x1B\x01\x40\xff"}},  /* @ */
	{0x41	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x41\xff"}},  /* A */
	{0x42	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x42\xff"}},  /* B */
	{0x43	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x43\xff"}},  /* C */
	{0x44	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x44\xff"}},  /* D */
	{0x45	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x45\xff"}},  /* E */
	{0x46	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x46\xff"}},  /* F */
	{0x47	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x47\xff"}},  /* G */
	{0x48	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x48\xff"}},  /* H */
	{0x49	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x49\xff"}},  /* I */
	{0x4A	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x4A\xff"}},  /* J */
	{0x4B	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x4B\xff"}},  /* K */
	{0x4C	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x4C\xff"}},  /* L */
	{0x4D	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x4D\xff"}},  /* M */
	{0x4E	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x4E\xff"}},  /* N */
	{0x4F	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x4F\xff"}},  /* O */
	{0x50	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x50\xff"}},  /* P */
	{0x51	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x51\xff"}},  /* Q */
	{0x52	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x52\xff"}},  /* R */
	{0x53	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x53\xff"}},  /* S */
	{0x54	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x54\xff"}},  /* T */
	{0x55	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x55\xff"}},  /* U */
	{0x56	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x56\xff"}},  /* V */
	{0x57	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x57\xff"}},  /* W */
	{0x58	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x58\xff"}},  /* X */
	{0x59	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x59\xff"}},  /* Y */
	{0x5A	 | VIRTUAL_KEY | ALT_KEY,	{"\x1B\x01\x5A\xff"}},  /* Z */
	{0x5B				   | ALT_KEY,	{"\x1B\x01\x5B\xff"}},  /* [ */
	{0x5C	 			   | ALT_KEY,	{"\x1B\x01\x5C\xff"}},  /* \ */
	{0x5D	 			   | ALT_KEY,	{"\x1B\x01\x5D\xff"}},  /* ] */
	{0x5E	 			   | ALT_KEY,	{"\x1B\x01\x5E\xff"}},  /* ^ */
	{0x5F	 			   | ALT_KEY,	{"\x1B\x01\x5F\xff"}},  /* _ */
	{0x60	 			   | ALT_KEY,	{"\x1B\x01\x60\xff"}},  /* ` */
	{0x7B	 			   | ALT_KEY,	{"\x1B\x01\x7B\xff"}},  /* { */
	{0x7C	 			   | ALT_KEY,	{"\x1B\x01\x7C\xff"}},  /* | */
	{0x7D	 			   | ALT_KEY,	{"\x1B\x01\x7D\xff"}},  /* } */
	{0x7E	 			   | ALT_KEY,	{"\x1B\x01\x7E\xff"}},  /* ~ */

	// Ctrl keys
	{0xB0	 | VIRTUAL_KEY | CTRL_KEY,	{"\x1B\x03\x20\xff"}},  /* space */
	{0xB7	 | VIRTUAL_KEY | CTRL_KEY,	{"\x1B\x03\x27\xff"}},  /* ' */
	{0xBC	 | VIRTUAL_KEY | CTRL_KEY,	{"\x1B\x03\x2C\xff"}},  /* , */
	{0xBD	 | VIRTUAL_KEY | CTRL_KEY,	{"\x1B\x03\x2D\xff"}},  /* - */
	{0xBE	 | VIRTUAL_KEY | CTRL_KEY,	{"\x1B\x03\x2E\xff"}},  /* . */
	{0xBF	 | VIRTUAL_KEY | CTRL_KEY,	{"\x1B\x03\x2F\xff"}},  /* / */
	{0x30	 | VIRTUAL_KEY | CTRL_KEY,	{"\x1B\x03\x30\xff"}},  /* 0 */
	{0x31	 | VIRTUAL_KEY | CTRL_KEY,	{"\x1B\x03\x31\xff"}},  /* 1 */
	{0x32	 | VIRTUAL_KEY | CTRL_KEY,	{"\x1B\x03\x32\xff"}},  /* 2 */
	{0x33	 | VIRTUAL_KEY | CTRL_KEY,	{"\x1B\x03\x33\xff"}},  /* 3 */
	{0x34	 | VIRTUAL_KEY | CTRL_KEY,	{"\x1B\x03\x34\xff"}},  /* 4 */
	{0x35	 | VIRTUAL_KEY | CTRL_KEY,	{"\x1B\x03\x35\xff"}},  /* 5 */
	{0x36	 | VIRTUAL_KEY | CTRL_KEY,	{"\x1B\x03\x36\xff"}},  /* 6 */
	{0x37	 | VIRTUAL_KEY | CTRL_KEY,	{"\x1B\x03\x37\xff"}},  /* 7 */
	{0x38	 | VIRTUAL_KEY | CTRL_KEY,	{"\x1B\x03\x38\xff"}},  /* 8 */
	{0x39	 | VIRTUAL_KEY | CTRL_KEY,	{"\x1B\x03\x39\xff"}},  /* 9 */
	{0xBA	 | VIRTUAL_KEY | CTRL_KEY,	{"\x1B\x03\x3B\xff"}},  /* ; */
	{0xBB	 | VIRTUAL_KEY | CTRL_KEY,	{"\x1B\x03\x3D\xff"}},  /* = */
	{0xC0	 | VIRTUAL_KEY | CTRL_KEY,	{"\x1B\x03\x60\xff"}},  /* ` */

	// Ctrl Alt keys
	{0xB0	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x03\x1B\x01\x20\xff"}},  /* space */
	{0xB7	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x03\x1B\x01\x27\xff"}},  /* ' */
	{0xBC	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x03\x1B\x01\x2C\xff"}},  /* , */
	{0xBD	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x03\x1B\x01\x2D\xff"}},  /* - */
	{0xBE	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x03\x1B\x01\x2E\xff"}},  /* . */
	{0xBF	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x03\x1B\x01\x2F\xff"}},  /* / */
	{0x30	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x03\x1B\x01\x30\xff"}},  /* 0 */
	{0x31	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x03\x1B\x01\x31\xff"}},  /* 1 */
	{0x32	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x03\x1B\x01\x32\xff"}},  /* 2 */
	{0x33	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x03\x1B\x01\x33\xff"}},  /* 3 */
	{0x34	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x03\x1B\x01\x34\xff"}},  /* 4 */
	{0x35	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x03\x1B\x01\x35\xff"}},  /* 5 */
	{0x36	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x03\x1B\x01\x36\xff"}},  /* 6 */
	{0x37	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x03\x1B\x01\x37\xff"}},  /* 7 */
	{0x38	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x03\x1B\x01\x38\xff"}},  /* 8 */
	{0x39	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x03\x1B\x01\x39\xff"}},  /* 9 */
	{0xBA	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x03\x1B\x01\x3B\xff"}},  /* ; */
	{0xBB	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x03\x1B\x01\x3D\xff"}},  /* = */
	{0x41	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x01\xff"}},  /* A */
	{0x42	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x02\xff"}},  /* B */
	{0x43	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x03\xff"}},  /* C */
	{0x44	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x04\xff"}},  /* D */
	{0x45	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x05\xff"}},  /* E */
	{0x46	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x06\xff"}},  /* F */
	{0x47	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x07\xff"}},  /* G */
	{0x48	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x08\xff"}},  /* H */
	{0x49	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x09\xff"}},  /* I */
	{0x4A	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x0A\xff"}},  /* J */
	{0x4B	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x0B\xff"}},  /* K */
	{0x4C	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x0C\xff"}},  /* L */
	{0x4D	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x0D\xff"}},  /* M */
	{0x4E	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x0E\xff"}},  /* N */
	{0x4F	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x0F\xff"}},  /* O */
	{0x50	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x10\xff"}},  /* P */
	{0x51	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x11\xff"}},  /* Q */
	{0x52	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x12\xff"}},  /* R */
	{0x53	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x13\xff"}},  /* S */
	{0x54	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x14\xff"}},  /* T */
	{0x55	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x15\xff"}},  /* U */
	{0x56	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x16\xff"}},  /* V */
	{0x57	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x17\xff"}},  /* W */
	{0x58	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x18\xff"}},  /* X */
	{0x59	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x19\xff"}},  /* Y */
	{0x5A	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x1A\xff"}},  /* Z */
	{0xDB	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x1B\xff"}},  /* [ */
	{0xDC	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x1C\xff"}},  /* \ */
	{0xDD	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x01\x1D\xff"}},  /* ] */
	{0xC0	 | VIRTUAL_KEY | ALT_KEY | CTRL_KEY,	{"\x1B\x03\x1B\x01\x10\xff"}},  /* ` */

	// Shift Ctrl keys
	{0x20	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x1B\x13\x1B\x03\x20\xff"}},  /* space */
	{0x31	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x1B\x03\x21\xff"}},  /* ! */
	{0xDE	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x1B\x03\x22\xff"}},  /* " */
	{0x33	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x1B\x03\x23\xff"}},  /* # */
	{0x34	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x1B\x03\x24\xff"}},  /* $ */
	{0x35	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x1B\x03\x25\xff"}},  /* % */
	{0x37	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x1B\x03\x26\xff"}},  /* & */
	{0x39	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x1B\x03\x28\xff"}},  /* ( */
	{0x30	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x1B\x03\x29\xff"}},  /* ) */
	{0x38	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x1B\x03\x2A\xff"}},  /* * */
	{0xBB	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x1B\x03\x2B\xff"}},  /* + */
	{0xBA	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x1B\x03\x3A\xff"}},  /* : */
	{0xBC	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x1B\x03\x3C\xff"}},  /* < */
	{0xBE	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x1B\x03\x3E\xff"}},  /* > */
	{0xBF	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x1B\x03\x3F\xff"}},  /* ? */
	{0xDB	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x1B\x03\x7B\xff"}},  /* { */
	{0xDC	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x1B\x03\x7C\xff"}},  /* | */
	{0xDD	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x1B\x03\x7D\xff"}},  /* } */
	{0xC0	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY,	{"\x1B\x03\x7E\xff"}},  /* ~ */

	// Shift Alt keys
	{0x20				   | SHIFT_KEY | ALT_KEY,	{"\x1B\x13\x1B\x01\x20\xff"}},  /* space */
	{0x41	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x41\xff"}},  /* A */
	{0x42	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x42\xff"}},  /* B */
	{0x43	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x43\xff"}},  /* C */
	{0x44	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x44\xff"}},  /* D */
	{0x45	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x45\xff"}},  /* E */
	{0x46	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x46\xff"}},  /* F */
	{0x47	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x47\xff"}},  /* G */
	{0x48	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x48\xff"}},  /* H */
	{0x49	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x49\xff"}},  /* I */
	{0x4A	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x4A\xff"}},  /* J */
	{0x4B	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x4B\xff"}},  /* K */
	{0x4C	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x4C\xff"}},  /* L */
	{0x4D	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x4D\xff"}},  /* M */
	{0x4E	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x4E\xff"}},  /* N */
	{0x4F	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x4F\xff"}},  /* O */
	{0x50	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x50\xff"}},  /* P */
	{0x51	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x51\xff"}},  /* Q */
	{0x52	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x52\xff"}},  /* R */
	{0x53	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x53\xff"}},  /* S */
	{0x54	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x54\xff"}},  /* T */
	{0x55	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x55\xff"}},  /* U */
	{0x56	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x56\xff"}},  /* V */
	{0x57	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x57\xff"}},  /* W */
	{0x58	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x58\xff"}},  /* X */
	{0x59	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x59\xff"}},  /* Y */
	{0x5A	 | VIRTUAL_KEY | SHIFT_KEY | ALT_KEY,	{"\x1B\x01\x5A\xff"}},  /* Z */

	// Shift Ctrl Alt keys
	{0x20	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x13\x1B\x03\x1B\x01\x20\xff"}},  /* space */
	{0x31	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x03\x1B\x01\x21\xff"}},  /* ! */
	{0xDE	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x03\x1B\x01\x22\xff"}},  /* " */
	{0x33	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x03\x1B\x01\x23\xff"}},  /* # */
	{0x34	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x03\x1B\x01\x24\xff"}},  /* $ */
	{0x35	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x03\x1B\x01\x25\xff"}},  /* % */
	{0x37	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x03\x1B\x01\x26\xff"}},  /* & */
	{0x39	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x03\x1B\x01\x28\xff"}},  /* ( */
	{0x30	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x03\x1B\x01\x29\xff"}},  /* ) */
	{0x38	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x03\x1B\x01\x2A\xff"}},  /* * */
	{0xBB	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x03\x1B\x01\x2B\xff"}},  /* + */
	{0xBA	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x03\x1B\x01\x3A\xff"}},  /* : */
	{0xBC	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x03\x1B\x01\x3C\xff"}},  /* < */
	{0xBE	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x03\x1B\x01\x3E\xff"}},  /* > */
	{0xBF	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x03\x1B\x01\x3F\xff"}},  /* ? */
	{0x40	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x00\xff"}},  /* @ */
	{0x41	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x01\xff"}},  /* A */
	{0x42	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x02\xff"}},  /* B */
	{0x43	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x03\xff"}},  /* C */
	{0x44	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x04\xff"}},  /* D */
	{0x45	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x05\xff"}},  /* E */
	{0x46	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x06\xff"}},  /* F */
	{0x47	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x07\xff"}},  /* G */
	{0x48	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x08\xff"}},  /* H */
	{0x49	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x09\xff"}},  /* I */
	{0x4A	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x0A\xff"}},  /* J */
	{0x4B	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x0B\xff"}},  /* K */
	{0x4C	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x0C\xff"}},  /* L */
	{0x4D	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x0D\xff"}},  /* M */
	{0x4E	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x0E\xff"}},  /* N */
	{0x4F	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x0F\xff"}},  /* O */
	{0x50	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x10\xff"}},  /* P */
	{0x51	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x11\xff"}},  /* Q */
	{0x52	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x12\xff"}},  /* R */
	{0x53	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x13\xff"}},  /* S */
	{0x54	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x14\xff"}},  /* T */
	{0x55	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x15\xff"}},  /* U */
	{0x56	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x16\xff"}},  /* V */
	{0x57	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x17\xff"}},  /* W */
	{0x58	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x18\xff"}},  /* X */
	{0x59	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x19\xff"}},  /* Y */
	{0x5A	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x1A\xff"}},  /* Z */
	{0x5B	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x1B\xff"}},  /* [ */
	{0x5C	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x1C\xff"}},  /* \ */
	{0x5D	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x1D\xff"}},  /* ] */
	{0x5E	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x1E\xff"}},  /* ^ */
	{0x5F	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x01\x1F\xff"}},  /* _ */
	{0xDB	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x13\x1B\x03\x1B\x01\x7B\xff"}},  /* { */
	{0xDC	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x13\x1B\x03\x1B\x01\x7C\xff"}},  /* | */
	{0xDD	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x13\x1B\x03\x1B\x01\x7D\xff"}},  /* } */
	{0xC0	 | VIRTUAL_KEY | SHIFT_KEY | CTRL_KEY | ALT_KEY,	{"\x1B\x13\x1B\x03\x1B\x01\x7E\xff"}},  /* ~ */
	};

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vtutf8_init
 *
 * DESCRIPTION:
 *	 Initializes the VT-UTF8 emulator.
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *	 nothing
 */
void vtutf8_init(const HHEMU hhEmu)
	{
	PSTDECPRIVATE pstPRI;
	int iRow;
	char *pszLocale = NULL;
	UINT uiOEMCP = 0;
	TCHAR str[20];

	static struct trans_entry const vtutf8_tbl[] =
		{
		{NEW_STATE, 0, 0, 0}, // State 0
		{0, ETEXT('\x20'),	ETEXT('\x7E'),	emuDecGraphic}, 	// Space - ~
		{9, ETEXT('\x80'),	0xFFFF,			vtUTF8FirstDataByte}, // 80h - FFh
		{1, ETEXT('\x1B'),	ETEXT('\x1B'),	nothing},			// Esc
		{0, ETEXT('\x05'),	ETEXT('\x05'),	vt100_answerback},	// Ctrl-E
		{0, ETEXT('\x07'),	ETEXT('\x07'),	emu_bell},			// Ctrl-G
		{0, ETEXT('\x08'),	ETEXT('\x08'),	vt_backspace},		// BackSpace
		{0, ETEXT('\x09'),	ETEXT('\x09'),	emuDecTab}, 		// Tab
		{0, ETEXT('\x0A'),	ETEXT('\x0C'),	emuLineFeed},		// NL - FF
		{0, ETEXT('\x0D'),	ETEXT('\x0D'),	carriagereturn},	// CR
		{0, ETEXT('\x0E'),	ETEXT('\x0F'),	vt_charshift},		// Ctrl-N
		{7, ETEXT('\x18'),	ETEXT('\x18'),	EmuStdChkZmdm}, 	// Ctrl-X

		{NEW_STATE, 0, 0, 0}, // State 1						// Esc
		{2, ETEXT('\x5B'),	ETEXT('\x5B'),	ANSI_Pn_Clr},		// [
		{3, ETEXT('\x23'),	ETEXT('\x23'),	nothing},			// #
		{4, ETEXT('\x28'),	ETEXT('\x29'),	vt_scs1},			// ( - )
		{0, ETEXT('\x37'),	ETEXT('\x38'),	vt100_savecursor},	// 7 - 8
		{1, ETEXT('\x3B'),	ETEXT('\x3B'),	ANSI_Pn_End},		// ;
		{0, ETEXT('\x3D'),	ETEXT('\x3E'),	vt_alt_kpmode}, 	// = - >
		{0, ETEXT('\x44'),	ETEXT('\x44'),	emuDecIND}, 		// D
		{0, ETEXT('\x45'),	ETEXT('\x45'),	ANSI_NEL},			// E
		{0, ETEXT('\x48'),	ETEXT('\x48'),	ANSI_HTS},			// H
		{0, ETEXT('\x48'),	ETEXT('\x48'),	DEC_HHC},           // H
		{0, ETEXT('\x4D'),	ETEXT('\x4D'),	emuDecRI},			// M
        {8, ETEXT('\x52'),  ETEXT('\x52'),  nothing},           // R
		{0, ETEXT('\x5A'),	ETEXT('\x5A'),	ANSI_DA},			// Z
		{0, ETEXT('\x63'),	ETEXT('\x63'),	vt100_hostreset},	// c

		{NEW_STATE, 0, 0, 0}, // State 2						// Esc[
		{2, ETEXT('\x3B'),	ETEXT('\x3B'),	ANSI_Pn_End},		// ;
		{2, ETEXT('\x30'),	ETEXT('\x3F'),	ANSI_Pn},			// 0 - ?
		{5, ETEXT('\x22'),	ETEXT('\x22'),	nothing},			// "
		{0, ETEXT('\x41'),	ETEXT('\x41'),	emuDecCUU}, 		// A
		{0, ETEXT('\x42'),	ETEXT('\x42'),	emuDecCUD}, 		// B
		{0, ETEXT('\x43'),	ETEXT('\x43'),	emuDecCUF}, 		// C
		{0, ETEXT('\x44'),	ETEXT('\x44'),	emuDecCUB}, 		// D
		{0, ETEXT('\x48'),	ETEXT('\x48'),	emuDecCUP}, 		// H
		{0, ETEXT('\x4A'),	ETEXT('\x4A'),	emuDecED},			// J
		{0, ETEXT('\x4B'),	ETEXT('\x4B'),	ANSI_EL},			// K
		{0, ETEXT('\x4C'),	ETEXT('\x4C'),	vt_IL}, 			// L
		{0, ETEXT('\x4D'),	ETEXT('\x4D'),	vt_DL}, 			// M
		{0, ETEXT('\x50'),	ETEXT('\x50'),	vt_DCH},			// P
        {0, ETEXT('\x5A'),  ETEXT('\x5A'),  ANSI_CBT},          // Z (Back tab (CBT))
		{0, ETEXT('\x63'),	ETEXT('\x63'),	ANSI_DA},			// c
		{0, ETEXT('\x66'),	ETEXT('\x66'),	emuDecCUP}, 		// f
		{0, ETEXT('\x67'),	ETEXT('\x67'),	ANSI_TBC},			// g
		{0, ETEXT('\x68'),	ETEXT('\x68'),	ANSI_SM},			// h
		{0, ETEXT('\x69'),	ETEXT('\x69'),	vt100PrintCommands},// i
		{0, ETEXT('\x6C'),	ETEXT('\x6C'),	ANSI_RM},			// l
		{0, ETEXT('\x6D'),	ETEXT('\x6D'),	ANSI_SGR},			// m
		{0, ETEXT('\x6E'),	ETEXT('\x6E'),	ANSI_DSR},			// n
		{0, ETEXT('\x71'),	ETEXT('\x71'),	nothing},			// q
		{0, ETEXT('\x72'),	ETEXT('\x72'),	vt_scrollrgn},		// r
		{0, ETEXT('\x78'),	ETEXT('\x78'),	vt100_report},		// x

		{NEW_STATE, 0, 0, 0}, // State 3						// Esc#
		{0, ETEXT('\x33'),	ETEXT('\x36'),	emuSetDoubleAttr},	// 3 - 6

		{0, ETEXT('\x38'),	ETEXT('\x38'),	vt_screen_adjust},	// 8

		{NEW_STATE, 0, 0, 0}, // State 4						// Esc ( - )
		{0, ETEXT('\x01'),	ETEXT('\xFF'),	vt_scs2},			// All

		{NEW_STATE, 0, 0, 0}, // State 5						// Esc["
		{0, ETEXT('\x70'),	ETEXT('\x70'),	nothing},			// p

		{NEW_STATE, 0, 0, 0}, // State 6						// Printer control
		{6, ETEXT('\x00'),	ETEXT('\xFF'),	vt100_prnc},		// All

		{NEW_STATE, 0, 0, 0}, // State 7						// Ctrl-X
		{7, ETEXT('\x00'),	ETEXT('\xFF'),	EmuStdChkZmdm}, 	// All

		{NEW_STATE, 0, 0, 0}, // State 8						// 80h - FFh
        {9, ETEXT('\x00'),  0xFFFF,  vtUTF8MiddleDataByte},		// all data

		{NEW_STATE, 0, 0, 0}, // State 9						// 80h - FFh
        {0, ETEXT('\x00'),  0xFFFF,  vtUTF8LastDataByte},		// all data

        };

	emuInstallStateTable(hhEmu, vtutf8_tbl, DIM(vtutf8_tbl));

	// Allocate space for and initialize data that is used only by the
	// VT100 emulator.
	//
	hhEmu->pvPrivate = malloc(sizeof(DECPRIVATE));

	if (hhEmu->pvPrivate == 0)
		{
		assert(FALSE);
		return;
		}

	pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	memset(pstPRI, 0, sizeof(DECPRIVATE));

	// Allocate an array to hold line attribute values.
	//
	pstPRI->aiLineAttr = malloc(MAX_EMUROWS * sizeof(int) );

	if (pstPRI->aiLineAttr == 0)
		{
		assert(FALSE);
		return;
		}

	for (iRow = 0; iRow < MAX_EMUROWS; iRow++)
		pstPRI->aiLineAttr[iRow] = NO_LINE_ATTR;

	pstPRI->sv_row			= 0;
	pstPRI->sv_col			= 0;
	pstPRI->gn				= 0;
	pstPRI->sv_AWM			= RESET;
	pstPRI->sv_DECOM		= RESET;
	pstPRI->sv_protectmode	= FALSE;
	pstPRI->fAttrsSaved 	= FALSE;
	pstPRI->pntr			= pstPRI->storage;

	// Initialize hhEmu values for VT100.
	//
	hhEmu->emu_kbdin		= vtUTF8_kbdin;
	hhEmu->emuResetTerminal = vt100_reset;
	hhEmu->emu_setcurpos	= emuDecSetCurPos;
	hhEmu->emu_deinstall	= emuVTUTF8Unload;
	hhEmu->emu_clearscreen	= emuDecClearScreen;

	hhEmu->emu_highchar 	= 0xFFFF;
	hhEmu->emu_maxrow       = 25;                   // 25 line emulator
	hhEmu->emu_maxcol		= 80;                   // 80 column emulator
	hhEmu->mode_vt220		= FALSE;
	hhEmu->bottom_margin    = hhEmu->emu_maxrow;    // this has to equal emu_maxrow which changed

	std_dsptbl(hhEmu, TRUE);
	vt_charset_init(hhEmu);

	emuKeyTableLoad(hhEmu, VTUTF8KeyTable, 
					 sizeof(VTUTF8KeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl);

	emuKeyTableLoad(hhEmu, VTUTF8_Keypad_KeyTable, 
					 sizeof(VTUTF8_Keypad_KeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl2);

	emuKeyTableLoad(hhEmu, VTUTF8_Cursor_KeyTable, 
					 sizeof(VTUTF8_Cursor_KeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl3);

	emuKeyTableLoad(hhEmu, VTUTF8ModifiedKeyTable, 
					 sizeof(VTUTF8ModifiedKeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl4);

	emuKeyTableLoad(hhEmu, VTUTF8ModifiedAlhpaKeyTable, 
					 sizeof(VTUTF8ModifiedAlhpaKeyTable)/sizeof(KEYTBLSTORAGE), 
					 &hhEmu->stEmuKeyTbl5);

	// This is needed to set the locale to the default defined by the regional
	// controls on the control panel. Without it, the locale is "C" and the 
	// wctomb() conversion would not work. (See the setlocale documentation for
	// more details.) rde 26 Sep 01
	sprintf((char *)(&str[0]), ".%d", GetOEMCP());
	pszLocale = setlocale(LC_ALL, str);

	// This was the first attempt which partially worked.
	//pszLocale = setlocale(LC_ALL, "");
	DbgOutStr("vtUTF8 locale=%s\r\n", pszLocale, 0,0,0,0);

	backscrlSetShowFlag(sessQueryBackscrlHdl(hhEmu->hSession), TRUE);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * emuVTUTF8Unload
 *
 * DESCRIPTION:
 *	 Unloads current emulator by freeing used memory.
 *
 * ARGUMENTS:
 *	 none
 *
 * RETURNS:
 *	 nothing
 */
void emuVTUTF8Unload(const HHEMU hhEmu)
	{
	PSTDECPRIVATE pstPRI = (PSTDECPRIVATE)hhEmu->pvPrivate;

	assert(hhEmu);

	if (pstPRI)
		{
		if (pstPRI->aiLineAttr)
			{
			free(pstPRI->aiLineAttr);
			pstPRI->aiLineAttr = 0;
			}

		free(hhEmu->pvPrivate);
		hhEmu->pvPrivate = 0;
		}

    //
    // Make sure to free the key tables that were created when the emulator
    // was loaded, otherwise there is a memory leak. REV: 05/09/2001
    //
	emuKeyTableFree(&hhEmu->stEmuKeyTbl);
	emuKeyTableFree(&hhEmu->stEmuKeyTbl2);
	emuKeyTableFree(&hhEmu->stEmuKeyTbl3);
	emuKeyTableFree(&hhEmu->stEmuKeyTbl4);
	emuKeyTableFree(&hhEmu->stEmuKeyTbl5);

	return;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vtUTF8_kbdin
 *
 * DESCRIPTION:
 *	Processes local keyboard keys for the VT-UTF8 emulator.
 *	Note: The only reason for a separate VT-UTF8 kbd function is to be
 *	able to convert key codes >= 80h (Alt-number pad keys) to UTF8 format.
 *	20 Jul 2001 rde
 *
 * ARGUMENTS:
 *  hhEmu - Private emulator handle.
 *  kcode - The key to examine.
 *  fTest - TRUE if we only want to test the key.
 *
 * RETURNS:
 *  0 if we can process the key, -1 otherwise.
 *
 * AUTHOR:	Bob Everett - 20 Jul 2001 
 */
int vtUTF8_kbdin(const HHEMU hhEmu, int key, const int fTest)
	{
	int index = 0;

//    DbgOutStr("vtUTF8_kbdin fTest=%d, key=%8x\r\n", fTest, key, 0, 0, 0);

	/* -------------- Check Backspace & Delete keys ------------- */

	if (hhEmu->stUserSettings.fReverseDelBk && ((key == VK_BACKSPACE) ||
			(key == DELETE_KEY) || (key == DELETE_KEY_EXT)))
		{
		key = (key == VK_BACKSPACE) ? DELETE_KEY : VK_BACKSPACE;
		}

	/* -------------- Cursor Key Mode ------------- */

	else if (hhEmu->mode_DECCKM == SET &&
			(index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl3)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl3);
		}

	/* -------------- Keypad Application Mode ------------- */

	else if (hhEmu->mode_DECKPAM &&
			(index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl2)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl2);
		}

	/* -------------- Normal keys ------------- */

	else if ((index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl);
		}

	/* -------------- Modified (Alt, etc.) Non-alpha keys ------------- */

	else if ((index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl4)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl4);
		}

	/* -------------- Modified (Alt, etc.) Alphanumeric keys ------------- */

	else if ((index = emuKbdKeyLookup(hhEmu, key, &hhEmu->stEmuKeyTbl5)) != -1)
		{
		if (!fTest)
			emuSendKeyString(hhEmu, index, &hhEmu->stEmuKeyTbl5);
		}

	else
		{
		static const int KeyBreak    = VK_CANCEL|VIRTUAL_KEY|CTRL_KEY;
		static const int KeyExtBreak = VK_CANCEL|VIRTUAL_KEY|CTRL_KEY|EXTENDED_KEY;
		static const int KeyBreakNT	 = VK_CANCEL|EXTENDED_KEY;
		static const int KeyAltBreak = VK_PAUSE |VIRTUAL_KEY|ALT_KEY;
	
		ECHAR            eChar;
	    HCLOOP           hCloop = sessQueryCLoopHdl(hhEmu->hSession);

	    if (fTest)
			{
	        // The backspace key is a special case. We must convert it to
	        // whatever the user has specified in the "Settings" properties
	        // page. So, if we are testing for backspace, return 0. This
	        // ensures that we get called again with fTest set to FALSE. When
	        // this happens we will process the key. - cab:11/18/96
	        //
			if (key == VK_BACKSPACE)
	            {
#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
				index = 0;
#else
				index = -1;
#endif
		         }
		    // We also process the break key.
	        //
		    else if (key == KeyBreak || key == KeyExtBreak || 
					key == KeyAltBreak || key == KeyBreakNT)
		        {
				index = 0;
		        }
		    else
		        {
				index = -1;
		        }
		    }
		else
			{
			// Process the backspace key according to the user setting
			// in the "Settings" properties page. - cab:11/18/96
			//
			if (key == VK_BACKSPACE)
				{
#ifdef INCL_USER_DEFINED_BACKSPACE_AND_TELNET_TERMINAL_ID
				switch(hhEmu->stUserSettings.nBackspaceKeys)
					{
				case EMU_BKSPKEYS_CTRLH:
					CLoopCharOut(hCloop, TEXT('\x08'));
					break;
	
				case EMU_BKSPKEYS_DEL:
					CLoopCharOut(hCloop, TEXT('\x7F'));
					break;
	
				case EMU_BKSPKEYS_CTRLHSPACE:
					CLoopCharOut(hCloop, TEXT('\x08'));
					CLoopCharOut(hCloop, TEXT('\x20'));
					CLoopCharOut(hCloop, TEXT('\x08'));
					break;

				default:
					assert(0);
					break;
					}
#endif
				index = -1;
				}

			// Process the break key.
			//
			else if (key == KeyBreak || key == KeyExtBreak || key == KeyBreakNT)
				{
				ComDriverSpecial(sessQueryComHdl(hhEmu->hSession), "Send Break", NULL, 0);
				index = -1;
				}
			else if (key == KeyAltBreak)
				{
				ComDriverSpecial(sessQueryComHdl(hhEmu->hSession), "Send IP", NULL, 0);
				index = -1;
				}

			// Processing for the enter key
			//
			else if (key == (VK_RETURN | VIRTUAL_KEY))
				{
				CLoopCharOut(hCloop, TEXT('\x0D'));
				index = -1;
				}

			// processing for the for the escape key
			//
			else if (key == (VK_ESCAPE | VIRTUAL_KEY))
				{
				CLoopCharOut(hCloop, TEXT('\x1B'));
				index = -1;
				}

			// processing for the for the tab key
			//
			else if (key == (VK_TAB | VIRTUAL_KEY))
				{
				CLoopCharOut(hCloop, TEXT('\x09'));
				index = -1;
				}

			// Throw away any other virtual keys.
			//
			else if (key & VIRTUAL_KEY)
				{
				index = -1;
				}
            
            //
            // Note: A 'Text Send' file transfer sends all its data through
			// this kbd routine.
            //
            // Note: Maybe we also need to see if this character is a DBCS 
			// character and send both bytes if it is. REV 25 Jul 2001
            //

			else
				{
				// Send any other characters out the port.
				//    
				if ((unsigned)key <= 0x007F)
					{
					// No UTF8 conversion is needed.
					eChar = (ECHAR)key;
					CLoopCharOut(hCloop, (UCHAR)(eChar & 0x00FF));
					}	
				else if ((unsigned)key <=0x07FF)
					{
					// I think only Alt-numberpad keys can fall in this range.
					eChar = (ECHAR)(UTF8_1ST_OF_2_BYTES_CODE | ((key & UTF8_2_BYTES_HIGHEST_5_BITS) >> 6));
					CLoopCharOut(hCloop, (UCHAR)(eChar & 0x00FF));

					eChar = (ECHAR)(UTF8_2ND_OF_2_BYTES_CODE | (key & UTF8_2_BYTES_LOWEST_6_BITS));
					CLoopCharOut(hCloop, (UCHAR)(eChar & 0x00FF));
					}
				else
					{
					// I don't think any keys can fall in this range, but what the hey.
					eChar = (ECHAR)(UTF8_1ST_OF_3_BYTES_CODE | ((key & UTF8_3_BYTES_HIGHEST_4_BITS) >> 12));
					CLoopCharOut(hCloop, (UCHAR)(eChar & 0x00FF));

					eChar = (ECHAR)(UTF8_2ND_OF_3_BYTES_CODE | ((key & UTF8_3_BYTES_MIDDLE_6_BITS) >> 6));
					CLoopCharOut(hCloop, (UCHAR)(eChar & 0x00FF));

					eChar = (ECHAR)(UTF8_3RD_OF_3_BYTES_CODE | (key & UTF8_3_BYTES_LOWEST_6_BITS));
					CLoopCharOut(hCloop, (UCHAR)(eChar & 0x00FF));
					}

				index = -1;
				}
			}
		}

//	DbgOutStr("vtUTF8_kbdin return=%dd\r\n", index, 0, 0, 0, 0);

	return index;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vtUTF8FirstDataByte
 *
 * DESCRIPTION:
 *	Handles UTF8 data coming in from a remote computer.
 *
 * ARGUMENTS:
 *  hhEmu - Private emulator handle.
 *
 * RETURNS:
 *  Nothing
 *
 * AUTHOR:	Bob Everett - 20 Jul 2001 
 */
void vtUTF8FirstDataByte(const HHEMU hhEmu)
	{
	ECHAR echCode = (ECHAR)hhEmu->emu_code;
	ECHAR echUTF8Type = 0;
	ECHAR echUTF8Code = 0;
	BOOL f2Bytes = FALSE;

	if (echCode >= 0x0100)
		{
		// Sometimes the data comes in as 1 byte (0x00##) and sometimes as
		// 2 bytes (0x####). It appears to be random. In this case, it's 2 
		// bytes. Each byte must be processed separately.
		echCode = (ECHAR)(hhEmu->emu_code >> 8);
		f2Bytes = TRUE;
		}

	echUTF8Type = UTF8_TYPE_MASK & echCode;

	if (echUTF8Type == UTF8_1ST_OF_3_BYTES_CODE)
		{
		hhEmu->state = 8;
		echUTF8Code = ((echCode & FIRST_4_BITS) << 12);
		DbgOutStr("vtUTF8 byte 1 of 3: code=%4x, Code=%4x, UTF8Code=%4x\r\n", 
				hhEmu->emu_code, echCode, echUTF8Code, 0, 0);
		}
	else
		{
		echUTF8Code = ((echCode & FIRST_5_BITS) << 6);
		DbgOutStr("vtUTF8 byte 1 of 2: code=%4x, Code=%4x, UTF8Code=%4x, state=%d\r\n", 
				hhEmu->emu_code, echCode, echUTF8Code, hhEmu->state, 0);
		}

	((PSTDECPRIVATE)hhEmu->pvPrivate)->echUTF8CodeInProgress = echUTF8Code;

	if (f2Bytes)
		{
		// Process the 2nd byte.
		hhEmu->emu_code &= 0x00FF;
		if (echUTF8Type == UTF8_1ST_OF_3_BYTES_CODE)
			{
			vtUTF8MiddleDataByte(hhEmu);
			hhEmu->state = 9;
			}
		else
			{
			vtUTF8LastDataByte(hhEmu);
			hhEmu->state = 0;
			}
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vtUTF8MiddleDataByte
 *
 * DESCRIPTION:
 *	Handles UTF8 data coming in from a remote computer.
 *
 * ARGUMENTS:
 *  hhEmu - Private emulator handle.
 *
 * RETURNS:
 *  Nothing
 *
 * AUTHOR:	Bob Everett - 20 Jul 2001 
 */
void vtUTF8MiddleDataByte(const HHEMU hhEmu)
	{
	ECHAR echCode = (ECHAR)hhEmu->emu_code;
	ECHAR echUTF8Code = 0;
	BOOL f2Bytes = FALSE;

	if (echCode >= 0x0100)
		{
		// It's 2 bytes. Each byte must be processed separately.
		echCode = (ECHAR)(hhEmu->emu_code >> 8);
		f2Bytes = TRUE;
		}

	echUTF8Code = ((echCode & FIRST_6_BITS) << 6);

	((PSTDECPRIVATE)hhEmu->pvPrivate)->echUTF8CodeInProgress |= echUTF8Code;
	DbgOutStr("vtUTF8 byte 2 of 3: code=%4x, Code=%4x, UTF8Code=%4x, InProg=%4x\r\n", 
			hhEmu->emu_code, echCode, echUTF8Code, ((PSTDECPRIVATE)hhEmu->pvPrivate)->echUTF8CodeInProgress, 0);

	if (f2Bytes)
		{
		// Process the 2nd byte.
		hhEmu->emu_code &= 0x00FF;
		vtUTF8LastDataByte(hhEmu);
		hhEmu->state = 0;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * vtUTF8LastDataByte
 *
 * DESCRIPTION:
 *	Handles UTF8 data coming in from a remote computer.
 *
 * ARGUMENTS:
 *  hhEmu - Private emulator handle.
 *
 * RETURNS:
 *  Nothing
 *
 * AUTHOR:	Bob Everett - 20 Jul 2001 
 */
void vtUTF8LastDataByte(const HHEMU hhEmu)
	{
	ECHAR echCode = (ECHAR)hhEmu->emu_code;
	ECHAR echUTF8Code = 0;
	ECHAR echUniCode = 0;
	ECHAR echOriginalCode = (ECHAR)hhEmu->emu_code;
	BOOL f2Bytes = FALSE;
	int iRetval = 0;

	if (echCode >= 0x0100)
		{
		// It's 2 bytes. Each byte must be processed separately.
		echCode = (ECHAR)(hhEmu->emu_code >> 8);
		f2Bytes = TRUE;
		}

	echUTF8Code = ((echCode & FIRST_6_BITS));

	hhEmu->emu_code = ETEXT(((PSTDECPRIVATE)hhEmu->pvPrivate)->echUTF8CodeInProgress | echUTF8Code);
	DbgOutStr("vtUTF8 last byte: code=%4x, Code=%4x, UTF8Code=%4x, code=%4x\r\n", 
			echOriginalCode, echCode, echUTF8Code, hhEmu->emu_code, 0);

	// The incoming bytes are now converted to Unicode. To support Unicode, 
	// don't call wctomb() which converts Unicode to MBCS.

	iRetval = wctomb((char *)&echUniCode, hhEmu->emu_code);
	if (iRetval < 0)
		hhEmu->emu_code = '?';
	else if (iRetval < 2)
		{
		// Only 1 byte was returned. This may not be necessary, but clear
		// the higher order byte.
		hhEmu->emu_code = echUniCode & 0x00ff;
		}
	else
		{
		// For unknown reasons, wctomb returns the bytes in the reverse order
		// from what the codepage documents show and what HT needs to display 
		// properly. rde 26 Sep 01
		hhEmu->emu_code = ((echUniCode & 0x00ff) << 8) | ((echUniCode & 0xff00) >> 8);
		}
	DbgOutStr("vtUTF8 iRetval=%4x, Code=%4x, code=%4x\r\n", 
			iRetval, echUniCode, hhEmu->emu_code, 0,0);

	emuDecGraphic(hhEmu);

	if (f2Bytes)
		{
		// Process the 2nd byte.
		hhEmu->emu_code = echOriginalCode & 0x00FF;
#if defined(EXTENDED_FEATURES)
        (void)(*hhEmu->emu_datain)(hhEmu, hhEmu->emu_code);
#else
        (void)(*hhEmu->emu_datain)((HEMU)hhEmu, hhEmu->emu_code);
#endif
		}
	}

#endif // INCL_VTUTF8

    /* end of vtutf8ini.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\banner.c ===
/*      File: \wacker\tdll\banner.h (created 16-Mar-94)
 *
 *      Copyright 1996 by Hilgraeve, Inc -- Monroe, MI
 *      All rights reserved
 *
 *      $Revision: 14 $
 *      $Date: 4/16/02 2:36p $
 */
#include <windows.h>
#pragma hdrstop

#include <commctrl.h>
#include <term\res.h>

#include "globals.h"
#include "tdll.h"
#include "stdtyp.h"
#include "assert.h"
#include "file_msc.h"
#include "errorbox.h"
#include "banner.h"
#include "misc.h"
#include "upgrddlg.h"

#include "stdtyp.h"
#include <emu\emu.h>
#include "term.hh" // This must be after emu.h

LRESULT CALLBACK BannerProc(HWND, UINT, WPARAM, LPARAM);
STATIC_FUNC void banner_WM_PAINT(HWND hwnd);
STATIC_FUNC void banner_WM_CREATE(HWND hwnd, LPCREATESTRUCT lpstCreate);

#define IDC_PB_UPGRADEINFO      101

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:    bannerRegisterClass
 *
 * DESCRIPTION:
 *      This function registers the window class for the banner window.
 *
 * ARGUEMENTS:
 *      The task instance handle.
 *
 * RETURNS:
 * The usual TRUE/FALSE from a registration function.
 *
 */
BOOL bannerRegisterClass(HANDLE hInstance)
	{
	ATOM bRet = TRUE;
	WNDCLASSEX wnd;

	memset(&wnd, 0, sizeof(WNDCLASSEX));
	wnd.cbSize = sizeof(WNDCLASSEX);

	if (GetClassInfoEx(hInstance, BANNER_DISPLAY_CLASS, &wnd) == FALSE)
		{
		wnd.style               = CS_HREDRAW | CS_VREDRAW;
		wnd.lpfnWndProc         = BannerProc;
		wnd.cbClsExtra          = 0;
		wnd.cbWndExtra          = sizeof(HANDLE);
		wnd.hInstance           = hInstance;
		wnd.hIcon               = extLoadIcon(MAKEINTRESOURCE(IDI_HYPERTERMINAL));
		wnd.hCursor             = LoadCursor(NULL, IDC_ARROW);
		wnd.hbrBackground       = (HBRUSH)(COLOR_WINDOW+1);
		wnd.lpszMenuName        = NULL;
		wnd.lpszClassName       = BANNER_DISPLAY_CLASS;
		wnd.hIconSm             = extLoadIcon(MAKEINTRESOURCE(IDI_HYPERTERMINAL));

		bRet = RegisterClassEx(&wnd);
		}

	return bRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:    bannerCreateBanner
 *
 * DESCRIPTION:
 *      This function is called to creat the banner window.  The banner window is
 *      a short lived window that the program can run without.
 *
 * ARGUEMENTS:
 *      The task instance handle.
 *
 * RETURNS:
 *      The handle of the banner window.
 *
 */
HWND bannerCreateBanner(HANDLE hInstance, LPTSTR pszTitle)
	{
	HWND hwndBanner = NULL;
	hwndBanner = CreateWindow(BANNER_DISPLAY_CLASS,
							pszTitle,
							BANNER_WINDOW_STYLE,
							0,
							0,
							100,
							100,
							NULL,
							NULL,
							hInstance,
							NULL);
	return hwndBanner;
	}

#define BANNER_FILE     1

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:    BannerProc
 *
 * DESCRIPTION:
 *      This is the window procedure for the initial banner window.
 *
 * ARGUEMENTS:
 *      The usual stuff that a window proc gets.
 *
 * RETURNS:
 *      All sorts of different stuff.
 *
 */
LRESULT CALLBACK BannerProc(HWND hwnd, UINT wMsg, WPARAM wPar, LPARAM lPar)
	{
	HBITMAP        hBitmap = (HBITMAP)0;
	HWND           hwndParent;
#ifdef USE_PRIVATE_EDITION_3_BANNER
    HWND           hwndButton = 0;
#endif
	LPCREATESTRUCT lpstCreate = (LPCREATESTRUCT)lPar;

	hwndParent = 0;

	switch (wMsg)
		{
	case WM_CREATE:
		banner_WM_CREATE(hwnd, lpstCreate);
		break;

	case WM_PAINT:
		banner_WM_PAINT(hwnd);
		break;

#ifdef USE_PRIVATE_EDITION_3_BANNER
    case WM_SETFOCUS:
	// When we are displaying the "Upgrade" button, it is the only
	// control in the banner. So we always want to have the focus
	// on it. - cab:12/02/96
	//
	hwndButton = GetDlgItem(hwnd, IDC_PB_UPGRADEINFO);
	assert(hwndButton);
	SetFocus(hwndButton);
	break;

    case WM_COMMAND:
	switch(wPar)
	    {
	case IDC_PB_UPGRADEINFO:
	    DoUpgradeDialog(hwnd);
	    break;

	default:
	    break;
	    }
	break;
#endif

	case WM_CHAR:
	case WM_KEYDOWN:
	case WM_KILLFOCUS:
	case WM_LBUTTONDOWN:
		hwndParent = (HWND)GetWindowLongPtr(hwnd, GWLP_USERDATA);
		if (hwndParent)
			SendMessage(hwnd, WM_CLOSE, 0, 0);
		break;

	case WM_DESTROY:
		hBitmap = (HBITMAP)GetWindowLongPtr(hwnd, 0);
		hwndParent = (HWND)GetWindowLongPtr(hwnd, GWLP_USERDATA);

		if (hBitmap != (HBITMAP)0)
			DeleteObject(hBitmap);

		if (hwndParent)
			SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)0L);

		break;

	default:
		return DefWindowProc(hwnd, wMsg, wPar, lPar);
		}

	return 0L;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: utilDrawBitmap
 *
 * DESCRIPTION:
 *      This function draws a bitmap in a window.
 *
 * ARGUMENTS:
 *      hWnd    -- handle of the window to draw in
 *      hBitmap -- bitmap to be drawn
 *      xStart  -- starting coordinate
 *      yStart  -- starting coordinate
 *
 * RETURNS:
 *
 */
VOID FAR PASCAL utilDrawBitmap(HWND hWnd, HDC hDC, HBITMAP hBitmap,
							   SHORT xStart, SHORT yStart)
  {
  BITMAP        bm;
  HDC           hdcMem;
  POINT         ptSize, ptOrg;

  if (hWnd && !hDC)
	  hDC = GetDC(hWnd);

  hdcMem = CreateCompatibleDC(hDC);
  SelectObject(hdcMem, hBitmap);
  SetMapMode(hdcMem, GetMapMode(hDC));

  GetObject(hBitmap, sizeof(BITMAP), (LPTSTR)&bm);

  // Convert device coordintes into logical coordinates.
  //
  ptSize.x = bm.bmWidth;
  ptSize.y = bm.bmHeight;
  DPtoLP(hDC, &ptSize, 1);

  ptOrg.x = 0;
  ptOrg.y = 0;
  DPtoLP(hdcMem, &ptOrg, 1);

  BitBlt(hDC, xStart, yStart, ptSize.x, ptSize.y, hdcMem, ptOrg.x, ptOrg.y,
	SRCCOPY);

  DeleteDC(hdcMem);

  if (hWnd && !hDC)
	  ReleaseDC(hWnd, hDC);

  return;
  }

// TODO:cab,11/29/96 put this where it belongs
//
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *  fontSetWindowFont
 *
 * DESCRIPTION:
 *  Changes the font for the given window to the one specified.
 *
 * ARGUMENTS:
 *  hwnd        - Handle of the window.
 *  pszFontName - Name of the new font.
 *  iPointSize  - The new font's point size.
 *
 * RETURNS:
 *  0 if successful, -1 if error
 *
 * AUTHOR:  C. Baumgartner, 11/29/96
 */
int fontSetWindowFont(HWND hwnd, LPCTSTR pszFontName, int iPointSize)
    {
    int     iPixPerLogicalInch = 0;
    HDC     hDC = 0;
    HFONT   hFont = 0;
    LOGFONT lf; memset(&lf, 0, sizeof(LOGFONT));

    assert(hwnd);
    assert(pszFontName);

    // Get the pixels per logical inch in the y direction.
    //
    hDC = GetDC(hwnd);
    iPixPerLogicalInch = GetDeviceCaps(hDC, LOGPIXELSY);
    ReleaseDC(hwnd, hDC);

    // Compute the height of the font in logical units.
    // This is simply: (iPointSize * iPixPerLogicalInch) / 72,
    // don't ask me to derive that equation, I just got it from
    // Charles Petzold's book.
    //
    lf.lfHeight = -MulDiv(iPointSize, iPixPerLogicalInch, 72);

    // Set the font name.
    //
	//mpt:1-28-98 changed from strcpy so that it will handle dbcs font names
    lstrcpy(lf.lfFaceName, pszFontName);

    // Create the desired font.
    //
    hFont = CreateFontIndirect(&lf);
    if ( !hFont )
		{
		assert(hFont);
		return -1;
		}

    // Tell the window what it's new font is.
    //
    SendMessage(hwnd, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE,0));

    return 0;
    }


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
STATIC_FUNC void banner_WM_CREATE(HWND hwnd, LPCREATESTRUCT lpstCreate)
	{
	RECT    rc;
	HBITMAP hBitmap = (HBITMAP)0;
	BITMAP  bm;
	INT     x, y, cx, cy;
#ifdef USE_PRIVATE_EDITION_3_BANNER
	TCHAR   achUpgradeInfo[100];
	TCHAR  ach[80];
    INT     nSize1;
#endif
	DWORD ExStyle;

	ExStyle = (DWORD)GetWindowLongPtr(hwnd, GWL_EXSTYLE);

#if(WINVER >= 0x0500)
	//
	// [mhamid]: if it is mirrored then turn off mirroing.
	//
	if (ExStyle & WS_EX_LAYOUTRTL)
		{
		SetWindowLongPtr(hwnd, GWL_EXSTYLE, (LONG_PTR)(ExStyle & ~WS_EX_LAYOUTRTL));
		}
#endif // WINVER >= 0x0500

   if (lpstCreate->hwndParent)
      SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lpstCreate->hwndParent);

    //mpt:03-12-98 Changed the bitmap and avi to use system colors
	//hBitmap = LoadBitmap(glblQueryDllHinst(), MAKEINTRESOURCE(IDD_BM_BANNER));
	hBitmap = (HBITMAP)LoadImage(glblQueryDllHinst(),
				MAKEINTRESOURCE(IDD_BM_BANNER),
				IMAGE_BITMAP,
				0,
				0,
				LR_CREATEDIBSECTION | LR_LOADTRANSPARENT | LR_LOADMAP3DCOLORS);
	SetWindowLongPtr(hwnd, 0, (LONG_PTR)hBitmap);

	GetObject(hBitmap, sizeof(BITMAP), (LPTSTR)&bm);

	SetRect(&rc, 0, 0, bm.bmWidth, bm.bmHeight);
	AdjustWindowRect(&rc, BANNER_WINDOW_STYLE, FALSE);

	cx = rc.right - rc.left;
	cy = rc.bottom - rc.top;

	x = (GetSystemMetrics(SM_CXSCREEN) - cx) / 2;
	y = (GetSystemMetrics(SM_CYSCREEN) - cy) / 2;

	MoveWindow(hwnd, x, y, cx, cy, TRUE);

	if (lpstCreate->hwndParent)
		mscCenterWindowOnWindow(hwnd, lpstCreate->hwndParent);

    // Create an "Upgrade Information" button. - cab:11/29/96
    //
#ifdef USE_PRIVATE_EDITION_3_BANNER
    {
    HWND hwndButton = 0;

    // Create the button, but don't put any text in it yet. We'll
    // do that after we change the font.
    //
    hwndButton = CreateWindow("button",
			      "",
			      WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
			      IDN_UPGRADE_BUTTON_X,
			      IDN_UPGRADE_BUTTON_Y,
			      IDN_UPGRADE_BUTTON_W,
			      IDN_UPGRADE_BUTTON_H,
			      hwnd,
			      (HMENU)IDC_PB_UPGRADEINFO,
			      glblQueryDllHinst(),
			      NULL);

	assert(hwndButton);

    // Set the text font in the button to 8 point MS Sans Serif.
    // mpt:1-21-98 moved font and size to resources

    if (LoadString(glblQueryDllHinst(), IDS_UPGRADE_FONT_SIZE,
	    ach, sizeof(ach)/sizeof(TCHAR)))
		{
		nSize1 = atoi(ach);
		}
	else
		{
		nSize1 = -8;
		}

    LoadString(glblQueryDllHinst(), IDS_UPGRADE_FONT, ach, sizeof(ach)/sizeof(TCHAR));

    if ( fontSetWindowFont(hwndButton, ach, nSize1) != 0 )
		{
		assert(0);
		}

    // Set the button text.
	LoadString(glblQueryDllHinst(), IDS_UPGRADE_INFO,
		achUpgradeInfo, sizeof(achUpgradeInfo)/sizeof(TCHAR));

    SetWindowText(hwndButton, achUpgradeInfo);
    }
#endif

#if defined(INCL_SPINNING_GLOBE)
    // Create an animation control and play spinning globe.
    //
	{
	HWND    hwndAnimate;
	//mpt:03-12-98 Changed the bitmap and avi to use system colors
	hwndAnimate = Animate_Create(hwnd, 100,
	    WS_VISIBLE | WS_CHILD | ACS_TRANSPARENT,
	    glblQueryDllHinst());

	MoveWindow(hwndAnimate, 177, 37, 118, 101, TRUE);
	Animate_Open(hwndAnimate, MAKEINTRESOURCE(IDR_GLOBE_AVI));
	if (!IsTerminalServicesEnabled())
		{
		Animate_Play(hwndAnimate, 0, -1, 1);
		}
	}
#endif
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * ARGUMENTS:
 *
 * RETURNS:
 *
 */
STATIC_FUNC void banner_WM_PAINT(HWND hwnd)
	{
	HDC         hDC;
	HBITMAP     hBitmap;
	PAINTSTRUCT ps;
	LOGFONT     lf;
	HFONT       hFont;

	hDC = BeginPaint(hwnd, &ps);
	hBitmap = (HBITMAP)GetWindowLongPtr(hwnd, 0);

#ifdef USE_PRIVATE_EDITION_3_BANNER
    // Don't draw over the button. - cab:11/29/96
    //
    ExcludeClipRect(hDC, IDN_UPGRADE_BUTTON_X, IDN_UPGRADE_BUTTON_Y, IDN_UPGRADE_BUTTON_X + IDN_UPGRADE_BUTTON_W,
	IDN_UPGRADE_BUTTON_Y + IDN_UPGRADE_BUTTON_H);
#endif

	if (hBitmap)
		utilDrawBitmap((HWND)0, hDC, hBitmap, 0, 0);

    // In the HTPE 3 banner, the version # and lot # are now in the
    // lower left corner of the bitmap. - cab:11/29/96
    //
	// Here's a mean trick.  The HwndFrame guy doesn't get set until
	// long after the banner goes up.  Since we don't want the version
	// number on the opening banner but do want it in the about portion
	// this works. - mrw:3/17/95
	//
	//if (glblQueryHwndFrame())
		{
		memset(&lf, 0, sizeof(LOGFONT));

#ifndef NT_EDITION
		lf.lfHeight = 14;
#else
		lf.lfHeight = 12;
#endif
		lf.lfCharSet = ANSI_CHARSET;
		//lf.lfWeight = FW_SEMIBOLD;
		strcpy(lf.lfFaceName, "Arial");

		hFont = CreateFontIndirect(&lf);

		if (hFont)
			{
			hFont = SelectObject(hDC, hFont);
			//SetBkColor(hDC, RGB(0,255,0));
			SetBkMode( hDC, TRANSPARENT );
#ifndef NT_EDITION
			TextOut(hDC, 19, 230, "Build Date", 10);
			TextOut(hDC, 19, 242, __DATE__, strlen(__DATE__));
			TextOut(hDC, 225, 230, "Copyright 2001", 15);
			TextOut(hDC, 225, 242, "Hilgraeve Inc.", 14);
#else
			TextOut(hDC, 19, 260, "Copyright 2001 Microsoft Corporation.  All rights reserved.", 59);
			TextOut(hDC, 19, 272, "Portions Copyright 1995-2001 Hilgraeve, Inc.  All Rights reserved.", 66);
#endif			
			DeleteObject(SelectObject(hDC, hFont));
			}
		}

	EndPaint(hwnd, &ps);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:    bannerUnregisterClass
 *
 * DESCRIPTION:
 *      This function unregisters the window class for the banner window.
 *
 * ARGUEMENTS:
 *      The task instance handle.
 *
 * RETURNS:
 * The usual TRUE/FALSE from a registration function.
 *
 */
BOOL bannerUnregisterClass(HANDLE hInstance)
	{
	return UnregisterClass(BANNER_DISPLAY_CLASS, hInstance);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\capture.hh ===
/*	File: D:\WACKER\tdll\capture.hh (Created: 12-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:41p $
 */

struct stCapturePrivate
	{
	HSESSION hSession;

	/* This is used if nothing else has been set */
	LPTSTR pszInternalCaptureName;

	LPTSTR pszDefaultCaptureName;
	LPTSTR pszTempCaptureName;

	int nDefaultCaptureMode;
	int nTempCaptureMode;

	int nDefaultFileMode;
	int nTempFileMode;

	int nState;

	HMENU  hMenu;

	ST_IOBUF *hCaptureFile;
	};

typedef struct stCapturePrivate STCAPTURE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\capture.h ===
/*	File: D:\WACKER\tdll\capture.h (Created: 12-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:35p $
 */

#define	CPF_ERR_BASE		0x230
#define	CPF_NO_MEMORY		CPF_ERR_BASE+0x0001
#define	CPF_SIZE_ERROR		CPF_ERR_BASE+0x0002

extern HCAPTUREFILE CreateCaptureFileHandle(const HSESSION hSession);

extern void DestroyCaptureFileHandle(HCAPTUREFILE hCapt);

extern int InitializeCaptureFileHandle(const HSESSION hSession,
										HCAPTUREFILE hCapt);

extern int LoadCaptureFileHandle(HCAPTUREFILE hCapt);

extern int SaveCaptureFileHandle(HCAPTUREFILE hCapt);

extern int cpfGetCaptureFilename(HCAPTUREFILE hCapt,
								LPTSTR pszName,
								const int nLen);

extern int cpfSetCaptureFilename(HCAPTUREFILE hCapt,
								LPCTSTR pszName,
								const int nMode);

#define	CPF_MODE_CHAR		1
#define	CPF_MODE_LINE		2
#define	CPF_MODE_SCREEN		3
#define	CPF_MODE_RAW		4

extern int cpfGetCaptureMode(HCAPTUREFILE hCapt);

extern int cpfSetCaptureMode(HCAPTUREFILE hCapt,
							const int nCaptMode,
							const int nModeFlag);

#define	CPF_FILE_APPEND			1
#define	CPF_FILE_OVERWRITE		2
#define	CPF_FILE_REN_SEQ		3
#define	CPF_FILE_REN_DATE		4

extern int cpfGetCaptureFileflag(HCAPTUREFILE hCapt);

extern int cpfSetCaptureFileflag(HCAPTUREFILE hCapt,
								const int nSaveMode,
								const int nModeFlag);

#define	CPF_CAPTURE_ON			1
#define	CPF_CAPTURE_OFF			2
#define	CPF_CAPTURE_PAUSE		3
#define	CPF_CAPTURE_RESUME		4

extern int cpfGetCaptureState(HCAPTUREFILE hCapt);

extern int cpfSetCaptureState(HCAPTUREFILE hCapt, int nState);

extern HMENU cpfGetCaptureMenu(HCAPTUREFILE hCapt);

#define	CF_CAP_CHARS	CPF_MODE_CHAR
#define	CF_CAP_LINES	CPF_MODE_LINE
#define	CF_CAP_SCREENS	CPF_MODE_SCREEN

extern void CaptureChar(HCAPTUREFILE hCapt, int nFlags, ECHAR cData);

extern void CaptureLine(HCAPTUREFILE hCapt, int nFlags, ECHAR *achStr, int nLen);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\clipbrd.c ===
/*	File: D:\WACKER\tdll\clipbrd.c (Created: 24-Jan-1994)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 2 $
 *	$Date: 5/09/01 4:42p $
 */

#include <windows.h>
#pragma hdrstop

#include "stdtyp.h"
#include "assert.h"
#include "session.h"
#include "tdll.h"
#include "cloop.h"
#include "htchar.h"
#include "mc.h"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CopyBufferToClipBoard
 *
 * DESCRIPTION:
 *	Function to copy text to clipboard
 *
 * ARGUMENTS:
 *	HWND	hwnd	- window that will own clipboard.
 *	DWORD	dwCnt	- size of buffer
 *	void   *pvBuf	- pointer to buffer
 *
 * RETURNS:
 *	BOOL
 *
 */
BOOL CopyBufferToClipBoard(const HWND hwnd, const DWORD dwCnt, const void *pvBuf)
	{
	HGLOBAL hMem;
	void *pvMem;
	TCHAR *pszTemp;

	if (pvBuf == 0 || dwCnt == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	if (!OpenClipboard(hwnd))
		return FALSE;

	hMem = GlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE, dwCnt + 1);

	if (hMem == 0)
		{
		assert(FALSE);
		return FALSE;
		}

	pvMem = GlobalLock(hMem);
    if (dwCnt)
	    MemCopy(pvMem, pvBuf, dwCnt);
	pszTemp = pvMem;
	*(pszTemp + dwCnt) = 0;
	GlobalUnlock(hMem);

	EmptyClipboard();
	SetClipboardData(CF_TEXT, hMem);
	CloseClipboard();

	return TRUE;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	PasteFromClipboardToHost
 *
 * DESCRIPTION:
 *  This function copies text from the clipboard to host.
 *
 * ARGUMENTS:
 *  HWND hwnd 			- window handle
 *  HSESSION hSession 	- the session handle
 *
 * RETURNS:
 *	BOOL
 *
 */
BOOL PasteFromClipboardToHost(const HWND hwnd, const HSESSION hSession)
	{
	HANDLE	hMem;
	LPTSTR  lptStr;

	// Clipboard had to have been opened first...
	//
	if (!OpenClipboard(hwnd))
		return FALSE;

	// Check to see if the clipboard format is available.
	//
	if (IsClipboardFormatAvailable(CF_TEXT) == FALSE)
		return FALSE;

	// Do we need to enumerate clipboard formats?

	if ((hMem = GetClipboardData(CF_TEXT)))
		{
		// hMem is owned by the clipboard, so we must not free it 
		// or leave it locked!
		//
		if ((lptStr = GlobalLock(hMem)))
			{
			CLoopSend(sessQueryCLoopHdl(hSession),
					lptStr,
					(size_t)(StrCharGetByteCount(lptStr)),
					0);

			GlobalUnlock(hMem);
			}
		}

	CloseClipboard();
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\chars.h ===
/*	File: D:\WACKER\tdll\chars.h (Created: 30-Nov-1993)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 3 $
 *	$Date: 10/11/99 5:31p $
 */

#if !defined(INCL_CHARS)
#define INCL_CHARS

/*
 * Keystrokes are passed in the following manner:
 *
 *	If the VIRTUAL_KEY flag is clear, then the lower byte of the value is the
 *		displayable (usually ASCII) code for the character
 *
 *	If the VIRTUAL_KEY flag is set, then the lower byte ov the value is the
 *		WINDOWs VK_* code for the key that was pressed.  In addition, the flags
 *		for ALT_KEY, CTRL_KEY, and SHIFT_KEY are set to the correct values.
 */

#define VIRTUAL_KEY 		0x00800000

#define ALT_KEY 			0x00010000
#define CTRL_KEY			0x00020000
#define SHIFT_KEY			0x00040000
#define EXTENDED_KEY		0x00080000

KEY_T TranslateToKey(const LPMSG pmsg);

// NumLock query helper returns true if NumLock is on, false if NumLock is off.
// mrw:10/6/99
//
#define QUERY_NUMLOCK() ((GetKeyState(VK_NUMLOCK) & 0x01) ? TRUE : FALSE)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\cloop.c ===
/*	File: cloop.c (created 12/27/93, JKH)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 15 $
 *	$Date: 7/12/02 8:06a $
 */
#include <windows.h>
#pragma hdrstop

#include "features.h"

// #define DEBUGSTR
#include "stdtyp.h"
#include "session.h"
#include "globals.h"
#include "timers.h"
#include "com.h"
#include "xfer_msc.h"
#include <emu\emu.h>
#if defined(CHARACTER_TRANSLATION)
#include "translat.hh"
#endif
#include "cloop.h"
#include "cloop.hh"
#include "htchar.h"
#include "assert.h"
#include "chars.h"

#if defined(INCL_VTUTF8)
BOOL DoUTF8 = FALSE;
#endif

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoop
 *
 * DESCRIPTION:
 *	This function comprises the 'engine' of the engine thread. Its action
 *	is controlled by a series of control bits that are set and cleared
 *	by calls to CLoopRcvControl and CLoopControl
 *
 * ARGUMENTS:
 *	pstCLoop -- Handle returned from CLoopCreateHandle
 *
 * RETURNS:
 *	nothing
 */
DWORD WINAPI CLoop(LPVOID pvData)
	{
	ST_CLOOP * const pstCLoop = (ST_CLOOP *)pvData;
	HCOM	   hCom;
	int 	   nRcvCount;
	TCHAR	   chData = (TCHAR)0;
	ECHAR      echData = (ECHAR)0;
	HSESSION   hSession;
	HEMU	   hEmu;
	KEY_T	   keyOut;
	ST_FCHAIN *pstCurrent;
	CHAINFUNC  pfChainFunc;
	int		   fValidChar;
#if defined(CHARACTER_TRANSLATION)
	HHTRANSLATE hTrans = NULL;
#endif
	int        nCount;
	int        nIndx;
	CHAR       chBuffer[32];		/* Yes, it is supposed to be a CHAR */
	int		   mc;
	PVOID      pvUserData;
	DWORD      dwEventCount;
	HANDLE     *pvEvents;

    DBGOUT_NORMAL("In CLoop(%lX)\r\n", pstCLoop,0,0,0,0);
	assert(pstCLoop);

	EnterCriticalSection(&pstCLoop->csect);

	hSession = pstCLoop->hSession;
	hCom = pstCLoop->hCom;
	hEmu = pstCLoop->hEmu;
#if defined(CHARACTER_TRANSLATION)
	hTrans = (HHTRANSLATE)sessQueryTranslateHdl(pstCLoop->hSession);
#endif

	assert(hSession);
	assert(hCom);
	assert(hEmu);

	DBGOUT_NORMAL("CLoop got critical section\r\n", 0,0,0,0,0);
	while (!bittest(pstCLoop->afControl, CLOOP_TERMINATE))
		{
		DWORD dwRet;

		// Normally, this CLoop function owns the critical section
		//	controlling the CLoop data. We give it up at least once each
		//	time through the loop to give other threads a change to call
		//	control functions.
		dwEventCount = DIM(pstCLoop->ahEvents);
		pvEvents = pstCLoop->ahEvents;

		LeaveCriticalSection(&pstCLoop->csect);

		// Block if there is nothing to do
		DBGOUT_YIELD("W+ ", 0,0,0,0,0);
		dwRet = WaitForMultipleObjects(dwEventCount, pvEvents, FALSE, INFINITE);
		DBGOUT_YIELD("W(0x%x)", dwRet,0,0,0,0);
		EnterCriticalSection(&pstCLoop->csect);
		DBGOUT_YIELD(": ", 0,0,0,0,0);

		// See if a transfer has been initiated
		if (bittest(pstCLoop->afControl, CLOOP_TRANSFER_READY))
			{
			DBGOUT_NORMAL("CLoop calling xfer\r\n", 0,0,0,0,0);

			LeaveCriticalSection(&pstCLoop->csect);

			xfrDoTransfer(sessQueryXferHdl(hSession));
			DBGOUT_NORMAL("CLoop back from xfer\r\n", 0,0,0,0,0);

			EnterCriticalSection(&pstCLoop->csect);

			CLoopControl((HCLOOP)pstCLoop, CLOOP_CLEAR, CLOOP_TRANSFER_READY);
			}

		// If there is input waiting and we are not blocked from receiving

		if (!pstCLoop->afRcvBlocked)
			{
			// Give priority to receiving over sending since normally
			//	we will receive more data than we send (CR becomes CR LF)
			//	and since we have more control over the send rate
			// TODO: implement priority setting by adjusting rcv count
			for (nRcvCount = 10; nRcvCount--; )
				{
				fValidChar = FALSE;
				if (mComRcvChar(hCom, &chData))
					{
					DBGOUT_NORMAL("Recieved Char\r\n", 0,0,0,0,0);

					// Check for force to 7-bit ASCII
					if (pstCLoop->stWorkSettings.fASCII7)
                        {
						chData &= 0x7F;
                        }

                    nCount = 0;

                    #if defined(CHARACTER_TRANSLATION)
                    if( nCount >= 0 && hTrans != NULL )
                        {
					    LeaveCriticalSection(&pstCLoop->csect);
					    hTrans->pfnIn(hTrans->pDllHandle, 
								      chData,
								      &nCount,
								      sizeof(chBuffer),
								      chBuffer);
					    EnterCriticalSection(&pstCLoop->csect);
                        }
                    #else // defined(CHARACTER_TRANSLATION)
                    if( nCount >= 0 )
						{
					    chBuffer[0] = chData;
					    nCount = 1; 
						}
                    #endif // defined(CHARACTER_TRANSLATION)

					for (nIndx = 0; nIndx < nCount; nIndx++)
						{
						if (pstCLoop->fDoMBCS)
							{
							if (pstCLoop->cLeadByte != 0)
								{
								chData = 0;
								echData = chBuffer[nIndx] & 0xFF;
								// There must be a macro for this somewhere
								echData |= (ECHAR)(pstCLoop->cLeadByte << 8);
								pstCLoop->cLeadByte = 0;
								fValidChar = TRUE;
								}
							else
								{
								if (IsDBCSLeadByte(chBuffer[nIndx]))
									{
									pstCLoop->cLeadByte = chBuffer[nIndx];
									}
								else
									{
									echData = chBuffer[nIndx] & 0xFF;
                                    pstCLoop->cLeadByte = 0;
									fValidChar = TRUE;
									}
								}
							} // if (fDoMBCS)
						else
							{
							echData 	= ETEXT(chBuffer[nIndx]);
							fValidChar 	= TRUE;
                            } // else (fDoMBCS)

                        if (fValidChar)
							{
							// Character translation/stripping
							//*if ((chData = pstCLoop->panFltrIn[chData]) == -1)
							//*	continue;


							// walk remote input function chain if it exists
							if (pstCLoop->fRmtChain)
								{
								pstCLoop->pstRmtChainNext = pstCLoop->pstRmtChain;
								while (pstCLoop->pstRmtChainNext)
									{
									pstCurrent = pstCLoop->pstRmtChainNext;
									pstCLoop->pstRmtChainNext = pstCurrent->pstNext;
									pfChainFunc = pstCurrent->pfFunc;
									pvUserData = pstCurrent->pvUserData;

									LeaveCriticalSection(&pstCLoop->csect);
									mc = (*pfChainFunc)(chData, pvUserData);
									EnterCriticalSection(&pstCLoop->csect);
									if ( mc == CLOOP_DISCARD )
										break;									
									}
								}

							if ( mc != CLOOP_DISCARD )
								{
								pstCLoop->fDataReceived = TRUE;
								CLoopCharIn(pstCLoop, echData);
								}


							if (pstCLoop->afRcvBlocked)
								{
								/*
								 * This is necessary because a script may be
								 * checking input and then stopping after it
								 * finds what it is looking for.  If the loop
								 * count is still possitive, the remaining
								 * characters will "slip thru" before this
								 * loop terminates.
								 * This won't break in any obvious way, so be
								 * careful to preserve this feature if this
								 * loop is rewritten.
								 *
								 * TODO: when scripts are added, make sure this
								 * works correctly with character translation.
								 */
								// Receiving has been blocked,
								// make sure any received
								// data gets displayed.
    					        LeaveCriticalSection(&pstCLoop->csect);
						        emuComDone(hEmu);
    					        EnterCriticalSection(&pstCLoop->csect);
								break;
								}
							}
						}

                    //
                    // Clear the temporary input character buffer.
                    // as the buffer has been copied into echData.
                    // REV: 03/06/2001
                    //
                    memset(chBuffer, 0, sizeof(chBuffer));
					}
				else
					{
					CLoopRcvControl((HCLOOP)pstCLoop, CLOOP_SUSPEND,
							CLOOP_RB_NODATA);
					if (pstCLoop->fDataReceived)
						{
						// Notify emulator that there is a pause in the
						//	stream of received data
    					LeaveCriticalSection(&pstCLoop->csect);
						emuComDone(hEmu);
    					EnterCriticalSection(&pstCLoop->csect);

						// If we had a delay timer already running, kill it
						if (pstCLoop->htimerRcvDelay)
							{
							TimerDestroy(&pstCLoop->htimerRcvDelay);
							}

						// The stream of incoming data has stopped, set a
						//	 timer so we can tell if it stops long enough to
						//	 do cursor tracking etc.
						if (TimerCreate(pstCLoop->hSession,
							            &pstCLoop->htimerRcvDelay,
										CLOOP_TRACKING_DELAY,
										/* pstCLoop->pfRcvDelay, */
										CLoopRcvDelayProc,
										(void *)pstCLoop) != TIMER_OK)
							{
							pstCLoop->htimerRcvDelay = (HTIMER)0;
							assert(FALSE);
							}

						pstCLoop->fDataReceived = FALSE;

						}
					}
				}
			}

		// Check for outgoing data.
		if (!pstCLoop->afSndBlocked)
			{
            // (Taken verbatim from HA5G, by JMH 03-22-96):
			// This change was added to fix a deadlock problem. While sending
			// and receiving data simultaneously at high speed, it was
			// possible for us to issue a handshake stop at the same time
			// we would receive one from the host. Our code would wait
			// in the ComSendBufr call and stop processing. Because of this,
			// we would not be processing incoming data so we would never
			// clear the handshake stop we had issued to the other end. If
			// the other end was caught in the same state -- deadlock.
			// This test slows our text transmission down. We should
			// redesgin our transmission model to fix this.  jkh, 1/19/95

			// if (CLoopGetNextOutput(pstCLoop, &keyOut)) DEADWOOD:jmh 03-22-96
            if (ComSndBufrBusy(hCom) == COM_BUSY)
                {
                //
                // Yield to other threads, but don't wait too long
                // to cause undo delay of data transfer.  Time was
                // changed from 10 milliseconds to 0 millisecond
                // which will yield to other threads (so the CPU
                // doesn't peg), but will not cause undo delay in
                // the data transmission.  This bug was reported
                // by customers after HTPE3 (and by Motorola to MS)
                // when sending data via text send. REV: 06/13/2001.
                //
				#if defined(DEADWOOD)
                Sleep(0);              // jkh  04/29/1998 don't peg CPU
				#else // defined(DEADWOOD)
				//
				// We should wait for the COM/TAPI driver to write the
				// data before we continue.  For now we will leave the
				// critical section so other threads can continue,
				// and loop back around.  TODO:REV 7/11/2002
				//
				LeaveCriticalSection(&pstCLoop->csect);
				//ComSndBufrWait(hCom, 100);
				//WaitForSingleObject(hCom->hSndReady, 1000);
				EnterCriticalSection(&pstCLoop->csect);
				#endif // defined(DEADWOOD)
                }
			else if (CLoopGetNextOutput(pstCLoop, &keyOut))
				{
				// Check for tab expansion
				//DbgOutStr("C", 0,0,0,0,0);
				if (keyOut == TEXT('\t') &&
						pstCLoop->stWorkSettings.fExpandTabsOut &&
						pstCLoop->stWorkSettings.nTabSizeOut)
					{
					//* int   i;
					//* POINT pt;

					//* mEmuGetCursorPos(
					//*			mGetEmulatorHdl(pstCLoop->hSession),
					//*			&pt);

					//* i = pstCLoop->stWorkSettings.usTabSizeOut -
					//* 	((pt.x + 1) % pstCLoop->stWorkSettings.usTabSizeOut);

					//* while (i-- > 0)
					//* 	(VOID)mEmuKbdIn(hEmu, (KEY_T)TEXT(' '), FALSE);
					}
				else
					{
                    //jmh 03-22-96 We need to unlock cloop around calls to
                    // emuKbdIn and emuDataIn, because they call the com
                    // thread, which may be stuck waiting to access cloop.
                    //
					LeaveCriticalSection(&pstCLoop->csect);
					emuKbdIn(hEmu, keyOut, FALSE);
					EnterCriticalSection(&pstCLoop->csect);
					}


				//
				// The keyOut shouuld no longer be (VK_RETURN | VIRTUAL_KEY)
				// but if it is, then treat it like '\r'. REV: 5/16/2002
				//
				if (keyOut == TEXT('\r') ||
					keyOut == (VK_RETURN | VIRTUAL_KEY))
					{
					if (pstCLoop->stWorkSettings.fLineWait)
						{
						CLoopSndControl((HCLOOP)pstCLoop, CLOOP_SUSPEND,
								CLOOP_SB_LINEWAIT);
						}

					if (pstCLoop->stWorkSettings.fSendCRLF)
						{
                        //DEADWOOD:jkh 8/18/97 
                        // Can't use CLoopSend here because the '\n' is placed
                        // behind any other codes waiting in the output queue.
                        // This caused all LF codes in a text file send to be
                        // sent AFTER the whole file, rather than after each CR

						// CLoopSend((HCLOOP) pstCLoop, TEXT("\n"), 1, 0);

    					LeaveCriticalSection(&pstCLoop->csect);
						emuKbdIn(hEmu, (KEY_T)'\n', FALSE);
    					EnterCriticalSection(&pstCLoop->csect);
#if 0 //DEADWOOD: RDE 20AUG98 MPT Fixed a local echo problem down in 
      //               CloopCharIn which then caused an extra linefeed
      //               to be displayed on the local terminal.
                        if (pstCLoop->stWorkSettings.fLocalEcho &&
								!pstCLoop->fSuppressDsp)
							{
							//jmh 03-22-96 We need to unlock cloop around calls to
							// emuKbdIn and emuDataIn, because they call the com
							// thread, which may be stuck waiting to access cloop.
							//
        					LeaveCriticalSection(&pstCLoop->csect);
							emuDataIn(hEmu, TEXT('\n'));
							emuComDone(hEmu);
        					EnterCriticalSection(&pstCLoop->csect);
							}
#endif
                        }

					if (pstCLoop->stWorkSettings.nLineDelay)
						{
						if (TimerCreate( pstCLoop->hSession,
							             &pstCLoop->htimerCharDelay,
										 pstCLoop->stWorkSettings.nLineDelay,
										 pstCLoop->pfCharDelay,
										 (void *)pstCLoop) == TIMER_OK)
							{
							CLoopSndControl((HCLOOP)pstCLoop, CLOOP_SUSPEND,
									        CLOOP_SB_DELAY);
							}
						}
					}
				else
					{
					if (pstCLoop->stWorkSettings.nCharDelay)
						{
						if (TimerCreate(pstCLoop->hSession,
							            &pstCLoop->htimerCharDelay,
										pstCLoop->stWorkSettings.nCharDelay,
										pstCLoop->pfCharDelay,
										(void *)pstCLoop) == TIMER_OK)
							{
							CLoopSndControl((HCLOOP)pstCLoop, CLOOP_SUSPEND,
								            CLOOP_SB_DELAY);
							}
						}
					}


				//* if (pstCLoop->lpLearn)
				//* 	{
				//* 	CLearnSendChar(pstCLoop->lpLearn, (METACHAR)keyOut);
				//* 	}
				}
			}

		// Make sure any buffered output waiting gets sent.
		//* ComSendPush(pstCLoop->hCom);

		}

    DBGOUT_NORMAL("Leaving CLoop(%lX)\r\n", pstCLoop,0,0,0,0);

	LeaveCriticalSection(&pstCLoop->csect);

	return 0;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopCharIn
 *
 * DESCRIPTION:
 *	Does rec eive processing for characters received from the remote system
 *
 * ARGUMENTS:
 *	pstCLoop -- Handle returned from CLoopCreateHandle
 *	mc		 -- Character to be processed.
 *
 * RETURNS:
 *	nothing
 */
void CLoopCharIn(ST_CLOOP *pstCLoop, ECHAR chIn)
	{
	// Check for echoplex
	if (pstCLoop->stWorkSettings.fEchoplex)
		{
		
		//mpt:1-27-98 converting echars to tchar was converting
		//            the character to a single byte. Consequently,
		//            echoing of a dbcs character was only echoing
		//            the second byte of the character.
		if ( (pstCLoop->fDoMBCS) && (chIn > 255) )
			{
			//send first byte
			ComSendCharNow(pstCLoop->hCom, (TCHAR) (chIn >> 8));
			//send second byte
			ComSendCharNow(pstCLoop->hCom, (TCHAR) (chIn & 0xFF));
			}
		else
			{
			ComSendCharNow(pstCLoop->hCom, (TCHAR) chIn);
			}

		//
		// See if we need to add a line feed to line end. REV: 5/21/2002
		//
		if ((chIn == ETEXT('\r') || chIn == (VK_RETURN | VIRTUAL_KEY)) &&
			pstCLoop->stWorkSettings.fAddLF)
			{
			ComSendCharNow(pstCLoop->hCom, TEXT('\n'));
			}
		}

	if (pstCLoop->stWorkSettings.fLineWait &&
			chIn == pstCLoop->stWorkSettings.chWaitChar)
		CLoopSndControl((HCLOOP)pstCLoop, CLOOP_RESUME, CLOOP_SB_LINEWAIT);

	// Display character in normal or image mode
	if (!pstCLoop->fSuppressDsp)
		{
		// DbgOutStr("Dsp %02X (%c)\r\n", chIn, chIn, 0,0,0);
		emuDataIn(pstCLoop->hEmu, chIn);

		//
		// See if we need to add a line feed to line end. REV: 5/21/2002
		//
		if ((chIn == ETEXT('\r') || chIn == (VK_RETURN | VIRTUAL_KEY)) &&
			pstCLoop->stWorkSettings.fAddLF)
			{
			emuDataIn(pstCLoop->hEmu, ETEXT('\n'));
			}
		}
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CLoopCharOut
 *
 * DESCRIPTION:
 *	Called to send a character out the port with processing by the CLoop
 *	routines. Note that this differs from CLoopSend.
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void CLoopCharOut(HCLOOP hCLoop, TCHAR chOut)
	{
	ST_CLOOP * const pstCLoop = (ST_CLOOP *)hCLoop;
	int              fCharValid = FALSE;
	ECHAR            echOut = (ECHAR)0;

    #if defined(CHARACTER_TRANSLATION)
	HHTRANSLATE      hTrans = NULL;
	int              nCount = 0;
	int              nIndx;
	CHAR             chBuffer[32];		/* Yes, it is supposed to be a CHAR */

	hTrans = (HHTRANSLATE)sessQueryTranslateHdl(pstCLoop->hSession);

	if (hTrans)
		{
		(*hTrans->pfnOut)(hTrans->pDllHandle, 
						chOut,
						&nCount,
						sizeof(chBuffer)/sizeof(TCHAR),
						chBuffer);
		}
	else
		{
		StrCharCopyN(chBuffer, &chOut, sizeof(chBuffer)/sizeof(TCHAR));
		}

	for (nIndx = 0; nIndx < nCount; nIndx += 1)
		{
		chOut = chBuffer[nIndx];
    #endif //CHARACTER_TRANSLATION

		ComSendCharNow(pstCLoop->hCom, chOut);
		if (pstCLoop->stWorkSettings.fLocalEcho &&
				!pstCLoop->fSuppressDsp)
			{
			if (pstCLoop->fDoMBCS)
				{
				if (pstCLoop->cLocalEchoLeadByte)
					{
					echOut = chOut & 0xFF;
					echOut |= (ECHAR)(pstCLoop->cLocalEchoLeadByte << 8);
					pstCLoop->cLocalEchoLeadByte = 0;
					fCharValid = TRUE;
					}
				else
					{
					if (IsDBCSLeadByte(chOut))
						{
						pstCLoop->cLocalEchoLeadByte = chOut;
						}
					else
						{
						echOut = chOut & 0xFF;
						fCharValid = TRUE;
						}
					}
				}
			else
				{
				echOut = (ECHAR)chOut;
                fCharValid = TRUE;
				}

			if (fCharValid)
				{
				emuDataIn(pstCLoop->hEmu, echOut);
				emuComDone(pstCLoop->hEmu);
				}
			}
        #if defined(CHARACTER_TRANSLATION)
		}
        #endif

    return;
    }

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CLoopBufrOut
 *
 * DESCRIPTION:
 *	Called to send a buffer of characters out the port with processing by the CLoop
 *	routines. Note that this differs from CLoopSend.
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *	void
 *
 */
void CLoopBufrOut(HCLOOP hCLoop, TCHAR *pchOut, int nLen)
	{
	ST_CLOOP * const pstCLoop = (ST_CLOOP *)hCLoop;
	int fCharValid = FALSE;

	while (nLen--)
		{
		ComSendChar(pstCLoop->hCom, *pchOut);	// place chars in comsend buffer
		if (pstCLoop->stWorkSettings.fLocalEcho &&
				!pstCLoop->fSuppressDsp)
			{
			if (pstCLoop->fDoMBCS)
				{
				if (pstCLoop->cLocalEchoLeadByte != 0)
					{
					*pchOut |= (TCHAR)(pstCLoop->cLocalEchoLeadByte << 8);
					pstCLoop->cLocalEchoLeadByte = 0;
					fCharValid = TRUE;
					}
				else
					{
					if (IsDBCSLeadByte(*pchOut))
						{
						pstCLoop->cLocalEchoLeadByte = *pchOut;
						}
					else
						{
						fCharValid = TRUE;
						}
					}
				}
			else
				{
				fCharValid = TRUE;
				}

			if (fCharValid)
				{
				emuDataIn(pstCLoop->hEmu, *pchOut);
				emuComDone(pstCLoop->hEmu);
				}
			}
		++pchOut;
		}
	ComSendPush(pstCLoop->hCom);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopRcvDelayProc
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
/* ARGSUSED */
void CALLBACK CLoopRcvDelayProc(void *pvData, long lSince)
	{
	// This timer was set the last time data input stopped. If no data
	//	has been received since, notify the display routines so they can
	//	do cursor tracking or whatever silly thing it is they do.
	ST_CLOOP *pstCLoop = (ST_CLOOP *)pvData;

	EnterCriticalSection(&pstCLoop->csect);
	if (!pstCLoop->fDataReceived)
		{
		emuTrackingNotify(pstCLoop->hEmu);
		}
	TimerDestroy(&pstCLoop->htimerRcvDelay);

	(void)&lSince;		// avoid compiler warnings
	LeaveCriticalSection(&pstCLoop->csect);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopCharDelayProc
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
/* ARGSUSED */
void CALLBACK CLoopCharDelayProc(void *pvData, long lSince)
	{
	ST_CLOOP *pstCLoop = (ST_CLOOP *)pvData;

	EnterCriticalSection(&pstCLoop->csect);

	TimerDestroy(&pstCLoop->htimerCharDelay);
	CLoopSndControl((HCLOOP)pstCLoop, CLOOP_RESUME, CLOOP_SB_DELAY);

	LeaveCriticalSection(&pstCLoop->csect);

	(void)&lSince;		// avoid compiler warnings
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\capture.c ===
/*
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 6 $
 *	$Date: 7/08/02 6:38p $
 */
#include <windows.h>
#pragma hdrstop

#define ARRAYSIZE(rg) (sizeof(rg)/sizeof((rg)[0]))

// #define	DEBUGSTR	1

#define	DO_RAW_MODE	1

#include <string.h>

#include "stdtyp.h"

#include "mc.h"
#include "sf.h"
#include <tdll\assert.h>
#include "file_io.h"
#include "globals.h"
#include "session.h"
#include "sess_ids.h"
#include "tdll.h"
#include "htchar.h"
#include "open_msc.h"

#include <term\res.h>

#include "capture.h"
#include "capture.hh"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	CreateCaptureFileHandle
 *
 * DESCRIPTION:
 *	This function is called to create a capture file handle and fill it with
 *	some reasonable set of defaults.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	A capture file handle or ZERO if there was an error.
 *
 */
HCAPTUREFILE CreateCaptureFileHandle(const HSESSION hSession)
	{
	int nRet;
	STCAPTURE *pST = NULL;	// REV 8/27/98

	pST = (STCAPTURE *)malloc(sizeof(STCAPTURE));
	if (pST == (STCAPTURE *)0)
		goto CCFHexit;

	memset(pST, 0, sizeof(STCAPTURE));

	nRet = InitializeCaptureFileHandle(hSession, (HCAPTUREFILE)pST);

	if (nRet == 0)
		return (HCAPTUREFILE)pST;

CCFHexit:

	if (pST != (STCAPTURE *)0)
		{
		if (pST->pszInternalCaptureName != (LPTSTR)0)
			{
			free(pST->pszInternalCaptureName);
			pST->pszInternalCaptureName = NULL;
			}
		if (pST->pszDefaultCaptureName != (LPTSTR)0)
			{
			free(pST->pszDefaultCaptureName);
			pST->pszDefaultCaptureName = NULL;
			}
		if (pST->pszTempCaptureName != (LPTSTR)0)
			{
			free(pST->pszTempCaptureName);
			pST->pszTempCaptureName = NULL;
			}
		free(pST);
		pST = NULL;
		}
	return (HCAPTUREFILE)0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	DestroyCaptureFileHandle
 *
 * DESCRIPTION:
 *	This function is called to free up all the resources that are associated
 *	with the capture file handle.  After this, it is GONE.
 *
 * PARAMETERS:
 *	hCapt    -- the capture handle
 *
 * RETURNS:
 *	Nothing.
 *
 */
void DestroyCaptureFileHandle(HCAPTUREFILE hCapt)
	{
	STCAPTURE *pST = NULL;

	pST = (STCAPTURE *)hCapt;
	assert(pST);

	if (pST != (STCAPTURE *)0)
		{
		if (pST->hCaptureFile != NULL)
			{
			fio_close(pST->hCaptureFile);
			}
		pST->hCaptureFile = NULL;

		if (pST->pszDefaultCaptureName != (LPTSTR)0)
			{
			free(pST->pszDefaultCaptureName);
			pST->pszDefaultCaptureName = NULL;
			}
		if (pST->pszInternalCaptureName != (LPTSTR)0)
			{
			free(pST->pszInternalCaptureName);
			pST->pszInternalCaptureName = NULL;
			}
		if (pST->pszTempCaptureName != (LPTSTR)0)
			{
			free(pST->pszTempCaptureName);
			pST->pszTempCaptureName = NULL;
			}

		if (pST->hMenu)
			{
			/* We only destroy it if it is not in use */
			switch (pST->nState)
				{
				case CPF_CAPTURE_ON:
				case CPF_CAPTURE_PAUSE:
				case CPF_CAPTURE_RESUME:
					DestroyMenu(pST->hMenu);
					break;
				case CPF_CAPTURE_OFF:
				default:
					break;
				}
			}

		free(pST);
		pST = NULL;
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	InitializeCaptureFileHandle
 *
 * DESCRIPTION:
 *	This function is called to set the capture file handle to a known state
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	ZERO if everything was OK, otherwise an error code
 */
int InitializeCaptureFileHandle(const HSESSION hSession, HCAPTUREFILE hCapt)
	{
	STCAPTURE *pST = (STCAPTURE *)hCapt;
	int nLen;
	LPTSTR pszStr;
	TCHAR acBuffer[FNAME_LEN];

	assert(pST);
	TCHAR_Fill(acBuffer, TEXT('\0'), sizeof(acBuffer) / sizeof(TCHAR)); // REV 8/27/98

	pST->hSession = hSession;

	/* Put together a reasonable default for the capture file */
	//Changed to remember the working folder path - mpt 8-18-99
	if ( !GetWorkingDirectory(acBuffer, sizeof(acBuffer) / sizeof(TCHAR)) )
		{
		GetCurrentDirectory(sizeof(acBuffer) / sizeof(TCHAR), acBuffer);
		}
	pszStr = StrCharLast(acBuffer);
	if (*pszStr != TEXT('\\'))
		StrCharCat(pszStr, TEXT("\\"));

	/* Decide if this should be in the resource strings */
	// StrCharCat(acBuffer, TEXT("CAPTURE.TXT"));
	pszStr = StrCharEnd(acBuffer);
	LoadString(glblQueryDllHinst(),
				IDS_CPF_CAP_FILE,
				pszStr,
				(int)(sizeof(acBuffer) - (pszStr - acBuffer) / sizeof(TCHAR)));
	nLen = StrCharGetByteCount(acBuffer) + 1;

	if (pST->pszInternalCaptureName != (LPTSTR)0)
		{
		free(pST->pszInternalCaptureName);
		pST->pszInternalCaptureName = NULL;
		}
	pST->pszInternalCaptureName = (LPTSTR)malloc((unsigned int)nLen * sizeof(TCHAR));
	if (pST->pszInternalCaptureName == (LPTSTR)0)
		goto ICFHexit;
	StrCharCopyN(pST->pszInternalCaptureName, acBuffer, nLen * sizeof(TCHAR));

	if (pST->pszDefaultCaptureName != (LPTSTR)0)
		free(pST->pszDefaultCaptureName);
	pST->pszDefaultCaptureName = (LPTSTR)0;

	if (pST->pszTempCaptureName != (LPTSTR)0)
		free(pST->pszTempCaptureName);
	pST->pszTempCaptureName = (LPTSTR)0;

#if defined(DO_RAW_MODE)
	pST->nDefaultCaptureMode = CPF_MODE_RAW;
	pST->nTempCaptureMode = CPF_MODE_RAW;
#else
	pST->nDefaultCaptureMode = CPF_MODE_LINE;
	pST->nTempCaptureMode = CPF_MODE_LINE;
#endif

	pST->nDefaultFileMode = CPF_FILE_APPEND;
	pST->nTempFileMode = CPF_FILE_APPEND;

	pST->nState = CPF_CAPTURE_OFF;

	return 0;

ICFHexit:

	if (pST != (STCAPTURE *)0)
		{
		if (pST->pszInternalCaptureName != (LPTSTR)0)
			{
			free(pST->pszInternalCaptureName);
			pST->pszInternalCaptureName = NULL;
			}
		}
	return CPF_NO_MEMORY;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	LoadCaptureFileHandle
 *
 * DESCRIPTION:
 *	This function is called to load the capture file settings from the system
 *	file.
 *
 * PARAMETERS:
 *	hSession -- the session handle
 *
 * RETURNS:
 *	ZERO if everythis was OK, otherwise an error code.
 *
 */
int LoadCaptureFileHandle(HCAPTUREFILE hCapt)
	{
	int nRet = 0;
	long lSize;
	STCAPTURE *pOld;

	pOld = (STCAPTURE *)hCapt;
	assert(pOld);
	if (pOld->hCaptureFile != NULL)
		{
		fio_close(pOld->hCaptureFile);
		}
	pOld->hCaptureFile = NULL;
	pOld->nState = CPF_CAPTURE_OFF;

	nRet = InitializeCaptureFileHandle(pOld->hSession, hCapt);
	if (nRet)
		return nRet;

	lSize = 0;
	sfGetSessionItem(sessQuerySysFileHdl(pOld->hSession),
					SFID_CPF_MODE,
					&lSize, NULL);
	if (lSize)
		{
		sfGetSessionItem(sessQuerySysFileHdl(pOld->hSession),
						SFID_CPF_MODE,
						&lSize,
						&pOld->nDefaultCaptureMode);
		if (pOld->nDefaultCaptureMode == 0)
#if defined(DO_RAW_MODE)
			pOld->nDefaultCaptureMode = CPF_MODE_RAW;
#else
			pOld->nDefaultCaptureMode = CPF_MODE_LINE;
#endif
		pOld->nTempCaptureMode = pOld->nDefaultCaptureMode;
		}

	lSize = 0;
	sfGetSessionItem(sessQuerySysFileHdl(pOld->hSession),
					SFID_CPF_FILE,
					&lSize, NULL);
	if (lSize)
		{
		lSize = sizeof(int);
		sfGetSessionItem(sessQuerySysFileHdl(pOld->hSession),
						SFID_CPF_FILE,
						&lSize,
						&pOld->nDefaultFileMode);
		if (pOld->nDefaultFileMode == 0)
			pOld->nDefaultFileMode = CPF_FILE_APPEND;
		pOld->nTempFileMode = pOld->nDefaultFileMode;
		}

	lSize = 0;
	sfGetSessionItem(sessQuerySysFileHdl(pOld->hSession),
					SFID_CPF_FILENAME,
					&lSize, NULL);
	if (lSize)
		{
		LPTSTR pszName;

		pszName = (LPTSTR)0;
		pszName = malloc((unsigned int)lSize);
		if (!pszName)
			{
			return CPF_NO_MEMORY;
			}
		sfGetSessionItem(sessQuerySysFileHdl(pOld->hSession),
						SFID_CPF_FILENAME,
						&lSize, pszName);

		if (pOld->pszDefaultCaptureName)
			{
			free(pOld->pszDefaultCaptureName);
			pOld->pszDefaultCaptureName = NULL;
			}
		pOld->pszDefaultCaptureName = pszName;

		if (pOld->pszTempCaptureName)
			free(pOld->pszTempCaptureName);
		pOld->pszTempCaptureName = (LPTSTR)0;
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	SaveCaptureFileHandle
 *
 * DESCRIPTION:
 *	This function is called to save whatever has been changed in the capture
 *	file handle out to the system file.
 *
 * PARAMETERS:
 *	hCapt    -- the capture handle
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code
 *
 */
int SaveCaptureFileHandle(HCAPTUREFILE hCapt)
	{
	STCAPTURE *pST;
	long lSize;

	pST = (STCAPTURE *)hCapt;
	assert(pST);

	if (pST != (STCAPTURE *)0)
		{
		/* Need to save the new value */
		if (pST->pszDefaultCaptureName)
			{
			lSize = StrCharGetByteCount(pST->pszDefaultCaptureName);
			if (lSize > 0)
				{
				lSize += 1;
				lSize *= sizeof(TCHAR);

				sfPutSessionItem(sessQuerySysFileHdl(pST->hSession),
								SFID_CPF_FILENAME,
								(unsigned long)lSize,
								pST->pszDefaultCaptureName);
				}
			}

		/* Need to save the new value */
		sfPutSessionItem(sessQuerySysFileHdl(pST->hSession),
						SFID_CPF_MODE,
						sizeof(int),
						&pST->nDefaultCaptureMode);

		/* Need to save the new value */
		sfPutSessionItem(sessQuerySysFileHdl(pST->hSession),
						SFID_CPF_FILE,
						sizeof(int),
						&pST->nDefaultFileMode);
		}

	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	cpfGetCaptureFilename
 *
 * DESCRIPTION:
 *	This function is used to get the default capture file name from the
 *	handle in order to load it into the dialog box.
 *
 * PARAMETERS:
 *	hCapt    -- the capture handle
 *	pszName  -- pointer to where to copy the file name
 *	nLen     -- size of the buffer
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code
 *
 */
int cpfGetCaptureFilename(HCAPTUREFILE hCapt,
						LPTSTR pszName,
						const int nLen)
	{
	STCAPTURE *pST;
	LPTSTR pszStr;

	pST = (STCAPTURE *)hCapt;
	assert(pST);

	if (pST != (STCAPTURE *)0)
		{
		if ((pszStr = pST->pszTempCaptureName) == (LPTSTR)0)
			{
			if ((pszStr = pST->pszDefaultCaptureName) == (LPTSTR)0)
				pszStr = pST->pszInternalCaptureName;
			}
		if (StrCharGetByteCount(pszStr) >= nLen)
			return CPF_SIZE_ERROR;
		StrCharCopyN(pszName, pszStr, nLen);
		}
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	cpfSetCaptureFilename
 *
 * DESCRIPTION:
 *	This function is called to set the name of the capture file.  If the mode
 *	flag is FALSE, only the temporary name is set.  If the mode file is TRUE,
 *	both the temporary and default names are set.
 *
 * PARAMETERS:
 *	hCapt    -- the capture handle
 *	pszName  -- the file name
 *	nMode    -- the mode flag, see above
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code
 *
 */
int cpfSetCaptureFilename(HCAPTUREFILE hCapt,
						LPCTSTR pszName,
						const int nMode)
	{
	int nRet = 0;
	int nLen;
	LPTSTR pszTemp;
	LPTSTR pszDefault;
	STCAPTURE *pST;

	pST = (STCAPTURE *)hCapt;
	assert(pST);

	if (pST != (STCAPTURE *)0)
		{
		nLen = StrCharGetByteCount(pszName) + 1;
		pszTemp = (LPTSTR)0;
		pszDefault = (LPTSTR)0;

		pszTemp = (LPTSTR)malloc((unsigned int)nLen * sizeof(TCHAR));
		if (pszTemp == (LPTSTR)0)
			{
			nRet = CPF_NO_MEMORY;
			goto SCFexit;
			}
		StrCharCopyN(pszTemp, pszName, nLen);
		if (nMode)
			{
			pszDefault = (LPTSTR)malloc((unsigned int)nLen * sizeof(TCHAR));
			if (pszDefault == (LPTSTR)0)
				{
				nRet = CPF_NO_MEMORY;
				goto SCFexit;
				}
			StrCharCopyN(pszDefault, pszName, nLen);
			}
		/* Got the memory that we need */
		if (pST->pszTempCaptureName)
			{
			free(pST->pszTempCaptureName);
			pST->pszTempCaptureName = NULL;
			}
		pST->pszTempCaptureName = pszTemp;
		if (nMode)
			{
			if (pST->pszDefaultCaptureName)
				{
				free(pST->pszDefaultCaptureName);
				pST->pszDefaultCaptureName = NULL;
				}
			pST->pszDefaultCaptureName = pszDefault;
			}
		}
	return nRet;

SCFexit:
	if (pszTemp)
		{
		free(pszTemp);
		pszTemp = NULL;
		}
	if (pszDefault)
		{
		free(pszDefault);
		pszDefault = NULL;
		}
	return nRet;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	cpfGetCaptureMode
 *
 * DESCRIPTION:
 *	This function returns the current default capture mode.
 *
 * PARAMETERS:
 *	hCapt    -- the capture handle
 *
 * RETURNS:
 *	The current capture mode.
 *
 */
int cpfGetCaptureMode(HCAPTUREFILE hCapt)
	{
	STCAPTURE *pST;

	pST = (STCAPTURE *)hCapt;
	assert(pST);

	if (pST != (STCAPTURE *)0)
		{
		return pST->nDefaultCaptureMode;
		}
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	cpfSetCaptureMode
 *
 * DESCRIPTION:
 *	This function changes the capture mode.  If the mode flag is set to FALSE,
 *	only the temporary mode is set.  If the mode flag is set to TRUE, both the
 *	temporary and default mode flags are set.
 *
 * PARAMETERS:
 *	hCapt    -- the capture handle
 *	nCaptMode -- the capture mode
 *	nModeFlag -- the mode flag
 *
 * RETURNS:
 *	ZERO of everything is OK, otherwise an error code
 *
 */
int cpfSetCaptureMode(HCAPTUREFILE hCapt,
						const int nCaptMode,
						const int nModeFlag)
	{
	STCAPTURE *pST;

	pST = (STCAPTURE *)hCapt;
	assert(pST);

	if (pST != (STCAPTURE *)0)
		{
		pST->nTempCaptureMode = nCaptMode;
		if (nModeFlag)
			pST->nDefaultCaptureMode = nCaptMode;
		}
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	cpfGetCaptureFileflag
 *
 * DESCRIPTION:
 *	This function is called to get the file save flags for capture to file.
 *
 * PARAMETERS:
 *	hCapt    -- the capture handle
 *
 * RETURNS:
 *	The file save flags.
 *
 */
int cpfGetCaptureFileflag(HCAPTUREFILE hCapt)
	{
	STCAPTURE *pST;

	pST = (STCAPTURE *)hCapt;
	assert(pST);

	if (pST != (STCAPTURE *)0)
		{
		return pST->nDefaultFileMode;
		}
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	cpfSetCaptureFileflag
 *
 * DESCRIPTION:
 *	This function is called to set the file save mode flag.  If the mode flag
 *	is set to FALSE, only the temporary value is changed, if the mode flag is
 *	TRUE, both the temporary and default values are changed.
 *
 * PARAMETERS:
 *	hCapt    -- the capture handle
 *	nSaveMode -- the new file save mode value
 *	nModeFlag -- the mode flag, see above
 *
 * RETURNS:
 *	ZERO if everything is OK, otherwise an error code.
 *
 */
int cpfSetCaptureFileflag(HCAPTUREFILE hCapt,
						const int nSaveMode,
						const int nModeFlag)
	{
	STCAPTURE *pST;

	pST = (STCAPTURE *)hCapt;
	assert(pST);

	if (pST != (STCAPTURE *)0)
		{
		pST->nTempFileMode = nSaveMode;
		if (nModeFlag)
			pST->nDefaultFileMode = nSaveMode;
		}
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	cpfGetCaptureState
 *
 * DESCRIPTION:
 *	This function returns a value that reflects the state of capturing.  It can
 *	be on, off, or paused.  See "capture.h" for the actual values.
 *
 * PARAMETERS:
 *	hCapt    -- the capture handle
 *
 * RETURNS:
 *	The current state of capturing.
 *
 */
int cpfGetCaptureState(HCAPTUREFILE hCapt)
	{
	STCAPTURE *pST;

	pST = (STCAPTURE *)hCapt;
	assert(pST);

	if (pST != (STCAPTURE *)0)
		{
		return pST->nState;
		}
	return 0;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	cpfSetCaptureState
 *
 * DESCRIPTION:
 *	This function changes the state of capturing.  It can turn it on, off,
 *	pause capturing or resume capturing.
 *
 * PARAMETERS:
 *	hCapt    -- the capture handle
 *	nState   -- the new state to change to
 *
 * RETURNS:
 *	The previous state of capturing.
 *
 */
int cpfSetCaptureState(HCAPTUREFILE hCapt, int nState)
	{
	int nOldState = 0;
	STCAPTURE *pST;
	LPTSTR pszStr;

	pST = (STCAPTURE *)hCapt;
	assert(pST);

	if (pST != (STCAPTURE *)0)
		{
		switch (nState)
			{
			case CPF_CAPTURE_ON:
				/* Open the capture file */
				if (pST->hCaptureFile)
					{
					/*
					 * We get here one of two ways.  The first and expected
					 * way is by selecting "Resume" from the menu.  This is
					 * not a problem.  the other way is that there is still
					 * a problem with the menus.  Go figure.
					 */
					break;
					}
				if ((pszStr = pST->pszTempCaptureName) == (LPTSTR)0)
					{
					if ((pszStr = pST->pszDefaultCaptureName) == (LPTSTR)0)
						pszStr = pST->pszInternalCaptureName;
					}
				switch (pST->nTempFileMode)
					{
					default:
					case CPF_FILE_OVERWRITE:
						pST->hCaptureFile = fio_open(pszStr,
													FIO_CREATE | FIO_WRITE);
						assert(pST->hCaptureFile);
						break;
					case CPF_FILE_APPEND:
						pST->hCaptureFile = fio_open(pszStr,
													FIO_WRITE | FIO_APPEND);
						assert(pST->hCaptureFile);
						break;
					case CPF_FILE_REN_SEQ:
						assert(TRUE);
						break;
					case CPF_FILE_REN_DATE:
						assert(TRUE);
						break;
					}
				break;
			case CPF_CAPTURE_OFF:
				/* Close the capture file */
				assert(pST->hCaptureFile);
				fio_close(pST->hCaptureFile);
				pST->hCaptureFile = NULL;
				break;
			default:
				break;
			}

		nOldState = pST->nState;
		pST->nState = nState;
		}
	return nOldState;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 */
HMENU cpfGetCaptureMenu(HCAPTUREFILE hCapt)
	{
	HMENU hRet = (HMENU)0;
	STCAPTURE *pST;

	pST = (STCAPTURE *)hCapt;
	assert(pST);

	if (pST != (STCAPTURE *)0)
		{
		// The SetMenuItemInfo() call will destroy this submenu whenever
		// its replaced by something else (like a plain menu item).  The
		// result was you could go into capture once, but the second time
		// you activated the menu it wouldn't load because the handle was
		// no longer valid.  So I moved the code to load the menu here. - mrw
		//
		if (!IsMenu(pST->hMenu))
			pST->hMenu = LoadMenu(glblQueryDllHinst(), TEXT("MenuCapture"));

		assert(pST->hMenu);
		hRet = pST->hMenu;
		}

	return hRet;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	CaptureChar
 *
 * DESCRIPTION:
 *	This function is called whenever the emulators have a character that might
 *	need to be capture.
 *
 * PARAMETERS:
 *	hCapt    -- the capture handle
 *	nFlags   -- capture flags (must match the capture state we are in)
 *	cData    -- the character to be captured
 *
 * RETURNS:
 *
 */
void CaptureChar(HCAPTUREFILE hCapt, int nFlags, ECHAR cData)
	{
	STCAPTURE *pST = (STCAPTURE *)hCapt;
	int nLen = 0;
	int i    = 0;
	TCHAR cChar[3];

	if (pST == NULL)
		{
		assert(pST);
		return;
		}

	/* Check the state */
	if (pST->nState == CPF_CAPTURE_OFF)
		return;
	if (pST->nState == CPF_CAPTURE_PAUSE)
		return;

	/* Check the file next */
	if (pST->hCaptureFile == NULL)
		return;

	/* Check the mode */
	if (pST->nTempCaptureMode != nFlags)
		return;

	DbgOutStr("Cc 0x%x %c (0x%x)\r\n", nFlags, cData, cData, 0,0);

	CnvrtECHARtoTCHAR(cChar, ARRAYSIZE(cChar), cData);

	/* Write out the character */
//	fio_putc(cChar, pST->hCaptureFile);
//	nLen = StrCharGetByteCount(cChar);
//	for (i = 0; i < nLen; i++)
// 		fio_putc(cChar[i], pST->hCaptureFile);

    fio_putc(cChar[0], pST->hCaptureFile);
    if (cChar[1])
        fio_putc(cChar[1], pST->hCaptureFile);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *	CaptureLine
 *
 * DESCRIPTION:
 *	This function is called whenever the emulators have a line that might need
 *	to be captured.
 *
 * PARAMETERS:
 *	hCapt    -- the capture handle
 *	nFlags   -- capture flags (must match the capture state we are in)
 *	pszStr   -- pointer to line to capture (sans <cr/lf>)
 *
 * RETURNS:
 *
 */
void CaptureLine(HCAPTUREFILE hCapt, int nFlags, ECHAR *achStr, int nLen)
	{
	STCAPTURE *pST = (STCAPTURE *)hCapt;
	LPTSTR pchEnd = NULL;
	TCHAR *pszStr = NULL;

	if (pST == NULL)
		{
		assert(pST);
		return;
		}

	/* Check the state */
	if (pST->nState == CPF_CAPTURE_OFF)
		return;
	if (pST->nState == CPF_CAPTURE_PAUSE)
		return;

	/* Check the file next */
	if (pST->hCaptureFile == NULL)
		return;

	/* Check the mode */
	if (pST->nTempCaptureMode != nFlags)
		return;


	// Allocate space assuming every character is double byte
	pszStr = (TCHAR *)malloc(((unsigned int)StrCharGetEcharLen(achStr) +
							  sizeof(ECHAR)) * sizeof(ECHAR));
	if (pszStr == NULL)
		{
		assert(FALSE);
		return;
		}

	CnvrtECHARtoMBCS(pszStr, ((unsigned long)StrCharGetEcharLen(achStr) + 1)
					* sizeof(ECHAR), achStr,
					StrCharGetEcharByteCount(achStr) + sizeof(ECHAR)); // mrw:5/17/95

	pchEnd = pszStr + (StrCharGetByteCount(pszStr) - 1);

	/* Write out the string */
	while (pszStr <= pchEnd)		
		fio_putc(*pszStr++, pST->hCaptureFile);

	free(pszStr);
	pszStr = NULL;

	fio_putc(TEXT('\r'), pST->hCaptureFile);
	fio_putc(TEXT('\n'), pST->hCaptureFile);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 * FUNCTION:
 *
 * DESCRIPTION:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\cloopout.c ===
/*	File: cloopout.c (created 12/28/93, JKH)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 5 $
 *	$Date: 7/08/02 6:39p $
 */
#include <windows.h>
#pragma hdrstop

// #define DEBUGSTR
#include "stdtyp.h"
#include "session.h"
#include <tdll\assert.h>
#include "mc.h"
#include "timers.h"
#include "file_msc.h"
#include "misc.h"
#include "tdll.h"
#include <term\res.h>
#include "htchar.h"
#include "cloop.h"
#include "cloop.hh"
#include "chars.h"

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopSend
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int CLoopSend
		(
		const HCLOOP	hCLoop,
			  void	   *pvData,
		const size_t	sztItems,
			  unsigned	uOptions)
	{
	ST_CLOOP	 * const pstCLoop = (ST_CLOOP *)hCLoop;
	int 		  fRetval = TRUE;
	ST_CLOOP_OUT *pstLast;
	ST_CLOOP_OUT *pstNew = NULL;
	size_t		  sztBytes;
	size_t		  sztAllocate;

	assert(pstCLoop);
	assert(pvData);

	if (!sztItems)
		return TRUE;

	EnterCriticalSection(&pstCLoop->csect);
	sztBytes = sztItems;
	if (bittest(uOptions, CLOOP_KEYS))
		sztBytes *= sizeof(KEY_T);

	// Notify the client that characters went out so the terminal can
	// do the appropriate tracking so user gets feedback about the
	// send operation, so there! - mrw

	NotifyClient(pstCLoop->hSession, (WORD)EVENT_CLOOP_SEND, 0);

	pstLast = pstCLoop->pstLastOutBlock;
	bitset(uOptions, CLOOP_CHARACTERS);

	// If new data is not in an allocated block and it will fit in the
	// block currently at the end of the chain, just add it in.
	if (!bittest(uOptions, CLOOP_ALLOCATED | CLOOP_SHARED) &&
			pstLast &&
			bittest(pstLast->uOptions, CLOOP_KEYS | CLOOP_CHARACTERS) ==
			bittest(uOptions, CLOOP_KEYS | CLOOP_CHARACTERS) &&
			sztBytes < (size_t)(pstLast->puchLimit - pstLast->puchHead))
		{
		// Copy data into existing block
		if (pstLast->puchHead == pstLast->puchTail)
			{
			// block is empty, reset pointers to beginning
			pstLast->puchHead = pstLast->puchTail = pstLast->puchData;
			}

        if (sztBytes)
            MemCopy(pstLast->puchHead, pvData, sztBytes);
		pstLast->puchHead += sztBytes;
		}

	else
		{
		// Couldn't put data into an existing block, try to add a new block
		// First create the block control structure
		if ((pstNew = CLoopNewOutBlock(pstCLoop, 0)) == NULL)
			{
			fRetval = FALSE;
			goto done;
			}

		pstNew->uOptions = uOptions;

		// Unless data is already in allocated memory that we can keep,
		// try to allocate memory for the new block
		if (!bittest(uOptions, CLOOP_ALLOCATED | CLOOP_SHARED))
			{
			sztAllocate = sztBytes;
			if (sztAllocate <= STD_BLOCKSIZE)
				{
				sztAllocate = STD_BLOCKSIZE;
				bitset(pstNew->uOptions, CLOOP_STDSIZE);
				}
			if ((pstNew->puchData = malloc(sztAllocate)) == NULL)
				{
				fRetval = FALSE;
				goto done;
				}
            if (sztBytes)
                MemCopy(pstNew->puchData, pvData, sztBytes);
			}
		else if (bittest(uOptions, CLOOP_SHARED))
			{
			// pvData actually contains a shared memory handle
			pstNew->hdlShared = (HGLOBAL)pvData;
			pstNew->puchData = GlobalLock(pstNew->hdlShared);
			sztAllocate = sztBytes;
			}
		else
			{
			// block was passed to us as allocated block that we now own.
			pstNew->puchData = pvData;
			sztAllocate = sztBytes;
			}

		pstNew->puchLimit = pstNew->puchData + sztAllocate;
		pstNew->puchHead = pstNew->puchData + sztBytes; // where data goes in
		pstNew->puchTail = pstNew->puchData; // where data comes out
		}

	done:
	if (!fRetval)
		{
		if (pstNew)
			{
			if (pstNew->puchData)
				{
				free(pstNew->puchData);
				pstNew->puchData = NULL;
				}
			free(pstNew);
			pstNew = NULL;
			}
		}
	else
		{
		pstCLoop->ulOutCount += sztItems;
		CLoopSndControl((HCLOOP)pstCLoop, CLOOP_RESUME, CLOOP_SB_NODATA);
		}
	LeaveCriticalSection(&pstCLoop->csect);
	return fRetval;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopSendTextFile
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
int CLoopSendTextFile(const HCLOOP hCLoop, TCHAR *pszFileName)
	{
	ST_CLOOP * const pstCLoop = (ST_CLOOP *)hCLoop;
	ST_CLOOP_OUT FAR *pstNew = NULL;
	int 			  fRetval = FALSE;
	unsigned long	  ulFileSize;
	size_t			  fileNameLen;

	assert(pstCLoop);
	assert(pszFileName);

	fileNameLen = (size_t)StrCharGetByteCount(pszFileName) + sizeof(TCHAR);

	EnterCriticalSection(&pstCLoop->csect);
	if (GetFileSizeFromName(pszFileName, &ulFileSize) && ulFileSize > 0)
		{
		if ((pstNew = CLoopNewOutBlock(pstCLoop, fileNameLen)) == NULL)
			goto done;		// leave fRetval FALSE

		pstNew->uOptions = CLOOP_TEXTFILE;
		StrCharCopyN(pstNew->puchData, pszFileName, fileNameLen);
		pstNew->ulBytes = ulFileSize;
		pstCLoop->ulOutCount += ulFileSize;

		// Set head and tail pointers even though they will not be directly
		//	used. When they are set to equal each other, the block will be
		//	removed from the chain
		pstNew->puchTail = pstNew->puchData;
		pstNew->puchHead = pstNew->puchData + 1;

		fRetval = TRUE;
		}

	done:
	if (!fRetval)
		{
		if (pstNew)
			{
			if (pstNew->puchData)
				{
				free(pstNew->puchData);
				pstNew->puchData = NULL;
				}
			free(pstNew);
			pstNew = NULL;
			}
		}
	else
		CLoopSndControl(hCLoop, CLOOP_RESUME, CLOOP_SB_NODATA);

	LeaveCriticalSection(&pstCLoop->csect);
	return fRetval;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopClearOutput
 *
 * DESCRIPTION:
 *	Clears all pending output from CLoop
 *
 * ARGUMENTS:
 *	pstCLoop -- The CLoop handle
 *
 * RETURNS:
 *	nothing
 */
void CLoopClearOutput(const HCLOOP hCLoop)
	{
	ST_CLOOP * const pstCLoop = (ST_CLOOP *)hCLoop;

	EnterCriticalSection(&pstCLoop->csect);
	pstCLoop->ulOutCount = 0L;

	//* CLoopTextDspStop(pstCLoop);
	pstCLoop->fTextDisplay = FALSE;
	while (pstCLoop->pstFirstOutBlock)
		CLoopRemoveFirstOutBlock(pstCLoop);
	//* ComSendClear(pstCLoop->hCom);
	CLoopSndControl(hCLoop, CLOOP_SUSPEND, CLOOP_SB_NODATA);
	LeaveCriticalSection(&pstCLoop->csect);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopGetOutputCount
 *
 * DESCRIPTION:
 *	Returns the number of characters queued for output
 *
 * ARGUMENTS:
 *	hCLoop -- The CLoop handle
 *
 * RETURNS:
 *	The number of characters queued for output
 */
unsigned long CLoopGetOutputCount(const HCLOOP hCLoop)
	{
	unsigned uCount;

	EnterCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	uCount = ((ST_CLOOP *)hCLoop)->ulOutCount;
	LeaveCriticalSection(&((ST_CLOOP *)hCLoop)->csect);
	return uCount;
	}


/* --- Internal routines --- */

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopGetNextOutput
 *
 * DESCRIPTION:
 *	Fetchs the next item from the output queue for transmission.
 *
 * ARGUMENTS:
 *	hCLoop -- The CLoop handle
 *	pkKey  -- Place to put the next item to be transmitted
 *
 * RETURNS:
 *	TRUE if there is data to be transmitted.
 */
int CLoopGetNextOutput(ST_CLOOP * const pstCLoop, KEY_T * const pkKey)
	{
	ST_CLOOP_OUT FAR *	pstBlock;
	int 				fRetval = FALSE;
	unsigned long		nBytesRead = 0L;
	KEY_T			   *pkGet;
	TCHAR				chFileChar;
	TCHAR				chChar;
	HWND				hwndDsp;
	CHAR				achBuf[2];

	assert(pstCLoop);
	assert(pkKey);				// Caller must provide pointer for result

	if (pstCLoop->keyHoldKey)
		{
		*pkKey = pstCLoop->keyHoldKey;
		pstCLoop->keyHoldKey = (KEY_T)0;
		fRetval = TRUE;
		}
	else if (pstCLoop->ulOutCount || pstCLoop->pstFirstOutBlock)
		{
		pstBlock = pstCLoop->pstFirstOutBlock;
		assert(pstBlock);	// should never be NULL while ulOutCount > 0
		// Skip any empty blocks (shouldn't be more than one)
		while (pstBlock->puchHead == pstBlock->puchTail)
			{
			CLoopRemoveFirstOutBlock(pstCLoop);
			pstBlock = pstCLoop->pstFirstOutBlock;
			assert(pstBlock);	// should never remove all blocks
			}

		if (bittest(pstBlock->uOptions, CLOOP_CHARACTERS))
			{
			if (bittest(pstBlock->uOptions, CLOOP_KEYS))
				{
				pkGet = (KEY_T *)pstBlock->puchTail;
				*pkKey = *pkGet++;
				pstBlock->puchTail = (TCHAR *)pkGet;
				--pstCLoop->ulOutCount;
				fRetval = TRUE;
				}
			else
				{
				chChar = *pstBlock->puchTail++;
				*pkKey = (KEY_T)chChar;
				--pstCLoop->ulOutCount;
				// We must strip the LF from CR-LF pairs. This data may come from
				//	the clipboard, in which case, line endings will be stored as
				//	CR-LF. Terminals normally send only a CR at line ends. If we
				//	DO need to send the LF, it will be added in the cloop output
				//	routines if the append LF option is set.
				if (chChar != TEXT('\n') ||
					(pstBlock->chLastChar != TEXT('\r') &&
					 pstBlock->chLastChar != (VK_RETURN | VIRTUAL_KEY)))
					{
					pstBlock->chLastChar = chChar;
					fRetval = TRUE;
					}
				}
			}

		else if (bittest(pstBlock->uOptions, CLOOP_OPENFILE))
			{
			//* TODO: this stuff will have to be expanded eventually to
			//	handle SBCS, DBCS and Unicode input files. For now, all
			//	text files are assumed to be SBCS.
			if (ReadFile(pstCLoop->hOutFile, achBuf, 1, &nBytesRead,
					(LPOVERLAPPED)0))
				{
				if (nBytesRead > 0)
					{
					//OemToCharBuff(achBuf, &chFileChar, 1);-  mrw:10/20/95
                    chFileChar = achBuf[0];  // mrw:10/20/95
					pstCLoop->ulSentSoFar += 1;
					*pkKey = (KEY_T)chFileChar;
					--pstBlock->ulBytes;
					--pstCLoop->ulOutCount;

					// We must strip the LF from CR-LF pairs. If line ends are
					//	set to CR-LF in the settings, an LF will be added back in
					//	later.
					if (chFileChar != TEXT('\n') ||
						(pstBlock->chLastChar != TEXT('\r') &&
						 pstBlock->chLastChar != (VK_RETURN | VIRTUAL_KEY)))
						{
						pstBlock->chLastChar = chFileChar;
						fRetval = TRUE;
						}
					}
				else
					{
					// When ReadFile returns TRUE but 0 chars. were read,
					// it indicates end of file.
					CloseHandle(pstCLoop->hOutFile);
					pstCLoop->hOutFile = (HANDLE *)0;
					pstBlock->puchTail = pstBlock->puchHead;
					}
				}
			else
				{
				// ReadFile returned an error
				//* TODO: display error message
				CloseHandle(pstCLoop->hOutFile);
				pstCLoop->hOutFile = (HANDLE *)0;
				pstBlock->puchTail = pstBlock->puchHead;
				// pstCLoop->ulOutCount -= pstBlock->ulBytes;
                pstCLoop->ulOutCount = 0;   //JMH 03-25-96
				}
			}
		else if (bittest(pstBlock->uOptions, CLOOP_TEXTFILE))
			{
			// New block with text file name, open file & start emptying
			pstCLoop->hOutFile = CreateFile(pstBlock->puchData,
					GENERIC_READ, FILE_SHARE_READ,
					(LPSECURITY_ATTRIBUTES)0, OPEN_EXISTING,
					FILE_FLAG_SEQUENTIAL_SCAN, (HANDLE)0);
			if (pstCLoop->hOutFile == INVALID_HANDLE_VALUE)
				{
				//* Display file error
                pstCLoop->hOutFile = (HANDLE *)0;
				pstBlock->puchTail = pstBlock->puchHead; // Remove from queue
                pstCLoop->ulOutCount = 0;
                PostMessage(sessQueryHwnd(pstCLoop->hSession),
                    WM_ERROR_MSG, (WPARAM) IDS_ER_OPEN_FAILED, 0);
				}
			else
				{
				pstCLoop->ulTotalSend += pstBlock->ulBytes;
				//* CLoopTextDspFilename(pstCLoop, (LPTSTR)pstBlock->puchData);
				bitset(pstBlock->uOptions, CLOOP_OPENFILE);
				}
			}
		else if (bittest(pstBlock->uOptions, CLOOP_TEXTDSP))
			{
			MemCopy(&hwndDsp, pstBlock->puchData, sizeof(hwndDsp));
			//* CLoopDoTextDsp(pstCLoop, hwndDsp);
			// Set puchHead == puchTail to cause this block to be dropped
			pstBlock->puchHead = pstBlock->puchTail = pstBlock->puchData;
			}
		if (pstCLoop->ulOutCount == 0 && !pstBlock->pstNext)
            {
			CLoopSndControl((HCLOOP)pstCLoop, CLOOP_SUSPEND, CLOOP_SB_NODATA);

            // mrw:3/11/96 - fixes send files being locked open after done.
            //
            if (pstCLoop->hOutFile)
                {
                CloseHandle(pstCLoop->hOutFile);
                pstCLoop->hOutFile = (HANDLE *)0;
                pstBlock->puchTail = pstBlock->puchHead;
                }
            }
		}

	if (fRetval)
		{
		if (*pkKey == TEXT('\r') && pstCLoop->keyLastKey == TEXT('\r') &&
				pstCLoop->stWorkSettings.fExpandBlankLines)
			{
			pstCLoop->keyHoldKey = *pkKey;	// this will be returned next call
			*pkKey = TEXT(' '); 		  // add space to expand blank line
			}
		pstCLoop->keyLastKey = *pkKey;
		}

	return fRetval;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopNewOutBlock
 *
 * DESCRIPTION:
 *	Internal routine to allocate and initialize a control block for the
 *	output chain.
 *
 * ARGUMENTS:
 *	siztData -- If non-zero, the routine will attempt to allocate memory
 *				of the specfied size and assign it to the puchData member.
 *				If zero the puchData member is set to NULL.
 *
 * RETURNS:
 *	Pointer to a new control block for the output chain
 */
ST_CLOOP_OUT *CLoopNewOutBlock(ST_CLOOP *pstCLoop, const size_t sizetData)
	{
	ST_CLOOP_OUT *pstNew = NULL;

	if ((pstNew = (ST_CLOOP_OUT *)malloc(sizeof(*pstNew))) != NULL)
		{
		pstNew->pstNext    =  NULL;
		pstNew->uOptions   =  0;
		pstNew->hdlShared  =  (HGLOBAL)0;
		pstNew->puchData   =  NULL;
		pstNew->puchLimit  =  NULL;
		pstNew->puchHead   =  NULL;
		pstNew->puchTail   =  NULL;
		pstNew->ulBytes    =  0L;
		pstNew->chLastChar = 0;

		if (sizetData > 0)
			{
			if ((pstNew->puchData = (TCHAR *)malloc(sizetData)) == NULL)
				{
				free(pstNew);
				pstNew = NULL;
				}
			}
		}
	if (!pstNew)
		{
		//* utilReportError(pstCLoop->hSession, RE_ERROR | RE_OK, NM_NEED_MEM,
		//* 	   strldGet(mGetStrldHdl(pstCLoop->hSession), NM_XFER_DISPLAY));
		}
	else
		{
		// link new block into chain
		if (pstCLoop->pstLastOutBlock)
			pstCLoop->pstLastOutBlock->pstNext = pstNew;
		else
			{
			assert(!pstCLoop->pstFirstOutBlock);
			pstCLoop->pstFirstOutBlock = pstNew;
			}
		pstCLoop->pstLastOutBlock = pstNew;
		}

	return pstNew;
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopRemoveFirstOutBlock
 *
 * DESCRIPTION:
 *
 *
 * ARGUMENTS:
 *
 *
 * RETURNS:
 *
 */
void CLoopRemoveFirstOutBlock(ST_CLOOP * const pstCLoop)
	{
	ST_CLOOP_OUT *pstBlock;

	pstBlock = pstCLoop->pstFirstOutBlock;
	if (pstBlock)
		{
		// link around block to be removed
		pstCLoop->pstFirstOutBlock = pstBlock->pstNext;
		if (!pstCLoop->pstFirstOutBlock)
			{
			// empty list
			assert(pstCLoop->pstLastOutBlock == pstBlock);
			pstCLoop->pstLastOutBlock = (ST_CLOOP_OUT *)0;
			}

		// free storage memory
		if (bittest(pstBlock->uOptions, CLOOP_SHARED))
			{
			GlobalUnlock(pstBlock->hdlShared);
			GlobalFree(pstBlock->hdlShared);
			}
		else
			{
			free(pstBlock->puchData);
			pstBlock->puchData = NULL;
			}

		// Now free the block control structure
		free(pstBlock);
		pstBlock = NULL;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\cloop.hh ===
/*	File: cloop.hh (created 12/27/93, JKH)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:39p $
 */

// These constants are used to turn on various types of debug display
//#define DBG_NORMAL
//#define DBG_YIELD
//#define DBG_OUT

#if defined(DBG_NORMAL)
	#define DEBUGSTR
	#define DBGOUT_NORMAL(s,a1,a2,a3,a4,a5) DbgOutStr(s,a1,a2,a3,a4,a5)
#else
	#define DBGOUT_NORMAL(s,a1,a2,a3,a4,a5)
#endif

#if defined(DBG_YIELD)
	#define DEBUGSTR
	#define DBGOUT_YIELD(s,a1,a2,a3,a4,a5) DbgOutStr(s,a1,a2,a3,a4,a5)
#else
	#define DBGOUT_YIELD(s,a1,a2,a3,a4,a5)
#endif

/* --- Constants --- */

#define STD_BLOCKSIZE 512
#define CLOOP_TRACKING_DELAY 1000L

#define SF_CLOOP_SENDCRLF		0x200
#define SF_CLOOP_EXPAND 		0x201
#define SF_CLOOP_LOCALECHO		0x202
#define SF_CLOOP_LINEWAIT		0x203
#define SF_CLOOP_WAITCHAR		0x204
#define SF_CLOOP_EXTABSOUT		0x205
#define SF_CLOOP_TABSIZEOUT 	0x206
#define SF_CLOOP_LINEDELAY		0x207
#define SF_CLOOP_CHARDELAY		0x208
#define SF_CLOOP_ADDLF			0x209
#define SF_CLOOP_ASCII7 		0x20A
#define SF_CLOOP_ECHOPLEX		0x20B

//Removed.	Moved to emulator settings.  0x20C now available.
//#define SF_CLOOP_WRAPLINES	  0x20C

#define SF_CLOOP_SHOWHEX		0x20D
#define SF_CLOOP_TABSIZEIN		0x20E
#define SF_CLOOP_DBCS		    0x20F

// Values for the usOptions field in ST_CLOOP_OUT
// The first three are defined in cloop.h because they can be
//	used in the options arguments of CLoopSend()
// #define CLOOP_KEYS			0x0001
// #define CLOOP_ALLOCATED		0x0002
// #define CLOOP_SHARED 		0x0004

#define CLOOP_CHARACTERS	 0x0008
#define CLOOP_TEXTFILE		 0x0010
#define CLOOP_OPENFILE		 0x0020
#define CLOOP_TEXTDSP		 0x0040
#define CLOOP_STDSIZE		 0x8000


// offsets into event array for blocking
#define EVENT_CONTROL	0
#define EVENT_RCV		1
#define EVENT_SEND		2

/* --- Typedefs --- */

// Support for queued output routines
typedef struct s_cloop_out ST_CLOOP_OUT;
typedef struct s_func_chain ST_FCHAIN;
typedef struct s_cloop_settings ST_CLOOP_SETTINGS;
typedef struct s_cloop ST_CLOOP;


/* --- Structure definitions --- */

struct s_cloop_out
	{
	ST_CLOOP_OUT *pstNext;
	unsigned	  uOptions; 	  // keys/chars? allocated? shared?
	HGLOBAL 	  hdlShared;	   // shared mem handle
	TCHAR		 *puchData; 	   // address of data block
	TCHAR		 *puchLimit;	   // first addr. past data block
	TCHAR		 *puchHead; 	   // where data is added to block
	TCHAR		 *puchTail; 	   // where data is removed from block
	unsigned long ulBytes;		   // size of file being sent
	TCHAR		  chLastChar;	   // last byte out
	};

struct s_func_chain
	{
	ST_FCHAIN *pstNext; 	// pointer to next in chain
	ST_FCHAIN *pstPrior;	// pointer to prior in chain
	ST_CLOOP  *pstParent;	// handle of owning CLoop
	CHAINFUNC  pfFunc;		// function to call
	void	  *pvUserData;	// data supplied by caller when registered
	};


// Structure to hold user-settable values
struct s_cloop_settings
	{
	//	for sending:
	int 	  fSendCRLF;				// TRUE to add LF to CR when sent
	int 	  fExpandBlankLines;		// TRUE to expand blank lines with space
	int 	  fLocalEcho;				// TRUE to echo typed chars.
	int 	  fLineWait;				// TRUE to wait for mcWaitChar
	TCHAR	  chWaitChar;				// Char to wait for after sending line
	int 	  fExpandTabsOut;
	int 	  nTabSizeOut;				// Default outgoing tab alignment
	int 	  nLineDelay;				// Delay in msecs. after each line
	int 	  nCharDelay;				// Delay in msecs. after each char.

	//	for receiving
	int 	  fAddLF;					// TRUE to append LF to rcvd. CR
	int 	  fASCII7;					// TRUE to strip high bit on input
	int 	  fEchoplex;				// TRUE to echo rmt. chars.
	int 	  fShowHex; 				// TRUE to show hex val. for ctrl chars.
	int 	  nTabSizeIn;				// Default incoming tab alignment
	};


// CLOOP Handle definition structure
struct s_cloop
	{
	HSESSION	  hSession; 			// Parent session
	HEMU		  hEmu; 				// Emulator handle for quick ref.
	HCOM		  hCom; 				// Com handle for quick ref.
	unsigned	  afControl;			// Bits that control CLoop actions
	unsigned	  afRcvBlocked; 		// Bits to inhibit receiving
	unsigned	  afSndBlocked; 		// Bits to inhibit sending
	int 		  nRcvBlkCnt;			// Script receive block count
	int 		  fRcvBlkOverride;		// Override for receive block count
	int 		  fSuppressDsp; 		// TRUE to suppress display of data
	int 		  nPriorityCount;		// Keeps track of how often we yield

	// Receive delay control to implement cursor tracking
	int 		  fDataReceived;		// TRUE when new data received
	HTIMER		  htimerRcvDelay;		// Timer to catch delay in data
	HTIMER		  htimerCharDelay;		// Timer for char&line delays
	TIMERCALLBACK pfRcvDelay;			// Call back when rcv. delay timer fires
	TIMERCALLBACK pfCharDelay;			// Call back when char delay timer fires

	// send control
	ST_CLOOP_OUT *pstFirstOutBlock; 	// End of output chain to send from
	ST_CLOOP_OUT *pstLastOutBlock;		// End of output chain to add to
	unsigned long ulOutCount;			// # of chars or keys awaiting output
	HANDLE		  hOutFile; 			// handle of file being sent
	KEY_T		  keyLastKey;
	KEY_T		  keyHoldKey;

	// Send display window control
	int 		  fTextDisplay;
	HWND		  hwndDsp;
	HGLOBAL 	  hDisplayBlock;		// Memory from GlobalAlloc for DDE link
	unsigned long ulTotalSend;
	unsigned long ulSentSoFar;
	HTIMER		  hTimerTextDsp;
	long		  lTimeStarted;
	TIMERCALLBACK pfTimerProc;

	// function chaining
	ST_FCHAIN	 *pstRmtChain;			// Chain of functions to call with
	ST_FCHAIN	 *pstRmtChainNext;		//	with each input char. from rmt.
	int 		  fRmtChain;			// Quick test if anything is in chain

	// User settings
	ST_CLOOP_SETTINGS stOrigSettings;	// Settings as stored in file
	ST_CLOOP_SETTINGS stWorkSettings;	// Settings in current use

	// for learning
	LPVOID	  lpLearn;					// A generic handle

	// Translation table pointers
	TCHAR		 *panFltrIn;			// Translation table - incoming data
	TCHAR		 *panFltrOut;			// Translation table - outgoing data
	TCHAR		 *panFltrInHold;		// Holding place for the pointer
	TCHAR		 *panFltrOutHold;		// Holding place for the pointer

	// Engine thread handle
	HANDLE		  hEngineThread;

	// Synchronization objects
	CRITICAL_SECTION csect;
	HANDLE		  ahEvents[3];			// 0=loop control,
										// 1=receive control
										// 2=send control
	// added for MBCS input support
	int			 fDoMBCS;				// Enables MBCS processing
	TCHAR		 cLeadByte;				// If this is non-zero, then the last
										// character was a lead byte and we are
										// building a multi-byte character
	TCHAR		 cLocalEchoLeadByte;	// Ditto
	};




/* --- Internal function prototypes --- */

DWORD WINAPI CLoop(LPVOID pvData);
void CLoopCharIn(ST_CLOOP *pstCLoop, ECHAR chIn);
void CALLBACK CLoopRcvDelayProc(void *pvData, long lSince);
void CALLBACK CLoopCharDelayProc(void *pvData, long lSince);
int 		  CLoopGetNextOutput(ST_CLOOP * const pstCLoop, KEY_T * const pkKey);
ST_CLOOP_OUT *CLoopNewOutBlock(ST_CLOOP *pstCLoop, const size_t sizetData);
void		  CLoopRemoveFirstOutBlock(ST_CLOOP * const pstCLoop);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\cloopctl.c ===
/*	File: cloopctl.c (created 12/16/93, JKH)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 12 $
 *	$Date: 5/01/02 1:00p $
 */
#include <windows.h>
#pragma hdrstop

#include <time.h>

// #define DEBUGSTR
#include "stdtyp.h"
#include "session.h"
#include "timers.h"
#include "com.h"
#include "mc.h"
#include "cnct.h"
#include "cloop.h"
#include "cloop.hh"
#include "htchar.h"
#include <tdll\assert.h>


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopCreateHandle
 *
 * DESCRIPTION:
 *	Creates handle for use of com loop routines. This function assumes that
 *	the emulator and com handles have already been created and stored in the
 *	session handle when it is called.
 *
 * ARGUMENTS:
 *	hSession -- Session handle
 *
 * RETURNS:
 *	A handle to be used in all other CLoop calls or NULL if unsuccessful
 */
HCLOOP CLoopCreateHandle(const HSESSION hSession)
	{
	ST_CLOOP *pstCLoop = (ST_CLOOP *)0;
	unsigned  ix;
	int 	  fSuccess = TRUE;

	pstCLoop = malloc(sizeof(*pstCLoop));
	if (!pstCLoop)
		fSuccess = FALSE;
	else
		{
		// Initialize structure
		memset(pstCLoop, 0, sizeof(ST_CLOOP));

		pstCLoop->hSession			= hSession;
		pstCLoop->hEmu				= sessQueryEmuHdl(hSession);
		pstCLoop->hCom				= sessQueryComHdl(hSession);
		pstCLoop->afControl 		= 0;
		pstCLoop->afRcvBlocked		= 0;
		pstCLoop->afSndBlocked		= CLOOP_SB_NODATA;
		pstCLoop->nRcvBlkCnt		= 0;
		pstCLoop->fRcvBlkOverride	= FALSE;
		pstCLoop->fSuppressDsp		= FALSE;
		pstCLoop->fDataReceived 	= FALSE;
		pstCLoop->htimerRcvDelay	= (HTIMER)0;
		pstCLoop->pfRcvDelay		= CLoopRcvDelayProc;
		pstCLoop->pfCharDelay		= CLoopCharDelayProc;
		pstCLoop->pstFirstOutBlock	= NULL;
		pstCLoop->pstLastOutBlock	= NULL;
		pstCLoop->ulOutCount		= 0L;
		pstCLoop->hOutFile			= (HANDLE)0;
		pstCLoop->keyLastKey		= (KEY_T)0;
		pstCLoop->keyHoldKey		= (KEY_T)0;
		pstCLoop->pstRmtChain		= NULL;
		pstCLoop->pstRmtChainNext	= NULL;
		pstCLoop->fRmtChain 		= FALSE;
		pstCLoop->fTextDisplay		= FALSE;
		pstCLoop->hDisplayBlock		= (HANDLE)0;

		// Set default user settings
		CLoopInitHdl((HCLOOP)pstCLoop);

		pstCLoop->lpLearn			= (LPVOID)0;

		for (ix = 0; ix < DIM(pstCLoop->ahEvents); ++ix)
			pstCLoop->ahEvents[ix] = (HANDLE)0;
		pstCLoop->hEngineThread = (HANDLE)0;

		pstCLoop->fDoMBCS			= FALSE;
		pstCLoop->cLeadByte			= 0;
		pstCLoop->cLocalEchoLeadByte= 0;
#if defined(CHAR_MIXED)
		// Added for debugging
		pstCLoop->fDoMBCS			= TRUE;
#endif

		// Create synchronization objects
		InitializeCriticalSection(&pstCLoop->csect);
		}

	if (!fSuccess)
		CLoopDestroyHandle((HCLOOP *)&pstCLoop);

	DBGOUT_NORMAL("CLoopCreateHandle(%lX) returned %lX\r\n",
			hSession,  pstCLoop, 0, 0, 0);
	return (HCLOOP)pstCLoop;
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopDestroyHandle
 *
 * DESCRIPTION:
 *	Destroys a handle created by CLoopCreateHandle and sets the storage
 *	variable to NULL;
 *
 * ARGUMENTS:
 *	ppstCLoop -- address of a variable holding a CLoop Handle
 *
 * RETURNS:
 *	nothing
 */
void CLoopDestroyHandle(HCLOOP * const ppstCLoop)
	{
	ST_CLOOP *pstCLoop;

	assert(ppstCLoop);

	pstCLoop = (ST_CLOOP *)*ppstCLoop;

	if (pstCLoop)
		{
		CLoopDeactivate((HCLOOP)pstCLoop);

		DeleteCriticalSection(&pstCLoop->csect);
		free(pstCLoop);
		pstCLoop = NULL;
		}

	*ppstCLoop = (HCLOOP)0;
	DBGOUT_NORMAL("CLoopDestroyHandle(l%X)\r\n", pstCLoop, 0,0,0,0);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CLoopActivate
 *
 * DESCRIPTION:
 *	Prepares cloop handle for actual use by starting its thread.
 *
 * ARGUMENTS:
 *	pstCLoop -- CLoop handle returned from CLoopCreateHandle
 *
 * RETURNS:
 *	TRUE if thread was started, FALSE otherwise
 */
int CLoopActivate(const HCLOOP hCLoop)
	{
	int 	  fSuccess = TRUE;
	ST_CLOOP *pstCLoop = (ST_CLOOP *)hCLoop;
	unsigned  ix;
	DWORD	  dwThreadId;

	// Store these in handle for fast access
	pstCLoop->hEmu = sessQueryEmuHdl(pstCLoop->hSession);
	pstCLoop->hCom = sessQueryComHdl(pstCLoop->hSession);

	for (ix = 0; ix < DIM(pstCLoop->ahEvents); ++ix)
		{
		pstCLoop->ahEvents[ix] = CreateEvent(NULL,
											 TRUE,	// must be manually reset
											 FALSE,	// create unsignalled
											 NULL);	// unnamed
		if (pstCLoop->ahEvents[ix] == NULL)
			{
			fSuccess = FALSE;
			//
			// Make sure to initialize the rest of the event handles to NULL;
			//
			for (++ix; ix < DIM(pstCLoop->ahEvents); ++ix)
				{
				pstCLoop->ahEvents[ix] = NULL;
				}
			}
		}

	if (fSuccess)
		{
		// Start the thread to handle cloop's responsibilities
		// (Gentleprograms, start your engines
		EnterCriticalSection(&pstCLoop->csect);

		pstCLoop->hEngineThread = CreateThread(
				(LPSECURITY_ATTRIBUTES)0,
				4096,
				(LPTHREAD_START_ROUTINE)CLoop,
				(LPVOID)pstCLoop,
				0,
				&dwThreadId);


		if (!pstCLoop->hEngineThread)
			fSuccess = FALSE;
#if 0   //jmh 07-10-96
		else
			SetThreadPriority(pstCLoop->hEngineThread,
					THREAD_PRIORITY_HIGHEST);
#endif  // 0

		LeaveCriticalSection(&pstCLoop->csect);
		}
	return fSuccess;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION:
 *	CLoopDeactivate
 *
 * DESCRIPTION:
 *	Shuts down cloop but does not destroy the handle
 *
 * ARGUMENTS:
 *	pstCLoop -- CLoop handle returned from CLoopCreateHandle
 *
 * RETURNS:
 *	nothing
 */
void CLoopDeactivate(const HCLOOP hCLoop)
	{
	ST_CLOOP *pstCLoop = (ST_CLOOP *)hCLoop;
	unsigned  ix;

	if (pstCLoop)
		{
		// This next call should cause the cloop thread to exit
		// Don't enter critical section to do this, since thread won't
		//	be able to exit
		if (pstCLoop->hEngineThread)
			{
			//JMH 05-28-96 CLoop was blowing up when no phone number was
			// provided, and you exited, answering no to the save prompt.
			// Suspending receive before terminating the thread fixed it.
			//
			CLoopRcvControl((HCLOOP)pstCLoop, CLOOP_SUSPEND, CLOOP_RB_INACTIVE);
			CLoopControl((HCLOOP)pstCLoop, CLOOP_SET, CLOOP_TERMINATE);

			// Wait for the engine thread to exit
			if (WaitForSingleObject(pstCLoop->hEngineThread, 0) == WAIT_OBJECT_0)
				{
				CloseHandle(pstCLoop->hEngineThread);
				}
            else if (WaitForSingleObject(pstCLoop->hEngineThread, 10000) == WAIT_TIMEOUT)
				{
				TerminateThread(pstCLoop->hEngineThread, 0);
				CloseHandle(pstCLoop->hEngineThread);
				}

			pstCLoop->hEngineThread = (HANDLE)0;
			}

		for (ix = 0; ix < DIM(pstCLoop->ahEvents); ++ix)
			{
			if (pstCLoop->ahEvents[ix])
				{
				CloseHandle(pstCLoop->ahEvents[ix]);
				pstCLoop->ahEvents[ix] = INVALID_HANDLE_VALUE;
				}
			}
		}
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopReset
 *
 * DESCRIPTION:
 *	Initializes the cloop routines for a new call. This is not really
 *	necessary prior to the first connection, but prevents left-over flags,
 *	buffers and such from one connection from affecting later connections.
 *
 * ARGUMENTS:
 *	pstCLoop -- CLoop handle returned from CLoopCreateHandle
 *
 * RETURNS:
 *	nothing
 */
void CLoopReset(const HCLOOP hCLoop)
	{
	ST_CLOOP *pstCLoop = (ST_CLOOP *)hCLoop;

	pstCLoop->afControl = 0;
	pstCLoop->afRcvBlocked = 0;
	pstCLoop->afSndBlocked = CLOOP_SB_NODATA;
	CLoopClearOutput((HCLOOP)pstCLoop);
	}



/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopRcvControl
 *
 * DESCRIPTION:
 *	Used to suspend and resume receiving in the CLoop routines. Can be
 *	called from Client or Wudge. Requests can be made to suspend or resume
 *	receiving for any of several reasons. Receiving can be suspended for
 *	more than one reason at a time. It will not resume until all reasons
 *	have been cleared.
 *
 * ARGUMENTS:
 *	hCLoop -- CLoop handle returned from CLoopCreateHandle
 *	iAction -- One of CLOOP_SUSPEND or CLOOP_RESUME
 *	iReason -- Reason for action as defined in cloop.h
 *				Ex.: CLOOP_RB_NODATA,  CLOOP_RB_INACTIVE
 *					 CLOOP_RB_SCRLOCK, CLOOP_RB_SCRIPT
 *
 * RETURNS:
 *	nothing
 */
void CLoopRcvControl(const HCLOOP hCLoop,
					 const unsigned uAction,
					 const unsigned uReason)
	{
	ST_CLOOP * const pstCLoop = (ST_CLOOP *)hCLoop;

	assert(uAction == CLOOP_SUSPEND || uAction == CLOOP_RESUME);

	EnterCriticalSection(&pstCLoop->csect);
	if (uReason == CLOOP_RB_SCRIPT)
		{
		/*
		 * Scripts work a little bit different
		 */
		// DbgOutStr("CLOOP_RB_SCRIPT %d", pstCLoop->nRcvBlkCnt, 0,0,0,0);
		switch (uAction)
			{
		default:
			break;

		case CLOOP_SUSPEND:
			pstCLoop->nRcvBlkCnt += 1;
			break;

		case CLOOP_RESUME:
			pstCLoop->nRcvBlkCnt -= 1;

			// There used to be code to prevent this value from going neg.
			// but we must allow this to go negative so that cleanup
			//	 can occur when we abort within an API call.
			break;
			}
		// DbgOutStr(" %d\r\n", pstCLoop->nRcvBlkCnt, 0,0,0,0);

		if (pstCLoop->fRcvBlkOverride == FALSE)
			{
			/*
			 * If someone is overriding us, let them restore the bits
			 */
			if (pstCLoop->nRcvBlkCnt > 0)
				{
				bitset(pstCLoop->afRcvBlocked, CLOOP_RB_SCRIPT);
				}
			else
				{
				bitclear(pstCLoop->afRcvBlocked, CLOOP_RB_SCRIPT);
				}
			}
		}
	else
		{
		if (uAction == CLOOP_SUSPEND)
			bitset(pstCLoop->afRcvBlocked, uReason);
		else if (uAction == CLOOP_RESUME)
			bitclear(pstCLoop->afRcvBlocked, uReason);
		}

	DBGOUT_NORMAL("CLoopRcvControl(%08lx):%04X (fRcvBlkOverride=%d, nRcvBlkCnt=%d)\r\n",
			pstCLoop, pstCLoop->afRcvBlocked, pstCLoop->fRcvBlkOverride,
			pstCLoop->nRcvBlkCnt,0);

	if (pstCLoop->afRcvBlocked)
		ResetEvent(pstCLoop->ahEvents[EVENT_RCV]);
	else
		SetEvent(pstCLoop->ahEvents[EVENT_RCV]);

	LeaveCriticalSection(&pstCLoop->csect);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopOverrideControl
 *
 * DESCRIPTION:
 *	This function can be called internally from the engine in order to
 *	override the CLoopRcvControl \CLOOP_RB_SCRIPT blocking state.  It is
 *	intended to be used during a connection process, when the connection
 *	stuff needs to see the data coming in.
 *
 * ARGUEMENTS:
 *	hCLoop	  -- CLoop handle returned from CLoopCreateHandle
 *	fOverride	-- TRUE to override, FALSE to restore things
 *
 * RETURNS:
 *	Nothing.
 */
void CLoopOverrideControl(const HCLOOP hCLoop, const int fOverride)
	{
	ST_CLOOP * const pstCLoop = (ST_CLOOP *)hCLoop;

	EnterCriticalSection(&pstCLoop->csect);
	if (fOverride)
		{
		pstCLoop->fRcvBlkOverride = TRUE;

		if (pstCLoop->nRcvBlkCnt > 0)
			{
			bitclear(pstCLoop->afRcvBlocked, CLOOP_RB_SCRIPT);
			if (!pstCLoop->afRcvBlocked)
				SetEvent(pstCLoop->ahEvents[EVENT_RCV]);
			}
		}
	else
		{
		pstCLoop->fRcvBlkOverride = FALSE;

		if (pstCLoop->nRcvBlkCnt > 0)
			{
			bitset(pstCLoop->afRcvBlocked, CLOOP_RB_SCRIPT);
			ResetEvent(pstCLoop->ahEvents[EVENT_RCV]);
			}
		}

	LeaveCriticalSection(&pstCLoop->csect);
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopSndControl
 *
 * DESCRIPTION:
 *	Used to suspend and resume sending from the CLoop routines.
 *	Requests can be made to suspend or resume sending for any of several
 *	reasons. Sending can be suspended for more than one reason at a time.
 *	It will not resume until all reasons have been cleared.
 *
 * ARGUMENTS:
 *	hCLoop -- CLoop handle returned from CLoopCreateHandle
 *	uAction -- One of CLOOP_SUSPEND or CLOOP_RESUME
 *	uReason -- Reason for action as defined in cloop.h
 *				Ex.: CLOOP_SB_NODATA,  CLOOP_SB_INACTIVE
 *					 CLOOP_SB_SCRLOCK, CLOOP_SB_LINEWAIT
 *
 * RETURNS:
 *	nothing
 */
void CLoopSndControl(const HCLOOP hCLoop,
					 const unsigned uAction,
					 const unsigned uReason)
	{
	ST_CLOOP * const pstCLoop = (ST_CLOOP *)hCLoop;

	assert(uAction == CLOOP_SUSPEND || uAction == CLOOP_RESUME);
	DbgOutStr("CLoopSndControl(%x, %x)\r\n", uAction, uReason, 0,0,0);

	EnterCriticalSection(&pstCLoop->csect);

	if (uAction == CLOOP_SUSPEND)
		{
		if (!pstCLoop->afSndBlocked)
			{
			DbgOutStr("Resetting EVENT_SEND (0x%x)\r\n", 0,0,0,0,0);
			ResetEvent(pstCLoop->ahEvents[EVENT_SEND]);
			}
		bitset(pstCLoop->afSndBlocked, uReason);
		}
	else if (uAction == CLOOP_RESUME)
		{
		// Allow this bit to be reset
		//
		if (bittest(uReason, CLOOP_SB_CNCTDRV))
			bitclear(pstCLoop->afSndBlocked, CLOOP_SB_CNCTDRV);

		// Only do this if we're not in the process of connecting
		//
		if (! bittest(pstCLoop->afSndBlocked, CLOOP_SB_CNCTDRV))
			{
			bitclear(pstCLoop->afSndBlocked, uReason);

			// If sending is being resumed because new data has arrived,
			// make sure we're connected. If not, send off a message to
			// try to connect without dialing
			if (bittest(uReason, CLOOP_SB_NODATA))
				{
				if (cnctQueryStatus(sessQueryCnctHdl(pstCLoop->hSession)) ==
					CNCT_STATUS_FALSE)
					{
					bitset(pstCLoop->afSndBlocked, CLOOP_SB_UNCONNECTED);
					}

				if (bittest(pstCLoop->afSndBlocked, CLOOP_SB_UNCONNECTED))
					{
					NotifyClient(pstCLoop->hSession, (int) EVENT_PORTONLY_OPEN, 0);
					}
				}
			}

		if (!pstCLoop->afSndBlocked)
			{
			DbgOutStr("Setting EVENT_SEND\r\n", 0,0,0,0,0);
			SetEvent(pstCLoop->ahEvents[EVENT_SEND]);
			}
		}

	LeaveCriticalSection(&pstCLoop->csect);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopControl
 *
 * DESCRIPTION:
 *	Used to control the action of the CLoop engine.
 *	The CLoop engine normally processes any characters
 *	received from the remote system and any characters or keys queued for
 *	output. This call can be used to alter the normal flow of data for
 *	special needs such as file transfers and scripts.
 *
 * ARGUMENTS:
 *	hCLoop -- Handle returned from call to CLoopCreateHandle
 *	uAction -- CLOOP_SET or CLOOP_CLEAR to set or clear control bits
 *	uReason -- Value indicating what is being controlled. Values are
 *				listed in cloop.h
 *				Ex:CLOOP_TERMINATE CLOOP_OUTPUT_WAITING CLOOP_TRANSFER_READY
 *
 * RETURNS:
 *	nothing
 */
void CLoopControl(
		const HCLOOP hCLoop,
			  unsigned uAction,
			  unsigned uReason)
	{
    ST_CLOOP * const pstCLoop = (ST_CLOOP *)hCLoop;

    if ( !pstCLoop )
        return; //MPT:10SEP98 to prevent an access violation

	EnterCriticalSection(&pstCLoop->csect);

    if (bittest(uReason, CLOOP_MBCS))
		{
		if (uAction == CLOOP_SET)
			pstCLoop->fDoMBCS = TRUE;
		else
			pstCLoop->fDoMBCS = FALSE;

		bitclear(uReason, CLOOP_MBCS);
		// I am not sure about returning here or not ...
		// As is, it requires that this be the only flag used for this call.

		LeaveCriticalSection(&pstCLoop->csect);
		return;
		}

	assert(uAction == CLOOP_SET || uAction == CLOOP_CLEAR);

	if (bittest(uReason, CLOOP_CONNECTED))
		{
		if (uAction == CLOOP_SET)
			{
			CLoopSndControl(hCLoop, CLOOP_RESUME, CLOOP_SB_UNCONNECTED);
			}
		else
			{
			CLoopClearOutput(hCLoop);
			CLoopSndControl(hCLoop, CLOOP_SUSPEND, CLOOP_SB_NODATA);
			}
		// Don't put this flag in afControl
		bitclear(uReason, CLOOP_CONNECTED);
		}

	if (bittest(uReason, CLOOP_SUPPRESS_DSP))
		{
		// This bit cannot be kept in afControl because doing so would
		// keep cloop from suspending itself when appropriate
		pstCLoop->fSuppressDsp = (uAction == CLOOP_SET);
		bitclear(uAction, CLOOP_SUPPRESS_DSP);
		}

#if 0
	if (uAction == CLOOP_SET)
		{
		bitset(pstCLoop->afControl, uReason);
		SetEvent(pstCLoop->ahEvents[EVENT_SEND]);
		}
	else if (uAction == CLOOP_CLEAR)
		{
		bitclear(pstCLoop->afControl, uReason);
		if (!pstCLoop->afControl)
			ResetEvent(pstCLoop->ahEvents[EVENT_SEND]);
		}
#endif

	if (bittest(uReason, CLOOP_MBCS))
		{
		if (uAction == CLOOP_SET)
			pstCLoop->fDoMBCS = TRUE;
		else
			pstCLoop->fDoMBCS = FALSE;

		bitclear(uReason, CLOOP_MBCS);
		// I am not sure about returning here or not ...
		LeaveCriticalSection(&pstCLoop->csect);
		return;
		}


	if (uAction == CLOOP_SET)
		bitset(pstCLoop->afControl, uReason);
	else if (uAction == CLOOP_CLEAR)
		bitclear(pstCLoop->afControl, uReason);

	if (pstCLoop->afControl)
		SetEvent(pstCLoop->ahEvents[EVENT_CONTROL]);
	else
		ResetEvent(pstCLoop->ahEvents[EVENT_CONTROL]);

	LeaveCriticalSection(&pstCLoop->csect);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopRegisterRmtInputChain
 *
 * DESCRIPTION:
 *	Adds a function to a chain of functions that are called whenever
 *	a new character is received from the remote system.
 *
 * ARGUMENTS:
 *	pstCLoop   -- Value returned from CLoopCreateHandle
 *	pfFunc	   -- Pointer to a function to be called when each remote
 *				  character is received. The function should be declared as:
 *				  VOID FAR PASCAL FunctionName(METACHAR mc, VOID FAR *pvUserData)
 *				  The value passed in the argument should be the return value
 *				  from MakeProcInstance.
 *	pvUserData -- Any arbitrary value that can be cast to VOID FAR *. This
 *				  value will be maintained in the chain and passed back to
 *				  the caller whenever (l*pfFunc) is called. No use is made
 *				  of this value by the CLoop routines.
 *
 * RETURNS:
 *	A void * return handle that must be saved and passed to
 *	CLoopUnregisterRmtInputChain when the function is no longer needed.
 */
void * CLoopRegisterRmtInputChain(const HCLOOP hCLoop,
			const CHAINFUNC pfFunc,
				  void *pvUserData)
	{
	ST_CLOOP * const pstCLoop = (ST_CLOOP *)hCLoop;
	ST_FCHAIN *pstNew = NULL;

	assert(pfFunc);
	assert(pstCLoop);

	if ((pstNew = (ST_FCHAIN *)malloc(sizeof(*pstNew))) != NULL)
		{
		EnterCriticalSection(&pstCLoop->csect);

		// Initialize new node
		pstNew->pstParent = pstCLoop;
		pstNew->pfFunc = pfFunc;
		pstNew->pvUserData = pvUserData;

		DBGOUT_NORMAL("CLoopRegisterRmtInputChain(0x%lx, 0x%lx) -> %lX\r\n",
					(LONG)pstNew->pfFunc, (LONG)pstNew->pvUserData,
					pstNew, 0, 0);

		// Always link new functions into beginning of chain. That way, if
		//	a new function is added into the chain from within a current
		//	callback, it will not be called until the next char. arrives.
		pstNew->pstNext = pstCLoop->pstRmtChain;
		pstCLoop->pstRmtChain = pstNew;
		pstNew->pstPrior = NULL;
		pstCLoop->fRmtChain = TRUE;
		LeaveCriticalSection(&pstCLoop->csect);
		}

	return (void *)pstNew;
	}

/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: CLoopUnregisterRmtInputChain
 *
 * DESCRIPTION:
 *	Removes a function from the chain of functions called when a remote
 *	character is received.
 *
 * ARGUMENTS:
 *	pvHdl -- Value returned from an earlier call to CLoopRegisterRmtInputChain
 *
 * RETURNS:
 *	nothing
 */
void CLoopUnregisterRmtInputChain(void *pvHdl)
	{
	ST_FCHAIN *pstNode = (ST_FCHAIN *)pvHdl;
	ST_CLOOP *pstCLoop;

	assert(pstNode);

	pstCLoop = pstNode->pstParent;
	EnterCriticalSection(&pstCLoop->csect);

	// See if we are removing next scheduled chain function
	if (pstNode == pstCLoop->pstRmtChainNext)
		{
		pstCLoop->pstRmtChainNext = pstNode->pstNext;
		}

	// Unlink node
	if (pstNode->pstPrior)
		{
		pstNode->pstPrior->pstNext = pstNode->pstNext;
		}
	else
		{
		pstCLoop->pstRmtChain = pstNode->pstNext;
		if (!pstNode->pstNext)
			{
			pstCLoop->fRmtChain = FALSE;
			}
		}

	if (pstNode->pstNext)
		{
		pstNode->pstNext->pstPrior = pstNode->pstPrior;
		}

	DBGOUT_NORMAL("CLoopUnregisterRmtInputChain(0x%lx)\r\n",
				(LONG)pvHdl, 0, 0, 0, 0);

	free(pstNode);
	pstNode = NULL;
	LeaveCriticalSection(&pstCLoop->csect);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: QueryCLoopMBCSState
 *
 * DESCRIPTION: Determines the current DBCS mode.
 *	
 * ARGUMENTS:
 *	hCLoop -- Handle returned from call to CLoopCreateHandle
 *
 * RETURNS:
 *    TRUE  -  if we are in DBCS mode.
 *    FALSE -  if we're not
 */
int QueryCLoopMBCSState(HCLOOP hCLoop)
	{
	ST_CLOOP *pstCLoop = (ST_CLOOP *)hCLoop;

	assert(pstCLoop);
	return(pstCLoop->fDoMBCS);
	}


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 * FUNCTION: SetCLoopMBCSState
 *
 * DESCRIPTION:  Turns on/off DBCS mode.
 *	
 * ARGUMENTS:
 *	hCLoop -- Handle returned from call to CLoopCreateHandle
 *           fState -- TRUE,  if we're turning MBCS on,
 *                         FALSE, if we're turning MBCS off.
 *
 * RETURNS:
 *    the value of dDoMBCS from the CLoop's internal struct
 */
int SetCLoopMBCSState(HCLOOP hCLoop, int fState)
   {
	ST_CLOOP *pstCLoop = (ST_CLOOP *)hCLoop;

	assert(pstCLoop);
	pstCLoop->fDoMBCS = fState;

	return(pstCLoop->fDoMBCS);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\osshell\accesory\hypertrm\tdll\cloop.h ===
/*	File: cloop.h (created 12/27/93, JKH)
 *
 *	Copyright 1994 by Hilgraeve Inc. -- Monroe, MI
 *	All rights reserved
 *
 *	$Revision: 1 $
 *	$Date: 10/05/98 12:39p $
 */

/* --- Constants --- */

// Values for usAction argument of CLoopRcvControl & CLoopSndControl
#define CLOOP_SUSPEND 1
#define CLOOP_RESUME  0

// Values for usAction argument of CLoopControl
#define CLOOP_SET	  1
#define CLOOP_CLEAR   0

// Values to return from chain functions
#define CLOOP_KEEP          0
#define CLOOP_DISCARD       1

// usReason values for CLoopRcvControl()
#define CLOOP_RB_NODATA 	 0x0001
#define CLOOP_RB_INACTIVE	 0x0002
#define CLOOP_RB_SCRLOCK	 0x0004
#define CLOOP_RB_SCRIPT 	 0x0008
#define CLOOP_RB_TRANSFER	 0x0010
#define CLOOP_RB_PRINTING	 0x0020 		// see PrintAbortProc (prnecho.c)
#define	CLOOP_RB_CNCTDRV	 0x0040

// usReason values for CLoopSndControl()
#define CLOOP_SB_NODATA 	 0x0001
#define CLOOP_SB_INACTIVE	 0x0002
#define CLOOP_SB_SCRLOCK	 0x0004
#define CLOOP_SB_LINEWAIT	 0x0008
#define CLOOP_SB_PRINTING	 0x0010 		// see PrintAbortProc (prnecho.c)
#define CLOOP_SB_DELAY		 0x0020
#define CLOOP_SB_UNCONNECTED 0x0040
#define	CLOOP_SB_CNCTDRV	 0x0080

// usReason values for CLoopControl()
#define CLOOP_TERMINATE 	 0x0001
#define CLOOP_TRANSFER_READY 0x0002
#define CLOOP_CONNECTED 	 0x0004
#define	CLOOP_MBCS			 0x0008
#define CLOOP_SUPPRESS_DSP	 0x8000

// usOptions values for CLoopSend()
#define CLOOP_KEYS			 0x0001
#define CLOOP_ALLOCATED 	 0x0002
#define CLOOP_SHARED		 0x0004
#define CLOOP_GLBL_ALLOCATED 0x0008 // tell cloop to free with GlobalFree()

/* --- Typedefs --- */

// Support for remote input chaining functions
typedef int (*CHAINFUNC)(ECHAR, void *);


/* --- Function Prototypes --- */
extern HCLOOP CLoopCreateHandle(const HSESSION hSession);
extern void   CLoopDestroyHandle(HCLOOP * const ppstCLoop);
extern int	  CLoopActivate(const HCLOOP hCLoop);
extern void   CLoopDeactivate(const HCLOOP hCLoop);
extern void   CLoopReset(const HCLOOP hCLoop);
extern void   CLoopRcvControl(const HCLOOP hCLoop,
					const unsigned uAction,
					const unsigned uReason);
extern void   CLoopOverrideControl(const HCLOOP hCLoop, const int fOverride);
extern void   CLoopSndControl(const HCLOOP hCLoop,
					const unsigned uAction,
					const unsigned uReason);
extern void   CLoopControl(const HCLOOP hCLoop,
						  unsigned uAction,
						  unsigned uReason);
extern void * CLoopRegisterRmtInputChain(const HCLOOP hCLoop,
					const CHAINFUNC pfFunc,
						  void *pvUserData);
extern void   CLoopUnregisterRmtInputChain(void *pvHdl);

extern int	  CLoopLoadHdl(const HCLOOP hCLoop);
extern int	  CLoopSaveHdl(const HCLOOP hCLoop);
extern int	  CLoopGetSendCRLF(const HCLOOP hCLoop);
extern void   CLoopSetSendCRLF(const HCLOOP hCLoop, const int fSendCRLF);
extern int	  CLoopGetExpandBlankLines(const HCLOOP hCLoop);
extern void   CLoopSetExpandBlankLines(const HCLOOP hCLoop,
					const int fExpandBlankLines);
extern int	  CLoopGetLocalEcho(const HCLOOP hCLoop);
extern void   CLoopSetLocalEcho(const HCLOOP hCLoop, const int fLocalEcho);
extern int	  CLoopGetLineWait(const HCLOOP hCLoop);
extern void   CLoopSetLineWait(const HCLOOP hCLoop, const int fLineWait);
extern TCHAR  CLoopGetWaitChar(const HCLOOP hCLoop);
extern void   CLoopSetWaitChar(const HCLOOP hCLoop, TCHAR chWaitChar);
extern int	  CLoopGetExpandTabsOut(const HCLOOP hCLoop);
extern void   CLoopSetExpandTabsOut(const HCLOOP hCLoop,
					const int fExpandTabsOut);
extern int	  CLoopGetTabSizeOut(const HCLOOP hCLoop);
extern void   CLoopSetTabSizeOut(const HCLOOP hCLoop, const int nTabSizeOut);
extern int	  CLoopGetLineDelay(const HCLOOP hCLoop);
extern void   CLoopSetLineDelay(const HCLOOP hCLoop, const int nLineDelay);
extern int	  CLoopGetCharDelay(const HCLOOP hCLoop);
extern void   CLoopSetCharDelay(const HCLOOP hCLoop, const int nCharDelay);
extern int	  CLoopGetAd