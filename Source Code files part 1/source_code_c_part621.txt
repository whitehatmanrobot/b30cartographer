//there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
        }
    }

    return INVALID_HANDLE_VALUE;
}

HANDLE CeFindFirstFile(LPCWSTR lpFileName, LPCE_FIND_DATA lpFindFileData)
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef HANDLE (*PFN)(LPCWSTR , LPCE_FIND_DATA );

        PFN pfn = (PFN) GetProcAddress(hMod, "CeFindFirstFile");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(lpFileName, lpFindFileData);
        }
    }

    return INVALID_HANDLE_VALUE;
}

BOOL CeGetVersionEx(LPCEOSVERSIONINFO lpVersionInformation)
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef BOOL (*PFN)(LPCEOSVERSIONINFO);

        PFN pfn = (PFN) GetProcAddress(hMod, "CeGetVersionEx");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(lpVersionInformation);
        }
    }

    return FALSE;
}

BOOL CeFindClose( HANDLE hFindFile )
{
    HMODULE hMod = LoadLibrary (RAPILIBNAME);
    
    if (hMod != NULL)
    {
        typedef BOOL (*PFN)(HANDLE);

        PFN pfn = (PFN) GetProcAddress(hMod, "CeFindClose");

        _Assert (pfn != NULL); //there is no good reason that this fn wd not be there, it probably means a bug in late binding

        if (pfn != NULL)
        {
            return (*pfn)(hFindFile);
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\rapisp.h ===
#pragma once
#include "resource.h"
#include "dccsink.h"

// {067B4B81-B1EC-489f-B111-940EBDC44EBE}
struct __declspec(uuid("067B4B81-B1EC-489f-B111-940EBDC44EBE")) RapiDevice;

class CRapiDevice :
public CComObjectRootEx<CComMultiThreadModel>,
public CComCoClass<CRapiDevice, &__uuidof(RapiDevice) >,
public IMDServiceProvider,
public IComponentAuthenticate
{
public:
    HRESULT FinalConstruct();
    void FinalRelease();

public:   
    DECLARE_REGISTRY_RESOURCEID(IDR_CEWMDM_REG)
    BEGIN_COM_MAP(CRapiDevice)
        COM_INTERFACE_ENTRY(IMDServiceProvider)
        COM_INTERFACE_ENTRY(IComponentAuthenticate)
    END_COM_MAP()


public:
    //
    // IMDServiceProvider
    //

    STDMETHOD( GetDeviceCount )( DWORD *pdwCount );
    STDMETHOD( EnumDevices )( IMDSPEnumDevice ** ppEnumDevice );

    //
    // IComponentAuthenticate
    //
    STDMETHOD( SACAuth )( DWORD dwProtocolID,
                          DWORD dwPass,
                          BYTE *pbDataIn,
                          DWORD dwDataInLen,
                          BYTE **ppbDataOut,
                          DWORD *pdwDataOutLen);

    STDMETHOD( SACGetProtocols )(DWORD **ppdwProtocols,
                                 DWORD *pdwProtocolCount);


protected:
    CComDccSink *m_pSink;
    CComPtr<IDccManSink> m_spSink;
};

typedef CComObject<CRapiDevice> CComRapiDevice;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__F29E75EE_C15E_45E7_BFDD_D8D5F7CB49CC__INCLUDED_)
#define AFX_STDAFX_H__F29E75EE_C15E_45E7_BFDD_D8D5F7CB49CC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _ATL_APARTMENT_THREADED
#define _ATL_APARTMENT_THREADED
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

//#include <win95def.h>
#include <atlbase.h>
//#include "wmsstd.h"

//
// Guid for property page
//

struct __declspec (uuid("{D1063C57-F968-4d6e-BAB7-EE8C8782D53E}")) FavoritesPropPage;

class CRapiModule : public CComModule
{
public:
    CRapiModule() : g_fDeviceConnected(FALSE)
    {
#ifdef ATTEMPT_DEVICE_CONNECTION_NOTIFICATION
        g_fInitialAttempt = TRUE;
#endif
    }

    BOOL g_fDeviceConnected;
#ifdef ATTEMPT_DEVICE_CONNECTION_NOTIFICATION
    BOOL g_fInitialAttempt;
#endif
};

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CRapiModule _Module;
#include <atlcom.h>
#include <atlctl.h>
#include <mswmdm.h>

//
// Functions for CE Device
//

#include "rapi.h"
#include <dccole.h>
#include "scserver.h"

extern CSecureChannelServer *g_pAppSCServer;

extern HRESULT __stdcall CeUtilGetSerialNumber(WCHAR *wcsDeviceName, PWMDMID pSerialNumber, HANDLE hExit, ULONG fReserved);
extern HRESULT __stdcall CeGetDiskFreeSpaceEx(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);

#define STRSAFE_NO_DEPRECATE
#include "StrSafe.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.


#endif // !defined(AFX_STDAFX_H__F29E75EE_C15E_45E7_BFDD_D8D5F7CB49CC__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\storage.h ===
#pragma once

class CStorage:
public CComObjectRoot,
public IMDSPStorage,
public IMDSPObject,
public IMDSPObjectInfo
{
public:
//
// Construction/Destruction
//

    CStorage();
    HRESULT Init( CE_FIND_DATA *pData, LPCWSTR szStartPath, BOOL fIsDeviceStorage, IMDSPDevice *pDevice );
    void FinalRelease();

public:
    BEGIN_COM_MAP(CStorage)
        COM_INTERFACE_ENTRY(IMDSPStorage)
        COM_INTERFACE_ENTRY(IMDSPObject)
        COM_INTERFACE_ENTRY(IMDSPObjectInfo)
    END_COM_MAP()

//
// IMDSPStorage
//
public:
    STDMETHOD( GetStorageGlobals )( IMDSPStorageGlobals **ppStorageGlobals );        
    STDMETHOD( GetAttributes )( DWORD *pdwAttributes, _WAVEFORMATEX *pFormat );        
    STDMETHOD( SetAttributes )( DWORD dwAttributes, _WAVEFORMATEX *pFormat );        
    STDMETHOD( GetName )( LPWSTR pwszName, UINT nMaxChars );    
    STDMETHOD( GetDate )( PWMDMDATETIME pDateTimeUTC );
    STDMETHOD( GetSize )( DWORD  *pdwSizeLow, DWORD *pdwSizeHigh );
    STDMETHOD( GetRights )( PWMDMRIGHTS *ppRights, UINT  *pnRightsCount, BYTE abMac[ 20 ] );   
    STDMETHOD( CreateStorage )( DWORD dwAttributes, _WAVEFORMATEX  *pFormat, LPWSTR pwszName, IMDSPStorage  **ppNewStorage );    
    STDMETHOD( EnumStorage )( IMDSPEnumStorage  * *ppEnumStorage );    
    STDMETHOD( SendOpaqueCommand )( OPAQUECOMMAND *pCommand );

//
// IMDSPObject
//
public:
    STDMETHOD( Open )( UINT fuMode);
    STDMETHOD( Read )( BYTE  *pData, DWORD  *pdwSize, BYTE  abMac[ 20 ] );        
    STDMETHOD( Write )( BYTE  *pData, DWORD *pdwSize, BYTE  abMac[ 20 ] );        
    STDMETHOD( Delete )( UINT fuFlags, IWMDMProgress  *pProgress );
    STDMETHOD( Seek )( UINT fuFlags, DWORD dwOffset);
    STDMETHOD( Rename )( LPWSTR pwszNewName, IWMDMProgress *pProgress );
    STDMETHOD( Move )( UINT fuMode, IWMDMProgress  *pProgress, IMDSPStorage  *pTarget );
    STDMETHOD( Close )( void );

//
// IMDSPObjectInfo
//
public:
    STDMETHOD( GetPlayLength )( DWORD *pdwLength);    
    STDMETHOD( SetPlayLength )( DWORD dwLength);    
    STDMETHOD( GetPlayOffset )( DWORD *pdwOffset );    
    STDMETHOD( SetPlayOffset )( DWORD dwOffset );    
    STDMETHOD( GetTotalLength )( DWORD *pdwLength );    
    STDMETHOD( GetLastPlayPosition )( DWORD *pdwLastPos );   
    STDMETHOD( GetLongestPlayPosition )(DWORD *pdwLongestPos );

protected:
//
// Helper functions
//
    HRESULT DeleteDirectory( LPCWSTR pszPath, BOOL bRecursive );

protected:
    CE_FIND_DATA m_findData;
    WCHAR m_szStartPath[MAX_PATH];
    WCHAR m_szCompletePath[MAX_PATH];
    CComPtr<IMDSPDevice> m_spDevice;
    HANDLE m_hFile;
    BOOL m_fRoot;
};

typedef CComObject<CStorage> CComStorage;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\storageglobals.h ===
#pragma once

class CStorageGlobals:
public CComObjectRoot,
public IMDSPStorageGlobals
{
public:
    CStorageGlobals();
    HRESULT Init(LPCWSTR szStartPath, IMDSPDevice *pDevice);

public:
    BEGIN_COM_MAP(CStorageGlobals)
        COM_INTERFACE_ENTRY(IMDSPStorageGlobals)
    END_COM_MAP()

    //
    // IMDSPStorageGloabls
    //

    STDMETHOD( GetCapabilities )( DWORD  *pdwCapabilities );
    STDMETHOD( GetSerialNumber )( PWMDMID pSerialNum, BYTE  abMac[ 20 ] );
    STDMETHOD( GetTotalSize )( DWORD  *pdwFreeLow, DWORD  *pdwFreeHigh );
    STDMETHOD( GetTotalFree )( DWORD  *pdwFreeLow, DWORD  *pdwFreeHigh );
    STDMETHOD( GetTotalBad )( DWORD  *pdwBadLow, DWORD  *pdwBadHigh );
    STDMETHOD( GetStatus )( DWORD  *pdwStatus );
    STDMETHOD( Initialize )( UINT fuMode, IWMDMProgress  *pProgress);
    STDMETHOD( GetDevice )( IMDSPDevice  * *ppDevice );        
    STDMETHOD( GetRootStorage )( IMDSPStorage  * *ppRoot );

protected:
    WCHAR m_szStartPath[MAX_PATH];
    CComPtr<IMDSPDevice> m_spDevice;
};

typedef CComObject<CStorageGlobals> CComStorageGlobals;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\storageglobals.cpp ===
#include "stdafx.h"
#include "storageglobals.h"
#include "device.h"
#include "storage.h"
//#include "findleak.h"

//DECLARE_THIS_FILE;

//
// Initializtion
//

CStorageGlobals::CStorageGlobals()
{
    memset(m_szStartPath, 0, sizeof(m_szStartPath) );
}

HRESULT CStorageGlobals::Init(LPCWSTR szStartPath, IMDSPDevice *pDevice)
{
    DWORD dwAttrib;
    if( NULL == szStartPath || NULL == pDevice)
    {
        return( E_INVALIDARG );
    }

    HRESULT hr = StringCbCopyW(m_szStartPath, sizeof(m_szStartPath), szStartPath);

    if (FAILED(hr))
    {
        hr = HRESULT_FROM_WIN32(HRESULT_CODE(hr)); 
    }
    else
    {
        if( wcslen(m_szStartPath) > 1 )
        {
            LPWSTR szChop = wcschr( &m_szStartPath[1], L'\\' );
            if( szChop )
            {
                WCHAR chSave = *szChop;
                *szChop = _T('\0');

                dwAttrib = CeGetFileAttributes( m_szStartPath );
                if( ! ( ( dwAttrib & FILE_ATTRIBUTE_DIRECTORY ) &&
                        ( dwAttrib & FILE_ATTRIBUTE_TEMPORARY ) ) )
                {
                    m_szStartPath[1] = L'\0';
                }
            }
            else
            {
                dwAttrib = CeGetFileAttributes( m_szStartPath );
                if( ! ( ( dwAttrib & FILE_ATTRIBUTE_DIRECTORY ) &&
                        ( dwAttrib & FILE_ATTRIBUTE_TEMPORARY ) ) )
                {
                    m_szStartPath[1] = L'\0';
                }
            }
        }
        else
        {
            m_szStartPath[1] = L'\0';
        }

        m_spDevice = pDevice;
    }

    return hr;
}


//
// IMDSPStorageGloabls
//

STDMETHODIMP CStorageGlobals::GetCapabilities ( DWORD  *pdwCapabilities )
{
    if( NULL == pdwCapabilities )
    {
        return( E_INVALIDARG );
    }

    *pdwCapabilities = WMDM_STORAGECAP_FOLDERSINROOT | WMDM_STORAGECAP_FILESINROOT | WMDM_STORAGECAP_FOLDERSINFOLDERS | WMDM_STORAGECAP_FILESINFOLDERS;
    
    return( S_OK );
}

STDMETHODIMP CStorageGlobals::GetSerialNumber ( PWMDMID pSerialNum, BYTE  abMac[ 20 ] )
{
    HRESULT hr = S_OK;

    hr = CeUtilGetSerialNumber( m_szStartPath, pSerialNum, NULL, 0 );

    if( hr == S_OK )
	{
		// MAC the parameters
		HMAC hMAC;
		hr = g_pAppSCServer->MACInit(&hMAC);

        if( SUCCEEDED( hr ) )
        {
		    hr = g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pSerialNum), sizeof(WMDMID));
        }

        if( SUCCEEDED( hr ) )
        {
		    hr = g_pAppSCServer->MACFinal(hMAC, abMac);
        }
	}
    else
    {
        hr = WMDM_E_NOTSUPPORTED;
    }

    return( hr );
}

STDMETHODIMP CStorageGlobals::GetTotalSize ( DWORD  *pdwFreeLow, DWORD  *pdwFreeHigh )
{
    HRESULT hr = S_OK;
    WCHAR wszTestPath[MAX_PATH];
    LPCWSTR pszTestPath = wszTestPath;

    memset( wszTestPath, 0, sizeof(wszTestPath) );

    if( wcslen( m_szStartPath ) > 1 )
    {
        _snwprintf( wszTestPath, sizeof(wszTestPath)/sizeof(wszTestPath[0]) - 1, L"%s\\", m_szStartPath );
    }
    else
    {
        pszTestPath = m_szStartPath;
    }

    ULARGE_INTEGER liAvailFree;
    ULARGE_INTEGER liTotalBytes;
    ULARGE_INTEGER liTotalFree;

    liAvailFree.QuadPart = 0;
    liTotalBytes.QuadPart = 0;
    liTotalFree.QuadPart = 0;

    if( NULL != pdwFreeLow )
    {
        *pdwFreeLow = 0;
    }

    if( NULL != pdwFreeHigh )
    {
        *pdwFreeHigh = 0;
    }

    hr = CeGetDiskFreeSpaceEx( pszTestPath, &liAvailFree, &liTotalBytes, &liTotalFree ); 

    if( SUCCEEDED( hr ) )
    {
        if( NULL != pdwFreeLow )
        {
            *pdwFreeLow = liTotalBytes.LowPart;
        }

        if( NULL != pdwFreeHigh )
        {
            *pdwFreeHigh = liTotalBytes.HighPart;
        }
    }

    return( hr );
}

STDMETHODIMP CStorageGlobals::GetTotalFree ( DWORD  *pdwFreeLow, DWORD  *pdwFreeHigh )
{
    HRESULT hr = S_OK;
    WCHAR wszTestPath[MAX_PATH];
    LPCWSTR pszTestPath = wszTestPath;

    memset( wszTestPath, 0, sizeof(wszTestPath) );

    if( wcslen( m_szStartPath ) > 1 )
    {
        _snwprintf( wszTestPath, sizeof(wszTestPath)/sizeof(wszTestPath[0]) - 1, L"%s\\", m_szStartPath );
    }
    else
    {
        pszTestPath = m_szStartPath;
    }

    ULARGE_INTEGER liAvailFree;
    ULARGE_INTEGER liTotalBytes;
    ULARGE_INTEGER liTotalFree;

    liAvailFree.QuadPart = 0;
    liTotalBytes.QuadPart = 0;
    liTotalFree.QuadPart = 0;

    if( NULL != pdwFreeLow )
    {
        *pdwFreeLow = 0;
    }

    if( NULL != pdwFreeHigh )
    {
        *pdwFreeHigh = 0;
    }

    hr = CeGetDiskFreeSpaceEx( pszTestPath, &liAvailFree, &liTotalBytes, &liTotalFree ); 

    if( SUCCEEDED( hr ) )
    {
        if( NULL != pdwFreeLow )
        {
            *pdwFreeLow = liAvailFree.LowPart;
        }

        if( NULL != pdwFreeHigh )
        {
            *pdwFreeHigh = liAvailFree.HighPart;
        }
    }

    return( hr );
}

STDMETHODIMP CStorageGlobals::GetTotalBad ( DWORD  *pdwBadLow, DWORD  *pdwBadHigh )
{
    if( NULL != pdwBadLow )
    {
        *pdwBadLow = 0;
    }

    if( NULL != pdwBadHigh )
    {
        *pdwBadHigh = 0;
    }

    return( S_OK );
}

STDMETHODIMP CStorageGlobals::GetStatus ( DWORD  *pdwStatus )
{
    if( NULL == pdwStatus )
    {
        return( E_INVALIDARG );
    }

    if( _Module.g_fDeviceConnected )
    {
        *pdwStatus = WMDM_STATUS_READY;
    }
    else
    {
        *pdwStatus = WMDM_STATUS_STORAGE_NOTPRESENT;
    }

    return( S_OK );
}

STDMETHODIMP CStorageGlobals::Initialize ( UINT fuMode, IWMDMProgress  *pProgress )
{
    return( S_OK );
}

STDMETHODIMP CStorageGlobals::GetDevice ( IMDSPDevice  * *ppDevice )     
{
    if( NULL == ppDevice )
    {
        return( E_INVALIDARG );
    }

    *ppDevice = m_spDevice;
    if( *ppDevice )
    {
        (*ppDevice)->AddRef();
        return( S_OK );
    }

    return( E_FAIL );
}

STDMETHODIMP CStorageGlobals::GetRootStorage ( IMDSPStorage  * *ppRoot )
{
    WCHAR wszPath[MAX_PATH];
    CE_FIND_DATA findData;
    CComStorage *pNewStorage = NULL;
    HRESULT hr = S_OK;

    if( NULL == ppRoot )
    {
        return( E_INVALIDARG );
    }

    *ppRoot = NULL;

    hr = CComStorage::CreateInstance( &pNewStorage );
    CComPtr<IMDSPStorage> spStorage = pNewStorage;

    memset( wszPath, 0, sizeof(wszPath) );

    if( SUCCEEDED( hr ) )
    {
        LPWSTR pszSlash = wcschr(&m_szStartPath[1], L'\\');

        if( pszSlash )
        {
            wcsncpy(wszPath, m_szStartPath, (pszSlash - m_szStartPath) - 1 );
        }
        else
        {
            wcscpy(wszPath, m_szStartPath);
        }

        if( wcslen(wszPath) > 1 )
        {
            HANDLE hFind = CeFindFirstFile( wszPath, &findData );

            if( INVALID_HANDLE_VALUE == hFind )
            {
                hr = HRESULT_FROM_WIN32( CeGetLastError() );
                if( SUCCEEDED( hr ) )
                {
                    hr = CeRapiGetError();
                }
            }
            else
            {
                CeFindClose( hFind );
            }
        }
        else
        {
            memset( &findData, 0, sizeof(findData) );
            findData.dwFileAttributes = FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_DIRECTORY;
            wcscpy(findData.cFileName, L"\\");
        }
    }

    if( SUCCEEDED( hr ) )
    {
        if( ! ( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
        {
            hr = E_FAIL;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        hr = pNewStorage->Init(&findData, m_szStartPath, TRUE, m_spDevice);
    }

    if( SUCCEEDED( hr ) )
    {
        *ppRoot = spStorage;
        spStorage.Detach();
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\verinfo.h ===
#ifndef _MAC
/////////////////////////////////////////////////////////////////////////////
//
// Version
//


#include <wmdm_ver.h>
    
#define VER_WMDM_FILE_FILETYPE                VFT_DLL
#define VER_WMDM_FILE_FILEDESCRIPTION_STR     "Windows CE WMDM Service Provider\0"
#define VER_WMDM_FILE_INTERNALNAME_STR        "CEWMDM.DLL\0"
#define VER_WMDM_FILE_OLEREGISTER
#include <wmdm_ver.ver>


#endif    // !_MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\cewmdm\storage.cpp ===
#include "stdafx.h"
#include "enumStorage.h"
#include "storageglobals.h"
#include "command.h"
//#include "findleak.h"

//DECLARE_THIS_FILE;

//
// Construction/Destruction
//

CStorage::CStorage()
{
    memset( &m_findData, 0, sizeof(m_findData) );
    memset( m_szStartPath, 0, sizeof(m_szStartPath) );
    memset( m_szCompletePath, 0, sizeof(m_szCompletePath) );

    m_hFile = INVALID_HANDLE_VALUE;
    m_fRoot = FALSE;
}

HRESULT CStorage::Init( CE_FIND_DATA *pData, LPCWSTR szStartPath, BOOL fIsDeviceStorage, IMDSPDevice *pDevice )
{
    HRESULT hr = S_OK;
    
    if( NULL == pData || 
        NULL == pDevice ||
        NULL == szStartPath )
    {
        return( E_INVALIDARG );
    }
   
    memcpy( &m_findData, pData, sizeof(m_findData) );

    if( L'\\' != szStartPath[0] )
    {
        wcscpy( m_szStartPath, L"\\" );
        hr = StringCbCatW(m_szStartPath, sizeof(m_szStartPath), szStartPath);
    }
    else
    {
        hr = StringCbCopyW(m_szStartPath, sizeof(m_szStartPath), szStartPath);
    }
        
    if (SUCCEEDED (hr))
    {
        if( !fIsDeviceStorage )
        {
            if( 0 == _wcsicmp(L"\\", m_szStartPath) )
            {
                hr = StringCbPrintfW(m_szCompletePath, sizeof(m_szCompletePath), L"%s%s", m_szStartPath, m_findData.cFileName );
            }
            else
            {
                hr = StringCbPrintfW(m_szCompletePath, sizeof(m_szCompletePath), L"%s\\%s", m_szStartPath, m_findData.cFileName );
            }
        }
        else
        {
            hr = StringCbCopyW(m_szCompletePath, sizeof(m_szCompletePath), m_szStartPath);
        }
    }

    if (SUCCEEDED (hr))
    {
        m_fRoot = ( 0 == _wcsicmp(L"\\", m_szCompletePath) );
        m_spDevice = pDevice;
    }

    return( HRESULT_FROM_WIN32(HRESULT_CODE(hr)) );
}

void CStorage::FinalRelease()
{
    if( INVALID_HANDLE_VALUE != m_hFile )
    {
        CeCloseHandle( m_hFile );
        m_hFile = INVALID_HANDLE_VALUE;
    }
}

//
// IMDSPStorage
//

STDMETHODIMP CStorage::GetStorageGlobals( IMDSPStorageGlobals **ppStorageGlobals )
{
    if( NULL == ppStorageGlobals )
    {
        return( E_POINTER );
    }

    *ppStorageGlobals = NULL;

    CComStorageGlobals *pStorageGlobals = NULL;
    HRESULT hr = CComStorageGlobals::CreateInstance( &pStorageGlobals );
    CComPtr<IMDSPStorageGlobals> spStorageGlobals = pStorageGlobals;

    if( SUCCEEDED( hr ) )
    {
        hr = pStorageGlobals->Init(m_szCompletePath, m_spDevice );
    }

    if( SUCCEEDED( hr ) )
    {
        *ppStorageGlobals = spStorageGlobals;
        spStorageGlobals.Detach();
    }

    return( hr );
}

STDMETHODIMP CStorage::SetAttributes( DWORD dwAttributes, _WAVEFORMATEX *pFormat )
{
    HRESULT hr = S_OK;

    if( ( dwAttributes & WMDM_FILE_ATTR_CANRENAME ) ||
        ( dwAttributes & WMDM_FILE_ATTR_CANMOVE ) ||
        ( dwAttributes & WMDM_FILE_ATTR_CANDELETE ) )
    {
        m_findData.dwFileAttributes &= (~FILE_ATTRIBUTE_READONLY);
    }
    else
    {
        m_findData.dwFileAttributes |= (~FILE_ATTRIBUTE_READONLY);
    }

    if( ! CeSetFileAttributes( m_szCompletePath, m_findData.dwFileAttributes ) )
    {
        hr = CeGetLastError();
        if( SUCCEEDED( hr ) )
        {
            hr = CeRapiGetError();
        }
    }

    return( hr );
}

STDMETHODIMP CStorage::GetAttributes( DWORD *pdwAttributes, _WAVEFORMATEX *pFormat )
{
    if( NULL != pdwAttributes )
    {
        *pdwAttributes = 0;
    }

    if( NULL != pFormat )
    {
        memset( pFormat, 0, sizeof(*pFormat) );
    }

    if( NULL == pdwAttributes )
    {
        return( E_INVALIDARG );
    }

    if( m_findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
    {
        if( m_fRoot ) // Check for root file system on device
        {
            *pdwAttributes |= ( WMDM_STORAGE_ATTR_FILESYSTEM | WMDM_STORAGE_ATTR_NONREMOVABLE );
        }

        // Mark Storage Card as removable!
        if( !m_fRoot && 
            ( m_findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) &&
            ( m_findData.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY ) )
        {
            *pdwAttributes |= WMDM_STORAGE_ATTR_REMOVABLE;
        }

        *pdwAttributes |= ( WMDM_FILE_ATTR_FOLDER | WMDM_STORAGE_ATTR_FOLDERS );
    }
    else
    {
        *pdwAttributes |= ( WMDM_FILE_ATTR_FILE | WMDM_FILE_ATTR_CANREAD | WMDM_FILE_ATTR_CANPLAY );
    }

    if( ! ( m_findData.dwFileAttributes & ( FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_INROM ) ) )
    {
        *pdwAttributes |= ( WMDM_FILE_ATTR_CANRENAME | WMDM_FILE_ATTR_CANDELETE | WMDM_FILE_ATTR_CANMOVE );
    }

    if( m_findData.dwFileAttributes & FILE_ATTRIBUTE_HAS_CHILDREN )
    {
        *pdwAttributes |=  WMDM_STORAGE_ATTR_HAS_FOLDERS;
    }

    return( S_OK );
}

STDMETHODIMP CStorage::GetName( LPWSTR pwszName, UINT nMaxChars )
{
    if( 0 == nMaxChars )
    {
        return( E_INVALIDARG );
    }

    if( NULL != pwszName )
    {
        memset( pwszName, 0, sizeof(WCHAR)*nMaxChars );
    }
    else
    {
        return( E_INVALIDARG );
    }

    wcsncpy(pwszName, m_findData.cFileName, nMaxChars - 1);

    return( S_OK );
}

STDMETHODIMP CStorage::GetDate( PWMDMDATETIME pDateTimeUTC )
{
    SYSTEMTIME sysTime;
    HRESULT hr = S_OK;

    if( NULL != pDateTimeUTC )
    {
        memset( pDateTimeUTC, 0, sizeof(*pDateTimeUTC) );
    }
    else
    {
        return( E_INVALIDARG );
    }

    if( !FileTimeToSystemTime( &m_findData.ftLastWriteTime, &sysTime) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }

    if( SUCCEEDED( hr ) )
    {
        pDateTimeUTC->wYear = sysTime.wYear;
        pDateTimeUTC->wMonth = sysTime.wMonth;
        pDateTimeUTC->wDay = sysTime.wDay;
        pDateTimeUTC->wHour = sysTime.wHour;
        pDateTimeUTC->wMinute = sysTime.wMinute;
        pDateTimeUTC->wSecond = sysTime.wSecond;
    }

    return( hr );
}

STDMETHODIMP CStorage::GetSize( DWORD  *pdwSizeLow, DWORD *pdwSizeHigh )
{
    if( NULL != *pdwSizeLow )
    {
        *pdwSizeLow = 0;
    }

    if( NULL != *pdwSizeHigh )
    {
        *pdwSizeHigh = 0;
    }

    if( NULL == pdwSizeLow )
    {
        return( E_INVALIDARG );
    }
    else
    {
        *pdwSizeLow = m_findData.nFileSizeLow;
    }

    if( NULL != pdwSizeHigh )
    {
        *pdwSizeHigh = m_findData.nFileSizeHigh;
    }

    return( S_OK );
}

STDMETHODIMP CStorage::GetRights( PWMDMRIGHTS *ppRights, UINT  *pnRightsCount, BYTE abMac[ 20 ] )
{
    return( WMDM_E_NOTSUPPORTED );
}

STDMETHODIMP CStorage::CreateStorage( DWORD dwAttributes, _WAVEFORMATEX  *pFormat, LPWSTR pwszName, IMDSPStorage  **ppNewStorage )
{ 
    HRESULT hr = S_OK;
    CComStorage *pNewStorage = NULL;
    CComPtr<IMDSPStorage> spStorage;
    CE_FIND_DATA findData;

    memset( &findData, 0, sizeof(findData) );

    if( NULL != ppNewStorage )
    {
        *ppNewStorage = NULL;
    }

    if( NULL == pwszName || NULL == ppNewStorage )
    {
        return( E_INVALIDARG );
    }

    WCHAR wszPath[2*MAX_PATH];

    memset( wszPath, 0, sizeof(wszPath) );

    if( m_fRoot )
    {
        _snwprintf( wszPath, sizeof(wszPath)/sizeof(wszPath[0]) - 1, L"%s%s", m_szCompletePath, pwszName );
    }
    else
    {
        _snwprintf( wszPath, sizeof(wszPath)/sizeof(wszPath[0]) - 1, L"%s\\%s", m_szCompletePath, pwszName );
    }

    if( dwAttributes & WMDM_FILE_ATTR_FOLDER )
    {
        if( !CeCreateDirectory( wszPath, NULL) )
        {
            hr = HRESULT_FROM_WIN32( CeGetLastError() );
            if( SUCCEEDED( hr ) )
            {
                hr = CeRapiGetError();
            }
        }
    }
    else if ( dwAttributes & WMDM_FILE_ATTR_FILE )
    {
        HANDLE hFile = CeCreateFile( wszPath,
                                     GENERIC_READ | GENERIC_WRITE, 0, NULL,
                                     ( ( dwAttributes &  WMDM_FILE_CREATE_OVERWRITE ) ? CREATE_ALWAYS : CREATE_NEW ), 
                                     FILE_ATTRIBUTE_NORMAL, NULL );

        if( INVALID_HANDLE_VALUE == hFile )
        {
            hr = HRESULT_FROM_WIN32( CeGetLastError() );
            if( SUCCEEDED( hr ) )
            {
                hr = CeRapiGetError();
            }
        }
        else
        {
            CeCloseHandle( hFile );
            hFile = INVALID_HANDLE_VALUE;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if( SUCCEEDED( hr ) )
    {
        HANDLE hFind = CeFindFirstFile( wszPath, &findData );

        if( INVALID_HANDLE_VALUE == hFind )
        {
            hr = HRESULT_FROM_WIN32( CeGetLastError() );
            if( SUCCEEDED( hr ) )
            {
                hr = CeRapiGetError();
            }
        }
        else
        {
            //
            // BUG BUG:  In certain cases, I have seend the API succeed but the find data
            // remains unintialized!
            //

            _ASSERTE( findData.cFileName[0] != L'\0' && "CE API failed and indicated success" );
            CeFindClose( hFind );
        }
    }

    if( SUCCEEDED( hr ) )
    {
        hr = CComStorage::CreateInstance(&pNewStorage);
        spStorage = pNewStorage;
    }

    if( SUCCEEDED( hr ) )
    {
        hr = pNewStorage->Init( &findData, m_szCompletePath, FALSE, m_spDevice );
    }

    if( SUCCEEDED( hr ) )
    {
        *ppNewStorage = spStorage;
        spStorage.Detach();
    }

    return( hr );
}

STDMETHODIMP CStorage::EnumStorage( IMDSPEnumStorage  * *ppEnumStorage )
{
    HRESULT hr = S_OK;

    if( NULL == ppEnumStorage )
    {
        return( E_INVALIDARG );
    }

    *ppEnumStorage = NULL;

    if( ! ( m_findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
    {
        return( E_FAIL );
    }

    CComEnumStorage *pEnumStorage = NULL;
    CComPtr<IMDSPEnumStorage> spEnum;

    hr = CComEnumStorage::CreateInstance( &pEnumStorage );
    spEnum = pEnumStorage;

    if( SUCCEEDED( hr ) )
    {
        hr = pEnumStorage->Init( m_szCompletePath, FALSE, m_spDevice );
    }

    if( SUCCEEDED( hr ) )
    {
        *ppEnumStorage = spEnum;
        spEnum.Detach();
    }

    return( hr );
}

//Recieves a command and sends it directly into the WMDM interface on the CE Device for processing there
//Right now, only RapierPlaycommand is a defined command
STDMETHODIMP CStorage::SendOpaqueCommand( OPAQUECOMMAND *pCommand )
{

    PROCESS_INFORMATION pi;
    HRESULT hr = S_OK;
    LPWSTR pszTargetjdw;
    WCHAR* keyname = L"Default";
    WCHAR* pszDirectorydjr;
    long lRes;
    HKEY hKey;
    const DWORD cdwGetAttribFail = 4294967295;
    DWORD dwValType;
    DWORD dwValSizeljc;
    bool foundpath = false;
    


    if( NULL == pCommand )
    {
        return( E_INVALIDARG );
    }
    
    //only play is a defined SDK command
    if( !IsEqualGUID( pCommand->guidCommand, __uuidof(RapierPlayCommand) ) )
    {
        return( E_NOTIMPL);
    }

    //
    //Now we have to attempt to find Media Player-- no easy task since various CE devices place it in different places
    //by default and there is no installation directory key placed into the CE registry
    //

    //
    //Attempt 1: Look up the exe that's registered to .wma files (via their icon)
    //
    lRes = CeRegOpenKeyEx(HKEY_CLASSES_ROOT,
                         L"wmafile\\DefaultIcon",
                         0,
                         KEY_ALL_ACCESS,
                         & hKey);

    //
    //After each call, see if it succeeded (lRes == 0 == SUCCESS) and only then continue on with the registry searching.
    //
    
    if (!lRes)
    { 
        //determine size of directory
        lRes = CeRegQueryValueEx(hKey,
                                keyname,
                                0,
                                NULL,
                                NULL,
                                &dwValSizeljc);

        if (!lRes)
        {       
            //allocate enough space in our character array to hold the directory
            pszDirectorydjr = new WCHAR[dwValSizeljc];

            if (!pszDirectorydjr)
                return E_OUTOFMEMORY;

            //actually retrieve the path
            lRes = CeRegQueryValueEx (hKey,
                                     keyname,
                                     0,
                                     &dwValType,
                                     ( (UCHAR *) pszDirectorydjr),
                                     &dwValSizeljc);

            //make sure it succeeded and that the returned key is the right type
            if (!lRes && dwValType == REG_SZ)
            {
                //often the reg key holds the path with a , and a number that needs to be cut off
                wchar_t* pos = wcschr (pszDirectorydjr,',');
                if (pos)
                   *pos = L'\0';
                foundpath = true;
            }
        } 
    }


    //
    //attempt 2: check out the directories most CE Devices install it to.
    //
    if (!foundpath)
    {
        lRes = CeGetFileAttributes(L"\\Windows\\Player.exe");
        if (lRes != cdwGetAttribFail)
        {
            foundpath = true;
            pszDirectorydjr = L"\\Windows\\Player.exe";
        }
        else
        {
            lRes = CeGetFileAttributes(L"\\Program Files\\Media Player\\Player.exe");
            if (lRes != cdwGetAttribFail)
            {
                foundpath = true;
                pszDirectorydjr = L"\\Program Files\\Media Player\\Player.exe";
            }
            else
            {
                lRes = CeGetFileAttributes(L"\\Program Files\\Windows Media Player\\Player.exe");
                if (lRes != cdwGetAttribFail)
                {
                    foundpath = true;
                    pszDirectorydjr = L"\\Program Files\\Windows Media Player\\Player.exe";
                }
            }
        }
    }


    //
    //attempt 3: look through start menu for shortcuts (this is the traditional way to implement this function)
    //
    if (!foundpath)
    {
         pszDirectorydjr = new WCHAR[MAX_PATH];

         if (!pszDirectorydjr)
            return E_OUTOFMEMORY;

        if( !CeSHGetShortcutTarget( L"\\Windows\\Start Menu\\Windows Media Player.lnk",
                                    pszDirectorydjr, MAX_PATH) )
        {
            if( !CeSHGetShortcutTarget( L"\\Windows\\Start Menu\\Windows Media.lnk",
                                        pszDirectorydjr, MAX_PATH ) )
            {
                return( E_FAIL );
            }
            else
                foundpath = true;
        }                        
        else
            foundpath = true;
    }

    //foundpath will only remain false if all of our 3 attempts completely failed
    if (!foundpath)
        return(E_FAIL);

    pszTargetjdw = wcsrchr( pszDirectorydjr, L'\"' );
    if( pszTargetjdw )
    {
        *pszTargetjdw = 0;
    }

    if( L'\"' == pszDirectorydjr[0] )
    {
        pszTargetjdw = &pszDirectorydjr[1];
    }
    else
    {
        pszTargetjdw = pszDirectorydjr;
    }
    
    //now that we have our final ptr, we can actually make the call to cecreateprocess and run it
    if( CeCreateProcess( pszTargetjdw,
                         m_szCompletePath,
                         NULL,
                         NULL,
                         FALSE,
                         0,
                         NULL,
                         NULL,
                         NULL,
                         &pi ) )
    {
        //close everything down
        CeCloseHandle( pi.hThread );
        CeCloseHandle( pi.hProcess );
    }
    else
    {
        hr = CeGetLastError();
        if( SUCCEEDED( hr ) )
        {
            hr = CeRapiGetError();
        }
    }

    return( hr );
}

//
// IMDSPObject
//

STDMETHODIMP CStorage::Open( UINT fuMode)
{
    HRESULT hr = S_OK;
    DWORD dwAccess = 0;
    if( fuMode & MDSP_READ )
    {
        dwAccess |= GENERIC_READ;
    }

    if( fuMode & MDSP_WRITE )
    {
        dwAccess |= GENERIC_WRITE;
    }

    if( INVALID_HANDLE_VALUE == m_hFile )
    {
        m_hFile = CeCreateFile( m_szCompletePath, dwAccess, 0, NULL, OPEN_EXISTING, NULL, NULL );

        if( INVALID_HANDLE_VALUE == m_hFile )
        {
            hr = HRESULT_FROM_WIN32( CeGetLastError() );
            if( SUCCEEDED( hr ) )
            {
                hr = CeRapiGetError();
            }
        }
    }
    else
    {
        hr = E_FAIL; // Already open???  What do you do???
    }

    return( hr );
}

STDMETHODIMP CStorage::Read( BYTE  *pData, DWORD  *pdwSize, BYTE  abMac[ 20 ] )
{
	HRESULT hr = S_OK;
	DWORD dwToRead;
    DWORD dwRead;
    BYTE *pTmpData=NULL; 


    if( NULL == pData || NULL == pdwSize )
    {
        return( E_INVALIDARG );
    }

    dwToRead=*pdwSize;
    *pdwSize = 0;

	pTmpData = new BYTE [dwToRead] ;
    if( NULL == pTmpData )
    {
        hr = E_OUTOFMEMORY;
    }

    if( SUCCEEDED( hr ) )
    {
	    if( CeReadFile(m_hFile, pTmpData, dwToRead, &dwRead, NULL) ) 
	    { 
		    *pdwSize = dwRead; 

		    // MAC the parameters
	        HMAC hMAC;
		    
		    hr = g_pAppSCServer->MACInit(&hMAC);
            if( SUCCEEDED( hr ) )
            {
		        hr = g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pTmpData), dwRead);
            }

            if( SUCCEEDED( hr ) )
            {
		        hr = g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pdwSize), sizeof(DWORD));
            }

            if( SUCCEEDED( hr ) )
            {
	            hr = g_pAppSCServer->MACFinal(hMAC, abMac);
            }

            if( SUCCEEDED( hr ) )
            {
		        hr = g_pAppSCServer->EncryptParam(pTmpData, dwRead);
            }

            if( SUCCEEDED( hr ) )
            {
    		    memcpy(pData, pTmpData, dwRead);
            }
	    }
        else
        { 
            hr = HRESULT_FROM_WIN32( CeGetLastError() );
            if( SUCCEEDED( hr ) )
            {
                hr = CeRapiGetError();
            }
        }
    }
	
    if( FAILED( hr ) )
    {
        *pdwSize = 0;
    }

	delete [] pTmpData;

	return hr;
}

STDMETHODIMP CStorage::Write( BYTE  *pData, DWORD *pdwSize, BYTE  abMac[ 20 ] )
{
	HRESULT hr = S_OK;
	DWORD dwWritten;
    BYTE *pTmpData=NULL;
    BYTE pSelfMac[WMDM_MAC_LENGTH];
	HMAC hMAC;
    DWORD dwSize = 0;

    if( NULL == pData || NULL == pdwSize )
    {
        return( E_INVALIDARG );
    }

    dwSize = *pdwSize;
    *pdwSize = 0;

	pTmpData = new BYTE [dwSize];
    if( NULL == pTmpData )
    {
        hr = E_OUTOFMEMORY;
    }

    if( SUCCEEDED( hr ) )
    {
        memcpy(pTmpData, pData, dwSize);
    }

    // Decrypt the pData Parameter
    if( SUCCEEDED( hr ) )
    {
	    hr = g_pAppSCServer->DecryptParam(pTmpData, dwSize);
    }
	
    if( SUCCEEDED( hr ) )
    {
	    hr = g_pAppSCServer->MACInit(&hMAC);
    }

    if( SUCCEEDED( hr ) )
    {
	    hr = g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pTmpData), dwSize);
    }

    if( SUCCEEDED( hr ) )
    {
	    hr = g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(&dwSize), sizeof(dwSize));
    }

    if( SUCCEEDED( hr ) )
    {
	    hr = g_pAppSCServer->MACFinal(hMAC, pSelfMac);
    }

    if( SUCCEEDED( hr ) )
    {
	    if (memcmp(abMac, pSelfMac, WMDM_MAC_LENGTH) != 0)
	    {
		    hr = WMDM_E_MAC_CHECK_FAILED;
	    }
    }

    if( SUCCEEDED( hr ) )
    {
	    if( !CeWriteFile(m_hFile, pTmpData, dwSize, &dwWritten,NULL) ) 
        {
		    hr = HRESULT_FROM_WIN32( CeGetLastError() );
            if( SUCCEEDED( hr ) )
            {
                hr = CeRapiGetError();
            }
        }
    }

    if( SUCCEEDED( hr ) && NULL != pdwSize )
    {
        *pdwSize = dwSize;
    }

    delete [] pTmpData;

    return( hr );
}
       
STDMETHODIMP CStorage::Delete(  UINT fuFlags, IWMDMProgress  *pProgress )
{
    HRESULT hr = S_OK;
    BOOL bRecursive = (fuFlags & WMDM_MODE_RECURSIVE);

    if( bRecursive &&
        !( m_findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
    {
        return( E_INVALIDARG );
    }

    if( m_findData.dwFileAttributes & FILE_ATTRIBUTE_INROM )
    {
        return( E_ACCESSDENIED );
    }

    if( ! ( m_findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
    {
        if( !CeDeleteFile(m_szCompletePath) )
        {
            hr = HRESULT_FROM_WIN32( CeGetLastError() );
            if( SUCCEEDED( hr ) )
            {
                hr = CeRapiGetError();
            }
        }
    }
    else
    {
        hr = DeleteDirectory(m_szCompletePath, bRecursive);
    }

    if( pProgress )
    {
        pProgress->Progress( 100 );
    }

    return( hr );
}

STDMETHODIMP CStorage::Seek( UINT fuFlags, DWORD dwOffset)
{
    HRESULT hr = S_OK;
    DWORD dwMoveMethod = 0;

    switch( fuFlags )
    {
    case MDSP_SEEK_CUR:
        dwMoveMethod = FILE_CURRENT;
        break;
    case MDSP_SEEK_EOF:
        dwMoveMethod = FILE_END;
        break;
    case MDSP_SEEK_BOF:
    default:
        dwMoveMethod = FILE_BEGIN;
        break;
    }

    if( !CeSetFilePointer( m_hFile, dwOffset, NULL, dwMoveMethod ) )
    {
        hr = HRESULT_FROM_WIN32( CeGetLastError() );
        if( SUCCEEDED( hr ) )
        {
            hr = CeRapiGetError();
        }
    }

    return( hr );
}

STDMETHODIMP CStorage::Rename( LPWSTR pwszNewName, IWMDMProgress *pProgress )
{
    HRESULT hr = S_OK;
    WCHAR wszRenamePath[2*MAX_PATH];
    LPWSTR pszSlash = NULL;

    if( NULL == pwszNewName )
    {
        return( E_INVALIDARG );
    }
    
    memset( wszRenamePath, 0, sizeof(wszRenamePath) );

    pszSlash = wcsrchr( m_szCompletePath, L'\\');

    if( pszSlash )
    {
        wcsncpy( wszRenamePath, m_szCompletePath, (pszSlash - m_szCompletePath) + 1 );
        wszRenamePath[ (pszSlash - m_szCompletePath) + 1 ] = L'\0';
    }

    wcsncat( wszRenamePath, pwszNewName, sizeof(wszRenamePath)/sizeof(wszRenamePath[0]) - ( wcslen(wszRenamePath) + 1 ) );

    if( !CeMoveFile( m_szCompletePath, wszRenamePath ) )
    {
        hr = HRESULT_FROM_WIN32( CeGetLastError() );
        if( SUCCEEDED( hr ) )
        {
            hr = CeRapiGetError();
        }
    }
    else
    {
        HANDLE hFind = CeFindFirstFile( wszRenamePath, &m_findData );

        if( INVALID_HANDLE_VALUE == hFind )
        {
            hr = HRESULT_FROM_WIN32( CeGetLastError() );
            if( SUCCEEDED( hr ) )
            {
                hr = CeRapiGetError();
            }
        }
        else
        {
            memset( m_szCompletePath, 0, sizeof(m_szCompletePath) );
            wcsncpy( m_szCompletePath, wszRenamePath, sizeof(m_szCompletePath)/sizeof(m_szCompletePath[0]) - 1 );
            CeFindClose( hFind );
        }
    }

    if( pProgress )
    {
        pProgress->Progress( 100 );
    }

    return( hr );
}

STDMETHODIMP CStorage::Move( UINT fuMode, IWMDMProgress  *pProgress, IMDSPStorage  *pTarget )
{
    HRESULT hr = E_NOTIMPL;

    if( pProgress )
    {
        pProgress->Progress( 100 );
    }

    return( hr );
}

STDMETHODIMP CStorage::Close( void )
{
    HRESULT hr = S_OK;

    if( INVALID_HANDLE_VALUE != m_hFile  )
    {
        if( !CeCloseHandle( m_hFile ) )
        {
            hr = HRESULT_FROM_WIN32( CeGetLastError() );
            if( SUCCEEDED( hr ) )
            {
                hr = CeRapiGetError();
            }
        }
        else
        {
            m_hFile = INVALID_HANDLE_VALUE;
        }
    }

    return( hr );
}

//
// IMDSPObjectInfo
//

STDMETHODIMP CStorage::GetPlayLength( DWORD *pdwLength)
{
    return( E_NOTIMPL );
}

STDMETHODIMP CStorage::SetPlayLength( DWORD dwLength)
{
    return( E_NOTIMPL );
}

STDMETHODIMP CStorage::GetPlayOffset( DWORD *pdwOffset )
{
    return( E_NOTIMPL );
}

STDMETHODIMP CStorage::SetPlayOffset( DWORD dwOffset )
{
    return( E_NOTIMPL );
}

STDMETHODIMP CStorage::GetTotalLength( DWORD *pdwLength )
{
    return( E_NOTIMPL );
}

STDMETHODIMP CStorage::GetLastPlayPosition( DWORD *pdwLastPos )
{
    return( E_NOTIMPL );
}

STDMETHODIMP CStorage::GetLongestPlayPosition(DWORD *pdwLongestPos )
{
    return( E_NOTIMPL );
}

//
// Helper functions
//
HRESULT CStorage::DeleteDirectory(LPCWSTR pszPath, BOOL bRecursive)
{
    HRESULT hr = S_OK;
    CE_FIND_DATA *rgFindData =NULL;
    DWORD dwCount;
    WCHAR szSearchPath[MAX_PATH];
    DWORD iFile;

    if( NULL == pszPath )
    {
        return( E_INVALIDARG );
    }

    if( !bRecursive )
    {
        if( !CeRemoveDirectory(pszPath) )
        {
            hr = HRESULT_FROM_WIN32( CeGetLastError() );
            if( SUCCEEDED( hr ) )
            {
                hr = CeRapiGetError();
            }
        }
    }
    else
    {
        memset( szSearchPath, 0, sizeof(szSearchPath) );
        if( m_fRoot )
        {
            _snwprintf( szSearchPath, sizeof(szSearchPath)/sizeof(szSearchPath[0]) - 1, L"%s*.*", pszPath );
        }
        else
        {
            _snwprintf( szSearchPath, sizeof(szSearchPath)/sizeof(szSearchPath[0]) - 1, L"%s\\*.*", pszPath );
        }
    
        if( !CeFindAllFiles( szSearchPath,
                        FAF_ATTRIBUTES | 
                        FAF_CREATION_TIME | 
                        FAF_LASTACCESS_TIME | 
                        FAF_LASTWRITE_TIME  | 
                        FAF_SIZE_HIGH | 
                        FAF_SIZE_LOW | 
                        FAF_OID | 
                        FAF_NAME,
                        &dwCount,
                        &rgFindData ) )
        {
            hr = HRESULT_FROM_WIN32( CeGetLastError() );
            if( SUCCEEDED( hr ) )
            {
                hr = CeRapiGetError();
            }
        }

        if( SUCCEEDED( hr ) )
        {
            for( iFile = 0; iFile < dwCount && SUCCEEDED( hr ); iFile++ )
            {       
                memset( szSearchPath, 0, sizeof(szSearchPath) );

                if( m_fRoot )
                {
                    _snwprintf( szSearchPath, sizeof(szSearchPath)/sizeof(szSearchPath[0]) - 1, L"%s*.*", rgFindData[iFile].cFileName);
                }
                else
                {
                    _snwprintf( szSearchPath, sizeof(szSearchPath)/sizeof(szSearchPath[0]) - 1, L"%s\\*.*", rgFindData[iFile].cFileName);
                }

                if( rgFindData[iFile].dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
                {
                    hr = DeleteDirectory(szSearchPath, bRecursive );
                }
                else
                {
                    if( !CeDeleteFile( szSearchPath ) )
                    {
                        hr = HRESULT_FROM_WIN32( CeGetLastError() );
                        if( SUCCEEDED( hr ) )
                        {
                            hr = CeRapiGetError();
                        }
                    }
                }
            }

            if( rgFindData )
            {
                CeRapiFreeBuffer( rgFindData );
            }
        }

        if( SUCCEEDED( hr ) )
        {
            if( !CeRemoveDirectory(pszPath) )
            {
                hr = HRESULT_FROM_WIN32( CeGetLastError() );
                if( SUCCEEDED( hr ) )
                {
                    hr = CeRapiGetError();
                }
            }
        }
    }
    
    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\hdsppch.h ===
//
//  Microsoft Windows Media Technologies
//   1999 Microsoft Corporation.  All rights reserved.
//
//  Refer to your End User License Agreement for details on your rights/restrictions to use these sample files.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__896E741D_3851_11D3_AA54_00C04FD22F6C__INCLUDED_)
#define AFX_STDAFX_H__896E741D_3851_11D3_AA54_00C04FD22F6C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include "hdspRC.h"       // main symbols
#include "LyraSP.h"
#include "MdspDefs.h"
#include "loghelp.h"
#include "scserver.h"

#include "MDServiceProvider.h"
#include "MDSPDevice.h"
#include "MDSPStorage.h"
#include "MDSPStorageGlobals.h"
#include "MDSPEnumDevice.h"
#include "MDSPEnumStorage.h"
#include <stdio.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__896E741D_3851_11D3_AA54_00C04FD22F6C__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\hdsppch.cpp ===
//
//  Microsoft Windows Media Technologies
//   1999 Microsoft Corporation.  All rights reserved.
//
//  Refer to your End User License Agreement for details on your rights/restrictions to use these sample files.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


//  stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "hdspPCH.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\hdsprc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Mdsp.rc
//
#define IDS_PROJNAME                    100
#define IDR_MDSERVICEPROVIDER           101
#define IDR_MDSPENUMDEVICE              102
#define IDS_STRING_SPPROGID             102
#define IDR_MDSPDEVICE                  103
#define IDR_MDSPENUMFORMATSUPPORT       104
#define IDR_MDSPENUMSTORAGE             105
#define IDR_MDSPSTORAGE                 106
#define IDR_MDSPSTORAGEGLOBALS          107
#define IDI_ICON_PM                     201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\loghelp.cpp ===
//
//  Microsoft Windows Media Technologies
//   1999 Microsoft Corporation.  All rights reserved.
//
//  Refer to your End User License Agreement for details on your rights/restrictions to use these sample files.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


#include "hdspPCH.h"
#include "wmdmlog_i.c"

BOOL fIsLoggingEnabled( VOID )
{
     static BOOL  fEnabled = FALSE;
    HRESULT      hr;
    IWMDMLogger *pLogger  = NULL;
    static BOOL  fChecked = FALSE;

    if( !fChecked )
    {
        fChecked = TRUE;

        hr = CoCreateInstance(
			CLSID_WMDMLogger,
			NULL,
			CLSCTX_INPROC_SERVER,
			IID_IWMDMLogger,
			(void**)&pLogger
		);
	    CORg( hr );

        hr = pLogger->IsEnabled( &fEnabled );
	    CORg( hr );
    }

Error:

    if( NULL != pLogger )
    {
        pLogger->Release();
        pLogger = NULL;
    }

    return fEnabled;
}

HRESULT hrLogString(LPSTR pszMessage, HRESULT hrSev)
{
    HRESULT      hr=S_OK;
    IWMDMLogger *pLogger = NULL;

    if( !fIsLoggingEnabled() )
    {
        return S_FALSE;
    }

    hr = CoCreateInstance(
		CLSID_WMDMLogger,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_IWMDMLogger,
		(void**)&pLogger
	);
    CORg( hr );

    hr = pLogger->LogString(
		( FAILED(hrSev) ? WMDM_LOG_SEV_ERROR : WMDM_LOG_SEV_INFO ),
		"LyraSP",
		pszMessage
	);
    CORg( hr );

Error:

    if( pLogger )
	{
        pLogger->Release();
	}
  
	return hr;
}

HRESULT hrLogDWORD(LPSTR pszFormat, DWORD dwValue, HRESULT hrSev)
{
    HRESULT      hr=S_OK;
    IWMDMLogger *pLogger = NULL;

    if( !fIsLoggingEnabled() )
    {
        return S_FALSE;
    }

    hr = CoCreateInstance(
		CLSID_WMDMLogger,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_IWMDMLogger,
		(void**)&pLogger
	);
    CORg( hr );

    hr = pLogger->LogDword(
		( FAILED(hrSev) ? WMDM_LOG_SEV_ERROR : WMDM_LOG_SEV_INFO ),
		"LyraSP",
		pszFormat,
		dwValue
	);
    CORg( hr );

Error:

    if( pLogger )
	{
        pLogger->Release();
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\loghelp.h ===
//
//  Microsoft Windows Media Technologies
//   1999 Microsoft Corporation.  All rights reserved.
//
//  Refer to your End User License Agreement for details on your rights/restrictions to use these sample files.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


#include "wmdmlog.h"

HRESULT hrLogString(LPSTR pszMessage, HRESULT hrSev);
HRESULT hrLogDWORD(LPSTR pszFormat, DWORD dwValue, HRESULT hrSev);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\mdserviceprovider.cpp ===
//
//  Microsoft Windows Media Technologies
//   1999 Microsoft Corporation.  All rights reserved.
//
//  Refer to your End User License Agreement for details on your rights/restrictions to use these sample files.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 

// MDServiceProvider.cpp : Implementation of CMDServiceProvider

#include "hdspPCH.h"
#include "key.c"

/////////////////////////////////////////////////////////////////////////////
// CMDServiceProvider
CMDServiceProvider::~CMDServiceProvider()
{
	if( m_hThread )
	{
		CloseHandle( m_hThread );
	}

	if( g_pAppSCServer )
	{
		delete g_pAppSCServer;
		g_pAppSCServer = NULL;
	}
}

CMDServiceProvider::CMDServiceProvider()
{
	g_pAppSCServer = new CSecureChannelServer();

	if( g_pAppSCServer )
	{
		g_pAppSCServer->SetCertificate(
			SAC_CERT_V1,
			(BYTE*)abCert, sizeof(abCert),
			(BYTE*)abPVK, sizeof(abPVK)
		);
	}	

    m_hThread = NULL;

	g_CriticalSection.Lock();
	ZeroMemory(
		g_GlobalDeviceInfo,
		sizeof(MDSPGLOBALDEVICEINFO)*MDSP_MAX_DEVICE_OBJ
	);
	g_bIsWinNT=IsWinNT();
    g_CriticalSection.Unlock();

		
	return;
}

static LPCSTR rgLyraKeys[] =
{
    "Software\\Thomson Consumer Electronics, Inc\\USB CompactFlash External Drive",
    "Software\\Thomson Consumer Electronics, Inc\\CompactFlash External Drive",
    "Software\\Thomson Multimedia\\USB CompactFlash External Drive",
    "Software\\Thomson Multimedia\\CompactFlash External Drive"
};

STDMETHODIMP CMDServiceProvider::GetDeviceCount(DWORD * pdwCount)
{
	HRESULT hr        = E_FAIL;
	CHAR    szDrive[] = "?:";
	INT     i = 0;
	INT     cnt = 0;
    BOOL    fFoundLyraKey = FALSE;
    HKEY    hKey = NULL;

    CFRg( g_pAppSCServer );
    if( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg( WMDM_E_NOTCERTIFIED );
	}
    
	CARg( pdwCount );

    for( i = 0;
         (!fFoundLyraKey) && (i < sizeof(rgLyraKeys)/sizeof(rgLyraKeys[0]));
         i++ )
    {
        if( ERROR_SUCCESS == RegOpenKeyExA( HKEY_LOCAL_MACHINE,
                                            rgLyraKeys[i],
                                            0,
                                            KEY_READ, 
                                            &hKey ) )
        {
            fFoundLyraKey = TRUE;
        }
    }

    if( fFoundLyraKey )
    {
	    for( i=LYRA_START_DRIVE_NUM; i<MDSP_MAX_DRIVE_COUNT; i++ )
	    {
		    szDrive[0] = 'A' + i;
		    if( UtilGetLyraDriveType(szDrive) == DRIVE_LYRA_TYPE )
		    {
			    cnt++;
		    }
	    }
    }

	*pdwCount = cnt;

	hr = S_OK;

Error:

    hrLogDWORD("IMDServiceProvider::GetDeviceCount returned 0x%08lx", hr, hr);

    if( NULL != hKey )
    {
        RegCloseKey( hKey );
    }

	return hr;
}


STDMETHODIMP CMDServiceProvider::EnumDevices(IMDSPEnumDevice **ppEnumDevice)
{
	HRESULT hr = E_FAIL;
	CComObject<CMDSPEnumDevice> *pEnumObj;
	INT     i = 0;
    BOOL    fFoundLyraKey = FALSE;
    HKEY    hKey = NULL;

	CFRg( g_pAppSCServer );
    if( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg( WMDM_E_NOTCERTIFIED );
	}
	CARg( ppEnumDevice );

    for( i = 0;
     (!fFoundLyraKey) && (i < sizeof(rgLyraKeys)/sizeof(rgLyraKeys[0]));
     i++ )
    {
        if( ERROR_SUCCESS == RegOpenKeyExA( HKEY_LOCAL_MACHINE,
                                            rgLyraKeys[i],
                                            0,
                                            KEY_READ, 
                                            &hKey ) )
        {
            fFoundLyraKey = TRUE;
        }
    }
    
    if( !fFoundLyraKey )
    {
        *ppEnumDevice = NULL;
        return( E_FAIL );
    }

	hr = CComObject<CMDSPEnumDevice>::CreateInstance( &pEnumObj );
	if( SUCCEEDED(hr) )
	{
		hr = pEnumObj->QueryInterface(
			IID_IMDSPEnumDevice,
			reinterpret_cast<void**>(ppEnumDevice)
		);
		if( FAILED(hr) )
		{
			delete pEnumObj;
			goto Error;
		}
	}

	hr = S_OK;

Error:

    hrLogDWORD("IMDServiceProvider::EnumDevices returned 0x%08lx", hr, hr);

    if( NULL != hKey )
    {
        RegCloseKey( hKey );
    }

	return hr;
}


STDMETHODIMP CMDServiceProvider::SACAuth(
	DWORD   dwProtocolID,
	DWORD   dwPass,
	BYTE   *pbDataIn,
	DWORD   dwDataInLen,
	BYTE  **ppbDataOut,
	DWORD  *pdwDataOutLen)
{
    HRESULT hr = E_FAIL;

	CFRg( g_pAppSCServer );

    hr = g_pAppSCServer->SACAuth(
		dwProtocolID,
		dwPass,
		pbDataIn, dwDataInLen,
		ppbDataOut, pdwDataOutLen
	);
	CORg( hr );
    
	hr = S_OK;

Error:
    
	hrLogDWORD("IComponentAuthenticate::SACAuth returned 0x%08lx", hr, hr);

    return hr;
}

STDMETHODIMP CMDServiceProvider::SACGetProtocols(
	DWORD **ppdwProtocols,
	DWORD  *pdwProtocolCount)
{
    HRESULT hr = E_FAIL;

	CFRg( g_pAppSCServer );

	hr = g_pAppSCServer->SACGetProtocols(
		ppdwProtocols,
		pdwProtocolCount
	);
	CORg( hr );
    
	hr = S_OK;

Error:
    
    hrLogDWORD("IComponentAuthenticate::SACGetProtocols returned 0x%08lx", hr, hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\key.c ===
#include "wtypes.h"

const BYTE abPVK[] = {
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 
	0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 
	0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 
	0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 
	0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 
	0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 
	0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 
	0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 
	0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 
	0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 
	0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 
	0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 
	0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 
	0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 
	0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 
	0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 
	0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 
	0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 
	0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 
	0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 
	0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 
	0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 
	0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 
	0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 
	0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 
	0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 
	0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 
	0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 
	0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 
	0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 
	0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 
	0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 
	0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 
	0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 
	0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 
	0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 
	0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 
	0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 
	0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 
	0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 
	0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 
	0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 
	0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 
	0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 
	0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 
	0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 
	0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 
	0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 
	0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 
	0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 
	0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 
	0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 
	0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 
	0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 
	0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 
	0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 
	0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 
	0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 
	0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 
	0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 
	0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 
	0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 
	0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 
	0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 
	0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 
	0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 
	0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 
	0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 
	0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 
	0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 
	0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 
	0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 
	0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 
	0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 
	0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 
	0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 
	0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 
	0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 
	0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 
	0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 
	0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x14, 0x48, 0xB0, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 
	0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 
	0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x26, 0x2D, 
	0x09, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x56, 0x3E, 0xF8, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 
	0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 
	0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 
	0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x4E, 0x26, 
	0x81, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0x64, 0xFA, 0x8C, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x22, 
	0x81, 0x1B, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x58, 0x4C, 0x0B, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x54, 0x8F, 0xDD, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 
	0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x0D, 0x37, 0xFD, 0x62, 
	0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 
	0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 
	0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 
	0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 
	0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 
	0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x5E, 0x02, 0x67, 
	0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 
	0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 
	0x9E, 0xC4, 0xC5, 0xD5, 0x7D, 0xC3, 0xCB, 0x22, 
	0x1A, 0x0A, 0xE5, 0x57, 0xCF, 0xAB, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x1A, 0x5D, 0x0E, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 
	0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 
	0x07, 0xCD, 0x22, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x65, 0x0A, 0xAE, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0x74, 
	0xDC, 0x97, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x70, 0x96, 0xD9, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0x2C, 0xE7, 0x5D, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x3F, 0x15, 0xB4, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0x95, 0x32, 
	0x86, 0x72, 0x41, 0x37, 0xC8, 0xCB, 0x9D, 0x31, 
	0xBE, 0x6C, 0xF7, 0xB1, 0xCA, 0x62, 0xD4, 0x69, 
	0x37, 0x70, 0x8A, 0x87, 0x2F, 0x1D, 0xDA, 0x7D, 
	0x58, 0x8A, 0x7D, 0x9F, 0xDC, 0xE2, 0x8E, 0x51, 
	0xE3, 0x73, 0x04, 0xF8, 0x54, 0xC1, 0x10, 0xBA, 
	0x97, 0xFE, 0xF0, 0x58, 0xEC, 0xB5, 0x8D, 0x06, 
	0x7C, 0xD0, 0x79, 0x58, 0x22, 0xB3, 0x3F, 0xED, 
	0xAA, 0x00, 0x29, 0x89, 0x9F, 0x7B, 0x0E, 0xD3, 
	0x49, 0x89, 0x79, 0x6D, 0x41, 0xCF, 0x30, 0x07, 
	0x23, 0x90, 0x96, 0xEF, 0xFF, 0x44, 0x9F, 0x61, 
	0xF5, 0x16, 0x31, 0x88, 0xD7, 0xDE, 0x5D, 0xE0, 
	0x8F, 0xE2, 0xA2, 0x9C, 0x8A, 0x97, 0xB8, 0x02, 
	0x93, 0x1E, 0xCD, 0xF0, 0x12, 0xFE, 0x87, 0x2A, 
	0x55, 0x6C, 0x9B, 0x0E, 0xAD, 0xA4, 0xEC, 0xA1, 
	0xD4, 0x84, 0xB6, 0x30, 0xFD, 0x93, 0x4F, 0x03, 
	0x34, 0x17, 0xE2, 0x71, 0x68, 0x44, 0xFD, 0xD0, 
	0x13, 0x25, 0x92, 0x61, 0x58, 0x7F, 0x55, 0xF6, 
	0x11, 0x67, 0xB7, 0x24, 0x6F, 0x50, 0x59, 0x77, 
	0x90, 0x1E, 0xFE, 0x26, 0x56, 0x9E, 0xCE, 0xEE, 
	0x16, 0xFA, 0x26, 0xEE, 0x6B, 0x3E, 0x05, 0xC4, 
	0x23, 0x76, 0x7D, 0x64, 0x7F, 0x5B, 0xBD, 0x7E, 
	0x4C, 0x65, 0xCF, 0xD7, 0x60, 0x0E, 0xCA, 0xBA, 
	0xAE, 0x1B, 0x0E, 0x15, 0xD5, 0x7E, 0x88, 0x28, 
	0x59, 0x68, 0x9F, 0xA1, 0x1C, 0x6E, 0x1A, 0xC2, 
	0x92, 0x6D, 0x7F, 0x90, 0x53, 0xFD, 0xD5, 0x42, 
	0x2A, 0x3B, 0xEE, 0x41, 0xD0, 0x2F, 0xA1, 0x89, 
	0x69, 0xE6, 0xF5, 0x7F, 0xC8, 0x4F, 0xB1, 0xBA, 
	0x72, 0xEF, 0xBD, 0xBA, 0xA8, 0x54, 0x38, 0x9B, 
	0xF9, 0xF5, 0xBA, 0x25, 0xA4, 0xB4, 0xA5, 0x20, 
	0x9F, 0x86, 0x9D, 0x17, 0x7D, 0xD7, 0x00, 0x14
};

const BYTE abCert[] = {
	0x00, 0x01, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
	0x52, 0x54, 0xF3, 0xCA, 0x33, 0x87, 0x2B, 0xF8, 
	0xD4, 0x59, 0x9D, 0x31, 0x23, 0x78, 0x16, 0x48, 
	0x04, 0x0B, 0x48, 0x17, 0xC4, 0xF1, 0xA7, 0x57, 
	0xB4, 0x87, 0xF8, 0xA8, 0x43, 0x6F, 0x71, 0x73, 
	0x71, 0x03, 0xCA, 0x47, 0x92, 0xF6, 0xED, 0x1C, 
	0x5C, 0x20, 0x19, 0x8D, 0x2A, 0xB8, 0x98, 0xDA, 
	0xDF, 0xAD, 0x85, 0xF7, 0x9A, 0x68, 0x92, 0x5E, 
	0x86, 0x3B, 0x72, 0x40, 0xFD, 0xF3, 0x73, 0xE4, 
	0xCB, 0xF5, 0xBB, 0x9F, 0x91, 0xEF, 0xE0, 0x25, 
	0x4F, 0x9C, 0x82, 0x97, 0xFA, 0xD2, 0x9D, 0x15, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE8, 
	0x00, 0x00, 0x00, 0x1A
};
//=======================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\mdserviceprovider.h ===
//
//  Microsoft Windows Media Technologies
//   1999 Microsoft Corporation.  All rights reserved.
//
//  Refer to your End User License Agreement for details on your rights/restrictions to use these sample files.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDServiceProvider.h : Declaration of the CMDServiceProvider

#ifndef __MDSERVICEPROVIDER_H_
#define __MDSERVICEPROVIDER_H_

/////////////////////////////////////////////////////////////////////////////
// CMDServiceProvider
class ATL_NO_VTABLE CMDServiceProvider : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMDServiceProvider, &CLSID_MDServiceProvider>,
	public IMDServiceProvider,
	public IComponentAuthenticate
{
public:
	CMDServiceProvider();
	~CMDServiceProvider();

DECLARE_CLASSFACTORY_SINGLETON(CMDServiceProvider)
DECLARE_REGISTRY_RESOURCEID(IDR_MDSERVICEPROVIDER)

BEGIN_COM_MAP(CMDServiceProvider)
	COM_INTERFACE_ENTRY(IMDServiceProvider)
	COM_INTERFACE_ENTRY(IComponentAuthenticate)
END_COM_MAP()

// IMDServiceProvider
public:
	DWORD m_dwThreadID;
	HANDLE m_hThread;
	STDMETHOD(EnumDevices)(/*[out]*/ IMDSPEnumDevice **ppEnumDevice);
	STDMETHOD(GetDeviceCount)(/*[out]*/ DWORD *pdwCount);
    STDMETHOD(SACAuth)(DWORD dwProtocolID,
                       DWORD dwPass,
                       BYTE *pbDataIn,
                       DWORD dwDataInLen,
                       BYTE **ppbDataOut,
                       DWORD *pdwDataOutLen);
    STDMETHOD(SACGetProtocols)(DWORD **ppdwProtocols,
                               DWORD *pdwProtocolCount);
};

#endif //__MDSERVICEPROVIDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\mdsp.cpp ===
//
//  Microsoft Windows Media Technologies
//   1999 Microsoft Corporation.  All rights reserved.
//
//  Refer to your End User License Agreement for details on your rights/restrictions to use these sample files.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 

// Mdsp.cpp : Implementation of MSHDSP.DLL's DLL Exports.

#include "hdspPCH.h"
#include "initguid.h"
#include "LyraSP_i.c"

CComModule            _Module;
HINSTANCE             g_hinstance; 
MDSPGLOBALDEVICEINFO  g_GlobalDeviceInfo[MDSP_MAX_DEVICE_OBJ];
WCHAR                 g_wcsBackslash[2] = { (WCHAR)0x5c, NULL };
CHAR                  g_szBackslash[2]  = { (CHAR)0x5c, NULL };
CSecureChannelServer *g_pAppSCServer=NULL;
CComMultiThreadModel::AutoCriticalSection g_CriticalSection;
BOOL				  g_bIsWinNT; 

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_MDServiceProvider, CMDServiceProvider)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	lpReserved;
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();

	g_hinstance = hInstance; 
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HKEY hKey;
	LONG lRet;

	lRet = RegCreateKeyEx(
		HKEY_LOCAL_MACHINE,
		STR_MDSPREG,
		0,
		NULL, 
		REG_OPTION_NON_VOLATILE,
		KEY_READ | KEY_WRITE,
		NULL,
		&hKey,
		NULL
	);
	if( ERROR_SUCCESS == lRet )
	{
	    CHAR szTemp[MAX_PATH];

		// Register the ProgID with WMDM
		//
		strcpy( szTemp, STR_MDSPPROGID );

		RegSetValueEx(
			hKey,
			"ProgID",
			0,
			REG_SZ,
			(LPBYTE)szTemp,
			lstrlen( szTemp ) + 1
		);

		RegCloseKey( hKey );

		// Register object, typelib and all interfaces in typelib
		//
		return _Module.RegisterServer(TRUE);
	}
	else
	{
		return REGDB_E_WRITEREGDB;
	}

}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();

    RegDeleteKey(HKEY_LOCAL_MACHINE, STR_MDSPREG);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\mdspdefs.h ===
//
//  Microsoft Windows Media Technologies
//   1999 Microsoft Corporation.  All rights reserved.
//
//  Refer to your End User License Agreement for details on your rights/restrictions to use these sample files.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


#ifndef __MDSPDEFS_H__
#define __MDSPDEFS_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "scserver.h"

typedef struct {
	BOOL  bValid;
	WCHAR wcsDevName[32];
	DWORD dwStatus;
	LPVOID pIMDSPStorageGlobals;
} MDSPGLOBALDEVICEINFO;

#define DRIVE_LYRA_TYPE		0xFF
#define LYRA_START_DRIVE_NUM 2

#define WMDM_WAVE_FORMAT_ALL   (WORD)0xFFFF
#define WCS_MIME_TYPE_ALL      L"*/*"

#define MDSP_MAX_DRIVE_COUNT   26
#define MDSP_MAX_DEVICE_OBJ    64

#define STR_MDSPREG            "Software\\Microsoft\\Windows Media Device Manager\\Plugins\\SP\\LyraSP"
#define STR_MDSPPROGID         "MDServiceProviderLyra.MDServiceProviderLyra" 

#define ALSO_CHECK_FILES

extern void wcsParseDeviceName(WCHAR *wcsIn, WCHAR **wcsOut);
extern HRESULT GetFileSizeRecursive(char *szPath, DWORD *pdwSizeLow, DWORD *pdwSizeHigh);
extern HRESULT DeleteFileRecursive(char *szPath);
extern HRESULT SetGlobalDeviceStatus(WCHAR *wcsName, DWORD dwStat, BOOL bClear);
extern HRESULT GetGlobalDeviceStatus(WCHAR *wcsNameIn, DWORD *pdwStat);
extern UINT __stdcall UtilGetLyraDriveType(LPSTR szDL);
extern BOOL IsWinNT();
extern BOOL UtilSetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes);
extern DWORD UtilGetFileAttributesW(LPCWSTR lpFileName);
extern HRESULT QuerySubFoldersAndFiles(LPCWSTR szCurrentFolder, DWORD *pdwAttr);
extern BOOL UtilCreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
extern HANDLE UtilCreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
extern BOOL UtilMoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
extern HRESULT DeleteFileRecursiveA(char *szPath);
extern HRESULT DeleteFileRecursiveW(WCHAR *wcsPath);

extern HINSTANCE             g_hinstance; 
extern MDSPGLOBALDEVICEINFO  g_GlobalDeviceInfo[MDSP_MAX_DEVICE_OBJ];
extern WCHAR                 g_wcsBackslash[];
extern CHAR                  g_szBackslash[];
extern CSecureChannelServer *g_pAppSCServer;
extern CComMultiThreadModel::AutoCriticalSection g_CriticalSection;
extern BOOL					 g_bIsWinNT;
  
#define	fFalse		    0
#define fTrue		    1

#define hrOK			HRESULT(S_OK)
#define hrTrue			HRESULT(S_OK)
#define hrFalse			ResultFromScode(S_FALSE)
#define hrFail			ResultFromScode(E_FAIL)
#define hrNotImpl		ResultFromScode(E_NOTIMPL)
#define hrNoInterface	ResultFromScode(E_NOINTERFACE)
#define hrNoMem			WMDM_E_BUFFERTOOSMALL
#define hrAbort			ResultFromScode(E_ABORT)
#define hrInvalidArg	ResultFromScode(E_INVALIDARG)

/*----------------------------------------------------------------------------
	CORg style error handling
	(Historicaly stands for Check OLE Result and Goto)
 ----------------------------------------------------------------------------*/

#define	CPRg(p)\
	do\
		{\
		if (!(p))\
			{\
			hr = hrNoMem;\
			goto Error;\
			}\
		}\
	while (fFalse)

#define	CHRg(hResult) CORg(hResult)

#define	CORg(hResult)\
	do\
		{\
		hr = (hResult);\
        if (FAILED(hr))\
            {\
            goto Error;\
            }\
		}\
	while (fFalse)

#define	CWRg(fResult)\
	{\
	if (!(fResult))\
		{\
        hr = GetLastError();\
	    if (!(hr & 0xFFFF0000)) hr = HRESULT_FROM_WIN32(hr);\
		goto Error;\
		}\
	}

#define	CFRg(fResult)\
	{\
	if (!(fResult))\
		{\
		hr = hrFail;\
		goto Error;\
		}\
	}

#define	CARg(p)\
	do\
		{\
		if (!(p))\
			{\
			hr = hrInvalidArg;\
			goto Error;\
			}\
		}\
	while (fFalse)


#endif // __MDSPDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\mdspdevice.cpp ===
//
//  Microsoft Windows Media Technologies
//   1999 Microsoft Corporation.  All rights reserved.
//
//  Refer to your End User License Agreement for details on your rights/restrictions to use these sample files.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 

// MDSPDevice.cpp : Implementation of CMDSPDevice

#include "hdspPCH.h"
#include "rescopy.h"
#include <SerialNumber.h>
#include <mmreg.h>

//
// Define some tables and constants we will need below
//

#define WAVE_FORMAT_MSAUDIO     0x161
static const _WAVEFORMATEX g_krgWaveFormats[] =
{
      // wFormatTag,             nChanneels, nSamplesPerSec, nAvgBytesPerSec, nBlockAlign, wBitsPerSample, cbSize
       { WAVE_FORMAT_MPEGLAYER3, 0,          0,              0,               0,           0,              0 },
       { WAVE_FORMAT_MSAUDIO,    2,          32000,          8000,            0,           0,              0 },
       { WAVE_FORMAT_MSAUDIO,    2,          44000,          20000,           0,           0,              0 }
};

static const LPCWSTR g_kszMimeTypes[] =
{
    L"audio/mpeg",
    L"audio/x-ms-wma"    
};

/////////////////////////////////////////////////////////////////////////////
// CMDSPDevice
HRESULT CMDSPDevice::InitGlobalDeviceInfo()
{
	return SetGlobalDeviceStatus(m_wcsName, 0, FALSE);
}

CMDSPDevice::CMDSPDevice() :
    m_fAlreadyCopiedResFiles( FALSE )
{
}

CMDSPDevice::~CMDSPDevice()
{	
}

STDMETHODIMP CMDSPDevice::GetName(LPWSTR pwszName, UINT nMaxChars)
{
	HRESULT hr = E_FAIL;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pwszName);
    CPRg(nMaxChars>wcslen(m_wcsName));

	if( m_wcsName[0] )
	{
		wcscpy(pwszName, L"Lyra ");
		wcscat(pwszName, m_wcsName);
		hr = S_OK;
	}
	else 
	{
		hr = WMDM_E_NOTSUPPORTED;
	}

Error:

    hrLogDWORD("IMDSPDevice::GetName returned 0x%08lx", hr, hr);
	
    return hr;
}

STDMETHODIMP CMDSPDevice::GetManufacturer(LPWSTR pwszName, UINT nMaxChars)
{
	HRESULT hr = S_OK;
	
	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pwszName);

	if(FAILED(UtilGetManufacturer(m_wcsName, &pwszName, nMaxChars)))
	{
		hr = E_NOTIMPL;
	}

Error:   

    hrLogDWORD("IMDSPDevice::GetManufacturer returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetVersion(DWORD * pdwVersion)
{
    HRESULT hr;
    
	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:

	hrLogDWORD("IMDSPDevice::GetVersion returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetType(DWORD * pdwType)
{
	HRESULT hr = S_OK;
    WMDMID  snTmp;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pdwType);

	*pdwType = WMDM_DEVICE_TYPE_STORAGE | WMDM_DEVICE_TYPE_NONSDMI;

	snTmp.cbSize = sizeof(WMDMID);

	hr = UtilGetSerialNumber(m_wcsName, &snTmp, FALSE);
	if( hr == S_OK )
	{
		*pdwType |= WMDM_DEVICE_TYPE_SDMI;
    }

	hr=S_OK;

Error:

    hrLogDWORD("IMDSPDevice::GetType returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetSerialNumber(
	PWMDMID pSerialNumber, 
	BYTE abMac[WMDM_MAC_LENGTH])
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pSerialNumber);

	hr = UtilGetSerialNumber(m_wcsName, pSerialNumber, TRUE);
	if( hr == HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) )
	{
		hr = WMDM_E_NOTSUPPORTED;
	}

	if( hr == S_OK )
	{
		// MAC the parameters
		HMAC hMAC;
		
		CORg(g_pAppSCServer->MACInit(&hMAC));
		CORg(g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pSerialNumber), sizeof(WMDMID)));
		CORg(g_pAppSCServer->MACFinal(hMAC, abMac));
	}

Error:

    hrLogDWORD("IMDSPDevice::GetSerialNumber returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetPowerSource(DWORD * pdwPowerSource, DWORD * pdwPercentRemaining)
{
	HRESULT hr=S_OK;

	CFRg(g_pAppSCServer);
    if( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pdwPowerSource);
	CARg(pdwPercentRemaining);

	*pdwPowerSource =   WMDM_POWER_CAP_EXTERNAL | 
						WMDM_POWER_IS_EXTERNAL |
						WMDM_POWER_PERCENT_AVAILABLE;
	*pdwPercentRemaining = 100;

Error:

    hrLogDWORD("IMDSPDevice::GetPowerSource returned 0x%08lx", hr, hr);

	return hr;
}

BOOL IsDriveReady(int nDriveNum)
{
    DWORD dwRet=ERROR_SUCCESS;

	// Disable drive error popup
	UINT uPrevErrMode=SetErrorMode(SEM_FAILCRITICALERRORS|SEM_NOOPENFILEERRORBOX);

	char szDL[32]="A:\\D569CFEE41e6A522E8F5.jnk";
	szDL[0] += (char)nDriveNum;

	HANDLE hFile=CreateFile(
					  szDL,                 // file name
					  0,                    // access mode
					  0,                    // share mode
					  NULL,					// SD
					  OPEN_EXISTING,        // how to create
					  0,					// file attributes
					  NULL                  // handle to template file
					  );

	if( hFile == INVALID_HANDLE_VALUE )
	{
		dwRet=GetLastError();
    }
	else 
	{
		CloseHandle(hFile); // rare situation when such a file exists.
	}

	// Restore default system error handling
	SetErrorMode(uPrevErrMode);

	return (ERROR_FILE_NOT_FOUND==dwRet || ERROR_SUCCESS==dwRet);
}


STDMETHODIMP CMDSPDevice::GetStatus(DWORD * pdwStatus)
{
	HRESULT hr = S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pdwStatus);

	CHRg(GetGlobalDeviceStatus(m_wcsName, pdwStatus));

	if( !( *pdwStatus & WMDM_STATUS_BUSY) )
	{
		if( IsDriveReady((m_wcsName[0]>96)?(m_wcsName[0]-L'a'):(m_wcsName[0]-L'A')))
		{
			*pdwStatus = WMDM_STATUS_READY;
		}
		else
		{
			*pdwStatus = WMDM_STATUS_STORAGE_NOTPRESENT;
		}
	}

	hr = S_OK;

Error:

    hrLogDWORD("IMDSPDevice::GetStatus returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetDeviceIcon(ULONG *hIcon)
{
	HRESULT hr = S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CFRg(g_hinstance);
    CARg(hIcon);
	CWRg( (*hIcon)=HandleToULong(LoadIconA(g_hinstance, MAKEINTRESOURCEA(IDI_ICON_PM)) ));

Error:

    hrLogDWORD("IMDSPDevice::GetDeviceIcon returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::SendOpaqueCommand(OPAQUECOMMAND *pCommand)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:

    hrLogDWORD("IMDSPDevice::SendOpaqueCommand returned 0x%08lx", hr, hr);

    return hr;
}

// IMDSPDeviceControl
STDMETHODIMP CMDSPDevice::GetDCStatus(/*[out]*/ DWORD *pdwStatus)
{
    HRESULT hr = E_FAIL;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = GetStatus(pdwStatus);

Error:

    hrLogDWORD("IMDSPDeviceControl::GetDCStatus returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetCapabilities(/*[out]*/ DWORD *pdwCapabilitiesMask)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    if( !pdwCapabilitiesMask )
	{
		return E_INVALIDARG;
	}
	*pdwCapabilitiesMask = WMDM_DEVICECAP_CANSTREAMPLAY;
	
    hr = S_OK;

Error:

    hrLogDWORD("IMDSPDeviceControl::GetCapabilities returned 0x%08lx", hr, hr);

    return S_OK;
}	

STDMETHODIMP CMDSPDevice::Play()
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:

    hrLogDWORD("IMDSPDeviceControl::Play returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPDevice::Record(/*[in]*/ _WAVEFORMATEX *pFormat)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:

    hrLogDWORD("IMDSPDeviceControl::Record returned 0x%08lx", hr, hr);
	
    return hr;
}

STDMETHODIMP CMDSPDevice::Pause()
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:

    hrLogDWORD("IMDSPDeviceControl::Pause returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::Resume()
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:

    hrLogDWORD("IMDSPDeviceControl::Resume returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPDevice::Stop()
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:

    hrLogDWORD("IMDSPDeviceControl::Stop returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPDevice::Seek(/*[in]*/ UINT fuMode, /*[in]*/ int nOffset)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:

    hrLogDWORD("IMDSPDeviceControl::Seek returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetFormatSupport(
	_WAVEFORMATEX **pFormatEx,
	UINT *pnFormatCount,
	LPWSTR **pppwszMimeType,
	UINT *pnMimeTypeCount)
{
    HRESULT hr = S_OK;
    UINT idxMimes = 0;
    UINT cMimes = 0;

    if( NULL != pnFormatCount )
    {
        *pnFormatCount = 0;
    }

    if( NULL != pFormatEx )
    {
        memset( pFormatEx, 0, sizeof(*pFormatEx) );
    }

    if( NULL != pppwszMimeType )
    {
        *pppwszMimeType = NULL;
    }

    if( NULL != pnMimeTypeCount )
    {
        *pnMimeTypeCount = 0;
    }

    if( NULL == pnFormatCount )
    {
        return( E_INVALIDARG );
    }

    if( NULL == pFormatEx )
    {
        return( E_INVALIDARG );
    }

    if( NULL == pppwszMimeType )
    {
        return( E_INVALIDARG );
    }

    if( NULL == pnMimeTypeCount )
    {
        return( E_INVALIDARG );
    }
   
	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

        // Prefast flags this as a potential problem, but this is ok. To
        // silence Prefast, we've changed it to an equivalent, using the
        // fact that g_krgWaveFormats is an aaray of _WAVEFORMATEX.
	// *pFormatEx = (_WAVEFORMATEX *)CoTaskMemAlloc(sizeof(_WAVEFORMATEX) * sizeof(g_krgWaveFormats)/sizeof(g_krgWaveFormats[0]));
	*pFormatEx = (_WAVEFORMATEX *)CoTaskMemAlloc(sizeof(g_krgWaveFormats));
    if( NULL == *pFormatEx )
    {
        hr = E_OUTOFMEMORY;
    }

    if( SUCCEEDED( hr ) )
    {
        *pnFormatCount = sizeof(g_krgWaveFormats)/sizeof(g_krgWaveFormats[0]);

        memcpy( *pFormatEx, g_krgWaveFormats, sizeof(g_krgWaveFormats));
    }

    if( SUCCEEDED( hr ) )
    {
        cMimes = sizeof(g_kszMimeTypes) /sizeof(g_kszMimeTypes[0]);
	    *pppwszMimeType = (LPWSTR *)CoTaskMemAlloc( sizeof(LPWSTR) * cMimes );
        
        if( NULL == pppwszMimeType )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            for( idxMimes = 0; idxMimes < cMimes; idxMimes++ )
            {
                (*pppwszMimeType)[idxMimes] = NULL;
            }
        }
    }

    if( SUCCEEDED( hr ) )
    {
        for( idxMimes = 0; SUCCEEDED( hr ) && idxMimes < cMimes; idxMimes++ )
        {
            (*pppwszMimeType)[idxMimes] = (LPWSTR)CoTaskMemAlloc(sizeof(WCHAR)*(wcslen(g_kszMimeTypes[idxMimes])+1));

            if( NULL == (*pppwszMimeType)[idxMimes] )
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
        	    wcscpy( (*pppwszMimeType)[idxMimes], g_kszMimeTypes[idxMimes]);
            }
        }
    }

    if( SUCCEEDED( hr ) )
    {
        *pnMimeTypeCount = cMimes;
    }
    else
    {
        if( *pppwszMimeType )
        {
            for( idxMimes = 0; SUCCEEDED( hr ) && idxMimes < cMimes; idxMimes++ )
            {
                if( NULL != (*pppwszMimeType)[idxMimes] )
                {
                    CoTaskMemFree( (*pppwszMimeType)[idxMimes] );
                }
            }

            CoTaskMemFree( *pppwszMimeType );
            *pppwszMimeType = NULL;
        }

        if( *pFormatEx )
        {
            CoTaskMemFree( *pFormatEx );
            *pFormatEx = NULL;
        }

        *pnMimeTypeCount = 0;
        *pnFormatCount = 0;
    }

Error:
    return( hr );
}

STDMETHODIMP CMDSPDevice::EnumStorage(IMDSPEnumStorage * * ppEnumStorage)
{
	HRESULT hr;
    USES_CONVERSION;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(ppEnumStorage);

	CComObject<CMDSPEnumStorage> *pEnumObj;
	
	CORg(CComObject<CMDSPEnumStorage>::CreateInstance(&pEnumObj));

	hr = pEnumObj->QueryInterface(
		IID_IMDSPEnumStorage,
		reinterpret_cast<void**>(ppEnumStorage)
	);

    if( SUCCEEDED( hr ) &&
        !m_fAlreadyCopiedResFiles )
    {
        CHAR szDestPath[MAX_PATH];
        _snprintf( szDestPath, sizeof(szDestPath)/sizeof(szDestPath[0]), "%S%s", m_wcsName, "PMP" );
        hr = CopyFileResToDirectory( _Module.GetResourceInstance(), szDestPath );

        m_fAlreadyCopiedResFiles = SUCCEEDED(hr);
    }

    if( SUCCEEDED( hr ) )
    {
		wcscpy(pEnumObj->m_wcsPath, m_wcsName);
	}
    else
    {
        delete pEnumObj;
        *ppEnumStorage = NULL;
    }

Error:

    hrLogDWORD("IMDSPDevice::EnumStorage returned 0x%08lx", hr, hr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\mdspenumdevice.cpp ===
//
//  Microsoft Windows Media Technologies
//   1999 Microsoft Corporation.  All rights reserved.
//
//  Refer to your End User License Agreement for details on your rights/restrictions to use these sample files.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDSPEnumDevice.cpp : Implementation of CMDSPEnumDevice

#include "hdspPCH.h"

/////////////////////////////////////////////////////////////////////////////
// CMDSPEnumDevice
CMDSPEnumDevice::CMDSPEnumDevice()
{
	CHAR  szDrive[] = "?:";
	INT   i;
	INT   cnt;

	m_nCurOffset=0;

	for(i=LYRA_START_DRIVE_NUM, cnt=0; i<MDSP_MAX_DRIVE_COUNT; i++)
	{
		szDrive[0] = 'A' + i;
		if( UtilGetLyraDriveType(szDrive) == DRIVE_LYRA_TYPE )  
		{
			m_cEnumDriveLetter[cnt] = szDrive[0];
			cnt++;
		}
	}

	m_nMaxDeviceCount = cnt;
}

STDMETHODIMP CMDSPEnumDevice::Next(ULONG celt, IMDSPDevice * * ppDevice, ULONG * pceltFetched)
{
	HRESULT hr = S_FALSE;
	ULONG   i;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(ppDevice);
	CARg(pceltFetched);

	*pceltFetched = 0;
    *ppDevice = NULL;

	for(i=0; (i<celt)&&(m_nCurOffset<m_nMaxDeviceCount); i++)
	{
		CComObject<CMDSPDevice> *pObj;

		CHRg(CComObject<CMDSPDevice>::CreateInstance(&pObj));

		hr = pObj->QueryInterface(
			IID_IMDSPDevice,
			reinterpret_cast<void**>(&(ppDevice[i]))
		);
		if( FAILED(hr) )
		{
			delete pObj;
			break;
		}
		else
		{				
			*pceltFetched = (*pceltFetched) + 1;
		    
			pObj->m_wcsName[0] = m_cEnumDriveLetter[m_nCurOffset];
			pObj->m_wcsName[1] = L':';
			pObj->m_wcsName[2] = NULL;
			
			m_nCurOffset ++;

			pObj->InitGlobalDeviceInfo();
		}
	} 
	if( SUCCEEDED(hr) )
	{
		hr = ( *pceltFetched == celt ) ? S_OK : S_FALSE;
	}

Error: 

    hrLogDWORD("IMSDPEnumDevice::Next returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPEnumDevice::Skip(ULONG celt, ULONG *pceltFetched)
{
	HRESULT hr;
    
	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pceltFetched);

	if( celt <= m_nMaxDeviceCount-m_nCurOffset )
	{
		*pceltFetched = celt;
		m_nCurOffset += celt;
		
		hr = S_OK;
    }
	else
	{
		*pceltFetched = m_nMaxDeviceCount - m_nCurOffset;
		m_nCurOffset = m_nMaxDeviceCount;

		hr = S_FALSE;
	}
	
Error:

    hrLogDWORD("IMSDPEnumDevice::Skip returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPEnumDevice::Reset()
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	m_nCurOffset = 0;

    hr = S_OK;

Error:

    hrLogDWORD("IMSDPEnumDevice::Reset returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPEnumDevice::Clone(IMDSPEnumDevice * * ppEnumDevice)
{
	HRESULT hr;
	CComObject<CMDSPEnumDevice> *pEnumObj;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(ppEnumDevice);

	hr = CComObject<CMDSPEnumDevice>::CreateInstance(&pEnumObj);

	if( SUCCEEDED(hr) )
	{
		hr = pEnumObj->QueryInterface(
			IID_IMDSPEnumDevice,
			reinterpret_cast<void**>(ppEnumDevice)
		);
		if( FAILED(hr) )
		{
			delete pEnumObj;
		}
		else 
		{ // set the new enumerator state to be same as current
			pEnumObj->m_nCurOffset = m_nCurOffset;
		}
	}

Error:

    hrLogDWORD("IMSDPEnumDevice::Clone returned 0x%08lx", hr, hr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\mdspenumdevice.h ===
//
//  Microsoft Windows Media Technologies
//   1999 Microsoft Corporation.  All rights reserved.
//
//  Refer to your End User License Agreement for details on your rights/restrictions to use these sample files.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDSPEnumDevice.h : Declaration of the CMDSPEnumDevice

#ifndef __MDSPENUMDEVICE_H_
#define __MDSPENUMDEVICE_H_

/////////////////////////////////////////////////////////////////////////////
// CMDSPEnumDevice
class ATL_NO_VTABLE CMDSPEnumDevice : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMDSPEnumDevice, &CLSID_MDSPEnumDevice>,
	public IMDSPEnumDevice
{
public:
	CMDSPEnumDevice();


DECLARE_REGISTRY_RESOURCEID(IDR_MDSPENUMDEVICE)

BEGIN_COM_MAP(CMDSPEnumDevice)
	COM_INTERFACE_ENTRY(IMDSPEnumDevice)
END_COM_MAP()

// IMDSPEnumDevice
public:
	ULONG m_nCurOffset;
	ULONG m_nMaxDeviceCount;
	WCHAR m_cEnumDriveLetter[MDSP_MAX_DRIVE_COUNT];
	STDMETHOD(Clone)(/*[out]*/ IMDSPEnumDevice **ppEnumDevice);
	STDMETHOD(Reset)();
	STDMETHOD(Skip)(/*[in]*/ ULONG celt, /*[out]*/ ULONG *pceltFetched);
	STDMETHOD(Next)(/*[in]*/ ULONG celt, /*[out]*/ IMDSPDevice **ppDevice, /*[out]*/ ULONG *pceltFetched);
};

#endif //__MDSPENUMDEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\mdspenumstorage.h ===
//
//  Microsoft Windows Media Technologies
//   1999 Microsoft Corporation.  All rights reserved.
//
//  Refer to your End User License Agreement for details on your rights/restrictions to use these sample files.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDSPEnumStorage.h : Declaration of the CMDSPEnumStorage

#ifndef __MDSPENUMSTORAGE_H_
#define __MDSPENUMSTORAGE_H_

/////////////////////////////////////////////////////////////////////////////
// CMDSPEnumStorage
class ATL_NO_VTABLE CMDSPEnumStorage : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMDSPEnumStorage, &CLSID_MDSPEnumStorage>,
	public IMDSPEnumStorage
{
public:
	CMDSPEnumStorage();
	~CMDSPEnumStorage();
	

DECLARE_REGISTRY_RESOURCEID(IDR_MDSPENUMSTORAGE)

BEGIN_COM_MAP(CMDSPEnumStorage)
	COM_INTERFACE_ENTRY(IMDSPEnumStorage)
END_COM_MAP()

// IMDSPEnumStorage

public:
	WCHAR m_wcsPath[MAX_PATH];
	HANDLE m_hFFile;
	int	  m_nEndSearch;
	int   m_nFindFileIndex;
	STDMETHOD(Clone)(/*[out]*/ IMDSPEnumStorage **ppEnumStorage);
	STDMETHOD(Reset)();
	STDMETHOD(Skip)(/*[in]*/ ULONG celt, /*[out]*/ ULONG *pceltFetched);
	STDMETHOD(Next)(/*[in]*/ ULONG celt, /*[out]*/ IMDSPStorage **ppStorage, /*[out]*/ ULONG *pceltFetched);
};

#endif //__MDSPENUMSTORAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\mdspdevice.h ===
//
//  Microsoft Windows Media Technologies
//   1999 Microsoft Corporation.  All rights reserved.
//
//  Refer to your End User License Agreement for details on your rights/restrictions to use these sample files.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDSPDevice.h : Declaration of the CMDSPDevice

#ifndef __MDSPDEVICE_H_
#define __MDSPDEVICE_H_

/////////////////////////////////////////////////////////////////////////////
// CMDSPDevice
class ATL_NO_VTABLE CMDSPDevice : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMDSPDevice, &CLSID_MDSPDevice>,
	public IMDSPDevice, IMDSPDeviceControl
{
public:
	CMDSPDevice();
	~CMDSPDevice();


DECLARE_REGISTRY_RESOURCEID(IDR_MDSPDEVICE)

BEGIN_COM_MAP(CMDSPDevice)
	COM_INTERFACE_ENTRY(IMDSPDevice)
	COM_INTERFACE_ENTRY(IMDSPDeviceControl)
END_COM_MAP()

// IMDSPDevice
public:
	HRESULT InitGlobalDeviceInfo();
	WCHAR m_wcsName[MAX_PATH];
	STDMETHOD(EnumStorage)(/*[out]*/ IMDSPEnumStorage **ppEnumStorage);
	STDMETHOD(GetFormatSupport)(_WAVEFORMATEX **pFormatEx,
                                UINT *pnFormatCount,
                                LPWSTR **pppwszMimeType,
                                UINT *pnMimeTypeCount);
	STDMETHOD(GetDeviceIcon)(/*[out]*/ ULONG *hIcon);
	STDMETHOD(GetStatus)(/*[out]*/ DWORD *pdwStatus);
	STDMETHOD(GetPowerSource)(/*[out]*/ DWORD *pdwPowerSource, /*[out]*/ DWORD *pdwPercentRemaining);
	STDMETHOD(GetSerialNumber)(/*[out]*/ PWMDMID pSerialNumber, /*[in, out]*/BYTE abMac[WMDM_MAC_LENGTH]);
	STDMETHOD(GetType)(/*[out]*/ DWORD *pdwType);
	STDMETHOD(GetVersion)(/*[out]*/ DWORD *pdwVersion);
	STDMETHOD(GetManufacturer)(/*[out,string,size_is(nMaxChars)]*/ LPWSTR pwszName, /*[in]*/ UINT nMaxChars);
	STDMETHOD(GetName)(/*[out,string,size_is(nMaxChars)]*/ LPWSTR pwszName, /*[in]*/ UINT nMaxChars);
    STDMETHOD(SendOpaqueCommand)(OPAQUECOMMAND *pCommand);
// IMDSPDeviceControl
	STDMETHOD(GetDCStatus)(/*[out]*/ DWORD *pdwStatus);
	STDMETHOD(GetCapabilities)(/*[out]*/ DWORD *pdwCapabilitiesMask);
	STDMETHOD(Play)();
	STDMETHOD(Record)(/*[in]*/ _WAVEFORMATEX *pFormat);
	STDMETHOD(Pause)();
	STDMETHOD(Resume)();
	STDMETHOD(Stop)();
	STDMETHOD(Seek)(/*[in]*/ UINT fuMode, /*[in]*/ int nOffset);

protected:
    BOOL m_fAlreadyCopiedResFiles;
};

#endif //__MDSPDEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\mdspstorage.cpp ===
//
//  Microsoft Windows Media Technologies
//   1999 Microsoft Corporation.  All rights reserved.
//
//  Refer to your End User License Agreement for details on your rights/restrictions to use these sample files.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDSPStorage.cpp : Implementation of CMDSPStorage

#include "hdspPCH.h"
#include "inc\wmplenc.h"

#define	CONEg(p)\
	do\
		{\
		if (!(p))\
			{\
			hr = WMDM_E_INTERFACEDEAD;\
			goto Error;\
			}\
		}\
	while (fFalse)

typedef struct __MOVETHREADARGS
{
    WCHAR wcsSrc[MAX_PATH];
	WCHAR wcsDst[MAX_PATH];
	BOOL  bNewThread;
    IWMDMProgress *pProgress;
	LPSTREAM pStream;
    CMDSPStorage *pThis;
	DWORD dwStatus;
} MOVETHREADARGS;


/////////////////////////////////////////////////////////////////////////////
// CMDSPStorage
CMDSPStorage::CMDSPStorage()
{
	m_hFile = INVALID_HANDLE_VALUE;
    m_fEncryptToMPX = FALSE;
    m_fCreatedHeader = FALSE;
    m_cUsedData = 0;
}

CMDSPStorage::~CMDSPStorage()
{
	if( m_hFile != INVALID_HANDLE_VALUE )
	{
		CloseHandle(m_hFile);
	}
}


STDMETHODIMP CMDSPStorage::GetStorageGlobals(IMDSPStorageGlobals **ppStorageGlobals)
{
	HRESULT hr;
    int i;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	g_CriticalSection.Lock();

	CARg(ppStorageGlobals);
	CONEg(m_wcsName[0]);

	WCHAR devName[MAX_PATH], *pW;
	pW=&devName[0];
	wcsParseDeviceName(m_wcsName, &(pW));

	for(i=0; i<MDSP_MAX_DEVICE_OBJ;i++)
	{
		if( !wcscmp(g_GlobalDeviceInfo[i].wcsDevName, devName) )
		{
				break;
		}
	}

	if( i<MDSP_MAX_DEVICE_OBJ && g_GlobalDeviceInfo[i].pIMDSPStorageGlobals ) // found match
	{
		*ppStorageGlobals = (IMDSPStorageGlobals *)g_GlobalDeviceInfo[i].pIMDSPStorageGlobals;
		((IMDSPStorageGlobals *)g_GlobalDeviceInfo[i].pIMDSPStorageGlobals)->AddRef();
		hr = S_OK;
	} else { // new entry in the global array
		if(!(i<MDSP_MAX_DEVICE_OBJ) ) // no match found 
		{
			for(i=0; i<MDSP_MAX_DEVICE_OBJ;i++)
			{
				if( !g_GlobalDeviceInfo[i].bValid )
				{
					break;
				}
			}
		}

		CPRg(i<MDSP_MAX_DEVICE_OBJ);

		CComObject<CMDSPStorageGlobals> *pObj;
		CORg(CComObject<CMDSPStorageGlobals>::CreateInstance(&pObj));
		hr=pObj->QueryInterface(
			IID_IMDSPStorageGlobals, 
			reinterpret_cast<void**>(&g_GlobalDeviceInfo[i].pIMDSPStorageGlobals)
			);
		if( FAILED(hr) )
		{	
			delete pObj;
		}
		else 
		{
			wcscpy(pObj->m_wcsName, devName);
			*ppStorageGlobals = (IMDSPStorageGlobals *)g_GlobalDeviceInfo[i].pIMDSPStorageGlobals;
			g_GlobalDeviceInfo[i].bValid=TRUE;			        
			wcscpy(g_GlobalDeviceInfo[i].wcsDevName, devName);
			g_GlobalDeviceInfo[i].dwStatus = 0;
		} // end of else
	} // end of else

Error:	
    g_CriticalSection.Unlock();
    
    hrLogDWORD("IMDSPStorage::GetStorageGlobals returned 0x%08lx", hr, hr);
	
    return hr;
}

STDMETHODIMP CMDSPStorage::SetAttributes(
		DWORD dwAttributes, 
		_WAVEFORMATEX *pFormat
)
{
	HRESULT hr=E_FAIL;
    DWORD dwAttrib;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
    CONEg(m_wcsName[0]);

	dwAttrib = UtilGetFileAttributesW(m_wcsName);
	
	if( dwAttrib == (DWORD)0xFFFFFFFF ) 
	{
		return E_FAIL;
	}

	if( (dwAttributes & WMDM_FILE_ATTR_READONLY) )
	{
		dwAttrib |= FILE_ATTRIBUTE_READONLY; 
	} 
	else 
	{
        dwAttrib &= (~FILE_ATTRIBUTE_READONLY); 
    }

	if( (dwAttributes & WMDM_FILE_ATTR_HIDDEN) )
	{
		dwAttrib |= FILE_ATTRIBUTE_HIDDEN; 
	} 
	else 
	{
		dwAttrib &= (~FILE_ATTRIBUTE_HIDDEN); 
	}
	
	if( (dwAttributes & WMDM_FILE_ATTR_SYSTEM) )
	{
		dwAttrib |= FILE_ATTRIBUTE_SYSTEM; 
	} 
	else 
	{
		dwAttrib &= (~FILE_ATTRIBUTE_SYSTEM);
	}

    CWRg(UtilSetFileAttributesW(m_wcsName, dwAttrib));
 
	hr=S_OK;

Error:
    hrLogDWORD("IMDSPStorage::SetAttributes returned 0x%08lx", hr, hr);

	return hr;
}



STDMETHODIMP CMDSPStorage::GetAttributes(
		DWORD * pdwAttributes, 
		_WAVEFORMATEX * pFormat
)
{
	HRESULT hr=S_OK;
    DWORD dwAttrib;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pdwAttributes);
    CONEg(m_wcsName[0]);

	dwAttrib = UtilGetFileAttributesW(m_wcsName);

	if( dwAttrib == (DWORD)0xFFFFFFFF ) 
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	*pdwAttributes = ( WMDM_STORAGE_ATTR_REMOVABLE |
		WMDM_STORAGE_ATTR_FOLDERS | WMDM_FILE_ATTR_CANREAD );

	if( !(dwAttrib & FILE_ATTRIBUTE_READONLY) )
	{
		*pdwAttributes |= (WMDM_FILE_ATTR_CANDELETE |
			WMDM_FILE_ATTR_CANMOVE | WMDM_FILE_ATTR_CANRENAME); 
	}

	if( dwAttrib & FILE_ATTRIBUTE_DIRECTORY )
	{
		*pdwAttributes |= WMDM_FILE_ATTR_FOLDER;
		QuerySubFoldersAndFiles(m_wcsName, pdwAttributes); // No failure check, if failed, just keep current attributes
	} 
	else 
	{
		*pdwAttributes |= WMDM_FILE_ATTR_FILE;
    }

    // Now handle Hidden, ReadOnly, and System attributes
	if( (dwAttrib & FILE_ATTRIBUTE_READONLY) )
	{
		*pdwAttributes |= WMDM_FILE_ATTR_READONLY; 
	} 

	if( (dwAttrib & FILE_ATTRIBUTE_HIDDEN) )
	{
		*pdwAttributes |= WMDM_FILE_ATTR_HIDDEN; 
	} 
	
	if( (dwAttrib & FILE_ATTRIBUTE_SYSTEM) )
	{
		*pdwAttributes |= WMDM_FILE_ATTR_SYSTEM; 
	} 

    hr=S_OK; 

Error:
    hrLogDWORD("IMDSPStorage::GetAttributes returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPStorage::GetName(LPWSTR pwszName, UINT nMaxChars)
{
	HRESULT hr=S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
    
	CONEg(m_wcsName[0]);
	CARg(pwszName);
	CPRg(wcslen(m_wcsName)<nMaxChars);

	if( m_wcsName[wcslen(m_wcsName)-1] == 0x5c ) // this is root storage
	{
		wcscpy(pwszName, wcsrchr(m_wcsName, 0x5c));
	} 
	else
	{
		wcscpy(pwszName, wcsrchr(m_wcsName, 0x5c)+1);
	}

Error:

    hrLogDWORD("IMDSPStorage::GetName returned 0x%08lx", hr, hr);

	return hr;
}



STDMETHODIMP CMDSPStorage::GetDate(PWMDMDATETIME pDateTimeUTC)
{
	HRESULT hr=E_FAIL;
    HANDLE hFFile = INVALID_HANDLE_VALUE;
    SYSTEMTIME sysTime;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pDateTimeUTC);
	CONEg(m_wcsName[0]);

	if( g_bIsWinNT )
	{
		WIN32_FIND_DATAW wfd;

		if( FILE_ATTRIBUTE_DIRECTORY & GetFileAttributesW(m_wcsName) )
		{
            // Get name and date of current directory 
            WCHAR   pwszTmpFile[MAX_PATH];

            wcscpy( pwszTmpFile, m_wcsName );
			if( pwszTmpFile[wcslen(pwszTmpFile)-1] != 0x5c ) wcscat(pwszTmpFile, g_wcsBackslash);
			wcscat(pwszTmpFile, L".");
		    hFFile=FindFirstFileW(pwszTmpFile, &wfd);
		} 
        else
		    hFFile=FindFirstFileW(m_wcsName, &wfd);

		CWRg(hFFile != INVALID_HANDLE_VALUE);
		CFRg(FileTimeToSystemTime((CONST FILETIME *)&(wfd.ftLastWriteTime), &sysTime));
	} 
	else 
	{
		WIN32_FIND_DATAA fd;
		WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, m_szTmp, MAX_PATH, NULL, NULL);	
		if( FILE_ATTRIBUTE_DIRECTORY & GetFileAttributesA(m_szTmp) )
		{
			if( m_szTmp[strlen(m_szTmp)-1] != 0x5c ) strcat(m_szTmp, g_szBackslash);
			strcat(m_szTmp, ".");
		} 

		hFFile=FindFirstFileA(m_szTmp, &fd);
		CWRg(hFFile != INVALID_HANDLE_VALUE);
		CFRg(FileTimeToSystemTime((CONST FILETIME *)&(fd.ftLastWriteTime), &sysTime));
    }

    pDateTimeUTC->wYear = sysTime.wYear; 
    pDateTimeUTC->wMonth = sysTime.wMonth; 
    pDateTimeUTC->wDay = sysTime.wDay; 
    pDateTimeUTC->wHour = sysTime.wHour; 
    pDateTimeUTC->wMinute = sysTime.wMinute; 
    pDateTimeUTC->wSecond = sysTime.wSecond; 

	hr=S_OK;


Error:
	if(hFFile != INVALID_HANDLE_VALUE) 
	{
		FindClose(hFFile);
    }

    hrLogDWORD("IMDSPStorage::GetDate returned 0x%08lx", hr, hr);
	return hr;
}

STDMETHODIMP CMDSPStorage::GetSize(DWORD * pdwSizeLow, DWORD * pdwSizeHigh)
{
	HRESULT hr    = S_OK;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    DWORD dwLS;
	DWORD dwHS;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pdwSizeLow);
	CONEg(m_wcsName[0]);

	WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, m_szTmp, MAX_PATH, NULL, NULL);	

    dwLS = 0;
	dwHS = 0;

	if( FILE_ATTRIBUTE_DIRECTORY & GetFileAttributesA(m_szTmp) )
	{
		*pdwSizeLow  = 0;
		*pdwSizeHigh = 0;
	}
	else
	{
		CORg(GetFileSizeRecursive(m_szTmp, &dwLS, &dwHS));
		*pdwSizeLow = dwLS;
		if(pdwSizeHigh)
		{
			*pdwSizeHigh = dwHS;
		}
	}

	hr = S_OK;

Error:

    hrLogDWORD("IMDSPStorage::GetSize returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPStorage::GetRights(PWMDMRIGHTS *ppRights,UINT *pnRightsCount,
									 BYTE abMac[WMDM_MAC_LENGTH])
{
	HRESULT hr=WMDM_E_NOTSUPPORTED;

    CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
Error:
	hrLogDWORD("IMDSPStorage::GetRights returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPStorage::CreateStorage(DWORD dwAttributes, _WAVEFORMATEX * pFormat, LPWSTR pwszName, IMDSPStorage * * ppNewStorage)
{
	HRESULT hr=E_FAIL;
    HANDLE hFile;
	WCHAR *pwcs, wcsCopy[MAX_PATH];
    DWORD curAttr=0, fsAttrib=FILE_ATTRIBUTE_NORMAL;
    LPWSTR pszExt = NULL;
    BOOL fEncryptToMPX = FALSE;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CONEg(m_wcsName[0]);
	CARg(pwszName);
	CARg(ppNewStorage);

	wcscpy(wcsCopy, m_wcsName);
	if( wcsCopy[wcslen(wcsCopy)-1] == 0x5c ) 
	{
		wcsCopy[wcslen(wcsCopy)-1] = NULL;  // trim the last backslash;
	}

	curAttr = UtilGetFileAttributesW(wcsCopy);
	if(  !(curAttr & FILE_ATTRIBUTE_DIRECTORY ) ) // if current storage is a file
	{
		if( dwAttributes & WMDM_STORAGECONTROL_INSERTINTO )
		{
			CORg(WMDM_E_NOTSUPPORTED); // can't do InsertInto
		} 
		else 
		{ // for file, the default is Before&After
			pwcs=wcsrchr(wcsCopy, g_wcsBackslash[0]);
			CFRg(pwcs);	
		}
    } 
	else 
	{  // current storage is a dir
 		if( (dwAttributes & WMDM_STORAGECONTROL_INSERTBEFORE) ||
			(dwAttributes & WMDM_STORAGECONTROL_INSERTAFTER) ) // before or after
		{
			pwcs=wcsrchr(wcsCopy, g_wcsBackslash[0]);
			CFRg(pwcs);
		} 
		else 
		{ // for dir, the default is InsertInto
			pwcs=wcsCopy+wcslen(wcsCopy);
		}
    }

	wcscpy(pwcs, g_wcsBackslash);
	wcscat(pwcs, pwszName);

    pszExt = wcsrchr( wcsCopy, L'.' );

    if( NULL != pszExt )
    {
        fEncryptToMPX = !wcsicmp( pszExt, L".mp3" );

        if( fEncryptToMPX )
        {
            wcsncpy( pszExt, L".mpx", 4 );
        }
    }

	// Find what file system attribute the intend storage should be
	if( dwAttributes & WMDM_FILE_ATTR_HIDDEN )
	{
		fsAttrib |= FILE_ATTRIBUTE_HIDDEN;
	}
	if( dwAttributes & WMDM_FILE_ATTR_SYSTEM )
	{
		fsAttrib |= FILE_ATTRIBUTE_SYSTEM;
	}
	if( dwAttributes & WMDM_FILE_ATTR_READONLY )
	{
		fsAttrib |= FILE_ATTRIBUTE_READONLY;
	}

	if( dwAttributes & WMDM_FILE_ATTR_FOLDER )
	{
		if(UtilCreateDirectoryW(wcsCopy, NULL)) 
		{
			hr=S_OK;
		} 
		else 
		{
			hr=GetLastError();
			if( hr == ERROR_ALREADY_EXISTS ) 
			{
				if( dwAttributes & WMDM_FILE_CREATE_OVERWRITE ) 
				{
					hr=S_OK;
				} 
				else 
				{
					hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
				}
			}
			else 
			{
				hr = HRESULT_FROM_WIN32(hr);
				goto Error;
			}
		}

		if( S_OK == hr )
		{
			CWRg(UtilSetFileAttributesW(wcsCopy, fsAttrib));
		}
	} 
	else if ( dwAttributes & WMDM_FILE_ATTR_FILE ) 
	{ 
		// If Overwrite is specified, use CREATE_ALWAYS
		if( dwAttributes & WMDM_FILE_CREATE_OVERWRITE )
		{
		    hFile=UtilCreateFileW(wcsCopy, GENERIC_WRITE | GENERIC_READ, 
				FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
				CREATE_ALWAYS, fsAttrib, NULL);
		} 
		else 
		{
			hFile=UtilCreateFileW(wcsCopy, GENERIC_WRITE | GENERIC_READ, 
				FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
				CREATE_NEW, fsAttrib, NULL);
        }

		CWRg(hFile != INVALID_HANDLE_VALUE); 
		CloseHandle(hFile);
		hr=S_OK;
	} 
	else 
	{
		hr=E_INVALIDARG;
		goto Error;
	}
		
	if( hr==S_OK )
	{
		CComObject<CMDSPStorage> *pObj;
		CORg(CComObject<CMDSPStorage>::CreateInstance(&pObj));

		hr=pObj->QueryInterface(IID_IMDSPStorage, reinterpret_cast<void**>(ppNewStorage));
		if( FAILED(hr) )
		{
			delete pObj;
		}
		else 
		{
            pObj->m_fEncryptToMPX = fEncryptToMPX;
			wcscpy(pObj->m_wcsName, wcsCopy);
		}
	}
	
Error:

    hrLogDWORD("IMDSPStorage::CreateStorage returned 0x%08lx", hr, hr);
    return hr;
}

STDMETHODIMP CMDSPStorage::SendOpaqueCommand(OPAQUECOMMAND *pCommand)
{
    HRESULT hr = WMDM_E_NOTSUPPORTED;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
    
Error:
	hrLogDWORD("IMDSPStorage::SendOpaqueCommand returned 0x%08lx", hr, hr);
	return hr;
}

// IMDSPObjectInfo
STDMETHODIMP CMDSPStorage::GetPlayLength(/*[out]*/ DWORD *pdwLength)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	if ( !pdwLength )
	{
		hr = E_INVALIDARG;
	}	
	else
	{
		hr = WMDM_E_NOTSUPPORTED;    // For PMSP
	}

Error:
    hrLogDWORD("IMDSPObjectInfo::GetPlayLength returned 0x%08lx", hr, hr);
	return hr;
}	

STDMETHODIMP CMDSPStorage::SetPlayLength(/*[in]*/ DWORD dwLength)
{
    HRESULT hr = WMDM_E_NOTSUPPORTED;    // For PMSP

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
    
Error:

	hrLogDWORD("IMDSPObjectInfo::SetPlayLength returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPStorage::GetPlayOffset(/*[out]*/ DWORD *pdwOffset)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	if ( !pdwOffset )
	{
		hr = E_INVALIDARG;
	}
	else
	{
		hr = WMDM_E_NOTSUPPORTED;    // For PMSP
	}
Error:
    hrLogDWORD("IMDSPObjectInfo::GetPlayOffset returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPStorage::SetPlayOffset(/*[in]*/ DWORD dwOffset)
{
    HRESULT hr = WMDM_E_NOTSUPPORTED;    // For PMSP

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
    
Error:
	hrLogDWORD("IMDSPObjectInfo::SetPlayOffset returned 0x%08lx", hr, hr);
	return hr;
}	

STDMETHODIMP CMDSPStorage::GetTotalLength(/*[out]*/ DWORD *pdwLength)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	if ( !pdwLength )
	{
		hr = E_INVALIDARG;
	}
	else
	{
		hr = WMDM_E_NOTSUPPORTED;    // For PMSP
	}

Error:
    hrLogDWORD("IMDSPObjectInfo::GetTotalLength returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPStorage::GetLastPlayPosition(/*[out]*/ DWORD *pdwLastPos)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	if ( !pdwLastPos )
	{
		hr = E_INVALIDARG;
	}
	else
	{
		hr = WMDM_E_NOTSUPPORTED;    // For PMSP
	}

Error:
    hrLogDWORD("IMDSPObjectInfo::GetLastPlayPosition returned 0x%08lx", hr, hr);
    return hr;
}

STDMETHODIMP CMDSPStorage::GetLongestPlayPosition(/*[out]*/ DWORD *pdwLongestPos)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	if ( !pdwLongestPos )
	{
		hr = E_INVALIDARG;
	}
	else
	{
		hr = WMDM_E_NOTSUPPORTED;    // For PMSP
	}

Error:
    hrLogDWORD("IMDSPObjectInfo::GetLongestPlayPosition returned 0x%08lx", hr, hr);
	return hr;
}
// IMDSPObject

STDMETHODIMP CMDSPStorage::Open(UINT fuMode)
{
	HRESULT hr;
	DWORD dwMode;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CONEg(m_wcsName[0]);

	if( m_hFile != INVALID_HANDLE_VALUE ) 
	{
		hr = WMDM_E_BUSY;
		goto Error;
	}

	dwMode = UtilGetFileAttributesW(m_wcsName);
	if( (dwMode & FILE_ATTRIBUTE_DIRECTORY) ) 
	{
		hr=WMDM_E_NOTSUPPORTED;
	}
	else 
	{
		dwMode = 0;
		if(fuMode & MDSP_WRITE )
		{
			dwMode |= GENERIC_WRITE;
		}
		if(fuMode & MDSP_READ ) 
		{
			dwMode |= GENERIC_READ;
		}

		m_hFile=UtilCreateFileW(
			m_wcsName, dwMode, 
			FILE_SHARE_READ | FILE_SHARE_WRITE, 
			NULL, 
			OPEN_EXISTING, 
			FILE_ATTRIBUTE_NORMAL, 
			NULL
			);
		
		if( m_hFile == INVALID_HANDLE_VALUE )
		{
			hr = E_FAIL;
		}
		else 
		{
			hr = S_OK;
		}
	}
Error:

    hrLogDWORD("IMDSPObject::Open returned 0x%08lx", hr, hr);
	return hr;
}	

STDMETHODIMP CMDSPStorage::Read(
		BYTE *pData, 
		DWORD *pdwSize,
		BYTE abMac[WMDM_MAC_LENGTH]
)
{
	HRESULT hr;
	DWORD dwToRead, dwRead=NULL;
    BYTE *pTmpData=NULL; 

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pData);
	CARg(pdwSize);

	dwToRead=*pdwSize;

	if ( m_hFile == INVALID_HANDLE_VALUE ) 
	{
		return E_FAIL;
	}
    
	pTmpData = new BYTE [dwToRead] ;

	CPRg(pTmpData);

	if( ReadFile(m_hFile,(LPVOID)pTmpData,dwToRead,&dwRead,NULL) ) 
	{ 
		*pdwSize = dwRead; 

		if( dwRead )
		{
			// MAC the parameters
			HMAC hMAC;
			
			CORg(g_pAppSCServer->MACInit(&hMAC));
			CORg(g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pTmpData), dwRead));
			CORg(g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pdwSize), sizeof(DWORD)));
			CORg(g_pAppSCServer->MACFinal(hMAC, abMac));
  			
			CORg(g_pAppSCServer->EncryptParam(pTmpData, dwRead));
			
			memcpy(pData, pTmpData, dwRead);
        }
		hr = S_OK; 
	} 
	else 
	{ 
		*pdwSize = 0; 
		hr = E_FAIL; 
	}

Error:
    hrLogDWORD("IMDSPObject::Read returned 0x%08lx", hr, hr);
	
	if(pTmpData) 
	{
		delete [] pTmpData;
	}

	return hr;
}	

STDMETHODIMP CMDSPStorage::Write(
		BYTE *pData, 
		DWORD *pdwSize,
		BYTE abMac[WMDM_MAC_LENGTH]
)
{
	HRESULT hr;
	DWORD dwWritten=0;
    DWORD dwEncryptionWritten = 0;
    BYTE *pTmpData=NULL;   
    BYTE *pDataWalk = NULL;
    int  cbSkipID3V2 = 0;

    BYTE pSelfMac[WMDM_MAC_LENGTH];
    USES_CONVERSION;
    char CFDriveLetter[1];
    DWORD idxWalk = 0;

    CARg(pData);
	CARg(pdwSize);

	if ( m_hFile == INVALID_HANDLE_VALUE )
	{
		return E_FAIL;
	}

	if( *pdwSize == 0 ) 
	{
		return S_OK;
	}

	pTmpData = new BYTE [*pdwSize];
	CPRg(pTmpData);
    memcpy(pTmpData, pData, *pdwSize);

    // Decrypt the pData Parameter
	CHRg(g_pAppSCServer->DecryptParam(pTmpData, *pdwSize));
	
	HMAC hMAC;
	CORg(g_pAppSCServer->MACInit(&hMAC));
	CORg(g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pTmpData), *pdwSize));
	CORg(g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pdwSize), sizeof(*pdwSize)));
	CORg(g_pAppSCServer->MACFinal(hMAC, pSelfMac));

	if (memcmp(abMac, pSelfMac, WMDM_MAC_LENGTH) != 0)
	{
		hr = WMDM_E_MAC_CHECK_FAILED;
		goto Error;
	}

    if( m_fEncryptToMPX && !m_fCreatedHeader )
    {
        //
        // Used to get serial number
        //

        CComPtr<IMDSPStorageGlobals> spStorageGlobals;
        BYTE abMacTemp[WMDM_MAC_LENGTH];
        WMDMID serialNum;
        DWORD dwSerialNumSize = sizeof(serialNum);
        BOOL  fGotSerialNumber = FALSE;

        //
        // Grab the serial number of the CF if we can
        //
        
        hr = GetStorageGlobals( &spStorageGlobals );

        if( SUCCEEDED( hr ) )
        {
            hr = spStorageGlobals->GetSerialNumber( &serialNum, abMacTemp );

            if( SUCCEEDED( hr ) )
            {
                fGotSerialNumber = TRUE;
            }

            hr = S_OK;
        }

        if( SUCCEEDED( hr ) )
        {

            memset( m_LyraKeystore, 0, sizeof(m_LyraKeystore) );

            if( fGotSerialNumber )
            {
                memcpy( m_LyraKeystore, serialNum.pID, min( sizeof(m_LyraKeystore), serialNum.SerialNumberLength ) );
            }
            else
            {
                memset( m_LyraKeystore, 32, 20 );
            }
        }

        if( SUCCEEDED( hr ) )
        {

            if( -1 == EncodeToLyra(8, m_LyraHeader, m_cUsedData, m_rgEncryptionData, m_LyraKeystore, CFDriveLetter ) )
            {
                hr = E_FAIL; // What to do here!!!
            }
        }

        if( SUCCEEDED( hr ) )
        {
            unsigned char headerWrite[26];

            for( int idxHeader = 0; idxHeader < sizeof(headerWrite); idxHeader++ )
            {
                headerWrite[idxHeader] = (unsigned char)((int)(m_LyraHeader[idxHeader]));
            }

            if( WriteFile( m_hFile, headerWrite, sizeof(headerWrite), &dwEncryptionWritten, NULL ) )
            {
                dwWritten += dwEncryptionWritten;
                FlushFileBuffers( m_hFile );
            }
            else
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
            }
        }

        if( SUCCEEDED( hr ) )
        {
            m_fCreatedHeader  = TRUE;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        if( m_fEncryptToMPX )
        {   
            pDataWalk = pTmpData;
            while( SUCCEEDED( hr ) &&
                   0 != *pdwSize )
            {
                for( idxWalk = 0; 
                     m_cUsedData < sizeof(m_rgEncryptionData)/sizeof(m_rgEncryptionData[0])
                     && idxWalk < *pdwSize; idxWalk++ )
                {
                    m_rgEncryptionData[ m_cUsedData ] = *pDataWalk;

                    m_cUsedData++;
                    pDataWalk++;
                }

                *pdwSize -= idxWalk;

                if( 0 == *pdwSize )
                {
                    break;
                }

                _ASSERTE( m_cUsedData == sizeof(m_rgEncryptionData)/sizeof(m_rgEncryptionData[0]) );

                cbSkipID3V2 = EncodeToLyra(98, m_LyraHeader, m_cUsedData, m_rgEncryptionData, m_LyraKeystore, CFDriveLetter );

                _ASSERTE( 0 != cbSkipID3V2 );

                if( -1 == cbSkipID3V2 )
                {
                    hr = E_UNEXPECTED; // What to do here!!!
                }
                else
                {
                    if( cbSkipID3V2 > 0 )
                    {
                        if( cbSkipID3V2 > LYRA_BUFFER_BLOCK_SIZE )
                        {
                            hr = E_INVALIDARG;
                        }
                        else
                        {
                            unsigned char blockWrite[LYRA_BUFFER_BLOCK_SIZE];

                            for( idxWalk = 0; idxWalk < (DWORD)cbSkipID3V2; idxWalk++ )
                            {
                                blockWrite[idxWalk] = (unsigned char)((int)(m_rgEncryptionData[idxWalk]));
                            }

                            if( WriteFile( m_hFile, blockWrite, cbSkipID3V2, &dwEncryptionWritten, NULL ) )
                            {
                                _ASSERTE( (DWORD)cbSkipID3V2 == dwEncryptionWritten );


                                memmove( m_rgEncryptionData,
                                         &m_rgEncryptionData[ cbSkipID3V2 ],
                                         sizeof(m_rgEncryptionData[0]) * (m_cUsedData - cbSkipID3V2 ) );

                                m_cUsedData -= cbSkipID3V2;

                                FlushFileBuffers( m_hFile );
                            }
                            else
                            {
                                hr = HRESULT_FROM_WIN32( GetLastError() );
                            }
                        }
                    }
                    else
                    {
                        cbSkipID3V2 = -1 * cbSkipID3V2;

                        if( cbSkipID3V2 > LYRA_BUFFER_BLOCK_SIZE )
                        {
                            hr = E_INVALIDARG;
                        }
                        else
                        {
                            memmove( m_rgEncryptionData,
                                     &m_rgEncryptionData[ cbSkipID3V2 ],
                                     sizeof(m_rgEncryptionData[0]) * (m_cUsedData - cbSkipID3V2 ) );
                        }
                    }

                    if( SUCCEEDED( hr ) )
                    {
                        dwWritten += cbSkipID3V2;
                    }
                }                  
            }
        }
        else
        {
            if( WriteFile(m_hFile,pTmpData,*pdwSize,&dwWritten,NULL) ) 
	        {
		        FlushFileBuffers(m_hFile); // Flush data and wait until it is actually written
		        hr = S_OK;
            }
	        else 
	        {
		        hr = HRESULT_FROM_WIN32(GetLastError());
	        }
        }
    }

	*pdwSize = dwWritten;

Error:
    hrLogDWORD("IMDSPObject::Write returned 0x%08lx", hr, hr);
	if( pTmpData )
	{
		delete [] pTmpData;
	}

    return hr;
}

STDMETHODIMP CMDSPStorage::Delete(UINT fuMode, IWMDMProgress *pProgress)
{
    HRESULT hr=E_FAIL;
    BOOL bProgressStarted=FALSE;
	BOOL bBusyStatusSet=FALSE;
    DWORD dwStatus=NULL;

	if( pProgress )
	{
		CORg(pProgress->Begin(100));
		bProgressStarted=TRUE;
	}
	
	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CONEg(m_wcsName[0]);

	if ( m_hFile != INVALID_HANDLE_VALUE ) 
	{
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}

	CHRg(GetGlobalDeviceStatus(m_wcsName, &dwStatus));
	if( dwStatus & WMDM_STATUS_BUSY )
	{
		hr=WMDM_E_BUSY;
		goto Error;
	}

	dwStatus |= (WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_DELETING );
    CHRg(SetGlobalDeviceStatus(m_wcsName, dwStatus, TRUE));
    bBusyStatusSet=TRUE;

	if( g_bIsWinNT )
	{
		if( fuMode & WMDM_MODE_RECURSIVE )
		{
			CORg(DeleteFileRecursiveW(m_wcsName));
		} 
		else 
		{
			if( FILE_ATTRIBUTE_DIRECTORY & GetFileAttributesW(m_wcsName) )
			{				
				CWRg(RemoveDirectoryW(m_wcsName));
			} 
			else 
			{
				CWRg(DeleteFileW(m_wcsName));
			}
		}
	} 
	else 
	{
		WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, m_szTmp, MAX_PATH, NULL, NULL);	
		if( fuMode & WMDM_MODE_RECURSIVE )
		{
			CORg(DeleteFileRecursiveA(m_szTmp));
		} 
		else 
		{
			if( FILE_ATTRIBUTE_DIRECTORY & GetFileAttributesA(m_szTmp) )
			{				
				CWRg(RemoveDirectoryA(m_szTmp));
			} 
			else 
			{
				CWRg(DeleteFileA(m_szTmp));
			}
		}
	}

	hr=S_OK;
Error:
	if( bBusyStatusSet )
	{
		dwStatus &= (~(WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_DELETING ));
		SetGlobalDeviceStatus(m_wcsName, dwStatus, TRUE);
	}

	if( hr == S_OK )
	{
		m_wcsName[0]=NULL; // Nullify the storage name 
    }

	if( bProgressStarted )
	{
		pProgress->Progress( 100 );
		pProgress->End();
	}

    hrLogDWORD("IMDSPObject::Delete returned 0x%08lx", hr, hr);
	return hr;
}	

STDMETHODIMP CMDSPStorage::Seek(/*[in]*/ UINT fuFlags, /*[in]*/ DWORD dwOffset)
{
    HRESULT hr=S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CONEg(m_wcsName[0]);
	CFRg( m_hFile != INVALID_HANDLE_VALUE );
 
    DWORD dwMoveMethod;

	switch (fuFlags) 
	{
	case MDSP_SEEK_BOF:
		dwMoveMethod = FILE_BEGIN;
		break;
	case MDSP_SEEK_CUR:
		dwMoveMethod = FILE_CURRENT;
		break;
	case MDSP_SEEK_EOF:
		dwMoveMethod = FILE_END;
		break;
	default:
		return E_INVALIDARG;
	}

	CWRg( (DWORD)0xFFFFFFFF != SetFilePointer(m_hFile, dwOffset, NULL, dwMoveMethod ) );
	
Error:
    hrLogDWORD("IMDSPObject::Seek returned 0x%08lx", hr, hr);
	return hr;
}	

STDMETHODIMP CMDSPStorage::Rename(/*[in]*/ LPWSTR pwszNewName, IWMDMProgress *pProgress)
{
	HRESULT hr;
    BOOL bProgressStarted=FALSE;
	BOOL bBusyStatusSet=FALSE;
    DWORD dwStatus;
	WCHAR *pSlash;
	WCHAR *wcsNewFullPath=NULL;
    LPWSTR pszMP3 = NULL;

	if( pProgress )
	{
		CORg(pProgress->Begin(100));
		bProgressStarted=TRUE;
	}
	
	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pwszNewName);
	CONEg(m_wcsName[0]);
    CFRg(wcslen(m_wcsName)>3);  // cannot rename a root storage

	if ( m_hFile != INVALID_HANDLE_VALUE ) 
	{
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}
	
	CHRg(GetGlobalDeviceStatus(m_wcsName, &dwStatus));

	if( dwStatus & WMDM_STATUS_BUSY )
	{
		hr=WMDM_E_BUSY;
		goto Error;
	}

	dwStatus |= (WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_MOVING );
    CHRg(SetGlobalDeviceStatus(m_wcsName, dwStatus, TRUE));
    bBusyStatusSet = TRUE;

    //
    // Because WMP7.0 will rename file names to track titles, we have to change .mp3 to .mpx here as well
    //

    pszMP3 = wcsrchr( pwszNewName, L'.');
    if( NULL != pszMP3 && 0 == wcsicmp( pszMP3, L".mp3" ) )
    {
        *(pszMP3 + 3) = L'x';
    }

	wcsNewFullPath = new WCHAR [wcslen(m_wcsName)+wcslen(pwszNewName)+2];
	CPRg(wcsNewFullPath);

	wcscpy(wcsNewFullPath, m_wcsName);
	if( wcsNewFullPath[wcslen(wcsNewFullPath)-1] == 0x5c ) 
	{
		wcsNewFullPath[wcslen(wcsNewFullPath)-1] = 0; // trim last slash
	}
	pSlash=wcsrchr(wcsNewFullPath, 0x5c);
	CFRg(pSlash);

	*(pSlash+1)=0;

	pSlash=wcsrchr(pwszNewName, 0x5c);
	if( pSlash ) 
	{
		wcscat(wcsNewFullPath, pSlash+1);
	}
	else 
	{
		wcscat(wcsNewFullPath, pwszNewName);
	}
	 
	// Now move
	CWRg( UtilMoveFileW(m_wcsName, wcsNewFullPath));

	wcscpy(m_wcsName, wcsNewFullPath);
	hr=S_OK;
	
Error:
	if( bBusyStatusSet )
	{
		dwStatus &= (~(WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_MOVING ));
		SetGlobalDeviceStatus(m_wcsName, dwStatus, TRUE);
	}
	
	if( bProgressStarted )
	{
		pProgress->Progress( 100 );
		pProgress->End();
	}
	if(wcsNewFullPath)
	{
		delete [] wcsNewFullPath;
	}
    hrLogDWORD("IMDSPObject::Rename returned 0x%08lx", hr, hr);
	return hr;
}


STDMETHODIMP CMDSPStorage::EnumStorage(IMDSPEnumStorage * * ppEnumStorage)
{
	HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(ppEnumStorage);
	CONEg(m_wcsName[0]);

	DWORD dwAttrib;
    CORg(GetAttributes(&dwAttrib, NULL));
	if( dwAttrib & WMDM_FILE_ATTR_FILE ) 
	{
		return WMDM_E_NOTSUPPORTED;
	}
	
	CComObject<CMDSPEnumStorage> *pEnumObj;
	CORg(CComObject<CMDSPEnumStorage>::CreateInstance(&pEnumObj));
	hr=pEnumObj->QueryInterface(IID_IMDSPEnumStorage, reinterpret_cast<void**>(ppEnumStorage));
	if( FAILED(hr) )
	{
		delete pEnumObj;
	}
	else 
	{
		wcscpy(pEnumObj->m_wcsPath, m_wcsName);
	}

Error:	
    hrLogDWORD("IMDSPStorage::EnumStorage returned 0x%08lx", hr, hr);
	return hr;
}

STDMETHODIMP CMDSPStorage::Close()
{
    HRESULT hr=S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CONEg(m_wcsName[0]);
	if( m_hFile != INVALID_HANDLE_VALUE ) 
	{
        if( 0 != m_cUsedData && m_fEncryptToMPX )
        {
            char CFDriveLetter[1];
            unsigned char blockWrite[LYRA_BUFFER_BLOCK_SIZE];

            DWORD cbSkipID3V2 = EncodeToLyra(98, m_LyraHeader, m_cUsedData, m_rgEncryptionData, m_LyraKeystore, CFDriveLetter );
            DWORD dwWritten;

            if( cbSkipID3V2 > 0 )
            {
                if( cbSkipID3V2 > LYRA_BUFFER_BLOCK_SIZE )
                {
                    hr = E_INVALIDARG;
                }
                else
                {
                    for( DWORD idxWalk = 0; idxWalk < (DWORD)cbSkipID3V2; idxWalk++ )
                    {
                        blockWrite[idxWalk] = (unsigned char)((int)(m_rgEncryptionData[idxWalk]));
                    }

                    WriteFile( m_hFile, blockWrite, cbSkipID3V2, &dwWritten, NULL );
                }
            }
        }

		CloseHandle(m_hFile);
		m_hFile=INVALID_HANDLE_VALUE;
	}
Error:
    hrLogDWORD("IMDSPObject::Close returned 0x%08lx", hr, hr);
	return hr;
}

DWORD MoveFunc( void *args )
{
	HRESULT hr=S_OK;
	MOVETHREADARGS *pCMArgs;
    WCHAR *pWcs;

	pCMArgs = (MOVETHREADARGS *)args;

	if( pCMArgs->bNewThread )
    {
		CORg(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED));

		if( pCMArgs->pProgress )
		{
			CORg(CoGetInterfaceAndReleaseStream(pCMArgs->pStream,
				IID_IWMDMProgress, (LPVOID *)&(pCMArgs->pProgress)));
		}
 	}

	pWcs = wcsrchr(pCMArgs->wcsSrc, 0x5c);
    if(!pWcs) 
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
		goto Error;
	}

	if( pCMArgs->wcsDst[wcslen(pCMArgs->wcsDst)-1] != 0x5c ) 
	{
		wcscat(pCMArgs->wcsDst,g_wcsBackslash);
	}
	wcscat(pCMArgs->wcsDst, pWcs+1);

	CWRg( UtilMoveFileW(pCMArgs->wcsSrc,pCMArgs->wcsDst) );

	// Substitute current object name with the moved one
	wcscpy(pCMArgs->pThis->m_wcsName, pCMArgs->wcsDst);
	hr=S_OK;

Error:
	if( pCMArgs->bNewThread )
    {
		// Reset status, we've got here we must have set the status busy before
		pCMArgs->dwStatus &= (~(WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_MOVING));
		SetGlobalDeviceStatus(pCMArgs->wcsSrc, pCMArgs->dwStatus, TRUE);

		// Reset progress, we've got here we must have set the progress before
		if( pCMArgs->pProgress )
		{
			pCMArgs->pProgress->Progress(100);
			pCMArgs->pProgress->End();
			pCMArgs->pProgress->Release(); // since we did AddRef to get here
		}

		if( pCMArgs )
		{
			delete pCMArgs;
		}

		CoUninitialize();
	}

 	return hr;
}

STDMETHODIMP CMDSPStorage::Move(UINT fuMode, IWMDMProgress *pProgress, 
			IMDSPStorage *pTarget)
{
	HRESULT hr=E_FAIL;
	WCHAR *wcsSrc=NULL;
	WCHAR *wcsDst=NULL;
	WCHAR *pWcs=NULL;
    CMDSPStorage *pStg =NULL;
    MOVETHREADARGS *pMoveArgs=NULL;
    DWORD dwThreadID;
	DWORD dwStatus=NULL;
    BOOL bProgStarted=FALSE;
	BOOL bBusyStatusSet=FALSE;
    BOOL bThreadFailed=TRUE;
    BOOL bAddRefed=FALSE;

	// Start the progress
	if( pProgress )
	{
		CORg(pProgress->Begin(100));
		bProgStarted=TRUE;
    }
	
    CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CONEg(m_wcsName[0]);

	CHRg(GetGlobalDeviceStatus(m_wcsName, &dwStatus));

	if( dwStatus & WMDM_STATUS_BUSY )
	{
		hr=WMDM_E_BUSY;
		goto Error;
	}

	pMoveArgs = new MOVETHREADARGS;
	CPRg(pMoveArgs);
	ZeroMemory(pMoveArgs, sizeof(MOVETHREADARGS));

	dwStatus |= (WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_MOVING );
    CHRg(SetGlobalDeviceStatus(m_wcsName, dwStatus, TRUE));
    bBusyStatusSet=TRUE;

	// setup MoveArgs for MoveFunc
	pMoveArgs->dwStatus = dwStatus;
	CARg(pTarget);
	pStg = (CMDSPStorage *)pTarget;
	wcsSrc = (WCHAR *)&(pMoveArgs->wcsSrc[0]);
	CPRg(wcsSrc);
	wcsDst = (WCHAR *)&(pMoveArgs->wcsDst[0]);
    CPRg(wcsDst);

	// Make sure the source and destination are on the same device
	wcsParseDeviceName(m_wcsName, &wcsSrc);
    wcsParseDeviceName(pStg->m_wcsName, &wcsDst);
	if( wcscmp(wcsSrc, wcsDst) )
	{
		hr = WMDM_E_NOTSUPPORTED; // do not support move out of the same device
		goto Error;
	}

    // Now check for target's attributes
	DWORD dwDstAttrib;

	wcscpy(wcsSrc, m_wcsName);
    wcscpy(wcsDst, pStg->m_wcsName);
	if ( fuMode & WMDM_STORAGECONTROL_INSERTINTO )
	{
        CHRg(pTarget->GetAttributes(&dwDstAttrib, NULL));
        CARg( dwDstAttrib & WMDM_FILE_ATTR_FOLDER ); // INSERTINFO must be to a folder
	} 
	else 
	{
        // Get the folder one level up
		pWcs = wcsrchr(wcsDst, 0x5c);
        CFRg(pWcs);
		*pWcs=NULL;

        CFRg( FILE_ATTRIBUTE_DIRECTORY & UtilGetFileAttributesW(wcsDst) ); // Normally shouldn't fail here
	}
 
    pMoveArgs->pThis = this;
	pMoveArgs->bNewThread =(fuMode & WMDM_MODE_THREAD)?TRUE:FALSE;
	
	// Now handle Progress marshaling 
	if( pProgress ) 
	{	
		pMoveArgs->pProgress = pProgress;
	    pProgress->AddRef();  // since we are going to use it in MoveFunc()
        bAddRefed=TRUE;

		if( pMoveArgs->bNewThread )
		{
			CORg(CoMarshalInterThreadInterfaceInStream(
				IID_IWMDMProgress, (LPUNKNOWN)pProgress, 
				(LPSTREAM *)&(pMoveArgs->pStream)));
		} 
	}
 
    if ( m_hFile != INVALID_HANDLE_VALUE ) 
	{
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}

	if( fuMode & WMDM_MODE_BLOCK )
	{
		hr = MoveFunc((void *)pMoveArgs); 
	} 
	else if ( fuMode & WMDM_MODE_THREAD ) 
	{
		if( CreateThread(
				NULL, 
				0, 
				(LPTHREAD_START_ROUTINE)MoveFunc, 
				(void *)pMoveArgs, 
				0, 
				&dwThreadID
				)
		)
		{
			bThreadFailed=FALSE;
			hr=S_OK;
		} 
		else 
		{
			hr=HRESULT_FROM_WIN32(GetLastError());			
		}
	} else 
		hr = E_INVALIDARG;

Error:
	if( (fuMode&WMDM_MODE_BLOCK) || bThreadFailed ) // otherwise these will be in MoveFunc()
	{
		if( bBusyStatusSet )
		{
			dwStatus &= (~(WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_MOVING));
			SetGlobalDeviceStatus(m_wcsName, dwStatus, TRUE);
		}
		if( bProgStarted )
		{
			pProgress->Progress(100);
			pProgress->End();
        }
		if( bAddRefed )
		{
			pProgress->Release(); // since we called AddRef before calling MoveFunc()
		}

		if( pMoveArgs )
		{
			delete pMoveArgs;
		}
	}

	return hr /*WMDM_E_NOTSUPPORTED*/;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\mdspenumstorage.cpp ===
//
//  Microsoft Windows Media Technologies
//   1999 Microsoft Corporation.  All rights reserved.
//
//  Refer to your End User License Agreement for details on your rights/restrictions to use these sample files.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDSPEnumStorage.cpp : Implementation of CMDSPEnumStorage

#include "hdspPCH.h"

/////////////////////////////////////////////////////////////////////////////
// CMDSPEnumStorage
CMDSPEnumStorage::CMDSPEnumStorage()
{
	m_hFFile=INVALID_HANDLE_VALUE; // this is similar to a cursor
	m_nEndSearch=0;				   // this signals the cursor is at the end	
	m_nFindFileIndex=0;            // this indicates the position of FindFile, used for Clone()
}

CMDSPEnumStorage::~CMDSPEnumStorage()
{
	if( m_hFFile !=INVALID_HANDLE_VALUE )
	{
		FindClose(m_hFFile); 
	}
}

STDMETHODIMP CMDSPEnumStorage::Next(ULONG celt, IMDSPStorage * * ppStorage, ULONG * pceltFetched)
{
	HRESULT hr=S_FALSE;

	CARg(ppStorage);
	CARg(pceltFetched);

	*pceltFetched = 0;

    if(m_nEndSearch)
	{
		return S_FALSE;
	}

	if ( wcslen(m_wcsPath) < 3 ) // For the root storage
	{
		CComObject<CMDSPStorage> *pStg;
		hr=CComObject<CMDSPStorage>::CreateInstance(&pStg);

		if( SUCCEEDED(hr) )
		{
			hr=pStg->QueryInterface(IID_IMDSPStorage, reinterpret_cast<void**>(ppStorage));
			if( FAILED(hr) ) 
			{ 
				delete pStg; 
				*pceltFetched=0; 
			}
			else 
			{ 
				wcscpy(pStg->m_wcsName, m_wcsPath);
				if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c ) 
				{
					wcscat(pStg->m_wcsName, g_wcsBackslash);
				}
				m_nEndSearch = 1;  // Signal end of enumeration
			}

		}

        if( SUCCEEDED(hr) ) // if obj created successfully
		{
			*pceltFetched=1;
			if( celt != 1 )
			{
				hr=S_FALSE;  // didn't get what he wanted
			}
		}
		return hr;
	} 
	
	// For non-root storage
    WCHAR wcsTmp[MAX_PATH];
	char szTmp[MAX_PATH];
	ULONG i;

    if( g_bIsWinNT )
	{
		WIN32_FIND_DATAW wfd;
		for(i=0; (i<celt)&&(!m_nEndSearch); )
		{
			if( m_hFFile == INVALID_HANDLE_VALUE ) 
			{    
				wcscpy(wcsTmp, m_wcsPath);
				if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c )
				{
					wcscat(wcsTmp, g_wcsBackslash);
				}
				wcscat(wcsTmp, L"*");
				m_hFFile = FindFirstFileW(wcsTmp, &wfd);
				if( m_hFFile == INVALID_HANDLE_VALUE ) 
				{
					m_nEndSearch = 1;
				}
				else 
				{
					m_nFindFileIndex=1;
				}
			} 
			else 
			{
				if( !FindNextFileW(m_hFFile, &wfd) )
				{
					m_nEndSearch = 1;
				}
				else 
				{
					m_nFindFileIndex++;
				}
			}
		
			if ( !m_nEndSearch )
			{
			   if( !wcscmp(wfd.cFileName, L".") || !wcscmp(wfd.cFileName, L"..") || !wcsicmp(wfd.cFileName, L"PMP") ) 
			   {
				   continue;
			   }

			   CComObject<CMDSPStorage> *pStg;
			   hr=CComObject<CMDSPStorage>::CreateInstance(&pStg);

			   if( SUCCEEDED(hr) )
			   {
					 hr=pStg->QueryInterface(
						 IID_IMDSPStorage, 
						 reinterpret_cast<void**>(&(ppStorage[*pceltFetched]))
						 );
					 
					 if( FAILED(hr) ) 
					 { 
						 delete pStg; 
					 }
					 else 
					 { 
						wcscpy(pStg->m_wcsName, m_wcsPath);
						if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c ) 
						{
							wcscat(pStg->m_wcsName, g_wcsBackslash);
						}
						wcscat(pStg->m_wcsName, wfd.cFileName);
						*pceltFetched = (*pceltFetched)+1;
						i++;
					 }
			   }
			}	
		} // end of For loop 
	} 
	else 
	{ // On Win9x, use A-version of Win32 APIs
		WIN32_FIND_DATAA fd;
		for(i=0; (i<celt)&&(!m_nEndSearch); )
		{
			if( m_hFFile == INVALID_HANDLE_VALUE ) 
			{    
				wcscpy(wcsTmp, m_wcsPath);
				if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c ) 
				{
					wcscat(wcsTmp, g_wcsBackslash);
				}
				wcscat(wcsTmp, L"*");
				WideCharToMultiByte(CP_ACP, NULL, wcsTmp, -1, szTmp, MAX_PATH, NULL, NULL);		
				m_hFFile = FindFirstFileA(szTmp, &fd);
				if( m_hFFile == INVALID_HANDLE_VALUE ) 
				{
					m_nEndSearch = 1;
				}
				else 
				{
					m_nFindFileIndex=1;
				}
			} 
			else 
			{
				if( !FindNextFileA(m_hFFile, &fd) ) 
				{
					m_nEndSearch = 1;
				}
				else
				{
					m_nFindFileIndex++;
				}
			}
		
			if ( !m_nEndSearch )
			{
			   if( !strcmp(fd.cFileName, ".") || !strcmp(fd.cFileName, "..") || !stricmp(fd.cFileName, "PMP") ) 
			   {
				   continue;
			   }
			   CComObject<CMDSPStorage> *pStg;
			   hr=CComObject<CMDSPStorage>::CreateInstance(&pStg);

			   if( SUCCEEDED(hr) )
			   {
				 hr=pStg->QueryInterface(IID_IMDSPStorage, reinterpret_cast<void**>(&(ppStorage[*pceltFetched])));
				 if( FAILED(hr) ) 
				 { 
					 delete pStg; 
				 }
				 else 
				 { 
					wcscpy(pStg->m_wcsName, m_wcsPath);
					if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c ) 
					{
						wcscat(pStg->m_wcsName, g_wcsBackslash);
					}
					MultiByteToWideChar(CP_ACP, NULL, fd.cFileName, -1, wcsTmp, MAX_PATH);
					wcscat(pStg->m_wcsName, wcsTmp);
					*pceltFetched = (*pceltFetched)+1;
					i++;
				 }
			   }
			}	
		} // end of For loop 
	}

	if( SUCCEEDED(hr) && (*pceltFetched<celt) ) 
	{
		hr = S_FALSE;
	}

Error:
    hrLogDWORD("IMDSPEnumStorage::Next returned 0x%08lx", hr, hr);
	return hr;
}

STDMETHODIMP CMDSPEnumStorage::Skip(ULONG celt, ULONG *pceltFetched)
{
	HRESULT hr=S_OK;

	CARg(celt);
	CARg(pceltFetched);
    CFRg(!m_nEndSearch);   // make sure it is not the end of list

	*pceltFetched = 0;
    if( wcslen(m_wcsPath) < 3 ) // do nothing if it is the root storage
	{
		return S_OK; 
	}

    char szTmp[MAX_PATH];
    WCHAR wcsTmp[MAX_PATH];
    ULONG i;

	if( g_bIsWinNT )
	{
		WIN32_FIND_DATAW wfd;
		for(i=0; (i<celt)&&(!m_nEndSearch); )
		{
			if( m_hFFile==INVALID_HANDLE_VALUE ) // at the start
			{
				wcscpy(wcsTmp, m_wcsPath);
				if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c )
				{
					wcscat(wcsTmp, g_wcsBackslash);
				}
				wcscat(wcsTmp, L"*");
				m_hFFile = FindFirstFileW(wcsTmp, &wfd);
				if( m_hFFile == INVALID_HANDLE_VALUE ) 
				{
					m_nEndSearch = 1;
				}
				else 
				{
					m_nFindFileIndex=1;
				}
			} 
			else 
			{
				if( !FindNextFileW(m_hFFile, &wfd) )  
				{
					m_nEndSearch = 1;
				}
				else 
				{
					m_nFindFileIndex++;
				}
			}
			if( !m_nEndSearch ) 
			{
				if( !wcscmp(wfd.cFileName, L".") || !wcscmp(wfd.cFileName, L"..") || !wcsicmp(wfd.cFileName, L"PMP") ) 
				{
					continue;
				}
				*pceltFetched = (*pceltFetched)+1;
				i++;
			}
		}
	} 
	else 
	{ // On Win9x, use A-version of Win32 APIs
		WIN32_FIND_DATAA fd;
		for(i=0; (i<celt)&&(!m_nEndSearch); )
		{
			if( m_hFFile==INVALID_HANDLE_VALUE ) // at the start
			{
				wcscpy(wcsTmp, m_wcsPath);
				if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c ) 
				{
					wcscat(wcsTmp, g_wcsBackslash);
				}
				wcscat(wcsTmp, L"*");
				WideCharToMultiByte(CP_ACP, NULL, wcsTmp, -1, szTmp, MAX_PATH, NULL, NULL);	
				m_hFFile = FindFirstFileA(szTmp, &fd);
				if( m_hFFile == INVALID_HANDLE_VALUE ) 
				{
					m_nEndSearch = 1;
				}
				else 
				{
					m_nFindFileIndex=1;
				}
			} 
			else 
			{
				if( !FindNextFileA(m_hFFile, &fd) )
				{
					m_nEndSearch = 1;
				}
				else 
				{
					m_nFindFileIndex++;
				}
			}
			if( !m_nEndSearch ) 
			{
				if( !strcmp(fd.cFileName, ".") || !strcmp(fd.cFileName, "..") || !stricmp(fd.cFileName, "PMP") ) 
				{
					continue;
				}
				*pceltFetched = (*pceltFetched)+1;
				i++;
			}
		}
	}
	if( *pceltFetched < celt ) 
	{
		hr = S_FALSE;
	}


Error:
    hrLogDWORD("IMDSPEnumStorage::Skip returned 0x%08lx", hr, hr);
	return hr;
}

STDMETHODIMP CMDSPEnumStorage::Reset()
{
    HRESULT hr = S_OK;
	
	m_nEndSearch=0;
	if(m_hFFile && m_hFFile != INVALID_HANDLE_VALUE ) 
	{
		FindClose(m_hFFile);
	}

	m_hFFile = INVALID_HANDLE_VALUE;
	m_nFindFileIndex=0;

    hrLogDWORD("IMDSPEnumStorage::Reset returned 0x%08lx", hr, hr);
	return hr;
}

STDMETHODIMP CMDSPEnumStorage::Clone(IMDSPEnumStorage * * ppEnumStorage)
{
	HRESULT hr=E_FAIL;

	CARg(ppEnumStorage);

	CComObject<CMDSPEnumStorage> *pEnumObj;
	CORg(CComObject<CMDSPEnumStorage>::CreateInstance(&pEnumObj));

	hr=pEnumObj->QueryInterface(IID_IMDSPEnumStorage, reinterpret_cast<void**>(ppEnumStorage));
	if( FAILED(hr) )
	{
		delete pEnumObj;
	}
    else 
	{
		WCHAR wcsTmp[MAX_PATH];
		char szTmp[MAX_PATH];
		int	i, nErrorEnd=0;

		wcscpy(pEnumObj->m_wcsPath, m_wcsPath);
		pEnumObj->m_nEndSearch = m_nEndSearch;
		pEnumObj->m_nFindFileIndex = m_nFindFileIndex;

		if( !(pEnumObj->m_nEndSearch) && (pEnumObj->m_nFindFileIndex) ) 
			// now Clone the FindFile state
		{
			if( g_bIsWinNT )
			{
				WIN32_FIND_DATAW wfd;
				for(i=0; (i<m_nFindFileIndex)&&(!nErrorEnd); )
				{
				  if( pEnumObj->m_hFFile == INVALID_HANDLE_VALUE ) 
				  {    
					wcscpy(wcsTmp, m_wcsPath);
					if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c )
					{
						wcscat(wcsTmp, g_wcsBackslash);
					}
					wcscat(wcsTmp, L"*");
					pEnumObj->m_hFFile = FindFirstFileW(wcsTmp, &wfd);
					if( pEnumObj->m_hFFile == INVALID_HANDLE_VALUE ) 
					{
						nErrorEnd = 1;
					}
					else 
					{
						i=1;
					}
				  } 
				  else 
				  {
					if( !FindNextFileW(pEnumObj->m_hFFile, &wfd) ) 
					{
						nErrorEnd = 1;
					}
					else 
					{
						i++;
					}
				  }
				  if ( !nErrorEnd )
				  {
					if( !wcscmp(wfd.cFileName, L".") || !wcscmp(wfd.cFileName, L"..") || !wcsicmp(wfd.cFileName, L"PMP") ) 
					{
						continue;
					}
				  }
				} // end of FOR loop
			} else {
				WIN32_FIND_DATAA fd;
				for(i=0; (i<m_nFindFileIndex)&&(!nErrorEnd); )
				{
				  if( pEnumObj->m_hFFile == INVALID_HANDLE_VALUE ) 
				  {    
					wcscpy(wcsTmp, m_wcsPath);
					if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c ) 
					{
						wcscat(wcsTmp, g_wcsBackslash);
					}
					wcscat(wcsTmp, L"*");
					WideCharToMultiByte(CP_ACP, NULL, wcsTmp, -1, szTmp, MAX_PATH, NULL, NULL);		
					pEnumObj->m_hFFile = FindFirstFileA(szTmp, &fd);
					if( pEnumObj->m_hFFile == INVALID_HANDLE_VALUE )
					{
						nErrorEnd = 1;
					}
					else 
					{
						i=1;
					}
				  } 
				  else 
				  {
					if( !FindNextFileA(pEnumObj->m_hFFile, &fd) ) 
					{
						nErrorEnd = 1;
					}
					else 
					{
						i++;
					}
				  }
				  if ( !nErrorEnd )
				  {
					if( !strcmp(fd.cFileName, ".") || !strcmp(fd.cFileName, "..") || !stricmp( fd.cFileName, "PMP") ) 
					{
						continue;
					}
				  }
				} // end of FOR loop
			}
		}
		
		if ( nErrorEnd ) 
		{
			hr = E_UNEXPECTED;
		}
		else 
		{
			hr=S_OK;
		}
    }

Error:
    hrLogDWORD("IMDSPEnumStorage::Clone returned 0x%08lx", hr, hr);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\rescopy.h ===
#pragma once

typedef struct tag_RezCallbackData
{
    tag_RezCallbackData()
    {
        pszDirectory = NULL;
        hr = S_OK;
    }

    LPCSTR  pszDirectory;
    HRESULT hr;
} RezCallbackData, *PResCallbackData;

#pragma pack(push, LyraExeHeader, 1)

typedef struct tag_LyraExeHeader
{
    BYTE headerReserverd_1[4];
    BYTE szLyra[4];
    BYTE szDecoderType[3];
    BYTE szRevision[3];
    BYTE szMonth[3];
    BYTE szDay[2];
    BYTE szTime[5];
    BYTE szYear[4];
    BYTE szComment[8];
} LyraExeHeader, *PLyraExeHeader;

extern HRESULT CopyFileResToDirectory( HINSTANCE hInstance, LPCSTR pszDestDir );

#pragma pack(pop, LyraExeHeader)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\mdspstorageglobals.h ===
//
//  Microsoft Windows Media Technologies
//   1999 Microsoft Corporation.  All rights reserved.
//
//  Refer to your End User License Agreement for details on your rights/restrictions to use these sample files.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDSPStorageGlobals.h : Declaration of the CMDSPStorageGlobals

#ifndef __MDSPSTORAGEGLOBALS_H_
#define __MDSPSTORAGEGLOBALS_H_

/////////////////////////////////////////////////////////////////////////////
// CMDSPStorageGlobals
class ATL_NO_VTABLE CMDSPStorageGlobals : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMDSPStorageGlobals, &CLSID_MDSPStorageGlobals>,
	public IMDSPStorageGlobals
{
public:
	CMDSPStorageGlobals()
	{
		m_pMDSPDevice=(IMDSPDevice *)NULL;
	}
	~CMDSPStorageGlobals();

DECLARE_REGISTRY_RESOURCEID(IDR_MDSPSTORAGEGLOBALS)

BEGIN_COM_MAP(CMDSPStorageGlobals)
	COM_INTERFACE_ENTRY(IMDSPStorageGlobals)
END_COM_MAP()

// IMDSPStorageGlobals
public:
	WCHAR m_wcsName[MAX_PATH];
	IMDSPDevice *m_pMDSPDevice;
	STDMETHOD(GetTotalSize)(/*[out]*/ DWORD *pdwTotalSizeLow, /*[out]*/ DWORD *pdwTotalSizeHigh);
	STDMETHOD(GetRootStorage)(/*[out]*/ IMDSPStorage **ppRoot);
	STDMETHOD(GetDevice)(/*[out]*/ IMDSPDevice **ppDevice);
	STDMETHOD(Initialize)(/*[in]*/ UINT fuMode, /*[in]*/ IWMDMProgress *pProgress);
	STDMETHOD(GetStatus)(/*[out]*/ DWORD *pdwStatus);
	STDMETHOD(GetTotalBad)(/*[out]*/ DWORD *pdwBadLow, /*[out]*/ DWORD *pdwBadHigh);
	STDMETHOD(GetTotalFree)(/*[out]*/ DWORD *pdwFreeLow, /*[out]*/ DWORD *pdwFreeHigh);
	STDMETHOD(GetSerialNumber)(/*[out]*/ PWMDMID pSerialNum, /*[in, out]*/BYTE abMac[WMDM_MAC_LENGTH]);
	STDMETHOD(GetCapabilities)(/*[out]*/ DWORD *pdwCapabilities);
};

#endif //__MDSPSTORAGEGLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\mdspstorageglobals.cpp ===
//
//  Microsoft Windows Media Technologies
//   1999 Microsoft Corporation.  All rights reserved.
//
//  Refer to your End User License Agreement for details on your rights/restrictions to use these sample files.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDSPStorageGlobals.cpp : Implementation of CMDSPStorageGlobals

#include "hdspPCH.h"
#include <SerialNumber.h>
 
/////////////////////////////////////////////////////////////////////////////
// CMDSPStorageGlobals

CMDSPStorageGlobals::~CMDSPStorageGlobals()
{
	if( m_pMDSPDevice != NULL )
	{
		m_pMDSPDevice->Release();
	}

	for(int i=0; i<MDSP_MAX_DEVICE_OBJ;i++)
	{
		if( !wcscmp(g_GlobalDeviceInfo[i].wcsDevName, m_wcsName) )
		{
			g_GlobalDeviceInfo[i].pIMDSPStorageGlobals = NULL;
		}
	}
}

STDMETHODIMP CMDSPStorageGlobals::GetCapabilities(DWORD * pdwCapabilities)
{
    HRESULT hr = S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pdwCapabilities);

	*pdwCapabilities = 0;
	*pdwCapabilities =	WMDM_STORAGECAP_FOLDERSINROOT		| 
						WMDM_STORAGECAP_FILESINROOT			|
						WMDM_STORAGECAP_FOLDERSINFOLDERS	|
						WMDM_STORAGECAP_FILESINFOLDERS		;
Error:

    hrLogDWORD("IMDSPStorageGlobals::GetCapabilities returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPStorageGlobals::GetSerialNumber(
	PWMDMID pSerialNum,
	BYTE abMac[WMDM_MAC_LENGTH])
{
	HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pSerialNum);

	IMDSPDevice *pDev;		// For PM SP, device is the same as StorageGlobals
	CHRg(GetDevice(&pDev));

	hr = UtilGetSerialNumber(m_wcsName, pSerialNum, FALSE);

	pDev->Release();

	if( hr == HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) )
	{
		hr = WMDM_E_NOTSUPPORTED;
	}

	if( hr == S_OK )
	{
		// MAC the parameters
		HMAC hMAC;
		CORg(g_pAppSCServer->MACInit(&hMAC));
		CORg(g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pSerialNum), sizeof(WMDMID)));
		CORg(g_pAppSCServer->MACFinal(hMAC, abMac));
	}

Error:

    hrLogDWORD("IMDSPStorageGlobals::GetSerialNumber returned 0x%08lx", hr, hr);
	
	return hr;
}

STDMETHODIMP CMDSPStorageGlobals::GetTotalSize(DWORD * pdwTotalSizeLow, DWORD * pdwTotalSizeHigh)
{
	HRESULT        hr = S_OK;
	char           pszDrive[32];
	DWORD          dwSectPerClust;
	DWORD          dwBytesPerSect;
	DWORD          dwFreeClusters;
	DWORD          dwTotalClusters;
	ULARGE_INTEGER i64TotalBytes;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pdwTotalSizeLow);
	CARg(pdwTotalSizeHigh);

	WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, pszDrive, 32, NULL, NULL);	

	CFRg(GetDiskFreeSpace(
		pszDrive,
		&dwSectPerClust, &dwBytesPerSect,
		&dwFreeClusters, &dwTotalClusters)
	);

	i64TotalBytes.QuadPart = UInt32x32To64(dwBytesPerSect, dwSectPerClust*dwTotalClusters);

    *pdwTotalSizeLow = i64TotalBytes.LowPart;
	*pdwTotalSizeHigh = i64TotalBytes.HighPart;

Error:

    hrLogDWORD("IMDSPStorageGlobals::GetTotalFree returned 0x%08lx", hr, hr);
    
	return hr;
}


STDMETHODIMP CMDSPStorageGlobals::GetTotalFree(DWORD * pdwFreeLow, DWORD * pdwFreeHigh)
{
	HRESULT        hr = S_OK;
	char           pszDrive[32];
	DWORD          dwSectPerClust;
	DWORD          dwBytesPerSect;
	DWORD          dwFreeClusters;
	DWORD          dwTotalClusters;
	ULARGE_INTEGER i64FreeBytesToCaller;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pdwFreeLow);
	CARg(pdwFreeHigh);

	WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, pszDrive, 32, NULL, NULL);	

	CFRg(GetDiskFreeSpace(
		pszDrive,
		&dwSectPerClust, &dwBytesPerSect,
		&dwFreeClusters, &dwTotalClusters)
	);

	i64FreeBytesToCaller.QuadPart = UInt32x32To64(dwBytesPerSect, dwSectPerClust*dwFreeClusters);

    *pdwFreeLow = i64FreeBytesToCaller.LowPart;
	*pdwFreeHigh = i64FreeBytesToCaller.HighPart;

Error:
    hrLogDWORD("IMDSPStorageGlobals::GetTotalFree returned 0x%08lx", hr, hr);
    return hr;
}

STDMETHODIMP CMDSPStorageGlobals::GetTotalBad(DWORD * pdwBadLow, DWORD * pdwBadHigh)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
    
	CORg(WMDM_E_NOTSUPPORTED);

Error:

	hrLogDWORD("IMDSPStorageGlobals::GetTotalBad returned 0x%08lx", hr, hr);
    
    return hr;
}

STDMETHODIMP CMDSPStorageGlobals::GetStatus(DWORD * pdwStatus)
{
	HRESULT      hr;
	IMDSPDevice *pDev;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CHRg(GetDevice(&pDev));

	hr = pDev->GetStatus(pdwStatus);

	pDev->Release();

Error:

    hrLogDWORD("IMDSPStorageGlobals::GetStatus returned 0x%08lx", hr, hr);
	
	return hr;
}


STDMETHODIMP CMDSPStorageGlobals::Initialize(UINT fuMode, IWMDMProgress * pProgress)
{
	HRESULT hr=S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CORg(WMDM_E_NOTSUPPORTED);

Error:

    hrLogDWORD("IMDSPStorageGlobals::Initialize returned 0x%08lx", hr, hr);
	
	return hr;
}

STDMETHODIMP CMDSPStorageGlobals::GetDevice(IMDSPDevice * * ppDevice)
{
	HRESULT hr;
	CComObject<CMDSPDevice> *pObj;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(ppDevice);

	if( m_pMDSPDevice )
	{
		*ppDevice = m_pMDSPDevice;
        (*ppDevice)->AddRef();
		return S_OK;
	}

	CORg(CComObject<CMDSPDevice>::CreateInstance(&pObj));

	hr = pObj->QueryInterface(
		IID_IMDSPDevice,
		reinterpret_cast<void**>(ppDevice)
	);
	if( FAILED(hr) )
	{
		delete pObj;
		goto Error;
	}
	else
	{
		wcscpy(pObj->m_wcsName, m_wcsName);
		
		pObj->InitGlobalDeviceInfo();

		m_pMDSPDevice = *ppDevice;
		m_pMDSPDevice->AddRef();
	}

	hr = S_OK;

Error:

    hrLogDWORD("IMDSPStorageGlobals::GetDevice returned 0x%08lx", hr, hr);
	
	return hr;
}

STDMETHODIMP CMDSPStorageGlobals::GetRootStorage(IMDSPStorage * * ppRoot)
{
	HRESULT hr;
	CComObject<CMDSPStorage> *pObj;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(ppRoot);

	CORg(CComObject<CMDSPStorage>::CreateInstance(&pObj));

	hr = pObj->QueryInterface(
		IID_IMDSPStorage,
		reinterpret_cast<void**>(ppRoot)
	);
	if( FAILED(hr) )
	{
		delete pObj;
		goto Error;
	}
	else
	{
		wcscpy(pObj->m_wcsName, m_wcsName);
		if( m_wcsName[wcslen(m_wcsName)-1] != 0x5c )
		{
			wcscat(pObj->m_wcsName, g_wcsBackslash);
		}
	}

	hr = S_OK;

Error:

    hrLogDWORD("IMDSPStorageGlobals::GetRootStorage returned 0x%08lx", hr, hr);
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\rescopy.cpp ===
#include "hdspPCH.h"
#include "resource.h"
#include "rescopy.h"

static char *g_szMonths[] = 
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

BOOL CALLBACK RezNamesCallback( HMODULE hModule, LPCSTR lpszType, LPSTR lpszName, LPARAM lParam )
{
    PResCallbackData pData = (PResCallbackData)lParam;
    DWORD            cResourceBytes = 0;
    CHAR             szDataPath[MAX_PATH];
    HRSRC            hrsrc = NULL;
    HGLOBAL          hglbResource = NULL;
    LPVOID           pDataFile = NULL;
    HANDLE           hFileWrite = INVALID_HANDLE_VALUE;
    DWORD            cBytesWritten = 0;
    BOOL             fEndSlash = FALSE;
    LPCSTR           pszEndSlash = NULL;
    PLyraExeHeader   pHeader = NULL;
    LyraExeHeader    HeaderComp;
    BOOL             fPerformVersionCheck = TRUE;
    BOOL             fOKToCopy = TRUE;
    UINT             idxMonth = 0;

    if( NULL == pData )
    {
        return( FALSE );
    }

    pszEndSlash = pData->pszDirectory;
    while( pszEndSlash && *pszEndSlash )
    {
        fEndSlash = ( *pszEndSlash == '\\' );
        pszEndSlash = CharNextA(pszEndSlash);
    }

    if( 0 > _snprintf(  szDataPath,
                        sizeof(szDataPath)/sizeof(szDataPath[0]),
                        fEndSlash ? "%s%s" : "%s\\%s",
                        pData->pszDirectory,
                        lpszName ) )
    {
        pData->hr = E_OUTOFMEMORY;
        return( FALSE );
    }

    hrsrc = FindResourceA( hModule, lpszName, lpszType );
    if( NULL == hrsrc )
    {
        pData->hr = HRESULT_FROM_WIN32( GetLastError() );
        return( FALSE );
    }

    cResourceBytes = SizeofResource( hModule, hrsrc );
    if( 0 == cResourceBytes )
    {
        pData->hr = E_UNEXPECTED;
        return( FALSE );
    }

    hglbResource = LoadResource(hModule, hrsrc );
    if( NULL == hrsrc )
    {
        pData->hr = HRESULT_FROM_WIN32( GetLastError() );
        return( FALSE );
    }

    //
    // Note: Win32 Claims that you do NOT have to Free/Unlock resource after calling lock
    //

    pDataFile = LockResource( hglbResource );
    if( NULL == pDataFile )
    {
        pData->hr = HRESULT_FROM_WIN32( GetLastError() );
        return( FALSE );
    }

    pszEndSlash = strrchr( lpszName, '.' );

    if( NULL != pszEndSlash &&
        0 == stricmp(pszEndSlash, ".exe") &&
        cResourceBytes > sizeof(LyraExeHeader) )
    {
        pHeader = (PLyraExeHeader)pDataFile;

        //
        // If our files don't have "LYRA" in them, then there is no
        // version check to perform (ughhhh!!!)
        //

        if( strncmp((char *)pHeader->szLyra, "LYRA", sizeof(pHeader->szLyra) ) )
        {
            fPerformVersionCheck = FALSE;
        }
    }
    else
    {
        fPerformVersionCheck = FALSE;
    }

    hFileWrite = CreateFileA( szDataPath,
                             GENERIC_WRITE | GENERIC_READ,
                             0,
                             NULL,
                             OPEN_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL );

    if( INVALID_HANDLE_VALUE == hFileWrite )
    {
        pData->hr = HRESULT_FROM_WIN32( GetLastError() );
        return( FALSE );
    }

    if( fPerformVersionCheck )
    {
        if( !ReadFile( hFileWrite,
                       &HeaderComp,
                       sizeof(HeaderComp),
                       &cBytesWritten,
                       NULL ) )
        {
            fPerformVersionCheck = FALSE;
        }

        //
        // Make sure we got the number of bytes we need for our version header,
        // if not, then just copy the file!
        //

        if( cBytesWritten != sizeof(HeaderComp) )
        {
            fPerformVersionCheck = FALSE;
        }
    }

    if( fPerformVersionCheck )
    {

        //
        // If we ARE going to perform a version check, then this MUST be set to false intially because
        // if we fail on the version check, we DONT want to copy the file!
        //

        fOKToCopy = FALSE;

        //
        // At this point, we know we have version stuff in our .exe in our resource,
        // and we know that we have 36 bytes of what "should" be a header, now
        // compare them, if they don't match, it's okay to copy
        //

        if( strncmp( (char *)pHeader->szLyra, (char *)HeaderComp.szLyra, sizeof(HeaderComp.szLyra) ) )
        {
            fOKToCopy = TRUE;
        }
        else
        {
            //
            // Okay, we have version information, check the revision number
            //

            if( pHeader->szRevision[0] >= HeaderComp.szRevision[0] )
            {
                if( pHeader->szRevision[0] == HeaderComp.szRevision[0] )
                {
                    if( pHeader->szRevision[2] >= HeaderComp.szRevision[2] )
                    {
                        if( pHeader->szRevision[2] > HeaderComp.szRevision[2] )
                        {
                            fOKToCopy = TRUE;
                        }
                        else
                        {
                            SYSTEMTIME sysTimeFile;
                            SYSTEMTIME sysTimeResource;
                            FILETIME ftFile;
                            FILETIME ftRes;

                            ZeroMemory( &sysTimeFile, sizeof(sysTimeFile) );
                            ZeroMemory( &sysTimeResource, sizeof(sysTimeResource) );

                            for( idxMonth = 0; idxMonth < 12; idxMonth++ )
                            {
                                if( !_strnicmp( (char*)pHeader->szMonth, g_szMonths[idxMonth], sizeof(pHeader->szMonth) ) )
                                {
                                    sysTimeResource.wMonth = idxMonth + 1;
                                }

                                if( !_strnicmp( (char*)HeaderComp.szMonth, g_szMonths[idxMonth], sizeof(HeaderComp.szMonth) ) )
                                {
                                    sysTimeFile.wMonth = idxMonth + 1;
                                }
                            }

                            sysTimeResource.wDay = ( pHeader->szDay[0] - '0' ) * 10 +
                                                   ( pHeader->szDay[1] - '0' );
                            sysTimeFile.wDay =     ( HeaderComp.szDay[0] - '0' ) * 10 +
                                                   ( HeaderComp.szDay[1] - '0' );

                            sysTimeResource.wYear= ( pHeader->szYear[0] - '0' ) * 1000 +
                                                   ( pHeader->szYear[1] - '0' ) * 100 +
                                                   ( pHeader->szYear[2] - '0' ) * 10 +
                                                   ( pHeader->szYear[3] - '0' );

                            sysTimeFile.wYear=     ( HeaderComp.szYear[0] - '0' ) * 1000 +
                                                   ( HeaderComp.szYear[1] - '0' ) * 100 +
                                                   ( HeaderComp.szYear[2] - '0' ) * 10 +
                                                   ( HeaderComp.szYear[3] - '0' );

                            sysTimeResource.wHour = ( pHeader->szTime[0] - '0' ) * 10 +
                                                    ( pHeader->szTime[1] - '0' );
                            sysTimeFile.wHour =     ( HeaderComp.szTime[0] - '0' ) * 10 +
                                                    ( HeaderComp.szTime[1] - '0' );

                            sysTimeResource.wMinute = ( pHeader->szTime[0] - '0' ) * 10 +
                                                      ( pHeader->szTime[1] - '0' );
                            sysTimeFile.wMinute =     ( HeaderComp.szTime[3] - '0' ) * 10 +
                                                      ( HeaderComp.szTime[4] - '0' );

                            SystemTimeToFileTime( &sysTimeResource, &ftRes );
                            SystemTimeToFileTime( &sysTimeFile, &ftFile );

                            fOKToCopy = ( CompareFileTime( &ftRes, &ftFile ) > 0 );
                        }
                    }
                }
                else
                {
                    fOKToCopy = TRUE;
                }
            }
        }
    }

    if( fOKToCopy )
    {
        SetFilePointer( hFileWrite, 0, NULL, FILE_BEGIN );
        SetEndOfFile( hFileWrite );

        if( !WriteFile( hFileWrite,
                        pDataFile,
                        cResourceBytes,
                        &cBytesWritten,
                        NULL ) )
        {
            pData->hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    CloseHandle( hFileWrite );
    return( TRUE );
}

HRESULT CopyFileResToDirectory( HINSTANCE hInstance, LPCSTR pszDestDir )
{
    HRESULT         hr = S_OK;
    RezCallbackData data;
    DWORD           dwAttributes;
    CHAR            szCreatePath[MAX_PATH];
    LPCSTR          pszCreateDir = NULL;

    if( NULL == hInstance ||
        NULL == pszDestDir )
    {
        return( E_INVALIDARG );
    }

    dwAttributes = GetFileAttributesA( pszDestDir );
    if( -1 != dwAttributes &&
        (!(FILE_ATTRIBUTE_DIRECTORY & dwAttributes )) )
    {
        return( E_INVALIDARG );
    }
    
    if( -1 == dwAttributes )
    {
        pszCreateDir = pszDestDir;

        while( *pszCreateDir && 
               SUCCEEDED( hr ) )
        {
            if( *pszCreateDir == '\\' )
            {
                if( ( (LPBYTE)pszCreateDir - (LPBYTE)pszDestDir ) > sizeof(szCreatePath) )
                {
                    hr = E_INVALIDARG;
                    continue;
                }
                else
                {
                    pszCreateDir = CharNextA( pszCreateDir );

                    memcpy( szCreatePath, pszDestDir, (LPBYTE)pszCreateDir-(LPBYTE)pszDestDir );
                    ((LPBYTE)szCreatePath)[ (LPBYTE)pszCreateDir - (LPBYTE)pszDestDir] = '\0';

                    if( strlen(szCreatePath) != 3 && // 3 indicates the drive path
                        !CreateDirectoryA( szCreatePath, NULL ) )
                    {
                        hr = HRESULT_FROM_WIN32( GetLastError() );

                        if( HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS ) == hr )
                        {
                            hr = S_OK;
                        }
                    }
                    continue;
                }
            }

            pszCreateDir = CharNextA( pszCreateDir );
        }

        if( SUCCEEDED( hr ) )
        {
            if( strlen(pszDestDir) != 3 && // 3 indicates the drive path
                !CreateDirectoryA( pszDestDir, NULL ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );

                if( HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS ) == hr )
                {
                    hr = S_OK;
                }
            }
        }
    }

#ifdef LYRA_HANDLES_HIDDEN
    if( SUCCEEDED( hr ) )
    {
        dwAttributes = GetFileAttributesA( pszDestDir );

        if( (DWORD)-1 != dwAttributes )
        {
            SetFileAttributesA( pszDestDir, dwAttributes | FILE_ATTRIBUTE_HIDDEN );
        }
    }
#endif

    if( SUCCEEDED( hr ) )
    {
        data.pszDirectory = pszDestDir;

        if( !EnumResourceNamesA( hInstance, "File", (ENUMRESNAMEPROC)RezNamesCallback, (LPARAM) &data) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    if( SUCCEEDED( hr ) )
    {
        hr = data.hr;
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\mdsputil.cpp ===
//
//  Microsoft Windows Media Technologies
//   1999 Microsoft Corporation.  All rights reserved.
//
//  Refer to your End User License Agreement for details on your rights/restrictions to use these sample files.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 

//***************************************************************************
//
// Name: 		MDSPutil.cpp
//
// Description:	Utility functions for MDSP 
//
//***************************************************************************

#include "hdspPCH.h"
#include <SerialNumber.h>

#define MDSP_PMID_IOMEGA  2     // from "serialid.h"

extern BOOL IsAdministrator(DWORD& dwLastError);

UINT __stdcall UtilGetLyraDriveType(LPSTR szDL)
{
	UINT uType = GetDriveType( szDL );

	if( DRIVE_REMOVABLE == uType )
	{
		WMDMID stID;
		HRESULT hr;
	    WCHAR wcsTmp[4]=L"A:\\";

        wcsTmp[0] = (USHORT)szDL[0];

#define WITH_IOMEGA
#ifdef WITH_IOMEGA
extern BOOL __stdcall IsIomegaDrive(DWORD dwDriveNum);
        
        DWORD dwLastError;
        if( IsAdministrator(dwLastError) )
		{
                        DWORD dwDriveNum;
                        if  (wcsTmp[0] >= L'A' && wcsTmp[0] <= L'Z')
                        {
                            dwDriveNum = wcsTmp[0] - L'A';
                        }
                        else if  (wcsTmp[0] >= L'a' && wcsTmp[0] <= L'z')
                        {
                            dwDriveNum = wcsTmp[0] - L'a';
                        }
                        else
                        {
                            // GetDriveType returned  DRIVE_REMOVABLE
                            // Assuming szDl is nothing more than
                            // drive_letter:\, we won't get here.
                            
                            // Following will force IsIomegaDrive to 
                            // return 0
                            dwDriveNum = 26;
                        }
			if( !IsIomegaDrive(dwDriveNum) )
			{
				uType = DRIVE_LYRA_TYPE;
			}
		}
		else  // ignore dwLastError. If not Administrator, call UtilGetSerialNumber which calls into PMSP Service
		{
			hr = UtilGetSerialNumber(wcsTmp, &stID, 0);
			if( S_OK!=hr || stID.dwVendorID != MDSP_PMID_IOMEGA )
			{
				uType = DRIVE_LYRA_TYPE;
			}
		}
#else
		hr = UtilGetSerialNumber(wcsTmp, &stID, 0);

		if( ((S_OK==hr)&&(20==stID.SerialNumberLength)) ||
			(HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr) 
		)
		{
			uType = DRIVE_LYRA_TYPE;
		}
#endif
	} 

	else
	{
		uType = DRIVE_UNKNOWN;
	}

    return uType;
}

BOOL UtilSetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes)
{
	if( g_bIsWinNT )
	{
		return SetFileAttributesW(lpFileName, dwFileAttributes);
	} 
	else 
	{ 
		BOOL bRet;
		char *szTmp=NULL;
		UINT uLen = 2*(wcslen(lpFileName)+1);
		szTmp = new char [uLen];
         
        if(!szTmp) 
		{
			SetLastError(ERROR_OUTOFMEMORY);
			return FALSE;  
		}

		WideCharToMultiByte(CP_ACP, NULL, lpFileName, -1, szTmp, uLen, NULL, NULL);
   
		bRet = SetFileAttributesA(szTmp, dwFileAttributes);

		if( szTmp ) 
		{
			delete [] szTmp;
		}
		return bRet;
	}
}

BOOL UtilCreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
	if( g_bIsWinNT )
	{
		return CreateDirectoryW(lpPathName, lpSecurityAttributes);
	} 
	else 
	{ 
		BOOL bRet;
		char *szTmp=NULL;
		UINT uLen = 2*(wcslen(lpPathName)+1);
		szTmp = new char [uLen];
         
        if(!szTmp) 
		{
			SetLastError(ERROR_OUTOFMEMORY);
			return FALSE;  
		}

		WideCharToMultiByte(CP_ACP, NULL, lpPathName, -1, szTmp, uLen, NULL, NULL);
   
		bRet = CreateDirectoryA(szTmp, lpSecurityAttributes);

		if( szTmp ) 
		{
			delete [] szTmp;
		}
		return bRet;
	}
}

DWORD UtilGetFileAttributesW(LPCWSTR lpFileName)
{
	if( g_bIsWinNT )
	{
		return GetFileAttributesW(lpFileName);
	} 
	else 
	{ 
		DWORD dwRet;
		char *szTmp=NULL;
		UINT uLen = 2*(wcslen(lpFileName)+1);
		szTmp = new char [uLen];
         
        if(!szTmp) 
		{
			SetLastError(ERROR_OUTOFMEMORY);
			return 0xFFFFFFFF;  
		}

		WideCharToMultiByte(CP_ACP, NULL, lpFileName, -1, szTmp, uLen, NULL, NULL);
   
		dwRet = GetFileAttributesA(szTmp);

		if( szTmp ) 
		{
			delete [] szTmp;
		}
		return dwRet;
	}
}

HANDLE UtilCreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
	if( g_bIsWinNT )
	{
		return CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
	} 
	else 
	{ 
		HANDLE hRet=INVALID_HANDLE_VALUE;
		char *szTmp=NULL;
		UINT uLen = 2*(wcslen(lpFileName)+1);
		szTmp = new char [uLen];
         
        if(!szTmp) 
		{
			SetLastError(ERROR_OUTOFMEMORY);
			return INVALID_HANDLE_VALUE;  
		}

		WideCharToMultiByte(CP_ACP, NULL, lpFileName, -1, szTmp, uLen, NULL, NULL);
   
		hRet = CreateFileA(szTmp, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

		if( szTmp ) 
		{
			delete [] szTmp;
		}
		return hRet;
	}
}

BOOL UtilMoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
{
	if( g_bIsWinNT )
	{
		return MoveFileW(lpExistingFileName, lpNewFileName);
	} 
	else 
	{ 
		BOOL bRet;
		char *szTmpSrc=NULL, *szTmpDst=NULL;
		szTmpSrc = new char [2*(wcslen(lpExistingFileName)+1)];
		szTmpDst = new char [2*(wcslen(lpNewFileName)+1)];
         
        if( (!szTmpSrc) || (!szTmpDst)) 
		{
                        if( szTmpSrc ) 
                        {
                            delete [] szTmpSrc;
                            szTmpSrc=NULL;
                        }
			SetLastError(ERROR_OUTOFMEMORY);
			return FALSE;  
		}

		WideCharToMultiByte(CP_ACP, NULL, lpExistingFileName, -1, szTmpSrc, 2*(wcslen(lpExistingFileName)+1), NULL, NULL);
		WideCharToMultiByte(CP_ACP, NULL, lpNewFileName, -1, szTmpDst, 2*(wcslen(lpNewFileName)+1), NULL, NULL);
    
		bRet = MoveFileA(szTmpSrc, szTmpDst);

		if( szTmpSrc ) 
		{
			delete [] szTmpSrc;
			szTmpSrc=NULL;
		}
		if( szTmpDst ) 
		{
			delete [] szTmpDst;
			szTmpDst=NULL;
		}
		return bRet;
	}
}

void wcsParseDeviceName(WCHAR *wcsIn, WCHAR **wcsOut)
{
	WCHAR wcsTmp[MAX_PATH], *pWcs;

        // @@@@ Change to a safe copy, but should we return error codes?
        // wcsIn is MAX_PATH chars for many calls to this function
	wcscpy( wcsTmp, wcsIn );

	pWcs = wcschr( wcsTmp, 0x5c );
	
    if( pWcs )
	{
		*pWcs=0;
	}

        // @@@@ wcsOut is 32 char in calls from this file
	wcscpy( *wcsOut, wcsTmp );
}

HRESULT GetFileSizeRecursive(char *szPath, DWORD *pdwSizeLow, DWORD *pdwSizeHigh)
{
	HRESULT hr         = S_OK;
    HANDLE  hFile      = INVALID_HANDLE_VALUE;
	HANDLE  hFindFile  = INVALID_HANDLE_VALUE;
    DWORD   dwSizeLow  = 0;
	DWORD   dwSizeHigh = 0;
    WIN32_FIND_DATAA fd;
    char szLP[MAX_PATH];

	CARg( szPath );
	CARg( pdwSizeLow );
	CARg( pdwSizeHigh ); 

	strcpy( szLP, szPath );
    if( FILE_ATTRIBUTE_DIRECTORY & GetFileAttributesA(szPath) )
	{	
		if( szLP[strlen(szLP)-1] != 0x5c )
		{
			strcat(szLP, g_szBackslash);
		}
		strcat(szLP, "*");

		hFindFile = FindFirstFileA(szLP, &fd);
        if( hFindFile != INVALID_HANDLE_VALUE )
		{
			if( strcmp(fd.cFileName, ".") && strcmp(fd.cFileName, "..") )
			{
				szLP[strlen(szLP)-1] = 0; // erase the '*'
				strcat(szLP, fd.cFileName);
				CORg(GetFileSizeRecursive(szLP, pdwSizeLow, pdwSizeHigh));
			}
			
			while ( FindNextFileA(hFindFile, &fd) ) 
			{
				if( strcmp(fd.cFileName, ".") && strcmp(fd.cFileName, "..") )
				{
					strcpy(szLP, szPath);
					if( szLP[strlen(szLP)-1] != 0x5c )
					{
						strcat(szLP, g_szBackslash);
					}
					strcat(szLP, fd.cFileName);
					CORg(GetFileSizeRecursive(szLP, pdwSizeLow, pdwSizeHigh));
				}
			} 
			hr = GetLastError();
			if( hr == ERROR_NO_MORE_FILES )
			{
				hr = S_OK; 
			}
			else
			{
				hr = HRESULT_FROM_WIN32(hr);
			}
		}	    	
	}
	else
	{
		hFile = CreateFileA(
			szPath,
			GENERIC_READ,
			FILE_SHARE_READ | FILE_SHARE_WRITE,
			NULL,
			OPEN_EXISTING,
			0,
			NULL
		);
	    CWRg(hFile != INVALID_HANDLE_VALUE); 

	 	dwSizeLow = GetFileSize(hFile, &dwSizeHigh);

        CloseHandle(hFile);

		CWRg( 0xFFFFFFFF != dwSizeLow );

		*pdwSizeLow += dwSizeLow;
		*pdwSizeHigh += dwSizeHigh;

		hr = S_OK;
    }

Error:

	if( hFindFile != INVALID_HANDLE_VALUE )
	{
		FindClose(hFindFile);
	}

	return hr;
}

HRESULT DeleteFileRecursive(char *szPath)
{
	HRESULT hr=S_OK;
 
	CARg(szPath);

    if( FILE_ATTRIBUTE_DIRECTORY & GetFileAttributesA(szPath) )
	{	
	    HANDLE hFindFile = INVALID_HANDLE_VALUE;
	    WIN32_FIND_DATAA fd;
		char szLP[MAX_PATH];
 
		strcpy(szLP, szPath);
		if( szLP[strlen(szLP)-1] != 0x5c )
		{
			strcat(szLP, g_szBackslash);
		}
		strcat(szLP, "*");

		hFindFile = FindFirstFileA(szLP, &fd);
        if ( hFindFile != INVALID_HANDLE_VALUE )
		{
			do {
				if( strcmp(fd.cFileName, ".") && strcmp(fd.cFileName, "..") )
				{
					strcpy(szLP, szPath);
					if( szLP[strlen(szLP)-1] != 0x5c )
					{
						strcat(szLP, g_szBackslash);
					}
					strcat(szLP, fd.cFileName);
					CHRg(DeleteFileRecursive(szLP)); 
				}
			} while ( FindNextFileA(hFindFile, &fd) ) ;
	
			FindClose(hFindFile);
		
			hr = GetLastError();
		}
		else
		{
			hr = GetLastError();
		}
		    
		// Until here this dir should be empty
		if( hr == ERROR_NO_MORE_FILES )
		{
			CWRg(RemoveDirectory(szPath));
			hr = S_OK;
		}
		else
		{
			hr = HRESULT_FROM_WIN32(hr);
		}
	}
	else
	{
		CWRg( DeleteFileA(szPath) );
    }

Error:

	return hr;
}

HRESULT SetGlobalDeviceStatus(WCHAR *wcsNameIn, DWORD dwStat, BOOL bClear)
{
	HRESULT hr = S_OK;
	WCHAR   wcsName[32];
	WCHAR  *pWN;
	int     i;

    g_CriticalSection.Lock();

    CARg(wcsNameIn);

	pWN = &wcsName[0];
	wcsParseDeviceName(wcsNameIn, &pWN);

	// Search for existing entries to see if there is a match
	//
	for( i=0; i<MDSP_MAX_DEVICE_OBJ; i++ )
	{
		if( g_GlobalDeviceInfo[i].bValid )
		{
			if(!wcscmp(wcsName, g_GlobalDeviceInfo[i].wcsDevName) )
			{
				if( bClear )
				{
					g_GlobalDeviceInfo[i].dwStatus = dwStat;
				}
				else 
				{
					g_GlobalDeviceInfo[i].dwStatus |= dwStat;
				}

				break;  // a match has been found;
			}
		} 
	}

	if( !(i<MDSP_MAX_DEVICE_OBJ) ) // new entry
	{
		for(i=0; i<MDSP_MAX_DEVICE_OBJ; i++)
		{
			if( !(g_GlobalDeviceInfo[i].bValid) )  // found empty space
			{
				wcscpy(g_GlobalDeviceInfo[i].wcsDevName, wcsName);
				g_GlobalDeviceInfo[i].bValid = TRUE;
				g_GlobalDeviceInfo[i].dwStatus = dwStat;
				break;
			}
		}
	}

	if( i<MDSP_MAX_DEVICE_OBJ )
	{
		hr = S_OK;
	}
	else
	{
		hr = hrNoMem;
	}

Error:

	g_CriticalSection.Unlock();

	return hr;
}

HRESULT GetGlobalDeviceStatus(WCHAR *wcsNameIn, DWORD *pdwStat)
{
	HRESULT  hr = S_OK;
	WCHAR    wcsName[32];
	WCHAR   *pWN;
	int      i;

    CARg(wcsNameIn);

	pWN = &wcsName[0];
	wcsParseDeviceName(wcsNameIn, &pWN);

	// Search for existing entries to see if there is a match
	//
	for( i=0; i<MDSP_MAX_DEVICE_OBJ; i++ )
	{
		if( g_GlobalDeviceInfo[i].bValid )
		{
			if(!wcscmp(wcsName, g_GlobalDeviceInfo[i].wcsDevName) )
			{
				*pdwStat = g_GlobalDeviceInfo[i].dwStatus;
				break;  // a match has been found;
			}
		} 
	}

	if( i<MDSP_MAX_DEVICE_OBJ )
	{
		hr = S_OK;
	}
	else
	{
		hr = E_FAIL;
	}

Error:

	return hr;
}

HRESULT QuerySubFoldersAndFilesW(LPCWSTR wcsCurrentFolder, DWORD *pdwAttr)
{
	HRESULT hr=E_FAIL;
	LPWSTR wcsName=NULL;
    int len;
	WIN32_FIND_DATAW wfd;
	int	nErrorEnd=0;
    HANDLE hFFile=INVALID_HANDLE_VALUE;
    DWORD dwAttrib;

	CARg(wcsCurrentFolder);
	CARg(pdwAttr);

	len=wcslen(wcsCurrentFolder);
	CARg(len>2);

    wcsName = new WCHAR [len+MAX_PATH];
	CPRg(wcsName);

	wcscpy(wcsName, wcsCurrentFolder);
	if( wcsName[wcslen(wcsName)-1] != 0x5c )
	{
		wcscat(wcsName, g_wcsBackslash);
	}
    wcscat(wcsName, L"*");


	while( !nErrorEnd )
	{
		if( hFFile == INVALID_HANDLE_VALUE ) 
		{    
			hFFile = FindFirstFileW(wcsName, &wfd);
			if( hFFile == INVALID_HANDLE_VALUE )
			{
				nErrorEnd = 1;
			}
		} 
		else 
		{
			if( !FindNextFileW(hFFile, &wfd) ) 
			{
				nErrorEnd = 1;
			}
		}
		
		if ( !nErrorEnd && hFFile != INVALID_HANDLE_VALUE )
		{
			if( !wcscmp(wfd.cFileName, L".") || !wcscmp(wfd.cFileName, L"..") ) 
			{
				continue;
			}
			else 
			{
				wcscpy(wcsName, wcsCurrentFolder);
				if( wcsName[wcslen(wcsName)-1] != 0x5c ) 
				{
					wcscat(wcsName, g_wcsBackslash);
				}
				wcscat(wcsName, wfd.cFileName);
		   		dwAttrib = GetFileAttributesW(wcsName);
	            if( dwAttrib & FILE_ATTRIBUTE_DIRECTORY )
				{
					*pdwAttr |= WMDM_STORAGE_ATTR_HAS_FOLDERS;
// definition is in MDSPdefs.h #define ALSO_CHECK_FILES
#ifndef ALSO_CHECK_FILES
					break;
#endif
				} 
#ifdef ALSO_CHECK_FILES
				else 
				{
					*pdwAttr |= WMDM_STORAGE_ATTR_HAS_FILES;
				}
				if( (*pdwAttr & WMDM_STORAGE_ATTR_HAS_FOLDERS) &&
					(*pdwAttr & WMDM_STORAGE_ATTR_HAS_FILES ) )
				{
					break; // No need to continue since we found both
				}
#endif
			}
		} // End of If
	} // End of while 
		
    hr=S_OK;
Error:
	if( hFFile != INVALID_HANDLE_VALUE )
	{
		FindClose(hFFile);
	}
	if( wcsName )
	{
		delete [] wcsName;
	}
	return hr; // If FAILED(hr), sorry, can't do it.
}

HRESULT QuerySubFoldersAndFilesA(LPCSTR szCurrentFolder, DWORD *pdwAttr)
{
	HRESULT hr=E_FAIL;
	LPSTR szName=NULL;
    int len;
	WIN32_FIND_DATAA fd;
	int	nErrorEnd=0;
    HANDLE hFFile=INVALID_HANDLE_VALUE;
    DWORD dwAttrib;

	CARg(szCurrentFolder);
	CARg(pdwAttr);

	len=strlen(szCurrentFolder);
	CARg(len>2);

    szName = new char [len+MAX_PATH];
	CPRg(szName);

	strcpy(szName, szCurrentFolder);
	if( szName[strlen(szName)-1] != 0x5c ) 
	{
		strcat(szName, g_szBackslash);
	}
    strcat(szName, "*");

	while( !nErrorEnd )
	{
		if( hFFile == INVALID_HANDLE_VALUE ) 
		{    
			hFFile = FindFirstFileA(szName, &fd);
			if( hFFile == INVALID_HANDLE_VALUE ) 
			{
				nErrorEnd = 1;
			}
		} 
		else 
		{
			if( !FindNextFileA(hFFile, &fd) ) 
			{
				nErrorEnd = 1;
			}
		}
		
		if ( !nErrorEnd && hFFile != INVALID_HANDLE_VALUE )
		{
			if( !strcmp(fd.cFileName, ".") || !strcmp(fd.cFileName, "..") ) 
			{
				continue;
			}
			else 
			{
				strcpy(szName, szCurrentFolder);
				if( szName[strlen(szName)-1] != 0x5c ) 
				{
					strcat(szName, g_szBackslash);
				}

				strcat(szName, fd.cFileName);
		   		dwAttrib = GetFileAttributesA(szName);
	            if( dwAttrib & FILE_ATTRIBUTE_DIRECTORY )
				{
					*pdwAttr |= WMDM_STORAGE_ATTR_HAS_FOLDERS;
// definition is in MDSPdefs.h #define ALSO_CHECK_FILES
#ifndef ALSO_CHECK_FILES
					break;
#endif
				} 
#ifdef ALSO_CHECK_FILES
				else 
				{
					*pdwAttr |= WMDM_STORAGE_ATTR_HAS_FILES;
				}
				if( (*pdwAttr & WMDM_STORAGE_ATTR_HAS_FOLDERS) &&
					(*pdwAttr & WMDM_STORAGE_ATTR_HAS_FILES ) 
				)
				{
					break; // No need to continue since we found both
				}
#endif
			}
		} // End of If
	} // End of while 
		
    hr=S_OK;

Error:
	if( hFFile != INVALID_HANDLE_VALUE )
	{
		FindClose(hFFile);
	}

	if( szName )
	{
		delete [] szName;
	}
	return hr; // If FAILED(hr), sorry, can't do it.
}


HRESULT QuerySubFoldersAndFiles(LPCWSTR wcsCurrentFolder, DWORD *pdwAttr)
{
	if( g_bIsWinNT )
	{
       return QuerySubFoldersAndFilesW(wcsCurrentFolder, pdwAttr);
	} 
	else 
	{
		HRESULT hr;
		char *szTmp=NULL;
		UINT uLen = 2*(wcslen(wcsCurrentFolder)+1);

		szTmp = new char [uLen];
        if(!szTmp) 
		{
			return HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);  
		}

		WideCharToMultiByte(CP_ACP, NULL, wcsCurrentFolder, -1, szTmp, uLen, NULL, NULL); 
		hr = QuerySubFoldersAndFilesA(szTmp, pdwAttr);
		if( szTmp ) 
		{
			delete [] szTmp;
		}
		return hr;
	}
}

HRESULT DeleteFileRecursiveW(WCHAR *wcsPath)
{
	HRESULT hr=S_OK;
 
	CARg(wcsPath);

    if( FILE_ATTRIBUTE_DIRECTORY & GetFileAttributesW(wcsPath) )
	{	
	    HANDLE hFindFile=INVALID_HANDLE_VALUE;
	    WIN32_FIND_DATAW wfd;
		WCHAR wcsLP[MAX_PATH];
 
		wcscpy(wcsLP, wcsPath);
		if( wcsLP[wcslen(wcsLP)-1] != 0x5c )
		{
			wcscat(wcsLP, g_wcsBackslash);
		}
		wcscat(wcsLP, L"*");
		hFindFile = FindFirstFileW(wcsLP, &wfd);
        if ( hFindFile != INVALID_HANDLE_VALUE )
		{
			do {
				if( wcscmp(wfd.cFileName, L".") && wcscmp(wfd.cFileName, L"..") )
				{
					wcscpy(wcsLP, wcsPath);
					if( wcsLP[wcslen(wcsLP)-1] != 0x5c )
					{
						wcscat(wcsLP, g_wcsBackslash);
					}
					wcscat(wcsLP, wfd.cFileName);
					CHRg(DeleteFileRecursiveW(wcsLP)); 
				}
			} while ( FindNextFileW(hFindFile, &wfd) ) ;
	
			FindClose(hFindFile);
			hr = GetLastError();
		} else {
			hr = GetLastError();
		}
		    
		// Until here this dir should be empty
		if( hr == ERROR_NO_MORE_FILES )
		{
			CWRg(RemoveDirectoryW(wcsPath));
			hr=S_OK;
		} 
		else 
		{
			hr = HRESULT_FROM_WIN32(hr);
		}
	} 
	else 
	{
		CWRg( DeleteFileW(wcsPath) );
    }

Error:
	return hr;
}

HRESULT DeleteFileRecursiveA(char *szPath)
{
	HRESULT hr=S_OK;
 
	CARg(szPath);

    if( FILE_ATTRIBUTE_DIRECTORY & GetFileAttributesA(szPath) )
	{	
	    HANDLE hFindFile=INVALID_HANDLE_VALUE;
	    WIN32_FIND_DATAA fd;
		char szLP[MAX_PATH];
 
		strcpy(szLP, szPath);
		if( szLP[strlen(szLP)-1] != 0x5c ) 
		{
			strcat(szLP, g_szBackslash);
		}
		strcat(szLP, "*");
		hFindFile = FindFirstFileA(szLP, &fd);
        if ( hFindFile != INVALID_HANDLE_VALUE )
		{
			do {
				if( strcmp(fd.cFileName, ".") && strcmp(fd.cFileName, "..") )
				{
					strcpy(szLP, szPath);
					if( szLP[strlen(szLP)-1] != 0x5c )
					{
						strcat(szLP, g_szBackslash);
					}
					strcat(szLP, fd.cFileName);
					CHRg(DeleteFileRecursiveA(szLP)); 
				}
			} while ( FindNextFileA(hFindFile, &fd) ) ;
	
			FindClose(hFindFile);
			hr = GetLastError();
		} 
		else 
		{
			hr = GetLastError();
		}
		    
		// Until here this dir should be empty
		if( hr == ERROR_NO_MORE_FILES )
		{
			CWRg(RemoveDirectory(szPath));
			hr=S_OK;
		} 
		else 
		{
			hr = HRESULT_FROM_WIN32(hr);
		}
	} 
	else 
	{
		CWRg( DeleteFileA(szPath) );
    }

Error:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\mdspstorage.h ===
//
//  Microsoft Windows Media Technologies
//   1999 Microsoft Corporation.  All rights reserved.
//
//  Refer to your End User License Agreement for details on your rights/restrictions to use these sample files.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDSPStorage.h : Declaration of the CMDSPStorage

#ifndef __MDSPSTORAGE_H_
#define __MDSPSTORAGE_H_

#define LYRA_BUFFER_BLOCK_SIZE 10240

/////////////////////////////////////////////////////////////////////////////
// CMDSPStorage
class ATL_NO_VTABLE CMDSPStorage : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMDSPStorage, &CLSID_MDSPStorage>,
	public IMDSPStorage, IMDSPObjectInfo, IMDSPObject
{
public:
	CMDSPStorage();
    ~CMDSPStorage();

DECLARE_REGISTRY_RESOURCEID(IDR_MDSPSTORAGE)

BEGIN_COM_MAP(CMDSPStorage)
	COM_INTERFACE_ENTRY(IMDSPStorage)
	COM_INTERFACE_ENTRY(IMDSPObjectInfo)
	COM_INTERFACE_ENTRY(IMDSPObject)
END_COM_MAP()

// IMDSPStorage
public:
	WCHAR   m_wcsName[MAX_PATH];
	char    m_szTmp[MAX_PATH];
	HANDLE	m_hFile;

    //
    // Lyra encryption goo
    //

    BOOL          m_fEncryptToMPX;
    BOOL          m_fCreatedHeader;
    unsigned int  m_LyraHeader[26];
    unsigned int  m_rgEncryptionData[LYRA_BUFFER_BLOCK_SIZE];
    char          m_LyraKeystore[33];
    unsigned int  m_cUsedData;

	STDMETHOD(SetAttributes)(/*[out]*/ DWORD dwAttributes,/*[in]*/ _WAVEFORMATEX *pFormat);
	STDMETHOD(EnumStorage)(/*[out]*/ IMDSPEnumStorage **ppEnumStorage);
	STDMETHOD(CreateStorage)(/*[in]*/ DWORD dwAttributes, /*[in]*/ _WAVEFORMATEX *pFormat, /*[in]*/ LPWSTR pwszName, /*[out]*/ IMDSPStorage **ppNewStorage);
    STDMETHOD(GetRights)(PWMDMRIGHTS *ppRights, UINT *pnRightsCount, /*[in, out]*/BYTE abMac[WMDM_MAC_LENGTH]);
	STDMETHOD(GetSize)(/*[out]*/ DWORD *pdwSizeLow, /*[out]*/ DWORD *pdwSizeHigh);
	STDMETHOD(GetDate)(PWMDMDATETIME pDateTimeUTC);
	STDMETHOD(GetName)(/*[out,string,size_is(nMaxChars)]*/ LPWSTR pwszName, /*[in]*/ UINT nMaxChars);
	STDMETHOD(GetAttributes)(/*[out]*/ DWORD *pdwAttributes, /*[out]*/ _WAVEFORMATEX *pFormat);
	STDMETHOD(GetStorageGlobals)(/*[out]*/ IMDSPStorageGlobals **ppStorageGlobals);
    STDMETHOD(SendOpaqueCommand)(OPAQUECOMMAND *pCommand);
// IMDSPObjectInfo
	STDMETHOD(GetPlayLength)(/*[out]*/ DWORD *pdwLength);
	STDMETHOD(SetPlayLength)(/*[in]*/ DWORD dwLength);
	STDMETHOD(GetPlayOffset)(/*[out]*/ DWORD *pdwOffset);
	STDMETHOD(SetPlayOffset)(/*[in]*/ DWORD dwOffset);
	STDMETHOD(GetTotalLength)(/*[out]*/ DWORD *pdwLength);
	STDMETHOD(GetLastPlayPosition)(/*[out]*/ DWORD *pdwLastPos);
	STDMETHOD(GetLongestPlayPosition)(/*[out]*/ DWORD *pdwLongestPos);
// IMDSPObject
	STDMETHOD(Open)(/*[in]*/ UINT fuMode);
	STDMETHOD(Read)(/*[out,size_is(*pdwSize)]*/ BYTE *pData, /*[in,out]*/ DWORD *pdwSize, /*[in, out]*/BYTE abMac[WMDM_MAC_LENGTH]);
	STDMETHOD(Write)(/*[in, size_is(dwSize)]*/ BYTE *pData, /*[in]*/ DWORD *pdwSize, /*[in, out]*/BYTE abMac[WMDM_MAC_LENGTH]);
	STDMETHOD(Delete)(/* [in] */ UINT fuMode, /*[in]*/ IWMDMProgress *pProgress);
	STDMETHOD(Seek)(/*[in]*/ UINT fuFlags, /*[in]*/ DWORD dwOffset);
	STDMETHOD(Rename)(/*[in]*/ LPWSTR pwszNewName, /*[in]*/ IWMDMProgress *pProgress);
    STDMETHOD(Move)(/*[in]*/ UINT fuMode, /*[in]*/ IWMDMProgress *pProgress, /*[in]*/ IMDSPStorage *pTarget);
	STDMETHOD(Close)();
};

#endif //__MDSPSTORAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\verinfo.h ===
#ifndef _MAC
/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#include "wmdm_ver.h"

#undef  VER_WMDM_PRODUCTNAME_STR
#define VER_WMDM_PRODUCTNAME_STR             "RCA Lyra WMDM Service Provider\0"
#define VER_WMDM_FILE_FILETYPE                VFT_DLL
#define VER_WMDM_FILE_FILEDESCRIPTION_STR     "RCA Lyra WMDM Service Provider\0"
#define VER_WMDM_FILE_INTERNALNAME_STR        "LyraSP.DLL\0"
#define VER_WMDM_FILE_OLEREGISTER

#include "wmdm_ver.ver"

#endif    // !_MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\lyrasp\inc\wmplenc.h ===
#define DllImport extern "C" __declspec (dllimport)

DllImport int __cdecl EncodeToLyra(int mode ,unsigned int *header,int byteblock,unsigned int* mpstream,char* keystore,char*CFDriveLetter);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\hdsprc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Mdsp.rc
//
#define IDS_PROJNAME                    100
#define IDR_MDSERVICEPROVIDER           101
#define IDR_MDSPENUMDEVICE              102
#define IDS_STRING_SPPROGID             103
#define IDS_TITLEPropPage               104
#define IDR_MDSPDEVICE                  105
#define IDS_HELPFILEPropPage            106
#define IDR_MDSPENUMFORMATSUPPORT       107
#define IDS_DOCSTRINGPropPage           108
#define IDR_PROPPAGE                    109
#define IDR_MDSPENUMSTORAGE             110
#define IDD_PROPPAGE                    111
#define IDR_MDSPSTORAGE                 112
#define IDR_MDSPSTORAGEGLOBALS          113
#define IDI_ICON_PM                     201
#define IDC_SERIALID                    1000
#define IDC_MANUFACTURER                1001
#define IDC_DEVICE_TYPE                 1002
#define IDC_POWER_CAP                   1003
#define IDC_POWER_IS                    1004
#define IDC_DEVICE_STATUS               1005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         202
#define _APS_NEXT_SYMED_VALUE           114
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\hdsppch.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__896E741D_3851_11D3_AA54_00C04FD22F6C__INCLUDED_)
#define AFX_STDAFX_H__896E741D_3851_11D3_AA54_00C04FD22F6C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include "hdspRC.h"       // main symbols
#include "MsHDSP.h"
#include "MdspDefs.h"
#include "loghelp.h"
#include "scserver.h"

#include "MDServiceProvider.h"
#include "MDSPDevice.h"
#include "MDSPStorage.h"
#include "MDSPStorageGlobals.h"
#include "MDSPEnumDevice.h"
#include "MDSPEnumStorage.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__896E741D_3851_11D3_AA54_00C04FD22F6C__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\loghelp.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


#include "wmdmlog.h"

HRESULT hrLogString(LPSTR pszMessage, HRESULT hrSev);
HRESULT hrLogDWORD(LPSTR pszFormat, DWORD dwValue, HRESULT hrSev);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\loghelp.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


#include "hdspPCH.h"
#include "wmdmlog_i.c"

BOOL fIsLoggingEnabled( VOID )
{
     static BOOL  fEnabled = FALSE;
    HRESULT      hr;
    IWMDMLogger *pLogger  = NULL;
    static BOOL  fChecked = FALSE;

    if( !fChecked )
    {
        fChecked = TRUE;

        hr = CoCreateInstance(
			CLSID_WMDMLogger,
			NULL,
			CLSCTX_INPROC_SERVER,
			IID_IWMDMLogger,
			(void**)&pLogger
		);
	    CORg( hr );

        hr = pLogger->IsEnabled( &fEnabled );
	    CORg( hr );
    }

Error:
    if( NULL != pLogger )
    {
        pLogger->Release();
        pLogger = NULL;
    }

    return fEnabled;
}

HRESULT hrLogString(LPSTR pszMessage, HRESULT hrSev)
{
    HRESULT      hr=S_OK;
    IWMDMLogger *pLogger = NULL;

    if( !fIsLoggingEnabled() )
    {
        return S_FALSE;
    }

    hr = CoCreateInstance(
		CLSID_WMDMLogger,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_IWMDMLogger,
		(void**)&pLogger
	);
    CORg( hr );

    hr = pLogger->LogString(
		( FAILED(hrSev) ? WMDM_LOG_SEV_ERROR : WMDM_LOG_SEV_INFO ),
		"MSHDSP",
		pszMessage
	);
    CORg( hr );

Error:

    if( pLogger )
	{
        pLogger->Release();
	}
  
	return hr;
}

HRESULT hrLogDWORD(LPSTR pszFormat, DWORD dwValue, HRESULT hrSev)
{
    HRESULT      hr=S_OK;
    IWMDMLogger *pLogger = NULL;

    if( !fIsLoggingEnabled() )
    {
        return S_FALSE;
    }

    hr = CoCreateInstance(
		CLSID_WMDMLogger,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_IWMDMLogger,
		(void**)&pLogger
	);
    CORg( hr );

    hr = pLogger->LogDword(
		( FAILED(hrSev) ? WMDM_LOG_SEV_ERROR : WMDM_LOG_SEV_INFO ),
		"MSHDSP",
		pszFormat,
		dwValue
	);
    CORg( hr );

Error:

    if( pLogger )
	{
        pLogger->Release();
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\hdsppch.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


//  stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "hdspPCH.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\mdserviceprovider.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 

// MDServiceProvider.cpp : Implementation of CMDServiceProvider

#include "hdspPCH.h"
#include "key.c"

/////////////////////////////////////////////////////////////////////////////
// CMDServiceProvider
CMDServiceProvider::~CMDServiceProvider()
{
	if( m_hThread )
	{
		CloseHandle( m_hThread );
	}

	if( g_pAppSCServer )
	{
		delete g_pAppSCServer;
		g_pAppSCServer = NULL;
	}
}

CMDServiceProvider::CMDServiceProvider()
{
	g_pAppSCServer = new CSecureChannelServer();

	if( g_pAppSCServer )
	{
		g_pAppSCServer->SetCertificate(
			SAC_CERT_V1,
			(BYTE*)abCert, sizeof(abCert),
			(BYTE*)abPVK, sizeof(abPVK)
		);
	}	

    m_hThread = NULL;

	g_CriticalSection.Lock();
	ZeroMemory(
		g_GlobalDeviceInfo,
		sizeof(MDSPGLOBALDEVICEINFO)*MDSP_MAX_DEVICE_OBJ
	);
    g_CriticalSection.Unlock();

	return;
}

STDMETHODIMP CMDServiceProvider::GetDeviceCount(DWORD * pdwCount)
{
	HRESULT hr        = E_FAIL;
	CHAR    szDrive[] = "?:";
	INT     i;
	INT     cnt;

	CFRg( g_pAppSCServer );
    if( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg( WMDM_E_NOTCERTIFIED );
	}
    
	CARg( pdwCount );

	for( i=0, cnt=0; i<MDSP_MAX_DRIVE_COUNT; i++ )
	{
		szDrive[0] = 'A' + i;
		if( UtilGetDriveType(szDrive) == DRIVE_FIXED )
		{
			cnt++;
		}
	}

	*pdwCount = cnt;

	hr = S_OK;

Error:

    hrLogDWORD("IMDServiceProvider::GetDeviceCount returned 0x%08lx", hr, hr);

	return hr;
}


STDMETHODIMP CMDServiceProvider::EnumDevices(IMDSPEnumDevice **ppEnumDevice)
{
	HRESULT hr = E_FAIL;
	CComObject<CMDSPEnumDevice> *pEnumObj;

	CFRg( g_pAppSCServer );
    if( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg( WMDM_E_NOTCERTIFIED );
	}
	
	hr = CComObject<CMDSPEnumDevice>::CreateInstance( &pEnumObj );
	if( SUCCEEDED(hr) )
	{
		hr = pEnumObj->QueryInterface(
			IID_IMDSPEnumDevice,
			reinterpret_cast<void**>(ppEnumDevice)
		);
		if( FAILED(hr) )
		{
			delete pEnumObj;
			goto Error;
		}
	}

	hr = S_OK;

Error:

    hrLogDWORD("IMDServiceProvider::EnumDevices returned 0x%08lx", hr, hr);

	return hr;
}


STDMETHODIMP CMDServiceProvider::SACAuth(
	DWORD   dwProtocolID,
	DWORD   dwPass,
	BYTE   *pbDataIn,
	DWORD   dwDataInLen,
	BYTE  **ppbDataOut,
	DWORD  *pdwDataOutLen)
{
    HRESULT hr = E_FAIL;

	CFRg( g_pAppSCServer );

    hr = g_pAppSCServer->SACAuth(
		dwProtocolID,
		dwPass,
		pbDataIn, dwDataInLen,
		ppbDataOut, pdwDataOutLen
	);
	CORg( hr );
    
	hr = S_OK;

Error:
    
	hrLogDWORD("IComponentAuthenticate::SACAuth returned 0x%08lx", hr, hr);

    return hr;
}

STDMETHODIMP CMDServiceProvider::SACGetProtocols(
	DWORD **ppdwProtocols,
	DWORD  *pdwProtocolCount)
{
    HRESULT hr = E_FAIL;

	CFRg( g_pAppSCServer );

	hr = g_pAppSCServer->SACGetProtocols(
		ppdwProtocols,
		pdwProtocolCount
	);
	CORg( hr );
    
	hr = S_OK;

Error:
    
    hrLogDWORD("IComponentAuthenticate::SACGetProtocols returned 0x%08lx", hr, hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\key.c ===
#include <wtypes.h>

const BYTE abPVK[] = {
	0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 
	0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 
	0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 
	0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 
	0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 
	0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 
	0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 
	0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 
	0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 
	0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 
	0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 
	0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 
	0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 
	0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 
	0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 
	0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 
	0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 
	0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 
	0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 
	0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 
	0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 
	0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 
	0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 
	0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 
	0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 
	0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 
	0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 
	0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 
	0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 
	0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 
	0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 
	0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 
	0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 
	0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 
	0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 
	0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 
	0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 
	0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 
	0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 
	0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 
	0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 
	0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 
	0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 
	0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 
	0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 
	0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 
	0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 
	0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 
	0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 
	0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 
	0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 
	0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 
	0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 
	0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 
	0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 
	0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 
	0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 
	0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 
	0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 
	0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 
	0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 
	0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 
	0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 
	0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 
	0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 
	0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 
	0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 
	0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 
	0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 
	0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 
	0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 
	0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 
	0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 
	0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 
	0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 
	0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 
	0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 
	0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 
	0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 
	0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 
	0x9E, 0xC4, 0xC5, 0xD5, 0x7D, 0xC3, 0xC1, 0x22, 
	0x1A, 0x0A, 0xE5, 0x57, 0xCF, 0x05, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x1A, 0x5D, 0xBF, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 
	0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 
	0x07, 0xCD, 0xA6, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x65, 0x0A, 0xB1, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0x74, 
	0xDC, 0xF3, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x70, 0x96, 0xAC, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0x2C, 0xE7, 0xA8, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0x51, 0xEA, 0xFC, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0x6D, 0xA1, 0x23, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0x58, 0xE8, 0x94, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x72, 0x22, 0x7F, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x51, 0x49, 0xA2, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x14, 0x48, 0x07, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x26, 0x2D, 0x37, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x56, 0x3E, 0xB5, 0x07, 0x9C, 0x17, 
	0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 
	0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 
	0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x4E, 0x26, 0x3F, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0x64, 0xFA, 0x65, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x71, 0x75, 
	0xAC, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x42, 
	0x61, 0x1C, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0x95, 
	0x32, 0x86, 0x72, 0x41, 0x37, 0xC8, 0xCB, 0x9D, 
	0x31, 0xBE, 0x6C, 0xF7, 0xB1, 0xCA, 0x62, 0x6B, 
	0x39, 0x3D, 0xF1, 0xA4, 0x06, 0x1F, 0x2E, 0xC2, 
	0xCF, 0x96, 0xD5, 0x7F, 0xEC, 0x5F, 0x4A, 0x8D, 
	0xDB, 0x0F, 0x60, 0x8B, 0x1A, 0x36, 0xB8, 0x74, 
	0x54, 0xF1, 0x47, 0x96, 0x04, 0xB5, 0xCB, 0xC7, 
	0x08, 0x5F, 0x55, 0xB5, 0x84, 0x75, 0xA3, 0x70, 
	0x4E, 0xC2, 0xA7, 0x8A, 0x9D, 0x7F, 0x6F, 0x0F, 
	0x9C, 0xE7, 0x09, 0x9F, 0xE1, 0xAA, 0x61, 0x94, 
	0xAB, 0xA6, 0xE8, 0xA5, 0xD0, 0x23, 0x7A, 0x46, 
	0xCF, 0xFD, 0x6E, 0x40, 0xD0, 0x2D, 0xA3, 0xEC, 
	0x9F, 0x71, 0xE5, 0x2D, 0x79, 0x7E, 0xC9, 0xB3, 
	0xE8, 0xAB, 0x97, 0xF9, 0x26, 0x87, 0x39, 0xAF, 
	0x19, 0x12, 0xA8, 0x44, 0x48, 0x84, 0xB1, 0x68, 
	0x8F, 0xB1, 0x05, 0x26, 0x8D, 0x00, 0xB7, 0x61, 
	0x31, 0x74, 0x1E, 0xF3, 0x24, 0xFE, 0x00, 0x14
};
const BYTE abCert[] = {
	0x00, 0x01, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
	0x7C, 0xF1, 0xF9, 0x82, 0xE5, 0xD6, 0xE9, 0x75, 
	0xAA, 0xBC, 0x33, 0x87, 0x3A, 0xBB, 0xE5, 0x18, 
	0xFB, 0x7C, 0x47, 0x68, 0x24, 0x6B, 0xE3, 0x3B, 
	0x7D, 0xC6, 0x7D, 0x94, 0xA4, 0xB1, 0x88, 0x8D, 
	0x85, 0x77, 0x2B, 0x78, 0xAE, 0x81, 0x53, 0x29, 
	0x69, 0xFD, 0x67, 0xD3, 0x95, 0x72, 0xE2, 0x58, 
	0xCB, 0xD3, 0x23, 0xFE, 0xC2, 0xC9, 0x6E, 0xCD, 
	0x7A, 0x8A, 0xFC, 0x22, 0x62, 0x0B, 0xB8, 0xD4, 
	0x68, 0x23, 0x7A, 0x3C, 0xFB, 0x43, 0xA8, 0x01, 
	0xA4, 0x10, 0x61, 0x75, 0x19, 0xDC, 0x38, 0x25, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE8, 
	0x00, 0x00, 0x00, 0x02
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\mdserviceprovider.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDServiceProvider.h : Declaration of the CMDServiceProvider

#ifndef __MDSERVICEPROVIDER_H_
#define __MDSERVICEPROVIDER_H_

/////////////////////////////////////////////////////////////////////////////
// CMDServiceProvider
class ATL_NO_VTABLE CMDServiceProvider : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMDServiceProvider, &CLSID_MDServiceProvider>,
	public IMDServiceProvider,
	public IComponentAuthenticate
{
public:
	CMDServiceProvider();
	~CMDServiceProvider();

DECLARE_CLASSFACTORY_SINGLETON(CMDServiceProvider)
DECLARE_REGISTRY_RESOURCEID(IDR_MDSERVICEPROVIDER)

BEGIN_COM_MAP(CMDServiceProvider)
	COM_INTERFACE_ENTRY(IMDServiceProvider)
	COM_INTERFACE_ENTRY(IComponentAuthenticate)
END_COM_MAP()

// IMDServiceProvider
public:
	DWORD m_dwThreadID;
	HANDLE m_hThread;
	STDMETHOD(EnumDevices)(/*[out]*/ IMDSPEnumDevice **ppEnumDevice);
	STDMETHOD(GetDeviceCount)(/*[out]*/ DWORD *pdwCount);
    STDMETHOD(SACAuth)(DWORD dwProtocolID,
                       DWORD dwPass,
                       BYTE *pbDataIn,
                       DWORD dwDataInLen,
                       BYTE **ppbDataOut,
                       DWORD *pdwDataOutLen);
    STDMETHOD(SACGetProtocols)(DWORD **ppdwProtocols,
                               DWORD *pdwProtocolCount);
};

#endif //__MDSERVICEPROVIDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\mdsp.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 

// Mdsp.cpp : Implementation of MSHDSP.DLL's DLL Exports.

#include "hdspPCH.h"
#include "initguid.h"
#include "MsHDSP_i.c"
#include "PropPage.h"

CComModule            _Module;
HINSTANCE             g_hinstance; 
MDSPGLOBALDEVICEINFO  g_GlobalDeviceInfo[MDSP_MAX_DEVICE_OBJ];
WCHAR                 g_wcsBackslash[2] = { (WCHAR)0x5c, NULL };
CHAR                  g_szBackslash[2]  = { (CHAR)0x5c, NULL };
CSecureChannelServer *g_pAppSCServer=NULL;
CComMultiThreadModel::AutoCriticalSection g_CriticalSection;
 
BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_MDServiceProvider, CMDServiceProvider)
    OBJECT_ENTRY(CLSID_HDSPPropPage, CPropPage)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	lpReserved;
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();

	g_hinstance = hInstance; 
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HKEY hKey;
	LONG lRet;

	lRet = RegCreateKeyEx(
		HKEY_LOCAL_MACHINE,
		STR_MDSPREG,
		0,
		NULL, 
		REG_OPTION_NON_VOLATILE,
		KEY_READ | KEY_WRITE,
		NULL,
		&hKey,
		NULL
	);
	if( ERROR_SUCCESS == lRet )
	{
	    CHAR szTemp[MAX_PATH];

		// Register the ProgID with WMDM
		//
		strcpy( szTemp, STR_MDSPPROGID );

		RegSetValueEx(
			hKey,
			"ProgID",
			0,
			REG_SZ,
			(LPBYTE)szTemp,
			lstrlen( szTemp ) + 1
		);

		RegCloseKey( hKey );

		// Register object, typelib and all interfaces in typelib
		//
		return _Module.RegisterServer(TRUE);
	}
	else
	{
		return REGDB_E_WRITEREGDB;
	}

}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();

    RegDeleteKey(HKEY_LOCAL_MACHINE, STR_MDSPREG);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\mdspdevice.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 

// MDSPDevice.cpp : Implementation of CMDSPDevice

#include "hdspPCH.h"
#include "mshdsp.h"
#include "wmsstd.h"
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

/////////////////////////////////////////////////////////////////////////////
// CMDSPDevice
HRESULT CMDSPDevice::InitGlobalDeviceInfo()
{
	return SetGlobalDeviceStatus(m_wcsName, 0, FALSE);
}

CMDSPDevice::CMDSPDevice()
{
    m_wcsName[0] = 0;
}

CMDSPDevice::~CMDSPDevice()
{	
}

STDMETHODIMP CMDSPDevice::GetName(LPWSTR pwszName, UINT nMaxChars)
{
	HRESULT hr = E_FAIL;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pwszName);
    CPRg(nMaxChars>wcslen(m_wcsName));

	if( m_wcsName[0] )
	{
		wcscpy(pwszName, m_wcsName);
		hr = S_OK;
	}
	else 
	{
		hr = WMDM_E_NOTSUPPORTED;
	}

Error:

    hrLogDWORD("IMDSPDevice::GetName returned 0x%08lx", hr, hr);
	
    return hr;
}

STDMETHODIMP CMDSPDevice::GetManufacturer(LPWSTR pwszName, UINT nMaxChars)
{
	HRESULT hr = S_OK;
	
	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pwszName);

	if(FAILED(UtilGetManufacturer(m_wcsName, &pwszName, nMaxChars)))
	{
            if (hr != STRSAFE_E_INSUFFICIENT_BUFFER)
            {
		hr = E_NOTIMPL;
            }
	}

Error:   

    hrLogDWORD("IMDSPDevice::GetManufacturer returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetVersion(DWORD * pdwVersion)
{
    HRESULT hr;
    
	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:

	hrLogDWORD("IMDSPDevice::GetVersion returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetType(DWORD * pdwType)
{
	HRESULT hr = S_OK;
    WMDMID  snTmp;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pdwType);

	*pdwType = WMDM_DEVICE_TYPE_STORAGE | WMDM_DEVICE_TYPE_NONSDMI;

	snTmp.cbSize = sizeof(WMDMID);

	hr = UtilGetSerialNumber(m_wcsName, &snTmp, FALSE);
	if( hr == S_OK )
	{
		*pdwType |= WMDM_DEVICE_TYPE_SDMI;
    }

	hr=S_OK;

Error:

    hrLogDWORD("IMDSPDevice::GetType returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetSerialNumber(
	PWMDMID pSerialNumber, 
	BYTE abMac[WMDM_MAC_LENGTH])
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pSerialNumber);

	hr = UtilGetSerialNumber(m_wcsName, pSerialNumber, TRUE);
	if( hr == HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) )
	{
		hr = WMDM_E_NOTSUPPORTED;
	}

	if( hr == S_OK )
	{
		// MAC the parameters
		HMAC hMAC;
		
		CORg(g_pAppSCServer->MACInit(&hMAC));
		CORg(g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pSerialNumber), sizeof(WMDMID)));
		CORg(g_pAppSCServer->MACFinal(hMAC, abMac));
	}

Error:

    hrLogDWORD("IMDSPDevice::GetSerialNumber returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetPowerSource(DWORD * pdwPowerSource, DWORD * pdwPercentRemaining)
{
	HRESULT hr=S_OK;

	CFRg(g_pAppSCServer);
    if( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pdwPowerSource);
	CARg(pdwPercentRemaining);

	*pdwPowerSource =   WMDM_POWER_CAP_EXTERNAL | 
						WMDM_POWER_IS_EXTERNAL |
						WMDM_POWER_PERCENT_AVAILABLE;
	*pdwPercentRemaining = 100;

Error:

    hrLogDWORD("IMDSPDevice::GetPowerSource returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetStatus(DWORD * pdwStatus)
{
	HRESULT hr = S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pdwStatus);

	CHRg(GetGlobalDeviceStatus(m_wcsName, pdwStatus));

	if( !( *pdwStatus & WMDM_STATUS_BUSY) )
	{
		*pdwStatus = WMDM_STATUS_READY;
	}

	hr = S_OK;

Error:

    hrLogDWORD("IMDSPDevice::GetStatus returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetDeviceIcon(ULONG *hIcon)
{
	HRESULT hr = S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CFRg(g_hinstance);
    CARg(hIcon);
	CWRg( (*hIcon)=HandleToULong(LoadIconA(g_hinstance, MAKEINTRESOURCEA(IDI_ICON_PM)) ));

Error:

    hrLogDWORD("IMDSPDevice::GetDeviceIcon returned 0x%08lx", hr, hr);

	return hr;
}

// Opaque Command to get extended certification information
//
// GUID = {C39BF696-B776-459c-A13A-4B7116AB9F09}
//
static const GUID guidCertInfoEx = 
{ 0xc39bf696, 0xb776, 0x459c, { 0xa1, 0x3a, 0x4b, 0x71, 0x16, 0xab, 0x9f, 0x9 } };

typedef struct
{
	HRESULT hr;
	DWORD   cbCert;
	BYTE    pbCert[1];

} CERTINFOEX;

static const BYTE bCertInfoEx_App[] =
{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09 };

static const BYTE bCertInfoEx_SP[] =
{ 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,
  0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00 };

STDMETHODIMP CMDSPDevice::SendOpaqueCommand(OPAQUECOMMAND *pCommand)
{
    HRESULT hr;
    HMAC    hMAC;
    BYTE    abMACVerify[WMDM_MAC_LENGTH];

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	// Compute and verify MAC
	//
	CORg( g_pAppSCServer->MACInit(&hMAC) );
	CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(&(pCommand->guidCommand)), sizeof(GUID)) );
	CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(&(pCommand->dwDataLen)), sizeof(pCommand->dwDataLen)) );
	if( pCommand->pData )
	{
		CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pCommand->pData), pCommand->dwDataLen) );
	}
	CORg( g_pAppSCServer->MACFinal(hMAC, abMACVerify) );

	if (memcmp(abMACVerify, pCommand->abMAC, WMDM_MAC_LENGTH) != 0)
	{
		CORg(WMDM_E_MAC_CHECK_FAILED);
	}

	// Take action based on the command GUID
	//
	if( memcmp(&(pCommand->guidCommand), &guidCertInfoEx, sizeof(GUID)) == 0 )
	{
		//
		// Command to exchange extended authentication information
		//

		CERTINFOEX *pCertInfoEx;

		DWORD cbData_App    = sizeof( bCertInfoEx_App )/sizeof( BYTE );
		DWORD cbData_SP     = sizeof( bCertInfoEx_SP )/sizeof( BYTE );
		DWORD cbData_Return = sizeof(CERTINFOEX) + cbData_SP;

		// The caller must include their extended cert info
		//
		if( !pCommand->pData )
		{
			CORg( E_INVALIDARG );
		}

		// Map the data in the opaque command to a CERTINFOEX structure
		//
		pCertInfoEx = (CERTINFOEX *)pCommand->pData;

		// In this simple extended authentication scheme, the caller must
		// provide the exact cert info
		//
		if( (pCertInfoEx->cbCert != cbData_App) ||
			(memcmp(pCertInfoEx->pbCert, bCertInfoEx_App, cbData_App) != 0) )
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}

		// Free the caller data and allocate enough data for our return data
		//
		CoTaskMemFree( pCommand->pData );

		CFRg( (pCommand->pData = (BYTE *)CoTaskMemAlloc(cbData_Return)) );
		pCommand->dwDataLen = cbData_Return;

		// Copy the extended cert info into return data structure
		//
		pCertInfoEx = (CERTINFOEX *)pCommand->pData;

		pCertInfoEx->hr     = S_OK;
		pCertInfoEx->cbCert = cbData_SP;
		memcpy( pCertInfoEx->pbCert, bCertInfoEx_SP, cbData_SP );

		// Compute MAC on return data
		//
		CORg( g_pAppSCServer->MACInit( &hMAC ) );
		CORg( g_pAppSCServer->MACUpdate( hMAC, (BYTE*)(&(pCommand->guidCommand)), sizeof(GUID) ) );
		CORg( g_pAppSCServer->MACUpdate( hMAC, (BYTE*)(&(pCommand->dwDataLen)), sizeof(pCommand->dwDataLen) ) );
		if( pCommand->pData )
		{
			CORg( g_pAppSCServer->MACUpdate( hMAC, (BYTE*)(pCommand->pData), pCommand->dwDataLen ) );
		}
		CORg( g_pAppSCServer->MACFinal( hMAC, pCommand->abMAC ) );

		hr = S_OK;
	}
	else
	{
		CORg(WMDM_E_NOTSUPPORTED);
	}

Error:

    hrLogDWORD("IMDSPDevice::SendOpaqueCommand returned 0x%08lx", hr, hr);

    return hr;
}

// IMDSPDevice2
STDMETHODIMP CMDSPDevice::GetStorage( LPCWSTR pszStorageName, IMDSPStorage** ppStorage )
{
    HRESULT hr;
    HRESULT hrTemp;
    WCHAR   pwszFileName[MAX_PATH+1];
    char    pszTemp[MAX_PATH];
    CComObject<CMDSPStorage> *pStg = NULL;

    // Get name of new file

    DWORD dwLen = wcslen(m_wcsName);

    // We reserve one char for the \ that might be added below
    if (dwLen >= ARRAYSIZE(pwszFileName)-1)
    {
        hr = STRSAFE_E_INSUFFICIENT_BUFFER; //defined in strsafe.h
        goto Error;
    }

    wcscpy( pwszFileName, m_wcsName );
    if( pwszFileName[dwLen-1] != '\\' ) 
        wcscat( pwszFileName, L"\\" );

    hrTemp = StringCchCatW( pwszFileName,
                            ARRAYSIZE(pwszFileName) - 1, 
                                // - 1 ensures the result fits into a MAX_PATH buffer.
                                // This makes the wcscpy into pStg->m_wcsName (below) safe.
                            pszStorageName );

    if (FAILED(hrTemp))
    {
        // The file does not exist
        hr = E_FAIL; // @@@@ Something else? S_FALSE?
        goto Error;
    }

	WideCharToMultiByte(CP_ACP, NULL, pwszFileName, -1, pszTemp, MAX_PATH, NULL, NULL);		
    if( GetFileAttributesA( pszTemp )  == -1 )
    {
        // The file does not exist
        hr = S_FALSE;
        goto Error;
    }

    // Create new storage object
    hr = CComObject<CMDSPStorage>::CreateInstance(&pStg);
	hr = pStg->QueryInterface( IID_IMDSPStorage, reinterpret_cast<void**>(ppStorage));
    wcscpy(pStg->m_wcsName, pwszFileName);

Error:
    if( hr != S_OK )
    {
        *ppStorage = NULL;
    }

    hrLogDWORD("IMDSPDevice::GetStorage returned 0x%08lx", hr, hr);
    return hr;
}
 
STDMETHODIMP CMDSPDevice::GetFormatSupport2(
                            DWORD dwFlags,
                            _WAVEFORMATEX** ppAudioFormatEx,
                            UINT* pnAudioFormatCount,
			                _VIDEOINFOHEADER** ppVideoFormatEx,
                            UINT* pnVideoFormatCount,
                            WMFILECAPABILITIES** ppFileType,
                            UINT* pnFileTypeCount )
{
    return E_NOTIMPL;
}

STDMETHODIMP CMDSPDevice::GetSpecifyPropertyPages( 
                            ISpecifyPropertyPages** ppSpecifyPropPages, 
							IUnknown*** pppUnknowns, 
							ULONG *pcUnks )
{
	HRESULT hr;
    IUnknown** ppUnknownArray = NULL;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    CARg(ppSpecifyPropPages);
    CARg(pppUnknowns);
    CARg(pcUnks);

    // This object also supports the ISpecifyPropertyPages interface
	CORg( QueryInterface( __uuidof(ISpecifyPropertyPages),
                         reinterpret_cast<void**>(ppSpecifyPropPages) ) );

    // Return one IUnknown interface, property page will QI for IDevice
    ppUnknownArray = (IUnknown**)CoTaskMemAlloc( sizeof(IUnknown*[1]) );
	CORg( QueryInterface( __uuidof(IUnknown),
                         reinterpret_cast<void**>(&ppUnknownArray[0]) ) );

    *pppUnknowns = ppUnknownArray; 
    *pcUnks = 1;

Error:
    hrLogDWORD("IMDSPDevice::GetSpecifyPropertyPages returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetPnPName( LPWSTR pwszPnPName, UINT nMaxChars )
{
    return E_NOTIMPL;
}


// ISpecifyPropertyPages
STDMETHODIMP CMDSPDevice::GetPages(CAUUID *pPages)
{
    HRESULT hr = S_OK;

    if( pPages == NULL )
    {
        return E_POINTER;
    }

    // Return the GUID for our property page
    pPages->cElems = 1;
    pPages->pElems = (GUID *)CoTaskMemAlloc( sizeof(GUID) * pPages->cElems );
    if( pPages->pElems == NULL )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        memcpy( &pPages->pElems[0], &__uuidof(HDSPPropPage), sizeof(GUID) );
    }

    return( hr );
}


// IMDSPDeviceControl
STDMETHODIMP CMDSPDevice::GetDCStatus(/*[out]*/ DWORD *pdwStatus)
{
    HRESULT hr = E_FAIL;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = GetStatus(pdwStatus);

Error:

    hrLogDWORD("IMDSPDeviceControl::GetDCStatus returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetCapabilities(/*[out]*/ DWORD *pdwCapabilitiesMask)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    if( !pdwCapabilitiesMask )
	{
		return E_INVALIDARG;
	}
	*pdwCapabilitiesMask = WMDM_DEVICECAP_CANSTREAMPLAY;
	
    hr = S_OK;

Error:

    hrLogDWORD("IMDSPDeviceControl::GetCapabilities returned 0x%08lx", hr, hr);

    return S_OK;
}	

STDMETHODIMP CMDSPDevice::Play()
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:

    hrLogDWORD("IMDSPDeviceControl::Play returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPDevice::Record(/*[in]*/ _WAVEFORMATEX *pFormat)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:

    hrLogDWORD("IMDSPDeviceControl::Record returned 0x%08lx", hr, hr);
	
    return hr;
}

STDMETHODIMP CMDSPDevice::Pause()
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:

    hrLogDWORD("IMDSPDeviceControl::Pause returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::Resume()
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:

    hrLogDWORD("IMDSPDeviceControl::Resume returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPDevice::Stop()
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:

    hrLogDWORD("IMDSPDeviceControl::Stop returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPDevice::Seek(/*[in]*/ UINT fuMode, /*[in]*/ int nOffset)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:

    hrLogDWORD("IMDSPDeviceControl::Seek returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetFormatSupport(
	_WAVEFORMATEX **pFormatEx,
	UINT *pnFormatCount,
	LPWSTR **pppwszMimeType,
	UINT *pnMimeTypeCount)
{
	HRESULT hr = S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pFormatEx);
	CARg(pppwszMimeType);
	CARg(pnFormatCount);
	CARg(pnMimeTypeCount);

	*pnFormatCount = 1;
	*pFormatEx = (_WAVEFORMATEX *)CoTaskMemAlloc(sizeof(_WAVEFORMATEX));
	CPRg( *pFormatEx );
	(*pFormatEx)->wFormatTag      = WMDM_WAVE_FORMAT_ALL;
	(*pFormatEx)->nChannels       = 2;
	(*pFormatEx)->cbSize          = 0;
    (*pFormatEx)->nSamplesPerSec  = 0; 
    (*pFormatEx)->nAvgBytesPerSec = 0; 
    (*pFormatEx)->nBlockAlign     = 0; 
    (*pFormatEx)->wBitsPerSample  = 0; 
    
    *pnMimeTypeCount= 1;
	*pppwszMimeType = (LPWSTR *)CoTaskMemAlloc(sizeof(LPWSTR)*1);
    CPRg(*pppwszMimeType);
	**pppwszMimeType = (LPWSTR)CoTaskMemAlloc(sizeof(WCHAR)*(wcslen(WCS_MIME_TYPE_ALL)+1));
	CPRg(**pppwszMimeType);
	wcscpy(**pppwszMimeType, WCS_MIME_TYPE_ALL);

Error:

    hrLogDWORD("IMDSPDevice::GetFormatSupport returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::EnumStorage(IMDSPEnumStorage** ppEnumStorage)
{
	HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(ppEnumStorage);

	CComObject<CMDSPEnumStorage> *pEnumObj;
	
	CORg(CComObject<CMDSPEnumStorage>::CreateInstance(&pEnumObj));

	hr = pEnumObj->QueryInterface(
		IID_IMDSPEnumStorage,
		reinterpret_cast<void**>(ppEnumStorage)
	);
	if( FAILED(hr) )
	{
		delete pEnumObj;
	}
        else 
	{
            // wcscpy(pEnumObj->m_wcsPath, m_wcsName);
            hr = StringCbCopyW(pEnumObj->m_wcsPath, 
                               ARRAYSIZE(pEnumObj->m_wcsPath),
                               m_wcsName);
            if (FAILED(hr))
            {
                (*ppEnumStorage)->Release();
                *ppEnumStorage = NULL;
                goto Error;
            }
	}

Error:

    hrLogDWORD("IMDSPDevice::EnumStorage returned 0x%08lx", hr, hr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\mdspdefs.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


#ifndef __MDSPDEFS_H__
#define __MDSPDEFS_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "scserver.h"

typedef struct {
	BOOL  bValid;
	WCHAR wcsDevName[32];
	DWORD dwStatus;
	LPVOID pIMDSPStorageGlobals;
} MDSPGLOBALDEVICEINFO;


#define WMDM_WAVE_FORMAT_ALL   (WORD)0xFFFF
#define WCS_MIME_TYPE_ALL      L"*/*"

#define MDSP_MAX_DRIVE_COUNT   26
#define MDSP_MAX_DEVICE_OBJ    64

#define STR_MDSPREG            "Software\\Microsoft\\Windows Media Device Manager\\Plugins\\SP\\MsHDSP"
#define STR_MDSPPROGID         "MDServiceProviderHD.MDServiceProviderHD" 


extern HRESULT __stdcall UtilGetSerialNumber(WCHAR *wcsDeviceName, PWMDMID pSerialNumber, BOOL fCreate);
extern HRESULT wcsParseDeviceName(WCHAR *wcsIn, WCHAR *wcsOut, DWORD dwNumCharsInOutBuffer);
extern HRESULT GetFileSizeRecursive(char *szPath, DWORD *pdwSizeLow, DWORD *pdwSizeHigh);
extern HRESULT DeleteFileRecursive(char *szPath);
extern HRESULT SetGlobalDeviceStatus(WCHAR *wcsName, DWORD dwStat, BOOL bClear);
extern HRESULT GetGlobalDeviceStatus(WCHAR *wcsNameIn, DWORD *pdwStat);
extern HRESULT __stdcall UtilGetManufacturer(LPWSTR pDeviceName, LPWSTR *ppwszName, UINT nMaxChars);
extern UINT __stdcall UtilGetDriveType(LPSTR szDL);

extern HINSTANCE             g_hinstance; 
extern MDSPGLOBALDEVICEINFO  g_GlobalDeviceInfo[MDSP_MAX_DEVICE_OBJ];
extern WCHAR                 g_wcsBackslash[2];
#define BACKSLASH_STRING_LENGTH (ARRAYSIZE(g_wcsBackslash)-1)
extern CHAR                  g_szBackslash[2];
#define BACKSLASH_SZ_STRING_LENGTH (ARRAYSIZE(g_szBackslash)-1)
extern CSecureChannelServer *g_pAppSCServer;
extern CComMultiThreadModel::AutoCriticalSection g_CriticalSection;
 
#define	fFalse		    0
#define fTrue		    1

#define hrOK			HRESULT(S_OK)
#define hrTrue			HRESULT(S_OK)
#define hrFalse			ResultFromScode(S_FALSE)
#define hrFail			ResultFromScode(E_FAIL)
#define hrNotImpl		ResultFromScode(E_NOTIMPL)
#define hrNoInterface	ResultFromScode(E_NOINTERFACE)
#define hrNoMem			WMDM_E_BUFFERTOOSMALL
#define hrAbort			ResultFromScode(E_ABORT)
#define hrInvalidArg	ResultFromScode(E_INVALIDARG)

/*----------------------------------------------------------------------------
	CORg style error handling
	(Historicaly stands for Check OLE Result and Goto)
 ----------------------------------------------------------------------------*/

#define	CPRg(p)\
	do\
		{\
		if (!(p))\
			{\
			hr = hrNoMem;\
			goto Error;\
			}\
		}\
	while (fFalse)

#define	CHRg(hResult) CORg(hResult)

#define	CORg(hResult)\
	do\
		{\
		hr = (hResult);\
        if (FAILED(hr))\
            {\
            goto Error;\
            }\
		}\
	while (fFalse)

#define	CWRg(fResult)\
	{\
	if (!(fResult))\
		{\
        hr = GetLastError();\
	    if (!(hr & 0xFFFF0000)) hr = HRESULT_FROM_WIN32(hr);\
		goto Error;\
		}\
	}

#define	CFRg(fResult)\
	{\
	if (!(fResult))\
		{\
		hr = hrFail;\
		goto Error;\
		}\
	}

#define	CARg(p)\
	do\
		{\
		if (!(p))\
			{\
			hr = hrInvalidArg;\
			goto Error;\
			}\
		}\
	while (fFalse)


#endif // __MDSPDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\mdspdevice.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDSPDevice.h : Declaration of the CMDSPDevice

#ifndef __MDSPDEVICE_H_
#define __MDSPDEVICE_H_

/////////////////////////////////////////////////////////////////////////////
// CMDSPDevice
class ATL_NO_VTABLE CMDSPDevice : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMDSPDevice, &CLSID_MDSPDevice>,
	public IMDSPDevice2, IMDSPDeviceControl,
    public ISpecifyPropertyPages
{
public:
	CMDSPDevice();
	~CMDSPDevice();


DECLARE_REGISTRY_RESOURCEID(IDR_MDSPDEVICE)

BEGIN_COM_MAP(CMDSPDevice)
	COM_INTERFACE_ENTRY(IMDSPDevice)
	COM_INTERFACE_ENTRY(IMDSPDevice2)
	COM_INTERFACE_ENTRY(IMDSPDeviceControl)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
END_COM_MAP()

// IMDSPDevice
public:
	HRESULT InitGlobalDeviceInfo();
	WCHAR m_wcsName[MAX_PATH];
	STDMETHOD(EnumStorage)(/*[out]*/ IMDSPEnumStorage **ppEnumStorage);
	STDMETHOD(GetFormatSupport)(_WAVEFORMATEX **pFormatEx,
                                UINT *pnFormatCount,
                                LPWSTR **pppwszMimeType,
                                UINT *pnMimeTypeCount);
	STDMETHOD(GetDeviceIcon)(/*[out]*/ ULONG *hIcon);
	STDMETHOD(GetStatus)(/*[out]*/ DWORD *pdwStatus);
	STDMETHOD(GetPowerSource)(/*[out]*/ DWORD *pdwPowerSource, /*[out]*/ DWORD *pdwPercentRemaining);
	STDMETHOD(GetSerialNumber)(/*[out]*/ PWMDMID pSerialNumber, /*[in, out]*/BYTE abMac[WMDM_MAC_LENGTH]);
	STDMETHOD(GetType)(/*[out]*/ DWORD *pdwType);
	STDMETHOD(GetVersion)(/*[out]*/ DWORD *pdwVersion);
	STDMETHOD(GetManufacturer)(/*[out,string,size_is(nMaxChars)]*/ LPWSTR pwszName, /*[in]*/ UINT nMaxChars);
	STDMETHOD(GetName)(/*[out,string,size_is(nMaxChars)]*/ LPWSTR pwszName, /*[in]*/ UINT nMaxChars);
    STDMETHOD(SendOpaqueCommand)(OPAQUECOMMAND *pCommand);
// IMDSPDevice2
	STDMETHOD(GetStorage)( LPCWSTR pszStorageName, IMDSPStorage** ppStorage );
 
    STDMETHOD(GetFormatSupport2)(   DWORD dwFlags,
                                    _WAVEFORMATEX **ppAudioFormatEx,
                                    UINT *pnAudioFormatCount,
			                        _VIDEOINFOHEADER **ppVideoFormatEx,
                                    UINT *pnVideoFormatCount,
                                    WMFILECAPABILITIES **ppFileType,
                                    UINT *pnFileTypeCount );

	STDMETHOD(GetSpecifyPropertyPages)( ISpecifyPropertyPages** ppSpecifyPropPages, 
									    IUnknown*** pppUnknowns, 
									    ULONG* pcUnks );

    STDMETHOD(GetPnPName)( LPWSTR pwszPnPName, UINT nMaxChars );


// IMDSPDeviceControl
	STDMETHOD(GetDCStatus)(/*[out]*/ DWORD *pdwStatus);
	STDMETHOD(GetCapabilities)(/*[out]*/ DWORD *pdwCapabilitiesMask);
	STDMETHOD(Play)();
	STDMETHOD(Record)(/*[in]*/ _WAVEFORMATEX *pFormat);
	STDMETHOD(Pause)();
	STDMETHOD(Resume)();
	STDMETHOD(Stop)();
	STDMETHOD(Seek)(/*[in]*/ UINT fuMode, /*[in]*/ int nOffset);

// ISpecifyPropertyPages
    STDMETHOD(GetPages)(CAUUID *pPages);

};

#endif //__MDSPDEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\mdspenumdevice.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDSPEnumDevice.h : Declaration of the CMDSPEnumDevice

#ifndef __MDSPENUMDEVICE_H_
#define __MDSPENUMDEVICE_H_

/////////////////////////////////////////////////////////////////////////////
// CMDSPEnumDevice
class ATL_NO_VTABLE CMDSPEnumDevice : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMDSPEnumDevice, &CLSID_MDSPEnumDevice>,
	public IMDSPEnumDevice
{
public:
	CMDSPEnumDevice();


DECLARE_REGISTRY_RESOURCEID(IDR_MDSPENUMDEVICE)

BEGIN_COM_MAP(CMDSPEnumDevice)
	COM_INTERFACE_ENTRY(IMDSPEnumDevice)
END_COM_MAP()

// IMDSPEnumDevice
public:
	ULONG m_nCurOffset;
	ULONG m_nMaxDeviceCount;
	WCHAR m_cEnumDriveLetter[MDSP_MAX_DRIVE_COUNT];
	STDMETHOD(Clone)(/*[out]*/ IMDSPEnumDevice **ppEnumDevice);
	STDMETHOD(Reset)();
	STDMETHOD(Skip)(/*[in]*/ ULONG celt, /*[out]*/ ULONG *pceltFetched);
	STDMETHOD(Next)(/*[in]*/ ULONG celt, /*[out]*/ IMDSPDevice **ppDevice, /*[out]*/ ULONG *pceltFetched);
};

#endif //__MDSPENUMDEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\mdspenumstorage.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDSPEnumStorage.h : Declaration of the CMDSPEnumStorage

#ifndef __MDSPENUMSTORAGE_H_
#define __MDSPENUMSTORAGE_H_

/////////////////////////////////////////////////////////////////////////////
// CMDSPEnumStorage
class ATL_NO_VTABLE CMDSPEnumStorage : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMDSPEnumStorage, &CLSID_MDSPEnumStorage>,
	public IMDSPEnumStorage
{
public:
	CMDSPEnumStorage();
	~CMDSPEnumStorage();
	

DECLARE_REGISTRY_RESOURCEID(IDR_MDSPENUMSTORAGE)

BEGIN_COM_MAP(CMDSPEnumStorage)
	COM_INTERFACE_ENTRY(IMDSPEnumStorage)
END_COM_MAP()

// IMDSPEnumStorage

public:
	WCHAR m_wcsPath[MAX_PATH];
	HANDLE m_hFFile;
	int	  m_nEndSearch;
	STDMETHOD(Clone)(/*[out]*/ IMDSPEnumStorage **ppEnumStorage);
	STDMETHOD(Reset)();
	STDMETHOD(Skip)(/*[in]*/ ULONG celt, /*[out]*/ ULONG *pceltFetched);
	STDMETHOD(Next)(/*[in]*/ ULONG celt, /*[out]*/ IMDSPStorage **ppStorage, /*[out]*/ ULONG *pceltFetched);
};

#endif //__MDSPENUMSTORAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\mdspenumstorage.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDSPEnumStorage.cpp : Implementation of CMDSPEnumStorage

#include "hdspPCH.h"
#include "wmsstd.h"
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

/////////////////////////////////////////////////////////////////////////////
// CMDSPEnumStorage
CMDSPEnumStorage::CMDSPEnumStorage()
{
	m_hFFile = INVALID_HANDLE_VALUE;
	m_nEndSearch = 0;
        m_wcsPath[0] = 0;
}

CMDSPEnumStorage::~CMDSPEnumStorage()
{
	if( m_hFFile != INVALID_HANDLE_VALUE )
	{
		FindClose(m_hFFile); 
	}
}

STDMETHODIMP CMDSPEnumStorage::Next(ULONG celt, IMDSPStorage **ppStorage, ULONG *pceltFetched)
{
	HRESULT hr = S_FALSE;

	CARg(ppStorage);
	CARg(pceltFetched);

	*pceltFetched = 0;

    if( m_nEndSearch )
	{
		return S_FALSE;
	}

        DWORD dwLen = wcslen(m_wcsPath);
        if (dwLen == 0  || dwLen >= ARRAYSIZE(m_wcsPath))
        {
            // a) Code below aassumes that dwLen > 0 (uses dwLen - 1 as an index
            // b) dwLen >= ARRAYSIZE(m_wcsPath) implies m_wcsPath has overflowed
            //    Below, we use the fact that dwLen < ARRAYSIZE(m_wcsPath) to 
            //    bound the sizes of temp variables into which m_wcsPath is copied
            return E_FAIL;
        }
	if( dwLen < 3 )
	{
		// For the root storage
		CComObject<CMDSPStorage> *pStg;
		hr=CComObject<CMDSPStorage>::CreateInstance(&pStg);

		if( SUCCEEDED(hr) )
		{
			hr = pStg->QueryInterface(
				IID_IMDSPStorage,
				reinterpret_cast<void**>(ppStorage)
			);
			if( FAILED(hr) )
			{
				delete pStg;
				*pceltFetched = 0;
			}
			else
			{ 
				wcscpy(pStg->m_wcsName, m_wcsPath);
				if( m_wcsPath[dwLen-1] != 0x5c )
				{
					wcscat(pStg->m_wcsName, g_wcsBackslash);
				}
				m_nEndSearch = 1;  // Signal end of enumeration
			}

		}

                if( SUCCEEDED(hr) ) // if obj created successfully
		{
			*pceltFetched = 1;
			if( celt != 1 )
			{
				hr = S_FALSE;  // didn't get what he wanted
			}
		}
	} 
	else
	{
		// For non-root storage
		WCHAR wcsTmp[MAX_PATH+1+BACKSLASH_STRING_LENGTH];// for appending "\\*"
                                         // Note that ARRAYSIZE(m_wcsPath) == MAX_PATH
		char  szTmp[MAX_PATH];
		WIN32_FIND_DATAA fd;
		ULONG i;

		for(i=0; (i<celt)&&(!m_nEndSearch); )
		{
                    if( m_hFFile == INVALID_HANDLE_VALUE )
                    {    
                            wcscpy(wcsTmp, m_wcsPath);
                            if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c )
                            {
                                    wcscat(wcsTmp, g_wcsBackslash);
                            }
                            wcscat(wcsTmp, L"*");
                            
                            WideCharToMultiByte(CP_ACP, NULL, wcsTmp, -1, szTmp, MAX_PATH, NULL, NULL);		

                            m_hFFile = FindFirstFileA(szTmp, &fd);
                            if( m_hFFile == INVALID_HANDLE_VALUE )
                            {
                                    m_nEndSearch = 1;
                            }
                    }
                    else
                    {
                            if( !FindNextFileA(m_hFFile, &fd) )
                            {
                                    m_nEndSearch = 1;
                            }
                    }
            
                    if ( !m_nEndSearch )
                    {
                        if( !strcmp(fd.cFileName, ".") || !strcmp(fd.cFileName, "..") ) 
                        {
                                continue;
                        }

                        CComObject<CMDSPStorage> *pStg;
                        hr = CComObject<CMDSPStorage>::CreateInstance(&pStg);

                        if( SUCCEEDED(hr) )
                        {
                            hr = pStg->QueryInterface(
                                    IID_IMDSPStorage,
                                    reinterpret_cast<void**>(&(ppStorage[*pceltFetched]))
                            );
                            if( FAILED(hr) )
                            {
                                    delete pStg;
                                    break;
                            }
                            else 
                            { 
                                // Compute the number of chars we'll use
                                // up in pStg->m_wcsName
                                int nHave = ARRAYSIZE(pStg->m_wcsName) - 1;
                                            // -1 for the NULL terminator

                                nHave -= dwLen;
                                if( m_wcsPath[dwLen-1] != 0x5c ) 
                                {
                                    nHave -= BACKSLASH_STRING_LENGTH;
                                }
                                MultiByteToWideChar(CP_ACP, NULL, fd.cFileName, -1, wcsTmp, MAX_PATH);
                                nHave -= wcslen(wcsTmp);
                                if (nHave >= 0)
                                {
                                    wcscpy(pStg->m_wcsName, m_wcsPath);
                                    if( m_wcsPath[dwLen-1] != 0x5c )
                                    {
                                            wcscat(pStg->m_wcsName, g_wcsBackslash);
                                    }
                                    wcscat(pStg->m_wcsName, wcsTmp);

                                    *pceltFetched = (*pceltFetched)+1;
                                    i++;
                                }
                                else
                                {
                                    ppStorage[*pceltFetched]->Release();
                                    ppStorage[*pceltFetched] = NULL;
                                    hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                                                        //defined in strsafe.h
                                    break;
                                }
                            }
                        }
                        else
                        {
                            break;
                        }
                    }	
		} // end of For loop 
		
		if( SUCCEEDED(hr) && (*pceltFetched < celt) ) 
		{
			hr = S_FALSE;
		}
                else if (FAILED(hr))
                {
                    for (; *pceltFetched; )
                    {
                        (*pceltFetched)--;
                        ppStorage[*pceltFetched]->Release();
                        ppStorage[*pceltFetched] = NULL;
                    }
                }
	}

Error:

    hrLogDWORD("IMDSPEnumStorage::Next returned 0x%08lx", hr, hr);
	
	return hr;
}

STDMETHODIMP CMDSPEnumStorage::Skip(ULONG celt, ULONG *pceltFetched)
{
	HRESULT hr = S_OK;
    char    szTmp[MAX_PATH];
    WCHAR   wcsTmp[MAX_PATH+1+BACKSLASH_STRING_LENGTH]; // for appending "\\*"
	WIN32_FIND_DATAA fd;
    ULONG   i;

	CARg(celt);
	CARg(pceltFetched);
    CFRg(!m_nEndSearch);   // make sure it is not the end of list

	*pceltFetched = 0;
    if( wcslen(m_wcsPath) < 3 ) // do nothing if it is the root storage
	{
		return S_OK; 
	}
    if( wcslen(m_wcsPath) >= ARRAYSIZE(wcsTmp) - BACKSLASH_STRING_LENGTH - 1 ) 
    {
        // We check the length against wcsTmp's size because wcsTmp is the 
        // recipient of a string copy below. However, note that m_wcsPath
        // also has MAX_PATH characters, so if this happens, it means that
        // it has overflowed. Bail out.
        return E_FAIL;
    }

	for(i=0; (i<celt)&&(!m_nEndSearch); )
	{
		if( m_hFFile==INVALID_HANDLE_VALUE ) // at the start
		{
			wcscpy(wcsTmp, m_wcsPath);
			if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c )
			{
				wcscat(wcsTmp, g_wcsBackslash);
			}
			wcscat(wcsTmp, L"*");
			WideCharToMultiByte(CP_ACP, NULL, wcsTmp, -1, szTmp, MAX_PATH, NULL, NULL);	
			m_hFFile = FindFirstFileA(szTmp, &fd);
			if( m_hFFile == INVALID_HANDLE_VALUE ) 
			{
				m_nEndSearch = 1;
			}
		}
		else
		{
			if( !FindNextFileA(m_hFFile, &fd) )
			{
				m_nEndSearch = 1;
			}
		}
		if( !m_nEndSearch )
		{
			if( !strcmp(fd.cFileName, ".") || !strcmp(fd.cFileName, "..") ) 
			{
			    continue;
			}

			*pceltFetched = (*pceltFetched)+1;
			i++;
		}
	}

	if( *pceltFetched < celt )
	{
		hr = S_FALSE;
	}

Error:

    hrLogDWORD("IMDSPEnumStorage::Skip returned 0x%08lx", hr, hr);
	
	return hr;
}

STDMETHODIMP CMDSPEnumStorage::Reset()
{
    HRESULT hr = S_OK;

	m_nEndSearch = 0;

	if(m_hFFile && m_hFFile != INVALID_HANDLE_VALUE ) 
	{
		FindClose(m_hFFile);
	}
	m_hFFile = INVALID_HANDLE_VALUE;

    hrLogDWORD("IMDSPEnumStorage::Reset returned 0x%08lx", hr, hr);
	
	return hr;
}

STDMETHODIMP CMDSPEnumStorage::Clone(IMDSPEnumStorage * * ppEnumStorage)
{
	HRESULT hr;

	CARg(ppEnumStorage);

	CComObject<CMDSPEnumStorage> *pEnumObj;
	CORg(CComObject<CMDSPEnumStorage>::CreateInstance(&pEnumObj));

	hr = pEnumObj->QueryInterface(
		IID_IMDSPEnumStorage,
		reinterpret_cast<void**>(ppEnumStorage)
	);
	if( FAILED(hr) )
	{
		delete pEnumObj;
	}
        else 
	{
            // wcscpy(pEnumObj->m_wcsPath, m_wcsPath);
            hr = StringCbCopyW(pEnumObj->m_wcsPath, 
                               ARRAYSIZE(pEnumObj->m_wcsPath),
                               m_wcsPath);
            if (FAILED(hr))
            {
                (*ppEnumStorage)->Release();
                *ppEnumStorage = NULL;
                goto Error;
            }

            // @@@@ Not doing anything more is wrong. If m_hFFile is not 
            // INVALID_HANDLE_VALUE, we have to "advance" the m_hFFile to
            // the same extent in the cloned object.
	}

Error:

    hrLogDWORD("IMDSPEnumStorage::Clone returned 0x%08lx", hr, hr);
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\mdspenumdevice.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDSPEnumDevice.cpp : Implementation of CMDSPEnumDevice

#include "hdspPCH.h"

/////////////////////////////////////////////////////////////////////////////
// CMDSPEnumDevice
CMDSPEnumDevice::CMDSPEnumDevice()
{
	CHAR  szDrive[] = "?:";
	INT   i;
	INT   cnt;

	m_nCurOffset=0;

	for(i=0, cnt=0; i<MDSP_MAX_DRIVE_COUNT; i++)
	{
		szDrive[0] = 'A' + i;

		// Add all FIXED drives to the enumeration list.
		//
		// Note: some hard drives do not report as FIXED, so always add C drive.
		//
		if( UtilGetDriveType(szDrive) == DRIVE_FIXED || szDrive[0] == 'C' )  
		{
			m_cEnumDriveLetter[cnt] = szDrive[0];
			cnt++;
		}
	}

	m_nMaxDeviceCount = cnt;
}

STDMETHODIMP CMDSPEnumDevice::Next(ULONG celt, IMDSPDevice * * ppDevice, ULONG * pceltFetched)
{
	HRESULT hr = S_FALSE;
	ULONG   i;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(ppDevice);
	CARg(pceltFetched);

	*pceltFetched = 0;
    *ppDevice = NULL;

	for(i=0; (i<celt)&&(m_nCurOffset<m_nMaxDeviceCount); i++)
	{
		CComObject<CMDSPDevice> *pObj;

		CHRg(CComObject<CMDSPDevice>::CreateInstance(&pObj));

		hr = pObj->QueryInterface(
			IID_IMDSPDevice,
			reinterpret_cast<void**>(&(ppDevice[i]))
		);
		if( FAILED(hr) )
		{
			delete pObj;
			break;
		}
		else
		{				
			*pceltFetched = (*pceltFetched) + 1;
		    
			pObj->m_wcsName[0] = m_cEnumDriveLetter[m_nCurOffset];
			pObj->m_wcsName[1] = L':';
			pObj->m_wcsName[2] = NULL;
			
			m_nCurOffset ++;

			pObj->InitGlobalDeviceInfo();
		}
	} 
	if( SUCCEEDED(hr) )
	{
		hr = ( *pceltFetched == celt ) ? S_OK : S_FALSE;
	}

Error: 

    hrLogDWORD("IMSDPEnumDevice::Next returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPEnumDevice::Skip(ULONG celt, ULONG *pceltFetched)
{
	HRESULT hr;
    
	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pceltFetched);

	if( celt <= m_nMaxDeviceCount-m_nCurOffset )
	{
		*pceltFetched = celt;
		m_nCurOffset += celt;
		
		hr = S_OK;
    }
	else
	{
		*pceltFetched = m_nMaxDeviceCount - m_nCurOffset;
		m_nCurOffset = m_nMaxDeviceCount;

		hr = S_FALSE;
	}
	
Error:

    hrLogDWORD("IMSDPEnumDevice::Skip returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPEnumDevice::Reset()
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	m_nCurOffset = 0;

    hr = S_OK;

Error:

    hrLogDWORD("IMSDPEnumDevice::Reset returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPEnumDevice::Clone(IMDSPEnumDevice * * ppEnumDevice)
{
	HRESULT hr;
	CComObject<CMDSPEnumDevice> *pEnumObj;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(ppEnumDevice);

	hr = CComObject<CMDSPEnumDevice>::CreateInstance(&pEnumObj);

	if( SUCCEEDED(hr) )
	{
		hr = pEnumObj->QueryInterface(
			IID_IMDSPEnumDevice,
			reinterpret_cast<void**>(ppEnumDevice)
		);
		if( FAILED(hr) )
		{
			delete pEnumObj;
			goto Error;
		}
	}

	hr = S_OK;

Error:

    hrLogDWORD("IMSDPEnumDevice::Clone returned 0x%08lx", hr, hr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\mdspstorageglobals.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDSPStorageGlobals.h : Declaration of the CMDSPStorageGlobals

#ifndef __MDSPSTORAGEGLOBALS_H_
#define __MDSPSTORAGEGLOBALS_H_

/////////////////////////////////////////////////////////////////////////////
// CMDSPStorageGlobals
class ATL_NO_VTABLE CMDSPStorageGlobals : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMDSPStorageGlobals, &CLSID_MDSPStorageGlobals>,
	public IMDSPStorageGlobals
{
public:
	CMDSPStorageGlobals()
	{
		m_pMDSPDevice=(IMDSPDevice *)NULL;
                m_wcsName[0] = L'\0';
	}
	~CMDSPStorageGlobals();

DECLARE_REGISTRY_RESOURCEID(IDR_MDSPSTORAGEGLOBALS)

BEGIN_COM_MAP(CMDSPStorageGlobals)
	COM_INTERFACE_ENTRY(IMDSPStorageGlobals)
END_COM_MAP()

// IMDSPStorageGlobals
public:
	WCHAR m_wcsName[MAX_PATH];
	IMDSPDevice *m_pMDSPDevice;
	STDMETHOD(GetTotalSize)(/*[out]*/ DWORD *pdwTotalSizeLow, /*[out]*/ DWORD *pdwTotalSizeHigh);
	STDMETHOD(GetRootStorage)(/*[out]*/ IMDSPStorage **ppRoot);
	STDMETHOD(GetDevice)(/*[out]*/ IMDSPDevice **ppDevice);
	STDMETHOD(Initialize)(/*[in]*/ UINT fuMode, /*[in]*/ IWMDMProgress *pProgress);
	STDMETHOD(GetStatus)(/*[out]*/ DWORD *pdwStatus);
	STDMETHOD(GetTotalBad)(/*[out]*/ DWORD *pdwBadLow, /*[out]*/ DWORD *pdwBadHigh);
	STDMETHOD(GetTotalFree)(/*[out]*/ DWORD *pdwFreeLow, /*[out]*/ DWORD *pdwFreeHigh);
	STDMETHOD(GetSerialNumber)(/*[out]*/ PWMDMID pSerialNum, /*[in, out]*/BYTE abMac[WMDM_MAC_LENGTH]);
	STDMETHOD(GetCapabilities)(/*[out]*/ DWORD *pdwCapabilities);
};

#endif //__MDSPSTORAGEGLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\mdspstorageglobals.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDSPStorageGlobals.cpp : Implementation of CMDSPStorageGlobals

#include "hdspPCH.h"
#include "strsafe.h"
 
/////////////////////////////////////////////////////////////////////////////
// CMDSPStorageGlobals

CMDSPStorageGlobals::~CMDSPStorageGlobals()
{
	if( m_pMDSPDevice != NULL )
	{
		m_pMDSPDevice->Release();
	}

	for(int i=0; i<MDSP_MAX_DEVICE_OBJ;i++)
	{
		if( !wcscmp(g_GlobalDeviceInfo[i].wcsDevName, m_wcsName) )
		{
			g_GlobalDeviceInfo[i].pIMDSPStorageGlobals = NULL;
		}
	}
}

STDMETHODIMP CMDSPStorageGlobals::GetCapabilities(DWORD * pdwCapabilities)
{
    HRESULT hr = S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pdwCapabilities);

	*pdwCapabilities = 0;
	*pdwCapabilities =	WMDM_STORAGECAP_FOLDERSINROOT		| 
						WMDM_STORAGECAP_FILESINROOT			|
						WMDM_STORAGECAP_FOLDERSINFOLDERS	|
						WMDM_STORAGECAP_FILESINFOLDERS		;
Error:

    hrLogDWORD("IMDSPStorageGlobals::GetCapabilities returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPStorageGlobals::GetSerialNumber(
	PWMDMID pSerialNum,
	BYTE abMac[WMDM_MAC_LENGTH])
{
	HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pSerialNum);

	IMDSPDevice *pDev;		// For PM SP, device is the same as StorageGlobals
	CHRg(GetDevice(&pDev));

	hr = UtilGetSerialNumber(m_wcsName, pSerialNum, FALSE);

	pDev->Release();

	if( hr == HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) )
	{
		hr = WMDM_E_NOTSUPPORTED;
	}

	if( hr == S_OK )
	{
		// MAC the parameters
		HMAC hMAC;
		CORg(g_pAppSCServer->MACInit(&hMAC));
		CORg(g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pSerialNum), sizeof(WMDMID)));
		CORg(g_pAppSCServer->MACFinal(hMAC, abMac));
	}

Error:

    hrLogDWORD("IMDSPStorageGlobals::GetSerialNumber returned 0x%08lx", hr, hr);
	
	return hr;
}

STDMETHODIMP CMDSPStorageGlobals::GetTotalSize(DWORD * pdwTotalSizeLow, DWORD * pdwTotalSizeHigh)
{
	HRESULT        hr = S_OK;
	char           pszDrive[32];
	DWORD          dwSectPerClust;
	DWORD          dwBytesPerSect;
	DWORD          dwFreeClusters;
	DWORD          dwTotalClusters;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pdwTotalSizeLow);
	CARg(pdwTotalSizeHigh);

	WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, pszDrive, 32, NULL, NULL);	

	if( GetDiskFreeSpace(
		pszDrive,
		&dwSectPerClust, &dwBytesPerSect,
		&dwFreeClusters, &dwTotalClusters))
	{
		ULARGE_INTEGER i64TotalBytes;

		i64TotalBytes.QuadPart = UInt32x32To64(dwBytesPerSect, dwSectPerClust*dwTotalClusters);

		*pdwTotalSizeLow = i64TotalBytes.LowPart;
		*pdwTotalSizeHigh = i64TotalBytes.HighPart;
	}
	else
	{
		ULARGE_INTEGER  uliFree;
		ULARGE_INTEGER  uliTotal;

		CFRg( GetDiskFreeSpaceEx(
			pszDrive,
			&uliFree,
			&uliTotal,
			NULL)
		);
		
		*pdwTotalSizeLow = uliTotal.LowPart;
		*pdwTotalSizeHigh = uliTotal.HighPart;
	}

Error:

    hrLogDWORD("IMDSPStorageGlobals::GetTotalFree returned 0x%08lx", hr, hr);
    
	return hr;
}


STDMETHODIMP CMDSPStorageGlobals::GetTotalFree(DWORD * pdwFreeLow, DWORD * pdwFreeHigh)
{
	HRESULT        hr = S_OK;
	char           pszDrive[32];
	DWORD          dwSectPerClust;
	DWORD          dwBytesPerSect;
	DWORD          dwFreeClusters;
	DWORD          dwTotalClusters;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pdwFreeLow);
	CARg(pdwFreeHigh);

	WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, pszDrive, 32, NULL, NULL);	

	if( GetDiskFreeSpace(
		pszDrive,
		&dwSectPerClust, &dwBytesPerSect,
		&dwFreeClusters, &dwTotalClusters))
	{
		ULARGE_INTEGER i64FreeBytesToCaller;

		i64FreeBytesToCaller.QuadPart = UInt32x32To64(dwBytesPerSect, dwSectPerClust*dwFreeClusters);

		*pdwFreeLow = i64FreeBytesToCaller.LowPart;
		*pdwFreeHigh = i64FreeBytesToCaller.HighPart;
	}
	else
	{
		ULARGE_INTEGER  uliFree;
		ULARGE_INTEGER  uliTotal;

		CFRg( GetDiskFreeSpaceEx(
			pszDrive,
			&uliFree,
			&uliTotal,
			NULL)
		);
		
		*pdwFreeLow = uliFree.LowPart;
		*pdwFreeHigh = uliFree.HighPart;
	}

Error:
    
	hrLogDWORD("IMDSPStorageGlobals::GetTotalFree returned 0x%08lx", hr, hr);
    return hr;
}

STDMETHODIMP CMDSPStorageGlobals::GetTotalBad(DWORD * pdwBadLow, DWORD * pdwBadHigh)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
    
	CORg(WMDM_E_NOTSUPPORTED);

Error:

	hrLogDWORD("IMDSPStorageGlobals::GetTotalBad returned 0x%08lx", hr, hr);
    
    return hr;
}

STDMETHODIMP CMDSPStorageGlobals::GetStatus(DWORD * pdwStatus)
{
	HRESULT      hr;
	IMDSPDevice *pDev;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CHRg(GetDevice(&pDev));

	hr = pDev->GetStatus(pdwStatus);

	pDev->Release();

Error:

    hrLogDWORD("IMDSPStorageGlobals::GetStatus returned 0x%08lx", hr, hr);
	
	return hr;
}


STDMETHODIMP CMDSPStorageGlobals::Initialize(UINT fuMode, IWMDMProgress * pProgress)
{
	HRESULT hr=S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CORg(WMDM_E_NOTSUPPORTED);

Error:

    hrLogDWORD("IMDSPStorageGlobals::Initialize returned 0x%08lx", hr, hr);
	
	return hr;
}

STDMETHODIMP CMDSPStorageGlobals::GetDevice(IMDSPDevice * * ppDevice)
{
	HRESULT hr;
	CComObject<CMDSPDevice> *pObj;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(ppDevice);

	if( m_pMDSPDevice )
	{
		*ppDevice = m_pMDSPDevice;
        (*ppDevice)->AddRef();
		return S_OK;
	}

	CORg(CComObject<CMDSPDevice>::CreateInstance(&pObj));

	hr = pObj->QueryInterface(
		IID_IMDSPDevice,
		reinterpret_cast<void**>(ppDevice)
	);
	if( FAILED(hr) )
	{
		delete pObj;
		goto Error;
	}
	else
	{
		// wcscpy(pObj->m_wcsName, m_wcsName);
                hr = StringCbCopyW(pObj->m_wcsName, sizeof(pObj->m_wcsName), m_wcsName);
                if( FAILED(hr) )
                {
                    (*ppDevice)->Release();
                    *ppDevice = NULL;
                    goto Error;
                }
		
		pObj->InitGlobalDeviceInfo();

		m_pMDSPDevice = *ppDevice;
		m_pMDSPDevice->AddRef();
	}

	hr = S_OK;

Error:

    hrLogDWORD("IMDSPStorageGlobals::GetDevice returned 0x%08lx", hr, hr);
	
	return hr;
}

STDMETHODIMP CMDSPStorageGlobals::GetRootStorage(IMDSPStorage * * ppRoot)
{
	HRESULT hr;
	CComObject<CMDSPStorage> *pObj;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(ppRoot);

	CORg(CComObject<CMDSPStorage>::CreateInstance(&pObj));

	hr = pObj->QueryInterface(
		IID_IMDSPStorage,
		reinterpret_cast<void**>(ppRoot)
	);
	if( FAILED(hr) )
	{
		delete pObj;
		goto Error;
	}
	else
	{
		// wcscpy(pObj->m_wcsName, m_wcsName);
                hr = StringCbCopyW(pObj->m_wcsName, sizeof(pObj->m_wcsName), m_wcsName);
                if( FAILED(hr) )
                {
                    (*ppRoot)->Release();
                    *ppRoot = NULL;
                    goto Error;
                }

                DWORD dwLen = wcslen(m_wcsName);

                if (dwLen == 0)
                {
                    hr = E_FAIL;
                    (*ppRoot)->Release();
                    *ppRoot = NULL;
                    goto Error;
                }
		if( m_wcsName[wcslen(m_wcsName)-1] != 0x5c )
		{
                    // wcscat(pObj->m_wcsName, g_wcsBackslash);
                    hr = StringCbCatW(pObj->m_wcsName, sizeof(pObj->m_wcsName),g_wcsBackslash);
                    if( FAILED(hr) )
                    {
                        (*ppRoot)->Release();
                        *ppRoot = NULL;
                        goto Error;
                    }
		}
	}

	hr = S_OK;

Error:

    hrLogDWORD("IMDSPStorageGlobals::GetRootStorage returned 0x%08lx", hr, hr);
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\mdspstorage.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDSPStorage.cpp : Implementation of CMDSPStorage

#include "hdspPCH.h"
#include "wmsstd.h"
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"


#define	CONEg(p)\
	do\
		{\
		if (!(p))\
			{\
			hr = WMDM_E_INTERFACEDEAD;\
			goto Error;\
			}\
		}\
	while (fFalse)

typedef struct __MOVETHREADARGS
{
    WCHAR wcsSrc[MAX_PATH];
	WCHAR wcsDst[MAX_PATH];
	BOOL  bNewThread;
    IWMDMProgress *pProgress;
	LPSTREAM pStream;
    CMDSPStorage *pThis;
	DWORD dwStatus;

} MOVETHREADARGS;


/////////////////////////////////////////////////////////////////////////////
// CMDSPStorage
CMDSPStorage::CMDSPStorage()
{
	m_hFile = INVALID_HANDLE_VALUE;
}

CMDSPStorage::~CMDSPStorage()
{
	if( m_hFile != INVALID_HANDLE_VALUE )
	{
		CloseHandle(m_hFile);
	}
}


STDMETHODIMP CMDSPStorage::GetStorageGlobals(IMDSPStorageGlobals **ppStorageGlobals)
{
	HRESULT hr;
    int i;
        BOOL bLocked = 0;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	g_CriticalSection.Lock();
        bLocked = 1;

	CARg(ppStorageGlobals);
	CONEg(m_wcsName[0]);

	WCHAR devName[MAX_PATH], *pW;
	pW = &devName[0];
	hr = wcsParseDeviceName(m_wcsName, pW, ARRAYSIZE(devName));
        if (FAILED(hr))
        {
            goto Error;
        }

	for(i=0; i<MDSP_MAX_DEVICE_OBJ;i++)
	{
		if( !wcscmp(g_GlobalDeviceInfo[i].wcsDevName, devName) )
		{
			break;
		}
	}

	if( i<MDSP_MAX_DEVICE_OBJ && g_GlobalDeviceInfo[i].pIMDSPStorageGlobals ) // found match
	{
		*ppStorageGlobals = (IMDSPStorageGlobals *)g_GlobalDeviceInfo[i].pIMDSPStorageGlobals;
		((IMDSPStorageGlobals *)g_GlobalDeviceInfo[i].pIMDSPStorageGlobals)->AddRef();
		hr = S_OK;
	}
	else
	{ // new entry in the global array
		if(!(i<MDSP_MAX_DEVICE_OBJ) ) // no match found 
		{
			for(i=0; i<MDSP_MAX_DEVICE_OBJ;i++)
			{
				if( !g_GlobalDeviceInfo[i].bValid )
				{
					break;
				}
			}
		}

		CPRg(i<MDSP_MAX_DEVICE_OBJ);

		CComObject<CMDSPStorageGlobals> *pObj;
		CORg(CComObject<CMDSPStorageGlobals>::CreateInstance(&pObj));
		hr = pObj->QueryInterface(
			IID_IMDSPStorageGlobals,
			reinterpret_cast<void**>(&g_GlobalDeviceInfo[i].pIMDSPStorageGlobals)
		);
		if( FAILED(hr) )
		{
			delete pObj;
		}
		else
		{
                        HRESULT hrTemp;

			// wcscpy(pObj->m_wcsName, devName);
                        hrTemp = StringCchCopyW(pObj->m_wcsName, ARRAYSIZE(pObj->m_wcsName), devName);
                        if (FAILED(hrTemp))
                        {
                            ((IUnknown*) (g_GlobalDeviceInfo[i].pIMDSPStorageGlobals))->Release();
                            g_GlobalDeviceInfo[i].pIMDSPStorageGlobals = NULL;
                            hr = hrTemp;
                            goto Error;
                        }

			// wcscpy(g_GlobalDeviceInfo[i].wcsDevName, devName);
                        hrTemp = StringCchCopyW(g_GlobalDeviceInfo[i].wcsDevName,
                                    ARRAYSIZE(g_GlobalDeviceInfo[i].wcsDevName), devName);
                        if (FAILED(hrTemp))
                        {
                            ((IUnknown*) (g_GlobalDeviceInfo[i].pIMDSPStorageGlobals))->Release();
                            g_GlobalDeviceInfo[i].pIMDSPStorageGlobals = NULL;
                            g_GlobalDeviceInfo[i].wcsDevName[0] = 0;
                            hr = hrTemp;
                            goto  Error;
                        }
			*ppStorageGlobals = (IMDSPStorageGlobals *)g_GlobalDeviceInfo[i].pIMDSPStorageGlobals;
			g_GlobalDeviceInfo[i].bValid=TRUE;			        
			g_GlobalDeviceInfo[i].dwStatus = 0;
		} // end of else
	} // end of else

Error:	

    if (bLocked)
    {
        g_CriticalSection.Unlock();
    }
    
    hrLogDWORD("IMSDPStorage::GetStorageGlobals returned 0x%08lx", hr, hr);
	
    return hr;
}

STDMETHODIMP CMDSPStorage::SetAttributes(DWORD dwAttributes, _WAVEFORMATEX *pFormat)
{
	HRESULT hr = E_FAIL;
    DWORD dwAttrib;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
    CONEg(m_wcsName[0]);

	WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, m_szTmp, MAX_PATH, NULL, NULL);	

	dwAttrib = GetFileAttributesA(m_szTmp);

	if( dwAttrib == (DWORD)0xFFFFFFFF )
	{
		return E_FAIL;
	}

	if( (dwAttributes & WMDM_FILE_ATTR_READONLY) )
	{
		dwAttrib |= FILE_ATTRIBUTE_READONLY; 
	}

	if( (dwAttributes & WMDM_FILE_ATTR_HIDDEN) )
	{
		dwAttrib |= FILE_ATTRIBUTE_HIDDEN; 
	}
	
	if( (dwAttributes & WMDM_FILE_ATTR_SYSTEM) )
	{
		dwAttrib |= FILE_ATTRIBUTE_SYSTEM; 
	}

    CWRg(SetFileAttributesA(m_szTmp, dwAttrib));

	hr = S_OK;

Error:

    hrLogDWORD("IMSDPStorage::SetAttributes returned 0x%08lx", hr, hr);

	return hr;
}

HRESULT QuerySubFoldersAndFiles(LPCSTR szCurrentFolder, DWORD *pdwAttr)
{
	HRESULT hr     = E_FAIL;
	LPSTR   szName = NULL;
    int     len;
	WIN32_FIND_DATAA fd;
	int	    nErrorEnd=0;
    HANDLE  hFFile = INVALID_HANDLE_VALUE;
    DWORD   dwAttrib;

	CARg(szCurrentFolder);
	CARg(pdwAttr);

	len = strlen(szCurrentFolder);
	CARg(len>2);

    szName = new char [len+BACKSLASH_SZ_STRING_LENGTH+MAX_PATH];
	CPRg(szName);

	strcpy(szName, szCurrentFolder);
	if( szName[strlen(szName)-1] != 0x5c )
	{
		strcat(szName, g_szBackslash);
	}
    strcat(szName, "*");

	while( !nErrorEnd )
	{
		if( hFFile == INVALID_HANDLE_VALUE )
		{    
			hFFile = FindFirstFileA(szName, &fd);
			if( hFFile == INVALID_HANDLE_VALUE )
			{
				nErrorEnd = 1;
			}
		}
		else
		{
			if( !FindNextFileA(hFFile, &fd) )
			{
				nErrorEnd = 1;
			}
		}
		
		if ( !nErrorEnd && hFFile != INVALID_HANDLE_VALUE )
		{
			if( !strcmp(fd.cFileName, ".") || !strcmp(fd.cFileName, "..") ) 
			{
				continue;
			}
			else
			{
				strcpy(szName, szCurrentFolder);
				if( szName[strlen(szName)-1] != 0x5c ) strcat(szName, g_szBackslash);
				strcat(szName, fd.cFileName);
		   		dwAttrib = GetFileAttributesA(szName);
                                if( dwAttrib & FILE_ATTRIBUTE_DIRECTORY )
				{
					*pdwAttr |= WMDM_STORAGE_ATTR_HAS_FOLDERS;
				} 
				else
				{
					*pdwAttr |= WMDM_STORAGE_ATTR_HAS_FILES;
				}
				if( (*pdwAttr & WMDM_STORAGE_ATTR_HAS_FOLDERS) &&
					(*pdwAttr & WMDM_STORAGE_ATTR_HAS_FILES ) )
				{
					break; // No need to continue since we found both
				}
			}
		} // End of If
	} // End of while 
		
    hr = S_OK;

Error:

	if( hFFile != INVALID_HANDLE_VALUE )
	{
		FindClose(hFFile);
	}
	if( szName )
	{
		delete [] szName;
	}

	return hr; // If FAILED(hr), sorry, can't do it.
}


STDMETHODIMP CMDSPStorage::GetAttributes(DWORD * pdwAttributes, _WAVEFORMATEX * pFormat)
{
	HRESULT hr = S_OK;
    DWORD dwAttrib;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pdwAttributes);
    CONEg(m_wcsName[0]);

	WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, m_szTmp, MAX_PATH, NULL, NULL);	
	dwAttrib = GetFileAttributesA(m_szTmp);

	if( dwAttrib == (DWORD)0xFFFFFFFF )
	{
		return E_FAIL;
	}

	*pdwAttributes = WMDM_STORAGE_ATTR_REMOVABLE |
					WMDM_STORAGE_ATTR_FOLDERS |
					WMDM_FILE_ATTR_CANREAD;

	if( !(dwAttrib & FILE_ATTRIBUTE_READONLY) )
	{
		*pdwAttributes |= WMDM_FILE_ATTR_CANDELETE |
						WMDM_FILE_ATTR_CANMOVE |
						WMDM_FILE_ATTR_CANRENAME; 
	}

	if( dwAttrib & FILE_ATTRIBUTE_DIRECTORY )
	{
		*pdwAttributes |= WMDM_FILE_ATTR_FOLDER;

		QuerySubFoldersAndFiles(m_szTmp, pdwAttributes); // No failure check, if failed, just keep current attributes
	}
	else
	{
		*pdwAttributes |= WMDM_FILE_ATTR_FILE;
    }

	// Now handle Hidden, ReadOnly, and System attributes
	if( (dwAttrib & FILE_ATTRIBUTE_READONLY) )
	{
		*pdwAttributes |= WMDM_FILE_ATTR_READONLY; 
	} 

	if( (dwAttrib & FILE_ATTRIBUTE_HIDDEN) )
	{
		*pdwAttributes |= WMDM_FILE_ATTR_HIDDEN; 
	} 
	
	if( (dwAttrib & FILE_ATTRIBUTE_SYSTEM) )
	{
		*pdwAttributes |= WMDM_FILE_ATTR_SYSTEM; 
	} 

Error:

    hrLogDWORD("IMSDPStorage::GetAttributes returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPStorage::GetName(LPWSTR pwszName, UINT nMaxChars)
{
	HRESULT hr = S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
    
	CONEg(m_wcsName[0]);
	CARg(pwszName);
	CPRg(wcslen(m_wcsName)<nMaxChars);

	if( m_wcsName[wcslen(m_wcsName)-1] == 0x5c ) // this is root storage
	{
		wcscpy(pwszName, wcsrchr(m_wcsName, 0x5c));
	}
	else 
	{
		wcscpy(pwszName, wcsrchr(m_wcsName, 0x5c)+1);
	}

Error:

    hrLogDWORD("IMSDPStorage::GetName returned 0x%08lx", hr, hr);

	return hr;
}



STDMETHODIMP CMDSPStorage::GetDate(PWMDMDATETIME pDateTimeUTC)
{
	HRESULT hr     = E_FAIL;
    HANDLE  hFFile = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA wfd;
    SYSTEMTIME      sysTime;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pDateTimeUTC);
	CONEg(m_wcsName[0]);

	CWRg(WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, m_szTmp, MAX_PATH, NULL, NULL));	

	DWORD curAttr = GetFileAttributesA(m_szTmp);
        if (curAttr == INVALID_FILE_ATTRIBUTES)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Error;
        }
	if( FILE_ATTRIBUTE_DIRECTORY & curAttr )
	{
                DWORD dwLen = strlen(m_szTmp)-1;
		if( m_szTmp[dwLen-1] != 0x5c )
		{
                    if (dwLen > ARRAYSIZE(m_szTmp) - 3)
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER; // defined in strsafe.h
                        goto Error;
                    }
                    else
                    {
			strcat(m_szTmp, g_szBackslash);
                    }
		}
                else
                {
                    if (dwLen > ARRAYSIZE(m_szTmp) - 2)
                    {
                        hr = STRSAFE_E_INSUFFICIENT_BUFFER; // defined in strsafe.h
                        goto Error;
                    }
                }
		strcat(m_szTmp, ".");
 	} 

	hFFile = FindFirstFile(m_szTmp, &wfd);
	CWRg(hFFile != INVALID_HANDLE_VALUE);

	CFRg(FileTimeToSystemTime((CONST FILETIME *)&wfd.ftLastWriteTime, &sysTime));

	pDateTimeUTC->wYear   = sysTime.wYear; 
    pDateTimeUTC->wMonth  = sysTime.wMonth; 
    pDateTimeUTC->wDay    = sysTime.wDay; 
    pDateTimeUTC->wHour   = sysTime.wHour; 
    pDateTimeUTC->wMinute = sysTime.wMinute; 
    pDateTimeUTC->wSecond = sysTime.wSecond; 

	hr = S_OK;

Error:

	if(hFFile != INVALID_HANDLE_VALUE) 
	{
		FindClose(hFFile);
	}

    hrLogDWORD("IMSDPStorage::GetDate returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPStorage::GetSize(DWORD * pdwSizeLow, DWORD * pdwSizeHigh)
{
	HRESULT hr    = S_OK;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    DWORD dwLS;
	DWORD dwHS;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pdwSizeLow);
	CONEg(m_wcsName[0]);

	CWRg(WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, m_szTmp, MAX_PATH, NULL, NULL));	

    dwLS = 0;
	dwHS = 0;

	DWORD curAttr = GetFileAttributesA(m_szTmp);
        if (curAttr == INVALID_FILE_ATTRIBUTES)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Error;
        }
	if( FILE_ATTRIBUTE_DIRECTORY & curAttr )
	{
		*pdwSizeLow  = 0;
		*pdwSizeHigh = 0;
	}
	else
	{
		CORg(GetFileSizeRecursive(m_szTmp, &dwLS, &dwHS));
		*pdwSizeLow = dwLS;
		if(pdwSizeHigh)
		{
			*pdwSizeHigh = dwHS;
		}
	}

	hr = S_OK;

Error:

    hrLogDWORD("IMSDPStorage::GetSize returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPStorage::GetRights(PWMDMRIGHTS *ppRights,UINT *pnRightsCount,
									 BYTE abMac[WMDM_MAC_LENGTH])
{
	HRESULT hr;

    CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CORg(WMDM_E_NOTSUPPORTED);

Error:

	hrLogDWORD("IMSDPStorage::GetRights returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPStorage::CreateStorage(DWORD dwAttributes, _WAVEFORMATEX * pFormat, LPWSTR pwszName, IMDSPStorage * * ppNewStorage)
{
	HRESULT  hr       = E_FAIL;
    HANDLE   hFile;
	CHAR    *psz;
	CHAR     szNew[MAX_PATH];
    DWORD    curAttr  = 0;
	DWORD    fsAttrib = FILE_ATTRIBUTE_NORMAL;
    
	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CONEg(m_wcsName[0]);
	CARg(pwszName);
	CARg(ppNewStorage);

	CWRg(WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, m_szTmp, MAX_PATH, NULL, NULL));
	if( m_szTmp[strlen(m_szTmp)-1] == 0x5c ) 
	{
		m_szTmp[strlen(m_szTmp)-1] = NULL;  // trim the last backslash;
	}

	curAttr = GetFileAttributesA(m_szTmp);
        if (curAttr == INVALID_FILE_ATTRIBUTES)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Error;
        }
	if(  !(curAttr & FILE_ATTRIBUTE_DIRECTORY ) ) // if current storage is a file
	{
		if( dwAttributes & WMDM_STORAGECONTROL_INSERTINTO )
		{
			CORg(WMDM_E_NOTSUPPORTED); // can't do InsertInto
		}
		else
		{ // for file, the default is Before&After
			psz = strrchr(m_szTmp, g_szBackslash[0]);
			CFRg(psz);	
		}
    }
	else
	{  // current storage is a dir
 		if( (dwAttributes & WMDM_STORAGECONTROL_INSERTBEFORE) ||
			(dwAttributes & WMDM_STORAGECONTROL_INSERTAFTER) ) // before or after
		{
			psz=strrchr(m_szTmp, g_szBackslash[0]);
			CFRg(psz);
		}
		else
		{ // for dir, the default is InsertInto
			psz=m_szTmp+strlen(m_szTmp);
		}
    }

	CWRg(WideCharToMultiByte(CP_ACP, NULL, pwszName, -1, szNew, MAX_PATH, NULL, NULL));	

	// strcpy(psz, g_szBackslash);
        HRESULT hrTemp = StringCchCopyA(psz, ARRAYSIZE(m_szTmp) - (psz - m_szTmp), g_szBackslash);
        if (FAILED(hrTemp))
        {
            hr = hrTemp;
            goto Error;
        }
	// strcat(psz, szNew);
        hrTemp = StringCchCatA(psz, ARRAYSIZE(m_szTmp) - (psz - m_szTmp), szNew);
        if (FAILED(hrTemp))
        {
            hr = hrTemp;
            goto Error;
        }

	// Find what file system attribute the intend storage should be
	if( dwAttributes & WMDM_FILE_ATTR_HIDDEN )
	{
		fsAttrib |= FILE_ATTRIBUTE_HIDDEN;
	}
	if( dwAttributes & WMDM_FILE_ATTR_SYSTEM )
	{
		fsAttrib |= FILE_ATTRIBUTE_SYSTEM;
	}
	if( dwAttributes & WMDM_FILE_ATTR_READONLY )
	{
		fsAttrib |= FILE_ATTRIBUTE_READONLY;
	}

	if( dwAttributes & WMDM_FILE_ATTR_FOLDER )
	{
		if(CreateDirectoryA(m_szTmp, NULL)) 
		{
			hr = S_OK;
		}
		else
		{
			hr = GetLastError();
			if( hr == ERROR_ALREADY_EXISTS ) 
			{
				if( dwAttributes & WMDM_FILE_CREATE_OVERWRITE ) 
				{
					hr = S_OK;
				}
				else
				{
					hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
				}
			}
			else
			{
				hr = HRESULT_FROM_WIN32(hr);
				goto Error;
			}
		}

		if( S_OK == hr )
		{
			SetFileAttributes(m_szTmp, fsAttrib);
		}
	} 
	else if ( dwAttributes & WMDM_FILE_ATTR_FILE ) 
	{ 
		// If Overwrite is specified, use CREATE_ALWAYS
		if( dwAttributes & WMDM_FILE_CREATE_OVERWRITE )
		{
		    hFile = CreateFileA(
				m_szTmp,
				GENERIC_WRITE | GENERIC_READ, 
				FILE_SHARE_READ | FILE_SHARE_WRITE,
				NULL, 
				CREATE_ALWAYS,
				fsAttrib,
				NULL
			);
		}
		else
		{
			hFile = CreateFileA(
				m_szTmp,
				GENERIC_WRITE | GENERIC_READ, 
				FILE_SHARE_READ | FILE_SHARE_WRITE,
				NULL, 
				CREATE_NEW,
				fsAttrib,
				NULL
			);
        }

		CWRg(hFile != INVALID_HANDLE_VALUE); 
		CloseHandle(hFile);

		hr = S_OK;
	}
	else
	{
		hr = E_INVALIDARG;
		goto Error;
	}
		
	if( hr == S_OK )
	{
		CComObject<CMDSPStorage> *pObj;
		CORg(CComObject<CMDSPStorage>::CreateInstance(&pObj));

		hr = pObj->QueryInterface(
			IID_IMDSPStorage,
			reinterpret_cast<void**>(ppNewStorage)
		);
		if( FAILED(hr) )
		{
			delete pObj;
		}
		else
		{
			MultiByteToWideChar(CP_ACP, NULL, m_szTmp, -1, pObj->m_wcsName, MAX_PATH);
		}
	}
	
Error:

    hrLogDWORD("IMSDPStorage::CreateStorage returned 0x%08lx", hr, hr);

    return hr;
}

STDMETHODIMP CMDSPStorage::SendOpaqueCommand(OPAQUECOMMAND *pCommand)
{
    HRESULT hr = WMDM_E_NOTSUPPORTED;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
    
Error:
	
	hrLogDWORD("IMSDPStorage::SendOpaqueCommand returned 0x%08lx", hr, hr);

	return hr;
}

// IMDSPStorage2
STDMETHODIMP CMDSPStorage::GetStorage( 
    LPCWSTR pszStorageName, 
    IMDSPStorage** ppStorage )
{
    HRESULT hr;
    HRESULT hrTemp;
    WCHAR   pwszFileName[MAX_PATH];
    DWORD   dwAttrib;
    CComObject<CMDSPStorage> *pStg = NULL;

    // This storage need to be a folder to contain other storages.
	WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, m_szTmp, MAX_PATH, NULL, NULL);	
	dwAttrib = GetFileAttributesA(m_szTmp);
	if( dwAttrib == (DWORD)0xFFFFFFFF ) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Error;
    }
	if( (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) == 0 )
    {
        // This storage is not a directory/folder
        hr = E_FAIL;     // @@@@ Is any other value more suitable?
        goto Error;
    }

    // Get name of file asked for

    DWORD dwLen = wcslen(m_wcsName);

    if (dwLen == 0)
    {
        hr = E_FAIL;
        goto Error;
    }
    if (dwLen >= ARRAYSIZE(pwszFileName))
    {
        hr = STRSAFE_E_INSUFFICIENT_BUFFER; // defined in strsafe.h
        goto Error;
    }

    // Get name of file asked for
    wcscpy( pwszFileName, m_wcsName );
    if( pwszFileName[dwLen-1] != L'\\' )
    {
        if (dwLen >= ARRAYSIZE(pwszFileName) - 1)
        {
            hr = STRSAFE_E_INSUFFICIENT_BUFFER; // defined in strsafe.h
            goto Error;
        }
        wcscat( pwszFileName, L"\\" );
    }

    hrTemp = StringCchCatW( pwszFileName,
                            ARRAYSIZE(pwszFileName),
                            pszStorageName );

    if (FAILED(hrTemp))
    {
        // The file does not exist
        hr = E_FAIL;  // @@@@ Change this?
        goto Error;
    }

    // Check if the file exists
	CWRg(WideCharToMultiByte(CP_ACP, NULL, pwszFileName, -1, m_szTmp, MAX_PATH, NULL, NULL));		
    if( GetFileAttributesA( m_szTmp )  == -1 )
    {
        // The file does not exist
        hr = S_FALSE;       // @@@@ Should this be a failure code?
        goto Error;
    }

    // Create new storage object
    hr = CComObject<CMDSPStorage>::CreateInstance(&pStg);
	hr = pStg->QueryInterface( IID_IMDSPStorage, reinterpret_cast<void**>(ppStorage));
    // wcscpy(pStg->m_wcsName, pwszFileName);
    hrTemp = StringCchCopyW(pStg->m_wcsName, ARRAYSIZE(pStg->m_wcsName), pwszFileName);
    if (FAILED(hrTemp))
    {
        hr = hrTemp;
        (*ppStorage)->Release();
        pStg = NULL; // to prevent its deletion below
        goto Error;
    }

Error:
    if( hr != S_OK )
    {
        if( pStg ) delete pStg;
        *ppStorage = NULL;
    }

    return hr;
}

STDMETHODIMP CMDSPStorage::CreateStorage2(  
    DWORD dwAttributes,
	DWORD dwAttributesEx,
    _WAVEFORMATEX *pAudioFormat,
    _VIDEOINFOHEADER *pVideoFormat,
    LPWSTR pwszName,
	ULONGLONG  qwFileSize,
    IMDSPStorage **ppNewStorage )
{
    // pVideoFormat, dwAttributesEx not used right now
    return CreateStorage( dwAttributes, pAudioFormat, pwszName, ppNewStorage );
}


STDMETHODIMP CMDSPStorage::SetAttributes2(  
    DWORD dwAttributes, 
	DWORD dwAttributesEx, 
	_WAVEFORMATEX *pAudioFormat,
	_VIDEOINFOHEADER* pVideoFormat )
{
    // pVideoFormat, dwAttributesEx not used right now
    return SetAttributes( dwAttributes, pAudioFormat );
}

STDMETHODIMP CMDSPStorage::GetAttributes2(  
    DWORD *pdwAttributes,
	DWORD *pdwAttributesEx,
    _WAVEFORMATEX *pAudioFormat,
	_VIDEOINFOHEADER* pVideoFormat )
{
    HRESULT hr = S_OK;

    CARg( pdwAttributesEx );
    *pdwAttributesEx = 0;

    // pVideoFormat, dwAttributesEx not used right now
    hr = GetAttributes( pdwAttributes, pAudioFormat );

Error:
    return hr;
}


// IMDSPObjectInfo
STDMETHODIMP CMDSPStorage::GetPlayLength(/*[out]*/ DWORD *pdwLength)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	if ( !pdwLength )
	{
		hr = E_INVALIDARG;
	}
	else 
	{
		hr = WMDM_E_NOTSUPPORTED;
	}

Error:

    hrLogDWORD("IMDSPObjectInfo::GetPlayLength returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPStorage::SetPlayLength(/*[in]*/ DWORD dwLength)
{
    HRESULT hr = WMDM_E_NOTSUPPORTED;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
    
Error:

	hrLogDWORD("IMDSPObjectInfo::SetPlayLength returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPStorage::GetPlayOffset(/*[out]*/ DWORD *pdwOffset)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	if ( !pdwOffset )
	{
		hr = E_INVALIDARG;
	}
	else 
	{
		hr = WMDM_E_NOTSUPPORTED;
	}

Error:

    hrLogDWORD("IMDSPObjectInfo::GetPlayOffset returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPStorage::SetPlayOffset(/*[in]*/ DWORD dwOffset)
{
    HRESULT hr = WMDM_E_NOTSUPPORTED;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
    
Error:

	hrLogDWORD("IMDSPObjectInfo::SetPlayOffset returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPStorage::GetTotalLength(/*[out]*/ DWORD *pdwLength)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	if ( !pdwLength )
	{
		hr = E_INVALIDARG;
	}
	else 
	{
		hr = WMDM_E_NOTSUPPORTED;
	}

Error:

    hrLogDWORD("IMDSPObjectInfo::GetTotalLength returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPStorage::GetLastPlayPosition(/*[out]*/ DWORD *pdwLastPos)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	if ( !pdwLastPos )
	{
		hr = E_INVALIDARG;
	}
	else 
	{
		hr = WMDM_E_NOTSUPPORTED;
	}

Error:

    hrLogDWORD("IMDSPObjectInfo::GetLastPlayPosition returned 0x%08lx", hr, hr);

    return hr;
}

STDMETHODIMP CMDSPStorage::GetLongestPlayPosition(/*[out]*/ DWORD *pdwLongestPos)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	if ( !pdwLongestPos )
	{
		hr = E_INVALIDARG;
	}
	else 
	{
		hr = WMDM_E_NOTSUPPORTED;
	}

Error:

    hrLogDWORD("IMDSPObjectInfo::GetLongestPlayPosition returned 0x%08lx", hr, hr);

	return hr;
}

// IMDSPObject
STDMETHODIMP CMDSPStorage::Open(/*[in]*/ UINT fuMode)
{
	HRESULT hr;
	DWORD   dwMode;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CONEg(m_wcsName[0]);

	if( m_hFile != INVALID_HANDLE_VALUE ) 
	{
		hr = WMDM_E_BUSY;
		goto Error;
	}

	WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, m_szTmp, MAX_PATH, NULL, NULL);	
	dwMode = GetFileAttributesA(m_szTmp);
	if( (dwMode & FILE_ATTRIBUTE_DIRECTORY) )
	{
		hr=WMDM_E_NOTSUPPORTED;
	}
	else
	{
		dwMode = 0;

		if(fuMode & MDSP_WRITE )
		{
			dwMode |= GENERIC_WRITE;
		}
		if(fuMode & MDSP_READ ) 
		{
			dwMode |= GENERIC_READ;
		}
		
		m_hFile = CreateFileA(
			m_szTmp,
			dwMode,
			FILE_SHARE_READ | FILE_SHARE_WRITE,
			NULL, 
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL,
			NULL
		);

		hr = ( m_hFile == INVALID_HANDLE_VALUE ) ? E_FAIL : S_OK;
	}

Error:

    hrLogDWORD("IMDSPObject::Open returned 0x%08lx", hr, hr);
	
	return hr;
}	

STDMETHODIMP CMDSPStorage::Read(
	BYTE  *pData,
	DWORD *pdwSize,
	BYTE   abMac[WMDM_MAC_LENGTH])
{
	HRESULT  hr;
	DWORD    dwToRead;
	DWORD    dwRead   = NULL;
    BYTE    *pTmpData = NULL; 

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pData);
	CARg(pdwSize);

	dwToRead = *pdwSize;

	if( m_hFile == INVALID_HANDLE_VALUE )
	{
		return E_FAIL;
	}
    
	pTmpData = new BYTE [dwToRead] ;

	CPRg(pTmpData);

	if( ReadFile(m_hFile,(LPVOID)pTmpData,dwToRead,&dwRead,NULL) ) 
	{ 
		*pdwSize = dwRead; 

		if( dwRead )
		{
			// MAC the parameters
			HMAC hMAC;
			
			CORg(g_pAppSCServer->MACInit(&hMAC));
			CORg(g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pTmpData), dwRead));
			CORg(g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pdwSize), sizeof(DWORD)));
			CORg(g_pAppSCServer->MACFinal(hMAC, abMac));
  			
			CORg(g_pAppSCServer->EncryptParam(pTmpData, dwRead));
			
			memcpy(pData, pTmpData, dwRead);
        }
	
		hr = S_OK; 
	}
	else
	{ 
		*pdwSize = 0; 

		hr = E_FAIL; 
	}

Error:

	if(pTmpData) 
	{
		delete [] pTmpData;
	}

    hrLogDWORD("IMDSPObject::Read returned 0x%08lx", hr, hr);
	
	return hr;
}	

STDMETHODIMP CMDSPStorage::Write(BYTE *pData, DWORD *pdwSize,
								 BYTE abMac[WMDM_MAC_LENGTH])
{
	HRESULT  hr;
	DWORD    dwWritten = 0;
    BYTE    *pTmpData  = NULL;
    BYTE     pSelfMac[WMDM_MAC_LENGTH];

	CARg(pData);
    CARg(pdwSize);

	if( m_hFile == INVALID_HANDLE_VALUE )
	{
		return E_FAIL;
	}

	pTmpData = new BYTE [*pdwSize];
	CPRg(pTmpData);
    memcpy(pTmpData, pData, *pdwSize);

    // Decrypt the pData Parameter
	CHRg(g_pAppSCServer->DecryptParam(pTmpData, *pdwSize));
	
	HMAC hMAC;
	CORg(g_pAppSCServer->MACInit(&hMAC));
	CORg(g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pTmpData), *pdwSize));
	CORg(g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pdwSize), sizeof(*pdwSize)));
	CORg(g_pAppSCServer->MACFinal(hMAC, pSelfMac));

	if (memcmp(abMac, pSelfMac, WMDM_MAC_LENGTH) != 0)
	{
		hr = WMDM_E_MAC_CHECK_FAILED;
		goto Error;
	}

	if( WriteFile(m_hFile,pTmpData,*pdwSize,&dwWritten,NULL) ) 
	{
		hr = S_OK;
	}
	else 
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}

	*pdwSize = dwWritten;

Error:

	if( pTmpData )
	{
		delete [] pTmpData;
	}

    hrLogDWORD("IMDSPObject::Write returned 0x%08lx", hr, hr);
	
	return hr;
}

STDMETHODIMP CMDSPStorage::Delete(UINT fuMode, IWMDMProgress *pProgress)
{
    HRESULT hr            = E_FAIL;
    BOOL bProgressStarted = FALSE;
	BOOL bBusyStatusSet   = FALSE;
    DWORD dwStatus        = NULL;

	if( pProgress )
	{
		CORg(pProgress->Begin(100));
		bProgressStarted=TRUE;
	}
	
	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CONEg(m_wcsName[0]);

	if ( m_hFile != INVALID_HANDLE_VALUE ) 
	{
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}

	CHRg(GetGlobalDeviceStatus(m_wcsName, &dwStatus));
	if( dwStatus & WMDM_STATUS_BUSY )
	{
		hr = WMDM_E_BUSY;
		goto Error;
	}

	dwStatus |= (WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_DELETING );
    CHRg(SetGlobalDeviceStatus(m_wcsName, dwStatus, TRUE));
    bBusyStatusSet=TRUE;

	WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, m_szTmp, MAX_PATH, NULL, NULL);	
	if( fuMode & WMDM_MODE_RECURSIVE )
	{
		CORg(DeleteFileRecursive(m_szTmp));
	}
	else
	{
		if( FILE_ATTRIBUTE_DIRECTORY & GetFileAttributesA(m_szTmp) )
		{				
			CWRg(RemoveDirectory(m_szTmp));
		}
		else
		{
			CWRg(DeleteFileA(m_szTmp));
		}
    }

	hr = S_OK;

Error:

	if( bBusyStatusSet )
	{
		dwStatus &= (~(WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_DELETING ));
		SetGlobalDeviceStatus(m_wcsName, dwStatus, TRUE);
	}

	if( hr == S_OK )
	{
		m_wcsName[0] = NULL; // Nullify the storage name 
    }

	if( bProgressStarted )
	{
		pProgress->Progress( 100 );
		pProgress->End();
	}

    hrLogDWORD("IMDSPObject::Delete returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPStorage::Seek(/*[in]*/ UINT fuFlags, /*[in]*/ DWORD dwOffset)
{
    HRESULT hr = S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CONEg(m_wcsName[0]);
	CFRg( m_hFile != INVALID_HANDLE_VALUE );
 
    DWORD dwMoveMethod;

	switch (fuFlags)
	{
	case MDSP_SEEK_BOF:
		dwMoveMethod = FILE_BEGIN;
		break;

	case MDSP_SEEK_CUR:
		dwMoveMethod = FILE_CURRENT;
		break;

	case MDSP_SEEK_EOF:
		dwMoveMethod = FILE_END;
		break;

	default:
		return E_INVALIDARG;
	}

	CWRg( (DWORD)0xFFFFFFFF != SetFilePointer(m_hFile, dwOffset, NULL, dwMoveMethod ) );
	
Error:

    hrLogDWORD("IMDSPObject::Seek returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPStorage::Rename(/*[in]*/ LPWSTR pwszNewName, IWMDMProgress *pProgress)
{
	HRESULT hr;
    BOOL    bProgressStarted = FALSE;
	BOOL    bBusyStatusSet   = FALSE;
    DWORD   dwStatus;

	if( pProgress )
	{
		CORg(pProgress->Begin(100));
		bProgressStarted=TRUE;
	}
	
	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pwszNewName);
	CONEg(m_wcsName[0]);
    CFRg(wcslen(m_wcsName)>3);  // cannot rename a root storage



	if ( m_hFile != INVALID_HANDLE_VALUE ) 
	{
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}
	
	CHRg(GetGlobalDeviceStatus(m_wcsName, &dwStatus));

	if( dwStatus & WMDM_STATUS_BUSY )
	{
		hr=WMDM_E_BUSY;
		goto Error;
	}

	dwStatus |= (WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_MOVING );
    CHRg(SetGlobalDeviceStatus(m_wcsName, dwStatus, TRUE));
    bBusyStatusSet = TRUE;

	char *pDirOffset;
	char szUpper[MAX_PATH], szNewFullPath[MAX_PATH], szNew[MAX_PATH];
	CWRg(WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, m_szTmp, MAX_PATH, NULL, NULL));	
	CWRg(WideCharToMultiByte(CP_ACP, NULL, pwszNewName, -1, szNew, MAX_PATH, NULL, NULL));	

	// From m_szTmp, find the upper level dir, and put it in szUpper.
	strcpy(szUpper, m_szTmp);
	if( szUpper[strlen(szUpper)-1] == 0x5c )
	{
		szUpper[strlen(szUpper)-1] = 0;
	}
	pDirOffset = strrchr(szUpper, 0x5c);
	if( pDirOffset )
	{
		*((char *)pDirOffset+1) = 0;
	}
	
	// From szUpper and szNew, form the full path for szNewFullPath
	strcpy(szNewFullPath, szUpper);
	pDirOffset=strrchr(szNew, 0x5c);
	if( pDirOffset ) 
	{
		// strcat(szNewFullPath, (char*)pDirOffset+1);
		hr = StringCchCatA(szNewFullPath, ARRAYSIZE(szNewFullPath), (char*)pDirOffset+1);
                if (FAILED(hr))
                {
                    goto Error;
                }
	}
	else 
	{
		// strcat(szNewFullPath, szNew);
		hr = StringCchCatA(szNewFullPath, ARRAYSIZE(szNewFullPath), szNew);
                if (FAILED(hr))
                {
                    goto Error;
                }
	}

	// Now move
	CWRg ( MoveFileA(m_szTmp, szNewFullPath) );

	MultiByteToWideChar(CP_ACP, NULL, szNewFullPath, -1, m_wcsName, MAX_PATH);

	hr = S_OK;
	
Error:
	if( bBusyStatusSet )
	{
		dwStatus &= (~(WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_MOVING ));
		SetGlobalDeviceStatus(m_wcsName, dwStatus, TRUE);
	}
	
	if( bProgressStarted )
	{
		pProgress->Progress( 100 );
		pProgress->End();
	}

    hrLogDWORD("IMDSPObject::Rename returned 0x%08lx", hr, hr);
	
	return hr;
}


STDMETHODIMP CMDSPStorage::EnumStorage(IMDSPEnumStorage * * ppEnumStorage)
{
	HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(ppEnumStorage);
	CONEg(m_wcsName[0]);

	DWORD dwAttrib;
    CORg(GetAttributes(&dwAttrib, NULL));
	if( dwAttrib & WMDM_FILE_ATTR_FILE )
	{
		return WMDM_E_NOTSUPPORTED;
	}
	
	CComObject<CMDSPEnumStorage> *pEnumObj;
	CORg(CComObject<CMDSPEnumStorage>::CreateInstance(&pEnumObj));
	hr = pEnumObj->QueryInterface(
		IID_IMDSPEnumStorage,
		reinterpret_cast<void**>(ppEnumStorage)
	);
	if( FAILED(hr) )
	{
		delete pEnumObj;
	}
	else 
	{
            // wcscpy(pEnumObj->m_wcsPath, m_wcsName);
            hr = StringCchCopyW(pEnumObj->m_wcsPath,
                                ARRAYSIZE(pEnumObj->m_wcsPath), m_wcsName);
            if (FAILED(hr))
            {
                (*ppEnumStorage)->Release();
                *ppEnumStorage = NULL;
            }
	}

Error:	

    hrLogDWORD("IMDSPStorage::EnumStorage returned 0x%08lx", hr, hr);
	
	return hr;
}

STDMETHODIMP CMDSPStorage::Close()
{
    HRESULT hr = S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CONEg(m_wcsName[0]);
	if( m_hFile != INVALID_HANDLE_VALUE ) 
	{
		CloseHandle(m_hFile);
		m_hFile=INVALID_HANDLE_VALUE;
	}

Error:

    hrLogDWORD("IMDSPObject::Close returned 0x%08lx", hr, hr);
	
	return hr;
}

DWORD MoveFunc( void *args )
{
	HRESULT  hr = S_OK;
	MOVETHREADARGS *pCMArgs;
    WCHAR   *pWcs;
	CHAR     szDst[MAX_PATH];
	CHAR     szSrc[MAX_PATH];

	pCMArgs = (MOVETHREADARGS *)args;

	if( pCMArgs->bNewThread )
    {
		CORg(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED));

		if( pCMArgs->pProgress )
		{
			CORg(CoGetInterfaceAndReleaseStream(
				pCMArgs->pStream,
				IID_IWMDMProgress,
				(LPVOID *)&(pCMArgs->pProgress))
			);
		}
 	}

	pWcs = wcsrchr(pCMArgs->wcsSrc, 0x5c);
    if(!pWcs) 
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
		goto Error;
	}
        DWORD dwDestLen = wcslen(pCMArgs->wcsDst);
        if (dwDestLen == 0)
        {
            // Code below assumes this string is at least one long
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            goto Error;
        }

        // Validate buffer sizes before the string copies
        int nHave = ARRAYSIZE(pCMArgs->wcsDst) - 1; // -1 for NULL terminator
        nHave -= dwDestLen;
        if( pCMArgs->wcsDst[dwDestLen-1] != 0x5c )
        {
            nHave -= BACKSLASH_STRING_LENGTH;
        }
        nHave -= wcslen(pWcs+1);
        if (nHave < 0)
        {
            hr = STRSAFE_E_INSUFFICIENT_BUFFER; // defined in strsafe.h
            goto Error;
        }

        // Validate the buffer size of pCMArgs->pThis->m_wcsName before
        // calling UtilMoveFile. ARRAYSIZE(pCMArgs->wcsDst) - nHave is
        // the length of the string (including the NULL terminator)
        // that will be constructed in pCMArgs->wcsDst and copied over to
        // pCMArgs->pThis->m_wcsName
        if (ARRAYSIZE(pCMArgs->wcsDst) - nHave > ARRAYSIZE(pCMArgs->pThis->m_wcsName))
        {
            hr = STRSAFE_E_INSUFFICIENT_BUFFER; // defined in strsafe.h
            goto Error;
        }

	if( pCMArgs->wcsDst[dwDestLen-1] != 0x5c ) 
	{
		wcscat(pCMArgs->wcsDst,g_wcsBackslash);
	}
	wcscat(pCMArgs->wcsDst, pWcs+1);

	WideCharToMultiByte(CP_ACP, NULL, pCMArgs->wcsDst, -1, szDst, MAX_PATH, NULL, NULL);	
	WideCharToMultiByte(CP_ACP, NULL, pCMArgs->wcsSrc, -1, szSrc, MAX_PATH, NULL, NULL);	

	CWRg( MoveFileA(szSrc,szDst) );

	// Substitute current object name with the moved one
	wcscpy(pCMArgs->pThis->m_wcsName, pCMArgs->wcsDst);

	hr = S_OK;

Error:

	if( pCMArgs->bNewThread )
    {
		// Reset status, we've got here we must have set the status busy before
		pCMArgs->dwStatus &= (~(WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_MOVING));
		SetGlobalDeviceStatus(pCMArgs->wcsSrc, pCMArgs->dwStatus, TRUE);

		// Reset progress, we've got here we must have set the progress before
		if( pCMArgs->pProgress )
		{
			pCMArgs->pProgress->Progress(100);
			pCMArgs->pProgress->End();
			pCMArgs->pProgress->Release(); // since we did AddRef to get here
		}

		if( pCMArgs )
		{
			delete pCMArgs;
		}

		CoUninitialize();
	}

 	return hr;
}

STDMETHODIMP CMDSPStorage::Move(UINT fuMode, IWMDMProgress *pProgress, 
			IMDSPStorage *pTarget)
{
	HRESULT  hr               = E_FAIL;
	WCHAR   *wcsSrc           = NULL;
	WCHAR   *wcsDst           = NULL;
	WCHAR    wcsTmp[MAX_PATH];
	WCHAR   *pWcs             = NULL;
    CMDSPStorage   *pStg      = NULL;
    MOVETHREADARGS *pMoveArgs = NULL;
    DWORD    dwThreadID;
	DWORD    dwStatus         = NULL;
    BOOL     bProgStarted     = FALSE;
	BOOL     bBusyStatusSet   = FALSE;
    BOOL     bThreadFailed    = TRUE;
    BOOL     bAddRefed        = FALSE;

	// Start the progress
	if( pProgress )
	{
		CORg(pProgress->Begin(100));
		bProgStarted=TRUE;
    }
	
    CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CONEg(m_wcsName[0]);

	CHRg(GetGlobalDeviceStatus(m_wcsName, &dwStatus));

	if( dwStatus & WMDM_STATUS_BUSY )
	{
		hr = WMDM_E_BUSY;
		goto Error;
	}

	pMoveArgs = new MOVETHREADARGS;
	CPRg(pMoveArgs);
	ZeroMemory(pMoveArgs, sizeof(MOVETHREADARGS));

	dwStatus |= (WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_MOVING );
    CHRg(SetGlobalDeviceStatus(m_wcsName, dwStatus, TRUE));
    bBusyStatusSet = TRUE;

	// setup MoveArgs for MoveFunc
	pMoveArgs->dwStatus = dwStatus;
	CARg(pTarget);
	pStg = (CMDSPStorage *)pTarget;
	wcsSrc = (WCHAR *)&(pMoveArgs->wcsSrc[0]);
	CPRg(wcsSrc);
	wcsDst = (WCHAR *)&(pMoveArgs->wcsDst[0]);
    CPRg(wcsDst);

	// Make sure the source and destination are on the same device
        hr = wcsParseDeviceName(m_wcsName, wcsSrc, ARRAYSIZE(pMoveArgs->wcsSrc));
        if (FAILED(hr))
        {
            goto Error;
        }
        hr = wcsParseDeviceName(pStg->m_wcsName, wcsDst, ARRAYSIZE(pMoveArgs->wcsDst));
        if (FAILED(hr))
        {
            goto Error;
        }
	if( wcscmp(wcsSrc, wcsDst) )
	{
		hr = WMDM_E_NOTSUPPORTED; // do not support move out of the same device
		goto Error;
	}

    // Now check for target's attributes
	DWORD dwDstAttrib, dwSrcAttrib;
    CHRg(GetAttributes(&dwSrcAttrib, NULL));

	// wcscpy(wcsSrc, m_wcsName);
        hr = StringCchCopyW(wcsSrc, ARRAYSIZE(pMoveArgs->wcsSrc), m_wcsName);
        if (FAILED(hr))
        {
            goto Error;
        }

        // wcscpy(wcsDst, pStg->m_wcsName);
        hr = StringCchCopyW(wcsDst, ARRAYSIZE(pMoveArgs->wcsDst), pStg->m_wcsName);
        if (FAILED(hr))
        {
            goto Error;
        }

	if ( fuMode & WMDM_STORAGECONTROL_INSERTINTO )
	{
        CHRg(pTarget->GetAttributes(&dwDstAttrib, NULL));
        CARg( dwDstAttrib & WMDM_FILE_ATTR_FOLDER ); // INSERTINFO must be to a folder
	}
	else
	{
        // Get the folder one level up
		pWcs = wcsrchr(wcsDst, 0x5c);
        CFRg(pWcs);
		*pWcs=NULL;

		WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, m_szTmp, MAX_PATH, NULL, NULL);	
        DWORD dwAttribs = GetFileAttributesA(m_szTmp);
        if (dwAttribs == INVALID_FILE_ATTRIBUTES)
        {
            goto Error;
        }
        CWRg( FILE_ATTRIBUTE_DIRECTORY & dwAttribs );
	}
 
	wcscpy(wcsTmp, wcsDst); // Store the destination folder

    pMoveArgs->pThis = this;
	pMoveArgs->bNewThread =(fuMode & WMDM_MODE_THREAD)?TRUE:FALSE;
	
	// Now handle Progress marshaling 
	if( pProgress ) 
	{	
		pMoveArgs->pProgress = pProgress;
	    pProgress->AddRef();  // since we are going to use it in MoveFunc()
        bAddRefed=TRUE;

		if( pMoveArgs->bNewThread )
		{
			CORg(CoMarshalInterThreadInterfaceInStream(
				IID_IWMDMProgress,
				(LPUNKNOWN)pProgress, 
				(LPSTREAM *)&(pMoveArgs->pStream))
			);
		} 
	}
 
    if ( m_hFile != INVALID_HANDLE_VALUE ) 
	{
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}

	if( fuMode & WMDM_MODE_BLOCK )
	{
		hr = MoveFunc((void *)pMoveArgs); 
	}
	else if ( fuMode & WMDM_MODE_THREAD )
	{
		if( CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)MoveFunc, 
			(void *)pMoveArgs, 0, &dwThreadID))
		{
			bThreadFailed=FALSE;
			hr = S_OK;
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());			
		}
	}
	else 
	{
		hr = E_INVALIDARG;
	}

Error:

	if( (fuMode&WMDM_MODE_BLOCK) || bThreadFailed ) // otherwise these will be in MoveFunc()
	{
		if( bBusyStatusSet )
		{
			dwStatus &= (~(WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_MOVING));
			SetGlobalDeviceStatus(m_wcsName, dwStatus, TRUE);
		}
		if( bProgStarted )
		{
			pProgress->Progress(100);
			pProgress->End();
        }
		if( bAddRefed )
		{
			pProgress->Release(); // since we called AddRef before calling MoveFunc()
		}
		if( pMoveArgs )
		{
			delete pMoveArgs;
		}
	}

    hrLogDWORD("IMDSPObject::Move returned 0x%08lx", hr, hr);
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\mdspstorage.h ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 


// MDSPStorage.h : Declaration of the CMDSPStorage

#ifndef __MDSPSTORAGE_H_
#define __MDSPSTORAGE_H_

/////////////////////////////////////////////////////////////////////////////
// CMDSPStorage
class ATL_NO_VTABLE CMDSPStorage : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMDSPStorage, &CLSID_MDSPStorage>,
	public IMDSPStorage2, IMDSPObjectInfo, IMDSPObject
{
public:
	CMDSPStorage();
    ~CMDSPStorage();

DECLARE_REGISTRY_RESOURCEID(IDR_MDSPSTORAGE)

BEGIN_COM_MAP(CMDSPStorage)
	COM_INTERFACE_ENTRY(IMDSPStorage)
	COM_INTERFACE_ENTRY(IMDSPStorage2)
	COM_INTERFACE_ENTRY(IMDSPObjectInfo)
	COM_INTERFACE_ENTRY(IMDSPObject)
END_COM_MAP()

// IMDSPStorage
public:
	WCHAR m_wcsName[MAX_PATH];
	char  m_szTmp[MAX_PATH];
	HANDLE	m_hFile;
	STDMETHOD(SetAttributes)(/*[out]*/ DWORD dwAttributes,/*[in]*/ _WAVEFORMATEX *pFormat);
	STDMETHOD(EnumStorage)(/*[out]*/ IMDSPEnumStorage **ppEnumStorage);
	STDMETHOD(CreateStorage)(/*[in]*/ DWORD dwAttributes, /*[in]*/ _WAVEFORMATEX *pFormat, /*[in]*/ LPWSTR pwszName, /*[out]*/ IMDSPStorage **ppNewStorage);
    STDMETHOD(GetRights)(PWMDMRIGHTS *ppRights, UINT *pnRightsCount, /*[in, out]*/BYTE abMac[WMDM_MAC_LENGTH]);
	STDMETHOD(GetSize)(/*[out]*/ DWORD *pdwSizeLow, /*[out]*/ DWORD *pdwSizeHigh);
	STDMETHOD(GetDate)(PWMDMDATETIME pDateTimeUTC);
	STDMETHOD(GetName)(/*[out,string,size_is(nMaxChars)]*/ LPWSTR pwszName, /*[in]*/ UINT nMaxChars);
	STDMETHOD(GetAttributes)(/*[out]*/ DWORD *pdwAttributes, /*[out]*/ _WAVEFORMATEX *pFormat);
	STDMETHOD(GetStorageGlobals)(/*[out]*/ IMDSPStorageGlobals **ppStorageGlobals);
    STDMETHOD(SendOpaqueCommand)(OPAQUECOMMAND *pCommand);

// IMDSPStorage2
	STDMETHOD(GetStorage)( LPCWSTR pszStorageName, IMDSPStorage** ppStorage );
 
    STDMETHOD(CreateStorage2)(  DWORD dwAttributes,
						        DWORD dwAttributesEx,
                                _WAVEFORMATEX *pAudioFormat,
                                _VIDEOINFOHEADER *pVideoFormat,
                                LPWSTR pwszName,
						        ULONGLONG  qwFileSize,
                                IMDSPStorage **ppNewStorage);


    STDMETHOD(SetAttributes2)(  DWORD dwAttributes, 
							    DWORD dwAttributesEx, 
						        _WAVEFORMATEX *pAudioFormat,
							    _VIDEOINFOHEADER* pVideoFormat );
    STDMETHOD(GetAttributes2)(  DWORD *pdwAttributes,
							    DWORD *pdwAttributesEx,
                                _WAVEFORMATEX *pAudioFormat,
							    _VIDEOINFOHEADER* pVideoFormat );
    
// IMDSPObjectInfo
	STDMETHOD(GetPlayLength)(/*[out]*/ DWORD *pdwLength);
	STDMETHOD(SetPlayLength)(/*[in]*/ DWORD dwLength);
	STDMETHOD(GetPlayOffset)(/*[out]*/ DWORD *pdwOffset);
	STDMETHOD(SetPlayOffset)(/*[in]*/ DWORD dwOffset);
	STDMETHOD(GetTotalLength)(/*[out]*/ DWORD *pdwLength);
	STDMETHOD(GetLastPlayPosition)(/*[out]*/ DWORD *pdwLastPos);
	STDMETHOD(GetLongestPlayPosition)(/*[out]*/ DWORD *pdwLongestPos);
// IMDSPObject
	STDMETHOD(Open)(/*[in]*/ UINT fuMode);
	STDMETHOD(Read)(/*[out,size_is(*pdwSize)]*/ BYTE *pData, /*[in,out]*/ DWORD *pdwSize, /*[in, out]*/BYTE abMac[WMDM_MAC_LENGTH]);
	STDMETHOD(Write)(/*[in, size_is(dwSize)]*/ BYTE *pData, /*[in]*/ DWORD *pdwSize, /*[in, out]*/BYTE abMac[WMDM_MAC_LENGTH]);
	STDMETHOD(Delete)(/* [in] */ UINT fuMode, /*[in]*/ IWMDMProgress *pProgress);
	STDMETHOD(Seek)(/*[in]*/ UINT fuFlags, /*[in]*/ DWORD dwOffset);
	STDMETHOD(Rename)(/*[in]*/ LPWSTR pwszNewName, /*[in]*/ IWMDMProgress *pProgress);
    STDMETHOD(Move)(/*[in]*/ UINT fuMode, /*[in]*/ IWMDMProgress *pProgress, /*[in]*/ IMDSPStorage *pTarget);
	STDMETHOD(Close)();
};

#endif //__MDSPSTORAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\verinfo.h ===
#ifndef _MAC
/////////////////////////////////////////////////////////////////////////////
//
// Version
//


#include <wmdm_ver.h>
    
#define VER_WMDM_FILE_FILETYPE                VFT_DLL
#define VER_WMDM_FILE_FILEDESCRIPTION_STR     "WMDM Sample SP for Hard Drives\0"
#define VER_WMDM_FILE_INTERNALNAME_STR        "MsHDSP.DLL\0"
#define VER_WMDM_FILE_OLEREGISTER
#include <wmdm_ver.ver>


#endif    // !_MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\proppage.cpp ===
// PropPage.cpp : Implementation of CPropPage
#include "hdspPCH.h"
#include "MsHDSP.h"
#include "PropPage.h"

/////////////////////////////////////////////////////////////////////////////
// CPropPage

HRESULT CPropPage::Activate(HWND hWndParent, LPCRECT pRect, BOOL bModal )
{
    HRESULT hr;
    IMDSPDevice* pIDevice = NULL;
    UINT uIndex;
    

    // Call the base class implementation
    CORg( IPropertyPageImpl<CPropPage>::Activate( hWndParent, pRect, bModal ) );

    // Get the IDevice interface that we passed out of GetSpecifyPropertyPages
    for( uIndex = 0; uIndex < m_nObjects; uIndex ++ )
    {
        hr = m_ppUnk[uIndex]->QueryInterface( &pIDevice );
        if( SUCCEEDED(hr) ) break;
    }
    if( !pIDevice ) return E_UNEXPECTED;

    // GetUserDefaultLCID() can be used to figure out what language 
    // the page should be displayed in
    
    // Update property page
    CORg( UpdateManufacturer( pIDevice ) );
    CORg( UpdateDeviceType( pIDevice  ) );
    CORg( UpdatePowerSource( pIDevice ) );
    CORg( UpdateStatus( pIDevice ) );

Error:
    if( pIDevice ) pIDevice->Release();

    return hr;
}

// Update manufacturer value
HRESULT CPropPage::UpdateManufacturer( IMDSPDevice* pIDevice )
{
    HRESULT hr;
    WCHAR   pwszWBuffer[MAX_PATH];
    CHAR   pszCBuffer[MAX_PATH];

    CORg( pIDevice->GetManufacturer( pwszWBuffer, MAX_PATH ) );
    WideCharToMultiByte(CP_ACP, NULL, pwszWBuffer, -1, pszCBuffer, MAX_PATH, NULL, NULL);	
    SetDlgItemText( IDC_MANUFACTURER, pszCBuffer );
Error:
    return hr;
}

// Update device type value
HRESULT CPropPage::UpdateDeviceType( IMDSPDevice* pIDevice  )
{
    HRESULT hr = S_OK;
    char    pszType[MAX_PATH];
    DWORD   dwType;
    int iIndex; 

    static SType_String sDeviceTypeStringArray[] = {
        { WMDM_DEVICE_TYPE_PLAYBACK, "Playback" },
        { WMDM_DEVICE_TYPE_RECORD,   "Record" },
        { WMDM_DEVICE_TYPE_DECODE,   "Decode" },
        { WMDM_DEVICE_TYPE_ENCODE,   "Encode" },
        { WMDM_DEVICE_TYPE_STORAGE,  "Storage" },
        { WMDM_DEVICE_TYPE_VIRTUAL,  "Virtual" },
        { WMDM_DEVICE_TYPE_SDMI,     "Sdmi" },
        { WMDM_DEVICE_TYPE_NONSDMI,  "non-sdmi" },
        { 0, NULL },
    };
    
    CORg( pIDevice->GetType( &dwType ) );

    // Add all the types reported by the device to the string.
    pszType[0] = '\0';
    for( iIndex = 0; sDeviceTypeStringArray[iIndex].dwType != 0; iIndex++ )
    {
        // Is this bit set, if it is then add the type as a string
        if( sDeviceTypeStringArray[iIndex].dwType & dwType )
        {
            if( strlen(pszType) )
            {
                strcat( pszType, ", " );
            }
            strcat( pszType, sDeviceTypeStringArray[iIndex].pszString );
        }
    }

    SetDlgItemText( IDC_DEVICE_TYPE, ((strlen(pszType)) ? pszType : "<none>") );

Error:
    return hr;
}

// Update device status property in device dialog box
HRESULT CPropPage::UpdatePowerSource( IMDSPDevice* pIDevice )
{
    HRESULT hr = S_OK;
    char    pszPowerSource[MAX_PATH];
    char    pszPowerIs[MAX_PATH];
    DWORD   dwPowerSource;
    DWORD   dwPercentRemaining;

    CORg( pIDevice->GetPowerSource( &dwPowerSource, &dwPercentRemaining ) ); 

    // Update capabileties
    if( (dwPowerSource & WMDM_POWER_CAP_BATTERY) &&
        (dwPowerSource & WMDM_POWER_CAP_EXTERNAL) )
    {
        SetDlgItemText( IDC_POWER_CAP, "Batteries and external");
    }
    else if(dwPowerSource & WMDM_POWER_CAP_BATTERY)
    {
        SetDlgItemText( IDC_POWER_CAP, "Batteries");
    }
    else if(dwPowerSource & WMDM_POWER_CAP_EXTERNAL)
    {
        SetDlgItemText( IDC_POWER_CAP, "External");
    }
    else
    {
        SetDlgItemText( IDC_POWER_CAP, "<non reported>");
    }

    // Update current power source string
    if( (dwPowerSource & WMDM_POWER_CAP_BATTERY) &&
        (dwPowerSource & WMDM_POWER_CAP_EXTERNAL) )
    {
        strcpy( pszPowerSource, "Batteries and external");
    }
    else if( dwPowerSource & WMDM_POWER_CAP_BATTERY)
    {
        strcpy( pszPowerSource,  "Batteries");
    }
    else if(dwPowerSource & WMDM_POWER_CAP_EXTERNAL)
    {
        strcpy( pszPowerSource,  "External");
    }
    else
    {
        strcpy( pszPowerSource,  "<none reported>");
    }
    
    wsprintf( pszPowerIs, "%s (%d%% remaining)", pszPowerSource, dwPercentRemaining );
    SetDlgItemText( IDC_POWER_IS, pszPowerIs );

Error:
    return hr;
}

// Update status property 
HRESULT CPropPage::UpdateStatus( IMDSPDevice* pIDevice )
{
    HRESULT hr;
    char    pszStatus[350];
    DWORD   dwStatus;
    int     iIndex;

    static SType_String sDeviceTypeStringArray[] = {
        { WMDM_STATUS_READY                   , "Ready" },
        { WMDM_STATUS_BUSY                    , "Busy" },
        { WMDM_STATUS_DEVICE_NOTPRESENT       , "Device not present" },
        { WMDM_STATUS_STORAGE_NOTPRESENT      , "Storage not present" },
        { WMDM_STATUS_STORAGE_INITIALIZING    , "Storage initializing" },
        { WMDM_STATUS_STORAGE_BROKEN          , "Storage broken" },
        { WMDM_STATUS_STORAGE_NOTSUPPORTED    , "Storage not supported" },
        { WMDM_STATUS_STORAGE_UNFORMATTED     , "Storage unformatted" },
        { WMDM_STATUS_STORAGECONTROL_INSERTING, "Storagecontrol inserting" },
        { WMDM_STATUS_STORAGECONTROL_DELETING , "Storagecontrol deleting" },
        { WMDM_STATUS_STORAGECONTROL_MOVING   , "Storagecontrol moving" },
        { WMDM_STATUS_STORAGECONTROL_READING  , "Storagecontrol reading" },
        { 0, NULL },
    };

    CORg( pIDevice->GetStatus( &dwStatus ) );
    
    // Add all the types reported by the device to the string.
    pszStatus[0] = '\0';
    for( iIndex = 0; sDeviceTypeStringArray[iIndex].dwType != 0; iIndex++ )
    {
        // Is this bit set, if it is then add the status as a string
        if( sDeviceTypeStringArray[iIndex].dwType & dwStatus )
        {
            if( strlen(pszStatus) )
            {
                strcat( pszStatus, ", " );
            }
            strcat( pszStatus, sDeviceTypeStringArray[iIndex].pszString );
        }
    }

    SetDlgItemText( IDC_DEVICE_STATUS, ((strlen(pszStatus)) ? pszStatus : "<none>") );

Error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__896E7425_3851_11D3_AA54_00C04FD22F6C__INCLUDED_)
#define AFX_DLLDATAX_H__896E7425_3851_11D3_AA54_00C04FD22F6C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__896E7425_3851_11D3_AA54_00C04FD22F6C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\key.h ===
extern BYTE g_abPriv[4096];
extern BYTE g_abAppCert[100];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\proppage.h ===
// PropPage.h : Declaration of the CPropPage

#ifndef __PROPPAGE_H_
#define __PROPPAGE_H_

#include "resource.h"       // main symbols

EXTERN_C const CLSID CLSID_HDSPPropPage;

struct SType_String
{
    DWORD   dwType;
    char*   pszString;
};

/////////////////////////////////////////////////////////////////////////////
// CPropPage
class ATL_NO_VTABLE CPropPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPropPage, &CLSID_HDSPPropPage>,
	public IPropertyPageImpl<CPropPage>,
	public CDialogImpl<CPropPage>
{
public:
	CPropPage() 
	{
		m_dwTitleID = IDS_TITLEPropPage;
		m_dwHelpFileID = IDS_HELPFILEPropPage;
		m_dwDocStringID = IDS_DOCSTRINGPropPage;
	}

	enum {IDD = IDD_PROPPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_PROPPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPropPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CPropPage)
	CHAIN_MSG_MAP(IPropertyPageImpl<CPropPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    STDMETHOD(Activate)(HWND hWndParent, LPCRECT prc, BOOL bModal);

private:
    HRESULT UpdateManufacturer( IMDSPDevice* pIDevice );
    HRESULT UpdateDeviceType( IMDSPDevice* pIDevice  );
    HRESULT UpdatePowerSource( IMDSPDevice* pIDevice );
    HRESULT UpdateStatus( IMDSPDevice* pIDevice );

};

#endif //__PROPPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mshdsp\mdsputil.cpp ===
//
//  Microsoft Windows Media Technologies
//  Copyright (C) Microsoft Corporation, 1999 - 2001. All rights reserved.
//

// MSHDSP.DLL is a sample WMDM Service Provider(SP) that enumerates fixed drives.
// This sample shows you how to implement an SP according to the WMDM documentation.
// This sample uses fixed drives on your PC to emulate portable media, and 
// shows the relationship between different interfaces and objects. Each hard disk
// volume is enumerated as a device and directories and files are enumerated as 
// Storage objects under respective devices. You can copy non-SDMI compliant content
// to any device that this SP enumerates. To copy an SDMI compliant content to a 
// device, the device must be able to report a hardware embedded serial number. 
// Hard disks do not have such serial numbers.
//
// To build this SP, you are recommended to use the MSHDSP.DSP file under Microsoft
// Visual C++ 6.0 and run REGSVR32.EXE to register the resulting MSHDSP.DLL. You can
// then build the sample application from the WMDMAPP directory to see how it gets 
// loaded by the application. However, you need to obtain a certificate from 
// Microsoft to actually run this SP. This certificate would be in the KEY.C file 
// under the INCLUDE directory for one level up. 

//***************************************************************************
//
// Name: 		MDSPutil.cpp
//
// Description:	Utility functions for MDSP 
//
//***************************************************************************

#include "hdspPCH.h"
#include "wmsstd.h"
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

HRESULT __stdcall UtilGetSerialNumber(WCHAR *wcsDeviceName, PWMDMID pSerialNumber, BOOL fCreate)
{
/*
	// TO TEST RETURNING A SERIAL NUMBER, UNCOMMENT THIS SECTION.
	//
	if( 1 )
	{
		BYTE DEF_HDID[20] = {
                0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
                0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39};

		pSerialNumber->dwVendorID = 0xFFFF;
		memcpy( (pSerialNumber->pID), DEF_HDID, sizeof(DEF_HDID) );
		pSerialNumber->SerialNumberLength = 20;
		return S_OK;
	}
	else 
*/
	{
		return WMDM_E_NOTSUPPORTED;
	}
}

UINT __stdcall UtilGetDriveType(LPSTR szDL)
{
    return GetDriveType( szDL );
}

HRESULT __stdcall UtilGetManufacturer(LPWSTR pDeviceName, LPWSTR *ppwszName, UINT nMaxChars)
{
    static const WCHAR* wszUnknown = L"Unknown";

    if (nMaxChars > wcslen(wszUnknown))
    {
	wcscpy( *ppwszName, wszUnknown);
	return S_OK;
    }
    else
    {
        return STRSAFE_E_INSUFFICIENT_BUFFER; // defined in strsafe.h
    }
}


HRESULT wcsParseDeviceName(WCHAR *wcsIn, WCHAR *wcsOut, DWORD dwOutBufSizeInChars)
{
    WCHAR wcsTmp[MAX_PATH], *pWcs;
    HRESULT hr;

    hr = StringCchCopyW(wcsTmp, ARRAYSIZE(wcsTmp), wcsIn);
    if (FAILED(hr))
    {
        return hr;
    }

    pWcs = wcschr(wcsTmp, 0x5c);

    if( pWcs ) *pWcs=0;

    if (wcslen(wcsTmp) < dwOutBufSizeInChars)
    {
        wcscpy(wcsOut, wcsTmp);
    }
    else
    {
        return STRSAFE_E_INSUFFICIENT_BUFFER; // defined in strsafe.h
    }
    return S_OK;
}

HRESULT GetFileSizeRecursive(char *szPath, DWORD *pdwSizeLow, DWORD *pdwSizeHigh)
{
	HRESULT hr         = S_OK;
    HANDLE  hFile      = INVALID_HANDLE_VALUE;
	HANDLE  hFindFile  = INVALID_HANDLE_VALUE;
    DWORD   dwSizeLow  = 0;
	DWORD   dwSizeHigh = 0;
    WIN32_FIND_DATAA fd;
    char szLP[MAX_PATH+BACKSLASH_SZ_STRING_LENGTH+1];

	CARg( szPath );
	CARg( pdwSizeLow );
	CARg( pdwSizeHigh ); 
        CARg(szPath[0]);

	// strcpy( szLP, szPath );
        hr = StringCchCopyA(szLP, ARRAYSIZE(szLP)-BACKSLASH_SZ_STRING_LENGTH-1, szPath);
        if (FAILED(hr))
        {
            goto Error;
        }

        DWORD dwAttrib = GetFileAttributesA(szPath);
        if (dwAttrib == INVALID_FILE_ATTRIBUTES)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Error;
        }

    if( FILE_ATTRIBUTE_DIRECTORY & dwAttrib )
	{	
		if( szLP[strlen(szLP)-1] != 0x5c )
		{
			strcat(szLP, g_szBackslash);
		}
		strcat(szLP, "*");

		hFindFile = FindFirstFileA(szLP, &fd);
        if( hFindFile != INVALID_HANDLE_VALUE )
		{
			if( strcmp(fd.cFileName, ".") && strcmp(fd.cFileName, "..") )
			{
				szLP[strlen(szLP)-1] = 0; // erase the '*'
				// strcat(szLP, fd.cFileName);
                                CORg(StringCchCatA(szLP, ARRAYSIZE(szLP), fd.cFileName));
				CORg(GetFileSizeRecursive(szLP, pdwSizeLow, pdwSizeHigh));
			}
			
			while ( FindNextFileA(hFindFile, &fd) ) 
			{
				if( strcmp(fd.cFileName, ".") && strcmp(fd.cFileName, "..") )
				{
					strcpy(szLP, szPath);
					if( szLP[strlen(szLP)-1] != 0x5c )
					{
						strcat(szLP, g_szBackslash);
					}
					// strcat(szLP, fd.cFileName);
                                        CORg(StringCchCatA(szLP, ARRAYSIZE(szLP), fd.cFileName));
					CORg(GetFileSizeRecursive(szLP, pdwSizeLow, pdwSizeHigh));
				}
			} 
			hr = GetLastError();
			if( hr == ERROR_NO_MORE_FILES )
			{
				hr = S_OK; 
			}
			else
			{
				hr = HRESULT_FROM_WIN32(hr);
			}
		}	    	
	}
	else
	{
		hFile = CreateFileA(
			szPath,
			GENERIC_READ,
			FILE_SHARE_READ | FILE_SHARE_WRITE,
			NULL,
			OPEN_EXISTING,
			0,
			NULL
		);
	    CWRg(hFile != INVALID_HANDLE_VALUE); 

	 	dwSizeLow = GetFileSize(hFile, &dwSizeHigh);
                if (dwSizeLow == INVALID_FILE_SIZE)
                {
                    DWORD dwLastError = GetLastError();
                    if (dwLastError != NO_ERROR)
                    {
                        hr = HRESULT_FROM_WIN32(dwLastError);
                        CloseHandle(hFile);
                        goto Error;
                    }
                }
                CloseHandle(hFile);
                unsigned _int64 u64Size = ((unsigned _int64) dwSizeHigh << 32) |
 dwSizeLow;
                u64Size += *pdwSizeLow | ((unsigned _int64) (*pdwSizeHigh) << 32
);
                *pdwSizeLow = (DWORD) (u64Size & 0xFFFFFFFF);
                *pdwSizeHigh = (DWORD) (u64Size >> 32);


		hr = S_OK;
    }

Error:

	if( hFindFile != INVALID_HANDLE_VALUE )
	{
		FindClose(hFindFile);
	}

	return hr;
}

HRESULT DeleteFileRecursive(char *szPath)
{
	HRESULT hr=S_OK;
 
	CARg(szPath);
        CARg(szPath[0]);

        DWORD dwAttrib = GetFileAttributesA(szPath);
        if (dwAttrib == INVALID_FILE_ATTRIBUTES)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Error;
        }

        if( FILE_ATTRIBUTE_DIRECTORY & dwAttrib )
	{	
	    HANDLE hFindFile = INVALID_HANDLE_VALUE;
	    WIN32_FIND_DATAA fd;
		char szLP[MAX_PATH+BACKSLASH_SZ_STRING_LENGTH+1];
 
		// strcpy(szLP, szPath);
                hr = StringCchCopyA(szLP, ARRAYSIZE(szLP)-BACKSLASH_SZ_STRING_LENGTH-1, szPath);
                if (FAILED(hr))
                {
                    goto Error;
                }
		if( szLP[strlen(szLP)-1] != 0x5c )
		{
			strcat(szLP, g_szBackslash);
		}
		strcat(szLP, "*");

		hFindFile = FindFirstFileA(szLP, &fd);
        if ( hFindFile != INVALID_HANDLE_VALUE )
		{
			do {
				if( strcmp(fd.cFileName, ".") && strcmp(fd.cFileName, "..") )
				{
					strcpy(szLP, szPath);
					if( szLP[strlen(szLP)-1] != 0x5c )
					{
						strcat(szLP, g_szBackslash);
					}
					// strcat(szLP, fd.cFileName);
                                        hr = StringCchCatA(szLP, ARRAYSIZE(szLP), fd.cFileName);
                                        if (FAILED(hr))
                                        {
                                            FindClose(hFindFile);
                                            CHRg(hr);
                                        }
					// CHRg(DeleteFileRecursive(szLP)); 
                                        hr = DeleteFileRecursive(szLP);
                                        if (FAILED(hr))
                                        {
                                            FindClose(hFindFile);
                                            CHRg(hr);
                                        }
				}
			} while ( FindNextFileA(hFindFile, &fd) ) ;
	
			hr = GetLastError();
			FindClose(hFindFile);
		}
		else
		{
			hr = GetLastError();
		}
		    
		// Until here this dir should be empty
		if( hr == ERROR_NO_MORE_FILES )
		{
			CWRg(RemoveDirectory(szPath));
			hr = S_OK;
		}
		else
		{
			hr = HRESULT_FROM_WIN32(hr);
		}
	}
	else
	{
		CWRg( DeleteFileA(szPath) );
        }

Error:

	return hr;
}

HRESULT SetGlobalDeviceStatus(WCHAR *wcsNameIn, DWORD dwStat, BOOL bClear)
{
	HRESULT hr = S_OK;
	WCHAR   wcsName[32];
	WCHAR  *pWN;
	int     i;

    g_CriticalSection.Lock();

    CARg(wcsNameIn);

	pWN = &wcsName[0];
	HRESULT hrTemp = wcsParseDeviceName(wcsNameIn, pWN, ARRAYSIZE(wcsName));
        if (FAILED(hrTemp))
        {
            hr = hrTemp;
            goto Error;
        }

	// Search for existing entries to see if there is a match
	//
	for( i=0; i<MDSP_MAX_DEVICE_OBJ; i++ )
	{
		if( g_GlobalDeviceInfo[i].bValid )
		{
			if(!wcscmp(wcsName, g_GlobalDeviceInfo[i].wcsDevName) )
			{
				if( bClear )
				{
					g_GlobalDeviceInfo[i].dwStatus = dwStat;
				}
				else 
				{
					g_GlobalDeviceInfo[i].dwStatus |= dwStat;
				}

				break;  // a match has been found;
			}
		} 
	}

	if( !(i<MDSP_MAX_DEVICE_OBJ) ) // new entry
	{
		for(i=0; i<MDSP_MAX_DEVICE_OBJ; i++)
		{
			if( !(g_GlobalDeviceInfo[i].bValid) )  // found empty space
			{
				wcscpy(g_GlobalDeviceInfo[i].wcsDevName, wcsName);
				g_GlobalDeviceInfo[i].bValid = TRUE;
				g_GlobalDeviceInfo[i].dwStatus = dwStat;
				break;
			}
		}
	}

	if( i<MDSP_MAX_DEVICE_OBJ )
	{
		hr = S_OK;
	}
	else
	{
		hr = hrNoMem;
	}

Error:

	g_CriticalSection.Unlock();

	return hr;
}

HRESULT GetGlobalDeviceStatus(WCHAR *wcsNameIn, DWORD *pdwStat)
{
	HRESULT  hr = S_OK;
	WCHAR    wcsName[32];
	WCHAR   *pWN;
	int      i;

    CARg(wcsNameIn);

	pWN = &wcsName[0];
	hr = wcsParseDeviceName(wcsNameIn, pWN, ARRAYSIZE(wcsName));
        if (FAILED(hr))
        {
            goto Error;
        }

	// Search for existing entries to see if there is a match
	//
	for( i=0; i<MDSP_MAX_DEVICE_OBJ; i++ )
	{
		if( g_GlobalDeviceInfo[i].bValid )
		{
			if(!wcscmp(wcsName, g_GlobalDeviceInfo[i].wcsDevName) )
			{
				*pdwStat = g_GlobalDeviceInfo[i].dwStatus;

				break;  // a match has been found;
			}
		} 
	}

	if( i<MDSP_MAX_DEVICE_OBJ )
	{
		hr = S_OK;
	}
	else
	{
		hr = E_FAIL;
	}

Error:

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\loghelp.cpp ===
#include "stdafx.h"
#include "loghelp.h"
#include <wmdmlog_i.c>

BOOL fIsLoggingEnabled( VOID )
{
    HRESULT hr;
    IWMDMLogger *pLogger = NULL;
    static BOOL fChecked = FALSE;
    static BOOL fEnabled = FALSE;

    if( !fChecked )
    {
        fChecked = TRUE;

        hr = CoCreateInstance(CLSID_WMDMLogger, NULL, CLSCTX_INPROC_SERVER, IID_IWMDMLogger, (void**)&pLogger);
        if (FAILED(hr))
        {
            goto exit;
        }

        hr = pLogger->IsEnabled(&fEnabled);
        if (FAILED(hr))
        {
            goto exit;
        }
    }

exit:
    if( NULL != pLogger )
    {
        pLogger->Release();
        pLogger = NULL;
    }

    return fEnabled;
}

HRESULT hrLogString(LPSTR pszMessage, HRESULT hrSev)
{
    HRESULT hr;
    IWMDMLogger *pLogger = NULL;
    DWORD dwFlags = ( FAILED(hrSev) ? WMDM_LOG_SEV_ERROR : WMDM_LOG_SEV_INFO );

    if( !fIsLoggingEnabled() )
    {
        return S_FALSE;
    }

    hr = CoCreateInstance(CLSID_WMDMLogger, NULL, CLSCTX_INPROC_SERVER, IID_IWMDMLogger, (void**)&pLogger);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = pLogger->LogString(dwFlags, "MSPMSP", pszMessage);
    if (FAILED(hr))
    {
        goto exit;
    }

exit:
    if (pLogger)
        pLogger->Release();
    return hr;
}

HRESULT hrLogDWORD(LPSTR pszFormat, DWORD dwValue, HRESULT hrSev)
{
    HRESULT hr;
    IWMDMLogger *pLogger = NULL;
    DWORD dwFlags = ( FAILED(hrSev) ? WMDM_LOG_SEV_ERROR : WMDM_LOG_SEV_INFO );

    if( !fIsLoggingEnabled() )
    {
        return S_FALSE;
    }

    hr = CoCreateInstance(CLSID_WMDMLogger, NULL, CLSCTX_INPROC_SERVER, IID_IWMDMLogger, (void**)&pLogger);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = pLogger->LogDword(dwFlags, "MSPMSP", pszFormat, dwValue);
    if (FAILED(hr))
    {
        goto exit;
    }

exit:
    if (pLogger)
        pLogger->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\loghelp.h ===
#include "wmdmlog.h"

HRESULT hrLogString(LPSTR pszMessage, HRESULT hrSev);
HRESULT hrLogDWORD(LPSTR pszFormat, DWORD dwValue, HRESULT hrSev);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\key.cpp ===
#include "wtypes.h"
BYTE g_abPriv[4096] = {
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 
	0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 
	0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 
	0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 
	0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 
	0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 
	0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 
	0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 
	0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 
	0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 
	0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 
	0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 
	0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 
	0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 
	0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 
	0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 
	0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 
	0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 
	0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 
	0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 
	0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 
	0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 
	0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 
	0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 
	0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 
	0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 
	0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 
	0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 
	0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 
	0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 
	0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 
	0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 
	0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 
	0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 
	0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 
	0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 
	0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 
	0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 
	0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 
	0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 
	0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 
	0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 
	0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 
	0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 
	0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 
	0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 
	0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 
	0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 
	0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 
	0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 
	0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 
	0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 
	0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 
	0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 
	0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 
	0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 
	0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 
	0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 
	0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 
	0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 
	0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 
	0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 
	0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 
	0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 
	0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 
	0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 
	0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 
	0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 
	0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 
	0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 
	0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 
	0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 
	0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 
	0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 
	0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 
	0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 
	0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 
	0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 
	0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 
	0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 
	0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 
	0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 
	0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 
	0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 
	0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 
	0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 
	0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 
	0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x72, 0x22, 
	0xE2, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 
	0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 
	0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 
	0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 
	0x7A, 0x98, 0x51, 0x49, 0xC6, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x14, 0x48, 
	0xA0, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x26, 0x2D, 0xE5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x56, 0x3E, 0x1B, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 
	0x03, 0x59, 0x4E, 0x26, 0x98, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0x64, 0xFA, 
	0x9E, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x22, 0x81, 0xCD, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x58, 
	0x4C, 0x94, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x54, 0x8F, 0x03, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x0D, 0x37, 0x29, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x5E, 0x02, 0xFB, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0x7D, 0xC3, 0xCB, 0x22, 0x1A, 0x0A, 0xE5, 0x57, 
	0xCF, 0xCF, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x1A, 0x5D, 0x3B, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 
	0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 
	0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 
	0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 
	0x78, 0xDC, 0xD1, 0x9F, 0x07, 0xCD, 0xA4, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x65, 0x0A, 
	0x7E, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0x74, 0xDC, 0x89, 0x1A, 0x0A, 
	0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x70, 0x96, 0x49, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0x95, 0x32, 0x86, 0x72, 0x41, 0x37, 0xC8, 
	0xCB, 0x9D, 0x31, 0xBE, 0x6C, 0xF7, 0xB1, 0xCA, 
	0x62, 0xD4, 0x69, 0x37, 0x70, 0x8A, 0x87, 0x2F, 
	0x1D, 0xDA, 0x7D, 0x58, 0x8A, 0x7D, 0x9F, 0xDC, 
	0xE2, 0x8E, 0xE3, 0x3A, 0x04, 0xF8, 0x54, 0xC1, 
	0x10, 0xBA, 0x97, 0xFE, 0xF0, 0x58, 0xEC, 0x3E, 
	0xB5, 0xBF, 0x06, 0x7C, 0xD0, 0x79, 0x58, 0x22, 
	0xB3, 0x3F, 0xED, 0xAA, 0x00, 0x29, 0x89, 0x9F, 
	0x7B, 0x0E, 0xD3, 0x49, 0x89, 0x79, 0x6D, 0x41, 
	0xCF, 0x30, 0x07, 0x23, 0x90, 0x96, 0xEF, 0xFF, 
	0x44, 0x9F, 0x61, 0xF5, 0x16, 0x31, 0x88, 0xD7, 
	0xDE, 0x5D, 0xE0, 0x8F, 0xE2, 0xA2, 0x9C, 0x8A, 
	0x97, 0xB8, 0x02, 0x93, 0x1E, 0xCD, 0xF0, 0x12, 
	0xFE, 0x87, 0x2A, 0x55, 0x6C, 0x9B, 0x0E, 0xAD, 
	0xA4, 0xEC, 0xA1, 0xD4, 0x84, 0xB6, 0x30, 0xFD, 
	0x93, 0x4F, 0x03, 0x34, 0x17, 0xE2, 0x71, 0x68, 
	0x44, 0xFD, 0xD0, 0x13, 0x25, 0x92, 0x61, 0x58, 
	0x7F, 0x55, 0xF6, 0x11, 0x67, 0xB7, 0x24, 0x6F, 
	0x50, 0x59, 0x77, 0x90, 0x1E, 0xFE, 0x26, 0x56, 
	0x9E, 0xCE, 0xEE, 0x16, 0xFA, 0x26, 0xEE, 0x6B, 
	0x3E, 0x05, 0xC4, 0x23, 0x76, 0x7D, 0x64, 0x7F, 
	0x5B, 0xBD, 0x7E, 0x4C, 0x65, 0xCF, 0xD7, 0x60, 
	0x0E, 0xCA, 0xBA, 0xAE, 0x1B, 0x0E, 0x15, 0xD5, 
	0x7E, 0x88, 0x28, 0x59, 0x68, 0x9F, 0xA1, 0x1C, 
	0x6E, 0x1A, 0xC2, 0x92, 0x6D, 0x7F, 0x90, 0x53, 
	0xFD, 0xD5, 0x42, 0x2A, 0x3B, 0xEE, 0x41, 0xD0, 
	0x2F, 0xA1, 0x89, 0x69, 0xE6, 0xF5, 0x7F, 0xC8, 
	0x4F, 0xB1, 0xBA, 0x09, 0xBF, 0xC3, 0x3B, 0x2B, 
	0x03, 0x8B, 0x5B, 0xF3, 0xE3, 0x30, 0xDB, 0xB7, 
	0x1D, 0xA9, 0xE0, 0xE2, 0x5B, 0x4A, 0x25, 0x11, 
	0xAF, 0x08, 0x23, 0x92, 0xF9, 0xC0, 0xBB, 0x76, 
	0xB8, 0x28, 0x38, 0xBB, 0x21, 0x40, 0x00, 0x14
};
BYTE g_abAppCert[100] = {
	0x00, 0x01, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
	0x1C, 0x0E, 0x62, 0xB6, 0x0B, 0xC7, 0x2D, 0xA5, 
	0x42, 0xBE, 0x9A, 0x79, 0x50, 0x70, 0x65, 0x77, 
	0xB7, 0x30, 0x9C, 0x84, 0xF5, 0xA4, 0x23, 0x04, 
	0xA9, 0x7D, 0xFD, 0x1B, 0xF3, 0x66, 0x9E, 0x1D, 
	0x8A, 0xF7, 0xC1, 0xA8, 0xBD, 0x3C, 0x78, 0x5B, 
	0x43, 0x03, 0xC9, 0x8E, 0xE7, 0xB5, 0xF5, 0x95, 
	0x2F, 0xEA, 0xB3, 0xF8, 0x89, 0xB7, 0x40, 0x5C, 
	0x1D, 0x9A, 0xF9, 0x4B, 0x3C, 0x4A, 0x20, 0xBD, 
	0xDF, 0x98, 0xD9, 0x49, 0xE7, 0x36, 0x66, 0x7F, 
	0xFF, 0x98, 0xC8, 0x42, 0xDC, 0x77, 0xED, 0x0D, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE8, 
	0x00, 0x00, 0x00, 0x05
};
//=======================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\mdserviceprovider.cpp ===
// MDServiceProvider.cpp : Implementation of CMDServiceProvider
#include "stdafx.h"
#include "MsPMSP.h"
#include "MDServiceProvider.h"
#include "MDSPEnumDevice.h"
#include "MdspDefs.h"
#include "loghelp.h"
#include "key.h"
#include "resource.h"
#include "serialnumber.h"
#include <WMDMUtil.h>

static const GUID g_DiskClassGuid = 
{ 0x4d36e967, 0xe325, 0x11ce, { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } };
HDEVNOTIFY g_hDevNotify=NULL;




LRESULT CALLBACK MDSPPnPproc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
	case WM_DEVICECHANGE:
		MDSPProcessDeviceChange(wParam, lParam);
		return 0;
    case WM_CREATE:
        return (DoRegisterDeviceInterface(hwnd, g_DiskClassGuid, &g_hDevNotify));
	case WM_DESTROY:
		PostQuitMessage(0);
		if( g_hDevNotify ) 
		   DoUnregisterDeviceInterface(g_hDevNotify);
		return 0L;
    default:
        return DefWindowProc(hwnd, message, wParam, lParam);
    } //end switch of messages passed to callback
}

DWORD MDSPThreadProc(LPVOID lpParam)
{
   	static char appname[]="PMSPPnPN";
   	MSG message;
   	WNDCLASSEX windowclass;
    HWND hWnd;

   	windowclass.style = CS_HREDRAW | CS_VREDRAW;
    windowclass.lpfnWndProc = MDSPPnPproc;
   	windowclass.cbClsExtra = 0;
   	windowclass.cbWndExtra = 0;
   	windowclass.cbSize = sizeof(WNDCLASSEX);
   	windowclass.hInstance = g_hinstance;   
   	windowclass.hIcon = NULL; // LoadIcon(NULL, IDI_APPLICATION);
   	windowclass.hIconSm= NULL; // LoadIcon(NULL, IDI_APPLICATION);
   	windowclass.hCursor = NULL; // LoadCursor(NULL, IDC_ARROW);
   	windowclass.hbrBackground=(HBRUSH) GetStockObject(WHITE_BRUSH);
   	windowclass.lpszMenuName=NULL;
   	windowclass.lpszClassName=appname;

   	RegisterClassEx(&windowclass);

   	hWnd = CreateWindow (appname, "PMSP PnP Notify",
                   WS_OVERLAPPEDWINDOW,
                   CW_USEDEFAULT,
                   CW_USEDEFAULT,
                   CW_USEDEFAULT,
                   CW_USEDEFAULT,
                   NULL, NULL, g_hinstance, NULL);

   	// ShowWindow(hWnd, SW_SHOWNORMAL);
   	UpdateWindow(hWnd);

   	while(GetMessage(&message, NULL, 0,0))
   	{
        TranslateMessage(&message);     //get key events
        DispatchMessage(&message);
    }        
   	return (DWORD)message.wParam;        
}


/////////////////////////////////////////////////////////////////////////////
// CMDServiceProvider
CMDServiceProvider::~CMDServiceProvider()
{
	if( m_hThread )
		CloseHandle(m_hThread);
	if (g_pAppSCServer)
	{
		delete g_pAppSCServer;
		g_pAppSCServer = NULL;
	}

        // UtilStartStopService(false);
}

CMDServiceProvider::CMDServiceProvider()
{
//	HRESULT hr;
//Temporary: read start drive from Registry
#ifdef MDSP_TEMP
	HKEY hKey;
	DWORD dwType, dwSize=4;

	g_dwStartDrive=1;
	if( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, STR_MDSPREG,
		0, KEY_READ, &hKey))
    {
		RegQueryValueEx(hKey,"StartDrive",0, &dwType, (LPBYTE)&g_dwStartDrive, &dwSize);
		RegCloseKey(hKey);
	}
#else 
	g_dwStartDrive=0;
#endif

	g_pAppSCServer = new CSecureChannelServer();

	if (g_pAppSCServer)
	{
            /* Beta AppCert and PVK
                    const BYTE abPVK[] = {
                                    0x61, 0x21, 0xF8, 0xE5, 0x64, 0xD9, 0x69, 0x9A,
                                    0xC0, 0x3F, 0xC6, 0x1C, 0xF9, 0x6B, 0xFB, 0x4F,
                                    0x7A, 0x1D, 0x11, 0x6E
                    };

                    const BYTE pCert[] = {
                                    0x00, 0x01, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
                                    0x2D, 0x40, 0x51, 0x5B, 0xC6, 0x85, 0x6F, 0xF9,
                                    0x22, 0x2C, 0x60, 0x15, 0xE7, 0x15, 0xA8, 0x96,
                                    0x0F, 0xCC, 0xC8, 0x5D, 0x22, 0x64, 0x4C, 0xB8,
                                    0xC8, 0xD2, 0x7D, 0x0B, 0xAC, 0x71, 0x30, 0x7B,
                                    0xF9, 0x1C, 0x6C, 0xE6, 0xAD, 0xA1, 0x43, 0x87,
                                    0x38, 0x35, 0xA2, 0xAC, 0xA3, 0x84, 0x1B, 0x82,
                                    0xD5, 0xFA, 0xAE, 0xF2, 0xEA, 0x23, 0xA3, 0xE2,
                                    0x03, 0x71, 0x14, 0x5B, 0x01, 0x9A, 0x6A, 0x3A,
                                    0x00, 0x57, 0x89, 0xF3, 0x44, 0x20, 0xD7, 0x9F,
                                    0xDB, 0xDE, 0xE9, 0x14, 0x62, 0xB9, 0x2A, 0x49,
                                    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE8,
                                    0x00, 0x00, 0x00, 0x02
                    };
            */
            /*
            // RTM AppCert and PVK (Subject ID 5, AppSec 1000)
            const BYTE abPVK[] = {
                    0xB3, 0x2B, 0x3E, 0xE4, 0x01, 0x18, 0xCE, 0x7A,
                    0x91, 0x04, 0xB6, 0xE6, 0xC3, 0xF7, 0x30, 0x04,
                    0x3C, 0xAA, 0x67, 0x13
            };
            const BYTE pCert[] = {
                    0x00, 0x01, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
                    0x25, 0x8D, 0x2F, 0x88, 0x21, 0xA6, 0xC4, 0x8F,
                    0xE0, 0x01, 0x62, 0x88, 0x1D, 0x09, 0x1F, 0x5F,
                    0xDF, 0xC6, 0xA6, 0x42, 0xD9, 0x49, 0x7F, 0x86,
                    0x71, 0x3F, 0x5F, 0x39, 0x19, 0x0B, 0xA1, 0xDB,
                    0x27, 0x33, 0x68, 0x0B, 0x1B, 0x6E, 0x78, 0x0E,
                    0xEC, 0x8A, 0xBB, 0x35, 0xD1, 0x0A, 0x8D, 0x58,
                    0x24, 0x90, 0x8D, 0x71, 0x8F, 0x16, 0x5B, 0x64,
                    0x52, 0x7C, 0xB3, 0x38, 0xD6, 0x51, 0x1B, 0x60,
                    0xB0, 0x03, 0xD6, 0x04, 0x1A, 0xC9, 0x35, 0x4F,
                    0x9B, 0x3A, 0x45, 0xDA, 0x94, 0x11, 0x4F, 0x0D,
                    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE8,
                    0x00, 0x00, 0x00, 0x05
            };
            */
		g_pAppSCServer->SetCertificate(SAC_CERT_V1, (BYTE*)g_abAppCert, sizeof(g_abAppCert), (BYTE*)g_abPriv, sizeof(g_abPriv));
	}
	
	g_bIsWinNT=IsWinNT();

//----------------------------------------------------------
//	PnP Notification Code, removed for public beta release
//----------------------------------------------------------
//	m_hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)MDSPThreadProc, 
//		NULL, 0, &m_dwThreadID);
//	CWRg(m_hThread);
    m_hThread = NULL;
    
	g_CriticalSection.Lock();
	ZeroMemory(g_NotifyInfo, sizeof(MDSPNOTIFYINFO)*MDSP_MAX_DEVICE_OBJ);
	ZeroMemory(g_GlobalDeviceInfo, sizeof(MDSPGLOBALDEVICEINFO)*MDSP_MAX_DEVICE_OBJ);
    g_CriticalSection.Unlock();
//Error:

    //
    // This call starts the Wmdm PM service is required.
    // This is now done by the library on demand.
    // UtilStartStopService(true);
    return;
}

STDMETHODIMP CMDServiceProvider::GetDeviceCount(DWORD * pdwCount)
{
	HRESULT hr=E_FAIL;
	char str[8]="c:";

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
    
	CARg(pdwCount);

	int i, cnt;
	for(i=g_dwStartDrive, cnt=0; i<MDSP_MAX_DRIVE_COUNT; i++)
	{
		str[0] = 'A' + i;
		if( UtilGetDriveType(str) == DRIVE_REMOVABLE ) cnt ++;
	}
	*pdwCount = cnt;
	hr=S_OK;
Error:

    hrLogDWORD("IMDServiceProvider::GetDeviceCount returned 0x%08lx", hr, hr);

	return hr;
}


STDMETHODIMP CMDServiceProvider::EnumDevices(IMDSPEnumDevice * * ppEnumDevice)
{
	HRESULT hr=E_FAIL;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(ppEnumDevice);

	CComObject<CMDSPEnumDevice> *pEnumObj;

	hr=CComObject<CMDSPEnumDevice>::CreateInstance(&pEnumObj);

	if( SUCCEEDED(hr) )
	{
		hr=pEnumObj->QueryInterface(IID_IMDSPEnumDevice, reinterpret_cast<void**>(ppEnumDevice));
		if( FAILED(hr) )
			delete pEnumObj;
	}

Error:
    hrLogDWORD("IMDServiceProvider::EnumDevices returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDServiceProvider::SACAuth(DWORD dwProtocolID,
                              DWORD dwPass,
                              BYTE *pbDataIn,
                              DWORD dwDataInLen,
                              BYTE **ppbDataOut,
                              DWORD *pdwDataOutLen)
{
    HRESULT hr=E_FAIL;

    if (g_pAppSCServer)
        hr = g_pAppSCServer->SACAuth(dwProtocolID, dwPass, pbDataIn, dwDataInLen, ppbDataOut, pdwDataOutLen);
    else
        hr = E_FAIL;
    
// Error:
    hrLogDWORD("IComponentAuthenticate::SACAuth returned 0x%08lx", hr, hr);

    return hr;
}

STDMETHODIMP CMDServiceProvider::SACGetProtocols(DWORD **ppdwProtocols,
                                      DWORD *pdwProtocolCount)
{
    HRESULT hr=E_FAIL;

    if (g_pAppSCServer)
        hr = g_pAppSCServer->SACGetProtocols(ppdwProtocols, pdwProtocolCount);
    else
        hr = E_FAIL;

// Error:
    hrLogDWORD("IComponentAuthenticate::SACGetProtocols returned 0x%08lx", hr, hr);

    return hr;
}

// IMDSPRevoked
HRESULT CMDServiceProvider::GetRevocationURL( IN OUT LPWSTR* ppwszRevocationURL, 
                                              IN OUT DWORD*  pdwBufferLen )    
{
    HRESULT hr = S_OK;
    DWORD   pdwSubjectIDs[2];

    // Check arguments passed in
    if( ppwszRevocationURL == NULL || pdwBufferLen == NULL ) 
    {
        hr = E_POINTER;
        goto Error;
    }

    // Always use the MS site to update this SP.
    if( ::IsMicrosoftRevocationURL( *ppwszRevocationURL ) ) return S_OK;

    // Build a new URL from our subject ID
    pdwSubjectIDs[0] = ::GetSubjectIDFromAppCert( *(APPCERT*)g_abAppCert );
    pdwSubjectIDs[1] = 0;
    CORg( ::BuildRevocationURL( pdwSubjectIDs, ppwszRevocationURL, pdwBufferLen ) );

Error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\mdspdevice.cpp ===
// MDSPDevice.cpp : Implementation of CMDSPDevice
#include "stdafx.h"
#include "MsPMSP.h"
#include "MDSPDevice.h"
#include "MDSPEnumStorage.h"
#include "MDSPStorage.h"
#include "MdspDefs.h"
#include "SerialNumber.h"
#include "loghelp.h"
#include "wmsstd.h"
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

/////////////////////////////////////////////////////////////////////////////
// CMDSPDevice
HRESULT CMDSPDevice::InitGlobalDeviceInfo()
{
	return SetGlobalDeviceStatus(m_wcsName, 0, FALSE);
}

CMDSPDevice::CMDSPDevice()
{
    m_wcsName[0] = 0;
}

CMDSPDevice::~CMDSPDevice()
{	
//----------------------------------------------------------
//	PnP Notification Code, removed for public beta release
//----------------------------------------------------------
//  // Search for existing entries to see if there is a match
//  g_CriticalSection.Lock();
//	for(int i=0; i<MDSP_MAX_DEVICE_OBJ; i++)
//	{
//		// Release Notification connectors
//		if( g_NotifyInfo[i].bValid  &&
//			g_NotifyInfo[i].pDeviceObj == this ) // need to release
//		{
//			if( g_NotifyInfo[i].pIWMDMConnect )
//			{
//				//((IWMDMConnect *)(g_NotifyInfo[i].pIWMDMConnect))->Release();
//			}
//			g_NotifyInfo[i].bValid=FALSE;
//		}
//	}
//	g_CriticalSection.Unlock();
}

STDMETHODIMP CMDSPDevice::GetName(LPWSTR pwszName, UINT nMaxChars)
{
    USES_CONVERSION;
    HRESULT hr=E_FAIL;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pwszName);

	if( m_wcsName && m_wcsName[0] )
	{
        // WinNT
        if( IsWinNT() )
        {
            SHFILEINFOW sfiw = { 0 };
            WCHAR pswzRoot[MAX_PATH+1];	

            DWORD dwLen = wcslen(m_wcsName);

            // We reserve one char for the \ that PathAddBackslashW might
            // add
            if (dwLen >= ARRAYSIZE(pswzRoot)-1)
            {
                hr = STRSAFE_E_INSUFFICIENT_BUFFER; //defined in strsafe.h
                goto Error;
            }
            wcscpy(pswzRoot, m_wcsName );
            PathAddBackslashW(pswzRoot);

            // Try to get the shell name for this path
            if( SHGetFileInfoW( pswzRoot, FILE_ATTRIBUTE_DIRECTORY, &sfiw, sizeof(sfiw),
                                         SHGFI_USEFILEATTRIBUTES | SHGFI_DISPLAYNAME) )
            {
                CPRg( nMaxChars> wcslen(sfiw.szDisplayName));
                wcscpy(pwszName, sfiw.szDisplayName );
            }
            else
            {	
                // Use path name on failure
                CPRg( nMaxChars > wcslen(m_wcsName));
                wcscpy( pwszName, m_wcsName);
            }

        }
        // Win9x
        else
        {
            SHFILEINFO sfi = { 0 };
            CHAR pszRoot[MAX_PATH];	

            strcpy( pszRoot, W2A(m_wcsName) );
            PathAddBackslashA(pszRoot);

            // Try to get the shell name for this path
            if (SHGetFileInfoA( pszRoot, FILE_ATTRIBUTE_DIRECTORY, &sfi, sizeof(sfi),
                                SHGFI_USEFILEATTRIBUTES | SHGFI_DISPLAYNAME))
            {
                CPRg( nMaxChars> strlen(sfi.szDisplayName));
                wcscpy(pwszName, A2W(sfi.szDisplayName) );
            }
            else
            {	
                // Use path name on failure
                CPRg( nMaxChars > wcslen(m_wcsName));
                wcscpy( pwszName, m_wcsName);
            }
        }

	    hr = S_OK;
	} 
    else
    {
        hr = WMDM_E_NOTSUPPORTED;
    }
Error:

    hrLogDWORD("IMDSPDevice::GetName returned 0x%08lx", hr, hr);
	
    return hr;
}

STDMETHODIMP CMDSPDevice::GetManufacturer(LPWSTR pwszName, UINT nMaxChars)
{
	HRESULT hr=S_OK;
	
	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pwszName);
	
	if(FAILED(UtilGetManufacturer(m_wcsName, &pwszName, nMaxChars)))
		hr=E_NOTIMPL;

Error:   

    hrLogDWORD("IMDSPDevice::GetManufacturer returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetVersion(DWORD * pdwVersion)
{
    HRESULT hr;
    
	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:
    
	hrLogDWORD("IMDSPDevice::GetVersion returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetType(DWORD * pdwType)
{
	HRESULT hr=S_OK;
    WMDMID snTmp;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pdwType);

	*pdwType = WMDM_DEVICE_TYPE_STORAGE | WMDM_DEVICE_TYPE_NONSDMI;

	snTmp.cbSize = sizeof(WMDMID);
	hr = UtilGetSerialNumber(m_wcsName, &snTmp, FALSE);

	if( hr == S_OK )
	{
		*pdwType |= WMDM_DEVICE_TYPE_SDMI;
    }

	hr=S_OK;
Error:

    hrLogDWORD("IMDSPDevice::GetType returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetSerialNumber(PWMDMID pSerialNumber, 
										  BYTE abMac[WMDM_MAC_LENGTH])
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pSerialNumber);
//	CARg((pSerialNumber->cbSize)==sizeof(WMDMID));

	hr = UtilGetSerialNumber(m_wcsName, pSerialNumber, TRUE);

	if( hr == HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) )
	{
		hr = WMDM_E_NOTSUPPORTED;
	}

	if( hr == S_OK )
	{
		// MAC the parameters
		HMAC hMAC;
		
		CORg(g_pAppSCServer->MACInit(&hMAC));
		CORg(g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pSerialNumber), sizeof(WMDMID)));
		CORg(g_pAppSCServer->MACFinal(hMAC, abMac));
	}
Error:

    hrLogDWORD("IMDSPDevice::GetSerialNumber returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetPowerSource(DWORD * pdwPowerSource, DWORD * pdwPercentRemaining)
{
	HRESULT hr=S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pdwPowerSource);
	CARg(pdwPercentRemaining);

	*pdwPowerSource = WMDM_POWER_CAP_EXTERNAL | 
		WMDM_POWER_IS_EXTERNAL | WMDM_POWER_PERCENT_AVAILABLE;
	*pdwPercentRemaining = 100;

Error:

    hrLogDWORD("IMDSPDevice::GetPowerSource returned 0x%08lx", hr, hr);

	return hr;
}

BOOL IsDriveReady(int nDriveNum)
{
    DWORD dwRet=ERROR_SUCCESS;

	// Disable drive error popup
	UINT uPrevErrMode=SetErrorMode(SEM_FAILCRITICALERRORS|SEM_NOOPENFILEERRORBOX);

	char szDL[32]="A:\\D569CFEE41e6A522E8F5.jnk";
	szDL[0] += (char)nDriveNum;

	HANDLE hFile=CreateFile(
					  szDL,                 // file name
					  0,                    // access mode
					  0,                    // share mode
					  NULL,					// SD
					  OPEN_EXISTING,        // how to create
					  0,					// file attributes
					  NULL                  // handle to template file
					  );

	if( hFile == INVALID_HANDLE_VALUE )
	{
		dwRet=GetLastError();
    }
	else 
	{
		CloseHandle(hFile); // rare situation when such a file exists.
	}

	// Restore default system error handling
	SetErrorMode(uPrevErrMode);

	return (ERROR_FILE_NOT_FOUND==dwRet || ERROR_SUCCESS==dwRet);
}

STDMETHODIMP CMDSPDevice::GetStatus(DWORD * pdwStatus)
{
	HRESULT hr=S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pdwStatus);

	CHRg(GetGlobalDeviceStatus(m_wcsName, pdwStatus));

	if( !( *pdwStatus & WMDM_STATUS_BUSY) )
	{
		if( IsDriveReady((m_wcsName[0]>96)?(m_wcsName[0]-L'a'):(m_wcsName[0]-L'A')))
		{
			*pdwStatus = WMDM_STATUS_READY;
		}
		else
		{
			*pdwStatus = WMDM_STATUS_STORAGE_NOTPRESENT;
		}
	}
	hr=S_OK;
Error:

    hrLogDWORD("IMDSPDevice::GetStatus returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetDeviceIcon(ULONG *hIcon)
{
    USES_CONVERSION;
	HRESULT hr=S_OK;
    SHFILEINFO sfi = { 0 };
    TCHAR szRoot[MAX_PATH+1];	

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
    
    CARg(hIcon);
    
 
    if (!m_wcsName || !(m_wcsName[0]))
    {
        CORg(WMDM_E_NOTSUPPORTED);
    }

    DWORD dwLen = wcslen(m_wcsName);

    // We reserve one char for the \ that PathAddBackslash might add
    if (dwLen >= ARRAYSIZE(szRoot)-1)
    {
        hr = STRSAFE_E_INSUFFICIENT_BUFFER; //defined in strsafe.h
        goto Error;
    }

    _tcscpy(szRoot, W2T(m_wcsName));
    PathAddBackslash(szRoot);
    if (SHGetFileInfo(  szRoot, FILE_ATTRIBUTE_DIRECTORY, &sfi, sizeof(sfi),
                        SHGFI_USEFILEATTRIBUTES | SHGFI_ICONLOCATION ))
    {
        TCHAR pszFilePath[MAX_PATH];

        // Got the path of the file containing the HICON.
        // Load the icon as a shared resource so that the user can get to all different
        // sizes of the icon.
        ExpandEnvironmentStrings( sfi.szDisplayName, pszFilePath, MAX_PATH );

        if( sfi.iIcon > 0 )
        {
            *hIcon = HandleToULong(ExtractIcon( g_hinstance, pszFilePath, sfi.iIcon ));
        }
        else
        {
            HMODULE hmod = LoadLibrary(pszFilePath);
            if (hmod)
            {
                *hIcon = HandleToULong(LoadImage( hmod, MAKEINTRESOURCE(-sfi.iIcon), 
                                           IMAGE_ICON, 0, 0,
                                           LR_SHARED|LR_DEFAULTSIZE ));
                FreeLibrary(hmod);
            }
        }
        CWRg( *hIcon );          // now has an HICON
    }
    else
    {
	    CFRg(g_hinstance);
        *hIcon = HandleToULong(LoadImage( g_hinstance, MAKEINTRESOURCEA(IDI_ICON_PM),IMAGE_ICON, 0, 0,LR_SHARED ));
	    CWRg( *hIcon );
    }

Error:

    hrLogDWORD("IMDSPDevice::GetDeviceIcon returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::SendOpaqueCommand(OPAQUECOMMAND *pCommand)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:
    
	hrLogDWORD("IMDSPDevice::SendOpaqueCommand returned 0x%08lx", hr, hr);
    
    return hr;
}

// IMDSPDevice2
STDMETHODIMP CMDSPDevice::GetStorage( LPCWSTR pszStorageName, IMDSPStorage** ppStorage )
{
    HRESULT hr = S_OK;
    HRESULT hrTemp;
    WCHAR   pwszFileName[MAX_PATH+1];
    CComObject<CMDSPStorage> *pStg = NULL;
    DWORD   dwAttrib;

    // Get name of file asked for

    DWORD dwLen = wcslen(m_wcsName);

    // We reserve one char for the \ that might be added below
    if (dwLen >= ARRAYSIZE(pwszFileName)-1)
    {
        hr = STRSAFE_E_INSUFFICIENT_BUFFER; //defined in strsafe.h
        goto Error;
    }

    wcscpy( pwszFileName, m_wcsName );
    if( pwszFileName[dwLen-1] != '\\' ) 
        wcscat( pwszFileName, L"\\" );

    hrTemp = StringCchCatW( pwszFileName,
                            ARRAYSIZE(pwszFileName) - 1, 
                                // - 1 ensures the result fits into a MAX_PATH buffer.
                                // This makes the wcscpy into pStg->m_wcsName (below) safe.
                            pszStorageName );

    if (FAILED(hrTemp))
    {
        // The file does not exist
        hr = E_FAIL;  // @@@@ Something else? S_FALSE?
        goto Error;
    }

    // Check if the file exists (NT)
    if( g_bIsWinNT )
    {
        dwAttrib = GetFileAttributesW( pwszFileName );
        if( dwAttrib == -1 )
        {
            // The file does not exist
            hr = S_FALSE;
            goto Error;
        }
    }
    // For Win9x use A-version of Win32 APIs
    else if( !g_bIsWinNT )
	{
        char    pszTemp[MAX_PATH];

		WideCharToMultiByte(CP_ACP, NULL, pwszFileName, -1, pszTemp, MAX_PATH, NULL, NULL);		
        dwAttrib = GetFileAttributesA( pszTemp );
        if( dwAttrib  == -1 )
        {
            // The file does not exist
            hr = S_FALSE;
            goto Error;
        }
    }

    // Create new storage object
    CORg( CComObject<CMDSPStorage>::CreateInstance(&pStg) );
	CORg( pStg->QueryInterface( IID_IMDSPStorage, reinterpret_cast<void**>(ppStorage)) );
    wcscpy(pStg->m_wcsName, pwszFileName);
    pStg->m_bIsDirectory = ((dwAttrib & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY);

Error:
    if( hr != S_OK )
    {
        if( pStg ) delete pStg;
        *ppStorage = NULL;
    }

    return hr;
}
 
STDMETHODIMP CMDSPDevice::GetFormatSupport2(
                            DWORD dwFlags,
                            _WAVEFORMATEX** ppAudioFormatEx,
                            UINT* pnAudioFormatCount,
			                _VIDEOINFOHEADER** ppVideoFormatEx,
                            UINT* pnVideoFormatCount,
                            WMFILECAPABILITIES** ppFileType,
                            UINT* pnFileTypeCount )
{
    return E_NOTIMPL;
}

STDMETHODIMP CMDSPDevice::GetSpecifyPropertyPages( 
                            ISpecifyPropertyPages** ppSpecifyPropPages, 
							IUnknown*** pppUnknowns, 
							ULONG* pcUnks )
{
    return E_NOTIMPL;
}


STDMETHODIMP CMDSPDevice::GetPnPName( LPWSTR pwszPnPName, UINT nMaxChars )
{
    return E_NOTIMPL;
}

// IMDSPDeviceControl
STDMETHODIMP CMDSPDevice::GetDCStatus(/*[out]*/ DWORD *pdwStatus)
{
    HRESULT hr=E_FAIL;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = GetStatus(pdwStatus);

Error:
    
	hrLogDWORD("IMDSPDeviceControl::GetDCStatus returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetCapabilities(/*[out]*/ DWORD *pdwCapabilitiesMask)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    if( !pdwCapabilitiesMask ) return E_INVALIDARG;
	*pdwCapabilitiesMask = WMDM_DEVICECAP_CANSTREAMPLAY;
	
    hr = S_OK;

Error:
    
	hrLogDWORD("IMDSPDeviceControl::GetCapabilities returned 0x%08lx", hr, hr);

    return S_OK;
}	

STDMETHODIMP CMDSPDevice::Play()
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:
    
	hrLogDWORD("IMDSPDeviceControl::Play returned 0x%08lx", hr, hr);
	return hr;
}	

STDMETHODIMP CMDSPDevice::Record(/*[in]*/ _WAVEFORMATEX *pFormat)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:
    
	hrLogDWORD("IMDSPDeviceControl::Record returned 0x%08lx", hr, hr);
	
    return hr;
}

STDMETHODIMP CMDSPDevice::Pause()
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:
    
	hrLogDWORD("IMDSPDeviceControl::Pause returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::Resume()
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:
    
	hrLogDWORD("IMDSPDeviceControl::Resume returned 0x%08lx", hr, hr);
	return hr;
}	

STDMETHODIMP CMDSPDevice::Stop()
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:
    
	hrLogDWORD("IMDSPDeviceControl::Stop returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPDevice::Seek(/*[in]*/ UINT fuMode, /*[in]*/ int nOffset)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

    hr = WMDM_E_NOTSUPPORTED;

Error:

    hrLogDWORD("IMDSPDeviceControl::Seek returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::GetFormatSupport( _WAVEFORMATEX **pFormatEx,
                                           UINT *pnFormatCount,
                                           LPWSTR **pppwszMimeType,
                                           UINT *pnMimeTypeCount)
{
	HRESULT hr=S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(pFormatEx);
	CARg(pppwszMimeType);
	CARg(pnFormatCount);
	CARg(pnMimeTypeCount);

	*pnFormatCount = 1;
	*pFormatEx = (_WAVEFORMATEX *)CoTaskMemAlloc(sizeof(_WAVEFORMATEX));
	CPRg( *pFormatEx);
	(*pFormatEx)->wFormatTag = WMDM_WAVE_FORMAT_ALL;
	(*pFormatEx)->nChannels = 2;
	(*pFormatEx)->cbSize = 0;
    (*pFormatEx)->nSamplesPerSec=0; 
    (*pFormatEx)->nAvgBytesPerSec=0; 
    (*pFormatEx)->nBlockAlign=0; 
    (*pFormatEx)->wBitsPerSample=0; 
    
    *pnMimeTypeCount= 1;
	*pppwszMimeType = (LPWSTR *)CoTaskMemAlloc(sizeof(LPWSTR)*1);
    CPRg(*pppwszMimeType);
	**pppwszMimeType = (LPWSTR)CoTaskMemAlloc(sizeof(WCHAR)*(wcslen(WCS_MIME_TYPE_ALL)+1));
	CPRg(**pppwszMimeType);
	wcscpy(**pppwszMimeType, WCS_MIME_TYPE_ALL);

Error:

    hrLogDWORD("IMDSPDevice::GetFormatSupport returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPDevice::EnumStorage(IMDSPEnumStorage * * ppEnumStorage)
{
	HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CARg(ppEnumStorage);

	CComObject<CMDSPEnumStorage> *pEnumObj;
	
	CORg(CComObject<CMDSPEnumStorage>::CreateInstance(&pEnumObj));

	hr=pEnumObj->QueryInterface(IID_IMDSPEnumStorage, reinterpret_cast<void**>(ppEnumStorage));
	if( FAILED(hr) )
            delete pEnumObj;
        else 
        {
            hr = StringCbCopyW(pEnumObj->m_wcsPath, 
                               ARRAYSIZE(pEnumObj->m_wcsPath),
                               m_wcsName);
            if (FAILED(hr))
            {
                (*ppEnumStorage)->Release();
                *ppEnumStorage = NULL;
                goto Error;
            }
        }
Error:

    hrLogDWORD("IMDSPDevice::EnumStorage returned 0x%08lx", hr, hr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\mdspdefs.h ===
#ifndef __MDSPDEFS_H__
#define __MDSPDEFS_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "scserver.h"

#define MDSP_TEMP
#define ALSO_CHECK_FILES

typedef PVOID           HDEVNOTIFY;
typedef HDEVNOTIFY     *PHDEVNOTIFY;
#define DEVICE_NOTIFY_WINDOW_HANDLE     0x00000000

typedef struct {
	BOOL  bValid;
	WCHAR wcsDevName[32];
    LPVOID pDeviceObj;
	LPVOID pIWMDMConnect;
} MDSPNOTIFYINFO;

typedef struct {
	BOOL  bValid;
	WCHAR wcsDevName[32];
	DWORD dwStatus;
	LPVOID pIMDSPStorageGlobals;
} MDSPGLOBALDEVICEINFO;


#define WMDM_WAVE_FORMAT_ALL (WORD)0xFFFF
#define WCS_MIME_TYPE_ALL L"*/*"

#define	MDSP_PMID_SOFT	0
#define	MDSP_PMID_SANDISK 1
#define MDSP_MAX_DRIVE_COUNT 26
#define MDSP_MAX_DEVICE_OBJ  64

#define STR_MDSPREG "Software\\Microsoft\\Windows Media Device Manager\\Plugins\\SP\\MSPMSP"
#define STR_MDSPPROGID "MDServiceProvider.MDServiceProvider" 
#define WCS_PMID_SOFT L"media.id"


extern DWORD DoRegisterDeviceInterface(HWND hWnd, GUID InterfaceClassGuid, HDEVNOTIFY *hDevNotify);
extern BOOL DoUnregisterDeviceInterface(HDEVNOTIFY hDev);
extern void MDSPProcessDeviceChange(WPARAM wParam, LPARAM lParam);
extern void MDSPNotifyDeviceConnection(WCHAR *wcsDeviceName, BOOL nIsConnect);
extern HRESULT wcsParseDeviceName(WCHAR *wcsIn, WCHAR *wcsOut, DWORD dwNumCharsInOutBuffer);
extern HRESULT GetFileSizeRecursiveA(char *szPath, DWORD *pdwSizeLow, DWORD *pdwSizeHigh);
extern HRESULT GetFileSizeRecursiveW(WCHAR *wcsPath, DWORD *pdwSizeLow, DWORD *pdwSizeHigh);
extern HRESULT DeleteFileRecursiveA(char *szPath);
extern HRESULT DeleteFileRecursiveW(WCHAR *wcsPath);
extern HRESULT SetGlobalDeviceStatus(WCHAR *wcsName, DWORD dwStat, BOOL bClear);
extern HRESULT GetGlobalDeviceStatus(WCHAR *wcsNameIn, DWORD *pdwStat);
extern BOOL IsIomegaDrive(LPSTR szDL);
extern UINT __stdcall UtilGetDriveType(LPSTR szDL);
extern BOOL IsWinNT();
extern BOOL UtilSetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes);
extern DWORD UtilGetFileAttributesW(LPCWSTR lpFileName);
extern BOOL UtilCreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
extern HANDLE UtilCreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
extern BOOL UtilMoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
extern HRESULT QuerySubFoldersAndFiles(LPCWSTR szCurrentFolder, DWORD *pdwAttr);

extern DWORD g_dwStartDrive;
extern HINSTANCE g_hinstance; 
extern MDSPNOTIFYINFO g_NotifyInfo[MDSP_MAX_DEVICE_OBJ];
extern MDSPGLOBALDEVICEINFO g_GlobalDeviceInfo[MDSP_MAX_DEVICE_OBJ];
extern WCHAR g_wcsBackslash[2];
#define BACKSLASH_STRING_LENGTH (ARRAYSIZE(g_wcsBackslash)-1)
extern CHAR g_szBackslash[2];
#define BACKSLASH_SZ_STRING_LENGTH (ARRAYSIZE(g_szBackslash)-1)
extern CComMultiThreadModel::AutoCriticalSection g_CriticalSection;
extern CSecureChannelServer *g_pAppSCServer;
extern BOOL g_bIsWinNT;
 
// The following are copied from drmerr.h
#define	fFalse		0
#define fTrue		1

#define hrOK			HRESULT(S_OK)
#define hrTrue			HRESULT(S_OK)
#define hrFalse			ResultFromScode(S_FALSE)
#define hrFail			ResultFromScode(E_FAIL)
#define hrNotImpl		ResultFromScode(E_NOTIMPL)
#define hrNoInterface	ResultFromScode(E_NOINTERFACE)
#define hrNoMem			WMDM_E_BUFFERTOOSMALL
#define hrAbort			ResultFromScode(E_ABORT)
#define hrInvalidArg	ResultFromScode(E_INVALIDARG)

/*----------------------------------------------------------------------------
	CORg style error handling
	(Historicaly stands for Check OLE Result and Goto)
 ----------------------------------------------------------------------------*/

#define DebugMessageCPRg(pwszFile, nLine)
#define DebugMessageCORg(pwszFile, nLine, hr)
#define DebugMessageCFRg(pwszFile, nLine)
#define DebugMessageCADORg(pwszFile, nLine, hr)

#define _UNITEXT(quote) L##quote
#define UNITEXT(quote) _UNITEXT(quote)

#define	CPRg(p)\
	do\
		{\
		if (!(p))\
			{\
            DebugMessageCPRg(UNITEXT(__FILE__), __LINE__);\
			hr = hrNoMem;\
			goto Error;\
			}\
		}\
	while (fFalse)

#define	CHRg(hResult) CORg(hResult)

#define	CORg(hResult)\
	do\
		{\
		hr = (hResult);\
        if (FAILED(hr))\
            {\
            DebugMessageCORg(UNITEXT(__FILE__), __LINE__, hr);\
            goto Error;\
            }\
		}\
	while (fFalse)

#define	CADORg(hResult)\
	do\
		{\
		hr = (hResult);\
        if (hr!=S_OK && hr!=S_FALSE)\
            {\
            hr = HRESULT_FROM_ADO_ERROR(hr);\
            DebugMessageCADORg(UNITEXT(__FILE__), __LINE__, hr);\
            goto Error;\
            }\
		}\
	while (fFalse)

#define	CORgl(label, hResult)\
	do\
		{\
		hr = (hResult);\
        if (FAILED(hr))\
            {\
            DebugMessageCORg(UNITEXT(__FILE__), __LINE__, hr);\
            goto label;\
            }\
		}\
	while (fFalse)

#define	CWRg(fResult)\
	{\
	if (!(fResult))\
		{\
        hr = GetLastError();\
	    if (!(hr & 0xFFFF0000)) hr = HRESULT_FROM_WIN32(hr);\
        DebugMessageCORg(UNITEXT(__FILE__), __LINE__, hr);\
		goto Error;\
		}\
	}

#define	CWRgl(label, fResult)\
	{\
	if (!(fResult))\
		{\
        hr = GetLastError();\
		if (!(hr & 0xFFFF0000)) hr = HRESULT_FROM_WIN32(hr);\
        DebugMessageCORg(UNITEXT(__FILE__), __LINE__, hr);\
		goto label;\
		}\
	}

#define	CFRg(fResult)\
	{\
	if (!(fResult))\
		{\
        DebugMessageCFRg(UNITEXT(__FILE__), __LINE__);\
		hr = hrFail;\
		goto Error;\
		}\
	}

#define	CFRgl(label, fResult)\
	{\
	if (!(fResult))\
		{\
        DebugMessageCFRg(UNITEXT(__FILE__), __LINE__);\
		hr = hrFail;\
		goto label;\
		}\
	}

#define	CARg(p)\
	do\
		{\
		if (!(p))\
			{\
			hr = hrInvalidArg;\
			goto Error;\
			}\
		}\
	while (fFalse)



#endif // __MDSPDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\mdsp.cpp ===
// Mdsp.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To merge the proxy/stub code into the object DLL, add the file 
//		dlldatax.c to the project.  Make sure precompiled headers 
//		are turned off for this file, and add _MERGE_PROXYSTUB to the 
//		defines for the project.  
//
//		If you are not running WinNT4.0 or Win95 with DCOM, then you
//		need to remove the following define from dlldatax.c
//		#define _WIN32_WINNT 0x0400
//
//		Further, if you are running MIDL without /Oicf switch, you also 
//		need to remove the following define from dlldatax.c.
//		#define USE_STUBLESS_PROXY
//
//		Modify the custom build rule for Mdsp.idl by adding the following 
//		files to the Outputs.
//			Mdsp_p.c
//			dlldata.c
//		To build a separate proxy/stub DLL, 
//		run nmake -f Mdspps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "MsPMSP.h"
#include "dlldatax.h"

#include "MsPMSP_i.c"
#include "MDServiceProvider.h"
//#include "MDSPEnumDevice.h"
//#include "MDSPDevice.h"
//#include "MDSPEnumStorage.h"
//#include "MDSPStorage.h"
//#include "MDSPStorageGlobals.h"
#include "MdspDefs.h"
#include "scserver.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;
DWORD g_dwStartDrive;
HINSTANCE g_hinstance; 
MDSPNOTIFYINFO g_NotifyInfo[MDSP_MAX_DEVICE_OBJ];
MDSPGLOBALDEVICEINFO g_GlobalDeviceInfo[MDSP_MAX_DEVICE_OBJ];
WCHAR g_wcsBackslash[2] = { (WCHAR)0x5c, NULL };
CHAR  g_szBackslash[2] = {(CHAR)0x5c, NULL };
CComMultiThreadModel::AutoCriticalSection g_CriticalSection;
CSecureChannelServer *g_pAppSCServer=NULL;
BOOL g_bIsWinNT;
 
BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_MDServiceProvider, CMDServiceProvider)
//	OBJECT_ENTRY(CLSID_MDSPEnumDevice, CMDSPEnumDevice)
//	OBJECT_ENTRY(CLSID_MDSPDevice, CMDSPDevice)
//	OBJECT_ENTRY(CLSID_MDSPEnumFormatSupport, CMDSPEnumFormatSupport)
//	OBJECT_ENTRY(CLSID_MDSPEnumStorage, CMDSPEnumStorage)
//	OBJECT_ENTRY(CLSID_MDSPStorage, CMDSPStorage)
//	OBJECT_ENTRY(CLSID_MDSPStorageGlobals, CMDSPStorageGlobals)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	lpReserved;
#ifdef _MERGE_PROXYSTUB
	if (!PrxDllMain(hInstance, dwReason, lpReserved))
		return FALSE;
#endif
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();

	g_hinstance = hInstance; 
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllCanUnloadNow() != S_OK)
		return S_FALSE;
#endif
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
		return S_OK;
#endif
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	HRESULT hRes = PrxDllRegisterServer();
	if (FAILED(hRes))
		return hRes;
#endif
    char szTemp[MAX_PATH];
    HKEY hKey;

	if( !RegCreateKeyEx(HKEY_LOCAL_MACHINE, STR_MDSPREG, 0, NULL, 
			REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, &hKey, NULL) )
	{
		strcpy(szTemp, STR_MDSPPROGID);
		RegSetValueEx( hKey, "ProgID", 0, REG_SZ, (LPBYTE)szTemp, sizeof(szTemp));
#ifdef MDSP_TEMP
		DWORD dwSD=1;
		RegSetValueEx( hKey, "StartDrive", 0, REG_DWORD, (LPBYTE)&dwSD, sizeof(DWORD));
#endif
		RegCloseKey(hKey);
		// registers object, typelib and all interfaces in typelib
		return _Module.RegisterServer(TRUE);
	} else return REGDB_E_WRITEREGDB;

}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	PrxDllUnregisterServer();
#endif
	_Module.UnregisterServer();

    RegDeleteKey(HKEY_LOCAL_MACHINE, STR_MDSPREG);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\mdspdevice.h ===
// MDSPDevice.h : Declaration of the CMDSPDevice

#ifndef __MDSPDEVICE_H_
#define __MDSPDEVICE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMDSPDevice
class ATL_NO_VTABLE CMDSPDevice : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMDSPDevice, &CLSID_MDSPDevice>,
	public IMDSPDevice2, IMDSPDeviceControl
{
public:
	CMDSPDevice();
	~CMDSPDevice();


DECLARE_REGISTRY_RESOURCEID(IDR_MDSPDEVICE)

BEGIN_COM_MAP(CMDSPDevice)
	COM_INTERFACE_ENTRY(IMDSPDevice)
	COM_INTERFACE_ENTRY(IMDSPDevice2)
	COM_INTERFACE_ENTRY(IMDSPDeviceControl)
END_COM_MAP()

// IMDSPDevice
public:
	HRESULT InitGlobalDeviceInfo();
	WCHAR m_wcsName[MAX_PATH];
	STDMETHOD(EnumStorage)(/*[out]*/ IMDSPEnumStorage **ppEnumStorage);
	STDMETHOD(GetFormatSupport)(_WAVEFORMATEX **pFormatEx,
                                UINT *pnFormatCount,
                                LPWSTR **pppwszMimeType,
                                UINT *pnMimeTypeCount);
	STDMETHOD(GetDeviceIcon)(/*[out]*/ ULONG *hIcon);
	STDMETHOD(GetStatus)(/*[out]*/ DWORD *pdwStatus);
	STDMETHOD(GetPowerSource)(/*[out]*/ DWORD *pdwPowerSource, /*[out]*/ DWORD *pdwPercentRemaining);
	STDMETHOD(GetSerialNumber)(/*[out]*/ PWMDMID pSerialNumber, /*[in, out]*/BYTE abMac[WMDM_MAC_LENGTH]);
	STDMETHOD(GetType)(/*[out]*/ DWORD *pdwType);
	STDMETHOD(GetVersion)(/*[out]*/ DWORD *pdwVersion);
	STDMETHOD(GetManufacturer)(/*[out,string,size_is(nMaxChars)]*/ LPWSTR pwszName, /*[in]*/ UINT nMaxChars);
	STDMETHOD(GetName)(/*[out,string,size_is(nMaxChars)]*/ LPWSTR pwszName, /*[in]*/ UINT nMaxChars);
    STDMETHOD(SendOpaqueCommand)(OPAQUECOMMAND *pCommand);

// IMDSPDevice2
	STDMETHOD(GetStorage)( LPCWSTR pszStorageName, IMDSPStorage** ppStorage );
 
    STDMETHOD(GetFormatSupport2)(   DWORD dwFlags,
                                    _WAVEFORMATEX** ppAudioFormatEx,
                                    UINT* pnAudioFormatCount,
			                        _VIDEOINFOHEADER** ppVideoFormatEx,
                                    UINT *pnVideoFormatCount,
                                    WMFILECAPABILITIES** ppFileType,
                                    UINT* pnFileTypeCount );

	STDMETHOD(GetSpecifyPropertyPages)( ISpecifyPropertyPages** ppSpecifyPropPages, 
									    IUnknown*** pppUnknowns, 
									    ULONG* pcUnks );

    STDMETHOD(GetPnPName)( LPWSTR pwszPnPName, UINT nMaxChars );

// IMDSPDeviceControl
	STDMETHOD(GetDCStatus)(/*[out]*/ DWORD *pdwStatus);
	STDMETHOD(GetCapabilities)(/*[out]*/ DWORD *pdwCapabilitiesMask);
	STDMETHOD(Play)();
	STDMETHOD(Record)(/*[in]*/ _WAVEFORMATEX *pFormat);
	STDMETHOD(Pause)();
	STDMETHOD(Resume)();
	STDMETHOD(Stop)();
	STDMETHOD(Seek)(/*[in]*/ UINT fuMode, /*[in]*/ int nOffset);
};

#endif //__MDSPDEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\mdserviceprovider.h ===
// MDServiceProvider.h : Declaration of the CMDServiceProvider

#ifndef __MDSERVICEPROVIDER_H_
#define __MDSERVICEPROVIDER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMDServiceProvider
class ATL_NO_VTABLE CMDServiceProvider : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMDServiceProvider, &CLSID_MDServiceProvider>,
	public IMDServiceProvider,
	public IComponentAuthenticate,
    public IMDSPRevoked
{
public:
	CMDServiceProvider();
	~CMDServiceProvider();

DECLARE_CLASSFACTORY_SINGLETON(CMDServiceProvider)
DECLARE_REGISTRY_RESOURCEID(IDR_MDSERVICEPROVIDER)

BEGIN_COM_MAP(CMDServiceProvider)
	COM_INTERFACE_ENTRY(IMDServiceProvider)
	COM_INTERFACE_ENTRY(IComponentAuthenticate)
	COM_INTERFACE_ENTRY(IMDSPRevoked)
END_COM_MAP()

// IMDServiceProvider
public:
	DWORD m_dwThreadID;
	HANDLE m_hThread;
	STDMETHOD(EnumDevices)(/*[out]*/ IMDSPEnumDevice **ppEnumDevice);
	STDMETHOD(GetDeviceCount)(/*[out]*/ DWORD *pdwCount);
    STDMETHOD(SACAuth)(DWORD dwProtocolID,
                       DWORD dwPass,
                       BYTE *pbDataIn,
                       DWORD dwDataInLen,
                       BYTE **ppbDataOut,
                       DWORD *pdwDataOutLen);
    STDMETHOD(SACGetProtocols)(DWORD **ppdwProtocols,
                               DWORD *pdwProtocolCount);

// IMDSPRevoked
    STDMETHOD(GetRevocationURL)( LPWSTR* ppwszRevocationURL,
                                 DWORD*  pdwBufferLen  );


};

#endif //__MDSERVICEPROVIDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\mdspenumdevice.cpp ===
// MDSPEnumDevice.cpp : Implementation of CMDSPEnumDevice
#include "stdafx.h"
#include "MsPMSP.h"

#include "MdspDefs.h"
#include "MDSPEnumDevice.h"
#include "MDSPDevice.h"
#include "loghelp.h"


/////////////////////////////////////////////////////////////////////////////
// CMDSPEnumDevice
CMDSPEnumDevice::CMDSPEnumDevice()
{
	m_nCurOffset=0;          // When reset Cursor=0, actual element starts from 1.
		
	char str[8]="c:";
	int i, cnt;
	for(i=g_dwStartDrive, cnt=0; i<MDSP_MAX_DRIVE_COUNT; i++)
	{
		str[0] = 'A' + i;
		if( UtilGetDriveType(str) == DRIVE_REMOVABLE  ) 
		{
			m_cEnumDriveLetter[cnt]=str[0];
			cnt ++;
		}
	}
	m_nMaxDeviceCount = cnt;
}

STDMETHODIMP CMDSPEnumDevice::Next(ULONG celt, IMDSPDevice * * ppDevice, ULONG * pceltFetched)
{
	HRESULT hr=S_FALSE;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(ppDevice);
	CARg(pceltFetched);

	*pceltFetched = 0;
    *ppDevice = NULL;

	ULONG i;

	for(i=0; (i<celt)&&(m_nCurOffset<m_nMaxDeviceCount); i++)
	{
		CComObject<CMDSPDevice> *pObj;

		CHRg(CComObject<CMDSPDevice>::CreateInstance(&pObj));
		hr=pObj->QueryInterface(IID_IMDSPDevice, reinterpret_cast<void**>(&(ppDevice[i])));
		if( FAILED(hr) )
		{
			delete pObj;
			break;
		} else {				
			*pceltFetched = (*pceltFetched) + 1;
		    pObj->m_wcsName[0] = m_cEnumDriveLetter[m_nCurOffset];
			pObj->m_wcsName[1] = L':';
			pObj->m_wcsName[2] = NULL;
			m_nCurOffset ++;
			pObj->InitGlobalDeviceInfo();
		}
	} 
	if( SUCCEEDED(hr) )
	{
		if( *pceltFetched == celt) 
			hr=S_OK;
		else 
		    hr = S_FALSE;
	}
Error: 

    hrLogDWORD("IMSDPEnumDevice::Next returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPEnumDevice::Skip(ULONG celt, ULONG *pceltFetched)
{
	HRESULT hr;
    
	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pceltFetched);

	if( celt <= m_nMaxDeviceCount-m_nCurOffset )
	{
		*pceltFetched = celt;
		m_nCurOffset += celt;
		hr = S_OK;
    } else {
		*pceltFetched = m_nMaxDeviceCount-m_nCurOffset;
		m_nCurOffset = m_nMaxDeviceCount;
		hr = S_FALSE;
	}
	
Error:

    hrLogDWORD("IMSDPEnumDevice::Skip returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPEnumDevice::Reset()
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	m_nCurOffset = 0;

    hr = S_OK;

Error:

    hrLogDWORD("IMSDPEnumDevice::Reset returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPEnumDevice::Clone(IMDSPEnumDevice * * ppEnumDevice)
{
	HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(ppEnumDevice);

	CComObject<CMDSPEnumDevice> *pEnumObj;
	hr=CComObject<CMDSPEnumDevice>::CreateInstance(&pEnumObj);

	if( SUCCEEDED(hr) )
	{
		hr=pEnumObj->QueryInterface(IID_IMDSPEnumDevice, reinterpret_cast<void**>(ppEnumDevice));
		if( FAILED(hr) )
			delete pEnumObj;
		else { // set the new enumerator state to be same as current
			pEnumObj->m_nCurOffset = m_nCurOffset;
		}
	}
Error:

    hrLogDWORD("IMSDPEnumDevice::Clone returned 0x%08lx", hr, hr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\mdspenumdevice.h ===
// MDSPEnumDevice.h : Declaration of the CMDSPEnumDevice

#ifndef __MDSPENUMDEVICE_H_
#define __MDSPENUMDEVICE_H_

#include "resource.h"       // main symbols
#include "MdspDefs.h"

/////////////////////////////////////////////////////////////////////////////
// CMDSPEnumDevice
class ATL_NO_VTABLE CMDSPEnumDevice : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMDSPEnumDevice, &CLSID_MDSPEnumDevice>,
	public IMDSPEnumDevice
{
public:
	CMDSPEnumDevice();


DECLARE_REGISTRY_RESOURCEID(IDR_MDSPENUMDEVICE)

BEGIN_COM_MAP(CMDSPEnumDevice)
	COM_INTERFACE_ENTRY(IMDSPEnumDevice)
END_COM_MAP()

// IMDSPEnumDevice
public:
	ULONG m_nCurOffset;
	ULONG m_nMaxDeviceCount;
	WCHAR m_cEnumDriveLetter[MDSP_MAX_DRIVE_COUNT];
	STDMETHOD(Clone)(/*[out]*/ IMDSPEnumDevice **ppEnumDevice);
	STDMETHOD(Reset)();
	STDMETHOD(Skip)(/*[in]*/ ULONG celt, /*[out]*/ ULONG *pceltFetched);
	STDMETHOD(Next)(/*[in]*/ ULONG celt, /*[out]*/ IMDSPDevice **ppDevice, /*[out]*/ ULONG *pceltFetched);
};

#endif //__MDSPENUMDEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\mdspenumstorage.cpp ===
// MDSPEnumStorage.cpp : Implementation of CMDSPEnumStorage
#include "stdafx.h"
#include "MsPMSP.h"
#include "MDSPEnumStorage.h"
#include "MDSPStorage.h"
#include "MdspDefs.h"
#include "loghelp.h"
#include "wmsstd.h"
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

/////////////////////////////////////////////////////////////////////////////
// CMDSPEnumStorage
CMDSPEnumStorage::CMDSPEnumStorage()
{
	m_hFFile=INVALID_HANDLE_VALUE; // this is similar to a cursor
	m_nEndSearch=0;				   // this signals the cursor is at the end	
	m_nFindFileIndex=0;            // this indicates the position of FindFile, used for Clone()
        m_wcsPath[0] = 0;
}

CMDSPEnumStorage::~CMDSPEnumStorage()
{
	if( m_hFFile !=INVALID_HANDLE_VALUE )
		FindClose(m_hFFile); 
}

STDMETHODIMP CMDSPEnumStorage::Next(ULONG celt, IMDSPStorage * * ppStorage, ULONG * pceltFetched)
{
    HRESULT hr=S_FALSE;

    CARg(ppStorage);
    CARg(pceltFetched);

    *pceltFetched = 0;

    if(m_nEndSearch) return S_FALSE;

    DWORD dwLen = wcslen(m_wcsPath);
    if (dwLen == 0  || dwLen >= ARRAYSIZE(m_wcsPath))
    {
        // a) Code below aassumes that dwLen > 0 (uses dwLen - 1 as an index
        // b) dwLen >= ARRAYSIZE(m_wcsPath) implies m_wcsPath has overflowed
        //    Below, we use the fact that dwLen < ARRAYSIZE(m_wcsPath) to
        //    bound the sizes of temp variables into which m_wcsPath is copied
        return E_FAIL;
    }
    if( dwLen < 3 )
    {
            CComObject<CMDSPStorage> *pStg;
            hr=CComObject<CMDSPStorage>::CreateInstance(&pStg);

            if( SUCCEEDED(hr) )
            {
                hr=pStg->QueryInterface(IID_IMDSPStorage, reinterpret_cast<void**>(ppStorage));
                if( FAILED(hr) ) { delete pStg; *pceltFetched=0; }
                else 
                { 
                    wcscpy(pStg->m_wcsName, m_wcsPath);
                    if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c ) 
                    {
                        wcscat(pStg->m_wcsName, g_wcsBackslash);
                    }
                    pStg->m_bIsDirectory = TRUE;
                    m_nEndSearch = 1;  // Signal end of enumeration
                }

            }

            if( SUCCEEDED(hr) ) // if obj created successfully
            {
                    *pceltFetched=1;
                    if( celt != 1 ) hr=S_FALSE;  // didn't get what he wanted
            }
            return hr;
    } 
    
    // For non-root storage
    WCHAR wcsTmp[MAX_PATH+1+BACKSLASH_STRING_LENGTH];// for appending "\\*"
                            // Note that ARRAYSIZE(m_wcsPath) == MAX_PATH
    char szTmp[MAX_PATH];
    ULONG i;

    if( g_bIsWinNT )
    {
        WIN32_FIND_DATAW wfd;
        for(i=0; (i<celt)&&(!m_nEndSearch); )
        {
            if( m_hFFile == INVALID_HANDLE_VALUE ) 
            {    
                wcscpy(wcsTmp, m_wcsPath);
                if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c ) wcscat(wcsTmp, g_wcsBackslash);
                wcscat(wcsTmp, L"*");
                m_hFFile = FindFirstFileW(wcsTmp, &wfd);
                if( m_hFFile == INVALID_HANDLE_VALUE ) 
                {
                    m_nEndSearch = 1;
                }
                else m_nFindFileIndex=1;
            } 
            else 
            {
                    if( !FindNextFileW(m_hFFile, &wfd) ) 
                    {
                        m_nEndSearch = 1;
                    }
                    else m_nFindFileIndex++;
            }
    
            if ( !m_nEndSearch )
            {
                if( !wcscmp(wfd.cFileName, L".") || !wcscmp(wfd.cFileName, L"..") ) 
                {
                    continue;
                }

                CComObject<CMDSPStorage> *pStg;
                hr=CComObject<CMDSPStorage>::CreateInstance(&pStg);

                if( SUCCEEDED(hr) )
                {
                    hr=pStg->QueryInterface(IID_IMDSPStorage, reinterpret_cast<void**>(&(ppStorage[*pceltFetched])));
                    if( FAILED(hr) ) 
                    { 
                        delete pStg; 
                        break;
                        /* *pceltFetched=0; */
                    }
                    else 
                    { 
                        // Compute the number of chars we'll use
                        // up in pStg->m_wcsName
                        int nHave = ARRAYSIZE(pStg->m_wcsName) - 1;
                                    // -1 for the NULL terminator

                        nHave -= dwLen;
                        if( m_wcsPath[dwLen-1] != 0x5c )
                        {
                            nHave -= BACKSLASH_STRING_LENGTH;
                        }
                        nHave -= wcslen(wfd.cFileName);

                        if (nHave >= 0)
                        {
                            wcscpy(pStg->m_wcsName, m_wcsPath);
                            if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c ) 
                            {
                                wcscat(pStg->m_wcsName, g_wcsBackslash);
                            }
                            wcscat(pStg->m_wcsName, wfd.cFileName);
                            pStg->m_bIsDirectory = ((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0);
                            *pceltFetched = (*pceltFetched)+1;
                            i++;
                        }
                        else
                        {
                            ppStorage[*pceltFetched]->Release();
                            ppStorage[*pceltFetched] = NULL;
                            hr = STRSAFE_E_INSUFFICIENT_BUFFER;
                                                //defined in strsafe.h
                            break;
                        }
                    }
                }
                else
                {
                    break;
                }
            }	
        } // end of For loop 
        if (FAILED(hr))
        {
            // Note: m_nFindFileIndex and m_hFind are not reset to their
            // state at the start of this function
            for (; *pceltFetched; )
            {
                (*pceltFetched)--;
                ppStorage[*pceltFetched]->Release();
                ppStorage[*pceltFetched] = NULL;
            }
        }
    } 
    else 
    { // On Win9x, use A-version of Win32 APIs
            WIN32_FIND_DATAA fd;
            for(i=0; (i<celt)&&(!m_nEndSearch); )
            {
                    if( m_hFFile == INVALID_HANDLE_VALUE ) 
        {    
                            wcscpy(wcsTmp, m_wcsPath);
                            if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c ) 
            {
                wcscat(wcsTmp, g_wcsBackslash);
            }
                            wcscat(wcsTmp, L"*");
                            WideCharToMultiByte(CP_ACP, NULL, wcsTmp, -1, szTmp, MAX_PATH, NULL, NULL);		
                            m_hFFile = FindFirstFileA(szTmp, &fd);
                            if( m_hFFile == INVALID_HANDLE_VALUE ) 
            {
                m_nEndSearch = 1;
            }
                            else m_nFindFileIndex=1;
                    } 
        else 
        {
                            if( !FindNextFileA(m_hFFile, &fd) ) 
            {
                m_nEndSearch = 1;
            }
                            else m_nFindFileIndex++;
                    }
            
                    if ( !m_nEndSearch )
                    {
                        if( !strcmp(fd.cFileName, ".") || !strcmp(fd.cFileName, "..") ) 
            {
                                continue;
            }

                        CComObject<CMDSPStorage> *pStg;
                        hr=CComObject<CMDSPStorage>::CreateInstance(&pStg);

                        if( SUCCEEDED(hr) )
                        {
                                hr=pStg->QueryInterface(IID_IMDSPStorage, reinterpret_cast<void**>(&(ppStorage[*pceltFetched])));
                                if( FAILED(hr) ) 
                { 
                    delete pStg; 
                    /* *pceltFetched=0; */
                }
                                else 
                { 
                                    wcscpy(pStg->m_wcsName, m_wcsPath);
                                    if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c ) 
                {
                    wcscat(pStg->m_wcsName, g_wcsBackslash);
                }
                                    MultiByteToWideChar(CP_ACP, NULL, fd.cFileName, -1, wcsTmp, MAX_PATH);
                                    wcscat(pStg->m_wcsName, wcsTmp);
                pStg->m_bIsDirectory = ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0);
                                    *pceltFetched = (*pceltFetched)+1;
                                    i++;
                                }
                        }
                    }	
            } // end of For loop 
    }
    if( SUCCEEDED(hr) && (*pceltFetched<celt) ) 
            hr = S_FALSE;

Error:
hrLogDWORD("IMDSPEnumStorage::Next returned 0x%08lx", hr, hr);
    return hr;
}

STDMETHODIMP CMDSPEnumStorage::Skip(ULONG celt, ULONG *pceltFetched)
{
	HRESULT hr=S_OK;

	CARg(celt);
	CARg(pceltFetched);
    CFRg(!m_nEndSearch);   // make sure it is not the end of list

	*pceltFetched = 0;
    if( wcslen(m_wcsPath) < 3 ) // do nothing if it is the root storage
		return S_OK; 

    char szTmp[MAX_PATH];
    WCHAR wcsTmp[MAX_PATH+1+BACKSLASH_STRING_LENGTH]; // for appending "\\*"
    ULONG i;

    if( wcslen(m_wcsPath) >= ARRAYSIZE(wcsTmp) - BACKSLASH_STRING_LENGTH - 1 )
    {
        // We check the length against wcsTmp's size because wcsTmp is the
        // recipient of a string copy below. However, note that m_wcsPath
        // also has MAX_PATH characters, so if this happens, it means that
        // it has overflowed. Bail out.
        return E_FAIL;
    }


	if( g_bIsWinNT )
	{
		WIN32_FIND_DATAW wfd;
		for(i=0; (i<celt)&&(!m_nEndSearch); )
		{
			if( m_hFFile==INVALID_HANDLE_VALUE ) // at the start
			{
				wcscpy(wcsTmp, m_wcsPath);
				if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c ) wcscat(wcsTmp, g_wcsBackslash);
				wcscat(wcsTmp, L"*");
				m_hFFile = FindFirstFileW(wcsTmp, &wfd);
				if( m_hFFile == INVALID_HANDLE_VALUE ) m_nEndSearch = 1;
				else m_nFindFileIndex=1;
			} else {
				if( !FindNextFileW(m_hFFile, &wfd) )  m_nEndSearch = 1;
				else m_nFindFileIndex++;
			}
			if( !m_nEndSearch ) {
				if( !wcscmp(wfd.cFileName, L".") || !wcscmp(wfd.cFileName, L"..") ) 
					continue;
				*pceltFetched = (*pceltFetched)+1;
				i++;
			}
		}
	} else { // On Win9x, use A-version of Win32 APIs
		WIN32_FIND_DATAA fd;
		for(i=0; (i<celt)&&(!m_nEndSearch); )
		{
			if( m_hFFile==INVALID_HANDLE_VALUE ) // at the start
			{
				wcscpy(wcsTmp, m_wcsPath);
				if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c ) wcscat(wcsTmp, g_wcsBackslash);
				wcscat(wcsTmp, L"*");
				WideCharToMultiByte(CP_ACP, NULL, wcsTmp, -1, szTmp, MAX_PATH, NULL, NULL);	
				m_hFFile = FindFirstFileA(szTmp, &fd);
				if( m_hFFile == INVALID_HANDLE_VALUE ) m_nEndSearch = 1;
				else m_nFindFileIndex=1;
			} else {
				if( !FindNextFileA(m_hFFile, &fd) )  m_nEndSearch = 1;
				else m_nFindFileIndex++;
			}
			if( !m_nEndSearch ) {
				if( !strcmp(fd.cFileName, ".") || !strcmp(fd.cFileName, "..") ) 
					continue;
				*pceltFetched = (*pceltFetched)+1;
				i++;
			}
		}
	}
	if( *pceltFetched < celt ) hr = S_FALSE;

Error:
    hrLogDWORD("IMDSPEnumStorage::Skip returned 0x%08lx", hr, hr);
	return hr;
}

STDMETHODIMP CMDSPEnumStorage::Reset()
{
    HRESULT hr = S_OK;
	m_nEndSearch=0;
	if(m_hFFile && m_hFFile != INVALID_HANDLE_VALUE ) 
		FindClose(m_hFFile);
	m_hFFile = INVALID_HANDLE_VALUE;
	m_nFindFileIndex=0;

// Error:
    hrLogDWORD("IMDSPEnumStorage::Reset returned 0x%08lx", hr, hr);
	return hr;
}

STDMETHODIMP CMDSPEnumStorage::Clone(IMDSPEnumStorage * * ppEnumStorage)
{
	HRESULT hr=E_FAIL;

	CARg(ppEnumStorage);
        if (wcslen(m_wcsPath) >= ARRAYSIZE(m_wcsPath))
        {
            // The variable has overflowed
            goto Error;
        }

	CComObject<CMDSPEnumStorage> *pEnumObj;
	CORg(CComObject<CMDSPEnumStorage>::CreateInstance(&pEnumObj));

	hr=pEnumObj->QueryInterface(IID_IMDSPEnumStorage, reinterpret_cast<void**>(ppEnumStorage));
	if( FAILED(hr) )
		delete pEnumObj;
    else {
		WCHAR wcsTmp[MAX_PATH+1+BACKSLASH_STRING_LENGTH];
		char szTmp[MAX_PATH];
		int	i, nErrorEnd=0;

		wcscpy(pEnumObj->m_wcsPath, m_wcsPath);
		pEnumObj->m_nEndSearch = m_nEndSearch;
		pEnumObj->m_nFindFileIndex = m_nFindFileIndex;

		if( !(pEnumObj->m_nEndSearch) && (pEnumObj->m_nFindFileIndex) ) 
			// now Clone the FindFile state
		{
			if( g_bIsWinNT )
			{
				WIN32_FIND_DATAW wfd;
				for(i=0; (i<m_nFindFileIndex)&&(!nErrorEnd); )
				{
				  if( pEnumObj->m_hFFile == INVALID_HANDLE_VALUE ) {    
					wcscpy(wcsTmp, m_wcsPath);
					if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c ) wcscat(wcsTmp, g_wcsBackslash);
					wcscat(wcsTmp, L"*");
					pEnumObj->m_hFFile = FindFirstFileW(wcsTmp, &wfd);
					if( pEnumObj->m_hFFile == INVALID_HANDLE_VALUE ) nErrorEnd = 1;
					else i=1;
				  } else {
					if( !FindNextFileW(pEnumObj->m_hFFile, &wfd) ) nErrorEnd = 1;
					else i++;
				  }
				  if ( !nErrorEnd )
				  {
					if( !wcscmp(wfd.cFileName, L".") || !wcscmp(wfd.cFileName, L"..") ) 
                                        {
						continue;
                                        }
				  }
				} // end of FOR loop
			} else {
				WIN32_FIND_DATAA fd;
				for(i=0; (i<m_nFindFileIndex)&&(!nErrorEnd); )
				{
				  if( pEnumObj->m_hFFile == INVALID_HANDLE_VALUE ) {    
					wcscpy(wcsTmp, m_wcsPath);
					if( m_wcsPath[wcslen(m_wcsPath)-1] != 0x5c ) wcscat(wcsTmp, g_wcsBackslash);
					wcscat(wcsTmp, L"*");
					WideCharToMultiByte(CP_ACP, NULL, wcsTmp, -1, szTmp, MAX_PATH, NULL, NULL);		
					pEnumObj->m_hFFile = FindFirstFileA(szTmp, &fd);
					if( pEnumObj->m_hFFile == INVALID_HANDLE_VALUE ) nErrorEnd = 1;
					else i=1;
				  } else {
					if( !FindNextFileA(pEnumObj->m_hFFile, &fd) ) nErrorEnd = 1;
					else i++;
				  }
				  if ( !nErrorEnd )
				  {
					if( !strcmp(fd.cFileName, ".") || !strcmp(fd.cFileName, "..") ) 
                                        {
						continue;
                                        }
				  }
				} // end of FOR loop
			}
		}
		
		if ( nErrorEnd ) hr = E_UNEXPECTED;
		else hr=S_OK;
    }
Error:
    hrLogDWORD("IMDSPEnumStorage::Clone returned 0x%08lx", hr, hr);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Mdsp.rc
//
#define IDS_PROJNAME                    100
#define IDR_MDSERVICEPROVIDER           101
#define IDR_MDSPENUMDEVICE              102
#define IDS_STRING_SPPROGID             102
#define IDR_MDSPDEVICE                  103
#define IDR_MDSPENUMFORMATSUPPORT       104
#define IDR_MDSPENUMSTORAGE             105
#define IDR_MDSPSTORAGE                 106
#define IDR_MDSPSTORAGEGLOBALS          107
#define IDI_ICON_PM                     201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\mdspenumstorage.h ===
// MDSPEnumStorage.h : Declaration of the CMDSPEnumStorage

#ifndef __MDSPENUMSTORAGE_H_
#define __MDSPENUMSTORAGE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMDSPEnumStorage
class ATL_NO_VTABLE CMDSPEnumStorage : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMDSPEnumStorage, &CLSID_MDSPEnumStorage>,
	public IMDSPEnumStorage
{
public:
	CMDSPEnumStorage();
	~CMDSPEnumStorage();
	

DECLARE_REGISTRY_RESOURCEID(IDR_MDSPENUMSTORAGE)

BEGIN_COM_MAP(CMDSPEnumStorage)
	COM_INTERFACE_ENTRY(IMDSPEnumStorage)
END_COM_MAP()

// IMDSPEnumStorage

public:
	WCHAR m_wcsPath[MAX_PATH];
	HANDLE m_hFFile;
	int	  m_nEndSearch;
	int   m_nFindFileIndex;
	STDMETHOD(Clone)(/*[out]*/ IMDSPEnumStorage **ppEnumStorage);
	STDMETHOD(Reset)();
	STDMETHOD(Skip)(/*[in]*/ ULONG celt, /*[out]*/ ULONG *pceltFetched);
	STDMETHOD(Next)(/*[in]*/ ULONG celt, /*[out]*/ IMDSPStorage **ppStorage, /*[out]*/ ULONG *pceltFetched);
};

#endif //__MDSPENUMSTORAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\mdspstorage.cpp ===
// MDSPStorage.cpp : Implementation of CMDSPStorage
#include "stdafx.h"
#include "MsPMSP.h"
#include "MDSPStorage.h"
#include "MDSPEnumStorage.h"
#include "MdspDefs.h"
#include "MDSPStorageGlobals.h"
#include "loghelp.h"
#include "wmsstd.h"
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

#define	CONEg(p)\
	do\
		{\
		if (!(p))\
			{\
			hr = WMDM_E_INTERFACEDEAD;\
			goto Error;\
			}\
		}\
	while (fFalse)

typedef struct __MOVETHREADARGS
{
    WCHAR wcsSrc[MAX_PATH];
	WCHAR wcsDst[MAX_PATH];
	BOOL  bNewThread;
    IWMDMProgress *pProgress;
	LPSTREAM pStream;
    CMDSPStorage *pThis;
	DWORD dwStatus;
} MOVETHREADARGS;


/////////////////////////////////////////////////////////////////////////////
// CMDSPStorage
CMDSPStorage::CMDSPStorage()
{
    m_hFile = INVALID_HANDLE_VALUE;
    m_bIsDirectory = FALSE;             // This needs to be set to a correct value after creation.
    m_wcsName[0] = 0;
    m_szTmp[0] = 0;
}

CMDSPStorage::~CMDSPStorage()
{
	if( m_hFile != INVALID_HANDLE_VALUE )
	{
		FlushFileBuffers(m_hFile);
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}

}


STDMETHODIMP CMDSPStorage::GetStorageGlobals(IMDSPStorageGlobals **ppStorageGlobals)
{
	HRESULT hr;
    int i;
    BOOL bLocked = 0;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	g_CriticalSection.Lock();
        bLocked = 1;

	CARg(ppStorageGlobals);
	CONEg(m_wcsName[0]);

	WCHAR devName[MAX_PATH], *pW;
	pW=&devName[0];
	hr = wcsParseDeviceName(m_wcsName, pW, ARRAYSIZE(devName));
        if (FAILED(hr))
        {
            goto Error;
        }

	for(i=0; i<MDSP_MAX_DEVICE_OBJ;i++)
	{
		if( !wcscmp(g_GlobalDeviceInfo[i].wcsDevName, devName) )
		{
				break;
		}
	}

	if( i<MDSP_MAX_DEVICE_OBJ && g_GlobalDeviceInfo[i].pIMDSPStorageGlobals ) // found match
	{
		*ppStorageGlobals = (IMDSPStorageGlobals *)g_GlobalDeviceInfo[i].pIMDSPStorageGlobals;
		((IMDSPStorageGlobals *)g_GlobalDeviceInfo[i].pIMDSPStorageGlobals)->AddRef();
		hr = S_OK;
	} else { // new entry in the global array
		if(!(i<MDSP_MAX_DEVICE_OBJ) ) // no match found 
		{
			for(i=0; i<MDSP_MAX_DEVICE_OBJ;i++)
			{
				if( !g_GlobalDeviceInfo[i].bValid )
				{
					break;
				}
			}
		}

		CPRg(i<MDSP_MAX_DEVICE_OBJ);

		CComObject<CMDSPStorageGlobals> *pObj;
		CORg(CComObject<CMDSPStorageGlobals>::CreateInstance(&pObj));
		hr=pObj->QueryInterface(IID_IMDSPStorageGlobals, reinterpret_cast<void**>(&g_GlobalDeviceInfo[i].pIMDSPStorageGlobals));
		if( FAILED(hr) )
			delete pObj;
		else {
                    HRESULT hrTemp;
                        
                        // wcscpy(pObj->m_wcsName, devName);
			hrTemp = StringCchCopyW(pObj->m_wcsName, ARRAYSIZE(pObj->m_wcsName), devName);
                        if (FAILED(hrTemp))
                        {
                            ((IUnknown*) (g_GlobalDeviceInfo[i].pIMDSPStorageGlobals))->Release();
                            g_GlobalDeviceInfo[i].pIMDSPStorageGlobals = NULL;
                            hr = hrTemp;
                            goto Error;
                        }

			// wcscpy(g_GlobalDeviceInfo[i].wcsDevName, devName);
			hrTemp = StringCchCopyW(g_GlobalDeviceInfo[i].wcsDevName,
                                    ARRAYSIZE(g_GlobalDeviceInfo[i].wcsDevName), devName);
                        if (FAILED(hrTemp))
                        {
                            ((IUnknown*) (g_GlobalDeviceInfo[i].pIMDSPStorageGlobals))->Release();
                            g_GlobalDeviceInfo[i].pIMDSPStorageGlobals = NULL;
                            g_GlobalDeviceInfo[i].wcsDevName[0] = 0;
                            hr = hrTemp;
                            goto  Error;
                        }

			*ppStorageGlobals = (IMDSPStorageGlobals *)g_GlobalDeviceInfo[i].pIMDSPStorageGlobals;
			g_GlobalDeviceInfo[i].bValid=TRUE;			        
			g_GlobalDeviceInfo[i].dwStatus = 0;
		} // end of else
	} // end of else
Error:	
    if (bLocked)
    {
        g_CriticalSection.Unlock();
    }
    
    hrLogDWORD("IMDSPStorage::GetStorageGlobals returned 0x%08lx", hr, hr);
	
    return hr;
}

STDMETHODIMP CMDSPStorage::SetAttributes(DWORD dwAttributes, _WAVEFORMATEX *pFormat)
{
	HRESULT hr=E_FAIL;
    DWORD dwAttrib;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
    CONEg(m_wcsName[0]);

	dwAttrib = UtilGetFileAttributesW(m_wcsName);
	
	if( dwAttrib == (DWORD)0xFFFFFFFF ) return HRESULT_FROM_WIN32(GetLastError());

	if( (dwAttributes & WMDM_FILE_ATTR_READONLY) )
	{
		dwAttrib |= FILE_ATTRIBUTE_READONLY; 
	} else {
        dwAttrib &= (~FILE_ATTRIBUTE_READONLY); 
    }

	if( (dwAttributes & WMDM_FILE_ATTR_HIDDEN) )
	{
		dwAttrib |= FILE_ATTRIBUTE_HIDDEN; 
	} else {
		dwAttrib &= (~FILE_ATTRIBUTE_HIDDEN); 
	}
	
	if( (dwAttributes & WMDM_FILE_ATTR_SYSTEM) )
	{
		dwAttrib |= FILE_ATTRIBUTE_SYSTEM; 
	} else {
		dwAttrib &= (~FILE_ATTRIBUTE_SYSTEM);
	}

    CWRg(UtilSetFileAttributesW(m_wcsName, dwAttrib));
 
	hr=S_OK;
Error:

    hrLogDWORD("IMDSPStorage::SetAttributes returned 0x%08lx", hr, hr);

	return hr;
}



STDMETHODIMP CMDSPStorage::GetAttributes(DWORD * pdwAttributes, _WAVEFORMATEX * pFormat)
{
	HRESULT hr=S_OK;
    DWORD dwAttrib;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pdwAttributes);
// 	CARg(pFormat);        pFormet can be NULL.
    CONEg(m_wcsName[0]);

	dwAttrib = UtilGetFileAttributesW(m_wcsName);

	if( dwAttrib == (DWORD)0xFFFFFFFF ) return HRESULT_FROM_WIN32(GetLastError());

	*pdwAttributes = ( WMDM_STORAGE_ATTR_REMOVABLE |
		WMDM_STORAGE_ATTR_FOLDERS | WMDM_FILE_ATTR_CANREAD );

	if( !(dwAttrib & FILE_ATTRIBUTE_READONLY) )
	{
		*pdwAttributes |= (WMDM_FILE_ATTR_CANDELETE |
			WMDM_FILE_ATTR_CANMOVE | WMDM_FILE_ATTR_CANRENAME); 
	}

	if( dwAttrib & FILE_ATTRIBUTE_DIRECTORY )
	{
		*pdwAttributes |= WMDM_FILE_ATTR_FOLDER;
		QuerySubFoldersAndFiles(m_wcsName, pdwAttributes); // No failure check, if failed, just keep current attributes
	} else {
		*pdwAttributes |= WMDM_FILE_ATTR_FILE;
    }

    // Now handle Hidden, ReadOnly, and System attributes
	if( (dwAttrib & FILE_ATTRIBUTE_READONLY) )
	{
		*pdwAttributes |= WMDM_FILE_ATTR_READONLY; 
	} 

	if( (dwAttrib & FILE_ATTRIBUTE_HIDDEN) )
	{
		*pdwAttributes |= WMDM_FILE_ATTR_HIDDEN; 
	} 
	
	if( (dwAttrib & FILE_ATTRIBUTE_SYSTEM) )
	{
		*pdwAttributes |= WMDM_FILE_ATTR_SYSTEM; 
	} 
    
	hr=S_OK; 
Error:

    hrLogDWORD("IMDSPStorage::GetAttributes returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPStorage::GetName(LPWSTR pwszName, UINT nMaxChars)
{
	HRESULT hr=S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
    
	CONEg(m_wcsName[0]);
	CARg(pwszName);
	CPRg(wcslen(m_wcsName)<nMaxChars);

	if( m_wcsName[wcslen(m_wcsName)-1] == 0x5c ) // this is root storage
	{
		wcscpy(pwszName, wcsrchr(m_wcsName, 0x5c));
	} else 
		wcscpy(pwszName, wcsrchr(m_wcsName, 0x5c)+1);

Error:

    hrLogDWORD("IMDSPStorage::GetName returned 0x%08lx", hr, hr);

	return hr;
}



STDMETHODIMP CMDSPStorage::GetDate(PWMDMDATETIME pDateTimeUTC)
{
	HRESULT hr=E_FAIL;
    HANDLE hFFile = INVALID_HANDLE_VALUE;
    SYSTEMTIME sysTime;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
    {
        CORg(WMDM_E_NOTCERTIFIED);
    }
	
    CARg(pDateTimeUTC);
    CONEg(m_wcsName[0]);

    if( g_bIsWinNT )
    {
        WIN32_FIND_DATAW wfd;

        if( m_bIsDirectory )
        {
            // Get name and date of current directory 
            WCHAR   pwszTmpFile[MAX_PATH+1+BACKSLASH_STRING_LENGTH];
            HRESULT hrTemp;

            // wcscpy( pwszTmpFile, m_wcsName );
            hrTemp = StringCchCopyW( pwszTmpFile, ARRAYSIZE(pwszTmpFile)-2, m_wcsName );
            if (FAILED(hrTemp))
            {
                hr = hrTemp;
                goto Error;
            }
            if( pwszTmpFile[wcslen(pwszTmpFile)-1] != 0x5c )
            {
                wcscat(pwszTmpFile, g_wcsBackslash);
            }
            wcscat(pwszTmpFile, L".");
            hFFile=FindFirstFileW(pwszTmpFile, &wfd);
        } 
        else
        {
            hFFile=FindFirstFileW(m_wcsName, &wfd);
        }

        CWRg(hFFile != INVALID_HANDLE_VALUE);
        CFRg(FileTimeToSystemTime((CONST FILETIME *)&(wfd.ftLastWriteTime), &sysTime));
    } 
    else 
    {
		WIN32_FIND_DATAA fd;
		WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, m_szTmp, MAX_PATH, NULL, NULL);	
		if( m_bIsDirectory )
		{
			if( m_szTmp[strlen(m_szTmp)-1] != 0x5c ) 
            {
                strcat(m_szTmp, g_szBackslash);
            }
			strcat(m_szTmp, ".");
		} 

		hFFile=FindFirstFileA(m_szTmp, &fd);
		CWRg(hFFile != INVALID_HANDLE_VALUE);
		CFRg(FileTimeToSystemTime((CONST FILETIME *)&(fd.ftLastWriteTime), &sysTime));
    }

    pDateTimeUTC->wYear = sysTime.wYear; 
    pDateTimeUTC->wMonth = sysTime.wMonth; 
    pDateTimeUTC->wDay = sysTime.wDay; 
    pDateTimeUTC->wHour = sysTime.wHour; 
    pDateTimeUTC->wMinute = sysTime.wMinute; 
    pDateTimeUTC->wSecond = sysTime.wSecond; 

	hr=S_OK;


Error:
	if(hFFile != INVALID_HANDLE_VALUE) 
		FindClose(hFFile);

    hrLogDWORD("IMDSPStorage::GetDate returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPStorage::GetSize(DWORD * pdwSizeLow, DWORD * pdwSizeHigh)
{
	HRESULT hr=S_OK;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwLS, dwHS;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pdwSizeLow);
	CONEg(m_wcsName[0]);

    dwLS = 0;
	dwHS = 0;

	if( g_bIsWinNT )
	{
#ifndef DO_RECURSIVE_GET_SIZE
		if( m_bIsDirectory )
		{
			*pdwSizeLow=0;
			*pdwSizeHigh=0;
			hr=S_OK;
			goto Error;
		}
#endif
		CORg(GetFileSizeRecursiveW(m_wcsName, &dwLS, &dwHS));
	} else { // On Win9x, use A-version of Win32 APIs
		WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, m_szTmp, MAX_PATH, NULL, NULL);	

#ifndef DO_RECURSIVE_GET_SIZE
		if( m_bIsDirectory )
		{
			*pdwSizeLow=0;
			*pdwSizeHigh=0;
			hr=S_OK;
			goto Error;
		}
#endif
		CORg(GetFileSizeRecursiveA(m_szTmp, &dwLS, &dwHS));
    }
	
	*pdwSizeLow = dwLS;
	if(pdwSizeHigh) *pdwSizeHigh=dwHS;

Error:

    hrLogDWORD("IMDSPStorage::GetSize returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPStorage::GetRights(PWMDMRIGHTS *ppRights,UINT *pnRightsCount,
									 BYTE abMac[WMDM_MAC_LENGTH])
{
	HRESULT hr=WMDM_E_NOTSUPPORTED;

    CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
Error:
	hrLogDWORD("IMDSPStorage::GetRights returned 0x%08lx", hr, hr);

	return hr;
}

STDMETHODIMP CMDSPStorage::CreateStorage(DWORD dwAttributes, _WAVEFORMATEX * pFormat, LPWSTR pwszName, IMDSPStorage * * ppNewStorage)
{
    HRESULT hr=E_FAIL;
    HRESULT hrTemp;
    HANDLE hFile;
    WCHAR *pwcs, wcsCopy[MAX_PATH];
    DWORD fsAttrib=FILE_ATTRIBUTE_NORMAL;
    
    CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
    {
        CORg(WMDM_E_NOTCERTIFIED);
    }
	
    CONEg(m_wcsName[0]);
    CARg(pwszName);
    CARg(ppNewStorage);

    *ppNewStorage = NULL;

    hrTemp = StringCchCopyW(wcsCopy, ARRAYSIZE(wcsCopy), m_wcsName);
    if (FAILED(hrTemp))
    {
        hr = hrTemp;
        goto Error;
    }
    if( wcsCopy[wcslen(wcsCopy)-1] == 0x5c ) 
            wcsCopy[wcslen(wcsCopy)-1] = NULL;  // trim the last backslash;

    if(  !(m_bIsDirectory ) ) // if current storage is a file
    {
        if( dwAttributes & WMDM_STORAGECONTROL_INSERTINTO )
        {
            CORg(WMDM_E_NOTSUPPORTED); // can't do InsertInto
        } 
        else 
        { // for file, the default is Before&After
            pwcs=wcsrchr(wcsCopy, g_wcsBackslash[0]);
            CFRg(pwcs);	
        }
    } 
    else 
    {  // current storage is a dir
        if( (dwAttributes & WMDM_STORAGECONTROL_INSERTBEFORE) ||
            (dwAttributes & WMDM_STORAGECONTROL_INSERTAFTER) ) // before or after
        {
            pwcs=wcsrchr(wcsCopy, g_wcsBackslash[0]);
            CFRg(pwcs);
        } 
        else 
        { // for dir, the default is InsertInto
            pwcs=wcsCopy+wcslen(wcsCopy);
        }
    }

    // wcscpy(pwcs, g_wcsBackslash);
    hrTemp = StringCchCopyW(pwcs, ARRAYSIZE(wcsCopy) - (pwcs - wcsCopy), g_wcsBackslash);
    if (FAILED(hrTemp))
    {
        hr = hrTemp;
        goto Error;
    }
    // wcscat(pwcs, pwszName);
    hrTemp = StringCchCatW(pwcs, ARRAYSIZE(wcsCopy) - (pwcs - wcsCopy), pwszName);
    if (FAILED(hrTemp))
    {
        hr = hrTemp;
        goto Error;
    }

    // Validate buffersize for the storage that we will create. Do this 
    // before the directory/file is created.
    // if( hr==S_OK )
    {
        CComObject<CMDSPStorage> *pObj;
        CORg(CComObject<CMDSPStorage>::CreateInstance(&pObj));

        hr=pObj->QueryInterface(IID_IMDSPStorage, reinterpret_cast<void**>(ppNewStorage));
        if( FAILED(hr) )
        {
            delete pObj;
            *ppNewStorage = NULL; // Should be so, but this is safer.
            goto Error;
        }
        else 
        {
            // wcscpy(pObj->m_wcsName, wcsCopy);
            hrTemp = StringCchCopyW(pObj->m_wcsName, ARRAYSIZE(pObj->m_wcsName), wcsCopy);
            if (FAILED(hrTemp))
            {
                hr = hrTemp;
                goto Error;
            }
            pObj->m_bIsDirectory = ((dwAttributes & WMDM_FILE_ATTR_FOLDER) != 0);
        }
    }

    // Find what file system attribute the intend storage should be
    if( dwAttributes & WMDM_FILE_ATTR_HIDDEN )
            fsAttrib |= FILE_ATTRIBUTE_HIDDEN;
    if( dwAttributes & WMDM_FILE_ATTR_SYSTEM )
            fsAttrib |= FILE_ATTRIBUTE_SYSTEM;
    if( dwAttributes & WMDM_FILE_ATTR_READONLY )
            fsAttrib |= FILE_ATTRIBUTE_READONLY;

    hr = E_FAIL;
    if( dwAttributes & WMDM_FILE_ATTR_FOLDER )
    {
        if(UtilCreateDirectoryW(wcsCopy, NULL)) 
        {
            hr=S_OK;
        }
        else 
        {
            hr=GetLastError();
            if( hr == ERROR_ALREADY_EXISTS ) 
            {
                if( dwAttributes & WMDM_FILE_CREATE_OVERWRITE ) 
                {
                    hr=S_OK;
                } 
                else 
                {
                    hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
                }
            }
            else 
            {
                hr = HRESULT_FROM_WIN32(hr);
                goto Error;
            }
        }

        if( S_OK == hr )
        {
            CWRg(UtilSetFileAttributesW(wcsCopy, fsAttrib));
        }
    } 
    else if ( dwAttributes & WMDM_FILE_ATTR_FILE ) 
    { 
        // If Overwrite is specified, use CREATE_ALWAYS
        if( dwAttributes & WMDM_FILE_CREATE_OVERWRITE )
        {
            hFile=UtilCreateFileW(wcsCopy,  GENERIC_WRITE | GENERIC_READ, 
                                  FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
                                  CREATE_ALWAYS, fsAttrib, NULL);

        } 
        else 
        {
            hFile=UtilCreateFileW(wcsCopy,  GENERIC_WRITE | GENERIC_READ, 
                                  FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
                                  CREATE_NEW, fsAttrib, NULL);
        }

        CWRg(hFile != INVALID_HANDLE_VALUE); 
        FlushFileBuffers(hFile);
        CloseHandle(hFile);
        hr=S_OK;
    } 
    else 
    {
        hr=E_INVALIDARG;
        goto Error;
    }
            
	
Error:

    if (FAILED(hr))
    {
        if ((*ppNewStorage) != NULL)
        {
            (*ppNewStorage)->Release();
            *ppNewStorage = NULL;
        }
    }
    hrLogDWORD("IMDSPStorage::CreateStorage returned 0x%08lx", hr, hr);

    return hr;
}

STDMETHODIMP CMDSPStorage::SendOpaqueCommand(OPAQUECOMMAND *pCommand)
{
    HRESULT hr = WMDM_E_NOTSUPPORTED;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
    
Error:
	hrLogDWORD("IMDSPStorage::SendOpaqueCommand returned 0x%08lx", hr, hr);
    
	return hr;
}

// IMDSPStorage2
STDMETHODIMP CMDSPStorage::GetStorage( 
    LPCWSTR pszStorageName, 
    IMDSPStorage** ppStorage )
{
    HRESULT hr = S_FALSE;
    HRESULT hrTemp;
    WCHAR   pwszFileName[MAX_PATH];
    DWORD   dwAttrib;
    CComObject<CMDSPStorage> *pStg = NULL;

	if( !m_bIsDirectory )
    {
        // This storage is not a directory/folder
        goto Error;
    }

    DWORD dwLen = wcslen(m_wcsName);

    if (dwLen == 0)
    {
        hr = E_FAIL;
        goto Error;
    }
    if (dwLen >= ARRAYSIZE(pwszFileName))
    {
        hr = STRSAFE_E_INSUFFICIENT_BUFFER; // defined in strsafe.h
        goto Error;
    }

    // Get name of file asked for
    wcscpy( pwszFileName, m_wcsName );
    if( pwszFileName[dwLen-1] != L'\\' ) 
    {
        if (dwLen >= ARRAYSIZE(pwszFileName) - 1)
        {
            hr = STRSAFE_E_INSUFFICIENT_BUFFER; // defined in strsafe.h
            goto Error;
        }
        wcscat( pwszFileName, L"\\" );
    }
    hrTemp = StringCchCatW( pwszFileName,
                            ARRAYSIZE(pwszFileName),
                            pszStorageName );

    if (FAILED(hrTemp))
    {
        // The storage does not exist
        hr = S_FALSE;
        goto Error;
    }

    // Check if the storage exists (NT)
    if( g_bIsWinNT )
    {
        dwAttrib = GetFileAttributesW( pwszFileName );
        if( dwAttrib == -1 ) 
        {
            // The storage does not exist
            hr = S_FALSE;
            goto Error;
        }
    }
    // For Win9x use A-version of Win32 APIs
    else 
	{
		WideCharToMultiByte(CP_ACP, NULL, pwszFileName, -1, m_szTmp, MAX_PATH, NULL, NULL);		
        dwAttrib = GetFileAttributesA( m_szTmp );
        if( dwAttrib == -1 )
        {
            // The storage does not exist
            hr = S_FALSE;
            goto Error;
        }
    }

    // Create new storage object
    hr = CComObject<CMDSPStorage>::CreateInstance(&pStg);
	hr = pStg->QueryInterface( IID_IMDSPStorage, reinterpret_cast<void**>(ppStorage));
    hrTemp = StringCchCopyW(pStg->m_wcsName, ARRAYSIZE(pStg->m_wcsName), pwszFileName);
    if (FAILED(hrTemp))
    {
        hr = hrTemp;
        (*ppStorage)->Release();
        pStg = NULL; // to prevent its deletion below
        goto Error;
    }
    pStg->m_bIsDirectory = ((dwAttrib & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY );

Error:
    if( hr != S_OK )
    {
        if( pStg ) delete pStg;
        *ppStorage = NULL;
    }

    return hr;
}
 
STDMETHODIMP CMDSPStorage::CreateStorage2(  
    DWORD dwAttributes,
	DWORD dwAttributesEx,
    _WAVEFORMATEX *pAudioFormat,
    _VIDEOINFOHEADER *pVideoFormat,
    LPWSTR pwszName,
	ULONGLONG  qwFileSize,
    IMDSPStorage **ppNewStorage )
{
    // pVideoFormat, dwAttributesEx not used right now
    return CreateStorage( dwAttributes, pAudioFormat, pwszName, ppNewStorage );
}


STDMETHODIMP CMDSPStorage::SetAttributes2(  
    DWORD dwAttributes, 
	DWORD dwAttributesEx, 
	_WAVEFORMATEX *pAudioFormat,
	_VIDEOINFOHEADER* pVideoFormat )
{
    // pVideoFormat, dwAttributesEx not used right now
    return SetAttributes( dwAttributes, pAudioFormat );
}

STDMETHODIMP CMDSPStorage::GetAttributes2(  
    DWORD *pdwAttributes,
	DWORD *pdwAttributesEx,
    _WAVEFORMATEX *pAudioFormat,
	_VIDEOINFOHEADER* pVideoFormat )
{
    HRESULT hr = S_OK;

    CARg( pdwAttributesEx );
    *pdwAttributesEx = 0;

    // pVideoFormat, dwAttributesEx not used right now
    hr = GetAttributes( pdwAttributes, pAudioFormat );

Error:
    return hr;
}

// IMDSPObjectInfo
STDMETHODIMP CMDSPStorage::GetPlayLength(/*[out]*/ DWORD *pdwLength)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	if ( !pdwLength )
		hr = E_INVALIDARG;
	else 
		hr = WMDM_E_NOTSUPPORTED;    // For PMSP

Error:
    hrLogDWORD("IMDSPObjectInfo::GetPlayLength returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPStorage::SetPlayLength(/*[in]*/ DWORD dwLength)
{
    HRESULT hr = WMDM_E_NOTSUPPORTED;    // For PMSP

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
    
Error:

	hrLogDWORD("IMDSPObjectInfo::SetPlayLength returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPStorage::GetPlayOffset(/*[out]*/ DWORD *pdwOffset)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	if ( !pdwOffset )
		hr = E_INVALIDARG;
	else 
		hr = WMDM_E_NOTSUPPORTED;    // For PMSP

Error:
    hrLogDWORD("IMDSPObjectInfo::GetPlayOffset returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPStorage::SetPlayOffset(/*[in]*/ DWORD dwOffset)
{
    HRESULT hr = WMDM_E_NOTSUPPORTED;    // For PMSP

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
    
Error:
	hrLogDWORD("IMDSPObjectInfo::SetPlayOffset returned 0x%08lx", hr, hr);
	return hr;
}	

STDMETHODIMP CMDSPStorage::GetTotalLength(/*[out]*/ DWORD *pdwLength)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	if ( !pdwLength )
		hr = E_INVALIDARG;
	else 
		hr = WMDM_E_NOTSUPPORTED;    // For PMSP

Error:
    hrLogDWORD("IMDSPObjectInfo::GetTotalLength returned 0x%08lx", hr, hr);

	return hr;
}	

STDMETHODIMP CMDSPStorage::GetLastPlayPosition(/*[out]*/ DWORD *pdwLastPos)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	if ( !pdwLastPos )
		hr = E_INVALIDARG;
	else 
		hr = WMDM_E_NOTSUPPORTED;    // For PMSP

Error:
    hrLogDWORD("IMDSPObjectInfo::GetLastPlayPosition returned 0x%08lx", hr, hr);

    return hr;
}

STDMETHODIMP CMDSPStorage::GetLongestPlayPosition(/*[out]*/ DWORD *pdwLongestPos)
{
    HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	if ( !pdwLongestPos )
		hr = E_INVALIDARG;
	else 
		hr = WMDM_E_NOTSUPPORTED;    // For PMSP

Error:
    hrLogDWORD("IMDSPObjectInfo::GetLongestPlayPosition returned 0x%08lx", hr, hr);

	return hr;

}
// IMDSPObject

STDMETHODIMP CMDSPStorage::Open(/*[in]*/ UINT fuMode)
{
	HRESULT hr;
	DWORD dwMode;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CONEg(m_wcsName[0]);

	if( m_hFile != INVALID_HANDLE_VALUE ) 
	{
		hr = WMDM_E_BUSY;
		goto Error;
	}

	if( m_bIsDirectory ) 
    {
        hr=WMDM_E_NOTSUPPORTED;
    }
	else 
    {
		dwMode = 0;
		if(fuMode & MDSP_WRITE )
			dwMode |= GENERIC_WRITE;
		if(fuMode & MDSP_READ ) 
			dwMode |= GENERIC_READ;
		m_hFile=UtilCreateFileW(m_wcsName, dwMode, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
			OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if( m_hFile == INVALID_HANDLE_VALUE )
			hr = E_FAIL;
		else 
			hr = S_OK;
	}
Error:

    hrLogDWORD("IMDSPObject::Open returned 0x%08lx", hr, hr);
	return hr;
}	

STDMETHODIMP CMDSPStorage::Read(BYTE *pData, DWORD *pdwSize,
								BYTE abMac[WMDM_MAC_LENGTH])
{
	HRESULT hr;
	DWORD dwToRead, dwRead=NULL;
    BYTE *pTmpData=NULL; 
	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pData);
	CARg(pdwSize);

	dwToRead=*pdwSize;

	if ( m_hFile == INVALID_HANDLE_VALUE ) return E_FAIL;
    
	pTmpData = new BYTE [dwToRead] ;

	CPRg(pTmpData);

	if( ReadFile(m_hFile,(LPVOID)pTmpData,dwToRead,&dwRead,NULL) ) 
	{ 
		*pdwSize = dwRead; 

		if( dwRead )
		{
			// MAC the parameters
			HMAC hMAC;
			
			CORg(g_pAppSCServer->MACInit(&hMAC));
			CORg(g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pTmpData), dwRead));
			CORg(g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pdwSize), sizeof(DWORD)));
			CORg(g_pAppSCServer->MACFinal(hMAC, abMac));
  			
			CORg(g_pAppSCServer->EncryptParam(pTmpData, dwRead));
			
			memcpy(pData, pTmpData, dwRead);
        }
		hr = S_OK; 
	} else { 
		*pdwSize = 0; 
		hr = E_FAIL; 
	}
Error:
    hrLogDWORD("IMDSPObject::Read returned 0x%08lx", hr, hr);
	
	if(pTmpData) 
	{
		delete [] pTmpData;
	}

	return hr;
}	

STDMETHODIMP CMDSPStorage::Write(BYTE *pData, DWORD *pdwSize,
								 BYTE abMac[WMDM_MAC_LENGTH])
{
	HRESULT hr;
	DWORD dwWritten=0;
    BYTE *pTmpData=NULL;
    BYTE pSelfMac[WMDM_MAC_LENGTH];

	CARg(pData);
	CARg(pdwSize);

	if ( m_hFile == INVALID_HANDLE_VALUE ) return E_FAIL;

	if( *pdwSize == 0 ) return S_OK;

	pTmpData = new BYTE [*pdwSize];
	CPRg(pTmpData);
    memcpy(pTmpData, pData, *pdwSize);

    // Decrypt the pData Parameter
	CHRg(g_pAppSCServer->DecryptParam(pTmpData, *pdwSize));
	
	HMAC hMAC;
	CORg(g_pAppSCServer->MACInit(&hMAC));
	CORg(g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pTmpData), *pdwSize));
	CORg(g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pdwSize), sizeof(*pdwSize)));
	CORg(g_pAppSCServer->MACFinal(hMAC, pSelfMac));

	if (memcmp(abMac, pSelfMac, WMDM_MAC_LENGTH) != 0)
	{
		hr = WMDM_E_MAC_CHECK_FAILED;
		goto Error;
	}

	if( WriteFile(m_hFile,pTmpData,*pdwSize,&dwWritten,NULL) ) 
	{
		hr = S_OK;
    }
	else 
		hr = HRESULT_FROM_WIN32(GetLastError());

	*pdwSize = dwWritten;

Error:
    hrLogDWORD("IMDSPObject::Write returned 0x%08lx", hr, hr);
	if( pTmpData )
	{
		delete [] pTmpData;
	}
	return hr;
}

STDMETHODIMP CMDSPStorage::Delete(UINT fuMode, IWMDMProgress *pProgress)
{
    HRESULT hr=E_FAIL;
    BOOL bProgressStarted=FALSE;
	BOOL bBusyStatusSet=FALSE;
    DWORD dwStatus=NULL;

	if( pProgress )
	{
		CORg(pProgress->Begin(100));
		bProgressStarted=TRUE;
	}
	
	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CONEg(m_wcsName[0]);

	if ( m_hFile != INVALID_HANDLE_VALUE ) 
	{
		FlushFileBuffers(m_hFile);
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}

	CHRg(GetGlobalDeviceStatus(m_wcsName, &dwStatus));
	if( dwStatus & WMDM_STATUS_BUSY )
	{
		hr=WMDM_E_BUSY;
		goto Error;
	}

	dwStatus |= (WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_DELETING );
    CHRg(SetGlobalDeviceStatus(m_wcsName, dwStatus, TRUE));
    bBusyStatusSet=TRUE;

	if( g_bIsWinNT )
	{
		if( fuMode & WMDM_MODE_RECURSIVE )
		{
			CORg(DeleteFileRecursiveW(m_wcsName));
		} 
        else 
        {
			if( m_bIsDirectory )
			{				
				CWRg(RemoveDirectoryW(m_wcsName));
			} 
            else 
            {
				CWRg(DeleteFileW(m_wcsName));
			}
		}
	} 
    else 
    {
    	WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, m_szTmp, MAX_PATH, NULL, NULL);	
		if( fuMode & WMDM_MODE_RECURSIVE )
		{
			CORg(DeleteFileRecursiveA(m_szTmp));
		} 
        else 
        {
			if( m_bIsDirectory )
			{				
				CWRg(RemoveDirectoryA(m_szTmp));
			} 
            else 
            {
				CWRg(DeleteFileA(m_szTmp));
			}
		}
	}

	hr=S_OK;
Error:
	if( bBusyStatusSet )
	{
		dwStatus &= (~(WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_DELETING ));
		SetGlobalDeviceStatus(m_wcsName, dwStatus, TRUE);
	}

	if( hr == S_OK )
	{
		m_wcsName[0]=NULL; // Nullify the storage name 
    }

	if( bProgressStarted )
	{
		pProgress->Progress( 100 );
		pProgress->End();
	}

    hrLogDWORD("IMDSPObject::Delete returned 0x%08lx", hr, hr);
	return hr;
}	

STDMETHODIMP CMDSPStorage::Seek(/*[in]*/ UINT fuFlags, /*[in]*/ DWORD dwOffset)
{
    HRESULT hr=S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CONEg(m_wcsName[0]);
	CFRg( m_hFile != INVALID_HANDLE_VALUE );
 
    DWORD dwMoveMethod;

	switch (fuFlags) {
	case MDSP_SEEK_BOF:
		dwMoveMethod = FILE_BEGIN;
		break;
	case MDSP_SEEK_CUR:
		dwMoveMethod = FILE_CURRENT;
		break;
	case MDSP_SEEK_EOF:
		dwMoveMethod = FILE_END;
		break;
	default:
		return E_INVALIDARG;
	}

	CWRg( (DWORD)0xFFFFFFFF != SetFilePointer(m_hFile, dwOffset, NULL, dwMoveMethod ) );
	
Error:
    hrLogDWORD("IMDSPObject::Seek returned 0x%08lx", hr, hr);
	return hr;
}	

STDMETHODIMP CMDSPStorage::Rename(/*[in]*/ LPWSTR pwszNewName, IWMDMProgress *pProgress)
{
	HRESULT hr;
    BOOL bProgressStarted=FALSE;
	BOOL bBusyStatusSet=FALSE;
    DWORD dwStatus;
	WCHAR *pSlash;
	WCHAR *wcsNewFullPath=NULL;

	if( pProgress )
	{
		CORg(pProgress->Begin(100));
		bProgressStarted=TRUE;
	}
	
	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pwszNewName);
	CONEg(m_wcsName[0]);
    CFRg(wcslen(m_wcsName)>3);  // cannot rename a root storage



	if ( m_hFile != INVALID_HANDLE_VALUE ) 
	{
		FlushFileBuffers(m_hFile);
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}
	
	CHRg(GetGlobalDeviceStatus(m_wcsName, &dwStatus));

	if( dwStatus & WMDM_STATUS_BUSY )
	{
		hr=WMDM_E_BUSY;
		goto Error;
	}

	dwStatus |= (WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_MOVING );
    CHRg(SetGlobalDeviceStatus(m_wcsName, dwStatus, TRUE));
    bBusyStatusSet = TRUE;

	wcsNewFullPath = new WCHAR [wcslen(m_wcsName)+wcslen(pwszNewName)+2];
	CPRg(wcsNewFullPath);

	wcscpy(wcsNewFullPath, m_wcsName);
	if( wcsNewFullPath[wcslen(wcsNewFullPath)-1] == 0x5c ) 
		wcsNewFullPath[wcslen(wcsNewFullPath)-1] = 0; // trim last slash
	pSlash=wcsrchr(wcsNewFullPath, 0x5c);
	CFRg(pSlash);

	*(pSlash+1)=0;

	pSlash=wcsrchr(pwszNewName, 0x5c);
	if( pSlash ) 
		wcscat(wcsNewFullPath, pSlash+1);
	else 
		wcscat(wcsNewFullPath, pwszNewName);

	 
        // Validate buffer size before calling UtilMoveFile
        if (wcslen(wcsNewFullPath) >= ARRAYSIZE(m_wcsName))
        {
            hr = STRSAFE_E_INSUFFICIENT_BUFFER; // defined in strsafe.h
            goto Error;
        }
	// Now move
	CWRg( UtilMoveFileW(m_wcsName, wcsNewFullPath));

	wcscpy(m_wcsName, wcsNewFullPath);
	hr=S_OK;
	
Error:
	if( bBusyStatusSet )
	{
		dwStatus &= (~(WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_MOVING ));
		SetGlobalDeviceStatus(m_wcsName, dwStatus, TRUE);
	}
	
	if( bProgressStarted )
	{
		pProgress->Progress( 100 );
		pProgress->End();
	}
	if(wcsNewFullPath)
	{
		delete [] wcsNewFullPath;
	}
    hrLogDWORD("IMDSPObject::Rename returned 0x%08lx", hr, hr);
	return hr;
}


STDMETHODIMP CMDSPStorage::EnumStorage(IMDSPEnumStorage * * ppEnumStorage)
{
	HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(ppEnumStorage);
	CONEg(m_wcsName[0]);

	if( !m_bIsDirectory ) return WMDM_E_NOTSUPPORTED;
	
	CComObject<CMDSPEnumStorage> *pEnumObj;
	CORg(CComObject<CMDSPEnumStorage>::CreateInstance(&pEnumObj));
	hr=pEnumObj->QueryInterface(IID_IMDSPEnumStorage, reinterpret_cast<void**>(ppEnumStorage));
	if( FAILED(hr) )
		delete pEnumObj;
	else 
        {
            hr = StringCchCopyW(pEnumObj->m_wcsPath,
                                ARRAYSIZE(pEnumObj->m_wcsPath), m_wcsName);
            if (FAILED(hr))
            {
                (*ppEnumStorage)->Release();
                *ppEnumStorage = NULL;
            }
        }

Error:	
    hrLogDWORD("IMDSPStorage::EnumStorage returned 0x%08lx", hr, hr);
	return hr;
}

STDMETHODIMP CMDSPStorage::Close()
{
    HRESULT hr=S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CONEg(m_wcsName[0]);
	if( m_hFile != INVALID_HANDLE_VALUE ) 
	{
		FlushFileBuffers(m_hFile);
		CloseHandle(m_hFile);
		m_hFile=INVALID_HANDLE_VALUE;
	}
Error:
    hrLogDWORD("IMDSPObject::Close returned 0x%08lx", hr, hr);
	return hr;
}

DWORD MoveFunc( void *args )
{
	HRESULT hr=S_OK;
	MOVETHREADARGS *pCMArgs;
    WCHAR *pWcs;

	pCMArgs = (MOVETHREADARGS *)args;

	if( pCMArgs->bNewThread )
    {
		CORg(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED));

		if( pCMArgs->pProgress )
		{
			CORg(CoGetInterfaceAndReleaseStream(pCMArgs->pStream,
				IID_IWMDMProgress, (LPVOID *)&(pCMArgs->pProgress)));
		}
 	}

	pWcs = wcsrchr(pCMArgs->wcsSrc, 0x5c);
    if(!pWcs) 
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
		goto Error;
	}

        DWORD dwDestLen = wcslen(pCMArgs->wcsDst);
        if (dwDestLen == 0)
        {
            // Code below assumes this string is at least one long
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            goto Error;
        }

        // Validate buffer sizes before the string copies
        int nHave = ARRAYSIZE(pCMArgs->wcsDst) - 1; // -1 for NULL terminator
        nHave -= dwDestLen;
	if( pCMArgs->wcsDst[dwDestLen-1] != 0x5c ) 
        {
            nHave -= BACKSLASH_STRING_LENGTH;
        }
        nHave -= wcslen(pWcs+1);
        if (nHave < 0)
        {
            hr = STRSAFE_E_INSUFFICIENT_BUFFER; // defined in strsafe.h
            goto Error;
        }

        // Validate the buffer size of pCMArgs->pThis->m_wcsName before
        // calling UtilMoveFile. ARRAYSIZE(pCMArgs->wcsDst) - nHave is
        // the length of the string (including the NULL terminator) 
        // that will be constructed in pCMArgs->wcsDst and copied over to 
        // pCMArgs->pThis->m_wcsName
        if (ARRAYSIZE(pCMArgs->wcsDst) - nHave > ARRAYSIZE(pCMArgs->pThis->m_wcsName))
        {
            hr = STRSAFE_E_INSUFFICIENT_BUFFER; // defined in strsafe.h
            goto Error;
        }

	if( pCMArgs->wcsDst[dwDestLen-1] != 0x5c ) 
		wcscat(pCMArgs->wcsDst,g_wcsBackslash);
	wcscat(pCMArgs->wcsDst, pWcs+1);

	CWRg( UtilMoveFileW(pCMArgs->wcsSrc,pCMArgs->wcsDst) );

	// Substitute current object name with the moved one
	wcscpy(pCMArgs->pThis->m_wcsName, pCMArgs->wcsDst);
	hr=S_OK;

Error:
	if( pCMArgs->bNewThread )
    {
		// Reset status, we've got here we must have set the status busy before
		pCMArgs->dwStatus &= (~(WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_MOVING));
		SetGlobalDeviceStatus(pCMArgs->wcsSrc, pCMArgs->dwStatus, TRUE);

		// Reset progress, we've got here we must have set the progress before
		if( pCMArgs->pProgress )
		{
			pCMArgs->pProgress->Progress(100);
			pCMArgs->pProgress->End();
			pCMArgs->pProgress->Release(); // since we did AddRef to get here
		}

		if( pCMArgs )
		{
			delete pCMArgs;
		}

		CoUninitialize();
	}

 	return hr;
}

STDMETHODIMP CMDSPStorage::Move( UINT fuMode, IWMDMProgress *pProgress, 
			                     IMDSPStorage *pTarget)
{
	HRESULT hr=E_FAIL;
	WCHAR *wcsSrc=NULL;
	WCHAR *wcsDst=NULL;
	WCHAR *pWcs=NULL;
    CMDSPStorage *pStg =NULL;
    MOVETHREADARGS *pMoveArgs=NULL;
    DWORD dwThreadID;
	DWORD dwStatus=NULL;
    BOOL bProgStarted=FALSE;
	BOOL bBusyStatusSet=FALSE;
    BOOL bThreadFailed=TRUE;
    BOOL bAddRefed=FALSE;

	// Start the progress
	if( pProgress )
	{
		CORg(pProgress->Begin(100));
		bProgStarted=TRUE;
    }
	
    CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CONEg(m_wcsName[0]);

	CHRg(GetGlobalDeviceStatus(m_wcsName, &dwStatus));

	if( dwStatus & WMDM_STATUS_BUSY )
	{
		hr=WMDM_E_BUSY;
		goto Error;
	}

	pMoveArgs = new MOVETHREADARGS;
	CPRg(pMoveArgs);
	ZeroMemory(pMoveArgs, sizeof(MOVETHREADARGS));

	dwStatus |= (WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_MOVING );
    CHRg(SetGlobalDeviceStatus(m_wcsName, dwStatus, TRUE));
    bBusyStatusSet=TRUE;

	// setup MoveArgs for MoveFunc
	pMoveArgs->dwStatus = dwStatus;
	CARg(pTarget);
	pStg = (CMDSPStorage *)pTarget;
	wcsSrc = (WCHAR *)&(pMoveArgs->wcsSrc[0]);
	CPRg(wcsSrc);
	wcsDst = (WCHAR *)&(pMoveArgs->wcsDst[0]);
    CPRg(wcsDst);

	// Make sure the source and destination are on the same device
	hr = wcsParseDeviceName(m_wcsName, wcsSrc, ARRAYSIZE(pMoveArgs->wcsSrc));
        if (FAILED(hr))
        {
            goto Error;
        }
        hr = wcsParseDeviceName(pStg->m_wcsName, wcsDst, ARRAYSIZE(pMoveArgs->wcsDst));
        if (FAILED(hr))
        {
            goto Error;
        }
	if( wcscmp(wcsSrc, wcsDst) )
	{
		hr = WMDM_E_NOTSUPPORTED; // do not support move out of the same device
		goto Error;
	}

    // Now check for target's attributes
	DWORD dwDstAttrib;

	// wcscpy(wcsSrc, m_wcsName);
        hr = StringCchCopyW(wcsSrc, ARRAYSIZE(pMoveArgs->wcsSrc), m_wcsName);
        if (FAILED(hr))
        {
            goto Error;
        }
        
        // wcscpy(wcsDst, pStg->m_wcsName);
        hr = StringCchCopyW(wcsDst, ARRAYSIZE(pMoveArgs->wcsDst), pStg->m_wcsName);
        if (FAILED(hr))
        {
            goto Error;
        }

	if ( fuMode & WMDM_STORAGECONTROL_INSERTINTO )
	{
        CHRg(pTarget->GetAttributes(&dwDstAttrib, NULL));
        CARg( dwDstAttrib & WMDM_FILE_ATTR_FOLDER ); // INSERTINFO must be to a folder
	} else {
        // Get the folder one level up
		pWcs = wcsrchr(wcsDst, 0x5c);
        CFRg(pWcs);
		*pWcs=NULL;

        CFRg( FILE_ATTRIBUTE_DIRECTORY & UtilGetFileAttributesW(wcsDst) ); // Normally shouldn't fail here
	}
 
    pMoveArgs->pThis = this;
	pMoveArgs->bNewThread =(fuMode & WMDM_MODE_THREAD)?TRUE:FALSE;
	
	// Now handle Progress marshaling 
	if( pProgress ) 
	{	
		pMoveArgs->pProgress = pProgress;
	    pProgress->AddRef();  // since we are going to use it in MoveFunc()
        bAddRefed=TRUE;

		if( pMoveArgs->bNewThread )
		{
			CORg(CoMarshalInterThreadInterfaceInStream(
				    IID_IWMDMProgress, (LPUNKNOWN)pProgress, 
				    (LPSTREAM *)&(pMoveArgs->pStream)));
		} 
	}
 
    if ( m_hFile != INVALID_HANDLE_VALUE ) 
	{
		FlushFileBuffers(m_hFile);
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}

	if( fuMode & WMDM_MODE_BLOCK )
	{
		hr = MoveFunc((void *)pMoveArgs); 
	} else if ( fuMode & WMDM_MODE_THREAD ) {
		if( CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)MoveFunc, 
			(void *)pMoveArgs, 0, &dwThreadID))
		{
			bThreadFailed=FALSE;
			hr=S_OK;
		} else {
			hr=HRESULT_FROM_WIN32(GetLastError());			
		}
	} else 
		hr = E_INVALIDARG;

Error:
	if( (fuMode&WMDM_MODE_BLOCK) || bThreadFailed ) // otherwise these will be in MoveFunc()
	{
		if( bBusyStatusSet )
		{
			dwStatus &= (~(WMDM_STATUS_BUSY | WMDM_STATUS_STORAGECONTROL_MOVING));
			SetGlobalDeviceStatus(m_wcsName, dwStatus, TRUE);
		}
		if( bProgStarted )
		{
			pProgress->Progress(100);
			pProgress->End();
        }
		if( bAddRefed )
		{
			pProgress->Release(); // since we called AddRef before calling MoveFunc()
		}

		if( pMoveArgs )
			delete pMoveArgs;
	}

	return hr /*WMDM_E_NOTSUPPORTED*/;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\mdspstorageglobals.cpp ===
// MDSPStorageGlobals.cpp : Implementation of CMDSPStorageGlobals
#include "stdafx.h"
#include "MsPMSP.h"
#include "MDSPStorageGlobals.h"
#include "MDSPStorage.h"
#include "MDSPDevice.h"
#include "MdspDefs.h"
#include "SerialNumber.h"
#include "winnt.h"
#include "loghelp.h"
#include "SHFormatDrive.h"
// #include "process.h"    /* _beginthread, _endthread */
#include "strsafe.h"

typedef struct __FORMATTHREADARGS
{
    CMDSPStorageGlobals *pThis;
	DWORD dwDriveNumber;
	BOOL  bNewThread;
    IWMDMProgress *pProgress;
	LPSTREAM pStream;
} FORMATTHREADARGS;

/////////////////////////////////////////////////////////////////////////////
// CMDSPStorageGlobals

CMDSPStorageGlobals::~CMDSPStorageGlobals()
{
	if( m_pMDSPDevice != NULL )
		m_pMDSPDevice->Release();

	for(int i=0; i<MDSP_MAX_DEVICE_OBJ;i++)
	{
		if( !wcscmp(g_GlobalDeviceInfo[i].wcsDevName, m_wcsName) )
		{
			g_GlobalDeviceInfo[i].pIMDSPStorageGlobals = NULL;
		}
	}
}

STDMETHODIMP CMDSPStorageGlobals::GetCapabilities(DWORD * pdwCapabilities)
{
    HRESULT hr = S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pdwCapabilities);

	*pdwCapabilities = 0;
	*pdwCapabilities =	WMDM_STORAGECAP_FOLDERSINROOT		| 
						WMDM_STORAGECAP_FILESINROOT			|
						WMDM_STORAGECAP_FOLDERSINFOLDERS	|
						WMDM_STORAGECAP_FILESINFOLDERS		;
Error:
    hrLogDWORD("IMDSPStorageGlobals::GetCapabilities returned 0x%08lx", hr, hr);
	return hr;
}

STDMETHODIMP CMDSPStorageGlobals::GetSerialNumber(PWMDMID pSerialNum,
												  BYTE abMac[WMDM_MAC_LENGTH])
{
	HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pSerialNum);
//	CARg((pSerialNum->cbSize)==sizeof(WMDMID));

	IMDSPDevice *pDev;		// For PM SP, device is the same as StorageGlobals
	CHRg(GetDevice(&pDev));

	hr = UtilGetSerialNumber(m_wcsName, pSerialNum, FALSE);

	pDev->Release();

	if( hr == HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED) )
	{
		hr = WMDM_E_NOTSUPPORTED;
	}

	if( hr == S_OK )
	{
		// MAC the parameters
		HMAC hMAC;
		CORg(g_pAppSCServer->MACInit(&hMAC));
		CORg(g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pSerialNum), sizeof(WMDMID)));
		CORg(g_pAppSCServer->MACFinal(hMAC, abMac));
	}

Error:
    hrLogDWORD("IMDSPStorageGlobals::GetSerialNumber returned 0x%08lx", hr, hr);
	return hr;
}

STDMETHODIMP CMDSPStorageGlobals::GetTotalSize(DWORD * pdwTotalSizeLow, DWORD * pdwTotalSizeHigh)
{
	HRESULT hr=S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pdwTotalSizeLow);
	CARg(pdwTotalSizeHigh);

	ULARGE_INTEGER i64FreeBytesToCaller, i64TotalBytes, i64FreeBytes;
	DWORD dwSectPerClust, dwBytesPerSect, dwFreeClusters, dwTotalClusters;

	if( g_bIsWinNT )
	{
		typedef BOOL (WINAPI *P_GDFSE)(LPCWSTR,PULARGE_INTEGER,PULARGE_INTEGER,PULARGE_INTEGER);
		P_GDFSE pGetDiskFreeSpaceExW;

		pGetDiskFreeSpaceExW = (P_GDFSE)GetProcAddress (GetModuleHandleW(L"kernel32.dll"),
													  "GetDiskFreeSpaceExW");
		if (pGetDiskFreeSpaceExW)
		{
			CFRg(pGetDiskFreeSpaceExW (m_wcsName,
					(PULARGE_INTEGER)&i64FreeBytesToCaller,
					(PULARGE_INTEGER)&i64TotalBytes,
					(PULARGE_INTEGER)&i64FreeBytes));
		} else {
			CFRg(GetDiskFreeSpaceW(m_wcsName, &dwSectPerClust, &dwBytesPerSect,
					&dwFreeClusters, &dwTotalClusters));

			i64TotalBytes.QuadPart = UInt32x32To64(dwBytesPerSect, dwSectPerClust*dwTotalClusters);
			// i64FreeBytesToCaller.QuadPart = UInt32x32To64(dwBytesPerSect, dwSectPerClust*dwFreeClusters);
		}
	} else { // On Win9x, use A-version of Win32 APIs
		char pszDrive[32];

		WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, pszDrive, 32, NULL, NULL);	

		typedef BOOL (WINAPI *P_GDFSE)(LPCSTR,PULARGE_INTEGER,PULARGE_INTEGER,PULARGE_INTEGER);
		P_GDFSE pGetDiskFreeSpaceEx;

		pGetDiskFreeSpaceEx = (P_GDFSE)GetProcAddress (GetModuleHandleA("kernel32.dll"),
													  "GetDiskFreeSpaceExA");
		if (pGetDiskFreeSpaceEx)
		{
			CFRg(pGetDiskFreeSpaceEx (pszDrive,
					(PULARGE_INTEGER)&i64FreeBytesToCaller,
					(PULARGE_INTEGER)&i64TotalBytes,
					(PULARGE_INTEGER)&i64FreeBytes));
		} else {
			CFRg(GetDiskFreeSpaceA(pszDrive, &dwSectPerClust, &dwBytesPerSect,
					&dwFreeClusters, &dwTotalClusters));

			i64TotalBytes.QuadPart = UInt32x32To64(dwBytesPerSect, dwSectPerClust*dwTotalClusters);
			// i64FreeBytesToCaller.QuadPart = UInt32x32To64(dwBytesPerSect, dwSectPerClust*dwFreeClusters);
		}
	}

    *pdwTotalSizeLow = i64TotalBytes.LowPart;
	*pdwTotalSizeHigh = i64TotalBytes.HighPart;

Error:
    hrLogDWORD("IMDSPStorageGlobals::GetTotalSize returned 0x%08lx", hr, hr);
    return hr;
}


STDMETHODIMP CMDSPStorageGlobals::GetTotalFree(DWORD * pdwFreeLow, DWORD * pdwFreeHigh)
{
	HRESULT hr=S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(pdwFreeLow);
	CARg(pdwFreeHigh);

	ULARGE_INTEGER i64FreeBytesToCaller, i64TotalBytes, i64FreeBytes;
	DWORD dwSectPerClust, dwBytesPerSect, dwFreeClusters, dwTotalClusters;

	if( g_bIsWinNT )
	{
		typedef BOOL (WINAPI *P_GDFSE)(LPCWSTR,PULARGE_INTEGER,PULARGE_INTEGER,PULARGE_INTEGER);
		P_GDFSE pGetDiskFreeSpaceExW;

		pGetDiskFreeSpaceExW = (P_GDFSE)GetProcAddress (GetModuleHandleW(L"kernel32.dll"),
													  "GetDiskFreeSpaceExW");
		if (pGetDiskFreeSpaceExW)
		{
			CFRg(pGetDiskFreeSpaceExW (m_wcsName,
					(PULARGE_INTEGER)&i64FreeBytesToCaller,
					(PULARGE_INTEGER)&i64TotalBytes,
					(PULARGE_INTEGER)&i64FreeBytes));
		} else {
			CFRg(GetDiskFreeSpaceW(m_wcsName, &dwSectPerClust, &dwBytesPerSect,
					&dwFreeClusters, &dwTotalClusters));

			// i64TotalBytes.QuadPart = UInt32x32To64(dwBytesPerSect, dwSectPerClust*dwTotalClusters);
			i64FreeBytesToCaller.QuadPart = UInt32x32To64(dwBytesPerSect, dwSectPerClust*dwFreeClusters);
		}

	} else { // On Win9x, use A-version of Win32 APIs
		char pszDrive[32];

		WideCharToMultiByte(CP_ACP, NULL, m_wcsName, -1, pszDrive, 32, NULL, NULL);	

		typedef BOOL (WINAPI *P_GDFSE)(LPCSTR,PULARGE_INTEGER,PULARGE_INTEGER,PULARGE_INTEGER);
		P_GDFSE pGetDiskFreeSpaceEx;

		pGetDiskFreeSpaceEx = (P_GDFSE)GetProcAddress (GetModuleHandleA("kernel32.dll"),
													  "GetDiskFreeSpaceExA");
		if (pGetDiskFreeSpaceEx)
		{
			CFRg(pGetDiskFreeSpaceEx (pszDrive,
					(PULARGE_INTEGER)&i64FreeBytesToCaller,
					(PULARGE_INTEGER)&i64TotalBytes,
					(PULARGE_INTEGER)&i64FreeBytes));
		} else {
			CFRg(GetDiskFreeSpace(pszDrive, &dwSectPerClust, &dwBytesPerSect,
					&dwFreeClusters, &dwTotalClusters));

			// i64TotalBytes.QuadPart = UInt32x32To64(dwBytesPerSect, dwSectPerClust*dwTotalClusters);
			i64FreeBytesToCaller.QuadPart = UInt32x32To64(dwBytesPerSect, dwSectPerClust*dwFreeClusters);
		}
	}

    *pdwFreeLow = i64FreeBytesToCaller.LowPart;
	*pdwFreeHigh = i64FreeBytesToCaller.HighPart;

Error:
    hrLogDWORD("IMDSPStorageGlobals::GetTotalFree returned 0x%08lx", hr, hr);
    return hr;
}

STDMETHODIMP CMDSPStorageGlobals::GetTotalBad(DWORD * pdwBadLow, DWORD * pdwBadHigh)
{
    HRESULT hr = WMDM_E_NOTSUPPORTED;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
    
Error:
	hrLogDWORD("IMDSPStorageGlobals::GetTotalBad returned 0x%08lx", hr, hr);
    
    return hr;
}

STDMETHODIMP CMDSPStorageGlobals::GetStatus(DWORD * pdwStatus)
{
	HRESULT hr;
	
	IMDSPDevice *pDev;		// For PM SP, device is the same as StorageGlobals

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}

	CHRg(GetDevice(&pDev));

	hr = pDev->GetStatus(pdwStatus);

	pDev->Release();
Error:
    hrLogDWORD("IMDSPStorageGlobals::GetStatus returned 0x%08lx", hr, hr);
	return hr;
}

DWORD DriveFormatFunc( void *dn )
{ 
    HRESULT hr=S_OK;
    FORMATTHREADARGS *pChildArgs=NULL;
    BOOL bProgStarted=FALSE;

	pChildArgs = (FORMATTHREADARGS *)dn;
	
	if( pChildArgs->bNewThread )
    {
		CORg(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED));

		if( pChildArgs->pProgress )
		{
			CORg(CoGetInterfaceAndReleaseStream(pChildArgs->pStream,
				IID_IWMDMProgress, (LPVOID *)&(pChildArgs->pProgress)));
		}
 	}

	if( pChildArgs->pProgress )
	{
		CORg(pChildArgs->pProgress->Begin(100));
		bProgStarted=TRUE;
	}

	CHRg(SetGlobalDeviceStatus(pChildArgs->pThis->m_wcsName, WMDM_STATUS_BUSY | WMDM_STATUS_STORAGE_INITIALIZING, TRUE));
    hr = SHFormatDrive(NULL, pChildArgs->dwDriveNumber, SHFMT_ID_DEFAULT, SHFMT_OPT_FULL); 
	SetGlobalDeviceStatus(pChildArgs->pThis->m_wcsName, WMDM_STATUS_READY, TRUE);

Error:
	if( bProgStarted )
	{
		pChildArgs->pProgress->Progress(100);
		pChildArgs->pProgress->End();
		pChildArgs->pProgress->Release();
	}
	if( pChildArgs->bNewThread )
    {
		CoUninitialize();
	}
	if( pChildArgs ) 
	{
		delete pChildArgs;
	}
	return hr;
}


STDMETHODIMP CMDSPStorageGlobals::Initialize(UINT fuMode, IWMDMProgress * pProgress)
{
	HRESULT hr=S_OK;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CORg(WMDM_E_NOTSUPPORTED);

/*  // This implementation is for PM-SP only
	DWORD dwStat;
    DWORD driveNum, dwThreadID;

	CORg(GetStatus(&dwStat));

	if( dwStat & WMDM_STATUS_BUSY )
	{
		return WMDM_E_BUSY;
	}

	FORMATTHREADARGS *pParentArgs;
	pParentArgs = new FORMATTHREADARGS;
	CPRg(pParentArgs);

	driveNum = (m_wcsName[0]>0x60) ? (m_wcsName[0]-L'a') : (m_wcsName[0]-L'A');
	
	pParentArgs->dwDriveNumber = driveNum;
	pParentArgs->bNewThread = (fuMode & WMDM_MODE_THREAD)?TRUE:FALSE;
	pParentArgs->pThis = this;
	if( pParentArgs->bNewThread )
	{
		if( pProgress ) 
		{
			pProgress->AddRef();
			CORg(CoMarshalInterThreadInterfaceInStream(
				IID_IWMDMProgress, (LPUNKNOWN)pProgress, 
				(LPSTREAM *)&(pParentArgs->pStream)));
			pParentArgs->pProgress=pProgress;  // mark it but don't use it
		} else {
			pParentArgs->pProgress=NULL;
		}
 	} else {
		pParentArgs->pProgress = pProgress;
		if( pProgress ) pProgress->AddRef();
    }

	if( fuMode & WMDM_MODE_BLOCK )
	{
		dwStat=DriveFormatFunc((void *)pParentArgs); 
		if( (dwStat==E_FAIL) || (dwStat==SHFMT_ERROR) || 
			(dwStat==SHFMT_CANCEL) || (dwStat==SHFMT_NOFORMAT) )
			hr=E_FAIL;
	} else if ( fuMode & WMDM_MODE_THREAD ) {
		CWRg(CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)DriveFormatFunc, 
			(void *)pParentArgs, 0, &dwThreadID));	
	} else 
		hr = E_INVALIDARG;
*/
Error:
    hrLogDWORD("IMDSPStorageGlobals::Initialize returned 0x%08lx", hr, hr);
	return hr;
}

STDMETHODIMP CMDSPStorageGlobals::GetDevice(IMDSPDevice * * ppDevice)
{
	HRESULT hr;

	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(ppDevice);

	if( m_pMDSPDevice )
	{
		*ppDevice = m_pMDSPDevice;
        (*ppDevice)->AddRef();
		return S_OK;
	}

	CComObject<CMDSPDevice> *pObj;

	CORg(CComObject<CMDSPDevice>::CreateInstance(&pObj));

	hr=pObj->QueryInterface(IID_IMDSPDevice, reinterpret_cast<void**>(ppDevice));
	if( FAILED(hr) )
		delete pObj;
	else {
		// wcscpy(pObj->m_wcsName, m_wcsName);
                hr = StringCbCopyW(pObj->m_wcsName, sizeof(pObj->m_wcsName), m_wcsName);
                if( FAILED(hr) )
                {
                    (*ppDevice)->Release();
                    *ppDevice = NULL;
                    goto Error;
                }
		pObj->InitGlobalDeviceInfo();
		m_pMDSPDevice = *ppDevice;
		m_pMDSPDevice->AddRef();
                hr = S_OK;
	}

Error:
    hrLogDWORD("IMDSPStorageGlobals::GetDevice returned 0x%08lx", hr, hr);
	return hr;
}

STDMETHODIMP CMDSPStorageGlobals::GetRootStorage(IMDSPStorage * * ppRoot)
{
	HRESULT hr;
	
	CFRg(g_pAppSCServer);
    if ( !(g_pAppSCServer->fIsAuthenticated()) )
	{
		CORg(WMDM_E_NOTCERTIFIED);
	}
	
	CARg(ppRoot);

	CComObject<CMDSPStorage> *pObj;

	CORg(CComObject<CMDSPStorage>::CreateInstance(&pObj));

	hr=pObj->QueryInterface(IID_IMDSPStorage, reinterpret_cast<void**>(ppRoot));
	if( FAILED(hr) )
        {
		delete pObj;
        }
	else 
        {
		// wcscpy(pObj->m_wcsName, m_wcsName);
                hr = StringCbCopyW(pObj->m_wcsName, sizeof(pObj->m_wcsName), m_wcsName);
                if( FAILED(hr) )
                {
                    (*ppRoot)->Release();
                    *ppRoot = NULL;
                    goto Error;
                }

                DWORD dwLen = wcslen(m_wcsName);

                if (dwLen == 0)
                {
                    hr = E_FAIL;
                    (*ppRoot)->Release();
                    *ppRoot = NULL;
                    goto Error;
                }
		if( m_wcsName[dwLen-1] != 0x5c ) 
                {
                    // wcscat(pObj->m_wcsName, g_wcsBackslash);
                    hr = StringCbCatW(pObj->m_wcsName, sizeof(pObj->m_wcsName),g_wcsBackslash);
                    if( FAILED(hr) )
                    {
                        (*ppRoot)->Release();
                        *ppRoot = NULL;
                        goto Error;
                    }
                }
                pObj->m_bIsDirectory = TRUE;
                hr = S_OK;
	}
	
Error:
    hrLogDWORD("IMDSPStorageGlobals::GetRootStorage returned 0x%08lx", hr, hr);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\mdspstorage.h ===
// MDSPStorage.h : Declaration of the CMDSPStorage

#ifndef __MDSPSTORAGE_H_
#define __MDSPSTORAGE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMDSPStorage
class ATL_NO_VTABLE CMDSPStorage : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMDSPStorage, &CLSID_MDSPStorage>,
	public IMDSPStorage2, IMDSPObjectInfo, IMDSPObject
{
public:
	CMDSPStorage();
    ~CMDSPStorage();

DECLARE_REGISTRY_RESOURCEID(IDR_MDSPSTORAGE)

BEGIN_COM_MAP(CMDSPStorage)
	COM_INTERFACE_ENTRY(IMDSPStorage)
	COM_INTERFACE_ENTRY(IMDSPStorage2)
	COM_INTERFACE_ENTRY(IMDSPObjectInfo)
	COM_INTERFACE_ENTRY(IMDSPObject)
END_COM_MAP()

// IMDSPStorage
public:
	WCHAR m_wcsName[MAX_PATH];
	char  m_szTmp[MAX_PATH];
	HANDLE	m_hFile;
    BOOL    m_bIsDirectory;
	STDMETHOD(SetAttributes)(/*[out]*/ DWORD dwAttributes,/*[in]*/ _WAVEFORMATEX *pFormat);
	STDMETHOD(EnumStorage)(/*[out]*/ IMDSPEnumStorage **ppEnumStorage);
	STDMETHOD(CreateStorage)(/*[in]*/ DWORD dwAttributes, /*[in]*/ _WAVEFORMATEX *pFormat, /*[in]*/ LPWSTR pwszName, /*[out]*/ IMDSPStorage **ppNewStorage);
    STDMETHOD(GetRights)(PWMDMRIGHTS *ppRights, UINT *pnRightsCount, /*[in, out]*/BYTE abMac[WMDM_MAC_LENGTH]);
	STDMETHOD(GetSize)(/*[out]*/ DWORD *pdwSizeLow, /*[out]*/ DWORD *pdwSizeHigh);
	STDMETHOD(GetDate)(/*[out]*/ PWMDMDATETIME pDateTimeUTC);
	STDMETHOD(GetName)(/*[out,string,size_is(nMaxChars)]*/ LPWSTR pwszName, /*[in]*/ UINT nMaxChars);
	STDMETHOD(GetAttributes)(/*[out]*/ DWORD *pdwAttributes, /*[out]*/ _WAVEFORMATEX *pFormat);
	STDMETHOD(GetStorageGlobals)(/*[out]*/ IMDSPStorageGlobals **ppStorageGlobals);
    STDMETHOD(SendOpaqueCommand)(OPAQUECOMMAND *pCommand);

// IMDSPStorage2
	STDMETHOD(GetStorage)( LPCWSTR pszStorageName, IMDSPStorage** ppStorage );
 
    STDMETHOD(CreateStorage2)(  DWORD dwAttributes,
						        DWORD dwAttributesEx,
                                _WAVEFORMATEX *pAudioFormat,
                                _VIDEOINFOHEADER *pVideoFormat,
                                LPWSTR pwszName,
						        ULONGLONG  qwFileSize,
                                IMDSPStorage **ppNewStorage);


    STDMETHOD(SetAttributes2)(  DWORD dwAttributes, 
							    DWORD dwAttributesEx, 
						        _WAVEFORMATEX *pAudioFormat,
							    _VIDEOINFOHEADER* pVideoFormat );
    STDMETHOD(GetAttributes2)(  DWORD *pdwAttributes,
							    DWORD *pdwAttributesEx,
                                _WAVEFORMATEX *pAudioFormat,
							    _VIDEOINFOHEADER* pVideoFormat );
    

    
// IMDSPObjectInfo
	STDMETHOD(GetPlayLength)(/*[out]*/ DWORD *pdwLength);
	STDMETHOD(SetPlayLength)(/*[in]*/ DWORD dwLength);
	STDMETHOD(GetPlayOffset)(/*[out]*/ DWORD *pdwOffset);
	STDMETHOD(SetPlayOffset)(/*[in]*/ DWORD dwOffset);
	STDMETHOD(GetTotalLength)(/*[out]*/ DWORD *pdwLength);
	STDMETHOD(GetLastPlayPosition)(/*[out]*/ DWORD *pdwLastPos);
	STDMETHOD(GetLongestPlayPosition)(/*[out]*/ DWORD *pdwLongestPos);
// IMDSPObject
	STDMETHOD(Open)(/*[in]*/ UINT fuMode);
	STDMETHOD(Read)(/*[out,size_is(*pdwSize)]*/ BYTE *pData, /*[in,out]*/ DWORD *pdwSize, /*[in, out]*/BYTE abMac[WMDM_MAC_LENGTH]);
	STDMETHOD(Write)(/*[in, size_is(dwSize)]*/ BYTE *pData, /*[in]*/ DWORD *pdwSize, /*[in, out]*/BYTE abMac[WMDM_MAC_LENGTH]);
	STDMETHOD(Delete)(/* [in] */ UINT fuMode, /*[in]*/ IWMDMProgress *pProgress);
	STDMETHOD(Seek)(/*[in]*/ UINT fuFlags, /*[in]*/ DWORD dwOffset);
	STDMETHOD(Rename)(/*[in]*/ LPWSTR pwszNewName, /*[in]*/ IWMDMProgress *pProgress);
    STDMETHOD(Move)(/*[in]*/ UINT fuMode, /*[in]*/ IWMDMProgress *pProgress, /*[in]*/ IMDSPStorage *pTarget);
	STDMETHOD(Close)();
};

#endif //__MDSPSTORAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\mdspstorageglobals.h ===
// MDSPStorageGlobals.h : Declaration of the CMDSPStorageGlobals

#ifndef __MDSPSTORAGEGLOBALS_H_
#define __MDSPSTORAGEGLOBALS_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMDSPStorageGlobals
class ATL_NO_VTABLE CMDSPStorageGlobals : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMDSPStorageGlobals, &CLSID_MDSPStorageGlobals>,
	public IMDSPStorageGlobals
{
public:
	CMDSPStorageGlobals()
	{
		m_pMDSPDevice=(IMDSPDevice *)NULL;
                m_wcsName[0] = L'\0';
	}
	~CMDSPStorageGlobals();

DECLARE_REGISTRY_RESOURCEID(IDR_MDSPSTORAGEGLOBALS)

BEGIN_COM_MAP(CMDSPStorageGlobals)
	COM_INTERFACE_ENTRY(IMDSPStorageGlobals)
END_COM_MAP()

// IMDSPStorageGlobals
public:
	WCHAR m_wcsName[MAX_PATH];
	IMDSPDevice *m_pMDSPDevice;
	STDMETHOD(GetTotalSize)(/*[out]*/ DWORD *pdwTotalSizeLow, /*[out]*/ DWORD *pdwTotalSizeHigh);
	STDMETHOD(GetRootStorage)(/*[out]*/ IMDSPStorage **ppRoot);
	STDMETHOD(GetDevice)(/*[out]*/ IMDSPDevice **ppDevice);
	STDMETHOD(Initialize)(/*[in]*/ UINT fuMode, /*[in]*/ IWMDMProgress *pProgress);
	STDMETHOD(GetStatus)(/*[out]*/ DWORD *pdwStatus);
	STDMETHOD(GetTotalBad)(/*[out]*/ DWORD *pdwBadLow, /*[out]*/ DWORD *pdwBadHigh);
	STDMETHOD(GetTotalFree)(/*[out]*/ DWORD *pdwFreeLow, /*[out]*/ DWORD *pdwFreeHigh);
	STDMETHOD(GetSerialNumber)(/*[out]*/ PWMDMID pSerialNum, /*[in, out]*/BYTE abMac[WMDM_MAC_LENGTH]);
	STDMETHOD(GetCapabilities)(/*[out]*/ DWORD *pdwCapabilities);
};

#endif //__MDSPSTORAGEGLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\mdsputil.cpp ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1999  Microsoft Corporation.  All Rights Reserved.          *
*                                                                           *
****************************************************************************/

//***************************************************************************
//
// Name: 		MDSPutil.cpp
//
// Description:	Utility functions for MDSP 
//
//***************************************************************************

#include "stdafx.h"

#include "MsPMSP.h"
#include "MdspDefs.h"
#include "wmsstd.h"
#include "stdio.h"
 
#include "DBT.h"
#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

BOOL UtilSetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes)
{
	if( g_bIsWinNT )
	{
		return SetFileAttributesW(lpFileName, dwFileAttributes);
	} else { 
		BOOL bRet;
		char *szTmp=NULL;
		UINT uLen = 2*(wcslen(lpFileName)+1);
		szTmp = new char [uLen];
         
        if(!szTmp) 
		{
			SetLastError(ERROR_OUTOFMEMORY);
			return FALSE;  
		}

		WideCharToMultiByte(CP_ACP, NULL, lpFileName, -1, szTmp, uLen, NULL, NULL);
   
		bRet = SetFileAttributesA(szTmp, dwFileAttributes);

		if( szTmp ) 
		{
			delete [] szTmp;
		}
		return bRet;
	}
}

DWORD UtilGetFileAttributesW(LPCWSTR lpFileName)
{
	if( g_bIsWinNT )
	{
		return GetFileAttributesW(lpFileName);
	} else { 
		DWORD dwRet;
		char *szTmp=NULL;
		UINT uLen = 2*(wcslen(lpFileName)+1);
		szTmp = new char [uLen];
         
        if(!szTmp) 
		{
			SetLastError(ERROR_OUTOFMEMORY);
			return 0xFFFFFFFF;  
		}

		WideCharToMultiByte(CP_ACP, NULL, lpFileName, -1, szTmp, uLen, NULL, NULL);
   
		dwRet = GetFileAttributesA(szTmp);

		if( szTmp ) 
		{
			delete [] szTmp;
		}
		return dwRet;
	}
}

BOOL UtilCreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
	if( g_bIsWinNT )
	{
		return CreateDirectoryW(lpPathName, lpSecurityAttributes);
	} else { 
		BOOL bRet;
		char *szTmp=NULL;
		UINT uLen = 2*(wcslen(lpPathName)+1);
		szTmp = new char [uLen];
         
        if(!szTmp) 
		{
			SetLastError(ERROR_OUTOFMEMORY);
			return FALSE;  
		}

		WideCharToMultiByte(CP_ACP, NULL, lpPathName, -1, szTmp, uLen, NULL, NULL);
   
		bRet = CreateDirectoryA(szTmp, lpSecurityAttributes);

		if( szTmp ) 
		{
			delete [] szTmp;
		}
		return bRet;
	}
}

HANDLE UtilCreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
	if( g_bIsWinNT )
	{
		return CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
	} else { 
		HANDLE hRet=INVALID_HANDLE_VALUE;
		char *szTmp=NULL;
		UINT uLen = 2*(wcslen(lpFileName)+1);
		szTmp = new char [uLen];
         
        if(!szTmp) 
		{
			SetLastError(ERROR_OUTOFMEMORY);
			return INVALID_HANDLE_VALUE;  
		}

		WideCharToMultiByte(CP_ACP, NULL, lpFileName, -1, szTmp, uLen, NULL, NULL);
   
		hRet = CreateFileA(szTmp, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

		if( szTmp ) 
		{
			delete [] szTmp;
		}
		return hRet;
	}
}

BOOL UtilMoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
{
	if( g_bIsWinNT )
	{
		return MoveFileW(lpExistingFileName, lpNewFileName);
	} else { 
		BOOL bRet;
		char *szTmpSrc=NULL, *szTmpDst=NULL;
		szTmpSrc = new char [2*(wcslen(lpExistingFileName)+1)];
		szTmpDst = new char [2*(wcslen(lpNewFileName)+1)];
         
        if( (!szTmpSrc) || (!szTmpDst)) 
		{
			SetLastError(ERROR_OUTOFMEMORY);
			return FALSE;  
		}

		WideCharToMultiByte(CP_ACP, NULL, lpExistingFileName, -1, szTmpSrc, 2*(wcslen(lpExistingFileName)+1), NULL, NULL);
		WideCharToMultiByte(CP_ACP, NULL, lpNewFileName, -1, szTmpDst, 2*(wcslen(lpNewFileName)+1), NULL, NULL);
    
		bRet = MoveFileA(szTmpSrc, szTmpDst);

		if( szTmpSrc ) 
		{
			delete [] szTmpSrc;
			szTmpSrc=NULL;
		}
		if( szTmpDst ) 
		{
			delete [] szTmpDst;
			szTmpDst=NULL;
		}
		return bRet;
	}
}

void MDSPNotifyDeviceConnection(WCHAR *wcsDeviceName, BOOL nIsConnect)
{
	g_CriticalSection.Lock();
	for(int i=0; i<MDSP_MAX_DEVICE_OBJ; i++)
	{
		if( ( g_NotifyInfo[i].bValid ) &&
		    ( !wcsncmp(wcsDeviceName, g_NotifyInfo[i].wcsDevName, 2) ) &&
			( g_NotifyInfo[i].pIWMDMConnect ) )
		{
			//if ( nIsConnect )
				//((IWMDMConnect *)(g_NotifyInfo[i].pIWMDMConnect))->Connect();
			//else 
		        //((IWMDMConnect *)(g_NotifyInfo[i].pIWMDMConnect))->Disconnect();   
		}
	}
	g_CriticalSection.Unlock();
}

void MDSPProcessDeviceChange(WPARAM wParam, LPARAM lParam)
{
	PDEV_BROADCAST_HDR pdbch;
	PDEV_BROADCAST_VOLUME pdbcv;
	WCHAR cDrive[4];
    int wmId, wmMask;
	pdbch = (PDEV_BROADCAST_HDR) lParam;
	switch (pdbch->dbch_devicetype) 
	{
		case DBT_DEVTYP_VOLUME:
			pdbcv = (PDEV_BROADCAST_VOLUME) pdbch;
			wcscpy(cDrive, L"C:");
			for(wmId=g_dwStartDrive; wmId<MDSP_MAX_DRIVE_COUNT; wmId++)
			{
				wmMask = 0x1 << wmId;
				if ( (pdbcv->dbcv_unitmask) & wmMask )
				{
					cDrive[0] = L'A'+wmId; 
					switch (wParam)
					{
					case DBT_DEVICEARRIVAL:
						MDSPNotifyDeviceConnection(cDrive, TRUE);
						break;
					case DBT_DEVICEREMOVECOMPLETE:
						MDSPNotifyDeviceConnection(cDrive, FALSE);
						break;
					default:
						break;
					}
				}
						
			}
			break;
		default:
			break;		
	}
}

/* ///////////////////////////////////////////////////////////////////////
Routine Description:
    Registers for notification of changes in the device interfaces for
    the specified interface class GUID. 

Parameters:
    InterfaceClassGuid - The interface class GUID for the device 
        interfaces. 

    hDevNotify - Receives the device notification handle. On failure, 
        this value is NULL.

Return Value:
    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.
//////////////////////////////////////////////////////////////////////// */


DWORD DoRegisterDeviceInterface(HWND hWnd, GUID InterfaceClassGuid, HDEVNOTIFY *hDevNotify)
{
	typedef HDEVNOTIFY (WINAPI *P_RDN)(HANDLE, LPVOID, DWORD);
	P_RDN pRegisterDeviceNotification;

	pRegisterDeviceNotification = (P_RDN)GetProcAddress(GetModuleHandle ("user32.dll"),
												  "RegisterDeviceNotificationA");
	if( pRegisterDeviceNotification )
    {
		DEV_BROADCAST_VOLUME NotificationFilter;

		ZeroMemory( &NotificationFilter, sizeof(NotificationFilter) );
		
		NotificationFilter.dbcv_size = sizeof(DEV_BROADCAST_VOLUME);
		NotificationFilter.dbcv_devicetype = DBT_DEVTYP_VOLUME;
		NotificationFilter.dbcv_unitmask = 0;
		NotificationFilter.dbcv_flags = DBTF_MEDIA;

		*hDevNotify = pRegisterDeviceNotification( hWnd, 
			&NotificationFilter,
			DEVICE_NOTIFY_WINDOW_HANDLE
		);

		if(!*hDevNotify) 
		{
			return GetLastError();
		}
		return ERROR_SUCCESS;
	} else 
	    return GetLastError();
}


BOOL DoUnregisterDeviceInterface(HDEVNOTIFY hDev)
{
	typedef BOOL (WINAPI *P_URDN)(HDEVNOTIFY);
	P_URDN pUnregisterDeviceNotification;

	pUnregisterDeviceNotification = (P_URDN)GetProcAddress(GetModuleHandle ("user32.dll"),
												  "UnregisterDeviceNotificationA");
	if( pUnregisterDeviceNotification )
	{
		return pUnregisterDeviceNotification(hDev);
	} else 
		return FALSE;
}


HRESULT wcsParseDeviceName(WCHAR *wcsIn, WCHAR *wcsOut, DWORD dwOutBufSizeInChars)
{
    WCHAR wcsTmp[MAX_PATH], *pWcs;
    HRESULT hr;

    hr = StringCchCopyW(wcsTmp, ARRAYSIZE(wcsTmp), wcsIn);
    if (FAILED(hr))
    {
        return hr;
    }

    pWcs = wcschr(wcsTmp, 0x5c);
    
    if( pWcs ) *pWcs=0;

    if (wcslen(wcsTmp) < dwOutBufSizeInChars)
    {
        wcscpy(wcsOut, wcsTmp);
    }
    else
    {
        return STRSAFE_E_INSUFFICIENT_BUFFER; // defined in strsafe.h
    }
    return S_OK;
}

HRESULT GetFileSizeRecursiveA(char *szPath, DWORD *pdwSizeLow, DWORD *pdwSizeHigh)
{
	HRESULT hr=S_OK;
    HANDLE hFile, hFindFile=INVALID_HANDLE_VALUE;
    DWORD dwSizeLow=0, dwSizeHigh=0;
    WIN32_FIND_DATAA fd;
    char szLP[MAX_PATH+BACKSLASH_SZ_STRING_LENGTH+1];

	CARg(szPath);
	CARg(pdwSizeLow);
	CARg(pdwSizeHigh); 
	CARg(szPath[0]);

	// strcpy(szLP, szPath);
        hr = StringCchCopyA(szLP, ARRAYSIZE(szLP)-BACKSLASH_SZ_STRING_LENGTH-1, szPath);
        if (FAILED(hr))
        {
            goto Error;
        }

        DWORD dwAttrib = GetFileAttributesA(szPath);
        if (dwAttrib == INVALID_FILE_ATTRIBUTES)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Error;
        }

    if( FILE_ATTRIBUTE_DIRECTORY & dwAttrib )
	{	
		if( szLP[strlen(szLP)-1] != 0x5c ) strcat(szLP, g_szBackslash);
		strcat(szLP, "*");
		hFindFile = FindFirstFileA(szLP, &fd);
        if ( hFindFile != INVALID_HANDLE_VALUE )
		{
			if( strcmp(fd.cFileName, ".") && strcmp(fd.cFileName, "..") )
			{
				szLP[strlen(szLP)-1] = 0; // erase the '*'
				// strcat(szLP, fd.cFileName);
				CORg(StringCchCatA(szLP, ARRAYSIZE(szLP), fd.cFileName));
                                CORg(GetFileSizeRecursiveA(szLP, pdwSizeLow, pdwSizeHigh));
			}
			
			while ( FindNextFileA(hFindFile, &fd) ) 
			{
				if( strcmp(fd.cFileName, ".") && strcmp(fd.cFileName, "..") )
				{
					strcpy(szLP, szPath);
					if( szLP[strlen(szLP)-1] != 0x5c ) strcat(szLP, g_szBackslash);
					// strcat(szLP, fd.cFileName);
                                        CORg(StringCchCatA(szLP, ARRAYSIZE(szLP), fd.cFileName));
					CORg(GetFileSizeRecursiveA(szLP, pdwSizeLow, pdwSizeHigh));
				}
			} 
			hr = GetLastError();
			if( hr == ERROR_NO_MORE_FILES ) hr=S_OK; 
			else hr = HRESULT_FROM_WIN32(hr);
		}	    	
	} else {
		hFile=CreateFileA(szPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
			OPEN_EXISTING, 0, NULL);
	    CWRg(hFile != INVALID_HANDLE_VALUE); 
	 	dwSizeLow = GetFileSize(hFile, &dwSizeHigh);
       // CloseHandle(hFile);
		// CWRg( 0xFFFFFFFF != dwSizeLow );
                if (dwSizeLow == INVALID_FILE_SIZE)
                {
                    DWORD dwLastError = GetLastError();
                    if (dwLastError != NO_ERROR)
                    {
                        hr = HRESULT_FROM_WIN32(dwLastError);
                        CloseHandle(hFile);
                        goto Error;
                    }
                }
        CloseHandle(hFile);
                // ha ha
		// *pdwSizeLow += dwSizeLow;
		// *pdwSizeHigh += dwSizeHigh;
                unsigned _int64 u64Size = ((unsigned _int64) dwSizeHigh << 32) | dwSizeLow;
                u64Size += *pdwSizeLow | ((unsigned _int64) (*pdwSizeHigh) << 32);
                *pdwSizeLow = (DWORD) (u64Size & 0xFFFFFFFF);
                *pdwSizeHigh = (DWORD) (u64Size >> 32);
		hr=S_OK;
    }
Error:
	if(hFindFile != INVALID_HANDLE_VALUE )
		FindClose(hFindFile);
	return hr;
}

HRESULT GetFileSizeRecursiveW(WCHAR *wcsPath, DWORD *pdwSizeLow, DWORD *pdwSizeHigh)
{
	HRESULT hr=S_OK;
    HANDLE hFile, hFindFile=INVALID_HANDLE_VALUE;
    DWORD dwSizeLow=0, dwSizeHigh=0;
    WIN32_FIND_DATAW wfd;
    WCHAR wcsLP[MAX_PATH+BACKSLASH_STRING_LENGTH+1];

	CARg(wcsPath);
	CARg(pdwSizeLow);
	CARg(pdwSizeHigh); 
	CARg(wcsPath[0]);

	// wcscpy(wcsLP, wcsPath);
        hr = StringCchCopyW(wcsLP, ARRAYSIZE(wcsLP)-BACKSLASH_STRING_LENGTH-1, wcsPath);
        if (FAILED(hr))
        {
            goto Error;
        }

        DWORD dwAttrib = GetFileAttributesW(wcsPath);
        if (dwAttrib == INVALID_FILE_ATTRIBUTES)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Error;
        }

    if( FILE_ATTRIBUTE_DIRECTORY & dwAttrib )
	{	
		if( wcsLP[wcslen(wcsLP)-1] != 0x5c ) wcscat(wcsLP, g_wcsBackslash);
		wcscat(wcsLP, L"*");
		hFindFile = FindFirstFileW(wcsLP, &wfd);
        if ( hFindFile != INVALID_HANDLE_VALUE )
		{
			if( wcscmp(wfd.cFileName, L".") && wcscmp(wfd.cFileName, L"..") )
			{
				wcsLP[wcslen(wcsLP)-1] = 0; // erase the '*'
				// wcscat(wcsLP, wfd.cFileName);
				CORg(StringCchCatW(wcsLP, ARRAYSIZE(wcsLP), wfd.cFileName));
				CORg(GetFileSizeRecursiveW(wcsLP, pdwSizeLow, pdwSizeHigh));
			}
			
			while ( FindNextFileW(hFindFile, &wfd) ) 
			{
				if( wcscmp(wfd.cFileName, L".") && wcscmp(wfd.cFileName, L"..") )
				{
					wcscpy(wcsLP, wcsPath);
					if( wcsLP[wcslen(wcsLP)-1] != 0x5c ) wcscat(wcsLP, g_wcsBackslash);
					// wcscat(wcsLP, wfd.cFileName);
                                        CORg(StringCchCatW(wcsLP, ARRAYSIZE(wcsLP), wfd.cFileName));
					CORg(GetFileSizeRecursiveW(wcsLP, pdwSizeLow, pdwSizeHigh));
				}
			} 
			hr = GetLastError();
			if( hr == ERROR_NO_MORE_FILES ) hr=S_OK; 
			else hr = HRESULT_FROM_WIN32(hr);
		}	    	
	} else {
		hFile=CreateFileW(wcsPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
			OPEN_EXISTING, 0, NULL);
	    CWRg(hFile != INVALID_HANDLE_VALUE); 
	 	dwSizeLow = GetFileSize(hFile, &dwSizeHigh);
       // CloseHandle(hFile);
		// CWRg( 0xFFFFFFFF != dwSizeLow );
                if (dwSizeLow == INVALID_FILE_SIZE)
                {
                    DWORD dwLastError = GetLastError();
                    if (dwLastError != NO_ERROR)
                    {
                        hr = HRESULT_FROM_WIN32(dwLastError);
                        CloseHandle(hFile);
                        goto Error;
                    }
                }
        CloseHandle(hFile);
                // ha ha
		// *pdwSizeLow += dwSizeLow;
		// *pdwSizeHigh += dwSizeHigh;
                unsigned _int64 u64Size = ((unsigned _int64) dwSizeHigh << 32) | dwSizeLow;
                u64Size += *pdwSizeLow | ((unsigned _int64) (*pdwSizeHigh) << 32);
                *pdwSizeLow = (DWORD) (u64Size & 0xFFFFFFFF);
                *pdwSizeHigh = (DWORD) (u64Size >> 32);
		hr=S_OK;
    }
Error:
	if(hFindFile != INVALID_HANDLE_VALUE )
		FindClose(hFindFile);
	return hr;
}

HRESULT DeleteFileRecursiveW(WCHAR *wcsPath)
{
	HRESULT hr=S_OK;
 
	CARg(wcsPath);
	CARg(wcsPath[0]);

        DWORD dwAttrib = GetFileAttributesW(wcsPath);
        if (dwAttrib == INVALID_FILE_ATTRIBUTES)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Error;
        }

    if( FILE_ATTRIBUTE_DIRECTORY & dwAttrib )
	{	
	    HANDLE hFindFile=INVALID_HANDLE_VALUE;
	    WIN32_FIND_DATAW wfd;
		WCHAR wcsLP[MAX_PATH+BACKSLASH_STRING_LENGTH+1];
 
		// wcscpy(wcsLP, wcsPath);
		hr = StringCchCopyW(wcsLP, ARRAYSIZE(wcsLP)-BACKSLASH_STRING_LENGTH-1, wcsPath);
                if (FAILED(hr))
                {
                    goto Error;
                }
		if( wcsLP[wcslen(wcsLP)-1] != 0x5c ) wcscat(wcsLP, g_wcsBackslash);
		wcscat(wcsLP, L"*");
		hFindFile = FindFirstFileW(wcsLP, &wfd);
        if ( hFindFile != INVALID_HANDLE_VALUE )
		{
			do {
				if( wcscmp(wfd.cFileName, L".") && wcscmp(wfd.cFileName, L"..") )
				{
					wcscpy(wcsLP, wcsPath);
					if( wcsLP[wcslen(wcsLP)-1] != 0x5c ) wcscat(wcsLP, g_wcsBackslash);
					// wcscat(wcsLP, wfd.cFileName);
					hr = StringCchCatW(wcsLP, ARRAYSIZE(wcsLP), wfd.cFileName);
                                        if (FAILED(hr))
                                        {
                                            FindClose(hFindFile);
                                            CHRg(hr);
                                        }
					// CHRg(DeleteFileRecursiveW(wcsLP)); 
					hr = DeleteFileRecursiveW(wcsLP); 
                                        if (FAILED(hr))
                                        {
                                            FindClose(hFindFile);
                                            CHRg(hr);
                                        }
				}
			} while ( FindNextFileW(hFindFile, &wfd) ) ;
	
			hr = GetLastError();
			FindClose(hFindFile);
		} else {
			hr = GetLastError();
		}
		    
		// Until here this dir should be empty
		if( hr == ERROR_NO_MORE_FILES )
		{
			CWRg(RemoveDirectoryW(wcsPath));
			hr=S_OK;
		} else hr = HRESULT_FROM_WIN32(hr);
	} else {
		CWRg( DeleteFileW(wcsPath) );
    }
Error:
	return hr;
}

HRESULT DeleteFileRecursiveA(char *szPath)
{
	HRESULT hr=S_OK;
 
	CARg(szPath);
	CARg(szPath[0]);

        DWORD dwAttrib = GetFileAttributesA(szPath);
        if (dwAttrib == INVALID_FILE_ATTRIBUTES)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Error;
        }

    if( FILE_ATTRIBUTE_DIRECTORY & dwAttrib )
	{	
	    HANDLE hFindFile=INVALID_HANDLE_VALUE;
	    WIN32_FIND_DATAA fd;
		char szLP[MAX_PATH+BACKSLASH_SZ_STRING_LENGTH+1];
 
		hr = StringCchCopyA(szLP, ARRAYSIZE(szLP)-BACKSLASH_SZ_STRING_LENGTH-1, szPath);
                if (FAILED(hr))
                {
                    goto Error;
                }
		if( szLP[strlen(szLP)-1] != 0x5c ) strcat(szLP, g_szBackslash);
		strcat(szLP, "*");
		hFindFile = FindFirstFileA(szLP, &fd);
        if ( hFindFile != INVALID_HANDLE_VALUE )
		{
			do {
				if( strcmp(fd.cFileName, ".") && strcmp(fd.cFileName, "..") )
				{
					strcpy(szLP, szPath);
					if( szLP[strlen(szLP)-1] != 0x5c ) strcat(szLP, g_szBackslash);
					// strcat(szLP, fd.cFileName);
					hr = StringCchCatA(szLP, ARRAYSIZE(szLP), fd.cFileName);
                                        if (FAILED(hr))
                                        {
                                            FindClose(hFindFile);
                                            CHRg(hr);
                                        }
                                        // CHRg(DeleteFileRecursive(szLP));
					hr = DeleteFileRecursiveA(szLP); 
                                        if (FAILED(hr))
                                        {
                                            FindClose(hFindFile);
                                            CHRg(hr);
                                        }
				}
			} while ( FindNextFileA(hFindFile, &fd) ) ;
	
			hr = GetLastError();
			FindClose(hFindFile);
		} else {
			hr = GetLastError();
		}
		    
		// Until here this dir should be empty
		if( hr == ERROR_NO_MORE_FILES )
		{
			CWRg(RemoveDirectory(szPath));
			hr=S_OK;
		} else hr = HRESULT_FROM_WIN32(hr);
	} else {
		CWRg( DeleteFileA(szPath) );
    }
Error:
	return hr;
}


HRESULT SetGlobalDeviceStatus(WCHAR *wcsNameIn, DWORD dwStat, BOOL bClear)
{
	HRESULT hr=S_OK;

    g_CriticalSection.Lock();

    CARg(wcsNameIn);

	WCHAR wcsName[ARRAYSIZE(g_GlobalDeviceInfo[0].wcsDevName)], *pWN;
	int i;

	pWN = &wcsName[0];
        
	HRESULT hrTemp = wcsParseDeviceName(wcsNameIn, pWN, ARRAYSIZE(wcsName));
        if (FAILED(hrTemp))
        {
            hr = hrTemp;
            goto Error;
        }

	// Search for existing entries to see if there is a match
	for(i=0; i<MDSP_MAX_DEVICE_OBJ; i++)
	{
		if( g_GlobalDeviceInfo[i].bValid )
		{
			if(!wcscmp(wcsName, g_GlobalDeviceInfo[i].wcsDevName) )
			{
				if( bClear )
					g_GlobalDeviceInfo[i].dwStatus = dwStat;
				else 
					g_GlobalDeviceInfo[i].dwStatus |= dwStat;
				break;  // a match has been found;
			}
		} 
	}

	if( !(i<MDSP_MAX_DEVICE_OBJ) ) // new entry
	{
		for(i=0; i<MDSP_MAX_DEVICE_OBJ; i++)
		{
			if( !(g_GlobalDeviceInfo[i].bValid) )  // found empty space
			{
				wcscpy(g_GlobalDeviceInfo[i].wcsDevName, wcsName);
				g_GlobalDeviceInfo[i].bValid = TRUE;
				g_GlobalDeviceInfo[i].dwStatus = dwStat;
				break;
			}
		}
	}

	if( i<MDSP_MAX_DEVICE_OBJ )
	{
		hr = S_OK;
	} else {
		hr = hrNoMem;
	}
Error:
	g_CriticalSection.Unlock();
	return hr;
}

HRESULT GetGlobalDeviceStatus(WCHAR *wcsNameIn, DWORD *pdwStat)
{
	HRESULT hr;

    CARg(wcsNameIn);

	WCHAR wcsName[32], *pWN;
	int i;

	pWN = &wcsName[0];
	hr = wcsParseDeviceName(wcsNameIn, pWN, ARRAYSIZE(wcsName));
        if (FAILED(hr))
        {
            goto Error;
        }
	// Search for existing entries to see if there is a match
	for(i=0; i<MDSP_MAX_DEVICE_OBJ; i++)
	{
		if( g_GlobalDeviceInfo[i].bValid )
		{
			if(!wcscmp(wcsName, g_GlobalDeviceInfo[i].wcsDevName) )
			{
				*pdwStat = g_GlobalDeviceInfo[i].dwStatus;
				break;  // a match has been found;
			}
		} 
	}

	if( i<MDSP_MAX_DEVICE_OBJ )
	{
		hr = S_OK;
	} else {
		hr = E_FAIL;
	}
Error:
	return hr;
}

HRESULT QuerySubFoldersAndFilesW(LPCWSTR wcsCurrentFolder, DWORD *pdwAttr)
{
	HRESULT hr=E_FAIL;
	LPWSTR wcsName=NULL;
    int len;
	WIN32_FIND_DATAW wfd;
	int	nErrorEnd=0;
    HANDLE hFFile=INVALID_HANDLE_VALUE;
    DWORD dwAttrib;

	CARg(wcsCurrentFolder);
	CARg(pdwAttr);

	len=wcslen(wcsCurrentFolder);
	CARg(len>2);

    wcsName = new WCHAR [len+BACKSLASH_STRING_LENGTH+MAX_PATH];
	CPRg(wcsName);

	wcscpy(wcsName, wcsCurrentFolder);
	if( wcsName[wcslen(wcsName)-1] != 0x5c ) wcscat(wcsName, g_wcsBackslash);
    wcscat(wcsName, L"*");


	while( !nErrorEnd )
	{
		if( hFFile == INVALID_HANDLE_VALUE ) {    
			hFFile = FindFirstFileW(wcsName, &wfd);
			if( hFFile == INVALID_HANDLE_VALUE ) nErrorEnd = 1;
		} else {
			if( !FindNextFileW(hFFile, &wfd) ) nErrorEnd = 1;
		}
		
		if ( !nErrorEnd && hFFile != INVALID_HANDLE_VALUE )
		{
			if( !wcscmp(wfd.cFileName, L".") || !wcscmp(wfd.cFileName, L"..") ) 
				continue;
			else {
				wcscpy(wcsName, wcsCurrentFolder);
				if( wcsName[wcslen(wcsName)-1] != 0x5c ) wcscat(wcsName, g_wcsBackslash);
				wcscat(wcsName, wfd.cFileName);
		   		dwAttrib = GetFileAttributesW(wcsName);
	            if( dwAttrib & FILE_ATTRIBUTE_DIRECTORY )
				{
					*pdwAttr |= WMDM_STORAGE_ATTR_HAS_FOLDERS;
// definition is in MDSPdefs.h #define ALSO_CHECK_FILES
#ifndef ALSO_CHECK_FILES
					break;
#endif
				} 
#ifdef ALSO_CHECK_FILES
				else {
					*pdwAttr |= WMDM_STORAGE_ATTR_HAS_FILES;
				}
				if( (*pdwAttr & WMDM_STORAGE_ATTR_HAS_FOLDERS) &&
					(*pdwAttr & WMDM_STORAGE_ATTR_HAS_FILES ) )
				{
					break; // No need to continue since we found both
				}
#endif
			}
		} // End of If
	} // End of while 
		
    hr=S_OK;
Error:
	if( hFFile != INVALID_HANDLE_VALUE )
		FindClose(hFFile);
	if( wcsName )
	{
		delete [] wcsName;
	}
	return hr; // If FAILED(hr), sorry, can't do it.
}

HRESULT QuerySubFoldersAndFilesA(LPCSTR szCurrentFolder, DWORD *pdwAttr)
{
	HRESULT hr=E_FAIL;
	LPSTR szName=NULL;
    int len;
	WIN32_FIND_DATAA fd;
	int	nErrorEnd=0;
    HANDLE hFFile=INVALID_HANDLE_VALUE;
    DWORD dwAttrib;

	CARg(szCurrentFolder);
	CARg(pdwAttr);

	len=strlen(szCurrentFolder);
	CARg(len>2);

    szName = new char [len+BACKSLASH_SZ_STRING_LENGTH+MAX_PATH];
	CPRg(szName);

	strcpy(szName, szCurrentFolder);
	if( szName[strlen(szName)-1] != 0x5c ) strcat(szName, g_szBackslash);
    strcat(szName, "*");


	while( !nErrorEnd )
	{
		if( hFFile == INVALID_HANDLE_VALUE ) {    
			hFFile = FindFirstFileA(szName, &fd);
			if( hFFile == INVALID_HANDLE_VALUE ) nErrorEnd = 1;
		} else {
			if( !FindNextFileA(hFFile, &fd) ) nErrorEnd = 1;
		}
		
		if ( !nErrorEnd && hFFile != INVALID_HANDLE_VALUE )
		{
			if( !strcmp(fd.cFileName, ".") || !strcmp(fd.cFileName, "..") ) 
				continue;
			else {
				strcpy(szName, szCurrentFolder);
				if( szName[strlen(szName)-1] != 0x5c ) strcat(szName, g_szBackslash);
				strcat(szName, fd.cFileName);
		   		dwAttrib = GetFileAttributesA(szName);
	            if( dwAttrib & FILE_ATTRIBUTE_DIRECTORY )
				{
					*pdwAttr |= WMDM_STORAGE_ATTR_HAS_FOLDERS;
// definition is in MDSPdefs.h #define ALSO_CHECK_FILES
#ifndef ALSO_CHECK_FILES
					break;
#endif
				} 
#ifdef ALSO_CHECK_FILES
				else {
					*pdwAttr |= WMDM_STORAGE_ATTR_HAS_FILES;
				}
				if( (*pdwAttr & WMDM_STORAGE_ATTR_HAS_FOLDERS) &&
					(*pdwAttr & WMDM_STORAGE_ATTR_HAS_FILES ) )
				{
					break; // No need to continue since we found both
				}
#endif
			}
		} // End of If
	} // End of while 
		
    hr=S_OK;
Error:
	if( hFFile != INVALID_HANDLE_VALUE )
		FindClose(hFFile);
	if( szName )
	{
		delete [] szName;
	}
	return hr; // If FAILED(hr), sorry, can't do it.
}


HRESULT QuerySubFoldersAndFiles(LPCWSTR wcsCurrentFolder, DWORD *pdwAttr)
{
	if( g_bIsWinNT )
	{
       return QuerySubFoldersAndFilesW(wcsCurrentFolder, pdwAttr);
	} else {
		HRESULT hr;
		char *szTmp=NULL;

		szTmp = new char [2*(wcslen(wcsCurrentFolder)+1)];
        if(!szTmp) 
		{
			return HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);  
		}

		WideCharToMultiByte(CP_ACP, NULL, wcsCurrentFolder, -1, szTmp, 2*(wcslen(wcsCurrentFolder)+1), NULL, NULL);
   
		hr = QuerySubFoldersAndFilesA(szTmp, pdwAttr);

		if( szTmp ) 
		{
			delete [] szTmp;
		}
		return hr;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmspps\dlldata.c ===
#include "..\MsPMSP\dlldata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\shformatdrive.h ===
/*************************************************************
  The header for SHFormatDrive API call
*************************************************************/

#if !defined(SHFMT_OPT_FULL)

#if defined (__cplusplus)
extern "C" {
#endif

DWORD WINAPI SHFormatDrive(HWND hwnd,
						   UINT drive,
						   UINT fmtID,
						   UINT options);

// Special value of fmtID 

#define SHFMT_ID_DEFAULT 0xFFFF

// Option bits for options parameter

#define SHFMT_OPT_FULL		0x0001
#define SHFMT_OPT_SYSONLY	0x0002

// Special return values, DWORD values

#define SHFMT_ERROR		0xFFFFFFFFL
#define SHFMT_CANCEL	0xFFFFFFFEL
#define SHFMT_NOFORMAT	0xFFFFFFFDL

#if defined (__cplusplus)
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmsp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__896E741D_3851_11D3_AA54_00C04FD22F6C__INCLUDED_)
#define AFX_STDAFX_H__896E741D_3851_11D3_AA54_00C04FD22F6C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#if !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <shlwapi.h>
#include <shellapi.h>
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__896E741D_3851_11D3_AA54_00C04FD22F6C__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmspps\mspmspps_p.c ===
#include "..\MsPMSP\MsPMSP_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmspps\mspmspps_i.c ===
#include "..\MsPMSP\MsPMSP_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmspsv\svchost\ntservapp.cpp ===
// NTService.cpp
// 
// This is the main program file containing the entry point.

#include "NTServApp.h"
#include "PMSPservice.h"

int __cdecl main(int argc, char* argv[])
{
    // Create the service object
    CPMSPService PMSPService;
    
    // Parse for standard arguments (install, uninstall, version etc.)
    if (!PMSPService.ParseStandardArgs(argc, argv)) {

        // Didn't find any standard args so start the service
        // Uncomment the DebugBreak line below to enter the debugger
        // when the service is started.
        // DebugBreak();
        PMSPService.StartService();
    }

    // When we get here, the service has been stopped
    return PMSPService.m_Status.dwWin32ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmspsv\svchost\ntservapp.h ===
// NTService.h

#include <windows.h>
#include <stdio.h>
#include "ntservice.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmspsv\svchost\ntservmsg.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: EVMSG_INSTALLED
//
// MessageText:
//
//  The %1 service was installed.
//
#define EVMSG_INSTALLED                  0x00000064L

//
// MessageId: EVMSG_REMOVED
//
// MessageText:
//
//  The %1 service was removed.
//
#define EVMSG_REMOVED                    0x00000065L

//
// MessageId: EVMSG_NOTREMOVED
//
// MessageText:
//
//  The %1 service could not be removed.
//
#define EVMSG_NOTREMOVED                 0x00000066L

//
// MessageId: EVMSG_CTRLHANDLERNOTINSTALLED
//
// MessageText:
//
//  The control handler could not be installed.
//
#define EVMSG_CTRLHANDLERNOTINSTALLED    0x00000067L

//
// MessageId: EVMSG_FAILEDINIT
//
// MessageText:
//
//  The initialization process failed.
//
#define EVMSG_FAILEDINIT                 0x00000068L

//
// MessageId: EVMSG_STARTED
//
// MessageText:
//
//  The service was started.
//
#define EVMSG_STARTED                    0x00000069L

//
// MessageId: EVMSG_BADREQUEST
//
// MessageText:
//
//  The service received an unsupported request.
//
#define EVMSG_BADREQUEST                 0x0000006AL

//
// MessageId: EVMSG_DEBUG
//
// MessageText:
//
//  Debug: %1
//
#define EVMSG_DEBUG                      0x0000006BL

//
// MessageId: EVMSG_STOPPED
//
// MessageText:
//
//  The service was stopped.
//
#define EVMSG_STOPPED                    0x0000006CL

//
// MessageId: EVMSG_NAMEDPIPEOPERATION
//
// MessageText:
//
//  The %1 pipe has an error: 
//
#define EVMSG_NAMEDPIPEOPERATION         0x0000006DL

//
// MessageId: EVMSG_DISPLAYNAME
//
// MessageText:
//
//  Portable media serial number%0
//
#define EVMSG_DISPLAYNAME                0x0000006EL

//
// MessageId: EVMSG_DESCRIPTION
//
// MessageText:
//
//  Retrieves the serial number of any portable music player connected to your computer%0
//
#define EVMSG_DESCRIPTION                0x0000006FL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmspsv\svchost\ntservice.h ===
// ntservice.h
//
// Definitions for CNTService
//
#pragma once


#ifndef _NTSERVICE_H_
#define _NTSERVICE_H_

#include "ntservmsg.h" // Event message ids

#define SERVICE_CONTROL_USER 128

class CNTService
{
public:
    CNTService();
    virtual ~CNTService();
    static BOOL IsInstalled();
    static void LogEvent( WORD wType, DWORD dwID,
                          const char* pszS1 = NULL,
                          const char* pszS2 = NULL,
                          const char* pszS3 = NULL);
    void SetStatus(DWORD dwState);
    BOOL Initialize();
    virtual void Run() = 0;
    virtual BOOL OnInit(DWORD& dwLastError) = 0;
    virtual void OnStop() = 0;
    virtual void OnInterrogate();
    virtual void OnPause();
    virtual void OnContinue();
    virtual void OnShutdown();
    virtual BOOL OnUserControl(DWORD dwOpcode) = 0;
    static void DebugMsg(const char* pszFormat, ...);
    
    // static member functions
    static void WINAPI Handler(DWORD dwOpcode);

    // data members
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_Status;
    BOOL m_bIsRunning;

};

// WARNING: This limits the application to only one CNTService object. 
extern CNTService* g_pService; // nasty hack to get object ptr
extern CRITICAL_SECTION g_csLock;

#endif // _NTSERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmspsv\svchost\svchost.h ===
// mspmspsv.h
#pragma once

#define SERVICE_NAME          "WmdmPmSp"
#define SERVICE_NAMEW         L"WmdmPmSp"
#define SERVICE_DLL_NAME      "MsPMSPSv.dll"
#define SERVICE_OLD_NAME      "WMDM PMSP Service"
#define SERVICE_FILE_DISC     "WMDM PM SP Service"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmspsv\svchost\pmspservice.cpp ===
// PMSPservice.cpp

#include "NTServApp.h"
#include "PMSPservice.h"
#include "svchost.h"

#define BUFSIZE         256
#define PIPE_TIMEOUT    2000
#define NUM_BYTES_PER_READ_REQUEST (sizeof(MEDIA_SERIAL_NUMBER_DATA))
#define INACTIVE_TIMEOUT_SHUTDOWN (5*60*1000) // in millisec -- 5 minutes

#include "serialid.h"
#include "aclapi.h"
#include <crtdbg.h>

LPTSTR g_lpszPipename = "\\\\.\\pipe\\WMDMPMSPpipe"; 

// static member variables
const DWORD CPMSPService::m_dwMaxConsecutiveConnectErrors = 5;

static DWORD CheckDriveType(HANDLE hPipe, LPCWSTR pwszDrive)
{
    // On XP, as a result of the impersonation, we use the
    // client's drive letter namespace for the GetDriveType call.
    // When we CreateFile the drive letter, we use the LocalSystem
    // drive namespace.
    if (ImpersonateNamedPipeClient(hPipe) == 0)
    {
      return GetLastError();
    }

    DWORD dwDriveType = GetDriveTypeW(pwszDrive);

    RevertToSelf(); 

    if (dwDriveType != DRIVE_FIXED && dwDriveType != DRIVE_REMOVABLE)
    {
        return ERROR_INVALID_PARAMETER; 
    }
    return ERROR_SUCCESS;
    
}


static VOID GetAnswerToRequest(HANDLE  hPipe,
                               LPBYTE  szBufIn, 
                               DWORD   dwSizeIn, 
                               LPBYTE  szBufOut, 
                               DWORD   dwBufSizeOut, 
                               LPDWORD pdwNumBytesWritten)
{
    WCHAR wcsDeviceName[]=L"A:\\";
    WMDMID stMSN;
    DWORD dwDriveNum;
    HRESULT hr=E_FAIL;
    PMEDIA_SERIAL_NUMBER_DATA pMSNIn = (PMEDIA_SERIAL_NUMBER_DATA)szBufIn;
    PMEDIA_SERIAL_NUMBER_DATA pMSNOut = (PMEDIA_SERIAL_NUMBER_DATA)szBufOut;

    if (!hPipe || !szBufIn || !szBufOut || !pdwNumBytesWritten || dwBufSizeOut < sizeof(MEDIA_SERIAL_NUMBER_DATA))
    {
        _ASSERTE(0);
        return;
    }

    // For all errors, we send back (and write to the pipe) the
    // entire MEDIA_SERIAL_NUMBER_DATA struct. On successful returns,
    // the number of bytes written may be more or less than 
    // sizeof(MEDIA_SERIAL_NUMBER_DATA) depnding on the length of
    // the serial number.

    ZeroMemory(szBufOut, dwBufSizeOut);
    *pdwNumBytesWritten = sizeof(MEDIA_SERIAL_NUMBER_DATA);
    if (dwSizeIn >= NUM_BYTES_PER_READ_REQUEST)
    {
        dwDriveNum = pMSNIn->Reserved[1];
        if (dwDriveNum < 26)
        {
            wcsDeviceName[0] = L'A' + (USHORT)dwDriveNum;
            CPMSPService::DebugMsg("Getting serial number for %c", 'A' + (USHORT) (wcsDeviceName[0] - 'A'));

            DWORD dwErr = CheckDriveType(hPipe, wcsDeviceName);
            CPMSPService::DebugMsg("CheckDriveType returns %u", dwErr);

            if (dwErr == ERROR_SUCCESS)
            {
                hr = UtilGetSerialNumber(wcsDeviceName, &stMSN, FALSE);

                CPMSPService::DebugMsg("hr = %x\n", hr);
                CPMSPService::DebugMsg("serial = %c %c %c %c ...\n", stMSN.pID[0], stMSN.pID[1], stMSN.pID[2], stMSN.pID[3]);

                if (hr == S_OK)
                {
                    // Note that dwNumBytesToTransfer could actually be less than sizeof(MEDIA_SERIAL_NUMBER_DATA)
                    DWORD dwNumBytesToTransfer = FIELD_OFFSET(MEDIA_SERIAL_NUMBER_DATA, SerialNumberData) + stMSN.SerialNumberLength;
                    if (dwNumBytesToTransfer > dwBufSizeOut)
                    {
                        pMSNOut->Result = ERROR_INSUFFICIENT_BUFFER;
                    }
                    else
                    {
                        CopyMemory(pMSNOut->SerialNumberData, stMSN.pID, stMSN.SerialNumberLength);
                        *pdwNumBytesWritten = dwNumBytesToTransfer;
                        pMSNOut->SerialNumberLength = stMSN.SerialNumberLength;
                        pMSNOut->Reserved[1] = stMSN.dwVendorID;
                        pMSNOut->Result = ERROR_SUCCESS;
                    }
                }
                else
                {
                    pMSNOut->Result = 0xFFFF & hr;
                }
            }
            else
            {
                pMSNOut->Result = dwErr;
            }
        }
        else
        {
            pMSNOut->Result = ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        // This should never happen because this function is called only after
        // reading NUM_BYTES_PER_READ_REQUEST or more bytes.
        _ASSERTE(m_PipeState[i].dwNumBytesRead >= NUM_BYTES_PER_READ_REQUEST);
        pMSNOut->Result = ERROR_INVALID_PARAMETER;
    }
}


CPMSPService::CPMSPService(DWORD& dwLastError)
:CNTService()
{
    ZeroMemory(&m_PipeState, MAX_PIPE_INSTANCES * sizeof(PIPE_STATE));

    m_hStopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
                                        // unsignalled manual reset event

    m_dwNumClients = 0;

    dwLastError = m_hStopEvent? ERROR_SUCCESS : GetLastError();
}

CPMSPService::~CPMSPService()
{
    CPMSPService::DebugMsg("~CPMSPService, last error %u, num clients: %u", 
                           m_Status.dwWin32ExitCode, m_dwNumClients );

    if (m_hStopEvent)
    {
        CloseHandle(m_hStopEvent);
    }

    DWORD i;
    DWORD dwRet;

    for (i = 0; i < MAX_PIPE_INSTANCES; i++)
    {
        if (m_PipeState[i].state == PIPE_STATE::CONNECT_PENDING ||
            m_PipeState[i].state == PIPE_STATE::READ_PENDING    ||
            m_PipeState[i].state == PIPE_STATE::WRITE_PENDING)
        {
            BOOL bDisconnect = 0;

            _ASSERTE(m_PipeState[i].hPipe);
            _ASSERTE(m_PipeState[i].overlapped.hEvent);
    
            CancelIo(m_PipeState[i].hPipe);

            CPMSPService::DebugMsg("~CPMSPService client %u's state: %u", i, m_PipeState[i].state);

            if (m_PipeState[i].state == PIPE_STATE::CONNECT_PENDING)
            {
                dwRet = WaitForSingleObject(m_PipeState[i].overlapped.hEvent, 0);
                _ASSERTE(dwRet != WAIT_FAILED);
                if (dwRet == WAIT_OBJECT_0)
                {
                    bDisconnect = 1;
                }
            }
            else
            {
                bDisconnect = 1;
                _ASSERTE(m_dwNumClients > 0);
                m_dwNumClients--;
            }

            // Note that we do not call FlushFileBuffers. That is 
            // a sync call and a malicious client can prevent us from 
            // progressing by not reading bytes from a pipe. That would
            // prevent the service from stopping.
            //
            // In normal circumstances we disconnect the pipe only after
            // the client tells us it is done (by closing its end of the
            // pipe), so these is no need to flush.

            if (bDisconnect)
            {
                DisconnectNamedPipe(m_PipeState[i].hPipe); 
            }
        }
        if (m_PipeState[i].overlapped.hEvent)
        {
            CloseHandle(m_PipeState[i].overlapped.hEvent);
        }
        if (m_PipeState[i].hPipe)
        {
            CloseHandle(m_PipeState[i].hPipe);
        }
    }
    _ASSERTE(m_dwNumClients == 0);
}

BOOL CPMSPService::OnInit(DWORD& dwLastError)
{
    BOOL  bRet = FALSE;
    PSID  pAuthUserSID = NULL;
    PSID  pAdminSID = NULL;
    PACL  pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;

    __try
    {
        DWORD i;
        DWORD dwRet;

        EXPLICIT_ACCESS ea[2];
        // SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
        SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
        SECURITY_ATTRIBUTES sa;

        // Create a well-known SID for interactive users
        if (!AllocateAndInitializeSid(&SIDAuthNT, 1,
                                        SECURITY_INTERACTIVE_RID,
                                        0, 0, 0, 0, 0, 0, 0,
                                        &pAuthUserSID))
        {
            dwLastError = GetLastError();
            DebugMsg("AllocateAndInitializeSid Error %u - auth users\n", dwLastError);
            __leave;
        }

        // Initialize an EXPLICIT_ACCESS structure for an ACE.
        // The ACE will allow authenticated users read access to the key.

        ZeroMemory(ea, 2 * sizeof(EXPLICIT_ACCESS));

        // Was: ea[0].grfAccessPermissions = GENERIC_WRITE | GENERIC_READ;
        
        // Disallow non admins from creating pipe instances. Don't know if
        // GENERIC_WRITE enables that, but the replacement below is safer.

        // Following leaves DELETE access turned on; what effect does this have for named pipes?
        // ea[0].grfAccessPermissions = (FILE_ALL_ACCESS & ~(FILE_CREATE_PIPE_INSTANCE | WRITE_OWNER | WRITE_DAC));
        // Following is same as above except that DELETE access is not given
        ea[0].grfAccessPermissions = (FILE_GENERIC_READ | FILE_GENERIC_WRITE) & ~(FILE_CREATE_PIPE_INSTANCE);
        ea[0].grfAccessMode = SET_ACCESS;
        ea[0].grfInheritance= NO_INHERITANCE;
        ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
        ea[0].Trustee.ptstrName  = (LPTSTR) pAuthUserSID;

        // Create a SID for the BUILTIN\Administrators group.

        if (!AllocateAndInitializeSid(&SIDAuthNT, 2, // 3,
                                        SECURITY_BUILTIN_DOMAIN_RID,
                                        DOMAIN_ALIAS_RID_ADMINS,
                                        0, // DOMAIN_ALIAS_RID_POWER_USERS, 
                                        0, 0, 0, 0, 0,
                                        &pAdminSID))
        {
            dwLastError = GetLastError();
            DebugMsg("AllocateAndInitializeSid Error %u - Domain, Power, Admins\n", dwLastError);
            __leave;
        }

        // Initialize an EXPLICIT_ACCESS structure for an ACE.
        // The ACE will allow the Administrators group full access to the key.

        ea[1].grfAccessPermissions = GENERIC_ALL;
        ea[1].grfAccessMode = SET_ACCESS;
        ea[1].grfInheritance= NO_INHERITANCE;
        ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[1].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        ea[1].Trustee.ptstrName  = (LPTSTR) pAdminSID;

        // Create a new ACL that contains the new ACEs.

        dwRet = SetEntriesInAcl(2, ea, NULL, &pACL);
        if (ERROR_SUCCESS != dwRet)
        {
            dwLastError = dwRet;
            DebugMsg("SetEntriesInAcl Error %u\n", dwLastError);
            __leave;
        }

        // Initialize a security descriptor.  

        pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, 
                                                SECURITY_DESCRIPTOR_MIN_LENGTH); 
        if (pSD == NULL)
        {
            dwLastError = GetLastError();
            DebugMsg("LocalAlloc Error %u\n", dwLastError);
            __leave;
        }

        if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
        {
            dwLastError = GetLastError();
            DebugMsg("InitializeSecurityDescriptor Error %u\n", dwLastError);
            __leave;
        }

        // Add the ACL to the security descriptor. 

        if (!SetSecurityDescriptorDacl(pSD, 
                                       TRUE,     // fDaclPresent flag   
                                       pACL, 
                                       FALSE))   // not a default DACL 
        {
            dwLastError = GetLastError();
            DebugMsg("SetSecurityDescriptorDacl Error %u\n", dwLastError);
            __leave;
        }
        // Bump up the check point
        SetStatus(SERVICE_START_PENDING);

        // Initialize a security attributes structure.

        sa.nLength = sizeof (SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = pSD;
        sa.bInheritHandle = FALSE;

        for (i = 0; i < MAX_PIPE_INSTANCES; i++)
        {
            // Note that if i == 0, we supply FILE_FLAG_FIRST_PIPE_INSTANCE
            // to this function. This causes the call to fail if an instance
            // of the named pipe is already open. That can happen in 2
            // cases: 1. Another instance of this dll is running or 2. We have
            // a name clash with another app (benign or malicious).

            // @@@@ Note: Apparently FILE_FLAG_FIRST_PIPE_INSTANCE is supported
            // only with Win2K SP2 and up. To do: (a) Confirm this (b) What is
            // the effect of setting this flag on Win2K gold and SP1?

            m_PipeState[i].hPipe = CreateNamedPipe(
                                g_lpszPipename,        // pipe name 
                                PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED |
                                (i == 0? FILE_FLAG_FIRST_PIPE_INSTANCE : 0),
                                                       // read/write access 
                                PIPE_TYPE_BYTE |       // byte type pipe 
                                PIPE_READMODE_BYTE |   // byte-read mode 
                                PIPE_WAIT,             // blocking mode 
                                MAX_PIPE_INSTANCES,    // max. instances  
                                BUFSIZE,               // output buffer size 
                                BUFSIZE,               // input buffer size 
                                PIPE_TIMEOUT,          // client time-out 
                                &sa);                  // no security attribute 

            if (m_PipeState[i].hPipe == INVALID_HANDLE_VALUE)
            {
                // Note that we bail out if we fail to create ANY pipe instance,
                // not just the first one. We expect to create all pipe instances;
                // failure to do so could mean that another app (benign or malicious)
                // is creating pipe instances. This is possible only if the other 
                // app has the FILE_CREATE_PIPE_INSTANCE access right.
                dwLastError = GetLastError();
                m_PipeState[i].hPipe = NULL;
                DebugMsg("CreateNamedPipe Error %u, instance = %u\n", dwLastError, i);
                __leave;
            }

            m_PipeState[i].overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
                                               // unsignalled manual reset event

            if (m_PipeState[i].overlapped.hEvent == NULL)
            {
                dwLastError = GetLastError();
                DebugMsg("CreateEvent Error %u, instance = %u\n", dwLastError, i);
                __leave;
            }

            // Errors connecting ot the client are sdtashed away in
            // m_PipeState[i].dwLastIOCallError. Let CPMSPService::Run 
            // deal with the error. We'll just continue to start up the 
            // service here.
            ConnectToClient(i);

            // Bump up the check point
            SetStatus(SERVICE_START_PENDING);
        }

        bRet = TRUE;
        dwLastError = ERROR_SUCCESS;
        CPMSPService::DebugMsg("OnInit succeeded");
    }
    __finally
    {
        if (pAuthUserSID)
        {
            FreeSid(pAuthUserSID);
        }
        if (pAdminSID)
        {
            FreeSid(pAdminSID);
        }
        if (pACL)
        {
            LocalFree(pACL);
        }
        if (pSD)
        {
            LocalFree(pSD);
        }
    }

    return bRet;
}

// This routine initiates a connection to a client on pipe instance i.
// Success/error status is saved away in m_PipeState[i].dwLastIOCallError
void CPMSPService::ConnectToClient(DWORD i)
{
    m_PipeState[i].state = PIPE_STATE::CONNECT_PENDING;

    m_PipeState[i].overlapped.Offset = m_PipeState[i].overlapped.OffsetHigh = 0;
    m_PipeState[i].dwNumBytesTransferredByLastIOCall = 0;
    m_PipeState[i].dwNumBytesRead = 0;
    m_PipeState[i].dwNumBytesToWrite = m_PipeState[i].dwNumBytesWritten = 0;
    m_PipeState[i].dwLastIOCallError = 0;

    DWORD dwRet = ConnectNamedPipe(m_PipeState[i].hPipe, &m_PipeState[i].overlapped);
    if (dwRet)
    {
        // The event should be signalled already, but just in case:
        SetEvent(m_PipeState[i].overlapped.hEvent);

        m_PipeState[i].dwLastIOCallError = ERROR_SUCCESS;
    }
    else
    {
        m_PipeState[i].dwLastIOCallError = GetLastError();
        if (m_PipeState[i].dwLastIOCallError == ERROR_PIPE_CONNECTED)
        {
            // The event should be signalled already, but just in case:
            SetEvent(m_PipeState[i].overlapped.hEvent);
        }
        else  if (m_PipeState[i].dwLastIOCallError == ERROR_IO_PENDING)
        {
            // Do nothing
        }
        else
        {
            // Set tbe event so that CPMSPService::Run deals with the error
            // in the next iteration of its main loop
            SetEvent(m_PipeState[i].overlapped.hEvent);
        }
    }
}

// This routine initiates a read on pipe instance i.
// Success/error status is saved away in m_PipeState[i].dwLastIOCallError
void CPMSPService::Read(DWORD i)
{
    DWORD dwRet;

    m_PipeState[i].state = PIPE_STATE::READ_PENDING;

    m_PipeState[i].overlapped.Offset = m_PipeState[i].overlapped.OffsetHigh = 0;

    CPMSPService::DebugMsg("Read(): client %u has %u unprocessed bytes in read buffer",
                           i, m_PipeState[i].dwNumBytesRead);

    if (m_PipeState[i].dwNumBytesRead >= NUM_BYTES_PER_READ_REQUEST)
    {
        // We already have another complete request; process it.
        dwRet = 1;
        m_PipeState[i].dwNumBytesTransferredByLastIOCall = 0;
    }
    else
    {
        dwRet = ReadFile(m_PipeState[i].hPipe, 
                         m_PipeState[i].readBuf + m_PipeState[i].dwNumBytesRead,
                         sizeof(m_PipeState[i].readBuf)- m_PipeState[i].dwNumBytesRead,
                         &m_PipeState[i].dwNumBytesTransferredByLastIOCall,
                         &m_PipeState[i].overlapped);
    }
    if (dwRet)
    {
        // The event should be signalled already if we issued a ReadFile, 
        // but it won't be signalled in other cases
        SetEvent(m_PipeState[i].overlapped.hEvent);

        m_PipeState[i].dwLastIOCallError = ERROR_SUCCESS;
    }
    else
    {
        m_PipeState[i].dwLastIOCallError = GetLastError();
        if (m_PipeState[i].dwLastIOCallError == ERROR_IO_PENDING)
        {
            // Do nothing
        }
        else
        {
            // Set tbe event so that CPMSPService::Run deals with the error
            // in the next iteration of its main loop. (Note that this may
            // not be an error condition - e.g., it could be EOF)
            SetEvent(m_PipeState[i].overlapped.hEvent);
        }
    }
}

// This routine initiates a write on pipe instance i.
// Success/error status is saved away in m_PipeState[i].dwLastIOCallError
void CPMSPService::Write(DWORD i)
{
    DWORD dwRet;

    m_PipeState[i].state = PIPE_STATE::WRITE_PENDING;

    m_PipeState[i].overlapped.Offset = m_PipeState[i].overlapped.OffsetHigh = 0;

    dwRet = WriteFile(m_PipeState[i].hPipe, 
                      m_PipeState[i].writeBuf + m_PipeState[i].dwNumBytesWritten,
                      m_PipeState[i].dwNumBytesToWrite - m_PipeState[i].dwNumBytesWritten,
                      &m_PipeState[i].dwNumBytesTransferredByLastIOCall,
                      &m_PipeState[i].overlapped);
    if (dwRet)
    {
        // The event should be signalled already, but just in case:
        SetEvent(m_PipeState[i].overlapped.hEvent);

        m_PipeState[i].dwLastIOCallError = ERROR_SUCCESS;
    }
    else
    {
        m_PipeState[i].dwLastIOCallError = GetLastError();
        if (m_PipeState[i].dwLastIOCallError == ERROR_IO_PENDING)
        {
            // Do nothing
        }
        else
        {
            // Set tbe event so that CPMSPService::Run deals with the error
            // in the next iteration of its main loop. (Note that this may
            // not be an error condition - e.g., it could be EOF)
            SetEvent(m_PipeState[i].overlapped.hEvent);
        }
    }
}

void CPMSPService::Run()
{
    DWORD  i;
    DWORD  dwRet;
    HANDLE hWaitArray[MAX_PIPE_INSTANCES+1];

    SetStatus(SERVICE_RUNNING);

    hWaitArray[0] = m_hStopEvent;
    for (i = 0; i < MAX_PIPE_INSTANCES; i++)
    {
        hWaitArray[i+1] = m_PipeState[i].overlapped.hEvent;
    }

    do
    {
        DWORD dwTimeout = (m_dwNumClients == 0)? INACTIVE_TIMEOUT_SHUTDOWN : INFINITE;
        dwRet = WaitForMultipleObjects(
                               sizeof(hWaitArray)/sizeof(hWaitArray[0]),
                               hWaitArray,
                               FALSE,       // wait for any one to be signalled
                               dwTimeout);

        if (dwRet == WAIT_FAILED)
        {
            m_Status.dwWin32ExitCode = GetLastError();
            CPMSPService::DebugMsg("Wait failed, last error %u", m_Status.dwWin32ExitCode );
            break;
        }
        if (dwRet == WAIT_OBJECT_0)
        {
            // Service has been stopped
            CPMSPService::DebugMsg("Service stopped");
            break;
        }
        if (dwRet == WAIT_TIMEOUT)
        {
            _ASSERTE(m_dwNumClients == 0);
            CPMSPService::DebugMsg("Service timed out - stopping");
            OnStop();
            continue;
        }
        _ASSERTE(dwRet >= WAIT_OBJECT_0 + 1);

        i = dwRet - WAIT_OBJECT_0 - 1;

        _ASSERTE(i < MAX_PIPE_INSTANCES);

        CPMSPService::DebugMsg("Service woken up by client %u in state %u", i, m_PipeState[i].state);

        // Although it's likely that all Win32 I/O calls do this at the
        // start of an I/O, we need to do this anyway. Our destructor 
        // uses the state of this event to determine whether to disconnect
        // the pipe.
        ResetEvent(m_PipeState[i].overlapped.hEvent);

        _ASSERTE(m_PipeState[i].state != PIPE_STATE::NO_IO_PENDING);

        if (m_PipeState[i].dwLastIOCallError == ERROR_IO_PENDING)
        {
            if (!GetOverlappedResult(m_PipeState[i].hPipe, 
                                     &m_PipeState[i].overlapped,
                                     &m_PipeState[i].dwNumBytesTransferredByLastIOCall,
                                     FALSE))
            {
                m_PipeState[i].dwLastIOCallError = GetLastError();

                // The following assertion should not fail because our event was
                // signaled.
                _ASSERTE(m_PipeState[i].dwLastIOCallError != ERROR_IO_INCOMPLETE);
            }
            else
            {
                m_PipeState[i].dwLastIOCallError = ERROR_SUCCESS;
            }
        }

        switch (m_PipeState[i].state)
        {
        case PIPE_STATE::NO_IO_PENDING:
            // This should not happen.
            // We have asserted m_PipeState[i].state != NO_IO_PENDING above.
            break;

        case PIPE_STATE::CONNECT_PENDING:
            if (m_PipeState[i].dwLastIOCallError == ERROR_SUCCESS || 
                m_PipeState[i].dwLastIOCallError == ERROR_PIPE_CONNECTED)
            {
                // A client has connected; issue a read
                m_dwNumClients++;
                CPMSPService::DebugMsg("Client %u connected, num clients is now: %u",
                                       i, m_dwNumClients);
                Read(i);

                // Reset error counter
                m_PipeState[i].dwConsecutiveConnectErrors = 0;
            }
            else
            {
                CPMSPService::DebugMsg("Client %u connect failed, error %u, # consecutive errors %u",
                                       i, m_PipeState[i].dwLastIOCallError, 
                                       m_PipeState[i].dwConsecutiveConnectErrors+1);
                if (++m_PipeState[i].dwConsecutiveConnectErrors == m_dwMaxConsecutiveConnectErrors)
                {
                    // We are done with this instance of the pipe, don't
                    // attempt to connect any more

                    // @@@@ We should break out of the loop and stop the service if all pipe instances 
                    // are hosed?

                    m_PipeState[i].state = PIPE_STATE::NO_IO_PENDING;
                }
                else
                {
                    // Connect to next client
                    ConnectToClient(i);
                }
            }
            break;

        case PIPE_STATE::READ_PENDING:
            if (m_PipeState[i].dwLastIOCallError == ERROR_SUCCESS)
            {
                // We read something. We may have read only a part of
                // a request or more than one request (if the client wrote
                // two requests to pipe before our read completed).  
                //
                // We have assumed that a request always has NUM_BYTES_PER_READ_REQUEST
                // bytes. Otherwise, we can't handle cases where the client writes
                // two requests at once (before our read completes) or writes part of 
                // requests or writes the whole request but ReadFile returns with some
                // of the bytes that the client wrote (this is unlikely to happen in 
                // practice).

                m_PipeState[i].dwNumBytesRead += m_PipeState[i].dwNumBytesTransferredByLastIOCall;

                CPMSPService::DebugMsg("Client %u read %u bytes; total bytes read: %u",
                                       i, m_PipeState[i].dwNumBytesTransferredByLastIOCall,
                                       m_PipeState[i].dwNumBytesRead);

                if (m_PipeState[i].dwNumBytesRead >= NUM_BYTES_PER_READ_REQUEST)
                {
                    GetAnswerToRequest(m_PipeState[i].hPipe,
                                       m_PipeState[i].readBuf, 
                                       m_PipeState[i].dwNumBytesRead,
                                       m_PipeState[i].writeBuf,
                                       sizeof(m_PipeState[i].writeBuf),
                                       &m_PipeState[i].dwNumBytesToWrite);
                    
                    // Remove the read request that has been processed from the read buffer
                    m_PipeState[i].dwNumBytesRead -= NUM_BYTES_PER_READ_REQUEST;
                    MoveMemory(m_PipeState[i].readBuf, 
                               m_PipeState[i].readBuf + NUM_BYTES_PER_READ_REQUEST,
                               m_PipeState[i].dwNumBytesRead); 

                    // Write response to the request that was just processed
                    Write(i);
                }
                else
                {
                    Read(i);
                }
            }
            else 
            {
                // If (m_PipeState[i].dwLastIOCallError == ERROR_HANDLE_EOF),
                // the reader's done and gone. So we can connect to another
                // client. For all other errors, we bail out on the client,
                // and connect to another client. Note that we do not call
                // FlushFileBuffers here. When the client's gone (we read EOF),
                // this is not necessary. In other cases, the client may lose
                // the  response to its last request - too bad. In any case the 
                // client has to be able to handle the server's abrupt disconnect.
                // 
                // Calling FlushFileBuffers opens us up to DOS attacks (and could
                // prevent the service from stopping) because the call is synchronous
                // and does not return till the client has read the stuff we wrote to
                // the pipe.

                CPMSPService::DebugMsg("Client %u read failed, error %u, num clients left: %u",
                                       i, m_PipeState[i].dwLastIOCallError, m_dwNumClients-1);
                DisconnectNamedPipe(m_PipeState[i].hPipe); 
                m_dwNumClients--;

                // Connect to another client
                ConnectToClient(i);
            }
            break;

        case PIPE_STATE::WRITE_PENDING:
            if (m_PipeState[i].dwLastIOCallError == ERROR_SUCCESS)
            {
                m_PipeState[i].dwNumBytesWritten += m_PipeState[i].dwNumBytesTransferredByLastIOCall;

                _ASSERTE(m_PipeState[i].dwNumBytesWritten <= m_PipeState[i].dwNumBytesToWrite);

                CPMSPService::DebugMsg("Wrote %u of %u bytes to client %u",
                                       m_PipeState[i].dwNumBytesWritten,
                                       m_PipeState[i].dwNumBytesToWrite, i);
                // >= is only a safety net. == should suffice in view of the assert above.
                if (m_PipeState[i].dwNumBytesWritten >= m_PipeState[i].dwNumBytesToWrite)
                {
                    // We are done with this request, read the next one
                    m_PipeState[i].dwNumBytesWritten = m_PipeState[i].dwNumBytesToWrite = 0;
                    Read(i);
                }
                else
                {
                    // We wrote only a part of what we were asked to write. Write the rest.
                    // This is very unlikely to happen since our buffers are small.
                    Write(i);
                }
            }
            else 
            {
                // For all errors, we bail out on the client,
                // and connect to another client. Note that we do not call
                // FlushFileBuffers here. The client may lose
                // the response to its last request - too bad. In any case the 
                // client has to be able to handle the server's abrupt disconnect.
                // 
                // Calling FlushFileBuffers opens us up to DOS attacks (and could
                // prevent the service from stopping) because the call is synchronous
                // and does not return till the client has read the stuff we wrote to
                // the pipe.

                CPMSPService::DebugMsg("Client %u write failed, error %u, num clients left: %u",
                                       i, m_PipeState[i].dwLastIOCallError, m_dwNumClients-1);
                m_PipeState[i].dwNumBytesWritten = m_PipeState[i].dwNumBytesToWrite = 0;
                DisconnectNamedPipe(m_PipeState[i].hPipe); 
                m_dwNumClients--;

                // Connect to another client
                ConnectToClient(i);
            }
            break;

        } // switch m_PipeState[i].state)
    }
    while (1);

    return;
}


// Process user control requests
BOOL CPMSPService::OnUserControl(DWORD dwOpcode)
{
    // switch (dwOpcode)
    // {
    // case SERVICE_CONTROL_USER + 0:

        // // Save the current status in the registry
        // SaveStatus();
        // return TRUE;

    // default:
    //    break;
    // }
    return FALSE; // say not handled
}

void CPMSPService::OnStop()
{
    SetStatus(SERVICE_STOP_PENDING);
    if (m_hStopEvent)
    {
        SetEvent(m_hStopEvent);
    }
    else
    {
        _ASSERTE(m_hStopEvent);
    }
}

void CPMSPService::OnShutdown()
{
    OnStop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmspsv\svchost\ntservice.cpp ===
// NTService.cpp
//
// Implementation of CNTService

#include <windows.h>
#include <stdio.h>
#include "NTService.h"
#include "svchost.h"
#include "PMSPService.h"
#include <crtdbg.h>

//// static variables
CNTService*             g_pService = NULL;
CRITICAL_SECTION        g_csLock;

CNTService::CNTService()
{
//    // Set the default service name and version
//    strncpy(m_szServiceName, szServiceName, sizeof(m_szServiceName)-1);
//    strncpy(m_szServiceDisplayName, szServiceDisplayName, sizeof(m_szServiceDisplayName)-1);
//    m_iMajorVersion = 1;
//    m_iMinorVersion = 4;

    // set up the initial service status 
    m_hServiceStatus = NULL;
    m_Status.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    m_Status.dwCurrentState = SERVICE_STOPPED;
    m_Status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    m_Status.dwWin32ExitCode = 0;
    m_Status.dwServiceSpecificExitCode = 0;
    m_Status.dwCheckPoint = 0;
    m_Status.dwWaitHint = 0;
    m_bIsRunning = FALSE;
}

CNTService::~CNTService()
{
    DebugMsg("CNTService::~CNTService()");
}

////////////////////////////////////////////////////////////////////////////////////////
// Default command line argument parsing


////////////////////////////////////////////////////////////////////////////////////////
// Install/uninstall routines

// Test if the service is currently installed
BOOL CNTService::IsInstalled()
{
    BOOL bResult = FALSE;

    // Open the Service Control Manager
    SC_HANDLE hSCM = ::OpenSCManager(NULL, // local machine
                                     NULL, // ServicesActive database
                                     GENERIC_READ); // access combined STANDARD_RIGHTS_READ,
	                                                // SC_MANAGER_ENUMERATE_SERVICE, and
	                                                // SC_MANAGER_QEURY_LOCK_STATUS
    if (hSCM) 
    {
        // Try to open the service
        SC_HANDLE hService = ::OpenService(hSCM,
                                           SERVICE_NAME,
                                           SERVICE_QUERY_CONFIG);
        if (hService) 
        {
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }

        ::CloseServiceHandle(hSCM);
    }
    return bResult;
}


///////////////////////////////////////////////////////////////////////////////////////
// Logging functions

// This function makes an entry into the application event log
void CNTService::LogEvent(WORD wType, DWORD dwID,
                          const char* pszS1,
                          const char* pszS2,
                          const char* pszS3)
{
    HANDLE hEventSource = NULL;
    const char* ps[3];
    ps[0] = pszS1;
    ps[1] = pszS2;
    ps[2] = pszS3;

    WORD iStr = 0;
    for (int i = 0; i < 3; i++) {
        if (ps[i] != NULL) iStr++;
        else
        {
            // Ensure that the remaining arguments are NULL, zap them
            // if they are not. Otherwise, ReportEvent will fail
            for (; i < 3; i++)
            {
                if (ps[i] != NULL)
                {
                    _ASSERTE(ps[i] == NULL);
                    ps[i] = NULL;
                }
            }
            // We will break out of the outer for loop since i == 3
        }
    }
        
    // Register event source 
    hEventSource = ::RegisterEventSource( NULL,  // local machine
                                          SERVICE_NAME); // source name

    if (hEventSource) 
    {
        ::ReportEvent(hEventSource,
                      wType,
                      0,
                      dwID,
                      NULL, // sid
                      iStr,
                      0,
                      ps,
                      NULL);

        ::DeregisterEventSource(hEventSource);   
    }
}


///////////////////////////////////////////////////////////////////////////////////////////
// status functions

void CNTService::SetStatus(DWORD dwState)
{
    DebugMsg("CNTService::SetStatus(%lu, %lu)", m_hServiceStatus, dwState);

    // If a stop is pending, the only next state we'll report is STOPPED.
    // If the Stop was issued while we are being started, the service thread
    // will start fully and then commence stopping (as the code is currently
    // structured). While it is starting, it will update the check point.
    // We ignore the state it sends in (START_PENDING) and lie to the SCM.

    if (m_Status.dwCurrentState != SERVICE_STOP_PENDING ||
        dwState == SERVICE_STOPPED)
    {
        if (m_Status.dwCurrentState != dwState)
        {
            m_Status.dwCurrentState = dwState;
            m_Status.dwCheckPoint = 0;
            m_Status.dwWaitHint = 0;
        }
    }
    if (m_Status.dwCurrentState == SERVICE_STOP_PENDING ||
        m_Status.dwCurrentState == SERVICE_START_PENDING ||
        m_Status.dwCurrentState == SERVICE_PAUSE_PENDING ||
        m_Status.dwCurrentState == SERVICE_CONTINUE_PENDING)
    {
        m_Status.dwCheckPoint++;
        m_Status.dwWaitHint = 500;
    }
    ::SetServiceStatus(m_hServiceStatus, &m_Status);
}

///////////////////////////////////////////////////////////////////////////////////////////
// Service initialization

BOOL CNTService::Initialize()
{
    DWORD dwLastError;

    DebugMsg("Entering CNTService::Initialize()");

    
    // Perform the actual initialization
    BOOL bResult = OnInit(dwLastError); 
    
    // Bump up the check point
    SetStatus(SERVICE_START_PENDING);

    if (!bResult) 
    {
        m_Status.dwWin32ExitCode = dwLastError;
	    CNTService::DebugMsg("The initialization process failed" );
        return FALSE;    
    }
    
    DebugMsg("Leaving CNTService::Initialize()");
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////////////////////
// main function to do the real work of the service

//////////////////////////////////////////////////////////////////////////////////////
// Control request handlers

// static member function (callback) to handle commands from the
// service control manager
void CNTService::Handler(DWORD dwOpcode)
{
    BOOL    bStop = FALSE;

    __try
    {
        EnterCriticalSection (&g_csLock);

        // Get a pointer to the object
        CNTService* pService = g_pService;

        if (!pService)
        {
            __leave;
        }
        
        CNTService::DebugMsg("CNTService::Handler(%lu)", dwOpcode);
        switch (dwOpcode) {
        case SERVICE_CONTROL_STOP: // 1
            pService->OnStop();
            break;

        case SERVICE_CONTROL_PAUSE: // 2
            pService->OnPause();
            break;

        case SERVICE_CONTROL_CONTINUE: // 3
            pService->OnContinue();
            break;

        case SERVICE_CONTROL_INTERROGATE: // 4
            pService->OnInterrogate();
            break;

        case SERVICE_CONTROL_SHUTDOWN: // 5
            pService->OnShutdown();
            break;

        default:
            if (dwOpcode >= SERVICE_CONTROL_USER) 
            {
                if (!pService->OnUserControl(dwOpcode)) 
                {
                    pService->LogEvent(EVENTLOG_ERROR_TYPE, EVMSG_BADREQUEST);
                }
            } 
            else 
            {
                pService->LogEvent(EVENTLOG_ERROR_TYPE, EVMSG_BADREQUEST);
            }
            break;
        }

        // Report current status - let the On* functions do this by calling SetStatus
        // CNTService::DebugMsg("Updating status (%lu, %lu)",
        //                 pService->m_hServiceStatus,
        //                 pService->m_Status.dwCurrentState);
        // ::SetServiceStatus(pService->m_hServiceStatus, &pService->m_Status);
    }
    __finally
    {
        LeaveCriticalSection (&g_csLock);
    }

}
        
// called when the service is interrogated
void CNTService::OnInterrogate()
{
    DebugMsg("CNTService::OnInterrogate()");
}

// called when the service is paused
void CNTService::OnPause()
{
    DebugMsg("CNTService::OnPause()");
}

// called when the service is continued
void CNTService::OnContinue()
{
    DebugMsg("CNTService::OnContinue()");
}

// called when the service is shut down
void CNTService::OnShutdown()
{
    DebugMsg("CNTService::OnShutdown()");
}

////////////////////////////////////////////////////////////////////////////////////////////
// Debugging support

// #define WRITE_TO_LOG_FILE

void CNTService::DebugMsg(const char* pszFormat, ...)
{
#if defined(DBG) || defined(WRITE_TO_LOG_FILE)
    char buf[1024];
    sprintf(buf, "[Serial Number Library](%lu): ", GetCurrentThreadId());
        va_list arglist;
        va_start(arglist, pszFormat);
    vsprintf(&buf[strlen(buf)], pszFormat, arglist);
        va_end(arglist);
    strcat(buf, "\n");

#if defined(DBG)
    OutputDebugString(buf);
#endif

#if defined(WRITE_TO_LOG_FILE)
    FILE* fp = fopen("c:\\WmdmService.txt", "a");
    if (fp)
    {
        fprintf(fp, buf);
        fclose(fp);
    }
#endif

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmspsv\svchost\pmspservice.h ===
// PMSPservice.h

#include "ntservice.h"

#define MAX_PIPE_INSTANCES (5)

class CPMSPService : public CNTService
{
public:
    CPMSPService(DWORD& dwLastError);
    virtual ~CPMSPService();
    virtual BOOL OnInit(DWORD& dwLastError);
    virtual void Run();
    virtual BOOL OnUserControl(DWORD dwOpcode);

    virtual void OnStop();
    virtual void OnShutdown();

protected:
    // Manual reset event; signalled to stop the service, else unsignalled
    HANDLE m_hStopEvent;

    // Number of clients connected to named pipe
    DWORD  m_dwNumClients; 

    typedef struct 
    {
        // Note: This struct is initilized by calling ZeroMemory in the
        // constructor. If members are added that should not have an inital
        //value of 0, change the constructor.

        HANDLE                  hPipe;
        OVERLAPPED              overlapped;
        enum {
            NO_IO_PENDING = 0,
            CONNECT_PENDING,
            READ_PENDING,
            WRITE_PENDING
        }                       state;

        // Read state:
        BYTE                    readBuf[256];
        DWORD                   dwNumBytesRead;

        // Write state:
        BYTE                    writeBuf[256];
        DWORD                   dwNumBytesToWrite;
        DWORD                   dwNumBytesWritten;

        // MSDN is not clear whether we can call GetOverlappedResult if an
        // i/o call returns with anything other than ERROR_IO_PENDING. 
        // So we don't. We stash away the last IO result and the number of
        // bytes transferred (if appropraite) so that we can 
        // decide whether to call GetOverlappedResult later.

        DWORD                   dwLastIOCallError;
        DWORD                   dwNumBytesTransferredByLastIOCall;

        // The number of consecutive calls to ConenctNamedPipe that return 
        // failure. Once this hits the limit, we do not attempt to connect to
        // this instance of the pipe any more.
        DWORD                   dwConsecutiveConnectErrors;

    } PIPE_STATE, *PPIPE_STATE;

    PIPE_STATE   m_PipeState[MAX_PIPE_INSTANCES];

    static const DWORD m_dwMaxConsecutiveConnectErrors;

    // Helper methods
    void ConnectToClient(DWORD i);
    void Read(DWORD i);
    void Write(DWORD i);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\setup\drmver\main.cpp ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wtypes.h>
#include <windows.h>

#include <sys\stat.h>

#include "wmdm_ver.h"
#include <tchar.h>

BOOL FileExists(LPCSTR pszFile)
{
    return (GetFileAttributesA(pszFile) != 0xFFFFFFFF);
}

////////////////////////////////////////////////////////////////////////
void SeparateName( const TCHAR *pszFullPath, TCHAR *pszFileName)
////////////////////////////////////////////////////////////////////////
{ 
    if( ( NULL == pszFullPath ) ||  ( NULL == pszFileName ) )
    {
        return;
    }

    TCHAR *pIndex = _tcsrchr( pszFullPath, _T( '\\' ) );  

    if( pIndex )
    {
        _tcscpy( pszFileName, pIndex + 1);
    }
    else                       
    {
        _tcscpy( pszFileName, pszFullPath);
    }
}       


//////////////////////////////////////////////////////////////////////////////
HRESULT GetFileVersion( LPCSTR pszFileName, LPSTR pszVersionStr )
//////////////////////////////////////////////////////////////////////////////
{
    if( ( NULL == pszFileName ) || ( !FileExists( pszFileName ) ) )
    {
        return( E_FAIL );
    }

    //
    // Figure out size of version information
    //
    DWORD dwHandle;
    DWORD versionInfoSize = GetFileVersionInfoSize( (LPSTR)pszFileName, &dwHandle );

    if( 0 == versionInfoSize )
    {
        DWORD dwError = GetLastError();

        return( E_FAIL );
    }

    //
    // Allocate a buffer to hold the version information
    //
    BYTE *pVersionInfo = new BYTE[versionInfoSize];

    if( NULL == pVersionInfo )
    {
        return( E_OUTOFMEMORY );
    }

    //
    // Load the version information
    //
    HRESULT hr = E_FAIL;

    if( GetFileVersionInfo( (LPSTR)pszFileName, 0, versionInfoSize, pVersionInfo ) )
    {
        VS_FIXEDFILEINFO *pFileInfo;
        UINT fileInfoLen;

        if( VerQueryValue( pVersionInfo, "\\", (void**)&pFileInfo, &fileInfoLen ) )
        {
            sprintf( pszVersionStr, "%lu,%lu,%lu,%lu", HIWORD( pFileInfo->dwFileVersionMS ), LOWORD( pFileInfo->dwFileVersionMS ), HIWORD( pFileInfo->dwFileVersionLS ), LOWORD( pFileInfo->dwFileVersionLS ) );
            
            hr = S_OK;
        }
        else
        {
            DWORD dwError = GetLastError();
        }
    }
    else
    {
        DWORD dwError = GetLastError();
    }

    delete [] pVersionInfo;

    return( hr );
}


//*****************************************************************************
void __cdecl main ( int argc, char **argv )
// See Usage for exact details
//*****************************************************************************
{
    BOOL fSent = FALSE;

    if( argc > 1 )
    {
        char szVersion[100];

        if( ( strstr( argv[1], "inf" ) ) || ( strstr( argv[1], "INF" ) ) )
        {
            char *pComma;

            strcpy( szVersion, VER_WMDM_PRODUCTVERSION_STR );

            pComma = strstr( szVersion, "." );

            while( NULL != pComma )
            {
                pComma[0] = ',';
                pComma = strstr( szVersion, "." );
            }

            fSent = TRUE;
        }
        else if( ( strstr( argv[1], "purge" ) ) || ( strstr( argv[1], "PURGE" ) ) )
        {
            char szData[50];
            char szCurrentIni[MAX_PATH];

            GetTempPath( sizeof( szCurrentIni ), szCurrentIni );
            strcat( szCurrentIni, "\\mp2size.ini" );

            if( GetPrivateProfileString( "Size", "Total", "Leprechauns", szData, sizeof( szData ), szCurrentIni )
                && ( 0 != _stricmp( "Leprechauns", szData ) ) )
            {
                printf( "TotalSize=%s\n", szData );
            }

            DeleteFile( szCurrentIni );

            exit( 0 );
        }
        else if( argc > 2 )
        {
            if( ( strstr( argv[1], "client" ) ) || ( strstr( argv[1], "CLIENT" ) ) )
            {
                if( S_OK == GetFileVersion( argv[2], szVersion ) )
                {
                    fSent = TRUE;
                }
            }
            else if( ( strstr( argv[1], "addsize" ) ) || ( strstr( argv[1], "ADDSIZE" ) ) )
            {
                if( FileExists( argv[2] ) )
                {
                    char szData[50];
                    char szCurrentIni[MAX_PATH];
                    struct _stat  ss;
                    DWORD dwSize = 0;

                    GetTempPath( sizeof( szCurrentIni ), szCurrentIni );
                    strcat( szCurrentIni, "\\mp2size.ini" );

                    if( GetPrivateProfileString( "Size", "Total", "Leprechauns", szData, sizeof( szData ), szCurrentIni )
                        && ( 0 != _stricmp( "Leprechauns", szData ) ) )
                    {
                        dwSize = atol( szData );
                    }
                    else
                    {
                        dwSize = 0;
                    }
                     
                    if( _stat( argv[2], &ss ) == 0)
                    {
                        dwSize += ss.st_size;
                    }

                    sprintf( szData, "%lu", dwSize );

                    WritePrivateProfileString( "Size", "Total", szData, szCurrentIni );

                    printf( "%lu", dwSize );
                }
                else
                {
                    printf( "File %s not found!\n", argv[2] );
                }

                exit( 0 );
            }
            else if( ( strstr( argv[1], "sizeit" ) ) || ( strstr( argv[1], "SIZEIT" ) ) )
            {
                if( FileExists( argv[2] ) )
                {
                    TCHAR szFileName[100];
                    struct _stat  ss;
                    DWORD dwSize = 0;

                    if( _stat( argv[2], &ss ) == 0)
                    {
                        dwSize += ss.st_size;
                    }

                    SeparateName( argv[2], szFileName );

                    printf( "%s=0,,%lu\n", szFileName, dwSize );
                }

                exit( 0 );
            }
        }

        if( fSent )
        {
            printf( "\nVERSION=\"%s\"\n", szVersion );
        }
    }

    if( !fSent )
    {
        printf( "\n[VersionSection]\n" );
        printf( "FileVersion=\"%s\"\n", VER_WMDM_PRODUCTVERSION_STR );
        printf( "ProductVersion=\"%s\"\n", VER_WMDM_PRODUCTVERSION_STR );
        printf( "FileDescription=\"Windows Media Component Setup Application\"\n" );
        printf( "ProductName=\"Windows Media Component Setup Application\"\n" );
        printf( "LegalCopyright=\"Copyright (C) %s %s\"\n", VER_WMDM_COMPANYNAME_STR, VER_WMDM_LEGALCOPYRIGHT_YEARS );
    }

    exit( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\mdsp\mspmspsv\svchost\svchost.cpp ===
// mpsmpssv.cpp
// 
// This is the main file containing the entry points.

#include "NTServApp.h"
#include "PMSPservice.h"
#include <nserror.h>
#include "svchost.h"
#include <Sddl.h>
#include <aclapi.h>
#include <crtdbg.h>
#include <wmsstd.h>

HRESULT AddToSvcHostGroup();
BOOL    UnregisterOldServer( SC_HANDLE hSCM );
STDAPI DllUnregisterServer(void);

#define SVCHOST_SUBKEY    "netsvcs"
#define SVCHOST_SUBKEYW  L"netsvcs"

//#define DEBUG_STOP { _asm { int 3 }; }
#define DEBUG_STOP

HMODULE g_hDll = NULL;

BOOL APIENTRY DllMain( HINSTANCE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved )
{
    switch (ul_reason_for_call)
    {
        case DLL_PROCESS_ATTACH:
            g_hDll = (HMODULE)hModule;
            InitializeCriticalSection (&g_csLock);
            DisableThreadLibraryCalls (hModule);
            break;

        case DLL_PROCESS_DETACH:
            DeleteCriticalSection (&g_csLock);
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            _ASSERTE(0);
            break;
    }
    return TRUE;
}



// Main entry point to start service
void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    // We grab the lock so that any attempt to stop the service while
    // the object is being constructed or registered will be pended.
    EnterCriticalSection (&g_csLock);

    _ASSERTE(g_pService == NULL);

    DEBUG_STOP
    CNTService::DebugMsg("Entering CNTService::ServiceMain()");

    DWORD           dwLastError;

    // Allocate this on the heap rather than the stack so that
    // we have a chance to call its destructor if the service
    // terminates ungracefully.
    CPMSPService*   pService = new CPMSPService(dwLastError);

    if (pService == NULL)
    {
        LeaveCriticalSection (&g_csLock);
        dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        // @@@@: What message do we log here
        // CNTService::LogEvent(EVENTLOG_ERROR_TYPE, EVMSG_CTRLHANDLERNOTINSTALLED);
        CNTService::DebugMsg("Leaving CNTService::ServiceMain() CPMSPService constructor failed - last error %u", dwLastError);
        return;
    }

    CPMSPService&   service = *pService;
    
    if (dwLastError != ERROR_SUCCESS)
    {
        LeaveCriticalSection (&g_csLock);
        // @@@@: What message do we log here
        // CNTService::LogEvent(EVENTLOG_ERROR_TYPE, EVMSG_CTRLHANDLERNOTINSTALLED);
        CNTService::DebugMsg("Leaving CNTService::ServiceMain() CPMSPService constructor failed - last error %u", dwLastError);
        delete pService;
        return;
    }

    // Register the control request handler
    service.m_hServiceStatus = RegisterServiceCtrlHandler( SERVICE_NAME,
                                                           CNTService::Handler );
    if (service.m_hServiceStatus == NULL) 
    {
        LeaveCriticalSection (&g_csLock);
        CNTService::LogEvent(EVENTLOG_ERROR_TYPE, EVMSG_CTRLHANDLERNOTINSTALLED);
        CNTService::DebugMsg("Leaving CNTService::ServiceMain() RegisterServiceCtrlHandler failed");
        delete pService;
        return;
    }

    service.SetStatus(SERVICE_START_PENDING);

    // Start the initialisation
    __try
    {
        g_pService = &service;  // The Handler method will need to get a hold of this object
        LeaveCriticalSection (&g_csLock);

        if (service.Initialize()) {

            // Do the real work. 
            // When the Run function returns, the service has stopped.
            service.m_bIsRunning = TRUE;
            service.Run();
        }
    }
    __finally
    {
        // Tell the service manager we are stopped and reset g_pService.
        // Note that we hold the crit sect while calling SetStatus so that
        // we have the final say on the status reported to the SCM.

        // Note: If the thread dies (e.g., av's), we clean up, but svchost
        // does not, so it is not possible to re-start the service. Consider
        // adding our own exception handler.

        EnterCriticalSection (&g_csLock);
        service.SetStatus(SERVICE_STOPPED);
        g_pService = NULL;
        LeaveCriticalSection (&g_csLock);
        CNTService::DebugMsg("Leaving CNTService::ServiceMain()");
        delete pService;
    }
}


HRESULT ModifySD(SC_HANDLE hService)
{
    PACL pDacl = NULL;
    PACL pNewDacl = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD Err = ERROR_SUCCESS;
    PSID pAuthenUserSid = NULL;


    __try
    {
        //
        // Get DACL for the service object.
        //
        Err = GetSecurityInfo(hService, SE_SERVICE, DACL_SECURITY_INFORMATION,
                              NULL, NULL, &pDacl, NULL, &pSD
                              );

        if(Err != ERROR_SUCCESS)
        {
            __leave;
        }
                                                  
        SID_IDENTIFIER_AUTHORITY Auth = SECURITY_NT_AUTHORITY;
        if(0 == AllocateAndInitializeSid(&Auth, 1, SECURITY_INTERACTIVE_RID, 
                                         0, 0, 0, 0, 0, 0, 0, &pAuthenUserSid)
          )
        {
            Err = GetLastError();
            __leave;
        }

        //
        // Initialize an EXPLICIT_ACCESS structure for the new ACE. The new ACE allows
        // authenticated users to start/stop our service.
        //
        EXPLICIT_ACCESS ExpAccess;
        ZeroMemory(&ExpAccess, sizeof(EXPLICIT_ACCESS));
        ExpAccess.grfAccessPermissions = SERVICE_START; // | SERVICE_STOP ;
        ExpAccess.grfAccessMode = GRANT_ACCESS;
        ExpAccess.grfInheritance = NO_INHERITANCE;
        ExpAccess.Trustee.pMultipleTrustee = NULL;
        ExpAccess.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
        ExpAccess.Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ExpAccess.Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;
        ExpAccess.Trustee.ptstrName = (LPTSTR)pAuthenUserSid;

        //Create new DACL
        Err = SetEntriesInAcl(1, &ExpAccess, pDacl, &pNewDacl) ;
        if(ERROR_SUCCESS == Err)
        {
            // Update the security descriptor on the service
            Err = SetSecurityInfo(hService, SE_SERVICE, DACL_SECURITY_INFORMATION, NULL, NULL,
                                pNewDacl, NULL);
        }


    }
    __finally
    {

        if(pSD)
        {
            LocalFree(pSD);
        }

        if(pAuthenUserSid){
            FreeSid(pAuthenUserSid);
        }

        if(pNewDacl)
        {
            LocalFree(pNewDacl);
        }

    }
    

    return HRESULT_FROM_WIN32(Err);
}

// Install and start service
STDAPI DllRegisterServer(void)
{
    HRESULT hr = E_FAIL;
    SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL; 
    TCHAR   pszDisplayName[256];
    char szKey[256];
    HKEY hKey = NULL;

    DEBUG_STOP;

    // Already installed?
    if( CNTService::IsInstalled() )
    {
       hr = DllUnregisterServer();
       if( !SUCCEEDED(hr) )
       {
           return hr;
       }
    }

    if( g_hDll == NULL )
    { 
        return E_FAIL;
    }

    // Open the Service Control Manager
    hSCM = ::OpenSCManager( NULL, // local machine
                            NULL, // ServicesActive database
                            SC_MANAGER_ALL_ACCESS); // full access
    if (!hSCM) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Error;
    }

    //
    // On Win2k we have this service running as separate process which should
    // be uninstalled.
    //
    UnregisterOldServer( hSCM );


    // Get the path of this dll
    char szFilePath[MAX_PATH];
    if (::GetModuleFileName( g_hDll, szFilePath, ARRAYSIZE(szFilePath)) == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Error;
    }

    // Create the service
    if (FormatMessage( FORMAT_MESSAGE_FROM_HMODULE, g_hDll, EVMSG_DISPLAYNAME,
                    0, pszDisplayName, ARRAYSIZE(pszDisplayName), NULL ) == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Error;
    }
    hService = ::CreateService(  hSCM,
                                 SERVICE_NAME,
                                 pszDisplayName,
                                 SERVICE_ALL_ACCESS,
                                 SERVICE_WIN32_SHARE_PROCESS,
                                 SERVICE_DEMAND_START,
                                 SERVICE_ERROR_NORMAL,
                                 "%SystemRoot%\\System32\\svchost.exe -k " SVCHOST_SUBKEY,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL);
    if (!hService) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Error;
    }

    //
    // Modify the security descriptor on the created service so that 
    // Authenticated Users can start/stop services. By default only admins can start/stop 
    // services
    //

    hr = ModifySD(hService);
    if(!SUCCEEDED(hr))
    {
        goto Error;
    }

    // Set description of service, method only avalible for OS >= Win2K so we
    // need to load the dll, method in runtime.
    {
        typedef BOOL (WINAPI *funCSC2)(SC_HANDLE, DWORD, LPVOID );
	    funCSC2 pChangeServiceConfig2 = NULL;
        HINSTANCE hDll = NULL;

        hDll = ::LoadLibraryExA( "advapi32.dll", NULL, 0 );
        if( hDll != NULL )
        {
            pChangeServiceConfig2 = (funCSC2)GetProcAddress( hDll, "ChangeServiceConfig2W");

	        if( pChangeServiceConfig2 )
            {
                WCHAR   pszDescription[1024];
                int     iCharsLoaded = 0;

                SERVICE_DESCRIPTIONW sd;
                iCharsLoaded = FormatMessageW( FORMAT_MESSAGE_FROM_HMODULE, g_hDll, EVMSG_DESCRIPTION,
                                               0, pszDescription, sizeof(pszDescription)/sizeof(pszDescription[0]), NULL ); 
                if( iCharsLoaded )
                {
                    sd.lpDescription = pszDescription;
                    pChangeServiceConfig2( hService, 
                                           SERVICE_CONFIG_DESCRIPTION,      
                                           &sd);
                }
            }
            FreeLibrary( hDll );
        }
    }

    // Add parameters subkey
    {
        strcpy(szKey, "SYSTEM\\CurrentControlSet\\Services\\");
        strcat(szKey, SERVICE_NAME);
        strcat(szKey, "\\Parameters");
        hr = ::RegCreateKey(HKEY_LOCAL_MACHINE, szKey, &hKey); 
        if( hr != ERROR_SUCCESS)  
        {
            hr = HRESULT_FROM_WIN32(hr);
            goto Error;
        }

        // Add the Event ID message-file name to the 'EventMessageFile' subkey.
        hr = ::RegSetValueEx(hKey,
                             "ServiceDll",
                             0,
                             REG_EXPAND_SZ, 
                             (CONST BYTE*)szFilePath,
                             strlen(szFilePath) + 1);     
        if( hr != ERROR_SUCCESS)  
        {
            hr = HRESULT_FROM_WIN32(hr);
            ::RegCloseKey(hKey);
            goto Error;
        }
        ::RegCloseKey(hKey);
    }


    hr = AddToSvcHostGroup();
    if( FAILED(hr) ) goto Error;

    // make registry entries to support logging messages
    // Add the source name as a subkey under the Application
    // key in the EventLog service portion of the registry.
    {
        strcpy(szKey, "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\");
        strcat(szKey, SERVICE_NAME);
        hr = ::RegCreateKey(HKEY_LOCAL_MACHINE, szKey, &hKey); 
        if( hr != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(hr);
            goto Error;
        }

        // Add the Event ID message-file name to the 'EventMessageFile' subkey.
        hr = ::RegSetValueEx(hKey,
                        "EventMessageFile",
                        0,
                        REG_EXPAND_SZ, 
                        (CONST BYTE*)szFilePath,
                        strlen(szFilePath) + 1);     
        if( hr != ERROR_SUCCESS)  
        {
            hr = HRESULT_FROM_WIN32(hr);
            ::RegCloseKey(hKey);
            goto Error;
        }

        // Set the supported types flags.
        DWORD dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;
        hr = ::RegSetValueEx(hKey,
                        "TypesSupported",
                        0,
                        REG_DWORD,
                        (CONST BYTE*)&dwData,
                         sizeof(DWORD));
        if( hr != ERROR_SUCCESS)  
        {
            hr = HRESULT_FROM_WIN32(hr);
            ::RegCloseKey(hKey);
            goto Error;
        }
        ::RegCloseKey(hKey);
    }

#if 0
    // Start service
    { 
        SERVICE_STATUS    ServiceStatus;

        if( !QueryServiceStatus( hService, &ServiceStatus ) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Error;
        }

        if( ServiceStatus.dwCurrentState != SERVICE_RUNNING )
        {
            // start the service
            BOOL    bStarted;
            bStarted = StartService(hService, 0, NULL);
            if( !bStarted )
            {

                hr = HRESULT_FROM_WIN32(GetLastError());

                // The service can not be started if it just was added to the svchost group. 
                // The svchost needs to be restarted first. 
                // (The svchost only reads it's service array at startup)
                if( hr == HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_IN_EXE) )
                {
                    // This error code will be handled by the installer 
                    hr = NS_S_REBOOT_REQUIRED;  // 0x000D2AF9L 
                }
                goto Error;

            }
        }
    }

#endif

    CNTService::LogEvent(EVENTLOG_INFORMATION_TYPE, EVMSG_INSTALLED, SERVICE_NAME);
    hr = S_OK;

Error:
    if( hService )  ::CloseServiceHandle(hService);
    if( hSCM )      ::CloseServiceHandle(hSCM);

    //
    // Check: should we return here NS_S_REBOOT_REQUIRED, if the service is installed.
    return hr;
}

// Stop and Uninstall service
STDAPI DllUnregisterServer(void)
{
    HRESULT hr = E_FAIL;
    char szKey[256];
    HKEY hKey = NULL;
    SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL;

    DEBUG_STOP

    // Not installed ?
    if( !CNTService::IsInstalled() )
    {
        return S_FALSE;
    }

    // Open the Service Control Manager
    hSCM = ::OpenSCManager(  NULL, // local machine
                             NULL, // ServicesActive database
                             SC_MANAGER_ALL_ACCESS); // full access
    if (!hSCM) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Error;
    }

    hService = ::OpenService(  hSCM,
                               SERVICE_NAME,
                               SERVICE_ALL_ACCESS);

    // Remove service
    if (hService) 
    {
        // Stop service
        { 
            SERVICE_STATUS    ServiceStatus;

            if( !QueryServiceStatus( hService, &ServiceStatus ) )
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Error;
            }

            if( ServiceStatus.dwCurrentState != SERVICE_STOPPED )
            {
                // start the service
                SERVICE_STATUS ss;
                BOOL    bStopped;

                bStopped = ControlService(  hService,
                                            SERVICE_CONTROL_STOP,
                                            &ss);
                if( !bStopped )
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    goto Error;
                }
            }
        }  
  
        if (::DeleteService(hService)) 
        {
            CNTService::LogEvent(EVENTLOG_INFORMATION_TYPE, EVMSG_REMOVED, SERVICE_NAME);
            hr = S_OK;
        } 
        else 
        {
            CNTService::LogEvent(EVENTLOG_ERROR_TYPE, EVMSG_NOTREMOVED, SERVICE_NAME);
            hr = HRESULT_FROM_WIN32(GetLastError());
            // Do not delete eventlog related registry keys unless the service has been deleted
            goto Error;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Error;
    }
   
    // Delete EventLog entry in registry
    strcpy(szKey, "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\");
    strcat(szKey, SERVICE_NAME);
    RegDeleteKey( HKEY_LOCAL_MACHINE, szKey );

Error:
    if(hSCM)        ::CloseServiceHandle(hSCM);
    if(hService)    ::CloseServiceHandle(hService);
   
    return hr;
}

// Add entry to the right svchost group, (netsvcs)
HRESULT AddToSvcHostGroup()
{
    HRESULT hr = S_OK;
    DWORD   dwOrgSize;
    DWORD   dwDestSize;
    long    lResult;
    DWORD   dwStrIndex;
    DWORD   dwType;
    HKEY    hKey = NULL;
    WCHAR*  pwszStringOrg = NULL;
    WCHAR*  pwszStringDest = NULL;

    DEBUG_STOP

    lResult = RegCreateKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Svchost", &hKey); 
    if( lResult != ERROR_SUCCESS ) 
    {
        hr = E_FAIL;
        goto Error;
    }
    lResult = RegQueryValueExW(  hKey,
                                 SVCHOST_SUBKEYW,     // subkey name
                                 NULL,
                                 &dwType,
                                 NULL,                // string buffer
                                 &dwOrgSize );        // size of returned string
    if( lResult != ERROR_SUCCESS )
    {
        hr = E_FAIL;
        goto Error;
    }
    if (dwType != REG_SZ && dwType != REG_MULTI_SZ && dwType != REG_EXPAND_SZ)
    {
        hr = E_FAIL;
        goto Error;
    }

    dwDestSize = dwOrgSize + (wcslen( SERVICE_NAMEW ) +1)*sizeof(WCHAR);
    pwszStringOrg = (WCHAR*)new BYTE[dwOrgSize];
    pwszStringDest = (WCHAR*)new BYTE[dwDestSize];

    if( pwszStringOrg == NULL || pwszStringDest == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }
    lResult = RegQueryValueExW( hKey,
                               SVCHOST_SUBKEYW,         // subkey name
                               NULL,
                               &dwType,
                               (BYTE*)pwszStringOrg,    // string buffer
                               &dwOrgSize );            // size of returned string
    if( lResult != ERROR_SUCCESS )
    {
        hr = E_FAIL;
        goto Error;
    }
    if (dwType != REG_SZ && dwType != REG_MULTI_SZ && dwType != REG_EXPAND_SZ)
    {
        hr = E_FAIL;
        goto Error;
    }

    // Copy the org string to the dest, check to see if our string is already there
    memset( pwszStringDest, 0, dwDestSize );
    for( dwStrIndex = 0; 
         (dwStrIndex*sizeof(WCHAR) < dwOrgSize) && ((pwszStringOrg)[dwStrIndex] != '\0'); 
         dwStrIndex += wcslen( &((WCHAR*)pwszStringOrg)[dwStrIndex] ) +1 )
    {
        // Check this string in the [array] of strings
        if( wcscmp( &((WCHAR*)pwszStringOrg)[dwStrIndex], SERVICE_NAMEW ) == 0 )
        {
            hr = S_OK;      // String already added
            goto Error;
        }
        wcscpy( &pwszStringDest[dwStrIndex], &pwszStringOrg[dwStrIndex] );       
    }
    

    // Add this new string to the array of strings. Terminate the array with two '\0' chars
    wcscpy( &pwszStringDest[dwStrIndex], SERVICE_NAMEW );       
    dwStrIndex += wcslen( SERVICE_NAMEW ) + 1;          

    dwDestSize = (dwStrIndex +1)* sizeof(WCHAR);        // Add space for terminating extra '\0'

    lResult = RegSetValueExW(hKey,
                             SVCHOST_SUBKEYW,           // subkey name
                             NULL,
                             dwType,
                             (BYTE*)pwszStringDest,     // string buffer
                             dwDestSize );              // size of returned string

Error:
    if( pwszStringOrg )  delete [] pwszStringOrg;
    if( pwszStringDest ) delete [] pwszStringDest;
    if( hKey ) RegCloseKey(hKey);
    return hr;
}


// Stop and Uninstall the old .exe service
BOOL UnregisterOldServer( SC_HANDLE hSCM ) 
{
    char            szKey[256];
    BOOL            bRet = TRUE;
    SC_HANDLE       hServiceOld;
    SERVICE_STATUS  ss;

    if( !hSCM ) return FALSE;

    hServiceOld = OpenService( hSCM,
                               SERVICE_OLD_NAME,
                               SERVICE_ALL_ACCESS);

    // Could not find the old service
    if( !hServiceOld )
	{
	    bRet = FALSE;
		goto Error;
	}

    // stop the service
    bRet = ControlService(hServiceOld,
                          SERVICE_CONTROL_STOP,
                          &ss);

    // Delete the service
    if ( !::DeleteService(hServiceOld)) 
	{
        bRet = FALSE;
    } 

    // Delete old EventLog entry in registry
    strcpy(szKey, "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\");
    strcat(szKey, SERVICE_OLD_NAME);
    RegDeleteKey( HKEY_LOCAL_MACHINE, szKey );

Error:
    if(hServiceOld) CloseServiceHandle(hServiceOld);
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\setup\platsdk\makefile.inc ===
!ifdef NOLINK
makeset:
    rem

!else
makeset: buildsetup

buildsetup:
    @echo **** Running MAKESET to collect files for Setup ****
    cmd /x /c makeset 

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\key.h ===
extern BYTE g_abPriv[4096];
extern BYTE g_abAppCert[100];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\setup\pmsvdist\makefile.inc ===
!ifdef NOLINK
makeset:
    rem

!else
makeset: buildsetup

buildsetup:
    @echo **** Running MAKESET to collect files for Setup ****
    cmd /x /c makeset 

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\loghelp.h ===
#include "wmdmlog.h"

HRESULT hrLogString(LPSTR pszMessage, HRESULT hrSev);
HRESULT hrLogDWORD(LPSTR pszFormat, DWORD dwValue, HRESULT hrSev);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\setup\redist\makefile.inc ===
!ifdef NOLINK
makeset:
    rem

!else
makeset: buildsetup

buildsetup:
    @echo **** Running MAKESET to collect files for Setup ****
    cmd /x /c makeset 

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\device.h ===
// Device.h : Declaration of the CDevice

#ifndef __DEVICE_H_
#define __DEVICE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDevice
class ATL_NO_VTABLE CWMDMDevice : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CWMDMDevice, &CLSID_WMDMDevice>,
	public IWMDMDevice2,
    public IWMDMDeviceControl
{
public:
    CWMDMDevice();
    ~CWMDMDevice();

BEGIN_COM_MAP(CWMDMDevice)
	COM_INTERFACE_ENTRY(IWMDMDevice)
	COM_INTERFACE_ENTRY(IWMDMDevice2)
    COM_INTERFACE_ENTRY(IWMDMDeviceControl)
END_COM_MAP()


public:
//IWMDMDevice
	STDMETHOD(GetName)(LPWSTR pwszName,
	                   UINT nMaxChars);
    STDMETHOD(GetManufacturer)(LPWSTR pwszName,
                               UINT nMaxChars);
    STDMETHOD(GetVersion)(DWORD *pdwVersion);
    STDMETHOD(GetType)(DWORD *pdwType);
    STDMETHOD(GetSerialNumber)(PWMDMID pSerialNumber, BYTE abMac[WMDM_MAC_LENGTH]); 
    STDMETHOD(GetPowerSource)(DWORD *pdwPowerSource,
                             DWORD *pdwPercentRemaining);
    STDMETHOD(GetStatus)(DWORD *pdwStatus);
    STDMETHOD(GetDeviceIcon)(ULONG *hIcon);
    STDMETHOD(SendOpaqueCommand)(OPAQUECOMMAND *pCommand);

//IWMDMDevice2
	STDMETHOD(GetStorage)( LPCWSTR pszStorageName, IWMDMStorage** ppStorage );

    STDMETHOD(GetFormatSupport2)( DWORD dwFlags,
                                  _WAVEFORMATEX **ppAudioFormatEx,
                                  UINT *pnAudioFormatCount,
			                      _VIDEOINFOHEADER **ppVideoFormatEx,
                                  UINT *pnVideoFormatCount,
                                  WMFILECAPABILITIES **ppFileType,
                                  UINT *pnFileTypeCount);

    STDMETHOD(GetSpecifyPropertyPages)( ISpecifyPropertyPages** ppSpecifyPropPages, 
								        IUnknown*** pppUnknowns, 
								        ULONG* pcUnks );

    STDMETHOD(GetPnPName)( LPWSTR pwszPnPName, UINT nMaxChars );

//IWMDMDeviceControl
    STDMETHOD(GetCapabilities)(DWORD *pdwCapabilitiesMask);
    STDMETHOD(Play)();
    STDMETHOD(Record)(_WAVEFORMATEX *pFormat);
    STDMETHOD(Pause)();
    STDMETHOD(Resume)();
    STDMETHOD(Stop)();
    STDMETHOD(Seek)(UINT fuMode, int nOffset);
    STDMETHOD(EnumStorage)(IWMDMEnumStorage **ppEnumStorage);
    STDMETHOD(GetFormatSupport)(_WAVEFORMATEX **ppFormatEx,
                                UINT *pnFormatCount,
                                LPWSTR **pppwszMimeType,
                                UINT *pnMimeTypeCount);

    void SetContainedPointer(IMDSPDevice *pDevice, WORD wSPIndex);

private:
    IMDSPDevice *m_pDevice;
	WORD m_wSPIndex;
};

#endif //__DEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\device.cpp ===
// Device.cpp : Implementation of CDevice
#include "stdafx.h"
#include "mswmdm.h"
#include "Device.h"
#include "Storage.h"
#include "WMDMStorageEnum.h"
#include "loghelp.h"
#include "scserver.h"
#include "scclient.h"
#include "spinfo.h"
#define DISABLE_DRM_LOG
#include <drmerr.h>



/////////////////////////////////////////////////////////////////////////////
// CWMDMDevice

extern CSecureChannelServer *g_pAppSCServer;
extern CSPInfo **g_pSPs;


CWMDMDevice::CWMDMDevice() 
 : m_pDevice(NULL)
{
	GlobalAddRef();
}

CWMDMDevice::~CWMDMDevice()
{
	if (m_pDevice)
		m_pDevice->Release();

	GlobalRelease();
}


//IWMDMDevice Methods
HRESULT CWMDMDevice::GetName(LPWSTR pwszName,
	                         UINT nMaxChars)
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pDevice->GetName(pwszName, nMaxChars) );

Error:
    hrLogDWORD("IWMDMDevice::GetName returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDevice::GetManufacturer(LPWSTR pwszName,
                                     UINT nMaxChars)
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pDevice->GetManufacturer(pwszName, nMaxChars) );

Error:
    hrLogDWORD("IWMDMDevice::GetManufacturer returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDevice::GetVersion(DWORD *pdwVersion)
{  
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pDevice->GetVersion(pdwVersion) );

Error:
    hrLogDWORD("IWMDMDevice::GetVersion returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDevice::GetType(DWORD *pdwType)
{
    HRESULT hr;

	CARg (pdwType);

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pDevice->GetType(pdwType) );

#if 0
	//////////////////////////////////////////
	//RC1 Hack for non-reentrant devices
	//////////////////////////////////////////	
	WCHAR wszManufacturer[MAX_PATH];
	CORg(m_pDevice->GetManufacturer (wszManufacturer, MAX_PATH));

	if (wcsstr(_wcsupr(wszManufacturer), L"S3/DIAMOND MULTIMEDIA"))
	{
		*pdwType |= WMDM_DEVICE_TYPE_NONREENTRANT | WMDM_DEVICE_TYPE_FILELISTRESYNC;
	}
#endif
	//////////////////////////////////////////
    
Error:
    hrLogDWORD("IWMDMDevice::GetType returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDevice::GetSerialNumber(PWMDMID pSerialNumber, BYTE abMac[WMDM_MAC_LENGTH])
{
    HRESULT hr;
	HMAC hMAC;
	CSecureChannelClient *pSCClient;
	BYTE abTempMAC[WMDM_MAC_LENGTH];
	BYTE abMACVerify[WMDM_MAC_LENGTH];

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

	g_pSPs[m_wSPIndex]->GetSCClient(&pSCClient);
	if (!pSCClient)
	{
		CORg( E_FAIL );
	}

    CORg( m_pDevice->GetSerialNumber(pSerialNumber, abTempMAC) );

	// Verify the MAC from SP
	CORg( pSCClient->MACInit(&hMAC) );
	CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(pSerialNumber), sizeof(WMDMID)) );
	CORg( pSCClient->MACFinal(hMAC, abMACVerify) );

	if (memcmp(abMACVerify, abTempMAC, WMDM_MAC_LENGTH) != 0)
	{
		CORg( WMDM_E_MAC_CHECK_FAILED );
	}

	// Compute the MAC to send back to the application
	CORg( g_pAppSCServer->MACInit(&hMAC) );
	CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pSerialNumber), sizeof(WMDMID)) );
	CORg( g_pAppSCServer->MACFinal(hMAC, abMac) );

Error:
    hrLogDWORD("IWMDMDevice::GetSerialNumber returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDevice::GetPowerSource(DWORD *pdwPowerSource,
                                    DWORD *pdwPercentRemaining)
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pDevice->GetPowerSource(pdwPowerSource, pdwPercentRemaining) );

Error:
    hrLogDWORD("IWMDMDevice::GetPowerSource returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDevice::GetStatus(DWORD *pdwStatus)
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pDevice->GetStatus(pdwStatus) );

Error:
    hrLogDWORD("IWMDMDevice::GetStatus returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDevice::EnumStorage(IWMDMEnumStorage **ppEnumStorage)
{
    HRESULT hr;
    CComObject<CWMDMStorageEnum> *pEnumObj = NULL;
    IMDSPEnumStorage *pEnumStg = NULL;

    

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CARg( ppEnumStorage );

    CORg( m_pDevice->EnumStorage(&pEnumStg) );
    CORg( CComObject<CWMDMStorageEnum>::CreateInstance(&pEnumObj) );
    CORg( pEnumObj->QueryInterface(IID_IWMDMEnumStorage, reinterpret_cast<void**>(ppEnumStorage)) );
    if (FAILED(hr))
    {
        delete pEnumObj;
        pEnumObj = NULL;
        goto Error;
    }

    pEnumObj->SetContainedPointer(pEnumStg, m_wSPIndex);

Error:
    if(pEnumStg) 
        pEnumStg->Release();

    
    hrLogDWORD("IWMDMDevice::EnumStorage returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDevice::GetFormatSupport(_WAVEFORMATEX **ppFormatEx,
                                      UINT *pnFormatCount,
                                      LPWSTR **pppwszMimeType,
                                      UINT *pnMimeTypeCount)
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pDevice->GetFormatSupport(ppFormatEx, pnFormatCount, pppwszMimeType, pnMimeTypeCount) );

Error:
    hrLogDWORD("IWMDMDevice::GetFormatSupport returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDevice::GetDeviceIcon(ULONG *hIcon)
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pDevice->GetDeviceIcon(hIcon) );

Error:    
    hrLogDWORD("IWMDMDevice::GetDeviceIcon returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDevice::SendOpaqueCommand(OPAQUECOMMAND *pCommand)
{
    HRESULT hr;
	HMAC hMAC;
	CSecureChannelClient *pSCClient;
	BYTE abMACVerify[WMDM_MAC_LENGTH];

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

	if( (pCommand == NULL) || 
        ((pCommand->pData == NULL) && (pCommand->dwDataLen > 0)) )
	{
		CORg( E_INVALIDARG );
	}

	// Verify the MAC from APP
	CORg( g_pAppSCServer->MACInit(&hMAC) );
	CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(&(pCommand->guidCommand)), sizeof(GUID)) );
	CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(&(pCommand->dwDataLen)), sizeof(pCommand->dwDataLen)) );

    if (pCommand->pData)
	{
		CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pCommand->pData), pCommand->dwDataLen) );
	}
	CORg( g_pAppSCServer->MACFinal(hMAC, abMACVerify) );

	if (memcmp(abMACVerify, pCommand->abMAC, WMDM_MAC_LENGTH) != 0)
	{
		CORg( WMDM_E_MAC_CHECK_FAILED );
	}

	g_pSPs[m_wSPIndex]->GetSCClient(&pSCClient);
	if (!pSCClient)
	{
		CORg( E_FAIL );
	}

	// Compute the MAC to send back to the SP
	CORg( pSCClient->MACInit(&hMAC) );
	CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&(pCommand->guidCommand)), sizeof(GUID)) );
	CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&(pCommand->dwDataLen)), sizeof(pCommand->dwDataLen)) );

    if (pCommand->pData)
	{
		CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(pCommand->pData), pCommand->dwDataLen) );
	}
	CORg( pSCClient->MACFinal(hMAC, pCommand->abMAC) );


    // Pass the call down to the SP
    CORg( m_pDevice->SendOpaqueCommand(pCommand) );

	// Verify the MAC from SP
	CORg( pSCClient->MACInit(&hMAC) );
	CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&(pCommand->guidCommand)), sizeof(GUID)) );
	CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&(pCommand->dwDataLen)), sizeof(pCommand->dwDataLen)) );

	if (pCommand->pData)
	{
		CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(pCommand->pData), pCommand->dwDataLen) );
	}

	CORg( pSCClient->MACFinal(hMAC, abMACVerify) );

	if (memcmp(abMACVerify, pCommand->abMAC, WMDM_MAC_LENGTH) != 0)
	{
		CORg( WMDM_E_MAC_CHECK_FAILED );
	}

	// Compute the MAC to send back to the application
	CORg( g_pAppSCServer->MACInit(&hMAC) );
	CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(&(pCommand->guidCommand)), sizeof(GUID)) );
	CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(&(pCommand->dwDataLen)), sizeof(pCommand->dwDataLen)) );

	if (pCommand->pData)
	{
		CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pCommand->pData), pCommand->dwDataLen) );
	}
	CORg( g_pAppSCServer->MACFinal(hMAC, pCommand->abMAC) );

Error:    
    hrLogDWORD("IWMDMDevice::SendOpaqueCommand returned 0x%08lx", hr, hr);

    return hr;
}

// IWMDMDevice2
HRESULT CWMDMDevice::GetStorage( LPCWSTR pszStorageName, IWMDMStorage** ppStorage )
{
    HRESULT hr;
    IMDSPDevice2*   pDev2 = NULL;
    IMDSPStorage* pMDSPStorageFound = NULL;
    IMDSPStorage*   pMDSubStorage = NULL;
    CComObject<CWMDMStorage>* pStgObj = NULL;

    CARg( ppStorage );
    CARg( pszStorageName );

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    // Get the Storage pointer from the SP (as a IMDSPStorage)
    hr = m_pDevice->QueryInterface(IID_IMDSPDevice2, reinterpret_cast<void**>(&pDev2));
    if( SUCCEEDED(hr) )
    {
        hr = pDev2->GetStorage( pszStorageName, &pMDSPStorageFound );
    }

    // This functionalty is not implemented by the SP. Find the storage by enumerating all storages
    if( hr == E_NOTIMPL || hr == E_NOINTERFACE )
    {
    	IMDSPEnumStorage *pEnum = NULL;
        WCHAR   pswzMDSubStorageName[MAX_PATH];
        ULONG   ulFetched;

	    CORg(m_pDevice->EnumStorage(&pEnum));
        while( S_OK == pEnum->Next(1, &pMDSubStorage, &ulFetched) ) 
        {
            hr = pMDSubStorage->GetName( pswzMDSubStorageName, MAX_PATH );
            if( SUCCEEDED(hr) && ( _wcsicmp( pswzMDSubStorageName, pszStorageName ) == 0 ) )
            {
                // We have found the storage we are looking for.
                pMDSPStorageFound = pMDSubStorage;
                break;
            }
            pMDSubStorage->Release();
        }
        pEnum->Release();
    }

    // Create a IWMDMStorage object and connect it to the the storage from the SP
    if( pMDSPStorageFound != NULL ) 
    {
        CORg( CComObject<CWMDMStorage>::CreateInstance(&pStgObj) );
        CORg( pStgObj->QueryInterface(IID_IWMDMStorage, reinterpret_cast<void**>(ppStorage)) );

        pStgObj->SetContainedPointer(pMDSPStorageFound, m_wSPIndex);
    }
    // Did not find a matching storage
    else if( SUCCEEDED(hr) )
    {
        hr = S_FALSE;
    }

Error:
    if( pDev2 ) 
        pDev2->Release();

    if( hr != S_OK )
    {
        ppStorage = NULL;
        delete pStgObj;
    }

    hrLogDWORD("IWMDMDevice2::GetStorage returned 0x%08lx", hr, hr);

    return hr;
}



HRESULT CWMDMDevice::GetFormatSupport2( 
                        			DWORD dwFlags,
                                    _WAVEFORMATEX **ppAudioFormatEx,
                                    UINT *pnAudioFormatCount,
	                                _VIDEOINFOHEADER **ppVideoFormatEx,
                                    UINT *pnVideoFormatCount,
                                    WMFILECAPABILITIES **ppFileType,
                                    UINT *pnFileTypeCount)
{
    HRESULT hr = S_OK;
    IMDSPDevice2*   pDev2 = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pDevice->QueryInterface(IID_IMDSPDevice2, reinterpret_cast<void**>(&pDev2)) );
    CORg( pDev2->GetFormatSupport2( dwFlags,
                                    ppAudioFormatEx,
                                    pnAudioFormatCount,
	                                ppVideoFormatEx,
                                    pnVideoFormatCount,
                                    ppFileType,
                                    pnFileTypeCount) );
Error:
    if( pDev2 ) 
        pDev2->Release();

    hrLogDWORD("IWMDMDevice2::GetFormatSupport2 returned 0x%08lx", hr, hr);

    return hr;
}


HRESULT CWMDMDevice::GetSpecifyPropertyPages(
    ISpecifyPropertyPages** ppSpecifyPropPages, 
	IUnknown*** pppUnknowns, 
	ULONG* pcUnks )
{
    HRESULT hr = S_OK;
    IMDSPDevice2*   pDev2 = NULL;

    CARg( ppSpecifyPropPages );
    CARg( pppUnknowns );
    CARg( pcUnks );

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pDevice->QueryInterface(IID_IMDSPDevice2, reinterpret_cast<void**>(&pDev2)) );
    CORg( pDev2->GetSpecifyPropertyPages( ppSpecifyPropPages, pppUnknowns, pcUnks ) );

Error:    
    if( pDev2 ) 
        pDev2->Release();

    hrLogDWORD("IWMDMDevice2::GetSpecifyPropertyPages returned 0x%08lx", hr, hr);

    return hr;
}


HRESULT CWMDMDevice::GetPnPName( LPWSTR pwszPnPName, UINT nMaxChars )
{
    HRESULT hr = S_OK;
    IMDSPDevice2*   pDev2 = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pDevice->QueryInterface(IID_IMDSPDevice2, reinterpret_cast<void**>(&pDev2)) );
    CORg( pDev2->GetPnPName( pwszPnPName, nMaxChars ) );

Error:
    if( pDev2 ) 
    {
        pDev2->Release();
    }

    hrLogDWORD("IWMDMDevice2::GetPnPName returned 0x%08lx", hr, hr);

    return hr;
}


// IWMDMDeviceControl
HRESULT CWMDMDevice::GetCapabilities(DWORD *pdwCapabilitiesMask)
{
    HRESULT hr;
    IMDSPDeviceControl *pDevCtrl = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    if (!pdwCapabilitiesMask)
    {
        CORg( E_INVALIDARG );
    }

    CORg( m_pDevice->QueryInterface(IID_IMDSPDeviceControl, reinterpret_cast<void**>(&pDevCtrl)) );
    CORg( pDevCtrl->GetCapabilities(pdwCapabilitiesMask) );

Error:
    if (pDevCtrl)
        pDevCtrl->Release();

    hrLogDWORD("IWMDMDeviceControl::GetCapabilities returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDevice::Play()
{
    HRESULT hr;
    IMDSPDeviceControl *pDevCtrl = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pDevice->QueryInterface(IID_IMDSPDeviceControl, reinterpret_cast<void**>(&pDevCtrl)) );
    CORg( pDevCtrl->Play() );

Error:
    if (pDevCtrl)
        pDevCtrl->Release();

    hrLogDWORD("IWMDMDeviceControl::Play returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDevice::Record(_WAVEFORMATEX *pFormat)
{
    HRESULT hr;
    IMDSPDeviceControl *pDevCtrl = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    if (!pFormat)
    {
        CORg( E_INVALIDARG );
    }

    CORg( m_pDevice->QueryInterface(IID_IMDSPDeviceControl, reinterpret_cast<void**>(&pDevCtrl)) );
    CORg( pDevCtrl->Record(pFormat) );

Error:
    if (pDevCtrl)
        pDevCtrl->Release();

    hrLogDWORD("IWMDMDeviceControl::Record returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDevice::Pause()
{
    HRESULT hr;
    IMDSPDeviceControl *pDevCtrl = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pDevice->QueryInterface(IID_IMDSPDeviceControl, reinterpret_cast<void**>(&pDevCtrl)) );
    CORg( pDevCtrl->Pause() );

Error:
    if (pDevCtrl)
        pDevCtrl->Release();

    hrLogDWORD("IWMDMDeviceControl::Pause returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDevice::Resume()
{
    HRESULT hr;
    IMDSPDeviceControl *pDevCtrl = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pDevice->QueryInterface(IID_IMDSPDeviceControl, reinterpret_cast<void**>(&pDevCtrl)) );
    CORg( pDevCtrl->Resume() );
    
Error:
    if (pDevCtrl)
        pDevCtrl->Release();

    hrLogDWORD("IWMDMDeviceControl::Resume returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDevice::Stop()
{
    HRESULT hr;
    IMDSPDeviceControl *pDevCtrl = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pDevice->QueryInterface(IID_IMDSPDeviceControl, reinterpret_cast<void**>(&pDevCtrl)) );
    CORg( pDevCtrl->Stop() );
    
Error:
    if (pDevCtrl)
        pDevCtrl->Release();

    hrLogDWORD("IWMDMDeviceControl::Stop returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDevice::Seek(UINT fuMode, int nOffset)
{
    HRESULT hr;
    IMDSPDeviceControl *pDevCtrl = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pDevice->QueryInterface(IID_IMDSPDeviceControl, reinterpret_cast<void**>(&pDevCtrl)) );
    CORg( pDevCtrl->Seek(fuMode, nOffset) );

Error:
    if (pDevCtrl)
        pDevCtrl->Release();

    hrLogDWORD("IWMDMDeviceControl::Seek returned 0x%08lx", hr, hr);

    return hr;
}



void CWMDMDevice::SetContainedPointer(IMDSPDevice *pDevice, WORD wSPIndex)
{
    m_pDevice = pDevice;
    m_pDevice->AddRef();
	m_wSPIndex = wSPIndex;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\loghelp.cpp ===
#include "stdafx.h"
#include "loghelp.h"
#include <wmdmlog_i.c>

BOOL fIsLoggingEnabled( VOID )
{
    HRESULT hr;
    IWMDMLogger *pLogger = NULL;
    static BOOL fChecked = FALSE;
    static BOOL fEnabled = FALSE;

    if( !fChecked )
    {
        fChecked = TRUE;

        hr = CoCreateInstance(CLSID_WMDMLogger, NULL, CLSCTX_INPROC_SERVER, IID_IWMDMLogger, (void**)&pLogger);
        if (FAILED(hr))
        {
            goto exit;
        }

        hr = pLogger->IsEnabled(&fEnabled);
        if (FAILED(hr))
        {
            goto exit;
        }
    }

exit:

    if( NULL != pLogger )
    {
        pLogger->Release();
        pLogger = NULL;
    }

    return fEnabled;
}

HRESULT hrLogString(LPSTR pszMessage, HRESULT hrSev)
{
    HRESULT hr;
    IWMDMLogger *pLogger = NULL;
    DWORD dwFlags = ( FAILED(hrSev) ? WMDM_LOG_SEV_ERROR : WMDM_LOG_SEV_INFO );

    if( !fIsLoggingEnabled() )
    {
        return S_FALSE;
    }

    hr = CoCreateInstance(CLSID_WMDMLogger, NULL, CLSCTX_INPROC_SERVER, IID_IWMDMLogger, (void**)&pLogger);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = pLogger->LogString(dwFlags, "WMDM", pszMessage);
    if (FAILED(hr))
    {
        goto exit;
    }

exit:
    if (pLogger)
        pLogger->Release();
    return hr;
}

HRESULT hrLogDWORD(LPSTR pszFormat, DWORD dwValue, HRESULT hrSev)
{
    HRESULT hr;
    IWMDMLogger *pLogger = NULL;
    DWORD dwFlags = ( FAILED(hrSev) ? WMDM_LOG_SEV_ERROR : WMDM_LOG_SEV_INFO );

    if( !fIsLoggingEnabled() )
    {
        return S_FALSE;
    }

    hr = CoCreateInstance(CLSID_WMDMLogger, NULL, CLSCTX_INPROC_SERVER, IID_IWMDMLogger, (void**)&pLogger);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = pLogger->LogDword(dwFlags, "WMDM", pszFormat, dwValue);
    if (FAILED(hr))
    {
        goto exit;
    }

exit:
    if (pLogger)
        pLogger->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\key.cpp ===
#include "wtypes.h"
BYTE g_abPriv[4096] = {
	0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 
	0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 
	0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 
	0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 
	0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 
	0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 
	0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 
	0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 
	0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 
	0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 
	0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 
	0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 
	0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 
	0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 
	0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 
	0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 
	0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 
	0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 
	0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 
	0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 
	0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 
	0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 
	0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 
	0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 
	0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 
	0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 
	0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 
	0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 
	0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 
	0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 
	0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 
	0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 
	0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 
	0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 
	0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 
	0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 
	0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 
	0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 
	0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 
	0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 
	0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 
	0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 
	0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 
	0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 
	0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 
	0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 
	0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 
	0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 
	0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 
	0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 
	0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 
	0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 
	0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 
	0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 
	0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 
	0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 
	0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 
	0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 
	0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 
	0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 
	0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 
	0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 
	0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 
	0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 
	0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 
	0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 
	0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 
	0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 
	0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 
	0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 
	0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 
	0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 
	0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 
	0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 
	0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 
	0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 
	0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 
	0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 
	0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 
	0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 
	0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 
	0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 
	0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 
	0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 
	0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 
	0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 
	0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 
	0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 
	0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 
	0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 
	0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 
	0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 
	0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 
	0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 
	0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 
	0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 
	0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 
	0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 
	0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 
	0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 
	0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 
	0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 
	0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 
	0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 
	0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 
	0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 
	0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 
	0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 
	0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 
	0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 
	0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 
	0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 
	0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 
	0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 
	0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 
	0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 
	0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 
	0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 
	0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 
	0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x72, 
	0x22, 0xA9, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 
	0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 
	0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 
	0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 
	0xF0, 0x7A, 0x98, 0x51, 0x49, 0x34, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x14, 
	0x48, 0x83, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x26, 0x2D, 0x75, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x56, 0x3E, 0xB1, 0x07, 0x9C, 0x17, 0x3E, 
	0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 0x48, 
	0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 0x19, 
	0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 
	0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 0x04, 
	0xB0, 0x03, 0x59, 0x4E, 0x26, 0x6F, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0x64, 
	0xFA, 0xCA, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 0x05, 
	0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 0xFA, 
	0x45, 0xCF, 0x96, 0xD3, 0x22, 0x81, 0x94, 0x61, 
	0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 0xE7, 
	0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 0x2E, 
	0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 0x0A, 
	0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 0xDC, 
	0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 0x27, 
	0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 0x8D, 
	0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 0xBC, 
	0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 
	0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 
	0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 0x66, 
	0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 0x4E, 
	0x37, 0x65, 0x62, 0xDE, 0x60, 0xAA, 0xFB, 0x61, 
	0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 0x91, 0x57, 
	0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 0x3E, 0x7D, 
	0x58, 0x4C, 0xDD, 0x3A, 0x05, 0x5C, 0x8B, 0x49, 
	0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 0xE5, 
	0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 0x61, 
	0x48, 0x54, 0x8F, 0x05, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x02, 0xBE, 0xF4, 0xD6, 0xA3, 0xFE, 
	0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 0xFF, 
	0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 0xD5, 
	0xC3, 0xDC, 0x22, 0x1A, 0x0A, 0xE5, 0xCF, 0xD8, 
	0x5F, 0x76, 0x62, 0xE3, 0xC1, 0x7D, 0xB5, 0xFA, 
	0x66, 0x7C, 0x5E, 0xB8, 0x85, 0x43, 0x70, 0x90, 
	0x4E, 0x0D, 0x37, 0x7B, 0x62, 0xDE, 0x60, 0xAA, 
	0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 0x49, 0x0B, 
	0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 0x9C, 0x17, 
	0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 0x5C, 0x8B, 
	0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 0xA7, 0x75, 
	0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 0x81, 0xEA, 
	0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 0x7B, 0xC8, 
	0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 0x7B, 0xE8, 
	0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 0xA5, 0xEA, 
	0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 0x15, 0x78, 
	0xDC, 0xD1, 0x9F, 0xCD, 0x58, 0xAC, 0x29, 0x01, 
	0x27, 0x24, 0x5E, 0x02, 0x22, 0xF4, 0xD6, 0xA3, 
	0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 0x45, 0x99, 
	0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 0xC4, 0xC5, 
	0xD5, 0x7D, 0xC3, 0x33, 0x22, 0x1A, 0x0A, 0xE5, 
	0x57, 0xCF, 0x0F, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x1A, 0x5D, 
	0x66, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 
	0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 
	0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 
	0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 
	0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 0xD3, 
	0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 0xEB, 
	0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 0xBF, 
	0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 0x2D, 
	0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 0x26, 
	0x15, 0x78, 0xDC, 0xD1, 0x9F, 0x07, 0xCD, 0x08, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x65, 
	0x0A, 0x1A, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 
	0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 
	0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 
	0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 
	0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 
	0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 
	0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 
	0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 
	0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0x74, 0xDC, 0xEE, 0x1A, 
	0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 
	0xC1, 0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 
	0x85, 0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 
	0xDE, 0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 
	0x98, 0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 
	0x07, 0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 
	0x05, 0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 
	0x8E, 0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x96, 
	0xD3, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0xF4, 
	0xD6, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 0xEE, 
	0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 0x9E, 
	0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 0x0A, 
	0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 0xC1, 
	0x7D, 0xB5, 0xFA, 0x66, 0x7C, 0x5E, 0xB8, 0x85, 
	0x43, 0x70, 0x90, 0x4E, 0x37, 0x65, 0x62, 0xDE, 
	0x60, 0xAA, 0xFB, 0x61, 0x4D, 0xF0, 0x7A, 0x98, 
	0x49, 0x0B, 0x91, 0x57, 0xC8, 0x3E, 0x5D, 0x07, 
	0x9C, 0x17, 0x3E, 0x7D, 0x4C, 0x63, 0x3A, 0x05, 
	0x5C, 0x8B, 0x49, 0x05, 0xCA, 0xEA, 0x4C, 0x8E, 
	0xA7, 0x75, 0xE5, 0xFA, 0x45, 0xCF, 0x70, 0x96, 
	0xCC, 0x81, 0xEA, 0x61, 0x48, 0x8F, 0x3E, 0x45, 
	0xEB, 0x7B, 0xC8, 0xE7, 0x19, 0x8D, 0xFA, 0x55, 
	0xBF, 0x7B, 0xE8, 0x2E, 0xDE, 0xB2, 0xBF, 0xD1, 
	0x2D, 0xA5, 0xEA, 0x0A, 0x04, 0xB0, 0x03, 0x59, 
	0x26, 0x15, 0x78, 0xDC, 0xD1, 0x9F, 0xCD, 0x58, 
	0xAC, 0x29, 0x01, 0x27, 0x24, 0x02, 0xBE, 0x2F, 
	0xF4, 0x14, 0xA3, 0xFE, 0x8D, 0xEF, 0xC8, 0x47, 
	0xEE, 0x45, 0x99, 0xFF, 0xBC, 0x27, 0xA1, 0xB9, 
	0x9E, 0xC4, 0xC5, 0xD5, 0xC3, 0xDC, 0x22, 0x1A, 
	0x0A, 0xE5, 0xCF, 0xD8, 0x5F, 0x76, 0x62, 0xE3, 
	0xC1, 0x7D, 0xB5, 0x95, 0x32, 0x86, 0x72, 0x41, 
	0x37, 0xC8, 0xCB, 0x9D, 0x31, 0xBE, 0x6C, 0xF7, 
	0xB1, 0xCA, 0x62, 0x6B, 0x39, 0x3D, 0xF1, 0xA4, 
	0x06, 0x1F, 0x2E, 0xC2, 0xCF, 0x96, 0xD5, 0x7F, 
	0xEC, 0x5F, 0x4A, 0x8D, 0xDB, 0x0F, 0x60, 0x8B, 
	0x1A, 0x36, 0xB8, 0x74, 0x54, 0xF1, 0x47, 0x96, 
	0x04, 0xB5, 0xCB, 0xC7, 0x08, 0x5F, 0x55, 0xB5, 
	0x84, 0x75, 0xA3, 0x70, 0x4E, 0xC2, 0xA7, 0x8A, 
	0x9D, 0x7F, 0x6F, 0x0F, 0x9C, 0xE7, 0x09, 0x9F, 
	0xE1, 0xAA, 0x61, 0x94, 0xAB, 0xA6, 0xE8, 0xA5, 
	0xD0, 0x23, 0x7A, 0x46, 0xCF, 0xFD, 0x6E, 0x40, 
	0xD0, 0x2D, 0xA3, 0xEC, 0x9F, 0x71, 0xE5, 0x2D, 
	0x79, 0x7E, 0xC9, 0xB3, 0xE8, 0xAB, 0x97, 0xF9, 
	0x26, 0x87, 0x39, 0xAF, 0x19, 0x12, 0xA8, 0x44, 
	0xB1, 0xB4, 0xAB, 0x82, 0x41, 0xA5, 0xBE, 0x35, 
	0xFC, 0x63, 0x1A, 0x25, 0xC9, 0x5E, 0x09, 0x00, 
	0x4E, 0x2F, 0xA2, 0x88, 0xD1, 0x15, 0x89, 0xC9, 
	0x52, 0x7D, 0x89, 0x27, 0xF3, 0xCE, 0x0F, 0xC1, 
	0xF6, 0x3C, 0x3D, 0xC0, 0xD7, 0x5B, 0xAD, 0x8E, 
	0x35, 0xB4, 0x12, 0x1B, 0x02, 0x20, 0xF7, 0x60, 
	0xE6, 0xBE, 0x82, 0xAE, 0x9E, 0xBE, 0xFE, 0xFF, 
	0xB2, 0x99, 0x2C, 0x90, 0x03, 0xCD, 0x00, 0x14
};
BYTE g_abAppCert[100] = {
	0x00, 0x01, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
	0x17, 0x9C, 0x96, 0x1A, 0x2C, 0x83, 0xD2, 0x1D, 
	0x6A, 0x43, 0xDF, 0x41, 0x84, 0x3D, 0x53, 0xD1, 
	0xCF, 0x01, 0xCA, 0x30, 0x2C, 0xBC, 0x52, 0x0A, 
	0xD4, 0x09, 0x1D, 0x2F, 0x87, 0x69, 0x3B, 0x34, 
	0xA1, 0xC3, 0xF9, 0xDF, 0xB9, 0xA3, 0xE9, 0x08, 
	0xB4, 0xD1, 0x36, 0x4A, 0x23, 0x6B, 0x9D, 0xE0, 
	0x9D, 0xAE, 0xAF, 0x57, 0xDF, 0xB4, 0x2D, 0x24, 
	0xD2, 0x66, 0x5E, 0x2D, 0x3D, 0xB7, 0x8E, 0xAA, 
	0x43, 0xCC, 0xBE, 0xF9, 0xA6, 0x19, 0xDA, 0x21, 
	0xC5, 0xE0, 0xC5, 0x5C, 0x4C, 0x6A, 0x3E, 0x25, 
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x07, 0xD0, 
	0x00, 0x00, 0x00, 0x03
};
//=======================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mswmdm.rc
//
#define IDS_PROJNAME                    100
#define IDR_MEDIADEVMGR                 101
#define IDR_WMDMDEVICEENUM              105

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\scpinfo.cpp ===
#include "stdafx.h"
#include "mswmdm.h"
#include "loghelp.h"
#include "scpinfo.h"
// We don't want to dll's using our lib to link to drmutil2.lib. 
// So disable DRM logging.
#define DISABLE_DRM_LOG
#include "drmerr.h"
#include "key.h"
#include "wmsstd.h"

#define MIN_SCP_APPSEC  1000

CSCPInfo::CSCPInfo() : m_pSCP(NULL), m_pSCClient(NULL)
{
	m_pSCClient = new CSecureChannelClient();
}

CSCPInfo::~CSCPInfo()
{
	SAFE_DELETE(m_pSCClient);
    SAFE_RELEASE(m_pSCP);
}

HRESULT CSCPInfo::hrInitialize(LPWSTR pwszProgID)
{
    HRESULT hr;
    CLSID clsid;
	IComponentAuthenticate *pAuth = NULL;
    DWORD dwLocalAppSec = 0;
    DWORD dwRemoteAppSec = 0;

	if (!m_pSCClient)
	{
		hr = E_FAIL;
		goto Error;
	}

	CORg( m_pSCClient->SetCertificate(SAC_CERT_V1, (BYTE*)g_abAppCert, sizeof(g_abAppCert), (BYTE*)g_abPriv, sizeof(g_abPriv)) );
    CORg( CLSIDFromProgID(pwszProgID, &clsid) );
    CORg( CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IComponentAuthenticate, (void**)&pAuth) );
	
    m_pSCClient->SetInterface(pAuth);
    CORg( m_pSCClient->Authenticate(SAC_PROTOCOL_V1) );
    CORg( m_pSCClient->GetAppSec( &dwLocalAppSec, &dwRemoteAppSec ) );

    // Only use SCP if appsec >= 1000
    if( dwRemoteAppSec < MIN_SCP_APPSEC )
    {
        hrLogString( "Ignoring SCP with AppSec < 1000", S_FALSE );
        hr = E_FAIL;
        goto Error;
    }

	CORg( pAuth->QueryInterface(IID_ISCPSecureAuthenticate, (void**)&m_pSCP) );
     
Error:
    if (pAuth)
		pAuth->Release();

    hrLogDWORD("CSCPInfo::hrInitialize returned 0x%08lx", hr, hr);
    
    return hr;
}

HRESULT CSCPInfo::hrGetInterface(ISCPSecureAuthenticate **ppSCP)
{
    m_pSCP->AddRef();
    
    *ppSCP = m_pSCP;

    return S_OK;
}

void CSCPInfo::GetSCClient(CSecureChannelClient **ppSCClient)
{
	*ppSCClient = m_pSCClient;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\mediadevmgr.h ===
// MediaDevMgr.h : Declaration of the CMediaDevMgr

#ifndef __MEDIADEVMGR_H_
#define __MEDIADEVMGR_H_

#include "resource.h"       // main symbols
#include "spinfo.h"
#include "scpinfo.h"

/////////////////////////////////////////////////////////////////////////////
// CMediaDevMgrClassFactory
class ATL_NO_VTABLE CMediaDevMgrClassFactory : 
public CComObjectRootEx<CComMultiThreadModel>,
public IClassFactory
{
public:
	BEGIN_COM_MAP(CMediaDevMgrClassFactory)
		COM_INTERFACE_ENTRY(IClassFactory)
	END_COM_MAP()

	//
	// IClassFactory
	//

	STDMETHOD(CreateInstance)(IUnknown * pUnkOuter, REFIID riid, void ** ppvObject);
	STDMETHOD(LockServer)(BOOL fLock);
};

typedef CComObject<CMediaDevMgrClassFactory> CComMediaDevMgrClassFactory;


/////////////////////////////////////////////////////////////////////////////
// CMediaDevMgr
class ATL_NO_VTABLE CMediaDevMgr : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMediaDevMgr, &CLSID_MediaDevMgr>,
	public IWMDeviceManager,
    public IComponentAuthenticate
{
public:
    CMediaDevMgr();
    ~CMediaDevMgr();


DECLARE_REGISTRY_RESOURCEID(IDR_MEDIADEVMGR)


BEGIN_COM_MAP(CMediaDevMgr)
	COM_INTERFACE_ENTRY(IWMDeviceManager)
    COM_INTERFACE_ENTRY(IComponentAuthenticate)
END_COM_MAP()

public:
    // The SCP's are loaded on first use.
    static HRESULT LoadSCPs();

    // IWMDeviceManager Methods
    STDMETHOD(GetRevision)(DWORD *pdwRevision);
	STDMETHOD(GetDeviceCount)(DWORD *pdwCount);
    STDMETHOD(EnumDevices)(IWMDMEnumDevice **ppEnumDevice);
    STDMETHOD(SACAuth)(DWORD dwProtocolID,
                       DWORD dwPass,
                       BYTE *pbDataIn,
                       DWORD dwDataInLen,
                       BYTE **ppbDataOut,
                       DWORD *pdwDataOutLen);
    STDMETHOD(SACGetProtocols)(DWORD **ppdwProtocols,
                               DWORD *pdwProtocolCount);

    // IWMDeviceManager2 Methods
	STDMETHOD(GetDeviceFromPnPName)( LPCWSTR pwszPnPName, IWMDMDevice** ppDevice );

private:
    HRESULT hrLoadSPs();
	static HRESULT hrLoadSCPs();

};

#endif //__MEDIADEVMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\scpinfo.h ===
#ifndef __SCPINFO_H_
#define __SCPINFO_H_

#include "scclient.h"

class CSCPInfo
{
public:
    CSCPInfo();
    ~CSCPInfo();

    HRESULT hrInitialize(LPWSTR pwszProgID);
    HRESULT hrGetInterface(ISCPSecureAuthenticate **ppSCP);
	void GetSCClient(CSecureChannelClient **ppSCClient);
private:
    ISCPSecureAuthenticate *m_pSCP;
	CSecureChannelClient *m_pSCClient;
};

#endif __SPINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\mediadevmgr.cpp ===
// MediaDevMgr.cpp : Implementation of CMediaDevMgr
#include "stdafx.h"
#include "mswmdm.h"
#include "loghelp.h"
#include "MediaDevMgr.h"
#include "WMDMDeviceEnum.h"
#include "SCServer.h"
#include "key.h"

#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

#define SDK_VERSION 0x00080000
#define WMDM_REG_LOCATION _T("Software\\Microsoft\\Windows Media Device Manager")
#define MDSP_REG_LOCATION _T("Software\\Microsoft\\Windows Media Device Manager\\Plugins\\SP")
#define MDSCP_REG_LOCATION _T("Software\\Microsoft\\Windows Media Device Manager\\Plugins\\SCP")
#define MSSCP_PROGID L"MsScp.MSSCP.1"
#define MSSCP_KEYNAME _T("MSSCP")
/////////////////////////////////////////////////////////////////////////////
// CMediaDevMgr


CSPInfo **g_pSPs = NULL;
WORD g_wSPCount = 0;

CSCPInfo **g_pSCPs = NULL;
WORD g_wSCPCount = 0;

int g_nGlobalRefCount = 0;
CComAutoCriticalSection csGlobal;

CSecureChannelServer *g_pAppSCServer = NULL;

//
// This method is called by objects accessing the global SP, SCP arrays.
// These objects will need to call GlobalAddRef, GlobalRelease so that we
// know when we can unload the plugins.
// 
void GlobalAddRef()
{
	csGlobal.Lock();
	g_nGlobalRefCount ++;
	csGlobal.Unlock();
}

void GlobalRelease()
{
	csGlobal.Lock();
	g_nGlobalRefCount --;

	// Check if we can unload SP's, SCP's
	if( g_nGlobalRefCount == 0 )
	{
		int iIndex;

		if( g_pSPs )
		{
			for(iIndex=0;iIndex<g_wSPCount;iIndex++)
				delete g_pSPs[iIndex];
			delete g_pSPs;
			g_pSPs = NULL;
			g_wSPCount = 0;
		}
		if( g_pSCPs )
		{
			for(iIndex=0;iIndex<g_wSCPCount;iIndex++)
				delete g_pSCPs[iIndex];
			delete g_pSCPs;
			g_pSCPs = NULL;
			g_wSCPCount = 0;
		}
		if( g_pAppSCServer )
		{
			delete g_pAppSCServer;
			g_pAppSCServer = NULL;
		}
	}
	csGlobal.Unlock();
}


CMediaDevMgr::CMediaDevMgr()
{
	// Add a refcount to SPs, SCPs
	GlobalAddRef();

    g_pAppSCServer = new CSecureChannelServer();
    if (g_pAppSCServer)
    {
		g_pAppSCServer->SetCertificate(SAC_CERT_V1, (BYTE*)g_abAppCert, sizeof(g_abAppCert), (BYTE*)g_abPriv, sizeof(g_abPriv));    
	}

	// Do we need to load SP's?
	csGlobal.Lock();
	if( g_pSPs == NULL )
	{
	    hrLoadSPs();
	}
	csGlobal.Unlock();
}

CMediaDevMgr::~CMediaDevMgr()
{
	// Decrease refcount to SPs, SCPs
	GlobalRelease();
}

// Static helper function. The SCP's are loaded on first use for pref.
HRESULT CMediaDevMgr::LoadSCPs()
{
    HRESULT hr = S_OK;

	csGlobal.Lock();
	if(g_pSCPs == NULL)
	{
		hr = hrLoadSCPs();
	}
	csGlobal.Unlock();

    return hr;
}

HRESULT CMediaDevMgr::hrLoadSPs()
{
    USES_CONVERSION;
    HRESULT hr;
    HKEY hKey = NULL;
    HKEY hSubKey = NULL;
    LONG lRetVal;
    LONG lRetVal2;
    DWORD dwSubKeys;
    DWORD dwMaxNameLen;
    WORD wIndex = 0;
    LPTSTR ptszKeyName = NULL;
    DWORD dwKeyNameLen;
    DWORD dwType;
    BYTE pbData[512];
    DWORD dwDataLen = 512;
    char szMessage[512+64];

    lRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, MDSP_REG_LOCATION, 0, KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, &hKey);
    if (lRetVal != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lRetVal);
        goto exit;
    }

    // Get the count of Sub-Keys under SP
    lRetVal = RegQueryInfoKey(hKey, NULL, NULL, NULL, &dwSubKeys, &dwMaxNameLen, NULL, NULL, NULL, NULL, NULL, NULL);
    if (lRetVal != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lRetVal);
        goto exit;
    }

    dwMaxNameLen++;
    // Allocate a buffer to hold the subkey names
    ptszKeyName = new TCHAR[dwMaxNameLen];
    if (!ptszKeyName)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Allocate the array of CSPInfo *'s
    g_pSPs = new CSPInfo *[dwSubKeys];
    if (!g_pSPs)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Loop through the sub-keys initializing a CSPInfo for each sub key
    lRetVal = ERROR_SUCCESS;
    while (lRetVal != ERROR_NO_MORE_ITEMS)
    {
        dwKeyNameLen = dwMaxNameLen;
        lRetVal = RegEnumKeyEx(hKey, wIndex, ptszKeyName, &dwKeyNameLen, NULL, NULL, NULL, NULL);
        if (lRetVal == ERROR_SUCCESS)
        {
            lRetVal2 = RegOpenKeyEx(hKey, ptszKeyName, NULL, KEY_QUERY_VALUE, &hSubKey);
            if (lRetVal2 != ERROR_SUCCESS)
            {
                hr = HRESULT_FROM_WIN32(lRetVal2);
                goto exit;
            }

            g_pSPs[g_wSPCount] = new CSPInfo;
            if (!g_pSPs[g_wSPCount])
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            dwDataLen = sizeof(pbData);
            lRetVal2 = RegQueryValueEx(hSubKey, _T("ProgID"), NULL, &dwType, pbData, &dwDataLen);
            if (lRetVal2 != ERROR_SUCCESS)
            {
                hr = HRESULT_FROM_WIN32(lRetVal2);                
                goto exit;
            }


            strcpy(szMessage, "Loading SP ProgID = ");
	    hr = StringCbCat(szMessage, sizeof(szMessage), (LPTSTR)pbData);
	    if(SUCCEEDED(hr) )
	    {
		hrLogString(szMessage, S_OK);
	    }

            
            hr = g_pSPs[g_wSPCount]->hrInitialize(T2W((LPTSTR)pbData));
            if (FAILED(hr))
            {
                // If this SP didn't initialize then we just try the next one.
                delete g_pSPs[g_wSPCount];
            }
            else
            {
                // We have added the CSPInfo to the array no inc the counter
                g_wSPCount++;
            }
           
            RegCloseKey(hSubKey);
            hSubKey = NULL;
            wIndex++;
        }
        else if (lRetVal != ERROR_NO_MORE_ITEMS)
        {
            hr = HRESULT_FROM_WIN32(lRetVal);
            goto exit;
        }
    }
    
    hr = S_OK;
exit:
    if (hKey)
        RegCloseKey(hKey);
    if (hSubKey)
        RegCloseKey(hSubKey);
    if (ptszKeyName)
        delete [] ptszKeyName;

    hrLogDWORD("CMediaDevMgr::hrLoadSPs returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CMediaDevMgr::hrLoadSCPs()
{
    USES_CONVERSION;
    HRESULT hr;
    HKEY hKey = NULL;
    HKEY hSubKey = NULL;
    LONG lRetVal;
    LONG lRetVal2;
    DWORD dwSubKeys;
    DWORD dwMaxNameLen;
	WORD wIndex = 0;
    LPTSTR ptszKeyName = NULL;
    DWORD dwKeyNameLen;
    DWORD dwType;
    BYTE pbData[512];
    DWORD dwDataLen = 512;
    char szMessage[512];

    lRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, MDSCP_REG_LOCATION, 0, KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, &hKey);
    if (lRetVal != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lRetVal);
        goto exit;
    }

    // Get the count of Sub-Keys under SP
    lRetVal = RegQueryInfoKey(hKey, NULL, NULL, NULL, &dwSubKeys, &dwMaxNameLen, NULL, NULL, NULL, NULL, NULL, NULL);
    if (lRetVal != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lRetVal);
        goto exit;
    }

    dwMaxNameLen++;
    // Allocate a buffer to hold the subkey names
    ptszKeyName = new TCHAR[dwMaxNameLen];
    if (!ptszKeyName)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Allocate the array of CSPInfo *'s
	// Add one for our SCP in case someone deleted the reg key
    g_pSCPs = new CSCPInfo *[dwSubKeys + 1];
    if (!g_pSCPs)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

	// WARNING: 
	//   We are hard coding the loading of the MSSCP as
	//   the first SCP in the system. This will always load
	//   as the first SCP in the array so that our SCP
	//   will always get first dibs on WMA content
    g_pSCPs[g_wSCPCount] = new CSCPInfo;
    if (!g_pSCPs[g_wSCPCount])
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    strcpy(szMessage, "Loading MSSCP");
    hrLogString(szMessage, S_OK);

    hr = g_pSCPs[g_wSCPCount]->hrInitialize(MSSCP_PROGID);
    if (FAILED(hr))
    {
        // If this SCP didn't initialize then we just try the next one.
        delete g_pSCPs[g_wSCPCount];
    }
    else
    {
        // We have added the CSPInfo to the array no inc the counter
        g_wSCPCount++;
    }

    // Loop through the sub-keys initializing a CSPInfo for each sub key
    lRetVal = ERROR_SUCCESS;
    while (lRetVal != ERROR_NO_MORE_ITEMS)
    {
        dwKeyNameLen = dwMaxNameLen;
        lRetVal = RegEnumKeyEx(hKey, wIndex, ptszKeyName, &dwKeyNameLen, NULL, NULL, NULL, NULL);
        if (lRetVal == ERROR_SUCCESS)
        {
            lRetVal2 = RegOpenKeyEx(hKey, ptszKeyName, NULL, KEY_QUERY_VALUE, &hSubKey);
            if (lRetVal2 != ERROR_SUCCESS)
            {
                hr = HRESULT_FROM_WIN32(lRetVal2);
                goto exit;
            }

			// If this is the MSSCP then skip it because we already loaded it.
			if (_tcscmp(MSSCP_KEYNAME, ptszKeyName) == 0)
			{
				wIndex++;
				continue;
			}

            g_pSCPs[g_wSCPCount] = new CSCPInfo;
            if (!g_pSCPs[g_wSCPCount])
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            dwDataLen = sizeof(pbData);
            lRetVal2 = RegQueryValueEx(hSubKey, _T("ProgID"), NULL, &dwType, pbData, &dwDataLen);
            if (lRetVal2 != ERROR_SUCCESS)
            {
                hr = HRESULT_FROM_WIN32(lRetVal2);                
                goto exit;
            }

            strcpy(szMessage, "Loading SCP ProgID = ");
	    hr = StringCbCat(szMessage, sizeof(szMessage), (LPTSTR)pbData);
	    if(SUCCEEDED(hr))
	    {
		hrLogString(szMessage, S_OK);
	    }


            hr = g_pSCPs[g_wSCPCount]->hrInitialize(T2W((LPTSTR)pbData));
            if (FAILED(hr))
            {
                // If this SCP didn't initialize then we just try the next one.
                delete g_pSCPs[g_wSCPCount];
            }
            else
            {
                // We have added the CSPInfo to the array no inc the counter
                g_wSCPCount++;
            }

            RegCloseKey(hSubKey);
            hSubKey = NULL;
            wIndex++;
        }
        else if (lRetVal != ERROR_NO_MORE_ITEMS)
        {
            hr = HRESULT_FROM_WIN32(lRetVal);
            goto exit;
        }
    }
    
    hr = S_OK;
exit:
    if (hKey)
        RegCloseKey(hKey);
    if (hSubKey)
        RegCloseKey(hSubKey);
    if (ptszKeyName)
        delete [] ptszKeyName;

    hrLogDWORD("CMediaDevMgr::hrLoadSCPs returned 0x%08lx", hr, hr);

    return hr;
}

// IWMDeviceManager Methods
HRESULT CMediaDevMgr::GetRevision(DWORD *pdwRevision)
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    if (!pdwRevision)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    *pdwRevision = SDK_VERSION;

    hr = S_OK;

exit:

    hrLogDWORD("IWMDeviceManager::GetRevision returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CMediaDevMgr::GetDeviceCount(DWORD *pdwCount)
{
    HRESULT hr;
    DWORD dwTotalDevCount = 0;
    DWORD dwDevCount;
    IMDServiceProvider *pProv = NULL;
    WORD x;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    if (!pdwCount)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    for (x=0;x<g_wSPCount;x++)
    {
        hr = g_pSPs[x]->hrGetInterface(&pProv);
        if (FAILED(hr))
        {
            goto exit;
        }
        hr = pProv->GetDeviceCount(&dwDevCount);
        if (FAILED(hr))
        {
            goto exit;
        }

        dwTotalDevCount += dwDevCount;
        pProv->Release();
        pProv = NULL;
    }

    *pdwCount = dwTotalDevCount;
    hr = S_OK;
exit:
    if (pProv)
        pProv->Release();

    hrLogDWORD("IWMDeviceManager::GetDeviceCount returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CMediaDevMgr::EnumDevices(IWMDMEnumDevice **ppEnumDevice)
{
    HRESULT hr;
    CComObject<CWMDMDeviceEnum> *pEnumObj;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    if (!ppEnumDevice)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    hr = CComObject<CWMDMDeviceEnum>::CreateInstance(&pEnumObj);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = pEnumObj->QueryInterface(IID_IWMDMEnumDevice, reinterpret_cast<void**>(ppEnumDevice));
    if (FAILED(hr))
    {
        delete pEnumObj;
        goto exit;
    }

exit:
    
    hrLogDWORD("IWMDeviceManager::EnumDevices returned 0x%08lx", hr, hr);

    return hr;
}

// IWMDeviceManager2 Methods
HRESULT CMediaDevMgr::GetDeviceFromPnPName( LPCWSTR pwszPnPName, IWMDMDevice** ppDevice )
{
    return E_NOTIMPL;
}


HRESULT CMediaDevMgr::SACAuth(DWORD dwProtocolID,
                              DWORD dwPass,
                              BYTE *pbDataIn,
                              DWORD dwDataInLen,
                              BYTE **ppbDataOut,
                              DWORD *pdwDataOutLen)
{
    HRESULT hr;

    if (g_pAppSCServer)
        hr = g_pAppSCServer->SACAuth(dwProtocolID, dwPass, pbDataIn, dwDataInLen, ppbDataOut, pdwDataOutLen);
    else
        hr = E_FAIL;
    
    hrLogDWORD("IComponentAuthenticate::SACAuth returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CMediaDevMgr::SACGetProtocols(DWORD **ppdwProtocols,
                                      DWORD *pdwProtocolCount)
{
    HRESULT hr;

    if (g_pAppSCServer)
        hr = g_pAppSCServer->SACGetProtocols(ppdwProtocols, pdwProtocolCount);
    else
        hr = E_FAIL;

    hrLogDWORD("IComponentAuthenticate::SACGetProtocols returned 0x%08lx", hr, hr);

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CMediaDevMgrClassFactory -
//
// Purpose : THis is used so that the Shell team can use WMDM in the "Both"
// threading model while WMP uses us via the Free threading model.  This
// class factory implementation simply delagates and uses the old class factory
// of MediaDevMgr ONLY IF the new CLSID was used to CoCreate WMDM.
//

STDMETHODIMP CMediaDevMgrClassFactory::CreateInstance(IUnknown * pUnkOuter, REFIID riid, void ** ppvObject)
{
	HRESULT hr = S_OK;		
	CComPtr<IClassFactory> spClassFactory;
	hr = _Module.GetClassObject( CLSID_MediaDevMgr, __uuidof(IClassFactory), (LPVOID *)&spClassFactory  );

	if( SUCCEEDED( hr ) )
	{
		hr = spClassFactory->CreateInstance( pUnkOuter, riid, ppvObject );
	}

	return( hr );
}

STDMETHODIMP CMediaDevMgrClassFactory::LockServer(BOOL fLock)
{
	fLock ? _Module.Lock() : _Module.Unlock();

	return( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\mswmdm.cpp ===
// mswmdm.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f mswmdmps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "mswmdm.h"

#include "mswmdm_i.c"
#include "MediaDevMgr.h"
#include "Device.h"
#include "Storage.h"
#include "StorageGlobal.h"
#include "WMDMDeviceEnum.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_MediaDevMgr, CMediaDevMgr)
//	OBJECT_ENTRY(CLSID_WMDMDevice, CWMDMDevice)
//	OBJECT_ENTRY(CLSID_WMDMStorage, CWMDMStorage)
//	OBJECT_ENTRY(CLSID_WMDMStorageGlobal, CWMDMStorageGlobal)
//BJECT_ENTRY(CLSID_WMDMDeviceEnum, CWMDMDeviceEnum)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	HRESULT hr = S_OK;

	//
	// Purpose : THis is used so that the Shell team can use WMDM in the "Both"
	// threading model while WMP uses us via the Free threading model.  This
	// class factory implementation simply delagates and uses the old class factory
	// of MediaDevMgr ONLY IF the new CLSID was used to CoCreate WMDM.
	//

	if( IsEqualGUID( rclsid, __uuidof(MediaDevMgrClassFactory) ) )
	{
		CComMediaDevMgrClassFactory *pNewClassFactory = NULL;
		
		hr = CComMediaDevMgrClassFactory::CreateInstance( &pNewClassFactory );
		CComPtr<IClassFactory> spClassFactory = pNewClassFactory;

		if( SUCCEEDED( hr ) )
		{
			hr = spClassFactory->QueryInterface( riid, ppv );
		}
	}
	else
	{
		hr = _Module.GetClassObject(rclsid, riid, ppv);
	}

	return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\spinfo.h ===
#ifndef __SPINFO_H_
#define __SPINFO_H_

#include "scclient.h"

class CSPInfo
{
public:
    CSPInfo();
    ~CSPInfo();

    HRESULT hrInitialize(LPWSTR pwszProgID);
    HRESULT hrGetInterface(IMDServiceProvider **ppProvider);
	void GetSCClient(CSecureChannelClient **ppSCClient);
private:
    IMDServiceProvider *m_pSP;
    CSecureChannelClient *m_pSCClient;
};

#endif __SPINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\spinfo.cpp ===
#include "stdafx.h"
#include "mswmdm.h"
#include "spinfo.h"
#include "loghelp.h"
// We don't want to dll's using our lib to link to drmutil2.lib. 
// So disable DRM logging.
#define DISABLE_DRM_LOG
#include "drmerr.h"
#include "key.h"
#include "wmsstd.h"

CSPInfo::CSPInfo() : m_pSP(NULL), m_pSCClient(NULL)
{
	m_pSCClient = new CSecureChannelClient();
}

CSPInfo::~CSPInfo()
{
	SAFE_DELETE(m_pSCClient);
    SAFE_RELEASE(m_pSP);
}

HRESULT CSPInfo::hrInitialize(LPWSTR pwszProgID)
{
    HRESULT hr;
    CLSID clsid;
	IComponentAuthenticate *pAuth = NULL;

	if (!m_pSCClient)
	{
		hr = E_FAIL;
		goto exit;
	}

	CORg( m_pSCClient->SetCertificate(SAC_CERT_V1, (BYTE*)g_abAppCert, sizeof(g_abAppCert), (BYTE*)g_abPriv, sizeof(g_abPriv)) );
    CORg( CLSIDFromProgID(pwszProgID, &clsid) );
    CORg( CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IComponentAuthenticate, (void**)&pAuth) );

    m_pSCClient->SetInterface(pAuth);
    CORg( m_pSCClient->Authenticate(SAC_PROTOCOL_V1) );

	CORg( pAuth->QueryInterface(IID_IMDServiceProvider, (void**)&m_pSP) );
     
exit:
Error:

	SAFE_RELEASE(pAuth);

    hrLogDWORD("CSPInfo::hrInitialize returned 0x%08lx", hr, hr);
    
    return hr;
}

HRESULT CSPInfo::hrGetInterface(IMDServiceProvider **ppProvider)
{
    m_pSP->AddRef();
    
    *ppProvider = m_pSP;

    return S_OK;
}

void CSPInfo::GetSCClient(CSecureChannelClient **ppSCClient)
{
	*ppSCClient = m_pSCClient;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\storage.h ===
// Storage.h : Declaration of the CStorage

#ifndef __STORAGE_H_
#define __STORAGE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CStorage
class ATL_NO_VTABLE CWMDMStorage : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CWMDMStorage, &CLSID_WMDMStorage>,
	public IWMDMStorage2,
    public IWMDMStorageControl2,
    public IWMDMObjectInfo,
    public IWMDMRevoked
{
public:
    CWMDMStorage();
    ~CWMDMStorage();

BEGIN_COM_MAP(CWMDMStorage)
	COM_INTERFACE_ENTRY(IWMDMStorage)
	COM_INTERFACE_ENTRY(IWMDMStorage2)
	COM_INTERFACE_ENTRY(IWMDMStorageControl)
	COM_INTERFACE_ENTRY(IWMDMStorageControl2)
	COM_INTERFACE_ENTRY(IWMDMObjectInfo)
    COM_INTERFACE_ENTRY(IWMDMRevoked)
END_COM_MAP()

public:

// IWMDMStorage
	STDMETHOD(SetAttributes)(DWORD dwAttributes, _WAVEFORMATEX *pFormat);
    STDMETHOD(GetStorageGlobals)(IWMDMStorageGlobals **ppStorageGlobals);
    STDMETHOD(GetAttributes)(DWORD *pdwAttributes,
                             _WAVEFORMATEX *pFormat);
    STDMETHOD(GetName)(LPWSTR pwszName,
                       UINT nMaxChars);
    STDMETHOD(GetDate)(PWMDMDATETIME pDateTimeUTC);
    STDMETHOD(GetSize)(DWORD *pdwSizeLow,
                       DWORD *pdwSizeHigh);
    STDMETHOD(GetRights)(PWMDMRIGHTS *ppRights, UINT *pnRightsCount, BYTE abMac[WMDM_MAC_LENGTH]);
    STDMETHOD(EnumStorage)(IWMDMEnumStorage **ppEnumStorage);
    STDMETHOD(SendOpaqueCommand)(OPAQUECOMMAND *pCommand);

// IWMDMStorage2
	STDMETHOD(GetStorage)( LPCWSTR pszStorageName, IWMDMStorage** ppStorage );

    STDMETHOD(SetAttributes2)(  DWORD dwAttributes, 
							    DWORD dwAttributesEx, 
						        _WAVEFORMATEX *pFormat,
							    _VIDEOINFOHEADER* pVideoFormat );
    STDMETHOD(GetAttributes2)(  DWORD *pdwAttributes,
							    DWORD *pdwAttributesEx,
                                _WAVEFORMATEX *pAudioFormat,
							    _VIDEOINFOHEADER* pVideoFormat );

// IWMDMStorageControl
    STDMETHOD(Insert)(UINT fuMode,
                      LPWSTR pwszFile,
                      IWMDMOperation *pOperation,
                      IWMDMProgress *pProgress,
                      IWMDMStorage **ppNewObject);
    STDMETHOD(Delete)(UINT fuMode,
                      IWMDMProgress *pProgress);
    STDMETHOD(Rename)(UINT fuMode,
                      LPWSTR pwszNewName,
                      IWMDMProgress *pProgress);
    STDMETHOD(Read)(UINT fuMode,
                    LPWSTR pwszFile,
                    IWMDMProgress *pProgress,
                    IWMDMOperation *pOperation);
    STDMETHOD(Move)(UINT fuMode,
                    IWMDMStorage *pTargetObject,
                    IWMDMProgress *pProgress);

// IWMDMStorageControl2
    STDMETHOD(Insert2)(UINT fuMode,
                      LPWSTR pwszFileSource,
                      LPWSTR pwszFileDest,
                      IWMDMOperation *pOperation,
                      IWMDMProgress *pProgress,
                      IUnknown* pUnknown,
                      IWMDMStorage **ppNewObject);

// IWMDMObjectInfo
    STDMETHOD(GetPlayLength)(DWORD *pdwLength);
    STDMETHOD(SetPlayLength)(DWORD dwLength);
    STDMETHOD(GetPlayOffset)(DWORD *pdwOffset);
    STDMETHOD(SetPlayOffset)(DWORD dwOffset);
    STDMETHOD(GetTotalLength)(DWORD *pdwLength);
    STDMETHOD(GetLastPlayPosition)(DWORD *pdwLastPos);
    STDMETHOD(GetLongestPlayPosition)(DWORD *pdwLongestPos);

// IWMDMRevoked
    STDMETHOD(GetRevocationURL)( LPWSTR* ppwszRevocationURL,
                                 DWORD*  pdwBufferLen,
                                 DWORD* pdwRevokedBitFlag );


    void SetContainedPointer(IMDSPStorage *pStorage, WORD wSPIndex);
    void GetContainedPointer(IMDSPStorage **ppStorage);
private:
    IMDSPStorage *m_pStorage;
	WORD m_wSPIndex;
	DWORD m_dwStatus;
    LPWSTR      m_pwszRevocationURL;
    DWORD       m_dwRevocationURLLen;
    DWORD       m_dwRevocationBitFlag;

    HRESULT hrCopyToStorageFromFile( UINT fuMode, LPWSTR pwszFileName, 
                                     UINT uNewStorageMode, LPWCH wszNewStorageName,
                                     IWMDMStorage*& pNewIWMDMStorage,
                                     IWMDMProgress *pProgress, 
                                     IUnknown*    pUnknown, BOOL fQuery);
    HRESULT hrCopyToOperationFromStorage(IWMDMOperation *pOperation, IWMDMProgress *pProgress, IMDSPObject *pObject);
    HRESULT hrCopyToStorageFromOperation(UINT fuMode, IWMDMOperation *pOperation, 
                                         UINT uNewStorageMode, LPWCH wszNewStorageName,
                                         IWMDMStorage*& pNewIWMDMStorage,
                                         IWMDMProgress *pProgress, 
                                         IUnknown*    pUnknown, BOOL fQuery);
    HRESULT hrCopyToFileFromStorage(LPWSTR pwszFileName, IWMDMProgress *pProgress, IMDSPObject *pObject);
    HRESULT InsertWorker(UINT fuMode,
                         LPWSTR pwszFileSource,
                         LPWSTR pwszFileDest,
                         IWMDMOperation *pOperation,
                         IWMDMProgress *pProgress,
                         IUnknown*    pUnknown,
                         IWMDMStorage **ppNewObject);
    HRESULT DeleteWorker(UINT fuMode, IWMDMProgress *pProgress);
    HRESULT RenameWorker(LPWSTR pwszNewName,
                         IWMDMProgress *pProgress);
    HRESULT MoveWorker(UINT fuMode,
                       IWMDMStorage *pTargetObject,
                       IWMDMProgress *pProgress,
                       IWMDMStorage **ppNewObject);
    HRESULT ReadWorker(UINT fuMode,
                       LPWSTR pwszFile,
                       IWMDMProgress *pProgress,
                       IWMDMOperation *pOperation);

    friend DWORD InsertThreadFunc(void *pData);
    friend DWORD DeleteThreadFunc(void *pData);
    friend DWORD RenameThreadFunc(void *pData);
//    friend DWORD MoveThreadFunc(void *pData);
    friend DWORD ReadThreadFunc(void *pData);

    HRESULT UpdateRevocationURL( LPWSTR* ppwszRevocationURL, 
                                 DWORD*  pdwRevocationURLLen, 
                                 DWORD*  pdwRevocationBitFlag );

};

#endif //__STORAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\storage.cpp ===
// Storage.cpp : Implementation of CStorage
#include "stdafx.h"
#include "mswmdm.h"
#include "Storage.h"
#include "scpinfo.h"
#include "spinfo.h"
#include "loghelp.h"
#include "WMDMStorageEnum.h"
#include "StorageGlobal.h"
#include "scclient.h"
#include "scserver.h"
// We don't want to dll's using our lib to link to drmutil2.lib. 
// So disable DRM logging.
#define DISABLE_DRM_LOG
#include "drmerr.h"
#include "wmsstd.h"
#include "key.h"
#include "MediaDevMgr.h"
#include <WMDMUtil.h>

//#define DUMP_FILE 
#ifdef DUMP_FILE
#include <stdio.h>
#include <stdlib.h>
#endif

#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

#define WMDM_TRANSFER_BUFFER_SIZE    57344
//65536 
//previous size 10240

/////////////////////////////////////////////////////////////////////////////
// CWMDMStorage
extern CSCPInfo **g_pSCPs;
extern WORD g_wSCPCount;
extern CSecureChannelServer *g_pAppSCServer;
extern CSPInfo **g_pSPs;

typedef struct __INSERTTHREADARGS
{
    CWMDMStorage *pThis;
    UINT fuMode;
    LPWSTR pwszFileSource;
    LPWSTR pwszFileDest;
    IStream     *pOperationStream;
    IStream     *pProgressStream;
    IStream     *pUnknownStream;
    IWMDMStorage **ppNewObject;
} INSERTTHREADARGS;

typedef struct __DELETETHREADARGS
{
    CWMDMStorage *pThis;
    IStream      *pProgressStream;
    UINT fuMode;
} DELETETHREADARGS;

typedef struct __RENAMETHREADARGS
{
    CWMDMStorage *pThis;
    LPWSTR  pwszNewName;
    IStream *pProgressStream;
    
} RENAMETHREADARGS;

typedef struct __READTHREADARGS
{
    CWMDMStorage *pThis;
    UINT fuMode;
    LPWSTR pwszFile;
    IStream *pProgressStream;
    IStream *pOperationStream;
    
} READTHREADARGS;

// Construction / Destruction
CWMDMStorage::CWMDMStorage() 
 : m_pStorage(NULL), m_dwStatus(WMDM_STATUS_READY)
{
	GlobalAddRef();

    m_pwszRevocationURL = NULL;
    m_dwRevocationURLLen = 0;
    m_dwRevocationBitFlag = 0;
}
    
CWMDMStorage::~CWMDMStorage()
{
    SAFE_RELEASE(m_pStorage);
    CoTaskMemFree( m_pwszRevocationURL );
	
	GlobalRelease();
}


// IWMDMStorage
HRESULT CWMDMStorage::SetAttributes(DWORD dwAttributes, _WAVEFORMATEX *pFormat)
{
    HRESULT hr;
    
    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pStorage->SetAttributes(dwAttributes, pFormat) );

Error:
    hrLogDWORD("IWMDMStorage::SetAttributes returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorage::GetStorageGlobals(IWMDMStorageGlobals **ppStorageGlobals)
{
    HRESULT hr;
    CComObject<CWMDMStorageGlobal> *pStgGlobal = NULL;
    IMDSPStorageGlobals *pSPStgGlobal = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    if (!ppStorageGlobals)
    {
        CORg( E_INVALIDARG );
    }

    CORg( m_pStorage->GetStorageGlobals(&pSPStgGlobal) );
    CORg( CComObject<CWMDMStorageGlobal>::CreateInstance(&pStgGlobal) );
    hr = pStgGlobal->QueryInterface(IID_IWMDMStorageGlobals, reinterpret_cast<void**>(ppStorageGlobals));
    if (FAILED(hr))
    {
        delete pStgGlobal;
        goto exit;
    }

    pStgGlobal->SetContainedPointer(pSPStgGlobal, m_wSPIndex);

exit:
Error:
    if (pSPStgGlobal)
        pSPStgGlobal->Release();

    hrLogDWORD("IWMDMStorage::GetStorageGlobals returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorage::GetAttributes(DWORD *pdwAttributes,
                                    _WAVEFORMATEX *pFormat)
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pStorage->GetAttributes(pdwAttributes, pFormat) );

Error:
    hrLogDWORD("IWMDMStorage::GetAttributes returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorage::GetName(LPWSTR pwszName,
                              UINT nMaxChars)
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pStorage->GetName(pwszName, nMaxChars) );

Error:
    hrLogDWORD("IWMDMStorage::GetName returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorage::GetDate(PWMDMDATETIME pDateTimeUTC)
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pStorage->GetDate(pDateTimeUTC) );

Error:
    hrLogDWORD("IWMDMStorage::GetDate returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorage::GetSize(DWORD *pdwSizeLow,
                              DWORD *pdwSizeHigh)
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pStorage->GetSize(pdwSizeLow, pdwSizeHigh) );

Error:
    hrLogDWORD("IWMDMStorage::GetSize returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorage::GetRights(PWMDMRIGHTS *ppRights, UINT *pnRightsCount, BYTE abMac[WMDM_MAC_LENGTH])
{
    HRESULT hr;
    IMDSPStorageGlobals *pStgGlobals = NULL;
    IMDSPObject *pObject = NULL;
    ISCPSecureAuthenticate *pSecureAuth = NULL;
    ISCPSecureQuery *pSecQuery = NULL;
    WORD wCurSCP = 0;
    DWORD dwBytesRead;
    BYTE *pData = NULL;
    UINT fuFlags;
    DWORD dwExSize;
    DWORD dwMDSize;
    DWORD dwRightsSize;
    DWORD dwBufferSize=0;
    BOOL fUseSCP = FALSE;
	CSecureChannelClient *pSCClient = NULL;
	CSecureChannelClient *pSPClient = NULL;
	HMAC hMAC;
	BYTE abTempMAC[SAC_MAC_LEN];
	BYTE abMACVerify[SAC_MAC_LEN];
 	UINT fuTempFlags;
	BYTE abSPSessionKey[SAC_SESSION_KEYLEN];
	DWORD dwSessionKeyLen = SAC_SESSION_KEYLEN;

    if (!ppRights || !pnRightsCount)
    {
        CORg( E_INVALIDARG );
    }

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

	g_pSPs[m_wSPIndex]->GetSCClient(&pSPClient);
	if (!pSPClient)
	{
		CORg( E_FAIL );
	}

    hr = m_pStorage->GetRights(ppRights, pnRightsCount, abTempMAC);
	if (SUCCEEDED(hr))
	{
		// Verify MAC returned by GetRights on the SP
		CORg( pSPClient->MACInit(&hMAC) );
		CORg( pSPClient->MACUpdate(hMAC, (BYTE*)(*ppRights), sizeof(WMDMRIGHTS) * (*pnRightsCount)) );
		CORg( pSPClient->MACUpdate(hMAC, (BYTE*)(pnRightsCount), sizeof(*pnRightsCount)) );
		CORg( pSPClient->MACFinal(hMAC, abMACVerify) );

		if (memcmp(abMACVerify, abTempMAC, WMDM_MAC_LENGTH) != 0)
		{
			CORg( WMDM_E_MAC_CHECK_FAILED );
		}
	}

    // If the SP doesn't give us the rights then we should 
    // try to use the SCP to get the rights.
    if ((E_NOTIMPL == hr) || (WMDM_E_NOTSUPPORTED == hr))
    {
        CORg( m_pStorage->GetStorageGlobals(&pStgGlobals) );
    
        if( g_pSCPs == NULL )
        {
            CMediaDevMgr::LoadSCPs();
        }

        for( wCurSCP = 0; wCurSCP < g_wSCPCount; wCurSCP ++ )
        {
            CORg( g_pSCPs[wCurSCP]->hrGetInterface(&pSecureAuth) );

			g_pSCPs[wCurSCP]->GetSCClient(&pSCClient);
			if (!pSCClient)
			{
				CORg( E_FAIL );
			}

            CORg( pSecureAuth->GetSecureQuery(&pSecQuery) );
            CORg( pSecQuery->GetDataDemands(&fuFlags, &dwRightsSize, &dwExSize, &dwMDSize, abTempMAC) );

			// Verify MAC returned by GetDataDemands
			CORg( pSCClient->MACInit(&hMAC) );
			CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&fuFlags), sizeof(fuFlags)) );
			CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwRightsSize), sizeof(dwRightsSize)) );
			CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwExSize), sizeof(dwExSize)) );
			CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwMDSize), sizeof(dwMDSize)) );
			CORg( pSCClient->MACFinal(hMAC, abMACVerify) );

			if (memcmp(abMACVerify, abTempMAC, WMDM_MAC_LENGTH) != 0)
			{
				CORg( WMDM_E_MAC_CHECK_FAILED );
			}

            if (!(fuFlags & WMDM_SCP_RIGHTS_DATA))
            {
                continue;
            }

            if (dwBufferSize < (dwExSize>dwRightsSize?dwExSize:dwRightsSize))
            {
                SAFE_ARRAY_DELETE(pData);
                dwBufferSize = dwExSize>dwRightsSize?dwExSize:dwRightsSize;
	            pData = new BYTE[dwBufferSize];
	            CPRg( pData );
            }

            CORg( m_pStorage->QueryInterface(IID_IMDSPObject, reinterpret_cast<void**>(&pObject)) );
            CORg( pObject->Open(MDSP_READ) );

            hr = WMDM_E_MOREDATA;
            while (hr == WMDM_E_MOREDATA)
            {
                dwBytesRead = dwBufferSize;
                CORg( pObject->Read(pData, &dwBytesRead, abTempMAC) );

				// BUGBUG: Copy this buffer before decrypting
				pSPClient->DecryptParam(pData, dwBytesRead);

				// Verify MAC returned by Read on the SP
				CORg( pSPClient->MACInit(&hMAC) );
				CORg( pSPClient->MACUpdate(hMAC, (BYTE*)pData, dwBytesRead) );
				CORg( pSPClient->MACUpdate(hMAC, (BYTE*)(&dwBytesRead), sizeof(dwBytesRead)) );
				CORg( pSPClient->MACFinal(hMAC, abMACVerify) );

				if (memcmp(abMACVerify, abTempMAC, WMDM_MAC_LENGTH) != 0)
				{
					CORg( WMDM_E_MAC_CHECK_FAILED );
				}

				// Create the MAC to send to ExamineData
				CORg( pSCClient->MACInit(&hMAC) );
				fuTempFlags = WMDM_SCP_EXAMINE_DATA;
				CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&fuTempFlags), sizeof(fuTempFlags)) );
				CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(pData), dwExSize) );
				CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwExSize), sizeof(dwExSize)) );
				CORg( pSCClient->MACFinal(hMAC, abTempMAC) );

				// Encrypt the pData Parameter
				pSCClient->EncryptParam(pData, dwExSize);

                CORg( pSecQuery->ExamineData(WMDM_SCP_EXAMINE_DATA, NULL, pData, dwExSize, abTempMAC) );
				CORg( pSCClient->DecryptParam(pData, dwExSize) );
            }

            if (hr == S_OK)
            {
				pSPClient->GetSessionKey(abSPSessionKey);

				// Create the MAC to send to GetRights
				pSCClient->MACInit(&hMAC);
				pSCClient->MACUpdate(hMAC, (BYTE*)(pData), dwRightsSize);
				pSCClient->MACUpdate(hMAC, (BYTE*)(&dwRightsSize), sizeof(dwRightsSize));
				pSCClient->MACUpdate(hMAC, (BYTE*)(abSPSessionKey), dwSessionKeyLen);
				pSCClient->MACUpdate(hMAC, (BYTE*)(&dwSessionKeyLen), sizeof(dwSessionKeyLen));
				pSCClient->MACFinal(hMAC, abTempMAC);

				// Encrypt the pData Parameter
				CORg( pSCClient->EncryptParam(pData, dwRightsSize) );
				CORg( pSCClient->EncryptParam((BYTE*)abSPSessionKey, dwSessionKeyLen) );
				
				CORg( pSecQuery->GetRights(pData, 
                                          dwRightsSize,
										  (BYTE*)abSPSessionKey,
										  dwSessionKeyLen,
                                          pStgGlobals,
                                          ppRights, 
                                          pnRightsCount, 
										  abTempMAC) );

				// Verify MAC returned by GetRights
				pSCClient->MACInit(&hMAC);
				pSCClient->MACUpdate(hMAC, (BYTE*)(*ppRights), sizeof(WMDMRIGHTS) * (*pnRightsCount));
				pSCClient->MACUpdate(hMAC, (BYTE*)(pnRightsCount), sizeof(*pnRightsCount));
				pSCClient->MACFinal(hMAC, abMACVerify);

				if (memcmp(abMACVerify, abTempMAC, WMDM_MAC_LENGTH) != 0)
				{
					hr = WMDM_E_MAC_CHECK_FAILED;
					goto exit;
				}

                break;
            }

            pObject->Release();
            pObject = NULL;
            pSecQuery->Release();
            pSecQuery = NULL;
        }
    }

	if (SUCCEEDED(hr))
	{
		// Create the MAC to return to caller
		g_pAppSCServer->MACInit(&hMAC);
		g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(*ppRights), sizeof(WMDMRIGHTS) * (*pnRightsCount));
		g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pnRightsCount), sizeof(*pnRightsCount));
		g_pAppSCServer->MACFinal(hMAC, abMac);
	}

Error:
exit:
    SAFE_ARRAY_DELETE(pData);
    SAFE_RELEASE(pObject);
    SAFE_RELEASE(pSecureAuth);
    SAFE_RELEASE(pSecQuery);
    SAFE_RELEASE(pStgGlobals);

    hrLogDWORD("IWMDMStorage::GetRights returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorage::EnumStorage(IWMDMEnumStorage **ppEnumStorage)
{
    HRESULT hr;
    CComObject<CWMDMStorageEnum> *pEnumObj = NULL;
    IMDSPEnumStorage *pEnumStg = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    CARg( ppEnumStorage );

    CORg( m_pStorage->EnumStorage(&pEnumStg) );

    CORg( CComObject<CWMDMStorageEnum>::CreateInstance(&pEnumObj) );

    hr = pEnumObj->QueryInterface(IID_IWMDMEnumStorage, reinterpret_cast<void**>(ppEnumStorage));
    if (FAILED(hr))
    {
        delete pEnumObj;
        goto exit;
    }

    pEnumObj->SetContainedPointer(pEnumStg, m_wSPIndex);

exit:
Error:
    SAFE_RELEASE(pEnumStg);

    hrLogDWORD("IWMDMStorage::EnumStorage returned 0x%08lx", hr, hr);
    return hr;
}


HRESULT CWMDMStorage::SendOpaqueCommand(OPAQUECOMMAND *pCommand)
{
    HRESULT hr;
	HMAC hMAC;
	BYTE abTempMAC[WMDM_MAC_LENGTH];
	CSecureChannelClient *pSPClient = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

	if( pCommand == NULL || 
       ((pCommand->pData == NULL) && (pCommand->dwDataLen > 0)) )
	{
		CORg( E_INVALIDARG );
	}

	g_pSPs[m_wSPIndex]->GetSCClient(&pSPClient);
	if (!pSPClient)
	{
		CORg( E_FAIL );
	}

    // Verify MAC on command
	CORg( g_pAppSCServer->MACInit(&hMAC) );
	CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(&(pCommand->guidCommand)), sizeof(pCommand->guidCommand)) );
	CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(&(pCommand->dwDataLen)), sizeof(pCommand->dwDataLen)) );

	if (pCommand->pData)
	{
		CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pCommand->pData), pCommand->dwDataLen) );
	}

	CORg( g_pAppSCServer->MACFinal(hMAC, (BYTE*)abTempMAC) );

	if (memcmp((BYTE*)(pCommand->abMAC), abTempMAC, WMDM_MAC_LENGTH) != 0)
	{
		CORg( WMDM_E_MAC_CHECK_FAILED );
	}

	// Convert the MAC for the SP
	CORg( pSPClient->MACInit(&hMAC) );
	CORg( pSPClient->MACUpdate(hMAC, (BYTE*)(&(pCommand->guidCommand)), sizeof(pCommand->guidCommand)) );
	CORg( pSPClient->MACUpdate(hMAC, (BYTE*)(&(pCommand->dwDataLen)), sizeof(pCommand->dwDataLen)) );
	if (pCommand->pData)
	{
		CORg( pSPClient->MACUpdate(hMAC, (BYTE*)(pCommand->pData), pCommand->dwDataLen) );
	}
	CORg( pSPClient->MACFinal(hMAC, (BYTE*)(pCommand->abMAC)) );

    CORg( m_pStorage->SendOpaqueCommand(pCommand) );

	// Verify the MAC returned by the SP
	CORg( pSPClient->MACInit(&hMAC) );
	CORg( pSPClient->MACUpdate(hMAC, (BYTE*)(&(pCommand->guidCommand)), sizeof(pCommand->guidCommand)) );
	CORg( pSPClient->MACUpdate(hMAC, (BYTE*)(&(pCommand->dwDataLen)), sizeof(pCommand->dwDataLen)) );
    if (pCommand->pData)
	{
		CORg( pSPClient->MACUpdate(hMAC, (BYTE*)(pCommand->pData), pCommand->dwDataLen) );
	}
	CORg( pSPClient->MACFinal(hMAC, (BYTE*)abTempMAC) );

	if (memcmp((BYTE*)(pCommand->abMAC), abTempMAC, WMDM_MAC_LENGTH) != 0)
	{
		CORg( WMDM_E_MAC_CHECK_FAILED );
	}

	// Convert the MAC to send back to the Application
	CORg( g_pAppSCServer->MACInit(&hMAC) );
	CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(&(pCommand->guidCommand)), sizeof(pCommand->guidCommand)) );
	CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(&(pCommand->dwDataLen)), sizeof(pCommand->dwDataLen)) );
	if (pCommand->pData)
	{
		CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pCommand->pData), pCommand->dwDataLen) );
	}
	CORg( g_pAppSCServer->MACFinal(hMAC, (BYTE*)(pCommand->abMAC)) );

Error:
    hrLogDWORD("IWMDMStorage::SendOpaqueCommand returned 0x%08lx", hr, hr);

    return hr;
}


// IWMDMStorage2
HRESULT CWMDMStorage::GetStorage( LPCWSTR pszStorageName, IWMDMStorage** ppStorage )
{
    HRESULT hr;
    IMDSPStorage2*  pStorage2 = NULL;
    IMDSPStorage*   pMDSPStorageFound = NULL;
    IMDSPStorage*   pMDSubStorage = NULL;
    CComObject<CWMDMStorage>* pStgObj = NULL;

    CARg( ppStorage );
    CARg( pszStorageName );

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    // Get the Storage pointer from the SP (as a IMDSPStorage2)
    hr = m_pStorage->QueryInterface(IID_IMDSPStorage2, reinterpret_cast<void**>(&pStorage2));
    if( SUCCEEDED(hr) )
    {
        hr = pStorage2->GetStorage( pszStorageName, &pMDSPStorageFound );
    }

    // This functionalty is not implemented by the SP. Find the storage by enumerating all storages
    if( hr == E_NOTIMPL || hr == E_NOINTERFACE )
    {
    	IMDSPEnumStorage *pEnum = NULL;
        WCHAR   pswzMDSubStorageName[MAX_PATH];
        ULONG   ulFetched;

	    CORg(m_pStorage->EnumStorage(&pEnum));
        while( S_OK == pEnum->Next(1, &pMDSubStorage, &ulFetched) ) 
        {
            hr = pMDSubStorage->GetName( pswzMDSubStorageName, MAX_PATH );
            if( SUCCEEDED(hr) && ( _wcsicmp( pswzMDSubStorageName, pszStorageName ) == 0 ) )
            {
                // We have found the storage we are looking for.
                pMDSPStorageFound = pMDSubStorage;
                break;
            }
            pMDSubStorage->Release();
        }
        pEnum->Release();
    }


    // Create a IWMDMStorage object and connect it to the the storage from the SP
    if( pMDSPStorageFound != NULL ) 
    {
        CORg( CComObject<CWMDMStorage>::CreateInstance(&pStgObj) );
        CORg( pStgObj->QueryInterface(IID_IWMDMStorage, reinterpret_cast<void**>(ppStorage)) );

        pStgObj->SetContainedPointer(pMDSPStorageFound, m_wSPIndex);
    }
    // Did not find a matching storage
    else if( SUCCEEDED(hr) )
    {
        hr = S_FALSE;
    }


Error:
    SAFE_RELEASE(pStorage2);

    if( hr != S_OK )
    {
        ppStorage = NULL;
        SAFE_DELETE( pStgObj );
    }

    hrLogDWORD("IWMDMDevice2::GetStorage returned 0x%08lx", hr, hr);

    return hr;
}


HRESULT CWMDMStorage::SetAttributes2(   DWORD dwAttributes, 
							            DWORD dwAttributesEx, 
						                _WAVEFORMATEX *pAudioFormat,
							            _VIDEOINFOHEADER* pVideoFormat )
{
    HRESULT hr;
    IMDSPStorage2* pStorage2 = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pStorage->QueryInterface( IID_IMDSPStorage2, reinterpret_cast<void**>(&pStorage2) ) );
    CORg( pStorage2->SetAttributes2(dwAttributes, 
                                    dwAttributesEx, 
                                    pAudioFormat, 
                                    pVideoFormat) );

Error:
    SAFE_RELEASE(pStorage2);

    hrLogDWORD("IWMDMStorage2::SetAttributes2 returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorage::GetAttributes2(   DWORD *pdwAttributes,
							            DWORD *pdwAttributesEx,
                                        _WAVEFORMATEX *pAudioFormat,
							            _VIDEOINFOHEADER* pVideoFormat )
{
    HRESULT hr;
    IMDSPStorage2* pStorage2 = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			CORg( WMDM_E_NOTCERTIFIED );
		}
	}
	else
	{
		CORg( E_FAIL );
	}

    CORg( m_pStorage->QueryInterface( IID_IMDSPStorage2, reinterpret_cast<void**>(&pStorage2) ) );
    CORg( pStorage2->GetAttributes2(  pdwAttributes, 
                                      pdwAttributesEx, 
                                      pAudioFormat, 
                                      pVideoFormat) );

Error:
    SAFE_RELEASE(pStorage2);

    hrLogDWORD("IWMDMStorage2::GetAttributes2 returned 0x%08lx", hr, hr);

    return hr;
}


// IWMDMStorageControl
HRESULT CWMDMStorage::Insert(UINT fuMode,
                             LPWSTR pwszFile,
                             IWMDMOperation *pOperation,
                             IWMDMProgress *pProgress,
                             IWMDMStorage **ppNewObject)
{
    HRESULT hr = S_OK;

    CORg( Insert2( fuMode,
                   pwszFile,
                   NULL,
                   pOperation,
                   pProgress,
                   NULL,
                   ppNewObject ) );
Error:
    hrLogDWORD("IWMDMStorageControl::Insert returned 0x%08lx", hr, hr);

    return hr;
}

// IWMDMStorageControl2
HRESULT CWMDMStorage::Insert2(UINT fuMode,
                              LPWSTR pwszFileSource,
                              LPWSTR pwszFileDest,
                              IWMDMOperation* pOperation,
                              IWMDMProgress* pProgress,
                              IUnknown* pUnknown,
                              IWMDMStorage** ppNewObject)
{ 
    HRESULT hr = S_OK;
    HANDLE hThread;
    DWORD dwThreadID;

    INSERTTHREADARGS *pThreadArgs = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    if (fuMode & WMDM_CONTENT_OPERATIONINTERFACE)
    {
        CARg(pOperation);
    }
    else
    {
        CARg(pwszFileSource);
    }

    if (fuMode & WMDM_MODE_BLOCK)
    {
        hr = InsertWorker(fuMode,
                          pwszFileSource,
                          pwszFileDest,
                          pOperation,
                          pProgress,
                          pUnknown,
                          ppNewObject);
    }
    else if (fuMode & WMDM_MODE_THREAD)
    {
        pThreadArgs = new INSERTTHREADARGS;
        CPRg(pThreadArgs);
        memset(pThreadArgs, 0, sizeof(INSERTTHREADARGS));

        pThreadArgs->pThis = this;
        pThreadArgs->fuMode = fuMode;

        if (!(fuMode & WMDM_CONTENT_OPERATIONINTERFACE))
        {
            pThreadArgs->pwszFileSource = new WCHAR[wcslen(pwszFileSource) + 1];
            CPRg( pThreadArgs->pwszFileSource );
            wcscpy(pThreadArgs->pwszFileSource, pwszFileSource );
        }
        else
        { 
            // Need to mashal callback interfaces since we are passing it to another thread.
            hr = CoMarshalInterThreadInterfaceInStream( __uuidof(IWMDMOperation),
                                                        pOperation,  
                                                        &pThreadArgs->pOperationStream );           
        }

        if( pwszFileDest )
        {
            pThreadArgs->pwszFileDest = new WCHAR[wcslen(pwszFileDest) + 1];
            CPRg( pThreadArgs->pwszFileDest );
            wcscpy(pThreadArgs->pwszFileDest, pwszFileDest);
        }

        if (pProgress)
        {
            // Need to mashal callback interfaces since we are passing it to another thread.
            hr = CoMarshalInterThreadInterfaceInStream( __uuidof(IWMDMProgress),
                                                        pProgress,  
                                                        &pThreadArgs->pProgressStream );           
        }

        if (pUnknown)
        {
            // Need to mashal callback interfaces since we are passing it to another thread.
            hr = CoMarshalInterThreadInterfaceInStream( __uuidof(IUnknown),
                                                        pUnknown,  
                                                        &pThreadArgs->pUnknownStream );           
        }

        pThreadArgs->ppNewObject = ppNewObject;

        pThreadArgs->pThis->AddRef();
        hThread = CreateThread(NULL, 0, InsertThreadFunc, (void*)pThreadArgs, 0, &dwThreadID);
        if (!hThread)
        {
            pThreadArgs->pThis->Release();
            hr = E_FAIL;
            goto exit;
        }

        CloseHandle(hThread);
    }
    else
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
exit:
Error:

    if ((FAILED(hr)) && (pThreadArgs))
    {
        SAFE_DELETE(pThreadArgs->pwszFileSource);
        SAFE_DELETE(pThreadArgs->pwszFileDest);
        SAFE_RELEASE(pThreadArgs->pOperationStream);
        SAFE_RELEASE(pThreadArgs->pProgressStream);
        SAFE_RELEASE(pThreadArgs->pUnknownStream);
        delete pThreadArgs;
    }

    hrLogDWORD("IWMDMStorageControl::Insert returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorage::Delete(UINT fuMode, IWMDMProgress *pProgress)
{
    HRESULT hr = S_OK;
    HANDLE hThread;
    DWORD dwThreadID;
    DELETETHREADARGS *pThreadArgs = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    if (fuMode & WMDM_MODE_BLOCK)
    {
        hr = DeleteWorker(fuMode, pProgress);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    else if (fuMode & WMDM_MODE_THREAD)
    {
        pThreadArgs = new DELETETHREADARGS;
        if (!pThreadArgs)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        memset( pThreadArgs, 0, sizeof(DELETETHREADARGS) );

        pThreadArgs->pThis = this;

        if (pProgress)
        {
            // Need to mashal callback interfaces since we are passing it to another thread.
            hr = CoMarshalInterThreadInterfaceInStream( __uuidof(IWMDMProgress),
                                                        pProgress,  
                                                        &pThreadArgs->pProgressStream );           
        }

        pThreadArgs->fuMode = fuMode;

        pThreadArgs->pThis->AddRef();
        hThread = CreateThread(NULL, 0, DeleteThreadFunc, (void *)pThreadArgs, 0, &dwThreadID);
        if (!hThread)
        {
            pThreadArgs->pThis->Release();
            hr = E_FAIL;
            goto exit;
        }
        CloseHandle(hThread);
    }
    else
    {
        hr = E_INVALIDARG;
        goto exit;
    }
exit:
    if ((FAILED(hr)) && (pThreadArgs))
    {
        SAFE_RELEASE(pThreadArgs->pProgressStream);
        delete pThreadArgs;
    }

    hrLogDWORD("IWMDMStorageControl::Delete returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorage::Rename(UINT fuMode,
                             LPWSTR pwszNewName,
                             IWMDMProgress *pProgress)
{
    HRESULT hr = S_OK;
    RENAMETHREADARGS *pThreadArgs = NULL;
    HANDLE hThread;
    DWORD dwThreadID;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    if ((!pwszNewName) || (wcslen(pwszNewName) == 0))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (fuMode & WMDM_MODE_BLOCK)
    {
        CORg( RenameWorker(pwszNewName, pProgress) );
    }
    else if (fuMode & WMDM_MODE_THREAD)
    {
        pThreadArgs = new RENAMETHREADARGS;
        CPRg( pThreadArgs );
        memset( pThreadArgs, 0, sizeof(RENAMETHREADARGS) );

        pThreadArgs->pThis = this;

        pThreadArgs->pwszNewName = new WCHAR[wcslen(pwszNewName) + 1];
        CPRg( pThreadArgs->pwszNewName );

        wcscpy(pThreadArgs->pwszNewName, pwszNewName);

        if (pProgress)
        {
            // Need to mashal callback interfaces since we are passing it to another thread.
            hr = CoMarshalInterThreadInterfaceInStream( __uuidof(IWMDMProgress),
                                                        pProgress,  
                                                        &pThreadArgs->pProgressStream );           
        }

        pThreadArgs->pThis->AddRef();
        hThread = CreateThread(NULL, 0, RenameThreadFunc, (void *)pThreadArgs, 0, &dwThreadID);
        if (!hThread)
        {
            pThreadArgs->pThis->Release();
            hr = E_FAIL;
            goto exit;
        }
        CloseHandle(hThread);
    }
    else
    {
        hr = E_INVALIDARG;
        goto exit;
    }

exit:
Error:
    if ((FAILED(hr)) && (pThreadArgs))
    {
        SAFE_DELETE(pThreadArgs->pwszNewName);
        SAFE_RELEASE(pThreadArgs->pProgressStream);
        delete pThreadArgs;
    }

    hrLogDWORD("IWMDMStorageControl::Rename returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorage::Read(UINT fuMode,
                           LPWSTR pwszFile,
                           IWMDMProgress *pProgress,
                           IWMDMOperation *pOperation)
{
    HRESULT hr = S_OK;
    READTHREADARGS *pThreadArgs = NULL;
    HANDLE hThread;
    DWORD dwThreadID;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    if (fuMode & WMDM_MODE_BLOCK)
    {
        CORg( ReadWorker(fuMode, pwszFile, pProgress, pOperation) );
    }
    else if (fuMode & WMDM_MODE_THREAD)
    {
        pThreadArgs = new READTHREADARGS;
        CPRg( pThreadArgs );
        memset( pThreadArgs, 0, sizeof(READTHREADARGS));

        pThreadArgs->pThis = this;

        pThreadArgs->pwszFile = new WCHAR[wcslen(pwszFile) + 1];
        CPRg( pThreadArgs->pwszFile );

        wcscpy(pThreadArgs->pwszFile, pwszFile);

        if (pProgress)
        {
            // Need to mashal callback interfaces since we are passing it to another thread.
            hr = CoMarshalInterThreadInterfaceInStream( __uuidof(IWMDMProgress),
                                                        pProgress,  
                                                        &pThreadArgs->pProgressStream );           
        }

        if (pOperation)
        {
            // Need to mashal callback interfaces since we are passing it to another thread.
            hr = CoMarshalInterThreadInterfaceInStream( __uuidof(IWMDMOperation),
                                                        pOperation,  
                                                        &pThreadArgs->pOperationStream );           
        }

        pThreadArgs->pThis->AddRef();
        hThread = CreateThread(NULL, 0, ReadThreadFunc, (void *)pThreadArgs, 0, &dwThreadID);
        if (!hThread)
        {
            pThreadArgs->pThis->Release();
            hr = E_FAIL;
            goto exit;
        }
        CloseHandle(hThread);
    }
    else
    {
        hr = E_INVALIDARG;
        goto exit;
    }

exit:
Error:
    if ((FAILED(hr)) && (pThreadArgs))
    {
        SAFE_DELETE(pThreadArgs->pwszFile);
        SAFE_RELEASE(pThreadArgs->pProgressStream);
        SAFE_RELEASE(pThreadArgs->pOperationStream);
        delete pThreadArgs;
    }

    hrLogDWORD("IWMDMStorageControl::Read returned 0x%08lx", hr, hr);
    
    return hr;
}

HRESULT CWMDMStorage::Move(UINT fuMode,
                           IWMDMStorage *pTargetObject,
                           IWMDMProgress *pProgress)
{
    HRESULT hr = S_OK;
    IMDSPObject *pObject = NULL;
    IMDSPStorage *pTargetStg = NULL;
    CComObject<CWMDMStorage> *pNewMDMStorage = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    CPRg(pTargetObject);

    CORg( m_pStorage->QueryInterface(IID_IMDSPObject, reinterpret_cast<void**>(&pObject)) );

    ((CWMDMStorage *)pTargetObject)->GetContainedPointer(&pTargetStg);

    CORg( pObject->Move(fuMode, 
                       pProgress, 
                       pTargetStg) );

exit:
Error:
    SAFE_RELEASE(pTargetStg);
    SAFE_RELEASE(pObject);

    hrLogDWORD("IWMDMStorageControl::Move returned 0x%08lx", hr, hr);

    return hr;
}

// IWMDMObjectInfo
HRESULT CWMDMStorage::GetPlayLength(DWORD *pdwLength)
{
    HRESULT hr;
    IMDSPObjectInfo *pInfo = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    CARg(pdwLength);

    CORg( m_pStorage->QueryInterface(IID_IMDSPObjectInfo, reinterpret_cast<void**>(&pInfo)) );
    CORg( pInfo->GetPlayLength(pdwLength) );

exit:
Error:
    SAFE_RELEASE(pInfo);

    hrLogDWORD("IWMDMObjectInfo::GetPlayLength returned 0x%08lx", hr, hr);
    return hr;
}

HRESULT CWMDMStorage::SetPlayLength(DWORD dwLength)
{
    HRESULT hr;
    IMDSPObjectInfo *pInfo = NULL;
    
    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    CORg( m_pStorage->QueryInterface(IID_IMDSPObjectInfo, reinterpret_cast<void**>(&pInfo)) );
    CORg( pInfo->SetPlayLength(dwLength) );

exit:
Error:
    SAFE_RELEASE(pInfo);

    hrLogDWORD("IWMDMObjectInfo::SetPlayLength returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorage::GetPlayOffset(DWORD *pdwOffset)
{
    HRESULT hr;
    IMDSPObjectInfo *pInfo = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    CARg(pdwOffset);

    CORg( m_pStorage->QueryInterface(IID_IMDSPObjectInfo, reinterpret_cast<void**>(&pInfo)) );
    CORg( pInfo->GetPlayOffset(pdwOffset) );

exit:
Error:
    SAFE_RELEASE(pInfo);

    hrLogDWORD("IWMDMObjectInfo::GetPlayOffset returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorage::SetPlayOffset(DWORD dwOffset)
{
    HRESULT hr;
    IMDSPObjectInfo *pInfo = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}
    
    CORg( m_pStorage->QueryInterface(IID_IMDSPObjectInfo, reinterpret_cast<void**>(&pInfo)) );

    CORg( pInfo->SetPlayOffset(dwOffset) );

exit:
Error:
    SAFE_RELEASE(pInfo);

    hrLogDWORD("IWMDMObjectInfo::SetPlayOffset returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorage::GetTotalLength(DWORD *pdwLength)
{
    HRESULT hr;
    IMDSPObjectInfo *pInfo = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    CARg( pdwLength);

    CORg( m_pStorage->QueryInterface(IID_IMDSPObjectInfo, reinterpret_cast<void**>(&pInfo)) );
    CORg( pInfo->GetTotalLength(pdwLength) );

exit:
Error:
    if (pInfo)
        pInfo->Release();

    hrLogDWORD("IWMDMObjectInfo::GetTotalLength returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorage::GetLastPlayPosition(DWORD *pdwLastPos)
{
    HRESULT hr;
    IMDSPObjectInfo *pInfo = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    if (!pdwLastPos)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    CORg( m_pStorage->QueryInterface(IID_IMDSPObjectInfo, reinterpret_cast<void**>(&pInfo)) );
    CORg( pInfo->GetLastPlayPosition(pdwLastPos) );

exit:
Error:
    if (pInfo)
        pInfo->Release();

    hrLogDWORD("IWMDMObjectInfo::GetLastPlayPosition returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorage::GetLongestPlayPosition(DWORD *pdwLongestPos)
{
    HRESULT hr;
    IMDSPObjectInfo *pInfo = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}
    
    CARg( pdwLongestPos);
    CORg( m_pStorage->QueryInterface(IID_IMDSPObjectInfo, reinterpret_cast<void**>(&pInfo)) );
    CORg( pInfo->GetLongestPlayPosition(pdwLongestPos) );

exit:
Error:
    if (pInfo)
        pInfo->Release();

    hrLogDWORD("IWMDMObjectInfo::GetLongestPlayPosition returned 0x%08lx", hr, hr);

    return hr;
}

void CWMDMStorage::SetContainedPointer(IMDSPStorage *pStorage, WORD wSPIndex)
{
    m_pStorage = pStorage;
    m_pStorage->AddRef();
	m_wSPIndex = wSPIndex;
    return;
}

void CWMDMStorage::GetContainedPointer(IMDSPStorage **ppStorage)
{
    *ppStorage = m_pStorage;
    (*ppStorage)->AddRef();
    return;
}

HRESULT CWMDMStorage::hrCopyToStorageFromFile( UINT fuMode, LPWSTR pwszFileName, 
                                               UINT uNewStorageMode, LPWCH wszNewStorageName,
                                               IWMDMStorage*& pNewIWMDMStorage,
                                               IWMDMProgress *pProgress, 
                                               IUnknown*    pUnknown, BOOL fQuery)
{
    USES_CONVERSION;
    HRESULT hr;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwBytesRead;
    DWORD dwBytesWrite;
    BYTE *pData = NULL;
    BOOL fRetVal;
    CComObject<CWMDMStorage> *pNewWMDMStorage = NULL;
    IMDSPStorage *pNewSPStorage = NULL;
    ISCPSecureAuthenticate *pSecureAuth = NULL; 
    ISCPSecureQuery *pSecQuery = NULL;
    ISCPSecureQuery2 *pSecQuery2 = NULL;
    ISCPSecureExchange *pSecExch = NULL;
    IMDSPObject *pObject = NULL;
    IMDSPStorageGlobals *pStgGlobals = NULL;
    IMDSPDevice *pDevice = NULL;
    IMDSPStorage2*  pStorage2 = NULL;

    WORD wCurSCP=0;
    UINT fuFlags;
    DWORD dwExSize;
    DWORD dwMDSize;
    DWORD dwRightsSize;
    DWORD dwBufferSize=WMDM_TRANSFER_BUFFER_SIZE;
    BOOL fUseSCP = FALSE;       // Should data be passed throw an SCP?
    BOOL fUsedSCP = FALSE;      // Was an SCP used to do the file transfer?
    UINT fuReadyFlags;
    DWORD dwType;
    ULONGLONG qwFileSizeSource;
    ULONGLONG qwFileSizeDest;
    DWORD dwTicks = 0;
    UINT nDecideFlags;
	CSecureChannelClient *pSCClient = NULL;
	CSecureChannelClient *pSPClient = NULL;
	HMAC hMAC;
	BYTE abMAC[WMDM_MAC_LENGTH];
	BYTE abMACVerify[WMDM_MAC_LENGTH];
 	UINT fuTempFlags;
	DWORD dwAppSec;
	BOOL fBeginCalled = FALSE;
	DWORD dwSPAppSec;
	DWORD dwAPPAppSec;
	LPWSTR pwszFileExt = NULL;
	DWORD dwSessionKeyLen = SAC_SESSION_KEYLEN;
	BYTE abSPSessionKey[SAC_SESSION_KEYLEN];
    BOOL fOpen = FALSE;
    DWORD dwVersion;
    BOOL bEOF = FALSE;
    BOOL bFlushSCP = FALSE;
    DWORD   dwAppAppCertLen;        // Length of AppCert of application 
    DWORD   dwSPAppCertLen;         // Length of AppCert of SP
    BYTE*   pAppAppCert = NULL;     // Buffer to hold App AppCert
    BYTE*   pSPAppCert = NULL;      // Buffer to hold SP AppCert


#ifdef DUMP_FILE
    FILE *hFileDump = NULL;
#endif

    // Clear revocation status
    CoTaskMemFree( m_pwszRevocationURL );
    m_pwszRevocationURL = NULL;
    m_dwRevocationURLLen = 0;
    m_dwRevocationBitFlag = 0;

    pData = new BYTE[WMDM_TRANSFER_BUFFER_SIZE];
    if (!pData)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

	g_pSPs[m_wSPIndex]->GetSCClient(&pSPClient);
	if (!pSPClient)
	{
		hr = E_FAIL;
		goto exit;
	}

    dwVersion = GetVersion();
    if (dwVersion < 0x80000000)
    {
        hFile = CreateFileW(pwszFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }
    else
    {
        hFile = CreateFileA(W2A(pwszFileName), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    }

    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    // If we are reporting progress then we need to tell the app how many ticks we think there will be
    qwFileSizeSource = (ULONGLONG)GetFileSize(hFile, NULL);
    if (pProgress)
    {
		fBeginCalled = TRUE;
        hr = pProgress->Begin((DWORD)qwFileSizeSource);
        if (FAILED(hr))
        {
            goto exit;
        }
    }

    CORg( m_pStorage->GetStorageGlobals(&pStgGlobals) );

    if( g_pSCPs == NULL )
    {
        CMediaDevMgr::LoadSCPs();
    }

    // Find the right scp
    for( wCurSCP = 0; wCurSCP < g_wSCPCount; wCurSCP++ )
    {
        hr = g_pSCPs[wCurSCP]->hrGetInterface(&pSecureAuth);
        if (FAILED(hr))
        {
            goto exit;
        }

		g_pSCPs[wCurSCP]->GetSCClient(&pSCClient);
		if (!pSCClient)
		{
			hr = E_FAIL;
			goto exit;
		}

        CORg( pSecureAuth->GetSecureQuery(&pSecQuery) );

        pSecureAuth->Release();
        pSecureAuth = NULL;

		// GetDataDemands has no incoming MAC so lets clear the buffer.
        CORg( pSecQuery->GetDataDemands(&fuFlags, &dwRightsSize, &dwExSize, &dwMDSize, abMAC));

		// Verify MAC returned by GetDataDemands
		CORg( pSCClient->MACInit(&hMAC) );
		CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&fuFlags), sizeof(fuFlags)));
		CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwRightsSize), sizeof(dwRightsSize)));
		CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwExSize), sizeof(dwExSize)) );
		CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwMDSize), sizeof(dwMDSize)) );
		CORg( pSCClient->MACFinal(hMAC, abMACVerify) );

		if (memcmp(abMACVerify, abMAC, WMDM_MAC_LENGTH) != 0)
		{
			hr = WMDM_E_MAC_CHECK_FAILED;
			goto exit;
		}

        if (!(fuFlags & (WMDM_SCP_EXAMINE_DATA | WMDM_SCP_DECIDE_DATA | WMDM_SCP_EXAMINE_EXTENSION)))
        {
            continue;
        }

		// If the SCP asked for the file extension then get it from the File
		if (fuFlags & WMDM_SCP_EXAMINE_EXTENSION)
		{
			// Only get the file extension once
			if (!pwszFileExt)
			{
				pwszFileExt = new WCHAR[64];
				if (!pwszFileExt)
				{
					hr = E_OUTOFMEMORY;
					goto exit;
				}

				if (NULL != wcschr(pwszFileName, L'.'))
				{
					wcsncpy(pwszFileExt, (LPWSTR)(wcsrchr(pwszFileName, L'.') + 1), 64);
				}
				else
				{
					SAFE_ARRAY_DELETE(pwszFileExt);
				}
			}
		}

        if (dwBufferSize < (dwExSize>dwMDSize?dwExSize:dwMDSize))
        {
            SAFE_ARRAY_DELETE(pData);
            dwBufferSize = dwExSize>dwMDSize?dwExSize:dwMDSize;
	        pData = new BYTE[dwBufferSize];
	        if (!pData)
	        {
                hr = E_OUTOFMEMORY;
		        goto exit;
	        }
        }

        // ExamineData
        hr = WMDM_E_MOREDATA;
        while (hr == WMDM_E_MOREDATA)
        {
            fRetVal = ReadFile(hFile, pData, dwBufferSize, &dwBytesRead, NULL);
            if (!fRetVal)
            {
                hr = E_FAIL;
                goto exit;
            }

			// Create the MAC to send to ExamineData
			CORg( pSCClient->MACInit(&hMAC) );
			fuTempFlags = WMDM_SCP_EXAMINE_DATA;
			CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&fuTempFlags), sizeof(fuTempFlags)));

			if (pwszFileExt)
			{
				CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(pwszFileExt), 2 * wcslen(pwszFileExt)));	
			}
			CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(pData), dwBytesRead) );
			CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwBytesRead), sizeof(dwBytesRead)));
			CORg( pSCClient->MACFinal(hMAC, abMAC) );

			// Encrypt the pData Parameter
			CORg( pSCClient->EncryptParam(pData, dwBytesRead));
            CORg( pSecQuery->ExamineData(fuTempFlags, pwszFileExt, pData, dwBytesRead, abMAC));
        }

        if (0xffffffff == SetFilePointer(hFile, 0, NULL, FILE_BEGIN))
        {
            goto exit;
        }
        
        // MakeDecision
        if (hr == S_OK)
        {   
            nDecideFlags = WMDM_SCP_DECIDE_DATA;
            if(fuMode & WMDM_MODE_TRANSFER_UNPROTECTED)
            {
                nDecideFlags |= WMDM_SCP_UNPROTECTED_OUTPUT;
            }
            if(fuMode & WMDM_MODE_TRANSFER_PROTECTED)
            {
                nDecideFlags |= WMDM_SCP_PROTECTED_OUTPUT;
            }

            // If the SCP supports ISCPSecQuery2 use it as a first choice
            hr = pSecQuery->QueryInterface( IID_ISCPSecureQuery2, (void**)(&pSecQuery2) );

			CORg( g_pAppSCServer->GetAppSec(NULL, &dwAPPAppSec));
			CORg( pSPClient->GetAppSec(NULL, &dwSPAppSec));

            // Appsec = min(appsec app, appsec SP )
			dwAppSec = dwSPAppSec>dwAPPAppSec?dwAPPAppSec:dwSPAppSec;

            hr = WMDM_E_MOREDATA;
            while (hr == WMDM_E_MOREDATA)
            {
                fRetVal = ReadFile(hFile, pData, dwBufferSize, &dwBytesRead, NULL);
                if (!fRetVal)
                {
                    hr = E_FAIL;
                    goto exit;
                }

				CORg( pSPClient->GetSessionKey((BYTE*)abSPSessionKey));
				CORg( pSCClient->MACInit(&hMAC) );
				CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&nDecideFlags), sizeof(nDecideFlags)));
				CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(pData), dwBytesRead) );
				CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwBytesRead), sizeof(dwBytesRead)) );
				CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwAppSec), sizeof(dwAppSec)));
				CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(abSPSessionKey), dwSessionKeyLen));
				CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwSessionKeyLen), sizeof(dwSessionKeyLen)));

                // Encrypt the pData Parameter
				CORg( pSCClient->EncryptParam(pData, dwBytesRead) );
				CORg( pSCClient->EncryptParam((BYTE*)abSPSessionKey, dwSessionKeyLen));

                // Use MakeDecision2 and pass in AppCerts of App, SP to check for revocation
                if( pSecQuery2 && (hr == S_OK) )
                {                   
                    // Get the AppCert of the App
                    g_pAppSCServer->GetRemoteAppCert( NULL, &dwAppAppCertLen );
                    CFRg( dwAppAppCertLen != NULL );
                    SAFE_ARRAY_DELETE(pAppAppCert);
                    pAppAppCert = new BYTE[dwAppAppCertLen];
                    CPRg( pAppAppCert );
                    g_pAppSCServer->GetRemoteAppCert( pAppAppCert, &dwAppAppCertLen );

                    // Get the AppCert of the SP
                    pSPClient->GetRemoteAppCert( NULL, &dwSPAppCertLen );
                    CFRg( dwSPAppCertLen != NULL )
                    SAFE_ARRAY_DELETE(pSPAppCert);
                    pSPAppCert = new BYTE[dwSPAppCertLen];
                    CPRg( pSPAppCert );
                    pSPClient->GetRemoteAppCert( pSPAppCert, &dwSPAppCertLen );

                    // Update mac:ing with the AppCert parameters
				    CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(pAppAppCert), dwAppAppCertLen));
				    CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwAppAppCertLen), sizeof(dwAppAppCertLen)));
				    CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(pSPAppCert), dwSPAppCertLen ));
				    CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwSPAppCertLen ), sizeof(dwSPAppCertLen)));
                    
				    CORg( pSCClient->MACFinal(hMAC, abMAC));
               
                    // Encrypt the 2 AppCerts 
			        CORg( pSCClient->EncryptParam(pAppAppCert, dwAppAppCertLen));
			        CORg( pSCClient->EncryptParam(pSPAppCert, dwSPAppCertLen) );
                    
                    qwFileSizeDest  = qwFileSizeSource;
                    hr = pSecQuery2->MakeDecision2( nDecideFlags, 
					                                 pData, 
											         dwBytesRead, 
											         dwAppSec, 
											         (BYTE*)abSPSessionKey,
											         dwSessionKeyLen,
											         pStgGlobals, 
                                                     pAppAppCert, dwAppAppCertLen,  // AppCert App
                                                     pSPAppCert, dwSPAppCertLen,    // AppCert SP
                                                     &m_pwszRevocationURL,          // LPSTR - revocation update URL
                                                     &m_dwRevocationURLLen,         // Length of URL string passed in
                                                     &m_dwRevocationBitFlag,        // revocation component bitflag
                                                     &qwFileSizeDest, pUnknown,         // File size, App IUnknown
											         &pSecExch,                     // Secure exchange
											         abMAC);
                    if( hr == WMDM_E_REVOKED )
                    {
                        // If the SP is revoked give it a chance to specify an URL.
                        UpdateRevocationURL( &m_pwszRevocationURL, 
                                             &m_dwRevocationURLLen, 
                                             &m_dwRevocationBitFlag );
                    }
                    CORg(hr);
 
                }
                else
                {
				    CORg( pSCClient->MACFinal(hMAC, abMAC));
                    qwFileSizeDest = 0;

                    // Use old MakeDecision call without AppCert revocation check
                    CORg( pSecQuery->MakeDecision(nDecideFlags, 
					                             pData, 
											     dwBytesRead, 
											     dwAppSec, 
											     (BYTE*)abSPSessionKey,
											     dwSessionKeyLen,
											     pStgGlobals, 
											     &pSecExch, 
											     abMAC) );
                }
            }

            if (0xffffffff == SetFilePointer(hFile, 0, NULL, FILE_BEGIN))
            {
                hr = E_FAIL;
                goto exit;
            }

            if (hr == S_OK)
            {
                fUseSCP = TRUE;
                if( pSecExch == NULL ) CORg(E_FAIL);
                break;
            }
            else
            {
                // If the SCP returns S_FALSE then we don't have rights to do the transfer
                hr = WMDM_E_NORIGHTS;
                goto exit;
            }
        }

        SAFE_RELEASE( pSecQuery );
        SAFE_RELEASE( pSecQuery2 );

    }

    // If this is only a query then we should just return without copying the file
    if (fQuery)
    {
        hr = S_OK;
        goto exit;
    }

    if (!fUseSCP)
    {
        CORg( pStgGlobals->GetDevice(&pDevice) );
        CORg( pDevice->GetType(&dwType) );

        // Do not allow content without and SCP to be transferred to an SDMI only device.
        if ((dwType & WMDM_DEVICE_TYPE_SDMI) && (!(dwType & WMDM_DEVICE_TYPE_NONSDMI)))
        {
            hr = WMDM_E_NORIGHTS;
            goto exit;
        }
        qwFileSizeDest = qwFileSizeSource;
    }

    // Create the storage we are going to write to.
    {
        hr = m_pStorage->QueryInterface( __uuidof(IMDSPStorage2), reinterpret_cast<void**>(&pStorage2) );
        if( SUCCEEDED(hr) && pStorage2 )
        {
            hr = pStorage2->CreateStorage2( uNewStorageMode, 0, NULL, NULL, wszNewStorageName, qwFileSizeDest, &pNewSPStorage);
            if( hr == E_NOTIMPL )
            {
                CORg( m_pStorage->CreateStorage(uNewStorageMode, NULL, wszNewStorageName, &pNewSPStorage) );
            }
            else CORg( hr );
        }
        else CORg( m_pStorage->CreateStorage(uNewStorageMode, NULL, wszNewStorageName, &pNewSPStorage) );
    }

    CORg( CComObject<CWMDMStorage>::CreateInstance(&pNewWMDMStorage) );
    hr = pNewWMDMStorage->QueryInterface(IID_IWMDMStorage, reinterpret_cast<void**>(&pNewIWMDMStorage));
    if (FAILED(hr))
    {
        delete pNewWMDMStorage;
        goto exit;
    }

    pNewWMDMStorage->SetContainedPointer(pNewSPStorage, m_wSPIndex);


    CORg( pNewSPStorage->QueryInterface(IID_IMDSPObject, reinterpret_cast<void**>(&pObject)) );
    CORg( pObject->Open(MDSP_WRITE) );

    fOpen = TRUE;

    fUsedSCP = fUseSCP;

#ifdef DUMP_FILE 
    hFileDump = fopen("\\Write.wma", "wb");
#endif


    // Copy file
    while( !bEOF || bFlushSCP )
    {
        dwBytesWrite = 0;
        dwBytesRead = 0;
        fuReadyFlags = 0;

        // Read data from file
        if( !bEOF && !bFlushSCP ) 
        {
            dwBytesRead = WMDM_TRANSFER_BUFFER_SIZE;

            fRetVal = ReadFile(hFile, pData, WMDM_TRANSFER_BUFFER_SIZE, &dwBytesRead, NULL);
            if( dwBytesRead == 0 ) 
            {
                break;
            }
            dwBytesWrite = dwBytesRead;
            if (!fRetVal)
            {
                hr = E_FAIL;
                goto exit;
            }
            bEOF = (WMDM_TRANSFER_BUFFER_SIZE != dwBytesRead);
            bFlushSCP = bEOF && fUseSCP;

            // Pass file-data to the SCP
            if( fUseSCP )
            {
			    // Calculate the MAC to send to the SCP
			    CORg( pSCClient->MACInit(&hMAC) );
			    CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(pData), dwBytesRead) );
			    CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwBytesRead), sizeof(dwBytesRead)) );
			    CORg( pSCClient->MACFinal(hMAC, abMAC) );
			    
			    // Encrypt the pData Parameter
			    CORg( pSCClient->EncryptParam(pData, dwBytesRead) );

                CORg( pSecExch->TransferContainerData(pData, dwBytesRead, &fuReadyFlags, abMAC) );

			    // Verify the MAC on the return parameters
			    CORg( pSCClient->MACInit(&hMAC) );
			    CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&fuReadyFlags), sizeof(fuReadyFlags)));
			    CORg( pSCClient->MACFinal(hMAC, abMACVerify) );

			    if (memcmp(abMACVerify, abMAC, WMDM_MAC_LENGTH) != 0)
			    {
				    hr = WMDM_E_MAC_CHECK_FAILED;
				    goto exit;
			    }

                // Are we done passing data to the SCP?
                bFlushSCP = ((fuReadyFlags & WMDM_SCP_TRANSFER_OBJECTDATA) &&
                             (fuReadyFlags & WMDM_SCP_NO_MORE_CHANGES))
                            ? TRUE : FALSE;

                // The SCP was not interesed in this data, use original data from the file.
                if( (fuReadyFlags & WMDM_SCP_NO_MORE_CHANGES) && 
                    !(fuReadyFlags & WMDM_SCP_TRANSFER_OBJECTDATA) )
                {
			        // Decrypt the original file data 
			        CORg( pSCClient->DecryptParam(pData, dwBytesRead) );
                    fUseSCP = FALSE;
                }
            }
        }

        // Get data back from SCP
        if( fUseSCP && (( fuReadyFlags & WMDM_SCP_TRANSFER_OBJECTDATA) || bFlushSCP ))
        {
            dwBytesWrite = dwBufferSize;

			// Calculate the MAC to send to the SCP
			CORg( pSCClient->MACInit(&hMAC) );
			CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwBytesWrite), sizeof(dwBytesWrite)));
			CORg( pSCClient->MACFinal(hMAC, abMAC) );

            CORg( pSecExch->ObjectData(pData, &dwBytesWrite, abMAC) );
            if(dwBytesWrite == 0)
            {
                if( bFlushSCP )
                {
                    bFlushSCP = FALSE;
                    fUseSCP = FALSE;    // Done using the SCP
                }
                continue;
            }

			// Decrypt the pData Parameter
			CORg( pSCClient->DecryptParam(pData, dwBytesWrite) );

			// Verify the MAC on the return parameters
			CORg( pSCClient->MACInit(&hMAC) );
			CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(pData), dwBytesWrite) );
			CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwBytesWrite), sizeof(dwBytesWrite)));
			CORg( pSCClient->MACFinal(hMAC, abMACVerify) );

			if (memcmp(abMACVerify, abMAC, WMDM_MAC_LENGTH) != 0)
			{
				hr = WMDM_E_MAC_CHECK_FAILED;
				goto exit;
			}
        }

        // Write data to SP
        if ( ((!fUseSCP) || (fuReadyFlags & WMDM_SCP_TRANSFER_OBJECTDATA) || bFlushSCP ) 
            && dwBytesWrite > 0 )
        {
#ifdef DUMP_FILE
            fwrite(pData, sizeof(BYTE), dwBytesWrite, hFileDump);
#endif

            // Create MAC to send to SP
		    CORg( pSPClient->MACInit(&hMAC) );
		    CORg( pSPClient->MACUpdate(hMAC, (BYTE*)(pData), dwBytesWrite) );
		    CORg( pSPClient->MACUpdate(hMAC, (BYTE*)(&dwBytesWrite), sizeof(dwBytesWrite)));
		    CORg( pSPClient->MACFinal(hMAC, abMAC) );

		    CORg( pSPClient->EncryptParam(pData, dwBytesWrite) );

            CORg( pObject->Write(pData, &dwBytesWrite, abMAC) );

            if (pProgress)
            {
                dwTicks += dwBytesRead;
                hr = pProgress->Progress(dwTicks);
                if (FAILED(hr))
                {
                    goto exit;
                }
            }
        }
    } // Copy file

#ifdef DUMP_FILE
    fclose(hFileDump);
#endif

    // Close content file
    if (pObject && fOpen)
    {
        HRESULT hr2 = pObject->Close();
        hr = FAILED(hr)?hr:hr2;
        fOpen = FALSE;
    }

    // SCP::TransferComplete()
    if (fUsedSCP)
    {
        CORg( pSecExch->TransferComplete() );
    }

Error:
exit:
    if (pObject && fOpen)
    {
        HRESULT hr2 = pObject->Close();
        hr = FAILED(hr)?hr:hr2;
        fOpen = FALSE;
    }

    // Delete new storage file if the copy operation failed.
    if( FAILED(hr) && pObject )
    {
        pObject->Delete(0, NULL);
    }

    if (pProgress)
	{
		if (!fBeginCalled)
		{
			pProgress->Begin(1);
		}
//		pProgress->End();      // This is done by the caller
	}
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    SAFE_ARRAY_DELETE(pAppAppCert);
    SAFE_ARRAY_DELETE(pSPAppCert);
    SAFE_ARRAY_DELETE(pData);
    SAFE_ARRAY_DELETE(pwszFileExt);
    SAFE_RELEASE(pDevice);
    SAFE_RELEASE(pStgGlobals);
    SAFE_RELEASE(pSecureAuth);
    SAFE_RELEASE(pSecQuery);
    SAFE_RELEASE(pSecQuery2);
    SAFE_RELEASE(pStorage2);
    SAFE_RELEASE(pSecExch);
    SAFE_RELEASE(pObject);
    SAFE_RELEASE(pNewSPStorage);

    hrLogDWORD("CWMDMStorage::hrCopyToStorageFromFile returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorage::hrCopyToOperationFromStorage(IWMDMOperation *pOperation, IWMDMProgress *pProgress, IMDSPObject *pObject)
{
    //USES_CONVERSION;
    HRESULT hr;
    BYTE *pData = NULL;
    DWORD dwBytes;
    DWORD dwTotalBytes = 0;
	HMAC hMAC;
	BYTE abMAC[WMDM_MAC_LENGTH];
	BYTE abMACVerify[WMDM_MAC_LENGTH];
	CSecureChannelClient *pSPClient = NULL;
    BOOL fOpen = FALSE;

    CARg(pOperation);
    CARg(pObject);

    pData = new BYTE[WMDM_TRANSFER_BUFFER_SIZE];
    CPRg(pData);

    CORg( pObject->Open(MDSP_READ) );

    fOpen = TRUE;

    CORg( pOperation->BeginRead() );

	g_pSPs[m_wSPIndex]->GetSCClient(&pSPClient);
	if (!pSPClient)
	{
		CORg( E_FAIL );
	}

    // Copy file
    dwBytes = WMDM_TRANSFER_BUFFER_SIZE;
    while ((WMDM_TRANSFER_BUFFER_SIZE == dwBytes))
    {
        dwBytes = WMDM_TRANSFER_BUFFER_SIZE;
        CORg( pObject->Read(pData, &dwBytes, abMAC) );

        CORg( pSPClient->DecryptParam(pData, dwBytes) );

		// Verify MAC returned by Read on the SP
		CORg( pSPClient->MACInit(&hMAC) );
		CORg( pSPClient->MACUpdate(hMAC, (BYTE*)(pData), dwBytes) );
		CORg( pSPClient->MACUpdate(hMAC, (BYTE*)(&dwBytes), sizeof(dwBytes)));
		CORg( pSPClient->MACFinal(hMAC, abMACVerify) );

		if (memcmp(abMACVerify, abMAC, WMDM_MAC_LENGTH) != 0)
		{
			hr = WMDM_E_MAC_CHECK_FAILED;
			goto exit;
		}

        // Calculate MAC to hand to operation
		CORg( g_pAppSCServer->MACInit(&hMAC) );
		CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pData), dwBytes) );
		CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(&dwBytes), sizeof(dwBytes)) );
		CORg( g_pAppSCServer->MACFinal(hMAC, abMAC) );

		// Encrypt the data parameter
		CORg( g_pAppSCServer->EncryptParam(pData, dwBytes) );
        CORg( pOperation->TransferObjectData(pData, &dwBytes, abMAC) );

        dwTotalBytes+=dwBytes;
        if (pProgress)
        {
            CORg( pProgress->Progress(dwTotalBytes) );
        }
    }

Error:
exit:
    HRESULT hr2;
    
    hr2 = pOperation->End(&hr, NULL);
    hr = FAILED(hr)?hr:hr2;

    if (pObject && fOpen)
    {
        hr2 = pObject->Close();
        hr = FAILED(hr)?hr:hr2;
    }

    SAFE_ARRAY_DELETE(pData);

    hrLogDWORD("CWMDMStorage::hrCopyToOperationFromStorage returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorage::hrCopyToStorageFromOperation(UINT fuMode, IWMDMOperation *pOperation, 
                                                   UINT uNewStorageMode, LPWCH wszNewStorageName,
                                                   IWMDMStorage*& pNewIWMDMStorage,
                                                   IWMDMProgress *pProgress, 
                                                   IUnknown*    pUnknown, BOOL fQuery)
{
    HRESULT hr;
    BYTE *pData = NULL;
    CComObject<CWMDMStorage> *pNewWMDMStorage = NULL;
    IMDSPObject *pObject = NULL;
    IMDSPStorage  *pNewSPStorage = NULL;
    IMDSPStorage2 *pStorage2 = NULL;
    IMDSPStorageGlobals *pStgGlobals = NULL;
    IMDSPDevice *pDevice = NULL;
    ISCPSecureAuthenticate *pSecureAuth = NULL;
    ISCPSecureQuery *pSecQuery = NULL;
    ISCPSecureQuery2 *pSecQuery2 = NULL;
    ISCPSecureExchange *pSecExch = NULL;
    DWORD dwRightsSize;
    DWORD dwExSize;
    DWORD dwMDSize;
    UINT fuFlags;
    UINT fuReadyFlags;
    WORD wCurSCP = 0;
    BOOL fUseSCP = FALSE;       // Should data be passed throw an SCP?
    BOOL fUsedSCP = FALSE;      // Was an SCP used to do the file transfer?
    DWORD dwBufferSize = 0;
    DWORD dwBytesRead;
    DWORD dwBytesWrite;
    DWORD dwType;
    ULONGLONG qwFileSizeSource;
    ULONGLONG qwFileSizeDest;
    UINT nDecideFlags;
    DWORD dwTicks = 0;
    DWORD dwBufferEnd = 0;
    BYTE *pTempData = NULL;
    DWORD dwBufferIncrement;
	CSecureChannelClient *pSCClient = NULL;
	CSecureChannelClient *pSPClient = NULL;
	DWORD dwAppSec;
	HMAC hMAC;
	BYTE abMAC[WMDM_MAC_LENGTH];
	BYTE abMACVerify[WMDM_MAC_LENGTH];
	UINT fuTempFlags;
	BOOL fBeginCalled = FALSE;
	DWORD dwSPAppSec;
	DWORD dwAPPAppSec;
	LPWSTR pwszFileExt = NULL;
	// LPWSTR pwszFileName = NULL;
	DWORD dwSessionKeyLen = SAC_SESSION_KEYLEN;
	BYTE abSPSessionKey[SAC_SESSION_KEYLEN];
    BOOL fOpen = FALSE; // Flag indicating if the IMDSPObject::Open has been called
    BOOL bEOF = FALSE;
    BOOL bFlushSCP = FALSE;
    DWORD   dwAppAppCertLen;        // Length of AppCert of application 
    DWORD   dwSPAppCertLen;         // Length of AppCert of SP
    BYTE*   pAppAppCert = NULL;     // Buffer to hold App AppCert
    BYTE*   pSPAppCert = NULL;      // Buffer to hold SP AppCert

    // Clear revocation 
    CoTaskMemFree( m_pwszRevocationURL );
    m_pwszRevocationURL = NULL;
    m_dwRevocationURLLen = 0;
    m_dwRevocationBitFlag = 0;


    CARg( pOperation );

	// pwszFileName = new WCHAR[512];
	// CPRg( pwszFileName );

	g_pSPs[m_wSPIndex]->GetSCClient(&pSPClient);
	if (!pSPClient)
	{
		CORg( E_FAIL );
	}

    CORg( m_pStorage->GetStorageGlobals(&pStgGlobals) );

    // Get size of source file
    DWORD dwFileSizeLow;
    DWORD dwFileSizeHigh;
    hr = pOperation->GetObjectTotalSize( &dwFileSizeLow, &dwFileSizeHigh );
    if( FAILED(hr) ) qwFileSizeSource = 0;
    else qwFileSizeSource = dwFileSizeLow + ((ULONGLONG)dwFileSizeHigh << 32);

    if( g_pSCPs == NULL )
    {
        CMediaDevMgr::LoadSCPs();
    }

    // Find the right SCP
    for( wCurSCP = 0; wCurSCP < g_wSCPCount; wCurSCP++ )
    {
        CORg( g_pSCPs[wCurSCP]->hrGetInterface(&pSecureAuth));
		g_pSCPs[wCurSCP]->GetSCClient(&pSCClient);
		if (!pSCClient)
		{
			CORg( E_FAIL );
		}

        CORg( pSecureAuth->GetSecureQuery(&pSecQuery) );

        pSecureAuth->Release();
        pSecureAuth = NULL;

        CORg( pSecQuery->GetDataDemands(&fuFlags, &dwRightsSize, &dwExSize, &dwMDSize, abMAC) );

		// Verify MAC returned by GetDataDemands
		CORg( pSCClient->MACInit(&hMAC) );
		CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&fuFlags), sizeof(fuFlags)) );
		CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwRightsSize), sizeof(dwRightsSize)) );
		CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwExSize), sizeof(dwExSize)) );
		CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwMDSize), sizeof(dwMDSize)) );
		CORg( pSCClient->MACFinal(hMAC, abMACVerify) );

		if (memcmp(abMACVerify, abMAC, WMDM_MAC_LENGTH) != 0)
		{
			hr = WMDM_E_MAC_CHECK_FAILED;
			goto exit;
		}

        if (!(fuFlags & (WMDM_SCP_EXAMINE_DATA | WMDM_SCP_DECIDE_DATA | WMDM_SCP_EXAMINE_EXTENSION)))
        {
            continue;
        }

		// If the SCP asked for the file extension then get it from the file name passed in
		if (fuFlags & WMDM_SCP_EXAMINE_EXTENSION)
		{
			// Only get the file extension once
			if (!pwszFileExt)
			{
				pwszFileExt = new WCHAR[64];
				CARg( pwszFileExt);

				if (NULL != wcschr(wszNewStorageName, L'.'))
				{
					wcsncpy(pwszFileExt, (LPWSTR)(wcsrchr(wszNewStorageName, L'.') + 1), 64);
				}
				else
				{
					SAFE_ARRAY_DELETE(pwszFileExt);
				}
			}
		}

        if (dwBufferSize < (dwExSize>dwMDSize?dwExSize:dwMDSize))
        {
            SAFE_ARRAY_DELETE(pData);
            dwBufferSize = dwExSize>dwMDSize?dwExSize:dwMDSize;
	        pData = new BYTE[dwBufferSize];
	        CARg( pData );
        }

        // ExamineData
        hr = WMDM_E_MOREDATA;
        dwBufferIncrement = dwBufferSize;
        while (hr == WMDM_E_MOREDATA)
        {
            dwBytesRead = dwBufferSize - dwBufferEnd;

			// Calculate MAC to send to TransferObjectData
			CORg( g_pAppSCServer->MACInit(&hMAC) );
			CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pData + dwBufferEnd), dwBytesRead) );
			CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(&dwBytesRead), sizeof(dwBytesRead)) );
			CORg( g_pAppSCServer->MACFinal(hMAC, abMAC) );

			// Encrypt the data parameter
			CORg( g_pAppSCServer->EncryptParam(pData + dwBufferEnd, dwBytesRead) );
            CORg( pOperation->TransferObjectData((BYTE *)(pData + dwBufferEnd), &dwBytesRead, abMAC) );

			if (dwBytesRead == 0)
			{
				// BUGBUG: Do we really want to return E_FAIL here?

				// If they app returns S_FALSE then there is no more data to transfer
				// Since the SCP couldn't decide yet we must fail.
				hr = E_FAIL;
				break;
			}

			// Decrypt the data parameter
			CORg( g_pAppSCServer->DecryptParam(pData + dwBufferEnd, dwBytesRead) );
			CORg( g_pAppSCServer->MACInit(&hMAC) );
			CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pData + dwBufferEnd), dwBytesRead) );
			CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(&dwBytesRead), sizeof(dwBytesRead)) );
			CORg( g_pAppSCServer->MACFinal(hMAC, abMACVerify) );

			if (memcmp(abMACVerify, abMAC, WMDM_MAC_LENGTH) != 0)
			{
				hr = WMDM_E_MAC_CHECK_FAILED;
				goto exit;
			}

			// Create the MAC to send to ExamineData
			CORg( pSCClient->MACInit(&hMAC) );

			fuTempFlags = WMDM_SCP_EXAMINE_DATA;
			CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&fuTempFlags), sizeof(fuTempFlags)) );

            if (pwszFileExt)
			{
				CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(pwszFileExt), 2 * wcslen(pwszFileExt)) );		
			}
			CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(pData + dwBufferEnd), dwBytesRead) );
			CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwBytesRead), sizeof(dwBytesRead)) );
			CORg( pSCClient->MACFinal(hMAC, abMAC) );

			// Encrypt the pData Parameter
			CORg( pSCClient->EncryptParam(pData + dwBufferEnd, dwBytesRead) );
            CORg( pSecQuery->ExamineData(fuTempFlags, pwszFileExt, (BYTE *)(pData + dwBufferEnd), dwBytesRead, abMAC) );

			// Decrypt the data parameter
			pSCClient->DecryptParam(pData + dwBufferEnd, dwBytesRead);

            if (hr == WMDM_E_MOREDATA)
            {
                dwBufferSize += dwBufferIncrement;

                pTempData = new BYTE[dwBufferSize];
                CARg( pTempData );

                dwBufferEnd += dwBytesRead;
                memcpy(pTempData, pData, dwBufferEnd);

                SAFE_ARRAY_DELETE(pData);
                pData = pTempData;
                pTempData = NULL;
            }
        }

        // MakeDecision
        if (hr == S_OK)
        {   
            if (fuMode & WMDM_MODE_TRANSFER_UNPROTECTED)
            {
                nDecideFlags = WMDM_SCP_DECIDE_DATA | WMDM_SCP_UNPROTECTED_OUTPUT;
            }
            else
            {
                nDecideFlags = WMDM_SCP_DECIDE_DATA | WMDM_SCP_PROTECTED_OUTPUT;
            }

            // If the SCP supports ISCPSecQuery2 use it as a first choice
            hr = pSecQuery->QueryInterface( IID_ISCPSecureQuery2, (void**)(&pSecQuery2) );

			CORg( g_pAppSCServer->GetAppSec(NULL, &dwAPPAppSec) );
			CORg( pSPClient->GetAppSec(NULL, &dwSPAppSec) );

            // Appsec = min(appsec app, appsec SP )
			dwAppSec = dwSPAppSec>dwAPPAppSec?dwAPPAppSec:dwSPAppSec;

            hr = WMDM_E_MOREDATA;
            dwBytesRead += dwBufferEnd;
            dwBufferEnd = 0;
            while (hr == WMDM_E_MOREDATA)
            {
				CORg( pSPClient->GetSessionKey((BYTE*)abSPSessionKey) );
				CORg( pSCClient->MACInit(&hMAC) );
				CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&nDecideFlags), sizeof(nDecideFlags)) );
				CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(pData + dwBufferEnd), dwBytesRead) );
				CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwBytesRead), sizeof(dwBytesRead)) );
				CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwAppSec), sizeof(dwAppSec)) );
				CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(abSPSessionKey), dwSessionKeyLen) );
				CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwSessionKeyLen), sizeof(dwSessionKeyLen)) );

				// Encrypt the pData Parameter
				CORg( pSCClient->EncryptParam(pData + dwBufferEnd, dwBytesRead) );
				CORg( pSCClient->EncryptParam((BYTE*)abSPSessionKey, dwSessionKeyLen) );


                // Use MakeDecision2 and pass in AppCerts of App, SP to check for revocation
                if( pSecQuery2 )
                {
                    // Get the AppCert of the App
                    g_pAppSCServer->GetRemoteAppCert( NULL, &dwAppAppCertLen );
                    CFRg( dwAppAppCertLen != NULL );
                    SAFE_ARRAY_DELETE(pAppAppCert);
                    pAppAppCert = new BYTE[dwAppAppCertLen];
                    CPRg( pAppAppCert );
                    g_pAppSCServer->GetRemoteAppCert( pAppAppCert, &dwAppAppCertLen );

                    // Get the AppCert of the SP
                    pSPClient->GetRemoteAppCert( NULL, &dwSPAppCertLen );
                    CFRg( dwSPAppCertLen != NULL )
                    SAFE_ARRAY_DELETE(pSPAppCert);
                    pSPAppCert = new BYTE[dwSPAppCertLen];
                    CPRg( pSPAppCert );
                    pSPClient->GetRemoteAppCert( pSPAppCert, &dwSPAppCertLen );

                    // Update mac:ing with the AppCert parameters
				    CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(pAppAppCert), dwAppAppCertLen));
				    CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwAppAppCertLen), sizeof(dwAppAppCertLen)));
				    CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(pSPAppCert), dwSPAppCertLen ));
				    CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwSPAppCertLen ), sizeof(dwSPAppCertLen)));
                    
				    CORg( pSCClient->MACFinal(hMAC, abMAC));
               
                    // Encrypt the 2 AppCerts 
			        CORg( pSCClient->EncryptParam(pAppAppCert, dwAppAppCertLen));
			        CORg( pSCClient->EncryptParam(pSPAppCert, dwSPAppCertLen) );

                    qwFileSizeDest = qwFileSizeSource;
                    hr = pSecQuery2->MakeDecision2( nDecideFlags, 
					                                 pData, 
											         dwBytesRead, 
											         dwAppSec, 
											         (BYTE*)abSPSessionKey,
											         dwSessionKeyLen,
											         pStgGlobals, 
                                                     pAppAppCert, dwAppAppCertLen,  // AppCert App
                                                     pSPAppCert, dwSPAppCertLen,    // AppCert SP
                                                     &m_pwszRevocationURL,          // String - revocation update URL
                                                     &m_dwRevocationURLLen,         // Length of URL string passed in
                                                     &m_dwRevocationBitFlag,        // revocatoin component bitflag
                                                     &qwFileSizeDest, pUnknown,
											         &pSecExch,                     
											         abMAC);
                    if( hr == WMDM_E_REVOKED )
                    {
                        // If the SP is revoked give it a chance to specify an URL.
                        UpdateRevocationURL( &m_pwszRevocationURL, 
                                             &m_dwRevocationURLLen, 
                                             &m_dwRevocationBitFlag );
                    }
                    CORg(hr);
 
                }
                else
                {
                    // If this SCP does not support the new ISCPSecureQuery2 interface use the old MakeDecision
				    CORg( pSCClient->MACFinal(hMAC, abMAC));
                    qwFileSizeDest = 0;
                               
                    CORg( pSecQuery->MakeDecision(nDecideFlags, 
					                             (BYTE *)(pData + dwBufferEnd), 
											     dwBytesRead, 
											     dwAppSec, 
											     (BYTE*)abSPSessionKey,
											     dwSessionKeyLen,
											     pStgGlobals, 
											     &pSecExch, 
											     abMAC) );
                }

				// Decrypt the data parameter
				CORg( pSCClient->DecryptParam(pData + dwBufferEnd, dwBytesRead) );

                // SCP needs more data for MakeDecision
                if (hr == WMDM_E_MOREDATA)
                {
                    dwBufferSize += dwBufferIncrement;

                    pTempData = new BYTE[dwBufferSize];
                    CARg( pTempData );

                    dwBufferEnd += dwBytesRead;
                    memcpy(pTempData, pData, dwBufferEnd);

                    SAFE_ARRAY_DELETE(pData);
                    pData = pTempData;
                    pTempData = NULL;

                    dwBytesRead = dwBufferSize - dwBufferEnd;

					// Calculate MAC to send to TransferObjectData
					CORg( g_pAppSCServer->MACInit(&hMAC) );
					CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pData + dwBufferEnd), dwBytesRead) );
					CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(&dwBytesRead), sizeof(dwBytesRead)) );
					CORg( g_pAppSCServer->MACFinal(hMAC, abMAC) );

					// Encrypt the data parameter
					CORg( g_pAppSCServer->EncryptParam(pData + dwBufferEnd, dwBytesRead) );
                    CORg( pOperation->TransferObjectData((BYTE *)(pData + dwBufferEnd), &dwBytesRead, abMAC) );

                    if (dwBytesRead == 0)
					{
						// BUGBUG: Do we really want to return E_FAIL here?

						// If they app returns S_FALSE then there is no more data to transfer
						// Since the SCP couldn't decide yet we must fail.
						hr = E_FAIL;
						break;
					}

					// Decrypt the data parameter
					CORg( g_pAppSCServer->DecryptParam(pData + dwBufferEnd, dwBytesRead) );
					CORg( g_pAppSCServer->MACInit(&hMAC) );
					CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pData + dwBufferEnd), dwBytesRead) );
					CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(&dwBytesRead), sizeof(dwBytesRead)) );
					CORg( g_pAppSCServer->MACFinal(hMAC, abMACVerify) );

					if (memcmp(abMACVerify, abMAC, WMDM_MAC_LENGTH) != 0)
					{
						hr = WMDM_E_MAC_CHECK_FAILED;
						goto exit;
					}

                }
            }
    
            dwBytesRead += dwBufferEnd;

            if (hr == S_OK)
            {
                fUseSCP = TRUE;
                if( pSecExch == NULL ) CORg(E_FAIL);
                break;
            }
            else
            {
                // If the SCP returns S_FALSE then we don't have rights to do the transfer
                hr = WMDM_E_NORIGHTS;
                goto exit;
            }
        }

        pSecQuery->Release();
        pSecQuery = NULL;
    }

    if (!fUseSCP)
    {
        CORg( pStgGlobals->GetDevice(&pDevice) );
        CORg( pDevice->GetType(&dwType) );

        // Do not allow content without and SCP to be transferred to an SDMI only device.
        if ((dwType & WMDM_DEVICE_TYPE_SDMI) && (!(dwType & WMDM_DEVICE_TYPE_NONSDMI)))
        {
            hr = WMDM_E_NORIGHTS;
            goto exit;
        }
        qwFileSizeDest = qwFileSizeSource;
    }

    // Create the storage to write to.
    {
        hr = m_pStorage->QueryInterface( __uuidof(IMDSPStorage2), reinterpret_cast<void**>(&pStorage2) );
        if( SUCCEEDED(hr) && pStorage2 )
        {
            hr = pStorage2->CreateStorage2( uNewStorageMode, 0, NULL, NULL, wszNewStorageName, qwFileSizeDest, &pNewSPStorage);
            if( hr == E_NOTIMPL )
            {
                CORg( m_pStorage->CreateStorage(uNewStorageMode, NULL, wszNewStorageName, &pNewSPStorage) );
            }
            else CORg( hr );
        }
        else CORg( m_pStorage->CreateStorage(uNewStorageMode, NULL, wszNewStorageName, &pNewSPStorage) );
    }
    

    CORg( CComObject<CWMDMStorage>::CreateInstance(&pNewWMDMStorage) );
    hr = pNewWMDMStorage->QueryInterface(IID_IWMDMStorage, reinterpret_cast<void**>(&pNewIWMDMStorage));
    if (FAILED(hr))
    {
        delete pNewWMDMStorage;
        goto exit;
    }

    pNewWMDMStorage->SetContainedPointer(pNewSPStorage, m_wSPIndex);
    CORg( pNewSPStorage->QueryInterface(IID_IMDSPObject, reinterpret_cast<void **>(&pObject)) );
    CORg( pObject->Open(MDSP_WRITE) );
    fOpen = TRUE;

    // If we are reporting progress then we need to tell the app how many ticks we think there will be
    if (pProgress)
    {
		fBeginCalled = TRUE;
        CORg( pProgress->Begin((DWORD)qwFileSizeSource) );
    }

    fUsedSCP = fUseSCP;

    // Copy file
    while( !bEOF || bFlushSCP )
    {
        dwBytesWrite = dwBytesRead;
        fuReadyFlags = 0;

        // Pass file-data to the SCP
        if (fUseSCP && dwBytesRead > 0)
        {
			CORg( pSCClient->MACInit(&hMAC) );
			CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(pData), dwBytesRead) );
			CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwBytesRead), sizeof(dwBytesRead)) );
			CORg( pSCClient->MACFinal(hMAC, abMAC) );

			CORg( pSCClient->EncryptParam(pData, dwBytesRead) );
            CORg( pSecExch->TransferContainerData(pData, dwBytesRead, &fuReadyFlags, abMAC) );

			CORg( pSCClient->MACInit(&hMAC) );
			CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&fuReadyFlags), sizeof(fuReadyFlags)) );
			CORg( pSCClient->MACFinal(hMAC, abMACVerify) );

			if (memcmp(abMACVerify, abMAC, WMDM_MAC_LENGTH) != 0)
			{
				hr = WMDM_E_MAC_CHECK_FAILED;
				goto exit;
			}

            // Are we done passing data to the SCP?
            bFlushSCP = ((fuReadyFlags & WMDM_SCP_TRANSFER_OBJECTDATA) &&
                         (fuReadyFlags & WMDM_SCP_NO_MORE_CHANGES))
                        ? TRUE : FALSE;

            // The SCP was not interesed in this data, use original data from the file.
            if( (fuReadyFlags & WMDM_SCP_NO_MORE_CHANGES) && 
                !(fuReadyFlags & WMDM_SCP_TRANSFER_OBJECTDATA) )
            {
			    // Decrypt the original file data 
			    CORg( pSCClient->DecryptParam(pData, dwBytesRead) );
                fUseSCP = FALSE;
            }
        }

        // Get data back from SCP
        if( fUseSCP && (( fuReadyFlags & WMDM_SCP_TRANSFER_OBJECTDATA) || bFlushSCP ))
        {
            dwBytesWrite = dwBufferSize;

			// Calculate the MAC to send to the SCP
			CORg( pSCClient->MACInit(&hMAC) );
			CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwBytesWrite), sizeof(dwBytesWrite)) );
			CORg( pSCClient->MACFinal(hMAC, abMAC) );

			// Get and decrypt data from SCP
            CORg( pSecExch->ObjectData(pData, &dwBytesWrite, abMAC) );
            if(dwBytesWrite == 0)
            {
                if( bFlushSCP )
                {
                    bFlushSCP = FALSE;
                    fUseSCP = FALSE;    // Done using the SCP
                }
                continue;
            }

			// Decrypt the pData Parameter
			CORg( pSCClient->DecryptParam(pData, dwBytesWrite) );

			CORg( pSCClient->MACInit(&hMAC) );
			CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(pData), dwBytesWrite) );
			CORg( pSCClient->MACUpdate(hMAC, (BYTE*)(&dwBytesWrite), sizeof(dwBytesWrite)) );
			CORg( pSCClient->MACFinal(hMAC, abMACVerify) );

			if (memcmp(abMACVerify, abMAC, WMDM_MAC_LENGTH) != 0)
			{
				hr = WMDM_E_MAC_CHECK_FAILED;
				goto exit;
			}
        }

        // Write data to SP
        if ( ((!fUseSCP) || (fuReadyFlags & WMDM_SCP_TRANSFER_OBJECTDATA) || bFlushSCP ) 
            && dwBytesWrite > 0 )
        {
            // Create MAC to send to SP
	        CORg( pSPClient->MACInit(&hMAC) );
	        CORg( pSPClient->MACUpdate(hMAC, (BYTE*)(pData), dwBytesWrite) );
	        CORg( pSPClient->MACUpdate(hMAC, (BYTE*)(&dwBytesWrite), sizeof(dwBytesWrite)) );
	        CORg( pSPClient->MACFinal(hMAC, abMAC) );

	        CORg( pSPClient->EncryptParam(pData, dwBytesWrite) );

            CORg( pObject->Write(pData, &dwBytesWrite, abMAC) );

            if (pProgress)
            {
                dwTicks += dwBytesRead;
                CORg( pProgress->Progress(dwTicks) );
            }
        }
        // No valid file data to send to SCP.
        dwBytesRead = 0;  

        // Read new file data 
        if( !bEOF && !bFlushSCP ) 
        {
            dwBytesRead = dwBufferSize;

		    CORg( g_pAppSCServer->MACInit(&hMAC) );
		    CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pData), dwBytesRead) );
		    CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(&dwBytesRead), sizeof(dwBytesRead)) );
		    CORg( g_pAppSCServer->MACFinal(hMAC, abMAC) );

		    CORg( g_pAppSCServer->EncryptParam(pData, dwBytesRead) );
            CORg( pOperation->TransferObjectData(pData, &dwBytesRead, abMAC) );

            bEOF = (S_FALSE == hr) || (dwBytesRead == 0);
            bFlushSCP = bEOF && fUseSCP;

            if ((S_FALSE == hr) || (dwBytesRead == 0))
		    {
			    // If they app returns S_FALSE then there is no more data to transfer
			    hr = S_OK;
			    continue;
		    }

		    CORg( g_pAppSCServer->DecryptParam(pData, dwBytesRead) );

		    CORg( g_pAppSCServer->MACInit(&hMAC) );
		    CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pData), dwBytesRead) );
            CORg( g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(&dwBytesRead), sizeof(dwBytesRead)) );
		    CORg( g_pAppSCServer->MACFinal(hMAC, abMACVerify) );

		    if (memcmp(abMACVerify, abMAC, WMDM_MAC_LENGTH) != 0)
		    {
			    CORg( WMDM_E_MAC_CHECK_FAILED );
		    }
        }
    } // Copy file


    // Close content file
    if (pObject && fOpen)
    {
        HRESULT hr2 = pObject->Close();
        hr = FAILED(hr)?hr:hr2;
        fOpen = FALSE;
    }

    // SCP::TransferComplete()
    if (fUsedSCP)
    {
        CORg( pSecExch->TransferComplete() );
    }

Error:
exit:
    if (pObject && fOpen)
    {
        HRESULT hr2 = pObject->Close();
        hr = FAILED(hr)?hr:hr2;
    }

    // Delete new storage file if the copy operation failed.
    if( FAILED(hr) && pObject )
    {
        pObject->Delete(0, NULL);
    }

    if (pProgress)
	{
		if (!fBeginCalled)
		{
			pProgress->Begin(1);
		}
//		pProgress->End();           This is done by the caller
	}

    SAFE_ARRAY_DELETE(pAppAppCert);
    SAFE_ARRAY_DELETE(pSPAppCert);
    SAFE_ARRAY_DELETE(pTempData);
    SAFE_ARRAY_DELETE(pData);
    SAFE_ARRAY_DELETE(pwszFileExt);
    // SAFE_ARRAY_DELETE(pwszFileName);
    SAFE_RELEASE(pDevice);
    SAFE_RELEASE(pStorage2);
    SAFE_RELEASE(pStgGlobals);
    SAFE_RELEASE(pObject);
    SAFE_RELEASE(pSecureAuth);
    SAFE_RELEASE(pSecQuery);
    SAFE_RELEASE(pSecQuery2);
    SAFE_RELEASE(pSecExch);
    SAFE_RELEASE(pNewSPStorage);

    hrLogDWORD("CWMDMStorage::hrCopyToStorageFromOperation returned 0x%08lx", hr, hr);

    return hr;
}



HRESULT CWMDMStorage::hrCopyToFileFromStorage(LPWSTR pwszFileName, IWMDMProgress *pProgress, IMDSPObject *pObject)
{
    USES_CONVERSION;
    HRESULT hr;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    BYTE *pData = NULL;
    DWORD dwBytes;
    DWORD dwBytesWritten;
    DWORD dwTotalBytes = 0;
	HMAC hMAC;
	BYTE abMAC[WMDM_MAC_LENGTH];
	BYTE abMACVerify[WMDM_MAC_LENGTH];
	CSecureChannelClient *pSPClient = NULL;
    BOOL fOpen = FALSE;
    DWORD dwVersion;

    pData = new BYTE[WMDM_TRANSFER_BUFFER_SIZE];
    if (!pData)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    dwVersion = GetVersion();
    if (dwVersion < 0x80000000)
    {
        hFile = CreateFileW(pwszFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    }
    else
    {
        hFile = CreateFileA(W2A(pwszFileName), GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    }

    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    CORg( pObject->Open(MDSP_READ) );

    fOpen = TRUE;

	g_pSPs[m_wSPIndex]->GetSCClient(&pSPClient);
	if (!pSPClient)
	{
		hr = E_FAIL;
		goto exit;
	}

    dwBytesWritten = WMDM_TRANSFER_BUFFER_SIZE;
    while ((WMDM_TRANSFER_BUFFER_SIZE == dwBytesWritten))
    {
        dwBytes = WMDM_TRANSFER_BUFFER_SIZE;
        CORg( pObject->Read(pData, &dwBytes, abMAC) );

		CORg( pSPClient->DecryptParam(pData, dwBytes) );

		// Verify MAC returned by SP
		CORg( pSPClient->MACInit(&hMAC) );
		CORg( pSPClient->MACUpdate(hMAC, (BYTE*)(pData), dwBytes) );
		CORg( pSPClient->MACUpdate(hMAC, (BYTE*)(&dwBytes), sizeof(dwBytes)) );
		CORg( pSPClient->MACFinal(hMAC, abMACVerify) );

        if (memcmp(abMACVerify, abMAC, WMDM_MAC_LENGTH) != 0)
		{
			hr = WMDM_E_MAC_CHECK_FAILED;
			goto exit;
		}

        CFRg( WriteFile(hFile, pData, dwBytes, &dwBytesWritten, NULL) );
        dwTotalBytes+=dwBytesWritten;
        if (pProgress)
        {
            CORg( pProgress->Progress(dwTotalBytes) );
        }
    }



exit:
Error:
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }
    if (pObject && fOpen)
    {
        HRESULT hr2 = pObject->Close();
        hr = FAILED(hr)?hr:hr2;
    }
    SAFE_ARRAY_DELETE(pData);

    hrLogDWORD("CWMDMStorage::hrCopyToFileFromStorage returned 0x%08lx", hr, hr);

    return hr;
}

DWORD InsertThreadFunc(void *pData)
{
    INSERTTHREADARGS *pThreadArgs = NULL;
    
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr))
    {

        pThreadArgs = (INSERTTHREADARGS *)pData;

        // We need to marshal the interfaces that the application passes down to us.
        // These interfaces can come from an STA and we will make callabacks on them.
        IWMDMOperation  *pOperation = NULL;
        IWMDMProgress   *pProgress = NULL;
        IUnknown        *pUnknown = NULL;

        if( pThreadArgs->pOperationStream )
        {
            hr = CoGetInterfaceAndReleaseStream( pThreadArgs->pOperationStream, 
                                                 __uuidof(IWMDMOperation), 
                                                 (void**)&pOperation );
        }
        if (SUCCEEDED(hr) && pThreadArgs->pProgressStream )
        {
            hr = CoGetInterfaceAndReleaseStream( pThreadArgs->pProgressStream, 
                                                 __uuidof(IWMDMProgress), 
                                                 (void**)&pProgress );
        }
        if (SUCCEEDED(hr) && pThreadArgs->pUnknownStream )
        {
            hr = CoGetInterfaceAndReleaseStream( pThreadArgs->pUnknownStream, 
                                                 __uuidof(IUnknown), 
                                                 (void**)&pUnknown );
        }

        if (SUCCEEDED(hr))
        {
            hr = ((CWMDMStorage *)(pThreadArgs->pThis))->InsertWorker(pThreadArgs->fuMode,
                                                                      pThreadArgs->pwszFileSource,
                                                                      pThreadArgs->pwszFileDest,
                                                                      pOperation,
                                                                      pProgress,
                                                                      pUnknown,
                                                                      pThreadArgs->ppNewObject);
        }

        SAFE_RELEASE( pOperation );
        SAFE_RELEASE( pProgress );
        SAFE_RELEASE( pUnknown );
        CoUninitialize();
    }

    if (pThreadArgs)
    {
        SAFE_DELETE(  pThreadArgs->pwszFileSource);
        SAFE_DELETE(  pThreadArgs->pwszFileDest);
        SAFE_RELEASE( pThreadArgs->pThis );
    }
    delete pData;

    return SUCCEEDED(hr)?0:-1;
}

HRESULT CWMDMStorage::InsertWorker(UINT fuMode,
                                   LPWSTR pwszFileSource,
                                   LPWSTR pwszFileDest,
                                   IWMDMOperation *pOperation,
                                   IWMDMProgress *pProgress,
                                   IUnknown*    pUnknown,
                                   IWMDMStorage **ppNewObject)
{
    HRESULT hr;
    HRESULT hr2;
    IMDSPStorage *pNewSPStorage = NULL;
    CComObject<CWMDMStorage> *pNewWMDMStorage = NULL;
    IWMDMStorage *pNewIWMDMStorage = NULL;
    UINT fuNewMode = 0;
    WCHAR wszDest[512];
    BOOL fQuery;
    BOOL fOperation;
    DWORD dwAttributes;
    BOOL fIsFile;
    IMDSPObject *pObject = NULL;
// BUGBUG: Fix this to a normal WAVEFORMATEX
    _WAVEFORMATEX Format;
	BOOL fBeginCalled = FALSE;

	// Update storage status
	m_dwStatus &= WMDM_STATUS_STORAGECONTROL_INSERTING;

    fOperation = fuMode & WMDM_CONTENT_OPERATIONINTERFACE;
    fIsFile = fuMode & WMDM_CONTENT_FILE;

    fuNewMode = fuMode & (WMDM_STORAGECONTROL_INSERTINTO | WMDM_STORAGECONTROL_INSERTAFTER | WMDM_STORAGECONTROL_INSERTBEFORE);

    if ((fOperation) && (!pOperation))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // BUGBUG: Deal with WAVEFORMATEX
    if (!fOperation)
    {
        if (!pwszFileSource)
        {
            hr = E_INVALIDARG;
            goto exit;
        }

        // Get output file name
        if( pwszFileDest != NULL )
        {
            // Use name passed in
            wcsncpy(wszDest, pwszFileDest, sizeof(wszDest)/sizeof(wszDest[0]));
        }
        else
        {
            // Use same as source name
            if (NULL != wcschr(pwszFileSource, L'\\'))
            {
                // Copy source name from last '\'
                wcsncpy(wszDest, (LPWSTR)(wcsrchr(pwszFileSource, L'\\') + 1), sizeof(wszDest)/sizeof(wszDest[0]) );		
            }
            else
            {
                wcsncpy(wszDest, pwszFileSource, sizeof(wszDest)/sizeof(wszDest[0]) );
            }
        }
    
        if (fuMode & WMDM_CONTENT_FILE)
        {
            fuNewMode |= WMDM_FILE_ATTR_FILE;
        }
        else if (fuMode & WMDM_CONTENT_FOLDER)
        {
            fuNewMode |= WMDM_FILE_ATTR_FOLDER;
        }
        else
        {
            hr = E_INVALIDARG;
            goto exit;
        }

        if (fuMode & WMDM_FILE_CREATE_OVERWRITE)
        {
            fuNewMode |= WMDM_FILE_CREATE_OVERWRITE;
        }
    }
    else
    {
        CORg( pOperation->BeginWrite() );

        if( pwszFileDest != NULL )
        {
            // Use name passed in
            wcsncpy(wszDest, pwszFileDest, sizeof(wszDest)/sizeof(wszDest[0]) );
        }
        else 
        {
            CORg( pOperation->GetObjectName(wszDest, 512) );
        }
        CORg( pOperation->GetObjectAttributes(&dwAttributes, &Format) );

        fIsFile = dwAttributes & WMDM_FILE_ATTR_FILE;

        fuNewMode |= dwAttributes;
    }

   
    fQuery = fuMode & WMDM_MODE_QUERY;

    if (fIsFile)
    {
        if (fOperation)
        {
			fBeginCalled = TRUE;
            hr = hrCopyToStorageFromOperation(fuMode, pOperation, 
                                               fuNewMode, wszDest,                                                
                                                pNewIWMDMStorage,
                                                pProgress, pUnknown,
                                                fQuery);
            CORg( hr );
        }
        else
        {
			fBeginCalled = TRUE;
            hr = hrCopyToStorageFromFile(fuMode, pwszFileSource, 
                                         fuNewMode, wszDest,                                                
                                         pNewIWMDMStorage,
                                         pProgress, pUnknown,
                                         fQuery);
            CORg( hr );
        }
    }
    else
    {
        // Create the folder
        CORg( m_pStorage->CreateStorage(fuNewMode, NULL, wszDest, &pNewSPStorage) );
        CORg( CComObject<CWMDMStorage>::CreateInstance(&pNewWMDMStorage) );
        CORg( pNewWMDMStorage->QueryInterface(IID_IWMDMStorage, reinterpret_cast<void**>(&pNewIWMDMStorage)) );
        pNewWMDMStorage->SetContainedPointer(pNewSPStorage, m_wSPIndex);
    }

exit:
Error:

    if (SUCCEEDED(hr) && ppNewObject && pNewIWMDMStorage)
    {
        // If they gave us a pointer then they want the new storage pointer back
        *ppNewObject = pNewIWMDMStorage;
        (*ppNewObject)->AddRef();
    }
    else if(ppNewObject) *ppNewObject = NULL;

    if( FAILED(hr) )
    {
        SAFE_RELEASE( pNewSPStorage );
        SAFE_DELETE( pNewWMDMStorage );
    }

    SAFE_RELEASE( pNewIWMDMStorage );
    if (fOperation)
    {
        if (FAILED(hr))
        {
            pOperation->End(&hr, NULL);
        }
        else
        {
            if (pNewIWMDMStorage)
            {
                pNewIWMDMStorage->AddRef();
            }
            pOperation->End(&hr, ppNewObject?*ppNewObject:NULL);
        }
    }

	if (pProgress)
	{
        hr2 = S_OK;
        if (!fBeginCalled)
        {
		    hr2 = pProgress->Begin(1);
        }

		if (SUCCEEDED(hr2))
		{
            IWMDMProgress2 *pProgress2 = NULL;
            HRESULT hrQI;

            // Try to use End2 of IWMDMProgress2 interface to report error code back to caller.
            hrQI = pProgress->QueryInterface( IID_IWMDMProgress2, (void**)(&pProgress2) );
            if( hrQI == S_OK && pProgress2 != NULL )
            {
                pProgress2->End2(hr);
                SAFE_RELEASE( pProgress2 );
            }
            else
            {
                pProgress->End();
            }
		}
	}

    SAFE_RELEASE(pObject);

	// Update storage status
	m_dwStatus &= !WMDM_STATUS_STORAGECONTROL_INSERTING;

    hrLogDWORD("CWMDMStorage::InsertWorker returned 0x%08lx", hr, hr);

    return hr;
}

DWORD DeleteThreadFunc(void *pData)
{
    DELETETHREADARGS *pThreadArgs = NULL;

    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr))
    {
        IWMDMProgress*  pProgress = NULL;
        pThreadArgs = (DELETETHREADARGS *)pData;

        if( pThreadArgs->pProgressStream )
        {
            hr = CoGetInterfaceAndReleaseStream( pThreadArgs->pProgressStream, 
                                                 __uuidof(IWMDMProgress), 
                                                 (void**)&pProgress );
        }


        hr = ((CWMDMStorage *)(pThreadArgs->pThis))->DeleteWorker( pThreadArgs->fuMode, 
                                                                   pProgress );

        SAFE_RELEASE( pProgress );
        CoUninitialize();
    }

    if (pThreadArgs)
    {
        SAFE_RELEASE( pThreadArgs->pThis );
    }

    delete pData;

    return SUCCEEDED(hr)?0:-1;
}

HRESULT CWMDMStorage::DeleteWorker(UINT fuMode, IWMDMProgress *pProgress)
{
    HRESULT hr;
    IMDSPObject *pObject = NULL;

	// Update storage status
	m_dwStatus &= WMDM_STATUS_STORAGECONTROL_DELETING;

    hr = m_pStorage->QueryInterface(IID_IMDSPObject, reinterpret_cast<void**>(&pObject));
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = pObject->Delete(fuMode, pProgress);
    if (FAILED(hr))
    {
        goto exit;
    }
exit:
    if (pObject)
        pObject->Release();

	// Update storage status
	m_dwStatus &= !WMDM_STATUS_STORAGECONTROL_DELETING;

    hrLogDWORD("CWMDMStorage::DeleteWorker returned 0x%08lx", hr, hr);

    return hr;
}

DWORD RenameThreadFunc(void *pData)
{
    RENAMETHREADARGS *pThreadArgs = NULL;

    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr))
    {
        IWMDMProgress* pProgress = NULL;
        pThreadArgs = (RENAMETHREADARGS *)pData;

        if( pThreadArgs->pProgressStream )
        {
            hr = CoGetInterfaceAndReleaseStream( pThreadArgs->pProgressStream, 
                                                 __uuidof(IWMDMProgress), 
                                                 (void**)&pProgress );
        }
        hr = ((CWMDMStorage *)(pThreadArgs->pThis))->RenameWorker(pThreadArgs->pwszNewName,
                                                                  pProgress );
        SAFE_RELEASE( pProgress );
        CoUninitialize();
    }

    if (pThreadArgs)
    {
        if (pThreadArgs->pwszNewName)
            delete pThreadArgs->pwszNewName;
        SAFE_RELEASE( pThreadArgs->pThis );
    }
    delete pData;
    return SUCCEEDED(hr)?0:-1;
}

HRESULT CWMDMStorage::RenameWorker(LPWSTR pwszNewName,
                                   IWMDMProgress *pProgress)
{
    HRESULT hr;
    IMDSPObject *pObject = NULL;

    if ((!pwszNewName) || (wcslen(pwszNewName) == 0))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    hr = m_pStorage->QueryInterface(IID_IMDSPObject, reinterpret_cast<void**>(&pObject));
    if (SUCCEEDED(hr))
    {
        hr = pObject->Rename(pwszNewName, pProgress);
        pObject->Release();
    }
exit:

    hrLogDWORD("CWMDMStorage::RenameWorker returned 0x%08lx", hr, hr);

    return hr;
}

DWORD ReadThreadFunc(void *pData)
{
    READTHREADARGS *pThreadArgs = NULL;

    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr))
    {
        IWMDMOperation* pOperation = NULL;
        IWMDMProgress*  pProgress = NULL;
        pThreadArgs = (READTHREADARGS *)pData;

        if( pThreadArgs->pOperationStream )
        {
            hr = CoGetInterfaceAndReleaseStream( pThreadArgs->pOperationStream, 
                                                 __uuidof(IWMDMOperation), 
                                                 (void**)&pOperation );
        }
        if (SUCCEEDED(hr) && pThreadArgs->pProgressStream )
        {
            hr = CoGetInterfaceAndReleaseStream( pThreadArgs->pProgressStream, 
                                                 __uuidof(IWMDMProgress), 
                                                 (void**)&pProgress );
        }

        hr = ((CWMDMStorage *)(pThreadArgs->pThis))->ReadWorker(pThreadArgs->fuMode,
                                                                pThreadArgs->pwszFile,
                                                                pProgress,
                                                                pOperation);
        SAFE_RELEASE(pOperation);
        SAFE_RELEASE(pProgress);
        CoUninitialize();
    }

    if (pThreadArgs)
    {
        if (pThreadArgs->pwszFile)
            delete pThreadArgs->pwszFile;

        SAFE_RELEASE( pThreadArgs->pThis );
    }
    delete pData;
    return SUCCEEDED(hr)?0:-1;
}

HRESULT CWMDMStorage::ReadWorker(UINT fuMode,
                                 LPWSTR pwszFile,
                                 IWMDMProgress *pProgress,
                                 IWMDMOperation *pOperation)
{
    HRESULT hr;
    IMDSPObject *pObject = NULL;
    DWORD dwFileSize;
    DWORD dwFileSizeHigh;
	BOOL fBeginCalled = FALSE;

	// Update Storage status
	m_dwStatus &= WMDM_STATUS_STORAGECONTROL_READING;

    hr = m_pStorage->GetSize(&dwFileSize, &dwFileSizeHigh);
    if (FAILED(hr))
    {
        goto exit;
    }

    if (pProgress)
    {
        hr = pProgress->Begin(dwFileSize);
		fBeginCalled = TRUE;
        if (FAILED(hr))
        {
            goto exit;
        }
    }

    hr = m_pStorage->QueryInterface(IID_IMDSPObject, reinterpret_cast<void**>(&pObject));
    if (FAILED(hr))
    {
        goto exit;
    }

    if (fuMode & WMDM_CONTENT_OPERATIONINTERFACE)
    {
		if (!pOperation)
		{
			hr = E_INVALIDARG;
			goto exit;
		}

        hr = hrCopyToOperationFromStorage(pOperation, pProgress, pObject);
        if (FAILED(hr))
        {
            goto exit;
        }
    }
    else
    {
		if (!pwszFile)
		{
			hr = E_INVALIDARG;
			goto exit;
		}

        hr = hrCopyToFileFromStorage(pwszFile, pProgress, pObject);
        if (FAILED(hr))
        {
            goto exit;
        }
    }

exit:
    if (pObject)
        pObject->Release();

	if (pProgress)
	{
        IWMDMProgress2 *pProgress2 = NULL;
        HRESULT hrQI;

        if (!fBeginCalled)
        {
            pProgress->Begin(1);
        }
        // Try to use End2 of IWMDMProgress2 interface to report error code back to caller.
        hrQI = pProgress->QueryInterface( IID_IWMDMProgress2, (void**)(&pProgress2) );
        if( hrQI == S_OK && pProgress2 != NULL )
        {
            pProgress2->End2(hr);
            SAFE_RELEASE( pProgress2 );
        }
        else
        {
            pProgress->End();
        }
	}

    // Update Storage status
	m_dwStatus &= !WMDM_STATUS_STORAGECONTROL_READING;

    hrLogDWORD("CWMDMStorage::ReadWorker returned 0x%08lx", hr, hr);

    return hr;
}


// IWMDMRevoked
HRESULT CWMDMStorage::GetRevocationURL(	LPWSTR* ppwszRevocationURL,
                                        DWORD*  pdwBufferLen,
								        OUT DWORD* pdwRevokedBitFlag )
{
    HRESULT hr = S_OK;

    CARg( ppwszRevocationURL );
    CARg( pdwBufferLen );
    CARg( pdwRevokedBitFlag );

    // Is the buffer passed in big enough?
    if( *pdwBufferLen < wcslen( m_pwszRevocationURL ) || *ppwszRevocationURL == NULL )
    {
        // Allocate new buffer
        *pdwBufferLen = wcslen( m_pwszRevocationURL ) + 1;
        CoTaskMemFree( *ppwszRevocationURL );
        *ppwszRevocationURL = (LPWSTR)CoTaskMemAlloc( *pdwBufferLen * sizeof(WCHAR) );
        if( *ppwszRevocationURL == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
    }

    wcscpy( *ppwszRevocationURL, m_pwszRevocationURL );
    *pdwRevokedBitFlag = m_dwRevocationBitFlag;

Error:
    return hr;
}

// We might change the URL given to us by the SCP if the WMDM client or the SP is revoked
HRESULT CWMDMStorage::UpdateRevocationURL( IN OUT LPWSTR* ppwszRevocationURL, 
                                           IN OUT DWORD*  pdwBufferLen,
                                           IN     DWORD*  pdwRevocationBitFlag )
{
    HRESULT hr = S_OK;
    IMDServiceProvider* pSP = NULL;
    IMDSPRevoked* pIMDSPRevoked = NULL;
    BOOL    bUpdateOK = FALSE;
    LPWSTR  pszTempURL;
    DWORD   dwTempLen = *pdwBufferLen; 

    // Work with a temp url so that we don't destroy a good url if something fails
    pszTempURL = (LPWSTR)CoTaskMemAlloc( *pdwBufferLen * sizeof(WCHAR) );
    CPRg( pszTempURL );
    wcscpy( pszTempURL, *ppwszRevocationURL );

    // If the SP has been revoked give it a chance to specify an URL of it's own.
    if( *pdwRevocationBitFlag & WMDM_SP_REVOKED )
    {
        CORg( g_pSPs[m_wSPIndex]->hrGetInterface(&pSP) );
        hr = pSP->QueryInterface( IID_IMDSPRevoked, (void**)&pIMDSPRevoked );
        
        if( SUCCEEDED(hr) && pIMDSPRevoked )
        {
            hr = pIMDSPRevoked->GetRevocationURL( &pszTempURL, &dwTempLen );
            if( hr != S_OK)
            {
                // We failed to update the string, reset it to initial value
                dwTempLen = *pdwBufferLen;
                CoTaskMemFree( pszTempURL );
                pszTempURL = (LPWSTR)CoTaskMemAlloc( *pdwBufferLen * sizeof(WCHAR) );
                CPRg( pszTempURL );
                wcscpy( pszTempURL, *ppwszRevocationURL );
            }
            else
            {
                bUpdateOK = TRUE;
            }
        }
    }

    // If the WMDM client is revoked we should go to the MS update URL
    if( (*pdwRevocationBitFlag & WMDM_WMDM_REVOKED) && 
        ::IsMicrosoftRevocationURL(pszTempURL) == FALSE )
    {
        DWORD   pdwSubjectIDs[2];
        pdwSubjectIDs[0] = ::GetSubjectIDFromAppCert( *(APPCERT*)g_abAppCert );
        pdwSubjectIDs[1] = 0;
        hr = ::BuildRevocationURL( pdwSubjectIDs, &pszTempURL, &dwTempLen );

        if(hr  == S_OK)
        {
            bUpdateOK = TRUE;
        }
    }

    // URL has changed, update out param.
    if( bUpdateOK && wcscmp( pszTempURL, *ppwszRevocationURL ) != 0 )
    {
        *pdwBufferLen = dwTempLen;
        CoTaskMemFree( *ppwszRevocationURL );
        *ppwszRevocationURL = (LPWSTR)CoTaskMemAlloc( dwTempLen * sizeof(WCHAR) );
        CPRg( *ppwszRevocationURL );
        wcscpy( *ppwszRevocationURL, pszTempURL );
    }

Error:
    if( pszTempURL != NULL )
    {
        CoTaskMemFree( pszTempURL );
    }
    SAFE_RELEASE(pSP);
    SAFE_RELEASE(pIMDSPRevoked);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__6EC6C748_355F_11D3_8470_00C04F79DBC0__INCLUDED_)
#define AFX_STDAFX_H__6EC6C748_355F_11D3_8470_00C04F79DBC0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED

void GlobalAddRef();
void GlobalRelease();

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__6EC6C748_355F_11D3_8470_00C04F79DBC0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\storageglobal.cpp ===
// StorageGlobal.cpp : Implementation of CStorageGlobal
#include "stdafx.h"
#include "mswmdm.h"
#include "StorageGlobal.h"
#include "Device.h"
#include "Storage.h"
#include "loghelp.h"
#include "scserver.h"
#include "scclient.h"
#include "spinfo.h"

/////////////////////////////////////////////////////////////////////////////
// CWMDMStorageGlobal

extern CSecureChannelServer *g_pAppSCServer;
extern CSPInfo **g_pSPs;

// IWMDMStorageGlobals
HRESULT CWMDMStorageGlobal::GetTotalSize(DWORD *pdwTotalSizeLow, DWORD *pdwTotalSizeHigh)
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    hr = m_pStgGlobals->GetTotalSize(pdwTotalSizeLow, pdwTotalSizeHigh);
	if (FAILED(hr))
	{
		goto exit;
	}

exit:
    hrLogDWORD("IWMDMStorageGlobals::GetTotalSize returned 0x%08lx", hr, hr);

    return hr;

}

HRESULT CWMDMStorageGlobal::GetCapabilities(DWORD *pdwCapabilities)
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    hr = m_pStgGlobals->GetCapabilities(pdwCapabilities);
	if (FAILED(hr))
	{
		goto exit;
	}

exit:
    hrLogDWORD("IWMDMStorageGlobals::GetCapabilities returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorageGlobal::GetSerialNumber(PWMDMID pSerialNum, BYTE abMac[WMDM_MAC_LENGTH])
{
    HRESULT hr;
	HMAC hMAC;
	CSecureChannelClient *pSCClient;
	BYTE abTempMAC[SAC_MAC_LEN];
	BYTE abMACVerify[SAC_MAC_LEN];

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

	if (!pSerialNum)
	{
		hr = E_INVALIDARG;
		goto exit;
	}

	g_pSPs[m_wSPIndex]->GetSCClient(&pSCClient);
	if (!pSCClient)
	{
		hr = E_FAIL;
		goto exit;
	}

    hr = m_pStgGlobals->GetSerialNumber(pSerialNum, abTempMAC);
	if (FAILED(hr))
	{
		goto exit;
	}

	// Verify the MAC from SP
	hr = pSCClient->MACInit(&hMAC);
	if (FAILED(hr))
	{
		goto exit;
	}

	hr = pSCClient->MACUpdate(hMAC, (BYTE*)(pSerialNum), sizeof(WMDMID));
	if (FAILED(hr))
	{
		goto exit;
	}

	hr = pSCClient->MACFinal(hMAC, abMACVerify);
	if (FAILED(hr))
	{
		goto exit;
	}

	if (memcmp(abMACVerify, abTempMAC, WMDM_MAC_LENGTH) != 0)
	{
		hr = WMDM_E_MAC_CHECK_FAILED;
		goto exit;
	}

	// Compute the MAC to send back to the application
	hr = g_pAppSCServer->MACInit(&hMAC);
	if (FAILED(hr))
	{
		goto exit;
	}

	hr = g_pAppSCServer->MACUpdate(hMAC, (BYTE*)(pSerialNum), sizeof(WMDMID));
	if (FAILED(hr))
	{
		goto exit;
	}

	hr = g_pAppSCServer->MACFinal(hMAC, abMac);
	if (FAILED(hr))
	{
		goto exit;
	}

exit:    

	hrLogDWORD("IWMDMStorageGlobals::GetSerialNumber returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorageGlobal::GetTotalFree(DWORD *pdwFreeLow,
                                         DWORD *pdwFreeHigh)
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    hr = m_pStgGlobals->GetTotalFree(pdwFreeLow, pdwFreeHigh);
	if (FAILED(hr))
	{
		goto exit;
	}

exit:    
    hrLogDWORD("IWMDMStorageGlobals::GetTotalFree returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorageGlobal::GetTotalBad(DWORD *pdwBadLow,
                                        DWORD *pdwBadHigh)
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    hr = m_pStgGlobals->GetTotalBad(pdwBadLow, pdwBadHigh);
	if (FAILED(hr))
	{
		goto exit;
	}

exit:
    hrLogDWORD("IWMDMStorageGlobals::GetTotalBad returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorageGlobal::GetStatus(DWORD *pdwStatus)
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    hr = m_pStgGlobals->GetStatus(pdwStatus);
	if (FAILED(hr))
	{
		goto exit;
	}

exit:    
    hrLogDWORD("IWMDMStorageGlobals::GetStatus returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorageGlobal::Initialize(UINT fuMode,
                                       IWMDMProgress *pProgress)
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    hr = m_pStgGlobals->Initialize(fuMode, pProgress);
	if (FAILED(hr))
	{
		goto exit;
	}

exit:    
    hrLogDWORD("IWMDMStorageGlobals::Initialize returned 0x%08lx", hr, hr);

    return hr;
}

void CWMDMStorageGlobal::SetContainedPointer(IMDSPStorageGlobals *pStgGlobals, WORD wSPIndex)
{
    m_pStgGlobals = pStgGlobals;
    m_pStgGlobals->AddRef();
	m_wSPIndex = wSPIndex;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\storageglobal.h ===
// StorageGlobal.h : Declaration of the CStorageGlobal

#ifndef __STORAGEGLOBAL_H_
#define __STORAGEGLOBAL_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CStorageGlobal
class ATL_NO_VTABLE CWMDMStorageGlobal : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CWMDMStorageGlobal, &CLSID_WMDMStorageGlobal>,
	public IWMDMStorageGlobals
{
public:
    CWMDMStorageGlobal() : m_pStgGlobals(NULL)
	{
	}

    ~CWMDMStorageGlobal()
	{
        if (m_pStgGlobals)
            m_pStgGlobals->Release();
	}

BEGIN_COM_MAP(CWMDMStorageGlobal)
	COM_INTERFACE_ENTRY(IWMDMStorageGlobals)
END_COM_MAP()

public:
// IWMDMStorageGlobals
    STDMETHOD(GetCapabilities)(DWORD *pdwCapabilities);
    STDMETHOD(GetSerialNumber)(PWMDMID pSerialNum, BYTE abMac[WMDM_MAC_LENGTH]);
	STDMETHOD(GetTotalSize)(DWORD *pdwTotalSizeLow,
                            DWORD *pdwTotalSizeHigh);
    STDMETHOD(GetTotalFree)(DWORD *pdwFreeLow,
                            DWORD *pdwFreeHigh);
    STDMETHOD(GetTotalBad)(DWORD *pdwBadLow,
                           DWORD *pdwBadHigh);
    STDMETHOD(GetStatus)(DWORD *pdwStatus);
    STDMETHOD(Initialize)(UINT fuMode,
                          IWMDMProgress *pProgress);
    void SetContainedPointer(IMDSPStorageGlobals *pStgGlobals, WORD wSPIndex);
private:
    IMDSPStorageGlobals *m_pStgGlobals;
	WORD m_wSPIndex;
};

#endif //__STORAGEGLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\wmdmdeviceenum.cpp ===
// WMDMDeviceEnum.cpp : Implementation of CWMDMDeviceEnum
#include "stdafx.h"
#include "mswmdm.h"
#include "spinfo.h"
#include "WMDMDeviceEnum.h"
#include "Device.h"
#include "loghelp.h"
#include "scserver.h"

/////////////////////////////////////////////////////////////////////////////
// CWMDMDeviceEnum

extern CSPInfo **g_pSPs;
extern WORD g_wSPCount;
extern CSecureChannelServer *g_pAppSCServer;

CWMDMDeviceEnum::CWMDMDeviceEnum() 
 : m_ppEnums(NULL), m_wCurrentSP(0), m_wSPCount(0)
{
	GlobalAddRef();

	m_pwSPSkipped=NULL;
    hrInitializeEnumArray();
}

CWMDMDeviceEnum::~CWMDMDeviceEnum()
{
    if (m_ppEnums)
    {
        for (WORD x=0;x<m_wSPCount;x++)
            m_ppEnums[x]->Release();
        delete m_ppEnums;
    }
	if( m_pwSPSkipped ) 
	{
		delete [] m_pwSPSkipped;
		m_pwSPSkipped=NULL;
	}

	GlobalRelease();
}



// IWMDMEnumDevice Methods
HRESULT CWMDMDeviceEnum::Next(ULONG celt,
	                          IWMDMDevice **ppDevice,
			                  ULONG *pceltFetched)
{
    HRESULT hr = S_FALSE;
    ULONG celtRemaining;
    ULONG ulFetched;
    ULONG ulX;
    IMDSPDevice **ppDevList = NULL;
    CComObject<CWMDMDevice> *pDevObj = NULL;
	WORD *pwSPIndexList = NULL;
	ULONG ulIndexOffset;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    if (!ppDevice || !pceltFetched || celt == 0)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

	m_csCurrentSP.Lock();

    // If we have gone through all of the SPs then the user must reset
    if (m_wCurrentSP > g_wSPCount - 1)
    {
        *pceltFetched = 0;
        *ppDevice = NULL;
        goto exit;
    }

    if( !m_pwSPSkipped )
	{
        hr = E_OUTOFMEMORY;
        goto exit;
	}

    ppDevList = new IMDSPDevice *[celt];
    if (!ppDevList)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

	pwSPIndexList = new WORD[celt];
	if (!pwSPIndexList)
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}

    hr = E_FAIL;
	if( m_ppEnums[m_wCurrentSP] )
	{
		hr = m_ppEnums[m_wCurrentSP]->Next(celt, ppDevList, &ulFetched);
	}

    if (FAILED(hr))
    {
		ulFetched = 0;
		hr = S_OK;  // Ignore the failure, continue to search the next SP.
        //goto exit;
    }

	for (ulIndexOffset=0;ulIndexOffset<ulFetched;ulIndexOffset++)
	{
		pwSPIndexList[ulIndexOffset] = m_pwSPSkipped[m_wCurrentSP];
	}

    if(celt != ulFetched)
    {
        celtRemaining = celt - ulFetched;
        m_wCurrentSP++;
        while (m_wCurrentSP < m_wSPCount)
        {
            hr = m_ppEnums[m_wCurrentSP]->Reset();
            if (FAILED(hr))
            {
                goto exit;
            }

            hr = m_ppEnums[m_wCurrentSP]->Next(celtRemaining, 
                                               reinterpret_cast<IMDSPDevice **>(ppDevList + ulIndexOffset), 
                                               &ulFetched);
            if (FAILED(hr))
            {
                goto exit;
            }

			for ( UINT uFetchedIndex = 0;uFetchedIndex<ulFetched; ulIndexOffset++, uFetchedIndex++)
			{
				pwSPIndexList[ulIndexOffset] = m_pwSPSkipped[m_wCurrentSP];
			}

            if (celtRemaining == ulFetched)
            {
                // We have all of the device we need
                celtRemaining = 0;
                break;
            }
            celtRemaining = celtRemaining - ulFetched;
            m_wCurrentSP++;
        }
        // Tell the caller how many devices we are returning.
        *pceltFetched = celt - celtRemaining;
    }
    else
    {
        *pceltFetched = ulFetched;
    }

	m_csCurrentSP.Unlock();

    for (ulX=0;ulX<*pceltFetched;ulX++)
    {
        hr = CComObject<CWMDMDevice>::CreateInstance(&pDevObj);
        if (FAILED(hr))
        {
            goto exit;
        }

        hr = pDevObj->QueryInterface(IID_IWMDMDevice, reinterpret_cast<void**>(&ppDevice[ulX]));
        if (FAILED(hr))
        {
            delete pDevObj;
            goto exit;
        }

        pDevObj->SetContainedPointer(ppDevList[ulX], pwSPIndexList[ulX]);
        // @@@@ Must release in all failure paths as well
        ppDevList[ulX]->Release();
    }
exit:
    if (SUCCEEDED(hr))
    { 
        if (celt == *pceltFetched)
        {
            hr = S_OK;
        }
        else
        {
            if (*pceltFetched == 0)
            {
                *ppDevice = NULL;
            }
            hr = S_FALSE;
        }
    }

    if (ppDevList)
        delete [] ppDevList;
	if (pwSPIndexList)
		delete [] pwSPIndexList;
	
    hrLogDWORD("IWMDMEnumDevice::Next returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDeviceEnum::Skip(ULONG celt, ULONG *pceltFetched)
{
    HRESULT hr;
    ULONG celtRemaining;
    ULONG ulFetched;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    if (!pceltFetched || celt == 0)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

	m_csCurrentSP.Lock();

    // If we have gone through all of the SPs then the user must reset
    // @@@@ unsigned compare: consider g_wSPCount == 0
    if (m_wCurrentSP > g_wSPCount - 1)
    {
        *pceltFetched = 0;
        hr = S_OK;
        goto exit;
    }

    hr = m_ppEnums[m_wCurrentSP]->Skip(celt, &ulFetched);
    if (FAILED(hr))
    {
        goto exit;
    }

    if(celt != ulFetched)
    {
        celtRemaining = celt - ulFetched;
        m_wCurrentSP++;
        while (m_wCurrentSP < m_wSPCount)
        {
            hr = m_ppEnums[m_wCurrentSP]->Reset();
            if (FAILED(hr))
            {
                goto exit;
            }

            hr = m_ppEnums[m_wCurrentSP]->Skip(celtRemaining, &ulFetched);
            if (FAILED(hr))
            {
                goto exit;
            }
            if (celtRemaining == ulFetched)
            {
                // We have all of the device we need
                celtRemaining = 0;
                break;
            }
            celtRemaining = celtRemaining - ulFetched;
            m_wCurrentSP++;
        }
        // Tell the caller how many devices we are returning.
        *pceltFetched = celt - celtRemaining;
    }
    else
        *pceltFetched = ulFetched;

	m_csCurrentSP.Unlock();

exit:
    if (SUCCEEDED(hr))
    { 
        if (celt == *pceltFetched)
            hr = S_OK;
        else
            hr = S_FALSE;
    }

    hrLogDWORD("IWMDMEnumDevice::Skip returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDeviceEnum::Reset()
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

	m_csCurrentSP.Lock();

    m_wCurrentSP = 0;

    hr = m_ppEnums[m_wCurrentSP]->Reset();
    if (FAILED(hr))
    {
        goto exit;
    }

	m_csCurrentSP.Unlock();
exit:

    hrLogDWORD("IWMDMEnumDevice::Skip returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDeviceEnum::Clone(IWMDMEnumDevice **ppEnumDevice)
{
    HRESULT hr;
    CComObject<CWMDMDeviceEnum> *pEnumObj;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    if (!ppEnumDevice)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

	m_csCurrentSP.Lock();

    hr = CComObject<CWMDMDeviceEnum>::CreateInstance(&pEnumObj);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = pEnumObj->QueryInterface(IID_IWMDMEnumDevice, reinterpret_cast<void**>(ppEnumDevice));
    if (FAILED(hr))
    {
        delete pEnumObj;
        goto exit;
    }

	m_csCurrentSP.Unlock();

exit:

    hrLogDWORD("IWMDMEnumDevice::Clone returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMDeviceEnum::hrInitializeEnumArray()
{
    HRESULT hr;
    WORD x;
    IMDServiceProvider *pProv = NULL;

	if( m_pwSPSkipped ) 
	{
		delete [] m_pwSPSkipped;
	}
	m_pwSPSkipped = new WORD [g_wSPCount];
    if (!m_pwSPSkipped)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    m_ppEnums = new IMDSPEnumDevice *[g_wSPCount];
    if (!m_ppEnums)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = S_OK;
    for (x=0,m_wSPCount=0;x<g_wSPCount;x++)
    {
        hr = g_pSPs[x]->hrGetInterface(&pProv);
        if (FAILED(hr))
        {
            continue; // goto exit;
        }
        hr = pProv->EnumDevices(&m_ppEnums[m_wSPCount]);
        if (FAILED(hr))
        {
            pProv->Release();
            pProv = NULL;
            continue; // goto exit;
        }

        m_pwSPSkipped[m_wSPCount]=x; // Remember the index for SAC
        m_wSPCount++;
        pProv->Release();
        pProv = NULL;
	
    }

exit:
    if (pProv)
        pProv->Release();

    hrLogDWORD("CWMDMDeviceEnum::hrInitializeEnumArray returned 0x%08lx", hr, hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\wmdmdeviceenum.h ===
// WMDMDeviceEnum.h : Declaration of the CWMDMDeviceEnum

#ifndef __WMDMDEVICEENUM_H_
#define __WMDMDEVICEENUM_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWMDMDeviceEnum
class ATL_NO_VTABLE CWMDMDeviceEnum : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CWMDMDeviceEnum, &CLSID_WMDMDeviceEnum>,
	public IWMDMEnumDevice
{
public:
    CWMDMDeviceEnum();
    ~CWMDMDeviceEnum();

BEGIN_COM_MAP(CWMDMDeviceEnum)
	COM_INTERFACE_ENTRY(IWMDMEnumDevice)
END_COM_MAP()

// IWMDMDeviceEnum
public:
	STDMETHOD(Next)(ULONG celt,
	                IWMDMDevice **ppDevice,
				    ULONG *pceltFetched);
	STDMETHOD(Skip)(ULONG celt, ULONG *pceltFetched);
	STDMETHOD(Reset)();
	STDMETHOD(Clone)(IWMDMEnumDevice **ppEnumDevice);
private:
	CComAutoCriticalSection m_csCurrentSP;
    WORD m_wCurrentSP;
    WORD m_wSPCount;
    IMDSPEnumDevice **m_ppEnums;
    WORD *m_pwSPSkipped;

    HRESULT hrInitializeEnumArray();
};

#endif //__WMDMDEVICEENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdmlog\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\wmdmformatenum.cpp ===
// WMDMFormatEnum.cpp : Implementation of CWMDMFormatEnum
#include "stdafx.h"
#include "mswmdm.h"
#include "WMDMFormatEnum.h"

/////////////////////////////////////////////////////////////////////////////
// CWMDMFormatEnum

// IWMDMEnumFormatSupport Methods
HRESULT CWMDMFormatEnum::Next(ULONG celt,
                              _WAVEFORMATEX *pFormat,
	                          LPWSTR pwszMimeType,
                              UINT nMaxChars,
			                  ULONG *pceltFetched)
{
    return m_pEnum->Next(celt, pFormat, pwszMimeType, nMaxChars, pceltFetched);
}

HRESULT CWMDMFormatEnum::Reset()
{
    return m_pEnum->Reset();
}

void CWMDMFormatEnum::SetContainedPointer(IMDSPEnumFormatSupport *pEnum)
{
    m_pEnum = pEnum;
    m_pEnum->AddRef();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\wmdmformatenum.h ===
// WMDMFormatEnum.h : Declaration of the CWMDMFormatEnum

#ifndef __WMDMFORMATENUM_H_
#define __WMDMFORMATENUM_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWMDMFormatEnum
class ATL_NO_VTABLE CWMDMFormatEnum : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CWMDMFormatEnum, &CLSID_WMDMFormatEnum>,
	public IWMDMEnumFormatSupport
{
public:
    CWMDMFormatEnum() : m_pEnum(NULL)
	{
	}
    ~CWMDMFormatEnum()
	{
        if (m_pEnum)
            m_pEnum->Release();
	}

BEGIN_COM_MAP(CWMDMFormatEnum)
	COM_INTERFACE_ENTRY(IWMDMEnumFormatSupport)
END_COM_MAP()

public:
    // IWMDMEnumFormatSupport
	STDMETHOD(Next)(ULONG celt,
                    _WAVEFORMATEX *pFormat,
	                LPWSTR pwszMimeType,
                    UINT nMaxChars,
				    ULONG *pceltFetched);
	STDMETHOD(Reset)();
    void SetContainedPointer(IMDSPEnumFormatSupport *pEnum);
private:
    IMDSPEnumFormatSupport *m_pEnum;
};

#endif //__WMDMFORMATENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\wmdmstorageenum.h ===
// WMDMStorageEnum.h : Declaration of the CWMDMStorageEnum

#ifndef __WMDMSTORAGEENUM_H_
#define __WMDMSTORAGEENUM_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWMDMStorageEnum
class ATL_NO_VTABLE CWMDMStorageEnum : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CWMDMStorageEnum, &CLSID_WMDMStorageEnum>,
	public IWMDMEnumStorage
{
public:
    CWMDMStorageEnum();
    ~CWMDMStorageEnum();

BEGIN_COM_MAP(CWMDMStorageEnum)
	COM_INTERFACE_ENTRY(IWMDMEnumStorage)
END_COM_MAP()

public:
    // IWMDMEnumStorage
	STDMETHOD(Next)(ULONG celt,
	               IWMDMStorage **ppStorage,
				   ULONG *pceltFetched);
	STDMETHOD(Skip)(ULONG celt, ULONG *pceltFetched);
	STDMETHOD(Reset)();
	STDMETHOD(Clone)(IWMDMEnumStorage **ppEnumStorage);

    void SetContainedPointer(IMDSPEnumStorage *pEnum, WORD wSPIndex);
private:
    IMDSPEnumStorage *m_pEnum;
	WORD m_wSPIndex;
};

#endif //__WMDMSTORAGEENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdm\wmdmstorageenum.cpp ===
// WMDMStorageEnum.cpp : Implementation of CWMDMStorageEnum
#include "stdafx.h"
#include "mswmdm.h"
#include "WMDMStorageEnum.h"
#include "Storage.h"
#include "loghelp.h"
#include "scserver.h"

/////////////////////////////////////////////////////////////////////////////
// CWMDMStorageEnum

extern CSecureChannelServer *g_pAppSCServer;

CWMDMStorageEnum::CWMDMStorageEnum() 
 : m_pEnum(NULL)
{
	GlobalAddRef();
}

CWMDMStorageEnum::~CWMDMStorageEnum()
{
	if (m_pEnum)
		m_pEnum->Release();

	GlobalRelease();
}


// IWMDMEnumStorage
HRESULT CWMDMStorageEnum::Next(ULONG celt,
	                      IWMDMStorage **ppStorage,
			              ULONG *pceltFetched)
{
    HRESULT hr;
	HRESULT hr2 = S_OK;
    ULONG ulX=0;
    IMDSPStorage **ppStorageList = NULL;
    CComObject<CWMDMStorage> *pStgObj = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    if (!ppStorage || !pceltFetched || celt == 0)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    ppStorageList = new IMDSPStorage *[celt];
    if (!ppStorageList)
    {
        hr = E_OUTOFMEMORY; // @@@@ May have to be added to doc as the return status?
        goto exit;
    }

    memset( ppStorageList, 0, celt * sizeof(IMDSPStorage *));

    hr = m_pEnum->Next(celt, ppStorageList, pceltFetched);
    if (FAILED(hr))
    {
        goto cleanup;
    }

    for (ulX=0;ulX<*pceltFetched;ulX++)
    {
        // Rio600 SP behaves badly for celt > 1.
        if( ppStorageList[ulX] == NULL )
        {
            *pceltFetched = ulX;
            goto cleanup;
        }

        hr2 = CComObject<CWMDMStorage>::CreateInstance(&pStgObj);
        if (FAILED(hr2))
        {
            goto cleanup;
        }

        hr2 = pStgObj->QueryInterface(IID_IWMDMStorage, reinterpret_cast<void**>(&ppStorage[ulX]));
        if (FAILED(hr2))
        {
            delete pStgObj;
            goto cleanup;
        }

        pStgObj->SetContainedPointer(ppStorageList[ulX], m_wSPIndex);
    }

cleanup:
    if (FAILED(hr2))
    {
        // We need to clean up the output array if we failed
        // @@@ ulX is unsigned: -1<ulX is always 0 use a signed var
        for (ulX--;-1<ulX;ulX--)
        {
            ppStorage[ulX]->Release();
            ppStorage[ulX] = NULL;
        }
        *pceltFetched=0;
		
		// If we got here then next must have succeeded but not the object creation
		hr = hr2;
    }

    if (*pceltFetched == 0)
    {
        *ppStorage = NULL;
    }

    for (ulX=0;ulX<*pceltFetched;ulX++)
        ppStorageList[ulX]->Release();

    if (ppStorageList)
        delete [] ppStorageList;
exit:    

    hrLogDWORD("IWMDMEnumStorage::Next returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorageEnum::Skip(ULONG celt, ULONG *pceltFetched)
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    if (!pceltFetched || celt == 0)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    hr = m_pEnum->Skip(celt, pceltFetched);
exit:

    hrLogDWORD("IWMDMEnumStorage::Skip returned 0x%08lx", hr, hr);

    return hr;
}

HRESULT CWMDMStorageEnum::Reset()
{
    HRESULT hr;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    hr = m_pEnum->Reset();

    hrLogDWORD("IWMDMEnumStorage::Reset returned 0x%08lx", hr, hr);
exit:
    return hr;
}

HRESULT CWMDMStorageEnum::Clone(IWMDMEnumStorage **ppEnumStorage)
{
    HRESULT hr;
    CComObject<CWMDMStorageEnum> *pEnumObj = NULL;

    if (g_pAppSCServer)
	{
		if(!g_pAppSCServer->fIsAuthenticated())
		{
			hr = WMDM_E_NOTCERTIFIED;
			goto exit;
		}
	}
	else
	{
		hr = E_FAIL;
		goto exit;
	}

    if (!ppEnumStorage)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    hr = CComObject<CWMDMStorageEnum>::CreateInstance(&pEnumObj);
    if (FAILED(hr))
    {
        goto exit;
    }

    hr = pEnumObj->QueryInterface(IID_IWMDMEnumStorage, reinterpret_cast<void**>(ppEnumStorage));
    if (FAILED(hr))
    {
        delete pEnumObj;
        goto exit;
    }

    pEnumObj->SetContainedPointer(m_pEnum, m_wSPIndex);
exit:

    hrLogDWORD("IWMDMEnumStorage::Clone returned 0x%08lx", hr, hr);

    return hr;
}

void CWMDMStorageEnum::SetContainedPointer(IMDSPEnumStorage *pEnum, WORD wSPIndex)
{
    m_pEnum = pEnum;
    m_pEnum->AddRef();
	m_wSPIndex = wSPIndex;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdmlog\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WmdmLog.rc
//
#define IDS_PROJNAME                    100
#define IDR_WMDMLOGGER                  101
#define IDS_LOG_SEV_INFO                201
#define IDS_LOG_SEV_WARN                202
#define IDS_LOG_SEV_ERROR               203
#define IDS_LOG_DATETIME                204
#define IDS_LOG_SRCNAME                 205
#define IDS_DEF_LOGFILE                 301
#define IDS_DEF_MAXSIZE                 302
#define IDS_DEF_SHRINKTOSIZE            303
#define IDS_DEF_LOGENABLED              304
#define IDS_MUTEX_TIMEOUT               401

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdmlog\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3E627865_5A84_11D3_8D78_444553540000__INCLUDED_)
#define AFX_STDAFX_H__3E627865_5A84_11D3_8D78_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include "util.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3E627865_5A84_11D3_8D78_444553540000__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdmlog\util.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows Media
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       Util.h
//
//--------------------------------------------------------------------------

#ifndef _UTIL_H_
#define _UTIL_H_

// Error handling
//
#define ExitOnTrue( f )       if( f ) goto lExit;
#define ExitOnFalse( f )      if( !(f) ) goto lExit;
#define ExitOnNull( x )       if( (x) == NULL ) goto lExit;
#define ExitOnFail( hr )      if( FAILED(hr) ) goto lExit;

#define FailOnTrue( f )       if( f ) goto lErr;
#define FailOnFalse( f )      if( !(f) ) goto lErr;
#define FailOnNull( x )       if( (x) == NULL ) goto lErr;
#define FailOnFail( hr )      if( FAILED(hr) ) goto lErr;

// String macros
//
#define AddPath( sz, szAdd )  { if(sz[lstrlen(sz)-1] != '\\') lstrcat(sz, "\\" ); lstrcat(sz,szAdd); }

// Misc constants
//
#define KB                    ( 1024 )
#define MAX_WSPRINTF_BUF      ( 1024 )

// Misc macros
//
#define Reference(x)          if( x ) {INT i=0;}

// OutputDebugString functions
//
#define ODS(sz)               OutputDebugString(sz)
#define ODS_1(t,v1)           { char sz[256]; wsprintf(sz,t,v1); ODS(sz); }


#endif  // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdmlog\wmdmlog.cpp ===
// WmdmLog.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f WmdmLogps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "WmdmLog.h"

#include <WmdmLog_i.c>
#include <WMDMLogger.h>

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_WMDMLogger, CWMDMLogger)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
	_Module.Init(ObjectMap, hInstance);
	DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	_Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdmlog\wmdmlogger.cpp ===
// WMDMLogger.cpp : Implementation of CWMDMLogger
//
#include "stdafx.h"
#include "wmdmlog.h"
#include "WMDMLogger.h"
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#define REGKEY_WMDM_ROOT    "Software\\Microsoft\\Windows Media Device Manager"
#define REGVAL_LOGENABLED   "Log.Enabled"
#define REGVAL_LOGFILE      "Log.Filename"
#define REGVAL_MAXSIZE      "Log.MaxSize"
#define REGVAL_SHRINKTOSIZE "Log.ShrinkToSize"

#define MUTEX_REGISTRY      "WMDMLogger.Registry.Mutex"
#define MUTEX_LOGFILE       "WMDMLogger.LogFile.Mutex"

#define READ_BUF_SIZE       4*1024

#define CRLF                "\r\n"


/////////////////////////////////////////////////////////////////////
//
// CWMDMLogger
//
/////////////////////////////////////////////////////////////////////

CWMDMLogger::CWMDMLogger()
{
	HRESULT hr;

	// Save instance handle for easy access
	//
	m_hInst = _Module.GetModuleInstance();
	if( !m_hInst )
	{
		ExitOnFail( hr = E_FAIL );
	}

	// Create the mutex'es for coordinating access to
	// shared resources.
	//
	m_hMutexRegistry = CreateMutex( NULL, FALSE, MUTEX_REGISTRY );
	if( !m_hMutexRegistry )
	{
		ExitOnFail( hr = E_FAIL );
	}
	m_hMutexLogFile  = CreateMutex( NULL, FALSE, MUTEX_LOGFILE );
	if( !m_hMutexLogFile )
	{
		ExitOnFail( hr = E_FAIL );
	}

	// Get the initial values from the registry.  For values that
	// don't exist in the registry, the defaults will be used
	//
	hr = hrLoadRegistryValues();

lExit:

	// Save the return code from the constructor so it can be checked
	// in public methods.
	//
	m_hrInit = hr;
}

CWMDMLogger::~CWMDMLogger()
{
	// Close the mutex handles
	//
	if( NULL != m_hMutexRegistry )
	{
		CloseHandle( m_hMutexRegistry );
	}
	if( NULL != m_hMutexLogFile )
	{
		CloseHandle( m_hMutexLogFile );
	}
}

HRESULT CWMDMLogger::hrWaitForAccess( HANDLE hMutex )
{
	HRESULT hr;
	DWORD   dwWaitRetVal;
	static  DWORD dwTimeout    = 0;
	static  BOOL  fHaveTimeout = FALSE;

	if( !fHaveTimeout )
	{
		hr = hrGetResourceDword( IDS_MUTEX_TIMEOUT, &dwTimeout );
		ExitOnFail( hr );

		fHaveTimeout = TRUE;
	}

	if( 0 == dwTimeout )
	{
		dwTimeout = INFINITE;
	}

	dwWaitRetVal = WaitForSingleObject( hMutex, dwTimeout );

	if( WAIT_FAILED == dwWaitRetVal )
	{
		ExitOnFail( hr = E_FAIL );
	}
	if( WAIT_TIMEOUT == dwWaitRetVal )
	{
		ExitOnFail( hr = E_ABORT );
	}

	hr = S_OK;

lExit:

	return hr;
}

HRESULT CWMDMLogger::hrGetResourceDword( UINT uStrID, LPDWORD pdw )
{
	HRESULT hr;
	CHAR    szDword[64];

	// Check params
	//
	if( !pdw )
	{
                hr = E_INVALIDARG;
		ExitOnFail( hr );
	}

	LoadString( m_hInst, uStrID, szDword, sizeof(szDword) );

	*pdw = (DWORD) atol( szDword );

	hr = S_OK;

lExit:

	return hr;
}

HRESULT CWMDMLogger::hrGetDefaultFileName( LPSTR szFilename, DWORD cchFilename )
{
	HRESULT hr;
	UINT    uRet;
	CHAR    szLogFile[MAX_PATH];

	uRet = GetSystemDirectory( szFilename, cchFilename );
	if( 0 == uRet )
	{
		ExitOnFail( hr = E_FAIL );
	}

	LoadString( m_hInst, IDS_DEF_LOGFILE, szLogFile, sizeof(szLogFile) );

	AddPath( szFilename, szLogFile );

	hr = S_OK;

lExit:

	return hr;
}

HRESULT CWMDMLogger::hrLoadRegistryValues()
{
	HRESULT hr     = S_OK;
	BOOL    fMutex = FALSE;
	HKEY    hKey   = NULL;
	LONG    lRetVal;
	DWORD   dwType;
	DWORD   dwDataLen;
	DWORD   dwEnabled;

	// Coordinate access to the shared registry value
	//
	hr = hrWaitForAccess( m_hMutexRegistry );
	ExitOnFail( hr );

	fMutex = TRUE;

	// Open the root WMDM registry key
	//
	lRetVal = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		REGKEY_WMDM_ROOT,
		0,
		KEY_QUERY_VALUE | KEY_SET_VALUE,
		&hKey
	);
	if( ERROR_SUCCESS != lRetVal )
	{
		ExitOnFail( hr = HRESULT_FROM_WIN32(lRetVal) );
	}

	// Get the enabled status of the logfile
	//
	dwDataLen = sizeof( dwEnabled );

	lRetVal = RegQueryValueEx(
		hKey,
		REGVAL_LOGENABLED,
		NULL,
		&dwType,
		(LPBYTE)&dwEnabled,
		&dwDataLen
	);
	if( ERROR_SUCCESS != lRetVal || dwType != REG_DWORD )
	{
		// No existing value, use the default
		//
		hr = hrGetResourceDword( IDS_DEF_LOGENABLED, &dwEnabled );
		ExitOnFail( hr );
	}

	m_fEnabled = ( dwEnabled != 0 );

	// Check if the log filename value already exists
	//
	dwDataLen = sizeof( m_szFilename );

	lRetVal = RegQueryValueEx(
		hKey,
		REGVAL_LOGFILE,
		NULL,
		&dwType,
		(LPBYTE)m_szFilename,
		&dwDataLen
	);
	if( ERROR_SUCCESS != lRetVal || dwType != REG_SZ )
	{
		CHAR szDefLogFile[MAX_PATH];

		// No existing value, so form the default log filename
		//
		hr = hrGetDefaultFileName( szDefLogFile, sizeof(szDefLogFile) );
		ExitOnFail( hr );

		// Set the default log filename
		//
		hr = hrSetLogFileName( szDefLogFile );
		ExitOnFail( hr );
	}

	// Get the maximum size for the logfile
	//
	dwDataLen = sizeof( m_dwMaxSize );

	lRetVal = RegQueryValueEx(
		hKey,
		REGVAL_MAXSIZE,
		NULL,
		&dwType,
		(LPBYTE)&m_dwMaxSize,
		&dwDataLen
	);
	if( ERROR_SUCCESS != lRetVal || dwType != REG_DWORD )
	{
		// No existing value, use the default
		//
		hr = hrGetResourceDword( IDS_DEF_MAXSIZE, &m_dwMaxSize );
		ExitOnFail( hr );
	}

	// Get the shrink-to size for the logfile
	//
	dwDataLen = sizeof( m_dwShrinkToSize );

	lRetVal = RegQueryValueEx(
		hKey,
		REGVAL_SHRINKTOSIZE,
		NULL,
		&dwType,
		(LPBYTE)&m_dwShrinkToSize,
		&dwDataLen
	);
	if( ERROR_SUCCESS != lRetVal || dwType != REG_DWORD )
	{
		// No existing value, use the default
		//
		hr = hrGetResourceDword( IDS_DEF_SHRINKTOSIZE, &m_dwShrinkToSize );
		ExitOnFail( hr );
	}

	// Set the file size params
	//
	hr = hrSetSizeParams( m_dwMaxSize, m_dwShrinkToSize );
	ExitOnFail( hr );

	hr = S_OK;

lExit:

	if( hKey )
	{
		RegCloseKey( hKey );
	}

	// Release the mutex
	//
	if( fMutex )
	{
		ReleaseMutex( m_hMutexRegistry );
	}

	return hr;
}


HRESULT CWMDMLogger::hrSetLogFileName(
	LPSTR pszFilename
)
{
	HRESULT hr     = S_OK;
	BOOL    fMutex = FALSE;
	HKEY    hKey   = NULL;
	LONG    lRetVal;

	//
	// Make sure that the new file name can be copied; if it fails we want to retain the old file
	// name and fail the call.
	//
	if(lstrlen(pszFilename) >= MAX_PATH )
	{
	    return E_INVALIDARG;
	}
	
	// Coordinate access to the shared registry value
	//
	hr = hrWaitForAccess( m_hMutexRegistry );
	ExitOnFail( hr );

	fMutex = TRUE;


	// Open the root WMDM registry key
	//
	lRetVal = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		REGKEY_WMDM_ROOT,
		0,
		KEY_SET_VALUE,
		&hKey
	);
	if( ERROR_SUCCESS != lRetVal )
	{
		ExitOnFail( hr = HRESULT_FROM_WIN32(lRetVal) );
	}

	// Set the LogFilename value
	//
	lRetVal = RegSetValueEx(
	                        hKey,
				REGVAL_LOGFILE,
				0L,
				REG_SZ,
				(LPBYTE)pszFilename,
				lstrlen(pszFilename)+1
				);
	if( ERROR_SUCCESS != lRetVal )
	{
	    ExitOnFail( hr = HRESULT_FROM_WIN32(lRetVal) );
	}

	// Set the local member data to the new log filename
	//
	hr = StringCbCopy(m_szFilename, sizeof(m_szFilename), pszFilename);
	if(FAILED(hr))
	{
	    // we need to undo the registry setting. 
	    goto lExit;
	    
	}

lExit:

	if( hKey )
	{
		RegCloseKey( hKey );
	}

	// Release the mutex
	//
	if( fMutex )
	{
		ReleaseMutex( m_hMutexRegistry );
	}

	return S_OK;
}

HRESULT CWMDMLogger::hrCheckFileSize( void )
{
	HRESULT hr;
	BOOL    fMutex     = FALSE;
	HANDLE  hFile      = INVALID_HANDLE_VALUE;
	HANDLE  hFileTemp  = INVALID_HANDLE_VALUE;
	LPBYTE  lpbData    = NULL;
	DWORD   dwSize;
	CHAR    szTempPath[MAX_PATH];
	CHAR    szTempFile[MAX_PATH];

	// Coordinate access to the shared logfile
	//
	hr = hrWaitForAccess( m_hMutexLogFile );
	ExitOnFail( hr );

	fMutex = TRUE;

	// Open the logfile
	//
	hFile = CreateFile(
		m_szFilename,
		GENERIC_READ,
		0,
		NULL,
		OPEN_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		NULL
	);
	if( INVALID_HANDLE_VALUE == hFile )
	{
		ExitOnFail( hr = E_ACCESSDENIED );
	}

	// Get the current size of the logfile
	//
	dwSize = GetFileSize( hFile, NULL );
	
	// Check if file needs to be trimmed
	//
	if( dwSize > m_dwMaxSize )
	{
		// Trim file to approximately m_dwShrinkToSize bytes
		//
		DWORD  dwTrimBytes = dwSize - m_dwShrinkToSize;
		DWORD  dwRead;
		DWORD  dwWritten;

		// Get the temp directory
		//
		if( 0 == GetTempPath(sizeof(szTempPath), szTempPath) )
		{
			ExitOnFail( hr = E_FAIL );
		}

		// Create a temp filename
		//
		if( 0 == GetTempFileName(szTempPath, "WMDM", 0, szTempFile) )
		{
			ExitOnFail( hr = E_FAIL );
		}

		// Open the temp file for writing
		//
		hFileTemp = CreateFile(
			szTempFile,
			GENERIC_WRITE,
			0,
			NULL,
			CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL,
			NULL
		);
		if( INVALID_HANDLE_VALUE == hFileTemp )
		{
			ExitOnFail( hr = E_ACCESSDENIED );
		}

		// Set the read pointer of the existing logfile to the
		// approximate trim position 
		///
		SetFilePointer( hFile, dwTrimBytes, NULL, FILE_BEGIN );

		// Allocate buffer for file reads
		//
		lpbData = (LPBYTE) CoTaskMemAlloc( READ_BUF_SIZE );
		if( !lpbData )
		{
			ExitOnFail( hr = E_OUTOFMEMORY );
		}

		// Read in the first chunk of the file, and search for the end of
		// the current line (a CRLF).  Write everything after that CRLF to 
		// the temp file.  If thee is no CRLF, then write the entire packet 
		// to the temp file.
		//
		if( ReadFile(hFile, lpbData, READ_BUF_SIZE, &dwRead, NULL) && dwRead > 0 )
		{
			LPBYTE lpb = lpbData;

			while( ((DWORD_PTR)lpb-(DWORD_PTR)lpbData < dwRead-1) && (*lpb != '\r' && *(lpb+1) != '\n') )
			{
				lpb++;
			}
			if( (DWORD_PTR)lpb-(DWORD_PTR)lpbData < dwRead-1 )
			{
				// Must have found a CRLF... skip it
				lpb += 2;
			}
			else
			{
				// No CRLF found... write entire packet to temp file
				lpb = lpbData;
			}
			WriteFile(
				hFileTemp,
				lpb,
				(DWORD)(dwRead - ( (DWORD_PTR)lpb - (DWORD_PTR)lpbData )),
				&dwWritten,
				NULL
			);
		}

		// Read the rest of the logfile and write it to the temp file
		//
		while( ReadFile(hFile, lpbData, READ_BUF_SIZE, &dwRead, NULL) && dwRead > 0 )
		{
			WriteFile(
				hFileTemp,
				lpbData,
				dwRead,
				&dwWritten,
				NULL
			);
		}

		// Close the open file handles
		//
		CloseHandle( hFile );
		hFile = INVALID_HANDLE_VALUE;

		CloseHandle( hFileTemp );
		hFileTemp = INVALID_HANDLE_VALUE;

		// Replace the current logfile with the temp file
		//
		DeleteFile( m_szFilename );
		MoveFile( szTempFile, m_szFilename );
	}

	hr = S_OK;

lExit:

	// Close any open file handles
	//
	if( INVALID_HANDLE_VALUE != hFile )
	{
		CloseHandle( hFile );
	}
	if( INVALID_HANDLE_VALUE != hFileTemp )
	{
		CloseHandle( hFileTemp );
	}

	// Free any allocated memory
	//
	if( lpbData )
	{
		CoTaskMemFree( lpbData );
	}

	// Release the mutex
	//
	if( fMutex )
	{
		ReleaseMutex( m_hMutexLogFile );
	}

	return hr;
}

HRESULT CWMDMLogger::hrSetSizeParams(
	DWORD dwMaxSize,
	DWORD dwShrinkToSize
)
{
	HRESULT hr     = S_OK;
	BOOL    fMutex = FALSE;
	HKEY    hKey   = NULL;
	LONG    lRetVal;

	// Coordinate access to the shared registry value
	//
	hr = hrWaitForAccess( m_hMutexRegistry );
	ExitOnFail( hr );

	fMutex = TRUE;

	// Open the root WMDM registry key
	//
	lRetVal = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		REGKEY_WMDM_ROOT,
		0,
		KEY_SET_VALUE,
		&hKey
	);
	if( ERROR_SUCCESS != lRetVal )
	{
		ExitOnFail( hr = HRESULT_FROM_WIN32(lRetVal) );
	}

	// Set the MaxSize value
	//
	lRetVal = RegSetValueEx(
		hKey,
		REGVAL_MAXSIZE,
		0L,
		REG_DWORD,
		(LPBYTE)&dwMaxSize,
		sizeof(dwMaxSize)
	);
	if( ERROR_SUCCESS != lRetVal )
	{
		ExitOnFail( hr = HRESULT_FROM_WIN32(lRetVal) );
	}

	// Set the ShrinkToSize value
	//
	lRetVal = RegSetValueEx(
		hKey,
		REGVAL_SHRINKTOSIZE,
		0L,
		REG_DWORD,
		(LPBYTE)&dwShrinkToSize,
		sizeof(dwShrinkToSize)
	);
	if( ERROR_SUCCESS != lRetVal )
	{
		ExitOnFail( hr = HRESULT_FROM_WIN32(lRetVal) );
	}

	// Set the local member data
	//
	m_dwMaxSize      = dwMaxSize;
	m_dwShrinkToSize = dwShrinkToSize;

	hr = S_OK;

lExit:

	if( hKey )
	{
		RegCloseKey( hKey );
	}

	// Release the mutex
	//
	if( fMutex )
	{
		ReleaseMutex( m_hMutexRegistry );
	}

	return S_OK;
}


HRESULT CWMDMLogger::hrEnable(
	BOOL fEnable
)
{
	HRESULT hr       = S_OK;
	BOOL    fMutex   = FALSE;
	HKEY    hKey     = NULL;
	DWORD   dwEnable = ( fEnable ? 1L : 0L );
	LONG    lRetVal;

	// Coordinate access to the shared registry value
	//
	hr = hrWaitForAccess( m_hMutexRegistry );
	ExitOnFail( hr );

	fMutex = TRUE;

	// Open the root WMDM registry key
	//
	lRetVal = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		REGKEY_WMDM_ROOT,
		0,
		KEY_SET_VALUE,
		&hKey
	);
	if( ERROR_SUCCESS != lRetVal )
	{
		ExitOnFail( hr = HRESULT_FROM_WIN32(lRetVal) );
	}

	// Set the Enabled value
	//
	lRetVal = RegSetValueEx(
		hKey,
		REGVAL_LOGENABLED,
		0L,
		REG_DWORD,
		(LPBYTE)&dwEnable,
		sizeof(dwEnable)
	);
	if( ERROR_SUCCESS != lRetVal )
	{
		ExitOnFail( hr = HRESULT_FROM_WIN32(lRetVal) );
	}

	// Set the local member data
	//
	m_fEnabled = fEnable;

	hr = S_OK;

lExit:

	if( hKey )
	{
		RegCloseKey( hKey );
	}

	// Release the mutex
	//
	if( fMutex )
	{
		ReleaseMutex( m_hMutexRegistry );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////
//
// IWMDMLogger Methods
//
/////////////////////////////////////////////////////////////////////

HRESULT CWMDMLogger::GetLogFileName(
	LPSTR pszFilename,
	UINT  nMaxChars
)
{
	HRESULT hr;

	// Check init error status
	//
	ExitOnFail( hr = m_hrInit );

	// Check for invalid arguments
	//
	if( !pszFilename )
	{
		ExitOnFail( hr = E_INVALIDARG );
	}

	// Make sure the log filename will fit in the output buffer
	//
	if( (UINT)lstrlen(m_szFilename)+1 > nMaxChars )
	{
		//BUGBUG: better return code
		ExitOnFail( hr = E_FAIL );
	}

	// Copy the log filename to output buffer
	//
	lstrcpy( pszFilename, m_szFilename  );

	hr = S_OK;

lExit:

	return hr;
}

HRESULT CWMDMLogger::SetLogFileName(
	LPSTR pszFilename
)
{
	HRESULT hr;

	// Check init error status
	//
	ExitOnFail( hr = m_hrInit );

	// Check for invalid arguments
	//
	if( !pszFilename )
	{
		ExitOnFail( hr = E_INVALIDARG );
	}

	hr = hrSetLogFileName( pszFilename );

lExit:

	return hr;
}


HRESULT CWMDMLogger::GetSizeParams(
	LPDWORD pdwMaxSize,
	LPDWORD pdwShrinkToSize
)
{
	HRESULT hr;

	// Check init error status
	//
	ExitOnFail( hr = m_hrInit );

	if( pdwMaxSize )
	{
		*pdwMaxSize = m_dwMaxSize;
	}
	if( pdwShrinkToSize )
	{
		*pdwShrinkToSize = m_dwShrinkToSize;
	}

	hr = S_OK;

lExit:

	return hr;
}

HRESULT CWMDMLogger::SetSizeParams(
	DWORD dwMaxSize,
	DWORD dwShrinkToSize
)
{
	HRESULT hr;

	// Check init error status
	//
	ExitOnFail( hr = m_hrInit );

	// Check params
	//
	if( dwShrinkToSize >= dwMaxSize )
	{
		ExitOnFail( hr = E_INVALIDARG );
	}

	hr = hrSetSizeParams( dwMaxSize, dwShrinkToSize );

lExit:

	return hr;
}

HRESULT CWMDMLogger::IsEnabled(
	BOOL *pfEnabled
)
{
	HRESULT hr;

	// Check init error status
	//
	ExitOnFail( hr = m_hrInit );

	if( pfEnabled )
	{
		*pfEnabled = m_fEnabled;
	}

	hr = S_OK;

lExit:

	return hr;
}

HRESULT CWMDMLogger::Enable(
	BOOL fEnable
)
{
	HRESULT hr;

	// Check init error status
	//
	ExitOnFail( hr = m_hrInit );

	hr = hrEnable( fEnable );

lExit:

	return hr;
}

HRESULT CWMDMLogger::LogString(
	DWORD dwFlags,
	LPSTR pszSrcName,
	LPSTR pszLog
)
{
	HRESULT hr;
	BOOL    fMutex = FALSE;
	HANDLE  hFile  = INVALID_HANDLE_VALUE;
	DWORD   dwWritten;
	CHAR    szPreLog[MAX_PATH];

	// Check init error status
	//
	ExitOnFail( hr = m_hrInit );

	// Coordinate access to the shared logfile
	//
	hr = hrWaitForAccess( m_hMutexLogFile );
	ExitOnFail( hr );

	fMutex = TRUE;

	// Check the file size params and adjust the file appropriately
	//
	hr = hrCheckFileSize();
	ExitOnFail( hr );

	// Open the logfile
	//
	hFile = CreateFile(
		m_szFilename,
		GENERIC_WRITE,
		0,
		NULL,
		OPEN_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		NULL
	);
	if( INVALID_HANDLE_VALUE == hFile )
	{
		ExitOnFail( hr = E_ACCESSDENIED );
	}

	// Seek to the end of the logfile
	//
	SetFilePointer( hFile, 0, NULL, FILE_END );

	// Put timestamp on log entry unless the flags say not to
	//
	if( !(dwFlags & WMDM_LOG_NOTIMESTAMP) )
	{
		CHAR       szFormat[MAX_PATH];
		SYSTEMTIME sysTime;

		GetLocalTime( &sysTime );

		LoadString( m_hInst, IDS_LOG_DATETIME, szFormat, sizeof(szFormat) );

		wsprintf(
			szPreLog, szFormat,
			sysTime.wYear, sysTime.wMonth,  sysTime.wDay,
			sysTime.wHour, sysTime.wMinute, sysTime.wSecond
		);

		WriteFile( hFile, szPreLog, lstrlen(szPreLog), &dwWritten, NULL );
	}

	// Log the component name
	//
	if( pszSrcName )
	{
		CHAR szFormat[MAX_PATH];

		LoadString( m_hInst, IDS_LOG_SRCNAME, szFormat, sizeof(szFormat) );
		wsprintf( szPreLog, szFormat, pszSrcName );

		WriteFile( hFile, szPreLog, lstrlen(szPreLog), &dwWritten, NULL );
	}

	// Log the severity
	//
	if( dwFlags & WMDM_LOG_SEV_ERROR )
	{
		LoadString( m_hInst, IDS_LOG_SEV_ERROR, szPreLog, sizeof(szPreLog) );
	}
	else if( dwFlags & WMDM_LOG_SEV_WARN )
	{
		LoadString( m_hInst, IDS_LOG_SEV_WARN, szPreLog, sizeof(szPreLog) );
	}
	else if( dwFlags & WMDM_LOG_SEV_INFO )
	{
		LoadString( m_hInst, IDS_LOG_SEV_INFO, szPreLog, sizeof(szPreLog) );
	}
	else
	{
		*szPreLog = '\0';
	}

	WriteFile( hFile, szPreLog, lstrlen(szPreLog), &dwWritten, NULL );

	// Write the logstring to the logfile followed by a CRLF
	//
	if( pszLog )
	{
		WriteFile( hFile, pszLog, lstrlen(pszLog), &dwWritten, NULL );
	}

	// End with a carriage return and line feed
	//
	WriteFile( hFile, CRLF, lstrlen(CRLF), &dwWritten, NULL );

	hr = S_OK;

lExit:

	if( INVALID_HANDLE_VALUE != hFile )
	{
		CloseHandle( hFile );
	}

	// Release the mutex
	//
	if( fMutex )
	{
		ReleaseMutex( m_hMutexLogFile );
	}

	return hr;
}


HRESULT CWMDMLogger::LogDword(
	DWORD   dwFlags,
	LPSTR   pszSrcName,
	LPSTR   pszLogFormat,
	DWORD   dwLog
)
{
	HRESULT hr;
	LPSTR   pszLog = NULL;

	// Check init error status
	//
	ExitOnFail( hr = m_hrInit );

	// Check params
	//
	if( !pszLogFormat )
	{
		ExitOnFail( hr = E_INVALIDARG );
	}

	// Allocate space for the final log text
	//
	pszLog = (LPSTR) CoTaskMemAlloc( MAX_WSPRINTF_BUF );
	if( !pszLog )
	{
		ExitOnFail( hr = E_OUTOFMEMORY );
	}

	// Create log string
	//
	wsprintf( pszLog, pszLogFormat, dwLog );

	// Log the string
	//
	hr = LogString( dwFlags, pszSrcName, pszLog );

lExit:

	if( pszLog )
	{
		CoTaskMemFree( pszLog );
	}

	return hr;
}

HRESULT CWMDMLogger::Reset(
	void
)
{
	HRESULT hr;
	BOOL    fMutex = FALSE;
	HANDLE  hFile  = INVALID_HANDLE_VALUE;

	// Check init error status
	//
	ExitOnFail( hr = m_hrInit );

	// Coordinate access to the shared logfile
	//
	hr = hrWaitForAccess( m_hMutexLogFile );
	ExitOnFail( hr );

	fMutex = TRUE;

	// Open the logfile with CREATE_ALWAYS to truncate the file
	//
	hFile = CreateFile(
		m_szFilename,
		GENERIC_WRITE,
		0,
		NULL,
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		NULL
	);
	if( INVALID_HANDLE_VALUE == hFile )
	{
		ExitOnFail( hr = E_ACCESSDENIED );
	}

	hr = S_OK;

lExit:

	if( INVALID_HANDLE_VALUE != hFile )
	{
		CloseHandle( hFile );
	}

	// Release the mutex
	//
	if( fMutex )
	{
		ReleaseMutex( m_hMutexLogFile );
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdmps\dlldata_stub.c ===
#include "dlldata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdmps\mswmdm_i_stub.c ===
#include "mswmdm_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdmps\mswmdm_p_stub.c ===
#include "mswmdm_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\wmdm_sr1\wmdmlog\wmdmlogger.h ===
// WMDMLogger.h : Declaration of the CWMDMLogger

#ifndef __WMDMLOGGER_H_
#define __WMDMLOGGER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWMDMLogger

class ATL_NO_VTABLE CWMDMLogger : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWMDMLogger, &CLSID_WMDMLogger>,
	public IWMDMLogger
{
public:
	CWMDMLogger();
	~CWMDMLogger();

DECLARE_REGISTRY_RESOURCEID(IDR_WMDMLOGGER)


BEGIN_COM_MAP(CWMDMLogger)
	COM_INTERFACE_ENTRY(IWMDMLogger)
END_COM_MAP()

public:
    
	// IWMDMLogger Methods
	//
	STDMETHOD(IsEnabled)(
		BOOL *pfEnabled
	);
	STDMETHOD(Enable)(
		BOOL fEnable
	);
	STDMETHOD(GetLogFileName)(
		LPSTR pszFilename,
		UINT  nMaxChars
	);
	STDMETHOD(SetLogFileName)(
		LPSTR pszFilename
	);
	STDMETHOD(LogString)(
		DWORD dwFlags,
		LPSTR pszSrcName,
		LPSTR pszLog
	);
	STDMETHOD(LogDword)(
		DWORD   dwFlags,
		LPSTR   pszSrcName,
		LPSTR   pszLogFormat,
		DWORD   dwLog
	);
	STDMETHOD(Reset)(
		void
	);
	STDMETHOD(GetSizeParams)(
		LPDWORD pdwMaxSize,
		LPDWORD pdwShrinkToSize
	);
	STDMETHOD(SetSizeParams)(
		DWORD dwMaxSize,
		DWORD dwShrinkToSize
	);
    
private:

	HINSTANCE m_hInst;
	HRESULT   m_hrInit;
	CHAR      m_szFilename[MAX_PATH];

	BOOL      m_fEnabled;

	DWORD     m_dwMaxSize;
	DWORD     m_dwShrinkToSize;

	HANDLE    m_hMutexRegistry;
	HANDLE    m_hMutexLogFile;

	HRESULT   hrEnable( BOOL fEnable );
	HRESULT   hrGetResourceDword( UINT uStrID, LPDWORD pdw );
	HRESULT   hrLoadRegistryValues( void );
	HRESULT   hrGetDefaultFileName( LPSTR szFilename, DWORD cchFilename );
	HRESULT   hrSetLogFileName( LPSTR pszFilename );
	HRESULT   hrSetSizeParams( DWORD dwMaxSize, DWORD dwShrinkToSize );
	HRESULT   hrCheckFileSize( void );
	HRESULT   hrWaitForAccess( HANDLE hMutex );

};

#endif //__WMDMLOGGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\kdext\c.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

	common.h

Abstract:

	Common header for the basic functionality tests for the RM APIs

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	josephj     01-13-99    Created

Notes:

--*/
#ifdef TESTPROGRAM

#include "rmtest.h"

#define ALLOCSTRUCT(_type) (_type *)LocalAlloc(LPTR, sizeof(_type))
#define FREE(_ptr)  LocalFree(_ptr)

#if RM_EXTRA_CHECKING
#define LOCKOBJ(_pObj, _psr) \
			RmWriteLockObject(&(_pObj)->Hdr, dbg_func_locid, (_psr))
#else // !RM_EXTRA_CHECKING
#define LOCKOBJ(_pObj, _psr) \
			RmWriteLockObject(&(_pObj)->Hdr, (_psr))
#endif // !RM_EXTRA_CHECKING

#define UNLOCKOBJ(_pObj, _psr) \
			RmUnlockObject(&(_pObj)->Hdr, (_psr))


#define EXIT()

#endif // TESTPROGRAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\kdext\common.h ===
#include <nt.h>
#include <ntverp.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include "util.h"
#include "parse.h"

//
// Handlers for top-level extension commands.
//

void
do_help(PCSTR args);

void
do_rm(PCSTR args);

void
do_arp(PCSTR args);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\kdext\dummy.c ===
#if TESTPROGRAM
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	dummy.c	- dummy global vars.

Abstract:


Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	josephj     03-30-98    Created

Notes:

--*/

#if 0
#include "c.h"

void test_AllocateObject(void);

void init_dummy_vars(void)
{
	test_AllocateObject();
}

void delete_dummy_vars(void)
{
	test_AllocateObject();
}

#endif // 0
#endif // TESTPROGRAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\kdext\dbgrm.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

	dbgrm.c	- DbgExtension Structure information specific to RM APIs

Abstract:


Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	josephj     03-01-99    Created

Notes:

--*/

#ifdef TESTPROGRAM
#include "c.h"
#else
#include "precomp.h"
#endif
#include "util.h"
#include "parse.h"
#include "dbgrm.h"

enum
{
    typeid_NULL,
    typeid_RM_OBJECT_HEADER,
    typeid_RM_TASK,
    typeid_RM_ASSOCIATIONS,
    typeid_RM_GROUP,
    typeid_RM_STACK_RECORD,
    typeid_RM_OBJECT_LOG,
    typeid_RM_OBJECT_TREE
};

//
// STRUCTURES CONCERNING TYPE "OBJECT_HEADER"
//

// Actually handles dumping of object info.
//
void
RmDumpObj(
	struct _TYPE_INFO *pType,
	UINT_PTR uAddr,
	char *szFieldSpec,
	UINT uFlags
	);

// Actually handles dumping of task info.
//
void
RmDumpTask(
	struct _TYPE_INFO *pType,
	UINT_PTR uAddr,
	char *szFieldSpec,
	UINT uFlags
	);


// Actually handles dumping of task info.
//
void
RmDumpGroup(
	struct _TYPE_INFO *pType,
	UINT_PTR uAddr,
	char *szFieldSpec,
	UINT uFlags
	);

// Actually handles dumping of task info.
//
void
RmDumpAssociations(
	struct _TYPE_INFO *pType,
	UINT_PTR uAddr,
	char *szFieldSpec,
	UINT uFlags
	);


// Actually handles dumping of task info.
//
void
RmDumpStackRecord(
	struct _TYPE_INFO *pType,
	UINT_PTR uAddr,
	char *szFieldSpec,
	UINT uFlags
	);

// Actually handles dumping of object log info.
//
void
RmDumpObjectLog(
	struct _TYPE_INFO *pType,
	UINT_PTR uAddr,
	char *szFieldSpec,
	UINT uFlags
	);

// Actually handles dumping of object decendents tree
//
void
RmDumpObjectTree(
	struct _TYPE_INFO *pType,
	UINT_PTR uAddr,
	char *szFieldSpec,
	UINT uFlags
	);


// Node function for dumping one node of the list of children.
//
ULONG
NodeFunc_DumpObjectTree (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	);

BITFIELD_INFO rgRM_OBJECT_STATE[] =
{

	{
	"O_ALLOC",
	RMOBJSTATE_ALLOCMASK,
	RMOBJSTATE_ALLOCATED
	},


	{
	"O_DEALLOC",
	RMOBJSTATE_ALLOCMASK,
	RMOBJSTATE_DEALLOCATED
	},

#if 0	// don't want this -- as it gets displayed for non-task, looking wierd.
	{
	"T_IDLE",
	RMTSKSTATE_MASK,
	RMTSKSTATE_IDLE
	},
#endif // 0

	{
	"T_STARTING",
	RMTSKSTATE_MASK,
	RMTSKSTATE_STARTING
	},

	{
	"T_ACTIVE",
	RMTSKSTATE_MASK,
	RMTSKSTATE_ACTIVE
	},

	{
	"T_PENDING",
	RMTSKSTATE_MASK,
	RMTSKSTATE_PENDING
	},

	{
	"T_ENDING",
	RMTSKSTATE_MASK,
	RMTSKSTATE_ENDING
	},

	{
	"T_DELAYED",
	RMTSKDELSTATE_MASK,
	RMTSKDELSTATE_DELAYED
	},

	{
	"T_ABORT_DELAY",
	RMTSKABORTSTATE_MASK,
	RMTSKABORTSTATE_ABORT_DELAY
	},

	{
	NULL
	}
};

TYPE_INFO type_RM_OBJECT_HEADER = {
    "RM_OBJECT_HEADER",
    "obj",
     typeid_RM_OBJECT_HEADER,
	 0, 						//fTYPEINFO_ISLIST,			// Flags
     sizeof(RM_OBJECT_HEADER),
     NULL,	// FIELD_INFO
     0,		// offset to next object.
     NULL,	// rgBitFieldInfo
	 RmDumpObj // pfnSpecializedDump
};

TYPE_INFO type_RM_TASK = {
    "RM_TASK",
    "tsk",
     typeid_RM_TASK,
	 0, 						//fTYPEINFO_ISLIST,			// Flags
     sizeof(RM_TASK),
     NULL,	// FIELD_INFO
     0,		// offset to next object.
     NULL,	// rgBitFieldInfo
	 RmDumpTask // pfnSpecializedDump
};

TYPE_INFO type_RM_GROUP = {
    "RM_GROUP",
    "grp",
     typeid_RM_GROUP,
	 0, 						//fTYPEINFO_ISLIST,			// Flags
     sizeof(RM_GROUP),
     NULL,	// FIELD_INFO
     0,		// offset to next object.
     NULL,	// rgBitFieldInfo
	 RmDumpGroup // pfnSpecializedDump
};


TYPE_INFO type_RM_ASSOCIATIONS = {
    "RM_ASSOCIATIONS",
    "asc",
     typeid_RM_ASSOCIATIONS,
	 0, 						//fTYPEINFO_ISLIST,			// Flags
     1,				//This is not really an object, but we must have nonzero size.
     NULL,	// FIELD_INFO
     0,		// offset to next object.
     NULL,	// rgBitFieldInfo
	 RmDumpAssociations // pfnSpecializedDump
};

TYPE_INFO type_RM_STACK_RECORD = {
    "RM_STACK_RECORD",
    "sr",
     typeid_RM_STACK_RECORD,
	 0, 						//fTYPEINFO_ISLIST,			// Flags
     sizeof(RM_STACK_RECORD),
     NULL,	// FIELD_INFO
     0,		// offset to next object.
     NULL,	// rgBitFieldInfo
	 RmDumpStackRecord // pfnSpecializedDump
};


TYPE_INFO type_RM_OBJECT_LOG = {
    "RM_OBJECT_LOG",
    "log",
     //typeid_RM_STACK_RECORD,
     typeid_RM_OBJECT_LOG,
	 0, 						//fTYPEINFO_ISLIST,			// Flags
     1,				//This is not really an object, but we must have nonzero size.
     NULL,	// FIELD_INFO
     0,		// offset to next object.
     NULL,	// rgBitFieldInfo
	 RmDumpObjectLog // pfnSpecializedDump
};

TYPE_INFO type_RM_OBJECT_TREE = {

    "RM_OBJECT_TREE",
    "tree",
     typeid_RM_OBJECT_TREE,
	 0, 						//fTYPEINFO_ISLIST,			// Flags
     1,				//This is not really an object, but we must have nonzero size.
     NULL,	// FIELD_INFO
     0,		// offset to next object.
     NULL,	// rgBitFieldInfo
	 RmDumpObjectTree // pfnSpecializedDump
};




TYPE_INFO *g_rgRM_Types[] =
{
    &type_RM_OBJECT_HEADER,
    &type_RM_TASK,
    &type_RM_GROUP,
    &type_RM_ASSOCIATIONS,
    &type_RM_STACK_RECORD,
    &type_RM_OBJECT_LOG,
    &type_RM_OBJECT_TREE,

    NULL
};


UINT_PTR
RM_ResolveAddress(
		TYPE_INFO *pType
		);

NAMESPACE RM_NameSpace = {
			g_rgRM_Types,
			NULL, // g_rgRM_Globals,
			RM_ResolveAddress
			};


UINT_PTR
RM_ResolveAddress(
		TYPE_INFO *pType
		)
{
	return 0;
}


void
do_rm(PCSTR args)
{

	DBGCOMMAND *pCmd = Parse(args, &RM_NameSpace);
	if (pCmd)
	{
		DumpCommand(pCmd);
		DoCommand(pCmd, NULL);
		FreeCommand(pCmd);
		pCmd = NULL;
	}

    return;

}

void
do_help(PCSTR args)
{
    return;
}

void
dump_object_fields(UINT_PTR uAddr, PRM_OBJECT_HEADER pObj);

// Actually handles dumping of object info.
//
void
RmDumpObj(
	struct _TYPE_INFO *pType,
	UINT_PTR uAddr,
	char *szFieldSpec,
	UINT uFlags
	)
/*++
	!rm obj 0x838c7560

	Object 0x838c7560 (LocalIP)
	  Hdr
		 Sig  :A13L 			State:0xc4db69b3  	   Refs:990
		 pLock: 0x838c7560		pSIinfo:0xfdd0a965	pDInfo :0xd54d947c
		 pParent: 0x2995941a	pRoot:0x060af4a8	pHLink :0xce4294fe
		 HdrSize: 0x123			Assoc:909
--*/
{
	RM_OBJECT_HEADER Obj;
	bool			  fRet;

	do
	{
		char rgDescriptionBuf[256];

		// First let's read the pObj structure.
		//
		fRet = dbgextReadMemory(
				uAddr,
				&Obj,
				sizeof(Obj),
				"RM_OBJECT_HEADER"
				);

		if (!fRet) break;

		// Try to read the object's description.
		//
		fRet = dbgextReadSZ(
					(UINT_PTR) Obj.szDescription,
					rgDescriptionBuf,
					sizeof(rgDescriptionBuf),
					"Obj.szDescription"
					);

		if (!fRet) break;

		MyDbgPrintf("\nObject 0x%p (%s)\n", uAddr, rgDescriptionBuf);

		dump_object_fields(uAddr, &Obj);


	} while(FALSE);
	
}

// Actually handles dumping of task info.
//
void
RmDumpTask(
	struct _TYPE_INFO *pType,
	UINT_PTR uAddr,
	char *szFieldSpec,
	UINT uFlags
	)
{
	RM_TASK Task;
	bool			  fRet;

	do
	{
		char rgDescriptionBuf[256];

		// First let's read the pObj structure.
		//
		fRet = dbgextReadMemory(
				uAddr,
				&Task,
				sizeof(Task),
				"RM_OBJECT_HEADER"
				);

		if (!fRet) break;

		// Try to read the object's description.
		//
		fRet = dbgextReadSZ(
					(UINT_PTR) Task.Hdr.szDescription,
					rgDescriptionBuf,
					sizeof(rgDescriptionBuf),
					"Task.Hdr.szDescription"
					);

		if (!fRet) break;

		//  Dump the object header
		//
		{
			MyDbgPrintf("\nTask 0x%p (%s)\n", uAddr, rgDescriptionBuf);
			dump_object_fields(uAddr, &Task.Hdr);
		}

		//
		// Now Dump the task-specific fields...
		//
		{
			/*
			TskHdr
				pfn: 0x5399424c			State:0x812d7211(IDLE) SCtxt:0x050eefc4
				pBlkTsk:0x377c74bc		lnkFellows:0x2b88126f
				Pending Tasks
					0x84215fa5 0xb51f9e9e 0x9e954e81 0x696095b9
					0x0c07aeff
			*/

			MyDbgPrintf(
				"    TaskHdr:\n"
		"            pfn:0x%p            SCtxt:0x%08lx\n",
				Task.pfnHandler,
				Task.SuspendContext
				);
			MyDbgPrintf(
				"        pBlkTsk:0x%p       lnkFellows:0x%p\n",
				Task.pTaskIAmPendingOn,
				&(((PRM_TASK) uAddr)->linkFellowPendingTasks)
				);

			// Note we can't use IsListEmpty because of the different address space.
			//
			if (Task.listTasksPendingOnMe.Flink == Task.listTasksPendingOnMe.Blink)
			{
				MyDbgPrintf("    No pending tasks.\n");
			}
			else
			{

				MyDbgPrintf("    Pending tasks:\n");
				dbgextDumpDLlist(
					(UINT_PTR) &(((PRM_TASK) uAddr)->listTasksPendingOnMe),
					FIELD_OFFSET(RM_TASK, linkFellowPendingTasks),
					"Pending tasks list"
					);
			}

		}

	} while(FALSE);
	
}

void
dbg_walk_rm_hash_table(
	PRM_HASH_TABLE pTable,
	UINT	uContainingOffset,
	char *szDescription

	);

#if RM_EXTRA_CHECKING
void
dbg_print_rm_associations(
		PRM_HASH_TABLE pRmAssociationHashTable,
		UINT MaxToPrint
		);
void
dbg_print_object_log_entries(
	UINT_PTR uObjectListOffset,
	UINT MaxToPrint
	);

#endif // RM_EXTRA_CHECKING

// Actually handles dumping of task info.
//
void
RmDumpGroup(
	struct _TYPE_INFO *pType,
	UINT_PTR uAddr,
	char *szFieldSpec,
	UINT uFlags
	)
/*
	!rm grp 0x838c7560

	Group 0x4d650b98 (LocalIP Group) of object 0x11eafd78 (Interface)
	Num:11 State:ENABLED	pSInfo: 0x944b6d1b pULTsk: 0x8c312bca
	Members:
		0x8db3267c 0xa639f663 0x8f3530a6 0xa4bfe0b9
		0x995dd9bf 0x61e1344b 0xd6323f50 0x606339fd
		0x2e8ed2a4 0x62e52f27 0xa82b59ab
*/
{
	RM_GROUP Group;
	bool	fRet;

	do
	{
		char rgDescriptionBuf[256];
		char rgOwningObjectDescriptionBuf[256];

		// First let's read the Group structure.
		//
		fRet = dbgextReadMemory(
				uAddr,
				&Group,
				sizeof(Group),
				"RM_GROUP"
				);

		if (!fRet) break;

		// Try to read the group's description.
		//
		fRet = dbgextReadSZ(
					(UINT_PTR) Group.szDescription,
					rgDescriptionBuf,
					sizeof(rgDescriptionBuf),
					"Obj.szDescription"
					);

		if (!fRet) break;

		// Try to read the owning object's description.
		//
		do {
			UINT_PTR uAddress;
			fRet =  dbgextReadUINT_PTR(
								(UINT_PTR) &(Group.pOwningObject->szDescription),
								&uAddress,
								"Owning Obj.szDescription ptr"
								);

			if (!fRet) break;

			fRet = dbgextReadSZ(
						uAddress,
						rgOwningObjectDescriptionBuf,
						sizeof(rgOwningObjectDescriptionBuf),
						"Owning Obj.szDescription"
						);

		} while (FALSE);

		if (!fRet)
		{
			*rgOwningObjectDescriptionBuf = 0;
		}

		MyDbgPrintf(
			"\nGroup 0x%p (%s) of object 0x%p (%s)\n",
			uAddr,
			rgDescriptionBuf,
			Group.pOwningObject,
			rgOwningObjectDescriptionBuf
			);

		MyDbgPrintf(
		"       Num:0x%08x            State:%s          pSInfo:0x%08x\n",
			Group.HashTable.NumItems,
			(Group.fEnabled) ? "ENABLED " : "DISABLED",
			Group.pStaticInfo
			);

		MyDbgPrintf(
		"    pULTsk:0x%08x\n",
			Group.pUnloadTask
			);

		if (Group.HashTable.NumItems==0)
		{
			MyDbgPrintf("    No members.\n");
		}
		else
		{
			MyDbgPrintf("    Members:\n");
			dbg_walk_rm_hash_table(
				&Group.HashTable,
				FIELD_OFFSET(RM_OBJECT_HEADER, HashLink),
				"Group members"
				);
		}

	} while(FALSE);
	
}

// Actually handles dumping of task info.
//
void
RmDumpAssociations(
	struct _TYPE_INFO *pType,
	UINT_PTR uAddr,
	char *szFieldSpec,
	UINT uFlags
	)
{
/*	
	!rm asc	 0x9ba265f8
	Associations for object 0x838c7560 (LocalIP):
		Child   of 0x010091A0 (Globals)
		Parent  of 0x00073558 (Task2)
		Parent  of 0x00073920 (Task3a)
		Parent  of 0x000739F8 (Task3b)
*/

	RM_OBJECT_HEADER Obj;
	bool			  fRet;
	UINT	uNumAssociations = -1;

	do
	{
		char rgDescriptionBuf[256];

		// First let's read the pObj structure.
		//
		fRet = dbgextReadMemory(
				uAddr,
				&Obj,
				sizeof(Obj),
				"RM_OBJECT_HEADER"
				);

		if (!fRet) break;

		// Try to read the object's description.
		//
		fRet = dbgextReadSZ(
					(UINT_PTR) Obj.szDescription,
					rgDescriptionBuf,
					sizeof(rgDescriptionBuf),
					"Obj.szDescription"
					);

		if (!fRet) break;

		// Try to get the number of associations field in the diag info struct.
		//
		if (Obj.pDiagInfo != NULL)
		{
			bool fRet;
			UINT_PTR uNumItemsOffset = 
				(UINT_PTR) &(Obj.pDiagInfo->AssociationTable.NumItems);
			fRet =  dbgextReadUINT(
							uNumItemsOffset,
							&uNumAssociations,
							"pDiagInfo->AssociationTable.NumItems"
							);
			if (!fRet)
			{
				uNumAssociations = (UINT) -1;
			}
		}

		if (uNumAssociations == 0)
		{
			MyDbgPrintf(
				"\nObject 0x%p (%s) has no associations.\n",
 				uAddr,
 				rgDescriptionBuf
 				);
		}
		else if (uNumAssociations == (UINT)-1)
		{
			MyDbgPrintf(
				"\nObject 0x%p (%s) associations are not available.\n",
 				uAddr,
 				rgDescriptionBuf
 				);
		}
		else
		{
#if RM_EXTRA_CHECKING
			// Get the association hash table table.
			//
			RM_HASH_TABLE AssociationTable;

			MyDbgPrintf(
				"\nAssociations (50 max) for 0x%p (%s):\n",
 				uAddr,
 				rgDescriptionBuf
 				);

			fRet = dbgextReadMemory(
					(UINT_PTR) &(Obj.pDiagInfo->AssociationTable),
					&AssociationTable,
					sizeof(AssociationTable),
					"Association Table"
					);

			if (!fRet) break;

			dbg_print_rm_associations(
					&AssociationTable,
					50
					);
#endif // RM_EXTRA_CHECKING
		}

	} while(FALSE);
	
}


// Actually handles dumping of task info.
//
void
RmDumpStackRecord(
	struct _TYPE_INFO *pType,
	UINT_PTR uAddr,
	char *szFieldSpec,
	UINT uFlags
	)
{
/*
	!rm sr  0x838c7560

	Stack Record 0x838c7560
		TmpRefs: 2
		HeldLocks:
			0xe916a45f 0x23d8d2d3 0x5f47a2f2
*/

	RM_STACK_RECORD sr;
	bool	fRet;

	do
	{

		// First let's read the RM_STACK_RECORD structure.
		//
		fRet = dbgextReadMemory(
				uAddr,
				&sr,
				sizeof(sr),
				"RM_STACK_RECORD"
				);

		if (!fRet) break;

		MyDbgPrintf( "\nStack Record 0x%p\n", uAddr);

		MyDbgPrintf(
	"    TmpRefs:0x%08x   LockLevel:0x%08lx   pFirst:0x%08lx   NumHeld=%lu\n",
			sr.TmpRefs,
			sr.LockInfo.CurrentLevel,
			sr.LockInfo.pFirst,
			sr.LockInfo.pNextFree-sr.LockInfo.pFirst
			);

		// Display held locks.
		//
		if (sr.LockInfo.CurrentLevel==0)
		{
			MyDbgPrintf("    No held locks.\n");
		}
		else
		{
			// MyDbgPrintf("    Held locks:<unimplemented>\n");
		}

	} while(FALSE);
	
}


// Actually handles dumping of the object log
//
void
RmDumpObjectLog(
	struct _TYPE_INFO *pType,
	UINT_PTR uAddr,
	char *szFieldSpec,
	UINT uFlags
	)
{
/*	
	!rm log	 0x9ba265f8
	Log for object 0x838c7560 (LocalIP):
		Added association X
		Deleted association Y
		...
*/

	RM_OBJECT_HEADER Obj;
	bool			  fRet;
	UINT	uNumEntries = 0;

	do
	{
		char rgDescriptionBuf[256];

		// First let's read the pObj structure.
		//
		fRet = dbgextReadMemory(
				uAddr,
				&Obj,
				sizeof(Obj),
				"RM_OBJECT_HEADER"
				);

		if (!fRet) break;

		// Try to read the object's description.
		//
		fRet = dbgextReadSZ(
					(UINT_PTR) Obj.szDescription,
					rgDescriptionBuf,
					sizeof(rgDescriptionBuf),
					"Obj.szDescription"
					);

		if (!fRet) break;

		// Try to get the number of log entries field in the diag info struct.
		//
		if (Obj.pDiagInfo != NULL)
		{
			bool fRet;
			UINT_PTR uNumItemsOffset = 
				(UINT_PTR) &(Obj.pDiagInfo->NumObjectLogEntries);
			fRet =  dbgextReadUINT(
							uNumItemsOffset,
							&uNumEntries,
							"pDiagInfo->NumObjectLogEntries"
							);
			if (!fRet)
			{
				uNumEntries = (UINT) -1;
			}
		}

		if (uNumEntries == 0)
		{
			MyDbgPrintf(
				"\nObject 0x%p (%s) has no log entries.\n",
 				uAddr,
 				rgDescriptionBuf
 				);
		}
		else if (uNumEntries == (UINT)-1)
		{
			MyDbgPrintf(
				"\nObject 0x%p (%s) log entries are not available.\n",
 				uAddr,
 				rgDescriptionBuf
 				);
		}
		else
		{
#if RM_EXTRA_CHECKING
			UINT uNumToDump = uNumEntries;
			if (uNumToDump > 50)
			{
				uNumToDump = 50;
			}

			MyDbgPrintf(
				"\nLog entries for 0x%p (%s) (%lu of %lu):\n",
 				uAddr,
 				rgDescriptionBuf,
 				uNumToDump,
 				uNumEntries
 				);

			dbg_print_object_log_entries(
				(UINT_PTR)  &(Obj.pDiagInfo->listObjectLog),
				uNumToDump
				);
					

#endif // RM_EXTRA_CHECKING
		}

	} while(FALSE);
	
}


// Actually handles dumping of the object tree
//
void
RmDumpObjectTree(
	struct _TYPE_INFO *pType,
	UINT_PTR uAddr,
	char *szFieldSpec,
	UINT uFlags
	)
{
/*	
	!rm tree 0x9ba265f8
	Tree for object 0x838c7560 (LocalIP) (Parent 0x82222222)

	Display sample:
		0x2222222(RemoteIp)
		|---0x22222222(Dest)
		|---|---0x22222222(Dest)
		|---|---|---0x22222222(Dest)
		|---|---0x22222222(pTask)
		|---0x11111111(RemoteIp)

*/

	
	RM_OBJECT_HEADER Obj;
	RM_OBJECT_HEADER ParentObj;
	bool			  fRet;
	UINT	uNumEntries = 0;

	do
	{
		char rgDescriptionBuf[256];
		char rgParentDescriptionBuf[256];

		// First let's read the pObj structure.
		//
		fRet = dbgextReadMemory(
				uAddr,
				&Obj,
				sizeof(Obj),
				"RM_OBJECT_HEADER"
				);

		if (!fRet) break;

		// Try to read the object's description.
		//
		fRet = dbgextReadSZ(
					(UINT_PTR) Obj.szDescription,
					rgDescriptionBuf,
					sizeof(rgDescriptionBuf),
					"Obj.szDescription"
					);

		if (!fRet) break;

		// Try to read the parent's object.
		//
		if (Obj.pParentObject!=NULL && (UINT_PTR) Obj.pParentObject != uAddr)
		{
			fRet = dbgextReadMemory(
					(UINT_PTR) Obj.pParentObject,
					&ParentObj,
					sizeof(ParentObj),
					"RM_OBJECT_HEADER"
					);
	
			if (!fRet) break;

			// Try to get pParent's description.
			//
			fRet = dbgextReadSZ(
						(UINT_PTR) ParentObj.szDescription,
						rgParentDescriptionBuf,
						sizeof(rgParentDescriptionBuf),
						"ParentObj.szDescription"
						);
	
			if (!fRet) break;
		}
		else
		{
			strcpy(rgParentDescriptionBuf, "<root>");
		}

		MyDbgPrintf(
			"\nObject Tree for  0x%p(%s) with parent 0x%p(%s):\n",
			uAddr,
			rgDescriptionBuf,
			Obj.pParentObject,
			rgParentDescriptionBuf
			);

		NodeFunc_DumpObjectTree(
						(UINT_PTR) &(((PRM_OBJECT_HEADER)uAddr)->linkSiblings),
						0,			// Index (unused)
						(void *)0 // pvContext == level
						);
	} while(FALSE);
}


void
dump_object_fields(UINT_PTR uAddr, PRM_OBJECT_HEADER pObj)
{
	UINT uNumAssociations = (UINT) -1;

	// Try to get the number of associations field in the diag info struct.
	//
	if (pObj->pDiagInfo != NULL)
	{
		bool fRet;
		UINT_PTR uNumItemsOffset = 
 			(UINT_PTR) &(pObj->pDiagInfo->AssociationTable.NumItems);
		fRet =  dbgextReadUINT(
						uNumItemsOffset,
						&uNumAssociations,
						"pDiagInfo->AssociationTable.NumItems"
						);
		if (!fRet)
		{
			uNumAssociations = (UINT) -1;
		}
	}

	MyDbgPrintf(
		"    Hdr:\n"
   	"            Sig:0x%08x            State:0x%08x            Refs:0x%08x\n",
		pObj->Sig,
		pObj->State,
		pObj->TotRefs
		);
	MyDbgPrintf(
		"          pLock:0x%p           pSInfo:0x%p          pDInfo:0x%p\n",
		pObj->pLock,
		pObj->pStaticInfo,
		pObj->pDiagInfo
		);
	MyDbgPrintf(
		"        pParent:0x%p            pRoot:0x%p          pHLink:0x%p\n",
		pObj->pParentObject,
		pObj->pRootObject,
		&(((PRM_OBJECT_HEADER) uAddr)->HashLink)
		);
	MyDbgPrintf(
		"        HdrSize:0x%08lx            Assoc:%d\n",
		sizeof(*pObj),
		uNumAssociations
		);

	MyDbgPrintf( "        RmState: ");

	DumpBitFields(
			pObj->RmState,
			rgRM_OBJECT_STATE
			);

	MyDbgPrintf( "\n");
}


void
dbg_walk_rm_hash_table(
	PRM_HASH_TABLE pRmHashTable,
	UINT	uContainingOffset,
	char *szDescription
	)
{
	// For now, we get the whole hash table array in one fell swoop...
	//
	PRM_HASH_LINK rgTable[512];
	UINT		  TableLength = pRmHashTable->TableLength;
	bool fRet;

	do
	{
		// Sanity check.
		//
		if (TableLength > sizeof(rgTable)/sizeof(*rgTable))
		{
			MyDbgPrintf(
				"    HashTable length %lu too large\n",
					 TableLength
					 );
			break;
		}

		// Read the whole hash table.
		//
		fRet = dbgextReadMemory(
				(UINT_PTR) pRmHashTable->pTable,
				rgTable,
				TableLength * sizeof(*rgTable),
				"Hash Table"
				);

		if (!fRet) break;

		
		// Now go through the table visiting each list...
		//
		{
			PRM_HASH_LINK *ppLink, *ppLinkEnd;
			UINT uCount = 0;
			UINT uMax   = 15;
		
			ppLink 		= rgTable;
			ppLinkEnd 	= ppLink + TableLength;
		
			for ( ; ppLink < ppLinkEnd; ppLink++)
			{
				PRM_HASH_LINK pLink =  *ppLink;

				for (;pLink != NULL; uCount++)
				{ 
					char *szPrefix;
					char *szSuffix;
					RM_HASH_LINK Link;


					szPrefix = "        ";
					szSuffix = "";
					if (uCount%4)
					{
						szPrefix = " ";
						if ((uCount%4)==3)
						{
							szSuffix = "\n";
						}
					}
		
					if (uCount >= uMax) break;
			
					MyDbgPrintf(
						"%s0x%p%s",
						 szPrefix,
						 ((char *) pLink) - uContainingOffset,
						 szSuffix
						 );

					// Let's try to read this link.
					//
					fRet = dbgextReadMemory(
							(UINT_PTR) pLink,
							&Link,
							sizeof(Link),
							"Hash Link"
							);
		
					if (!fRet) break;
			
					pLink = Link.pNext;
				}
				if (!fRet || (uCount >= uMax)) break;
			}

			{
				MyDbgPrintf("\n");
			}
			if (uCount < pRmHashTable->NumItems)
			{
				MyDbgPrintf("        ...\n");
			}
		}

	} while (FALSE);

}

#if RM_EXTRA_CHECKING

void
dbg_dump_one_association(
	RM_PRIVATE_DBG_ASSOCIATION *pAssoc
	);

void
dbg_print_rm_associations(
		PRM_HASH_TABLE pRmAssociationHashTable,
		UINT	MaxToPrint
		)
{
	// For now, we get the whole hash table array in one fell swoop...
	//
	PRM_HASH_LINK rgTable[512];
	UINT		  TableLength = pRmAssociationHashTable->TableLength;
	bool fRet;

	do
	{
		// Sanity check.
		//
		if (TableLength > sizeof(rgTable)/sizeof(*rgTable))
		{
			MyDbgPrintf(
				"    HashTable length %lu too large\n",
					 TableLength
					 );
			break;
		}

		// Read the whole hash table.
		//
		fRet = dbgextReadMemory(
				(UINT_PTR) pRmAssociationHashTable->pTable,
				rgTable,
				TableLength * sizeof(*rgTable),
				"Hash Table"
				);

		if (!fRet) break;

		
		// Now go through the table visiting each list...
		//
		{
			PRM_HASH_LINK *ppLink, *ppLinkEnd;
			UINT uCount = 0;
			UINT uMax   = MaxToPrint;
		
			ppLink 		= rgTable;
			ppLinkEnd 	= ppLink + TableLength;
		
			for ( ; ppLink < ppLinkEnd; ppLink++)
			{
				PRM_HASH_LINK pLink =  *ppLink;

				for (;pLink != NULL; uCount++)
				{ 
					RM_PRIVATE_DBG_ASSOCIATION Assoc;
					UINT_PTR uAssocOffset = 
						(UINT_PTR) CONTAINING_RECORD(
										pLink,
										RM_PRIVATE_DBG_ASSOCIATION,
										HashLink
										);


					if (uCount >= uMax) break;
			

					// Let's try to read this association...
					//
					fRet = dbgextReadMemory(
							uAssocOffset,
							&Assoc,
							sizeof(Assoc),
							"Association"
							);

					if (!fRet) break;

					dbg_dump_one_association(&Assoc);

					pLink = Assoc.HashLink.pNext;

				}

				if (!fRet || (uCount >= uMax)) break;
			}

			if (uCount < pRmAssociationHashTable->NumItems)
			{
				MyDbgPrintf("        ...\n");
			}
		}

	} while (FALSE);

}

void
dbg_dump_one_association(
	RM_PRIVATE_DBG_ASSOCIATION *pAssoc
	)
/*++
		Dump the information on the specific association.
		pAssoc is valid memory, however anything it points to is not in
		our address space.

		Since the association contains a format string, which may have
		"%s"s in it, we need scan this format string and read any strings
		referenced.

		All this effort is well worth it. Check out the sample output!

				Associations for 0x01023A40 (Globals):
						Owns group 0x01023AC4 (O1 Group)
						Parent  of 0x00073240 (O2)
						Parent  of 0x00073488 (O2)
				
				Associations for 0x000736D0 (Task3a):
						Child   of 0x00073240 (O2)
						Pending on 0x000732C8 (TaskO2)
--*/
{

	char rgFormatString[256];
	char rgStrings[3][256];
	char *szFormatString;
	ULONG_PTR Args[3];
	char *szDefaultFormatString =  "\tAssociation (E1=0x%x, E2=0x%x, T=0x%x)\n";
	bool fRet = FALSE;


	do
	{
		
		// Try to read the format string.
		//
		{
			fRet = dbgextReadSZ(
						(UINT_PTR) pAssoc->szFormatString,
						rgFormatString,
						sizeof(rgFormatString),
						"Association format"
						);
	
			if (fRet)
			{
				szFormatString = rgFormatString;
			}
			else
			{
				break;
			}
		}

		// Now run through the format string, looking for "%s"s.
		// and munging as required.
		//
		{
			char *pc = rgFormatString;
			UINT uCount=0;
							
			Args[0] = pAssoc->Entity1;
			Args[1] = pAssoc->Entity2;
			Args[2] = pAssoc->AssociationID;

			while (uCount<3 && pc[0]!=0 && pc[1]!=0)
			{
				if (pc[0]=='%')
				{
					if (pc[1]=='s')
					{
						// pc[1]='p';
						fRet = dbgextReadSZ(
								(UINT_PTR) Args[uCount],
								rgStrings[uCount],
								sizeof(rgStrings[uCount]),
								"Association format"
								);
						if (fRet)
						{
							Args[uCount] = (ULONG_PTR) rgStrings[uCount];
						}
						else
						{
							break;
						}
					}

					pc++; // we want to end up skipping past both chars.
					uCount++;
				}
				pc++;
			}
		}

	}
	while (FALSE);

	if (!fRet)
	{
		// Back off to the defaults..
		//
		szFormatString = szDefaultFormatString;
		Args[0] = pAssoc->Entity1;
		Args[1] = pAssoc->Entity2;
		Args[2] = pAssoc->AssociationID;

	}

	MyDbgPrintf(
		szFormatString,
		Args[0],
		Args[1],
		Args[2]
		);
}

ULONG
NodeFunc_DumpObjectLogFromObjectLink (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	)
{
	RM_DBG_LOG_ENTRY LE;
	LIST_ENTRY *pLink = (LIST_ENTRY*) uNodeAddr;
	UINT_PTR uLEOffset = (UINT_PTR) CONTAINING_RECORD(
										pLink,
										RM_DBG_LOG_ENTRY,
										linkObjectLog
										);

	char rgPrefixString[256];
	char rgFormatString[256];
	char rgStrings[4][256];
	char *szPrefixString;
	char *szFormatString;
	ULONG_PTR Args[4];
	char *szDefaultFormatString = 
				"Log Entry (P1=%p, P2=%p, P3=%p, P4=%p, szFmt=%p)\n";

	bool fRet = FALSE;

	// Read the containing record.
	//
	fRet = dbgextReadMemory(
			uLEOffset,
			&LE,
			sizeof(LE),
			"Log Entry"
			);

	if (!fRet) return 0;						// EARLY RETURN;

#if 0
	if (LE.pfnDumpEntry != NULL)
	{
		//
		// TODO we need to get the corresponding function to dump this
		// specialized entry.
		//
		MyDbgPrintf(
			"Specialized (pfn=%p szFmt=%p, P1=%p, P2=%p, P3=%p, P4=%p)\n",
			LE.pfnDumpEntry,
			LE.szFormatString,
			LE.Param1,
			LE.Param2,
			LE.Param3,
			LE.Param4
			);
		return 0;								// EARLY RETURN
	}
#else
	// 
	// Above check is invalid, because in all cases there is a pfnDump function.
	//
#endif

	//
	// TODO -- following code is very similar to the dump-association code --
	// move common stuff to some utility function.
	//

	do
	{
		// Try to read the prefix string.
		//
		{
			fRet = FALSE;

			if (LE.szPrefix != NULL)
			{
				fRet = dbgextReadSZ(
							(UINT_PTR) LE.szPrefix,
							rgPrefixString,
							sizeof(rgPrefixString),
							"Prefix String"
							);
			}
	
			if (fRet)
			{
				szPrefixString = rgPrefixString;
			}
			else
			{
				szPrefixString = "";
			}
		}

		// Try to read the format string.
		//
		{
			fRet = dbgextReadSZ(
						(UINT_PTR) LE.szFormatString,
						rgFormatString,
						sizeof(rgFormatString),
						"Log entry format"
						);
	
			if (fRet)
			{
				szFormatString = rgFormatString;
			}
			else
			{
				break;
			}
		}

		// Now run through the format string, looking for "%s"s.
		// and munging as required.
		//
		{
			char *pc = rgFormatString;
			UINT uCount=0;
							
			Args[0] = LE.Param1;
			Args[1] = LE.Param2;
			Args[2] = LE.Param3;
			Args[3] = LE.Param4;

			while (uCount<4 && pc[0]!=0 && pc[1]!=0)
			{
				if (pc[0]=='%')
				{
					if (pc[1]=='s')
					{
						// pc[1]='p';
						fRet = dbgextReadSZ(
								(UINT_PTR) Args[uCount],
								rgStrings[uCount],
								sizeof(rgStrings[uCount]),
								"Log entry param"
								);
						if (fRet)
						{
							Args[uCount] = (ULONG_PTR) rgStrings[uCount];
						}
						else
						{
							break;
						}
					}

					pc++; // we want to end up skipping past both chars.
					uCount++;
				}
				pc++;
			}
		}

	} while (FALSE);

	if (!fRet)
	{
		// Back off to the defaults..
		//
		szPrefixString = "";
		szFormatString = szDefaultFormatString;
		Args[0] = LE.Param1;
		Args[1] = LE.Param2;
		Args[2] = LE.Param3;
		Args[3] = LE.Param4;

	}

	MyDbgPrintf(szPrefixString);

	MyDbgPrintf(
		szFormatString,
		Args[0],
		Args[1],
		Args[2],
		Args[3],
		LE.szFormatString
		);

	return 0;
}

void
dbg_print_object_log_entries(
	UINT_PTR uObjectListOffset,
	UINT MaxToPrint
	)
{
	WalkDLlist(
		uObjectListOffset,
		0, 	//uOffsetStartLink
		NULL,	// pvContext
		NodeFunc_DumpObjectLogFromObjectLink,
		MaxToPrint,
		"Object log"
		);
}
#endif //  RM_EXTRA_CHECKING


char szDumpTreePrefix[] =	"|---|---|---|---|---|---|---|---|---|---"
							"|---|---|---|---|---|---|---|---|---|---";
ULONG
NodeFunc_DumpObjectTree (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	)
{
	bool fRet = FALSE;

	do
	{
		char rgDescriptionBuf[256];
		LIST_ENTRY *pLink = (LIST_ENTRY*) uNodeAddr;
		UINT_PTR uObjOffset = (UINT_PTR) CONTAINING_RECORD(
											pLink,
											RM_OBJECT_HEADER,
											linkSiblings
											);
		UINT Level = (UINT) (UINT_PTR) pvContext; // we put the level in the context.
		RM_OBJECT_HEADER Obj;
		char *szPrefix;
	
		// First make szPrefix point to the end (trailing zero) of the prefix string.
		//
		szPrefix = szDumpTreePrefix + sizeof(szDumpTreePrefix)-1;
	
		// Now back up "Level" times.
		//
		if (Level < ((sizeof(szDumpTreePrefix)-1)/4))
		{
			szPrefix -= Level*4;
		}
		else
		{
			// Level is too large -- don't display anything.
			//
			MyDbgPrintf("Dump Tree depth(%d) is too large.\n", Level);
			break;
		}


		// Read the containing record.
		//
		fRet = dbgextReadMemory(
				uObjOffset,
				&Obj,
				sizeof(Obj),
				"Object"
				);
	
		if (!fRet) break;
	
		// Try to read the object's description.
		//
		fRet = dbgextReadSZ(
					(UINT_PTR) Obj.szDescription,
					rgDescriptionBuf,
					sizeof(rgDescriptionBuf),
					"Obj.szDescription"
					);
	
		if (!fRet) break;

		// Display the object info.
		//
		MyDbgPrintf(
			"%s%p(%s)\n",
			szPrefix,
			uObjOffset,
			rgDescriptionBuf
			);
		
		//
		// Now walk the list of children, displaying each of them.
		//
		WalkDLlist(
			(UINT_PTR) &(((PRM_OBJECT_HEADER)uObjOffset)->listChildren),
			0, 	//uOffsetStartLink
			(void*) (Level+1),	// pvContext
			NodeFunc_DumpObjectTree,
			50, 		// Max children per node to dump
			"Object children"
			);
		
	} while (FALSE);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\kdext\dbgrm.h ===
//=================================================================================
// 					D E B U G G E R    E X T E N S I O N    S U P P O R T
//=================================================================================

typedef struct
{
	ULONG		dwSig;						// matches pObj->dwSig;
    BITFIELD_INFO	*rgStateFlagInfo;		// to display pObj->dwState;
	// PFN_DUMP	pfnDump;					// specialized dump.

} RMDBG_OBJECT_DUMP_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\kdext\dbgarp.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

	dbgarp.c	- DbgExtension Structure information specific to ARP1394

Abstract:


Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	josephj     03-02-99    Created

Notes:

--*/


#ifdef TESTPROGRAM
#include "c.h"
#else
#include "precomp.h"
#endif // TESTPROGRAM

#include "util.h"
#include "parse.h"
#if 0

void
do_arp(PCSTR args)
{

	DBGCOMMAND *pCmd = Parse(args, &ARP1394_NameSpace);
	if (pCmd)
	{
		DumpCommand(pCmd);
		DoCommand(pCmd, NULL);
		FreeCommand(pCmd);
		pCmd = NULL;
	}

    return;

}


#endif // 0

void
do_arp(PCSTR args)
{


	MyDbgPrintf( "do_arp(...) called\n" );

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\kdext\main.c ===
#ifdef TESTPROGRAM

#include "common.h"

WINDBG_EXTENSION_APIS ExtensionApis;

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    );
//
// dprintf          (ExtensionApis.lpOutputRoutine)
// GetExpression    (ExtensionApis.lpGetExpressionRoutine)
// GetSymbol        (ExtensionApis.lpGetSymbolRoutine)
// Disassm          (ExtensionApis.lpDisasmRoutine)
// CheckControlC    (ExtensionApis.lpCheckControlCRoutine)
// ReadMemory       (ExtensionApis.lpReadProcessMemoryRoutine)
// WriteMemory      (ExtensionApis.lpWriteProcessMemoryRoutine)
// GetContext       (ExtensionApis.lpGetThreadContextRoutine)
// SetContext       (ExtensionApis.lpSetThreadContextRoutine)
// Ioctl            (ExtensionApis.lpIoctlRoutine)
// StackTrace       (ExtensionApis.lpStackTraceRoutine)
//

ULONG_PTR
DummyMyGetExpression (
    PCSTR lpExpression
    );
void init_dummy_vars(void);
void delete_dummy_vars(void);

ULONG_PTR
WDBGAPI
MyGetExpression (
    PCSTR lpExpression
    )
{
	return DummyMyGetExpression(lpExpression);
}


ULONG
WDBGAPI
MyReadMemory (
    ULONG_PTR 	offset,
    PVOID  		lpBuffer,
    ULONG  		cb,
    PULONG 		lpcbBytesRead
    )
{
    BOOL fRet = FALSE;

    _try
    {

        CopyMemory(lpBuffer, (void*)offset, cb);
        *lpcbBytesRead = cb;
        fRet = TRUE;
    }
    _except (EXCEPTION_EXECUTE_HANDLER)
    {
    	MyDbgPrintf("Read memory exception at 0x%lu[%lu]\n", offset, cb);
        fRet = FALSE;
    }

    return fRet;
}

ULONG
WDBGAPI
MyWriteMemory(
    ULONG_PTR   offset,
    LPCVOID 	lpBuffer,
    ULONG   	cb,
    PULONG  	lpcbBytesWritten
    )
{
    BOOL fRet = FALSE;

    _try
    {

        CopyMemory((void*)offset, lpBuffer, cb);
        *lpcbBytesWritten = cb;
        fRet = TRUE;
    }
    _except (EXCEPTION_EXECUTE_HANDLER)
    {
        fRet = FALSE;
    }

    return fRet;
}

void test_walklist(void);

int __cdecl main(
	int argc,
	char *argv[]
	)
{
    UINT u=0;

    ExtensionApis.lpOutputRoutine = printf;
    ExtensionApis.lpGetExpressionRoutine = MyGetExpression;
    ExtensionApis.lpReadProcessMemoryRoutine = MyReadMemory;
    ExtensionApis.lpWriteProcessMemoryRoutine = MyWriteMemory;

    WinDbgExtensionDllInit(
        &ExtensionApis,
        0xc, // MajorVersion,
        0x0 // MinorVersion
        );

	//
	// This sets up some dummy global variables.
	//
	init_dummy_vars();

	//test_walklist();

    do
    {
        char rgch[256];

        printf("> ");
        u = scanf("%[^\n]", rgch);
        if (!u || u==EOF) break;

        printf("Input = [%s]\n", rgch);

        if (*rgch == 'q') break;

        do_rm(rgch);

      // skip past EOL
      {
          char c;
          u = scanf("%c", &c);
      }

    } while (u!=EOF);

	delete_dummy_vars();

  return 0;
}

typedef struct _LIST
{
	struct _LIST *pNext;
	UINT  uKey;
} LIST;

LIST L3 = {NULL, 0x4000};
LIST L2 = {&L3,  0x3000};
LIST L1 = {&L2,  0X2000};
LIST L0 = {&L1,  0X1000};

ULONG
NodeFunc_DumpLIST (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	)
{
	LIST L;
	BOOL fRet = dbgextReadMemory(
					uNodeAddr,
					&L,
					sizeof(L),
					"LIST"
					);
	if (fRet)
	{
		MyDbgPrintf(
			"LIST[%lu]@0x%08lx = {Next=0x%08lx, Key=0x%lx}\n",
			uIndex,
			uNodeAddr,
			L.pNext,
			L.uKey
			);
	}
	return 0;
}

void test_walklist(void)
{
	UINT uRet = 0;

	uRet =  WalkList(
				(UINT_PTR) &L0,
				0,
				0, // 0 start
				-1,// -1 end
				NULL,
				//NodeFunc_DumpAddress,
				NodeFunc_DumpLIST,
				"Test list"
				);

}

ULONG_PTR
DummyMyGetExpression (
    PCSTR lpExpression
    )
{
	extern void *pvDummyAtmArpGlobalInfo;
	extern void *pvDummyAtmArpProtocolCharacteristics;
	extern void *pvDummyAtmArpClientCharacteristics;

#if 0
    if (!lstrcmpi(lpExpression, "atmarpc!AtmArpGlobalInfo"))
    {
        return (ULONG) pvDummyAtmArpGlobalInfo;
    }

    if (!lstrcmpi(lpExpression, "atmarpc!AtmArpProtocolCharacteristics"))
    {
        return (ULONG) pvDummyAtmArpProtocolCharacteristics;
    }

    if (!lstrcmpi(lpExpression, "atmarpc!AtmArpClientCharacteristics"))
    {
        return (ULONG) pvDummyAtmArpClientCharacteristics;
    }
#endif // 0

    return 0;

}
#endif // TESTPROGRAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\kdext\parse.h ===
typedef enum // tokens: * . ? [ ] / help dt dg L number <identifier>
{
    tokSTAR,            // *
    tokDOT,             // .
    tokQUESTION,        // ?
    tokLBRAC,           // [
    tokRBRAC,           // ]
    tokSLASH,           // /
    tokKEYWORD,         // alnum strings which match one of the known keys.
    tokNUMBER,           // 0xcbde 129
    tokIDENTIFIER       // non-keyword and non-number alnum

} eTOKTYPE;


typedef struct
{
    eTOKTYPE eTok;
    UINT     uID;     // Tok-specific ID:
                      //    IDENTIFIER: a unique number across all identifiers.
                      //    NUMBER: the number
                      //    KEYWORD: eKEYWORD
                      //    Other tokens: uID is unused.
    char    *szStr;   // String containg original chars that made up this token.

                      // Note: a string of pure hex digits which is followed 
                      // by a non-alnum char is assumed to be a number --
                      // later if it turns out to be more likely that it is
                      // an identifier, it is converted to an identifier.
                      // Same deal with a keyword -- if it turns out based
                      // on context to be most likely an identifier or part
                      // of an identifier, it will be converted to an
                      // identifier.
    
} TOKEN;

typedef enum
{
    keywordNULL,            // Invalid keyword, use for sentinels.
    keywordHELP,            // help
    keywordDUMP_TYPE,       // dt
    keywordDUMP_GLOBALS,    // dg
    keywordL                // L

} eKEYWORD;

//
// Following is not used currently...
//
typedef enum
{
    phraseCMD,
    phraseIDENTIFIER,   // with optional wildcards
    phraseINDEX,        // [2], [*],  [1-3], etc.
    phraseDOT,          // .
    phraseNUMBER,       // 0x8908 abcd
    phraseOBJ_COUNT,    // L 2
    phraseFLAG          // /xyz

} ePHRASE;

typedef enum
{
    cmdDUMP_TYPE,
    cmdDUMP_GLOBALS,
    cmdHELP

}ePRIMARY_COMMAND;


struct _DBGCOMMAND;

typedef void (*PFN_SPECIAL_COMMAND_HANDLER)(struct _DBGCOMMAND *pCmd);

typedef struct _DBGCOMMAND
{
	NAMESPACE 		*pNameSpace;	// Name space applicable for this command.
    ePRIMARY_COMMAND ePrimaryCmd; // DumpGlobals, DumpType, help
    UINT 			uFlags;            // One or more fCMDFLAG_*
    TOKEN 			*ptokObject;     // eg <type>
    TOKEN 			*ptokSubObject;  // eg <field>
    UINT 			uVectorIndexStart; // if[0]
    UINT 			uVectorIndexEnd; // if[0]
    UINT 			uObjectAddress; // <address>
    UINT 			uObjectCount; // L 10

    void 			*pvContext;    // private context.
    //PFN_SPECIAL_COMMAND_HANDLER pfnSpecialHandler;

} DBGCOMMAND;


#define fCMDFLAG_HAS_VECTOR_INDEX       (0x1<<0)
#define fCMDFLAG_HAS_SUBOBJECT          (0x1<<1)
#define fCMDFLAG_HAS_OBJECT_ADDRESS     (0x1<<2)
#define fCMDFLAG_HAS_OBJECT_COUNT       (0x1<<3)
#define fCMDFLAG_OBJECT_STAR_PREFIX     (0x1<<4)
#define fCMDFLAG_OBJECT_STAR_SUFFIX     (0x1<<5)
#define fCMDFLAG_SUBOBJECT_STAR_PREFIX  (0x1<<6)
#define fCMDFLAG_SUBOBJECT_STAR_SUFFIX  (0x1<<7)

#define CMD_SET_FLAG(_pCmd, _f)  ((_pCmd)->uFlags |= (_f))
#define CMD_CLEAR_FLAG(_pCmd, _f)  ((_pCmd)->uFlags &= ~(_f))
#define CMD_IS_FLAG_SET(_pCmd, _f)  ((_pCmd)->uFlags & (_f))

DBGCOMMAND *
Parse(
    IN  const char *szInput,
    IN	NAMESPACE *
);

void
FreeCommand(
    DBGCOMMAND *pCommand
);

void
DumpCommand(
    DBGCOMMAND *pCommand
);


#if 0
//!aac dt <type> . <field> <address> L <count> <flags>
//!aac dt <type> [index] . <field>   L <count> <flags>
//!aac dg <name> . <field>
//
//!aac dt if[*].*handle* 0x324890 L 5

0. Break up sentance into tokens:
        keywords: * . L dg dt ? help [ ] /
        identifier: contiguous non-keyword alnum
        number: interpreted as hex with optional 0x.
1st pass: combine "[*]", "*word*", "/xyz" into single entities 

1. Parse primary command: literal text
2. Parse primary object: [*]literal_text[*]
3. Parse index "[...]"
4. Parse field "."
5. Parse address (hex number)
6. Parse object count L <count>
#endif //  0

void
DoCommand(DBGCOMMAND *pCmd, PFN_SPECIAL_COMMAND_HANDLER pfnHandler);

void
DoDumpType(DBGCOMMAND *pCmd);

void
DoDumpGlobals(DBGCOMMAND *pCmd);

void
DoHelp(DBGCOMMAND *pCmd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\kdext\myrm.c ===
//
// This wierd file is just to include ..\arp1394\rm.c, because the SOURCES
// file complains about the path "..\arp1394\rm.c".
//
#ifdef TESTPROGRAM
#include "..\arp1394\rm.c"
#endif // TESTPROGRAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\kdext\rmtest.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

	rmtest.h

Abstract:

	Header file which allows rm.h to compile as a win32 app.

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	josephj     01-13-99    Created

Notes:

--*/
#include <ccdefs.h>
#include <nt.h>
#include <ntverp.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>

#ifdef ASSERT
	#undef ASSERT
	#define ASSERT(cond) ((cond)? 0: DebugBreak())
#endif // ASSERT

#define NDIS_SPIN_LOCK 						CRITICAL_SECTION
#define NDIS_STATUS							UINT
#define	NdisZeroMemory(_ptr, _size) 		ZeroMemory(_ptr, _size)
#define	NdisInterlockedIncrement(_ptr)		InterlockedIncrement(_ptr)
#define	NdisInterlockedDecrement(_ptr)		InterlockedDecrement(_ptr)
#define	NdisAllocateMemoryWithTag(_pp, _sz, _tag) \
										   (*((PVOID*)_pp) = LocalAlloc(LPTR, (_sz)))
#define NdisFreeMemory(_p, _x, _y)			LocalFree(_p)
#define	NdisAcquireSpinLock					EnterCriticalSection
#define	NdisReleaseSpinLock					LeaveCriticalSection
#define	NdisDprAcquireSpinLock				EnterCriticalSection
#define	NdisDprReleaseSpinLock				LeaveCriticalSection

#define NDIS_STATUS_SUCCESS 				ERROR_SUCCESS
#define NDIS_STATUS_FAILURE 				ERROR_GEN_FAILURE
#define NDIS_STATUS_RESOURCES 				ERROR_NOT_ENOUGH_MEMORY
#define NDIS_STATUS_PENDING					E_PENDING
#define	MTAG_TASK							'aTRM'
#define	NdisAllocateSpinLock(_plock)	InitializeCriticalSection(_plock)
#define	NdisFreeSpinLock(_plock)		DeleteCriticalSection(_plock)
#define	NDIS_EVENT						HANDLE
#define NdisInitializeEvent(_pE)		(*(_pE) = CreateEvent(NULL,TRUE,FALSE, NULL))
#define NdisWaitEvent(_pE,_T)			WaitForSingleObject(*(_pE), INFINITE)
#define NdisSetEvent(_pE)				SetEvent(*(_pE))

#define	DbgPrint						printf
#if DBG

#define KeGetCurrentIrql() (0)

#define ASSERTEX(x, ctxt)										\
{                                                           	\
    if (!(x))                                               	\
    {                                                       	\
        printf( "A13: !ASSERT( %s ) C:0x%p L:%d,F:%s\n",		\
            #x, (ctxt), __LINE__, __FILE__ );                   \
        DebugBreak();                                    		\
    }                                                       	\
}

#define ENTER(_Name, _locid)				   					\
 	char *dbg_func_name	=  (_Name);								\
 	UINT dbg_func_locid = (_locid);
#define TR_INFO(str) 	(printf("TEST: %s:", dbg_func_name), printf str)
#define TR_WARN(str) 	(printf("TEST: %s:", dbg_func_name), printf str)
#define TR_FATAL(str) 	(printf("TEST: %s:", dbg_func_name), printf str)
#define TR_VERB(str) 	
#define TRACE0(ulLevel,  Args) (printf Args)
#define EXIT()
#define DBGSTMT(_stmt)		_stmt

#else // !DBG

#define ASSERTEX(x, ctxt)

#define ENTER(_Name, _locid)
#define TR_INFO(str)
#define TR_WARN(str)
#define TR_FATAL(str)
#define TR_VERB(str)
#define EXIT()
#define DBGSTMT(_stmt)

#endif // DBG

#define FAIL(_err) 		((_err) != NDIS_STATUS_SUCCESS)
#define PEND(_Status) ((_Status) == NDIS_STATUS_PENDING)

//
// Following added just to get ..\priv.h and .\buf.c to build
//
typedef VOID *IP_BIND_COMPLETE;
typedef VOID *IP_DEL_INTERFACE;
typedef VOID *IP_ADD_INTERFACE;
typedef UINT IPAddr;
typedef UINT IPMask;
typedef UINT IPRcvCmpltRtn;
typedef VOID* IPStatusRtn;
typedef VOID* IPTDCmpltRtn;
typedef VOID* IPTxCmpltRtn;
typedef VOID* IPRcvRtn;
typedef UINT NDIS_CLIENT_CHARACTERISTICS;
typedef VOID  *NDIS_HANDLE;
typedef NDIS_HANDLE *PNDIS_HANDLE;
typedef UINT NDIS_PROTOCOL_CHARACTERISTICS;
typedef VOID* NDIS_STRING;
typedef UINT  NIC1394_FIFO_ADDRESS;
typedef NDIS_STATUS *PNDIS_STATUS;
typedef NDIS_STRING *PNDIS_STRING;
typedef VOID * PNDIS_REQUEST;
typedef VOID * PNDIS_PACKET;
typedef VOID *  PCO_ADDRESS_FAMILY;
typedef VOID *  PCO_CALL_PARAMETERS;
typedef UINT RouteCacheEntry;
typedef UINT  TDIEntityID;
typedef UINT  TDIObjectID;
typedef struct _NDIS_BUFFER
{
	struct _NDIS_BUFFER *Next;
	UINT		uData;
} NDIS_BUFFER,  *PNDIS_BUFFER;
typedef UINT NIC1394_DESTINATION;
typedef VOID * PDEVICE_OBJECT;
typedef VOID * PIRP;
typedef VOID * PIO_STACK_LOCATION;
typedef struct
{
	SINGLE_LIST_ENTRY *pList;
} SLIST_HEADER;

#define NdisAllocateBufferPool(_s, _h, _max) 		\
				{									\
					*(_s) = NDIS_STATUS_SUCCESS;	\
					*(_h) = (NDIS_HANDLE) 1;		\
				}

#define ExInitializeSListHead(_h) ((_h)->pList = NULL)

#define ExInterlockedPopEntrySList(_l, _spinlock)	\
				(_l)->pList; {if ((_l)->pList) {(_l)->pList = (_l)->pList->Next;}}

#define STRUCT_OF(_t, _p, _f)	CONTAINING_RECORD(_p, _t, _f)

#define	NDIS_BUFFER_LINKAGE(_pBuf)	((_pBuf)->Next)

#define NdisFreeBuffer(buf)			LocalFree(buf)

#define NdisAllocateBuffer(s, ppbuf, handle, mem, len) \
			{										\
				PNDIS_BUFFER X_pBuf;				\
				ASSERT((len)==sizeof(UINT));		\
				X_pBuf = LocalAlloc(LPTR, sizeof(NDIS_BUFFER));	\
				if (X_pBuf == NULL)					\
				{									\
					*(s) = NDIS_STATUS_RESOURCES;	\
					*(ppbuf) = NULL;				\
				}									\
				else								\
				{									\
					X_pBuf->uData = *(UINT*) (mem);	\
					*(ppbuf) = X_pBuf;				\
					*(s) = NDIS_STATUS_SUCCESS;		\
				}									\
			}

#define ExInterlockedPushEntrySList(_l, _ptr, _spinlock) \
			{										\
				(_ptr)->Next = (_l)->pList;			\
				(_l)->pList = (_ptr);				\
			}


typedef
VOID
(*PNDIS_TIMER_FUNCTION) (
	IN	PVOID					SystemSpecific1,
	IN	PVOID					FunctionContext,
	IN	PVOID					SystemSpecific2,
	IN	PVOID					SystemSpecific3
	);

typedef	VOID	(*NDIS_PROC)(struct _NDIS_WORK_ITEM *, PVOID);

typedef struct _NDIS_WORK_ITEM
{
	PVOID			Context;
	NDIS_PROC		Routine;
	UCHAR			WrapperReserved[8*sizeof(PVOID)];
} NDIS_WORK_ITEM, *PNDIS_WORK_ITEM;

typedef struct
{
	HANDLE hTimer;

	PNDIS_TIMER_FUNCTION	pfnHandler;
	PVOID					Context;

} NDIS_TIMER, *PNDIS_TIMER;

VOID 
NdisInitializeWorkItem(
       IN PNDIS_WORK_ITEM WorkItem,
       IN NDIS_PROC Routine,
       IN PVOID Context
       );

NDIS_STATUS
NdisScheduleWorkItem(
       IN PNDIS_WORK_ITEM WorkItem
       );

VOID
NdisSetTimer(
	IN	PNDIS_TIMER				Timer,
	IN	UINT					MillisecondsToDelay
	);

VOID
NdisInitializeTimer(
	IN OUT PNDIS_TIMER			Timer,
	IN	PNDIS_TIMER_FUNCTION	TimerFunction,
	IN	PVOID					FunctionContext
	);

VOID
NdisCancelTimer(
	IN PNDIS_TIMER Timer,
	OUT PBOOLEAN TimerCancelled
	);

#include <rm.h>
// #include <priv.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\kdext\parse.c ===
#include "common.h"

typedef struct
{
    eKEYWORD eKey;
    char *szzAliases;   // Multi-sz string of aliases.
                        // First one is the "official" name.
} KEYWORDREC;

KEYWORDREC rgKeywords[] =
{
    {keywordHELP,           "help\0"},
    // OBSOLETE {keywordDUMP_TYPE,      "dt\0"}, 
    // OBSOLETE {keywordDUMP_GLOBALS,   "dg\0"},
    {keywordL,              "L\0"},
    {keywordNULL,           NULL}      // sentinel, must be last.
};


//
// Contains the list of tokens created by parsing an input string.
//
typedef struct
{
    TOKEN *rgToks;
    UINT cToks;
    UINT uNextFreeTok;
    UINT uCurrentTok;

    char *rgStringBuf;
    UINT cchStringBuf;
    UINT uNextFree;
    BOOL fFinalized;
    CRITICAL_SECTION crit;

} TOKLIST;


DBGCOMMAND *
parse_command(TOKLIST *pTL, NAMESPACE *pNameSpace);

TOKLIST
*toklist_create(void);

void
toklist_destroy(TOKLIST *pTL);

BOOL
toklist_add(TOKLIST *pTL, eTOKTYPE eTok, char *szOrig, UINT uID);

BOOL
toklist_finalize(TOKLIST *pTL);


TOKEN *
toklist_get_next(TOKLIST *pTL);

BOOL
toklist_restart(TOKLIST *pTL);

void
toklist_dump(TOKLIST *pTL);

void
tok_dump(TOKEN *pTok);


UINT
toklist_tokenize(TOKLIST *pTL, char *szInput);

UINT
toklist_parse_keyword(
      TOKLIST *pTL,
      KEYWORDREC rgKeywords[],
      char *pcInput
      );
    
UINT
toklist_parse_hexnum(
      TOKLIST *pTL,
      char *pcInput
      );

UINT
toklist_parse_identifier(
      TOKLIST *pTL,
      char *pcInput
      );

BOOL
cmd_parse_help(
    DBGCOMMAND *pCmd,
    TOKLIST *pTL
    );

BOOL
tok_try_force_to_ident(TOKLIST *pTL, BOOL fPrefixStar, TOKEN *pTok);

void
MyDumpObject (
    DBGCOMMAND *pCmd,
    TYPE_INFO *pType,
    UINT_PTR uAddr,
    UINT     cbSize,
    const char *szDescription
    );


ULONG
NodeFunc_DumpType (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	);

ULONG
NodeFunc_UpdateCache (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	);


DBGCOMMAND *
Parse(
    IN  const char *szInput,
    IN	NAMESPACE *pNameSpace
)
{
    TOKLIST *pTL = NULL;
    BOOL fRet = FALSE;
    DBGCOMMAND *pCmd = NULL;
    UINT cbInput =  (lstrlenA(szInput)+1)*sizeof(*szInput);
    char *szRWInput 
        = LocalAlloc(LPTR, cbInput);

    // MyDbgPrintf("Parse(\"%s\");\n", szInput);

    if (szRWInput)
    {
        CopyMemory(szRWInput, szInput, cbInput);
        pTL =  toklist_create();
    }

    if (pTL)
    {

#if TEST_TOKLIST_ADD
    #if 0
        fRet = toklist_add(pTL, tokSTAR,        "*",        tokSTAR);
        fRet = toklist_add(pTL, tokDOT,         ".",        tokDOT);
        fRet = toklist_add(pTL, tokQUESTION,    "?",        tokQUESTION);
        fRet = toklist_add(pTL, tokLBRAC,       "[",        tokLBRAC);
        fRet = toklist_add(pTL, tokRBRAC,       "]",        tokRBRAC);
        fRet = toklist_add(pTL, tokSLASH,       "/",        tokSLASH);
        fRet = toklist_add(pTL, tokKEYWORD,     "help",     keywordHELP);
        fRet = toklist_add(pTL, tokNUMBER,      "0x1234",   0x1234);
        fRet = toklist_add(pTL, tokIDENTIFIER,  "cow",      0);
        fRet = toklist_add(pTL, tokSTAR,        "*",        tokSTAR);
        fRet = toklist_add(pTL, tokDOT,         ".",        tokDOT);
        fRet = toklist_add(pTL, tokQUESTION,    "?",        tokQUESTION);
        fRet = toklist_add(pTL, tokLBRAC,       "[",        tokLBRAC);
        fRet = toklist_add(pTL, tokRBRAC,       "]",        tokRBRAC);
        fRet = toklist_add(pTL, tokSLASH,       "/",        tokSLASH);
        fRet = toklist_add(pTL, tokKEYWORD,     "help",     keywordHELP);
        fRet = toklist_add(pTL, tokNUMBER,      "0x1234",   0x1234);
        fRet = toklist_add(pTL, tokIDENTIFIER,  "cow",      0);
    #else
        char rgInput[] =
                 // "*.?[]/"
                 // "help "
                 // "0x12340 0 1 02 "
                 // "kelp"
                "dt if[*].*handle* 0x324890 L 5"
                ;
        toklist_tokenize (pTL, rgInput);
    #endif 

#endif // TEST_TOKLIST_ADD

        toklist_tokenize(pTL, szRWInput);
        
        toklist_finalize(pTL);
        
        // toklist_dump(pTL);

        pCmd = parse_command(pTL, pNameSpace);

        if (!pCmd)
        {
            toklist_destroy(pTL);
        }
        pTL = NULL;
    }

    if (szRWInput)
    {
        LocalFree(szRWInput);
        szRWInput = NULL;
    }
        
    return pCmd;
    
}

void
FreeCommand(
    DBGCOMMAND *pCmd
)
{
    if (pCmd)
    {
        TOKLIST *pTL =  (TOKLIST*)pCmd->pvContext;
        if (pTL)
        {
            // MyDbgPrintf("FreeCommand:\n");
            // toklist_restart(pTL);
            // toklist_dump(pTL);
            toklist_destroy((TOKLIST*)pCmd->pvContext);
        }

        ZeroMemory(pCmd, sizeof(*pCmd));
        LocalFree(pCmd);
    }
}

void
DumpCommand(
    DBGCOMMAND *pCmd
)
{
    char *szCmd = "";
    char *szObjPreStar = "";
    char *szObj = "";
    char *szObjSufStar = "";
    char *szObjVecRange = "";
    char *szDot = "";
    char *szSubObjPreStar = "";
    char *szSubObj = "";
    char *szSubObjSufStar = "";
    char *szObjAddr  = "";
    char *szObjCount = "";
    char rgVecRange[64];
    char rgObjAddr[64];
    char rgObjCount[64];
    

    if (!pCmd) goto end;

    switch(pCmd->ePrimaryCmd)
    {
    case cmdDUMP_TYPE:       szCmd = "dt"; break;
    case cmdDUMP_GLOBALS:    szCmd = "dg"; break;
    case cmdHELP:            szCmd = "help"; break;
    default:            szCmd = "<unknown>"; break;
    }

    if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_PREFIX))
    {
        szObjPreStar = "*";
    }
    if (pCmd->ptokObject)
    {
        szObj = pCmd->ptokObject->szStr;
    }

    if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_SUFFIX))
    {
        szObjSufStar = "*";
    }

    if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_HAS_VECTOR_INDEX))
    {
        wsprintfA(
            rgVecRange,
            "[%ld,%ld]",
            pCmd->uVectorIndexStart, 
            pCmd->uVectorIndexEnd 
            );

        szObjVecRange = rgVecRange;
    }

    if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_HAS_SUBOBJECT))
    {
        szDot = ".";
    }

    if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_SUBOBJECT_STAR_PREFIX))
    {
        szSubObjPreStar = "*";
    }

    if (pCmd->ptokSubObject)
    {
        szSubObj = pCmd->ptokSubObject->szStr;
    }

    if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_SUBOBJECT_STAR_SUFFIX))
    {
        szSubObjSufStar = "*";
    }

    if (CMD_IS_FLAG_SET(pCmd,  fCMDFLAG_HAS_OBJECT_ADDRESS))
    {
        wsprintf(rgObjAddr, "0x%lx", pCmd->uObjectAddress);
        szObjAddr = rgObjAddr;
    }

    if (CMD_IS_FLAG_SET(pCmd,  fCMDFLAG_HAS_OBJECT_COUNT))
    {
        wsprintf(rgObjCount, " L 0x%lx", pCmd->uObjectCount);
        szObjCount = rgObjCount;
    }
    
    if (0)
    {
    #if 0
        MyDbgPrintf(
            "\nCOMMAND = {"
            "cmd=%lu;"
            "F=0x%lx;"
            "O=0x%lx;"
            "SO=0x%lx;"
            "VS=%ld;"
            "VE=%ld;"
            "OA=0x%lx;"
            "OC=%ld;"
            "}\n",
            pCmd->ePrimaryCmd,
            pCmd->uFlags,
            pCmd->ptokObject,
            pCmd->ptokSubObject,
            pCmd->uVectorIndexStart,
            pCmd->uVectorIndexEnd,
            pCmd->uObjectAddress,
            pCmd->uObjectCount
            );
    #else
        MyDbgPrintf(
            "COMMAND = \"%s %s%s%s%s%s%s%s%s%s%s\";\n",
            szCmd,
            szObjPreStar,
            szObj,
            szObjSufStar,
            szObjVecRange,
            szDot,
            szSubObjPreStar,
            szSubObj,
            szSubObjSufStar,
            szObjAddr,
            szObjCount
        );
    #endif
    }
end:
    return;
}


#define TL_LOCK(_ptl)   EnterCriticalSection(&(_ptl)->crit)
#define TL_UNLOCK(_ptl) LeaveCriticalSection(&(_ptl)->crit)


TOKLIST
*toklist_create(void)
{
    TOKLIST *pTL = LocalAlloc(LPTR, sizeof(TOKLIST));

    if (pTL)
    {
        InitializeCriticalSection(&pTL->crit);
    }

    return pTL;
}


void
toklist_destroy(TOKLIST *pTL)
{
    if (pTL)
    {
        TL_LOCK(pTL);

        if (pTL->rgToks)
        {
            LocalFree(pTL->rgToks);
        }

        if (pTL->rgStringBuf)
        {
            LocalFree(pTL->rgStringBuf);
        }

        DeleteCriticalSection(&pTL->crit);

        ZeroMemory(pTL, sizeof(*pTL));
        LocalFree(pTL);
    }
}


BOOL
toklist_add(TOKLIST *pTL, eTOKTYPE eTok, char *szOrig, UINT uID)
{
    BOOL fRet = FALSE;
    TOKEN *pTok = NULL;
    UINT cch  = 0;
    char *pc  = NULL;

    TL_LOCK(pTL);

    if (pTL->fFinalized) goto end;

    //
    // Make sure we've enough space for the token.
    //
    if (pTL->uNextFreeTok >= pTL->cToks)
    {
        UINT cNewToks = 2*pTL->cToks+1;
        TOKEN *pNewToks = (TOKEN*) LocalAlloc(LPTR, cNewToks*sizeof(*pNewToks));
        if (!pNewToks) goto end;

        if (pTL->rgToks)
        {
            CopyMemory(
                pNewToks,
                pTL->rgToks,
                pTL->uNextFreeTok*sizeof(*pNewToks)
                );

            LocalFree(pTL->rgToks);
        }

        pTL->rgToks = pNewToks;
        pTL->cToks = cNewToks;
    }

    //
    // Now deal with szOrig
    //

    cch = lstrlenA(szOrig)+1;

    if ((pTL->uNextFree+cch+1) > pTL->cchStringBuf) // "+1" because multisz
    {
        UINT cNewStr = 2*pTL->cchStringBuf+cch+1;
        char *pNewStr = LocalAlloc(LPTR, cNewStr*sizeof(*pNewStr));
        if (!pNewStr) goto end;

        if (pTL->rgStringBuf)
        {
            CopyMemory(
                pNewStr,
                pTL->rgStringBuf,
                pTL->uNextFree*sizeof(*pNewStr)
                );
            LocalFree(pTL->rgStringBuf);

            //
            // Since we've reallocated the string buffer, we must
            // now fixup the string pointers in the list of tokens
            //
            {
                TOKEN *pTok = pTL->rgToks;
                TOKEN *pTokEnd = pTok + pTL->uNextFreeTok;
                for(; pTok<pTokEnd; pTok++)
                {
                    pTok->szStr = pNewStr + (pTok->szStr - pTL->rgStringBuf);
                }
            }
        }

        pTL->rgStringBuf = pNewStr;
        pTL->cchStringBuf = cNewStr;
    }

    //
    // At this point we know we have enough space...
    //

    //
    // See if we already have this string and if not copy it...
    //
    {
        BOOL fFound = FALSE;
        for (pc = pTL->rgStringBuf; *pc; pc+=(lstrlenA(pc)+1))
        {
            if (!lstrcmpiA(pc, szOrig))
            {
                // found it
                fFound = TRUE;
                break;
            }
        }
    
    
        if (!fFound)
        {
            MYASSERT(pTL->uNextFree == (UINT) (pc-pTL->rgStringBuf));
    
            CopyMemory(
                pc,
                szOrig,
                cch*sizeof(*szOrig)
                );
            pTL->uNextFree += cch;
        }
    }

    if (eTok == tokIDENTIFIER)
    {
        //
        // For this special case we ignore the passed-in uID and
        // use instead the offset of the string in our string table.
        //
        uID =  (UINT) (pc - pTL->rgStringBuf);
    }

    pTok = pTL->rgToks+pTL->uNextFreeTok++;
    pTok->eTok = eTok;
    pTok->uID = uID;
    pTok->szStr = pc;
    fRet = TRUE;

end:

    TL_UNLOCK(pTL);
    return fRet;
}


BOOL
toklist_finalize(TOKLIST *pTL)
{
    BOOL fRet = FALSE;

    TL_LOCK(pTL);
    
    if (pTL->fFinalized) goto end;

    pTL->fFinalized = TRUE;
    fRet = TRUE;

end:
    
    TL_UNLOCK(pTL);
    return fRet;
}

BOOL
toklist_restart(TOKLIST *pTL)
{
    BOOL fRet = FALSE;

    TL_LOCK(pTL);
    
    if (!pTL->fFinalized) goto end;
    pTL->uCurrentTok = 0;
    fRet = TRUE;

end:
    
    TL_UNLOCK(pTL);
    return fRet;
}


TOKEN *
toklist_get_next(TOKLIST *pTL)
{
    TOKEN *pTok = NULL;

    TL_LOCK(pTL);

    if (!pTL->fFinalized) goto end;

    if (pTL->uCurrentTok >= pTL->uNextFreeTok)
    {
        MYASSERT(pTL->uCurrentTok == pTL->uNextFreeTok);
        goto end;
    }
    else
    {
        pTok = pTL->rgToks+pTL->uCurrentTok++;
    }

end:
    TL_UNLOCK(pTL);


    return pTok;
}

void
toklist_dump(TOKLIST *pTL)
{
    TL_LOCK(pTL);

    MyDbgPrintf(
            "\nTOKLIST 0x%08lx = {"
            "fFin=%lu cToks=%lu  uNextFreeTok=%lu cchStr=%lu uNextFree=%lu"
            "}\n",
            pTL,
            pTL->fFinalized,
            pTL->cToks,
            pTL->uNextFreeTok,
            pTL->cchStringBuf,
            pTL->uNextFree
        );
    
    if (pTL->fFinalized)
    {
        TOKEN *pTok =  toklist_get_next(pTL);
        while(pTok)
        {
            tok_dump(pTok);
            
            pTok =  toklist_get_next(pTL);
        }
        toklist_restart(pTL);
    }

    TL_UNLOCK(pTL);
}


void
tok_dump(TOKEN *pTok)
{
    MyDbgPrintf(
            "\tTOKEN 0x%08lx = {eTok=%lu uID=0x%08lx sz=\"%s\"}\n",
            pTok,
            pTok->eTok,
            pTok->uID,
            pTok->szStr
        );
    
}


UINT
toklist_tokenize(TOKLIST *pTL, char *szInput)
{
    UINT cTokens = 0;
    char *pc = szInput;
    char c = 0;
    BOOL fRet = FALSE;

    for (; (c=*pc)!=0; pc++)
    {
        switch(c)
        {
        
        case '*':
            fRet = toklist_add(pTL, tokSTAR,        "*",        tokSTAR);
            continue;

        case '.':
            fRet = toklist_add(pTL, tokDOT,         ".",        tokDOT);
            continue;

        case '?':
            fRet = toklist_add(pTL, tokQUESTION,    "?",        tokQUESTION);
            continue;

        case '[':
            fRet = toklist_add(pTL, tokLBRAC,       "[",        tokLBRAC);
            continue;

        case ']':
            fRet = toklist_add(pTL, tokRBRAC,       "]",        tokRBRAC);
            continue;

        case '/':
            fRet = toklist_add(pTL, tokSLASH,       "/",        tokSLASH);
            continue;

        case '\n':
        case '\r':
        case '\t':
        case ' ':
            continue;
        
        default:

            {
                UINT uCharsParsed =  0;
                char *pcEnd = pc;
                char cSave = 0;

                //
                // We'll locate the end of the potential keyword/number/ident:
                // and temprarily place a NULL char there.
                // 
                //
                while (__iscsym(*pcEnd))
                {
                    pcEnd++;
                }
            
                cSave = *pcEnd;
                *pcEnd = 0;

                if (__iscsymf(c))
                {
                    // This may be a keyword, hex number or identifier. We try
                    // in this order
                    uCharsParsed =  toklist_parse_keyword(
                                                pTL,
                                                rgKeywords,
                                                pc
                                                );
    
                    if (!uCharsParsed && isxdigit(c))
                    {
                        //
                        // Didn't find a keyword and this is a hex digit --
                        // let's try to parse it as a hex number...
                        //
                        uCharsParsed =  toklist_parse_hexnum(pTL, pc);
                    }
    
                    if (!uCharsParsed)
                    {
                        //
                        // Parse it as an identifier...
                        //
                        uCharsParsed =  toklist_parse_identifier(pTL, pc);
                    }
    
                    if (!uCharsParsed)
                    {
                        //
                        // This is an error
                        //
                        MyDbgPrintf("Error at %s\n", pc);
                        goto end;
                    }
                }
                else if (isxdigit(c))
                {
                   uCharsParsed =  toklist_parse_hexnum(pTL, pc);
                }

                //
                // If we've parsed anything it should be ALL of the string...
                //
                MYASSERT(!uCharsParsed || uCharsParsed==(UINT)lstrlenA(pc));

                //
                // Restore the char we replaced by NULL.
                //
                *pcEnd = cSave;
    
                if (!uCharsParsed)
                {
                    //
                    // Syntax error
                    //
                    MyDbgPrintf("Error at %s\n", pc);
                    goto end;
                }
                else
                {
                    pc+= (uCharsParsed-1); // "-1" because of pc++ in
                                            // for clause above.
                }
            }
        }
    }

end:

return cTokens;

}

UINT
toklist_parse_keyword(
      TOKLIST *pTL,
      KEYWORDREC rgKeywords[],
      char *pcInput
      )
//
// Assumes 1st char is valid.
//
{
    UINT uRet = 0;
    KEYWORDREC *pkr = rgKeywords;

    if (!__iscsymf(*pcInput)) goto end;

    for (;pkr->eKey!=keywordNULL; pkr++)
    {
        if (!lstrcmpi(pcInput, pkr->szzAliases))
        {
            //
            // found it
            //
            toklist_add(pTL, tokKEYWORD,  pcInput,  pkr->eKey);
            uRet = lstrlenA(pcInput);
            break;
        }
    }

end:

    return uRet;
}
    
UINT
toklist_parse_hexnum(
      TOKLIST *pTL,
      char *pcInput
      )
{
    char *pc = pcInput;
    UINT uValue = 0;
    char c;
    UINT u;

    //
    //  look for and ignore the "0x" prefix...
    //
    if (pc[0]=='0' && (pc[1]=='x' || pc[1]=='X'))
    {
        pc+=2;
    }


    //
    // Reject number if it is doesn't contain hex digits or is too large
    //
    for (u=0; isxdigit(*pc) && u<8; pc++,u++)
    {
        UINT uDigit = 0;

        char c = *pc;
        if (!isdigit(c))
        {
            // Doesn't work if c ALREADY is upcase: c = _toupper(c);
            //
            if (c >= 'a' && c <= 'f')
            {
            	c = (char) _toupper(c);
			}
            uDigit = 10 + c - 'A';
        }
        else
        {
            uDigit = c - '0';
        }

        uValue = (uValue<<4)|uDigit;
    }
    
    if (!u || *pc)
    {
        return 0;
    }
    else
    {
        toklist_add(pTL, tokNUMBER, pcInput, uValue);
        return (UINT) (pc - pcInput);
    }
}

UINT
toklist_parse_identifier(
      TOKLIST *pTL,
      char *pcInput
      )
{
    UINT uRet = 0;

    if (!__iscsymf(*pcInput)) goto end;

    toklist_add(pTL, tokIDENTIFIER,  pcInput,  0);
    uRet = lstrlenA(pcInput);

end:

    return uRet;
}

DBGCOMMAND *
parse_command(TOKLIST *pTL, NAMESPACE *pNameSpace)
{
    BOOL fRet = FALSE;
    DBGCOMMAND *pCmd = LocalAlloc(LPTR, sizeof(*pCmd));
    TOKEN *pTok =  NULL;
    BOOL fSyntaxError = FALSE;

    if (!pCmd) goto end;

    toklist_restart(pTL);
    pTok =  toklist_get_next(pTL);

    if (!pTok) goto end;

	pCmd->pNameSpace = pNameSpace;
    //
    // Now let's step through the token list, building up our command
    // information.
    //

    // look for help or ?
    if (pTok->eTok == tokQUESTION
       || (pTok->eTok == tokKEYWORD && pTok->uID == keywordHELP))
    {
        pCmd->ePrimaryCmd = cmdHELP;
        fRet = cmd_parse_help(pCmd, pTL);
        goto end;
    }

    fSyntaxError = TRUE;
    fRet = FALSE;

	//
	// Here we would look for other keywords. Currently there are none
	// (dt and dg are not used anymore).
	//
	//
	#if OBSOLETE
    if (pTok->eTok == tokKEYWORD)
    {
           BOOL fDump = FALSE;
		if (pTok->uID == keywordDUMP_TYPE)
        {
            pCmd->ePrimaryCmd = cmdDUMP_TYPE;
            fDump = TRUE;
        }
        else if (pTok->uID == keywordDUMP_GLOBALS)
        {
            pCmd->ePrimaryCmd = cmdDUMP_GLOBALS;
            fDump = TRUE;
        }
        ...
	}
	#endif // OBSOLETE

	pCmd->ePrimaryCmd = cmdDUMP_TYPE;

	//
	// Pares the form a[b].*c* d L e
	//
	{

		BOOL   fPrefixStar = FALSE;
		// we look for patterns like...
		//!aac <type> . <field> <address> L <count> <flags>
		//!aac <type> [index] . <field>   L <count> <flags>
		//
		//!aac i[*].*handle* 0x324890 L 5
		//[*]ident[*]\[<range>\][.][*]ident[*] <number> [L <number>]

		UINT uFlags;            // One or more fCMDFLAG_*
		TOKEN *ptokObject;     // eg <type>
		TOKEN *ptokSubObject;  // eg <field>
		UINT uVectorIndexStart; // if[0]
		UINT uVectorIndexEnd; // if[0]
		UINT uObjectAddress; // <address>
		UINT uObjectCount; // L 10
	
		//
		// 1. Look for primary star
		//
		if (pTok && pTok->eTok == tokSTAR)
		{
			fPrefixStar = TRUE;
			CMD_SET_FLAG(pCmd, fCMDFLAG_OBJECT_STAR_PREFIX);
			pTok = toklist_get_next(pTL);
		}

		//
		// 2.  Look for ident
		//
		if (pTok && tok_try_force_to_ident(pTL, fPrefixStar, pTok))
		{
			//
			// This will try to convert keywords and numbers to idents if
			// possible.
			//
			pCmd->ptokObject = pTok;
			pTok = toklist_get_next(pTL);
		}

		//
		// 3. Look for suffix * for object.
		//
		if (pTok && pTok->eTok == tokSTAR)
		{
			CMD_SET_FLAG(pCmd, fCMDFLAG_OBJECT_STAR_SUFFIX);
			pTok = toklist_get_next(pTL);
		}

		//
		// 4. Look for Vector Range
		//
		if (pTok && pTok->eTok == tokLBRAC)
		{
			//
			// For now, we support either a single * or a single number.
			//
			pTok = toklist_get_next(pTL);

			if (!pTok)
			{
				goto end; // Error -- incomplete vector range
			}
			else
			{
				if (pTok->eTok == tokSTAR)
				{
					pCmd->uVectorIndexStart = 0;
					pCmd->uVectorIndexEnd = (UINT) -1;
				}
				else if (pTok->eTok == tokNUMBER)
				{
					pCmd->uVectorIndexStart =
					pCmd->uVectorIndexEnd = pTok->uID;
				}
				else
				{
					goto end; // failure...
				}

				CMD_SET_FLAG(pCmd, fCMDFLAG_HAS_VECTOR_INDEX);

				pTok = toklist_get_next(pTL);

				if (!pTok || pTok->eTok != tokRBRAC)
				{
					goto end; // failure ... expect RBRAC.
				}
				else
				{
					pTok = toklist_get_next(pTL);
				}
			}
		}

		//
		// 5. Look for DOT
		//
		if (pTok && pTok->eTok == tokDOT)
		{
			fPrefixStar = FALSE;
			pTok = toklist_get_next(pTL);

			// We expect ([*]ident[*]|*)
			//
			// 1. Look for primary star
			//
			if (pTok && pTok->eTok == tokSTAR)
			{
				fPrefixStar = TRUE;
				CMD_SET_FLAG(pCmd, fCMDFLAG_SUBOBJECT_STAR_PREFIX);
				pTok = toklist_get_next(pTL);
			}

			//
			// 2.  Look for ident
			//
			if (pTok && tok_try_force_to_ident(pTL, fPrefixStar, pTok))
			{
				//
				// This will try to convert keywords and numbers to idents if
				// possible.
				//
				pCmd->ptokSubObject = pTok;
				pTok = toklist_get_next(pTL);
			}

			//
			// 3. Look for suffix * for object.
			//
			if (pTok && pTok->eTok == tokSTAR)
			{
				CMD_SET_FLAG(pCmd, fCMDFLAG_SUBOBJECT_STAR_SUFFIX);
				pTok = toklist_get_next(pTL);
			}

			//
			// At this point we should either have a non-null IDENT
			// or the PREFIX START should be set for the object
			// (indicateing "a.*").
			//
			if (    pCmd->ptokSubObject
 				|| (pCmd->uFlags & fCMDFLAG_SUBOBJECT_STAR_SUFFIX))
			{
				CMD_SET_FLAG(pCmd, fCMDFLAG_HAS_SUBOBJECT);
			}
			else
			{
				goto end; // error
			}
		}

		//
		// 6. Look for object address
		//
		if (pTok && pTok->eTok == tokNUMBER)
		{
			pCmd->uObjectAddress = pTok->uID;
			CMD_SET_FLAG(pCmd, fCMDFLAG_HAS_OBJECT_ADDRESS);
			pTok = toklist_get_next(pTL);
		}

		//
		// 7. Look for object count
		//
		if (   pTok && pTok->eTok == tokKEYWORD
			&& pTok->uID == keywordL)
		{
			pTok = toklist_get_next(pTL);
			if (pTok && pTok->eTok == tokNUMBER)
			{
				pCmd->uObjectCount = pTok->uID;
				CMD_SET_FLAG(pCmd, fCMDFLAG_HAS_OBJECT_COUNT);
				pTok = toklist_get_next(pTL);
			}
			else
			{
				// error
			}
		}

		//
		// At this point we should be done...
		//
		if (pTok)
		{
			// error -- extra garbage...
		}
		else
		{
			// Success.
			fRet = TRUE;
			fSyntaxError = FALSE;
		}
	}

end:

    if (fRet)
    {
        pCmd->pvContext = pTL;
    }
    else
    {
        if (fSyntaxError)
        {
            MyDbgPrintf("Unexpected: %s\n", (pTok) ? pTok->szStr : "<null>");
        }
        else
        {
            MyDbgPrintf("Parse failed\n");
        }

        if (pCmd)
        {
            ZeroMemory(pCmd, sizeof(*pCmd));
            LocalFree(pCmd);
            pCmd = NULL;
        }
    }

    if (pTL)
    {
        toklist_restart(pTL);
    }

    return pCmd;
}

BOOL
cmd_parse_help(
    DBGCOMMAND *pCmd,
    TOKLIST *pTL
    )
{
    TOKEN *pTok = toklist_get_next(pTL);

    if (!pTok || pTok->eTok == tokSTAR)
    {
        // User type "help" or "help *"
        MyDbgPrintf("DO HELP\n");
    }

    return TRUE;
}

BOOL
tok_try_force_to_ident(TOKLIST *pTL, BOOL fPrefixStar, TOKEN *pTok)
//
// This gets called when an identifier is expected -- so we see if this
// particular token can be interpreted as in identifier. Some examples
// of when we can do this:
//  dt if.*20334     <--- the "20334" could be part of an identifier, because
//                        of the * prefix.
//
//  dt L.help        <--- both "L" and "help" would have been parsed as
//                        keywords, but here they are intended to be
//                        identifiers.
//  dt abc.def       <--- abc and def would have been parsed as numbers (they
//                        are valid hex numbers), but are intended to be
//                        identifiers.
{
    BOOL fRet = FALSE;

    switch(pTok->eTok)
    {

    case tokNUMBER:
        //
        // We could do this, but subject to some restrictions...
        //
        if (!__iscsymf(pTok->szStr[0]) &&  !fPrefixStar)
        {
            break; // Can't to this: no prefix wild-card (*) and the
                   // number starts with a non-letter.
        }

        // FALL THROUGH ...

    case tokKEYWORD:
        //
        // We can go ahead, but we must make pTok.uID now the offset
        // from the start of the internal string array.
        // 
        {
            char *pc = pTL->rgStringBuf;
        
            for (; *pc; pc+=(lstrlenA(pc)+1))
            {
                if (!lstrcmpiA(pc, pTok->szStr))
                {
                    // found it
                    // MyDbgPrintf("FORCE_TO_IDENT:\nOLD:\n");
                    // tok_dump(pTok);
                    pTok->uID =  (UINT) (pc - pTL->rgStringBuf);
                    pTok->eTok = tokIDENTIFIER;
                    // MyDbgPrintf("NEW:\n");
                    // tok_dump(pTok);
                    fRet = TRUE;

                    break;
                }
            }
        }
        break;

    case tokIDENTIFIER:
        //
        // nothing to do...
        //
        fRet = TRUE;
        break;

    default:
        //
        // Can't convert any other kind of token to identifier...
        //
        break;

    }

    return fRet;
}

void
DoCommand(DBGCOMMAND *pCmd, PFN_SPECIAL_COMMAND_HANDLER pfnHandler)
{
    char *szMsg = NULL;

//    pCmd->pfnSpecialHandler = pfnHandler;

    switch(pCmd->ePrimaryCmd)
    {
    case cmdDUMP_TYPE:
        DoDumpType(pCmd);
        break;
    case cmdDUMP_GLOBALS:
        DoDumpGlobals(pCmd);
        break;
    case cmdHELP:
        DoHelp(pCmd);
        break;

    default:
        szMsg = "Unknown command\n";
        break;
    }


    if (szMsg)
    {
        MyDbgPrintf(szMsg);
    }

    return;
}


typedef struct
{
    DBGCOMMAND *pCmd;
    TYPE_INFO  *pType;

} MY_LIST_NODE_CONTEXT;

typedef
ULONG
MyDumpListNode (
		UINT_PTR uNodeAddr,
		UINT uIndex,
		void *pvContext
		);

void
DoDumpType(DBGCOMMAND *pCmd)
{
    char *szPattern = NULL;
    PFNMATCHINGFUNCTION pfnMatchingFunction = MatchAlways;
    TYPE_INFO **ppti = NULL;
    UINT uMatchCount = 0;
    TYPE_INFO *ptiDump = NULL;

    //
    // Pick a selection function ...
    //
    if (pCmd->ptokObject)
    {
        szPattern = pCmd->ptokObject->szStr;
        if (  CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_PREFIX)
            &&CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_SUFFIX))
        {
            pfnMatchingFunction = MatchSubstring;
        }
        else if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_PREFIX))
        {
            pfnMatchingFunction = MatchSuffix;
        }
        else if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_SUFFIX))
        {
            pfnMatchingFunction = MatchPrefix;
        }
        else
        {
            pfnMatchingFunction = MatchExactly;
        }
        
    }

    //
    // search through global type array for type pName.
    //
    for(ppti=pCmd->pNameSpace->pTypes;*ppti;ppti++)
    {
        TYPE_INFO *pti = *ppti;
        bool fMatch  = !szPattern
                   || !_stricmp(szPattern, pti->szShortName)
                   || pfnMatchingFunction(szPattern,  pti->szName);

        if (fMatch)
        {
        #if 0
            MyDbgPrintf(
                "TYPE \"%2s\" %s (%lu Bytes)\n",
                pti->szShortName,
                pti->szName,
                pti->cbSize
                );
		#endif // 0
            uMatchCount++;
            if (!ptiDump)
            {
                ptiDump = pti;
            }
                
#if 0
            uAddr = 
            MyDbgPrintf(
                "dc 0x%08lx L %03lx \"%2s\" %s\n",
                pgi->uAddr,
                pgi->cbSize,
                pgi->szShortName,
                pgi->szName
                );
            if (szPattern && pgi->uAddr)
            {
                MyDumpObject(
                    pCmd,
                    pgi->pBaseType,
                    pgi->uAddr,
                    pgi->cbSize,
                    pgi->szName
                    );
            }
#endif // 0
        }
    }

    if (!uMatchCount)
    {
        MyDbgPrintf(
            "Could not find type \"%s\"",
             (szPattern ? szPattern : "*")
             );
    }
    else if (   uMatchCount==1)
    {

		UINT uObjectCount = 1;
		UINT uStartIndex = 0;
		UINT_PTR uObjectAddress = 0;
		BOOLEAN fList =  TYPEISLIST(ptiDump)!=0;

    	if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_HAS_OBJECT_ADDRESS))
    	{
			uObjectAddress = pCmd->uObjectAddress;
		}

		//
		// Determine start index.
		//
		if (CMD_IS_FLAG_SET(pCmd,  fCMDFLAG_HAS_VECTOR_INDEX))
		{
			uStartIndex =  pCmd->uVectorIndexStart;
			if (fList && !CMD_IS_FLAG_SET(pCmd, fCMDFLAG_HAS_OBJECT_COUNT))
			{
				uObjectCount =  pCmd->uVectorIndexEnd - uStartIndex;
				if (uObjectCount != (UINT) -1)
				{
					uObjectCount++;
				}
			}
		}

		//
		// Determine object count...
		//
		if (CMD_IS_FLAG_SET(pCmd,  fCMDFLAG_HAS_OBJECT_COUNT))
		{
			uObjectCount =  pCmd->uObjectCount;
		}

		//
		// If no address is specified, we'll try to resolve it ...
		//
    	if (!CMD_IS_FLAG_SET(pCmd, fCMDFLAG_HAS_OBJECT_ADDRESS))
    	{
    		BOOLEAN fUseCache = FALSE;

			//
			// Algorithm for determining whether to use cache or to resolve
			// address:
			//
			if (ptiDump->uCachedAddress)
			{
				//
				// Except for the special case of [0], we will use
				// the the cached value.
				//
				if (!(		uStartIndex ==0
					 	&& 	uObjectCount==1
					 	&&  CMD_IS_FLAG_SET(pCmd,  fCMDFLAG_HAS_VECTOR_INDEX)))
				{
					fUseCache = TRUE;
				}
			}

			if (fUseCache)
			{
				uObjectAddress = ptiDump->uCachedAddress;
			}
			else
			{
				if (pCmd->pNameSpace->pfnResolveAddress)
				{
					uObjectAddress = pCmd->pNameSpace->pfnResolveAddress(
														ptiDump
														);
				}
			}
    	}

    	if (uObjectAddress && uObjectCount)
    	{

			//
			// Prune these to "reasonable" values.
			//
			if (uObjectCount > 100)
			{
				MyDbgPrintf("Limiting object count to 100\n");
				uObjectCount = 100;
			}

			if (fList)
			{
				MY_LIST_NODE_CONTEXT Context;
				Context.pCmd = pCmd;
				Context.pType = ptiDump;

				WalkList(
					uObjectAddress,		// start address
					ptiDump->uNextOffset, 		// next offset
					uStartIndex,
					uStartIndex+uObjectCount-1, // end index
					&Context,					// context
					NodeFunc_DumpType,			// function
					(char *) ptiDump->szName
					);

				//
				// If only a single structure was dumped, and it was dumped
				// successfully, we will update this structure's cache.
				// TODO: we don't check for success 
				//
				if (uObjectCount==1)
				{
					WalkList(
						uObjectAddress,			// start address
						ptiDump->uNextOffset, 	// next offset
						uStartIndex,
						uStartIndex,  			// end index
						ptiDump,					// context
						NodeFunc_UpdateCache,	// function
						(char *) ptiDump->szName
						);
				}
			}
			else
			{
				UINT cbSize =  ptiDump->cbSize;
				UINT_PTR uAddr  =  uObjectAddress + uStartIndex*cbSize;
				UINT_PTR uEnd   =  uAddr + uObjectCount*cbSize;
				//
				// For arays, compute offset to start address
				//
				uObjectAddress = uAddr;

				for (; uAddr<uEnd; uAddr+=cbSize)
				{
					MyDumpObject(
						pCmd,
						ptiDump,
						uAddr,
						ptiDump->cbSize,
						ptiDump->szName
						);
				}
				//
				// If only a single structure was dumped, and it was dumped
				// successfully, we will update this structure's cache.
				// TODO: we don't check for success 
				//
				if (uObjectCount==1)
				{
					ptiDump->uCachedAddress = uObjectAddress;
				}
			}

    	}
    	else
    	{
    		MyDbgPrintf(
				"Could not resolve address for object %s\n",
				ptiDump->szName
				);
    	}
    }

}

void
DoDumpGlobals(DBGCOMMAND *pCmd)
{
    GLOBALVAR_INFO *pgi = pCmd->pNameSpace->pGlobals;
    char *szPattern = NULL;
    PFNMATCHINGFUNCTION pfnMatchingFunction = MatchAlways;

    //
    // Pick a selection function ...
    //
    if (pCmd->ptokObject)
    {
        szPattern = pCmd->ptokObject->szStr;
        if (  CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_PREFIX)
            &&CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_SUFFIX))
        {
            pfnMatchingFunction = MatchSubstring;
        }
        else if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_PREFIX))
        {
            pfnMatchingFunction = MatchSuffix;
        }
        else if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_OBJECT_STAR_SUFFIX))
        {
            pfnMatchingFunction = MatchPrefix;
        }
        else
        {
            pfnMatchingFunction = MatchExactly;
        }
        
    }

    //
    // Run through our list of globals, and if the entry is selected,
    // we will display it.
    //
    for (;pgi->szName; pgi++)
    {
        bool fMatch  = !szPattern
                       || !_stricmp(szPattern, pgi->szShortName)
                       || pfnMatchingFunction(szPattern,  pgi->szName);
        if (fMatch)
        {
            pgi->uAddr = dbgextGetExpression(pgi->szName);
            MyDbgPrintf(
                "dc 0x%08lx L %03lx \"%2s\" %s\n",
                pgi->uAddr,
                pgi->cbSize,
                pgi->szShortName,
                pgi->szName
                );
            if (szPattern && pgi->uAddr)
            {
                MyDumpObject(
                    pCmd,
                    pgi->pBaseType,
                    pgi->uAddr,
                    pgi->cbSize,
                    pgi->szName
                    );
            }
        }
    }
}

void
DoHelp(
	DBGCOMMAND *pCmd // OPTIONAL
	)
{
	//
	//
	//
    MyDbgPrintf("help unimplemented\n");
}

void
MyDumpObject (
    DBGCOMMAND *pCmd,
    TYPE_INFO *pType,
    UINT_PTR uAddr,
    UINT     cbSize,
    const char *szDescription
    )
{
    UINT uMatchFlags = 0;
    char *szFieldSpec  = NULL;

    if (pCmd->ptokSubObject)
    {
        szFieldSpec = pCmd->ptokSubObject->szStr;
        if (  CMD_IS_FLAG_SET(pCmd, fCMDFLAG_SUBOBJECT_STAR_PREFIX)
            &&CMD_IS_FLAG_SET(pCmd, fCMDFLAG_SUBOBJECT_STAR_SUFFIX))
        {
            uMatchFlags = fMATCH_SUBSTRING;
        }
        else if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_SUBOBJECT_STAR_PREFIX))
        {
            uMatchFlags = fMATCH_SUFFIX;
        }
        else if (CMD_IS_FLAG_SET(pCmd, fCMDFLAG_SUBOBJECT_STAR_SUFFIX))
        {
            uMatchFlags = fMATCH_PREFIX;
        }
    }

    if (!pType)
    {
        DumpMemory(
            uAddr,
            cbSize,
            0,
            szDescription
            );
    }
    else
    {
        DumpStructure(pType, uAddr, szFieldSpec, uMatchFlags);
    }
}

ULONG
NodeFunc_DumpType (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	)
{
	MY_LIST_NODE_CONTEXT *pContext =  (MY_LIST_NODE_CONTEXT*) pvContext;

	MyDbgPrintf("[%lu] ", uIndex);
	MyDumpObject (
		pContext->pCmd,
		pContext->pType,
		uNodeAddr,
		pContext->pType->cbSize,
		pContext->pType->szName
		);
	return 0;
}

ULONG
NodeFunc_UpdateCache (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	)
{
	TYPE_INFO *pti = (TYPE_INFO*) pvContext;

	if (pti->uCachedAddress != uNodeAddr)
	{
		MyDbgPrintf(
			"Updating Cache from 0x%lx to 0x%lx\n", 
			pti->uCachedAddress,
			uNodeAddr
			);
	}
	pti->uCachedAddress = uNodeAddr;
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\kdext\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	util.c	- Generic Debugger Extension Utilities

Abstract:

	Taken from AliD's ndiskd(ndiskd.c).

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	josephj     03-30-98    Created (taken fron AliD's ndiskd (ndiskd.c).

Notes:

--*/
#include "common.h"


WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf

#define    NL      1
#define    NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?




/*
 * Print out an optional message, an ANSI_STRING, and maybe a new-line
 */
BOOL
PrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl )
{
    PCHAR    StringData;
    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    StringData = (PCHAR)LocalAlloc( LPTR, pStr->Length + 1 );

    if( StringData == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory((ULONG_PTR) pStr->Buffer,
               StringData,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        StringData[ pStr->Length ] = '\0';
        dprintf("%s%s", StringData, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)StringData);

    return BytesRead;
}

/*
 * Get 'size' bytes from the debuggee program at 'dwAddress' and place it
 * in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 */
BOOL
GetData( IN LPVOID ptr, IN UINT_PTR dwAddress, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count = size;

    while( size > 0 ) {

    if (count >= 3000)
        count = 3000;

        b = ReadMemory(dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count ) {
            ERRPRT( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG_PTR)ptr + count);
    }

    return TRUE;
}


/*
 * Print out a single HEX character
 */
VOID
PrintHexChar( IN UCHAR c )
{
    dprintf( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Print out 'buf' of 'cbuf' bytes as HEX characters
 */
VOID
PrintHexBuf( IN PUCHAR buf, IN ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        dprintf( " " );
    }
}


/*
 * Fetch the null terminated UNICODE string at dwAddress into buf
 */
BOOL
GetString( IN UINT_PTR dwAddress, IN LPWSTR buf, IN ULONG MaxChars )
{
    do {
        if( !GetData( buf, dwAddress, sizeof( *buf ), "Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( --MaxChars && *buf++ != '\0' );

    return TRUE;
}

char *mystrtok ( char *string, char * control )
{
    static UCHAR *str;
    char *p, *s;

    if( string )
        str = string;

    if( str == NULL || *str == '\0' )
        return NULL;

    //
    // Skip leading delimiters...
    //
    for( ; *str; str++ ) {
        for( s=control; *s; s++ ) {
            if( *str == *s )
                break;
        }
        if( *s == '\0' )
            break;
    }

    //
    // Was it was all delimiters?
    //
    if( *str == '\0' ) {
        str = NULL;
        return NULL;
    }

    //
    // We've got a string, terminate it at first delimeter
    //
    for( p = str+1; *p; p++ ) {
        for( s = control; *s; s++ ) {
            if( *p == *s ) {
                s = str;
                *p = '\0';
                str = p+1;
                return s;
            }
        }
    }

    //
    // We've got a string that ends with the NULL
    //
    s = str;
    str = NULL;
    return s;
}

        
VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;
    g_pfnDbgPrintf = dprintf;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf(
        "%s IPATM Extension dll for Build %d debugging %s kernel for Build %d\n",
        kind,
        VER_PRODUCTBUILD,
        SavedMajorVersion == 0x0c ? "Checked" : "Free",
        SavedMinorVersion
    );
}

VOID
CheckVersion(
    VOID
    )
{

	//
	// for now don't bother to version check
	//
	return;
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

//
//	VOID
//	PrintName(
//		PUNICODE_STRING Name
//		);
// print a unicode string
// Note: the Buffer field in unicode string is unmapped
//
VOID
PrintName(
	PUNICODE_STRING Name
	)
{
	USHORT i;
	WCHAR ubuf[256];
	UCHAR abuf[256];
	
	if (!GetString((UINT_PTR)Name->Buffer, ubuf, (ULONG)Name->Length))
	{
		return;
	}

	for (i = 0; i < Name->Length/2; i++)
	{
		abuf[i] = (UCHAR)ubuf[i];
	}
	abuf[i] = 0;

	dprintf("%s",abuf);
}

MYPWINDBG_OUTPUT_ROUTINE g_pfnDbgPrintf = NULL;




bool
dbgextReadMemory(
    UINT_PTR uOffset,
    void * pvBuffer,
    UINT cb,
    char *pszDescription
    )
{
    UINT cbBytesRead=0;

    bool fRet = ReadMemory(
                    uOffset,
                    pvBuffer,
                    cb,
                    &cbBytesRead
                    );
    if (!fRet || cbBytesRead != cb)
    {
        ERRPRT("Read  failed: 0x%X(%s, %u bytes)\n",uOffset,pszDescription,cb);
        fRet = FALSE;
    }

    return fRet;
}

bool
dbgextWriteMemory(
    UINT_PTR uOffset,
    void * pvBuffer,
    UINT cb,
    char *pszDescription
    )
{
    UINT cbBytesWritten=0;
    bool fRet = WriteMemory(
                    uOffset,
                    pvBuffer,
                    cb,
                    &cbBytesWritten
                    );
    if (!fRet || cbBytesWritten != cb)
    {
        ERRPRT("Write failed: 0x%X(%s, %u bytes)\n",uOffset,pszDescription,cb);
        fRet = FALSE;
    }
    return 0;
}


bool
dbgextReadUINT_PTR(
    UINT_PTR uOffset,
    UINT_PTR *pu,
    char *pszDescription
    )
{
    UINT cbBytesRead=0;

    bool fRet = ReadMemory(
                    uOffset,
                    pu,
                    sizeof(*pu),
                    &cbBytesRead
                    );
    if (!fRet || cbBytesRead != sizeof(*pu))
    {
        ERRPRT("Read  failed: 0x%X(%s, UINT_PTR)\n",uOffset,pszDescription);
        fRet = FALSE;
    }

    return fRet;
}

bool
dbgextReadUINT(
    UINT_PTR uOffset,
    UINT *pu,
    char *pszDescription
    )
{
    UINT cbBytesRead=0;

    bool fRet = ReadMemory(
                    uOffset,
                    pu,
                    sizeof(*pu),
                    &cbBytesRead
                    );
    if (!fRet || cbBytesRead != sizeof(*pu))
    {
        ERRPRT("Read  failed: 0x%X(%s, UINT)\n",uOffset,pszDescription);
        fRet = FALSE;
    }

    return fRet;
}

bool
dbgextReadSZ(
    UINT_PTR uOffset,
    char *szBuf,
    UINT	cbMax,
    char *pszDescription
    )
// Read a NULL-terminated string (upto cbMax)
//
{
    UINT cbBytesRead=0;

    bool fRet = ReadMemory(
                    uOffset,
                    szBuf,
                    cbMax,
                    &cbBytesRead
                    );
    if (!fRet)
    {
        ERRPRT("Read  failed: 0x%p(%s, SZ)\n",uOffset,pszDescription);
        fRet = FALSE;
    }
    else
    {
    	if (cbBytesRead)
    	{
    		szBuf[cbBytesRead-1] = 0;
		}
		else
		{
			*szBuf = 0;
		}
    }
    return fRet;
}

bool
dbgextWriteUINT_PTR(
    UINT_PTR uOffset,
    UINT_PTR u,
    char *pszDescription
    )
{
    UINT cbBytesWritten=0;
    bool fRet = WriteMemory(
                    uOffset,
                    &u,
                    sizeof(uOffset),
                    &cbBytesWritten
                    );
    if (!fRet || cbBytesWritten != sizeof(u))
    {
        ERRPRT("Write failed: 0x%X(%s, UINT_PTR)\n",uOffset,pszDescription);
        fRet = FALSE;
    }
    return fRet;
}

UINT_PTR
dbgextGetExpression(
    const char *pcszExpression
    )
{
    UINT_PTR uRet =  GetExpression(pcszExpression);
    
    //
    // At such a point we use this for something besides pointers,
    // we will remove the check below.
    //

    if (!uRet)
    {
        ERRPRT("Eval  failed: \"%s\"\n", pcszExpression);
    }

    return uRet;
}

void
dbgextDumpDLlist(
	UINT_PTR uOffset,
	UINT	uContainingOffset,
	char 	*pszDescription
	)
/*++
	Print the pointers to the containing records of
	all the items in the doubly-linked list.
--*/
{
	bool fRet;
	LIST_ENTRY Link;
	LIST_ENTRY *pHead;
	LIST_ENTRY *pFlink;
	UINT uCount = 0;
	UINT uMax = 16;

	do
	{
		char *szPrefix;
		char *szSuffix;

		// Read the list header.
		//
		fRet = dbgextReadMemory(
				uOffset,
				&Link,
				sizeof(Link),
				pszDescription
				);

		if (!fRet) break;

		pHead = (LIST_ENTRY *) uOffset;
		pFlink = Link.Flink;

		if (pFlink == pHead)
		{
			MyDbgPrintf("        <empty>\n");
			break;
		}


		for(
			;
			(pFlink != pHead);
			pFlink = Link.Flink, uCount++)
		{
			char *pContainingRecord = ((char *)pFlink) -  uContainingOffset;

			szPrefix = "        ";
			szSuffix = "";
			if (uCount%4)
			{
				szPrefix = " ";
				if ((uCount%4)==3)
				{
					szSuffix = "\n";
				}
			}

			if (uCount >= uMax) break;
			

			// Read the next link.
			//
			fRet = dbgextReadMemory(
					(UINT_PTR) pFlink,
					&Link,
					sizeof(Link),
					pszDescription
					);
			if (!fRet) break;

			MyDbgPrintf("%s0x%p%s", szPrefix, pContainingRecord, szSuffix);
		}

		if (uCount%4)
		{
			MyDbgPrintf("\n");
		}
		if (pFlink != pHead && uCount >= uMax)
		{
			MyDbgPrintf("        ...\n");
		}

	} while (FALSE);
}

void
WalkDLlist(
	UINT_PTR uOffsetHeadList,
	UINT_PTR uOffsetStartLink,	OPTIONAL
	void *pvContext,
	PFNNODEFUNC pFunc,
	UINT	MaxToWalk,
	char *pszDescription
	)
/*++
	Print the pointers to the containing records of
	all the items in the doubly-linked list.
--*/
{
	bool fRet;
	LIST_ENTRY Link;
	LIST_ENTRY *pHead;
	LIST_ENTRY *pFlink;
	UINT uCount = 0;
	UINT uMax = MaxToWalk;

	do
	{
		// Read the list header.
		//
		fRet = dbgextReadMemory(
				uOffsetHeadList,
				&Link,
				sizeof(Link),
				pszDescription
				);

		if (!fRet) break;

		pHead = (LIST_ENTRY *) uOffsetHeadList;

		if (uOffsetStartLink == 0)
		{
			pFlink = Link.Flink;
		}
		else
		{
			pFlink = (LIST_ENTRY*) uOffsetStartLink;
		}

		if (pFlink == pHead)
		{
			// MyDbgPrintf("        <end-of-list>\n");
			break;
		}


		for(
			;
			(pFlink != pHead);
			pFlink = Link.Flink, uCount++)
		{
			if (uCount >= uMax) break;
			
			// Read the next link.
			//
			fRet = dbgextReadMemory(
					(UINT_PTR) pFlink,
					&Link,
					sizeof(Link),
					pszDescription
					);
			if (!fRet) break;

			// Call the nodefunc..
			//
			pFunc((UINT_PTR)pFlink, 0 /*uIndex*/, pvContext);
		}
	} while (FALSE);
}

void
DumpObjects(TYPE_INFO *pType, UINT_PTR uAddr, UINT cObjects, UINT uFlags)
{
    //
    // Print object's type and size
    //
    dprintf(
        "%s@0x%X (%lu Bytes)\n",
        pType->szName,
        uAddr,
        pType->cbSize
        );


    DumpMemory(
        uAddr,
        pType->cbSize,
        0,
        pType->szName
        );
    
    //
    // Dump bytes...
    //

    return;
}

BYTE rgbScratchBuffer[100000];

bool
DumpMemory(
    UINT_PTR uAddr,
    UINT cb,
    UINT uFlags,
    const char *pszDescription
    )
{
    bool fTruncated = FALSE;
    bool fRet = FALSE;
    UINT cbLeft = cb;
    char *pbSrc = rgbScratchBuffer;

    if (cbLeft>1024)
    {
        cbLeft = 1024;
        fTruncated = TRUE;
    }
    
    fRet = dbgextReadMemory(
            uAddr,
            rgbScratchBuffer,
            cbLeft,
            (char*)pszDescription
            );

    if (!fRet) goto end;

    #define ROWSIZE 16 // bytes
    //
    // Dump away...
    //
    while (cbLeft)
    {
        char rgTmp_dwords[ROWSIZE];
        char rgTmp_bytes[ROWSIZE];
        char *pb=NULL;
        UINT cbRow = ROWSIZE;
        if (cbRow > cbLeft)
        {
            cbRow = cbLeft;
        }
    
        
        memset(rgTmp_dwords, 0xff, sizeof(rgTmp_dwords));
        memset(rgTmp_bytes,  ' ', sizeof(rgTmp_bytes));

        memcpy(rgTmp_dwords, pbSrc, cbRow);
        memcpy(rgTmp_bytes,  pbSrc, cbRow);
        
        // sanitize bytes
        for (pb=rgTmp_bytes; pb<(rgTmp_bytes+sizeof(rgTmp_bytes)); pb++)
        {
            char c = *pb;
            if (c>=0x20 && c<0x7f) // isprint is too permissive.
            {
                if (*pb=='\t')
                {
                    *pb=' ';
                }
            }
            else
            {
                *pb='.';
            }
        }

        dprintf(
            "    %08lx: %08lx %08lx %08lx %08lx |%4.4s|%4.4s|%4.4s|%4.4s|\n",
            uAddr,
            ((DWORD*) rgTmp_dwords)[0],
            ((DWORD*) rgTmp_dwords)[1],
            ((DWORD*) rgTmp_dwords)[2],
            ((DWORD*) rgTmp_dwords)[3],
        #if 1
            rgTmp_bytes+0,
            rgTmp_bytes+4,
            rgTmp_bytes+8,
            rgTmp_bytes+12
        #else
            "aaaabbbbccccdddd",
            "bbbb",
            "cccc",
            "dddd"
        #endif
            );

        cbLeft -= cbRow;
        pbSrc += cbRow;
        uAddr += cbRow;
    }

#if 0
0x00000000: 00000000 00000000 00000000 00000000 |xxxx|xxxx|xxxx|xxxx|
0x00000000: 00000000 00000000 00000000 00000000 |xxxx|xxxx|xxxx|xxxx|
0x00000000: 00000000 00000000 00000000 00000000 |xxxx|xxxx|xxxx|xxxx|
#endif // 

end:

    return fRet;
}


bool
MatchPrefix(const char *szPattern, const char *szString)
{
    BOOL fRet = FALSE;
    ULONG uP = lstrlenA(szPattern);
    ULONG uS = lstrlenA(szString);

    if (uP<=uS)
    {
        fRet = (_memicmp(szPattern, szString, uP)==0);
    }

    return fRet;
}

bool
MatchSuffix(const char *szPattern, const char *szString)
{
    BOOL fRet = FALSE;
    ULONG uP = lstrlenA(szPattern);
    ULONG uS = lstrlenA(szString);

    if (uP<=uS)
    {
        szString += (uS-uP);
        fRet = (_memicmp(szPattern, szString, uP)==0);
    }
    return fRet;
}

bool
MatchSubstring(const char *szPattern, const char *szString)
{
    BOOL fRet = FALSE;
    ULONG uP = lstrlenA(szPattern);
    ULONG uS = lstrlenA(szString);

    if (uP<=uS)
    {
        const char *szLast =  szString + (uS-uP);
        do
        {
            fRet = (_memicmp(szPattern, szString, uP)==0);

        } while (!fRet && szString++ < szLast);
    }

    return fRet;
}

bool
MatchExactly(const char *szPattern, const char *szString)
{
    BOOL fRet = FALSE;
    ULONG uP = lstrlenA(szPattern);
    ULONG uS = lstrlenA(szString);

    if (uP==uS)
    {
        fRet = (_memicmp(szPattern, szString, uP)==0);
    }

    return fRet;
}


bool
MatchAlways(const char *szPattern, const char *szString)
{
    return TRUE;
}

void
DumpBitFields(
		ULONG  			Flags,
    	BITFIELD_INFO	rgBitFieldInfo[]
		)
{
	BITFIELD_INFO *pbf = rgBitFieldInfo;

	for(;pbf->szName; pbf++)
	{
		if ((Flags & pbf->Mask) == pbf->Value)
		{
			MyDbgPrintf(" %s", pbf->szName);
		}
	}
}

void
DumpStructure(
    TYPE_INFO *pType,
    UINT_PTR uAddr,
    char *szFieldSpec,
    UINT uFlags
    )
{
    //
    // Determine field comparision function ...
    //
    PFNMATCHINGFUNCTION pfnMatchingFunction = MatchAlways;

	if (pType->pfnSpecializedDump)
	{
		// Call the specialized function to handle this...
		//
		pType->pfnSpecializedDump(
				pType,
				uAddr,
				szFieldSpec,
				uFlags
				);
		return;	
	}

    //
    // Pick a selection function ...
    //
    if (szFieldSpec)
    {
        if (uFlags & fMATCH_SUBSTRING)
        {
            pfnMatchingFunction = MatchSubstring;
        }
        else if (uFlags & fMATCH_SUFFIX)
        {
            pfnMatchingFunction = MatchSuffix;
        }
        else if (uFlags & fMATCH_PREFIX)
        {
            pfnMatchingFunction = MatchPrefix;
        }
        else
        {
            pfnMatchingFunction = MatchExactly;
        }
    }

    //
    // Print object's type and size
    //
    dprintf(
        "%s@0x%X (%lu Bytes)\n",
        pType->szName,
        uAddr,
        pType->cbSize
        );

    //
    // Run through all the fields in this type, and if the entry is selected,
    // we will display it.
    //
    {
        STRUCT_FIELD_INFO *pField = pType->rgFields;
        for (;pField->szFieldName; pField++)
        {
            bool fMatch  = !szFieldSpec
                           || pfnMatchingFunction(szFieldSpec, pField->szFieldName);
            if (fMatch)
            {
                UINT_PTR uFieldAddr = uAddr + pField->uFieldOffset;

                // special-case small fields...
                if (pField->uFieldSize<=sizeof(ULONG_PTR))
                {

					ULONG_PTR Buf=0;
    				BOOL fRet = dbgextReadMemory(
										uFieldAddr,
										&Buf,
										pField->uFieldSize,
                        				(char*)pField->szFieldName
										);
					if (fRet)
					{
						// print it as a hex number

						MyDbgPrintf(
							"\n%s\t[%lx,%lx]: 0x%lx",
							pField->szFieldName,
							pField->uFieldOffset,
							pField->uFieldSize,
							Buf
							);

						//
						// If it's an embedded object and it's a bitfield,
						// print the bitfields...
						//
						if (	FIELD_IS_EMBEDDED_TYPE(pField)
							&&  TYPEISBITFIELD(pField->pBaseType) )
						{
							DumpBitFields(
									(ULONG)Buf,
								    pField->pBaseType->rgBitFieldInfo
								    );
							
						}
						
						MyDbgPrintf("\n");
	
					}
					continue;
				}

            #if 0
                MyDbgPrintf(
                    "%s\ndc 0x%08lx L %03lx %s\n",
                    pField->szSourceText,
                    uFieldAddr,
                    pField->uFieldSize,
                    pField->szFieldName
                    );
            #else // 1
                MyDbgPrintf(
                    "\n%s\t[%lx,%lx]\n",
                    pField->szFieldName,
                    pField->uFieldOffset,
                    pField->uFieldSize
                    );
            #endif // 1

                // if (szFieldSpec)
                {
                #if 0
                    MyDumpObjects(
                        pCmd,
                        pgi->pBaseType,
                        pgi->uAddr,
                        pgi->cbSize,
                        pgi->szName
                        );
                #endif // 0
                    DumpMemory(
                        uFieldAddr,
                        pField->uFieldSize,
                        0,
                        pField->szFieldName
                        );
                }
            }
        }
    }

    return;
}


DECLARE_API( help )
{
    do_help(args);
}


DECLARE_API( rm )
{
    do_rm(args);
}

DECLARE_API( arp )
{
    do_arp(args);
}


ULONG
NodeFunc_DumpAddress (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	)
{
	MyDbgPrintf("[%lu] 0x%08lx\n", uIndex, uNodeAddr);
	return 0;
}


UINT
WalkList(
	UINT_PTR uStartAddress,
	UINT uNextOffset,
	UINT uStartIndex,
	UINT uEndIndex,
	void *pvContext,
	PFNNODEFUNC pFunc,
	char *pszDescription
	)
//
// Visit each node in the list in turn,
// reading just the next pointers. It calls pFunc for each list node
// between uStartIndex and uEndIndex. It terminates under the first of
// the following conditions:
// 	* Null pointer
// 	* ReadMemoryError
// 	* Read past uEndIndex
// 	* pFunc returns FALSE
//
{
	UINT uIndex = 0;
	UINT_PTR uAddress = uStartAddress;
	BOOL fRet = TRUE;
	UINT uRet = 0;


	//
	// First skip until we get to uStart Index
	//
	for (;fRet && uAddress && uIndex < uStartIndex; uIndex++)
	{
		fRet =  dbgextReadUINT_PTR(
							uAddress+uNextOffset,
							&uAddress,
							pszDescription
							);
	}


	//
	// Now call pFunc with each node
	//
	for (;fRet && uAddress && uIndex <= uEndIndex; uIndex++)
	{
		uRet = pFunc(uAddress, uIndex, pvContext);

		fRet =  dbgextReadUINT_PTR(
							uAddress+uNextOffset,
							&uAddress,
							pszDescription
							);
	}

	pFunc = NodeFunc_DumpAddress;
	return uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\kdext\util.h ===
#define  MYASSERT(_cond) \
            ((_cond) ?  0 : MyDbgPrintf("ASSERTION FAILED\n"))


typedef int bool;


//
// Debugger Extension Primitives
//


bool
dbgextReadMemory(
    UINT_PTR uOffset,
    void * pvBuffer,
    UINT cb,
    char *pszDescription
    );

bool
dbgextReadUINT(
    UINT_PTR uOffset,
    UINT *pu,
    char *pszDescription
    );

bool
dbgextReadUINT_PTR(
    UINT_PTR uOffset,
    UINT_PTR *pu,
    char *pszDescription
    );

bool
dbgextReadSZ(
    UINT_PTR uOffset,
    char *szBuf,
    UINT	cbMax,
    char *pszDescription
    );

bool
dbgextWriteMemory(
    UINT_PTR uOffset,
    void * pvBuffer,
    UINT cb,
    char *pszDescription
    );

bool
dbgextWriteUINT_PTR(
    UINT_PTR uOffset,
    UINT_PTR u,
    char *pszDescription
    );


UINT_PTR
dbgextGetExpression(
    const char *pcszExpression
    );


#if 0   // Not sure what this one is about...
void 
dbgextGetSymbol(
    void *offset,
    UCHAR *pchBuffer,
    UINT  *pDisplacement
    );
#endif // 0

void
dbgextDumpDLlist(
	UINT_PTR uOffset,
	UINT	uContainingOffset,
	char 	*pszDescription
	);


typedef
void
(__cdecl *MYPWINDBG_OUTPUT_ROUTINE)(
    const char * lpFormat,
    ...
    );

extern MYPWINDBG_OUTPUT_ROUTINE g_pfnDbgPrintf;

#define MyDbgPrintf g_pfnDbgPrintf


//
//  User Commands Parsing Support and Structures
//
typedef struct
{
    //TOKEN tokCmd;
    UINT uParam;
    UINT uFlags;

} COMMAND;

struct _TYPE_INFO;

typedef
void
(*PFN_SPECIALIZED_DUMP)(
		struct _TYPE_INFO *pType,
		UINT_PTR uAddr,
		char *szFieldSpec,
		UINT uFlags
		);
#define fDUMP_ONE_LINE_SUMMARY (0x1)

typedef struct
{
	char *szName;
	UINT Mask;
	UINT Value;

} BITFIELD_INFO;


typedef struct _TYPE_INFO
{
    const char *	szName;
    const char *	szShortName;
    UINT 			uTypeID;
    UINT 			uFlags;		// One or more fTYPEINFO_ flags.
    UINT 			cbSize;

    struct _STRUCT_FIELD_INFO *rgFields;

    UINT 			uNextOffset;
					// If this type is a list element, this is the offset
					// in bytes to the next pointer.
					// Only valid if uFlags contains fTYPEINFO_ISLIST
					
    BITFIELD_INFO	*rgBitFieldInfo;
    				//
    				// If this type is a bitfield, this this points
    				// to an array of BITFIELD_INFO structs, giving
    				// the set of valid bitfield constants that can
    				// be held in this bitfield.
    				//
    				// Note -- only one of rgFields and rgBitField info
    				// 		   should be non-null (both can be null).
    				//

	PFN_SPECIALIZED_DUMP		pfnSpecializedDump;
					//
					// If nonzero, use this function instead of the standard
					// structure dumping routine.
					//

	UINT_PTR		uCachedAddress; // Set to the address of this type that
									// was most recently referenced.



} TYPE_INFO;



#define fTYPEINFO_ISLIST     (0x1<<0)
#define fTYPEINFO_ISBITFIELD (0x1<<1)

#define TYPEISLIST(_pType) 		((_pType)->uFlags & fTYPEINFO_ISLIST)
#define TYPEISBITFIELD(_pType) 	((_pType)->uFlags & fTYPEINFO_ISBITFIELD)

//
// STRUCT_FIELD_INFO contains information about a particular field of a struct.
//
typedef struct _STRUCT_FIELD_INFO
{
    const char *szFieldName;
    UINT uFieldOffset; // Offset in bytes from start of containing structure.
    UINT uFieldSize;
    UINT uFlags;  // one or more fFI_* flags define below
    TYPE_INFO *pBaseType;

} STRUCT_FIELD_INFO;


#define fFI_PTR     (0x1<<0)    // Field is a pointer
#define fFI_LIST    (0x1<<1)    // Field is a pointer to 1st element of a list
#define fFI_ARRAY   (0x1<<2)    // Field is an array (pointer to array if 
                                // fFI_PTR is set). 
#define fFI_OPAQUE  (0x1<<3)    // Treat object as opaque, of size uObjectSize.
                                // If set then fLIST must not be set.

#define FIELD_IS_EMBEDDED_TYPE(_pFI)  \
				(   !((_pFI)->uFlags & (fFI_PTR|fFI_OPAQUE|fFI_ARRAY)) \
				 && ((_pFI)->pBaseType))
		//
		//	true iff the field is itself a valid type
		//

#define FIELD_IS_PTR_TO_TYPE(_pFI)  \
				(   ((_pFI)->uFlags & fFI_PTR) \
				 && !((_pFI)->uFlags & (fFI_OPAQUE|fFI_ARRAY)) \
				 && ((_pFI)->pBaseType))
		//
		//	true iff the field is pointer to a valid type
		//

#define FIELD_SIZE(type, field)  sizeof(((type *)0)->field)

//
// Information about a global variable.
//
typedef struct
{
    const char *szName; // of variable.
    const char *szShortName;
    TYPE_INFO  *pBaseType;  // could be null (unspecified).
    UINT       uFlags;
    UINT       cbSize;
    UINT_PTR   uAddr;       // Address in debuggee's address space.
    
} GLOBALVAR_INFO;


typedef
UINT_PTR
(*PFN_RESOLVE_ADDRESS)(
				TYPE_INFO *pType
				);

typedef struct
{
	TYPE_INFO	**pTypes;
	GLOBALVAR_INFO *pGlobals;
	PFN_RESOLVE_ADDRESS pfnResolveAddress;

} NAMESPACE;

void
DumpObjects(TYPE_INFO *pType, UINT_PTR uAddr, UINT cObjects, UINT uFlags);

#define fMATCH_SUBSTRING (0x1<<0)
#define fMATCH_PREFIX    (0x1<<1)
#define fMATCH_SUFFIX    (0x1<<2)

void
DumpStructure(
    TYPE_INFO *pType,
    UINT_PTR uAddr,
    char *szFieldSpec,
    UINT uFlags
    );

bool
DumpMemory(
    UINT_PTR uAddr,
    UINT cb,
    UINT uFlags,
    const char *pszDescription
    );

typedef bool (*PFNMATCHINGFUNCTION) (
                    const char *szPattern,
                    const char *szString
                    );

bool
MatchPrefix(const char *szPattern, const char *szString);

bool
MatchSuffix(const char *szPattern, const char *szString);

bool
MatchSubstring(const char *szPattern, const char *szString);

bool
MatchExactly(const char *szPattern, const char *szString);

bool
MatchAlways(const char *szPattern, const char *szString);

typedef ULONG (*PFNNODEFUNC)(
				UINT_PTR uNodeAddr,
				UINT uIndex,
				void *pvContext
				);
//
//	 PFNNODEFUNC is the prototype of the func passed into WalkList
//


UINT
WalkList(
	UINT_PTR uStartAddress,
	UINT uNextOffset,
	UINT uStartIndex,
	UINT uEndIndex,
	void *pvContext,
	PFNNODEFUNC pFunc,
	char *pszDescription
	);
//
// Visit each node in the list in turn,
// reading just the next pointers. It calls pFunc for each list node
// between uStartIndex and uEndIndex. It terminates under the first of
// the following conditions:
// 	* Null pointer
// 	* ReadMemoryError
// 	* Read past uEndIndex
// 	* pFunc returns FALSE
//

void
WalkDLlist(
	UINT_PTR uOffsetHeadList,
	UINT_PTR uOffsetStartLink,	OPTIONAL
	void *pvContext,
	PFNNODEFUNC pFunc,
	UINT	MaxToWalk,
	char *pszDescription
	);

ULONG
NodeFunc_DumpAddress (
	UINT_PTR uNodeAddr,
	UINT uIndex,
	void *pvContext
	);
//
//	This is a sample node function -- simply dumps the specfied address.
//


void
DumpBitFields(
		ULONG  			Flags,
    	BITFIELD_INFO	rgBitFieldInfo[]
		);
// Dump bitfield info.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\ccdefs.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    ccdefs.h

Abstract:

    This file consolidates conditional-compilation defines for ARP1394

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    josephj     03-24-99    created

--*/

#define NT      1
#define NDIS50  1
#define NDIS

#ifndef ARP_WIN98
    #define _PNP_POWER_
#endif // ARP_WIN98

// Define this if you want to use the fake version of NdisClMake/CloseCall
//
// #define ARPDBG_FAKE_CALLS    1

// Define this if you want to use the fake version of NdisCoSendPackets
//
// #define ARPDBG_FAKE_SEND 1


// This gets conditonally defined to conditionally include code (in fake.c) that is
// only used by the various fake versions of APIs.
//
#if (ARPDBG_FAKE_CALLS | ARPDBG_FAKE_SEND)
    #define ARPDBG_FAKE_APIS    1
#endif


#if (DBG)
    // Define this to enable a whole lot of extra checking in the RM api's -- things
    // like debug associations and extra checking while locking/unlocking.
    //
    #define RM_EXTRA_CHECKING 1
    #define FAIL_SET_IOCTL 0

#else // DBG

    #define FAIL_SET_IOCTL 1


#endif  // DBG

#define ARP_DEFERIFINIT 1
#define ARP_ICS_HACK    1
#define TEST_ICS_HACK   0
#define ARP_DO_TIMESTAMPS 0
#define ARP_DO_ALL_TIMESTAMPS 0
#define NOT_TESTED_YET 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\kdext\t.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

	t.c

Abstract:

	Basic functionality tests for the RM APIs

Revision History:

	Who         When        What
	--------    --------    ----------------------------------------------
	josephj     01-13-99    Created

Notes:

--*/

#include "c.h"

#ifdef TESTPROGRAM

enum
{
	LOCKLEVEL_GLOBALS=1,
	LOCKLEVEL_O1,
	LOCKLEVEL_O2
};

typedef struct
{
	RM_OBJECT_HEADER 	Hdr;
	RM_LOCK 			Lock;

	//
	// Resources
	//
	BOOLEAN 			fInited1; // Resource1
	BOOLEAN 			fInited2; // Resource2


	
	//
	// Groups
	//
	RM_GROUP			Group;

} GLOBALS;


//================================ O1 Information ==================================
PRM_OBJECT_HEADER
O1Create(
		PRM_OBJECT_HEADER pParentObject,
		PVOID				pCreateParams,
	 	PRM_STACK_RECORD psr
		);

VOID
O1Delete(
	PRM_OBJECT_HEADER Obj,
	PRM_STACK_RECORD psr
	);



//
// Hash table comparison function.
//
BOOLEAN
O1CompareKey(
	PVOID           pKey,
	PRM_HASH_LINK   pItem
	);


//
// Hash generating function.
//
ULONG
O1Hash(
	PVOID           pKey
	);


typedef struct
{
	RM_OBJECT_HEADER Hdr;
	RM_LOCK Lock;
	UINT	Key;
	BOOLEAN fInited;
} O1;


RM_HASH_INFO
O1_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

	O1CompareKey,	// fnCompare

	// Function to generate a ULONG-sized hash.
	//
	O1Hash		// pfnHash

};

RM_STATIC_OBJECT_INFO
O1_StaticInfo = 
{
	0, // TypeUID
	0, // TypeFlags
	"O1",	// TypeName
	0, // Timeout

	O1Create,
	O1Delete,
	NULL, // Verifier

	0,	 // ResourceTable size
	NULL, // ResourceTable
	&O1_HashInfo, // pHashInfo
};


//================================ O2 Information ==================================
PRM_OBJECT_HEADER
O2Create(
		PRM_OBJECT_HEADER pParentObject,
		PVOID				pCreateParams,
	 	PRM_STACK_RECORD psr
		);

VOID
O2Delete(
	PRM_OBJECT_HEADER Obj,
	PRM_STACK_RECORD psr
	);



//
// Hash table comparison function.
//
BOOLEAN
O2CompareKey(
	PVOID           pKey,
	PRM_HASH_LINK   pItem
	);


//
// Hash generating function.
//
ULONG
O2Hash(
	PVOID           pKey
	);


typedef struct
{
	RM_OBJECT_HEADER Hdr;
	RM_LOCK Lock;
	UINT	Key;
	BOOLEAN fInited;

	RM_TASK O2Task;
} O2;


RM_HASH_INFO
O2_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

	O2CompareKey,	// fnCompare

	// Function to generate a ULONG-sized hash.
	//
	O2Hash		// pfnHash

};

RM_STATIC_OBJECT_INFO
O2_StaticInfo = 
{
	0, // TypeUID
	0, // TypeFlags
	"O2",	// TypeName
	0, // Timeout

	O2Create,
	O2Delete,
	NULL, //verifier

	0,	 // ResourceTable size
	NULL, // ResourceTable
	&O2_HashInfo, // pHashInfo
};

//================================ GLOBALS (ROOT Object) Information =================


//
// List of fixed resources used by ArpGlobals
//
enum
{
	RTYPE_GLOBAL_RESOURCE1,
	RTYPE_GLOBAL_RESOURCE2

}; // ARP_GLOBAL_RESOURCES;

RM_STATUS
testResHandleGlobalResource1(
	PRM_OBJECT_HEADER 				pObj,
	RM_RESOURCE_OPERATION 			Op,
	PVOID 							pvUserParams,
	PRM_STACK_RECORD				psr
);

RM_STATUS
testResHandleGlobalResource2(
	PRM_OBJECT_HEADER 				pObj,
	RM_RESOURCE_OPERATION 			Op,
	PVOID 							pvUserParams,
	PRM_STACK_RECORD				psr
);
	
VOID
testTaskDelete (
	PRM_OBJECT_HEADER pObj,
 	PRM_STACK_RECORD psr
	);

//
// Identifies information pertaining to the use of the above resources.
// Following table MUST be in strict increasing order of the RTYPE_GLOBAL
// enum.
//
RM_RESOURCE_TABLE_ENTRY 
Globals_ResourceTable[] =
{
	{RTYPE_GLOBAL_RESOURCE1, 	testResHandleGlobalResource1},
	{RTYPE_GLOBAL_RESOURCE2, 	testResHandleGlobalResource2}
};

RM_STATIC_OBJECT_INFO
Globals_StaticInfo = 
{
	0, // TypeUID
	0, // TypeFlags
	"Globals",	// TypeName
	0, // Timeout

	NULL, // pfnCreate
	NULL, // pfnDelete
	NULL,	// verifier

	sizeof(Globals_ResourceTable)/sizeof(Globals_ResourceTable[1]),
	Globals_ResourceTable
};

RM_STATIC_OBJECT_INFO
Tasks_StaticInfo = 
{
	0, // TypeUID
	0, // TypeFlags
	"TEST Task",	// TypeName
	0, // Timeout

	NULL, // pfnCreate
	testTaskDelete, // pfnDelete
	NULL,	// LockVerifier

	0,	 // length of resource table
	NULL // Resource Table
};

RM_STATIC_OBJECT_INFO
O2Tasks_StaticInfo = 
{
	0, // TypeUID
	0, // TypeFlags
	"O2 Task",	// TypeName
	0, // Timeout

	NULL, // pfnCreate
	NULL, // pfnDelete NULL because it's contained in O2.
	NULL,	// LockVerifier

	0,	 // length of resource table
	NULL // Resource Table
};

typedef struct
{
	RM_TASK TskHdr;
	int i;

} T1_TASK;

typedef struct
{
	RM_TASK TskHdr;
	int i;

} T2_TASK;

typedef struct
{
	RM_TASK TskHdr;
	int i;

} T3_TASK;

typedef union
{
	RM_TASK TskHdr;
	T1_TASK T1;
	T2_TASK T2;
	T3_TASK T3;

} TESTTASK;

GLOBALS Globals;

RM_STATUS
init_globals(
	PRM_STACK_RECORD psr
	);

VOID
deinit_globals(
	PRM_STACK_RECORD psr
	);


NDIS_STATUS
Task1 (
	IN	struct _RM_TASK	*			pTask,
	IN	RM_TASK_OPERATION			Op,
	IN	UINT_PTR					UserParam,	// Unused
	IN	PRM_STACK_RECORD			pSR
	);

NDIS_STATUS
Task2 (
	IN	struct _RM_TASK	*			pTask,
	IN	RM_TASK_OPERATION			Code,
	IN	UINT_PTR					UserParam,	// Unused
	IN	PRM_STACK_RECORD			pSR
	);

NDIS_STATUS
Task3 (
	IN	struct _RM_TASK	*			pTask,
	IN	RM_TASK_OPERATION			Code,
	IN	UINT_PTR					UserParam,	// Task to pend on.
	IN	PRM_STACK_RECORD			pSR
	);

NDIS_STATUS
TaskO2 (
	IN	struct _RM_TASK	*			pTask,
	IN	RM_TASK_OPERATION			Op,
	IN	UINT_PTR					UserParam,	// Unused
	IN	PRM_STACK_RECORD			pSR
	);

NDIS_STATUS
TaskUnloadO2 (
	IN	struct _RM_TASK	*			pTask,
	IN	RM_TASK_OPERATION			Op,
	IN	UINT_PTR					UserParam,	// Unused
	IN	PRM_STACK_RECORD			pSR
	);

NDIS_STATUS
AllocateTask(
	IN	PRM_OBJECT_HEADER			pParentObject,
	IN	PFN_RM_TASK_HANDLER 		pfnHandler,
	IN	UINT 						Timeout,
	IN	const char * 				szDescription,
	OUT	PRM_TASK 					*ppTask,
	IN	PRM_STACK_RECORD			pSR
	)
{
	TESTTASK *pTTask = ALLOCSTRUCT(TESTTASK);
	NDIS_STATUS Status = NDIS_STATUS_RESOURCES;
		
	*ppTask = NULL;

	if (pTTask != NULL)
	{

		RmInitializeTask(
					&(pTTask->TskHdr),
					pParentObject,
					pfnHandler,
					&Tasks_StaticInfo,
					szDescription,
					Timeout,
					pSR
					);
		*ppTask = &(pTTask->TskHdr);
		Status = NDIS_STATUS_SUCCESS;
	}

	return Status;
}


VOID
FreeTask(
	IN	PRM_TASK					pTask,
	IN	PRM_STACK_RECORD			pSR
	)
{
	FREE(pTask);
}

PRM_OBJECT_HEADER
O1Create(
		PRM_OBJECT_HEADER 	pParentObject,
		PVOID				pCreateParams,
	 	PRM_STACK_RECORD 	psr
		)
{
	O1 * po1 = 	ALLOCSTRUCT(O1);

	if (po1)
	{
		RmInitializeLock(
			&po1->Lock,
			LOCKLEVEL_O1
			);

		RmInitializeHeader(
			pParentObject, // NULL, // pParentObject,
			&po1->Hdr,
			123,
			&po1->Lock,
			&O1_StaticInfo,
			NULL,
			psr
			);

			po1->Key = (UINT) (UINT_PTR) pCreateParams;
	}
	return &po1->Hdr;
}


VOID
O1Delete(
	PRM_OBJECT_HEADER Obj,
	PRM_STACK_RECORD psr
	)
{
	FREE(Obj);
}

PRM_OBJECT_HEADER
O2Create(
		PRM_OBJECT_HEADER 	pParentObject,
		PVOID				pCreateParams,
	 	PRM_STACK_RECORD 	pSR
		)
{
	O2 * po2 = 	ALLOCSTRUCT(O2);

	if (po2)
	{
		RmInitializeLock(
			&po2->Lock,
			LOCKLEVEL_O2
			);

		RmInitializeHeader(
			pParentObject, // NULL, // pParentObject,
			&po2->Hdr,
			234,
			&po2->Lock,
			&O2_StaticInfo,
			NULL,
			pSR
			);

		RmInitializeTask(
					&(po2->O2Task),
					&po2->Hdr,
					TaskO2,
					&O2Tasks_StaticInfo,
					"TaskO2",
					0,
					pSR
					);
		po2->Key = (UINT) (UINT_PTR) pCreateParams;
	}
	return &po2->Hdr;
}


VOID
O2Delete(
	PRM_OBJECT_HEADER Obj,
	PRM_STACK_RECORD psr
	)
{
	FREE(Obj);
}


RM_STATUS
testResHandleGlobalResource1(
	PRM_OBJECT_HEADER 				pObj,
	RM_RESOURCE_OPERATION 			Op,
	PVOID 							pvUserParams,
	PRM_STACK_RECORD				psr
)
{
	NDIS_STATUS 		Status 		= NDIS_STATUS_FAILURE;
	GLOBALS  			*pGlobals 	= CONTAINING_RECORD(pObj, GLOBALS, Hdr);

	ENTER("GlobalResource1", 0xd7c1efbb);

	if (Op == RM_RESOURCE_OP_LOAD)
	{
		TR_INFO(("LOADING RESOUCE1\n"));
		pGlobals->fInited1 = TRUE;
		Status = NDIS_STATUS_SUCCESS;

	}
	else if (Op == RM_RESOURCE_OP_UNLOAD)
	{
		TR_INFO(("UNLOADING RESOUCE1\n"));

		//
		// Were unloading this "resource."
		//

		ASSERTEX(pGlobals->fInited1, pGlobals);
		pGlobals->fInited1 = FALSE;

		// Always return success on unload.
		//
		Status = NDIS_STATUS_SUCCESS;
	}
	else
	{
		// Unexpected op code.
		//
		ASSERTEX(FALSE, pObj);
	}

	EXIT()
	return Status;
}

RM_STATUS
testResHandleGlobalResource2(
	PRM_OBJECT_HEADER 				pObj,
	RM_RESOURCE_OPERATION 			Op,
	PVOID 							pvUserParams,
	PRM_STACK_RECORD				psr
)
{
	NDIS_STATUS 		Status 		= NDIS_STATUS_FAILURE;
	GLOBALS  			*pGlobals 	= CONTAINING_RECORD(pObj, GLOBALS, Hdr);

	ENTER("GlobalResource2", 0xca85474f)

	if (Op == RM_RESOURCE_OP_LOAD)
	{
		TR_INFO(("LOADING RESOUCE2\n"));
		pGlobals->fInited2 = TRUE;
		Status = NDIS_STATUS_SUCCESS;

	}
	else if (Op == RM_RESOURCE_OP_UNLOAD)
	{
		TR_INFO(("UNLOADING RESOUCE2\n"));

		//
		// Were unloading this "resource."
		//

		ASSERTEX(pGlobals->fInited2, pGlobals);
		pGlobals->fInited2 = FALSE;

		// Always return success on unload.
		//
		Status = NDIS_STATUS_SUCCESS;
	}
	else
	{
		// Unexpected op code.
		//
		ASSERTEX(FALSE, pObj);
	}

	EXIT()
	return Status;
}

RM_STATUS
init_globals(
	PRM_STACK_RECORD psr
	)
{
	NDIS_STATUS Status;

	//
	// Initialize the global, statically-allocated object Globals;
	//

	RmInitializeLock(
		&Globals.Lock,
		LOCKLEVEL_GLOBALS
		);

	RmInitializeHeader(
		NULL, // pParentObject,
		&Globals.Hdr,
		001,
		&Globals.Lock,
		&Globals_StaticInfo,
		NULL,
		psr
		);

	//
	// Load resource1
	//
	Status = RmLoadGenericResource(
				&Globals.Hdr,
				RTYPE_GLOBAL_RESOURCE1,
				psr
				);

	if (!FAIL(Status))
	{
		//
		// Load resource1
		//
		Status = RmLoadGenericResource(
					&Globals.Hdr,
					RTYPE_GLOBAL_RESOURCE2,
					psr
					);
	}

	return Status;
}


VOID
deinit_globals(
	PRM_STACK_RECORD psr
	)
{
	RmUnloadGenericResource(
				&Globals.Hdr,
				RTYPE_GLOBAL_RESOURCE1,
				psr
				);

	RmUnloadAllGenericResources(
			&Globals.Hdr,
			psr
			);

	RmDeallocateObject(
			&Globals.Hdr,
			psr
			);
}


//
// Hash comparision function.
//
BOOLEAN
O1CompareKey(
	PVOID           pKey,
	PRM_HASH_LINK   pItem
	)
{
	O1 *pO1 = CONTAINING_RECORD(pItem, O1, Hdr.HashLink);
	
	return *((UINT*)pKey) == pO1->Key;
}


//
// Hash generating function.
//
ULONG
O1Hash(
	PVOID           pKey
	)
{
	return *(UINT*)pKey;
}

//
// Hash comparision function.
//
BOOLEAN
O2CompareKey(
	PVOID           pKey,
	PRM_HASH_LINK   pItem
	)
{
	O2 *pO2 = CONTAINING_RECORD(pItem, O2, Hdr.HashLink);
	
	return *((UINT*)pKey) == pO2->Key;
}


//
// Hash generating function.
//
ULONG
O2Hash(
	PVOID           pKey
	)
{
	return *(UINT*)pKey;
}

VOID
testTaskDelete (
	PRM_OBJECT_HEADER pObj,
 	PRM_STACK_RECORD psr
	)
{
	printf("testTaskDelete: Called to delete obj %p\n", pObj);
}


NDIS_STATUS
Task1(
	IN	struct _RM_TASK	*			pTask,
	IN	RM_TASK_OPERATION			Code,
	IN	UINT_PTR					UserParam,	// Unused
	IN	PRM_STACK_RECORD			pSR
	)
//
// DONE
//
{
	NDIS_STATUS 		Status 	= NDIS_STATUS_FAILURE;
	O1*	po1 	= (O1*) RM_PARENT_OBJECT(pTask);
	ENTER("Task1", 0x4abf3903)

	switch(Code)
	{

		case RM_TASKOP_START:
			printf("Task1: START called\n");
			Status = NDIS_STATUS_SUCCESS;
		break;

		case RM_TASKOP_END:
			printf("Task1: END called\n");
			Status = (NDIS_STATUS) UserParam;
		break;

		default:
		{
			ASSERTEX(!"Unexpected task op", pTask);
		}
		break;

	} // switch (Code)

	RM_ASSERT_NOLOCKS(pSR);
	EXIT()

	return Status;
}


NDIS_STATUS
Task2(
	IN	struct _RM_TASK	*			pTask,
	IN	RM_TASK_OPERATION			Code,
	IN	UINT_PTR					UserParam,	// Unused
	IN	PRM_STACK_RECORD			pSR
	)
//
// DONE
//
{
	NDIS_STATUS 		Status 	= NDIS_STATUS_FAILURE;
	O1*	po1 	= (O1*) RM_PARENT_OBJECT(pTask);
	ENTER("Task2", 0x6e65b76c)

	// Following are the list of pending states for this task.
	//
	enum
	{
		PEND_OnStart
	};

	switch(Code)
	{

		case RM_TASKOP_START:
		{

			printf("Task2: START called\n");
			RmSuspendTask(pTask, PEND_OnStart, pSR);
			RM_ASSERT_NOLOCKS(pSR);
			Status = NDIS_STATUS_PENDING;

		}
		break;

		case  RM_TASKOP_PENDCOMPLETE:
		{

			switch(RM_PEND_CODE(pTask))
			{
				case PEND_OnStart:
				{
		
		
					printf("Task2: PEND_OnStart complete\n");
					Status = (NDIS_STATUS) UserParam;
		
					// Status of the completed operation can't itself be pending!
					//
					ASSERT(Status != NDIS_STATUS_PENDING);
		
				} // end case  PEND_OnStart
				break;
	

				default:
				{
					ASSERTEX(!"Unknown pend op", pTask);
				}
				break;
	

			} // end switch(RM_PEND_CODE(pTask))

		} // case RM_TASKOP_PENDCOMPLETE
		break;

		case RM_TASKOP_END:
		{
			printf("Task2: END called\n");
			Status = (NDIS_STATUS) UserParam;

		}
		break;

		default:
		{
			ASSERTEX(!"Unexpected task op", pTask);
		}
		break;

	} // switch (Code)

	RM_ASSERT_NOLOCKS(pSR);
	EXIT()

	return Status;
}


NDIS_STATUS
Task3(
	IN	struct _RM_TASK	*			pTask,
	IN	RM_TASK_OPERATION			Code,
	IN	UINT_PTR					UserParam,
	IN	PRM_STACK_RECORD			pSR
	)
{
	NDIS_STATUS 		Status 	= NDIS_STATUS_FAILURE;
	O1*	po1 	= (O1*) RM_PARENT_OBJECT(pTask);
    T3_TASK *pT3Task = (T3_TASK *) pTask;
	ENTER("Task3", 0x7e89bf6d)

	// Following are the list of pending states for this task.
	//
	enum
	{
		PEND_OnStart
	};

    printf ("pT3Task.i = %d\n", pT3Task->i);

	switch(Code)
	{

		case RM_TASKOP_START:
		{
	        PRM_TASK 	pOtherTask = (PRM_TASK) UserParam;

			printf("Task3: START called\n");
            RmPendTaskOnOtherTask(pTask, PEND_OnStart, pOtherTask, pSR);
			RM_ASSERT_NOLOCKS(pSR);
			Status = NDIS_STATUS_PENDING;

		}
		break;

		case  RM_TASKOP_PENDCOMPLETE:
		{

			switch(RM_PEND_CODE(pTask))
			{
				case PEND_OnStart:
				{
		
		
					printf("Task3: PEND_OnStart complete\n");
					Status = (NDIS_STATUS) UserParam;
		
					// Status of the completed operation can't itself be pending!
					//
					ASSERT(Status != NDIS_STATUS_PENDING);
		
				} // end case  PEND_OnStart
				break;
	

				default:
				{
					ASSERTEX(!"Unknown pend op", pTask);
				}
				break;
	

			} // end switch(RM_PEND_CODE(pTask))

		} // case RM_TASKOP_PENDCOMPLETE
		break;

		case RM_TASKOP_END:
		{
			printf("Task3: END called\n");
			Status = (NDIS_STATUS) UserParam;

		}
		break;

		default:
		{
			ASSERTEX(!"Unexpected task op", pTask);
		}
		break;

	} // switch (Code)

	RM_ASSERT_NOLOCKS(pSR);
	EXIT()

	return Status;
}

NDIS_STATUS
TaskO2(
	IN	struct _RM_TASK	*			pTask,
	IN	RM_TASK_OPERATION			Code,
	IN	UINT_PTR					UserParam,	// Unused
	IN	PRM_STACK_RECORD			pSR
	)
//
// DONE
//
{
	NDIS_STATUS 		Status 	= NDIS_STATUS_FAILURE;
	O2*	po2 	= (O2*) RM_PARENT_OBJECT(pTask);
	ENTER("TaskO2", 0xe10fbc33)

	// Following are the list of pending states for this task.
	//
	enum
	{
		PEND_OnStart
	};

	ASSERT(po2 == CONTAINING_RECORD(pTask, O2, O2Task));

	switch(Code)
	{

		case RM_TASKOP_START:
		{

			printf("TaskO2: START called\n");
			RmSuspendTask(pTask, PEND_OnStart, pSR);
			RM_ASSERT_NOLOCKS(pSR);
			Status = NDIS_STATUS_PENDING;

		}
		break;

		case  RM_TASKOP_PENDCOMPLETE:
		{

			switch(RM_PEND_CODE(pTask))
			{
				case PEND_OnStart:
				{
		
		
					printf("TaskO2: PEND_OnStart complete\n");
					Status = (NDIS_STATUS) UserParam;
		
					// Status of the completed operation can't itself be pending!
					//
					ASSERT(Status != NDIS_STATUS_PENDING);
		
				} // end case  PEND_OnStart
				break;
	

				default:
				{
					ASSERTEX(!"Unknown pend op", pTask);
				}
				break;
	

			} // end switch(RM_PEND_CODE(pTask))

		} // case RM_TASKOP_PENDCOMPLETE
		break;

		case RM_TASKOP_END:
		{
			printf("TaskO2: END called\n");
			Status = (NDIS_STATUS) UserParam;

		}
		break;

		default:
		{
			ASSERTEX(!"Unexpected task op", pTask);
		}
		break;

	} // switch (Code)

	RM_ASSERT_NOLOCKS(pSR);
	EXIT()

	return Status;
}

NDIS_STATUS
TaskUnloadO2(
	IN	struct _RM_TASK	*			pTask,
	IN	RM_TASK_OPERATION			Code,
	IN	UINT_PTR					UserParam,	// Unused
	IN	PRM_STACK_RECORD			pSR
	)
//
// DONE
//
{
	NDIS_STATUS 		Status 	= NDIS_STATUS_FAILURE;
	O2*	po2 	= (O2*) RM_PARENT_OBJECT(pTask);
	ENTER("TaskUnloadO2", 0xa15314da)

	// Following are the list of pending states for this task.
	//
	enum
	{
		PEND_OnStart
	};

	switch(Code)
	{

		case RM_TASKOP_START:
		{

			printf("TaskTaskO2: START called\n");
            RmPendTaskOnOtherTask(pTask, PEND_OnStart, &po2->O2Task, pSR);
			RmResumeTask(&po2->O2Task, 0, pSR);
			RM_ASSERT_NOLOCKS(pSR);
			Status = NDIS_STATUS_PENDING;

		}
		break;

		case  RM_TASKOP_PENDCOMPLETE:
		{

			switch(RM_PEND_CODE(pTask))
			{
				case PEND_OnStart:
				{
		
		
					printf("TaskUnloadO2: PEND_OnStart complete\n");
					Status = (NDIS_STATUS) UserParam;
		
					// Status of the completed operation can't itself be pending!
					//
					ASSERT(Status != NDIS_STATUS_PENDING);
		
				} // end case  PEND_OnStart
				break;
	

				default:
				{
					ASSERTEX(!"Unknown pend op", pTask);
				}
				break;
	

			} // end switch(RM_PEND_CODE(pTask))

		} // case RM_TASKOP_PENDCOMPLETE
		break;

		case RM_TASKOP_END:
		{
			printf("TaskUnloadO2: END called\n");

	 		// Actually free object po2 in group.
			//
			RmFreeObjectInGroup(
						&Globals.Group,
						&po2->Hdr,
						NULL, // pTask
						pSR
						);

			Status = (NDIS_STATUS) UserParam;

		}
		break;

		default:
		{
			ASSERTEX(!"Unexpected task op", pTask);
		}
		break;

	} // switch (Code)

	RM_ASSERT_NOLOCKS(pSR);
	EXIT()

	return Status;
}


struct
{
	BOOLEAN fInited;
	PRM_GROUP pGroup;

	// Following is a dummy stack record. It needs to be initialized before
	// it can be used.
	//
	struct
	{
		RM_LOCKING_INFO rm_lock_array[4];
		RM_STACK_RECORD sr;

		RM_LOCK	Lock;
	} SrInfo;

} gDummys;


void init_dummy_vars(void)
{
	RM_STATUS Status;
	O2 * po2 = NULL;
	O2 * po2A = NULL;
	PRM_TASK pTask3a=NULL;
	PRM_TASK pTask3b=NULL;
	RM_DECLARE_STACK_RECORD(sr)

	printf("\nEnter init_dummy_vars\n\n");;

	// Must be done before any RM apis are used.
	//
	RmInitializeRm();

	do
	{
		UINT Key = 1234;
		Status = init_globals(&sr);
		
		if (FAIL(Status)) break;

		gDummys.fInited = TRUE;

		// Initialize the dummy stack info and the lock for it to use.
		//
		{
			// True Init
			//
			gDummys.SrInfo.sr.TmpRefs 				= 0;
			gDummys.SrInfo.sr.LockInfo.CurrentLevel = 0;
			gDummys.SrInfo.sr.LockInfo.pFirst 		= rm_lock_array;
			gDummys.SrInfo.sr.LockInfo.pNextFree 	= rm_lock_array;
			gDummys.SrInfo.sr.LockInfo.pLast 		= rm_lock_array
								+ sizeof(rm_lock_array)/sizeof(*rm_lock_array) - 1;
			RM_INIT_DBG_STACK_RECORD(gDummys.SrInfo.sr, 0);

			// Add some bogus temp refs.
			//
			gDummys.SrInfo.sr.TmpRefs 				= 0x123;

			// Now initialize the lock...
			RmInitializeLock(
				&gDummys.SrInfo.Lock,
				0x345					// locklevel.
				);
			
			// And lock
			// WARNING: we use the private function rmLock defined internal
			// to rm.c.
			//
			{
				VOID
				rmLock(
					PRM_LOCK 				pLock,
				#if RM_EXTRA_CHECKING
					UINT					uLocID,
					PFNLOCKVERIFIER 		pfnVerifier,
					PVOID 	 				pVerifierContext,
				#endif //RM_EXTRA_CHECKING
					PRM_STACK_RECORD 		pSR
					);

				rmLock(
					&gDummys.SrInfo.Lock,
				#if RM_EXTRA_CHECKING
					0,			// uLocID,
					NULL, 		// pfnVerifier,
					NULL,		// pVerifierContext,
				#endif //RM_EXTRA_CHECKING
					&gDummys.SrInfo.sr
					);
			}
		}

		RmInitializeGroup(
					&Globals.Hdr,
					&O2_StaticInfo,
					&Globals.Group,
					"O1 Group",
					&sr
					);

		printf("Called RmInitializeGroup\n");

		Status = RM_CREATE_AND_LOCK_OBJECT_IN_GROUP(
						&Globals.Group,
						&Key,						// Key
						(PVOID)Key,						// CreateParams
						(RM_OBJECT_HEADER**) &po2,
						NULL,	// pfCreated
						&sr);

		if (FAIL(Status))
		{
			printf("Create object in group failed!\n");
			po2 = NULL;
		}
		else
		{
			UINT KeyA = 2345;
			printf("Create 1st object in group succeeded!\n");

			UNLOCKOBJ(po2, &sr);

			// Now start the O2Task, which will pend ...
			//
			Status = RmStartTask(
						&po2->O2Task,
						0, // UserParam (unused)
						&sr
						);
			ASSERT(PEND(Status));

			RmTmpDereferenceObject(&po2->Hdr, &sr); // Added in lookup.


			Status = RM_CREATE_AND_LOCK_OBJECT_IN_GROUP(
							&Globals.Group,
							&KeyA,						// Key
							(PVOID)KeyA,						// CreateParams
							(RM_OBJECT_HEADER**) &po2A,
							NULL,	// pfCreated
							&sr);

			if (FAIL(Status))
			{
				printf("Create 2nd object in group failed!\n");
				po2A = NULL;
			}
			else
			{
				printf("Create 2nd object in group succeeded!\n");

				UNLOCKOBJ(po2A, &sr);

				// Now start the O2Task, which will pend ...
				//
				Status = RmStartTask(
							&po2A->O2Task,
							0, // UserParam (unused)
							&sr
							);
				ASSERT(PEND(Status));

				RmTmpDereferenceObject(&po2A->Hdr, &sr);
			}

		}

		// 
		// Now let's start a couple of T3 tasks, to both pend on 
		// &po2->O2Task.
		//
		if (po2 != NULL)
		{

			Status = AllocateTask(
						&po2->Hdr, 			// pParentObject
						Task3,				// pfnHandler
						0,					// Timeout
						"Task3a",
						&pTask3a,
						&sr
						);
			if (FAIL(Status))
			{
				pTask3a = NULL;
			}
			else
			{
				Status = RmStartTask(
							pTask3a,
							(UINT_PTR) &po2->O2Task, // UserParam 
							&sr
							);
				ASSERT(Status == NDIS_STATUS_PENDING);
			}

			Status = AllocateTask(
						&po2->Hdr, 			// pParentObject
						Task3,				// pfnHandler
						0,					// Timeout
						"Task3b",
						&pTask3b,
						&sr
						);
			if (FAIL(Status))
			{
				pTask3b = NULL;
			}
			else
			{

				Status = RmStartTask(
							pTask3b,
							(UINT_PTR) &po2->O2Task, // UserParam 
							&sr
							);
				ASSERT(Status == NDIS_STATUS_PENDING);
			}

			// Add some log entries.
			//
			RmDbgLogToObject(
					&po2->Hdr,
					NULL,		// szPrefix
					"How now brown cow: pO2=%p, szDesc=%s\n",
					(UINT_PTR) po2,
					(UINT_PTR) po2->Hdr.szDescription,
					0,
					0,
					NULL,
					NULL
					);



			RM_ASSERT_NOLOCKS(&sr);

		}


		printf(
			"DUMMY: pGroup=0x%p; po2=0x%p; po2A=0x%p\n",
			&Globals.Group,
			po2,
			po2A
			);
		if (po2 && po2A)
		{
			printf(
				"DUMMY: po2->pTask=0x%p; po2A->pTask=0x%p\n",
				&po2->O2Task,
				&po2A->O2Task
				);
			printf(
				"DUMMY: pTask3a=0x%p; pTask3b=0x%p; pSR=0x%p\n",
				pTask3a,
				pTask3b,
				&gDummys.SrInfo.sr
				);
		}

		gDummys.pGroup = &Globals.Group;


	} while(FALSE);

	RM_ASSERT_CLEAR(&sr);

	printf("\nLeaving init_dummy_vars\n\n");;
}


void delete_dummy_vars(void)
{
	RM_STATUS Status;
	O1 * po1;
	RM_DECLARE_STACK_RECORD(sr)

	printf("\nEnter delete_dummy_vars\n\n");;

	do
	{
		if (!gDummys.fInited) break;

		RmUnloadAllObjectsInGroup(
					gDummys.pGroup,
					AllocateTask,
					TaskUnloadO2,
					NULL,
					NULL, // pTask
					0, 	  // uTaskPendCode
					&sr
					);
		RmDeinitializeGroup(
			gDummys.pGroup,
			&sr
			);

		deinit_globals(&sr);

	} while(FALSE);

	// Must be done after all RM apis are complete.
	//
	RmDeinitializeRm();

	RM_ASSERT_CLEAR(&sr);

	printf("\nLeaving  delete_dummy_vars\n");
}

VOID 
NdisInitializeWorkItem(
       IN PNDIS_WORK_ITEM pWorkItem,
       IN NDIS_PROC Routine,
       IN PVOID Context
       )
{
	ZeroMemory(pWorkItem, sizeof(*pWorkItem));
	pWorkItem->Context = Context;
	pWorkItem->Routine = Routine;
}


VOID
ApcProc_ScheduleWorkItem(
    ULONG_PTR Param
        )
{
	PNDIS_WORK_ITEM pWI = (PNDIS_WORK_ITEM) Param;

	pWI->Routine(pWI, pWI->Context);
}


NDIS_STATUS
NdisScheduleWorkItem(
       IN PNDIS_WORK_ITEM WorkItem
       )
{
	DWORD dwRet = QueueUserAPC(
						ApcProc_ScheduleWorkItem,
						GetCurrentThread(),
						(UINT_PTR) WorkItem
						);
	return dwRet ? NDIS_STATUS_SUCCESS: NDIS_STATUS_FAILURE;
}


VOID
NdisInitializeTimer(
	IN OUT PNDIS_TIMER			pTimer,
	IN	PNDIS_TIMER_FUNCTION	TimerFunction,
	IN	PVOID					FunctionContext
	)
{
	ZeroMemory(pTimer, sizeof(*pTimer));
	pTimer->hTimer = CreateWaitableTimer(
							NULL, 	// lpTimerAttributes
  							TRUE, 	// bManualReset
  							NULL	//lpTimerName
							);
	ASSERT(pTimer->hTimer != NULL);
	pTimer->pfnHandler = TimerFunction;
	pTimer->Context = FunctionContext;
}


VOID CALLBACK
TimerAPCProc_NdisSetTimer(
  LPVOID lpArgToCompletionRoutine,   // data value
  DWORD dwTimerLowValue,             // timer low value
  DWORD dwTimerHighValue            // timer high value
)
{
	PNDIS_TIMER				pTimer = (PNDIS_TIMER) lpArgToCompletionRoutine;

	pTimer->pfnHandler(
				NULL, 				// SystemSpecific1
				pTimer->Context,		// FunctionContext
				NULL, 				// SystemSpecific2
				NULL 				// SystemSpecific3
				);
}


VOID
NdisSetTimer(
	IN	PNDIS_TIMER				pTimer,
	IN	UINT					MillisecondsToDelay
	)
{
	BOOL fRet;
  	LARGE_INTEGER DueTime;

  	DueTime.QuadPart = Int32x32To64(
						(INT) MillisecondsToDelay,
						-10000		//	convert to 100-nanosec, specify relative time
						);

	fRet = SetWaitableTimer(
  				pTimer->hTimer,            	// handle to a timer object
  				&DueTime,          			// when timer will become signaled
  				0,                          // periodic timer interval
				TimerAPCProc_NdisSetTimer, 	// completion routine
  				pTimer,        				// data for completion routine
  				FALSE                       // flag for resume state
  				);
	
	ASSERT(fRet);
}

VOID
NdisCancelTimer(
	IN PNDIS_TIMER Timer,
	OUT PBOOLEAN TimerCancelled
	)
{
	ASSERT(FALSE);
}

#endif // TESTPROGRAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\arp.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    arp.c

Abstract:

    ARP1394 ARP request/response handling code.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     03-28-99    Created

Notes:

--*/
#include <precomp.h>

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_ARP

// #define ARP_DEFAULT_MAXREC 0xD
#define ARP_DEFAULT_MAXREC 0x8


#define LOGSTATS_SuccessfulArpQueries(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.arpcache.SuccessfulQueries))
#define LOGSTATS_FailedArpQueried(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.arpcache.FailedQueries))
#define LOGSTATS_TotalQueries(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.arpcache.TotalQueries))
#define LOGSTATS_TotalArpResponses(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.arpcache.TotalResponses))

//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================
  
NDIS_STATUS
arpSendArpRequest(
    PARPCB_REMOTE_IP pRemoteIp,
    PRM_STACK_RECORD pSR
    );

VOID
arpProcessArpRequest(
    PARP1394_INTERFACE          pIF,    // NOLOCKIN NOLOCKOUT
    PIP1394_ARP_PKT_INFO    pPktInfo,
    PRM_STACK_RECORD            pSR
    );

VOID
arpProcessArpResponse(
    PARP1394_INTERFACE          pIF,    // NOLOCKIN NOLOCKOUT
    PIP1394_ARP_PKT_INFO    pPktInfo,
    PRM_STACK_RECORD            pSR
    );

VOID
arpTryAbortResolutionTask(
    PARPCB_REMOTE_IP pRemoteIp,
    PRM_STACK_RECORD pSR
    );

NDIS_STATUS
arpParseArpPkt(
    IN   PIP1394_ARP_PKT  pArpPkt,
    IN   UINT                       cbBufferSize,
    OUT  PIP1394_ARP_PKT_INFO   pPktInfo
    )
/*++
Routine Description:

    Parse the contents of IP/1394 ARP packet data starting at
    pArpPkt. Place the results into pPktInfo.

Arguments:

    pArpPkt     - Contains the unaligned contents of an ip/1394 ARP Pkt.
    pPktInfo    - Unitialized structure to be filled with the parsed contents of the
                  pkt.

Return Value:

    NDIS_STATUS_FAILURE if the parse failed (typically because of invalid pkt
                        contents.)
    NDIS_STATUS_SUCCESS on successful parsing.
    
--*/
{
    ENTER("arpParseArpPkt", 0x20098dc0)
    NDIS_STATUS                 Status;
    DBGSTMT(CHAR *szError   = "General failure";)

    Status  = NDIS_STATUS_FAILURE;

    do
    {
        UINT SenderMaxRec;
        UINT OpCode;

        // Verify length.
        //
        if (cbBufferSize < sizeof(*pArpPkt))
        {
            DBGSTMT(szError = "pkt size too small";)
            break;
        }

        // Verify constant fields.
        //

    #if 0 // Reserved is no "NodeId, which contains the nodeid of the sending
          // node, if known (0 otherwise).
        if (pArpPkt->header.Reserved != 0)
        {
            DBGSTMT(szError = "header.Reserved!=0";)
            break;
        }
    #endif // 0

        if (N2H_USHORT(pArpPkt->header.EtherType) != NIC1394_ETHERTYPE_ARP)
        {
            DBGSTMT(szError = "header.EtherType!=ARP";)
            break;
        }

        if (N2H_USHORT(pArpPkt->hardware_type) != IP1394_HARDWARE_TYPE)
        {
            DBGSTMT(szError = "Invalid hardware_type";)
            break;
        }

        if (N2H_USHORT(pArpPkt->protocol_type) != IP1394_PROTOCOL_TYPE)
        {
            DBGSTMT(szError = "Invalid protocol_type";)
            break;
        }

        if (pArpPkt->hw_addr_len != IP1394_HW_ADDR_LEN)
        {
            DBGSTMT(szError = "Invalid hw_addr_len";)
            break;
        }


        if (pArpPkt->IP_addr_len != sizeof(ULONG))
        {
            DBGSTMT(szError = "Invalid IP_addr_len";)
            break;
        }


        // Opcode
        //
        {
            OpCode = N2H_USHORT(pArpPkt->opcode);
    
            if (    OpCode != IP1394_ARP_REQUEST
                &&  OpCode != IP1394_ARP_RESPONSE)
            {
                DBGSTMT(szError = "Invalid opcode";)
                break;
            }
        }


        // Max send block size...
        //
        {
            UINT maxrec =  pArpPkt->sender_maxrec;

            if (IP1394_IS_VALID_MAXREC(maxrec))
            {
                SenderMaxRec = maxrec;
            }
            else
            {
                DBGSTMT(szError = "Invalid sender_maxrec";)
                break;
            }
        }

        //
        // Pkt appears valid, let's fill out the parsed information....
        //
    
        ARP_ZEROSTRUCT(pPktInfo);

        pPktInfo->OpCode            =  OpCode;
        pPktInfo->SenderMaxRec  =  SenderMaxRec;
    
        // Speed code...
        //
        {
            UINT SenderMaxSpeedCode;

            //
            // We rely on the fact that the RFC speed code constants
            // (IP1394_SSPD_*) are identical to the corresponding
            // constants defined in 1394.h (SCODE_*). Let's ensure this...
            //

            #if (IP1394_SSPD_S100 != SCODE_100_RATE)
                #error "RFC Speed code out of sync with 1394.h"
            #endif
    
            #if (IP1394_SSPD_S200 != SCODE_200_RATE)
                #error "RFC Speed code out of sync with 1394.h"
            #endif
    
            #if (IP1394_SSPD_S400 != SCODE_400_RATE)
                #error "RFC Speed code out of sync with 1394.h"
            #endif
    
            #if (IP1394_SSPD_S800 != SCODE_800_RATE)
                #error "RFC Speed code out of sync with 1394.h"
            #endif
    
            #if (IP1394_SSPD_S1600 != SCODE_1600_RATE)
                #error "RFC Speed code out of sync with 1394.h"
            #endif
    
            #if (IP1394_SSPD_S3200 != SCODE_3200_RATE)
                #error "RFC Speed code out of sync with 1394.h"
            #endif
    
            SenderMaxSpeedCode = pArpPkt->sspd;

            if (SenderMaxSpeedCode >  SCODE_3200_RATE)
            {
                //
                // This is either a bad value, or a rate higher than we know about.
                // We can't distinguish between the two, so we just set the speed to
                // the highest we know about.
                // TODO: 3/28/99 JosephJ not sure if this is the correct
                // behaviour -- maybe we should fail -- I'll be asking the
                // working group to rule on this shortly...
                //
                SenderMaxSpeedCode = SCODE_3200_RATE;
            }

            pPktInfo->SenderMaxSpeedCode = SenderMaxSpeedCode;
        }


        // Unique ID -- we also need to swap DWORDS to convert from network byte
        // order.
        //
        {
            PUINT puSrc   = (PUINT) & (pArpPkt->sender_unique_ID);
            PUINT puDest  = (PUINT) & (pPktInfo->SenderHwAddr.UniqueID);
            // pPktInfo->SenderHwAddr.UniqueID = pArpPkt->sender_unique_ID;
            puDest[0] = puSrc[1];
            puDest[1] = puSrc[0];
        }

        pPktInfo->SenderHwAddr.Off_Low  =H2N_ULONG(pArpPkt->sender_unicast_FIFO_lo);
        pPktInfo->SenderHwAddr.Off_High =H2N_USHORT(pArpPkt->sender_unicast_FIFO_hi);

        // These remain network byte order...
        //
        pPktInfo->SenderIpAddress       = (IP_ADDRESS) pArpPkt->sender_IP_address;
        pPktInfo->TargetIpAddress       = (IP_ADDRESS) pArpPkt->target_IP_address;

        // Extract the Src Node Address
        //
        {
            PNDIS1394_UNFRAGMENTED_HEADER pHeader = (PNDIS1394_UNFRAGMENTED_HEADER)&pArpPkt->header;

            if (pHeader->u1.fHeaderHasSourceAddress == TRUE)
            {
                pPktInfo->SourceNodeAdddress = pHeader->u1.SourceAddress;
                pPktInfo->fPktHasNodeAddress = TRUE;
            }

        }
        Status = NDIS_STATUS_SUCCESS;
        

    } while (FALSE);

    if (FAIL(Status))
    {
        TR_INFO(("Bad arp pkt data at 0x%p (%s)\n",  pArpPkt, szError));
    }
    else
    {
        TR_INFO(("Received ARP PKT. UID=0x%I64x FIFO=0x%04lx:0x%08lx OP=%lu SIP=0x%04lx TIP=0x%04lx.\n",
                pPktInfo->SenderHwAddr.UniqueID,
                pPktInfo->SenderHwAddr.Off_High,
                pPktInfo->SenderHwAddr.Off_Low,
                pPktInfo->OpCode,
                pPktInfo->SenderIpAddress,
                pPktInfo->TargetIpAddress
                ));

    }

    EXIT()

    return Status;
}


VOID
arpPrepareArpPkt(
    IN      PIP1394_ARP_PKT_INFO    pPktInfo,
    // IN       UINT                        SenderMaxRec,
    OUT     PIP1394_ARP_PKT   pArpPkt
    )
/*++

Routine Description:

    Use information in pArpPktInfo to prepare an arp packet starting at
    pvArpPkt.

Arguments:

    pPktInfo        -   Parsed version of the arp request/response packet.
    // SenderMaxRec -   max_rec value of the local host
    pArpPkt         -   unitialized memory in which to store the packet contents.
                        This memory must have a min size of sizeof(*pArpPkt).
--*/
{
    // UINT SenderMaxRec;
    UINT OpCode;

    ARP_ZEROSTRUCT(pArpPkt);

    pArpPkt->header.EtherType       = H2N_USHORT(NIC1394_ETHERTYPE_ARP);
    pArpPkt->hardware_type          = H2N_USHORT(IP1394_HARDWARE_TYPE);
    pArpPkt->protocol_type          = H2N_USHORT(IP1394_PROTOCOL_TYPE);
    pArpPkt->hw_addr_len            = (UCHAR) IP1394_HW_ADDR_LEN;
    pArpPkt->IP_addr_len            = (UCHAR) sizeof(ULONG);
    pArpPkt->opcode                 = H2N_USHORT(pPktInfo->OpCode);
    pArpPkt->sender_maxrec          = (UCHAR) pPktInfo->SenderMaxRec;

    //
    // We rely on the fact that the RFC speed code constants
    // (IP1394_SSPD_*) are identical to the corresponding
    // constants defined in 1394.h (SCODE_*). We have a bunch of compiler-time
    // checks to ensure this (see  arpParseArpPkt(...)).
    // 
    pArpPkt->sspd                   =  (UCHAR) pPktInfo->SenderMaxSpeedCode;

    // Unique ID -- we also need to swap DWORDS to convert to network byte order.
    //
    {
        PUINT puSrc   = (PUINT) & (pPktInfo->SenderHwAddr.UniqueID);
        PUINT puDest  = (PUINT) & (pArpPkt->sender_unique_ID);
        // pArpPkt->sender_unique_ID        =  pPktInfo->SenderHwAddr.UniqueID;
        puDest[0] = puSrc[1];
        puDest[1] = puSrc[0];
    }

    pArpPkt->sender_unicast_FIFO_lo = N2H_ULONG(pPktInfo->SenderHwAddr.Off_Low);
    pArpPkt->sender_unicast_FIFO_hi = N2H_USHORT(pPktInfo->SenderHwAddr.Off_High);

    // These are already in network byte order...
    //
    pArpPkt->sender_IP_address      =   (ULONG) pPktInfo->SenderIpAddress;
    pArpPkt->target_IP_address      =   (ULONG) pPktInfo->TargetIpAddress;

}

NDIS_STATUS
arpPrepareArpResponse(
    IN      PARP1394_INTERFACE          pIF,            // NOLOCKIN NOLOCKOUT
    IN      PIP1394_ARP_PKT_INFO    pArpRequest,
    OUT     PIP1394_ARP_PKT_INFO    pArpResponse,
    IN      PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    If it makes sense to do so, prepare (in pArpResponse) an arp response to
    the arp request in pArpRequest.

Arguments:

    pIF             -   Interface control block.
    pArpRequest     -   Parsed version of the ARP request packet.
    pArpResponse    -   Uninitialized memory to hold the parsed version of the
                        ARP response packet (if there is a response).

Return Value:

    NDIS_STATUS_SUCCESS if the response was filled out.
    Some NDIS error code otherwise.

--*/
{
    ENTER("arpPrepareArpResponse", 0x0d7e0e60)
    NDIS_STATUS         Status;
    PARPCB_LOCAL_IP     pLocalIp;

    Status      = NDIS_STATUS_FAILURE;
    pLocalIp    = NULL;

    RM_ASSERT_OBJUNLOCKED(&pIF->Hdr, pSR);

    do
    {
        IP_ADDRESS  TargetIpAddress =  pArpRequest->TargetIpAddress;

        // Lookup local IP
        //
        Status =  RM_LOOKUP_AND_LOCK_OBJECT_IN_GROUP(
                        &pIF->LocalIpGroup,
                        (PVOID) ULongToPtr (TargetIpAddress),
                        (RM_OBJECT_HEADER**) &pLocalIp,
                        pSR
                        );
    
        if (FAIL(Status))
        {
            pLocalIp = NULL;
            break;
        }
        
        Status = NDIS_STATUS_FAILURE;

        RM_DBG_ASSERT_LOCKED(&pLocalIp->Hdr, pSR);
        ASSERT(TargetIpAddress == pLocalIp->IpAddress);
    
        if (ARP_LOCAL_IP_IS_UNLOADING(pLocalIp)) break;

        //
        // If the local IP is non-unicast, don't respond!
        //
        if (pLocalIp->IpAddressType != LLIP_ADDR_LOCAL)
        {
            TR_WARN(("Ignoring arp request for non-unicast address 0x%08lx.\n",
                TargetIpAddress));
            break;
        }

        //
        // We do serve the target IP address. Let's fill out pArpResponse...
        //

        ARP_ZEROSTRUCT(pArpResponse);
        pArpResponse->OpCode            = IP1394_ARP_RESPONSE;
        pArpResponse->SenderIpAddress   = TargetIpAddress;

        // This field is unused in the response, but we fill it anyway..
        // 11/19/1999 From Kaz Honda of Sony: we should fill it with destination
        // IP address (i.e. the ip address of the sender of the arp request).
        // because that is analogous to what ethernet arp does. Note that
        // the ip/1394 rfc says that the field should be ignored, but we do
        // this anyway.
        //
        // pArpResponse->TargetIpAddress    = TargetIpAddress;
        pArpResponse->TargetIpAddress   =  pArpRequest->SenderIpAddress;

        // Fill out adapter info..
        //
        {
            PARP1394_ADAPTER pAdapter =  (PARP1394_ADAPTER) RM_PARENT_OBJECT(pIF);
            pArpResponse->SenderHwAddr.UniqueID  = pAdapter->info.LocalUniqueID;
            pArpResponse->SenderHwAddr.Off_Low   = pIF->recvinfo.offset.Off_Low;
            pArpResponse->SenderHwAddr.Off_High  = pIF->recvinfo.offset.Off_High;
            pArpResponse->SenderMaxRec= pAdapter->info.MaxRec;
            pArpResponse->SenderMaxSpeedCode= pAdapter->info.MaxSpeedCode;
        }

        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);
    
    if (pLocalIp != NULL)
    {
        UNLOCKOBJ(pLocalIp, pSR);
        RmTmpDereferenceObject(&pLocalIp->Hdr, pSR);
    }

    RM_ASSERT_OBJUNLOCKED(&pIF->Hdr, pSR);

    EXIT()
    return Status;
}


NDIS_STATUS
arpTaskResolveIpAddress(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
{
    NDIS_STATUS         Status;
    PARPCB_REMOTE_IP    pRemoteIp;
    PTASK_RESOLVE_IP_ADDRESS pResolutionTask;
    enum
    {
        PEND_ResponseTimeout
    };
    ENTER("TaskResolveIpAddress", 0x3dd4b434)

    Status          = NDIS_STATUS_FAILURE;
    pRemoteIp       = (PARPCB_REMOTE_IP) RM_PARENT_OBJECT(pTask);
    pResolutionTask = (PTASK_RESOLVE_IP_ADDRESS) pTask;

    switch(Code)
    {
        case RM_TASKOP_START:
        {
            DBGMARK(0x7de307cc);
            //
            // There should NOT be another resolution task running
            // on pRemoteIp. Why? Because a resolution task is ONLY
            // started in the context of a send-pkts task, and there can be
            // ONLY one active send-pkts task on pRemoteIp at any one time.
            //

            LOCKOBJ(pRemoteIp, pSR);
            if (pRemoteIp->pResolutionTask != NULL)
            {
                ASSERT(!"pRemoteIp->pResolutionTask != NULL");
                UNLOCKOBJ(pRemoteIp, pSR);
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            //
            // Make ourselves the official resolution task.
            //
            // Although it's tempting to put pTask as entity1 and
            // pTask->Hdr.szDescption as entity2 below, we specify NULL for both so
            // that we can be sure that ONLY one resolution task can be active at any
            // one time. TODO: modify addassoc semantics to get both advantages.
            //
            DBG_ADDASSOC(
                &pRemoteIp->Hdr,
                NULL,                           // Entity1
                NULL,                           // Entity2
                ARPASSOC_RESOLUTION_IF_TASK,
                "   Resolution task\n",
                pSR
                );
            pRemoteIp->pResolutionTask = pTask;
            pResolutionTask->RetriesLeft = 3;

            // Now we do a fake suspend/resume so we move on to the next stage.
            //
            RmSuspendTask(pTask, PEND_ResponseTimeout, pSR);
            UNLOCKOBJ(pRemoteIp, pSR);
            RmResumeTask(pTask, NDIS_STATUS_SUCCESS, pSR);

            Status = NDIS_STATUS_PENDING;
        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            switch(RM_PEND_CODE(pTask))
            {
                case PEND_ResponseTimeout:
                {
                    DBGMARK(0x3b5562e6);
                    LOCKOBJ(pRemoteIp, pSR);

                    //
                    // Let's see if the address is resolved and/or we're
                    // to abort the resolution task because perhaps pRemoteIp
                    // is going away.
                    //

                    if (pRemoteIp->pUnloadTask != NULL)
                    {
                        OBJLOG0(
                            pRemoteIp,
                            "Aborting address resolution because we're unloading.\n"
                            );
                        Status = NDIS_STATUS_FAILURE;
                        UNLOCKOBJ(pRemoteIp, pSR);
                        break;
                    }
                    if (pRemoteIp->pDest != NULL)
                    {
                        LOGSTATS_SuccessfulArpQueries(IF_FROM_REMOTEIP(pRemoteIp));
                        OBJLOG1(
                            pRemoteIp,
                            "Resolved Ip Address; pDest = 0x%p\n",
                            pRemoteIp->pDest
                            );
                      ASSERT(
                      CHECK_REMOTEIP_RESOLVE_STATE(pRemoteIp, ARPREMOTEIP_RESOLVED)
                      );
                      Status = NDIS_STATUS_SUCCESS;
                      UNLOCKOBJ(pRemoteIp, pSR);
                      break;
                    }

                    //
                    // We need to resolve this address..
                    //

                    if (pResolutionTask->RetriesLeft)
                    {
                        pResolutionTask->RetriesLeft--;

                        // Build an ARP request and send it out.
                        //
                        Status = arpSendArpRequest(pRemoteIp, pSR);

                        // pRemoteIp's lock is released by the above call.
                        //
                        RM_ASSERT_OBJUNLOCKED(&pRemoteIp->Hdr, pSR);

                        //
                        // We ignore the return status of the above call -- so
                        // whether or not the request could be sent out,
                        // we suspend this task for resolution-timeout seconds.
                        //
        
                        RmSuspendTask(pTask, PEND_ResponseTimeout, pSR);
        
                        RmResumeTaskDelayed(
                            pTask, 
                            0,
                            ARP1394_ADDRESS_RESOLUTION_TIMEOUT,
                            &pResolutionTask->Timer,
                            pSR
                            );

                        Status = NDIS_STATUS_PENDING;
                    }
                    else
                    {
                        LOGSTATS_FailedArpQueried(IF_FROM_REMOTEIP(pRemoteIp));
                        // Oops -- couldn't resolve this address.
                        //
                        OBJLOG1(
                            pRemoteIp,
                            "Timed out trying to resolve address 0x%08lx\n",
                            pRemoteIp->IpAddress
                            );
                        UNLOCKOBJ(pRemoteIp, pSR);
                        Status = NDIS_STATUS_FAILURE;
                    }
                }
                break;
            }
        }
        break;

        case RM_TASKOP_END:
        {
            //
            // We are done with address resolution. Clear ourselves
            // as the official address resolution task of pRemoteIp.
            //
            LOCKOBJ(pRemoteIp, pSR);

            DBGMARK(0x6bd6d27a);

            if (pRemoteIp->pResolutionTask != pTask)
            {
                ASSERT(FALSE);
            }
            else
            {
        
                // Delete the association added when setting the resolution task
                //
                DBG_DELASSOC(
                    &pRemoteIp->Hdr,
                    NULL,
                    NULL,
                    ARPASSOC_RESOLUTION_IF_TASK,
                    pSR
                    );
            
                pRemoteIp->pResolutionTask = NULL;

            }

            UNLOCKOBJ(pRemoteIp, pSR);

            // Propagate the status code
            //
            Status = (NDIS_STATUS) UserParam;
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)


    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}

NDIS_STATUS
arpSendArpRequest(
    PARPCB_REMOTE_IP pRemoteIp, // LOCKIN NOLOCKOUT
    PRM_STACK_RECORD pSR
    )
{
    NDIS_STATUS Status;
    PARP1394_INTERFACE pIF;
    PNDIS_PACKET    pNdisPacket;
    PIP1394_ARP_PKT pPktData;
    IPAddr TargetIpAddress = 0;
    
    ENTER("arpSendArpRequest", 0xcecfc632)
    RM_ASSERT_OBJLOCKED(&pRemoteIp->Hdr, pSR);

    pIF = (PARP1394_INTERFACE)  RM_PARENT_OBJECT(pRemoteIp);

    DBGMARK(0xb90e9ffc);

    Status = arpAllocateControlPacket(
                pIF,
                sizeof(IP1394_ARP_PKT),
                ARP1394_PACKET_FLAGS_ARP,
                &pNdisPacket,
                &pPktData,
                pSR
                );

    if (FAIL(Status))
    {
        UNLOCKOBJ(pRemoteIp, pSR);
    }
    else
    {
        IP1394_ARP_PKT_INFO     PktInfo;
        PARP1394_ADAPTER pAdapter =  (PARP1394_ADAPTER) RM_PARENT_OBJECT(pIF);

        //
        // If we are running in bridge the Target Ip Address is stored in 
        // the BridgeTargetIpAddress Field. Otherwise it is in the Key.
        //
        ASSERT (pRemoteIp->IpAddress != 0);            

        // Prepare the packet.
        //
        PktInfo.SenderHwAddr.UniqueID   = pAdapter->info.LocalUniqueID;
        PktInfo.SenderHwAddr.Off_Low    = pIF->recvinfo.offset.Off_Low;
        PktInfo.SenderHwAddr.Off_High   = pIF->recvinfo.offset.Off_High;
        PktInfo.OpCode                  = IP1394_ARP_REQUEST;
        PktInfo.SenderMaxRec            = pAdapter->info.MaxRec;
        PktInfo.SenderMaxSpeedCode      = pAdapter->info.MaxSpeedCode;
        PktInfo.TargetIpAddress         = pRemoteIp->IpAddress;
        PktInfo.SenderIpAddress         = pIF->ip.DefaultLocalAddress;


        arpPrepareArpPkt(
                &PktInfo,
                // ARP_DEFAULT_MAXREC, // SenderMaxRec TODO
                pPktData
                );

        RmTmpReferenceObject(&pIF->Hdr, pSR);
        UNLOCKOBJ(pRemoteIp, pSR);
        RM_ASSERT_NOLOCKS(pSR);

        TR_INFO(("Attempting to send ARP Req PKT. UID=0x%I64x FIFO=0x%04lx:0x%08lx OP=%lu SIP=0x%04lx TIP=0x%04lx.\n",
                PktInfo.SenderHwAddr.UniqueID,
                PktInfo.SenderHwAddr.Off_High,
                PktInfo.SenderHwAddr.Off_Low,
                PktInfo.OpCode,
                PktInfo.SenderIpAddress,
                PktInfo.TargetIpAddress
                ));

        LOGSTATS_TotalQueries(pIF);

        ARP_FASTREADLOCK_IF_SEND_LOCK(pIF);

        // Actually send the packet (this will silently fail and free the pkt
        // if we're not in a position to send the pkt.)
        //
        arpSendControlPkt(
                pIF,            // LOCKIN NOLOCKOUT (IF send lk)
                pNdisPacket,
                pIF->pBroadcastDest,
                pSR
                );
        
        RM_ASSERT_NOLOCKS(pSR);
        RmTmpDereferenceObject(&pIF->Hdr, pSR);
    }

    EXIT()
    return Status;
}

VOID
arpSendControlPkt(
    IN  ARP1394_INTERFACE       *   pIF,            // LOCKIN NOLOCKOUT (IF send lk)
    IN  PNDIS_PACKET                pNdisPacket,
    PARPCB_DEST                     pDest,
    IN  PRM_STACK_RECORD            pSR
    )
/*++


Routine Description:

    Send a packet on the broadcast channel.

Arguments:

    pIF             - Our interface object
    pNdisPacket     - Packet to send

--*/
{
    NDIS_STATUS Status;
    MYBOOL      fRet;
    ENTER("arpSendControlPkt", 0x2debf9b7)

    DBGMARK(0xe6823818);

    //
    // If we can't send now, we fail.
    //
    if (pDest==NULL || !ARP_CAN_SEND_ON_DEST(pDest))
    {
        ARP_FASTUNLOCK_IF_SEND_LOCK(pIF);

        TR_WARN(("Couldn't send control pkt 0x%p.\n", pNdisPacket));

        arpFreeControlPacket(
            pIF,
            pNdisPacket,
            pSR
            );

        return;                             // EARLY RETURN
    }

    arpRefSendPkt( pNdisPacket, pDest);

    // Release the IF send lock.
    //
    ARP_FASTUNLOCK_IF_SEND_LOCK(pIF);

    // Actually send the packet
    //
#if ARPDBG_FAKE_SEND
    arpDbgFakeNdisCoSendPackets(
            pDest->VcHdr.NdisVcHandle,
            &pNdisPacket,
            1,
            &pDest->Hdr,
            &pDest->VcHdr
        );
#else   // !ARPDBG_FAKE_SEND
    NdisCoSendPackets(
            pDest->VcHdr.NdisVcHandle,
            &pNdisPacket,
            1
        );
#endif  // !ARPDBG_FAKE_SEND
    
    EXIT()

}


VOID
arpProcessArpPkt(
    PARP1394_INTERFACE pIF, // NOLOCKIN NOLOCKOUT
    PIP1394_ARP_PKT pArpPkt,
    UINT                cbBufferSize
    )
/*++
    Process an arp packet (request OR response) from the 1394 bus.
--*/
{
    NDIS_STATUS Status;
    IP1394_ARP_PKT_INFO     PktInfo;
    ENTER("arpProcessArpPkt", 0x6e81a8fa)
    RM_DECLARE_STACK_RECORD(sr)

    DBGMARK(0x03f6830e);

    Status = arpParseArpPkt(
                pArpPkt,
                cbBufferSize,
                &PktInfo
                );


    if (!FAIL(Status))
    {
        if (PktInfo.OpCode ==  IP1394_ARP_REQUEST)
        {
            arpProcessArpRequest(pIF, &PktInfo, &sr);
        }
        else
        {
            ASSERT(PktInfo.OpCode == IP1394_ARP_RESPONSE);
            arpProcessArpResponse(pIF, &PktInfo, &sr);
        }
    }

    RM_ASSERT_CLEAR(&sr);

    EXIT()

}


VOID
arpProcessArpRequest(
    PARP1394_INTERFACE          pIF,    // NOLOCKIN NOLOCKOUT
    PIP1394_ARP_PKT_INFO    pPktInfo,
    PRM_STACK_RECORD            pSR
    )
{
    IP1394_ARP_PKT_INFO     ResponsePktInfo;
    NDIS_STATUS Status;
    ENTER("arpProcessArpRequest", 0xd33fa61d)

    RM_ASSERT_NOLOCKS(pSR);

    // pStatsCmd->TotalResponses        = pIF->stats.arpcache.TotalResponses;
    // pStatsCmd->TotalLookups          = pIF->stats.arpcache.TotalLookups;

    //
    // First check to see if this is an ARP that was originated by us.
    //
    do
    {
        UINT64                  DestUniqueId = pPktInfo->SenderHwAddr.UniqueID;
        ARP1394_ADAPTER         *pAdapter = (ARP1394_ADAPTER *) RM_PARENT_OBJECT(pIF);
        UINT64                  LocalUniqueId = pAdapter->info.LocalUniqueID; 
        ARP_DEST_PARAMS         DestParams;
        PNDIS_PACKET            pNdisPacket;
        PIP1394_ARP_PKT         pPktData;
    

        //
        // This arp packet was originated by this machine. Do not respond to it.
        //
        if (LocalUniqueId == DestUniqueId)
        {
            break;
        }

        //
        // Prepare the structure that will be used to generate the arp response.
        //
    
        Status = arpPrepareArpResponse(
                    pIF,            // NOLOCKIN NOLOCKOUT
                    pPktInfo,
                    &ResponsePktInfo,
                    pSR
                    );

        if (FAIL(Status))
        {
            break;
        }

        
        ARP_ZEROSTRUCT(&DestParams);
        DestParams.HwAddr.AddressType   = NIC1394AddressType_FIFO;
        DestParams.HwAddr.FifoAddress   = pPktInfo->SenderHwAddr; // Struct copy

        //
        // Update our arp cache with information from the sender's portion of
        // the arp request.
        //
        arpUpdateArpCache(
                pIF,
                pPktInfo->SenderIpAddress, // Remote IP Address,
                NULL,                   // Sender's Ethernet Address
                &DestParams,             // Remote Destination HW Address
                TRUE,                      // If required, create an entry for this.,
                pSR
                );

        //
        // Let's send the response!
        //

        Status = arpAllocateControlPacket(
                    pIF,
                    sizeof(IP1394_ARP_PKT),
                    ARP1394_PACKET_FLAGS_ARP,
                    &pNdisPacket,
                    &pPktData,
                    pSR
                    );
    
        if (FAIL(Status))
        {
            break;
        }

        LOGSTATS_TotalArpResponses(pIF);

        // Prepare the packet.
        //
        arpPrepareArpPkt(
                &ResponsePktInfo,
                // ARP_DEFAULT_MAXREC, // SenderMaxRec TODO
                pPktData
                );

        RM_ASSERT_NOLOCKS(pSR);

        TR_WARN(("Attempting to send ARP Resp PKT. UID=0x%I64x FIFO=0x%04lx:0x%08lx OP=%lu SIP=0x%04lx TIP=0x%04lx.\n",
            pPktInfo->SenderHwAddr.UniqueID,
            pPktInfo->SenderHwAddr.Off_High,
            pPktInfo->SenderHwAddr.Off_Low,
            pPktInfo->OpCode,
            pPktInfo->SenderIpAddress,
            pPktInfo->TargetIpAddress
            ));

        ARP_FASTREADLOCK_IF_SEND_LOCK(pIF);

        // Actually send the packet (this will silently fail and free the pkt
        // if we're not in a position to send the pkt.)
        //
        arpSendControlPkt(
                pIF,            // LOCKIN NOLOCKOUT (IF send lk)
                pNdisPacket,
                pIF->pBroadcastDest,
                pSR
                );
        

    } while (FALSE);

    RM_ASSERT_NOLOCKS(pSR);
}

VOID
arpProcessArpResponse(
    PARP1394_INTERFACE          pIF,    // NOLOCKIN NOLOCKOUT
    PIP1394_ARP_PKT_INFO    pPktInfo,
    PRM_STACK_RECORD            pSR
    )
{
    ARP_DEST_PARAMS     DestParams;
    RM_ASSERT_NOLOCKS(pSR);
    ARP_ZEROSTRUCT(&DestParams);

    DestParams.HwAddr.AddressType       = NIC1394AddressType_FIFO;
    DestParams.HwAddr.FifoAddress       = pPktInfo->SenderHwAddr; // Struct copy

    arpUpdateArpCache(
            pIF,
            pPktInfo->SenderIpAddress, // Remote IP Address
            NULL,                     // Senders Mac Address (Bridge only)
            &DestParams,        // Remote Destination HW Address
            FALSE,          // Don't update unless we already have an entry for it.
            pSR
            );
}


VOID
arpUpdateArpCache(
    PARP1394_INTERFACE          pIF,    // NOLOCKIN NOLOCKOUT
    IP_ADDRESS                  RemoteIpAddress,
    ENetAddr                    *pRemoteEthAddress,
    PARP_DEST_PARAMS            pDestParams,
    MYBOOL                      fCreateIfRequired,
    PRM_STACK_RECORD            pSR
    )
/*++
    Update cache and also abort any resolution task that may be going on.
--*/
{
    REMOTE_DEST_KEY RemoteDestKey;
    PARP1394_ADAPTER pAdapter = (PARP1394_ADAPTER)RM_PARENT_OBJECT(pIF);
    ENTER("arpUpdateArpCache", 0x3a16a415)
    LOCKOBJ(pIF, pSR);

    do
    {
        ARPCB_REMOTE_IP *pRemoteIp = NULL;
        INT             fCreated = FALSE;
        UINT            RemoteIpCreateFlags = 0;
        NDIS_STATUS     Status;

        DBGMARK(0xd3b27d1f);

        if (fCreateIfRequired)
        {
            RemoteIpCreateFlags |= RM_CREATE;
        }

        // Create the Key from the passed in parameters
        // 
        if (ARP_BRIDGE_ENABLED(pAdapter) == TRUE) 
        {
            ASSERT (pRemoteEthAddress != NULL);
            RemoteDestKey.ENetAddress = *pRemoteEthAddress;
            TR_INFO(("Arp1394 - Bridge update cache Mac Address %x %x %x %x %x %x\n",
                        RemoteDestKey.ENetAddress.addr[0], 
                        RemoteDestKey.ENetAddress.addr[1],
                        RemoteDestKey.ENetAddress.addr[2],
                        RemoteDestKey.ENetAddress.addr[3],
                        RemoteDestKey.ENetAddress.addr[4],
                        RemoteDestKey.ENetAddress.addr[5]));
        }
        else
        {
            REMOTE_DEST_KEY_INIT(&RemoteDestKey);
          
            RemoteDestKey.IpAddress = RemoteIpAddress;

            TR_INFO( ("Arp1394 - Non-Bridge update cache Mac Address %x %x %x %x %x %x\n",
                        RemoteDestKey.ENetAddress.addr[0], 
                        RemoteDestKey.ENetAddress.addr[1],
                        RemoteDestKey.ENetAddress.addr[2],
                        RemoteDestKey.ENetAddress.addr[3],
                        RemoteDestKey.ENetAddress.addr[4],
                        RemoteDestKey.ENetAddress.addr[5]));
        }
        // Lookup/Create Remote IP Address
        //
        Status = RmLookupObjectInGroup(
                        &pIF->RemoteIpGroup,
                        RemoteIpCreateFlags,
                        (PVOID) (&RemoteDestKey),
                        (PVOID) (&RemoteDestKey), // pCreateParams
                        (RM_OBJECT_HEADER**) &pRemoteIp,
                        &fCreated,  // pfCreated
                        pSR
                        );
        if (FAIL(Status))
        {
            OBJLOG1(
                pIF,
                "Couldn't add localIp entry with addr 0x%lx\n",
                RemoteIpAddress
                );
            break;
        }

        //
        // Update the RemoteIp Last time checked here. This will refresh the 
        // Arp Entry for this Remote Ip struct
        //
        pRemoteIp->sendinfo.TimeLastChecked = 0;

        UNLOCKOBJ(pIF, pSR);

        arpUpdateRemoteIpDest(
            pIF,
            pRemoteIp,
            pDestParams,
            pSR
            );

        // If there is a resolution task going on for pRemoteIp we abort it.
        //
        arpTryAbortResolutionTask(pRemoteIp, pSR);

        // Finally, remove the tmprefs added in the lookups.
        //
        RmTmpDereferenceObject(&pRemoteIp->Hdr, pSR);

        return;                                         // EARLY RETURN

    } while (FALSE);

    UNLOCKOBJ(pIF, pSR);
    EXIT()
}


VOID
arpTryAbortResolutionTask(
        PARPCB_REMOTE_IP pRemoteIp, // NOLOCKIN NOLOCKOUT
        PRM_STACK_RECORD pSR
        )
{
    ENTER("arpTryAbortResolutionTask", 0xf34f16f2)
    PTASK_RESOLVE_IP_ADDRESS pResolutionTask;
    UINT    TaskResumed;
    RM_ASSERT_NOLOCKS(pSR);

    LOCKOBJ(pRemoteIp, pSR);
    pResolutionTask = (PTASK_RESOLVE_IP_ADDRESS) pRemoteIp->pResolutionTask;
    if (pResolutionTask != NULL)
    {
        RmTmpReferenceObject(&pResolutionTask->TskHdr.Hdr, pSR);
    }
    UNLOCKOBJ(pRemoteIp, pSR);

    DBGMARK(0x5b93ad3e);

    if (pResolutionTask != NULL)
    {
        RmResumeDelayedTaskNow(
            &pResolutionTask->TskHdr,
            &pResolutionTask->Timer,
            &TaskResumed,
            pSR
            );

        RmTmpDereferenceObject(&pResolutionTask->TskHdr.Hdr, pSR);
    }

    EXIT()
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\cfg.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    cfg.c

Abstract:

    ARP1394 Configuration-related routines.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     12-01-98    Created (adapted from atmarp.sys)

Notes:

--*/
#include <precomp.h>


//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_CFG

// TODO: change this to ARP1394
#define ARP_NAME_STRING     NDIS_STRING_CONST("ATMARPC")

//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================

#if TODO
//
//  Size of local temp buffer
//
#define WORK_BUF_SIZE       200


#define ASCII_TO_INT(val)       \
            ( ( ((val) >= '0') && ('9' >= (val)) ) ? ((val) - '0') :    \
              ( ((val) >= 'a') && ('z' >= (val)) ) ? ((val) - 'a' + 10) :   \
              ( ((val) >= 'A') && ('Z' >= (val)) ) ? ((val) - 'A' + 10) :   \
              0 )


//
//  Parameters for reading in a ULONG from configuration into an Interface
//  structure.
//
typedef struct _AA_READ_CONFIG_PARAMS
{
    ULONG           StructOffset;   // Offset of param from beginning of struct
    PWCHAR          ParameterName;  // Name in config database
    ULONG           DefaultValue;
} AA_READ_CONFIG_PARAMS, *PAA_READ_CONFIG_PARAMS;

#define AA_MAKE_RCP(Off, Name, Dflt)    \
        { Off, Name, Dflt }

#define LIS_CONFIG_ENTRY(Field, Name, Dflt) \
        AA_MAKE_RCP(FIELD_OFFSET(struct _ATMARP_INTERFACE, Field), Name, Dflt)

#define AA_BANDWIDTH_UNSPECIFIED        ((ULONG)-1)
#define AA_PACKET_SIZE_UNSPECIFIED      ((ULONG)-1)
#define AA_MTU_UNSPECIFIED              ((ULONG)-1)
#define AA_SPEED_UNSPECIFIED            ((ULONG)-1)

//
//  List of ULONG parameters for an LIS
//
AA_READ_CONFIG_PARAMS AtmArpLISConfigTable[] =
{
    LIS_CONFIG_ENTRY(SapSelector, L"SapSelector", AA_DEF_SELECTOR_VALUE),
    LIS_CONFIG_ENTRY(HeaderPool[AA_HEADER_TYPE_UNICAST].MaxHeaderBufs, L"MaxHeaderBufs", AA_DEF_MAX_HEADER_BUFFERS),
    LIS_CONFIG_ENTRY(HeaderPool[AA_HEADER_TYPE_UNICAST].HeaderBufSize, L"HeaderBufSize", AA_PKT_LLC_SNAP_HEADER_LENGTH),
#ifdef IPMCAST
    LIS_CONFIG_ENTRY(HeaderPool[AA_HEADER_TYPE_NUNICAST].MaxHeaderBufs, L"McastMaxHeaderBufs", AA_DEF_MAX_HEADER_BUFFERS),
    LIS_CONFIG_ENTRY(HeaderPool[AA_HEADER_TYPE_NUNICAST].HeaderBufSize, L"McastHeaderBufSize", sizeof(AA_MC_PKT_TYPE1_SHORT_HEADER)),
#endif // IPMCAST
    LIS_CONFIG_ENTRY(ProtocolBufSize, L"ProtocolBufSize", AA_DEF_PROTOCOL_BUFFER_SIZE),
    LIS_CONFIG_ENTRY(MaxProtocolBufs, L"MaxProtocolBufs", AA_DEF_MAX_PROTOCOL_BUFFERS),
    LIS_CONFIG_ENTRY(MTU, L"MTU", AA_MTU_UNSPECIFIED),
    LIS_CONFIG_ENTRY(Speed, L"Speed", AA_SPEED_UNSPECIFIED),
    LIS_CONFIG_ENTRY(PVCOnly, L"PVCOnly", AA_DEF_PVC_ONLY_VALUE),
    LIS_CONFIG_ENTRY(ServerConnectInterval, L"ServerConnectInterval", AA_DEF_SERVER_CONNECT_INTERVAL),
    LIS_CONFIG_ENTRY(ServerRegistrationTimeout, L"ServerRegistrationTimeout", AA_DEF_SERVER_REGISTRATION_TIMEOUT),
    LIS_CONFIG_ENTRY(AddressResolutionTimeout, L"AddressResolutionTimeout", AA_DEF_ADDRESS_RESOLUTION_TIMEOUT),
    LIS_CONFIG_ENTRY(ARPEntryAgingTimeout, L"ARPEntryAgingTimeout", AA_DEF_ARP_ENTRY_AGING_TIMEOUT),
    LIS_CONFIG_ENTRY(InARPWaitTimeout, L"InARPWaitTimeout", AA_DEF_INARP_WAIT_TIMEOUT),
    LIS_CONFIG_ENTRY(ServerRefreshTimeout, L"ServerRefreshTimeout", AA_DEF_SERVER_REFRESH_INTERVAL),
    LIS_CONFIG_ENTRY(MinWaitAfterNak, L"MinWaitAfterNak", AA_DEF_MIN_WAIT_AFTER_NAK),
    LIS_CONFIG_ENTRY(MaxRegistrationAttempts, L"MaxRegistrationAttempts", AA_DEF_MAX_REGISTRATION_ATTEMPTS),
    LIS_CONFIG_ENTRY(MaxResolutionAttempts, L"MaxResolutionAttempts", AA_DEF_MAX_RESOLUTION_ATTEMPTS),

    LIS_CONFIG_ENTRY(DefaultFlowSpec.SendPeakBandwidth, L"DefaultSendBandwidth", AA_BANDWIDTH_UNSPECIFIED),
    LIS_CONFIG_ENTRY(DefaultFlowSpec.ReceivePeakBandwidth, L"DefaultReceiveBandwidth", AA_BANDWIDTH_UNSPECIFIED),
    LIS_CONFIG_ENTRY(DefaultFlowSpec.SendMaxSize, L"DefaultSendMaxSize", AA_PACKET_SIZE_UNSPECIFIED),
    LIS_CONFIG_ENTRY(DefaultFlowSpec.ReceiveMaxSize, L"DefaultReceiveMaxSize", AA_PACKET_SIZE_UNSPECIFIED),
    LIS_CONFIG_ENTRY(DefaultFlowSpec.SendServiceType, L"DefaultServiceType", AA_DEF_FLOWSPEC_SERVICETYPE),
    LIS_CONFIG_ENTRY(DefaultFlowSpec.AgingTime, L"DefaultVCAgingTimeout", AA_DEF_VC_AGING_TIMEOUT)
#ifdef IPMCAST
    ,
    LIS_CONFIG_ENTRY(MARSConnectInterval, L"MARSConnectInterval", AA_DEF_SERVER_CONNECT_INTERVAL),
    LIS_CONFIG_ENTRY(MARSRegistrationTimeout, L"MARSRegistrationTimeout", AA_DEF_SERVER_REGISTRATION_TIMEOUT),
    LIS_CONFIG_ENTRY(MARSKeepAliveTimeout, L"MARSKeepAliveTimeout", AA_DEF_MARS_KEEPALIVE_TIMEOUT),
    LIS_CONFIG_ENTRY(JoinTimeout, L"JoinTimeout", AA_DEF_MARS_JOIN_TIMEOUT),
    LIS_CONFIG_ENTRY(LeaveTimeout, L"LeaveTimeout", AA_DEF_MARS_LEAVE_TIMEOUT),
    LIS_CONFIG_ENTRY(MaxDelayBetweenMULTIs, L"MaxDelayBetweenMULTIs", AA_DEF_MULTI_TIMEOUT),
    LIS_CONFIG_ENTRY(MulticastEntryAgingTimeout, L"MulticastEntryAgingTimeout", AA_DEF_MCAST_IP_ENTRY_AGING_TIMEOUT),
    LIS_CONFIG_ENTRY(MinRevalidationDelay, L"MinMulticastRevalidationDelay", AA_DEF_MIN_MCAST_REVALIDATION_DELAY),
    LIS_CONFIG_ENTRY(MaxRevalidationDelay, L"MaxMulticastRevalidationDelay", AA_DEF_MAX_MCAST_REVALIDATION_DELAY),
    LIS_CONFIG_ENTRY(MinPartyRetryDelay, L"MinMulticastPartyRetryDelay", AA_DEF_MIN_MCAST_PARTY_RETRY_DELAY),
    LIS_CONFIG_ENTRY(MaxPartyRetryDelay, L"MaxMulticastPartyRetryDelay", AA_DEF_MAX_MCAST_PARTY_RETRY_DELAY),
    LIS_CONFIG_ENTRY(MaxJoinOrLeaveAttempts, L"MaxJoinLeaveAttempts", AA_DEF_MAX_JOIN_LEAVE_ATTEMPTS)

#endif // IPMCAST
};


//
//  Size of above table.
//
#define LIS_CONFIG_ENTRIES  \
        sizeof(AtmArpLISConfigTable)/sizeof(AA_READ_CONFIG_PARAMS)


//
//  Names of LIS parameters and subkey names that don't appear
//  in the above table.
//

#define AA_LIS_IP_CONFIG_STRING                 L"IPConfig"
#define AA_LIS_ATMARP_SERVER_LIST_KEY           L"ARPServerList"
#define AA_LIS_MARS_SERVER_LIST_KEY             L"MARServerList"
#define AA_LIS_ATMARP_SERVER_ADDRESS            L"AtmAddress"
#define AA_LIS_ATMARP_SERVER_SUBADDRESS         L"AtmSubaddress"

#endif // TODO


NDIS_STATUS
arpCfgReadAdapterConfiguration(
    IN  ARP1394_ADAPTER *           pAdapter,
    IN  PRM_STACK_RECORD            pSR
)
/*++

Routine Description:

    Reads the following adapter configuration information from the
    registry:
        * pAdapter->ConfigString (Configuration string for the IP Interface
          associated with this adapter.)

Arguments:

    pAdapter                - Points to our adapter structure.

Return Value:

    NDIS Status code

--*/
{

    NDIS_HANDLE         ConfigHandle;
    NDIS_STATUS         Status;
    PNDIS_STRING        pConfigString = &pAdapter->bind.ConfigName;
    ENTER("ReadAdapterConfig", 0x025d9c6e)
    
    ASSERT(ARP_ATPASSIVE());

    //
    // We do not read adapter configuration if we're operating in ethernet emulation
    // (aka Bridge) mode...
    //
    if (ARP_BRIDGE_ENABLED(pAdapter))
    {
        return NDIS_STATUS_SUCCESS; // ****************** EARLY RETURN *********
    }

    // Set to this to test failure handling of bind-adapter after
    // open adapter succeeds.
    // return NDIS_STATUS_FAILURE;

    TR_INFO(("pAdapter 0x%p, pConfigString = 0x%p\n", pAdapter, pConfigString));

    NdisOpenProtocolConfiguration(
                        &Status,
                        &ConfigHandle,
                        pConfigString
                        );

    if (Status != NDIS_STATUS_SUCCESS)
    {
        ConfigHandle = NULL;
    }
    else
    {
#if MILLEN
        //
        // On Win98/Millennium, we don't read the "IpConfigString" from the 
        // Adapter (actually protocol->adapter binding) configuration (ConfigHandle).
        // This is because the "IpConfigString" value is the SAME as the 
        // protocol binding key (i.e., pAdapter->bind.ConfigName).
        //
        // So we SIMPLY COPY pConfigString into pAdapter->bind.IpConfigString.
        //
        Status =  arpCopyUnicodeString(
                        &(pAdapter->bind.IpConfigString),
                        pConfigString,
                        FALSE                                // Don't UpCase
                        );

        if (FAIL(Status))
        {
            ARP_ZEROSTRUCT(&(pAdapter->bind.IpConfigString));
        }
#else //!MILLEN
        //
        //  Read in the IPConfig string. If this is not present,
        //  fail this call.
        //
        NDIS_STRING                     IpConfigName = NDIS_STRING_CONST("IPConfig");
        PNDIS_CONFIGURATION_PARAMETER   pParam;

        NdisReadConfiguration(
                &Status,
                &pParam,
                ConfigHandle,
                &IpConfigName,
                NdisParameterMultiString
                );

        if ((Status == NDIS_STATUS_SUCCESS) &&
            (pParam->ParameterType == NdisParameterMultiString))
        {

            Status =  arpCopyUnicodeString(
                            &(pAdapter->bind.IpConfigString),
                            &(pParam->ParameterData.StringData),
                            FALSE                                // Don't UpCase
                            );
            if (FAIL(Status))
            {
                ARP_ZEROSTRUCT(&(pAdapter->bind.IpConfigString));
            }
        }

        //
        // Note: NdisCloseConfiguration frees the contents of pParam.
        //
#endif //!MILLEN
    }

    if (ConfigHandle != NULL)
    {
        NdisCloseConfiguration(ConfigHandle);
        ConfigHandle = NULL;
    }

    TR_INFO(("pAdapter 0x%p, Status 0x%p\n", pAdapter, Status));
    if (!FAIL(Status))
    {
        TR_INFO((
            "ConfigName=%Z; IPConfigName=%Z.\n", 
            &pAdapter->bind.ConfigName,
            &pAdapter->bind.IpConfigString
            ));
    }

    EXIT()

    return Status;
}


NDIS_STATUS
arpCfgReadInterfaceConfiguration(
    IN  NDIS_HANDLE                 InterfaceConfigHandle,
    IN  ARP1394_INTERFACE*          pInterface,
    IN  PRM_STACK_RECORD            pSR
)
/*++

Routine Description:

    Get all configuration parameters for the specified IP interface. We first
    fill in all configurable parameters with default values, and then
    overwrite them with values from the configuration database.

Arguments:

    InterfaceLISComfigHandle    - the handle returned by
                                  arpCfgOpenInterfaceConfiguration
    pInterface                  - the Interface control block structure for this
                                  interface.

Return Value:

    NDIS_STATUS_SUCCESS if we were able to read in all config info.
    NDIS_STATUS_RESOURCES if we came across an allocation failure.
    NDIS_STATUS_FAILURE for any other kind of error.

--*/
{
    //
    // This is unimplemented.
    //
    // TODO -- remember to  update interface with the interface lock held!
    //

#if TODO
    NDIS_STATUS             Status;
    PAA_READ_CONFIG_PARAMS  pParamEntry;
    ULONG                   i;
    PATM_SAP                pAtmSap;
    PATM_ADDRESS            pAtmAddress;    // SAP address
    NDIS_STRING                     ParameterName;
    PNDIS_CONFIGURATION_PARAMETER   pNdisConfigurationParameter;


    do
    {
        //
        //  Read in all the ULONGs first.
        //
        pParamEntry = AtmArpLISConfigTable;
        for (i = 0; i < LIS_CONFIG_ENTRIES; i++)
        {
            NdisInitUnicodeString(
                            &ParameterName,
                            pParamEntry->ParameterName
                            );
            NdisReadConfiguration(
                            &Status,
                            &pNdisConfigurationParameter,
                            LISConfigHandle,
                            &ParameterName,
                            NdisParameterInteger
                            );

            if (Status != NDIS_STATUS_SUCCESS)
            {
                //
                //  Error in accessing this parameter -- use the default.
                //
                *(ULONG *)((PUCHAR)pInterface + pParamEntry->StructOffset) =
                                    pParamEntry->DefaultValue;
            }
            else
            {
                *(ULONG *)((PUCHAR)pInterface + pParamEntry->StructOffset) =
                                pNdisConfigurationParameter->ParameterData.IntegerData;
            }

            pParamEntry++;
        }

        //
        //  Postprocessing. Sanity checks on some values.
        //  Round up some sizes to make them multiples of 4.
        //
        pInterface->ProtocolBufSize = ROUND_UP(pInterface->ProtocolBufSize);
        pInterface->HeaderPool[AA_HEADER_TYPE_UNICAST].HeaderBufSize = ROUND_UP(pInterface->HeaderPool[AA_HEADER_TYPE_UNICAST].HeaderBufSize);
#ifdef IPMCAST
        pInterface->HeaderPool[AA_HEADER_TYPE_NUNICAST].HeaderBufSize = ROUND_UP(pInterface->HeaderPool[AA_HEADER_TYPE_NUNICAST].HeaderBufSize);
#endif // IPMCAST

        //
        //  More postprocessing: use the SAP Selector value to set up our
        //  "basic" listening SAP.
        //
        pInterface->SapList.pInterface = pInterface;
        pInterface->SapList.Flags = AA_SAP_REG_STATE_IDLE;
        pInterface->SapList.pInfo->SapType = SAP_TYPE_NSAP;
        pInterface->SapList.pInfo->SapLength = sizeof(ATM_SAP) + sizeof(ATM_ADDRESS);
        pAtmSap = (PATM_SAP)(pInterface->SapList.pInfo->Sap);

        AA_COPY_MEM((PUCHAR)&(pAtmSap->Blli), &AtmArpDefaultBlli, sizeof(ATM_BLLI_IE));
        AA_COPY_MEM((PUCHAR)&(pAtmSap->Bhli), &AtmArpDefaultBhli, sizeof(ATM_BHLI_IE));

        pAtmSap->NumberOfAddresses = 1;

        pAtmAddress = (PATM_ADDRESS)pAtmSap->Addresses;
        pAtmAddress->AddressType = SAP_FIELD_ANY_AESA_REST;
        pAtmAddress->NumberOfDigits = ATM_ADDRESS_LENGTH;
        pAtmAddress->Address[ATM_ADDRESS_LENGTH-1] = (UCHAR)(pInterface->SapSelector);

        pInterface->NumberOfSaps = 1;

        //
        //  If the MTU wasn't specified, get it from the adapter.
        //
        if (pInterface->MTU == AA_MTU_UNSPECIFIED)
        {
            pInterface->MTU = pInterface->pAdapter->MaxPacketSize - AA_PKT_LLC_SNAP_HEADER_LENGTH;
        }
        else
        {
            //
            //  If the MTU value isn't within bounds, default to 9180 bytes.
            //
            if ((pInterface->MTU < 9180) || (pInterface->MTU > 65535 - 8))
            {
                pInterface->MTU = 9180;
            }
        }

        //
        //  If the I/F speed wasn't specified, get it from the adapter.
        //
        if (pInterface->Speed == AA_SPEED_UNSPECIFIED)
        {
            pInterface->Speed = pInterface->pAdapter->LineRate.Outbound;
        }
            
        //
        //  Set up default flow parameters, if not specified, from the values
        //  we got from the adapter.
        //
        if (pInterface->DefaultFlowSpec.SendPeakBandwidth == AA_BANDWIDTH_UNSPECIFIED)
        {
            pInterface->DefaultFlowSpec.SendPeakBandwidth = pInterface->pAdapter->LineRate.Outbound;
            pInterface->DefaultFlowSpec.SendAvgBandwidth = pInterface->pAdapter->LineRate.Outbound;
        }

        if (pInterface->DefaultFlowSpec.ReceivePeakBandwidth == AA_BANDWIDTH_UNSPECIFIED)
        {
            pInterface->DefaultFlowSpec.ReceivePeakBandwidth = pInterface->pAdapter->LineRate.Inbound;
            pInterface->DefaultFlowSpec.ReceiveAvgBandwidth = pInterface->pAdapter->LineRate.Inbound;
        }

        if (pInterface->DefaultFlowSpec.SendMaxSize == AA_PACKET_SIZE_UNSPECIFIED)
        {
            pInterface->DefaultFlowSpec.SendMaxSize = pInterface->MTU + AA_PKT_LLC_SNAP_HEADER_LENGTH;
        }

        if (pInterface->DefaultFlowSpec.ReceiveMaxSize == AA_PACKET_SIZE_UNSPECIFIED)
        {
            pInterface->DefaultFlowSpec.ReceiveMaxSize = pInterface->MTU + AA_PKT_LLC_SNAP_HEADER_LENGTH;
        }

        pInterface->DefaultFlowSpec.Encapsulation = AA_DEF_FLOWSPEC_ENCAPSULATION;
        pInterface->DefaultFlowSpec.SendServiceType =
        pInterface->DefaultFlowSpec.ReceiveServiceType = SERVICETYPE_BESTEFFORT;

        Status = NDIS_STATUS_SUCCESS;
        break;
    }
    while (FALSE);

    return (Status);
#endif // TODO
    return 0;
}


NDIS_STATUS
arpCfgGetInterfaceConfiguration(
        IN ARP1394_INTERFACE    *   pIF,
        IN PRM_STACK_RECORD pSR
        )
/*++

Routine Description:

    Read configuration information for interface pIF.

Arguments:


Return Value:

    NDIS_STATUS_SUCCESS on success.
    Ndis error code     otherwise.

--*/
{
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
    ENTER("GetInterfaceConfiguration", 0xb570e01d)
    NDIS_STATUS Status;

    RM_ASSERT_NOLOCKS(pSR);

    do
    {
        NDIS_HANDLE             ArpInterfaceConfigHandle = NULL;
        NDIS_STRING             IpConfigString;

#if OBSOLETE
        //  Get the config string for FIRST specified LIS (we support only one)
        //
        {
            PWSTR               p;
            do
            {
                p = pAdapter->bind.IpConfigString.Buffer;
        
                ASSERT(p!=NULL);
                DBGMARK(0x4b47fbd3);
    
            } while (p == NULL);
    
            if (*p == L'\0')
            {
                Status = NDIS_STATUS_FAILURE;
                break;
            }
    
            NdisInitUnicodeString(&IpConfigString, p);
        }
#else  // !OBSOLETE
        IpConfigString = pAdapter->bind.IpConfigString; // Struct copy
#endif // !OBSOLETE

        //  Open the configuration section for this interface.
        //
        {
            NDIS_STRING         String;
            NDIS_HANDLE         IpInterfaceConfigHandle;
            NDIS_STRING         OurSectionName = ARP_NAME_STRING;
    
            ASSERT(ARP_ATPASSIVE());
    
    
            NdisOpenProtocolConfiguration(
                            &Status,
                            &IpInterfaceConfigHandle,
                            &IpConfigString
                            );
    
            if (Status != NDIS_STATUS_SUCCESS)
            {
                //
                // Even though we don't currently require anything
                // under the IP config handle, we treat this as a fatal error.
                //
                TR_WARN(("FATAL: cannot open IF IP configuration. pIF=0x%lx\n",pIF));
                break;
            }
    
            //
            //  Get to our configuration section for this interface.
            //
            NdisOpenConfigurationKeyByName(
                        &Status,
                        IpInterfaceConfigHandle,
                        &OurSectionName,
                        &ArpInterfaceConfigHandle
                        );
    
            if (FAIL(Status))
            {
                //
                // We don't *require* this to succeed.
                //
                TR_WARN(("Cannot open IF configuration. pIF=0x%lx\n", pIF));
                ArpInterfaceConfigHandle = NULL;
                Status = NDIS_STATUS_SUCCESS;
            }

            //
            //  We don't need the main Interface section open anymore.
            //
            NdisCloseConfiguration(IpInterfaceConfigHandle);
    
        }

    
        if (ArpInterfaceConfigHandle != NULL)
        {
    
            //  Get all configuration information for this interface.
            //
            Status = arpCfgReadInterfaceConfiguration(
                                        ArpInterfaceConfigHandle,
                                        pIF,
                                        pSR
                                        );
        
            // Close the configuration handle.
            //
            NdisCloseConfiguration(ArpInterfaceConfigHandle);
            ArpInterfaceConfigHandle = NULL;

            if (FAIL(Status))
            {
                TR_WARN((" FATAL: bad status (0x%p) reading IF cfg\n", Status));
                break;
            }
        }

    
        LOCKOBJ(pIF, pSR);

        // NOTE: we don't need to explicitly free pIF->ip.ConfigString.Buffer 
        // when the interface goes away. The Buffer is maintained in pAdapter.
        //
        pIF->ip.ConfigString = IpConfigString; // struct copy.

    UNLOCKOBJ(pIF, pSR);
    
    } while(FALSE);


    EXIT()
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\buf.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    buf.c

Abstract:

    Buffer management utilities

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     03-10-99    Created

Notes:

--*/
#include <precomp.h>

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_BUF


NDIS_STATUS
arpInitializeConstBufferPool(
    IN      UINT                    NumBuffersToCache,
    IN      UINT                    MaxBuffers,
    IN      const PVOID             pvMem,
    IN      UINT                    cbMem,
    IN      PRM_OBJECT_HEADER       pOwningObject,
    IN OUT  ARP_CONST_BUFFER_POOL * pHdrPool,
    IN      PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Initialize a pool   of pre-initialized buffers (of type NDIS_BUFFER). Each buffer
    points to the same, CONSTANT piece of virtual memory, that is supplied by
    the caller (pvMem, of size cbMem).

Arguments:

    NumBuffersToCache   -   Max number of pre-initialized buffers to keep in the
                            internal cache.
    MaxBuffers          -   Max number of buffers allowed to be allocated at any one
                            time.
    pvMem               -   The constant piece of memory that all the buffers point
                            to.
    cbMem               -   The size (in bytes) of the above piece of memory.
    pOwningObject       -   The object that owns the const buffer pool.
    pHdrPool            -   Unitialized memory to hold the const buffer pool.


Return Value:

    NDIS_STATUS_SUCCESS on successfill initialization of the const buffer pool.
    NDIS failure code on failure.

--*/
{
    ENTER("arpInitializeConstBufferPool", 0x943463d4)
    NDIS_STATUS Status;

    ARP_ZEROSTRUCT(pHdrPool);

    do 
    {
        // Allocate the buffer pool
        //
        NdisAllocateBufferPool(
                &Status,
                &pHdrPool->NdisHandle,
                MaxBuffers
                );
    
        if (FAIL(Status))
        {
            TR_WARN((
                "pOwningObj 0x%p, NdisAllocateBufferPool err status 0x%x\n",
                pOwningObject, Status));

            break;
        }

        pHdrPool->NumBuffersToCache = NumBuffersToCache;
        pHdrPool->MaxBuffers        = MaxBuffers;
        pHdrPool->pvMem             = pvMem;
        pHdrPool->cbMem             = cbMem;
        pHdrPool->pOwningObject     = pOwningObject;

        // Initialize Slist to contain initialized and available buffers.
        //
        ExInitializeSListHead(&pHdrPool->BufferList);

        // Initialize spin lock that serializes accesses to the above list.
        //
        NdisAllocateSpinLock(&pHdrPool->NdisLock);

        // (DBG) Add an association to the owning object, to make sure that it
        // deallocates us eventually!
        //
        DBG_ADDASSOC(
            pOwningObject,
            pHdrPool,                   // Entity1
            NULL,                       // Entity2 (unused)
            ARPASSOC_CBUFPOOL_ALLOC,    // AssocID
            "    Buffer pool 0x%p\n",   // Format string
            pSR
            );

        //
        // Note: we don't populate the list at this stage -- instead we add items on
        // demand.
        //

        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    EXIT()
    return Status;
}


VOID
arpDeinitializeConstBufferPool(
IN      ARP_CONST_BUFFER_POOL *pHdrPool,
IN      PRM_STACK_RECORD pSR
)
/*++

Routine Description:

    Deinitialize a previously-initialized const buffer pool. Free all buffers.
    buffers. This function must ONLY be called when there are no outstanding
    allocated buffers.

Arguments:

    pHdrPool    -   const buffer pool to deinitialize

--*/
{
    SLIST_ENTRY   *   pListEntry;
    ENTER("arpDeinitializeConstBufferPool", 0x0db6f5b2)

    // There should be no outstanding buffers...
    //
    ASSERTEX(pHdrPool->NumAllocd ==  pHdrPool->NumInCache, pHdrPool);

    // (DBG) Delete the association we assume was previously added when pHdrPool
    // was initialized.
    //
    DBG_DELASSOC(
        pHdrPool->pOwningObject,
        pHdrPool,                   // Entity1
        NULL,                       // Entity2 (unused)
        ARPASSOC_CBUFPOOL_ALLOC,    // AssocID
        pSR
        );

    // Free any buffers in the cache...
    //
    while(1) {

        pListEntry =  ExInterlockedPopEntrySList(
                            &pHdrPool->BufferList,
                            &pHdrPool->NdisLock.SpinLock
                            );
        if (pListEntry!=NULL)
        {
            PNDIS_BUFFER pNdisBuffer = STRUCT_OF(NDIS_BUFFER, pListEntry, Next);
            InterlockedDecrement(&pHdrPool->NumInCache);
            NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
            NdisFreeBuffer(pNdisBuffer);
        }
        else
        {
            break;
        }
    }

    ASSERTEX(pHdrPool->NumInCache==0, pHdrPool);
    
    ARP_ZEROSTRUCT(pHdrPool);

    EXIT()
}


PNDIS_BUFFER
arpAllocateConstBuffer(
ARP_CONST_BUFFER_POOL *pHdrPool
)
/*++

Routine Description:

        HOT PATH

        Allocate and return a pre-initialized buffer from the the 
        specified const buffer pool.

Arguments:

    pHdrPool    header pool from which buffer is to be allocated.

Return Value:

    Non-NULL ptr to buffer on success
    NULL         on failure (typically because the number of allocated buffers
                 equals the maximum specified when the header pool was initialized)

--*/
{
    ENTER("arpAllocateConstBuffer", 0x52765841)

    PNDIS_BUFFER            pNdisBuffer;
    SLIST_ENTRY         *   pListEntry;

    // Try to pick up a buffer from our list of pre-initialized
    // buffers
    //
    pListEntry =  ExInterlockedPopEntrySList(
                        &pHdrPool->BufferList,
                        &pHdrPool->NdisLock.SpinLock
                        );
    if (pListEntry != NULL)
    {
        LONG l;
        //
        // FAST PATH
        //

        pNdisBuffer = STRUCT_OF(NDIS_BUFFER, pListEntry, Next);
        NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
        l = NdisInterlockedDecrement(&pHdrPool->NumInCache);

        ASSERT(l>=0);

#define LOGBUFSTATS_TotCachedAllocs(_pHdrPool) \
        NdisInterlockedIncrement(&(_pHdrPool)->stats.TotCacheAllocs);

        LOGBUFSTATS_TotCachedAllocs(pHdrPool);

    }
    else
    {

        //
        // SLOW PATH -- allocate a fresh buffer
        //


        if (pHdrPool->NumAllocd >= pHdrPool->MaxBuffers)
        {
            //
            // Exceeded limit, we won't bother trying to allocate a new ndis buffer.
            // (The MaxBuffers limit is hard for us, even if it's not for 
            //  NdisAllocateBufferPool :-) ).
            //
            // Note that the above check is an approximate check, given that
            // many threads may be concurrently making it.
            //
#define LOGBUFSTATS_TotAllocFails(_pHdrPool) \
        NdisInterlockedIncrement(&(_pHdrPool)->stats.TotAllocFails);

            LOGBUFSTATS_TotAllocFails(pHdrPool);
            pNdisBuffer = NULL;
        }
        else
        {
            NDIS_STATUS             Status;

            //
            // Allocate and initialize a buffer.
            //
            NdisAllocateBuffer(
                    &Status,
                    &pNdisBuffer,
                    pHdrPool->NdisHandle,
                    (PVOID) pHdrPool->pvMem,
                    pHdrPool->cbMem
                    );

            //
            // TODO: consider conditionally-compiling stats gathering.
            //

            if (FAIL(Status))
            {
                TR_WARN(
                     ("NdisAllocateBuffer failed: pObj 0x%p, status 0x%x\n",
                            pHdrPool->pOwningObject, Status));

                LOGBUFSTATS_TotAllocFails(pHdrPool);
                pNdisBuffer = NULL;
            }
            else
            {
#define LOGBUFSTATS_TotBufAllocs(_pHdrPool) \
        NdisInterlockedIncrement(&(_pHdrPool)->stats.TotBufAllocs);

                LOGBUFSTATS_TotBufAllocs(pHdrPool);

                NdisInterlockedIncrement(&pHdrPool->NumAllocd);
            }
        }
    }

    return pNdisBuffer;
}

VOID
arpDeallocateConstBuffer(
    ARP_CONST_BUFFER_POOL * pHdrPool,
    PNDIS_BUFFER            pNdisBuffer
    )
/*++

Routine Description:

        HOT PATH

        Free a buffer previously allocated by a call to  arpAllocateConstBuffer.

Arguments:

    pHdrPool    header pool from which buffer is to be allocated.
    pNdisBuffer buffer to free.

--*/
{
    ENTER("arpDeallocateConstBuffer", 0x8a905115)

    // Try to pick up a pre-initialized buffer from our list of pre-initialized
    // buffers
    //


    if (pHdrPool->NumInCache < pHdrPool->NumBuffersToCache)
    {
        //
        // FAST PATH
        //
        // Note that the above check is an approximate check, given that
        // many threads may be concurrently making it.
        //

        ExInterlockedPushEntrySList(
            &pHdrPool->BufferList,
            STRUCT_OF(SLIST_ENTRY, &(pNdisBuffer->Next), Next),
            &(pHdrPool->NdisLock.SpinLock)
            );

        NdisInterlockedIncrement(&pHdrPool->NumInCache);
    }
    else
    {
        LONG l;
        //
        // SLOW PATH -- free back to buffer pool
        //
        NDIS_BUFFER_LINKAGE(pNdisBuffer) = NULL;
        NdisFreeBuffer(pNdisBuffer);
        l = NdisInterlockedDecrement(&pHdrPool->NumAllocd);
        ASSERT(l>=0);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\dbg.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    dbg.h

Abstract:

    Debug-related definitions for ARP1394

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    josephj     11-20-98    created, adapted from L2TP.

--*/



//-----------------------------------------------------------------------------
// Debug constants
//-----------------------------------------------------------------------------

// Memory tags used with NdisAllocateMemoryWithTag to identify allocations
// made by the L2TP driver.  Also, several context blocks define a first field
// of 'ulTag' set to these values for ASSERT sanity checking and eased memory
// dump browsing.  Such tags are set to MTAG_FREED just before NdisFreeMemory
// is called.
//

// Rm/generic tags
// 
#define MTAG_DBGINFO    'd31A'
#define MTAG_TASK       't31A'
#define MTAG_STRING     's31A'
#define MTAG_FREED      'z31A'
#define MTAG_RMINTERNAL 'r31A'

// Arp-sepcific
//
#define MTAG_ADAPTER    'A31A'
#define MTAG_INTERFACE  'I31A'
#define MTAG_LOCAL_IP   'L31A'
#define MTAG_REMOTE_IP  'R31A'
#define MTAG_REMOTE_ETH 'E31A'
#define MTAG_DEST       'D31A'
#define MTAG_PKT        'P31A'
#define MTAG_MCAP_GD    'G31A'
#define MTAG_ICS_BUF    'i31A'
#define MTAG_ARP_GENERIC 'g31A'


// Trace levels.
//
#define TL_FATAL    0x0 // Fatal errors -- always printed in checked build.
#define TL_WARN     0x1 // Warnings
#define TL_INFO     0x2 // Informational (highest level workable for general use)
#define TL_VERB     0x3 // VERBOSE

// Trace mask bits.
//
#define TM_MISC     (0x1<<0)    // Misc.
#define TM_NT       (0x1<<1)    // Driver entry, dispatch, ioctl handling   (nt.c)
#define TM_ND       (0x1<<2)    // Ndis handlers except connection-oriented (nd.c)
#define TM_CO       (0x1<<3)    // Connection-oriented handlers             (co.c)
#define TM_IP       (0x1<<4)    // Interface to IP                          (ip.c)
#define TM_WMI      (0x1<<5)    // WMI                                      (wmi.c)
#define TM_CFG      (0x1<<6)    // Configuration                            (cfg.c)
#define TM_RM       (0x1<<7)    // RM APIs                                  (rm.c)
#define TM_UT       (0x1<<8)    // UTIL APIs                                (util.c)
#define TM_BUF      (0x1<<9)    // Buffer management                        (buf.c)
#define TM_FAKE     (0x1<<10)   // FAKE ndis and ip entrypoints             (fake.c)
#define TM_ARP      (0x1<<11)   // ARP request/response handling code       (arp.c)
#define TM_PKT      (0x1<<12)   // ARP control packet management            (pkt.c)
#define TM_MCAP     (0x1<<13)   // MCAP protocol                            (mcap.c)
#define TM_ETH      (0x1<<14)   // Ethernet-emulation                       (eth.c)

// Bytes to appear on each line of dump output.
//
#define DUMP_BytesPerLine 16


//-----------------------------------------------------------------------------
// Debug global declarations (defined in debug.c)
//-----------------------------------------------------------------------------

// Active debug trace level and active trace set mask.  Set these variables
// with the debugger at startup to enable and filter the debug output.  All
// messages with (TL_*) level less than or equal to 'g_ulTraceLevel' and from
// any (TM_*) set(s) present in 'g_ulTraceMask' are displayed.
//
extern INT      g_ulTraceLevel;
extern ULONG    g_ulTraceMask;
extern INT      g_SkipAll;
extern INT      g_DiscardNonUnicastPackets;


//-----------------------------------------------------------------------------
// Debug macros
//-----------------------------------------------------------------------------

#if DBG

// TRACE sends printf style output to the kernel debugger.  Caller indicates a
// "verbosity" level with the 'ulLevel' argument and associates the trace with
// one or more trace sets with the 'ulMask' bit mask argument.  Notice that
// the variable count printf arguments 'Args' must be parenthesized.
//
#define TRACE(ulLevel,  Args)                               \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & TM_CURRENT)) \
    {                                                          \
        DbgPrint( "A13: %s:", dbg_func_name);                  \
        DbgPrint Args;                                         \
        DbgPrint ("\n");                                        \
    }                                                          \
}

// TRACE0 is like TRACE, except that it doesn't print the prefix.
//
#define TRACE0(ulLevel,  Args)                              \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & TM_CURRENT)) \
    {                                                          \
        DbgPrint Args;                                         \
    }                                                          \
}

#define TR_FATAL(Args)                                         \
    TRACE(TL_FATAL, Args)

#define TR_INFO(Args)                                          \
    TRACE(TL_INFO, Args)

#define TR_WARN(Args)                                          \
    TRACE(TL_WARN, Args)

#define TR_VERB(Args)                                          \
    TRACE(TL_VERB, Args)

#define ENTER(_Name, _locid)                                    \
    char *dbg_func_name =  (_Name);                             \
    UINT dbg_func_locid = (_locid);
    
#define EXIT()


// ASSERT checks caller's assertion expression and if false, prints a kernel
// debugger message and breaks.
//
#undef ASSERT
#define ASSERT(x)                                               \
{                                                               \
    if (!(x))                                                   \
    {                                                           \
        DbgPrint( "A13: !ASSERT( %s ) L:%d,F:%s\n",             \
            #x, __LINE__, __FILE__ );                           \
        DbgBreakPoint();                                        \
    }                                                           \
}

#define ASSERTEX(x, ctxt)                                       \
{                                                               \
    if (!(x))                                                   \
    {                                                           \
        DbgPrint( "A13: !ASSERT( %s ) C:0x%p L:%d,F:%s\n",      \
            #x, (ctxt), __LINE__, __FILE__ );                   \
        DbgBreakPoint();                                        \
    }                                                           \
}

// DUMP prints to the kernel debugger a hex dump of 'cb' bytes starting at 'p'
// in groups of 'ul'.  If 'f' is set the address of each line in shown before
// the dump.  DUMPB, DUMPW, and DUMPDW are BYTE, WORD, and DWORD dumps
// respectively.  Note that the multi-byte dumps do not reflect little-endian
// (Intel) byte order.  The 'ulLevel' and 'ulMask' are described for TRACE.
//
#define DUMP(ulLevel,ulMask,p,cb,f,ul)                         \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, f, ul );                          \
    }                                                          \
}

#define DUMPB(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 1 );                           \
    }                                                          \
}

#define DUMPW(ulLevel,ulMask,p,cb)                             \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 2 );                           \
    }                                                          \
}

#define DUMPDW(ulLevel,ulMask,p,cb)                            \
{                                                              \
    if (ulLevel <= g_ulTraceLevel && (g_ulTraceMask & ulMask)) \
    {                                                          \
        Dump( (CHAR* )p, cb, 0, 4 );                           \
    }                                                          \
}

// DbgMark does nothing useful. But it is convenient to insert DBGMARK in
// places in your code while debugging, and set a breakpoint on DbgMark, so that
// the debugger will stop at the places you inserted DBGMARK. It's a bit more
// flexible than inserting a hardcoded DbgBreakPoint.
//
void DbgMark(UINT Luid);
#define DBGMARK(_Luid) DbgMark(_Luid)


#define DBGSTMT(_stmt)      _stmt

#define RETAILASSERTEX ASSERTEX
#define RETAILASSERT   ASSERT

#define ARP_INIT_REENTRANCY_COUNT() \
    static LONG ReentrancyCount=1;
    
#define ARP_INC_REENTRANCY() \
    arpDbgIncrementReentrancy(&ReentrancyCount)
    
#define ARP_DEC_REENTRANCY() \
    arpDbgDecrementReentrancy(&ReentrancyCount)

#else // !DBG

// Debug macros compile out of non-DBG builds.
//
#define TRACE(ulLevel,ulMask,Args)
#define TR_FATAL(Args)
#define TR_INFO(Args)
#define TR_WARN(Args)
#define TR_VERB(Args)
#undef ASSERT
#define ASSERT(x)
#define ASSERTEX(x, ctxt)
#define DUMP(ulLevel,ulMask,p,cb,f,dw)
#define DUMPB(ulLevel,ulMask,p,cb)
#define DUMPW(ulLevel,ulMask,p,cb)
#define DUMPDW(ulLevel,ulMask,p,cb)
#define ENTER(_Name, _locid)
#define EXIT()
#define DBGMARK(_Luid) (0)
#define DBGSTMT(_stmt)

#if 1
    #define ARP_INIT_REENTRANCY_COUNT()
    #define ARP_INC_REENTRANCY() 0
    #define ARP_DEC_REENTRANCY() 0

#else // !0

    #define ARP_INIT_REENTRANCY_COUNT() \
        static LONG ReentrancyCount=1;
        
    #define ARP_INC_REENTRANCY() \
        arpDbgIncrementReentrancy(&ReentrancyCount)
        
    #define ARP_DEC_REENTRANCY() \
        arpDbgDecrementReentrancy(&ReentrancyCount)
#endif // 0

#define RETAILASSERT(x)                                         \
{                                                               \
    if (!(x))                                                   \
    {                                                           \
        DbgPrint( "A13: !RETAILASSERT( %s ) L:%d,F:%s\n",       \
            #x, __LINE__, __FILE__ );                           \
        DbgBreakPoint();                                        \
    }                                                           \
}

#define RETAILASSERTEX(x, ctxt)                                 \
{                                                               \
    if (!(x))                                                   \
    {                                                           \
        DbgPrint( "A13: !RETAILASSERT( %s ) C:0x%p L:%d,F:%s\n",\
            #x, (ctxt), __LINE__, __FILE__ );                   \
        DbgBreakPoint();                                        \
    }                                                           \
}

#endif



#if BINARY_COMPATIBLE
#define         ASSERT_PASSIVE() (0)
#else // !BINARY_COMPATIBLE
#define     ASSERT_PASSIVE() \
                ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL)
            
#endif // !BINARY_COMPATIBLE
//-----------------------------------------------------------------------------
// Prototypes
//-----------------------------------------------------------------------------

VOID
CheckList(
    IN LIST_ENTRY* pList,
    IN BOOLEAN fShowLinks );

VOID
Dump(
    CHAR* p,
    ULONG cb,
    BOOLEAN fAddress,
    ULONG ulGroup );

VOID
DumpLine(
    CHAR* p,
    ULONG cb,
    BOOLEAN  fAddress,
    ULONG ulGroup );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\dbg.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    dbg.c   ARP1394 Debugging Code

Abstract:

    NT System entry points for ARP1394.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     12-02-98    Created

Notes:

--*/
#include <precomp.h>

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_DBG

INT   g_DiscardNonUnicastPackets;
INT g_SkipAll;

#if DBG

ULONG g_ulTraceMask = 0xffffffff;

#define DEFAULT_TRACE_LEVEL TL_FATAL    


INT g_ulTraceLevel = DEFAULT_TRACE_LEVEL;

void
DbgMark(UINT Luid)
{
    // do nothing useful, but do something specific, so that the compiler doesn't
    // alias DbgMark to some other function that happens to do nothing.
    //
    static int i;
    i=Luid;
}

LONG g_MaxReentrancy = 5;
LONG g_MaxGlobalReentrancy = 10;
LONG g_ReentrancyCount=1;

VOID
arpDbgIncrementReentrancy(
    PLONG pReentrancyCount
    )
{
    LONG Count;

    Count = NdisInterlockedIncrement(pReentrancyCount);
    if (Count > (g_MaxReentrancy+1))
    {
        NdisInterlockedIncrement(&g_MaxReentrancy);
    }

    Count = NdisInterlockedIncrement(&g_ReentrancyCount);
    if (Count > (g_MaxGlobalReentrancy+1))
    {
        NdisInterlockedIncrement(&g_MaxGlobalReentrancy);
    }
}

VOID
arpDbgDecrementReentrancy(
    PLONG pReentrancyCount
    )
{
    LONG Count;
    Count = NdisInterlockedDecrement(pReentrancyCount);

    Count = NdisInterlockedDecrement(&g_ReentrancyCount);
}
    
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\co.c ===
/*++
Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    co.c

Abstract:

    ARP1394 connection-oriented handlers.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     12-01-98    Created

Notes:

--*/
#include <precomp.h>

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_CO



//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//
//  The following functions and typedefs are accessed only in this file.
//
//=========================================================================



UINT
arpRecvFifoReceivePacket(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PNDIS_PACKET                pNdisPacket
);


VOID
arpRecvFifoIncomingClose(
    IN  NDIS_STATUS                 CloseStatus,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PVOID                       pCloseData  OPTIONAL,
    IN  UINT                        Size        OPTIONAL
);


VOID
arpDestIncomingClose(
    IN  NDIS_STATUS                 CloseStatus,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PVOID                       pCloseData  OPTIONAL,
    IN  UINT                        Size        OPTIONAL
);

VOID
arpDestSendComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PNDIS_PACKET                pNdisPacket
);

UINT
arpDestReceivePacket(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PNDIS_PACKET                pNdisPacket
);



NDIS_STATUS
arpTaskUnloadEthDhcpEntry(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpInitializeIfPools(
    IN PARP1394_INTERFACE pIF,
    IN PRM_STACK_RECORD pSR
);

VOID
arpDeInitializeIfPools(
    IN  PARP1394_INTERFACE pIF,
    IN  PRM_STACK_RECORD pSR
);


#if ARP_DEFERIFINIT
MYBOOL
arpIsAdapterConnected(
        IN  PARP1394_ADAPTER    pAdapter,
        IN  PRM_STACK_RECORD    pSR
        );
#endif // ARP_DEFERIFINIT

#if DBG

    VOID
    arpDbgDisplayMapping(
        IP_ADDRESS              IpAddress,
        PNIC1394_DESTINATION    pHwAddr,
        char *                  szPrefix
        );
    #define ARP_DUMP_MAPPING(_Ip, _Hw, _sz) \
            arpDbgDisplayMapping(_Ip, _Hw, _sz)
        
#else // !DBG

    #define ARP_DUMP_MAPPING(_Ip, _Hw, _sz) \
            (0)

#endif

NDIS_STATUS
arpSetupSpecialDest(
    IN  PARP1394_INTERFACE      pIF,
    IN  NIC1394_ADDRESS_TYPE    AddressType,
    IN  PRM_TASK                pParentTask,
    IN  UINT                    PendCode,
    OUT PARPCB_DEST         *   ppSpecialDest,
    PRM_STACK_RECORD            pSR
    );

VOID
arpTryAbortPrimaryIfTask(
    PARP1394_INTERFACE      pIF,
    PRM_STACK_RECORD        pSR
    );

VOID
arpDoLocalIpMaintenance(
        PARP1394_INTERFACE pIF,
        UINT CurrentTime,
        UINT SecondsSinceLastMaintenance,
        MYBOOL *pfProcessed,
        PRM_STACK_RECORD pSR
        );

VOID
arpDoRemoteIpMaintenance(
        PARP1394_INTERFACE pIF,
        UINT CurrentTime,
        UINT SecondsSinceLastMaintenance,
        MYBOOL *pfProcessed,
        PRM_STACK_RECORD pSR
        );

VOID
arpDoRemoteEthMaintenance(
        PARP1394_INTERFACE pIF,
        UINT CurrentTime,
        UINT SecondsSinceLastMaintenance,
        MYBOOL *pfProcessed,
        PRM_STACK_RECORD pSR
        );

VOID
arpDoMcapDbMaintenance(
        PARP1394_INTERFACE pIF,
        UINT CurrentTIme,
        UINT SecondsSinceLastMaintenance,
        MYBOOL *pfProcessed,
        PRM_STACK_RECORD pSR
        );

VOID
arpDoDhcpTableMaintenance(
        PARP1394_INTERFACE pIF,
        UINT CurrentTime,
        UINT SecondsSinceLastMaintenance,
        MYBOOL *pfProcessed,
        PRM_STACK_RECORD pSR
        );

INT
arpMaintainOneLocalIp(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        );

INT
arpMaintainOneRemoteIp(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        );

INT
arpMaintainOneRemoteEth(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        );

INT
arpMaintainOneDhcpEntry(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,  // Unused
        PRM_STACK_RECORD    pSR
        );

VOID
arpUpdateLocalIpDest(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    IN  PARPCB_LOCAL_IP             pLocalIp,
    IN  PARP_DEST_PARAMS            pDestParams,
    PRM_STACK_RECORD                pSR
    );

UINT
arpFindAssignedChannel(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    IN  IP_ADDRESS                  IpAddress,
    IN  UINT                        CurrentTime,
    PRM_STACK_RECORD                pSR
    );

UINT
arpFindFreeChannel(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    PRM_STACK_RECORD                pSR
    );

VOID
arpUpdateRemoteIpDest(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    IN  PARPCB_REMOTE_IP            pRemoteIp,
    IN  PARP_DEST_PARAMS            pDestParams,
    PRM_STACK_RECORD                pSR
    );

VOID
arpRemoteDestDelete(
        PRM_OBJECT_HEADER pHdr,
        PRM_STACK_RECORD  pSR
        );

VOID 
arpRefreshArpEntry(
    PARPCB_REMOTE_IP pRemoteIp,
    PRM_STACK_RECORD pSR
    );


INT
arpMaintainArpCache(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,  // Unused
        PRM_STACK_RECORD    pSR
        );


PRM_OBJECT_HEADER
arpRemoteDestCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    pSR
        );

PRM_OBJECT_HEADER
arpDhcpTableEntryCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    pSR
        );

VOID
arpDhcpTableEntryDelete(
        PRM_OBJECT_HEADER pHdr,
        PRM_STACK_RECORD  pSR
        );

// ARP1394_INTERFACE_StaticInfo contains static information about
// objects of type  ARP1394_INTERFACE;
//
RM_STATIC_OBJECT_INFO
ARP1394_INTERFACE_StaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "INTERFACE",    // TypeName
    0, // Timeout

    NULL, // pfnCreate
    arpObjectDelete, // pfnDelete
    NULL,   // LockVerifier

    0,   // length of resource table
    NULL // Resource Table
};

// Specialized VC handlers for the RECEIVE_FIFO VC
//
ARP_STATIC_VC_INFO
g_ArpRecvFifoVcStaticInfo = 
{
    //  Description
    //
    "Recv FIFO VC",                 // Description

    //
    // Specialized VC handlers.
    //
    NULL,                       // NULL SendComplete handler.
    arpRecvFifoReceivePacket,
    arpRecvFifoIncomingClose,
    
    // VC_TYPE
    //
    ARPVCTYPE_RECV_FIFO,

    FALSE   // FALSE == Is NOT Dest VC
};

// Specialized VC handlers for the BROADCAST VC
//
ARP_STATIC_VC_INFO
g_ArpBroadcastChannelVcStaticInfo = 
{
    //  Description
    //
    "Broadcast VC",                 // Description

    //
    // Specialized VC handlers.
    //
    // arpBroadcastChannelSendComplete,
    // arpBroadcastChannelReceivePacket,
    // arpBroadcastChannelIncomingClose,
    arpDestSendComplete,
    arpDestReceivePacket,
    arpDestIncomingClose,

    // VC_TYPE
    //
    ARPVCTYPE_BROADCAST_CHANNEL,

    TRUE    // Is dest VC
};

// Specialized VC handlers for a send FIFO VC.
//
ARP_STATIC_VC_INFO
g_ArpSendFifoVcStaticInfo = 
{
    //  Description
    //
    "Send FIFO VC",                 // Description

    //
    // Specialized VC handlers.
    //
    // arpSendFifoSendComplete,
    // arpSendFifoIncomingClose,
    arpDestSendComplete,
    NULL,                           // NULL Recv Pkt handler.
    arpDestIncomingClose,
    
    // VC_TYPE
    //
    ARPVCTYPE_SEND_FIFO,

    TRUE    // Is dest VC
};

// Specialized VC handlers for the MULTICHANNEL VC
//
ARP_STATIC_VC_INFO
g_ArpMultiChannelVcStaticInfo = 
{
    //  Description
    //
    "MultiChannel VC",                  // Description

    //
    // Specialized VC handlers.
    //
    NULL,                           // NULL Send complete handler.
    arpDestReceivePacket,
    arpDestIncomingClose,
    // arpMultiChannelReceivePacket,
    // arpMultiChannelIncomingClose,

    // VC_TYPE
    //
    ARPVCTYPE_MULTI_CHANNEL,

    TRUE    // Is dest VC
    
};

// Specialized VC handlers for the ETHERNET VC
//
ARP_STATIC_VC_INFO
g_ArpEthernetVcStaticInfo = 
{
    //  Description
    //
    "Ethernet VC",                  // Description

    //
    // Specialized VC handlers.
    //
    // arpEthernetSendComplete,
    // arpEthernetIncomingClose,
    arpDestSendComplete,
    arpEthernetReceivePacket,
    arpDestIncomingClose,
    
    // VC_TYPE
    //
    ARPVCTYPE_ETHERNET,

    TRUE    // Is dest VC
};

// Specialized VC handlers for RECV CHANNEL VCs
//
ARP_STATIC_VC_INFO
g_ArpRecvChannelVcStaticInfo = 
{
    //  Description
    //
    "Recv Channel VC",                  // Description

    //
    // Specialized VC handlers.
    //
    NULL,                           // NULL Send complete handler.
    // arpRecvChannelReceivePacket,
    // arpRecvChannelIncomingClose,
    arpDestReceivePacket,
    arpDestIncomingClose,
    
    // VC_TYPE
    //
    ARPVCTYPE_RECV_CHANNEL,

    TRUE    // Is dest VC
};


// Specialized VC handlers for SEND CHANNEL VCs
//
ARP_STATIC_VC_INFO
g_ArpSendChannelVcStaticInfo = 
{
    //  Description
    //
    "Send Channel VC",                  // Description

    //
    // Specialized VC handlers.
    //
    // arpSendChannelSendComplete,
    // arpSendChannelIncomingClose,
    arpDestSendComplete,
    NULL,                           // NULL receive packet handler.
    arpDestIncomingClose,
    
    // VC_TYPE
    //
    ARPVCTYPE_SEND_CHANNEL,

    TRUE    // Is dest VC
};


NDIS_STATUS
arpCreateInterface(
        IN  PARP1394_ADAPTER    pAdapter,
        OUT PARP1394_INTERFACE *ppIF,
        IN  PRM_STACK_RECORD    pSR
        );

VOID
arpDeleteInterface(
        IN  PARP1394_INTERFACE  pIF,
        IN  PRM_STACK_RECORD    pSR
        );

VOID
arpActivateIf(
    PARP1394_INTERFACE  pIF,
    PRM_TASK            pCallingTask,   // OPTIONAL
    UINT                SuspendCode,    // OPTIONAL
    PRM_STACK_RECORD    pSR
    );

VOID
arpDeactivateIf(
    PARP1394_INTERFACE  pIF,
    PRM_TASK            pCallingTask,   // OPTIONAL
    UINT                SuspendCode,    // OPTIONAL
    PRM_STACK_RECORD    pSR
    );

NDIS_STATUS
arpCallIpAddInterface(
        IN ARP1394_INTERFACE*   pIF,
        IN  PRM_STACK_RECORD    pSR
        );

PRM_OBJECT_HEADER
arpLocalIpCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    pSR
        );

VOID
arpLocalIpDelete(
        PRM_OBJECT_HEADER pHdr,
        PRM_STACK_RECORD  pSR
        );

PRM_OBJECT_HEADER
arpRemoteIpCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    pSR
        );

PRM_OBJECT_HEADER
arpRemoteEthCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    pSR
        );

VOID
arpRemoteIpDelete(
        PRM_OBJECT_HEADER pHdr,
        PRM_STACK_RECORD  pSR
        );

VOID
arpRemoteEthDelete(
        PRM_OBJECT_HEADER pHdr,
        PRM_STACK_RECORD  pSR
        );

PRM_OBJECT_HEADER
arpDestinationCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    pSR
        );

VOID
arpDestinationDelete(
        PRM_OBJECT_HEADER pHdr,
        PRM_STACK_RECORD  pSR
        );

VOID
arpAddStaticArpEntries(
    IN ARP1394_INTERFACE *pIF,
    IN PRM_STACK_RECORD pSR
    );


MYBOOL
arpNeedToCleanupDestVc(
        ARPCB_DEST *pDest   // LOCKING LOCKOUT
        );

VOID
arpDeinitDestination(
    PARPCB_DEST             pDest,
    MYBOOL                  fOnlyIfUnused,
    PRM_STACK_RECORD        pSR
    );

VOID
arpDeinitRemoteIp(
    PARPCB_REMOTE_IP        pRemoteIp,
    PRM_STACK_RECORD        pSR
    );

VOID
arpDeinitRemoteEth(
    PARPCB_REMOTE_ETH       pRemoteEth,
    PRM_STACK_RECORD        pSR
    );

//=========================================================================
//      C O N N E C T I O N - O R I E N T E D   H A N D L E R S
//=========================================================================

VOID
ArpCoAfRegisterNotify(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PCO_ADDRESS_FAMILY          pAddressFamily
)
/*++

Routine Description:

    This routine is called by NDIS when a Call manager registers its support
    for an Address Family over an adapter. If this is the Address Family we
    are interested in (1394), then we create and initialize an IP interface for
    this adapter.

Arguments:

    ProtocolBindingContext  - our context passed in NdisOpenAdapter, which is
                              a pointer to our Adapter structure.
    pAddressFamily          - points to a structure describing the Address Family
                              being registered by a Call Manager.

--*/
{
    ENTER("CoAfRegisterNotify", 0x51041947)
    PARP1394_ADAPTER    pAdapter = (PARP1394_ADAPTER) ProtocolBindingContext;
    NDIS_STATUS         Status;
    RM_DECLARE_STACK_RECORD(sr)

    do
    {
        PRM_TASK pTask;
        PARP1394_INTERFACE pIF;

        //  Check if this AF is interesting to us.
        //
        if ((pAddressFamily->AddressFamily != CO_ADDRESS_FAMILY_1394) ||
            (pAddressFamily->MajorVersion != NIC1394_AF_CURRENT_MAJOR_VERSION) ||
            (pAddressFamily->MinorVersion != NIC1394_AF_CURRENT_MINOR_VERSION))
        {
            TR_INFO(
            ("Uninteresting AF %d or MajVer %d or MinVer %d\n",
                pAddressFamily->AddressFamily,
                pAddressFamily->MajorVersion,
                pAddressFamily->MinorVersion));
            break;
        }

        LOCKOBJ(pAdapter, &sr);

        // If we already have an interface active, we ignore this notification.
        //
        if (pAdapter->pIF != NULL)
        {
            UNLOCKOBJ (pAdapter, &sr);

            ASSERT (CHECK_POWER_STATE (pAdapter,ARPAD_POWER_LOW_POWER) == FALSE);

            TR_WARN(
                ("pAdapter 0x%p, IF already created!\n",
                pAdapter));
            ASSERTEX(FALSE, pAdapter);
            break;
        }

        // Create Interface
        //
        Status = arpCreateInterface(
                        pAdapter,
                        &pIF,
                        &sr
                        );

        if (FAIL(Status))
        {
            break;
        }

        //
        // Allocate and start task to complete the interface initialization...
        //

        Status = arpAllocateTask(
                    &pIF->Hdr,          // pParentObject
                    arpTaskInitInterface,       // pfnHandler
                    0,                              // Timeout
                    "Task: InitInterface",  // szDescription
                    &pTask,
                    &sr
                    );
    
        if (FAIL(Status))
        {
            TR_WARN(("FATAL: couldn't alloc init intf task!\n"));
            arpDeleteInterface(pIF, &sr );
            break;
        }

        pAdapter->pIF = pIF;

        arpSetPrimaryIfTask(pIF, pTask, ARPIF_PS_INITING, &sr);

        UNLOCKOBJ(pAdapter, &sr);

        RM_ASSERT_NOLOCKS(&sr);
        (VOID)RmStartTask(
                    pTask,
                    0, // UserParam (unused)
                    &sr
                    );

        //
        // The InitializeTask will do all required cleanup on failure, including
        // deallocating the interface.
        //

    } while (FALSE);

    RmUnlockAll(&sr);
    RM_ASSERT_CLEAR(&sr);
    EXIT()
}


VOID
ArpCoOpenAfComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolAfContext,
    IN  NDIS_HANDLE                 NdisAfHandle
)
/*++

Routine Description:

    NDIS calls this function to indicate completion of a previous call to
    NdisClOpenAddressFamily.

Arguments:

    Status              -   return status of the open address family call.
    ProtocolAfContext   -   actually a pointer to our interface control block.
    NdisAfHandle        -   the new Ndis AF handle for this adapter.

--*/
{
    ENTER("OpenAfComplete", 0x86a3c14d)
    PARP1394_INTERFACE  pIF = (PARP1394_INTERFACE) ProtocolAfContext;
    PARP1394_ADAPTER     pAdapter = (PARP1394_ADAPTER) RM_PARENT_OBJECT(pIF);
    RM_DECLARE_STACK_RECORD(sr)

    TIMESTAMP("==>OpenAfComplete");
    // We expect a nonzero task here (the pActDeactTask), which we unpend
    // after filling in the Ndis Af Handle.
    //
    {
        TR_INFO((
            "AfCtxt=0x%lx, status=0x%lx, NdisAfHandle=0x%lx",
            ProtocolAfContext,
            Status,
            NdisAfHandle
            ));

        // We don't pass on NdisAfHandle -- instead we place it in pIF.
        //
        if (Status == NDIS_STATUS_SUCCESS)
        {
            LOCKOBJ(pIF, &sr);
            ASSERTEX(pIF->ndis.AfHandle == NULL, pIF);
            DBG_ADDASSOC(
                &pIF->Hdr,                  // pObject
                NdisAfHandle,               // Instance1
                NULL,                       // Instance2
                ARPASSOC_IF_OPENAF,         // AssociationID
                "    Open AF NdisHandle=%p\n",// szFormat
                &sr
                );
            pIF->ndis.AfHandle = NdisAfHandle;
            UNLOCKOBJ(pIF, &sr);
        }

        // This could have been  caused by a resume or a bind. 
        // In each case, resume the appropriate task
        //
        if (CHECK_POWER_STATE (pAdapter, ARPAD_POWER_LOW_POWER) == TRUE)
        {
            RmResumeTask (pIF->PoMgmt.pAfPendingTask, (UINT_PTR)Status , &sr); 

        }
        else        
        {
            // We expect a nonzero task here (UNbind task), which we unpend.
            // No need to grab locks or anything at this stage.
            //
            RmResumeTask(pIF->pActDeactTask, (UINT_PTR) Status, &sr);
        }
    }

    RM_ASSERT_CLEAR(&sr)
    TIMESTAMPX("<==OpenAfComplete");
    EXIT()
}


VOID
ArpCoCloseAfComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolAfContext
)
/*++

Routine Description:

    NDIS calls this function to indicate completion of a previous call to
    NdisClCloseAddressFamily.

Arguments:

    Status              -   return status of the close address family call.
    ProtocolAfContext   -   actually a pointer to our interface control block.

--*/
{
    ENTER("CloseAfComplete", 0x0cc281db)
    PARP1394_INTERFACE  pIF = (PARP1394_INTERFACE) ProtocolAfContext;
    PARP1394_ADAPTER    pAdapter=(ARP1394_ADAPTER*)RM_PARENT_OBJECT(pIF);
    RM_DECLARE_STACK_RECORD(sr)

    TIMESTAMP("==>ArpCoCloseAfComlete");

    // This could happen because of a Set Power to a low power state.
    // of an actual unbind. In each case, resume the task that would
    // have been waiting for the CloseAf to complete.
    //
    if (CHECK_POWER_STATE (pAdapter, ARPAD_POWER_NORMAL) == TRUE || 
        pAdapter->PoMgmt.bFailedResume )
    {
        // We expect a nonzero task here (UNbind task), which we unpend.
        // No need to grab locks or anything at this stage.
        //

        RmResumeTask(pIF->pActDeactTask, (UINT_PTR) Status, &sr);

    }
    else        
    {
        
        RmResumeTask (pIF->PoMgmt.pAfPendingTask, (UINT_PTR)Status , &sr); 

    }
    
    RM_ASSERT_CLEAR(&sr)
    TIMESTAMP("<==ArpCoCloseAfComlete");
    EXIT()
}


VOID
ArpCoSendComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PNDIS_PACKET                pNdisPacket
)
/*++

Routine Description:

    NDIS calls this function to indicate completion of a previous call to
    NdisCoSendPackets.

Arguments:

    Status              -   return status of the send packet call.
    ProtocolVcContext   -   actually a pointer to our context for this VC. This
                            is either a pointer to an ARPCB_DEST (if the VC is
                            for a call to a remote FIFO address or channel),
                            or to ARP1394_INTERFACE (if the VC is for a call to the
                            single RECEIVE FIFO for this interface.)
    pNdisPacket         -   The packet that was sent.

--*/
{
    PARP_VC_HEADER  pVcHdr  = (PARP_VC_HEADER)  ProtocolVcContext;

    //
    // We use the special status NDIS_STATUS_NOT_RESETTABLE to indicate
    // that the an encapsulation buffer hasn't been inserted into the IP packet.
    // (See 2/5/2000 notes.txt entry). So we want to make sure that the miniport
    // doesn't return this status.
    //
    ASSERT(Status != NDIS_STATUS_NOT_RESETTABLE);

    pVcHdr->pStaticInfo->CoSendCompleteHandler(
                Status,
                ProtocolVcContext,
                pNdisPacket
                );
}


VOID
ArpCoStatus(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 ProtocolVcContext   OPTIONAL,
    IN  NDIS_STATUS                 GeneralStatus,
    IN  PVOID                       pStatusBuffer,
    IN  UINT                        StatusBufferSize
)
/*++

Routine Description:

    This routine is called when the miniport indicates a status
    change, possibly on a VC.

    We ignore this.

Arguments:

    <Ignored>

--*/
{
    
    PARP1394_ADAPTER pAdapter = (PARP1394_ADAPTER)ProtocolBindingContext;
    PNIC1394_STATUS_BUFFER  p1394StatusBuffer = (PNIC1394_STATUS_BUFFER )pStatusBuffer;
 
    do
    {


        if (CHECK_AD_ACTIVE_STATE(pAdapter, ARPAD_AS_ACTIVATED)==FALSE)
        {
            break;
        }

        if (GeneralStatus != NDIS_STATUS_MEDIA_SPECIFIC_INDICATION)
        {   
            break;
        }

        if ((p1394StatusBuffer->Signature == NIC1394_MEDIA_SPECIFIC) &&
            (p1394StatusBuffer->Event == NIC1394_EVENT_BUS_RESET ))
        {
            arpNdProcessBusReset(pAdapter);
            break;
        }


    }while (FALSE);

}

UINT
ArpCoReceivePacket(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PNDIS_PACKET                pNdisPacket
)
/*++

    HOT PATH
    
Routine Description:

    This is routine is called when a packet is received on a VC owned
    by the arp module. If it is an ARP/MCAP-related packet, we consume it ourselves.
    Otherwise, we pass it up to IP.

Arguments:

    ProtocolBindingContext      - Actually a pointer to our Adapter structure
    ProtocolVcContext           - Actually a pointer to our VC context, which is
                                  either ARP1394_INTERFACE (for the recv FIFO vc)
                                  or ARPCB_DEST (for vcs to remote destinations or
                                  to channels).
                                 
    pNdisPacket                 - NDIS packet being received.

Return Value:

    0 -- If we consume the packet ourselves (because we don't hold on to ARP/MCAP
         OR if we're calling the IP's IPRcvHandler (in which case we're ASSUMING IP
         doesn't hold on to the packet either).
    Set by IP -- if we're calling IP's IPRcvPktHandler

--*/
{
    PARP_VC_HEADER  pVcHdr  = (PARP_VC_HEADER)  ProtocolVcContext;
    UINT            Ret;
    ARP_INIT_REENTRANCY_COUNT()

    ARP_INC_REENTRANCY();

    Ret = pVcHdr->pStaticInfo->CoReceivePacketHandler(
                ProtocolBindingContext,
                ProtocolVcContext,
                pNdisPacket
                );

    ARP_DEC_REENTRANCY();

    return Ret;
}


NDIS_STATUS
ArpCoCreateVc(
    IN  NDIS_HANDLE                 ProtocolAfContext,
    IN  NDIS_HANDLE                 NdisVcHandle,
    OUT PNDIS_HANDLE                pProtocolVcContext
)
/*++

Routine Description:

    Entry point called by NDIS when the Call Manager wants to create
    a new endpoint (VC).  We don't expect this to be called, because all our calls
    are outgoing.

Arguments:

    <ignored>

Return Value:

    NDIS_STATUS_FAILURE

--*/
{
    // We don't expect this, because all our calls are outgoing.
    //
    ASSERT(!"Unexpected");
    return NDIS_STATUS_FAILURE;
}


NDIS_STATUS
ArpCoDeleteVc(
    IN  NDIS_HANDLE                 ProtocolVcContext
)
/*++

Routine Description:

    Entry point called by NDIS when the Call Manager wants to delete a VC for
    an INCOMING call. We don't expect this to be called, because all our calls
    are outgoing.

Arguments:

    <ignored>

Return Value:

    NDIS_STATUS_FAILURE

--*/
{
    ASSERT(!"Unexpected");
    return 0;
}


NDIS_STATUS
ArpCoIncomingCall(
    IN      NDIS_HANDLE             ProtocolSapContext,
    IN      NDIS_HANDLE             ProtocolVcContext,
    IN OUT  PCO_CALL_PARAMETERS     pCallParameters
)
/*++

Routine Description:

    Entry point called by NDIS when the Call Manager wants to indicate an
    INCOMING call. We don't expect this to be called, because all our calls
    are outgoing.

Arguments:

    <ignored>

Return Value:

    NDIS_STATUS_FAILURE

--*/
{
    ASSERT(!"Unexpected");
    return NDIS_STATUS_FAILURE;
}


VOID
ArpCoCallConnected(
    IN  NDIS_HANDLE                 ProtocolVcContext
)
/*++

Routine Description:

    Entry point called by NDIS when the Call Manager wants to indicate that an
    INCOMING call has reach the connected state. We don't expect this to be called,
    because all our calls are outgoing.

Arguments:

    <ignored>

--*/
{
    ASSERT(!"Unexpected");
}


VOID
ArpCoIncomingClose(
    IN  NDIS_STATUS                 CloseStatus,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PVOID                       pCloseData  OPTIONAL,
    IN  UINT                        Size        OPTIONAL
)
/*++

Routine Description:

    This handler is called by NDIS when a call is closed unsolicited,
    either by the network or by the remote peer. We need to unload all resources
    associated with this VC.

Arguments:

    CloseStatus         - Reason for the call clearing
    ProtocolVcContext   - A pointer to the our context for this VC.
    pCloseData          - (Ignored)
    Size                - (Ignored)

--*/
{
    PARP_VC_HEADER  pVcHdr  = (PARP_VC_HEADER)  ProtocolVcContext;

    pVcHdr->pStaticInfo->ClIncomingCloseCallHandler(
                CloseStatus,
                ProtocolVcContext,
                pCloseData,
                Size
                );
}


VOID
ArpCoQosChange(
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS         pCallParameters
)
/*++

Routine Description:

    This handler is called by NDIS if the remote peer modifies call parameters
    "on the fly", i.e. after the call is established and running.

    We do not expect or support this.

Arguments:

    ProtocolVcContext       - Pointer to our context for this VC
    pCallParameters         - updated call parameters.

--*/
{
    ASSERT(!"Unimplemented");
}


VOID
ArpCoMakeCallComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  NDIS_HANDLE                 NdisPartyHandle     OPTIONAL,
    IN  PCO_CALL_PARAMETERS         pCallParameters
)
/*++

Routine Description:

    This routine is called by NDIS when an outgoing call request (NdisClMakeCall)
    has completed. The "Status" parameter indicates whether the call was
    successful or not.

Arguments:

    Status                      - Result of the NdisClMakeCall
    ProtocolVcContext           - Pointer to our context for this VC.
    NdisPartyHandle             - Not used (no point-to-multipoint calls)
    pCallParameters             - Pointer to call parameters

--*/
{
    PRM_TASK                pTask;
    PARP1394_INTERFACE      pIF;
    PARP_VC_HEADER  pVcHdr  = (PARP_VC_HEADER)  ProtocolVcContext;
    RM_DECLARE_STACK_RECORD(sr)


    if (pVcHdr->pStaticInfo->IsDestVc)
    {
        //
        // This is destination VC (either send FIFO or channel)
        //
        PARPCB_DEST     pDest;

        pDest   =  CONTAINING_RECORD(pVcHdr, ARPCB_DEST, VcHdr);
        ASSERT_VALID_DEST(pDest);
        pIF = (PARP1394_INTERFACE) RM_PARENT_OBJECT(pDest);
        
        if (pVcHdr->pStaticInfo->VcType == ARPVCTYPE_SEND_FIFO)
        {
            DBGMARK(0x8a1c2e4d);
            if (Status == NDIS_STATUS_SUCCESS)
            {
                LOGSTATS_SuccessfulSendFifoMakeCalls(pIF);
            }
            else
            {
                LOGSTATS_FailedSendFifoMakeCalls(pIF);
            }
        }
        else
        {
            //
            // NOTE -- Ethernet is treated as "channel"
            //

            DBGMARK(0xb803909b);
            if (Status == NDIS_STATUS_SUCCESS)
            {
                LOGSTATS_SuccessfulChannelMakeCalls(pIF);
            }
            else
            {
                LOGSTATS_FailedChannelMakeCalls(pIF);
            }
        }
    }
    else
    {
        DBGMARK(0xd32d028c);
        ASSERT(pVcHdr->pStaticInfo->VcType == ARPVCTYPE_RECV_FIFO);
        pIF     =  CONTAINING_RECORD( pVcHdr, ARP1394_INTERFACE, recvinfo.VcHdr);
        ASSERT_VALID_INTERFACE(pIF);
    }

    pTask = pVcHdr->pMakeCallTask;

    ASSERT(pTask != NULL);

    RmResumeTask(pTask, (UINT_PTR) Status, &sr);

    RM_ASSERT_CLEAR(&sr)

}


VOID
ArpCoCloseCallComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  NDIS_HANDLE                 ProtocolPartyContext OPTIONAL
)
/*++

Routine Description:

    This routine handles completion of a previous NdisClCloseCall.

    We delete the VC on which the call was just closed, regardless of the value
    of Status.


Arguments:

    Status                  - Status of the Close Call.
    ProtocolVcContext       - Pointer to our contex for this VC.
    ProtocolPartyContext    - Not used.

--*/
{
    PRM_TASK        pTask;
    PARP_VC_HEADER  pVcHdr  = (PARP_VC_HEADER)  ProtocolVcContext;
    RM_DECLARE_STACK_RECORD(sr)

    DBGMARK(0x0ecb7bd5);

    pTask = pVcHdr->pCleanupCallTask;
    ASSERT(pTask != NULL);
    RmResumeTask(pTask, (UINT_PTR) Status, &sr);

    RM_ASSERT_CLEAR(&sr)
}


VOID
ArpCoModifyQosComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS         pCallParameters
)
/*++

Routine Description:

    This routine is called by NDIS on completion of a previous call to
    NdisClModifyCallQoS. Since we don't call this, this should never
    get called.

Arguments:

    <Don't care>

--*/
{
        ASSERT(!"Unexpected");
}


NDIS_STATUS
ArpCoRequest(
    IN  NDIS_HANDLE                 ProtocolAfContext,
    IN  NDIS_HANDLE                 ProtocolVcContext   OPTIONAL,
    IN  NDIS_HANDLE                 ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST            pNdisRequest
)
/*++

Routine Description:

    This routine is called by NDIS when our Call Manager sends us an
    NDIS Request. NDIS Requests that are of significance to us are:
    - OID_CO_AF_CLOSE
        The Call Manager wants us to shut down this Interface.

    We ignore all other OIDs.

Arguments:

    ProtocolAfContext           - Our context for the Address Family binding.
    ProtocolVcContext           - Our context for a VC.
    ProtocolPartyContext        - Our context for a Party. Since we don't do
                                  PMP, this is ignored (must be NULL).
    pNdisRequest                - Pointer to the NDIS Request.

Return Value:

    NDIS_STATUS_SUCCESS if we recognized the OID
    NDIS_STATUS_NOT_RECOGNIZED if we didn't.

    TODO: handle AF_CLOSE
--*/
{
    NDIS_STATUS          Status = NDIS_STATUS_NOT_RECOGNIZED;
    ENTER("ArpCoRequest", 0x0d705cb5)
    PARP1394_INTERFACE  pIF = (PARP1394_INTERFACE) ProtocolAfContext;
    RM_DECLARE_STACK_RECORD(sr)

    if (pNdisRequest->RequestType == NdisRequestSetInformation)
    {
        switch (pNdisRequest->DATA.SET_INFORMATION.Oid)
        {
            case OID_CO_AF_CLOSE:

                // TODO -- initiate shutdown of interface.
                // But I don't think we will actually ever get this from
                // NIC1394!
                //
                ASSERT(!"Unimplemented!");
                Status = NDIS_STATUS_SUCCESS;
                break;

            default:
                ASSERT(!"Unexpected OID from NIC1394!");
                Status = NDIS_STATUS_FAILURE;
                break;
        }
    }

    TR_INFO((
        "Called. pIF=0x%p. pReq=0x%p. Oid=0x%lu. Return status=0x%lx\n",
        pIF,
        pNdisRequest->RequestType,
        pNdisRequest->DATA.SET_INFORMATION.Oid,
        Status
        ));

    RM_ASSERT_CLEAR(&sr);
    EXIT()
    return (Status);
}


VOID
ArpCoRequestComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolAfContext,
    IN  NDIS_HANDLE                 ProtocolVcContext   OPTIONAL,
    IN  NDIS_HANDLE                 ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_REQUEST               pNdisRequest
)
/*++

Routine Description:

    This routine is called by NDIS when a previous call to NdisCoRequest
    that had pended, is complete. We handle this based on the request
    we had sent, which has to be one of:
    -  OID_NIC1394_LOCAL_NODE_INFO
        Get NIC1394 adapter information.
    -  OID_NIC1394_VC_INFO
        Get updated NIC1394 information about this VC.

Arguments:

    Status                      - Status of the Request.
    ProtocolAfContext           - Our context for the Address Family binding.
    ProtocolVcContext           - Our context for a VC.
    ProtocolPartyContext        - Our context for a Party. Since we don't do
                                  PMP, this is ignored (must be NULL).
    pNdisRequest                - Pointer to the NDIS Request.

--*/
{
    //
    // TODO: unimplemented.
    //
}

//=========================================================================
//                  P R I V A T E      F U N C T I O N S
//
//=========================================================================


NDIS_STATUS
arpTaskInitInterface(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for loading a newly-created IP interface.

    This is a primary task for the interface object.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    NDIS_STATUS         Status;
    PARP1394_INTERFACE  pIF;
    ENTER("TaskInitInterface", 0x4d42506c)

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_InitAdapterComplete,
        PEND_ActivateIfComplete,
        PEND_DeinitIfOnFailureComplete
    };

    Status              = NDIS_STATUS_FAILURE;
    pIF                 = (PARP1394_INTERFACE) RM_PARENT_OBJECT(pTask);

    switch(Code)
    {

        case RM_TASKOP_START:
        {
            CO_ADDRESS_FAMILY       AddressFamily;

            //
            // We expect to ALREADY be the active primary task.
            // No need to get the IF lock to do this check...
            //
            if (pIF->pPrimaryTask != pTask)
            {
                ASSERT(!"start: we are not the active primary task!");
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            //
            // Determine if adapter initialization is ongoing. If it is, we need
            // to wait for it to complete.
            //
            {
                PARP1394_ADAPTER    pAdapter;
                PRM_TASK            pAdapterInitTask;

                // No need to lock pIF to get pAdapter...
                //
                pAdapter = (PARP1394_ADAPTER) RM_PARENT_OBJECT(pIF);

                LOCKOBJ(pAdapter, pSR);
                if (CHECK_AD_PRIMARY_STATE(pAdapter,  ARPAD_PS_INITING))
                {
                    pAdapterInitTask =  pAdapter->bind.pPrimaryTask;
                    ASSERT(pAdapterInitTask->pfnHandler
                                            ==  arpTaskInitializeAdapter);
                    RmTmpReferenceObject(&pAdapterInitTask->Hdr, pSR);
                    OBJLOG0(
                        pIF,
                        "Waiting for adapter init to complere.\n"
                        );
                    Status = NDIS_STATUS_PENDING;
                }
                else
                {
                    pAdapterInitTask = NULL;
                    if (CHECK_AD_PRIMARY_STATE(pAdapter,  ARPAD_PS_INITED))
                    {
                        Status = NDIS_STATUS_SUCCESS;
                    }
                    else
                    {
                        OBJLOG1(
                            pIF,
                            "Failing init because adapter state(0x%x) is not INITED.\n",
                            GET_AD_PRIMARY_STATE(pAdapter)
                            );
                        Status = NDIS_STATUS_FAILURE;
                    }
                }
        
                UNLOCKOBJ(pAdapter, pSR);

                RM_ASSERT_NOLOCKS(pSR);

                if (pAdapterInitTask != NULL)
                {
                    RmPendTaskOnOtherTask(
                            pTask, 
                            PEND_InitAdapterComplete,
                            pAdapterInitTask,
                            pSR
                            );
                    RmTmpDereferenceObject(&pAdapterInitTask->Hdr, pSR);
                }
            }

            if (!PEND(Status) && !FAIL(Status))
            {
                //
                // Activate the interface...
                //
                arpActivateIf(pIF, pTask, PEND_ActivateIfComplete, pSR);
                Status = NDIS_STATUS_PENDING;
            }
        }

        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            Status = (NDIS_STATUS) UserParam;

            switch(RM_PEND_CODE(pTask))
            {

                case PEND_InitAdapterComplete:
                {
                    //
                    // Activate the interface...
                    //
                    //
                    if (!FAIL(Status))
                    {
                        arpActivateIf(pIF, pTask, PEND_ActivateIfComplete, pSR);
                        Status = NDIS_STATUS_PENDING;
                    }
                }
                break;

                case PEND_ActivateIfComplete:
                {

                    LOCKOBJ(pIF, pSR);
                    if (FAIL(Status))
                    {
                        arpClearPrimaryIfTask(pIF, pTask, ARPIF_PS_FAILEDINIT, pSR);
                        UNLOCKOBJ(pIF, pSR);

                        arpDeinitIf(
                                pIF,
                                pTask,          //  pCallingTask
                                PEND_DeinitIfOnFailureComplete,
                                pSR
                                );
                        Status = NDIS_STATUS_PENDING;
                    }
                    else
                    {
                        // 
                        // Successful activation. Clear the primary task
                        // and set the primary state appropriately.
                        //
                        arpClearPrimaryIfTask(pIF, pTask, ARPIF_PS_INITED, pSR);
                        UNLOCKOBJ(pIF, pSR);
                    }

                } // end case PEND_ActivateIfComplete
                break;
    
                case PEND_DeinitIfOnFailureComplete:
                {
                    // We expect pIF to be deallocated...
                    //
                    ASSERT(RM_IS_ZOMBIE(pIF));

                    //
                    // We ignore the return status of shutdown inteface.
                    // and set Status to failure, because it is
                    // the init interface task that is failing.
                    //
                    Status = NDIS_STATUS_FAILURE;
                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            //
            // Nothing to do here. (Debug) Do some checking.
            //
        #if (DBG)
            Status = (NDIS_STATUS) UserParam;
            if (FAIL(Status))
            {
                ASSERT(RM_IS_ZOMBIE(pIF));
            }
            ASSERT(pIF->pPrimaryTask != pTask);
        #endif // DBG

        }
        break;

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskActivateInterface(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for activating an already initialized IP interface.
    Activating consists of:
        - Reading configuration information
        - Opening the address family
        - Initiating the recv FIFO call

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    PARP1394_INTERFACE  pIF     = (PARP1394_INTERFACE) RM_PARENT_OBJECT(pTask);
    PARP1394_ADAPTER    pAdapter;
    ENTER("TaskActivateInterface", 0x950cb22e)

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_OpenAF,
        PEND_SetupBroadcastChannel,
        PEND_SetupReceiveVc,
        PEND_SetupMultiChannel,
        PEND_SetupEthernetVc
    };

    // No need to lock pIF to get pAdapter...
    //
    pAdapter = (PARP1394_ADAPTER) RM_PARENT_OBJECT(pIF);


    switch(Code)
    {

        case RM_TASKOP_START:
        {
            CO_ADDRESS_FAMILY       AddressFamily;

            
            TIMESTAMP("===ActivateIF: Starting");
            // Fail initialization if the adapter is not INITED.
            //
            {
            

                LOCKOBJ(pAdapter, pSR);
                if (!CHECK_AD_PRIMARY_STATE(pAdapter,  ARPAD_PS_INITED))
                {
                    OBJLOG1(
                        pIF,
                        "Failing init because adapter state(0x%x) is not INITED.\n",
                        GET_AD_PRIMARY_STATE(pAdapter)
                        );
                    Status = NDIS_STATUS_FAILURE;
                    UNLOCKOBJ(pAdapter, pSR);
                    break;
                }
                UNLOCKOBJ(pAdapter, pSR);
            }

            LOCKOBJ(pIF, pSR);
            if (pIF->pActDeactTask != NULL)
            {
                // This should never happen, because the Activate task is
                // always started by an active primary task, and at most one primary
                // task is active at any point of time.
                //
                ASSERTEX(!"start: activate/deactivate task exists!", pIF);
                Status = NDIS_STATUS_FAILURE;
                UNLOCKOBJ(pIF, pSR);
                break;
            }
            arpSetSecondaryIfTask(pIF, pTask, ARPIF_AS_ACTIVATING, pSR);


            // FIRST, we have to re-enable all the groups in the
            // IF structure, which may be disabled if this activation
            // is happening after a deactivation...
            //
            RmEnableGroup(&pIF->LocalIpGroup, pSR);
            RmEnableGroup(&pIF->RemoteIpGroup, pSR);

            if (ARP_BRIDGE_ENABLED(pAdapter))
            {
                RmEnableGroup(&pIF->RemoteEthGroup, pSR);

                RmEnableGroup (&pIF->EthDhcpGroup, pSR);
            }
            RmEnableGroup(&pIF->DestinationGroup, pSR);


            UNLOCKOBJ(pIF, pSR);

            //  Pick up configuration info for this interface.
            //
            Status = arpCfgGetInterfaceConfiguration(
                                        pIF,
                                        pSR
                                        );
        
            if (FAIL(Status))
            {
                OBJLOG1(pIF, "Cannot open IF configuration. Status=0x%lx\n", Status);
                break;
            }

            //
            // Suspend task and call NdisClOpenAddressFamily...
            //

            NdisZeroMemory(&AddressFamily, sizeof(AddressFamily));
    
            AddressFamily.AddressFamily = CO_ADDRESS_FAMILY_1394;
            AddressFamily.MajorVersion = NIC1394_AF_CURRENT_MAJOR_VERSION;
            AddressFamily.MinorVersion = NIC1394_AF_CURRENT_MINOR_VERSION;

            RmSuspendTask(pTask, PEND_OpenAF, pSR);
            RM_ASSERT_NOLOCKS(pSR);
    
            TIMESTAMP("===ActivateIF: Calling NdisClOpenAddressFamily");
            Status = NdisClOpenAddressFamily(
                        pIF->ndis.AdapterHandle,
                        &AddressFamily,
                        (NDIS_HANDLE)pIF,
                        &ArpGlobals.ndis.CC,
                        sizeof(ArpGlobals.ndis.CC),
                        &(pIF->ndis.AfHandle)
                        );
    
            if (Status != NDIS_STATUS_PENDING)
            {
                ArpCoOpenAfComplete(
                        Status,
                        (NDIS_HANDLE)pIF,
                        pIF->ndis.AfHandle
                        );
            }
            Status = NDIS_STATUS_PENDING;

        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            Status = (NDIS_STATUS) UserParam;

            switch(RM_PEND_CODE(pTask))
            {

                case PEND_OpenAF:
                {
                    PARPCB_DEST pBroadcastDest;

                    if (FAIL(Status))
                    {
                        // 
                        // OpenAF failed...
                        //
                        break;
                    }

                    // Check if the adapter state is inited and fail if not.
                    // We keep coming down this path if we're waiting for
                    // the adapter to switch to the "connected" status -- so
                    // in the mean time, if we're shutting down the adapter,
                    // we want to bail out.
                    //
                    if (!CHECK_AD_PRIMARY_STATE(pAdapter,  ARPAD_PS_INITED))
                    {
                        TR_WARN((
                            "Failing init because adapter state(0x%x) is not INITED.\n",
                            GET_AD_PRIMARY_STATE(pAdapter)
                            ));
                        TIMESTAMP("===ActivateIF: Failing Init because adapter state is not inited");
                        Status = NDIS_STATUS_FAILURE;
                        break;
                    }
                    else
                    {
                        ASSERT(sizeof(TASK_ACTIVATE_IF)<=sizeof(ARP1394_TASK));

                        //
                        // If we're not at passive, we need to switch to
                        // passive before we can call arpIsAdapterConnected().
                        //
                        if (!ARP_ATPASSIVE())
                        {
                            // NOTE: we specify completion code PEND_OpenAF
                            //       because we want to get back here (except
                            //       we'll be at passive).
                            //
                            RmSuspendTask(pTask, PEND_OpenAF, pSR);
                            RmResumeTaskAsync(
                                pTask,
                                NDIS_STATUS_SUCCESS,
                                &((TASK_ACTIVATE_IF*)pTask)->WorkItem,
                                pSR
                                );
                            Status = NDIS_STATUS_PENDING;
                            break;
                        }

                        if (!arpIsAdapterConnected(pAdapter, pSR))
                        {
                            //
                            // Let's wait awhile and try again.
                            //

                            TR_INFO((
                                "Delaying IF init until adapter goes"
                                " to connect state.\n"
                                ));
                            RmSuspendTask(pTask, PEND_OpenAF, pSR);
                            RmResumeTaskDelayed(
                                pTask, 
                                NDIS_STATUS_SUCCESS,
                                ARP1394_WAIT_FOR_CONNECT_STATUS_TIMEOUT,
                                &((TASK_ACTIVATE_IF*)pTask)->Timer,
                                pSR
                                );
                            Status = NDIS_STATUS_PENDING;
                            break;
                        }
                        
                    }

                    //
                    // Successfully opened the address family and waited for
                    // connect status.
                    // Now setup the broadcast channel VC.
                    // 
                    //

                    TR_INFO(("Interface: 0x%p, Got NdisAfHandle: 0x%p\n",
                                    pIF, pIF->ndis.AfHandle));
    
                    //
                    // Let's create a destination object representing the
                    // broadcast channel, and make a call to it.
                    //
                    Status =  arpSetupSpecialDest(
                                pIF,
                                NIC1394AddressType_Channel, // This means bcast channel.
                                pTask,                      // pParentTask
                                PEND_SetupBroadcastChannel, //  PendCode
                                &pBroadcastDest,
                                pSR
                                );
                    
                    // Should either fail or pend -- never return success.
                    //
                    ASSERT(Status != NDIS_STATUS_SUCCESS);

                    if (!PEND(Status))
                    {
                        OBJLOG0( pIF, "FATAL: Couldn't create BC dest entry.\n");
                    }
                    else
                    {
                        //
                    }
                }
                break;

                case PEND_SetupBroadcastChannel:
                {
                    PRM_TASK pMakeCallTask;

                    if (FAIL(Status))
                    {
                        // 
                        // Couldn't setup the broadcast channel...
                        //
                        break;
                    }

                    //
                    // Successfully opened the address family.
                    // Now setup the receive FIFO VC.
                    // 
                    //

                    // TR_INFO(("Interface: 0x%p, Got NdisAfHandle: 0x%p\n",
                    //              pIF, pIF->ndis.AfHandle));
    
                    //
                    // Let's start a MakeCall task and pend on it.
                    //

                    Status = arpAllocateTask(
                                &pIF->Hdr,                  // pParentObject
                                arpTaskMakeRecvFifoCall,        // pfnHandler
                                0,                              // Timeout
                                "Task: MakeRecvFifoCall",       // szDescription
                                &pMakeCallTask,
                                pSR
                                );

                    if (FAIL(Status))
                    {
                        // Couldn't allocate task. Let's do a fake completion of
                        // this stage...
                        //
                        RmSuspendTask(pTask, PEND_SetupReceiveVc, pSR);
                        RmResumeTask(pTask, (UINT_PTR) Status, pSR);
                        Status = NDIS_STATUS_PENDING;
                        break;
                    }
                    else
                    {
                        RmPendTaskOnOtherTask(
                            pTask,
                            PEND_SetupReceiveVc,
                            pMakeCallTask,
                            pSR
                            );
        
                        (VOID)RmStartTask(
                                pMakeCallTask,
                                0, // UserParam (unused)
                                pSR
                                );
                    
                        Status = NDIS_STATUS_PENDING;
                    }
                }
                break;

                case PEND_SetupReceiveVc:
                {
                    PARPCB_DEST pMultiChannelDest;

                    if (FAIL(Status))
                    {
                        TR_WARN(("FATAL: COULDN'T SETUP RECEIVE FIFO VC!\n"));
                        break;
                    }
    
                    //
                    // Let's create a destination object representing the
                    // multichannel vc, and make a call to it.
                    //
                    Status =  arpSetupSpecialDest(
                                pIF,
                                NIC1394AddressType_MultiChannel,
                                pTask,                      // pParentTask
                                PEND_SetupMultiChannel, //  PendCode
                                &pMultiChannelDest,
                                pSR
                                );
                    
                    // Should either fail or pend -- never return success.
                    //
                    ASSERT(Status != NDIS_STATUS_SUCCESS);

                    if (!PEND(Status))
                    {
                        OBJLOG0( pIF, "FATAL: Couldn't create BC dest entry.\n");
                    }
                    else
                    {
                        //
                        // On pending, pMultiChannelDest contains a valid
                        // pDest which has been tmpref'd. 
                        // Keep a pointer to the broadcast dest in the IF.
                        // and  link the broadcast dest to the IF.
                        //
                        {
                        #if RM_EXTRA_CHECKING
                            RmLinkObjectsEx(
                                &pIF->Hdr,
                                &pMultiChannelDest->Hdr,
                                0x34639a4c,
                                ARPASSOC_LINK_IF_OF_MCDEST,
                                "    IF of MultiChannel Dest 0x%p (%s)\n",
                                ARPASSOC_LINK_MCDEST_OF_IF,
                                "    MultiChannel Dest of IF 0x%p (%s)\n",
                                pSR
                                );
                        #else // !RM_EXTRA_CHECKING
                            RmLinkObjects(&pIF->Hdr, &pMultiChannelDest->Hdr,pSR);
                        #endif // !RM_EXTRA_CHECKING

                            LOCKOBJ(pIF, pSR);
                            ASSERT(pIF->pMultiChannelDest == NULL);
                            pIF->pMultiChannelDest = pMultiChannelDest;
                            UNLOCKOBJ(pIF, pSR);

                            // arpSetupSpecialDest ref'd pBroadcastDest.
                            //
                            RmTmpDereferenceObject(&pMultiChannelDest->Hdr, pSR);
                        }
                    }
                }
                break;

                case PEND_SetupMultiChannel:
                {
                    PARPCB_DEST pEthernetDest;

                    if (FAIL(Status))
                    {
                        // Ignore the failure.
                    TR_WARN(("COULDN'T SETUP MULTI-CHANNEL VC (IGNORING FAILURE)!\n"));
                    }
    
                    //
                    // Let's create a destination object representing the
                    // ethernet, and make a call to it.
                    //
                    Status =  arpSetupSpecialDest(
                                pIF,
                                NIC1394AddressType_Ethernet,
                                pTask,                      // pParentTask
                                PEND_SetupEthernetVc, //  PendCode
                                &pEthernetDest,
                                pSR
                                );
                    
                    // Should either fail or pend -- never return success.
                    //
                    ASSERT(Status != NDIS_STATUS_SUCCESS);

                    if (!PEND(Status))
                    {
                        OBJLOG0( pIF, "FATAL: Couldn't create BC dest entry.\n");
                    }
                    else
                    {
                        //
                        // On pending, pEthernetDest contains a valid
                        // pDest which has been tmpref'd. 
                        // Keep a pointer to the broadcast dest in the IF.
                        // and  link the broadcast dest to the IF.
                        //
                        {
                        #if RM_EXTRA_CHECKING
                            RmLinkObjectsEx(
                                &pIF->Hdr,
                                &pEthernetDest->Hdr,
                                0xcea46d67,
                                ARPASSOC_LINK_IF_OF_ETHDEST,
                                "    IF of Ethernet Dest 0x%p (%s)\n",
                                ARPASSOC_LINK_ETHDEST_OF_IF,
                                "    Ethernet Dest of IF 0x%p (%s)\n",
                                pSR
                                );
                        #else // !RM_EXTRA_CHECKING
                            RmLinkObjects(&pIF->Hdr, &pEthernetDest->Hdr,pSR);
                        #endif // !RM_EXTRA_CHECKING

                            LOCKOBJ(pIF, pSR);
                            ASSERT(pIF->pEthernetDest == NULL);
                            pIF->pEthernetDest = pEthernetDest;
                            UNLOCKOBJ(pIF, pSR);

                            // arpSetupSpecialDest ref'd pBroadcastDest.
                            //
                            RmTmpDereferenceObject(&pEthernetDest->Hdr, pSR);
                        }
                    }
                }
                break;

                case PEND_SetupEthernetVc:
                {

                    if (FAIL(Status))
                    {
                        TR_WARN(("COULDN'T SETUP ETHERNET VC (IGNORING FAILURE)!\n"));
                        Status = NDIS_STATUS_SUCCESS;
                    }
        
                    if (!ARP_ATPASSIVE())
                    {
                        ASSERT(sizeof(TASK_ACTIVATE_IF)<=sizeof(ARP1394_TASK));

                        // We're not at passive level, but we need to be when we
                        // call IP's add interface. So we switch to passive...
                        // NOTE: we specify completion code PEND_SetupReceiveVc
                        //       because we want to get back here (except
                        //       we'll be at passive).
                        //
                        RmSuspendTask(pTask, PEND_SetupEthernetVc, pSR);
                        RmResumeTaskAsync(
                            pTask,
                            Status,
                            &((TASK_ACTIVATE_IF*)pTask)->WorkItem,
                            pSR
                            );
                        Status = NDIS_STATUS_PENDING;
                        break;
                    }
                        
                    ASSERT(Status == NDIS_STATUS_SUCCESS);

                    //
                    // Successfully opened the address family and setup
                    // the recv VC.

                    // Announce this new interface to IP
                    //
                    TR_INFO(("Interface: 0x%p, Setup recv VC 0x%p\n",
                                    pIF, pIF->recvinfo.VcHdr.NdisVcHandle));

                    if (!ARP_BRIDGE_ENABLED(pAdapter))
                    {
                        Status = arpCallIpAddInterface(
                                        pIF,
                                        pSR
                                        );
    
                        // We don't expect a pending return here.
                        //
                        ASSERT(Status != NDIS_STATUS_PENDING);
    
                        if (!FAIL(Status))
                        {
                            LOCKOBJ(pIF, pSR);
                            // Add any static arp intries
                            //
                            arpAddStaticArpEntries(pIF, pSR);
                            UNLOCKOBJ(pIF, pSR);
                        }
    
                    }

                    if (!FAIL(Status))
                    {
                        //
                        // Start the maintenance task on this IF.
                        //
                        arpStartIfMaintenanceTask(pIF, pSR);
                    }
    
                } // end  case PEND_SetupEthernetVc
                break;

    
                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            Status = (NDIS_STATUS) UserParam;

            LOCKOBJ(pIF, pSR);

            //
            // Was this task able to update the Interface' state
            //
            if (GET_IF_ACTIVE_STATE(pIF) == ARPIF_AS_ACTIVATING)
            {
                //
                // If so, then set the new state
                //
                ASSERT (pIF->pActDeactTask == pTask)
                
                if (FAIL(Status))
                {
                    //
                    // Failure. Whoever was responsible for starting this task
                    // is also responsible for cleaning up after a failed
                    // activation.
                    //
                    arpClearSecondaryIfTask(pIF, pTask, ARPIF_AS_FAILEDACTIVATE, pSR);
                }
                else
                {
                    //
                    // Success
                    //
                    arpClearSecondaryIfTask(pIF, pTask, ARPIF_AS_ACTIVATED, pSR);
                }
            }
            else
            {
                //
                //  Only an early failure should get us here. 
                //  Set the flag for informational purposes
                //
                ASSERT (FAIL(Status) == TRUE);
                ASSERT (pIF->pActDeactTask == NULL);
                ASSERT (!CHECK_AD_PRIMARY_STATE(pAdapter,  ARPAD_PS_INITED));

                SET_IF_ACTIVE_STATE(pIF, ARPIF_AS_FAILEDACTIVATE);
            }
            UNLOCKOBJ(pIF, pSR);

        }
        break;

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
} 


NDIS_STATUS
arpCallIpAddInterface(
            IN ARP1394_INTERFACE    *   pIF, // NOLOCKIN NOLOCKOUT
            IN PRM_STACK_RECORD pSR
            )
/*++

Routine Description:

    Call's IP's AddInterfaceRtn (ArpGlobals.ip.pAddInterfaceRtn), passing it
    a structure continging pointers to our IP handlers and related information.

--*/
{
    ENTER("CallIpAddInterface", 0xe47fc4d4)
    struct LLIPBindInfo         BindInfo;
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
    NDIS_STATUS Status;
    NdisZeroMemory(&BindInfo, sizeof(BindInfo));

    RM_ASSERT_NOLOCKS(pSR);

#if ENABLE_OFFLOAD
    #error "Unimplemented"
    //
    // Query and set NIC offload capabilities.
    //
    BindInfo.lip_OffloadFlags   = pAdapter->Offload.Flags;
    BindInfo.lip_MaxOffLoadSize = pAdapter->Offload.MaxOffLoadSize;
    BindInfo.lip_MaxSegments    = pAdapter->Offload.MinSegmentCount;
#endif // ENABLE_OFFLOAD
    BindInfo.lip_context = (PVOID)pIF;
    BindInfo.lip_transmit = ArpIpMultiTransmit;
    BindInfo.lip_transfer = ArpIpTransfer;
    BindInfo.lip_close = ArpIpClose;
    BindInfo.lip_addaddr = ArpIpAddAddress;
    BindInfo.lip_deladdr = ArpIpDelAddress;
    BindInfo.lip_invalidate = ArpIpInvalidate;
    BindInfo.lip_open = ArpIpOpen;
    BindInfo.lip_qinfo = ArpIpQueryInfo;
    BindInfo.lip_setinfo = ArpIpSetInfo;
    BindInfo.lip_getelist = ArpIpGetEList;
    BindInfo.lip_arpresolveip = ArpSendARPApi;
    BindInfo.lip_mss = pIF->ip.MTU;
    BindInfo.lip_speed = pAdapter->info.Speed;
    //
    //  Set LIP_COPY_FLAG to avoid having TransferData
    //  called all the time.
    //
    BindInfo.lip_flags      = LIP_COPY_FLAG;

#if MILLEN
    #if (ARP1394_IP_PHYSADDR_LEN > 7)
        #error "Win98 doesn't like addrlen to be > 7"
    #endif
#endif // MILLEN

    BindInfo.lip_addrlen    = ARP1394_IP_PHYSADDR_LEN;
    BindInfo.lip_addr       = (PUCHAR) &pAdapter->info.EthernetMacAddress;

    {
        ENetAddr *pMacAddr = (ENetAddr *)BindInfo.lip_addr;
        TR_INFO (("ARP1394 INTERFACE ADDRESS %x %x %x %x %x %x\n",
                pMacAddr->addr[0],pMacAddr->addr[1],pMacAddr->addr[2],pMacAddr->addr[3],pMacAddr->addr[4],pMacAddr->addr[5]));



        TR_INFO (("UNIQUE ID Address %I64x \n",pAdapter->info.LocalUniqueID));


    }

    BindInfo.lip_pnpcomplete = ArpIpPnPComplete;

    Status = ArpGlobals.ip.pAddInterfaceRtn(
                       &pAdapter->bind.DeviceName,
                        NULL,   // IfName (unused) --  See 10/14/1998 entry
                                // in atmarpc.sys, notes.txt
                        &pIF->ip.ConfigString,
                        pAdapter->bind.IpConfigHandle,
                        (PVOID)pIF,
                        ArpIpDynRegister,
                        &BindInfo
                        ,0, // RequestedIndex (unused) --  See 10/14/1998 entry
                            // in notes.txt
                        // IF_TYPE_IPOVER_ATM, // TODO: change to 1394
                        IF_TYPE_IEEE1394,
                        IF_ACCESS_BROADCAST,
                        IF_CONNECTION_DEDICATED
                        );

    if (Status == IP_SUCCESS)
    {
        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        //            
        // Sometimes IP can fail AddInterface synchronously. At that time, there 
        // may be an Resolve Local IP address Task going on. Keep the AddAddrCmplRtn
        // function pointer. 
        //
        IPAddAddrCmpltRtn AddAddrCmplRtn = pIF->ip.AddAddrCmplRtn;
        ARP_ZEROSTRUCT(&(pIF->ip));
        pIF->ip.AddAddrCmplRtn = AddAddrCmplRtn;
        TR_WARN(("IPAddInterface ret 0x%p\n", Status));
        Status = NDIS_STATUS_FAILURE;
    }
    
    RM_ASSERT_NOLOCKS(pSR);
    EXIT()
    return Status;
}



ULONG
arpIpAddressHash(
    PVOID           pKey
    )
/*++

Routine Description:

    Hash function responsible for returning a hash of pKey, which
    we expect to be an Ip address (literally, not ptr to one).

Return Value:

    ULONG-sized hash of the IP address.

--*/
{
    ULONG u = (ULONG) (ULONG_PTR) pKey; // win64 safe (ip addr is 4 bytes)
    char *pc = (char *) &u;

    //
    // The ip address is in network order, but we would like the 1st byte
    // to contain the most variable information (to maximize the hashing benefit),
    // while still keeping most of the information in the hash (so that the quick
    // compare based on the hash key will be more effective). We could reversse
    // the byte order of the entire address, but instead we simply xor in the 4th
    // byte into the 1st byte position (fewer instructions, for whatever that's
    // worth.)
    //

    return u ^ pc[3];
}

ULONG
arpRemoteDestHash(
    PVOID           pKey
    )
/*++

Routine Description:

    Hash function responsible for returning a hash of pKey, which
    we expect to be an Ip address (literally, not ptr to one).

Return Value:

    ULONG-sized hash of the IP address.

--*/
{
    ULONG u = 0; 

    char *pc = NULL;

    u = *((PULONG)pKey); // win64 safe (ip addr is 4 bytes)
    pc = (char *) &u;
    //
    // The ip address is in network order, but we would like the 1st byte
    // to contain the most variable information (to maximize the hashing benefit),
    // while still keeping most of the information in the hash (so that the quick
    // compare based on the hash key will be more effective). We could reversse
    // the byte order of the entire address, but instead we simply xor in the 4th
    // byte into the 1st byte position (fewer instructions, for whatever that's
    // worth.)
    //

    return u ^ pc[3];
}

BOOLEAN
arpLocalIpCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Hash comparison function for ARPCB_LOCAL_IP.

Arguments:

    pKey        - Actually  the IP address (not ptr to IP address) in network-byte
                  order.
    pItem       - Points to ARPCB_LOCAL_IP.Hdr.HashLink.

Return Value:

    TRUE IFF the key (IP address) exactly matches the key of the specified 
    LocalIp object.

--*/
{
    ARPCB_LOCAL_IP *pLIP = 
        CONTAINING_RECORD(pItem, ARPCB_LOCAL_IP, Hdr.HashLink);

    if (pLIP->IpAddress == (ULONG) (ULONG_PTR) pKey)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    
}

BOOLEAN
arpRemoteDestCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Hash comparison function for ARPCB_REMOTE_IP.

Arguments:

    pKey        - Actually  the IP address (not ptr to IP address) in network-byte
                  order.
    pItem       - Points to ARPCB_REMOTE_IP.Hdr.HashLink.

Return Value:

    TRUE IFF the key (IP address) exactly matches the key of the specified 
    RemoteIp object.

--*/
{
    ENTER ("arpRemoteDestCompareKey", 0x62b9d9ae)
    PREMOTE_DEST_KEY pRemoteDestKey = (PREMOTE_DEST_KEY)pKey;
    ARPCB_REMOTE_IP *pRIP = 
        CONTAINING_RECORD(pItem, ARPCB_REMOTE_IP, Hdr.HashLink);
    BOOLEAN fCompare = FALSE;

        
    if ((pRIP->Key.u.u32 == pRemoteDestKey->u.u32)  &&
       (pRIP->Key.u.u16 == pRemoteDestKey->u.u16))
    {
        fCompare = TRUE; 
    }

    TR_INFO( ("Comparision %d Key %x %x %x %x %x %x pRemoteIP %x %x %x %x %x %x\n",
                fCompare,
                pRemoteDestKey->ENetAddress.addr[0],
                pRemoteDestKey->ENetAddress.addr[1],
                pRemoteDestKey->ENetAddress.addr[2],
                pRemoteDestKey->ENetAddress.addr[3],
                pRemoteDestKey->ENetAddress.addr[4],
                pRemoteDestKey->ENetAddress.addr[5],
                pRIP->Key.ENetAddress.addr[0],
                pRIP->Key.ENetAddress.addr[1],
                pRIP->Key.ENetAddress.addr[2],
                pRIP->Key.ENetAddress.addr[3],
                pRIP->Key.ENetAddress.addr[4],
                pRIP->Key.ENetAddress.addr[5]));

    EXIT();
    return fCompare;  // success
}

BOOLEAN
arpRemoteIpCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Hash comparison function for ARPCB_REMOTE_IP.

Arguments:

    pKey        - Actually  the IP address 
    pItem       - Points to ARPCB_REMOTE_IP.Hdr.HashLink.

Return Value:

    TRUE IFF the key (IP address) exactly matches the key of the specified 
    RemoteIp object.

--*/
{
    ARPCB_REMOTE_IP *pRIP = 
        CONTAINING_RECORD(pItem, ARPCB_REMOTE_IP, Hdr.HashLink);

    if (pRIP->IpAddress == (ULONG) (ULONG_PTR) pKey)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    
}

BOOLEAN
arpRemoteEthCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Hash comparison function for ARPCB_REMOTE_ETH.

Arguments:

    pKey        - Actually  the IP address (not ptr to IP address) in network-byte
                  order.
    pItem       - Points to ARPCB_REMOTE_ETH.Hdr.HashLink.

Return Value:

    TRUE IFF the key (IP address) exactly matches the key of the specified 
    RemoteEth object.

--*/
{
    ARPCB_REMOTE_ETH *pRE = 
        CONTAINING_RECORD(pItem, ARPCB_REMOTE_ETH, Hdr.HashLink);

    if (pRE->IpAddress == (ULONG) (ULONG_PTR) pKey)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


BOOLEAN
arpDestinationCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Hash comparison function for ARPCB_DEST.

Arguments:

    pKey        - Actually a pointer to a ARP_DEST_PARAMS structure.
    pItem       - Points to ARPCB_DEST.Hdr.HashLink.

Return Value:

    TRUE IFF the key (HW address) exactly matches the key of the specified 
    Dest object.

--*/
{
    ARPCB_DEST              *pD = CONTAINING_RECORD(pItem, ARPCB_DEST, Hdr.HashLink);
    PARP_DEST_PARAMS            pDestParams =  (PARP_DEST_PARAMS) pKey;
    NIC1394_DESTINATION     *pKeyHwAddr =  &pDestParams->HwAddr;
    NIC1394_ADDRESS_TYPE    AddressType = pKeyHwAddr->AddressType;

    if (pD->Params.HwAddr.AddressType == AddressType)
    {
        if (AddressType == NIC1394AddressType_FIFO)
        {
            if (pKeyHwAddr->FifoAddress.UniqueID == pD->Params.HwAddr.FifoAddress.UniqueID
             && pKeyHwAddr->FifoAddress.Off_Low == pD->Params.HwAddr.FifoAddress.Off_Low
             && pKeyHwAddr->FifoAddress.Off_High == pD->Params.HwAddr.FifoAddress.Off_High)
            {
                return TRUE;
            }
        }
        else if (AddressType == NIC1394AddressType_Channel)
        {
            if (pKeyHwAddr->Channel == pD->Params.HwAddr.Channel)
            {
                if (pDestParams->ReceiveOnly ==  pD->Params.ReceiveOnly)
                {
                    return TRUE;
                }
            }
        }
        else if (AddressType == NIC1394AddressType_MultiChannel)
        {
            return TRUE;
        }
        else if (AddressType == NIC1394AddressType_Ethernet)
        {
            return TRUE;
        }
    }

    return FALSE;
}

ULONG
arpDestinationHash(
    PVOID           pKey
    )
/*++

Routine Description:

    Hash function responsible for returning a hash of pKey, which
    we expect to be pointer to a NIC1394_DESTINATION HW address.
    IMPORTANT: Since that address is a union of channel or Fifo (different sizes),
        we expect that the structure was first zero'd out (no uninitialized bits).
    We expect this pointer to be quadword aligned.

Arguments:

    pKey        - Actually a pointer to a  ARP_DEST_KEY structure.

Return Value:

    ULONG-sized hash of pKey.

--*/
{
    ULONG *pu = (ULONG*) pKey;

    // We expect both channel and fifo are at the beginning of the structure,
    // and the structure is atleast 2 dwords.
    // NOTE: we only look at the HwAddr field of ARP_DEST_PARAMS, so both
    // send and receive destinations will hash to the same value. Big deal.
    //
    ASSERT(
        FIELD_OFFSET(ARP_DEST_PARAMS,  HwAddr) == 0 &&
        FIELD_OFFSET(NIC1394_DESTINATION,  FifoAddress) == 0 &&
        FIELD_OFFSET(NIC1394_DESTINATION,  Channel) == 0     &&
        sizeof(NIC1394_DESTINATION) >= 2*sizeof(*pu));

    
    // Return 1st DWORD xor 2nd DWORD
    //
    return pu[0] ^ pu[1];
}


BOOLEAN
arpDhcpTableCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Hash comparison function for ARPCB_DEST.

Arguments:

    pKey        - Actually a pointer to the xid .
    pItem       - Points to ARPCB_DEST.Hdr.HashLink.

Return Value:

    TRUE IFF the key (HW address) exactly matches the key of the specified 
    Dest object.

--*/
{
    ARP1394_ETH_DHCP_ENTRY  *pEntry = 
        CONTAINING_RECORD(pItem, ARP1394_ETH_DHCP_ENTRY  , Hdr.HashLink);

    if (pEntry->xid== (*(PULONG)pKey))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


ULONG
arpDhcpTableHash (
    PVOID           pKey
    )
/*++

Routine Description:

    

Arguments:

    pKey        - Actually a pointer to a  Xid of a dhcp transaction .

Return Value:

    ULONG-sized hash of pKey.

--*/
{
    ULONG *pu = (ULONG*) pKey;

    return (*pu);
}

// arpLocalIp_HashInfo contains information required maintain a hashtable
// of ARPCB_LOCAL_IP objects.
//
RM_HASH_INFO
arpLocalIp_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    arpLocalIpCompareKey,   // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    arpIpAddressHash        // pfnHash

};


// arpRemoteIp_HashInfo contains information required maintain a hashtable
// of ARPCB_REMOTE_IP objects.
//
RM_HASH_INFO
arpRemoteIp_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    arpRemoteIpCompareKey,  // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    arpIpAddressHash        // pfnHash

};


// arpRemoteIp_HashInfo contains information required maintain a hashtable
// of ARPCB_REMOTE_IP objects.
//
RM_HASH_INFO
arpRemoteEth_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    arpRemoteEthCompareKey, // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    arpIpAddressHash        // pfnHash

};

// arpDestination_HashInfo contains information required maintain a hashtable
// of ARPCB_DEST objects.
//
RM_HASH_INFO
arpDestination_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    arpDestinationCompareKey,   // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    arpDestinationHash      // pfnHash

};


// arpRemoteDest_HashInfo contains information required maintain a hashtable
// of ARPCB_REMOTE_IP objects.
//
RM_HASH_INFO
arpRemoteDest_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    arpRemoteDestCompareKey, // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    arpRemoteDestHash        // pfnHash
};


// arpRemoteDest_HashInfo contains information required maintain a hashtable
// of ARPCB_REMOTE_IP objects.
//
RM_HASH_INFO
arpDhcpTable_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    arpDhcpTableCompareKey, // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    arpDhcpTableHash        // pfnHash
};

// ArpGlobal_LocalIpStaticInfo contains static information about
// objects of type ARPCB_LOCAL_IP.
//
RM_STATIC_OBJECT_INFO
ArpGlobal_LocalIpStaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "LocalIp",  // TypeName
    0, // Timeout

    arpLocalIpCreate,   // pfnCreate
    arpLocalIpDelete,       // pfnDelete
    NULL, // pfnVerifyLock

    0,    // Size of resource table
    NULL, // ResourceTable

    &arpLocalIp_HashInfo
};


// ArpGlobal_RemoteIpStaticInfo contains static information about
// objects of type ARPCB_REMOTE_IP.
//
RM_STATIC_OBJECT_INFO
ArpGlobal_RemoteIpStaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "RemoteIp", // TypeName
    0, // Timeout

    arpRemoteDestCreate,  // pfnCreate
    arpRemoteIpDelete,      // pfnDelete
    NULL, // pfnVerifyLock

    0,    // Size of resource table
    NULL, // ResourceTable

    &arpRemoteDest_HashInfo
};


// ArpGlobal_RemoteEthStaticInfo contains static information about
// objects of type ARPCB_REMOTE_ETH.
//
RM_STATIC_OBJECT_INFO
ArpGlobal_RemoteEthStaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "RemoteEth",    // TypeName
    0, // Timeout

    arpRemoteEthCreate,     // pfnCreate
    arpRemoteEthDelete,         // pfnDelete
    NULL, // pfnVerifyLock

    0,    // Size of resource table
    NULL, // ResourceTable

    &arpRemoteEth_HashInfo
};

// ArpGlobal_DestinationStaticInfo contains static information about
// objects of type ARPCB_DEST.
//
RM_STATIC_OBJECT_INFO
ArpGlobal_DestinationStaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "Destination",  // TypeName
    0, // Timeout

    arpDestinationCreate,   // pfnCreate
    arpDestinationDelete,       // pfnDelete
    NULL, // pfnVerifyLock

    0,    // Size of resource table
    NULL, // ResourceTable

    &arpDestination_HashInfo
};

RM_STATIC_OBJECT_INFO
ArpGlobal_RemoteDestStaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "RemoteIp", // TypeName
    0, // Timeout

    arpRemoteDestCreate,  // pfnCreate
    arpRemoteDestDelete,      // pfnDelete
    NULL, // pfnVerifyLock

    0,    // Size of resource table
    NULL, // ResourceTable

    &arpRemoteDest_HashInfo
};

RM_STATIC_OBJECT_INFO
ArpGlobal_DhcpTableStaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "DhcpTableEntry", // TypeName
    0, // Timeout

    arpDhcpTableEntryCreate,  // pfnCreate
    arpDhcpTableEntryDelete,      // pfnDelete
    NULL, // pfnVerifyLock

    0,    // Size of resource table
    NULL, // ResourceTable

    &arpDhcpTable_HashInfo 
};

NDIS_STATUS
arpTaskDeactivateInterface(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
Routine Description:

    Task handler responsible for deactivating an IP interface (but leaving
    it allocated and linked to the adapter).

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused
--*/
{
    NDIS_STATUS         Status;
    PARP1394_INTERFACE  pIF;
    PTASK_DEACTIVATE_IF pShutdownTask;
    UINT                Stage;
    PARP1394_ADAPTER    pAdapter;
    enum
    {
        STAGE_Start,
        STAGE_StopMaintenanceTask,
        STAGE_CleanupVcComplete,
        STAGE_CloseLocalIpGroup,
        STAGE_CloseRemoteIpGroup,
        STAGE_CloseRemoteEthGroup,
        STAGE_CloseRemoteDhcpGroup,
        STAGE_CloseDestinationGroup,
        STAGE_SwitchedToPassive,
        STAGE_CloseAF,
        STAGE_CloseIp,
        STAGE_End
    };
    ENTER("TaskDeactivateInterface", 0x1a34699e)

    Status              = NDIS_STATUS_FAILURE;
    pIF                 = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pTask);
    pShutdownTask       = (PTASK_DEACTIVATE_IF) pTask;
    pAdapter            = (PARP1394_ADAPTER) RM_PARENT_OBJECT(pIF);


    // 
    // Message normalizing code
    //
    switch(Code)
    {

        case RM_TASKOP_START:
            Stage = STAGE_Start;
            break;

        case  RM_TASKOP_PENDCOMPLETE:
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            Stage = RM_PEND_CODE(pTask);
            break;

        case RM_TASKOP_END:
            Status = (NDIS_STATUS) UserParam;
            Stage= STAGE_End;
            break;

        default:
            ASSERT(FALSE);
            return NDIS_STATUS_FAILURE;                 // ** EARLY RETURN **

    }

    switch(Stage)
    {
        case STAGE_Start:
        {


            // There should NOT be another activate/deactivate task running
            // on this interface. Why? Because an activate/deactivate task is ONLY
            // started in the context of the active primary task, and there can be
            // ONLY one active primary task on this IF at any one time.
            //
            TIMESTAMP("===DeinitIF:Starting");

            LOCKOBJ(pIF, pSR);
            if (pIF->pActDeactTask != NULL)
            {
                ASSERT(!"pIF->pActDeactTask != NULL");
                UNLOCKOBJ(pIF, pSR);
                Status = NDIS_STATUS_FAILURE;
                break;
            }
            arpSetSecondaryIfTask(pIF, pTask, ARPIF_AS_DEACTIVATING, pSR);
            UNLOCKOBJ(pIF, pSR);


            //
            // Stop the IF maintenance task if it's running.
            //
            Status =  arpTryStopIfMaintenanceTask(
                            pIF,
                            pTask,
                            STAGE_StopMaintenanceTask,
                            pSR
                            );
        }           

        if (PEND(Status)) break;

        // FALL THROUGH

        case STAGE_StopMaintenanceTask:
        {
            LOCKOBJ(pIF, pSR);

            TIMESTAMP("===DeinitIF:MaintenanceTask stopped");
            // Unlink the explicit reference of the broadcast channel destination
            // from the interface.
            //
            if (pIF->pBroadcastDest != NULL)
            {
                PARPCB_DEST pBroadcastDest = pIF->pBroadcastDest;
                pIF->pBroadcastDest = NULL;
    
                // NOTE: We're unlinking the two with the IF lock (which is
                // is the same as the pBroadcastDest's lock) held.
                // This is OK to do.
                //
    
            #if RM_EXTRA_CHECKING
                RmUnlinkObjectsEx(
                    &pIF->Hdr,
                    &pBroadcastDest->Hdr,
                    0x66bda49b,
                    ARPASSOC_LINK_IF_OF_BCDEST,
                    ARPASSOC_LINK_BCDEST_OF_IF,
                    pSR
                    );
            #else // !RM_EXTRA_CHECKING
                RmUnlinkObjects(&pIF->Hdr, &pBroadcastDest->Hdr, pSR);
            #endif // !RM_EXTRA_CHECKING
    
            }

            //
            // If the VC state needs cleaning up, we need to get a task
            // going to clean it up. Other wise we fake the completion of this
            // stage so that we move on to the next...
            //
            if (pIF->recvinfo.VcHdr.NdisVcHandle == NULL)
            {
                UNLOCKOBJ(pIF, pSR);
                Status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                PRM_TASK pCleanupCallTask = pIF->recvinfo.VcHdr.pCleanupCallTask;


                // If there is already an official cleanup-vc task, we pend on it.
                // Other wise we allocate our own, pend on it, and start it.
                //
                if (pCleanupCallTask != NULL)
                {
                    TR_WARN((
                        "IF %p Cleanup-vc task %p exists; pending on it.\n",
                         pIF,
                         pCleanupCallTask));
                    RmTmpReferenceObject(&pCleanupCallTask->Hdr, pSR);
    
                    UNLOCKOBJ(pIF, pSR);
                    RmPendTaskOnOtherTask(
                        pTask,
                        STAGE_CleanupVcComplete,
                        pCleanupCallTask,
                        pSR
                        );

                    RmTmpDereferenceObject(&pCleanupCallTask->Hdr, pSR);
                    Status = NDIS_STATUS_PENDING;
                }
                else
                {
                    //
                    // Start the call cleanup task and pend on int.
                    //
                    UNLOCKOBJ(pIF, pSR);

                    Status = arpAllocateTask(
                                &pIF->Hdr,                  // pParentObject,
                                arpTaskCleanupRecvFifoCall, // pfnHandler,
                                0,                          // Timeout,
                                "Task: CleanupRecvFifo on shutdown IF", // szDescrip.
                                &pCleanupCallTask,
                                pSR
                                );
                

                    if (FAIL(Status))
                    {
                        // Couldn't allocate task.
                        //
                        TR_WARN(("FATAL: couldn't alloc cleanup call task!\n"));
                    }
                    else
                    {
                        Status = RmPendTaskOnOtherTask(
                                    pTask,
                                    STAGE_CleanupVcComplete,
                                    pCleanupCallTask,
                                    pSR
                                    );
                        ASSERT(!FAIL(Status));
                
                        // RmStartTask uses up the tmpref on the task
                        // which was added by arpAllocateTask.
                        //
                        Status = RmStartTask(
                                    pCleanupCallTask,
                                    0, // UserParam (unused)
                                    pSR
                                    );
                        // We rely on pending status to decide whether
                        // or not to fall through to the next stage.
                        //
                        Status = NDIS_STATUS_PENDING;
                    }
                }
            }
        }

        if (PEND(Status)) break;

        // FALL THROUGH 

        case STAGE_CleanupVcComplete:
        {
            TIMESTAMP("===DeinitIF:RecvFifo cleanup complete");
            // Initiate unload of all the items in the LocalIpGroup.
            //
            OBJLOG1(pTask, "    Unloading LocalIpGroup 0x%p\n",
                        &pIF->LocalIpGroup);
            RmUnloadAllObjectsInGroup(
                        &pIF->LocalIpGroup,
                        arpAllocateTask,
                        arpTaskUnloadLocalIp,
                        NULL,   // userParam
                        pTask, // pTask to unpend when the unload completes.
                        STAGE_CloseLocalIpGroup,      // uTaskPendCode
                        pSR
                        );

            Status = NDIS_STATUS_PENDING;
        }
        break;

        case STAGE_CloseLocalIpGroup:
        {
            // Initiate unload of all the items in the RemoteIpGroup.
            //
            TIMESTAMP("===DeinitIF:LocalIp objects cleaned up.");
            OBJLOG1(
                pTask,
                "    Unloading RemoteIpGroup 0x%p\n",
                &pIF->RemoteIpGroup
                );
            RmUnloadAllObjectsInGroup(
                        &pIF->RemoteIpGroup,
                        arpAllocateTask,
                        arpTaskUnloadRemoteIp,
                        NULL,   // userParam
                        pTask, // pTask to unpend when the unload is complete.
                        STAGE_CloseRemoteIpGroup,     // uTaskPendCode
                        pSR
                        );

            Status = NDIS_STATUS_PENDING;
        }
        break;

        case STAGE_CloseRemoteIpGroup:
        {

            if (ARP_BRIDGE_ENABLED(pAdapter))
            {

                // Initiate unload of all the items in the RemoteEthGroup.
                //
                TIMESTAMP("===DeinitIF:RemoteIp objects cleaned up.");
                OBJLOG1(
                    pTask,
                    "    Unloading RemoteEthGroup 0x%p\n",
                    &pIF->RemoteEthGroup
                    );
                RmUnloadAllObjectsInGroup(
                            &pIF->RemoteEthGroup,
                            arpAllocateTask,
                            arpTaskUnloadRemoteEth,
                            NULL,   // userParam
                            pTask, // pTask to unpend when the unload is complete.
                            STAGE_CloseRemoteEthGroup,    // uTaskPendCode
                            pSR
                            );

                Status = NDIS_STATUS_PENDING;
                break;
            }
            else
            {
                // Bridging not enabled ...
                // FALL THROUGH....
            }
        }

        case STAGE_CloseRemoteEthGroup:
        {
            // Initiate unload of all the items in the DestinationGroup.
            //
            
            if (ARP_BRIDGE_ENABLED(pAdapter))
            {

                TIMESTAMP("===DeinitIF:RemoteEth Dhcp objects cleaned up.");
                OBJLOG1(pTask, "    Unloading EthDhcpGroup 0x%p\n",
                            &pIF->EthDhcpGroup);

                RmUnloadAllObjectsInGroup(
                            &pIF->EthDhcpGroup,
                            arpAllocateTask,
                            arpTaskUnloadEthDhcpEntry,
                            NULL,   // userParam
                            pTask, // pTask to unpend when the unload is complete.
                            STAGE_CloseRemoteDhcpGroup,      // uTaskPendCode
                            pSR
                            );

                Status = NDIS_STATUS_PENDING;
                break;
            }
            else
            {
                // Bridging not enabled ...
                // FALL THROUGH....
            }
         }

        case STAGE_CloseRemoteDhcpGroup:
        {
            // Initiate unload of all the items in the DestinationGroup.
            //
            TIMESTAMP("===DeinitIF:RemoteIp objects cleaned up.");
            OBJLOG1(pTask, "    Unloading DestinationGroup 0x%p\n",
                        &pIF->DestinationGroup);
            RmUnloadAllObjectsInGroup(
                        &pIF->DestinationGroup,
                        arpAllocateTask,
                        arpTaskUnloadDestination,
                        NULL,   // userParam
                        pTask, // pTask to unpend when the unload is complete.
                        STAGE_CloseDestinationGroup,      // uTaskPendCode
                        pSR
                        );

            Status = NDIS_STATUS_PENDING;
        }
        break;

        
        case STAGE_CloseDestinationGroup:
        {
            //
            // Unlink the special "destination VCs"
            //
            LOCKOBJ(pIF, pSR);

            TIMESTAMP("===DeinitIF:Destination objects cleaned up.");

            if (pIF->pMultiChannelDest != NULL)
            {
                PARPCB_DEST pMultiChannelDest = pIF->pMultiChannelDest;
                pIF->pMultiChannelDest = NULL;
    
                // NOTE: We're unlinking the two with the IF lock (which is
                // is the same as the pBroadcastDest's lock) held.
                // This is OK to do.
                //
    
            #if RM_EXTRA_CHECKING
                RmUnlinkObjectsEx(
                    &pIF->Hdr,
                    &pMultiChannelDest->Hdr,
                    0xf28090bd,
                    ARPASSOC_LINK_IF_OF_MCDEST,
                    ARPASSOC_LINK_MCDEST_OF_IF,
                    pSR
                    );
            #else // !RM_EXTRA_CHECKING
                RmUnlinkObjects(&pIF->Hdr, &pMultiChannelDest->Hdr, pSR);
            #endif // !RM_EXTRA_CHECKING
    
            }

            if (pIF->pEthernetDest != NULL)
            {
                PARPCB_DEST pEthernetDest = pIF->pEthernetDest;
                pIF->pEthernetDest = NULL;
    
                // NOTE: We're unlinking the two with the IF lock (which is
                // is the same as the pBroadcastDest's lock) held.
                // This is OK to do.
                //
    
            #if RM_EXTRA_CHECKING
                RmUnlinkObjectsEx(
                    &pIF->Hdr,
                    &pEthernetDest->Hdr,
                    0xf8eedcd1,
                    ARPASSOC_LINK_IF_OF_ETHDEST,
                    ARPASSOC_LINK_ETHDEST_OF_IF,
                    pSR
                    );
            #else // !RM_EXTRA_CHECKING
                RmUnlinkObjects(&pIF->Hdr, &pEthernetDest->Hdr, pSR);
            #endif // !RM_EXTRA_CHECKING
    
            }

            UNLOCKOBJ(pIF, pSR);

            // If required, switch to passive. This check should obviously be done
            // without any locks held!
            if (!ARP_ATPASSIVE())
            {
                // We're not at passive level, but we need to be when we
                // call IP's del interface. So we switch to passive...
                //
                RmSuspendTask(pTask, STAGE_SwitchedToPassive, pSR);
                RmResumeTaskAsync(pTask, 0, &pShutdownTask->WorkItem, pSR);
                Status = NDIS_STATUS_PENDING;
            }
            else
            {
                Status = NDIS_STATUS_SUCCESS;
            }
        }

        if (PEND(Status)) break;

        // FALL THROUGH

        case STAGE_SwitchedToPassive:
        {
            PVOID IpContext;

            TIMESTAMP("===DeinitIF:Switched to Passive(if we aren't already).");
            // We're now switched to passive
            //
            ASSERT(ARP_ATPASSIVE());

            // If required, del the IP interface.
            //
                
            LOCKOBJ(pIF, pSR);
            IpContext = pIF->ip.Context;

            if (IpContext == NULL)
            {

                // Pretend that we're waiting on IpClose because
                // we fall through below.
                //
                pShutdownTask->fPendingOnIpClose = TRUE;
                UNLOCKOBJ(pIF, pSR);

                Status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                ASSERT(!ARP_BRIDGE_ENABLED(pAdapter));
                pIF->ip.Context = NULL;
                ASSERT(!pShutdownTask->fPendingOnIpClose);

                // Note: a task's lock is it's parent's lock, and this task's
                // parent is pIF...
                //
                pShutdownTask->fPendingOnIpClose = TRUE;
                UNLOCKOBJ(pIF, pSR);

                // We'll suspend this task, waiting for our ArpIpClose routine to
                // be called...
                //
                RmSuspendTask(pTask, STAGE_CloseIp, pSR);

                TIMESTAMP("===DeinitIF:Calling IP's DellInterface Rtn");
                ArpGlobals.ip.pDelInterfaceRtn(
                    IpContext
                    ,TRUE  // DeleteIndex (unused)
                    );

                Status = NDIS_STATUS_PENDING;
            }
        }
        
        if (PEND(Status)) break;

        // FALL THROUGH

        case STAGE_CloseIp:
        {
            NDIS_HANDLE NdisAfHandle;

            TIMESTAMP("===DeinitIF:Done with deleting IP interface (if there was one)");
            //
            // IP has called our arpIpClose function (if we'd bound to IP)
            // NOTE: Task's locks actually are their parent's locks,
            // which in this case is pIF;
            //
            // We're done with all VCs, etc. Time to close the AF, if it's open.
            //

            LOCKOBJ(pTask, pSR);
            ASSERT(pShutdownTask->fPendingOnIpClose);
            pShutdownTask->fPendingOnIpClose = FALSE;
            NdisAfHandle = pIF->ndis.AfHandle;
            pIF->ndis.AfHandle = NULL;
            UNLOCKOBJ(pTask, pSR);
    
            if (NdisAfHandle == NULL)
            {
                Status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                //
                // (Debug) Delete the association we added when the
                // address family was opened.
                //
                DBG_DELASSOC(
                    &pIF->Hdr,                  // pObject
                    NdisAfHandle,               // Instance1
                    NULL,                       // Instance2
                    ARPASSOC_IF_OPENAF,         // AssociationID
                    pSR
                    );

                //
                // Suspend task and call NdisCloseAdapter...
                //
                RmSuspendTask(pTask, STAGE_CloseAF, pSR);
                RM_ASSERT_NOLOCKS(pSR);
                TIMESTAMP("===DeinitIF: Calling NdisClCloseAddressFamily");
                Status = NdisClCloseAddressFamily(
                            NdisAfHandle
                            );
        
                if (Status != NDIS_STATUS_PENDING)
                {
                    ArpCoCloseAfComplete(
                            Status,
                            (NDIS_HANDLE)pIF
                            );
                    Status = NDIS_STATUS_PENDING;
                }
            }
        }
        
        if (PEND(Status)) break;

        // FALL THROUGH

        case STAGE_CloseAF:
        {

            //
            // The close AF operation is complete.
            // We've not got anything else to do.
            //
            TIMESTAMP("===DeinitIF: Done with CloseAF");

            // Recover the last status ...
            //
            Status = (NDIS_STATUS) UserParam;

            // Status of the completed operation can't itself be pending!
            //
            ASSERT(Status != NDIS_STATUS_PENDING);

            //
            // By returning Status != pending, we implicitly complete
            // this task.
            //
        }
        break;

        case STAGE_End:
        {
            //
            // We are done with all async aspects of shutting down the interface.
            // Nothing to do besides clearing the actdeact task.
            //
            LOCKOBJ(pIF, pSR);
            arpClearSecondaryIfTask(pIF, pTask, ARPIF_AS_FAILEDACTIVATE, pSR);
            UNLOCKOBJ(pIF, pSR);

            TIMESTAMP("===DeinitIF: All done!");

            // Force status to be success
            //
            Status = NDIS_STATUS_SUCCESS;
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Stage)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskDeinitInterface(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
Routine Description:

    Task handler responsible for deinitializing and deleting an interface.

Arguments:

    UserParam   for (Code ==  RM_TASKOP_START)          : unused
    
--*/
{
    NDIS_STATUS         Status;
    PARP1394_INTERFACE  pIF;
    MYBOOL              fTryInitiateUnload;
    enum
    {
        PEND_ExistingPrimaryTaskComplete,
        PEND_DeactivateIfComplete
    };
    ENTER("TaskDeinitInterface", 0xf059b63b)

    Status              = NDIS_STATUS_FAILURE;
    pIF                 = (PARP1394_INTERFACE) RM_PARENT_OBJECT(pTask);
    fTryInitiateUnload  = FALSE;

    switch(Code)
    {
        case RM_TASKOP_START:
        {
            fTryInitiateUnload = TRUE;
        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            switch(RM_PEND_CODE(pTask))
            {
                case PEND_ExistingPrimaryTaskComplete:
                {
                    fTryInitiateUnload = TRUE;
                }
                break;

                case PEND_DeactivateIfComplete:
                {
                    ASSERT(pIF->pPrimaryTask == pTask);

                    // We're done deactivating the IF. We actually delete the IF
                    // in the context of the END handler...
                    //
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;
            }
        }
        break;

        case RM_TASKOP_END:
        {
            //
            // We are done with all async aspects of unloading the interface.
            // Now on to synchronous cleanup and deallocation...
            //

            ARP1394_ADAPTER *   pAdapter;

            // Nothing to do if we're not the active primary task.
            //
            if (pIF->pPrimaryTask != pTask)
            {
                // We should only get here if pIF was unloaded by someone else....
                //
                ASSERT(RM_IS_ZOMBIE(pIF));
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);

            LOCKOBJ(pAdapter, pSR);

            // Remove linkage to adapter. Note: pIF lock is the adapter lock.
            //
            pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
            ASSERT(pIF->Hdr.pLock == pAdapter->Hdr.pLock);
            ASSERT(pAdapter->pIF == pIF);
            pAdapter->pIF = NULL;

            // Clear ourselves as the primary task of the interface object.
            //
            arpClearPrimaryIfTask(pIF, pTask, ARPIF_PS_DEINITED, pSR);

            // Deallocate the IF (adapter lock must be held when calling this)
            //
            arpDeleteInterface(pIF, pSR);

            UNLOCKOBJ(pAdapter, pSR);

            // Force status to be success
            //
            Status = NDIS_STATUS_SUCCESS;
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)


    if (fTryInitiateUnload)
    {
        LOCKOBJ(pIF, pSR);
        if (pIF->pPrimaryTask!=NULL)
        {
            //
            // There is an existing primary task -- we wait for it to complete.
            //
            PRM_TASK pPrimaryTask = pIF->pPrimaryTask;
            RmTmpReferenceObject(&pPrimaryTask->Hdr, pSR);
            UNLOCKOBJ(pIF,pSR);
            RmPendTaskOnOtherTask(
                pTask,
                PEND_ExistingPrimaryTaskComplete,
                pPrimaryTask,
                pSR
                );
            arpTryAbortPrimaryIfTask(pIF, pSR);
            RmTmpDereferenceObject(&pPrimaryTask->Hdr, pSR);
            Status = NDIS_STATUS_PENDING;
        }
        else  if (!RM_IS_ZOMBIE(pIF))
        {
            //
            // There is no primary task currently, and the IF is not already
            // been unloaded -- make pTask the primary task,
            // and initiate deactivation of  the IF. When it's done, we'll actually
            // delete the IF.
            //
            arpSetPrimaryIfTask(pIF, pTask, ARPIF_PS_DEINITING, pSR);
            UNLOCKOBJ(pIF,pSR);
            arpDeactivateIf(pIF, pTask, PEND_DeactivateIfComplete, pSR);
            Status = NDIS_STATUS_PENDING;
        }
        else
        {
            // pIF is already unloaded....
            //
            UNLOCKOBJ(pIF, pSR);
            Status = NDIS_STATUS_SUCCESS;
        }
    }

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskReinitInterface(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
Routine Description:

    Task handler responsible for reiniting (deactivating, then activating)
    an interface.

    This is a primary interface task.

Arguments:

    UserParam   for (Code ==  RM_TASKOP_START)          : unused
    
--*/
{
    NDIS_STATUS         Status;
    PARP1394_INTERFACE  pIF;
    MYBOOL              fTryInitiateReinit;
    enum
    {
        PEND_ExistingPrimaryTaskComplete,
        PEND_DeactivateIfComplete,
        PEND_ActivateIfComplete,
        PEND_DeinitInterfaceOnFailureComplete
    };
    ENTER("TaskReinitInterface", 0x8b670f05)
    Status              = NDIS_STATUS_FAILURE;
    pIF                 = (PARP1394_INTERFACE) RM_PARENT_OBJECT(pTask);
    fTryInitiateReinit  = FALSE;

    switch(Code)
    {
        case RM_TASKOP_START:
        {
            fTryInitiateReinit = TRUE;
        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            Status = (NDIS_STATUS) UserParam;

            switch(RM_PEND_CODE(pTask))
            {
                case PEND_ExistingPrimaryTaskComplete:
                {
                    fTryInitiateReinit = TRUE;
                }
                break;

                case PEND_DeactivateIfComplete:
                {
                    //
                    // We're done deactivating the IF. We now
                    // activate the IF.
                    //
                    arpActivateIf(pIF, pTask, PEND_ActivateIfComplete, pSR);
                    Status = NDIS_STATUS_PENDING;
                }
                break;

                case PEND_ActivateIfComplete:
                {
                    // We're done activating the IF. 
                    //
                    LOCKOBJ(pIF, pSR);
                    if (FAIL(Status))
                    {
                        arpClearPrimaryIfTask(pIF, pTask, ARPIF_PS_FAILEDINIT, pSR);
                        UNLOCKOBJ(pIF, pSR);

                        arpDeinitIf(
                                pIF,
                                pTask,          //  pCallingTask
                                PEND_DeinitInterfaceOnFailureComplete,
                                pSR
                                );
                        Status = NDIS_STATUS_PENDING;
                    }
                    else
                    {
                        // 
                        // Successful activation. Clear the primary task
                        // and set the primary state appropriately.
                        //
                        arpClearPrimaryIfTask(pIF, pTask, ARPIF_PS_INITED, pSR);
                        UNLOCKOBJ(pIF, pSR);
                    }

                } // end case PEND_ActivateIfComplete
                break;
    
                case  PEND_DeinitInterfaceOnFailureComplete:
                {
                    // We expect pIF to be deallocated...
                    //
                    ASSERT(RM_IS_ZOMBIE(pIF));

                    //
                    // We ignore the return status of deinit inteface.
                    // and set Status to failure, because it is
                    // the reinit interface task that is failing.
                    //
                    Status = NDIS_STATUS_FAILURE;
                }
                break;
            }
        }
        break;

        case RM_TASKOP_END:
        {
            PARP1394_ADAPTER    pAdapter;
            PTASK_REINIT_IF     pReinitTask;

            pAdapter    = (PARP1394_ADAPTER) RM_PARENT_OBJECT(pIF);
            pReinitTask = (PTASK_REINIT_IF) pTask;
            Status = (NDIS_STATUS) UserParam;

            if (FAIL(Status))
            {
                ASSERT(RM_IS_ZOMBIE(pIF));
            }
            ASSERT(pIF->pPrimaryTask != pTask);

            //
            // IF the reconfig event is non NULL, signal completion of the net pnp
            // event that started this
            // reconfig task. No need to claim any locks here -- the fields
            // referenced below are not going to change...
            //
            if (pReinitTask->pNetPnPEvent != NULL)
            {
                NdisCompletePnPEvent(
                    Status,
                    pAdapter->bind.AdapterHandle,
                    pReinitTask->pNetPnPEvent
                    );
            }
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)


    if (fTryInitiateReinit)
    {
        LOCKOBJ(pIF, pSR);
        if (pIF->pPrimaryTask!=NULL)
        {
            //
            // There is an existing primary task -- we wait for it to complete.
            //
            PRM_TASK pPrimaryTask = pIF->pPrimaryTask;
            RmTmpReferenceObject(&pIF->pPrimaryTask->Hdr, pSR);
            UNLOCKOBJ(pIF,pSR);
            RmPendTaskOnOtherTask(
                pTask,
                PEND_ExistingPrimaryTaskComplete,
                pPrimaryTask,
                pSR
                );
            RmTmpDereferenceObject(&pIF->pPrimaryTask->Hdr, pSR);
            Status = NDIS_STATUS_PENDING;
        }
        else
        {
            //
            // There is no primary task currently -- make pTask the primary task,
            // and initiate deactivation of  the IF. When it's done, we'll
            // reactivate the IF.
            //
            arpSetPrimaryIfTask(pIF, pTask, ARPIF_PS_REINITING, pSR);
            UNLOCKOBJ(pIF,pSR);
            arpDeactivateIf(pIF, pTask, PEND_DeactivateIfComplete, pSR);
            Status = NDIS_STATUS_PENDING;
        }
    }

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskUnloadLocalIp(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    )
/*++
Routine Description:

    Task handler responsible for shutting down an IP interface.

    3/26/1999 JosephJ    TODO -- this being one of the earlier-written tasks,
    is ripe for a re-write!

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused
--*/
{
    ENTER("TaskUnloadLocalIp", 0xf42aaa68)
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARPCB_LOCAL_IP* pLocalIp    = (ARPCB_LOCAL_IP*) RM_PARENT_OBJECT(pTask);
    ARP1394_INTERFACE *pIF = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pLocalIp);

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_OtherUnloadComplete,
        PEND_AddressRegistrationComplete
    };

    switch(Code)
    {

        case RM_TASKOP_START:
        {
            LOCKOBJ(pLocalIp, pSR);

            // First check if pLocalIp is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pLocalIp))
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            //
            // pLocalIp is allocated. Now check if there is already a
            // shutdown task attached to pLocalIp.
            //
            if (pLocalIp->pUnloadTask != NULL)
            {
                //
                // There is a shutdown task. We pend on it.
                //

                PRM_TASK pOtherTask = pLocalIp->pUnloadTask;
                TR_WARN(("Unload task %p exists; pending on it.\n", pOtherTask));
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pLocalIp, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_OtherUnloadComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // There is no unload task going on. Let's
            // make this task THE unload task.
            // 
            pLocalIp->pUnloadTask = pTask;

            //
            // Since we're THE unload task, add an association to pLocalIp,
            // which will only get cleared when the pLocalIp->pUnloadTask field
            // above is cleared.
            //
            DBG_ADDASSOC(
                &pLocalIp->Hdr,                     // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_LOCALIP_UNLOAD_TASK,       // AssociationID
                "    Official unload task 0x%p (%s)\n", // szFormat
                pSR
                );

            //
            // If there is a registration task going, we cancel it and
            // wait for it to complete.
            //
            if (pLocalIp->pRegistrationTask != NULL)
            {
                PRM_TASK pOtherTask = pLocalIp->pRegistrationTask;
                TR_WARN(("Registration task %p exists; pending on it.\n", pOtherTask));
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);

                UNLOCKOBJ(pLocalIp, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_AddressRegistrationComplete,
                    pOtherTask,
                    pSR
                    );
                //
                // TODO  Cancel Registration task (we haven't implemented cancel
                // yet!)
                //
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // We're here because there is no async unload work to be done.
            // We simply return and finish synchronous cleanup in the END
            // handler for this task.
            //
            Status = NDIS_STATUS_SUCCESS;
            
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {

            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_OtherUnloadComplete:
                {
        
                    //
                    // There was another unload task going when we started, and
                    // it's now complete. Nothing for us to do...
                    //
                    // TODO need standard way to propagate the error code.
                    //
                    Status = (NDIS_STATUS) UserParam;
                }
                break;
    
    
                case  PEND_AddressRegistrationComplete:
                {
                    //
                    // There was address-registration going on, but how it's
                    // complete. We should be able to synchronously clean up
                    // this task now
                    //

                    //
                    // If we're here, that means we're THE official unload
                    // task. Let's assert that fact.
                    // (no need to get the lock on the object).
                    //
                    ASSERTEX(pLocalIp->pUnloadTask == pTask, pLocalIp);

                    Status      = NDIS_STATUS_SUCCESS;
                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            LOCKOBJ(pLocalIp, pSR);

            //
            // We're done. There should be no async activities left to do.
            //
            ASSERTEX(pLocalIp->pRegistrationTask == NULL, pLocalIp);

            //
            // If we're THE unload task, we go on and deallocate the object.
            //
            if (pLocalIp->pUnloadTask == pTask)
            {
                PARPCB_DEST pDest = pLocalIp->pDest;

                //
                // pLocalIp had better not be in a zombie state -- THIS task
                // is the one responsible for deallocating the object!
                //
                ASSERTEX(!RM_IS_ZOMBIE(pLocalIp), pLocalIp);

                if (pDest != NULL)
                {
                    RmTmpReferenceObject(&pDest->Hdr, pSR);
                    arpUnlinkLocalIpFromDest(pLocalIp, pSR);
                }

                pLocalIp->pUnloadTask = NULL;

                // Delete the association we added when we set
                // pLocalIp->pUnloadTask to pTask.
                //
                DBG_DELASSOC(
                    &pLocalIp->Hdr,                     // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_LOCALIP_UNLOAD_TASK,       // AssociationID
                    pSR
                    );

                RmFreeObjectInGroup(
                    &pIF->LocalIpGroup,
                    &(pLocalIp->Hdr),
                    NULL,               // NULL pTask == synchronous.
                    pSR
                    );

                ASSERTEX(RM_IS_ZOMBIE(pLocalIp), pLocalIp);

                UNLOCKOBJ(pLocalIp, pSR);

                //
                // If we were linked to a pDest, we unload it if it's
                // no longer used by anyone else.
                //
                if (pDest != NULL)
                {
                    arpDeinitDestination(pDest, TRUE, pSR); // TRUE==only if
                                                              // unused.

                    RmTmpDereferenceObject(&pDest->Hdr, pSR);
                }
            }
            else
            {
                //
                // We weren't THE unload task, nothing left to do.
                // The object had better be in the zombie state..
                //

                ASSERTEX(
                    pLocalIp->pUnloadTask == NULL && RM_IS_ZOMBIE(pLocalIp),
                    pLocalIp
                    );
                Status = NDIS_STATUS_SUCCESS;
            }

            Status = (NDIS_STATUS) UserParam;
        }
        break; // RM_TASKOP_END:

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskUnloadRemoteIp(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
    This task is responsible for shuttingdown and eventually deleting a remote IP
    object.

    It goes through the following stages:
        - Cancel any ongoing address resolution and wait for that to complete.
        - Unlink itself from a Destination object, if it's linked to one.
        - Remove itself from the interface's LocalIpGroup (and thereby deallocate
          itself).
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    ENTER("TaskUnloadRemoteIp", 0xf42aaa68)
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARPCB_REMOTE_IP*    pRemoteIp   = (ARPCB_REMOTE_IP*) RM_PARENT_OBJECT(pTask);
    ARP1394_INTERFACE *pIF = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pRemoteIp);

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_AtPassiveLevel,
        PEND_OtherUnloadComplete,   
        PEND_SendPktsComplete,
        PEND_ResolutionComplete
    };

    switch(Code)
    {

        case RM_TASKOP_START:
        {
            LOCKOBJ(pRemoteIp, pSR);

            // First check if pRemoteIp is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pRemoteIp))
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }


            //
            // pRemoteIp is allocated. Now check if there is already a
            // shutdown task attached to pRemoteIp.
            //
            if (pRemoteIp->pUnloadTask != NULL)
            {
                //
                // There is a shutdown task. We pend on it.
                //

                PRM_TASK pOtherTask = pRemoteIp->pUnloadTask;
                TR_WARN(("Unload task %p exists; pending on it.\n", pOtherTask));
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pRemoteIp, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_OtherUnloadComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // There is no unload task going on. Let's
            // make this task THE unload task.
            // 
            pRemoteIp->pUnloadTask = pTask;

            //
            // Since we're THE unload task, add an association to pRemoteIp,
            // which will only get cleared when the  pRemoteIp->pUnloadTask field
            // above is cleared.
            //
            DBG_ADDASSOC(
                &pRemoteIp->Hdr,                    // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_REMOTEIP_UNLOAD_TASK,      // AssociationID
                "    Official unload task 0x%p (%s)\n", // szFormat
                pSR
                );


            //
            // if we are at dpc level then resume at passive
            //
            
            RmSuspendTask(pTask, PEND_AtPassiveLevel, pSR);

            UNLOCKOBJ(pRemoteIp,pSR);
            
            Status = NDIS_STATUS_PENDING;


            if (!ARP_ATPASSIVE())
            {

                // We're not at passive level, . So we switch to passive...
                //
                RmResumeTaskAsync(
                    pTask,
                    Status,
                    &((TASK_UNLOAD_REMOTE*)pTask)->WorkItem,
                    pSR
                    );
            }
            else
            {   
                // We resume right away if we are already at passive
                RmResumeTask(pTask,PEND_AtPassiveLevel,pSR);
            }

            
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            switch(RM_PEND_CODE(pTask))
            {
                case PEND_AtPassiveLevel:
                {
                    LOCKOBJ (pRemoteIp, pSR);
                    //
                    // If there is a SendPkts task going, we cancel it and
                    // wait for it to complete.
                    // WARNING: We only do this check and wait ONCE. So we RELY
                    // on the fact that once there is a NONNULL pRemoteIp->pUnloadTask,
                    // NO NEW pSendPktsTasks will bind itself to pRemoteIP. If you
                    // look at the code for  arpTaskSendPktsOnRemoteIp,  you will
                    // see that it does not bind itself if pRemoteIp->pUnloadTask is nonnull
                    //
                    if (pRemoteIp->pSendPktsTask != NULL)
                    {
                        PRM_TASK pOtherTask = pRemoteIp->pSendPktsTask;
                        TR_WARN(("SendPkts task %p exists; pending on it.\n", pOtherTask));
                        RmTmpReferenceObject(&pOtherTask->Hdr, pSR);

                        UNLOCKOBJ(pRemoteIp, pSR);
                        RmPendTaskOnOtherTask(
                            pTask,
                            PEND_SendPktsComplete,
                            pOtherTask,
                            pSR
                            );
                        //
                        // TODO  Cancel SendPks task (we haven't implemented cancel
                        // yet!)
                        //
                        RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                        Status = NDIS_STATUS_PENDING;
                        break;
                    }

                    //
                    // We're here because there is no async unload work to be done.
                    // We simply return and finish synchronous cleanup in the END
                    // handler for this task.
                    //
                    if (pRemoteIp->pResolutionTask != NULL)
                    {
                        PRM_TASK pOtherTask = pRemoteIp->pResolutionTask ;
                        TR_WARN(("Resolution task %p exists; pending on it.\n", pOtherTask));
                        RmTmpReferenceObject(&pOtherTask->Hdr, pSR);

                        UNLOCKOBJ(pRemoteIp, pSR);
                        RmPendTaskOnOtherTask(
                            pTask,
                            PEND_ResolutionComplete,
                            pOtherTask,
                            pSR
                            );

                        RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                        Status = NDIS_STATUS_PENDING;
                        break;
            
                    }

                    //
                    // If there were no tasks pending then we have completed our task.
                    //
                    Status = NDIS_STATUS_SUCCESS;
                    
                }
                break;
                case  PEND_OtherUnloadComplete:
                {
        
                    //
                    // There was another unload task going when we started, and
                    // it's now complete. Nothing for us to do...
                    //
                    // TODO need standard way to propagate the error code.
                    //
                    Status = (NDIS_STATUS) UserParam;
                }
                break;
    
                case  PEND_SendPktsComplete:
                {
                    //
                    // There was a SendPktsTask going on, but how it's
                    // complete. We should be able to synchronously clean up
                    // this task now
                    //

                    //
                    // If we're here, that means we're THE official unload
                    // task. Let's assert that fact.
                    // (no need to get the lock on the object).
                    //
                    ASSERT(pRemoteIp->pUnloadTask == pTask);

                    Status      = NDIS_STATUS_SUCCESS;
                }
                break;

                case PEND_ResolutionComplete:
                {
                    //
                    // There was a resolution Task going on, but how it's
                    // complete. We should be able to synchronously clean up
                    // this task now
                    //

                    //
                    // If we're here, that means we're THE official unload
                    // task. Let's assert that fact.
                    // (no need to get the lock on the object).
                    //
                    ASSERT(pRemoteIp->pUnloadTask == pTask);

                    Status      = NDIS_STATUS_SUCCESS;

                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            LOCKOBJ(pRemoteIp, pSR);

            //
            // We're done. There should be no async activities left to do.
            //
            ASSERTEX(pRemoteIp->pResolutionTask == NULL, pRemoteIp);
            ASSERTEX(pRemoteIp->pSendPktsTask == NULL, pRemoteIp);

            //
            // If we're THE unload task, we go on and deallocate the object.
            //
            if (pRemoteIp->pUnloadTask == pTask)
            {
                PARPCB_DEST pDest = pRemoteIp->pDest;

                //
                // pRemoteIp had better not be in a zombie state -- THIS task
                // is the one responsible for deallocating the object!
                //
                ASSERTEX(!RM_IS_ZOMBIE(pRemoteIp), pRemoteIp);

                if (pDest != NULL)
                {
                    RmTmpReferenceObject(&pDest->Hdr, pSR);
                    arpUnlinkRemoteIpFromDest(pRemoteIp, pSR);
                }
                pRemoteIp->pUnloadTask = NULL;

                // Del  the association between pRCE and pRemoteIp...
                //
                ARP_WRITELOCK_IF_SEND_LOCK(pIF, pSR);

                arpDelRceList(pRemoteIp, pSR);   

                ARP_UNLOCK_IF_SEND_LOCK(pIF, pSR);
                

                RmFreeObjectInGroup(
                    &pIF->RemoteIpGroup,
                    &(pRemoteIp->Hdr),
                    NULL,               // NULL pTask == synchronous.
                    pSR
                    );

                ASSERTEX(RM_IS_ZOMBIE(pRemoteIp), pRemoteIp);
                     
                // Delete the association we added when we set
                // pRemoteIp->pUnloadTask to pTask.
                //
                DBG_DELASSOC(
                    &pRemoteIp->Hdr,                    // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_REMOTEIP_UNLOAD_TASK,      // AssociationID
                    pSR
                    );

                UNLOCKOBJ(pRemoteIp, pSR);

                //
                // If we were linked to a pDest, we unload it if it's
                // no longer used by anyone else.
                //
                if (pDest != NULL)
                {
                    arpDeinitDestination(pDest, TRUE, pSR); // TRUE==only if
                                                              // unused.

                    RmTmpDereferenceObject(&pDest->Hdr, pSR);
                }
            }
            else
            {
                //
                // We weren't THE unload task, nothing left to do.
                // The object had better be in the zombie state..
                //

                ASSERTEX(
                    pRemoteIp->pUnloadTask == NULL && RM_IS_ZOMBIE(pRemoteIp),
                    pRemoteIp
                    );
                Status = NDIS_STATUS_SUCCESS;
            }

            Status = (NDIS_STATUS) UserParam;
        }
        break; // RM_TASKOP_END:

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    EXIT()

    return Status;
}



NDIS_STATUS
arpTaskUnloadRemoteEth(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
    This task is responsible for shuttingdown and eventually deleting a remote IP
    object.

    It goes through the following stages:
        - Cancel any ongoing address resolution and wait for that to complete.
        - Unlink itself from a Destination object, if it's linked to one.
        - Remove itself from the interface's LocalIpGroup (and thereby deallocate
          itself).
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    ENTER("TaskUnloadRemoteEth", 0xf42aaa68)
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARPCB_REMOTE_ETH*   pRemoteEth  = (ARPCB_REMOTE_ETH*) RM_PARENT_OBJECT(pTask);
    ARP1394_INTERFACE *pIF = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pRemoteEth);

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_AtPassiveLevel,
        PEND_OtherUnloadComplete
    };

    switch(Code)
    {

        case RM_TASKOP_START:
        {
            LOCKOBJ(pRemoteEth, pSR);

            // First check if pRemoteEth is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pRemoteEth))
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            //
            // pRemoteEth is allocated. Now check if there is already a
            // shutdown task attached to pRemoteEth.
            //
            if (pRemoteEth->pUnloadTask != NULL)
            {
                //
                // There is a shutdown task. We pend on it.
                //

                PRM_TASK pOtherTask = pRemoteEth->pUnloadTask;
                TR_WARN(("Unload task %p exists; pending on it.\n", pOtherTask));
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pRemoteEth, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_OtherUnloadComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // There is no unload task going on. Let's
            // make this task THE unload task.
            // 
            pRemoteEth->pUnloadTask = pTask;

            //
            // Since we're THE unload task, add an association to pRemoteEth,
            // which will only get cleared when the  pRemoteEth->pUnloadTask field
            // above is cleared.
            //
            DBG_ADDASSOC(
                &pRemoteEth->Hdr,                   // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_REMOTEETH_UNLOAD_TASK,     // AssociationID
                "    Official unload task 0x%p (%s)\n", // szFormat
                pSR
                );

            //
            // We're here because there is no async unload work to be done.
            
            //
            // if we are at dpc level then resume at passive
            //
            
            RmSuspendTask(pTask, PEND_AtPassiveLevel, pSR);

            UNLOCKOBJ(pRemoteEth,pSR);
            
            Status = NDIS_STATUS_PENDING;


            if (!ARP_ATPASSIVE())
            {

                // We're not at passive level, . So we switch to passive...
                //
                RmResumeTaskAsync(
                    pTask,
                    Status,
                    &((TASK_UNLOAD_REMOTE*)pTask)->WorkItem,
                    pSR
                    );
            }
            else
            {   
                // We resume right away if we are already at passive
                RmResumeTask(pTask,PEND_AtPassiveLevel,pSR);
            }


            
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_AtPassiveLevel:
                {

                    //
                    Status = NDIS_STATUS_SUCCESS;

                }
                break;
                case  PEND_OtherUnloadComplete:
                {
        
                    //
                    // There was another unload task going when we started, and
                    // it's now complete. Nothing for us to do...
                    //
                    // TODO need standard way to propagate the error code.
                    //
                    Status = (NDIS_STATUS) UserParam;
                }
                break;
    

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            LOCKOBJ(pRemoteEth, pSR);

            //
            // We're done. There should be no async activities left to do.
            //

            //
            // If we're THE unload task, we go on and deallocate the object.
            //
            if (pRemoteEth->pUnloadTask == pTask)
            {
                //
                // pRemoteEth had better not be in a zombie state -- THIS task
                // is the one responsible for deallocating the object!
                //
                ASSERTEX(!RM_IS_ZOMBIE(pRemoteEth), pRemoteEth);

                pRemoteEth->pUnloadTask = NULL;

                RmFreeObjectInGroup(
                    &pIF->RemoteEthGroup,
                    &(pRemoteEth->Hdr),
                    NULL,               // NULL pTask == synchronous.
                    pSR
                    );

                ASSERTEX(RM_IS_ZOMBIE(pRemoteEth), pRemoteEth);
                     
                // Delete the association we added when we set
                // pRemoteEth->pUnloadTask to pTask.
                //
                DBG_DELASSOC(
                    &pRemoteEth->Hdr,                   // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_REMOTEETH_UNLOAD_TASK,     // AssociationID
                    pSR
                    );

                UNLOCKOBJ(pRemoteEth, pSR);

            }
            else
            {
                //
                // We weren't THE unload task, nothing left to do.
                // The object had better be in the zombie state..
                //

                ASSERTEX(
                    pRemoteEth->pUnloadTask == NULL && RM_IS_ZOMBIE(pRemoteEth),
                    pRemoteEth
                    );
                Status = NDIS_STATUS_SUCCESS;
            }

            Status = (NDIS_STATUS) UserParam;
        }
        break; // RM_TASKOP_END:

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    EXIT()

    return Status;
}

NDIS_STATUS
arpTaskUnloadDestination(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for unloading a destination.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    ENTER("TaskUnloadDestination", 0x93f66831)
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARPCB_DEST* pDest   = (ARPCB_DEST*) RM_PARENT_OBJECT(pTask);
    ARP1394_INTERFACE *pIF = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pDest);

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_OtherUnloadComplete,
        PEND_CleanupVcComplete
    };

    switch(Code)
    {

        case RM_TASKOP_START:
        {
            LOCKOBJ(pDest, pSR);

            // First check if pDest is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pDest))
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            //
            // pDest is allocated. Now check if there is already a
            // shutdown task attached to pDest.
            //
            if (pDest->pUnloadTask != NULL)
            {
                //
                // There is a shutdown task. We pend on it.
                //

                PRM_TASK pOtherTask = pDest->pUnloadTask;
                TR_WARN(("Unload task %p exists; pending on it.\n", pOtherTask));
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pDest, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_OtherUnloadComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // There is no unload task going on. Let's
            // make this task THE unload task.
            // 
            pDest->pUnloadTask = pTask;

            //
            // Since we're THE unload task, add an association to pDest,
            // which will only get cleared when the  pDest->pUnloadTask field
            // above is cleared.
            //
            DBG_ADDASSOC(
                &pDest->Hdr,                        // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_DEST_UNLOAD_TASK,      // AssociationID
                "    Official unload task 0x%p (%s)\n", // szFormat
                pSR
                );

            //
            // If the VC state needs cleaning up, we need to get a task
            // going to clean it up.
            //
            if (arpNeedToCleanupDestVc(pDest))
            {
                PRM_TASK pCleanupCallTask = pDest->VcHdr.pCleanupCallTask;

                // If there is already an official cleanup-vc task, we pend on it.
                // Other wise we allocate our own, pend on it, and start it.
                //
                if (pCleanupCallTask != NULL)
                {
                    TR_WARN((
                        "Cleanup-vc task %p exists; pending on it.\n",
                         pCleanupCallTask));
                    RmTmpReferenceObject(&pCleanupCallTask->Hdr, pSR);
    
                    UNLOCKOBJ(pDest, pSR);
                    RmPendTaskOnOtherTask(
                        pTask,
                        PEND_CleanupVcComplete,
                        pCleanupCallTask,
                        pSR
                        );

                    RmTmpDereferenceObject(&pCleanupCallTask->Hdr, pSR);
                    Status = NDIS_STATUS_PENDING;
                    break;
                }
                else
                {
                    //
                    // Start the call cleanup task and pend on int.
                    //

                    UNLOCKOBJ(pDest, pSR);
                    RM_ASSERT_NOLOCKS(pSR);

                    Status = arpAllocateTask(
                                &pDest->Hdr,                // pParentObject,
                                arpTaskCleanupCallToDest,   // pfnHandler,
                                0,                          // Timeout,
                                "Task: CleanupCall on UnloadDest",  // szDescription
                                &pCleanupCallTask,
                                pSR
                                );
                
                    if (FAIL(Status))
                    {
                        TR_WARN(("FATAL: couldn't alloc cleanup call task!\n"));
                    }
                    else
                    {
                        RmPendTaskOnOtherTask(
                            pTask,
                            PEND_CleanupVcComplete,
                            pCleanupCallTask,               // task to pend on
                            pSR
                            );
                
                        // RmStartTask uses up the tmpref on the task
                        // which was added by arpAllocateTask.
                        //
                        Status = RmStartTask(
                                    pCleanupCallTask,
                                    0, // UserParam (unused)
                                    pSR
                                    );
                    }
                    break;
                }
            }

            //
            // We're here because there is no async unload work to be done.
            // We simply return and finish synchronous cleanup in the END
            // handler for this task.
            //
            Status = NDIS_STATUS_SUCCESS;
            
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {

            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_OtherUnloadComplete:
                {
        
                    //
                    // There was another unload task going when we started, and
                    // it's now complete. Nothing for us to do...
                    //
                    // TODO need standard way to propagate the error code.
                    //
                    Status = (NDIS_STATUS) UserParam;
                }
                break;
    
    
                case  PEND_CleanupVcComplete:
                {
                    //
                    // There was vc-cleanup to be done, but how it's
                    // complete. We should be able to synchronously clean up
                    // this task now
                    //

                #if DBG
                    LOCKOBJ(pDest, pSR);

                    ASSERTEX(!arpNeedToCleanupDestVc(pDest), pDest);

                    //
                    // If we're here, that means we're THE official unload
                    // task. Let's assert that fact.
                    //
                    ASSERT(pDest->pUnloadTask == pTask);

                    UNLOCKOBJ(pDest, pSR);
                #endif DBG

                    Status      = NDIS_STATUS_SUCCESS;
                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            LOCKOBJ(pDest, pSR);

            //
            // We're done. There should be no async activities left to do.
            //
            ASSERTEX(!arpNeedToCleanupDestVc(pDest), pDest);

            //
            // If we're THE unload task, we go on and deallocate the object.
            //
            if (pDest->pUnloadTask == pTask)
            {
                //
                // pDest had better not be in a zombie state -- THIS task
                // is the one responsible for deallocating the object!
                //
                ASSERTEX(!RM_IS_ZOMBIE(pDest), pDest);

                arpUnlinkAllRemoteIpsFromDest(pDest, pSR);

                RmFreeObjectInGroup(
                    &pIF->DestinationGroup,
                    &(pDest->Hdr),
                    NULL,               // NULL pTask == synchronous.
                    pSR
                    );

                ASSERTEX(RM_IS_ZOMBIE(pDest), pDest);

                     
                pDest->pUnloadTask = NULL;

                // Delete the association we added when we set
                // pDest->pUnloadTask to pTask.
                //
                DBG_DELASSOC(
                    &pDest->Hdr,                        // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_DEST_UNLOAD_TASK,      // AssociationID
                    pSR
                    );
            }
            else
            {
                //
                // We weren't THE unload task, nothing left to do.
                // The object had better be in the zombie state..
                //

                ASSERTEX(
                    pDest->pUnloadTask == NULL && RM_IS_ZOMBIE(pDest),
                    pDest
                    );
                Status = NDIS_STATUS_SUCCESS;
            }

            Status = (NDIS_STATUS) UserParam;
        }
        break; // RM_TASKOP_END:

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    EXIT()

    return Status;
}


// The following structure is to define a set of hard-coded arp entries...
//
typedef struct
{
    IP_ADDRESS              IpAddress;
    NIC1394_FIFO_ADDRESS    DestFifoAddr;

} UNICAST_REMOTE_IP_INFO;


// FakeDestinationsInfo contains information to setup a set of hard-coded 
// arp entries..
//
UNICAST_REMOTE_IP_INFO
FakeDestinationsInfo[] =
{
  //
  //{IpAddr,     {UniqueID, OffLow, OffHi}}
  //
#if 0
    {0x0100000a, {0, 0, 0x100}},    // 10.0.0.1 -> (0, 0, 0x100)
    {0x0200000a, {0, 0, 0x100}},    // 10.0.0.2
    {0x0300000a, {0, 0, 0x100}},    // 10.0.0.3
    {0x0400000a, {0, 0, 0x100}},    // 10.0.0.4
    {0x020000e0, {0, 0, 0x100}},    // 224.0.0.2 (mcast port)
    {0xff00000a, {0, 0, 0x100}},    // 10.0.0.-1 (local bcast)
    {0xffffffff, {0, 0, 0x100}},    // -1.-1.-1.-1 (bcast)
#endif //0

    {0, {0, 0, 0}}, // Must be last -- Indicates end.
};


VOID
arpAddStaticArpEntries(
    IN ARP1394_INTERFACE *pIF,  // LOCKING LOCKOUT
    IN PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Add static items into the RemoteIp group (the arp cache).
    TODO: we currently put in some fake entries.

--*/
{
    UNICAST_REMOTE_IP_INFO *pRemoteIpInfo;
    RM_DBG_ASSERT_LOCKED(&pIF->Hdr, pSR);

    for(
        pRemoteIpInfo =  FakeDestinationsInfo;
        pRemoteIpInfo->IpAddress != 0;
        pRemoteIpInfo++)
    {
        NDIS_STATUS Status;

        Status = arpAddOneStaticArpEntry(
                    pIF,
                    pRemoteIpInfo->IpAddress,
                    &pRemoteIpInfo->DestFifoAddr,
                    pSR
                    );
        if (FAIL(Status))
        {
            break;
        }
    }
}


VOID
arpLinkRemoteIpToDest(
    ARPCB_REMOTE_IP     *pRemoteIp, // LOCKIN LOCKOUT
    ARPCB_DEST          *pDest,     // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Link a remote IP entry (pRemoteIp) to the specified destination HW entry
    (pDest). Update the pRemoteIp's state to indicate that this
    is resolved.

--*/
{
    ENTER("arpLinkRemoteIpToDest", 0x3be06bc6)

    ARP_DUMP_MAPPING(
            pRemoteIp->IpAddress,
            (pDest==NULL)? NULL : &pDest->Params.HwAddr,
            "Linking Remote IP");

    TR_INFO(("Linking IP 0x%08lx to  Dest addr 0x%08lx\n",
                pRemoteIp->IpAddress,
                (UINT) pDest->Params.HwAddr.FifoAddress.UniqueID // Truncation
                ));

    RM_DBG_ASSERT_LOCKED(&pRemoteIp->Hdr, pSR);
    RM_DBG_ASSERT_LOCKED(&pDest->Hdr, pSR);

    if (pRemoteIp->pDest != NULL)
    {
        ASSERT(!"pRemoteIp->pDest != NULL");
    }
    else
    {
        pRemoteIp->pDest = pDest;
        InsertHeadList(&pDest->listIpToThisDest, &pRemoteIp->linkSameDest);
    #if RM_EXTRA_CHECKING
        RmLinkObjectsEx(
            &pRemoteIp->Hdr,
            &pDest->Hdr,
            0x597d0495,
            ARPASSOC_LINK_IPADDR_OF_DEST,
            "    REMOTE_IP of 0x%p (%s)\n",
            ARPASSOC_LINK_DEST_OF_IPADDR,
            "    DEST of 0x%p (%s)\n",
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmLinkObjects(&pRemoteIp->Hdr, &pDest->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

        // Now set the pRemoteIp state to reflect that it RESOLVED.
        //
        SET_REMOTEIP_RESOLVE_STATE(pRemoteIp, ARPREMOTEIP_RESOLVED);
    }

    EXIT()
}


VOID
arpUnlinkRemoteIpFromDest(
    ARPCB_REMOTE_IP     *pRemoteIp, // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Unlink the remote IP entry (pRemoteIp) from the destination HW entry its
    linked to. Clear pRemoteIp's resolved flag.

--*/
{
    ENTER("arpUnlinkRemoteIpFromDest", 0xc5809147)
    ARPCB_DEST          *pDest = pRemoteIp->pDest;
    
    ARP_DUMP_MAPPING(
            pRemoteIp->Key.IpAddress,
            (pDest==NULL)? NULL : &pDest->Params.HwAddr,
            "Unlink Remote IP");

    TR_INFO(("Unlinking IP 0x%p (Addr 0x%08lx) from  Dest 0x%p (addr 0x%08lx)\n",
                pRemoteIp,
                pRemoteIp->Key.IpAddress,
                pDest,
                (pDest==NULL)
                 ? 0
                 :((UINT) pDest->Params.HwAddr.FifoAddress.UniqueID) // Truncation
                ));
    if (pDest == NULL)
    {
        ASSERT(!"pRemoteIp->pDest == NULL");
    }
    else
    {
        //
        // We assume that both objects share the same lock.
        //
        ASSERT(pRemoteIp->Hdr.pLock == pDest->Hdr.pLock);

        RM_DBG_ASSERT_LOCKED(&pRemoteIp->Hdr, pSR);

        RemoveEntryList(&pRemoteIp->linkSameDest);

        pRemoteIp->pDest = NULL;
    
        // Now set the pRemoteIp state to reflect that it UNRESOLVED.
        //
        SET_REMOTEIP_RESOLVE_STATE(pRemoteIp, ARPREMOTEIP_UNRESOLVED);

    #if RM_EXTRA_CHECKING
        RmUnlinkObjectsEx(
            &pRemoteIp->Hdr,
            &pDest->Hdr,
            0x5ad067aa,
            ARPASSOC_LINK_IPADDR_OF_DEST,
            ARPASSOC_LINK_DEST_OF_IPADDR,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmUnlinkObjects(&pRemoteIp->Hdr, &pDest->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

    }

    EXIT()
}

VOID
arpUnlinkAllRemoteIpsFromDest(
    ARPCB_DEST  *pDest, // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Unlink all RemoteIps (if any) from destination pDest.

--*/
{
    ENTER("arpUnlinkAllRemoteIpsFromDest", 0x35120630)


    TR_INFO(("Unlinking All RemoteIps from  Dest 0x%p (addr 0x%08lx)\n",
                pDest,
                ((UINT) pDest->Params.HwAddr.FifoAddress.UniqueID) // Truncation
                ));

    RM_DBG_ASSERT_LOCKED(&pDest->Hdr, pSR);

    while (!IsListEmpty(&pDest->listIpToThisDest))
    {
        LIST_ENTRY *pLink;
        ARPCB_REMOTE_IP *pRemoteIp;

        pLink = RemoveHeadList(&pDest->listIpToThisDest);
        pRemoteIp = CONTAINING_RECORD(
                    pLink,
                    ARPCB_REMOTE_IP,
                    linkSameDest
                    );
        arpUnlinkRemoteIpFromDest(pRemoteIp, pSR);
    }

    EXIT()
}

VOID
arpLinkLocalIpToDest(
    ARPCB_LOCAL_IP  *pLocalIp,  // LOCKIN LOCKOUT
    ARPCB_DEST          *pDest,     // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Link a remote IP entry (pLocalIp) to the specified destination HW entry
    (pDest). Update the pLocalIp's state to indicate that this
    is resolved.

--*/
{
    ENTER("arpLinkLocalIpToDest", 0x3be06bc6)

    ARP_DUMP_MAPPING(pLocalIp->IpAddress, &pDest->Params.HwAddr, "Linking Local IP");

#if 0
    TR_INFO(("Linking Local IP 0x%08lx to  Dest addr 0x%08lx\n",
                pLocalIp->IpAddress,
                (UINT) pDest->Params.HwAddr.FifoAddress.UniqueID // Truncation
                ));
#endif // 0

    RM_DBG_ASSERT_LOCKED(&pLocalIp->Hdr, pSR);
    RM_DBG_ASSERT_LOCKED(&pDest->Hdr, pSR);

    if (pLocalIp->pDest != NULL)
    {
        ASSERT(!"pLocalIp->pDest != NULL");
    }
    else
    {
        //
        // LocalIps may only be linked to pDests of type
        // ReceiveOnly.
        //
        ASSERT(pDest->Params.ReceiveOnly);

        pLocalIp->pDest = pDest;
        InsertHeadList(&pDest->listLocalIp, &pLocalIp->linkSameDest);
    #if RM_EXTRA_CHECKING
        RmLinkObjectsEx(
            &pLocalIp->Hdr,
            &pDest->Hdr,
            0x597d0495,
            ARPASSOC_LINK_IPADDR_OF_DEST,
            "    LOCAL_IP of 0x%p (%s)\n",
            ARPASSOC_LINK_DEST_OF_IPADDR,
            "    DEST of Local 0x%p (%s)\n",
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmLinkObjects(&pLocalIp->Hdr, &pDest->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

    }

    EXIT()
}


VOID
arpUnlinkLocalIpFromDest(
    ARPCB_LOCAL_IP  *pLocalIp,  // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Unlink the local IP entry (pLocalIp) from the destination HW entry its
    linked to.

--*/
{
    ENTER("arpUnlinkLocalIpFromDest", 0xc5809147)
    ARPCB_DEST          *pDest = pLocalIp->pDest;
    

    ARP_DUMP_MAPPING(
            pLocalIp->IpAddress,
            (pDest==NULL)? NULL : &pDest->Params.HwAddr,
            "Unlink Local IP");

    TR_INFO(("Unlinking Local IP 0x%p (Addr 0x%08lx) from  Dest 0x%p (addr 0x%08lx)\n",
                pLocalIp,
                pLocalIp->IpAddress,
                pDest,
                (pDest==NULL)
                 ? 0
                 :((UINT) pDest->Params.HwAddr.FifoAddress.UniqueID) // Truncation
                ));
    if (pDest == NULL)
    {
        ASSERT(!"pLocalIp->pDest == NULL");
    }
    else
    {
        //
        // We assume that both objects share the same lock.
        //
        ASSERT(pLocalIp->Hdr.pLock == pDest->Hdr.pLock);

        RM_DBG_ASSERT_LOCKED(&pLocalIp->Hdr, pSR);

        //
        // LocalIps may only be unlinked from pDests of type
        // ReceiveOnly.
        //
        ASSERT(pDest->Params.ReceiveOnly);

        RemoveEntryList(&pLocalIp->linkSameDest);

    #if RM_EXTRA_CHECKING
        RmUnlinkObjectsEx(
            &pLocalIp->Hdr,
            &pDest->Hdr,
            0x5ad067aa,
            ARPASSOC_LINK_IPADDR_OF_DEST,
            ARPASSOC_LINK_DEST_OF_IPADDR,
            pSR
            );
    #else // !RM_EXTRA_CHECKING
        RmUnlinkObjects(&pLocalIp->Hdr, &pDest->Hdr, pSR);
    #endif // !RM_EXTRA_CHECKING

        pLocalIp->pDest = NULL;
    
    }

    EXIT()
}

VOID
arpUnlinkAllLocalIpsFromDest(
    ARPCB_DEST  *pDest, // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Unlink all Localif any) from destination pDest.

--*/
{
    ENTER("arpUnlinkAllLocalIpsFromDest", 0x35120630)


    TR_INFO(("Unlinking All LocalIps from  Dest 0x%p (addr 0x%08lx)\n",
                pDest,
                ((UINT) pDest->Params.HwAddr.FifoAddress.UniqueID) // Truncation
                ));

    RM_DBG_ASSERT_LOCKED(&pDest->Hdr, pSR);

    //
    // LocalIps may only be unlinked from pDests of type
    // ReceiveOnly.
    //
    ASSERT(pDest->Params.ReceiveOnly);

    while (!IsListEmpty(&pDest->listLocalIp))
    {
        LIST_ENTRY *pLink;
        ARPCB_LOCAL_IP  *pLocalIp;

        pLink = RemoveHeadList(&pDest->listLocalIp);
        pLocalIp = CONTAINING_RECORD(
                    pLink,
                    ARPCB_LOCAL_IP,
                    linkSameDest
                    );
        arpUnlinkLocalIpFromDest(pLocalIp, pSR);
    }

    EXIT()
}


MYBOOL
arpNeedToCleanupDestVc(
        ARPCB_DEST *pDest   // LOCKING LOCKOUT
        )
/*++

Routine Description:

    Deterinine if we need to do any cleanup work on destination pDest.
    "Cleanup work" includes if there is any ongoing asynchronous activity
    involving pDest, such as a make call or close call in progress.

Return Value:

    TRUE    iff there is cleanup work to be done.
    FALSE   otherwise.

--*/
{
    // Note -- return true if  pDest->VcHdr.pCleanupCallTask is non-NULL, even if there
    // is nothing else to be done -- we do have to wait for this pCleanupCallTask
    // to complete.
    if (    pDest->VcHdr.pMakeCallTask != NULL
        ||  pDest->VcHdr.pCleanupCallTask!=NULL
        ||  pDest->VcHdr.NdisVcHandle!=NULL)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


PRM_OBJECT_HEADER
arpLocalIpCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    Allocate and initialize an object of type ARPCB_LOCAL_IP.

Arguments:

    pParentObject   - Actually a pointer to the interface (ARP1394_INTERFACE)
    pCreateParams   - Actually the IP address (not a pointer to the IP address)
                      to associate with this local IP.

Return Value:

    Pointer to the allocated and initialized object on success.
    NULL otherwise.

--*/
{
    ARPCB_LOCAL_IP *pLocalIp;
    PRM_OBJECT_HEADER pHdr;
    NDIS_STATUS Status;

    Status =  ARP_ALLOCSTRUCT(pLocalIp, MTAG_LOCAL_IP);

    if (Status != NDIS_STATUS_SUCCESS || pLocalIp== NULL)
    {
        return NULL;
    }

    ARP_ZEROSTRUCT(pLocalIp);

    pHdr = (PRM_OBJECT_HEADER) pLocalIp;
    ASSERT(pHdr == &pLocalIp->Hdr);

    // We expect the parent object to be the IF object!
    //
    ASSERT(pParentObject->Sig == MTAG_INTERFACE);
    

    if (pHdr)
    {

        RmInitializeHeader(
            pParentObject,
            pHdr,
            MTAG_LOCAL_IP,
            pParentObject->pLock,
            &ArpGlobal_LocalIpStaticInfo,
            NULL, // szDescription
            pSR
            );

            pLocalIp->IpAddress = (IP_ADDRESS) (UINT_PTR) pCreateParams;
    }
    return pHdr;
}


VOID
arpLocalIpDelete(
        PRM_OBJECT_HEADER pHdr,
        PRM_STACK_RECORD  pSR
        )
/*++

Routine Description:

    Free an object of type ARPCB_LOCAL_IP.

Arguments:

    pHdr    - Actually a pointer to the local ip object to be freed.

--*/
{
    ARPCB_LOCAL_IP *pLocalIp = (ARPCB_LOCAL_IP *) pHdr;
    ASSERT(pLocalIp->Hdr.Sig == MTAG_LOCAL_IP);
    pLocalIp->Hdr.Sig = MTAG_FREED;

    ARP_FREE(pHdr);
}

PRM_OBJECT_HEADER
arpRemoteIpCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    Allocate and initialize an object of type ARPCB_REMOTE_IP.

Arguments:

    pParentObject   - Actually a pointer to the interface (ARP1394_INTERFACE)
    pCreateParams   - Actually the IP address (not a pointer to the IP address)
                      to associate with this remote IP object.

Return Value:

    Pointer to the allocated and initialized object on success.
    NULL otherwise.

--*/
{
    ARPCB_REMOTE_IP *pRemoteIp;
    PRM_OBJECT_HEADER pHdr;
    NDIS_STATUS Status;  

    Status = ARP_ALLOCSTRUCT(pRemoteIp, MTAG_REMOTE_IP);

    if (Status != NDIS_STATUS_SUCCESS || pRemoteIp == NULL)
    {
        return NULL;
    }
    
    ARP_ZEROSTRUCT(pRemoteIp);

    pHdr = (PRM_OBJECT_HEADER) pRemoteIp;
    ASSERT(pHdr == &pRemoteIp->Hdr);

    // We expect the parent object to be the IF object!
    //
    ASSERT(pParentObject->Sig == MTAG_INTERFACE);
    

    if (pHdr)
    {
        RmInitializeHeader(
            pParentObject,
            pHdr,
            MTAG_REMOTE_IP,
            pParentObject->pLock,
            &ArpGlobal_RemoteIpStaticInfo,
            NULL, // szDescription
            pSR
            );

        pRemoteIp->IpAddress = (IP_ADDRESS) (UINT_PTR) pCreateParams;

        // Initialize  various other stuff...
        InitializeListHead(&pRemoteIp->sendinfo.listSendPkts);

        if (arpCanTryMcap(pRemoteIp->IpAddress))
        {
            SET_REMOTEIP_MCAP(pRemoteIp,  ARPREMOTEIP_MCAP_CAPABLE);
        }
    }
    return pHdr;
}


PRM_OBJECT_HEADER
arpRemoteEthCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    Allocate and initialize an object of type ARPCB_REMOTE_ETH.

Arguments:

    pParentObject   - Actually a pointer to the interface (ARP1394_INTERFACE)
    pCreateParams   - Points to a ARP_REMOTE_ETH_PARAMS structure
                      to associate with this remote IP object.

Return Value:

    Pointer to the allocated and initialized object on success.
    NULL otherwise.

--*/
{
    ARPCB_REMOTE_ETH *pRemoteEth;
    PARP_REMOTE_ETH_PARAMS pMyParams =  (PARP_REMOTE_ETH_PARAMS) pCreateParams;
    PRM_OBJECT_HEADER pHdr;
    NDIS_STATUS Status;

    Status = ARP_ALLOCSTRUCT(pRemoteEth, MTAG_REMOTE_ETH);

    if (Status != NDIS_STATUS_SUCCESS || pRemoteEth == NULL) 
    {
        return NULL;
    }
    
    ARP_ZEROSTRUCT(pRemoteEth);

    pHdr = (PRM_OBJECT_HEADER) pRemoteEth;
    ASSERT(pHdr == &pRemoteEth->Hdr);

    // We expect the parent object to be the IF object!
    //
    ASSERT(pParentObject->Sig == MTAG_INTERFACE);
    

    if (pHdr)
    {
        RmInitializeHeader(
            pParentObject,
            pHdr,
            MTAG_REMOTE_ETH,
            pParentObject->pLock,
            &ArpGlobal_RemoteEthStaticInfo,
            NULL, // szDescription
            pSR
            );

        pRemoteEth->IpAddress = pMyParams->IpAddress;
        pRemoteEth->EthAddress = pMyParams->EthAddress;

    }
    return pHdr;
}


VOID
arpRemoteIpDelete(
        PRM_OBJECT_HEADER pHdr,
        PRM_STACK_RECORD  pSR
        )
/*++

Routine Description:

    Free an object of type ARPCB_REMOTE_IP.

Arguments:

    pHdr    - Actually a pointer to the remote ip object to be freed.

--*/
{
    ARPCB_REMOTE_IP *pRemoteIp = (ARPCB_REMOTE_IP *) pHdr;
    ASSERT(pRemoteIp->Hdr.Sig == MTAG_REMOTE_IP);
    pRemoteIp->Hdr.Sig = MTAG_FREED;

    ARP_FREE(pHdr);
}


VOID
arpRemoteEthDelete(
        PRM_OBJECT_HEADER pHdr,
        PRM_STACK_RECORD  pSR
        )
/*++

Routine Description:

    Free an object of type ARPCB_REMOTE_IP.

Arguments:

    pHdr    - Actually a pointer to the remote ip object to be freed.

--*/
{
    ARPCB_REMOTE_ETH *pRemoteEth = (ARPCB_REMOTE_ETH *) pHdr;
    ASSERT(pRemoteEth->Hdr.Sig == MTAG_REMOTE_ETH);
    pRemoteEth->Hdr.Sig = MTAG_FREED;

    ARP_FREE(pHdr);
}

PRM_OBJECT_HEADER
arpDestinationCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    Allocate and initialize an object of type ARPCB_DEST.

Arguments:

    pParentObject   - Actually a pointer to the interface (ARP1394_INTERFACE)
    pCreateParams   - Actually a pointer to a ARP_DEST_KEY containing
                      the hw addresses to associate with this object.

Return Value:

    Pointer to the allocated and initialized object on success.
    NULL otherwise.

--*/
{
    ARPCB_DEST *pDest;
    PRM_OBJECT_HEADER pHdr;
    NDIS_STATUS Status;
    
    Status = ARP_ALLOCSTRUCT(pDest, MTAG_DEST);

    if (Status != NDIS_STATUS_SUCCESS || pDest == NULL)
    {
        return NULL;
    }
    
    ARP_ZEROSTRUCT(pDest);

    pHdr = (PRM_OBJECT_HEADER) pDest;
    ASSERT(pHdr == &pDest->Hdr);

    // We expect the parent object to be the IF object!
    //
    ASSERT(pParentObject->Sig == MTAG_INTERFACE);
    

    if (pHdr)
    {
        RmInitializeHeader(
            pParentObject,
            pHdr,
            MTAG_DEST,
            pParentObject->pLock,
            &ArpGlobal_DestinationStaticInfo,
            NULL, // szDescription
            pSR
            );

            pDest->Params = *((PARP_DEST_PARAMS) pCreateParams);

            InitializeListHead(&pDest->listIpToThisDest);
            InitializeListHead(&pDest->listLocalIp);

    }
    return pHdr;
}


VOID
arpDestinationDelete(
        PRM_OBJECT_HEADER pHdr,
        PRM_STACK_RECORD  pSR
        )
/*++

Routine Description:

    Free an object of type ARPCB_DEST.

Arguments:

    pHdr    - Actually a pointer to the destination object to be freed.

--*/
{
    ARPCB_DEST *pDest = (ARPCB_DEST *) pHdr;
    ASSERT(pDest->Hdr.Sig == MTAG_DEST);
    pDest->Hdr.Sig = MTAG_FREED;

    ARP_FREE(pHdr);
}



PRM_OBJECT_HEADER
arpDhcpTableEntryCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    Allocate and initialize an object of type ARPCB_REMOTE_IP.

Arguments:

    pParentObject   - Actually a pointer to the interface (ARP1394_INTERFACE)
    pCreateParams   - Actually the IP address (not a pointer to the IP address)
                      to associate with this remote IP object.

Return Value:

    Pointer to the allocated and initialized object on success.
    NULL otherwise.

--*/
{
    ENTER ("arpRemoteDestCreate", 0xa896311a)
    ARP1394_ETH_DHCP_ENTRY *pEntry = NULL;

    ULONG xid = *(PULONG)pCreateParams;
    PRM_OBJECT_HEADER pHdr;
    NDIS_STATUS Status;

    Status = ARP_ALLOCSTRUCT(pEntry, MTAG_ARP_GENERIC);

    if (Status != NDIS_STATUS_SUCCESS || pEntry == NULL)
    {
        return NULL;
    }
    
    ARP_ZEROSTRUCT(pEntry);

    pHdr = (PRM_OBJECT_HEADER) pEntry;
    ASSERT(pHdr == &pEntry->Hdr);

    // We expect the parent object to be the IF object!
    //
    ASSERT(pParentObject->Sig == MTAG_INTERFACE);
    

    if (pHdr)
    {
        RmInitializeHeader(
            pParentObject,
            pHdr,
            MTAG_ARP_GENERIC,
            pParentObject->pLock,
            &ArpGlobal_DhcpTableStaticInfo ,
            NULL, // szDescription
            pSR
            );

        TR_INFO( ("New XID %x \n", xid));
  
        // set up the key 
        pEntry->xid = xid;
        
    }
    EXIT()
    return pHdr;
}




VOID
arpDhcpTableEntryDelete(
        PRM_OBJECT_HEADER pHdr,
        PRM_STACK_RECORD  pSR
        )
/*++

Routine Description:

    Free an object of type ARPCB_REMOTE_IP.

Arguments:

    pHdr    - Actually a pointer to the remote ip object to be freed.

--*/
{
    ARP1394_ETH_DHCP_ENTRY *pEntry = (ARP1394_ETH_DHCP_ENTRY*) pHdr;
    ASSERT(pEntry->Hdr.Sig == MTAG_ARP_GENERIC);
    pEntry->Hdr.Sig = MTAG_FREED;

    ARP_FREE(pHdr);
}



NDIS_STATUS
arpTaskMakeCallToDest(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

    This task is responsible for making a call to a destination
    (either send-FIFO or send/recv-CHANNEL).

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          :  unused

--*/
{
    ENTER("TaskMakeCallToDest", 0x25108eaa)
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARPCB_DEST        * pDest   = (ARPCB_DEST*) RM_PARENT_OBJECT(pTask);
    ARP1394_INTERFACE * pIF     = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pDest);
    TASK_MAKECALL     * pMakeCallTask =  (TASK_MAKECALL*) pTask;

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_OtherMakeCallTaskComplete,
        PEND_MakeCallComplete
    };

    ASSERT(sizeof(ARP1394_TASK) >= sizeof(*pMakeCallTask));


    switch(Code)
    {
        case RM_TASKOP_START:
        {
            BOOLEAN IsFifo;
            PARP_STATIC_VC_INFO pVcStaticInfo;

            LOCKOBJ(pDest, pSR);

            DBGMARK(0x7a74bf2a);

            // First check if pDest is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pDest))
            {
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            // If there is a call cleanup task in progress, we fail right away... 
            //
            if (pDest->VcHdr.pCleanupCallTask != NULL)
            {
                OBJLOG2(
                    pDest,
                    "Failing MakeCall task %p because Cleanup task %p exists.\n",
                    pTask,
                    pDest->VcHdr.pCleanupCallTask
                    );
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            //
            // pDest is allocated. Now check if there is already a
            // MakeCall task attached to pDest.
            //
            if (pDest->VcHdr.pMakeCallTask != NULL)
            {
                //
                // There is a make-call task. We pend on it.
                //

                PRM_TASK pOtherTask = pDest->VcHdr.pMakeCallTask;
                OBJLOG1(
                    pTask,
                    "MakeCall task %p exists; pending on it.\n",
                    pOtherTask);

                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pDest, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_OtherMakeCallTaskComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // Grab the IF send lock and make sure we're in the position to make a
            // call -- there should be no VC handle.
            // We must do this BEFORE we become the official task, so that we don't
            // wipe out the connection as part of our cleanup.
            //
            ARP_WRITELOCK_IF_SEND_LOCK(pIF, pSR);
            if (pDest->VcHdr.NdisVcHandle != NULL)
            {
                OBJLOG1(
                 pTask,
                 "VcHandle 0x%p already exists!, failing make call attempt.\n",
                 pDest->VcHdr.NdisVcHandle);
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            ASSERT(pDest->sendinfo.OkToSend == FALSE);
            ASSERT(pDest->sendinfo.NumOutstandingSends == 0);

            //
            // There is no MakeCall task going on, and there's no VC handle. Let's
            // make this task THE MakeCall task.
            // 

            pDest->VcHdr.pMakeCallTask = pTask;

            //
            // Since we're THE MakeCall task, add an association to pDest,
            // which will only get cleared when the  pDest->VcHdr.pMakeCallTask field
            // above is cleared.
            //
            DBG_ADDASSOC(
                &pDest->Hdr,                        // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_DEST_MAKECALL_TASK,        // AssociationID
                "    Official makecall task 0x%p (%s)\n", // szFormat
                pSR
                );


            // Setup call params.
            //
            {
                PNIC1394_MEDIA_PARAMETERS p1394Params =
                            (PNIC1394_MEDIA_PARAMETERS)
                            &pMakeCallTask->MediaParams.Parameters;
                PNIC1394_DESTINATION    pDestAddr = &pDest->Params.HwAddr;

                //No need: ARP_ZEROSTRUCT(&pMakeCallTask->CallParams);
                //No need: ARP_ZEROSTRUCT(&pMakeCallTask->MediaParams);
                pMakeCallTask->CallParams.MediaParameters =
                                (PCO_MEDIA_PARAMETERS) &pMakeCallTask->MediaParams;
                pMakeCallTask->MediaParams.ParamType      = NIC1394_MEDIA_SPECIFIC;

                IsFifo = FALSE;

                switch(pDestAddr->AddressType)
                {
                case  NIC1394AddressType_Channel:
                    pMakeCallTask->MediaParams.Flags     = TRANSMIT_VC | RECEIVE_VC;
                    pVcStaticInfo = &g_ArpBroadcastChannelVcStaticInfo;
                    break;

                case  NIC1394AddressType_FIFO:
                    pMakeCallTask->MediaParams.Flags     = TRANSMIT_VC;
                    pVcStaticInfo = &g_ArpSendFifoVcStaticInfo;
                    IsFifo = TRUE;
                    break;

                case  NIC1394AddressType_MultiChannel:
                    pMakeCallTask->MediaParams.Flags     = RECEIVE_VC;
                    pVcStaticInfo = &g_ArpMultiChannelVcStaticInfo;
                    break;

                case  NIC1394AddressType_Ethernet:
                    pMakeCallTask->MediaParams.Flags     = TRANSMIT_VC | RECEIVE_VC;
                    pVcStaticInfo = &g_ArpEthernetVcStaticInfo;
                    break;

                default:
                    ASSERT(FALSE);
                    break;
                }


                TR_INFO(("Our Parameters offset = 0x%lx; Official offset = 0x%lx\n",
                    FIELD_OFFSET(ARP1394_CO_MEDIA_PARAMETERS,  Parameters),
                    FIELD_OFFSET(CO_MEDIA_PARAMETERS, MediaSpecific.Parameters)));
                    
                ASSERT(FIELD_OFFSET(ARP1394_CO_MEDIA_PARAMETERS,  Parameters)
                == FIELD_OFFSET(CO_MEDIA_PARAMETERS, MediaSpecific.Parameters));

                p1394Params->Destination        = *pDestAddr; // struct copy.
                p1394Params->Flags              = NIC1394_VCFLAG_FRAMED;
                p1394Params->MaxSendBlockSize   = -1; // (nic should pick)
                p1394Params->MaxSendSpeed       = -1; // (nic should pick)
                p1394Params->MTU                = ARP1394_ADAPTER_MTU;
                                                  // TODO --  make above based on
                                                  // config.
            }
            
            // Now create a vc and make the call...
            // 
            {
                RmUnlockAll(pSR);
                Status = arpInitializeVc(
                            pIF,
                            pVcStaticInfo,
                            &pDest->Hdr,
                            &pDest->VcHdr,
                            pSR
                            );
                if (FAIL(Status))
                {
                    break;
                }

                // Save away the fields within sendinfo...
                //
                ARP_WRITELOCK_IF_SEND_LOCK(pIF, pSR);
                pDest->sendinfo.OkToSend = FALSE;
                pDest->sendinfo.IsFifo  = IsFifo;
                ARP_UNLOCK_IF_SEND_LOCK(pIF, pSR);

                RmSuspendTask(pTask,  PEND_MakeCallComplete, pSR);

                DBGMARK(0xef9d8be3);

                //
                //  Make the Call now
                //
                if (IsFifo)
                {
                    LOGSTATS_TotalSendFifoMakeCalls(pIF);
                }
                else
                {
                    LOGSTATS_TotalChannelMakeCalls(pIF);
                }
                RM_ASSERT_NOLOCKS(pSR);
            #if ARPDBG_FAKE_CALLS
                Status = arpDbgFakeNdisClMakeCall(
                                pDest->VcHdr.NdisVcHandle,
                                &pMakeCallTask->CallParams,
                                NULL,               // ProtocolPartyContext
                                NULL,               // NdisPartyHandle
                                &pDest->Hdr,
                                &pDest->VcHdr,
                                pSR
                                );
            #else   // !ARPDBG_FAKE_CALLS
                Status = NdisClMakeCall(
                                pDest->VcHdr.NdisVcHandle,
                                &pMakeCallTask->CallParams,
                                NULL,               // ProtocolPartyContext
                                NULL                // NdisPartyHandle
                                );
            #endif  // !ARPDBG_FAKE_CALLS

        
                if (!PEND(Status))
                {
                    ArpCoMakeCallComplete(
                                Status,
                                (NDIS_HANDLE) (&pDest->VcHdr),
                                NULL,
                                &pMakeCallTask->CallParams
                                );
                    Status = NDIS_STATUS_PENDING;
                }
            }
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            switch(RM_PEND_CODE(pTask))
            {
                case   PEND_OtherMakeCallTaskComplete:
                {
        
                    //
                    // There was another makecall task going when we started, and
                    // it's now complete. Nothing for us to do...
                    //
                    Status = (NDIS_STATUS) UserParam;
                }
                break;
    
    
                case PEND_MakeCallComplete:
                {
                    //
                    // The make call is complete. We're done...
                    //
                    Status = (NDIS_STATUS) UserParam;

                #if ARPDBG_FAKE_CALLS
                    //
                    // In the fake case, we give the "user" the opportunity to change
                    // the status to Success for the special VC (BROADCAST
                    // MCAP, ETHERNET) make call fails,
                    // because otherwise the adapter bind itself is going to fail.
                    //
                    // We do this even in the retail build (if ARPDBG_FAKE_CALLS is
                    // enabled).
                    //
                    if ((1 || FAIL(Status)) && !pDest->sendinfo.IsFifo)
                    {
                        // To try the failure path of the BC make call, enable
                        // the if 0 code. Currently we change status to success
                        // so that stress tests which include loading/unloading
                        // of the driver will run without breaking here everytime.
                        //
                    #if 1
                        DbgPrint(
                            "A13: Fake %s failed. &Status=%p.\n",
                            pDest->VcHdr.pStaticInfo->Description,
                            &Status
                            );
                        DbgBreakPoint();
                    #else
                        Status = NDIS_STATUS_SUCCESS;
                    #endif
                    }
                #endif  // ARPDBG_FAKE_CALLS

                    LOCKOBJ(pDest, pSR);
                    ASSERT (pDest->VcHdr.pMakeCallTask == pTask);

                    ASSERT(pDest->VcHdr.NdisVcHandle != NULL);
    
                    ARP_WRITELOCK_IF_SEND_LOCK(pIF, pSR);

                    DBGMARK(0xd50a6864);


                    if (FAIL(Status))
                    {
                        pDest->sendinfo.OkToSend     = FALSE;
                    }
                    else
                    {
                        //
                        // Success! Packets can now be sent over this VC without
                        // further ado.
                        //
                        pDest->sendinfo.OkToSend     = TRUE;
                    }

                    RmUnlockAll(pSR);

                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            Status = (NDIS_STATUS) UserParam;

            LOCKOBJ(pDest, pSR);

            if (pDest->VcHdr.pMakeCallTask == pTask)
            {
                //
                // We're the official pMakeCallTask
                //

                // Delete the association we added when we set
                // pDest->VcHdr.pMakeCallTask to pTask.
                //
                DBG_DELASSOC(
                    &pDest->Hdr,                        // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_DEST_MAKECALL_TASK,        // AssociationID
                    pSR
                    );

                // Remove reference to us in pDest.
                //
                pDest->VcHdr.pMakeCallTask = NULL;

                if (FAIL(Status) && pDest->VcHdr.NdisVcHandle != NULL)
                {
                    UNLOCKOBJ(pDest, pSR);

                    // WARNING: the above completely nukes out pDest.VcHdr.
                    //
                    arpDeinitializeVc(pIF, &pDest->VcHdr, &pDest->Hdr, pSR);
                }
            }
        }
        break;

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskCleanupCallToDest(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
        This task is responsible for cleaning up a previously-made call to a
        destination.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    ENTER("TaskCleanupCallToDest", 0xc89dfb47)
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARPCB_DEST        * pDest   = (ARPCB_DEST*) RM_PARENT_OBJECT(pTask);
    ARP1394_INTERFACE * pIF     = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pDest);
    MYBOOL              fCloseCall = FALSE;
    NDIS_HANDLE         NdisVcHandle = NULL;

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_OtherCleanupTaskComplete,
        PEND_OutstandingSendsComplete,
        PEND_CloseCallComplete
    };

    DBGMARK(0x6198198e);

    switch(Code)
    {
        case RM_TASKOP_START:
        {
            LOCKOBJ(pDest, pSR);

            // First check if pDest is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pDest))
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            //
            // pDest is allocated. Now check if there is already a
            // CleanupCall task attached to pDest.
            //
            if (pDest->VcHdr.pCleanupCallTask != NULL)
            {
                //
                // There is an existing CleanupCall task. We pend on it.
                //

                PRM_TASK pOtherTask = pDest->VcHdr.pCleanupCallTask;
                OBJLOG1(
                    pTask,
                    "CleanupVc task %p exists; pending on it.\n",
                    pOtherTask
                    );
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pDest, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_OtherCleanupTaskComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // There is no CleanupCall task going on. Let's
            // make this task THE CleanupCall task.
            // 
            pDest->VcHdr.pCleanupCallTask = pTask;

            //
            // Since we're THE CleanupCall task, add an association to pDest,
            // which will only get cleared when the  pDest->VcHdr.pCleanupCallTask field
            // above is cleared.
            //
            DBG_ADDASSOC(
                &pDest->Hdr,                        // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_DEST_CLEANUPCALL_TASK,     // AssociationID
                "    Official CleanupCall task 0x%p (%s)\n", // szFormat
                pSR
                );

            //
            // Grab the IF send lock and disable further sends on this vc;
            // Also if there are pending sends, we'll need to suspend ourselves
            // until all the sends are done.
            //
            ARP_WRITELOCK_IF_SEND_LOCK(pIF, pSR);
            pDest->sendinfo.OkToSend = FALSE;

            // There should be no other task waiting for outstanding sends to
            // complete -- only the OFFICIAL CleanupTask (that's us) explicitly
            // waits for sends to complete.
            //
            ASSERTEX(pDest->sendinfo.pSuspendedCleanupCallTask == NULL,
                    pDest->sendinfo.pSuspendedCleanupCallTask);

            if (pDest->sendinfo.NumOutstandingSends != 0)
            {
                DBGMARK(0xea3987f0);
                //
                // Outstanding sends, we need to suspend ourselves until
                // the count goes to zero...
                //

                pDest->sendinfo.pSuspendedCleanupCallTask = pTask;

                // Following association will be cleared when we are resumed
                // after the outstanding sends goes to zero.
                //
                DBG_ADDASSOC(
                    &pDest->Hdr,                        // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_DEST_CLEANUPCALLTASK_WAITING_ON_SENDS,// AssociationID
                    "    Vc tasks 0x%p (%s) waiting on outstanding sends\n",
                    pSR
                    );
                RmSuspendTask(pTask, PEND_OutstandingSendsComplete, pSR);

                Status = NDIS_STATUS_PENDING;
            }
            else
            {
                DBGMARK(0x306bc5c3);
                //
                // If we're here, we're free to go on and close the call.
                //
                fCloseCall = TRUE;
                NdisVcHandle = pDest->VcHdr.NdisVcHandle;
            }
            
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {

            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_OtherCleanupTaskComplete:
                {
        
                    //
                    // There was another cleanup-vc task going when we started, and
                    // it's now complete. Nothing for us to do...
                    //
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;
    
    
                case  PEND_OutstandingSendsComplete:
                {
                    // We were waiting for outstanding sends to complete, and
                    // the last one to complete has resumed us (after setting
                    // pDest->sendinfo.pSuspendedCleanupCallTask to NULL).
                    //
                    ARP_WRITELOCK_IF_SEND_LOCK(pIF, pSR);
                    ASSERT(pDest->sendinfo.pSuspendedCleanupCallTask == NULL);
                    ASSERT(!ARP_CAN_SEND_ON_DEST(pDest));
                    ASSERT(pDest->sendinfo.NumOutstandingSends==0);
                    NdisVcHandle = pDest->VcHdr.NdisVcHandle;
                    ARP_UNLOCK_IF_SEND_LOCK(pIF, pSR);

                    // There were outstanding sends,  but how there are none.
                    // We should be able to close the call now.
                    //
                    fCloseCall = TRUE;
                    DBGMARK(0xf3b10866);
                    Status = NDIS_STATUS_SUCCESS;
                    break;
                }
                break;

                case PEND_CloseCallComplete:
                {
                    //
                    // The close call is complete...
                    //
                    LOCKOBJ(pDest, pSR);

                    ASSERT(pDest->VcHdr.pCleanupCallTask == pTask);

                    // Delete the association we added when we set
                    // pDest->VcHdr.pCleanupCallTask to pTask.
                    //
                    DBG_DELASSOC(
                        &pDest->Hdr,                        // pObject
                        pTask,                              // Instance1
                        pTask->Hdr.szDescription,           // Instance2
                        ARPASSOC_DEST_CLEANUPCALL_TASK,     // AssociationID
                        pSR
                        );
                    pDest->VcHdr.pCleanupCallTask = NULL;

                    RmUnlockAll(pSR);
                    DBGMARK(0xa590bb4f);
                    arpDeinitializeVc(pIF, &pDest->VcHdr, &pDest->Hdr, pSR);

                    Status = NDIS_STATUS_SUCCESS;
                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            LOCKOBJ(pDest, pSR);


            DBGMARK(0xcfc9dbaf);
            //
            // We're done. There should be no async activities left to do.
            //
            #if DBG
            ARP_READLOCK_IF_SEND_LOCK(pIF, pSR);
            ASSERTEX(pDest->VcHdr.NdisVcHandle == NULL, pDest);
            ASSERTEX(!ARP_CAN_SEND_ON_DEST(pDest), pDest);
            ASSERTEX(pDest->sendinfo.NumOutstandingSends==0, pDest);
            ARP_UNLOCK_IF_SEND_LOCK(pIF, pSR);
            #endif DBG

            Status = NDIS_STATUS_SUCCESS;

        }
        break; // RM_TASKOP_END:

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    if (fCloseCall)
    {
        DBGMARK(0x653b1cc3);

        RmSuspendTask(pTask, PEND_CloseCallComplete, pSR);

    #if ARPDBG_FAKE_CALLS
        Status = arpDbgFakeNdisClCloseCall(
                    NdisVcHandle,
                    NULL,               // No party handle
                    NULL,               // No Buffer
                    0,                  // Size of above
                    &pDest->Hdr,
                    &pDest->VcHdr,
                    pSR
                );
    #else   // !ARPDBG_FAKE_CALLS
        Status = NdisClCloseCall(
                    NdisVcHandle,
                    NULL,               // No party handle
                    NULL,               // No Buffer
                    0                   // Size of above
                );
    #endif  // !ARPDBG_FAKE_CALLS

        if (Status != NDIS_STATUS_PENDING)
        {
            ArpCoCloseCallComplete(
                    Status,
                    (NDIS_HANDLE) &pDest->VcHdr,
                    (NDIS_HANDLE)NULL
                    );
            Status = NDIS_STATUS_PENDING;
        }
    }

    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskMakeRecvFifoCall(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    This task is responsible for making a call to the interface's single
    receive FIFO.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    ENTER("TaskMakeRecvFifoCall", 0x25108eaa)
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARP1394_INTERFACE * pIF     = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pTask);
    TASK_MAKECALL     * pMakeCallTask =  (TASK_MAKECALL*) pTask;

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_OtherMakeCallTaskComplete,
        PEND_MakeCallComplete
    };

    ASSERT(sizeof(ARP1394_TASK) >= sizeof(*pMakeCallTask));


    switch(Code)
    {
        case RM_TASKOP_START:
        {
            LOCKOBJ(pIF, pSR);

            DBGMARK(0x6d7d9959);


            // If there is a call cleanup task in progress, we fail right away... 
            //
            if (pIF->recvinfo.VcHdr.pCleanupCallTask != NULL)
            {
                OBJLOG2(
                    pIF,
                    "Failing MakeCall task %p because Cleanup task %p exists.\n",
                    pIF,
                    pIF->recvinfo.VcHdr.pCleanupCallTask
                    );
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            //
            // Now check if there is already a
            // MakeCall task attached to pIF.
            //
            if (pIF->recvinfo.VcHdr.pMakeCallTask != NULL)
            {
                //
                // There is a make-call task. We pend on it.
                //

                PRM_TASK pOtherTask = pIF->recvinfo.VcHdr.pMakeCallTask;
                OBJLOG1(
                    pTask,
                    "MakeCall task %p exists; pending on it.\n",
                    pOtherTask);

                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pIF, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_OtherMakeCallTaskComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // There is no MakeCall task going on. Let's
            // make this task THE MakeCall task.
            // 
            pIF->recvinfo.VcHdr.pMakeCallTask = pTask;

            //
            // Since we're THE MakeCall task, add an association to pIF,
            // which will only get cleared when the  pIF->pMakeCallTask field
            // above is cleared.
            //
            DBG_ADDASSOC(
                &pIF->Hdr,                          // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_IF_MAKECALL_TASK,          // AssociationID
                "    Official makecall task 0x%p (%s)\n", // szFormat
                pSR
                );

            //
            // Make sure we're in the position to make a
            // call -- there should be no VC handle.
            //
            if (pIF->recvinfo.VcHdr.NdisVcHandle != NULL)
            {
                OBJLOG1(
                 pTask,
                 "VcHandle 0x%p already exists!, failing make call attempt.\n",
                 pIF->recvinfo.VcHdr.NdisVcHandle);
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            // Setup call params.
            //
            {
                PNIC1394_MEDIA_PARAMETERS p1394Params =
                            (PNIC1394_MEDIA_PARAMETERS)
                            &pMakeCallTask->MediaParams.Parameters;
                NIC1394_DESTINATION     DestAddr;
                PNIC1394_DESTINATION    pDestAddr;

                ARP_ZEROSTRUCT(&DestAddr);

                // TODO: put real values....
                //
                DestAddr.FifoAddress.UniqueID   = 0;
                DestAddr.FifoAddress.Off_Low    = 0;
                DestAddr.FifoAddress.Off_High   = 0x100;
                DestAddr.AddressType = NIC1394AddressType_FIFO;
                pDestAddr = &DestAddr;

                //No need: ARP_ZEROSTRUCT(&pMakeCallTask->CallParams);
                //No need: ARP_ZEROSTRUCT(&pMakeCallTask->MediaParams);
                pMakeCallTask->CallParams.MediaParameters =
                                (PCO_MEDIA_PARAMETERS) &pMakeCallTask->MediaParams;

                pMakeCallTask->MediaParams.Flags          = RECEIVE_VC;
                pMakeCallTask->MediaParams.ParamType      = NIC1394_MEDIA_SPECIFIC;

                ASSERT(FIELD_OFFSET(ARP1394_CO_MEDIA_PARAMETERS,  Parameters)
                == FIELD_OFFSET(CO_MEDIA_PARAMETERS, MediaSpecific.Parameters));

                p1394Params->Destination        = *pDestAddr; // struct copy.
                p1394Params->Flags              = NIC1394_VCFLAG_FRAMED;
                p1394Params->MaxSendBlockSize   = -1; // (nic should pick)
                p1394Params->MaxSendSpeed       = -1; // (nic should pick)
                p1394Params->MTU                = ARP1394_ADAPTER_MTU;
                                                  // TODO --  make above based on
                                                  // config.
            }
            
            // Now create a vc and make the call...
            // 
            {
                NDIS_HANDLE NdisVcHandle;
                RmUnlockAll(pSR);

                Status = arpInitializeVc(
                            pIF,
                            &g_ArpRecvFifoVcStaticInfo,
                            &pIF->Hdr,
                            &pIF->recvinfo.VcHdr,
                            pSR
                            );
                if (FAIL(Status))
                {
                    break;
                }
                NdisVcHandle = pIF->recvinfo.VcHdr.NdisVcHandle;

                RmSuspendTask(pTask,  PEND_MakeCallComplete, pSR);

                DBGMARK(0xf313a276);

                //
                //  Make the Call now
                //
                RM_ASSERT_NOLOCKS(pSR);
            #if ARPDBG_FAKE_CALLS
                Status = arpDbgFakeNdisClMakeCall(
                                NdisVcHandle,
                                &pMakeCallTask->CallParams,
                                NULL,               // ProtocolPartyContext
                                NULL,               // NdisPartyHandle
                                &pIF->Hdr,
                                &pIF->recvinfo.VcHdr,
                                pSR
                                );
            #else   // !ARPDBG_FAKE_CALLS
                Status = NdisClMakeCall(
                                NdisVcHandle,
                                &pMakeCallTask->CallParams,
                                NULL,               // ProtocolPartyContext
                                NULL                // NdisPartyHandle
                                );
            #endif  // !ARPDBG_FAKE_CALLS

        
                if (!PEND(Status))
                {
                    ArpCoMakeCallComplete(
                                Status,
                                (NDIS_HANDLE) &pIF->recvinfo.VcHdr,
                                NULL,
                                &pMakeCallTask->CallParams
                                );
                    Status = NDIS_STATUS_PENDING;
                }
            }
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            switch(RM_PEND_CODE(pTask))
            {
                case   PEND_OtherMakeCallTaskComplete:
                {
        
                    //
                    // There was another makecall task going when we started, and
                    // it's now complete. Nothing for us to do...
                    //
                    Status = (NDIS_STATUS) UserParam;
                }
                break;
    
    
                case PEND_MakeCallComplete:
                {

                    //
                    // The make call is complete. We're done...
                    //
                    Status = (NDIS_STATUS) UserParam;

                #if ARPDBG_FAKE_CALLS
                    //
                    // In the fake case, we give the "user" the opportunity to change
                    // the status to Success if the recv FIFO make call fails,
                    // because otherwise the adapter bind itself is going to fail.
                    //
                    // We do this even in the retail build (if ARPDBG_FAKE_CALLS is
                    // enabled).
                    //
                    if (FAIL(Status))
                    {
                        // To try the failure path of the recv fifo make call, enable
                        // the if 0 code. Currently we change status to success
                        // so that stress tests which include loading/unloading
                        // of the driver will run without breaking here everytime.
                        //
                    #if 0
                        DbgPrint(
                            "A13: FakeRecvMakeCall failed. &Status=%p.\n",
                            &Status
                            );
                        DbgBreakPoint();
                    #else
                        Status = NDIS_STATUS_SUCCESS;
                    #endif
                    }
                #endif  // ARPDBG_FAKE_CALLS

                    LOCKOBJ(pIF, pSR);
                    ASSERT (pIF->recvinfo.VcHdr.pMakeCallTask == pTask);

                    ASSERT(pIF->recvinfo.VcHdr.NdisVcHandle != NULL);

                    // On success, update pIF->recvinfo.offset.
                    //
                    if (!FAIL(Status))
                    {
                        PNIC1394_MEDIA_PARAMETERS p1394Params =
                                    (PNIC1394_MEDIA_PARAMETERS)
                                    &pMakeCallTask->MediaParams.Parameters;
                        pIF->recvinfo.offset.Off_Low =
                                p1394Params->Destination.FifoAddress.Off_Low;
                        pIF->recvinfo.offset.Off_High =
                                p1394Params->Destination.FifoAddress.Off_High;
                    }

                    DBGMARK(0xa3b591b7);

                    RmUnlockAll(pSR);

                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            Status = (NDIS_STATUS) UserParam;

            LOCKOBJ(pIF, pSR);

            if (pIF->recvinfo.VcHdr.pMakeCallTask == pTask)
            {
                //
                // We're the official pMakeCallTask
                //

                // Delete the association we added when we set
                // pIF->recvinfo.VcHdr.pMakeCallTask to pTask.
                //
                DBG_DELASSOC(
                    &pIF->Hdr,                      // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_IF_MAKECALL_TASK,      // AssociationID
                    pSR
                    );

                // Remove reference to us in pIF.
                //
                pIF->recvinfo.VcHdr.pMakeCallTask = NULL;

                if (FAIL(Status) && pIF->recvinfo.VcHdr.NdisVcHandle != NULL)
                {
                    UNLOCKOBJ(pIF, pSR);

                    // WARNING: the above completely nukes out VcHdr.
                    //
                    arpDeinitializeVc(pIF, &pIF->recvinfo.VcHdr, &pIF->Hdr, pSR);
                }
            }
        }
        break;

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskCleanupRecvFifoCall(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

        This task is responsible for cleaning up a previously-made call to the
        IF's single recvFIFO VC.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    ENTER("TaskCleanupRecvFifoCall", 0x6e9581f7)
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARP1394_INTERFACE * pIF     = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pTask);
    MYBOOL              fCloseCall   = FALSE;
    NDIS_HANDLE         NdisVcHandle = NULL;

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_MakeCallTaskComplete,
        PEND_OtherCleanupTaskComplete,
        PEND_CloseCallComplete
    };

    DBGMARK(0xa651415b);

    switch(Code)
    {

        case RM_TASKOP_START:
        {
            LOCKOBJ(pIF, pSR);

            // First check if pIF is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pIF))
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            //
            // pIF is allocated. Now check if there is already a
            // CleanupCall task attached to pIF.
            //
            if (pIF->recvinfo.VcHdr.pCleanupCallTask != NULL)
            {
                //
                // There is an existing CleanupCall task. We pend on it.
                //

                PRM_TASK pOtherTask = pIF->recvinfo.VcHdr.pCleanupCallTask;
                OBJLOG1(
                    pTask,
                    "CleanupVc task %p exists; pending on it.\n",
                    pOtherTask
                    );
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pIF, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_OtherCleanupTaskComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // There is no CleanupCall task going on. Let's
            // make this task THE CleanupCall task.
            // 
            pIF->recvinfo.VcHdr.pCleanupCallTask = pTask;

            //
            // Since we're THE CleanupCall task, add an association to pIF,
            // which will only get cleared when the  pIF->recvinfo.VcHdr.pCleanupCallTask
            // field above is cleared.
            //
            DBG_ADDASSOC(
                &pIF->Hdr,                      // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_IF_CLEANUPCALL_TASK,       // AssociationID
                "    Official CleanupCall task 0x%p (%s)\n", // szFormat
                pSR
                );

            if (pIF->recvinfo.VcHdr.pMakeCallTask != NULL)
            {
                // Oops, there is a make call task ongoing.
                // TODO: abort the makecall task.
                // For now, we just wait until it's complete.
                //

                PRM_TASK pOtherTask = pIF->recvinfo.VcHdr.pMakeCallTask;
                OBJLOG1(
                    pTask,
                    "MakeCall task %p exists; pending on it.\n",
                    pOtherTask
                    );
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pIF, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_MakeCallTaskComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }
            else
            {
                NdisVcHandle = pIF->recvinfo.VcHdr.NdisVcHandle;
                if (NdisVcHandle != NULL)
                {
                    fCloseCall = TRUE;
                }
                else
                {
                    // Nothing to do.
                    Status = NDIS_STATUS_SUCCESS;
                }
            }
            
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {

            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_OtherCleanupTaskComplete:
                {
        
                    //
                    // There was another cleanup-vc task going when we started, and
                    // it's now complete. Nothing for us to do...
                    //
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;
    
                case  PEND_MakeCallTaskComplete:
                {
                    //
                    // There was a makecall task going when we started, and
                    // it's now complete. We go on to cleanup the call.
                    // There cannot be another makecall task now, because a
                    // makecall task doesn't start if there is an active
                    // cleanupcall task.
                    //
                    ASSERT(pIF->recvinfo.VcHdr.pMakeCallTask == NULL);
                    
                    NdisVcHandle = pIF->recvinfo.VcHdr.NdisVcHandle;
                    if (NdisVcHandle != NULL)
                    {
                        fCloseCall = TRUE;
                    }
                    else
                    {
                        // Nothing to do.
                        Status = NDIS_STATUS_SUCCESS;
                    }
                }
                break;

                case PEND_CloseCallComplete:
                {
                    //
                    // The close call is complete...
                    //
                    LOCKOBJ(pIF, pSR);

                    ASSERT(pIF->recvinfo.VcHdr.pCleanupCallTask == pTask);

                    // Delete the association we added when we set
                    // pIF->recvinfo.VcHdr.pCleanupCallTask to pTask.
                    //
                    DBG_DELASSOC(
                        &pIF->Hdr,                      // pObject
                        pTask,                              // Instance1
                        pTask->Hdr.szDescription,           // Instance2
                        ARPASSOC_IF_CLEANUPCALL_TASK,       // AssociationID
                        pSR
                        );
                    pIF->recvinfo.VcHdr.pCleanupCallTask = NULL;

                    // Delete the VC...
                    //
                    ASSERT(pIF->recvinfo.VcHdr.NdisVcHandle != NULL);
                    UNLOCKOBJ(pIF, pSR);
                    DBGMARK(0xc6b52f21);
                    arpDeinitializeVc(pIF, &pIF->recvinfo.VcHdr, &pIF->Hdr, pSR);

                    Status = NDIS_STATUS_SUCCESS;
                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            LOCKOBJ(pIF, pSR);

            DBGMARK(0xc65b2f08);
            //
            // We're done. There should be no async activities left to do.
            //
            ASSERTEX(pIF->recvinfo.VcHdr.NdisVcHandle == NULL, pIF);
            Status = NDIS_STATUS_SUCCESS;

        }
        break; // RM_TASKOP_END:

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    if (fCloseCall)
    {
        DBGMARK(0x04d5b2d9);

        RmSuspendTask(pTask, PEND_CloseCallComplete, pSR);

    #if ARPDBG_FAKE_CALLS
        Status = arpDbgFakeNdisClCloseCall(
                    NdisVcHandle,
                    NULL,               // No party handle
                    NULL,               // No Buffer
                    0,                  // Size of above
                    &pIF->Hdr,
                    &pIF->recvinfo.VcHdr,
                    pSR
                );
    #else   // !ARPDBG_FAKE_CALLS
        Status = NdisClCloseCall(
                    NdisVcHandle,
                    NULL,               // No party handle
                    NULL,               // No Buffer
                    0                   // Size of above
                );
    #endif  // !ARPDBG_FAKE_CALLS

        if (Status != NDIS_STATUS_PENDING)
        {
            ArpCoCloseCallComplete(
                    Status,
                    (NDIS_HANDLE) &pIF->recvinfo.VcHdr,
                    (NDIS_HANDLE)NULL
                    );
            Status = NDIS_STATUS_PENDING;
        }
    }

    EXIT()

    return Status;
}

NDIS_STATUS
arpAddOneStaticArpEntry(
    IN PARP1394_INTERFACE       pIF,    // LOCKIN LOCKOUT
    IN IP_ADDRESS               IpAddress,
    IN PNIC1394_FIFO_ADDRESS    pFifoAddr,
    IN PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    Create a pRemoteIp and IP address IpAddress and (if not already existing)
    create a pDest object with hw address pFifoAddr and link the two.

Return Value:
    
    NDIS_STATUS_SUCCESS on success. Ndis failure code on failure (could be
    because of a resource allocation failure or because there already exists
    a pRemoteIp with the specified IP address).

--*/
{
    INT fCreated = FALSE;
    ARPCB_REMOTE_IP *pRemoteIp = NULL;
    ARPCB_DEST      *pDest = NULL;
    NDIS_STATUS     Status;
    ARP_DEST_PARAMS DestParams;
    REMOTE_DEST_KEY RemoteDestKey;

    RM_DBG_ASSERT_LOCKED(&pIF->Hdr, pSR);
    ARP_ZEROSTRUCT(&DestParams);
    DestParams.HwAddr.AddressType =  NIC1394AddressType_FIFO;
    DestParams.HwAddr.FifoAddress = *pFifoAddr; // struct copy
    REMOTE_DEST_KEY_INIT(&RemoteDestKey);
    RemoteDestKey.IpAddress = IpAddress;

    do
    {
        Status = RmLookupObjectInGroup(
                        &pIF->RemoteIpGroup,
                        RM_CREATE|RM_NEW,
                        (PVOID) (&RemoteDestKey),
                        (PVOID) (&RemoteDestKey), // pCreateParams
                        (RM_OBJECT_HEADER**) &pRemoteIp,
                        &fCreated,  // pfCreated
                        pSR
                        );
        if (FAIL(Status))
        {
            OBJLOG1(
                pIF,
                "Couldn't add fake static localIp entry with addr 0x%lx\n",
                IpAddress
                );
            break;
        }
    
        // Now create a destination item for this structure.
        //
        Status = RmLookupObjectInGroup(
                        &pIF->DestinationGroup,
                        RM_CREATE,              //NOT RM_NEW (could be existing)
                        &DestParams,
                        &DestParams,    // pParams
                        (RM_OBJECT_HEADER**) &pDest,
                        &fCreated,
                        pSR
                        );
        if (FAIL(Status))
        {
            OBJLOG1(
                pIF,
                "Couldn't add fake dest entry with hw addr 0x%lx\n",
                (UINT) DestParams.HwAddr.FifoAddress.UniqueID // Truncation
                );
        #if 0
            TR_WARN((
                "Couldn't add fake dest entry with hw addr 0x%lx\n",
                (UINT) DestParams.HwAddr.FifoAddress.UniqueID // Truncation
                ));
        #endif // 0
            
            //
            // We'll leave the RemoteIp entry around -- it will be cleaned up later.
            // We do have to deref the tmpref added when looking it up.
            //
            RmTmpDereferenceObject(&pRemoteIp->Hdr, pSR);
            break;
        }
    
        //
        // We've created both RemoteIp and Destination entries. Now link them.
        // (We still have the IF lock, which is the same as the RemoteIP and 
        //  desination locks for now).
        //
        // TODO: will need to change this when pRemoteIp gets its own lock.
        //
        RM_ASSERT_SAME_LOCK_AS_PARENT(pRemoteIp);
        RM_ASSERT_SAME_LOCK_AS_PARENT(pDest);
    
        arpLinkRemoteIpToDest(
            pRemoteIp,
            pDest,
            pSR
            );
    
        // Now set the pRemoteIp state to reflect that it is STATIC and FIFO
        //
        SET_REMOTEIP_SDTYPE(pRemoteIp, ARPREMOTEIP_STATIC);
        SET_REMOTEIP_FCTYPE(pRemoteIp, ARPREMOTEIP_FIFO);
    
    
        // Finally, remove the tmprefs added in the lookups.
        //
        RmTmpDereferenceObject(&pRemoteIp->Hdr, pSR);
        RmTmpDereferenceObject(&pDest->Hdr, pSR);

    } while (FALSE);

    return Status;
}


VOID
arpActivateIf(
    PARP1394_INTERFACE  pIF,
    PRM_TASK            pCallingTask,   // OPTIONAL
    UINT                SuspendCode,    // OPTIONAL
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Initiate the asynchronous activation of pIF.

    NO locks must be held on entrance and none are held on exit.

Arguments:

    pIF             - Interface to activate.
    pCallingTask    - Optional task to suspend and resume when activation completes
                      (possibly async).
    SuspendCode     - SuspendCode for the above task.

--*/
{
    PRM_TASK    pTask;
    NDIS_STATUS Status;

    RM_ASSERT_NOLOCKS(pSR);

    Status = arpAllocateTask(
                &pIF->Hdr,                  // pParentObject,
                arpTaskActivateInterface,   // pfnHandler,
                0,                          // Timeout,
                "Task: Activate Interface", // szDescription
                &pTask,
                pSR
                );

    if (FAIL(Status))
    {
        OBJLOG0(pIF, ("FATAL: couldn't alloc Activate IF task!\n"));
        ASSERT(FALSE);
        if (pCallingTask != NULL)
        {
            RmSuspendTask(pCallingTask, SuspendCode, pSR);
            RmResumeTask(pCallingTask, Status, pSR);
        }
    }
    else
    {
        if (pCallingTask != NULL)
        {
            RmPendTaskOnOtherTask(
                pCallingTask,
                SuspendCode,
                pTask,
                pSR
                );
        }

        (void)RmStartTask(pTask, 0, pSR);
    }
}


VOID
arpDeinitIf(
    PARP1394_INTERFACE  pIF,
    PRM_TASK            pCallingTask,   // OPTIONAL
    UINT                SuspendCode,    // OPTIONAL
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Initiate the asynchronous unload of pIF. If pIF is currently being loaded
    (initialized), abort the initializeation or wait for it to complete before
    unloading it. If pIF is currently being unloaded and pCallingTask is 
    NULL, return right away, else (pCallingTask is not NULL),
    suspend pCallingTask and make it pend until the unload completes.

    NO locks must be held on entrance and none are held on exit.

Arguments:

    pIF             - Interface to unload.
    pCallingTask    - Optional task to suspend if unload is completing async.
    SuspendCode     - SuspendCode for the above task.

Return Value:

    NDIS_STATUS_SUCCESS -- on synchronous success OR pCallingTask==NULL
    NDIS_STATUS_PENDING -- if pCallingTask is made to pend until the operation
                        completes.

--*/
{
    PRM_TASK    pTask;
    NDIS_STATUS Status;

    //
    // NOTE: We could check to see if pIF can be synchronously unloaded,
    // and if so unload it right here. We don't bother because that's just
    // more code, and with dubious perf benefit.
    //

    RM_ASSERT_NOLOCKS(pSR);

    Status = arpAllocateTask(
                &pIF->Hdr,                  // pParentObject,
                arpTaskDeinitInterface,     // pfnHandler,
                0,                          // Timeout,
                "Task: Deinit Interface",   // szDescription
                &pTask,
                pSR
                );

    if (FAIL(Status))
    {
        OBJLOG0(pIF, ("FATAL: couldn't alloc close IF task!\n"));
        ASSERT(FALSE);
        if (pCallingTask != NULL)
        {
            RmSuspendTask(pCallingTask, SuspendCode, pSR);
            RmResumeTask(pCallingTask, Status, pSR);
        }
    }
    else
    {
        if (pCallingTask != NULL)
        {
            RmPendTaskOnOtherTask(
                pCallingTask,
                SuspendCode,
                pTask,
                pSR
                );
        }

        (void)RmStartTask(pTask, 0, pSR);
    }
}


VOID
arpDeinitDestination(
    PARPCB_DEST             pDest,  // NOLOCKIN NOLOCKOUT
    MYBOOL                  fOnlyIfUnused,
    PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Initate the unload of destination pDest.

    If fOnlyIfUnused is TRUE, then only do this if there are no 
    local or remote IPs pointing to it.

    NOTE: it's possible that some pLocal/pRemoteIps may be linked to
        pDest AFTER we've decided to deinit pDest. Tough luck -- in this
        unlikely event, we'll unload this pDest, and the unlinked
        pLocals/pRemotes will have to re-figure who to link to.

--*/
{
    ENTER("DeinitDestination", 0xc61b8f82)
    PRM_TASK    pTask;
    NDIS_STATUS Status;

    RM_ASSERT_NOLOCKS(pSR);

    if (fOnlyIfUnused)
    {
        //
        // We don't deinit the destination if there are local or remote ip's 
        // linked to it, OR if it is the broadcast channel.
        //
        LOCKOBJ(pDest, pSR);
        if (    !IsListEmpty(&pDest->listLocalIp)
             || !IsListEmpty(&pDest->listIpToThisDest)
             || pDest == ((PARP1394_INTERFACE) RM_PARENT_OBJECT(pDest))
                         ->pBroadcastDest)
        {
            UNLOCKOBJ(pDest, pSR);
            return;                         // ********* EARLY RETURN **********
        }
        UNLOCKOBJ(pDest, pSR);
    }

#if DBG
    if (pDest->Params.HwAddr.AddressType ==  NIC1394AddressType_FIFO)
    {
        PUCHAR puc = (PUCHAR)  &pDest->Params.HwAddr.FifoAddress;
        TR_WARN(("Deiniting Destination: FIFO %02lx-%02lx-%02lx-%02lx-%02lx-%02lx-%02lx-%02lx.\n",
            puc[0], puc[1], puc[2], puc[3],
            puc[4], puc[5], puc[6], puc[7]));
    }
    else if (pDest->Params.HwAddr.AddressType ==  NIC1394AddressType_Channel)
    {
        TR_WARN(("Deiniting Destination: Channel %lu.\n",
                pDest->Params.HwAddr.Channel));
    }
#endif // DBG



    Status = arpAllocateTask(
                &pDest->Hdr,                // pParentObject,
                arpTaskUnloadDestination,   // pfnHandler,
                0,                          // Timeout,
                "Task: Unload Dest",        // szDescription
                &pTask,
                pSR
                );
    if (FAIL(Status))
    {
        OBJLOG0(pDest, ("FATAL: couldn't alloc unload dest task!\n"));
    }
    else
    {
        (VOID) RmStartTask(
                    pTask,
                    0, // UserParam (unused)
                    pSR
                    );
    }
}


VOID
arpDeactivateIf(
    PARP1394_INTERFACE  pIF,
    PRM_TASK            pCallingTask,   // OPTIONAL
    UINT                SuspendCode,    // OPTIONAL
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Initiate the asynchronous deactivation of pIF.
    "Deactivation" consists of tearing down any activity and handles associated
    with this IF. The IF will remain allocated linked to the adapter.

    NO locks must be held on entrance and none are held on exit.

Arguments:

    pIF             - Interface to unload.
    pCallingTask    - Optional task to suspend if deactivation is completing async.
    SuspendCode     - SuspendCode for the above task.

--*/
{
    PRM_TASK    pTask;
    NDIS_STATUS Status;

    //
    // NOTE: We could check to see if pIF can be synchronously deactivated,
    // and if so deactivate it right here. We don't bother because that's just
    // more code, and with dubious perf benefit.
    //

    RM_ASSERT_NOLOCKS(pSR);

    Status = arpAllocateTask(
                &pIF->Hdr,                  // pParentObject,
                arpTaskDeactivateInterface, // pfnHandler,
                0,                          // Timeout,
                "Task: DeactivateInterface",// szDescription
                &pTask,
                pSR
                );

    if (FAIL(Status))
    {
        OBJLOG0(pIF, ("FATAL: couldn't alloc deactivate IF task!\n"));
        ASSERT(FALSE);
        if (pCallingTask != NULL)
        {
            RmSuspendTask(pCallingTask, SuspendCode, pSR);
            RmResumeTask(pCallingTask, Status, pSR);
        }
    }
    else
    {
        if (pCallingTask != NULL)
        {
            RmPendTaskOnOtherTask(
                pCallingTask,
                SuspendCode,
                pTask,
                pSR
                );
        }

        (void)RmStartTask(pTask, 0, pSR);
    }
}




NDIS_STATUS
arpCreateInterface(
        IN  PARP1394_ADAPTER    pAdapter,   // LOCKIN LOCKOUT
        OUT PARP1394_INTERFACE *ppIF,
        IN  PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    Allocates and performs basic initialization of an interface object.
    The interface object subsequently needs to be initialized by the starting
    the initialization task before it is completely initialized.
    
    *ppIF shares the same lock as it's parent, pAdapter.

Arguments:

    pAdapter        - Adapter that will own the interface.
    ppIF            - Place to store the allocated interface.

Return Value:

    NDIS_STATUS_SUCCESS on successful allocation and initialization of the interface.
    NDIS failure code   on failure.
--*/
{
    NDIS_STATUS Status;
    ARP1394_INTERFACE *pIF;
    ENTER("arpCreateInterface", 0x938c36ff)

    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);

    do
    {

        Status = ARP_ALLOCSTRUCT(pIF, MTAG_INTERFACE);

        if (Status != NDIS_STATUS_SUCCESS || pIF == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        ARP_ZEROSTRUCT(pIF);

        RmInitializeHeader(
            &(pAdapter->Hdr),                   // pParentObject
            &pIF->Hdr,
            MTAG_INTERFACE,
            &pAdapter->Lock,
            &ARP1394_INTERFACE_StaticInfo,
            NULL,                               // szDescription
            pSR
            );

        // Note arpInitializeIfPools expects pIF to be locked. We know it's locked
        // because it shares the same lock as it's parent, and the parent is lozked.
        //
        Status = arpInitializeIfPools(pIF, pSR);

        if (FAIL(Status))
        {
            RmDeallocateObject(
                &(pIF->Hdr),
                pSR
                );
            pIF = NULL;
            break;
        }

        //
        // Intialize the various groups in the interface...
        //

        RmInitializeGroup(
                        &pIF->Hdr,                              // pOwningObject
                        &ArpGlobal_LocalIpStaticInfo,
                        &(pIF->LocalIpGroup),
                        "LocalIp group",                        // szDescription
                        pSR
                        );

        RmInitializeGroup(
                        &pIF->Hdr,                              // pOwningObject
                        &ArpGlobal_RemoteIpStaticInfo,
                        &(pIF->RemoteIpGroup),
                        "RemoteIp group",                       // szDescription
                        pSR
                        );

        RmInitializeGroup(
                        &pIF->Hdr,                              // pOwningObject
                        &ArpGlobal_RemoteEthStaticInfo,
                        &(pIF->RemoteEthGroup),
                        "RemoteEth group",                      // szDescription
                        pSR
                        );

        RmInitializeGroup(
                        &pIF->Hdr,                              // pOwningObject
                        &ArpGlobal_DhcpTableStaticInfo,
                        &(pIF->EthDhcpGroup),
                        "Eth Dhcp group",                      // szDescription
                        pSR
                        );


        RmInitializeGroup(
                        &pIF->Hdr,                              // pOwningObject
                        &ArpGlobal_DestinationStaticInfo,
                        &(pIF->DestinationGroup),
                        "Destination group",                    // szDescription
                        pSR
                        );



        //
        //  Cache the adapter handle.
        //
        pIF->ndis.AdapterHandle = pAdapter->bind.AdapterHandle;
    
        // TODO -- put the real IP MTU (based on adapter info and config info)
        //
        pIF->ip.MTU     = ARP1394_ADAPTER_MTU-16;     // Bytes ('-16' accounts for
                                                  // the encapsulation header.
                                                  // 16 is overkill:  4 should
                                                  // be enough.)

        // Init stuff in pIF->sendinfo (the const header pools were initialized
        // earlier, because their initialization could fail).
        //
        RmInitializeLock(&pIF->sendinfo.Lock, LOCKLEVEL_IF_SEND);
        InitializeListHead(&pIF->sendinfo.listPktsWaitingForHeaders);

        arpResetIfStats(pIF, pSR);

        pIF->ip.ATInstance = INVALID_ENTITY_INSTANCE;
        pIF->ip.IFInstance = INVALID_ENTITY_INSTANCE;

        pIF->ip.BroadcastAddress = 0xFFFFFFFF; // Defaults to all-1's.

        //
        // Do any other non-failure-prone initialization here.
        //

    } while (FALSE);

    *ppIF = pIF;

    EXIT()
    return Status;
}


VOID
arpDeleteInterface(
        IN  PARP1394_INTERFACE  pIF, // LOCKIN LOCKOUT (adapter lock)
        IN  PRM_STACK_RECORD    pSR
        )
{
    ARP1394_ADAPTER *   pAdapter =
                            (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);

    
    RM_ASSERT_OBJLOCKED(&pAdapter->Hdr, pSR);

    // We expect that the adapter has already removed it's reference to pIF.
    //
    ASSERT(pAdapter->pIF != pIF);

    // Deinitialize all the groups in the IF ...
    //
    RmDeinitializeGroup(&(pIF->LocalIpGroup), pSR);
    RmDeinitializeGroup(&(pIF->RemoteIpGroup), pSR);
    RmDeinitializeGroup(&(pIF->RemoteEthGroup), pSR);
    RmDeinitializeGroup(&(pIF->DestinationGroup), pSR);
    RmDeinitializeGroup(&(pIF->EthDhcpGroup),pSR);

    // Deinit the various pools associated with pIF.
    //
    arpDeInitializeIfPools(pIF, pSR);


    // Verify that everything is truly done...
    //
    ASSERTEX(pIF->pPrimaryTask == NULL, pIF);
    ASSERTEX(pIF->pActDeactTask == NULL, pIF);
    ASSERTEX(pIF->ip.Context == NULL, pIF);
    ASSERTEX(pIF->ndis.AfHandle == NULL, pIF);

    // Add any other checks you want here...

    // Deallocate the IF
    //
    RmDeallocateObject(
        &(pIF->Hdr),
        pSR
        );
}

VOID
arpResetIfStats(
        IN  PARP1394_INTERFACE  pIF, // LOCKIN LOCKOUT
        IN  PRM_STACK_RECORD    pSR
        )
{
    ENTER("arpResetIfStats", 0x3eb52cda)
    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);

    // Zero  stats
    //
    //
    ARP_ZEROSTRUCT(&(pIF->stats));

    // Set the timestamp indicating start of stats collection.
    //
    NdisGetCurrentSystemTime(&(pIF->stats.StatsResetTime));

    // Get the perf counter frequency (we don't need to do this each time, but
    // why bother special casing.)
    //
    (VOID) KeQueryPerformanceCounter(&(pIF->stats.PerformanceFrequency));

    EXIT()
}


NDIS_STATUS
arpInitializeVc(
    PARP1394_INTERFACE  pIF,
    PARP_STATIC_VC_INFO pVcInfo,
    PRM_OBJECT_HEADER   pOwner,
    PARP_VC_HEADER      pVcHdr,
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Initialize the Vc Header; Allocate the NdisVcHandle;

Arguments:

    pIF         - Interface this applies to
    pVcInfo     - Static info about this VC
    pOwner      - Owning object (for referencing)
    pVcHdr      - Protocol Vc context to initialize

--*/
{
    NDIS_STATUS Status;
    NDIS_HANDLE NdisVcHandle;
    ENTER("arpInitializeVc", 0x36fe9837)

    // (DEBUG ONLY) Verify that all fields are already zero.
    //  TODO: We don't assert that pVcHdr->pMakeCallTask == NULL, because
    // it's already set on entry -- we should clean up the semantics of
    // arpInitializeVc.
    //
    ASSERT (    pVcHdr->pStaticInfo == NULL
            &&  pVcHdr->NdisVcHandle == NULL
            &&  pVcHdr->pCleanupCallTask == NULL );

    NdisVcHandle = NULL;
    // Try to create Ndis VC
    //
    Status = NdisCoCreateVc(
                    pIF->ndis.AdapterHandle,
                    pIF->ndis.AfHandle,
                    (NDIS_HANDLE) pVcHdr,   // ProtocolVcContext,
                    &NdisVcHandle
                    );
    if (FAIL(Status))
    {
        TR_WARN(("Couldn't create VC handle\n"));
        pVcHdr->NdisVcHandle = NULL;
        
    }
    else
    {
        pVcHdr->pStaticInfo  = pVcInfo;
        pVcHdr->NdisVcHandle = NdisVcHandle;

        // Link-to-external pOwningObject to the ndis-vc handle.
        //
    #if RM_EXTRA_CHECKING

        #define szARPASSOC_EXTLINK_TO_NDISVCHANDLE "    Linked to NdisVcHandle 0x%p\n"
        
        RmLinkToExternalEx(
            pOwner,                                 // pHdr
            0xb57e657b,                             // LUID
            (UINT_PTR) NdisVcHandle,                // External entity
            ARPASSOC_EXTLINK_TO_NDISVCHANDLE,       // AssocID
            szARPASSOC_EXTLINK_TO_NDISVCHANDLE,
            pSR
            );

    #else   // !RM_EXTRA_CHECKING

        RmLinkToExternalFast(pOwner);

    #endif // !RM_EXTRA_CHECKING

    }


    EXIT()

    return Status;
}

VOID
arpDeinitializeVc(
    PARP1394_INTERFACE  pIF,
    PARP_VC_HEADER      pVcHdr,
    PRM_OBJECT_HEADER   pOwner,     // NOLOCKIN NOLOCKOUT
    PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    DeInitialize the Vc Header; Deallocate the NdisVcHandle;

Arguments:

    pIF         - Interface this applies to
    pOwner      - Owning object (for de-referencing)
    pVcHdr      - Protocol Vc context to de-initialize

--*/
{
    ENTER("arpDeinitializeVc", 0x270b29ac)

    NDIS_HANDLE NdisVcHandle;

    RM_ASSERT_NOLOCKS(pSR);
    
    LOCKHDR(pOwner, pSR);

    // (DEBUG ONLY) Verify that there is no make-call or close-call task.
    //
    ASSERT( pVcHdr->pMakeCallTask == NULL && pVcHdr->pCleanupCallTask == NULL );

    NdisVcHandle = pVcHdr->NdisVcHandle;

    // Zero out the structure.
    //
    ARP_ZEROSTRUCT(pVcHdr);

    UNLOCKHDR(pOwner, pSR);

    RM_ASSERT_NOLOCKS(pSR);

    // Delete the Link-to-external pOwningObject to the ndis-vc handle.
    //
    #if RM_EXTRA_CHECKING

        RmUnlinkFromExternalEx(
            pOwner,                                 // pHdr
            0xee1b4fe3,                             // LUID
            (UINT_PTR) NdisVcHandle,                // External entity
            ARPASSOC_EXTLINK_TO_NDISVCHANDLE,       // AssocID
            pSR
            );

    #else   // !RM_EXTRA_CHECKING

        RmUnlinkFromExternalFast(pOwner);

    #endif // !RM_EXTRA_CHECKING

    // Delete the ndis vc handle.
    //
    NdisCoDeleteVc(NdisVcHandle);
    

    EXIT()
}


UINT
arpRecvFifoReceivePacket(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PNDIS_PACKET                pNdisPacket
)
/*++
            HOT PATH
--*/
{
    PARP_VC_HEADER          pVcHdr;
    PARP1394_INTERFACE      pIF;

    pVcHdr  = (PARP_VC_HEADER) ProtocolVcContext;
    pIF     =  CONTAINING_RECORD( pVcHdr, ARP1394_INTERFACE, recvinfo.VcHdr);
    ASSERT_VALID_INTERFACE(pIF);

    return arpProcessReceivedPacket(
                pIF,
                pNdisPacket,
                FALSE                   // IsChannel
                );

}


VOID
arpRecvFifoIncomingClose(
    IN  NDIS_STATUS                 CloseStatus,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PVOID                       pCloseData  OPTIONAL,
    IN  UINT                        Size        OPTIONAL
)
{

    PARP_VC_HEADER          pVcHdr;
    PARP1394_INTERFACE      pIF;
    RM_DECLARE_STACK_RECORD(sr)

    pVcHdr  = (PARP_VC_HEADER) ProtocolVcContext;
    pIF     =  CONTAINING_RECORD( pVcHdr, ARP1394_INTERFACE, recvinfo.VcHdr);
    ASSERT_VALID_INTERFACE(pIF);

    //
    // This is the IF receive FIFO VC. For now, geting an incoming close on
    // the receive FIFO vc results in our initiating the deinit of pIF.
    //
    OBJLOG1(pIF,"Got incoming close on recv FIFO!. Status=0x%lx\n", CloseStatus);

    (VOID) arpDeinitIf(
                pIF,
                NULL,           //  pCallingTask
                0,              //  SuspendCode
                &sr
                );
        
    RM_ASSERT_CLEAR(&sr);
}


VOID
arpBroadcastChannelIncomingClose(
    IN  NDIS_STATUS                 CloseStatus,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PVOID                       pCloseData  OPTIONAL,
    IN  UINT                        Size        OPTIONAL
)
{
    PARP_VC_HEADER          pVcHdr;
    PARP1394_INTERFACE      pIF;
    ARPCB_DEST          *   pDest;
    RM_DECLARE_STACK_RECORD(sr)

    pVcHdr  = (PARP_VC_HEADER) ProtocolVcContext;
    pDest   =  CONTAINING_RECORD( pVcHdr, ARPCB_DEST, VcHdr);
    ASSERT_VALID_DEST(pDest);
    pIF     = (ARP1394_INTERFACE*)  RM_PARENT_OBJECT(pDest);

    //
    // Since all our calls are outgoing, getting an IncomingClose means that
    // the call was in the active state. Anyway, what we need to do is update the
    // call state and start the VcCleanupTask for this Vc.
    //

    //
    // This is the broadcast channel VC.
    // FOR NOW: we leave the IF alone, but deinit the dest-VC.
    //
    OBJLOG1(pDest,"Got incoming close!  Status=0x%lx\n", CloseStatus);
    LOGSTATS_IncomingClosesOnChannels(pIF);
    (VOID) arpDeinitDestination(pDest, FALSE, &sr); // FALSE == force deinit

    RM_ASSERT_CLEAR(&sr);
}


UINT
arpProcessReceivedPacket(
    IN  PARP1394_INTERFACE      pIF,
    IN  PNDIS_PACKET            pNdisPacket,
    IN  MYBOOL                  IsChannel
    )
{

    ENTER("arpProcessReceivedPacket", 0xe317990b)
    UINT                    TotalLength;    // Total bytes in packet
    PNDIS_BUFFER            pNdisBuffer;    // Pointer to first buffer
    UINT                    BufferLength;
    UINT                    ReturnCount;
    PVOID                   pvPktHeader;
    PNIC1394_ENCAPSULATION_HEADER
                            pEncapHeader;
    const UINT              MacHeaderLength = sizeof(NIC1394_ENCAPSULATION_HEADER);
    ARP1394_ADAPTER *   pAdapter =
                            (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
    BOOLEAN                 fBridgeMode = ARP_BRIDGE_ENABLED(pAdapter);

    DBGMARK(0x2361f585);

    ReturnCount = 0;

    NdisQueryPacket(
                    pNdisPacket,
                    NULL,
                    NULL,
                    &pNdisBuffer,
                    &TotalLength
                    );


    if (TotalLength > 0)
    {
        NdisQueryBuffer(
                pNdisBuffer,
                (PVOID *)&pvPktHeader,
                &BufferLength
                );
    }
    else
    {
        pvPktHeader = NULL;
        BufferLength = 0;
    }

    pEncapHeader  = (PNIC1394_ENCAPSULATION_HEADER) pvPktHeader;

    TR_INFO(
("Rcv: NDISpkt 0x%x, NDISbuf 0x%x, Buflen %d, Totlen %d, Pkthdr 0x%x\n",
                pNdisPacket,
                pNdisBuffer,
                BufferLength,
                TotalLength,
                pvPktHeader));

    // TODO -- we include mcap/arp in InOctets below, is this the right thing?
    //
    ARP_IF_STAT_ADD(pIF, InOctets, TotalLength);

    LOGSTATS_TotRecvs(pIF, pNdisPacket);
    if (IsChannel)
    {
        LOGSTATS_RecvChannelCounts(pIF, pNdisPacket);
    }
    else
    {
        LOGSTATS_RecvFifoCounts(pIF, pNdisPacket);
    }
    

    if (BufferLength < MacHeaderLength || pvPktHeader == NULL)
    {
        // Packet is too small, discard.
        //
        ARP_IF_STAT_INCR(pIF, InDiscards);
        return 0;                               // EARLY RETURN
    }

    if (fBridgeMode)
    {
        arpEthReceive1394Packet(
                pIF,
                pNdisPacket,
                pvPktHeader,
                BufferLength,
                IsChannel
                );
        return 0;                       // ********* EARLY RETURN *******
    }


    //
    // Discard the packet if the IP interface is not open
    //
    if (!CHECK_IF_IP_STATE(pIF, ARPIF_IPS_OPEN))
    {
        TR_INFO(("Discardning received pkt because pIF 0x%p IP IF is not open.\n", pIF));

        return 0;                       // ********* EARLY RETURN *******
    }

    //
    // At this point, pEncapHeader contains the IP/1394 unfragmented encapsulation
    // header. We look at the ethertype to decide what to do with it.
    //
    if (pEncapHeader->EtherType ==  H2N_USHORT(NIC1394_ETHERTYPE_IP))
    {
        //
        //  The EtherType is IP, so we pass up this packet to the IP layer.
        // (Also we indicate all packets we receive on the broadcast channel
        // to the ethernet VC).
        //

        TR_INFO(
            ("Rcv: pPkt 0x%x: EtherType is IP, passing up.\n", pNdisPacket));

        if (IsChannel)
        {
            ARP_IF_STAT_INCR(pIF, InNonUnicastPkts);

        }
        else
        {
            ARP_IF_STAT_INCR(pIF, InUnicastPkts);
        }

        if (NDIS_GET_PACKET_STATUS(pNdisPacket) != NDIS_STATUS_RESOURCES)
        {
            UINT    DataSize;
            #define ARP_MIN_1ST_RECV_BUFSIZE 512

            //
            // Following are notes taken from atmarpc.sys sources...
            //
            // 2/8/1998 JosephJ
            //      We set DataSize to the total payload size,
            //      unless the first buffer is too small to
            //      hold the IP header. In the latter case,
            //      we set DataSize to be the size of the 1st buffer
            //      (minus the LLS/SNAP header size).
            //
            //      This is to work around a bug in tcpip.
            //
            // 2/25/1998 JosephJ
            //      Unfortunately we have to back out YET AGAIN
            //      because large pings (eg ping -l 4000) doesn't
            //      work -- bug#297784
            //      Hence the "0" in "0 && DataSize" below.
            //      Take out the "0" to put back the per fix.
            //

            //
            // Note: MacHeaderLength is the TOTAL size of the stuff before the
            // start of the IP pkt. This includes the size of the encapsulation
            // header plus (for channels only) the size of the GASP header.
            //

            DataSize = BufferLength - MacHeaderLength;

            {
                LOGSTATS_CopyRecvs(pIF, pNdisPacket);
            }

            pIF->ip.RcvPktHandler(
                pIF->ip.Context,
                (PVOID)((PUCHAR)pEncapHeader+sizeof(*pEncapHeader)), // start of data
                DataSize,
                TotalLength,
                (NDIS_HANDLE)pNdisPacket,
                MacHeaderLength,
                IsChannel,
                0,
                pNdisBuffer,
                &ReturnCount,
                NULL
                );
        }
        else
        {
            LOGSTATS_ResourceRecvs(pIF, pNdisPacket);

            pIF->ip.RcvHandler(
                pIF->ip.Context,
                (PVOID)((PUCHAR)pEncapHeader+sizeof(*pEncapHeader)),
                BufferLength - MacHeaderLength,
                TotalLength - MacHeaderLength,
                (NDIS_HANDLE)pNdisPacket,
                MacHeaderLength,
                IsChannel,
                NULL
                );
        }
    }
    else if (pEncapHeader->EtherType ==  H2N_USHORT(NIC1394_ETHERTYPE_ARP))
    {
        PIP1394_ARP_PKT pArpPkt =  (PIP1394_ARP_PKT) pEncapHeader;
        if (TotalLength != BufferLength)
        {
            ASSERT(!"Can't deal with TotalLength != BufferLength");
        }
        else
        {
            arpProcessArpPkt(
                pIF,
                pArpPkt, 
                BufferLength
                );
        }
    }
    else if (pEncapHeader->EtherType ==  H2N_USHORT(NIC1394_ETHERTYPE_MCAP))
    {
        PIP1394_MCAP_PKT pMcapPkt =  (PIP1394_MCAP_PKT) pEncapHeader;
        if (TotalLength != BufferLength)
        {
            ASSERT(!"Can't deal wiht TotalLength != BufferLength");
        }
        else
        {
            arpProcessMcapPkt(
                pIF,
                pMcapPkt, 
                BufferLength
                );
        }
    }
    else
    {
        //
        //  Discard packet -- unknown/bad EtherType
        //
        TR_INFO(("Encap hdr 0x%x, bad EtherType 0x%x\n",
                 pEncapHeader, pEncapHeader->EtherType));
        ARP_IF_STAT_INCR(pIF, UnknownProtos);
    }

    EXIT()
    return ReturnCount;
}

NDIS_STATUS
arpInitializeIfPools(
    IN  PARP1394_INTERFACE pIF,
    IN  PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    This routine is called in the context of creating an interface. It
    allocate the various buffer and packet pools associated with the interface.
    It cleans up all pools on failure.

Arguments:

    pIF - Interface to initialize

Return Value:

    NDIS_STATUS_SUCCESS on success
    Ndis failure code otherwise.

--*/
{
    ENTER("arpInitializeIfPools", 0x0a3b1b32)
    MYBOOL fHeaderPoolInitialized = FALSE;
    MYBOOL fPacketPoolInitialized = FALSE;
    MYBOOL fEthernetPoolsInitialized = FALSE;
    NDIS_STATUS Status;

    do
    {
        // TODO: replace 10, 100, by constants, or perhaps global vars.

        Status = arpInitializeConstBufferPool(
                        10,                             //NumBuffersToCache,
                        100,                            //MaxBuffers,
                        &Arp1394_IpEncapHeader,         //pvMem,
                        sizeof(Arp1394_IpEncapHeader),  //cbMem,
                        &pIF->Hdr,
                        &pIF->sendinfo.HeaderPool,
                        pSR
                        );

        if (FAIL(Status))
        {
            OBJLOG1(
                pIF,
                "Couldn't initialize const header pool (Status=0x%lx)!\n",
                Status
                );
            break;
        }

        fHeaderPoolInitialized = TRUE;

        Status =  arpAllocateControlPacketPool(
                                    pIF,
                                    ARP1394_MAX_PROTOCOL_PACKET_SIZE,
                                    pSR
                                    );

        if (FAIL(Status))
        {
            TR_WARN((
                "Couldn't allocate control packet pool (Status=0x%lx)!\n",
                Status
                ));
            break;
        }

        fPacketPoolInitialized = TRUE;

        Status = arpAllocateEthernetPools(
                                pIF,
                                pSR
                                );

        if (FAIL(Status))
        {
            OBJLOG1(
                pIF,
                "Couldn't allocate ethernet packet pool (Status=0x%lx)!\n",
                Status
                );
            break;
        }
        fEthernetPoolsInitialized = TRUE;

    } while (FALSE);

    if (FAIL(Status))
    {
        if (fHeaderPoolInitialized)
        {
            // Deinit the header const buffer pool.
            //
            arpDeinitializeConstBufferPool(&pIF->sendinfo.HeaderPool, pSR);
        }

        if (fPacketPoolInitialized)
        {
            // Deinit the control packet pool
            //
            arpFreeControlPacketPool( pIF,pSR);
        }

        if (fEthernetPoolsInitialized)
        {
            // Deinit the ethernet packet pool
            //
            arpFreeEthernetPools(pIF, pSR);
        }
    }
    else
    {
        ASSERT(fHeaderPoolInitialized && fPacketPoolInitialized);
        ASSERT(fEthernetPoolsInitialized);
    }

    return Status;
}


VOID
arpDeInitializeIfPools(
    IN  PARP1394_INTERFACE pIF,     // LOCKIN LOCKOUT
    IN  PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

    This routine is called in the context of deleting an interface. It
    cleans up the various buffer and packet pools associated with the interface.

    Should NOT be called with a partially-initialized pIF.

Arguments:

    pIF - Interface to deinit pools


--*/
{
    ENTER("arpDeInitializeIfPools", 0x1a54488d)
    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);

    // Deinit the header const buffer pool.
    //
    arpDeinitializeConstBufferPool(&pIF->sendinfo.HeaderPool, pSR);

    // Deinit the control packet pool
    //
    arpFreeControlPacketPool(pIF,pSR);

    // Deinit the ethernet packet and buffer pool
    //
    arpFreeEthernetPools(pIF,pSR);

}


MYBOOL
arpIsAdapterConnected(
        IN  PARP1394_ADAPTER    pAdapter,   // NOLOCKIN NOLOCKOUT
        IN  PRM_STACK_RECORD    pSR
        )
{
    ENTER("arpIsAdapterConnected", 0x126b577a)
    // static UINT u = 0;
    MYBOOL  fRet;
    ARP_NDIS_REQUEST            ArpNdisRequest;
    NDIS_MEDIA_STATE            ConnectStatus;
    NDIS_STATUS Status;

    RM_ASSERT_NOLOCKS(pSR);

#if 0
    if (u==0)
    {
        fRet = FALSE;
        u=1;
    }
    else
    {
        fRet = TRUE;
    }
#else // !0

    Status =  arpPrepareAndSendNdisRequest(
                pAdapter,
                &ArpNdisRequest,
                NULL,                       // pTask (NULL==BLOCK)
                0,                          // unused
                OID_1394_IP1394_CONNECT_STATUS,
                &ConnectStatus,
                sizeof(ConnectStatus),
                NdisRequestQueryInformation,
                pSR
                );
    ASSERT(!PEND(Status));

    fRet = FALSE;
    if (!FAIL(Status))
    {
        if (ConnectStatus == NdisMediaStateConnected)
        {
            fRet = TRUE;
        }
    }
#endif // !0
    
    
    RM_ASSERT_NOLOCKS(pSR);
    EXIT()
    return fRet;
}


NDIS_STATUS
arpSetupSpecialDest(
    IN  PARP1394_INTERFACE      pIF,
    IN  NIC1394_ADDRESS_TYPE    AddressType,
    IN  PRM_TASK                pParentTask,
    IN  UINT                    PendCode,
    OUT PARPCB_DEST         *   ppSpecialDest,
    IN  PRM_STACK_RECORD        pSR
    )
{
    ENTER("SetupSpecialDest", 0x745a806d)
    ARP_DEST_PARAMS     DestParams;
    PCHAR               szDescription;
    PARPCB_DEST         pDest;
    INT                 fCreated = FALSE;
    PRM_TASK            pMakeCallTask;
    NDIS_STATUS         Status;
    MYBOOL              fBroadcastDest = FALSE;
    ULONG               LookupFlags = 0;
    PARP1394_ADAPTER    pAdapter = (PARP1394_ADAPTER)RM_PARENT_OBJECT(pIF);

    *ppSpecialDest = NULL;

    //
    // Let's create a destination object representing the
    // multichannel, and make a call to it.
    //
    ARP_ZEROSTRUCT(&DestParams);

    DestParams.HwAddr.AddressType =  AddressType;

    switch(AddressType)
    {
    case NIC1394AddressType_Channel:
        DestParams.HwAddr.Channel =  NIC1394_BROADCAST_CHANNEL;
        fBroadcastDest = TRUE;
        szDescription = "Task: Broadcast MakeCall";
    break;

    case NIC1394AddressType_MultiChannel:
        szDescription = "Task: MultiChannel MakeCall";
    break;

    case NIC1394AddressType_Ethernet:
        szDescription = "Task: Ethernet MakeCall";
    break;

    default:
        ASSERT(FALSE);
        return NDIS_STATUS_FAILURE;                 // ****** EARLY RETURN *****
    }

#if RM_EXTRA_CHECKING
    switch(AddressType)
    {
    case NIC1394AddressType_Channel:
        szDescription = "Task: Broadcast MakeCall";
    break;

    case NIC1394AddressType_MultiChannel:
        szDescription = "Task: MultiChannel MakeCall";
    break;

    case NIC1394AddressType_Ethernet:
        szDescription = "Task: Ethernet MakeCall";
    break;

    default:
        ASSERT(FALSE);
        return NDIS_STATUS_FAILURE;                 // ****** EARLY RETURN *****
    }
#endif // RM_EXTRA_CHECKING


    // Now create a destination item for this structure.
    //
    if (CHECK_POWER_STATE(pAdapter,ARPAD_POWER_LOW_POWER) == TRUE)
    {
        // In the resume, the Destination structures are aleady there
        // so don't create a new one.

        LookupFlags = 0;
    }
    else
    {
        //
        // We don't expect it to already exist in the non PM case
        //
        LookupFlags = RM_CREATE | RM_NEW;
    }
    
    Status = RmLookupObjectInGroup(
                    &pIF->DestinationGroup,
                    LookupFlags ,       
                    &DestParams,    // Key
                    &DestParams,    // pParams
                    (RM_OBJECT_HEADER**) &pDest,
                    &fCreated,
                    pSR
                    );
    if (FAIL(Status))
    {
        OBJLOG1( pIF, "FATAL: Couldn't create special dest type %d.\n", AddressType);
    }
    else
    {

        Status = arpAllocateTask(
                    &pDest->Hdr,            // pParentObject
                    arpTaskMakeCallToDest,  // pfnHandler
                    0,                      // Timeout
                    szDescription,
                    &pMakeCallTask,
                    pSR
                    );

        if (FAIL(Status))
        {
            RmTmpDereferenceObject(&pDest->Hdr, pSR);

            // NOTE: Even on failure, we leave the newly-created
            // special dest object. It will get cleaned up when
            // the interface is unloaded.
            //
        }
        else
        {
            *ppSpecialDest = pDest;

            if (fBroadcastDest)
            {
                // pDest contains a valid
                // pDest which has been tmpref'd. 
                // Keep a pointer to the broadcast dest in the IF.
                // and  link the broadcast dest to the IF.
                //
            #if RM_EXTRA_CHECKING
                RmLinkObjectsEx(
                    &pIF->Hdr,
                    &pDest->Hdr,
                    0xacc1dbe9,
                    ARPASSOC_LINK_IF_OF_BCDEST,
                    "    IF of Broadcast Dest 0x%p (%s)\n",
                    ARPASSOC_LINK_BCDEST_OF_IF,
                    "    Broadcast Dest of IF 0x%p (%s)\n",
                    pSR
                    );
            #else // !RM_EXTRA_CHECKING
                RmLinkObjects(&pIF->Hdr, &pDest->Hdr,pSR);
            #endif // !RM_EXTRA_CHECKING

                LOCKOBJ(pIF, pSR);
                ASSERT(pIF->pBroadcastDest == NULL);
                pIF->pBroadcastDest = pDest;
                UNLOCKOBJ(pIF, pSR);

                // arpSetupSpecialDest ref'd pDest.
                //
                RmTmpDereferenceObject(&pDest->Hdr, pSR);
            }

            RmPendTaskOnOtherTask(
                pParentTask,
                PendCode,
                pMakeCallTask,
                pSR
                );
    
            (VOID)RmStartTask(
                    pMakeCallTask,
                    0, // UserParam (unused)
                    pSR
                    );
        
            Status = NDIS_STATUS_PENDING;
        }
    }

    return Status;
}



VOID
arpDestSendComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PNDIS_PACKET                pNdisPacket
)
{
    PARP_VC_HEADER pVcHdr       = (PARP_VC_HEADER) ProtocolVcContext;
    PARPCB_DEST         pDest   = CONTAINING_RECORD(pVcHdr, ARPCB_DEST, VcHdr);
    PARP1394_INTERFACE  pIF     = (PARP1394_INTERFACE) RM_PARENT_OBJECT(pDest);

    ASSERT_VALID_DEST(pDest);
    ASSERT_VALID_INTERFACE(pIF);

    // The call to NdisCoSendPacket returns.

    arpCompleteSentPkt(
            Status,
            pIF,
            pDest,
            pNdisPacket
            );
}


UINT
arpDestReceivePacket(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PNDIS_PACKET                pNdisPacket
)
//
// Standard Recv Handler for most Vcs
//
{
    PARP_VC_HEADER          pVcHdr;
    PARPCB_DEST             pDest;
    PARP1394_INTERFACE      pIF;
    PARP1394_ADAPTER        pAdapter ;
    BOOLEAN                 fBridgeMode ;
    
    pVcHdr  = (PARP_VC_HEADER) ProtocolVcContext;
    pDest   =  CONTAINING_RECORD( pVcHdr, ARPCB_DEST, VcHdr);
    ASSERT_VALID_DEST(pDest);
    pIF     = (ARP1394_INTERFACE*)  RM_PARENT_OBJECT(pDest);
    ASSERT_VALID_INTERFACE(pIF);

    pAdapter = (PARP1394_ADAPTER)pIF->Hdr.pParentObject;
        
    fBridgeMode = ARP_BRIDGE_ENABLED(pAdapter);

    //
    // if we are in bridge mode, then check to see if 
    // this is a loopback packet
    //
    if (fBridgeMode == TRUE)
    {
        
        PLOOPBACK_RSVD pLoopbackRsvd = (PLOOPBACK_RSVD) pNdisPacket->ProtocolReserved;
        
        BOOLEAN fIsLoopbackPacket = (pLoopbackRsvd->LoopbackTag == NIC_LOOPBACK_TAG);

        if (fIsLoopbackPacket  == TRUE)
        {
            // drop the packet as it is a loopback packet
            return 0;
        }

        // else it is a normal receive. continue to arpProcessReceivedPacket
    }


    //
    // Process the receive packet
    //

    return arpProcessReceivedPacket(
                pIF,
                pNdisPacket,
                TRUE                    // IsChannel
                );

}


VOID
arpDestIncomingClose(
    IN  NDIS_STATUS                 CloseStatus,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PVOID                       pCloseData  OPTIONAL,
    IN  UINT                        Size        OPTIONAL
)
{
    PARP_VC_HEADER          pVcHdr;
    PARP1394_INTERFACE      pIF;
    ARPCB_DEST          *   pDest;
    ENTER("arpDestIncomingClose",0x8727a7f1)        
    RM_DECLARE_STACK_RECORD(sr)

    pVcHdr  = (PARP_VC_HEADER) ProtocolVcContext;
    pDest   =  CONTAINING_RECORD( pVcHdr, ARPCB_DEST, VcHdr);
    ASSERT_VALID_DEST(pDest);
    pIF     = (ARP1394_INTERFACE*)  RM_PARENT_OBJECT(pDest);

    //
    // Since all our calls are outgoing, getting an IncomingClose means that
    // the call was in the active state. Anyway, what we need to do is update the
    // call state and start the VcCleanupTask for this Vc.
    //

    //
    // We leave the IF alone, but deinit the dest-VC.
    //
    OBJLOG1(pDest,"Got incoming close!  Status=0x%lx\n", CloseStatus);
    LOGSTATS_IncomingClosesOnChannels(pIF);

    {
        ARP1394_ADAPTER *pAdapter = (ARP1394_ADAPTER*)RM_PARENT_OBJECT(pIF);
        BOOLEAN fBridgeMode = ARP_BRIDGE_ENABLED(pAdapter);
        NDIS_STATUS Status = NDIS_STATUS_FAILURE;
        //
        // If the Bridge is enabled, then just close the call on the destination.
        // In the normal case, we delete the destintation structure. 
        if (fBridgeMode == TRUE)
        {
            PRM_TASK pCleanupCallTask = NULL;

            // 
            // In the Bridgecase we want to keep alive our knowledge 
            // about the 1394 network as we 
            // can only learn this knowledge from Ethernet arps 
            // which are outside our control. 
            //

            //
            // AN incoming close signifies that the Remote Node that this Dest
            // represents has gone away. We want to keep the Dest structure alive
            // in case the other node resumes from standby/ hibernate and 
            // does not send out any ARPs so we cannot learn its address.
            //
            //

                
            Status = arpAllocateTask(
                        &pDest->Hdr,                // pParentObject,
                        arpTaskCleanupCallToDest,   // pfnHandler,
                        0,                          // Timeout,
                        "Task: CleanupCall on UnloadDest",  // szDescription
                        &pCleanupCallTask,
                        &sr
                        );
        
            if (FAIL(Status))
            {
                TR_WARN(("FATAL: couldn't alloc cleanup call task!\n"));
            }
            else
            {
        
                // RmStartTask uses up the tmpref on the task
                // which was added by arpAllocateTask.
                //
                Status = RmStartTask(
                            pCleanupCallTask,
                            0, // UserParam (unused)
                            &sr
                            );
            }



        }
        else
        {
            (VOID) arpDeinitDestination(pDest, FALSE, &sr); //  FALSE == forced deinit

        }

    }
    
    RM_ASSERT_CLEAR(&sr);
}

VOID
arpTryAbortPrimaryIfTask(
    PARP1394_INTERFACE      pIF,    // NOLOCKIN NOLOCKOUT
    PRM_STACK_RECORD        pSR
    )
{
    ENTER("arpTryAbortPrimaryIfTask", 0x39c51d16)

    RM_ASSERT_NOLOCKS(pSR);
    LOCKOBJ(pIF,pSR);

    if (pIF->pActDeactTask!=NULL)
    {
        //
        // Actually 
        // delayed.
        //
        PRM_TASK pTask = pIF->pActDeactTask;
        RmTmpReferenceObject(&pTask->Hdr, pSR);
        UNLOCKOBJ(pIF,pSR);
        
        if (pTask->pfnHandler ==  arpTaskActivateInterface)
        {
            TASK_ACTIVATE_IF *pActivateIfTask =  (TASK_ACTIVATE_IF *) pTask;
            UINT TaskResumed;
            TR_WARN(("Aborting ActivateIfTask %p\n", pTask));
            RmResumeDelayedTaskNow(
                &pActivateIfTask->TskHdr,
                &pActivateIfTask->Timer,
                &TaskResumed,
                pSR
                );
        }
        RmTmpDereferenceObject(&pTask->Hdr, pSR);
    }
    else
    {
        UNLOCKOBJ(pIF,pSR);
    }

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
}


NDIS_STATUS
arpTaskIfMaintenance(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for periodic IF maintenance.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pTask);
    PTASK_IF_MAINTENANCE    pIfTask;

    enum
    {
        STAGE_Start,
        STAGE_ResumeDelayed,
        STAGE_End

    } Stage;

    ENTER("TaskIfMaintenance", 0x57e523ed)

    pIfTask = (PTASK_IF_MAINTENANCE) pTask;
    ASSERT(sizeof(TASK_IF_MAINTENANCE) <= sizeof(ARP1394_TASK));

    // 
    // Message normalizing code
    //
    switch(Code)
    {

        case RM_TASKOP_START:
            Stage = STAGE_Start;
            break;

        case  RM_TASKOP_PENDCOMPLETE:
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            Stage = RM_PEND_CODE(pTask);
            break;

        case RM_TASKOP_END:
            Status = (NDIS_STATUS) UserParam;
            Stage= STAGE_End;
            break;

        default:
            ASSERT(FALSE);
            return NDIS_STATUS_FAILURE;                 // ** EARLY RETURN **

    }

    ASSERTEX(!PEND(Status), pTask);
        
    switch(Stage)
    {

        case  STAGE_Start:
        {
            // If there is already a maintenance task, we exit immediately.
            //
            LOCKOBJ(pIF, pSR);
            if (pIF->pMaintenanceTask == NULL)
            {
                pIF->pMaintenanceTask = pTask;
                DBG_ADDASSOC(
                    &pIF->Hdr,                      // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_IF_MAINTENANCE_TASK,       // AssociationID
                    "    Official maintenance task 0x%p (%s)\n", // szFormat
                    pSR
                    );
            }
            else
            {
                // There already is a maintenance task. We're done.
                //
                UNLOCKOBJ(pIF, pSR);
                Status = NDIS_STATUS_SUCCESS;
                break;
            }
            UNLOCKOBJ(pIF, pSR);
        
            //
            // We're now the official maintenance task for this interface.
            //

            
            // We move on to the next stage, after a delay, and to get
            // out of the current context.
            //
            pIfTask->Delay = 5; // Arbitrary initial delay (seconds)

            RmSuspendTask(pTask, STAGE_ResumeDelayed, pSR);
            RmResumeTaskDelayed(
                pTask, 
                0,
                1000 * pIfTask->Delay,
                &pIfTask->Timer,
                pSR
                );
            Status = NDIS_STATUS_PENDING;


         }
         break;

        case STAGE_ResumeDelayed:
        {
            UINT    Time;
            UINT    Delta;
            MYBOOL  fProcessed;
            //
            // If qe're quitting, we get out of here.
            // Otherwise we'll send a packet either on the ethernet VC
            // or via the miniport's connectionless ethernet interface.
            //

            if (pIfTask->Quit)
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            Time = arpGetSystemTime();

            //
            // Process the MCAP database
            //
            Delta =  Time - pIfTask->McapDbMaintenanceTime;
            arpDoMcapDbMaintenance(pIF, Time, Delta, &fProcessed, pSR);
            if (fProcessed)
            {
                //
                // Update the last "McapDbMaintenance" time.
                //
                pIfTask->McapDbMaintenanceTime = Time;
            }

            //
            // Process Remote IPs
            //
            Delta =  Time - pIfTask->RemoteIpMaintenanceTime;
            arpDoRemoteIpMaintenance(pIF, Time, Delta, &fProcessed, pSR);
        
            if (fProcessed)
            {
                //
                // Update the last "RemoteIpMaintenance" time.
                //
                pIfTask->RemoteIpMaintenanceTime = Time;
            }

            //
            // Process Remote Eths
            //
            Delta =  Time - pIfTask->RemoteEthMaintenanceTime;
            arpDoRemoteEthMaintenance(pIF, Time, Delta, &fProcessed, pSR);
        
            if (fProcessed)
            {
                //
                // Update the last "RemoteIpMaintenance" time.
                //
                pIfTask->RemoteEthMaintenanceTime = Time;
            }

            //
            // Process Local IPs
            //
            Delta =  Time - pIfTask->LocalIpMaintenanceTime;
            arpDoLocalIpMaintenance(pIF, Time, Delta, &fProcessed, pSR);
        
            if (fProcessed)
            {
                //
                // Update the last "LocalIpMaintenance" time.
                //
                pIfTask->LocalIpMaintenanceTime = Time;
            }

            //
            // Process DhcpTableEntries
            //
            Delta =  Time - pIfTask->DhcpTableMaintainanceTime;;
            arpDoDhcpTableMaintenance(pIF, Time, Delta, &fProcessed, pSR);
        
            if (fProcessed)
            {
                //
                // Update the last "LocalIpMaintenance" time.
                //
                pIfTask->DhcpTableMaintainanceTime= Time;
            }

            // Now we wait again...
            //
            RmSuspendTask(pTask, STAGE_ResumeDelayed, pSR);
            RmResumeTaskDelayed(
                pTask, 
                0,
                1000 * pIfTask->Delay,
                &pIfTask->Timer,
                pSR
                );
            Status = NDIS_STATUS_PENDING;

        }
        break;

        case STAGE_End:
        {
            NDIS_HANDLE                 BindContext;


            LOCKOBJ(pIF, pSR);
            if (pIF->pMaintenanceTask == pTask)
            {
                // We're the official ics test task, we clear ourselves from
                // the interface object and do any initialization required.
                //
                DBG_DELASSOC(
                    &pIF->Hdr,                      // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_IF_MAINTENANCE_TASK,       // AssociationID
                    pSR
                    );
                pIF->pMaintenanceTask = NULL;
                UNLOCKOBJ(pIF, pSR);
            }
            else
            {
                // We're not the official IF maintenance task.
                // Nothing else to do.
                //
                UNLOCKOBJ(pIF, pSR);
                break;
            }
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


VOID
arpStartIfMaintenanceTask(
    IN  PARP1394_INTERFACE          pIF,  // NOLOCKIN NOLOCKOUT
    PRM_STACK_RECORD                pSR
    )
{
    PRM_TASK pTask;
    NDIS_STATUS Status;
    ENTER("arpStartIfMaintenanceTask", 0xb987276b)

    RM_ASSERT_NOLOCKS(pSR);

    //
    // Allocate and start an instance of the arpTaskIfMaintenance task.
    //

    Status = arpAllocateTask(
                &pIF->Hdr,          // pParentObject
                arpTaskIfMaintenance,       // pfnHandler
                0,                              // Timeout
                "Task: IF Maintenance", // szDescription
                &pTask,
                pSR
                );

    if (FAIL(Status))
    {
        TR_WARN(("couldn't alloc IF maintenance task!\n"));
    }
    else
    {

        (VOID)RmStartTask(
                    pTask,
                    0, // UserParam (unused)
                    pSR
                    );
    }

    EXIT()
}

NDIS_STATUS
arpTryStopIfMaintenanceTask(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    IN  PRM_TASK                    pTask, // task to pend until M task completes
    IN  UINT                        PendCode, // Pend code to suspend task.
    PRM_STACK_RECORD                pSR
    )
/*++
    Status : PENDING means task has been suspended, non PENDING
    means operation has completed synchronously.
--*/
{
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    PTASK_IF_MAINTENANCE    pIfTask;
    ENTER("arpTryStopIfMaintenanceTask", 0xb987276b)


    LOCKOBJ(pIF, pSR);

    pIfTask = (PTASK_IF_MAINTENANCE) pIF->pMaintenanceTask;
    if (pIfTask != NULL)
    {
        pIfTask->Quit = TRUE;
        RmTmpReferenceObject(&pIfTask->TskHdr.Hdr, pSR);
    }
    UNLOCKOBJ(pIF, pSR);

    //
    // Resume the maintenance task if it's waiting  -- it will then quit
    // because we set the Quit field above.
    //
    if (pIfTask != NULL)
    {
        UINT    TaskResumed;

        Status = RmPendTaskOnOtherTask(
                    pTask,
                    PendCode,
                    &pIfTask->TskHdr,
                    pSR
                    );

        if (Status == NDIS_STATUS_SUCCESS)
        {
            RmResumeDelayedTaskNow(
                &pIfTask->TskHdr,
                &pIfTask->Timer,
                &TaskResumed,
                pSR
                );
            Status = NDIS_STATUS_PENDING; // We've GOT to return pending!
        }
        else
        {
            ASSERT(FALSE);
            Status = NDIS_STATUS_FAILURE;
        }

        RmTmpDereferenceObject(&pIfTask->TskHdr.Hdr, pSR);
    }

    RM_ASSERT_NOLOCKS(pSR)
    EXIT()

    return Status;
}

VOID
arpDoLocalIpMaintenance(
        PARP1394_INTERFACE pIF,
        UINT CurrentTime,
        UINT SecondsSinceLastMaintenance,
        MYBOOL *pfProcessed,
        PRM_STACK_RECORD pSR
        )
{
    ENTER("LocalIpMaintenance", 0x1a39fc89)

    if (SecondsSinceLastMaintenance < 10)
    {
        TR_INFO(("Skipping Local Ip maintenance (delay=%lu).\n",
                SecondsSinceLastMaintenance
                ));
        *pfProcessed = FALSE;
        return;                             // EARLY RETURN;
    }

    *pfProcessed = TRUE;

    TR_INFO(("Actually doing Local Ip maintenance.\n"));

    RmWeakEnumerateObjectsInGroup(
        &pIF->LocalIpGroup,
        arpMaintainOneLocalIp,
        NULL, // Context
        pSR
        );

    EXIT()
}

VOID
arpDoRemoteIpMaintenance(
        PARP1394_INTERFACE pIF,
        UINT CurrentTime,
        UINT SecondsSinceLastMaintenance,
        MYBOOL *pfProcessed,
        PRM_STACK_RECORD pSR
        )
{
    ENTER("RemoteIpMaintenance", 0x1ae00035)

    if (SecondsSinceLastMaintenance < 15)
    {
        TR_INFO(("Skipping Remote Ip maintenance (delay=%lu).\n",
                SecondsSinceLastMaintenance
                ));
        *pfProcessed = FALSE;
        return;                             // EARLY RETURN;
    }

    *pfProcessed = TRUE;

    TR_INFO(("Actually doing Remote Ip maintenance.\n"));

    RmWeakEnumerateObjectsInGroup(
        &pIF->RemoteIpGroup,
        arpMaintainArpCache,
        NULL, // Context
        pSR
        );

    EXIT()
}


VOID
arpDoRemoteEthMaintenance(
        PARP1394_INTERFACE pIF,
        UINT CurrentTime,
        UINT SecondsSinceLastMaintenance,
        MYBOOL *pfProcessed,
        PRM_STACK_RECORD pSR
        )
{
    ENTER("RemoteEthMaintenance", 0x6c496b7f)

    if (SecondsSinceLastMaintenance < 15)
    {
        TR_INFO(("Skipping Eth Ip maintenance (delay=%lu).\n",
                SecondsSinceLastMaintenance
                ));
        *pfProcessed = FALSE;
        return;                             // EARLY RETURN;
    }

    *pfProcessed = TRUE;

    TR_INFO(("Actually doing Remote Eth maintenance.\n"));

    RmWeakEnumerateObjectsInGroup(
        &pIF->RemoteEthGroup,
        arpMaintainOneRemoteEth,
        NULL, // Context
        pSR
        );

    EXIT()
}


VOID
arpDoDhcpTableMaintenance(
        PARP1394_INTERFACE pIF,
        UINT CurrentTime,
        UINT SecondsSinceLastMaintenance,
        MYBOOL *pfProcessed,
        PRM_STACK_RECORD pSR
        )
{
    ENTER("DhcpMaintenance", 0x1a39fc89)

    if (SecondsSinceLastMaintenance < 120)
    {
        TR_INFO(("Skipping Local Ip maintenance (delay=%lu).\n",
                SecondsSinceLastMaintenance
                ));
        *pfProcessed = FALSE;
        return;                             // EARLY RETURN;
    }

    *pfProcessed = TRUE;

    TR_INFO(("Actually doing Dhcp maintenance.\n"));

    RmWeakEnumerateObjectsInGroup(
        &pIF->EthDhcpGroup,
        arpMaintainOneDhcpEntry,
        NULL, // Context
        pSR
        );

    EXIT()
}


// Enum function
//
INT
arpMaintainOneDhcpEntry(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,  // Unused
        PRM_STACK_RECORD    pSR
        )
{
    ENTER("arpMaintainOneDhcpEntry", 0xc7604372)
    NDIS_STATUS         Status;
    ARP1394_ETH_DHCP_ENTRY *pEntry;
    PARP1394_INTERFACE  pIF;


    pEntry = (ARP1394_ETH_DHCP_ENTRY *) pHdr;

    pIF = (PARP1394_INTERFACE  )RM_PARENT_OBJECT (pEntry);

    RM_ASSERT_NOLOCKS(pSR);

    do
    {
        UINT                CurrentTime = arpGetSystemTime();

        #define ARP_PURGE_DHCP_TABLE_TIME 90    // Arp entry timeout.

        //
        // NOTE: we don't bother to get the lock with dealing with
        // sendinfo.TimeLastChecked -- this is ok.
        //
        if (pEntry->TimeLastChecked==0)
        {
            // Set this field to the current time. It will be cleared back to 0
            // when the next packet is sent to this remote Eth.
            //
            pEntry->TimeLastChecked = CurrentTime;
        }
        else if ((CurrentTime - pEntry->TimeLastChecked)
                     >= ARP_PURGE_DHCP_TABLE_TIME )
        {
            // 
            // We should clean up this dhcp entry. this is the only code path 
            // from which an entry is ever deleted.
            //

            RmFreeObjectInGroup(
                &pIF->EthDhcpGroup,
                &(pEntry->Hdr),
                NULL,               // NULL pTask == synchronous.
                pSR
                );

            break;
        }

    } while (FALSE);
    
    RM_ASSERT_NOLOCKS(pSR)

    return TRUE; // Continue to enumerate.
}

    
// Enum function
//
INT
arpMaintainOneLocalIp(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,  // Unused
        PRM_STACK_RECORD    pSR
        )
{
    ENTER("MaintainOneLocalIp", 0x1ae00035)
    PARPCB_LOCAL_IP     pLocalIp;
    IP_ADDRESS          LocalAddr;
    PARP1394_INTERFACE  pIF;
    UINT                Channel;

    pLocalIp    = (PARPCB_LOCAL_IP) pHdr;
    LocalAddr   = pLocalIp->IpAddress;
    pIF         = IF_FROM_LOCALIP(pLocalIp);

    RM_ASSERT_NOLOCKS(pSR);
    do
    {
        ARPCB_DEST  *pDest;
        ARP_DEST_PARAMS DestParams;

        // Skip if we can't do MCAP on this address.
        //
        LOCKOBJ(pLocalIp, pSR);
        if (!CHECK_LOCALIP_MCAP(pLocalIp, ARPLOCALIP_MCAP_CAPABLE))
        {
            UNLOCKOBJ(pLocalIp, pSR);
            break;
        }
        UNLOCKOBJ(pLocalIp, pSR);
    
        //
        // Find a channel mapping to this address, if any.
        //
        Channel = arpFindAssignedChannel(
                        pIF, 
                        LocalAddr,
                        0,          // TODO -- pass in current time.
                        pSR
                        );
        
        //
        // NOTE: Special return value NIC1394_BROADCAST_CHANNEL is returned if
        // this address is mapped to no specific channel.
        //
    
        ARP_ZEROSTRUCT(&DestParams);
        DestParams.HwAddr.AddressType =  NIC1394AddressType_Channel;
        DestParams.HwAddr.Channel =  Channel;
        DestParams.ReceiveOnly =  TRUE;
        DestParams.AcquireChannel =  FALSE;

        arpUpdateLocalIpDest(pIF, pLocalIp, &DestParams, pSR);

    
    } while (FALSE);
    
    RM_ASSERT_NOLOCKS(pSR)

    return TRUE; // Continue to enumerate.
}


// Enum function
//
INT
arpMaintainOneRemoteIp(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,  // Unused
        PRM_STACK_RECORD    pSR
        )
#if 0
    for each RIP send VC
        if !marked dirty
            mark dirty
            if linked to channel pdest
            check if channel is still mapped to group
            if not, unlink.
            if required initiate link to new pdest (possibly channel)
        else
            //expired
            unlink from pdest and get rid of it
#endif // 0
{
    ENTER("MaintainOneRemoteIp", 0x1ae00035)
    NDIS_STATUS         Status;
    PARPCB_REMOTE_IP    pRemoteIp;
    PARP1394_INTERFACE  pIF;


    pRemoteIp   = (PARPCB_REMOTE_IP) pHdr;
    pIF         = IF_FROM_LOCALIP(pRemoteIp);

    RM_ASSERT_NOLOCKS(pSR);

    do
    {
        IP_ADDRESS          IpAddr;
        UINT                Channel;
        ARP_DEST_PARAMS     DestParams;
        ARPCB_DEST          *pDest;
        BOOLEAN             AcquireChannel;
        UINT                CurrentTime = arpGetSystemTime();

        IpAddr      = pRemoteIp->Key.IpAddress;

        #define ARP_PURGE_REMOTEIP_TIME 300 // Arp entry timeout.

        //
        // NOTE: we don't bother to get the lock with dealing with
        // sendinfo.TimeLastChecked -- this is ok.
        //
        if (pRemoteIp->sendinfo.TimeLastChecked==0)
        {

            if (CHECK_REMOTEIP_SDTYPE(pRemoteIp, ARPREMOTEIP_DYNAMIC)
                || CHECK_REMOTEIP_RESOLVE_STATE (pRemoteIp, ARPREMOTEIP_UNRESOLVED))
            {
                // Set this field to the current time. It will be cleared back to 0
                // when the next packet is sent to this remote ip.
                //
                pRemoteIp->sendinfo.TimeLastChecked = CurrentTime;
            }
        }
        else if ((CurrentTime - pRemoteIp->sendinfo.TimeLastChecked)
                     >= ARP_PURGE_REMOTEIP_TIME)
        {
            // 
            // We should clean up this remote ip.
            //
            arpDeinitRemoteIp(pRemoteIp, pSR);
            break;
        }

#if ARP_ENABLE_MCAP_SEND

        //
        // We'll now see if we need to re-set which destination this
        // pRemoteIp points to.
        //

        // Skip if we can't do MCAP on this address.
        //
        LOCKOBJ(pRemoteIp, pSR);
        if (!CHECK_REMOTEIP_MCAP(pRemoteIp, ARPREMOTEIP_MCAP_CAPABLE))
        {
            UNLOCKOBJ(pRemoteIp, pSR);
            break;
        }
        UNLOCKOBJ(pRemoteIp, pSR);

        //
        // Find a channel mapping to this address, if any.
        //
        Channel = arpFindAssignedChannel(
                        pIF, 
                        pRemoteIp->Key.IpAddress,
                        0,
                        pSR
                        );
        
        //
        // NOTE: Special return value NIC1394_BROADCAST_CHANNEL is returned if
        // this address is mapped to no specific channel.
        //

        AcquireChannel = FALSE;

    
    #if 0   // Let's not enable this just yet -- instead 

        if (Channel == NIC1394_BROADCAST_CHANNEL)
        {
            //
            // Hmm... let's get aggressive and try to grab a channel.
            //
            Channel = arpFindFreeChannel(pIF, pSR);
            if (Channel != NIC1394_BROADCAST_CHANNEL)
            {
                //
                // Got one!
                //
                AcquireChannel = TRUE;
            }
        }
        else
        {
            //
            // There is already a channel allocated by someone to be used
            // for this ip address. Let's use it.
            //
        }
    #endif // 0 
    
        ARP_ZEROSTRUCT(&DestParams);
        DestParams.HwAddr.AddressType =  NIC1394AddressType_Channel;
        DestParams.HwAddr.Channel =  Channel;
        DestParams.AcquireChannel =  AcquireChannel;

        arpUpdateRemoteIpDest(pIF, pRemoteIp, &DestParams, pSR);

#endif //  ARP_ENABLE_MCAP_SEND

    } while (FALSE);
    
    RM_ASSERT_NOLOCKS(pSR)

    return TRUE; // Continue to enumerate.
}


// Enum function
//
INT
arpMaintainOneRemoteEth(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,  // Unused
        PRM_STACK_RECORD    pSR
        )
{
    ENTER("MaintainOneRemoteEth", 0x21807796)
    NDIS_STATUS         Status;
    PARPCB_REMOTE_ETH   pRemoteEth;
    PARP1394_INTERFACE  pIF;


    pRemoteEth  = (PARPCB_REMOTE_ETH) pHdr;
    pIF         = IF_FROM_LOCALIP(pRemoteEth);

    RM_ASSERT_NOLOCKS(pSR);

    do
    {
        UINT                CurrentTime = arpGetSystemTime();

        #define ARP_PURGE_REMOTEETH_TIME 300    // Arp entry timeout.

        //
        // NOTE: we don't bother to get the lock with dealing with
        // sendinfo.TimeLastChecked -- this is ok.
        //
        if (pRemoteEth->TimeLastChecked==0)
        {
            // Set this field to the current time. It will be cleared back to 0
            // when the next packet is sent to this remote Eth.
            //
            pRemoteEth->TimeLastChecked = CurrentTime;
        }
        else if ((CurrentTime - pRemoteEth->TimeLastChecked)
                     >= ARP_PURGE_REMOTEETH_TIME)
        {
            // 
            // We should clean up this remote eth.
            //
            arpDeinitRemoteEth(pRemoteEth, pSR);
            break;
        }

    } while (FALSE);
    
    RM_ASSERT_NOLOCKS(pSR)

    return TRUE; // Continue to enumerate.
}

UINT
arpFindAssignedChannel(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    IN  IP_ADDRESS                  IpAddress,
    IN  UINT                        CurrentTime, // OPTIONAL
    PRM_STACK_RECORD                pSR
    )
/*++
    NOTE: Special return value NIC1394_BROADCAST_CHANNEL is returned if
    this address is mapped to no specific channel.
--*/
{
    ENTER("FindAssignedChannel", 0xd20a216b)
    UINT Channel = NIC1394_BROADCAST_CHANNEL;
    UINT u;

    LOCKOBJ(pIF, pSR);

    if (CurrentTime == 0)
    {
        CurrentTime = arpGetSystemTime();
    }

    //
    // Run down the channel info array, looking for a matching IP address.
    //
    for (u = 0;  u < ARP_NUM_CHANNELS; u++)
    {
        PMCAP_CHANNEL_INFO pMci;
        pMci = &pIF->mcapinfo.rgChannelInfo[u];

        if (    IpAddress == pMci->GroupAddress
            &&  arpIsActiveMcapChannel(pMci, CurrentTime))
        {
            ASSERT(pMci->Channel == u);
            Channel = u;
            TR_WARN(("Found Matching channel %lu for ip address 0x%lu.\n",
                Channel,
                IpAddress
                ));
            break;
        }
    }

    UNLOCKOBJ(pIF, pSR);

    return Channel;

    EXIT()
}


VOID
arpUpdateLocalIpDest(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    IN  PARPCB_LOCAL_IP             pLocalIp,
    IN  PARP_DEST_PARAMS            pDestParams,
    PRM_STACK_RECORD                pSR
    )
/*++
    Make pLocalIp point to a des with params pDestParams. 
    Create a pDest if required.
    If pLocalIp is pointing to some other pDest, cleanup that other pDest if
    no one else is refering to it.
--*/
{
    ENTER("UpdateLocalIpDest", 0x3f2dcaa7)
    ARPCB_DEST          *pOldDest = NULL;

    RM_ASSERT_NOLOCKS(pSR);

    // pLocalIp uses it's parent's (pIF's) lock.
    //
    RM_ASSERT_SAME_LOCK_AS_PARENT(pLocalIp);

    do
    {
        PCHAR               szDescription;
        INT                 fCreated = FALSE;
        PRM_TASK            pMakeCallTask;
        UINT                Channel;
        NDIS_STATUS         Status;
        ARPCB_DEST          *pDest;

        //
        // Currently, only Channel Dests are supported.
        //
        if (pDestParams->HwAddr.AddressType != NIC1394AddressType_Channel)
        {
            ASSERT(FALSE);
            break;
        }
        else
        {
            Channel =  pDestParams->HwAddr.Channel;
        }

        LOCKOBJ(pIF, pSR);

        RM_DBG_ASSERT_LOCKED(&pLocalIp->Hdr, pSR); // same lock as pIF;
        pDest = pLocalIp->pDest;

        if (pDest != NULL)
        {
            RM_DBG_ASSERT_LOCKED(&pDest->Hdr, pSR); // same lock as pIF;

            if (pDest->Params.HwAddr.AddressType == NIC1394AddressType_Channel)
            {
                if (pDest->Params.HwAddr.Channel == Channel)
                {
                    //
                    // We're already linked to this channel. Nothing more to do.
                    //
                    UNLOCKOBJ(pIF, pSR);
                    break;
                }
            }
            else
            {
                //
                // Shouldn't get here -- MCAP_CAPABLE addresses shouldn't be
                // linked to non-channel destinations (for NOW anyway).
                //
                ASSERT(!"pLocalIp linked to non-channel pDest.");
                UNLOCKOBJ(pIF, pSR);
                break;
            }

            //
            // We're linked to some other pDest currently. We'll have
            // to unlink ourselves from pDest, and get rid of the other
            // pDest if no one is using it.
            //
            RmTmpReferenceObject(&pDest->Hdr, pSR);
    
            arpUnlinkLocalIpFromDest(pLocalIp, pSR);
        }

        pOldDest = pDest;
        pDest = NULL;
    
        ASSERT(pLocalIp->pDest == NULL);
    
    
        //
        // SPECIAL CASE: If the channel is the broadcast channel, we don't
        // need to do anything more, because the broadcast channel is always
        // active.
        //
        if (Channel ==  NIC1394_BROADCAST_CHANNEL)
        {
            UNLOCKOBJ(pIF, pSR);
            break;
        }

        //
        // Now link to a new dest and if required initiate a call on it.
        //


        // Now create a destination item for this structure.
        //
        Status = RmLookupObjectInGroup(
                        &pIF->DestinationGroup,
                        RM_CREATE,      // Create if required
                        pDestParams,    // Key
                        pDestParams,    // pParams
                        (RM_OBJECT_HEADER**) &pDest,
                        &fCreated,
                        pSR
                        );
        if (FAIL(Status))
        {
            UNLOCKOBJ(pIF, pSR);
            OBJLOG1( pIF, "FATAL: Couldn't create local-ip dest type %d.\n",
                            pDestParams->HwAddr.AddressType);
            break;
        }
    

        Status = arpAllocateTask(
                    &pDest->Hdr,            // pParentObject
                    arpTaskMakeCallToDest,  // pfnHandler
                    0,                      // Timeout
                    "Task: MakeCallToDest (local ip)",
                    &pMakeCallTask,
                    pSR
                    );

        if (FAIL(Status))
        {
            UNLOCKOBJ(pIF, pSR);

            // NOTE: Even on failure, we leave the newly-created
            // special dest object. It will get cleaned up when
            // the interface is unloaded.
            //
        }
        else
        {
            arpLinkLocalIpToDest(pLocalIp, pDest, pSR);

            UNLOCKOBJ(pIF, pSR);

            (VOID)RmStartTask(
                    pMakeCallTask,
                    0, // UserParam (unused)
                    pSR
                    );
        }
        RmTmpDereferenceObject(&pDest->Hdr, pSR); // Added by RmLookupObjectIn..

    } while (FALSE);

    //
    // If required, get rid of pOldDest.
    //
    if (pOldDest != NULL)
    {
        arpDeinitDestination(pOldDest, TRUE,  pSR); // TRUE == only if unused.
        RmTmpDereferenceObject(&pOldDest->Hdr, pSR);
    }

    RM_ASSERT_NOLOCKS(pSR);
}


UINT
arpFindFreeChannel(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    PRM_STACK_RECORD                pSR
    )
/*++
    NOTE: Special return value NIC1394_BROADCAST_CHANNEL is returned if
    we couldn't find a free channel.

    Also there's no guarantee that this channel is really free.
--*/
{
    ENTER("FindAssignedChannel", 0xd20a216b)
    UINT Channel = NIC1394_BROADCAST_CHANNEL;
    UINT u;

    LOCKOBJ(pIF, pSR);

    //
    // Run down the channel info array, looking for an empty slot.
    //
    for (u = 0;  u < ARP_NUM_CHANNELS; u++)
    {
        PMCAP_CHANNEL_INFO pMci;
        pMci = &pIF->mcapinfo.rgChannelInfo[u];

        if (pMci->GroupAddress == 0)
        {
            ASSERT(pMci->Channel == 0);
            // pMci->Channel = u;
            Channel = u;
            TR_WARN(("Found Free channel %lu.\n",
                Channel
                ));
            break;
        }
    }

    UNLOCKOBJ(pIF, pSR);

    return Channel;

    EXIT()
}


VOID
arpUpdateRemoteIpDest(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    IN  PARPCB_REMOTE_IP            pRemoteIp,
    IN  PARP_DEST_PARAMS            pDestParams,
    PRM_STACK_RECORD                pSR
    )
{
    ENTER("UpdateRemoteIpDest", 0x3f2dcaa7)
    ARPCB_DEST          *pOldDest = NULL;

    RM_ASSERT_NOLOCKS(pSR);

    // pRemoteIp uses it's parent's (pIF's) lock.
    //
    RM_ASSERT_SAME_LOCK_AS_PARENT(pRemoteIp);

    do
    {
        PCHAR               szDescription;
        INT                 fCreated = FALSE;
        PRM_TASK            pMakeCallTask;
        UINT                Channel;
        NDIS_STATUS         Status;
        ARPCB_DEST          *pDest;

        //
        // Lookup/Create Remote Destination
        // NOTE/WARNING: We'll create a new destination even if one exists for
        // the same uniqueID but different FIFO-address -- this is by design.
        // What should happen is that the old pDest should be eventually removed.
        //
        Status = RmLookupObjectInGroup(
                        &pIF->DestinationGroup,
                        RM_CREATE,              //NOT RM_NEW (could be existing)
                        pDestParams,
                        pDestParams,    // pParams
                        (RM_OBJECT_HEADER**) &pDest,
                        &fCreated,
                        pSR
                        );
        if (FAIL(Status))
        {
            OBJLOG1(
                pIF,
                "Couldn't add dest entry with hw addr 0x%lx\n",
                (UINT) pDestParams->HwAddr.FifoAddress.UniqueID // Truncation
                );
            
            //
            // We'll leave the RemoteIp entry around -- it will be cleaned up later.
            //
        #if 0
            // We do have to deref the tmpref added when looking it up.
            //
            RmTmpDereferenceObject(&pRemoteIp->Hdr, pSR);
        #endif // 0
            break;
        }

        LOCKOBJ(pIF, pSR);

        if (pRemoteIp->pDest != pDest)
        {
            // If required, unlink any existing destination from pIP.
            //
            if (pRemoteIp->pDest != NULL)
            {
                pOldDest =  pRemoteIp->pDest;
                RmTmpReferenceObject(&pOldDest->Hdr, pSR);

                arpUnlinkRemoteIpFromDest(
                    pRemoteIp,  // LOCKIN LOCKOUT
                    pSR
                    );
                ASSERT(pRemoteIp->pDest == NULL);
            }
    
            // Set the pRemoteIp state to reflect that it is FIFO/Channel
            // and DYNAMIC.
            //
            {

                // (Dbg only) Change lock scope from pIF to pLocalIp, because
                // we're altering pLocalIp's state below...
                //
                RmDbgChangeLockScope(
                    &pIF->Hdr,
                    &pRemoteIp->Hdr,
                    0x1385053b,             // LocID
                    pSR
                    );
    
                if (pDestParams->HwAddr.AddressType ==  NIC1394AddressType_FIFO)
                {
                    SET_REMOTEIP_FCTYPE(pRemoteIp, ARPREMOTEIP_FIFO);
                }
                else
                {
                    SET_REMOTEIP_FCTYPE(pRemoteIp, ARPREMOTEIP_CHANNEL);
                }
                SET_REMOTEIP_SDTYPE(pRemoteIp, ARPREMOTEIP_DYNAMIC);

                // (Dbg only) Change lock scope back to pIF.
                //
                RmDbgChangeLockScope(
                    &pRemoteIp->Hdr,
                    &pIF->Hdr,
                    0x315d28a1,             // LocID
                    pSR
                    );
            }
    
            // Link pRemoteIp to pDest.
            //
            //
            // We've created both RemoteIp and Destination entries. Now link them.
            // (We still have the IF lock, which is the same as the RemoteIP and 
            //  desination locks for now).
            //
            // TODO: will need to change this when pRemoteIp gets its own lock.
            //
            RM_ASSERT_SAME_LOCK_AS_PARENT(pRemoteIp);
            RM_ASSERT_SAME_LOCK_AS_PARENT(pDest);
        
            arpLinkRemoteIpToDest(
                pRemoteIp,
                pDest,
                pSR
                );
        }
        
        UNLOCKOBJ(pIF, pSR);

        RmTmpDereferenceObject(&pDest->Hdr, pSR);

    } while(FALSE);

    //
    // If required, get rid of pOldDest.
    //
    if (pOldDest != NULL)
    {
        arpDeinitDestination(pOldDest, TRUE,  pSR); // TRUE == only if unused.
        RmTmpDereferenceObject(&pOldDest->Hdr, pSR);
    }

    RM_ASSERT_NOLOCKS(pSR);
}


VOID
arpDeinitRemoteIp(
    PARPCB_REMOTE_IP        pRemoteIp,
    PRM_STACK_RECORD        pSR
    )
/*++
    Unload a remote ip.
--*/
{
    ENTER("arpDeinitRemoteIp", 0xea0a2662)
    PRM_TASK    pTask;
    NDIS_STATUS Status;

    RM_ASSERT_NOLOCKS(pSR);

#if DBG
    {
        IP_ADDRESS IpAddress = pRemoteIp->Key.IpAddress;
        TR_WARN(("Deiniting RemoteIp %d.%d.%d.%d\n",
                ((PUCHAR)(&IpAddress))[0],
                ((PUCHAR)(&IpAddress))[1],
                ((PUCHAR)(&IpAddress))[2],
                ((PUCHAR)(&IpAddress))[3]));
    }
#endif // DBG

    Status = arpAllocateTask(
                &pRemoteIp->Hdr,                // pParentObject,
                arpTaskUnloadRemoteIp,      // pfnHandler,
                0,                          // Timeout,
                "Task: Unload Remote Ip",       // szDescription
                &pTask,
                pSR
                );

    if (FAIL(Status))
    {
        OBJLOG0(pRemoteIp, ("FATAL: couldn't alloc unload pRemoteIp task!\n"));
    }
    else
    {
        (VOID) RmStartTask(
                    pTask,
                    0, // UserParam (unused)
                    pSR
                    );
    }
}

VOID
arpDeinitRemoteEth(
    PARPCB_REMOTE_ETH       pRemoteEth,
    PRM_STACK_RECORD        pSR
    )
/*++
    Unload a remote ip.
--*/
{
    ENTER("arpDeinitRemoteEth", 0x72dd17e7)
    PRM_TASK    pTask;
    NDIS_STATUS Status;

    RM_ASSERT_NOLOCKS(pSR);

#if DBG
    {
        IP_ADDRESS IpAddress = pRemoteEth->IpAddress;
        TR_WARN(("Deiniting RemoteEth %d.%d.%d.%d\n",
                ((PUCHAR)(&IpAddress))[0],
                ((PUCHAR)(&IpAddress))[1],
                ((PUCHAR)(&IpAddress))[2],
                ((PUCHAR)(&IpAddress))[3]));
    }
#endif // DBG

    Status = arpAllocateTask(
                &pRemoteEth->Hdr,               // pParentObject,
                arpTaskUnloadRemoteEth,     // pfnHandler,
                0,                          // Timeout,
                "Task: Unload Remote Eth",      // szDescription
                &pTask,
                pSR
                );

    if (FAIL(Status))
    {
        OBJLOG0(pRemoteEth, ("FATAL: couldn't alloc unload pRemoteIp task!\n"));
    }
    else
    {
        (VOID) RmStartTask(
                    pTask,
                    0, // UserParam (unused)
                    pSR
                    );
    }
}


VOID
arpDoMcapDbMaintenance(
        PARP1394_INTERFACE pIF,
        UINT CurrentTime,
        UINT SecondsSinceLastMaintenance,
        MYBOOL *pfProcessed,
        PRM_STACK_RECORD pSR
        )
/*++
    Go through the mcap database, zeroing out all entries marked
    "NotRecentlyUpdated", and marking all others "NotRecentlyUpdated."

    Also send out an mcap advertisements for all channels we've locally allocated.
--*/
{
    UINT u;
    UINT NumLocallyAllocated =0;
    PNDIS_PACKET pNdisPacket;
    NDIS_STATUS Status;

    ENTER("McapDbMaintenance", 0x1ae00035)

    if (SecondsSinceLastMaintenance < 10)
    {
        TR_INFO(("Skipping McapDb maintenance (delay=%lu).\n",
                SecondsSinceLastMaintenance
                ));
        *pfProcessed = FALSE;
        return;                             // EARLY RETURN;
    }

    *pfProcessed = TRUE;

    TR_INFO(("Actually doing Mcap Db maintenance.\n"));


    LOCKOBJ(pIF, pSR);

    //
    // Run down the channel info array, looking for and zapping stale channel
    // assignments.
    //
    for (u = 0;  u < ARP_NUM_CHANNELS; u++)
    {
        PMCAP_CHANNEL_INFO pMci;
        MYBOOL fOk;
        pMci = &pIF->mcapinfo.rgChannelInfo[u];

        if (pMci->GroupAddress == 0) continue; // An empty record.
        
        fOk = arpIsActiveMcapChannel(pMci, CurrentTime);

        if (!fOk)
        {
            TR_WARN(("McapDB: clearing stale channel %lu.\n",
                pMci->Channel
                ));
            ASSERT(pMci->Channel == u);
            ARP_ZEROSTRUCT(pMci);
            continue;
        }

        if (pMci->Flags & MCAP_CHANNEL_FLAGS_LOCALLY_ALLOCATED)
        {
            NumLocallyAllocated++;
        }
    }

    // If required, send an mcap advertisement packet.
    //
    do
    {
        IP1394_MCAP_PKT_INFO    PktInfo;
        PIP1394_MCAP_GD_INFO    pGdi;
        UINT                    cb = NumLocallyAllocated * sizeof(*pGdi);
        UINT                    v;

        if (NumLocallyAllocated==0) break;

        ASSERT(FALSE);

        if (cb <= sizeof(PktInfo.GdiSpace))
        {
            pGdi = PktInfo.GdiSpace;
        }
        else
        {
            NdisAllocateMemoryWithTag(&pGdi, cb,  MTAG_MCAP_GD);
            if (pGdi == NULL)
            {
                TR_WARN(("Allocation Failure"));
                break;
            }
        }
        PktInfo.pGdis = pGdi;

        // Now go through the mcap list,  picking up locally allocated 
        // channels.
        //
        for (u=0, v=0;  u < ARP_NUM_CHANNELS; u++)
        {
            PMCAP_CHANNEL_INFO pMci;
            pMci = &pIF->mcapinfo.rgChannelInfo[u];
    
            if (pMci->Flags & MCAP_CHANNEL_FLAGS_LOCALLY_ALLOCATED)
            {
                if (v >= NumLocallyAllocated)
                {
                    ASSERT(FALSE);
                    break;
                }
                if (pMci->ExpieryTime > CurrentTime)
                {
                    pGdi->Expiration    = pMci->ExpieryTime - CurrentTime;
                }
                else
                {
                    pGdi->Expiration    = 0;
                }

                pGdi->Channel       = pMci->Channel;
                pGdi->SpeedCode     = pMci->SpeedCode;
                pGdi->GroupAddress  = pMci->GroupAddress;

                v++;  pGdi++;
            }
        }

        UNLOCKOBJ(pIF, pSR);

        PktInfo.NumGroups   =  v;
        PktInfo.SenderNodeID    =  0;           // TODO
        PktInfo.OpCode      =  IP1394_MCAP_OP_ADVERTISE;

        //
        // Now we must actually allocate and send the advertisement.
        //
        Status = arpCreateMcapPkt(
                    pIF,
                    &PktInfo,
                    &pNdisPacket,
                    pSR
                    );

        if (FAIL(Status)) break;

        TR_WARN(("Attempting to send MCAP ADVERTISE PKT."
            "NumGoups=%lu Group0-1 == 0x%08lx->%lu 0x%08lx->%lu.\n",
                PktInfo.NumGroups,
                PktInfo.pGdis[0].GroupAddress,
                PktInfo.pGdis[0].Channel,
                PktInfo.pGdis[1].GroupAddress,
                PktInfo.pGdis[1].Channel
                ));

        ARP_FASTREADLOCK_IF_SEND_LOCK(pIF);

        // Actually send the packet (this will silently fail and free the pkt
        // if we're not in a position to send the pkt.)
        //
        arpSendControlPkt(
                pIF,            // LOCKIN NOLOCKOUT (IF send lk)
                pNdisPacket,
                pIF->pBroadcastDest,
                pSR
                );
        
        RM_ASSERT_NOLOCKS(pSR);
        RmTmpDereferenceObject(&pIF->Hdr, pSR);

    } while (FALSE);

    UNLOCKOBJ(pIF, pSR);

    EXIT()
}


#if DBG
VOID
arpDbgDisplayMapping(
    IP_ADDRESS              IpAddress,
    PNIC1394_DESTINATION    pHwAddr,
    char *                  szPrefix
    )
{
    ENTER("MAP", 0x0)
    if (pHwAddr == NULL)
    {
        TR_WARN(("%s %d.%d.%d.%d --> <no destination>\n",
                szPrefix,
                ((PUCHAR)(&IpAddress))[0],
                ((PUCHAR)(&IpAddress))[1],
                ((PUCHAR)(&IpAddress))[2],
                ((PUCHAR)(&IpAddress))[3]));
    }
    else if (pHwAddr->AddressType ==  NIC1394AddressType_FIFO)
    {
        PUCHAR puc = (PUCHAR)  &pHwAddr->FifoAddress;
        TR_WARN(("%s %d.%d.%d.%d --> FIFO %02lx-%02lx-%02lx-%02lx-%02lx-%02lx-%02lx-%02lx.\n",
                szPrefix,
                ((PUCHAR)(&IpAddress))[0],
                ((PUCHAR)(&IpAddress))[1],
                ((PUCHAR)(&IpAddress))[2],
                ((PUCHAR)(&IpAddress))[3],
            puc[0], puc[1], puc[2], puc[3],
            puc[4], puc[5], puc[6], puc[7]));
    }
    else if (pHwAddr->AddressType ==  NIC1394AddressType_Channel)
    {
        TR_WARN(("%s %d.%d.%d.%d --> CHANNEL %d.\n",
                szPrefix,
                ((PUCHAR)(&IpAddress))[0],
                ((PUCHAR)(&IpAddress))[1],
                ((PUCHAR)(&IpAddress))[2],
                ((PUCHAR)(&IpAddress))[3],
                pHwAddr->Channel));
    }
    else
    {
        TR_WARN(("%s %d.%d.%d.%d --> Special dest 0x%08lx.\n",
                szPrefix,
                ((PUCHAR)(&IpAddress))[0],
                ((PUCHAR)(&IpAddress))[1],
                ((PUCHAR)(&IpAddress))[2],
                ((PUCHAR)(&IpAddress))[3],
                pHwAddr->Channel));
    }
    EXIT()
}
#endif // DBG


PRM_OBJECT_HEADER
arpRemoteDestCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    pSR
        )
/*++

Routine Description:

    Allocate and initialize an object of type ARPCB_REMOTE_IP.

Arguments:

    pParentObject   - Actually a pointer to the interface (ARP1394_INTERFACE)
    pCreateParams   - Actually the IP address (not a pointer to the IP address)
                      to associate with this remote IP object.

Return Value:

    Pointer to the allocated and initialized object on success.
    NULL otherwise.

--*/
{
    ENTER ("arpRemoteDestCreate", 0xa896311a)
    ARPCB_REMOTE_IP *pRemoteIp;
    PRM_OBJECT_HEADER pHdr;
    PREMOTE_DEST_KEY pKey = (PREMOTE_DEST_KEY)pCreateParams;
    NDIS_STATUS Status;

    Status = ARP_ALLOCSTRUCT(pRemoteIp, MTAG_REMOTE_IP);

    if (Status != NDIS_STATUS_SUCCESS || pRemoteIp == NULL)
    {
        return NULL;
    }
    
    ARP_ZEROSTRUCT(pRemoteIp);

    pHdr = (PRM_OBJECT_HEADER) pRemoteIp;
    ASSERT(pHdr == &pRemoteIp->Hdr);

    // We expect the parent object to be the IF object!
    //
    ASSERT(pParentObject->Sig == MTAG_INTERFACE);
    

    if (pHdr)
    {
        RmInitializeHeader(
            pParentObject,
            pHdr,
            MTAG_REMOTE_IP,
            pParentObject->pLock,
            &ArpGlobal_RemoteIpStaticInfo,
            NULL, // szDescription
            pSR
            );

    TR_INFO( ("New RemoteDest Key %x %x %x %x %x %x \n",
                pKey->ENetAddress.addr[0],
                pKey->ENetAddress.addr[1],
                pKey->ENetAddress.addr[2],
                pKey->ENetAddress.addr[3],
                pKey->ENetAddress.addr[4],
                pKey->ENetAddress.addr[5]));
  
        // set up the remote key 
        REMOTE_DEST_KEY_INIT(&pRemoteIp->Key);
        pRemoteIp->Key = *((PREMOTE_DEST_KEY) pCreateParams); 
        pRemoteIp->IpAddress = ((PREMOTE_DEST_KEY) pCreateParams)->IpAddress;
        
        // Initialize  various other stuff...
        InitializeListHead(&pRemoteIp->sendinfo.listSendPkts);

        if ((IS_REMOTE_DEST_IP_ADDRESS(&pRemoteIp->Key) == TRUE) &&
               arpCanTryMcap(pRemoteIp->IpAddress))
        {
            SET_REMOTEIP_MCAP(pRemoteIp,  ARPREMOTEIP_MCAP_CAPABLE);
        }
    }

    //
    // Add a backup task that could potentially be used to delete this Remote Ip
    //
    arpAddBackupTasks (&ArpGlobals, 1);
    EXIT()
    return pHdr;
}




VOID
arpRemoteDestDelete(
        PRM_OBJECT_HEADER pHdr,
        PRM_STACK_RECORD  pSR
        )
/*++

Routine Description:

    Free an object of type ARPCB_REMOTE_IP.

Arguments:

    pHdr    - Actually a pointer to the remote ip object to be freed.

--*/
{
    ARPCB_REMOTE_IP *pRemoteIp = (ARPCB_REMOTE_IP *) pHdr;
    ASSERT(pRemoteIp->Hdr.Sig == MTAG_REMOTE_IP);
    pRemoteIp->Hdr.Sig = MTAG_FREED;

    ARP_FREE(pHdr);
    //
    // Remove a backup task that was added when RemoteIp was created
    //
    arpRemoveBackupTasks (&ArpGlobals, 1);

}



// Enum function
//
INT
arpMaintainArpCache(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,  // Unused
        PRM_STACK_RECORD    pSR
        )
#if 0
    for each RIP send VC
        if !marked dirty
            mark dirty
            if linked to channel pdest
            check if channel is still mapped to group
            if not, unlink.
            if required initiate link to new pdest (possibly channel)
        else
            //expired
            unlink from pdest and get rid of it
#endif // 0
{
    ENTER("arpMaintainArpCache", 0xefc55765)
    NDIS_STATUS         Status;
    PARPCB_REMOTE_IP    pRemoteIp;
    PARP1394_INTERFACE  pIF;


    pRemoteIp   = (PARPCB_REMOTE_IP) pHdr;
    pIF         = IF_FROM_LOCALIP(pRemoteIp);

    RM_ASSERT_NOLOCKS(pSR);

    do
    {
        IP_ADDRESS          IpAddr;
        UINT                Channel;
        ARP_DEST_PARAMS     DestParams;
        ARPCB_DEST          *pDest;
        BOOLEAN             AcquireChannel;
        UINT                CurrentTime = arpGetSystemTime();
        UINT                TimeSinceLastCheck;  
        IpAddr      = pRemoteIp->Key.IpAddress;

        #define ARP_PURGE_REMOTEIP_TIME 300 // Arp entry timeout.
        #define ARP_REFRESH_REMOTEIP_TIME (ARP_PURGE_REMOTEIP_TIME - 60) // Arp Refresh time

        TimeSinceLastCheck = CurrentTime - pRemoteIp->sendinfo.TimeLastChecked ;
        //
        // NOTE: we don't bother to get the lock with dealing with
        // sendinfo.TimeLastChecked -- this is ok.
        //
        if (pRemoteIp->sendinfo.TimeLastChecked==0)
        {

            if (CHECK_REMOTEIP_SDTYPE(pRemoteIp, ARPREMOTEIP_DYNAMIC)
                || CHECK_REMOTEIP_RESOLVE_STATE (pRemoteIp, ARPREMOTEIP_UNRESOLVED))
            {
                // Set this field to the current time. It will be cleared back to 0
                // when the next packet is sent to this remote ip.
                //
                pRemoteIp->sendinfo.TimeLastChecked = CurrentTime;
            }
        }
        else if (TimeSinceLastCheck >= ARP_REFRESH_REMOTEIP_TIME &&
                TimeSinceLastCheck <= ARP_PURGE_REMOTEIP_TIME)
        {
            arpRefreshArpEntry(pRemoteIp, pSR);
        } 
        else  if (TimeSinceLastCheck >= ARP_PURGE_REMOTEIP_TIME) 
        {
            // 
            // We should clean up this remote ip.
            //
            arpDeinitRemoteIp(pRemoteIp, pSR);
            break;
        }

#if ARP_ENABLE_MCAP_SEND

        //
        // We'll now see if we need to re-set which destination this
        // pRemoteIp points to.
        //

        // Skip if we can't do MCAP on this address.
        //
        LOCKOBJ(pRemoteIp, pSR);
        if (!CHECK_REMOTEIP_MCAP(pRemoteIp, ARPREMOTEIP_MCAP_CAPABLE))
        {
            UNLOCKOBJ(pRemoteIp, pSR);
            break;
        }
        UNLOCKOBJ(pRemoteIp, pSR);

        //
        // Find a channel mapping to this address, if any.
        //
        Channel = arpFindAssignedChannel(
                        pIF, 
                        pRemoteIp->Key.IpAddress,
                        0,
                        pSR
                        );
        
        //
        // NOTE: Special return value NIC1394_BROADCAST_CHANNEL is returned if
        // this address is mapped to no specific channel.
        //

        AcquireChannel = FALSE;

    
    #if 0   // Let's not enable this just yet -- instead 

        if (Channel == NIC1394_BROADCAST_CHANNEL)
        {
            //
            // Hmm... let's get aggressive and try to grab a channel.
            //
            Channel = arpFindFreeChannel(pIF, pSR);
            if (Channel != NIC1394_BROADCAST_CHANNEL)
            {
                //
                // Got one!
                //
                AcquireChannel = TRUE;
            }
        }
        else
        {
            //
            // There is already a channel allocated by someone to be used
            // for this ip address. Let's use it.
            //
        }
    #endif // 0 
    
        ARP_ZEROSTRUCT(&DestParams);
        DestParams.HwAddr.AddressType =  NIC1394AddressType_Channel;
        DestParams.HwAddr.Channel =  Channel;
        DestParams.AcquireChannel =  AcquireChannel;

        arpUpdateRemoteIpDest(pIF, pRemoteIp, &DestParams, pSR);

#endif //  ARP_ENABLE_MCAP_SEND

    } while (FALSE);
    
    RM_ASSERT_NOLOCKS(pSR)

    return TRUE; // Continue to enumerate.
}



VOID 
arpRefreshArpEntry(
    PARPCB_REMOTE_IP pRemoteIp,
    PRM_STACK_RECORD pSR
    )
{
    ENTER("arpRefreshArpEntry",0x2e19af0b)
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    PRM_TASK pTask = NULL;

    do
    {
        PUCHAR pIpAddress;
        //
        // We do not refresh Ip addresses ending in 0xff because they are broadcast
        // packets and we are only concernetd with maintaining unicast destinations
        //
        pIpAddress = (PUCHAR)&pRemoteIp->IpAddress;
        
        if (pIpAddress[3] == 0xff)
        {
            break;
        }
        
        //
        // We do not need to hold the lock as we are gauranteed that only one instance 
        // of the original timer function is going to fire. By implication, all calls to 
        // this function are serialized
        //
        if (pRemoteIp->pResolutionTask != NULL)
        {
            // There is already another task trying to resolve this Ip Address
            // so exit
            break;
        }
        
        

        Status = arpAllocateTask(
                    &pRemoteIp->Hdr,               // pParentObject,
                    arpTaskResolveIpAddress,     // pfnHandler,
                    0,                              // Timeout
                    "Task: ResolveIpAddress",       // szDescription
                    &pTask,
                    pSR
                    );

        if (FAIL(Status))
        {
            pTask = NULL;
            break;
        }

        RmStartTask (pTask,0,pSR);

    }while (FALSE);

    EXIT()
}




NDIS_STATUS
arpTaskUnloadEthDhcpEntry(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++
    This task is responsible for shuttingdown and eventually deleting a Dhcp Entry

    It goes through the following stages:
        simply calls RmFreeObject in Group as there is no asynchronous unload work to be done.
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    ENTER("TaskUnloadRemoteEth", 0xf42aaa68)
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    ARP1394_ETH_DHCP_ENTRY *   pDhcpEntry = (ARP1394_ETH_DHCP_ENTRY*) RM_PARENT_OBJECT(pTask);
    ARP1394_INTERFACE *pIF = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pDhcpEntry );

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_OtherUnloadComplete
    };

    switch(Code)
    {

        case RM_TASKOP_START:
        {
            LOCKOBJ(pDhcpEntry, pSR);

            // First check if pDhcpEntry is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pDhcpEntry))
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            //
            // pDhcpEntry is allocated. Now check if there is already a
            // shutdown task attached to pDhcpEntry.
            //
            if (pDhcpEntry ->pUnloadTask != NULL)
            {
                //
                // There is a shutdown task. We pend on it.
                //

                PRM_TASK pOtherTask = pDhcpEntry->pUnloadTask;
                TR_WARN(("Unload task %p exists; pending on it.\n", pOtherTask));
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pDhcpEntry , pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_OtherUnloadComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // There is no unload task going on. Let's
            // make this task THE unload task.
            // 
            pDhcpEntry->pUnloadTask = pTask;

            //
            // Since we're THE unload task, add an association to pDhcpEntry,
            // which will only get cleared when the  pDhcpEntry->pUnloadTask field
            // above is cleared.
            //
            DBG_ADDASSOC(
                &pDhcpEntry->Hdr,                   // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_ETHDHCP_UNLOAD_TASK,     // AssociationID
                "    Official unload task 0x%p (%s)\n", // szFormat
                pSR
                );

            //
            // We're here because there is no async unload work to be done.
            // We simply return and finish synchronous cleanup in the END
            // handler for this task.
            //
            Status = NDIS_STATUS_SUCCESS;
            
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_OtherUnloadComplete:
                {
        
                    //
                    // There was another unload task going when we started, and
                    // it's now complete. Nothing for us to do...
                    //
                    // TODO need standard way to propagate the error code.
                    //
                    Status = (NDIS_STATUS) UserParam;
                }
                break;
    

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            LOCKOBJ(pDhcpEntry, pSR);

            //
            // We're done. There should be no async activities left to do.
            //

            //
            // If we're THE unload task, we go on and deallocate the object.
            //
            if (pDhcpEntry ->pUnloadTask == pTask)
            {
                //
                // pDhcpEntry had better not be in a zombie state -- THIS task
                // is the one responsible for deallocating the object!
                //
                ASSERTEX(!RM_IS_ZOMBIE(pDhcpEntry ), pDhcpEntry );

                pDhcpEntry ->pUnloadTask = NULL;

                RmFreeObjectInGroup(
                    &pIF->EthDhcpGroup,
                    &(pDhcpEntry ->Hdr),
                    NULL,               // NULL pTask == synchronous.
                    pSR
                    );

                ASSERTEX(RM_IS_ZOMBIE(pDhcpEntry ), pDhcpEntry );
                     
                // Delete the association we added when we set
                // pDhcpEntry->pUnloadTask to pTask.
                //
                DBG_DELASSOC(
                    &pDhcpEntry ->Hdr,                   // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_ETHDHCP_UNLOAD_TASK,     // AssociationID
                    pSR
                    );

                UNLOCKOBJ(pDhcpEntry, pSR);

            }
            else
            {
                //
                // We weren't THE unload task, nothing left to do.
                // The object had better be in the zombie state..
                //

                ASSERTEX(
                    pDhcpEntry->pUnloadTask == NULL && RM_IS_ZOMBIE(pDhcpEntry),
                    pDhcpEntry
                    );
                Status = NDIS_STATUS_SUCCESS;
            }

            Status = (NDIS_STATUS) UserParam;
        }
        break; // RM_TASKOP_END:

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RmUnlockAll(pSR);

    EXIT()

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\fake.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    fake.c

Abstract:

    Fake versions of various external calls (ndis, ip...).
    Used for debugging and component testing only.

    To enable, define ARPDBG_FAKE_APIS in ccdefs.h

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     03-22-98    Created

Notes:

--*/
#include <precomp.h>


#if ARPDBG_FAKE_APIS

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_FAKE


//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================



#if RM_EXTRA_CHECKING
    #define LOCKROOTOBJ(_pHdr, _pSR)            \
            RmWriteLockObject(                  \
                    (_pHdr)->pRootObject,       \
                    0,                          \
                    (_pSR)                      \
                    )
#else       // !RM_EXTRA_CHECKING
    #define LOCKROOTOBJ(_pHdr, _pSR)            \
            RmWriteLockObject(                  \
                    (_pHdr)->pRootObject,       \
                    (_pSR)                      \
                    )
#endif      // !RM_EXTRA_CHECKING

#define UNLOCKROOTOBJ(_pHdr, _pSR)          \
        RmUnlockObject(                     \
                (_pHdr)->pRootObject,       \
                (_pSR)                      \
                )

typedef
VOID
(*PFN_FAKE_COMPLETIONCALLBACK)(
    struct _FAKETASK *pFTask
);


// This task structure holds a union of the information required for the completions
// of the various apis that are being faked.
//
typedef struct _FAKETASK
{
    RM_TASK TskHdr;

    //  Client's context to pass back
    //
    PVOID                   pClientContext;

    // Client object the call is associated.
    //
    PRM_OBJECT_HEADER       pOwningObject;

    //  The status to report in the asynchronous completion fn.
    //
    NDIS_STATUS             Status;

    //  Milliseconds to delay before calling the async completion fn.
    //
    UINT                    DelayMs;

    //  Wheather to call the completion fn at DPC or PASSIVE IRQL level.
    //
    INT                     fDpc;

    // This is used solely to switch to DPC level when asynchronously
    // calling the completion callback.
    //
    NDIS_SPIN_LOCK          NdisLock;

    // This is used solely to wait DelayMs ms if required.
    //
    NDIS_TIMER              Timer;

    // This is used solely to switch to a different (and PASSIVE) context.
    //
    NDIS_WORK_ITEM          WorkItem;

    // This is used only for fake NdisClMakeCall
    //
    PCO_CALL_PARAMETERS     CallParameters;

    // This is used only for fake NdisCoSendPackets
    //
    PNDIS_PACKET            pNdisPacket;

    // The actual completion callback function;
    //
    PFN_FAKE_COMPLETIONCALLBACK pfnCompletionCallback;

} FAKETASK;


VOID
arpFakeMakeCallCompletionCallback(
    struct _FAKETASK *pFTask
);


VOID
arpFakeCloseCallCompletionCallback(
    struct _FAKETASK *pFTask
);


VOID
arpFakeSendPacketsCompletionCallback(
    struct _FAKETASK *pFTask
);


NDIS_STATUS
arpDbgAllocateFakeTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription,
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
arpDbgFakeTaskDelete(
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    );

RM_STATIC_OBJECT_INFO
FakeTasks_StaticInfo = 
{
    0,                      // TypeUID
    0,                      // TypeFlags
    "FAKE Task",            // TypeName
    0,                      // Timeout

    NULL,                   // pfnCreate
    arpDbgFakeTaskDelete,   // pfnDelete
    NULL,                   // pfnVerifier

    0,                      // length of resource table
    NULL                    // Resource Table
};


NDIS_STATUS
arpDbgFakeCompletionTask(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );


//=========================================================================
//                  F A K E      N D I S     E N T R Y P O I N T S
//=========================================================================


NDIS_STATUS
arpDbgFakeNdisClMakeCall(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    OUT PNDIS_HANDLE            NdisPartyHandle,        OPTIONAL
    IN  PRM_OBJECT_HEADER       pOwningObject,
    IN  PVOID                   pClientContext,
    IN  PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Fake version of NdisClMakeCall.

--*/
{
    ENTER("FakeNdisClMakeCall", 0x3d4195ae)
    NDIS_STATUS Status;
    NDIS_STATUS AsyncStatus;
    UINT DelayMs;
    
    DBGMARK(0xced41a61);
    RM_ASSERT_NOLOCKS(pSR);
    ASSERT(NdisPartyHandle==NULL);
    ASSERT(ProtocolPartyContext==NULL);
    ASSERT(NdisVcHandle != NULL);


    do
    {
        static
        OUTCOME_PROBABILITY
        StatusOutcomes[] = 
        {
            {NDIS_STATUS_SUCCESS,   1},     // Return NDIS_STATUS_SUCCESS
            {NDIS_STATUS_FAILURE,   1}      // Return NDIS_STATUS_FAILURE
        };

        static
        OUTCOME_PROBABILITY
        DelayMsOutcomes[] = 
        {
            {0,         5},     // Delay 0ms, etc...
            {10,        5},
            {100,       5},
            {1000,      1},
            {10000,     1}
        };

        static
        OUTCOME_PROBABILITY
        AsyncOutcomes[] = 
        {
            {TRUE,      1},     // Complete Async
            {FALSE,     1}      // Complete Sync
        };
        
        static
        OUTCOME_PROBABILITY
        DpcOutcomes[] = 
        {
            {TRUE,      1},     // Complete at DPC level
            {FALSE,     1}      // Complete at PASSIVE level
        };

        FAKETASK *pMCTask;


        // We serialize calls to arpGenRandomInt by claiming the root object's
        // lock...
        //
        LOCKROOTOBJ(pOwningObject, pSR);

        // Get the status we're supposed to return.
        //
        Status =
        AsyncStatus = (NDIS_STATUS) arpGenRandomInt(
                                     StatusOutcomes,
                                     ARRAY_LENGTH(StatusOutcomes)
                                     );

        // Determine if we're to return synchronously or complete
        // asynchronously...
        //
        if (!arpGenRandomInt(AsyncOutcomes, ARRAY_LENGTH(AsyncOutcomes)))
        {
            // We're to return synchronously.
            //
            UNLOCKROOTOBJ(pOwningObject, pSR);
            break;
        }

        // 
        // We're to complete asynchronously...
        //

        DelayMs             = arpGenRandomInt(
                                        DelayMsOutcomes,
                                        ARRAY_LENGTH(DelayMsOutcomes)
                                        );

        if (DelayMs == 0)
        {
            // We're to immediately indicatie async completion...
            // (we don't mess with IRQ levels if we're returning here..)
            //
            UNLOCKROOTOBJ(pOwningObject, pSR);
            ArpCoMakeCallComplete(
                        AsyncStatus,
                        pClientContext,
                        NULL,
                        CallParameters
                        );
            Status = NDIS_STATUS_PENDING;
            break;
        }

        // We're to indicate status sometime in the future -- in a different context.
        // Start a task to do this...
        //

        Status = arpDbgAllocateFakeTask(
                            pOwningObject,              // pParentObject,
                            arpDbgFakeCompletionTask,   // pfnHandler,
                            0,                          // Timeout,
                            "Task:Fake NdisClMakeCall", // szDescription,
                            &(PRM_TASK) pMCTask,
                            pSR
                            );
        if (FAIL(Status))
        {
            // Couldn't allocate task. Call callback right away...
            //
            UNLOCKROOTOBJ(pOwningObject, pSR);
            ArpCoMakeCallComplete(
                        AsyncStatus,
                        pClientContext,
                        NULL,
                        CallParameters
                        );
            Status = NDIS_STATUS_PENDING;
            break;
        }

        
        // Initialize pMCTask...
        //
        pMCTask->pClientContext     = pClientContext;
        pMCTask->pOwningObject      = pOwningObject;
        pMCTask->Status             = AsyncStatus;
        pMCTask->DelayMs            = DelayMs;
        pMCTask->fDpc               = arpGenRandomInt(
                                            DpcOutcomes,
                                            ARRAY_LENGTH(DpcOutcomes)
                                            );
        pMCTask->CallParameters =  CallParameters;
        pMCTask->pfnCompletionCallback = arpFakeMakeCallCompletionCallback;

        UNLOCKROOTOBJ(pOwningObject, pSR);

        (void) RmStartTask(
                    &pMCTask->TskHdr,
                    0, // UserParam (unused)
                    pSR
                    );

        Status = NDIS_STATUS_PENDING;

    } while (FALSE);


    RM_ASSERT_NOLOCKS(pSR);
    EXIT();

    return Status;
}


NDIS_STATUS
arpDbgFakeNdisClCloseCall(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  NDIS_HANDLE             NdisPartyHandle         OPTIONAL,
    IN  PVOID                   Buffer                  OPTIONAL,
    IN  UINT                    Size,                   OPTIONAL
    IN  PRM_OBJECT_HEADER       pOwningObject,
    IN  PVOID                   pClientContext,
    IN  PRM_STACK_RECORD        pSR
    )
/*++

Routine Description:

    Fake version of NdisClCloseCall.

--*/
{
    ENTER("FakeNdisClCloseCall", 0x7d8bbd3c)
    NDIS_STATUS Status;
    NDIS_STATUS AsyncStatus;
    UINT        DelayMs;
    
    DBGMARK(0x228fac3a);
    RM_ASSERT_NOLOCKS(pSR);
    ASSERT(NdisPartyHandle==NULL);
    ASSERT(NdisVcHandle != NULL);


    do
    {

        static
        OUTCOME_PROBABILITY
        DelayMsOutcomes[] = 
        {
            {0,         5},     // Delay 0ms, etc...
            {10,        5},
            {100,       5},
            {1000,      1},
            {10000,     1}
        };

        static
        OUTCOME_PROBABILITY
        AsyncOutcomes[] = 
        {
            {TRUE,      1},     // Complete Async
            {FALSE,     1}      // Complete Sync
        };
        
        static
        OUTCOME_PROBABILITY
        DpcOutcomes[] = 
        {
            {TRUE,      1},     // Complete at DPC level
            {FALSE,     1}      // Complete at PASSIVE level
        };

        FAKETASK *pCCTask;


        // We serialize calls to arpGenRandomInt by claiming the root object's
        // lock...
        //
        LOCKROOTOBJ(pOwningObject, pSR);

        // Get the status we're supposed to return.
        //
        Status =
        AsyncStatus = NDIS_STATUS_SUCCESS; // We never fail this call.

        // Determine if we're to return synchronously or complete
        // asynchronously...
        //
        if (!arpGenRandomInt(AsyncOutcomes, ARRAY_LENGTH(AsyncOutcomes)))
        {
            // We're to return synchronously.
            //
            UNLOCKROOTOBJ(pOwningObject, pSR);
            break;
        }

        // 
        // We're to complete asynchronously...
        //

        DelayMs             = arpGenRandomInt(
                                        DelayMsOutcomes,
                                        ARRAY_LENGTH(DelayMsOutcomes)
                                        );

        if (DelayMs == 0)
        {
            // We're to immediately indicatie async completion...
            // (we don't mess with IRQ levels if we're returning here..)
            //
            UNLOCKROOTOBJ(pOwningObject, pSR);
            ArpCoCloseCallComplete(
                    AsyncStatus,
                    pClientContext,
                    NULL
                    );
            Status = NDIS_STATUS_PENDING;
            break;
        }

        Status = arpDbgAllocateFakeTask(
                            pOwningObject,          // pParentObject,
                            arpDbgFakeCompletionTask,   // pfnHandler,
                            0,                          // Timeout,
                            "Task:Fake NdisClCloseCall", // szDescription,
                            &(PRM_TASK) pCCTask,
                            pSR
                            );
        if (FAIL(Status))
        {
            // Couldn't alloc task; lets call callback right now and return pending.
            //
            UNLOCKROOTOBJ(pOwningObject, pSR);
            ArpCoCloseCallComplete(
                    AsyncStatus,
                    pClientContext,
                    NULL
                    );
            Status = NDIS_STATUS_PENDING;
            break;
        }

        
        // Initialize pCCTask...
        //
        pCCTask->pClientContext     = pClientContext;
        pCCTask->pOwningObject      = pOwningObject;
        pCCTask->Status             = AsyncStatus;
        pCCTask->DelayMs            = DelayMs;
        pCCTask->fDpc               = arpGenRandomInt(
                                            DpcOutcomes,
                                            ARRAY_LENGTH(DpcOutcomes)
                                            );
        pCCTask->pfnCompletionCallback = arpFakeCloseCallCompletionCallback;

        UNLOCKROOTOBJ(pOwningObject, pSR);

        (void) RmStartTask(
                    &pCCTask->TskHdr,
                    0, // UserParam (unused)
                    pSR
                    );

        Status = NDIS_STATUS_PENDING;

    } while (FALSE);


    RM_ASSERT_NOLOCKS(pSR);
    EXIT();

    return Status;
}


VOID
arpDbgFakeNdisCoSendPackets(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets,
    IN  PRM_OBJECT_HEADER       pOwningObject,
    IN  PVOID                   pClientContext
    )
/*++

Routine Description:

    Fake version of NdisCoSendPackets.

--*/
{
    ENTER("FakeNdisCoSendPackets", 0x98c6a8aa)
    NDIS_STATUS Status;
    NDIS_STATUS AsyncStatus;
    UINT        DelayMs;
    RM_DECLARE_STACK_RECORD(sr)
    
    DBGMARK(0x3be1b902);
    ASSERT(NumberOfPackets==1);

    do
    {
        static
        OUTCOME_PROBABILITY
        StatusOutcomes[] = 
        {
            {NDIS_STATUS_SUCCESS,   1},     // Return NDIS_STATUS_SUCCESS
            {NDIS_STATUS_FAILURE,   1}      // Return NDIS_STATUS_FAILURE
        };

        static
        OUTCOME_PROBABILITY
        DelayMsOutcomes[] = 
        {
            {0,         5},     // Delay 0ms, etc...
            {10,        5},
            {100,       5},
            {1000,      1},
            {10000,     1}
        };
        
        static
        OUTCOME_PROBABILITY
        DpcOutcomes[] = 
        {
            {TRUE,      1},     // Complete at DPC level
            {FALSE,     1}      // Complete at PASSIVE level
        };

        FAKETASK *pSPTask;


        // We serialize calls to arpGenRandomInt by claiming the root object's
        // lock...
        //
        LOCKROOTOBJ(pOwningObject, &sr);

        // Get the status we're supposed to return.
        //
        Status =
        AsyncStatus = (NDIS_STATUS) arpGenRandomInt(
                                     StatusOutcomes,
                                     ARRAY_LENGTH(StatusOutcomes)
                                     );

        // Compute the delay amount.
        //
        DelayMs             = arpGenRandomInt(
                                            DelayMsOutcomes,
                                            ARRAY_LENGTH(DelayMsOutcomes)
                                            );
        if (DelayMs == 0)
        {
            UNLOCKROOTOBJ(pOwningObject, &sr);
            // We're to immediately indicatie async completion...
            // (we don't mess with IRQ levels if we're returning here..)
            //
            ArpCoSendComplete(
                AsyncStatus,
                pClientContext,
                *PacketArray
                );
            break;
        }

        //
        // Nonzero delay -- start task to complete this.
        //

        Status = arpDbgAllocateFakeTask(
                            pOwningObject,              // pParentObject,
                            arpDbgFakeCompletionTask,   // pfnHandler,
                            0,                          // Timeout,
                            "Task:Fake NdisCoSendPackets", // szDescription,
                            &(PRM_TASK) pSPTask,
                            &sr
                            );
        if (FAIL(Status))
        {
            UNLOCKROOTOBJ(pOwningObject, &sr);
            // Fail...
            //
            ArpCoSendComplete(
                AsyncStatus,
                pClientContext,
                *PacketArray
                );
            break;
        }

        
        // Initialize pSPTask...
        //
        pSPTask->pClientContext     = pClientContext;
        pSPTask->pOwningObject      = pOwningObject;
        pSPTask->Status             = AsyncStatus;
        pSPTask->DelayMs            = DelayMs;
        pSPTask->fDpc               = arpGenRandomInt(
                                            DpcOutcomes,
                                            ARRAY_LENGTH(DpcOutcomes)
                                            );
        pSPTask->pNdisPacket        = *PacketArray;
        pSPTask->pfnCompletionCallback = arpFakeSendPacketsCompletionCallback;

        UNLOCKROOTOBJ(pOwningObject, &sr);

        (void) RmStartTask(
                    &pSPTask->TskHdr,
                    0, // UserParam (unused)
                    &sr
                    );

        Status = NDIS_STATUS_PENDING;

    } while (FALSE);

    RM_ASSERT_NOLOCKS(&sr);
    EXIT();

}


NDIS_STATUS
arpDbgFakeCompletionTask(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

        This task is to complete the fake api asynchronously after the
        specified delay, with the specified status, and at the specified
        IRQL (passive/dpc).

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    NDIS_STATUS         Status  = NDIS_STATUS_FAILURE;
    FAKETASK          * pFTask =  (FAKETASK *) pTask;
    ENTER("FakeCompletionTask", 0xc319c5c2)

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_ResumedAfterDelay,
        PEND_SwitchedToAsync,
    };

    switch(Code)
    {

        case RM_TASKOP_START:
        {

            TR_WARN((
                "START: Delay=%lu; fDpc=%lu; Status=%lu\n",
                    pFTask->DelayMs,
                    pFTask->fDpc,
                    pFTask->Status
                ));

            if (pFTask->DelayMs!=0)
            {
                //  Non-zero delay -- let's resume after the delay...
                //
                RmSuspendTask(pTask, PEND_ResumedAfterDelay, pSR);

                RmResumeTaskDelayed(
                    pTask, 
                    0,
                    pFTask->DelayMs,
                    &pFTask->Timer,
                    pSR
                    );
            }
            else
            {
                // No delay is requested. Switch to async right away...
                //
                RmSuspendTask(pTask, PEND_SwitchedToAsync, pSR);

                RmResumeTaskAsync(
                    pTask,
                    0,
                    &pFTask->WorkItem,
                    pSR
                    );
            }

            RM_ASSERT_NOLOCKS(pSR);
            Status = NDIS_STATUS_PENDING;

        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {

            switch(RM_PEND_CODE(pTask))
            {
                case PEND_ResumedAfterDelay:
                {
                    // We've waited around for pFTask->DelayMs ms; Now
                    // switch to passive...
                    //
                    RmSuspendTask(pTask, PEND_SwitchedToAsync, pSR);

                    RmResumeTaskAsync(
                        pTask,
                        0,
                        &pFTask->WorkItem,
                        pSR
                        );
                    Status = NDIS_STATUS_PENDING;
                }
                break;

                case PEND_SwitchedToAsync:
                {
                    //
                    // We should now be at PASSIVE IRQL.
                    // Call the completion routine either at DPC or PASSIVE irql.
                    //

                    if (pFTask->fDpc)
                    {
                        //  We need to call the routine at DPC level.
                        //
                        NdisAllocateSpinLock(&pFTask->NdisLock);
                        NdisAcquireSpinLock(&pFTask->NdisLock);
                    }

                    // Call the completion routine.
                    //
                    pFTask->pfnCompletionCallback(pFTask);

                    // If required, release the lock we held earlier.
                    //
                    if (pFTask->fDpc)
                    {
                        NdisReleaseSpinLock(&pFTask->NdisLock);
                    }
                    Status = pFTask->Status;
        
                } // end case  PEND_OnStart
                break;
    

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            Status = (NDIS_STATUS) UserParam;

        }
        break;

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


NDIS_STATUS
arpDbgAllocateFakeTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription,
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Allocates and initializes a task of subtype FAKETASK.

Arguments:

    pParentObject       - Object that is to be the parent of the allocated task.
    pfnHandler          - The task handler for the task.
    Timeout             - Unused.
    szDescription       - Text describing this task.
    ppTask              - Place to store pointer to the new task.

Return Value:

    NDIS_STATUS_SUCCESS if we could allocate and initialize the task.
    NDIS_STATUS_RESOURCES otherwise
--*/
{
    FAKETASK *pFTask;
    NDIS_STATUS Status;
        
    ARP_ALLOCSTRUCT(pFTask, MTAG_DBGINFO);
    Status = NDIS_STATUS_RESOURCES;
    *ppTask = NULL;

    if (pFTask != NULL)
    {

        RmInitializeTask(
                    &(pFTask->TskHdr),
                    pParentObject,
                    pfnHandler,
                    &FakeTasks_StaticInfo,
                    szDescription,
                    Timeout,
                    pSR
                    );
        *ppTask = &(pFTask->TskHdr);
        Status = NDIS_STATUS_SUCCESS;
    }

    return Status;
}


VOID
arpDbgFakeTaskDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    )
/*++

Routine Description:

    Actually free the specified task.

Arguments:

    pObj        - Actually the task to be freed.

--*/
{
    ARP_FREE(pObj);
}


INT
arpGenRandomInt(
    OUTCOME_PROBABILITY *rgOutcomes,
    UINT                cOutcomes
    )
/*++

Routine Description:

    Generate a new sample given the specified probability distribution.


Arguments:

    rgOutcomes      - Array of outcomes from which to select the random
                      sample.
    cOutcomes       - Number of elements in the above array.

Return Value:

    Random integer

--*/
{
    ULONG   u, sum, partsum;
    OUTCOME_PROBABILITY *pOp, *pOpEnd;

    // Get a nicely-random number.
    //
    u = ran1x();

    // Run through weights, computing the sum of weights...
    //
    pOp = pOpEnd = rgOutcomes;
    pOpEnd += cOutcomes;
    sum=0;
    for(; pOp<pOpEnd; pOp++)
    {
        sum += pOp->Weight;
    }

    // It's really meaningless to pass in a pPD with zero sum of weights.
    // We return 0 in this case. 
    //
    if (sum == 0)           return 0;               // EARLY RETURN

    // Make u range from 0..sum-1 inclusive
    //
    u ^= u>>16; // Get more randomness in the lower 16 bits for mod below...
    u %= sum;

    // Now go through the array of outcomes, computing the partial sum (partsum)
    // of weigths, and picking the FIRST outcome at array position X such that
    // u < partsum.
    //
    partsum=0;
    pOp = pOpEnd = rgOutcomes;
    pOpEnd += cOutcomes;
    for(; pOp<pOpEnd; pOp++)
    {
        partsum += pOp->Weight;
        if (u < partsum)
        {
            break;  // Found it!
        }
    }

    ASSERT(pOp<pOpEnd);

    return pOp->Outcome;
}


static long g_idum;

unsigned long ran1x(void)
/*++

Routine Description:

    Closely based on ran1() from "Numerical Recipes in C." ISBN 0 521 43108 5
    (except that it returns unsigned long instead of float, and uses g_idum
     instead of input arg long *idum).

    Pretty uniform and uncorrelated from sample to sample; also individual bits are
    pretty random. We need these properties.

Return Value:

    Random unsigned integer.

--*/
{
    #define IA      16807
    #define IM      RAN1X_MAX
    #define IQ      127773
    #define IR      2836
    #define NTAB    32
    #define NDIV    (1+(IM-1)/NTAB)

    int j;
    long k;
    static long iy=0;
    static long iv[NTAB];

    if (g_idum <= 0 || !iy)
    {
        //
        // Initialization code... (I'm not really sure if iy or g_idum can
        // go to zero in the course of operation, so I'm leaving this
        // initialization code here instead of moving it to sranx1x).
        //

        if (-g_idum < 1)
        {
            g_idum = 1;
        }
        else
        {
            g_idum = -g_idum;
        }
        for (j=NTAB+7;j>=0;j--)
        {
            k = g_idum/IQ;
            g_idum = IA*(g_idum-k*IQ)-IR*k;
            if (g_idum<0)
            {
                g_idum += IM;
            }
            if (j<NTAB)
            {
                iv[j] = g_idum;
            }
        }
        iy=iv[0];
    }

    k=g_idum/IQ;
    g_idum=IA*(g_idum-k*IQ)-IR*k;
    if (g_idum<0)
    {
        g_idum += IM;
    }
    j = iy/NDIV;
    iy = iv[j];
    iv[j] = g_idum;

    // iy ranges from 1 .. (IM-1)
    //
    return (unsigned long) iy;
}

void
sran1x(
    unsigned long seed
    )
/*++

Routine Description:

    Sets the seed used by ran1x.

--*/
{
    g_idum = (long) seed;

    //
    // Make sure the seed is -ve, to trigger ran1x initialization code above.
    //

    if (g_idum > 0)
    {
        g_idum = -g_idum;
    }
    if (g_idum==0)
    {
        g_idum = -1;
    }
}


VOID
arpFakeMakeCallCompletionCallback(
    struct _FAKETASK *pFTask
)
/*++

Routine Description:

    Calls ARP's makecall completion callback.

Arguments:

    pFTask  - Task in whose context this callback is to be made. The task
              contains information used in calling the makecall  completion
              callback.
--*/
{
    // Call the make call completion routine.
    //
    ArpCoMakeCallComplete(
                pFTask->Status,
                (NDIS_HANDLE)  pFTask->pClientContext,
                NULL,
                pFTask->CallParameters
                );
}


VOID
arpFakeCloseCallCompletionCallback(
    struct _FAKETASK *pFTask
)
/*++

Routine Description:

    Calls ARP's closecall completion callback.

Arguments:

    pFTask  - Task in whose context this callback is to be made. The task
              contains information used in calling the closecall  completion
              callback.
--*/
{
        ArpCoCloseCallComplete(
                pFTask->Status,
                (NDIS_HANDLE)  pFTask->pClientContext,
                NULL
                );
}


VOID
arpFakeSendPacketsCompletionCallback(
    struct _FAKETASK *pFTask
)
/*++

Routine Description:

    Calls ARP's cosendpackets completion callback.

Arguments:

    pFTask  - Task in whose context this callback is to be made. The task
              contains information used in calling the cosendpackets  completion
              callback.
--*/
{
        ArpCoSendComplete(
                pFTask->Status,
                (NDIS_HANDLE)  pFTask->pClientContext,
                pFTask->pNdisPacket
                );
}

#endif // ARPDBG_FAKE_APIS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\fake.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    ccdefs.h

Abstract:

    Header file for fake versions of various external calls (ndis, ip...).
    Used for debugging and component testing only.

    To enable, define ARPDBG_FAKE_APIS in ccdefs.h

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    josephj     03-24-99    created

--*/


NDIS_STATUS
arpDbgFakeNdisClMakeCall(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    OUT PNDIS_HANDLE            NdisPartyHandle,        OPTIONAL
    IN  PRM_OBJECT_HEADER       pOwningObject,
    IN  PVOID                   pClientContext,
    IN  PRM_STACK_RECORD        pSR
    );

NDIS_STATUS
arpDbgFakeNdisClCloseCall(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  NDIS_HANDLE             NdisPartyHandle         OPTIONAL,
    IN  PVOID                   Buffer                  OPTIONAL,
    IN  UINT                    Size,                   OPTIONAL
    IN  PRM_OBJECT_HEADER       pOwningObject,
    IN  PVOID                   pClientContext,
    IN  PRM_STACK_RECORD        pSR
    );


VOID
arpDbgFakeNdisCoSendPackets(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets,
    IN  PRM_OBJECT_HEADER       pOwningObject,
    IN  PVOID                   pClientContext
    );


//
// The following defines and prototypes are exposed here just so that they
// are accessable to the component tests under .\tests.
//

#define RAN1X_MAX 2147483647

// ran1x returns randum unsigned longs in the range  0..RAN1X_MAX exclusive
// (i.e., 1..(RAN1X_MAX-1) inclusive).
//
unsigned long ran1x(
    void
    );

// like "srand" -- sets the seed.
//
void
sran1x(
    unsigned long seed
    );

typedef struct
{
    INT     Outcome;        // Value of this outcome
    UINT    Weight;         // Relative weight of this outcome

} OUTCOME_PROBABILITY;

INT
arpGenRandomInt(
    OUTCOME_PROBABILITY *rgOPs,
    UINT cOutcomes
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\ioctl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    Handler routines for Internal IOCTLs, including IOCTL_ARP1394_REQUEST.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     11-20-97    Created

Notes:

--*/

#include <precomp.h>
// #include "ioctl.h"

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_NT


NTSTATUS
arpDoClientCommand(
        PARP1394_IOCTL_COMMAND              pCmd,
        UINT                                BufLen,
        UINT                                OutputLen
        );

NTSTATUS
arpDoEthernetCommand(
        PARP1394_IOCTL_COMMAND              pCmd,
        UINT                                BufLen
        );

NTSTATUS
arpIoctlGetArpCache(
        PARP1394_INTERFACE                  pIF,
        PARP1394_IOCTL_GET_ARPCACHE         pGetCacheCmd,
        PRM_STACK_RECORD                    pSR
        );

NTSTATUS
arpIoctlAddArpEntry(
        PARP1394_INTERFACE                  pIF,
        PARP1394_IOCTL_ADD_ARP_ENTRY        pAddArpEntryCmd,
        PRM_STACK_RECORD                    pSR
        );

NTSTATUS
arpIoctlDelArpEntry(
        PARP1394_INTERFACE                  pIF,
        PARP1394_IOCTL_DEL_ARP_ENTRY        pDelArpEntryCmd,
        PRM_STACK_RECORD                    pSR
        );

NTSTATUS
arpIoctlGetPacketStats(
        PARP1394_INTERFACE                  pIF,
        PARP1394_IOCTL_GET_PACKET_STATS     pStatsCmd,
        PRM_STACK_RECORD                    pSR
        );

NTSTATUS
arpIoctlGetTaskStats(
        PARP1394_INTERFACE                  pIF,
        PARP1394_IOCTL_GET_TASK_STATS       pStatsCmd,
        PRM_STACK_RECORD                    pSR
        );


NTSTATUS
arpIoctlGetArpStats(
        PARP1394_INTERFACE                  pIF,
        PARP1394_IOCTL_GET_ARPCACHE_STATS   pStatsCmd,
        PRM_STACK_RECORD                    pSR
        );

NTSTATUS
arpIoctlGetCallStats(
        PARP1394_INTERFACE                  pIF,
        PARP1394_IOCTL_GET_CALL_STATS       pStatsCmd,
        PRM_STACK_RECORD                    pSR
        );

NTSTATUS
arpIoctlResetStats(
        PARP1394_INTERFACE                  pIF,
        PARP1394_IOCTL_RESET_STATS          pResetStatsCmd,
        PRM_STACK_RECORD                    pSR
        );

NTSTATUS
arpIoctlReinitIf(
        PARP1394_INTERFACE                  pIF,
        PARP1394_IOCTL_REINIT_INTERFACE     pReinitCmd,
        PRM_STACK_RECORD                    pSR
        );

PARP1394_INTERFACE
arpGetIfByIp(
        IN OUT IP_ADDRESS                   *pLocalIpAddress, // OPTIONAL
        PRM_STACK_RECORD                    pSR
        );

UINT
arpGetStatsDuration(
        PARP1394_INTERFACE pIF
        );

NTSTATUS
arpIoctlSendPacket(
        PARP1394_INTERFACE              pIF,
        PARP1394_IOCTL_SEND_PACKET      pSendPacket,
        PRM_STACK_RECORD                pSR
        );

NTSTATUS
arpIoctlRecvPacket(
        PARP1394_INTERFACE              pIF,
        PARP1394_IOCTL_RECV_PACKET      pRecvPacket,
        PRM_STACK_RECORD                pSR
        );

NTSTATUS
arpIoctlGetNicInfo(
        PARP1394_INTERFACE              pIF,
        PARP1394_IOCTL_NICINFO          pIoctlNicInfo,
        PRM_STACK_RECORD                pSR
        );

NTSTATUS
arpIoctlGetEuidNodeMacInfo(
        PARP1394_INTERFACE          pIF,
        PARP1394_IOCTL_EUID_NODE_MAC_INFO   pEuidInfo,
        PRM_STACK_RECORD            pSR
        );


NTSTATUS
ArpHandleIoctlRequest(
    IN  PIRP                    pIrp,
    IN  PIO_STACK_LOCATION      pIrpSp
    )
/*++

Routine Description:

    Private IOCTL interface to the ARP1394 administration utility.

--*/
{
    NTSTATUS                NtStatus = STATUS_UNSUCCESSFUL;
    PUCHAR                  pBuf;  
    UINT                    BufLen;
    ULONG                   Code;
    UINT                    OutputLength;

    ENTER("Ioctl", 0x4e96d522)

    pIrp->IoStatus.Information = 0;
    pBuf    = pIrp->AssociatedIrp.SystemBuffer;
    BufLen  = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
    Code    = pIrpSp->Parameters.DeviceIoControl.IoControlCode;

    OutputLength = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
    TR_WARN(("Code = 0x%p\n", Code));
    
    if (Code ==  ARP_IOCTL_CLIENT_OPERATION && pBuf != NULL)
    {
        PARP1394_IOCTL_COMMAND          pCmd;
        pCmd = (PARP1394_IOCTL_COMMAND) pBuf;


        if (   (pCmd->Hdr.Op >= ARP1394_IOCTL_OP_ETHERNET_FIRST)
            && (pCmd->Hdr.Op <= ARP1394_IOCTL_OP_ETHERNET_LAST))
        {
            // This is an ethernet-emulation related ioctl request (from
            // NIC1394.SYS). We handle these differently.
            //
            if (pIrp->RequestorMode == KernelMode)
            {
                NtStatus = arpDoEthernetCommand(pCmd, BufLen);
            }
            else
            {
                //
                // The ethernet ioctl has not come from nic1394. fail the request
                //
                NtStatus = STATUS_UNSUCCESSFUL;
            }
        }
        else
        {
            NtStatus = arpDoClientCommand(pCmd, BufLen,OutputLength);
        }

        //
        // All commands return stuff in pCmd itself...
        //
        if (NtStatus == STATUS_SUCCESS)
        {
            pIrp->IoStatus.Information = BufLen;
        }
    }
    else
    {
        TR_WARN(("Unrecognized code.\n"));
    }

    EXIT()
    return NtStatus;
}

NTSTATUS
arpDoClientCommand(
    PARP1394_IOCTL_COMMAND  pCmd,
    UINT                    BufLen,
    UINT                    OutputLength
    )
{
    ENTER("arpDoClientCommand", 0xd7985f1b)
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    PARP1394_INTERFACE  pIF;
    RM_DECLARE_STACK_RECORD(sr)

    do
    {
        IP_ADDRESS          IpAddress;

        pIF = NULL;

        if (pCmd == NULL)
        {
            TR_WARN(("Invalid buffer %p\n", pCmd));
            break;

        }

        if (BufLen<sizeof(pCmd->Hdr))
        {
            TR_WARN(("Buffer too small (%lu)\n", BufLen));
            break;
        }

        if (pCmd->Hdr.Version != ARP1394_IOCTL_VERSION)
        {
            TR_WARN(("Incorrect version 0x%08lx\n", pCmd->Hdr.Version));
            break;
        }

        if (OutputLength< sizeof(*pCmd))
        {
            TR_WARN(("Buffer too small (%lu)\n", BufLen));
            break;
        }

        
        IpAddress = (IP_ADDRESS)  pCmd->Hdr.IfIpAddress;

        // IpAddress could be all-zeros, in which case we'll get the first IF,
        // and IpAddress will be set to one of the local IP addresses of this IF.
        // NOTE: pIF is tmpref'd.
        //
        pIF = arpGetIfByIp(&IpAddress, &sr);

        if (pIF == NULL)
        {
            TR_WARN(("Couldn't find IF with IP 0x%0x8lx\n", IpAddress));
            break;
        }

        pCmd->Hdr.IfIpAddress        = IpAddress;
        
        switch(pCmd->Hdr.Op)
        {
        case ARP1394_IOCTL_OP_GET_ARPCACHE:
            {
                PARP1394_IOCTL_GET_ARPCACHE pGetArpCache =  &pCmd->GetArpCache;
        
                if (OutputLength >= sizeof(*pGetArpCache))
                {
                    //
                    // Check if there is enough space for all the arp entries.
                    //
                    ULONG EntrySpace;
                    EntrySpace = OutputLength - FIELD_OFFSET(
                                                ARP1394_IOCTL_GET_ARPCACHE,
                                                Entries
                                                );
                    if ((EntrySpace/sizeof(pGetArpCache->Entries[0])) >
                        pGetArpCache->NumEntriesAvailable)
                    {
                        //
                        // Yes, there is enough space.
                        //
                        NtStatus = arpIoctlGetArpCache(pIF, pGetArpCache, &sr);
                    }
                }
            }
            break;
    
        case ARP1394_IOCTL_OP_ADD_STATIC_ENTRY:
            {
            
                PARP1394_IOCTL_ADD_ARP_ENTRY pAddCmd =  &pCmd->AddArpEntry;
                if (OutputLength >= sizeof(*pAddCmd))
                {
                    NtStatus = arpIoctlAddArpEntry(pIF, pAddCmd, &sr);
                }
                
            }
            break;
    
        case ARP1394_IOCTL_OP_DEL_STATIC_ENTRY:
            {
            
                PARP1394_IOCTL_DEL_ARP_ENTRY pDelCmd =  &pCmd->DelArpEntry;
                if (OutputLength >= sizeof(*pDelCmd))
                {
                    NtStatus = arpIoctlDelArpEntry(pIF, pDelCmd, &sr);
                }
            }
            break;
        
        case ARP1394_IOCTL_OP_GET_PACKET_STATS:
            {
                PARP1394_IOCTL_GET_PACKET_STATS pStats =  &pCmd->GetPktStats;
                if (OutputLength >= sizeof(*pStats))
                {
                    NtStatus = arpIoctlGetPacketStats(pIF, pStats, &sr);
                }
            }
            break;
    
    
        case ARP1394_IOCTL_OP_GET_ARPCACHE_STATS:
            {
                PARP1394_IOCTL_GET_ARPCACHE_STATS pStats =  &pCmd->GetArpStats;
                if (OutputLength >= sizeof(*pStats))
                {
                    NtStatus = arpIoctlGetArpStats(pIF, pStats, &sr);
                }
            }
            break;
    
        case ARP1394_IOCTL_OP_GET_CALL_STATS:
            {
                PARP1394_IOCTL_GET_CALL_STATS pStats =  &pCmd->GetCallStats;
                if (OutputLength >= sizeof(*pStats))
                {
                    NtStatus = arpIoctlGetCallStats(pIF, pStats, &sr);
                }
            }
            break;
    
        case ARP1394_IOCTL_OP_RESET_STATS:
            {
                PARP1394_IOCTL_RESET_STATS pResetStats =  &pCmd->ResetStats;
                if (OutputLength >= sizeof(*pResetStats))
                {
                    NtStatus = arpIoctlResetStats(pIF, pResetStats, &sr);
                }
            }
            break;

        case ARP1394_IOCTL_OP_REINIT_INTERFACE:
            {
                PARP1394_IOCTL_REINIT_INTERFACE pReinitIf =  &pCmd->ReinitInterface;
                if (OutputLength >= sizeof(*pReinitIf))
                {
                    NtStatus = arpIoctlReinitIf(pIF, pReinitIf, &sr);
                }
            }
            break;
        
        case  ARP1394_IOCTL_OP_GET_NICINFO:
            {
                ARP1394_IOCTL_NICINFO *pIoctlNicInfo = &pCmd->IoctlNicInfo;
                if (OutputLength >= sizeof(*pIoctlNicInfo))
                {
                    NtStatus = arpIoctlGetNicInfo(pIF, pIoctlNicInfo, &sr);
                }
            }
            break;
        case ARP1394_IOCTL_OP_GET_EUID_NODE_MAC_TABLE:
            {
                PARP1394_IOCTL_EUID_NODE_MAC_INFO pIoctlEuidInfo = &pCmd->EuidNodeMacInfo;
                if (OutputLength >= sizeof(*pIoctlEuidInfo))
                {
                    NtStatus = arpIoctlGetEuidNodeMacInfo(pIF, pIoctlEuidInfo, &sr);
                }

            }
            break;

        default:
            TR_WARN(("Unknown op %lu\n",  pCmd->Hdr.Op));
            break;
    
        }
    } while (FALSE);

    if (NtStatus != STATUS_SUCCESS)
    {
        TR_WARN(("Command unsuccessful. NtStatus = 0x%lx\n", NtStatus));
    }

    if (pIF != NULL)
    {
        RmTmpDereferenceObject(&pIF->Hdr, &sr);
    }

    RM_ASSERT_CLEAR(&sr);
    EXIT()

    return NtStatus;
}


NTSTATUS
arpDoEthernetCommand(
    PARP1394_IOCTL_COMMAND  pCmd,
    UINT                    BufLen
    )
{
    ENTER("arpDoEthernetCommand", 0xa723f233)
    PARP1394_IOCTL_ETHERNET_NOTIFICATION pNotif;
    PARP1394_ADAPTER pAdapter = NULL;
    RM_DECLARE_STACK_RECORD(sr)

    pNotif = (PARP1394_IOCTL_ETHERNET_NOTIFICATION) pCmd;

    do
    {
        NDIS_STATUS NdisStatus = NDIS_STATUS_FAILURE;
        NDIS_STRING DeviceName;

        if (BufLen<sizeof(*pNotif))
        {
            TR_WARN(("Buffer too small (%lu)\n", BufLen));
            break;
        }

        if (pNotif->Hdr.Version != ARP1394_IOCTL_VERSION)
        {
            TR_WARN(("Incorrect version 0x%08lx\n", pCmd->Hdr.Version));
            break;
        }


        NdisInitUnicodeString(&DeviceName, pNotif->AdapterName);

        //null-terminate DeviceName
        DeviceName.Buffer[(DeviceName.MaximumLength/sizeof(WCHAR))-1] = '\0';

        if (pNotif->Hdr.Op == ARP1394_IOCTL_OP_ETHERNET_START_EMULATION)
        {
            //
            // ArpNdBindAdapter will try to create the adapter in "Bridge
            // mode" if it passed in a NULL bind context.
            // It will of course fail if the adapter exists.
            //
            ArpNdBindAdapter(
                &NdisStatus,
                NULL,           // BindContext
                &DeviceName,    // pDeviceName
                NULL,           // SystemSpecific1
                NULL            // SystemSpecific2
                );
            break;
        }

        //
        // The remaining operations concern an existing adapter which has been
        // created in "bridge" mode. Let's look up this adapter based on it's
        // name.
        //

        NdisStatus = RmLookupObjectInGroup(
                            &ArpGlobals.adapters.Group,
                            0,                              // Flags
                            (PVOID) &DeviceName,            // pKey
                            NULL,                           // pvCreateParams
                            &(PRM_OBJECT_HEADER) pAdapter,  // pObj
                            NULL,                           // pfCreated
                            &sr
                            );
        if (FAIL(NdisStatus))
        {
            TR_WARN(("Couldn't find adapter object\n"));
            pAdapter = NULL;
            break;
        }

        if (!ARP_BRIDGE_ENABLED(pAdapter))
        {
            TR_WARN((
            "Ignoring Ethernet Emulation Ioctl Op 0x%x"
            " because adapter 0x%p is not in bridge mode.\n",
            pNotif->Hdr.Op,
            pAdapter));
            break;
        }

        //
        // OK -- we've found the adapter and the adapter is in bridged mode.
        // Let's look at the specific command.
        //

        switch(pNotif->Hdr.Op)
        {

        case  ARP1394_IOCTL_OP_ETHERNET_STOP_EMULATION:
            {
                // Calling ArpNdUnbindAdapter with NULL UnbindContext prevents
                // it from trying to call NdisCompleteUnbindAdapter.
                //
                ArpNdUnbindAdapter(
                    &NdisStatus,
                    (NDIS_HANDLE) pAdapter,
                    NULL // UnbindContext
                    );
            }
            break;

        case ARP1394_IOCTL_OP_ETHERNET_ADD_MULTICAST_ADDRESS:
            {
                // TODO: unimplemented.
            }
            break;

        case ARP1394_IOCTL_OP_ETHERNET_DEL_MULTICAST_ADDRESS:
            {
                // TODO: unimplemented.
            }
            break;

        case ARP1394_IOCTL_OP_ETHERNET_ENABLE_PROMISCUOUS_MODE:
            {
                // TODO: unimplemented.
            }
            break;

        case ARP1394_IOCTL_OP_ETHERNET_DISABLE_PROMISCUOUS_MODE:
            {
                // TODO: unimplemented.
            }
            break;
    
        default:
            TR_WARN(("Unknown op %lu\n",  pCmd->Hdr.Op));
            break;
    
        }

    } while (FALSE);

    if (pAdapter != NULL)
    {
        RmTmpDereferenceObject(&pAdapter->Hdr, &sr);
    }

    RM_ASSERT_CLEAR(&sr);
    EXIT()

    return STATUS_SUCCESS;
}


NTSTATUS
arpIoctlGetArpCache(
        PARP1394_INTERFACE           pIF,
        PARP1394_IOCTL_GET_ARPCACHE pGetCacheCmd,
        PRM_STACK_RECORD            pSR
        )
{
    ENTER("GetArpCache", 0xa64453c7)
    NTSTATUS            NtStatus;
    TR_WARN(("GET ARP CACHE\n"));

    pGetCacheCmd->NumEntriesUsed    = 0;
    NtStatus                        = STATUS_UNSUCCESSFUL;

    do
    {
        PARP1394_ADAPTER pAdapter;
        PARP1394_ARP_ENTRY  pEntry;
        ARPCB_REMOTE_IP *   pRemoteIp;
        NDIS_STATUS         Status;
        UINT                EntriesAvailable;
        UINT                EntriesUsed;
        UINT                CurIndex;
        UINT                Index;


        LOCKOBJ(pIF, pSR);

        pAdapter =  (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
        pGetCacheCmd->NumEntriesInArpCache   = pIF->RemoteIpGroup.HashTable.NumItems;
        pGetCacheCmd->LocalHwAddress.UniqueID= pAdapter->info.LocalUniqueID;
        pGetCacheCmd->LocalHwAddress.Off_Low = pIF->recvinfo.offset.Off_Low;
        pGetCacheCmd->LocalHwAddress.Off_High= pIF->recvinfo.offset.Off_High;

        //
        // Pick up pGetCacheCmd->NumEntriesAvailable arp entries starting
        // from the (pGetCacheCmd->Index)'th one.
        //
    
        pRemoteIp       = NULL;
        EntriesAvailable = pGetCacheCmd->NumEntriesAvailable;
        EntriesUsed = 0;
        Index = pGetCacheCmd->Index;
        pEntry = pGetCacheCmd->Entries;
        CurIndex = 0;
    
        // Get the 1st entry...
        //
        Status = RmGetNextObjectInGroup(
                    &pIF->RemoteIpGroup,
                    NULL,
                    &(PRM_OBJECT_HEADER)pRemoteIp,
                    pSR
                    );
        if (FAIL(Status))
        {
            // Presumably there are no entries.
            pRemoteIp = NULL;
        }
    
        while (pRemoteIp != NULL)
        {
            ARPCB_REMOTE_IP *   pNextRemoteIp = NULL;

            if (EntriesUsed >= EntriesAvailable)
            {
                //
                // out of space; Update the context, and set special return value.
                //
                RmTmpDereferenceObject(&pRemoteIp->Hdr, pSR);
                pRemoteIp = NULL;
                break;
            }
    
            // If this entry is within the range asked for, we copy the IP and
            // HW address over onto pEntry...
            //
            if (CurIndex >= Index)
            {
                ARP_ZEROSTRUCT(pEntry);
                pEntry->IpAddress = pRemoteIp->Key.IpAddress;
                if (CHECK_REMOTEIP_RESOLVE_STATE(pRemoteIp, ARPREMOTEIP_RESOLVED))
                {
                    ARPCB_DEST *pDest = pRemoteIp->pDest;
    
                    TR_INFO(("ReadNext: found Remote IP Entry 0x%x, Addr %d.%d.%d.%d\n",
                                pRemoteIp,
                                ((PUCHAR)(&(pRemoteIp->IpAddress)))[0],
                                ((PUCHAR)(&(pRemoteIp->IpAddress)))[1],
                                ((PUCHAR)(&(pRemoteIp->IpAddress)))[2],
                                ((PUCHAR)(&(pRemoteIp->IpAddress)))[3]
                            ));
            
                    // We assert that
                    // IF lock is the same as pRemoteIp's and pDest's lock,
                    // and that lock is locked.
                    // We implicitly assert that pDest is non-NULl as well.
                    //
                    ASSERTEX(pRemoteIp->Hdr.pLock == pDest->Hdr.pLock, pRemoteIp);
                    RM_DBG_ASSERT_LOCKED(&pRemoteIp->Hdr, pSR);
    
                    pEntry->HwAddress.UniqueID  = pDest->Params.HwAddr.FifoAddress.UniqueID;
                    pEntry->HwAddress.Off_Low   = pDest->Params.HwAddr.FifoAddress.Off_Low;
                    pEntry->HwAddress.Off_High  = pDest->Params.HwAddr.FifoAddress.Off_High;
    
                    if (CHECK_REMOTEIP_SDTYPE(pRemoteIp, ARPREMOTEIP_STATIC))
                    {
                        // TODO
                    }
                    else
                    {
                        // TODO
                    }
                }
                else
                {
                    // TODO
                }
    
                pEntry++;
                EntriesUsed++;
            }
    
            // Lookup next entry's IP address and save it in our context.
            //
            Status = RmGetNextObjectInGroup(
                            &pIF->RemoteIpGroup,
                            &pRemoteIp->Hdr,
                            &(PRM_OBJECT_HEADER)pNextRemoteIp,
                            pSR
                            );
    
            if (FAIL(Status))
            {
                //
                // we're presumably done. 
                //
                pNextRemoteIp = NULL;
            }
    
            // TmpDeref pRemoteIp and move on to the next one.
            //
            RmTmpDereferenceObject(&pRemoteIp->Hdr, pSR);
            pRemoteIp = pNextRemoteIp;
    
        }
    
        ASSERT(pRemoteIp == NULL);
        UNLOCKOBJ(pIF, pSR);

        ASSERT(EntriesUsed <= pGetCacheCmd->NumEntriesAvailable);
        pGetCacheCmd->NumEntriesUsed = EntriesUsed;
        NtStatus = STATUS_SUCCESS;

    } while (FALSE);

    EXIT()
    return NtStatus;
}


NTSTATUS
arpIoctlAddArpEntry(
        PARP1394_INTERFACE           pIF,
        PARP1394_IOCTL_ADD_ARP_ENTRY pAddArpEntryCmd,
        PRM_STACK_RECORD            pSR
        )
{
    ENTER("AddArpEntry", 0xcda56c6f)
    NTSTATUS            NtStatus;

    TR_WARN(("ADD ARP ENTRY\n"));
    NtStatus                        = STATUS_UNSUCCESSFUL;

    do
    {
        NDIS_STATUS         Status;
        NIC1394_FIFO_ADDRESS    FifoAddress;

#if FAIL_SET_IOCTL

        break;
#endif

        LOCKOBJ(pIF, pSR);

        FifoAddress.UniqueID    = pAddArpEntryCmd->HwAddress.UniqueID;
        FifoAddress.Off_Low     = pAddArpEntryCmd->HwAddress.Off_Low;
        FifoAddress.Off_High    = pAddArpEntryCmd->HwAddress.Off_High;

        // 
        // TODO -- we hardcode the Off_Low and Off_High values for now...
        //
        FifoAddress.Off_Low     = 0x0;
        FifoAddress.Off_High    = 0x100;

        // Actually add the entry...
        //
        Status = arpAddOneStaticArpEntry(
                    pIF,
                    pAddArpEntryCmd->IpAddress,
                    &FifoAddress,
                    pSR
                    );
    
        UNLOCKOBJ(pIF, pSR);

        if (!FAIL(Status))
        {
            NtStatus = STATUS_SUCCESS;
        }

    } while (FALSE);


    EXIT()
    return NtStatus;
}

NTSTATUS
arpIoctlDelArpEntry(
        PARP1394_INTERFACE           pIF,
        PARP1394_IOCTL_DEL_ARP_ENTRY pDelArpEntryCmd,
        PRM_STACK_RECORD            pSR
        )
{
    ENTER("DelArpEntry", 0x3427306a)
    NTSTATUS            NtStatus;

    TR_WARN(("DEL ARP ENTRY\n"));
    NtStatus                        = STATUS_UNSUCCESSFUL;

#if FAIL_SET_IOCTL

     return NtStatus;

#endif

    NtStatus = arpDelArpEntry(pIF,pDelArpEntryCmd->IpAddress,pSR);
    EXIT()
    return NtStatus;
}


NTSTATUS
arpIoctlGetPacketStats(
    PARP1394_INTERFACE           pIF,
    PARP1394_IOCTL_GET_PACKET_STATS pStatsCmd,
    PRM_STACK_RECORD            pSR
    )
{
    ENTER("GetPacketStats", 0xe7c75fdb)
    NTSTATUS            NtStatus;

    TR_WARN(("GET PACKET STATS\n"));
    NtStatus                        = STATUS_UNSUCCESSFUL;

    do
    {
        NDIS_STATUS             Status;

        pStatsCmd->StatsDuration        = arpGetStatsDuration(pIF);
    
        pStatsCmd->TotSends             = pIF->stats.sendpkts.TotSends;
        pStatsCmd->FastSends            = pIF->stats.sendpkts.FastSends;
        pStatsCmd->MediumSends          = pIF->stats.sendpkts.MediumSends;
        pStatsCmd->SlowSends            = pIF->stats.sendpkts.SlowSends;
        pStatsCmd->BackFills            = pIF->stats.sendpkts.BackFills;
        // TODO: report  pIF->sendinfo.HeaderPool.stats.TotAllocFails
        pStatsCmd->HeaderBufUses        = 
                                    pIF->sendinfo.HeaderPool.stats.TotBufAllocs
                                 + pIF->sendinfo.HeaderPool.stats.TotCacheAllocs;
        pStatsCmd->HeaderBufCacheHits   =
                                 pIF->sendinfo.HeaderPool.stats.TotCacheAllocs;
    
        pStatsCmd->TotRecvs             = pIF->stats.recvpkts.TotRecvs;
        pStatsCmd->NoCopyRecvs          = pIF->stats.recvpkts.NoCopyRecvs;
        pStatsCmd->CopyRecvs            = pIF->stats.recvpkts.CopyRecvs;
        pStatsCmd->ResourceRecvs        = pIF->stats.recvpkts.ResourceRecvs;
    
        pStatsCmd->SendFifoCounts       = pIF->stats.sendpkts.SendFifoCounts;
        pStatsCmd->RecvFifoCounts       = pIF->stats.recvpkts.RecvFifoCounts;

        pStatsCmd->SendChannelCounts    = pIF->stats.sendpkts.SendChannelCounts;
        pStatsCmd->RecvChannelCounts    = pIF->stats.recvpkts.RecvChannelCounts;

        NtStatus = STATUS_SUCCESS;

    } while (FALSE);

    EXIT()
    return NtStatus;
}



NTSTATUS
arpIoctlGetTaskStats(
    PARP1394_INTERFACE           pIF,
    PARP1394_IOCTL_GET_TASK_STATS pStatsCmd,
    PRM_STACK_RECORD            pSR
    )
{
    ENTER("GetTaskStats", 0x4abc46b5)
    TR_WARN(("GET TASK STATS\n"));
    return 0;
}


NTSTATUS
arpIoctlGetArpStats(
    PARP1394_INTERFACE           pIF,
    PARP1394_IOCTL_GET_ARPCACHE_STATS pStatsCmd,
    PRM_STACK_RECORD            pSR
    )
{
    ENTER("GetArpStats", 0x5482de10)
    TR_WARN(("GET ARP STATS\n"));

    pStatsCmd->StatsDuration        = arpGetStatsDuration(pIF);
    pStatsCmd->TotalQueries         = pIF->stats.arpcache.TotalQueries;
    pStatsCmd->SuccessfulQueries    = pIF->stats.arpcache.SuccessfulQueries;
    pStatsCmd->FailedQueries        = pIF->stats.arpcache.FailedQueries;
    pStatsCmd->TotalResponses       = pIF->stats.arpcache.TotalResponses;
    pStatsCmd->TotalLookups         = pIF->stats.arpcache.TotalLookups;
    pStatsCmd->TraverseRatio        = RM_HASH_TABLE_TRAVERSE_RATIO(
                                                &(pIF->RemoteIpGroup.HashTable)
                                                );

    EXIT()
    return  STATUS_SUCCESS;
}

NTSTATUS
arpIoctlGetCallStats(
    PARP1394_INTERFACE           pIF,
    PARP1394_IOCTL_GET_CALL_STATS pStatsCmd,
    PRM_STACK_RECORD            pSR
    )
{
    ENTER("GetCallStats", 0xf81ed4cf)
    TR_WARN(("GET CALL STATS\n"));

    //
    // FIFO-related call stats.
    //
    pStatsCmd->TotalSendFifoMakeCalls   =
                                pIF->stats.calls.TotalSendFifoMakeCalls;
    pStatsCmd->SuccessfulSendFifoMakeCalls =
                                pIF->stats.calls.SuccessfulSendFifoMakeCalls;
    pStatsCmd->FailedSendFifoMakeCalls =
                                pIF->stats.calls.FailedSendFifoMakeCalls;
    pStatsCmd->IncomingClosesOnSendFifos =
                                pIF->stats.calls.IncomingClosesOnSendFifos;

    //
    // Channel-related call stats.
    //
    pStatsCmd->TotalChannelMakeCalls =
                                pIF->stats.calls.TotalChannelMakeCalls;
    pStatsCmd->SuccessfulChannelMakeCalls =
                                pIF->stats.calls.SuccessfulChannelMakeCalls;
    pStatsCmd->FailedChannelMakeCalls =
                                pIF->stats.calls.FailedChannelMakeCalls;
    pStatsCmd->IncomingClosesOnChannels =
                                pIF->stats.calls.IncomingClosesOnChannels;

    return STATUS_SUCCESS;
}

NTSTATUS
arpIoctlResetStats(
        PARP1394_INTERFACE           pIF,
        PARP1394_IOCTL_RESET_STATS pResetStatsCmd,
        PRM_STACK_RECORD            pSR
        )
{
    NTSTATUS            NtStatus;
    ENTER("ResetStats", 0xfa50cfc9)
    TR_WARN(("RESET STATS\n"));

    NtStatus                        = STATUS_UNSUCCESSFUL;

    do
    {
        NDIS_STATUS         Status;
        NIC1394_FIFO_ADDRESS    FifoAddress;


        LOCKOBJ(pIF, pSR);
        arpResetIfStats(pIF, pSR);
        UNLOCKOBJ(pIF, pSR);
        NtStatus = STATUS_SUCCESS;

    } while (FALSE);

    EXIT()
    return NtStatus;
}

NTSTATUS
arpIoctlReinitIf(
        PARP1394_INTERFACE           pIF,
        PARP1394_IOCTL_REINIT_INTERFACE pReinitIfCmd,
        PRM_STACK_RECORD            pSR
        )
{
    ENTER("ReinitIf", 0xed00187a)
    NTSTATUS            NtStatus;

    TR_WARN(("REINIT IF\n"));
    NtStatus                        = STATUS_UNSUCCESSFUL;

    do
    {
        NDIS_STATUS         Status;
        NIC1394_FIFO_ADDRESS    FifoAddress;

#if FAIL_SET_IOCTL

        break;            
#endif

        Status = arpTryReconfigureIf(pIF, NULL, pSR);

        if (PEND(Status) || !FAIL(Status))
        {
            NtStatus = STATUS_SUCCESS;
        }

    } while (FALSE);

    EXIT()
    return NtStatus;
}


PARP1394_INTERFACE
arpGetIfByIp(
    IN OUT IP_ADDRESS *pLocalIpAddress, // OPTIONAL
    PRM_STACK_RECORD pSR
    )
/*++
Routine Description:

    Find and return the 1st (and usually only) interface which has
    *pLocalIpAddress as a local IP address.

    If pLocalIpAddress is NULL, or *pLocalIpAddress is 0, return the
    first interface.

    Tmpref the interface before returning it.

--*/
{
    ENTER("arpGetIfByIp", 0xe9667c54)
    PARP1394_ADAPTER   pAdapter      = NULL;
    PARP1394_INTERFACE pIF = NULL;
    PARP1394_INTERFACE pFirstIF = NULL;
    NDIS_STATUS        Status;
    IP_ADDRESS         LocalIpAddress = 0;

    if (pLocalIpAddress != NULL)
    {
        LocalIpAddress = *pLocalIpAddress;
    }

    //
    // We iterate through all adapters, and for each adapter we look
    // for the specified ip address in the IF's LocalIp group.
    //

    // Get the 1st adapter...
    //
    Status = RmGetNextObjectInGroup(
                    &ArpGlobals.adapters.Group,
                    NULL,
                    &(PRM_OBJECT_HEADER)pAdapter,
                    pSR
                    );

    if (FAIL(Status))
    {
        pAdapter = NULL;
    }

    while (pAdapter != NULL)
    {
        ARP1394_ADAPTER *   pNextAdapter = NULL;


        // Check if this adapter's interface has the local ip address.
        //
        LOCKOBJ(pAdapter, pSR);
        ASSERT(pIF==NULL);
        pIF = pAdapter->pIF;
        if (pIF != NULL)
        {
            RmTmpReferenceObject(&pIF->Hdr, pSR);
            if (pFirstIF == NULL)
            {
                pFirstIF = pIF;
                RmTmpReferenceObject(&pFirstIF->Hdr, pSR);
            }
        }
        UNLOCKOBJ(pAdapter, pSR);

        if (pIF != NULL)
        {
            PARPCB_LOCAL_IP pLocalIp;
            LOCKOBJ(pIF, pSR);

            if (LocalIpAddress != 0)
            {
                Status = RmLookupObjectInGroup(
                                    &pIF->LocalIpGroup,
                                    0,                      // Flags
                                    (PVOID) ULongToPtr (LocalIpAddress),    // pKey
                                    NULL,                   // pvCreateParams
                                    &(PRM_OBJECT_HEADER)pLocalIp,
                                    NULL, // pfCreated
                                    pSR
                                    );
            }
            else
            {
                PARPCB_LOCAL_IP pPrevLocalIp = NULL;

                do
                {
                    Status = RmGetNextObjectInGroup(
                                    &pIF->LocalIpGroup,
                                    &(pPrevLocalIp)->Hdr,
                                    &(PRM_OBJECT_HEADER)pLocalIp,
                                    pSR
                                    );
                    if (pPrevLocalIp != NULL)
                    {
                        RmTmpDereferenceObject(&pPrevLocalIp->Hdr, pSR);
                    }
                    pPrevLocalIp = pLocalIp;

                    //
                    // we need to keep looking until we find a UNICAST
                    // local ip address!
                    //

                } while (!FAIL(Status) && pLocalIp->IpAddressType!=LLIP_ADDR_LOCAL);
            }

            UNLOCKOBJ(pIF, pSR);

            if (FAIL(Status))
            {
                // This IF is not the one, sorry...
                //
                RmTmpDereferenceObject(&pIF->Hdr, pSR);
                pIF = NULL;
            }
            else
            {
                // Found a local IP address (either matching or first one).
                // Let's get out of here...
                //
                if (pLocalIpAddress != NULL)
                {
                    *pLocalIpAddress = pLocalIp->IpAddress;
                }
                RmTmpDereferenceObject(&pLocalIp->Hdr, pSR);
                RmTmpDereferenceObject(&pAdapter->Hdr, pSR);
                pLocalIp = NULL;
                pAdapter = NULL;
                //
                // Note: we keep the reference on pIF, which we return.
                //
                break; // break out of the enclosing while(adapters-left) loop.
            }
        }

        // Lookup next adapter.
        //
        Status = RmGetNextObjectInGroup(
                        &ArpGlobals.adapters.Group,
                        &pAdapter->Hdr,
                        &(PRM_OBJECT_HEADER)pNextAdapter,
                        pSR
                        );

        if (FAIL(Status))
        {
            //
            // we're presumably done. 
            //
            pNextAdapter = NULL;
        }


        // TmpDeref pAdapter and move on to the next one.
        //
        RmTmpDereferenceObject(&pAdapter->Hdr, pSR);
        pAdapter = pNextAdapter;

    }

    //
    // If LocalipAddress ==0 AND
    // if we couldn't find any IF with any local IP address
    // (this would be because we haven't started an IF as yet)
    // we return the first IF we find.
    //
    if (LocalIpAddress == 0 && pIF == NULL)
    {
        pIF = pFirstIF;
        pFirstIF = NULL;
    }

    if (pFirstIF != NULL)
    {
        RmTmpDereferenceObject(&pFirstIF->Hdr, pSR);
    }

    return pIF;
}

UINT
arpGetStatsDuration(
        PARP1394_INTERFACE pIF
        )
/*++
    Return duration in seconds since start of statistics gathering.
--*/
{
    LARGE_INTEGER liCurrent;

    // Get the current time (in 100-nanosecond units).
    //
    NdisGetCurrentSystemTime(&liCurrent);

    // Compute the difference since the start of stats collection.
    //
    liCurrent.QuadPart -=  pIF->stats.StatsResetTime.QuadPart;

    // Convert to seconds.
    //
    liCurrent.QuadPart /= 10000000;

    // return low part.
    //
    return liCurrent.LowPart;
}

NTSTATUS
arpIoctlSendPacket(
        PARP1394_INTERFACE              pIF,
        PARP1394_IOCTL_SEND_PACKET      pSendPacket,
        PRM_STACK_RECORD                pSR
        )
/*++
    Send the pSendPacket->PacketSize bytes of data in pSendPacket->Data as
    a single packet on the broadcast channel. The encap header is expected
    to be already in the packet.
--*/
{
    ENTER("IoctlSendPacket", 0x59746279)
    NTSTATUS            NtStatus;

    RM_ASSERT_NOLOCKS(pSR);

    TR_WARN(("SEND PACKET\n"));
    NtStatus                        = STATUS_UNSUCCESSFUL;

    do
    {
        NDIS_STATUS         Status;
        PNDIS_PACKET        pNdisPacket;
        PVOID               pPktData;
        UINT                Size = pSendPacket->PacketSize;

        //
        // Validate contents of pSendPacket.
        //
        if (Size > sizeof(pSendPacket->Data))
        {
            TR_WARN(("PacketSize value %lu is too large.\n", Size));
            break;
        }

        //
        // Allocate a control packet and copy over the contents.
        //
        Status = arpAllocateControlPacket(
                    pIF,
                    Size,
                    ARP1394_PACKET_FLAGS_IOCTL,
                    &pNdisPacket,
                    &pPktData,
                    pSR
                    );

        if (FAIL(Status))
        {
            TR_WARN(("Couldn't allocate send packet.\n"));
            break;
        }

        NdisMoveMemory(pPktData, pSendPacket->Data, Size);

        ARP_FASTREADLOCK_IF_SEND_LOCK(pIF);

        // Actually send the packet (this will silently fail and free the pkt
        // if we're not in a position to send the pkt.)
        //
        arpSendControlPkt(
                pIF,            // LOCKIN NOLOCKOUT (IF send lk)
                pNdisPacket,
                pIF->pBroadcastDest,
                pSR
                );

        NtStatus = STATUS_SUCCESS;

    } while (FALSE);

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
    return NtStatus;
}


NTSTATUS
arpIoctlRecvPacket(
        PARP1394_INTERFACE              pIF,
        PARP1394_IOCTL_RECV_PACKET      pRecvPacket,
        PRM_STACK_RECORD                pSR
        )
{
    ENTER("IoctlRecvPacket", 0x59746279)
    NTSTATUS            NtStatus;

    RM_ASSERT_NOLOCKS(pSR);

    TR_WARN(("RECV PACKET\n"));
    NtStatus                        = STATUS_UNSUCCESSFUL;

    do
    {
        NDIS_STATUS         Status;
        PNDIS_PACKET        pNdisPacket;
        PVOID               pPktData;
        UINT                Size = pRecvPacket->PacketSize;

        //
        // Validate contents of pRecvPacket.
        //
        if (Size > sizeof(pRecvPacket->Data))
        {
            TR_WARN(("PacketSize value %lu is too large.\n", Size));
            break;
        }

        //
        // Allocate a control packet and copy over the contents.
        //
        Status = arpAllocateControlPacket(
                    pIF,
                    Size,
                    ARP1394_PACKET_FLAGS_IOCTL,
                    &pNdisPacket,
                    &pPktData,
                    pSR
                    );

        if (FAIL(Status))
        {
            TR_WARN(("Couldn't allocate recv packet.\n"));
            break;
        }

        NdisMoveMemory(pPktData, pRecvPacket->Data, Size);

        //
        // Set the packet flags to STATUS_RESOURCES, so that our receive-
        // indicate handler will return synchronously.
        //
        NDIS_SET_PACKET_STATUS (pNdisPacket,  NDIS_STATUS_RESOURCES);

        //
        // Call our internal common receive packet handler.
        //
        arpProcessReceivedPacket(
                    pIF,
                    pNdisPacket,
                    TRUE                    // IsChannel
                    );

        //
        // Now we free the packet.
        //
        arpFreeControlPacket(
            pIF,
            pNdisPacket,
            pSR
            );

        NtStatus = STATUS_SUCCESS;

    } while (FALSE);

    RM_ASSERT_NOLOCKS(pSR);

    EXIT()
    return NtStatus;
}


NTSTATUS
arpIoctlGetNicInfo(
        PARP1394_INTERFACE          pIF,
        PARP1394_IOCTL_NICINFO      pIoctlNicInfo,
        PRM_STACK_RECORD            pSR
        )
{
    ENTER("IoctlGetNicInfo", 0x637c44e0)
    NTSTATUS            NtStatus = STATUS_UNSUCCESSFUL;
    ARP_NDIS_REQUEST    ArpNdisRequest;
    PARP1394_ADAPTER    pAdapter;

    pAdapter =  (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);

    do
    {
        NDIS_STATUS Status;

        if (pIoctlNicInfo->Info.Hdr.Version != NIC1394_NICINFO_VERSION)
        {
            TR_WARN(("NicInfo version mismatch. Want 0x%lx, got 0x%lx.\n",
                    NIC1394_NICINFO_VERSION, pIoctlNicInfo->Info.Hdr.Version));
            break;
        }

        //
        // Copy over all the fields.
        //

        Status =  arpPrepareAndSendNdisRequest(
                    pAdapter,
                    &ArpNdisRequest,
                    NULL,                   // pTask (NULL==BLOCK)
                    0,                      // unused
                    OID_1394_NICINFO,
                    &pIoctlNicInfo->Info,
                    sizeof(pIoctlNicInfo->Info),
                    NdisRequestQueryInformation,
                    pSR
                    );

        if (FAIL(Status))
        {
            TR_WARN(("NdisRequest failed with error 0x%08lx.\n", Status));
            break;
        }

        if (pIoctlNicInfo->Info.Hdr.Version !=  NIC1394_NICINFO_VERSION)
        {
            TR_WARN(("Unexpected NIC NicInfo version 0x%lx returned.\n",
                    pIoctlNicInfo->Info.Hdr.Version));
            break;
        }

        NtStatus = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    return NtStatus;
}





NTSTATUS
arpIoctlGetEuidNodeMacInfo(
        PARP1394_INTERFACE          pIF,
        PARP1394_IOCTL_EUID_NODE_MAC_INFO   pEuidInfo,
        PRM_STACK_RECORD            pSR
        )
{
    ENTER("IoctlGetNicInfo", 0x34db9cf4)
    NTSTATUS            NtStatus = STATUS_UNSUCCESSFUL;
    ARP_NDIS_REQUEST    ArpNdisRequest;
    PARP1394_ADAPTER    pAdapter;

    pAdapter =  (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);

    do
    {
        NDIS_STATUS Status;


        //
        // Copy over all the fields.
        //

        Status =  arpPrepareAndSendNdisRequest(
                    pAdapter,
                    &ArpNdisRequest,
                    NULL,                   // pTask (NULL==BLOCK)
                    0,                      // unused
                    OID_1394_QUERY_EUID_NODE_MAP,
                    &pEuidInfo->Map,
                    sizeof(pEuidInfo->Map),
                    NdisRequestQueryInformation,
                    pSR
                    );

        if (FAIL(Status))
        {
            TR_WARN(("NdisRequest failed with error 0x%08lx.\n", Status));
            break;
        }

        NtStatus = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\eth.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    eth.c

Abstract:

    ARP1394 Ethernet emulation-related handlers.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     11-22-99    Created
    Adube      10-2000     Added Bridging

Notes:

--*/
#include <precomp.h>

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_ETH


UINT Arp1394ToIcs = 0;

//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================


// These are ethernet arp specific  constants
//
#define ARP_ETH_ETYPE_IP    0x800
#define ARP_ETH_ETYPE_ARP   0x806
#define ARP_ETH_REQUEST     1
#define ARP_ETH_RESPONSE    2
#define ARP_ETH_HW_ENET     1
#define ARP_ETH_HW_802      6


//
// Check whether an address is multicast
//
#define ETH_IS_MULTICAST(Address) \
        (BOOLEAN)(((PUCHAR)(Address))[0] & ((UCHAR)0x01))


//
// Check whether an address is broadcast.
//
#define ETH_IS_BROADCAST(Address)               \
    ((((PUCHAR)(Address))[0] == ((UCHAR)0xff)) && (((PUCHAR)(Address))[1] == ((UCHAR)0xff)))


#pragma pack (push, 1)

//* Structure of an Ethernet header (taken from ip\arpdef.h).
typedef struct  ENetHeader {
    ENetAddr    eh_daddr;
    ENetAddr    eh_saddr;
    USHORT      eh_type;
} ENetHeader;

const ENetAddr BroadcastENetAddr = 
{
    {0xff, 0xff, 0xff, 0xff, 0xff, 0xff}
};

// Following is a template for creating Ethernet Multicast addresses
// from ip multicast addresses.
// The last 3 bytes are the last 3 bytes (network byte order) of the mcast
// address.
//
const ENetAddr MulticastENetAddr =
{
    {0x01,0x00,0x5E,0x00, 0x00, 0x00}
};

//
// This is the Ethernet address to which the bridge sends STA packets.
// STA packets are used by the bridge to detect loops
//

// Size of a basic UDP header
#define SIZE_OF_UDP_HEADER          8       // bytes

// Minimum size of the payload of a BOOTP packet
#define SIZE_OF_BASIC_BOOTP_PACKET  236     // bytes


// The UDP IP protocol type
#define UDP_PROTOCOL          0x11

// Size of Ethernet header
#define ETHERNET_HEADER_SIZE (ETH_LENGTH_OF_ADDRESS * 2 ) + 2



UCHAR gSTAMacAddr[ETH_LENGTH_OF_ADDRESS] = { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x00 };

#define NIC1394_ETHERTYPE_STA 0x777
const
NIC1394_ENCAPSULATION_HEADER
Arp1394_StaEncapHeader =
{
    0x0000,     // Reserved
    H2N_USHORT(NIC1394_ETHERTYPE_STA)
};

// Structure of an Ethernet ARP packet.
//
typedef struct {
    ENetHeader  header;
    USHORT      hardware_type; 
    USHORT      protocol_type;
    UCHAR       hw_addr_len;
    UCHAR       IP_addr_len; 
    USHORT      opcode;                  // Opcode.
    ENetAddr    sender_hw_address;
    IP_ADDRESS  sender_IP_address;
    ENetAddr    target_hw_address;
    IP_ADDRESS  target_IP_address;

} ETH_ARP_PKT, *PETH_ARP_PKT;

#pragma pack (pop)

// Parsed version of an ethernet ARP packet.
//
typedef struct {

    ENetAddr        SourceEthAddress;   // Ethernet source h/w address.
    ENetAddr        DestEthAddress;     // Ethernet source h/w address.

    UINT            OpCode; // ARP_ETH_REQUEST/RESPONSE

    ENetAddr        SenderEthAddress;   // Ethernet source h/w address.
    IP_ADDRESS      SenderIpAddress;    // IP source address

    ENetAddr        TargetEthAddress;   // Ethernet destination h/w address.
    IP_ADDRESS      TargetIpAddress;    // IP target address

} ETH_ARP_PKT_INFO, *PETH_ARP_PKT_INFO;




#define ARP_FAKE_ETH_ADDRESS(_AdapterNum)                   \
        {                                                   \
            0x02 | (((UCHAR)(_AdapterNum) & 0x3f) << 2),    \
            ((UCHAR)(_AdapterNum) & 0x3f),                  \
            0,0,0,0                                         \
        }

#define ARP_DEF_REMOTE_ETH_ADDRESS \
                ARP_FAKE_ETH_ADDRESS(0xf)


#define  ARP_IS_BOOTP_REQUEST(_pData)  (_pData[0] == 0x1)      // Byte 0 is the operation; 1 for a request, 2 for a reply
#define  ARP_IS_BOOTP_RESPONSE(_pData)  (_pData[0] == 0x2)      // Byte 0 is the operation; 1 for a request, 2 for a reply


typedef struct _ARP_BOOTP_INFO 
{
    
    ULONG Xid;
    
    BOOLEAN bIsRequest;    

    ENetAddr requestorMAC;


} ARP_BOOTP_INFO , *PARP_BOOTP_INFO; 




NDIS_STATUS
arpIcsTranslateIpPkt(
    IN  PARP1394_INTERFACE          pIF,
    IN  PNDIS_PACKET                pOrigPkt, 
    IN  ARP_ICS_FORWARD_DIRECTION   Direction,
    IN  MYBOOL                      fUnicast,
    OUT PNDIS_PACKET                *ppNewPkt,
    OUT PREMOTE_DEST_KEY            pDestAddress, // OPTIONAL
    PRM_STACK_RECORD                pSR
    );

NDIS_STATUS
arpGetEthHeaderFrom1394IpPkt(
    IN  PARP1394_INTERFACE  pIF,
    IN  PVOID               pvData,
    IN  UINT                cbData,
    IN  MYBOOL              fUnicast,
    OUT ENetHeader          *pEthHdr,
    OUT PIP_ADDRESS         pDestIpAddress, // OPTIONAL
    PRM_STACK_RECORD        pSR
    );

NDIS_STATUS
arpGet1394HeaderFromEthIpPkt(
    IN  PARP1394_INTERFACE  pIF,
    IN  PNDIS_BUFFER        pFirstBuffer,
    IN  PVOID               pvData,
    IN  UINT                cbData,
    IN  MYBOOL              fUnicast,
    OUT NIC1394_ENCAPSULATION_HEADER
                            *p1394Hdr,
    OUT PREMOTE_DEST_KEY     pDestIpAddress, // OPTIONAL
    PRM_STACK_RECORD        pSR
    );

NDIS_STATUS
arpGetEthAddrFromIpAddr(
    IN  PARP1394_INTERFACE  pIF,
    IN  MYBOOL              fUnicast,
    IN  IP_ADDRESS          DestIpAddress,
    OUT ENetAddr            *pEthAddr,
    PRM_STACK_RECORD        pSR
    );

NDIS_STATUS
arpParseEthArpPkt(
    IN   PETH_ARP_PKT     pArpPkt,
    IN   UINT                       cbBufferSize,
    OUT  PETH_ARP_PKT_INFO          pPktInfo
    );

VOID
arpPrepareEthArpPkt(
    IN   PETH_ARP_PKT_INFO          pPktInfo,
    OUT  PETH_ARP_PKT     pArpPkt
    );

MYBOOL
arpIsUnicastEthDest(
    IN   UNALIGNED  ENetHeader   *pEthHdr
    );

VOID
arpEthProcess1394ArpPkt(
    IN  PARP1394_INTERFACE         pIF,
    IN  PIP1394_ARP_PKT pArpPkt,
    IN  UINT                       HeaderSize
    );

VOID
arpEthProcessEthArpPkt(
    IN  PARP1394_INTERFACE      pIF,
    IN  PETH_ARP_PKT  pArpPkt,
    IN  UINT                    HeaderSize
    );

NDIS_STATUS
arpConstructEthArpInfoFrom1394ArpInfo(
    IN  PARP1394_INTERFACE          pIF,
    IN   PIP1394_ARP_PKT_INFO   p1394PktInfo,
    OUT  PETH_ARP_PKT_INFO          pEthPktInfo,
    PRM_STACK_RECORD                pSR
    );

NDIS_STATUS
arpConstruct1394ArpInfoFromEthArpInfo(
    IN  PARP1394_INTERFACE      pIF,
    IN   PETH_ARP_PKT_INFO      pEthPktInfo,
    OUT  PIP1394_ARP_PKT_INFO   p1394PktInfo,
    PRM_STACK_RECORD            pSR
    );

VOID
arpIcsForwardIpPacket(
    IN  PARP1394_INTERFACE  pIF,
    IN  PNDIS_PACKET        pPacket,
    IN  ARP_ICS_FORWARD_DIRECTION   Direction,
    IN  MYBOOL              fUnicast,
    IN  PRM_STACK_RECORD    pSR
    );

NDIS_STATUS
arpGetSourceMacAddressFor1394Pkt (
    IN PARP1394_ADAPTER pAdapter,
    IN UCHAR SourceNodeAddress,
    IN BOOLEAN fIsValidSourceNodeAddress,
    OUT ENetAddr* pSourceMacAddress,
    PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpEthConstructSTAEthHeader(
    IN PUCHAR pvData,
    IN UINT cbData,
    OUT ENetHeader   *pEthHdr
    );

NDIS_STATUS
arpEthModifyBootPPacket(
    IN  PARP1394_INTERFACE          pIF,                // NOLOCKIN NOLOCKOUT
    IN  ARP_ICS_FORWARD_DIRECTION   Direction,
    IN  PREMOTE_DEST_KEY             pDestAddress, // OPTIONAL
    IN  PUCHAR                       pucNewData,
    IN  ULONG                         PacketLength,
    IN  PRM_STACK_RECORD                pSR
    );

BOOLEAN
arpEthPreprocessBootPPacket(
    IN PARP1394_INTERFACE       pIF,
    IN PUCHAR                   pPacketData,
    IN PUCHAR                   pBootPData,     // Actual BOOTP packet
    OUT PBOOLEAN                pbIsRequest,
    PARP_BOOTP_INFO             pInfoBootP,
    PRM_STACK_RECORD           pSR
    );


VOID
arpIcsForwardIpPacket(
    IN  PARP1394_INTERFACE          pIF,
    IN  PNDIS_PACKET                pPacket,
    IN  ARP_ICS_FORWARD_DIRECTION   Direction,
    IN  MYBOOL                      fUnicast,
    IN  PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Forward a packet from the ip/1394 side to the ethernet side, or vice-versa.

Arguments:


--*/
{
    NDIS_STATUS         Status;
    PNDIS_PACKET        pNewPkt = NULL;
    ENTER("arpIcsForwardIpPacket", 0x98630e8f)

    do
    {
        PARPCB_DEST pDest = NULL;

        //
        // Create the translated packet.
        //
        Status =  arpIcsTranslateIpPkt(
                    pIF,
                    pPacket,
                    Direction,
                    fUnicast,
                    &pNewPkt,
                    NULL,       // Optional pIpDestAddr
                    pSR
                    );
    
        if (FAIL(Status))
        {
            if (Status == NDIS_STATUS_ALREADY_MAPPED)
            {
                //
                // This is a loop-backed packet.
                //
                arpEthReceivePacket(
                    pIF,
                    pPacket
                    );
            }
            pNewPkt = NULL;
            break;
        }

        // We special case unicast sends to 1394, because that requires
        // special treatment: we need to lookup the destination and if
        // required create a VC to that destination. This
        // is done elsewhere (in arpEthernetReceivePacket), so we assert
        // we never get this this case.
        //
        ASSERT(!(Direction == ARP_ICS_FORWARD_TO_1394 && fUnicast))
        

        ARP_FASTREADLOCK_IF_SEND_LOCK(pIF);

        //
        // Determine destination
        //
        if (Direction ==  ARP_ICS_FORWARD_TO_1394)
        {
            pDest = pIF->pBroadcastDest;
        }
        else    
        {
            ASSERT(Direction ==  ARP_ICS_FORWARD_TO_ETHERNET);
            pDest = pIF->pEthernetDest;
        };

        arpSendControlPkt(
                pIF,            // LOCKIN NOLOCKOUT (IF send lk)
                pNewPkt,
                pDest,
                pSR
                );

    } while (FALSE);

    EXIT()

}


NDIS_STATUS
arpIcsTranslateIpPkt(
    IN  PARP1394_INTERFACE          pIF,                // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET                pOrigPkt, 
    IN  ARP_ICS_FORWARD_DIRECTION   Direction,
    IN  MYBOOL                      fUnicast,
    OUT PNDIS_PACKET                *ppNewPkt,
    OUT PREMOTE_DEST_KEY             pDestAddress, // OPTIONAL
    PRM_STACK_RECORD                pSR
    )
{

    NDIS_STATUS     Status;
    PNDIS_PACKET    pNewPkt     = NULL;
    PVOID           pvNewData   = NULL;


    do
    {
        PNDIS_BUFFER    pOrigBuf    = NULL;
        PVOID           pvOrigData  = NULL;
        UINT            OrigBufSize;
        PVOID           pvNewHdr    = NULL;
        UINT            OrigHdrSize;
        UINT            NewHdrSize;
        UINT            OrigPktSize;
        UINT            NewPktSize;
        UINT            BytesCopied;
        NIC1394_ENCAPSULATION_HEADER
                        Nic1394Hdr;
        ENetHeader      EthHdr;


        // Get size of 1st buffer and pointer to it's data.
        // (We only bother about the 1st buffer)
        //
        NdisQueryPacket(
                        pOrigPkt,
                        NULL,
                        NULL,
                        &pOrigBuf,
                        &OrigPktSize
                        );
    
    
        if (OrigPktSize > 0)
        {
            NdisQueryBuffer(
                    pOrigBuf,
                    &pvOrigData,
                    &OrigBufSize
                    );
        }
        else
        {
            OrigBufSize = 0;
        }

        if (pvOrigData == NULL)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        // Compute direction-specific information
        //
        if(Direction == ARP_ICS_FORWARD_TO_1394)
        {
            OrigHdrSize = sizeof(EthHdr);
            NewHdrSize  = sizeof(Nic1394Hdr);

            Status = arpGet1394HeaderFromEthIpPkt(
                        pIF,
                        pOrigBuf,
                        pvOrigData,
                        OrigBufSize,
                        fUnicast,
                        &Nic1394Hdr,
                        pDestAddress,
                        pSR
                        );
            pvNewHdr    = (PVOID) &Nic1394Hdr;
        }
        else
        {
            ASSERT(Direction==ARP_ICS_FORWARD_TO_ETHERNET);
            OrigHdrSize = sizeof(Nic1394Hdr);
            NewHdrSize = sizeof(EthHdr);

            Status = arpGetEthHeaderFrom1394IpPkt(
                        pIF,
                        pvOrigData,
                        OrigBufSize,
                        fUnicast,
                        &EthHdr,
                        &pDestAddress->IpAddress,
                        pSR
                        );

            pvNewHdr    = (PVOID) &EthHdr;

        };

        if (FAIL(Status)) break;
    


        // Make sure the 1st buffer contains enough data for the header.
        //
        if (OrigBufSize < OrigHdrSize)
        {
            ASSERT(FALSE);                  // We should check why we're getting
                                            // this kind of tiny 1st buffer.
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        // Compute the new packet size.
        //
        NewPktSize = OrigPktSize - OrigHdrSize + NewHdrSize;

        // Allocate an appropriately sized control packet.
        //
        Status = arpAllocateControlPacket(
                    pIF,
                    NewPktSize,
                    ARP1394_PACKET_FLAGS_ICS,
                    &pNewPkt,
                    &pvNewData,
                    pSR
                    );

        if (FAIL(Status))
        {
            ASSERT(FALSE); // we want to know if we hit this in regular use.
            pNewPkt = NULL;
            break;
        }

        // Copy over the new header.
        //
        NdisMoveMemory(pvNewData, pvNewHdr, NewHdrSize);

        // Copy the rest of the packet contents.
        //
        NdisCopyFromPacketToPacket(
            pNewPkt,                    // Dest pkt
            NewHdrSize,                 // Dest offset
            OrigPktSize - OrigHdrSize,  // BytesToCopy
            pOrigPkt,                   // Source,
            OrigHdrSize,                // SourceOffset
            &BytesCopied
            );
        if (BytesCopied != (OrigPktSize - OrigHdrSize))
        {
            ASSERT(FALSE);                  // Should never get here.
            Status = NDIS_STATUS_FAILURE;
            break;
        }


        // Add the Bootp code here.
        Status = arpEthModifyBootPPacket(pIF,
                                        Direction,
                                        pDestAddress, 
                                        (PUCHAR)pvNewData,
                                        NewPktSize ,
                                        pSR);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            ASSERT (!"TempAssert -arpEthModifyBootPPacket FAILED"); 
            break;
        }

    } while (FALSE);

    if (FAIL(Status) && pNewPkt != NULL)
    {
        arpFreeControlPacket(
            pIF,
            pNewPkt,
            pSR
            );

       *ppNewPkt = NULL;
    }
    else
    {
       *ppNewPkt = pNewPkt;
    }

    return Status;
}

NDIS_STATUS
arpGetEthHeaderFrom1394IpPkt(
    IN  PARP1394_INTERFACE  pIF,
    IN  PVOID               pvData,
    IN  UINT                cbData,
    IN  MYBOOL              fUnicast,
    OUT ENetHeader          *pEthHdr,
    OUT PIP_ADDRESS         pDestIpAddress, // OPTIONAL
    PRM_STACK_RECORD        pSR
    )
/*++
    Return a fully filled ethernet header, with source and estination
    MAC addresses and ethertype set to IP.

    The source address is always the local adapter's MAC address.

    The destination address is set by calling arpGetEthAddrFromIpAddr


--*/
{
    ENTER("arpGetEthHeaderFrom1394IpPkt", 0x0)
    static
    ENetHeader
    StaticEthernetHeader =
    {
        {0xff, 0xff, 0xff, 0xff, 0xff, 0xff},               // eh_daddr == BCAST
        ARP_DEF_REMOTE_ETH_ADDRESS,
        H2N_USHORT(NIC1394_ETHERTYPE_IP)                    // eh_type
    };
    
    ARP1394_ADAPTER *       pAdapter;
    BOOLEAN                 fBridgeMode;
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;

    PNDIS1394_UNFRAGMENTED_HEADER pHeader = (PNDIS1394_UNFRAGMENTED_HEADER)pvData;

    pAdapter    = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
    fBridgeMode = ARP_BRIDGE_ENABLED(pAdapter);

    do
    {
        UNALIGNED IPHeader *pIpHdr;
        IP_ADDRESS  IpDest;

        if (cbData < (sizeof(NIC1394_ENCAPSULATION_HEADER) + sizeof(IPHeader)))
        {
            //
            // Packet is too small.
            //
            TR_INFO(("Discarding packet because pkt too small\n"));
            break;
        }
        pIpHdr = (UNALIGNED IPHeader*)
                     (((PUCHAR) pvData)+sizeof(NIC1394_ENCAPSULATION_HEADER));
        IpDest = pIpHdr->iph_dest;

        if (pDestIpAddress != NULL)
        {
            *pDestIpAddress = IpDest;
        }


        if (!fBridgeMode)
        {
            //
            // TODO: we currently return a hardcoded ethernet address.
            // Need to constuct one by looking into the actual IP packet data.
            //
            *pEthHdr = StaticEthernetHeader;
        
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // Following is specific to BRIDGE mode
        //


        // Always set the source address according to the sender.
        //
        {
            ENetAddr SourceMacAddress;
            
            Status = \
                arpGetSourceMacAddressFor1394Pkt (pAdapter,
                                                    pHeader->u1.SourceAddress,
                                                    pHeader->u1.fHeaderHasSourceAddress,
                                                    &SourceMacAddress,
                                                    pSR);

            if (FAIL(Status))
            {
                break;
            }

            pEthHdr->eh_saddr = SourceMacAddress ; 

        }

        //
        // If we have a STA packet then construct the STA Header
        // or else construct the sender/destination specific Ethernet
        // Header
        //
        {

            if (pHeader->u1.EtherType  == N2H_USHORT(NIC1394_ETHERTYPE_STA)  )
            {
                arpEthConstructSTAEthHeader(pvData,cbData, pEthHdr);
            }
            else
            {

                pEthHdr->eh_type = H2N_USHORT(ARP_ETH_ETYPE_IP);
                Status =  arpGetEthAddrFromIpAddr(
                                pIF,
                                fUnicast,
                                IpDest,
                                &pEthHdr->eh_daddr,
                                pSR
                                );
            }
        }
    } while (FALSE);

    return Status;
}



NDIS_STATUS
arpGet1394HeaderFromEthIpPkt(
    IN  PARP1394_INTERFACE  pIF,
    IN  PNDIS_BUFFER        pFirstBuffer,
    IN  PVOID               pvData,
    IN  UINT                cbData,
    IN  MYBOOL              fUnicast,
    OUT NIC1394_ENCAPSULATION_HEADER
                            *p1394Hdr,
    OUT PREMOTE_DEST_KEY    pDestAddress, // OPTIONAL
    PRM_STACK_RECORD        pSR
    )
{
    MYBOOL  fLoopBack = FALSE;
    ENetHeader *pEthHdr =  (ENetHeader *) pvData;
    ARP1394_ADAPTER *       pAdapter;
    BOOLEAN                 fBridgeMode;

    if (cbData < (sizeof(ENetHeader) ) )
    {
        //
        // Packet is too small.
        //
        return NDIS_STATUS_FAILURE;  // ***** EARLY RETURN ****
    }

    pAdapter    = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
    fBridgeMode = ARP_BRIDGE_ENABLED(pAdapter);


    if (NdisEqualMemory(&pEthHdr->eh_daddr, 
                        &pAdapter->info.EthernetMacAddress,
                        sizeof(ENetAddr)))
    {
        if (!fBridgeMode)
        {
            // We're not in bridge mode -- so this must be only on MILL
            // This is addressed to our local mac address.
            // We fail with special failure status
            // NDIS_STATUS_ALREADY_MAPPED, indicating "loopback".
            //

            fLoopBack = TRUE;
        }
    }
    else
    {
        //
        // Do nothing ... because we can get unicasts to our fictitious gateway
        //
    }

    if (fLoopBack)
    {
        return NDIS_STATUS_ALREADY_MAPPED;
    }
    else
    {

        BOOLEAN fIsSTAPacket ;
        //
        // We have an STA packet, if the destination is our special 
        // Multicast Destination
        //
        fIsSTAPacket = (TRUE == NdisEqualMemory (&pEthHdr->eh_daddr, 
                                                &gSTAMacAddr, 
                                                ETH_LENGTH_OF_ADDRESS) );

        if (fIsSTAPacket  == TRUE)
        {
            *p1394Hdr = Arp1394_StaEncapHeader;
        }
        else
        {
            *p1394Hdr = Arp1394_IpEncapHeader;
        }

        if (pDestAddress != NULL)
        {
            //
            // Extract the Enet Address to use it as part of the lookup
            //
            UNALIGNED ENetAddr *pENetDest;
            pENetDest = (UNALIGNED ENetAddr *)(pvData);
            pDestAddress->ENetAddress = *pENetDest;
            
        }

        return NDIS_STATUS_SUCCESS;
    }
}


VOID
arpEthReceivePacket(
    IN  ARP1394_INTERFACE   *   pIF,
    PNDIS_PACKET            pNdisPacket
    )
/*
    This is the connectionLESS ethernet receive packet handler.
    Following code adapted from the co receive packet handler.
*/
{
    ENTER("arpEthReceivePacket", 0xc8afbabb)
    UINT                    TotalLength;    // Total bytes in packet
    PNDIS_BUFFER            pNdisBuffer;    // Pointer to first buffer
    UINT                    BufferLength;
    UINT                    ReturnCount;
    PVOID                   pvPktHeader;
    ENetHeader          *   pEthHeader;
    const UINT              MacHeaderLength = sizeof(ENetHeader);
    ARP1394_ADAPTER *       pAdapter;
    BOOLEAN                 fBridgeMode;

    pAdapter    = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
    fBridgeMode = ARP_BRIDGE_ENABLED(pAdapter);

    DBGMARK(0x2425d318);

    ReturnCount = 0;

    //
    // Discard the packet if the IP interface is not activated
    //
    do
    {
        //
        // Discard packet if adapter is in bridge mode.
        //
        if (fBridgeMode)
        {
            break;
        }


        //
        // Discard the packet if the adapter is not active
        //
        if (!CHECK_IF_ACTIVE_STATE(pIF,  ARPAD_AS_ACTIVATED))
        {
            TR_INFO(("Eth:Discardning received Eth pkt because pIF 0x%p is not activated.\n", pIF));
    
            break;
        }

        NdisQueryPacket(
                        pNdisPacket,
                        NULL,
                        NULL,
                        &pNdisBuffer,
                        &TotalLength
                        );
    
        if (TotalLength > 0)
        {
            NdisQueryBuffer(
                    pNdisBuffer,
                    (PVOID *)&pvPktHeader,
                    &BufferLength
                    );
        }
        else
        {
            break;
        }
    
        pEthHeader  =  (ENetHeader*) pvPktHeader;
    
        TR_INFO(
    ("EthRcv: NDISpkt 0x%x, NDISbuf 0x%x, Buflen %d, Totlen %d, Pkthdr 0x%x\n",
                    pNdisPacket,
                    pNdisBuffer,
                    BufferLength,
                    TotalLength,
                    pvPktHeader));
    
        if (BufferLength < MacHeaderLength || pEthHeader   == NULL)
        {
            // Packet is too small, discard.
            //
            break;
        }
    
        //
        // At this point, pEthHeader contains the Ethernet header.
        // We look at the ethertype to decide what to do with it.
        //
        if (pEthHeader->eh_type ==  N2H_USHORT(ARP_ETH_ETYPE_IP))
        {
            //
            //  The EtherType is IP, so we pass up this packet to the IP layer.
            // (Also we indicate all packets we receive on the broadcast channel
            // to the ethernet VC).
            //
    
            TR_INFO(
                ("Rcv: pPkt 0x%x: EtherType is IP, passing up.\n", pNdisPacket));
    
            ARP_IF_STAT_INCR(pIF, InNonUnicastPkts);
    
            LOGSTATS_CopyRecvs(pIF, pNdisPacket);
            #if MILLEN
                ASSERT_PASSIVE();
            #endif // MILLEN
            pIF->ip.RcvHandler(
                pIF->ip.Context,
                (PVOID)((PUCHAR)pEthHeader+sizeof(*pEthHeader)),
                BufferLength - MacHeaderLength,
                TotalLength - MacHeaderLength,
                (NDIS_HANDLE)pNdisPacket,
                MacHeaderLength,
                FALSE,              // FALSE == NOT received via broadcast.
                                    // Important, because we are reflecting directed
                                    // packets up to IP. If we report TRUE here,
                                    // IP assumes it's not a directed packet, and
                                    // handles it differently.
                NULL
                );
        }
        else
        {
            //
            //  Discard packet -- unknown/bad EtherType
            //
            TR_INFO(("Encap hdr 0x%x, bad EtherType 0x%x\n",
                     pEthHeader, pEthHeader->eh_type));
            ARP_IF_STAT_INCR(pIF, UnknownProtos);
        }

    } while (FALSE);

    EXIT()
    return;
}


VOID
arpEthProcess1394ArpPkt(
    IN  PARP1394_INTERFACE         pIF,
    IN  PIP1394_ARP_PKT pArpPkt,
    IN  UINT                       HeaderSize
    )
/*++

    Process an ip/1394 ARP packet. We do the following:
    0. Parse the paket
    1. Update our local RemoteIP cache.
    2. Create and send an equivalent ethernet arp pkt on the ethernet VC.
       (We look up the destination ethernet address in our ethernet cache)

    This function must only be called when the adapter is in "Bridged mode."

--*/
{
    IP1394_ARP_PKT_INFO     Ip1394PktInfo;
    ETH_ARP_PKT_INFO        EthArpInfo;
    NDIS_STATUS                 Status = NDIS_STATUS_FAILURE;
    ARP_DEST_PARAMS             DestParams;
    PARP1394_ADAPTER            pAdapter =(PARP1394_ADAPTER ) RM_PARENT_OBJECT(pIF);
    ENetAddr                    SenderEnetAddress;
    IPAddr                      SenderIpAddress = 0;
    REMOTE_DEST_KEY             RemoteDestKey;
    
    ENTER("arpEthProcess1394ArpPkt", 0x0)
    RM_DECLARE_STACK_RECORD(Sr)

    ARP_ZEROSTRUCT(&DestParams);

    do {

        PNDIS_PACKET    pPkt        = NULL;
        PVOID           pvData  = NULL;

        Status =  arpParseArpPkt(
                        pArpPkt,
                        HeaderSize,
                        &Ip1394PktInfo
                        );
    
        if (FAIL(Status))
        {
            TR_WARN(("Failed parse of received 1394 ARP PKT.\n"));
            break;
        }

        DestParams.HwAddr.AddressType   = NIC1394AddressType_FIFO;
        DestParams.HwAddr.FifoAddress   = Ip1394PktInfo.SenderHwAddr; // Struct copy

        REMOTE_DEST_KEY_INIT(&RemoteDestKey);


        if ((ARP_BRIDGE_ENABLED(pAdapter) == TRUE) &&
            (Ip1394PktInfo.fPktHasNodeAddress == FALSE))
        {
            // We do not have the sender's Node ID -- fail.
            TR_WARN (("Did not Receive Sender's Node ID in Pkt"))
            Status = NDIS_STATUS_FAILURE;
            break;
        }
        
        if (ARP_BRIDGE_ENABLED(pAdapter) == TRUE)
        {
            // Extract the Source Mac address using the Sender Node Address

            Status = arpGetSourceMacAddressFor1394Pkt(pAdapter, 
                                            Ip1394PktInfo.SourceNodeAdddress,
                                            TRUE,
                                            &Ip1394PktInfo.SourceMacAddress,
                                            &Sr);                                

            RemoteDestKey.ENetAddress =  Ip1394PktInfo.SourceMacAddress; 
            
        }
        else
        {
            RemoteDestKey.IpAddress  = Ip1394PktInfo.SenderIpAddress;       
            Status = NDIS_STATUS_SUCCESS;
        }

        if (Status != NDIS_STATUS_SUCCESS)
        {
            TR_WARN (("Unable to get valid Source  MAC Address from Pkt"))
            Status = NDIS_STATUS_SUCCESS; 
            
            break;
        }
    
        // Update our 1394 ARP cache.
        //
        arpUpdateArpCache(
                pIF,
                RemoteDestKey.IpAddress  , // Remote IP Address
                &RemoteDestKey.ENetAddress, 
                &DestParams,    // Remote Destination HW Address
                TRUE,           // Update even if we don't already have an entry
                &Sr
                );

        Status = arpConstructEthArpInfoFrom1394ArpInfo(
                        pIF,
                        &Ip1394PktInfo,
                        &EthArpInfo,
                        &Sr
                        );

        if (FAIL(Status)) break;

        // Allocate an appropriately sized control packet.
        //
        Status = arpAllocateControlPacket(
                    pIF,
                    sizeof(ETH_ARP_PKT),
                    ARP1394_PACKET_FLAGS_ICS,
                    &pPkt,
                    &pvData,
                    &Sr
                    );

        if (FAIL(Status))
        {
            ASSERT(FALSE); // we want to know if we hit this in regular use.
            pPkt = NULL;
            break;
        }

        NdisInterlockedIncrement (&Arp1394ToIcs);

        // Fill it out..
        //
        arpPrepareEthArpPkt(
                &EthArpInfo,
                (PETH_ARP_PKT) pvData
                );
    
        // Send the packet over the ethernet VC...
        //
        ARP_FASTREADLOCK_IF_SEND_LOCK(pIF);

        arpSendControlPkt(
                pIF,            // LOCKIN NOLOCKOUT (IF send lk)
                pPkt,
                pIF->pEthernetDest,
                &Sr
                );

    } while (FALSE);

    RM_ASSERT_CLEAR(&Sr);
}


VOID
arpEthProcessEthArpPkt(
    IN  PARP1394_INTERFACE      pIF,
    IN  PETH_ARP_PKT  pArpPkt,
    IN  UINT                    HeaderSize
    )
/*++

    Process an Ethernet ARP packet. We do the following:
    0. Parse the packet
    1. Update our local ethernet arp cache.
    2. Create and send an equivalent 1394  arp pkt on the broadcast VC.
       (We look up the destination ethernet address in our ethernet cache)

    This function must only be called when the adapter is in "Bridged mode."

--*/
{

    ETH_ARP_PKT_INFO    EthPktInfo;
    IP1394_ARP_PKT_INFO     Ip1394ArpInfo;
    NDIS_STATUS                 Status;
    ARP_REMOTE_ETH_PARAMS   CreateParams;
    ENTER("arpEthProcessEthArpPkt", 0x0)
    RM_DECLARE_STACK_RECORD(Sr)

    ARP_ZEROSTRUCT(&CreateParams);

    do {

        PNDIS_PACKET    pPkt        = NULL;
        PVOID           pvData  = NULL;

        Status =  arpParseEthArpPkt(
                        pArpPkt,
                        HeaderSize,
                        &EthPktInfo
                        );
    
        if (FAIL(Status))
        {
            TR_WARN(("Failed parse of received Ethernet ARP PKT.\n"));
            break;
        }

        Status = arpConstruct1394ArpInfoFromEthArpInfo(
                        pIF,
                        &EthPktInfo,
                        &Ip1394ArpInfo,
                        &Sr
                        );

        if (FAIL(Status)) break;

        // Allocate an appropriately sized control packet.
        //
        Status = arpAllocateControlPacket(
                    pIF,
                    sizeof(IP1394_ARP_PKT),
                    ARP1394_PACKET_FLAGS_ICS,
                    &pPkt,
                    &pvData,
                    &Sr
                    );

        if (FAIL(Status))
        {
            ASSERT(FALSE); // we want to know if we hit this in regular use.
            pPkt = NULL;
            break;
        }

        // Fill it out..
        //
        arpPrepareArpPkt(
                &Ip1394ArpInfo,
                (PIP1394_ARP_PKT) pvData
                );
    
        // Send the packet over the ethernet VC...
        //
        ARP_FASTREADLOCK_IF_SEND_LOCK(pIF);

        arpSendControlPkt(
                pIF,            // LOCKIN NOLOCKOUT (IF send lk)
                pPkt,
                pIF->pBroadcastDest,
                &Sr
                );

    } while (FALSE);

    RM_ASSERT_CLEAR(&Sr);
}



NDIS_STATUS
arpParseEthArpPkt(
    IN   PETH_ARP_PKT     pArpPkt,
    IN   UINT                       cbBufferSize,
    OUT  PETH_ARP_PKT_INFO          pPktInfo
    )
/*++
Routine Description:

    Parse the contents of IP/Ethernet ARP packet data starting at
    pArpPkt. Place the results into pPktInfo.

Arguments:

    pArpPkt - Contains the unaligned contents of an ip/eth ARP Pkt.
    pPktInfo    - Unitialized structure to be filled with the parsed contents of the
                  pkt.

Return Value:

    NDIS_STATUS_FAILURE if the parse failed (typically because of invalid pkt
                        contents.)
    NDIS_STATUS_SUCCESS on successful parsing.
    
--*/
{
    ENTER("arpParseEthArpPkt", 0x359e9bf2)
    NDIS_STATUS                 Status;
    DBGSTMT(CHAR *szError   = "General failure";)

    Status  = NDIS_STATUS_FAILURE;

    do
    {
        UINT OpCode;

        // Verify length.
        //
        if (cbBufferSize < sizeof(*pArpPkt))
        {
            DBGSTMT(szError = "pkt size too small";)
            break;
        }

        // Verify constant fields.
        //

        if (N2H_USHORT(pArpPkt->header.eh_type) != ARP_ETH_ETYPE_ARP)
        {
            DBGSTMT(szError = "header.eh_type!=ARP";)
            break;
        }

    #if 0
        ARP_ETH_HW_ENET OR ARP_ETH_HW_802 
        if (N2H_USHORT(pArpPkt->hardware_type) != IP1394_HARDWARE_TYPE)
        {
            DBGSTMT(szError = "Invalid hardware_type";)
            break;
        }
    #endif // 0

        // ARP_ETH_ETYPE_IP  ARP_ETH_ETYPE_ARP
        if (N2H_USHORT(pArpPkt->protocol_type) != ARP_ETH_ETYPE_IP)
        {
            DBGSTMT(szError = "Invalid protocol_type";)
            break;
        }

        if (pArpPkt->hw_addr_len != ARP_802_ADDR_LENGTH)
        {
            DBGSTMT(szError = "Invalid hw_addr_len";)
            break;
        }


        if (pArpPkt->IP_addr_len != sizeof(ULONG))
        {
            DBGSTMT(szError = "Invalid IP_addr_len";)
            break;
        }


        // Opcode
        //
        {
            OpCode = N2H_USHORT(pArpPkt->opcode);
    
            if (    OpCode != ARP_ETH_REQUEST
                &&  OpCode != ARP_ETH_RESPONSE)
            {
                DBGSTMT(szError = "Invalid opcode";)
                break;
            }
        }

        //
        // Pkt appears valid, let's fill out the parsed information....
        //
    
        ARP_ZEROSTRUCT(pPktInfo);

        pPktInfo->SourceEthAddress  = pArpPkt->header.eh_saddr; // struct copy.
        pPktInfo->DestEthAddress    = pArpPkt->header.eh_daddr; // struct copy.
        pPktInfo->OpCode            =  (USHORT) OpCode;

        // These remain network byte order...
        //
        pPktInfo->SenderIpAddress       = (IP_ADDRESS) pArpPkt->sender_IP_address;
        pPktInfo->TargetIpAddress       = (IP_ADDRESS) pArpPkt->target_IP_address;

        pPktInfo->SenderEthAddress      = pArpPkt->sender_hw_address; // struct copy
        pPktInfo->TargetEthAddress      = pArpPkt->target_hw_address; // struct copy

        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    if (FAIL(Status))
    {
        TR_INFO(("Bad arp pkt data at 0x%p (%s)\n",  pArpPkt, szError));
    }
    else
    {
        PUCHAR pSip = (PUCHAR)&pPktInfo->SenderIpAddress;
        PUCHAR pTip = (PUCHAR)&pPktInfo->TargetIpAddress;
        TR_VERB(("Received ETH ARP PKT. OP=%lu SIP=%d.%d.%d.%d TIP=%d.%d.%d.%d.\n",
                pPktInfo->OpCode,
                pSip[0],pSip[1],pSip[2],pSip[3],
                pTip[0],pTip[1],pTip[2],pTip[3]
                ));

    }

    EXIT()

    return Status;
}


VOID
arpPrepareEthArpPkt(
    IN   PETH_ARP_PKT_INFO          pPktInfo,
    OUT  PETH_ARP_PKT     pArpPkt
    )
/*++

Routine Description:

    Use information in pArpPktInfo to prepare an ethernet arp packet starting at
    pvArpPkt.

Arguments:

    pPktInfo        -   Parsed version of the eth arp request/response packet.
    pArpPkt         -   unitialized memory in which to store the packet contents.
                        This memory must have a min size of sizeof(*pArpPkt).
--*/
{
    // UINT SenderMaxRec;
    UINT OpCode;

    ARP_ZEROSTRUCT(pArpPkt);

    pArpPkt->header.eh_type         = H2N_USHORT(ARP_ETH_ETYPE_ARP);
    pArpPkt->header.eh_daddr        = pPktInfo->DestEthAddress;
    pArpPkt->header.eh_saddr        = pPktInfo->SourceEthAddress;
    pArpPkt->hardware_type          = H2N_USHORT(ARP_ETH_HW_ENET); // TODO 
                                            // we always set the type
                                            // to ARP_ETH_HW_ENET -- not sure
                                            // if this a valid assumption or
                                            // if we need to query the NIC.
    pArpPkt->protocol_type          = H2N_USHORT(ARP_ETH_ETYPE_IP);
    pArpPkt->hw_addr_len            = (UCHAR)  ARP_802_ADDR_LENGTH;
    pArpPkt->IP_addr_len            = (UCHAR) sizeof(ULONG);
    pArpPkt->opcode                 = H2N_USHORT(pPktInfo->OpCode);


    // These are already in network byte order...
    //
    pArpPkt->sender_IP_address      =   (ULONG) pPktInfo->SenderIpAddress;
    pArpPkt->target_IP_address      =   (ULONG) pPktInfo->TargetIpAddress;
    pArpPkt->sender_hw_address      =  pPktInfo->SenderEthAddress; // struct copy
    pArpPkt->target_hw_address      =  pPktInfo->TargetEthAddress; // struct copy
}


UINT
arpEthernetReceivePacket(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PNDIS_PACKET                pNdisPacket
)
/*++

    NDIS Co receive packet for the ethernet VC.

    We do the following:

    If it's an ARP packet, we translate it and send it on the bcast channel.
    Else if it was a ethernet unicast packet, we change the header 
        and treat it like an IP unicast packet -- SlowIpTransmit
    Else we change the header and then send it on the bcast desination.

--*/
{
    PARP_VC_HEADER          pVcHdr;
    PARPCB_DEST             pDest;
    PARP1394_INTERFACE      pIF;
    ARP1394_ADAPTER *       pAdapter;
    ENetHeader             *pEthHdr;

    UINT                    TotalLength;    // Total bytes in packet
    PNDIS_BUFFER            pNdisBuffer;    // Pointer to first buffer
    UINT                    BufferLength;
    PVOID                   pvPktHeader;
    const UINT              MacHeaderLength = sizeof(ENetHeader);
    MYBOOL                  fBridgeMode;
    MYBOOL                  fUnicast;
    MYBOOL                  fIsSTAPacket;
    ENTER("arpEthernetReceivePacket", 0x0)
    RM_DECLARE_STACK_RECORD(sr)

    DBGMARK(0x72435b28);

#if TESTPROGRAM
    {
        extern ARP1394_INTERFACE  * g_pIF;
        pIF =  g_pIF;
    }
#else // !TESTPROGRAM
    pVcHdr  = (PARP_VC_HEADER) ProtocolVcContext;
    pDest   =  CONTAINING_RECORD( pVcHdr, ARPCB_DEST, VcHdr);
    ASSERT_VALID_DEST(pDest);
    pIF     = (ARP1394_INTERFACE*)  RM_PARENT_OBJECT(pDest);
#endif // TESTPROGRAM

    ASSERT_VALID_INTERFACE(pIF);
    pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
    fBridgeMode = ARP_BRIDGE_ENABLED(pAdapter);

    do
    {

        if (!fBridgeMode) // This is really only for MILL
        {
        #if MILLEN
            arpIcsForwardIpPacket(
                pIF,
                pNdisPacket, 
                ARP_ICS_FORWARD_TO_1394,
                FALSE,  // FALSE == NonUnicast
                &sr
                );
        #endif // MILLEN
            break;
        }

        NdisQueryPacket(
                        pNdisPacket,
                        NULL,
                        NULL,
                        &pNdisBuffer,
                        &TotalLength
                        );
    
    
        if (TotalLength > 0)
        {
            NdisQueryBuffer(
                    pNdisBuffer,
                    (PVOID *)&pvPktHeader,
                    &BufferLength
                    );
        }
        else
        {
            break;
        }

        TR_VERB(
    ("Eth Rcv: NDISpkt 0x%x, NDISbuf 0x%x, Buflen %d, Totlen %d, Pkthdr 0x%x\n",
                    pNdisPacket,
                    pNdisBuffer,
                    BufferLength,
                    TotalLength,
                    pvPktHeader));

        if (BufferLength < MacHeaderLength)
        {
            // Packet is too small, discard.
            //
            break;
        }

        if (pvPktHeader == NULL)
        {   
            break;
        }

        pEthHdr  = (ENetHeader*)  pvPktHeader;

        
        fUnicast = arpIsUnicastEthDest(pEthHdr);

        switch(N2H_USHORT(pEthHdr->eh_type))
        {

        case ARP_ETH_ETYPE_ARP:
            {
                PETH_ARP_PKT pArpPkt =  (PETH_ARP_PKT) pEthHdr;
                if (BufferLength < sizeof(*pArpPkt))
                {
                    // discard packet.
                    break;
                }
                arpEthProcessEthArpPkt(pIF, pArpPkt, BufferLength);
            }
            break;

        case ARP_ETH_ETYPE_IP:
            {
                //
                // The EtherType is IP, so we translate the header and
                // send if of on the appropriate 1394 FIFO vc.
                //

                if (fUnicast)
                {
                    PNDIS_PACKET    pNewPkt     = NULL;
                    IP_ADDRESS  IpDest;
                    NDIS_STATUS Status;
                    REMOTE_DEST_KEY Dest;

                    // is this meant for the 1394 net.
                    REMOTE_DEST_KEY_INIT(&Dest);
                    //
                    // Create the translated packet.
                    //
                    Status =  arpIcsTranslateIpPkt(
                                pIF,
                                pNdisPacket,
                                ARP_ICS_FORWARD_TO_1394,
                                TRUE,   // TRUE == fUnicast.
                                &pNewPkt,
                                &Dest,
                                &sr
                                );
                
                    if (FAIL(Status))
                    {
                        break;
                    }

                    Status =  arpSlowIpTransmit(
                                    pIF,
                                    pNewPkt,
                                    Dest,
                                    NULL    // RCE
                                    );
                    if (!PEND(Status))
                    {
                        // We need to deallocate the packet ourselves
                        //
                        arpFreeControlPacket(
                            pIF,
                            pNewPkt,
                            &sr
                            );
                    }
                }
                else
                {
                    // This is a broadcast or multicast IP packet -- swith
                    // the link-layer header and send it over the 1394
                    // broadcast channel.
                    //
                    arpIcsForwardIpPacket(
                        pIF,
                        pNdisPacket,
                        ARP_ICS_FORWARD_TO_1394,
                        FALSE,  // FALSE == NonUnicast
                        &sr
                        );
                }
            }
            break;
            
        default:

            //
            // Last option is that it could be a Bridge STA packet.
            // However the bridge does not use an Ethertype, so we 
            // have to check the destination mac address
            //
            fIsSTAPacket = (TRUE == NdisEqualMemory (&pEthHdr->eh_daddr, 
                                                    &gSTAMacAddr, 
                                                    ETH_LENGTH_OF_ADDRESS) );

            if (fIsSTAPacket == TRUE)
            {
                //
                // switch the link-layer header and send it over the 1394
                // broadcast channel.
                //
                arpIcsForwardIpPacket(
                    pIF,
                    pNdisPacket,
                    ARP_ICS_FORWARD_TO_1394,
                    FALSE,  // FALSE == NonUnicast
                    &sr );

            }
            break;
        }


    } while (FALSE);

    RM_ASSERT_CLEAR(&sr);

    return 0;
}


VOID
arpEthReceive1394Packet(
    IN  PARP1394_INTERFACE      pIF,
    IN  PNDIS_PACKET            pNdisPacket,
    IN  PVOID                   pvHeader,
    IN  UINT                    HeaderSize,
    IN  MYBOOL                  IsChannel
    )
/*++
    Handle an incoming packet from the 1394 side when in bridged mode.

    pEncapHeader -- the 1st buffer in the packet.
--*/
{
    PNIC1394_ENCAPSULATION_HEADER pEncapHeader;
    ENTER("arpEthReceived1394Packet", 0xe317990b)
    RM_DECLARE_STACK_RECORD(sr)

    pEncapHeader =  (PNIC1394_ENCAPSULATION_HEADER) pvHeader;

    do
    {
        //
        // Discard the packet if the adapter is not active
        //
        if (!CHECK_IF_ACTIVE_STATE(pIF,  ARPAD_AS_ACTIVATED))
        {
            TR_INFO(("Eth:Discardning received 1394 pkt because pIF 0x%p is not activated.\n", pIF));
    
            break;
        }
    
        if (pEncapHeader->EtherType ==  H2N_USHORT(NIC1394_ETHERTYPE_IP))
        {
            LOGSTATS_CopyRecvs(pIF, pNdisPacket);

            //
            // The EtherType is IP, so we translate the header and
            // send it off on the ethernet vc.
            //
            arpIcsForwardIpPacket(
                    pIF,
                    pNdisPacket,
                    ARP_ICS_FORWARD_TO_ETHERNET,
                    !IsChannel,
                    &sr
                    );
        }
        else if (pEncapHeader->EtherType ==  H2N_USHORT(NIC1394_ETHERTYPE_ARP))
        {
            PIP1394_ARP_PKT pArpPkt =  (PIP1394_ARP_PKT) pEncapHeader;
            if (HeaderSize < sizeof(*pArpPkt))
            {
                // discard packet.
                break;
            }
            arpEthProcess1394ArpPkt(pIF, pArpPkt, HeaderSize);
        }
        else if (pEncapHeader->EtherType ==  H2N_USHORT(NIC1394_ETHERTYPE_MCAP))
        {
            PIP1394_MCAP_PKT pMcapPkt =  (PIP1394_MCAP_PKT) pEncapHeader;
            arpProcessMcapPkt(
                pIF,
                pMcapPkt, 
                HeaderSize
                );
        }
        else if (pEncapHeader->EtherType == H2N_USHORT(NIC1394_ETHERTYPE_STA))
        {
            //
            // The EtherType is STA, so we translate the header and
            // send it off on the ethernet vc.
            //
            arpIcsForwardIpPacket(
                    pIF,
                    pNdisPacket,
                    ARP_ICS_FORWARD_TO_ETHERNET,
                    IsChannel,
                    &sr
                    );

        }
        else 
        {
            //
            //  Discard packet -- unknown/bad EtherType
            //
            TR_INFO(("Encap hdr 0x%x, bad EtherType 0x%x\n",
                     pEncapHeader, pEncapHeader->EtherType));
        }
    }   while (FALSE);

    EXIT()
    RM_ASSERT_CLEAR(&sr);

    return;
}


MYBOOL
arpIsUnicastEthDest(
    IN   UNALIGNED  ENetHeader   *pEthHdr
)
/*++
    Returns TRUE IFF the packet is either ethernet broadcast or
    multicast.

    //
    // TODO: there's probably a quicker check (single bit?).
    //
--*/
{
    if (NdisEqualMemory(&pEthHdr->eh_daddr, 
                        &BroadcastENetAddr,
                        sizeof(ENetAddr)))
    {
        // Broadcast address
        //
        return FALSE;
    }


    if (NdisEqualMemory(&pEthHdr->eh_daddr,
                        &MulticastENetAddr,
                        3))
    {
        // 1st 3 bytes match our Ethernet multicast address template, so we
        // conclude that this is a multicast address.
        // TODO: verify this check.
        //
        return FALSE;
    }

    return TRUE;
}

NDIS_STATUS
arpGetEthAddrFromIpAddr(
    IN  PARP1394_INTERFACE  pIF,
    IN  MYBOOL              fUnicast,
    IN  IP_ADDRESS          DestIpAddress,
    OUT ENetAddr            *pEthAddr,
    PRM_STACK_RECORD        pSR
    )
/*++
    The destination address is set as follows:
    if (fUnicast)
    {
        We look up our ethernet arp cache (pIF->RemoteEthGroup) and
        if we find an entry there, we use the MAC address in that entry.
        If we don't find, we fail this function.
    }
    else
    {
        if (destination IP address is class D)
        {
            we create the corresponding MAC address (based on the standard
            formula for mapping IPv4 multicast addresses to MAC addresses).
        }
        else
        {
            we set the destination address to broadcast (all 0xff's).
            (NOTE: we easily determine if the IP address is a broadast
             address because we don't have the subnet mask, so instead we
            assume that it's a broadcast destination if it's not class D
            and it came over the broadcast channel (i.e. fUnicast == FALSE))
        }
    }

--*/
{
    ENTER("arpGetEthAddrFromIpAddr", 0x0)
    ARP1394_ADAPTER *       pAdapter;
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    pAdapter    = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);

    do
    {
        if (fUnicast)
        {
            // Lookup the ethernet MAC address in the MAC arp cache.
            //

            *pEthAddr = pAdapter->info.EthernetMacAddress;
            Status = NDIS_STATUS_SUCCESS;
        }
        else
        {
            //
            // Set the destination address to Multicast if dest IP is
            // class D, else multicast
            //

            if (CLASSD_ADDR(DestIpAddress))
            {
                //
                // Construct the corresponding multicast ethernet address.
                // This code is adapted from tcpip\arp.c
                //
                // Basically we copy over a "template" of the multicast
                // address, and then or-in the LSB 23 bits (in network byte
                // order) of the ip address.
                //

                #define ARP_MCAST_MASK      0xffff7f00
                UINT UNALIGNED *pTmp;

                *pEthAddr = MulticastENetAddr; // struct copy.
                pTmp = (UINT UNALIGNED *) & pEthAddr->addr[2];
                *pTmp |= (DestIpAddress & ARP_MCAST_MASK);
            }
            else
            {
                //
                // We assume DestIpAddress is a broadcast address -- see
                // comments at the head of this function
                //
                *pEthAddr = BroadcastENetAddr; // struct copy
            }
        }

        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    return Status;
}


NDIS_STATUS
arpConstructEthArpInfoFrom1394ArpInfo(
    IN  PARP1394_INTERFACE      pIF,
    IN  PIP1394_ARP_PKT_INFO    p1394PktInfo,
    OUT PETH_ARP_PKT_INFO       pEthPktInfo,
    PRM_STACK_RECORD            pSR
    )
/*++
    Translate a parsed version of an Ethernet ARP packet into 
    the parsed version of an equivalent 1394 arp packet.

    We ALWAYS set the source ethernet address AND the target ethernet
    address to OUR ethernet MAC address. So other ethernet nodes think of
    us as a a single ethernet mic which hosts a whole bunch of IP addresses.

    We COULD use our proprietary algorithm to convert from EU64 ID to MAC
    addresses and then use those for the target addresses, but we're not
    sure of the ramifications of that in the bridge mode.

--*/
{
    ENTER("arpConstructEthArpInfoFrom1394ArpInfo", 0x8214aa14)
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    ENetAddr    SourceMacAddress; 
    do
    {
        MYBOOL         fUnicast;
        IP_ADDRESS     IpDest;
        ARP1394_ADAPTER *       pAdapter;
        UINT Ip1394OpCode = p1394PktInfo->OpCode;
        UINT EthOpCode;

        pAdapter    = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);

        ARP_ZEROSTRUCT(pEthPktInfo);

        if (Ip1394OpCode == IP1394_ARP_REQUEST)
        {
            fUnicast = FALSE;
            IpDest   = 0xFFFFFFFF; // IP broadcast address.
            EthOpCode= ARP_ETH_REQUEST;
        }
        else
        {
            // TODO: We expect TargetIpAddress to contain the address
            // of the arp request that resulted in this reply. This
            // is not per ip/1394 spec, which says that the TargetIpAddress
            // is to be ignored. However Kaz has suggested that we
            // utilize this field in this way -- search for "Kaz" in 
            // arp.c
            //
            // If we can't rely on this, then we must either
            // (a) BROADCAST arp replies over ethernet OR
            // (b) keep track of outstanding arp requests which need replies.
            //
            fUnicast = TRUE;
            IpDest   = p1394PktInfo->TargetIpAddress;
            EthOpCode= ARP_ETH_RESPONSE;
        }
    
        Status =  arpGetSourceMacAddressFor1394Pkt (pAdapter, 
                                                   p1394PktInfo->SourceNodeAdddress, 
                                                   p1394PktInfo->fPktHasNodeAddress,
                                                   &SourceMacAddress,
                                                   pSR ); 
        
        if (FAIL(Status))
        {
            break;
        }

        pEthPktInfo->SourceEthAddress = SourceMacAddress ;
        pEthPktInfo->SenderEthAddress = SourceMacAddress ;
        pEthPktInfo->TargetEthAddress = pAdapter->info.EthernetMacAddress;


        Status =  arpGetEthAddrFromIpAddr(
                        pIF,
                        fUnicast,
                        IpDest,
                        &pEthPktInfo->DestEthAddress,
                        pSR
                        );
        if (FAIL(Status))
        {
            break;
        }

        pEthPktInfo->OpCode = EthOpCode;
        pEthPktInfo->SenderIpAddress  = p1394PktInfo->SenderIpAddress;
        pEthPktInfo->TargetIpAddress  = p1394PktInfo->TargetIpAddress;

        

        Status = NDIS_STATUS_SUCCESS;

        {
            UCHAR pIp[4];

            TR_WARN(("Received Arp - "));

            if (EthOpCode == ARP_ETH_RESPONSE)
            {
                TR_WARN(("Response\n"));
            }
            else
            {
                TR_WARN (("Request\n"));
            }

            NdisMoveMemory (&pIp[0], &pEthPktInfo->SenderIpAddress, sizeof(IPAddr) );

            TR_WARN(("Ethernet Source %x %x %x %x %x %x,IP source  %d %d %d %d \n  ",
                       pEthPktInfo->SourceEthAddress.addr[0],
                       pEthPktInfo->SourceEthAddress.addr[1],
                       pEthPktInfo->SourceEthAddress.addr[2],
                       pEthPktInfo->SourceEthAddress.addr[3],
                       pEthPktInfo->SourceEthAddress.addr[4],
                       pEthPktInfo->SourceEthAddress.addr[5],
                        pIp[0],
                        pIp[1],
                        pIp[2],
                        pIp[3]));
                        
            NdisMoveMemory (&pIp[0], &pEthPktInfo->TargetIpAddress, sizeof(IPAddr) );

            TR_WARN(("Ethernet Target %x %x %x %x %x %x , IP Target %d %d %d %d \n",
                       pEthPktInfo->TargetEthAddress.addr[0],
                       pEthPktInfo->TargetEthAddress.addr[1],
                       pEthPktInfo->TargetEthAddress.addr[2],
                       pEthPktInfo->TargetEthAddress.addr[3],
                       pEthPktInfo->TargetEthAddress.addr[4],
                       pEthPktInfo->TargetEthAddress.addr[5],
                        pIp[0],
                        pIp[1],
                        pIp[2],
                        pIp[3]));

            
            TR_WARN(("Ethernet Dest %x %x %x %x %x %x \n",
                       pEthPktInfo->DestEthAddress.addr[0],
                       pEthPktInfo->DestEthAddress.addr[1],
                       pEthPktInfo->DestEthAddress.addr[2],
                       pEthPktInfo->DestEthAddress.addr[3],
                       pEthPktInfo->DestEthAddress.addr[4],
                       pEthPktInfo->DestEthAddress.addr[5]));                            


            TR_WARN(("Ethernet Sender %x %x %x %x %x %x \n\n",
                       pEthPktInfo->SenderEthAddress.addr[0],
                       pEthPktInfo->SenderEthAddress.addr[1],
                       pEthPktInfo->SenderEthAddress.addr[2],
                       pEthPktInfo->SenderEthAddress.addr[3],
                       pEthPktInfo->SenderEthAddress.addr[4],
                       pEthPktInfo->SenderEthAddress.addr[5]));                            

        }

    } while (FALSE);

    return Status;
}



NDIS_STATUS
arpConstruct1394ArpInfoFromEthArpInfo(
    IN  PARP1394_INTERFACE      pIF,
    IN   PETH_ARP_PKT_INFO      pEthPktInfo,
    OUT  PIP1394_ARP_PKT_INFO   p1394PktInfo,
    PRM_STACK_RECORD            pSR
    )
/*++
    Translate a parsed version of an IP1394 ARP packet into 
    the parsed version of an equivalent Ethernet arp packet.

    We always report our own adapter info as the hw/specific info
    in the arp packet. We do this for both arp requests and responses.

    This means that we look like a single host with multiple ip addresses
    to other ip/1394 nodes.

--*/
{
    ARP1394_ADAPTER *       pAdapter;
    UINT Ip1394OpCode;
    UINT EthOpCode = pEthPktInfo->OpCode;

    pAdapter    = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);

    ARP_ZEROSTRUCT(p1394PktInfo);

    if (EthOpCode == ARP_ETH_REQUEST)
    {
        Ip1394OpCode=  IP1394_ARP_REQUEST;
    }
    else
    {
        Ip1394OpCode=  IP1394_ARP_RESPONSE;
    }

    p1394PktInfo->OpCode = Ip1394OpCode;
    p1394PktInfo->SenderIpAddress  = pEthPktInfo->SenderIpAddress;
    p1394PktInfo->TargetIpAddress  = pEthPktInfo->TargetIpAddress;

    // Fill out adapter info..
    //
    p1394PktInfo->SenderHwAddr.UniqueID  = pAdapter->info.LocalUniqueID;
    p1394PktInfo->SenderHwAddr.Off_Low   = pIF->recvinfo.offset.Off_Low;
    p1394PktInfo->SenderHwAddr.Off_High  = pIF->recvinfo.offset.Off_High;
    p1394PktInfo->SenderMaxRec= pAdapter->info.MaxRec;
    p1394PktInfo->SenderMaxSpeedCode= pAdapter->info.MaxSpeedCode;

    return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
arpGetSourceMacAddressFor1394Pkt (
    IN PARP1394_ADAPTER pAdapter,
    IN UCHAR SourceNodeAddress,
    IN BOOLEAN fIsValidSourceNodeAddress,
    OUT ENetAddr* pSourceMacAddress,
    PRM_STACK_RECORD            pSR
    )
/*++
    If the Packet has a valid Source Node Address then return it or else fail 
    the function
--*/
{
    ENetAddr InvalidMacAddress = {0,0,0,0,0,0};
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;

    NdisZeroMemory (pSourceMacAddress, sizeof(*pSourceMacAddress));

    do
    {
        //
        // Get the Mac Address from the Node Address
        //
        if (fIsValidSourceNodeAddress == TRUE)
        {
            *pSourceMacAddress = (pAdapter->EuidMap.Node[SourceNodeAddress].ENetAddress);

        }
        else
        {
            break;
        }
        
        //
        // Is the source address all zero's 
        //
        if (NdisEqualMemory (pSourceMacAddress, &InvalidMacAddress, sizeof (ENetAddr) ) == 1)
        {
            //ASSERT (NdisEqualMemory (pSourceMacAddress, &InvalidMacAddress, sizeof (ENetAddr) ) != 1);
            // Get the New Topology
            //
            arpGetEuidTopology (pAdapter,pSR);
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // The SourceMacAddress should not be a broadcast or multicast address
        //
        if (ETH_IS_BROADCAST(pSourceMacAddress)  || ETH_IS_MULTICAST(pSourceMacAddress))
        {
            ASSERT (ETH_IS_BROADCAST(pSourceMacAddress)  == FALSE);
            ASSERT (ETH_IS_MULTICAST(pSourceMacAddress) == FALSE);
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        Status = NDIS_STATUS_SUCCESS;
        
    }while (FALSE);
    return Status;
    
}


NDIS_STATUS
arpEthConstructSTAEthHeader(
    IN PUCHAR pvData,
    IN UINT cbData,
    OUT ENetHeader   *pEthHdr
    )
/*++
    Constructs the Ethernet header of the STA packet .
    Expects that Source Mac Address has already been filled in

    Arguments:
    pvData - Start of the Data packet
    cbData - Length of the data
    pEthHdr - output value
--*/
    
{
    UINT LenIpData = cbData - sizeof (NIC1394_ENCAPSULATION_HEADER);
    //
    // First set the destination Mac address in the Ethernet Header
    //
    NdisMoveMemory (&pEthHdr->eh_daddr, &gSTAMacAddr, sizeof (gSTAMacAddr)); 


    //
    // Use the length of the packet to store it in the packets. Should be 0x26 or 0x7
    //

    pEthHdr->eh_type = H2N_USHORT(LenIpData);

    return NDIS_STATUS_SUCCESS;
        
}



//
// the Bootp Code is take heavily from the bridge module
//


BOOLEAN
arpDecodeIPHeader(
    IN PUCHAR                   pHeader,
    OUT PARP_IP_HEADER_INFO    piphi
    )
/*++

Routine Description:

    Decodes basic information from the IP header (no options)

Arguments:

    pHeader                     Pointer to an IP header
    piphi                       Receives the info

Return Value:

    TRUE: header was valid
    FALSE: packet is not an IP packet

--*/
{
    // First nibble of the header encodes the packet version, which must be 4.
    if( (*pHeader >> 4) != 0x04 )
    {
        return FALSE;
    }

    // Next nibble of the header encodes the length of the header in 32-bit words.
    // This length must be at least 20 bytes or something is amiss.
    piphi->headerSize = (*pHeader & 0x0F) * 4;
    if( piphi->headerSize < 20 )
    {
        return FALSE;
    }

    // Retrieve the protocol byte (offset 10)
    piphi->protocol = pHeader[9];

    // The source IP address begins at the 12th byte (most significant byte first)
#if 0    
    piphi->ipSource = 0L;
    piphi->ipSource |= pHeader[12] << 24;
    piphi->ipSource |= pHeader[13] << 16;
    piphi->ipSource |= pHeader[14] << 8;
    piphi->ipSource |= pHeader[15];

    // The destination IP address is next
    piphi->ipTarget = 0L;
    piphi->ipTarget |= pHeader[16] << 24;
    piphi->ipTarget |= pHeader[17] << 16;
    piphi->ipTarget |= pHeader[18] << 8;
    piphi->ipTarget |= pHeader[19];
#endif
    return TRUE;
}



PUCHAR
arpIsEthBootPPacket(
    IN PUCHAR                   pPacketData,
    IN UINT                     packetLen,
    IN PARP_IP_HEADER_INFO     piphi
    )
/*++

Routine Description:

    Determines whether a given packet is a BOOTP packet
    Requires a phy length of six

    Different from the Bridge Code, packetLen is length of the Ip Packet

Arguments:

    pPacketData                 Pointer to the packet's data buffer
    packetLen                   Amount of data at pPacketDaa
    piphi                       Info about the IP header of this packet

Return Value:

    A pointer to the BOOTP payload within the packet, or NULL if the packet was not
    a BOOTP Packet.

--*/
{
    ENTER("arpIsEthBootPPacket",0xbcdce2dd);
    // After the IP header, there must be enough room for a UDP header and
    // a basic BOOTP packet
    if( packetLen < (UINT)piphi->headerSize + SIZE_OF_UDP_HEADER +
                    SIZE_OF_BASIC_BOOTP_PACKET)
    {
        return NULL;
    }

    // Protocol must be UDP
    if( piphi->protocol != UDP_PROTOCOL )
    {
        return NULL;
    }

    // Jump to the beginning of the UDP packet by skipping the IP header
    pPacketData += piphi->headerSize;

    // The first two bytes are the source port and should be the
    // BOOTP Client port (0x0044) or the BOOTP Server port (0x0043)
    if( (pPacketData[0] != 00) ||
        ((pPacketData[1] != 0x44) && (pPacketData[1] != 0x43)) )
    {
        return NULL;
    }

    // The next two bytes are the destination port and should be the BOOTP
    // server port (0x0043) or the BOOTP client port (0x44)
    if( (pPacketData[2] != 00) ||
        ((pPacketData[3] != 0x43) && (pPacketData[3] != 0x44)) )
    {
        return NULL;
    }

    // Skip ahead to the beginning of the BOOTP packet
    pPacketData += SIZE_OF_UDP_HEADER;

    // The first byte is the op code and should be 0x01 for a request
    // or 0x02 for a reply
    if( pPacketData[0] > 0x02 )
    {
        return NULL;
    }
    

    // The next byte is the hardware type and should be 0x01 for Ethernet
    // or 0x07 (officially arcnet) for ip1394
    //
    if( pPacketData[1] != 0x01 && pPacketData[1] != 0x07  )
    {
        return NULL;
    }

    // The next byte is the address length and should be 0x06 for Ethernet
    if( pPacketData[2] != 0x06 )
    {
        return NULL;
    }

    // Everything checks out; this looks like a BOOTP request packet.
    TR_INFO ( ("Received Bootp Packet \n"));
    EXIT()
    return pPacketData;
}



//
// The IP and UDP checksums treat the data they are checksumming as a
// sequence of 16-bit words. The checksum is carried as the bitwise
// inverse of the actual checksum (~C). The formula for calculating
// the new checksum as transmitted, ~C', given that a 16-bit word of
// the checksummed data has changed from w to w' is
//
//      ~C' = ~C + w + ~w' (addition in ones-complement)
//
// This function returns the updated checksum given the original checksum
// and the original and new values of a word in the checksummed data.
// RFC 1141
//
USHORT
arpEthCompRecalcChecksum(
    IN USHORT                   oldChecksum,
    IN USHORT                   oldWord,
    IN USHORT                   newWord
    )
{
    ULONG                       sum,XSum;
    ULONG                       RfcSum, RfcXSum;



    sum = oldChecksum + oldWord + ((~(newWord)) & 0xFFFF);
    XSum =  (USHORT)((sum & 0xFFFF) + (sum >> 16));

    RfcSum = oldWord + ((~(newWord)) & 0xffff);
    RfcSum  += oldChecksum;
    RfcSum   = (RfcSum& 0xffff) + (RfcSum  >>16);
    RfcXSum  = (RfcSum + (RfcSum  >>16));

    ASSERT (RfcXSum  == XSum);
    return (USHORT)RfcXSum;
    

}



VOID
arpEthRewriteBootPClientAddress(
    IN PUCHAR                   pPacketData,
    IN PARP_IP_HEADER_INFO      piphi,
    IN PUCHAR                   newMAC
    )
/*++

Routine Description:

    This function writes New MAC to the HW address embedded in the DHCP packet

Arguments:
    
Return Value:


--*/
{
    USHORT                      checkSum;
    PUCHAR                      pBootPData, pCheckSum, pDestMAC, pSrcMAC;
    UINT                        i;

    // The BOOTP packet lives right after the UDP header
    pBootPData = pPacketData + piphi->IpHeaderOffset + piphi->headerSize + SIZE_OF_UDP_HEADER;

    // The checksum lives at offset 7 in the UDP packet.
    pCheckSum = pPacketData + piphi->IpHeaderOffset + piphi->headerSize + 6;
    checkSum = 0;
    checkSum = pCheckSum[0] << 8;
    checkSum |= pCheckSum[1];

    if (checkSum == 0xffff)
    {
        // Tcpip Illustrated - Vol 1 'UDP Checksum'
        checkSum = 0;
    }

    // Replace the client's hardware address, updating the checksum as we go.
    // The client's hardware address lives at offset 29 in the BOOTP packet
    pSrcMAC = newMAC;
    pDestMAC = &pBootPData[28];

    for( i = 0 ; i < ETH_LENGTH_OF_ADDRESS / 2; i++ )
    {
        checkSum = arpEthCompRecalcChecksum( checkSum,
                                           (USHORT)(pDestMAC[0] << 8 | pDestMAC[1]),
                                           (USHORT)(pSrcMAC[0] << 8 | pSrcMAC[1]) );

        pDestMAC[0] = pSrcMAC[0];
        pDestMAC[1] = pSrcMAC[1];

        pDestMAC += 2;
        pSrcMAC += 2;
    }

    // Write the new checksum back out
    pCheckSum[0] = (UCHAR)(checkSum >> 8);
    pCheckSum[1] = (UCHAR)(checkSum & 0xFF);








}





NDIS_STATUS
arpEthBootP1394ToEth(
    IN  PARP1394_INTERFACE          pIF,                // NOLOCKIN NOLOCKOUT
    IN  ARP_ICS_FORWARD_DIRECTION   Direction,
    IN  PREMOTE_DEST_KEY             pDestAddress, 
    IN  PUCHAR                       pucNewData,
    IN  PUCHAR                       pBootPData,
    IN  PARP_IP_HEADER_INFO          piphi,
    IN  PRM_STACK_RECORD             pSR
    )        
/*++

Routine Description:

    This function handles the translation from 1394 to Eth. Essentially, 
    we look at the SRC MAC address in the Ethernet Packet, make sure the HW 
    Addr embedded is the same as the SRC MAC address.

    We also make an entry in our table - XID, OldHWAddress, NewHWAddress. 
    
    The packet has already been rewritten into Ethernet by this time

Arguments:
    pIF - pInterface
    Direction - Eth To 1394 or  1394-To-Eth
    pDestAddress - the Eth Hw address used in the translation
    pucNewData - the Data in the new packet
    pBootPdata - pointer to the Bootp part of the packet
    piphi - ip header info
    
Return Value:


--*/
{
    BOOLEAN         bIsRequest = FALSE;
    BOOLEAN         bIsResponse;
    ARP_BOOTP_INFO  InfoBootP;
    NDIS_STATUS     Status = NDIS_STATUS_FAILURE;
    ENetHeader*      pEnetHeader = (ENetHeader*)pucNewData;
    ENetAddr         NewMAC;
    BOOLEAN         bIs1394HwAlreadyInDhcpRequest;

    ENTER ("arpEthBootP1394ToEth", 0x66206f0b);
    NdisZeroMemory (&InfoBootP, sizeof(InfoBootP));
    //
    // Is this a DHCP Request 
    //

    do
    {
        bIsResponse = ARP_IS_BOOTP_RESPONSE(pBootPData);

        if (bIsResponse == TRUE)
        {
            //
            // if this is a DHCP Reply , the do not touch the packet - there are no inconsistencies.
            //
            Status = NDIS_STATUS_SUCCESS;
            break;

        }
        
        
        if( FALSE == arpEthPreprocessBootPPacket(pIF,pucNewData, pBootPData, &bIsRequest, &InfoBootP,pSR) )
        {
            // This is an invalid packet
            ASSERT (FALSE);
            break;
        }

        
        //
        // This is a DHCP Request
        //


        //
        // if the HWAddr and the Src Mac address the same.
        // then are job is already done.
        //
        //At this point the 1394 packet is already in Ethernet format

        NewMAC = pEnetHeader->eh_saddr;

        TR_INFO(("DHCP REQUEST target MAC  %x %x %x %x %x %x , SrcMAC %x %x %x %x %x %x \n",
                InfoBootP.requestorMAC.addr[0],InfoBootP.requestorMAC.addr[1],InfoBootP.requestorMAC.addr[2],
                InfoBootP.requestorMAC.addr[3],InfoBootP.requestorMAC.addr[4],InfoBootP.requestorMAC.addr[5],
                NewMAC.addr[0],NewMAC.addr[1],NewMAC.addr[2],
                NewMAC.addr[3],NewMAC.addr[4],NewMAC.addr[5]));

        bIs1394HwAlreadyInDhcpRequest = NdisEqualMemory (&InfoBootP.requestorMAC, &NewMAC , sizeof (ENetAddr)) ;

        
        if (TRUE == bIs1394HwAlreadyInDhcpRequest )
        {
            //
            // Nothing to do , id the HW add and the src MAC are equal
            //
            Status = NDIS_STATUS_SUCCESS;
            break;            
        }

        
        //
        // Make an entry into our table - consisting of the XID. OldHW Address and 
        // New HY address
        // We've already done this. 
        
        //
        // Overwrite the hw address embedded in the DHCP packet. - make sure to rewrite the 
        // checksum.
        //
        arpEthRewriteBootPClientAddress(pucNewData,piphi,&NewMAC.addr[0]);

        TR_VERB (("arpEthBootP1394ToEth  -Dhcp packet Rewriting BootpClient Address\n"));

        
        Status = NDIS_STATUS_SUCCESS;
    }while (FALSE);

    EXIT();
    return Status;;
}





NDIS_STATUS
arpEthBootPEthTo1394(
    IN  PARP1394_INTERFACE          pIF,                // NOLOCKIN NOLOCKOUT
    IN  ARP_ICS_FORWARD_DIRECTION   Direction,
    IN  PREMOTE_DEST_KEY             pDestAddress, // OPTIONAL
    IN  PUCHAR                       pucNewData,
    IN  PUCHAR                       pBootPData,
    IN PARP_IP_HEADER_INFO           piphi,
    IN  PRM_STACK_RECORD                pSR
    )        
/*++

Routine Description:

    This function translates BootP packet from the Ethernet Net to 1394. if this is a dhcp reply (offer), 
    then we need to rewrite the Hw Addr in the DHCP packlet

Arguments:
    
    pIF - pInterface
    Direction - Eth To 1394 or  1394-To-Eth
    pDestAddress - the Eth Hw address used in the translation
    pucNewData - the Data in the new packet
    
Return Value:


--*/
{
    BOOLEAN         fIsBootpRequest = FALSE;
    ARP_BOOTP_INFO  InfoBootP;
    NDIS_STATUS     Status = NDIS_STATUS_FAILURE;
    ENetHeader*      pEnetHeader = (ENetHeader*)pucNewData;
    ENetAddr         NewMAC;
    PUCHAR          pMACInPkt = NULL;
    BOOLEAN         bIs1394HwAlreadyInDhcpResponse = FALSE;

    ENTER("arpEthBootPEthTo1394", 0x383f9e33);
    NdisZeroMemory (&InfoBootP, sizeof(InfoBootP));
    //
    // Is this a DHCP Request 
    //

    do
    {

        // Do a quick check .
        fIsBootpRequest = ARP_IS_BOOTP_REQUEST(pBootPData);

        if (fIsBootpRequest  == TRUE)
        {
            //
            // if this is a DHCP Request, the do not modify the packet - 
            // there are no inconsistencies in this code path.
            //
            Status = NDIS_STATUS_SUCCESS;
            break;

        }

        
        if( FALSE == arpEthPreprocessBootPPacket(pIF,pucNewData, pBootPData, &fIsBootpRequest, &InfoBootP,pSR) )
        {
            // This is an uninteresting packet
            break;
        }

        //
        // InfoBootP has the original HW addr used in the corresponding Dhcp request.
        // We'll put the hw Addr back into dhcp reply
        

            
        //
        //offset of the chaddr in bootp packet
        //
        pMACInPkt = &pBootPData[28];  

        

        TR_INFO(("DHCP RESPONSE target MAC  %x %x %x %x %x %x , SrcMAC %x %x %x %x %x %x \n",
                InfoBootP.requestorMAC.addr[0],InfoBootP.requestorMAC.addr[1],InfoBootP.requestorMAC.addr[2],
                InfoBootP.requestorMAC.addr[3],InfoBootP.requestorMAC.addr[4],InfoBootP.requestorMAC.addr[5],
                pMACInPkt[0],pMACInPkt[1],pMACInPkt[2],
                pMACInPkt[3],pMACInPkt[4],pMACInPkt[5]));

        //
        // Is the HWAddr in the dhcp packet the correct one.
        //
        
        bIs1394HwAlreadyInDhcpResponse = NdisEqualMemory(&InfoBootP.requestorMAC, pMACInPkt, sizeof (InfoBootP.requestorMAC)) ;
        
        if (TRUE == bIs1394HwAlreadyInDhcpResponse)
        {
            //
            // Yes, they are equal, we do not rewrite the packet
            //
            Status = NDIS_STATUS_SUCCESS;
            break;

        }


                    
        TR_VERB( ("DHCP RESPONSE  Rewriting Bootp Response pBootpData %p Before\n",pBootPData));

        //
        // Replace the CL Addr in the DHCP packet with the original HW addr
        //
        arpEthRewriteBootPClientAddress(pucNewData,piphi,&InfoBootP.requestorMAC.addr[0]);

        
        //
        // recompute the checksum
        //

        Status = NDIS_STATUS_SUCCESS;

        } while (FALSE);

    EXIT();
    return Status;
}



NDIS_STATUS
arpEthModifyBootPPacket(
    IN  PARP1394_INTERFACE          pIF,                // NOLOCKIN NOLOCKOUT
    IN  ARP_ICS_FORWARD_DIRECTION   Direction,
    IN  PREMOTE_DEST_KEY             pDestAddress, // OPTIONAL
    IN  PUCHAR                       pucNewData,
    IN  ULONG                         PacketLength,
    IN  PRM_STACK_RECORD                pSR
    )        
/*++

Routine Description:

    This function contains the code to process a Bootp Packet. This basically ensures that the 
    MAC address entered in the DHCP packet matches the Src Mac address of the Ethernet Packet 
    (in the 1394 - Eth mode). In the other case (Eth-1394 mode), we replace the Ch address with 
    the correct CH addr (if we have to). 
    

Arguments:
    pIF - pInterface
    Direction - Eth To 1394 or  1394-To-Eth
    pDestAddress - the Eth Hw address used in the translation
    pucNewData - the Data in the new packet
    
Return Value:


--*/
{
    ARP_IP_HEADER_INFO      iphi;
    PUCHAR                  pBootPData = NULL;
    NDIS_STATUS             Status= NDIS_STATUS_FAILURE;
    PARP1394_ADAPTER        pAdapter = (PARP1394_ADAPTER)RM_PARENT_OBJECT(pIF);
    ULONG                   IpHeaderOffset = 0;
    PUCHAR                  pIPHeader = NULL;
    BOOLEAN                 fIsIpPkt;
    NdisZeroMemory(&iphi, sizeof (iphi));
    

    do
    {
        //
        // if we are not in bridge mode - exit.
        //
        if (ARP_BRIDGE_ENABLED(pAdapter) == FALSE)
        {
            break;
        }       

        if (Direction == ARP_ICS_FORWARD_TO_ETHERNET)
        {
            // Packet is in the ethernet format
            IpHeaderOffset = ETHERNET_HEADER_SIZE; 
        
        }
        else
        {
            // Packet is in the IP 1394 format
            IpHeaderOffset = sizeof (NIC1394_UNFRAGMENTED_HEADER); //4
        }

        iphi.IpHeaderOffset = IpHeaderOffset;
        iphi.IpPktLength = PacketLength - IpHeaderOffset;
        pIPHeader = pucNewData + IpHeaderOffset ;

        //
        // if this is not a bootp packet -exit
        //
        fIsIpPkt = arpDecodeIPHeader (pIPHeader , &iphi);

        if (fIsIpPkt == FALSE)
        {
            //
            // not an IP pkt
            //
            Status = NDIS_STATUS_SUCCESS;
            break;
        }
            
        
        pBootPData  = arpIsEthBootPPacket (pIPHeader ,PacketLength-IpHeaderOffset, &iphi);

        if (pBootPData == NULL)
        {
            Status = NDIS_STATUS_SUCCESS;
            break;
        }
        //
        // are we doing 1394 - to-  Eth
        //
        if (Direction == ARP_ICS_FORWARD_TO_ETHERNET)
        {

            Status = arpEthBootP1394ToEth(pIF, Direction,pDestAddress,pucNewData,pBootPData,&iphi,  pSR);

        }
        else
        {
            //
            // are we doing Eth to 1394
            //
            Status = arpEthBootPEthTo1394(pIF, Direction,pDestAddress,pucNewData,pBootPData , &iphi,pSR);

        }
        Status = NDIS_STATUS_SUCCESS;
    }while (FALSE);
    
    // else we are doing Eth to 1394
    return Status;
}


//
// This function is taken verbatim from the bridge
//


BOOLEAN
arpEthPreprocessBootPPacket(
    IN PARP1394_INTERFACE       pIF,
    IN PUCHAR                   pPacketData,
    IN PUCHAR                   pBootPData,     // Actual BOOTP packet
    OUT PBOOLEAN                pbIsRequest,
    PARP_BOOTP_INFO             pInfoBootP,
    PRM_STACK_RECORD           pSR
    )
/*++

Routine Description:

    Does preliminary processing of a BOOTP packet common to the inbound and outbound case

Arguments:

    pPacketData                 Pointer to a packet's data buffer
    pBootPData                  Pointer to the BOOTP payload within the packet
    pAdapt                      Receiving adapter (or NULL if this packet is outbound from
                                    the local machine)
    pbIsRequest                 Receives a flag indicating if this is a BOOTP request
    ppTargetAdapt               Receives the target adapter this packet should be relayed to
                                    (only valid if bIsRequest == FALSE and return == TRUE)
    requestorMAC                   The MAC address this packet should be relayed to (valid under
                                    same conditions as ppTargetAdapt)

Return Value:

    TRUE : packet was processed successfully
    FALSE : an error occured or something is wrong with the packet

--*/
{
    PARP1394_ETH_DHCP_ENTRY pEntry= NULL;
    ULONG                       xid;
    NDIS_STATUS                 Status = NDIS_STATUS_FAILURE;
    ENTER ("arpEthPreprocessBootPPacket",0x25427efc);

    // Decode the xid (bytes 5 through 8)
    xid = 0L;
    xid |= pBootPData[4] << 24;
    xid |= pBootPData[5] << 16;
    xid |= pBootPData[6] << 8;
    xid |= pBootPData[7];

    // Byte 0 is the operation; 1 for a request, 2 for a reply
    if( pBootPData[0] == 0x01 )
    {
        ULONG                 bIsNewEntry = FALSE;

        // This is a request. We need to note the correspondence betweeen
        // this client's XID and its adapter and MAC address

        TR_INFO(("DHCP REQUEST XID: %x , HW %x %x %x %x %x %x \n", xid, 
                    pBootPData[28],pBootPData[29],pBootPData[30],pBootPData[31],pBootPData[32],pBootPData[33]));

        Status = RmLookupObjectInGroup(
                    &pIF->EthDhcpGroup,
                    RM_CREATE,
                    (PVOID) &xid,             // pKey
                    (PVOID) &xid,             // pvCreateParams
                    &(PRM_OBJECT_HEADER)pEntry,
                    &bIsNewEntry ,
                    pSR
                    );


        if( pEntry != NULL )
        {
            if( bIsNewEntry )
            {
                // Initialize the entry.
                // The client's hardware address is at offset 29
                ETH_COPY_NETWORK_ADDRESS( &pEntry->requestorMAC.addr[0], &pBootPData[28] );

                pEntry->xid = xid;

            }
            else
            {
                //
                // An entry already existed for this XID. This is fine if the existing information
                // matches what we're trying to record, but it's also possible that two stations
                // decided independently to use the same XID, or that the same station changed
                // apparent MAC address and/or adapter due to topology changes. Our scheme breaks
                // down under these circumstances.
                //
                // Either way, use the most recent information possible; clobber the existing
                // information with the latest.
                //

                LOCKOBJ(pEntry, pSR);

                {
                    UINT            Result;
                    ETH_COMPARE_NETWORK_ADDRESSES_EQ( &pEntry->requestorMAC.addr[0], &pBootPData[28], &Result );

                    // Warn if the data changed, as this probably signals a problem
                    if( Result != 0 )
                    {
                        
                        TR_WARN(("ARP1394 WARNING: Station with MAC address %02x:%02x:%02x:%02x:%02x:%02x is using DHCP XID %x at the same time as station %02x:%02x:%02x:%02x:%02x:%02x!\n",
                                          pBootPData[28], pBootPData[29], pBootPData[30], pBootPData[31], pBootPData[32], pBootPData[33],
                                          xid, pEntry->requestorMAC.addr[0], pEntry->requestorMAC.addr[1], pEntry->requestorMAC.addr[2],
                                          pEntry->requestorMAC.addr[3], pEntry->requestorMAC.addr[4], pEntry->requestorMAC.addr[5] ));
                    }
                }

                ETH_COPY_NETWORK_ADDRESS( &pEntry->requestorMAC.addr[0], &pBootPData[28] );

                UNLOCKOBJ (pEntry, pSR);
            }
        
            RmTmpDereferenceObject (&pEntry->Hdr, pSR);
            
        }
        else
        {
            // This packet could not be processed
            TR_INFO(("Couldn't create table entry for BOOTP packet!\n"));
            return FALSE;
        }

        *pbIsRequest = TRUE;
        pInfoBootP->bIsRequest = TRUE; 

        ETH_COPY_NETWORK_ADDRESS(&pInfoBootP->requestorMAC,&pEntry->requestorMAC);

        return TRUE;
    }
    else if ( pBootPData[0] == 0x02 )
    {
        //
        // NON-CREATE search
        // Look up the xid for this transaction to recover the MAC address of the client
        //

        TR_INFO (("Seeing a DHCP response xid %x mac %x %x %x %x %x %x \n", 
                xid, pBootPData[28],pBootPData[29],pBootPData[30],pBootPData[31],pBootPData[32],pBootPData[33]));
        Status = RmLookupObjectInGroup(
                    &pIF->EthDhcpGroup,
                    0,                        // do not create
                    (PVOID) &xid,             // pKey
                    (PVOID) &xid,             // pvCreateParams
                    &(PRM_OBJECT_HEADER)pEntry,
                    NULL,
                    pSR
                    );


        if( pEntry != NULL )
        {
            LOCKOBJ( pEntry, pSR);
            ETH_COPY_NETWORK_ADDRESS( &pInfoBootP->requestorMAC.addr, pEntry->requestorMAC.addr );
            UNLOCKOBJ( pEntry, pSR );

            //
            // We will use this adapter outside the table lock. NULL is a permissible
            // value that indicates that the local machine is the requestor for
            // this xid.
            //
            RmTmpDereferenceObject(&pEntry->Hdr, pSR);
        }

        if( pEntry != NULL )
        {
            *pbIsRequest = FALSE;
            return TRUE;
        }
        else
        {
            TR_INFO (("DHCP Response:Could not find xid %x in DHCP table \n",xid);)
            return FALSE;
        }
    }
    else
    {
        // Someone passed us a crummy packet
        return FALSE;
    }
}

#if DBG
VOID
Dump(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )

    // Hex dump 'cb' bytes starting at 'p' grouping 'ulGroup' bytes together.
    // For example, with 'ulGroup' of 1, 2, and 4:
    //
    // 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
    // 0000 0000 0000 0000 0000 0000 0000 0000 |................|
    // 00000000 00000000 00000000 00000000 |................|
    //
    // If 'fAddress' is true, the memory address dumped is prepended to each
    // line.
    //
{
    while (cb)
    {
        INT cbLine;

        cbLine = (cb < DUMP_BytesPerLine) ? cb : DUMP_BytesPerLine;
        DumpLine( p, cbLine, fAddress, ulGroup );
        cb -= cbLine;
        p += cbLine;
        
    }
}
#endif


#if DBG
VOID
DumpLine(
    IN CHAR* p,
    IN ULONG cb,
    IN BOOLEAN fAddress,
    IN ULONG ulGroup )
{
    CHAR* pszDigits = "0123456789ABCDEF";
    CHAR szHex[ ((2 + 1) * DUMP_BytesPerLine) + 1 ];
    CHAR* pszHex = szHex;
    CHAR szAscii[ DUMP_BytesPerLine + 1 ];
    CHAR* pszAscii = szAscii;
    ULONG ulGrouped = 0;

    if (fAddress)
        DbgPrint( "A13: %p: ", p );
    else
        DbgPrint( "A13: " );

    while (cb)
    {
        *pszHex++ = pszDigits[ ((UCHAR )*p) / 16 ];
        *pszHex++ = pszDigits[ ((UCHAR )*p) % 16 ];

        if (++ulGrouped >= ulGroup)
        {
            *pszHex++ = ' ';
            ulGrouped = 0;
        }

        *pszAscii++ = (*p >= 32 && *p < 128) ? *p : '.';

        ++p;
        --cb;
    }

    *pszHex = '\0';
    *pszAscii = '\0';

    DbgPrint(
        "%-*s|%-*s|\n",
        (2 * DUMP_BytesPerLine) + (DUMP_BytesPerLine / ulGroup), szHex,
        DUMP_BytesPerLine, szAscii );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\ip.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    ip.c

Abstract:

    ARP1394 IP-related handlers.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     01-06-98    Created (adapted from atmarpc.sys, arpif.c)

Notes:

--*/
#include <precomp.h>

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_IP

#define CLASSA_MASK     0x000000ff
#define CLASSB_MASK     0x0000ffff
#define CLASSC_MASK     0x00ffffff
#define CLASSD_MASK     0x000000e0
#define CLASSE_MASK     0xffffffff




//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================
  
ULONG ArpSendCompletes = 0;
ULONG ArpSends = 0;
ULONG ArpSendFailure = 0;


#define LOGSTATS_SendFifoCounts(_pIF, _pNdisPacket, _Status) \
            arpLogSendFifoCounts(_pIF, _pNdisPacket, _Status)
#define LOGSTATS_SendChannelCounts(_pIF, _pNdisPacket, _Status) \
            arpLogSendChannelCounts(_pIF, _pNdisPacket, _Status)
#define LOGSTATS_TotalArpCacheLookups(_pIF, _Status)        \
    NdisInterlockedIncrement(&((_pIF)->stats.arpcache.TotalLookups))

const
NIC1394_ENCAPSULATION_HEADER
Arp1394_IpEncapHeader =
{
    0x0000,     // Reserved
    H2N_USHORT(NIC1394_ETHERTYPE_IP)
};

//
// ZZZ This is a little-endian specific check.
//
#define ETH_IS_MULTICAST(Address) \
    (BOOLEAN)(((PUCHAR)(Address))[0] & ((UCHAR)0x01))


//
// Check whether an address is broadcast.
//
#define ETH_IS_BROADCAST(Address)               \
    ((((PUCHAR)(Address))[0] == ((UCHAR)0xff)) && (((PUCHAR)(Address))[1] == ((UCHAR)0xff)))

VOID
arpReStartInterface(
    IN  PNDIS_WORK_ITEM             pWorkItem,
    IN  PVOID                       IfContext
);

NDIS_STATUS
arpInitializeLocalIp(
    IN  ARPCB_LOCAL_IP * pLocalIp,  // LOCKIN NOLOCKOUT
    IN  UINT                        AddressType,
    IN  IP_ADDRESS                  IpAddress,
    IN  IP_MASK                     Mask,
    IN  PVOID                           context,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
arpUnloadLocalIp(
    IN  ARPCB_LOCAL_IP * pLocalIp,  // LOCKIN NOLOCKOUT
    IN  PRM_STACK_RECORD            pSR
    );

INT
arpQueryIpEntityId(
    ARP1394_INTERFACE *             pIF,
    IN      UINT                    EntityType,
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    PRM_STACK_RECORD                pSR
    );

VOID
nicGetMacAddressFromEuid (
    UINT64 *pEuid, 
    ENetAddr *pMacAddr
    );

INT
arpQueryIpAddrXlatInfo(
    ARP1394_INTERFACE *             pIF,
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    PRM_STACK_RECORD                pSR
    );

INT
arpQueryIpAddrXlatEntries(
    ARP1394_INTERFACE *             pIF,
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    IN      PVOID                   QueryContext,
    PRM_STACK_RECORD                pSR
    );

INT
arpQueryIpMibStats(
    ARP1394_INTERFACE *             pIF,
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    PRM_STACK_RECORD                pSR
    );

PNDIS_BUFFER
arpCopyToNdisBuffer(
    IN  PNDIS_BUFFER                pDestBuffer,
    IN  PUCHAR                      pDataSrc,
    IN  UINT                        LenToCopy,
    IN OUT  PUINT                   pOffsetInBuffer
    );

VOID
arpSendIpPkt(
    IN  ARP1394_INTERFACE       *   pIF,            // LOCKIN NOLOCKOUT (IF send lk)
    IN  PARPCB_DEST                 pDest,
    IN  PNDIS_PACKET                pNdisPacket
    );

VOID
arpAddRce(
    IN  ARPCB_REMOTE_IP *pRemoteIp,
    IN  RouteCacheEntry *pRCE,
    IN  PRM_STACK_RECORD pSR
    );

VOID
arpDelRce(
    IN  RouteCacheEntry *pRce,  // IF send lock WRITELOCKIN WRITELOCKOUTD
    IN  PRM_STACK_RECORD pSR
    );

NDIS_STATUS
arpTaskSendPktsOnRemoteIp(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

VOID
arpTryResumeSuspendedCleanupTask(
    IN  ARP1394_INTERFACE   *   pIF,
    IN  ARPCB_DEST          *   pDest
    );

VOID
arpQueuePktOnRemoteIp(
    IN  ARPCB_REMOTE_IP     *   pRemoteIp,      // LOCKIN LOCKOUT
    IN  PNDIS_PACKET        pNdisPacket,
    IN  PRM_STACK_RECORD    pSR
    );

VOID
arpSendPktsQueuedOnRemoteIp(
    IN  ARP1394_INTERFACE   *   pIF,            // NOLOCKIN NOLOCKOUT
    IN  ARPCB_REMOTE_IP     *   pRemoteIp,      // NOLOCKIN NOLOCKOUT
    IN  PRM_STACK_RECORD    pSR
    );

MYBOOL
arpIsNonUnicastIpAddress(
    IN  PARP1394_INTERFACE          pIF,        // LOCKIN LOCKOUT
    IN  IP_ADDRESS                  Addr,
    IN  PRM_STACK_RECORD            pSR
    );

MYBOOL
arpIsNonUnicastEthAddress (
    IN  PARP1394_INTERFACE          pIF,        // LOCKIN LOCKOUT
    IN  ENetAddr*                   pAddr,
    IN  PRM_STACK_RECORD            pSR
);

VOID
arpLoopbackNdisPacket(
    IN PARP1394_INTERFACE pIF,
    IN PARPCB_DEST pBroadcastDest,
    IN PNDIS_PACKET pOldPacket
    );

NDIS_STATUS
arpTaskSendARPApi(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );



//=========================================================================
//                  I P     H A N D L E R S
//=========================================================================


INT
ArpIpDynRegister(
    IN  PNDIS_STRING                pAdapterString,
    IN  PVOID                       IpContext,
    IN  struct _IP_HANDLERS *       pIpHandlers,
    IN  struct LLIPBindInfo *       pBindInfo,
    IN  UINT                        InterfaceNumber
)
/*++

Routine Description:

    This routine is called from the IP layer when it wants to tell us,
    the ARP module, about its handlers for an Interface.

Arguments:

    pAdapterString      - Name of the logical adapter for this interface
    IpContext           - IP's context for this interface
    pIpHandlers         - Points to struct containing the IP handlers
    pBindInfo           - Pointer to bind info with our information
    InterfaceNumber     - ID for this interface

Return Value:

    TRUE always.

--*/
{
    ENTER("IfDynRegister", 0xc1b569b9)
    ARP1394_INTERFACE*          pIF;
    RM_DECLARE_STACK_RECORD(sr)
    pIF = (ARP1394_INTERFACE*)(pBindInfo->lip_context);

    TR_INFO(("pIF 0x%p\n", pIF));
    ASSERT(pIF->Hdr.Sig == MTAG_INTERFACE);

    LOCKOBJ(pIF, &sr);

    //
    // TODO: fail if we're not in a position to do this -- such as when shutting
    // down.
    //

    pIF->ip.Context         = IpContext;
    pIF->ip.RcvHandler      = pIpHandlers->IpRcvHandler;
    pIF->ip.TxCmpltHandler  = pIpHandlers->IpTxCompleteHandler;
    pIF->ip.StatusHandler   = pIpHandlers->IpStatusHandler;
    pIF->ip.TDCmpltHandler  = pIpHandlers->IpTransferCompleteHandler;
    pIF->ip.RcvCmpltHandler = pIpHandlers->IpRcvCompleteHandler;
    pIF->ip.PnPEventHandler = pIpHandlers->IpPnPHandler;
    pIF->ip.RcvPktHandler   = pIpHandlers->IpRcvPktHandler;
    pIF->ip.AddAddrCmplRtn  = pIpHandlers->IpAddAddrCompleteRtn;
    pIF->ip.IFIndex         = InterfaceNumber;

    UNLOCKOBJ(pIF, &sr);
    //
    RM_ASSERT_CLEAR(&sr);
    EXIT()

    return TRUE;
}


VOID
ArpIpOpen(
    IN  PVOID                       Context
)
/*++

Routine Description:

    This routine is called when IP is ready to use this interface.

Arguments:

    Context     - Actually a pointer to our ARP394_INTERFACE structure

--*/
{
    ARP1394_INTERFACE*          pIF;
    ENTER("ArpIpOpen", 0x7cae1e55)
    RM_DECLARE_STACK_RECORD(sr)

    TR_INFO(("Enter. pContext = 0x%p\n", Context));

    pIF = (ARP1394_INTERFACE*) Context;

    // Validate context.
    //
    ASSERT(pIF->Hdr.Sig == MTAG_INTERFACE);

    LOCKOBJ(pIF, &sr);

    // Get the local HW address if we don't have it yet
    //
    {
        // TODO (this is from ip/atm -- I think in our case we can assume we have
        // it?)
    }
    
    //  Mark interface as open.
    //
    {
        ASSERT(CHECK_IF_IP_STATE(pIF, ARPIF_IPS_CLOSED));
        SET_IF_IP_STATE(pIF, ARPIF_IPS_OPEN);
        pIF->stats.LastChangeTime = GetTimeTicks();

    }

    // Record the fact that we're open, to verify that the IF is closed before
    // the IF block is deallocated.
    //
    DBG_ADDASSOC(&pIF->Hdr, NULL, NULL, ARPASSOC_IP_OPEN, "    IP IF Open\n", &sr);

    UNLOCKOBJ(pIF, &sr);

    RM_ASSERT_CLEAR(&sr);
    EXIT()
}



VOID
ArpIpClose(
    IN  PVOID                       Context
)
/*++

Routine Description:

    IP wants to stop using this Interface.

Arguments:

    Context     - Actually a pointer to our ARP1394_INTERFACE structure

--*/
{
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*) Context;
    PRM_TASK pTask;
    BOOLEAN fResumeTask = FALSE;
    ENTER("ArpIpClose", 0xdb8c8216)
    RM_DECLARE_STACK_RECORD(sr)

    TR_INFO(("Enter. pContext = 0x%p\n", Context));
    ASSERT(pIF->Hdr.Sig == MTAG_INTERFACE);

    LOCKOBJ(pIF, &sr);

    // if State has not opened, then do not close it.
    //
    pIF->stats.LastChangeTime= GetTimeTicks();

    if (!CHECK_IF_IP_STATE(pIF, ARPIF_IPS_CLOSED))
    {
        //
        //Set state to closed.
        //
    
        SET_IF_IP_STATE(pIF, ARPIF_IPS_CLOSED);

        // (delete "ARPASSOC_IP_OPEN" association added in arpIpOpen)
        //
        DBG_DELASSOC(&pIF->Hdr, NULL, NULL, ARPASSOC_IP_OPEN, &sr);

        // If there is a shutdown task pending, we notify it
        // Note: a task is protected by it's parent object's lock, which is
        // pIF in the case of the init and shutdown-interface tasks.
        //
        pTask = pIF->pActDeactTask;
        if (pTask && pTask->pfnHandler  ==  arpTaskDeactivateInterface)
        {
            TASK_DEACTIVATE_IF  *pShutdownTask = 
                                     (TASK_DEACTIVATE_IF    *) pTask;
            if (pShutdownTask->fPendingOnIpClose)
            {
                ASSERT(pIF->ip.Context == NULL);
                RmTmpReferenceObject(&pTask->Hdr, &sr);
                fResumeTask = TRUE;
            }
            else
            {
                // Hmm... unsolicited IpClose. We don't expect this currently.
                //
                ASSERT(FALSE);
                pIF->ip.Context = NULL;
            }
        }
    }
    UNLOCKOBJ(pIF, &sr);

    if (fResumeTask)
    {
        RmResumeTask(pTask, (UINT_PTR) 0, &sr);
        RmTmpDereferenceObject(&pTask->Hdr, &sr);
    }

    RM_ASSERT_CLEAR(&sr);
    EXIT()
}


UINT
ArpIpAddAddress(
    IN  PVOID                       Context,
    IN  UINT                        AddressType,
    IN  IP_ADDRESS                  IpAddress,
    IN  IP_MASK                     Mask,
    IN  PVOID                       Context2
)
/*++

Routine Description:

    The IP layer calls this when a new IP address (or block of IP addresses,
    as determined by AddressType) needs to be added to an Interface.

    We could see any of four address types: Local, Multicast, Broadcast
    and Proxy ARP. In the case of Proxy ARP, the address along with the mask
    can specify a block of contiguous IP addresses for which this host acts
    as a proxy. Currently, we only support the "Local", "Broadcast", and
    "Multicast" types.

Arguments:

    Context         - Actually a pointer to our structure
    AddressType     - Type of address(es) being added.
    IpAddress       - Address to be added.
    Mask            - For the above.
    Context2        - Additional context (We ignore this)

Return Value:

    TRUE if successful, FALSE otherwise.

--*/
{
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*) Context;
    ENTER("ArpIpAddAddress", 0xd6630961)
    INT fCreated = FALSE;
    ARPCB_LOCAL_IP *pLocalIp = NULL;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    IP_STATUS   IpStatus;
    RM_DECLARE_STACK_RECORD(sr)

    TR_INFO(("Enter. pIF = 0x%p\n", pIF));
    ASSERT(pIF->Hdr.Sig == MTAG_INTERFACE);
    LOCKOBJ(pIF, &sr);

    // We're not yet in the open state -- we're "opening", so we don't assert...
    // ASSERT(!CHECK_IF_OPEN_STATE(pIF, ARPIF_CLOSED));

    do
    {
        //
        // Note: we could just as well have done the initialiation as part of
        // the creation of the LocalIpObject itself, by passing in all the
        // required initialization params in the pvCreateParams arg to
        // RmLookupObjectInGroup. Instead we choose to do the initialization
        // ourselves. Things are more explicit this way.
        //

        // Unfortunately, to do this we must first validate the args...
        //
        if (AddressType != LLIP_ADDR_BCAST &&
            AddressType != LLIP_ADDR_MCAST &&
            AddressType != LLIP_ADDR_LOCAL)
        {
            break;
        }

        Status = RmLookupObjectInGroup(
                            &pIF->LocalIpGroup,
                            RM_CREATE,
                            (PVOID) ULongToPtr (IpAddress),             // pKey
                            (PVOID) ULongToPtr (IpAddress),             // pvCreateParams
                            &(PRM_OBJECT_HEADER)pLocalIp,
                            &fCreated,
                            &sr
                            );
        if (FAIL(Status)) break;

        //
        // NOTE: we already have claimed the pIF lock, which
        // which is the same as the pIF lock.
        //
        RM_ASSERT_SAME_LOCK_AS_PARENT(pLocalIp);

        // (Dbg only) Change lock scope from pIF to pLocalIp.
        //
        RmDbgChangeLockScope(
            &pIF->Hdr,
            &pLocalIp->Hdr,
            0x9cbc0b52,             // LocID
            &sr
            );

        if (fCreated)
        {

            if (AddressType == LLIP_ADDR_BCAST)
            {
                // Update the interface's broadcast address...
                //
                pIF->ip.BroadcastAddress = IpAddress;
            }
            else if (AddressType == LLIP_ADDR_LOCAL)
            {
                // Update the interface's default local IP address.
                // TODO: need to find another one if this address is removed.
                //
                pIF->ip.DefaultLocalAddress = IpAddress;
            }



            Status = arpInitializeLocalIp(
                    pLocalIp,
                    AddressType,
                    IpAddress,
                    Mask,
                    Context2,
                    &sr
                    );
            //
            // pLocalIp's lock is released above (which is actually the IF lock).
            //
            RM_ASSERT_NOLOCKS(&sr);
        }
        else
        {
            //
            // Hmm... this IP address already existed. Apparently it's possible for
            // MCAST addreses (IP/ATM arp module dealt with this for the MCAST case).
            // We don't special-case LOCAL/BCAST/MCAST addresses at this stage,
            // so we support multiple adds for all types of local IP addresses.
            //
            ASSERTEX(pLocalIp->AddAddressCount>0, pLocalIp);
            pLocalIp->AddAddressCount++;
        }

        RmTmpDereferenceObject(&pLocalIp->Hdr, &sr);

    } while (FALSE);

    TR_INFO((
            "IF 0x%p, Type %d, Addr %d.%d.%d.%d, Mask 0x%p, pLocIp 0x%p, Ret %d\n",
            pIF,
            AddressType,
            ((PUCHAR)(&IpAddress))[0],
            ((PUCHAR)(&IpAddress))[1],
            ((PUCHAR)(&IpAddress))[2],
            ((PUCHAR)(&IpAddress))[3],
            Mask, pLocalIp, !FAIL(Status)));

    RmUnlockAll(&sr);

    RM_ASSERT_CLEAR(&sr);
    EXIT()

    //
    // Translate Ndis Status to IPStatus
    //
    if (NDIS_STATUS_PENDING == Status)
    {
        IpStatus = IP_PENDING;
    }
    else
    {
        //            
        // If we are not going to pend, then IpStatus should return 1 in the success case and
        // 0 in the failure case
        //
        IpStatus = (!FAIL(Status));
    }

    return IpStatus;
}


UINT
ArpIpDelAddress(
    IN  PVOID                       Context,
    IN  UINT                        AddressType,
    IN  IP_ADDRESS                  IpAddress,
    IN  IP_MASK                     Mask
)
/*++

Routine Description:

    This is called from the IP layer when an address added via ArpIpAddAddress
    is to be deleted.

    Assumption: the given address was successfully added earlier.

Arguments:

    Context         - Actually a pointer to our Interface structure
    AddressType     - Type of address(es) being deleted.
    IpAddress       - Address to be deleted.
    Mask            - For the above.

Return Value:

    TRUE if successful, FALSE otherwise.

--*/
{
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*) Context;
    ENTER("ArpIpDelAddress", 0xd6630961)
    ARPCB_LOCAL_IP *pLocalIp = NULL;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    RM_DECLARE_STACK_RECORD(sr)

    TR_INFO(("Enter. pIF = 0x%p\n", Context));
    ASSERT(pIF->Hdr.Sig == MTAG_INTERFACE);

#if OBSOLETE // See ArpIpAddAddress
    //
    // WARNING: We SHOULD NOT grab the IF lock, because we request that
    // the pLocalIp's lock be grabbed in RmLookupObjectInGroup below,
    // AND the pLocalIp's lock is actually the same as the IF lock.
    // (This is asserted later on below).
    // So obviously we can't get the IF lock here! (And we don't need to either).
    //
#endif // OBSOLETE

    LOCKOBJ(pIF, &sr);

    ASSERT(!CHECK_IF_IP_STATE(pIF, ARPIF_IPS_CLOSED));

    do
    {

        Status = RmLookupObjectInGroup(
                            &pIF->LocalIpGroup,
                            0,                   // Flags
                            (PVOID) ULongToPtr (IpAddress),  // pKey
                            NULL,                // pvCreateParams
                            &(PRM_OBJECT_HEADER)pLocalIp,
                            NULL, // pfCreated
                            &sr
                            );
        if (FAIL(Status))
        {
            UNLOCKOBJ(pIF, &sr);
            break;
        }

        //
        // NOTE: we have the pLocalIp lock, which is the same as the pIF lock.
        //
        RM_ASSERT_SAME_LOCK_AS_PARENT(pLocalIp);

        // (Dbg only) Change lock scope from pIF to pLocalIp.
        //
        RmDbgChangeLockScope(
            &pIF->Hdr,
            &pLocalIp->Hdr,
            0x188ed5b3,         // LocID
            &sr
            );

        if (pLocalIp->AddAddressCount <= 1)
        {
            ASSERTEX(pLocalIp->AddAddressCount == 1, pLocalIp);

            arpUnloadLocalIp(
                    pLocalIp,
                    &sr
                    );
            //
            // pLocalIp's lock is released above.
            //
            RM_ASSERT_NOLOCKS(&sr);
        }
        else
        {
            pLocalIp->AddAddressCount--;
            UNLOCKOBJ(pLocalIp, &sr);
        }

        RmTmpDereferenceObject(&pLocalIp->Hdr, &sr);

    } while (FALSE);

    TR_INFO((
            "IF 0x%p, Type %d, Addr %d.%d.%d.%d, Mask 0x%p, pLocIp 0x%p, Ret %d\n",
            pIF,
            AddressType,
            ((PUCHAR)(&IpAddress))[0],
            ((PUCHAR)(&IpAddress))[1],
            ((PUCHAR)(&IpAddress))[2],
            ((PUCHAR)(&IpAddress))[3],
            Mask, pLocalIp, !FAIL(Status)));

    RM_ASSERT_CLEAR(&sr);
    EXIT()
    return !FAIL(Status);
}


NDIS_STATUS
ArpIpMultiTransmit(
    IN  PVOID                       Context,
    IN  PNDIS_PACKET *              pNdisPacketArray,
    IN  UINT                        NumberOfPackets,
    IN  IP_ADDRESS                  Destination,
    IN  RouteCacheEntry *           pRCE        OPTIONAL,
    IN  void *                  ArpCtxt
)
/*++

    TODO: implement send array-of-packets. Currenty we just call
    ArpIpTransmit multiple times. We'll gain a few cycles by processing
    all at once, although it's not going to be a big gain, because we're pretty
    fast with the single-packet case, provided the RCE is valid.

Routine Description:

    This is called from the IP layer when it has a sequence of datagrams,
    each in the form of an NDIS buffer chain, to send over an Interface.

Arguments:

    Context             - Actually a pointer to our Interface structure
    pNdisPacketArray    - Array of Packets to be sent on this Interface
    NumberOfPackets     - Length of array
    Destination         - IP address of next hop for this packet
    pRCE                - Optional pointer to Route Cache Entry structure.

Return Value:

    NDIS_STATUS_PENDING if all packets were queued for transmission.
    If one or more packets "failed", we set the packet status to reflect
    what happened to each, and return NDIS_STATUS_FAILURE.

--*/
{
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    PNDIS_PACKET *      ppNdisPacket;

    for (ppNdisPacket = pNdisPacketArray;
         NumberOfPackets > 0;
         NumberOfPackets--, ppNdisPacket++)
    {
        PNDIS_PACKET            pNdisPacket;

        pNdisPacket = *ppNdisPacket;
        NDIS_SET_PACKET_STATUS(pNdisPacket, NDIS_STATUS_PENDING);
        ASSERTEX(pNdisPacket->Private.Head != NULL, pNdisPacket);

        Status = ArpIpTransmit(
                        Context,
                        *ppNdisPacket,
                        Destination,
                        pRCE
                        ,NULL
                        );

        if (Status != NDIS_STATUS_PENDING)
        {
            NDIS_SET_PACKET_STATUS(*ppNdisPacket, Status);
            break;
        }
    }

    return Status;
}


NDIS_STATUS
ArpIpTransmit(
    IN  PVOID                       Context,
    IN  PNDIS_PACKET                pNdisPacket,
    IN  IP_ADDRESS                  Destination,
    IN  RouteCacheEntry *           pRCE        OPTIONAL,
    IN  void *                  ArpCtxt
)
/*++

    HOT PATH
    
Routine Description:

    This is called from the IP layer when it has a datagram (in the form of
    an NDIS buffer chain) to send over an Interface.

    The destination IP address is passed to us in this routine, which may
    or may not be the final destination for the packet. 

    The Route Cache Entry is created by the IP layer, and is used to speed
    up our lookups. An RCE, if specified, uniquely identifies atleast the
    IP destination for this packet. The RCE contains space for the ARP layer
    to keep context information about this destination. When the first packet
    goes out to a Destination, our context info in the RCE will be NULL, and
    we search the ARP Table for the matching IP Entry. However, we then fill
    our context info (pointer to IP Entry) in the RCE, so that subsequent
    transmits aren't slowed down by an IP address lookup.

Arguments:

    Context             - Actually a pointer to our Interface structure
    pNdisPacket         - Packet to be sent on this Interface
    Destination         - IP address of next hop for this packet
    pRCE                - Optional pointer to Route Cache Entry structure.

Return Value:

    Status of the transmit: NDIS_STATUS_SUCCESS, NDIS_STATUS_PENDING, or
    a failure.

--*/
{
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*) Context;
    ARP1394_ADAPTER * pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF );
    NDIS_STATUS Status;
    REMOTE_DEST_KEY        DestinationKey;
    ARP_INIT_REENTRANCY_COUNT()
    ENTER("IfTransmit", 0x46f1973e)

    ARP_INC_REENTRANCY();
    ASSERT_VALID_INTERFACE(pIF);

    // IP does sometimes call this function before we set our state to OPEN,
    // so this is an incorrect assert...
    // ASSERT(!CHECK_IF_IP_STATE(pIF, ARPIF_IPS_CLOSED));

    TR_INFO((
        "pIf 0x%p, Pkt 0x%p, Dst 0x%p, pRCE 0x%p\n",
        pIF, pNdisPacket, Destination, pRCE));

    DBGMARK(0xf87d7fff);
    NdisInterlockedIncrement (&ArpSends);

    // Since we don't hold any locks, this check is approximate, but it should
    // prevent lots of useless activity while we're trying to shutdown.
    //
    // Check for not Inited Or Low Power
    if (!CHECK_IF_PRIMARY_STATE(pIF, ARPIF_PS_INITED) || 
        (! CHECK_POWER_STATE(pAdapter, ARPAD_POWER_NORMAL) ))

    {
        TR_INFO(("Failing ArpIpTransmit because pIF 0x%p is closing.\n", pIF));

        ARP_DEC_REENTRANCY();
        NdisInterlockedIncrement (&ArpSendCompletes);
        NdisInterlockedIncrement (&ArpSendFailure);
        return NDIS_STATUS_FAILURE;                             // EARLY_RETURN
    }

#define LOGSTATS_TotSends(_pIF, _pNdisPacket) \
    NdisInterlockedIncrement(&((_pIF)->stats.sendpkts.TotSends))

#define LOGSTATS_SetPktTimestamp(_pIF, _pNdisPacket)                    \
    {                                                                   \
        LARGE_INTEGER liTemp = KeQueryPerformanceCounter(NULL);         \
        *(PULONG) ((_pNdisPacket)->WrapperReservedEx) = liTemp.LowPart; \
    }

    LOGSTATS_TotSends(pIF, pNdisPacket);
    LOGSTATS_SetPktTimestamp(pIF, pNdisPacket);

    //
    // If there is a RCE, we'll try to quickly get all the information we need
    // and send off the packet. If we can't do this, we resort to the 
    //  "slow send path" (call arpIpSlowtransmit)...
    //
    if (pRCE != NULL)
    {
        ARP_RCE_CONTEXT *   pArpRceContext;
        ARPCB_REMOTE_IP *   pRemoteIp;
        
        pArpRceContext =  ARP_OUR_CTXT_FROM_RCE(pRCE);

        ARP_FASTREADLOCK_IF_SEND_LOCK(pIF);

        pRemoteIp =  pArpRceContext->pRemoteIp;

        //
        // Validate the Remote Ip. If it not meant for this packet
        // fall back to the slow path
        //
        if (pRemoteIp != NULL && pRemoteIp->IpAddress == Destination)
        {
            ARPCB_DEST      *   pDest;

            pDest = pRemoteIp->pDest;
            if (pDest != NULL )
            {
                //
                // Note: pDest->sendinfo is protected by the IF send lock.
                //
                if (ARP_CAN_SEND_ON_DEST(pDest))
                {

#define LOGSTATS_FastSends(_pIF, _pNdisPacket) \
    NdisInterlockedIncrement(&((_pIF)->stats.sendpkts.FastSends))

                    LOGSTATS_FastSends(pIF, pNdisPacket);

                    arpSendIpPkt(pIF, pDest, pNdisPacket);
                    //
                    // IF Send lock released above.

                    ARP_DEC_REENTRANCY();
                    return NDIS_STATUS_PENDING;                 // EARLY RETURN
                }
            }
        }
        else
        {
            // if we have a mismatched RCE , then the RCE should be ignored
            // i,e. not be propagated to the SlowIpTransmit.
            //
            if (pRemoteIp != NULL && pRemoteIp->IpAddress != Destination)
            {
                pRCE = NULL;
            }
            
        }

        //
        // If we get here, it's on to slow path...
        //
        ARP_FASTUNLOCK_IF_SEND_LOCK(pIF);

    }

    // The slow path...
    //
    REMOTE_DEST_KEY_INIT(&DestinationKey);
    DestinationKey.IpAddress = Destination;
    Status = arpSlowIpTransmit(
                    pIF,
                    pNdisPacket,
                    DestinationKey,
                    pRCE
                    );

    if (Status != NDIS_STATUS_PENDING)
    {
        LOGSTATS_SendFifoCounts(pIF, pNdisPacket, Status);
    }

    ARP_DEC_REENTRANCY();
    EXIT()

    return Status;
}


NDIS_STATUS
ArpIpTransfer(
    IN  PVOID                       Context,
    IN  NDIS_HANDLE                 Context1,
    IN  UINT                        ArpHdrOffset,
    IN  UINT                        ProtoOffset,
    IN  UINT                        BytesWanted,
    IN  PNDIS_PACKET                pNdisPacket,
    OUT PUINT                       pTransferCount
)
/*++

Routine Description:

    This routine is called from the IP layer in order to copy in the
    contents of a received packet that we indicated up earlier. The
    context we had passed up in the receive indication is given back to
    us, so that we can identify what it was that we passed up.

    We simply call NDIS to do the transfer.

Arguments:

    Context             - Actually a pointer to our Interface structure
    Context1            - Packet context we had passed up (pointer to NDIS packet)
    ArpHdrOffset        - Offset we had passed up in the receive indicate
    ProtoOffset         - The offset into higher layer protocol data to start copy from
    BytesWanted         - The amount of data to be copied
    pNdisPacket         - The packet to be copied into
    pTransferCount      - Where we return the actual #bytes copied

Return Value:

    NDIS_STATUS_SUCCESS always.

--*/
{
    ENTER("IfTransfer", 0xa084562c)

    TR_INFO((
     "Ctx 0x%p, Ctx1 0x%p, HdrOff %d, ProtOff %d, Wanted %d, Pkt 0x%p\n",
            Context,
            Context1,
            ArpHdrOffset,
            ProtoOffset,
            BytesWanted,
            pNdisPacket));

    NdisCopyFromPacketToPacket(
            pNdisPacket,
            0,
            BytesWanted,
            (PNDIS_PACKET)Context1,
            ArpHdrOffset+ProtoOffset,
            pTransferCount
            );

    EXIT()
    return NDIS_STATUS_SUCCESS;
}


VOID
ArpIpInvalidate(
    IN  PVOID                       Context,
    IN  RouteCacheEntry *           pRCE
)
/*++

Routine Description:

    This routine is called from the IP layer to invalidate a Route Cache
    Entry. If this RCE is associated with one of our IP Entries, unlink
    it from the list of RCE's pointing to that IP entry.

Arguments:

    Context             - Actually a pointer to our Interface structure
    pRCE                - Pointer to Route Cache Entry being invalidated.

--*/
{
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*) Context;
    ENTER("ArpIpInvalidate", 0xee77fb09)
    RM_DECLARE_STACK_RECORD(sr)

    TR_INFO(("Enter. pIF = 0x%p pRCE=0x%p\n", pIF, pRCE));

    ASSERT_VALID_INTERFACE(pIF);
    ASSERT(pRCE != NULL);

    DBGMARK(0xe35c780d);

    ARP_WRITELOCK_IF_SEND_LOCK(pIF, &sr);
    arpDelRce(pRCE, &sr);
    ARP_UNLOCK_IF_SEND_LOCK(pIF, &sr);

    RM_ASSERT_CLEAR(&sr);
    EXIT()


}


INT
ArpIpQueryInfo(
    IN      PVOID                   Context,
    IN      TDIObjectID *           pID,
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    IN      PVOID                   QueryContext
)
/*++

Routine Description:

    This is called from the IP layer to query for statistics or other
    information about an interface.

Arguments:

    Context                 - Actually a pointer to our Interface
    pID                     - Describes the object being queried
    pNdisBuffer             - Space for returning information
    pBufferSize             - Pointer to size of above. On return, we fill
                              it with the actual bytes copied.
    QueryContext            - Context value pertaining to the query.

Return Value:

    TDI Status code.

--*/
{
    UINT                    EntityType;
    UINT                    Instance;
    INT                     ReturnStatus;
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*) Context;
    ENTER("ArpIpQueryInfo", 0x15059be1)
    RM_DECLARE_STACK_RECORD(sr)


    EntityType = pID->toi_entity.tei_entity;
    Instance = pID->toi_entity.tei_instance;


    TR_VERB((
        "IfQueryInfo: pIf 0x%p, pID 0x%p, pBuf 0x%p, Size %d, Ent %d, Inst %d\n",
            pIF, pID, pNdisBuffer, *pBufferSize, EntityType, Instance));
    ASSERT(pIF->Hdr.Sig == MTAG_INTERFACE);

    //
    //  Initialize
    //
    ReturnStatus = TDI_INVALID_PARAMETER;

    LOCKOBJ(pIF, &sr);

    do
    {
        if (!CHECK_IF_PRIMARY_STATE(pIF, ARPIF_PS_INITED))
        {
            if (!CHECK_IF_ACTIVE_STATE(pIF, ARPIF_AS_ACTIVATING))
            {
                ReturnStatus = TDI_INVALID_REQUEST;
                break;
            }
        }

        //
        //  Check the Entity and Instance values.
        //

        if ((EntityType != AT_ENTITY || Instance != pIF->ip.ATInstance) &&
            (EntityType != IF_ENTITY || Instance != pIF->ip.IFInstance))
        {
            TR_INFO(
                ("Mismatch: Entity %d, AT_ENTITY %d, Inst %d, IF AT Inst %d, IF_ENTITY %d, IF IF Inst %d\n",
                    EntityType,
                    AT_ENTITY,
                    Instance,
                    pIF->ip.ATInstance,
                    IF_ENTITY,
                    pIF->ip.IFInstance
                ));

            ReturnStatus = TDI_INVALID_REQUEST;
            break;
        }


        TR_VERB(("QueryInfo: pID 0x%p, toi_type %d, toi_class %d, toi_id %d\n",
            pID, pID->toi_type, pID->toi_class, pID->toi_id));


        if (pID->toi_type != INFO_TYPE_PROVIDER)
        {
            TR_INFO(("toi_type %d != PROVIDER (%d)\n",
                    pID->toi_type,
                    INFO_TYPE_PROVIDER));

            break;
        }

        if (pID->toi_class == INFO_CLASS_GENERIC)
        {
            if (pID->toi_id == ENTITY_TYPE_ID)
            {
                ReturnStatus = arpQueryIpEntityId(
                                        pIF,
                                        EntityType,
                                        pNdisBuffer,
                                        pBufferSize,
                                        &sr
                                        );
            }
            break;
        }

        if (EntityType == AT_ENTITY)
        {
            //
            //  This query is for an Address Translation Object.
            //
            if (pID->toi_id == AT_MIB_ADDRXLAT_INFO_ID)
            {
                ReturnStatus = arpQueryIpAddrXlatInfo(
                                        pIF,
                                        pNdisBuffer,
                                        pBufferSize,
                                        &sr
                                        );
            }
            else if (pID->toi_id == AT_MIB_ADDRXLAT_ENTRY_ID)
            {
                ReturnStatus = arpQueryIpAddrXlatEntries(
                                        pIF,
                                        pNdisBuffer,
                                        pBufferSize,
                                        QueryContext,
                                        &sr
                                        );
            }
            else
            {
                ReturnStatus = TDI_INVALID_PARAMETER;
            }
            break;
        }

        if (    pID->toi_class == INFO_CLASS_PROTOCOL
            &&  pID->toi_id == IF_MIB_STATS_ID)
        {
            ReturnStatus = arpQueryIpMibStats(
                                        pIF,
                                        pNdisBuffer,
                                        pBufferSize,
                                        &sr
                                        );
        }
    }
    while (FALSE);

    if (    ReturnStatus != TDI_SUCCESS
         && ReturnStatus != TDI_BUFFER_OVERFLOW
         && ReturnStatus != TDI_INVALID_REQUEST)
    {
        //
        // This again preserves the semantics of QueryInfo from atmarpc.sys...
        //
        *pBufferSize = 0;
    }

    TR_VERB(("Returning 0x%p (%s), BufferSize %d\n",
                    ReturnStatus,
                    ((ReturnStatus == TDI_SUCCESS)? "SUCCESS": "FAILURE"),
                    *pBufferSize
            ));

    UNLOCKOBJ(pIF, &sr);
    RM_ASSERT_CLEAR(&sr);
    EXIT()

    return (ReturnStatus);
}


INT
ArpIpSetInfo(
    IN      PVOID                   Context,
    IN      TDIObjectID *           pID,
    IN      PVOID                   pBuffer,
    IN      UINT                    BufferSize
)
/*++

Routine Description:

    This is called from the IP layer to set the value of an object
    for an interface.

Arguments:
    Context                 - Actually a pointer to our Interface
    pID                     - Describes the object being set
    pBuffer                 - Value for the object
    BufferSize              - Size of above

Return Value:

    TDI Status code.

--*/
{
    ARP1394_INTERFACE *pIF = (ARP1394_INTERFACE*) Context;
    UINT Entity, Instance;
    IFEntry *pIFE = (IFEntry *) pBuffer;
    NTSTATUS ReturnStatus = TDI_INVALID_REQUEST;
    IPNetToMediaEntry *IPNME = NULL;

    ENTER("IpSetInfo", 0x05dabea3)
    RM_DECLARE_STACK_RECORD(sr)

    //
    // This code is taken from the tcpip Arp module with some changes to adjust 
    // it to arp1394's internal structures
    //
    // This code only supports deleting Arp Entries
    //

    Entity = pID->toi_entity.tei_entity;
    Instance = pID->toi_entity.tei_instance;


    do
    {

        // First, make sure it's possibly an ID we can handle.
        if (Entity != AT_ENTITY || Instance != pIF->ip.ATInstance) 
        {
            TR_INFO(
                ("Mismatch: Entity %d, AT_ENTITY %d, Inst %d, IF AT Inst %d, IF_ENTITY %d, IF IF Inst %d\n",
                    Entity,
                    AT_ENTITY,
                    Instance,
                    pIF->ip.ATInstance,
                    IF_ENTITY,
                    pIF->ip.IFInstance
                ));

            ReturnStatus = TDI_INVALID_REQUEST;
            break;
        }

                
        if (pID->toi_type != INFO_TYPE_PROVIDER) {
            ReturnStatus = TDI_INVALID_REQUEST;
            break;

        }

    
        if (pID->toi_id != AT_MIB_ADDRXLAT_ENTRY_ID ||
            BufferSize < sizeof(IPNetToMediaEntry)) 
        {
            ReturnStatus = TDI_INVALID_REQUEST;
            break;
        }            

        // He does want to set an ARP table entry. See if he's trying to
        // create or delete one.

        IPNME = (IPNetToMediaEntry *) pBuffer;

        if (IPNME->inme_type != INME_TYPE_INVALID) 
        {
        
            ReturnStatus = TDI_INVALID_REQUEST;
            break;

        }

        // We need to delete the IP address passed in the ipnme struct                        
        
        ReturnStatus = arpDelArpEntry (pIF, IPNME->inme_addr, &sr);
        

    }while (FALSE);            

    EXIT();
    return ReturnStatus; 
    
}



INT
ArpIpGetEList(
    IN      PVOID                   Context,
    IN      TDIEntityID *           pEntityList,
    IN OUT  PUINT                   pEntityListSize
)
/*++

Routine Description:

    This routine is called when the interface starts up, in order to
    assign all relevant Entity Instance numbers for an interface.
    The ARP1394 module belongs to the "AT" and "IF" types. The entity
    list is a list of <Entity type, Instance number> tuples that have
    been filled in by other modules.

    For each of the entity types we support, we find the largest
    instance number in use (by walking thru the Entity list), and
    assign to ourselves the next larger number in each case. Using
    these numbers, we append our tuples to the end of the Entity list,
    if there is enough space.

    W2K: we may find that our entries are already present, in which
    case we don't create new entries.


Arguments:

    Context                 - Actually a pointer to our ARP1394_INTERFACE
    pEntityList             - Pointer to TDI Entity list
    pEntityListSize         - Pointer to length of above list. We update
                              this if we add our entries to the list.

Return Value:

    TRUE if successful, FALSE otherwise.

--*/
{
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*) Context;
    UINT                EntityCount;    // Total elements in Entity list
    UINT                i;              // Iteration counter
    UINT                MyATInstance;   // "AT" Instance number we assign to ourselves
    UINT                MyIFInstance;   // "IF" Instance number we assign to ourselves
    INT                 ReturnValue;
    TDIEntityID *       pATEntity;      // Points to our AT entry
    TDIEntityID *       pIFEntity;      // Points to our IF entry
    ENTER("ArpIpGetEList", 0x8b5190e5)
    RM_DECLARE_STACK_RECORD(sr)

    ASSERT(pIF->Hdr.Sig == MTAG_INTERFACE);
    EntityCount = *pEntityListSize;
    pATEntity = NULL;
    pIFEntity = NULL;
    MyATInstance = MyIFInstance = 0;

    TR_INFO(("IfGetEList: pIf 0x%p, &pIF.ip 0x%p pList 0x%p, Cnt %d\n",
            pIF, &pIF->ip, pEntityList, EntityCount));

    LOCKOBJ(pIF, &sr);

    do
    {
        //
        //  Walk down the list, looking for AT/IF entries matching our
        //  instance values. Also remember the largest AT and IF instance
        //  values we see, so that we can allocate the next larger values
        //  for ourselves, in case we don't have instance values assigned.
        //
        for (i = 0; i < EntityCount; i++, pEntityList++)
        {
            //
            //  Skip invalid entries.
            //
            if (pEntityList->tei_instance == INVALID_ENTITY_INSTANCE)
            {
                continue;
            }

            if (pEntityList->tei_entity == AT_ENTITY)
            {
                if (pEntityList->tei_instance == pIF->ip.ATInstance)
                {
                    //
                    //  This is our AT entry.
                    //
                    pATEntity = pEntityList;
                }
                else
                {
                    if (MyATInstance < (pEntityList->tei_instance + 1))
                    {
                        MyATInstance = pEntityList->tei_instance + 1;
                    }
                }
            }
            else if (pEntityList->tei_entity == IF_ENTITY)
            {
                if (pEntityList->tei_instance == pIF->ip.IFInstance)
                {
                    //
                    //  This is our IF entry.
                    //
                    pIFEntity = pEntityList;
                }
                else
                {
                    if (MyIFInstance < (pEntityList->tei_instance + 1))
                    {
                        MyIFInstance = pEntityList->tei_instance + 1;
                    }
                }
            }
        }


        ReturnValue = TRUE;

        // WARNING: The following check is subtle -- we MUST set the instance
        // values to INVALID_ENTITY_INSTANCE when the interface is being
        // deactivated, but we MUST NOT do this if the interface is just opened
        // (ArpIpOpen called)  -- otherwise we could mess up the caller's state
        // to such an extent that a reboot is required. Basically our behaviour
        // here is what results in the proper acquiring AND release of instance IDs.
        //
        // So don't replace the following check by checking for
        // ARPIF_PS_INITED or ARPIF_IPS_OPEN or even ARPIF_PS_DEINITING.
        // The latter check (ARPIF_PS_DEINITING) would have been ok except for the
        // fact that the IF is deactivated/reactivated during ARPIF_PS_REINITING
        // as well, so the correct check is basically the one below...
        //
        //
        if(CHECK_IF_ACTIVE_STATE(pIF, ARPIF_AS_DEACTIVATING))
        {
            //
            // We're deactivating the interface, set values to invalid and
            // get out of here...
            //

            if (pATEntity)
            {
                pATEntity->tei_instance = INVALID_ENTITY_INSTANCE;
            }

            if (pIFEntity)
            {
                pIFEntity->tei_instance = INVALID_ENTITY_INSTANCE;
            }
            break;
        }

        //
        //  Update or create our Address Translation entry.
        //
        if (pATEntity)
        {
            //
            //  We found our entry, nothing to do...
            //
            TR_INFO(("YOWZA: Found existing AT entry.\n"));
        }
        else
        {
            //
            //  Grab an entry for ourselves...
            //
            TR_INFO(("YOWZA: Grabbing new AT entry 0x%lu.\n", MyATInstance));

            if (EntityCount >= MAX_TDI_ENTITIES)
            {
                ReturnValue = FALSE;
                break;
            }

            pEntityList->tei_entity = AT_ENTITY;
            pEntityList->tei_instance = MyATInstance;
            pIF->ip.ATInstance = MyATInstance;

            pEntityList++;
            (*pEntityListSize)++;
            EntityCount++;
        }

        //
        //  Update or create or IF entry.
        //
        if (pIFEntity)
        {
            //
            //  We found our entry, nothing to do...
            //
            TR_INFO(("YOWZA: Found existing IF entry.\n"));
        }
        else
        {
            //
            //  Grab an entry for ourselves.
            //
            TR_INFO(("YOWZA: Grabbing new IF entry 0x%lu.\n", MyIFInstance));

            if (EntityCount >= MAX_TDI_ENTITIES)
            {
                ReturnValue = FALSE;
                break;
            }

            pEntityList->tei_entity = IF_ENTITY;
            pEntityList->tei_instance = MyIFInstance;
            pIF->ip.IFInstance = MyIFInstance;

            pEntityList++;
            (*pEntityListSize)++;
            EntityCount++;
        }
    }
    while (FALSE);


    TR_INFO(
     ("IfGetEList: returning %d, MyAT %d, MyIF %d, pList 0x%p, Size %d\n",
        ReturnValue, MyATInstance, MyIFInstance, pEntityList, *pEntityListSize));

    UNLOCKOBJ(pIF, &sr);
    RM_ASSERT_CLEAR(&sr);
    EXIT()
    return (ReturnValue);
}



VOID
ArpIpPnPComplete(
    IN  PVOID                       Context,
    IN  NDIS_STATUS                 Status,
    IN  PNET_PNP_EVENT              pNetPnPEvent
)
/*++

Routine Description:

    This routine is called by IP when it completes a previous call
    we made to its PnP event handler. We complete the
    NDIS PNP notification that lead to this.

Arguments:

    Context                 - Actually a pointer to our ATMARP Interface
    Status                  - Completion status from IP
    pNetPnPEvent            - The PNP event

Return Value:

    None

--*/
{
    ENTER("ArpIpPnPComplete", 0x23b1941e)
    PARP1394_INTERFACE          pIF;

    pIF = (PARP1394_INTERFACE) Context;

    TR_INFO(("IfPnPComplete: IF 0x%p, Status 0x%p, Event 0x%p\n",
                    pIF, Status, pNetPnPEvent));

    if (pIF == NULL)
    {
        NdisCompletePnPEvent(
                    Status,
                    NULL,
                    pNetPnPEvent
                    );
    }
    else
    {
        PARP1394_ADAPTER pAdapter;
        ASSERT_VALID_INTERFACE(pIF);
        pAdapter = (PARP1394_ADAPTER) RM_PARENT_OBJECT(pIF);
        NdisCompletePnPEvent(
                Status,
                pAdapter->bind.AdapterHandle,
                pNetPnPEvent
                );
    }

    EXIT()
    return;
}


NDIS_STATUS         
ArpSendARPApi(
    void * pInterface, 
    IPAddr Destination, 
    void * pControlBlock
    )
/*++

Routine Description:

    This function is used by user mode components to ask us to 
    resolve an IP address.
    We Start a Task to do this. 

Arguments:

    Context                 - Actually a pointer to our Interface
    Dest                    - IP address to be resolved
    pControlBlock            - Used in completing the request

Return Value:

    None

--*/
{
    ENTER ("ArpResolveIP", 0xd631b91d)
    PARP1394_INTERFACE  pIF = (PARP1394_INTERFACE ) pInterface;
    PTASK_SEND_ARP_API  pSendArpTask = NULL;
    NDIS_STATUS         Status;
    RM_DECLARE_STACK_RECORD(sr)



    do
    {
        //
        // Let's start a resolution task and pend on it.
        //
        Status = arpAllocateTask(
                    &pIF->Hdr,                    // pParentObject
                    arpTaskSendARPApi,        // pfnHandler
                    0,                              // Timeout
                    "Task: SendARP API",       // szDescription
                    &(PRM_TASK)pSendArpTask ,
                    &sr
                    );
        if (FAIL(Status))
        {
            // Couldn't allocate task. We fail with STATUS_RESOURCES
            //
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        pSendArpTask->IPDest = Destination;
        pSendArpTask->pSendArpCB = pControlBlock;

        (VOID)RmStartTask(
                (PRM_TASK)pSendArpTask ,
                0, // UserParam unused
                &sr
                );
    
        Status = NDIS_STATUS_PENDING;

    } while (FALSE);

    return Status;
    EXIT()
}


NDIS_STATUS
arpTaskSendARPApi(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    This task is called because of a call to the iphlpapi SenArp

    It sends out an ARP. If the IP address is present on the network,
    it will convert it to a 48 bit MAC address and return the MAC 
    address.

Arguments:

Return Value:

    None

--*/
{
    ENTER("arpTaskSendARPApi", 0x7b7d5d9d)

    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*)RM_PARENT_OBJECT (pTask);
    PARPCB_REMOTE_IP        pRemoteIp = ((PTASK_CONFLICT_IP)pTask)->pRemoteIp;
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    BOOLEAN                 fDerefRemoteIp = FALSE;
    PTASK_SEND_ARP_API      pSendArpTask= (PTASK_SEND_ARP_API )pTask;
    PRM_TASK                pResolutionTask = NULL;

    enum
    {
        PEND_AddressResolutionComplete,
    };




    switch(Code)
    {
        case RM_TASKOP_START:
        {
            REMOTE_DEST_KEY        Destination;
            UINT                 fRemoteIpCreated = FALSE;
            REMOTE_DEST_KEY_INIT(&Destination);
    
            //
            // Check to see if there is already a ResolveLocalIp Address Task
            // on this LocalIp
            //
            LOCKOBJ(pIF,pSR);

            //
            //Create the Remote Ip structure that will be used during resolve.
            //
            Destination.IpAddress = pSendArpTask->IPDest;

             //
            // Should we acquire the lock
            //
           
            Status = RmLookupObjectInGroup(
                            &pIF->RemoteIpGroup,
                            RM_CREATE,
                            (PVOID) &Destination,
                            (PVOID) (&Destination),   // pCreateParams
                            (RM_OBJECT_HEADER**) &pRemoteIp,
                            &fRemoteIpCreated,                   // pfCreated  (unused)
                            pSR
                            );
            LOGSTATS_TotalArpCacheLookups(pIF, Status);

            if (FAIL(Status))
            {
                OBJLOG1(
                    pIF,
                    "Couldn't lookup/create RemoteIpp entry with addr 0x%lx\n",
                    Destination.IpAddress
                    );
                Status = NDIS_STATUS_FAILURE;
                pRemoteIp = NULL;
                
                break;
            }
            

            pSendArpTask->fRemoteIpCreated = (fRemoteIpCreated == TRUE);

            fDerefRemoteIp  = TRUE;

            // First check if pRemoteIp is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pRemoteIp))
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            // pRemoteIp is allocated. Now check to see if we already have a destination
            //
            if (CHECK_REMOTEIP_RESOLVE_STATE(pRemoteIp,ARPREMOTEIP_RESOLVED)== TRUE)
            {
                ARPCB_DEST *pDest = pRemoteIp->pDest;
                ASSERT (pDest != NULL);
                ASSERT (pDest->Params.HwAddr.AddressType == NIC1394AddressType_FIFO);
                pSendArpTask->UniqueID = pDest->Params.HwAddr.FifoAddress.UniqueID;

                Status = NDIS_STATUS_SUCCESS;
                break;
            }
                
            
            // Now we check if there is an UnloadTask bound to pRemoteIP. This
            // is an IMPORTANT check -- because the unload task expects that
            // once it is bound to pRemoteIp, no new pSendPktsTasks will bind
            // themselves to pRemoteIp -- see arpTaskUnloadRemoteIp.
            //
            if (pRemoteIp->pUnloadTask != NULL)
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            //
            // If there is a resolution task going, we  wait for it to complete.
            //

        #if RM_EXTRA_CHECKING
            RmLinkObjectsEx(
                &pRemoteIp->Hdr,
                &pTask->Hdr,
                0x34222bb1,
                ARPASSOC_REMOTEIP_RESOLVE_TASK,
                "    REMOTE_IP of 0x%p (%s)\n",
                ARPASSOC_TASK_TO_RESOLVE_REMOTEIP,
                "    TASK of 0x%p (%s)\n",
                pSR
                );
        #else // !RM_EXTRA_CHECKING
            RmLinkObjects(&pRemoteIp->Hdr, &pTask->Hdr, pSR);
        #endif // !RM_EXTRA_CHECKING

            pSendArpTask->pRemoteIp = pRemoteIp;
            pSendArpTask->fLinkedRemoteIp = TRUE;

            //
            // Let's start the address resolution task!
            //

            DBGMARK(0xd0da6726);

            //
            // Let's start a resolution task and pend on it.
            //
            Status = arpAllocateTask(
                        &pRemoteIp->Hdr,                    // pParentObject
                        arpTaskResolveIpAddress,        // pfnHandler
                        0,                              // Timeout
                        "Task: ResolveIpAddress",       // szDescription
                        &pResolutionTask,
                        pSR
                        );
            if (FAIL(Status))
            {
                // Couldn't allocate task. We fail with STATUS_RESOURCES
                //
                Status = NDIS_STATUS_RESOURCES;
            }
            else
            {
                UNLOCKOBJ(pIF,pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_AddressResolutionComplete,
                    pResolutionTask,
                    pSR
                    );

                (VOID)RmStartTask(
                        pResolutionTask,
                        0, // UserParam unused
                        pSR
                        );
            
                Status = NDIS_STATUS_PENDING;
            }
            break;
            
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_AddressResolutionComplete:
                {
                    
                        
                    ARPCB_DEST *pDest = pRemoteIp->pDest;
                    
                    ASSERT (pSendArpTask->UniqueID == 0);
                    //
                    // If we have a destination, then extract the Unique ID of that destination.
                    // We do not look at the state of the ResolveIpAddress Task
                    //
                    if (pDest != NULL &&                // The Resolve Task found a Destination
                        pDest->Params.HwAddr.AddressType == NIC1394AddressType_FIFO) // Dest is a Fifo
                    {
                        pSendArpTask->UniqueID = pDest->Params.HwAddr.FifoAddress.UniqueID;
                    }
                
                    Status = NDIS_STATUS_SUCCESS;
                    
                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {

            LOCKOBJ(pIF,pSR);
            
            if (pSendArpTask->fLinkedRemoteIp == TRUE)
            {
                #if RM_EXTRA_CHECKING
                    RmUnlinkObjectsEx(
                        &pRemoteIp->Hdr,
                        &pTask->Hdr,
                        0x5ad067aa,
                        ARPASSOC_REMOTEIP_RESOLVE_TASK,
                        ARPASSOC_TASK_TO_RESOLVE_REMOTEIP,
                        pSR
                        );
                #else // !RM_EXTRA_CHECKING
                    RmUnlinkObjects(&pRemoteIp->Hdr, &pTask->Hdr, pSR);
                #endif // !RM_EXTRA_CHECKING
            }

            UNLOCKOBJ(pIF,pSR);

            //
            // If the object is still alive and we were responsible for create it 
            // then delete the object.
            //
            if ((pSendArpTask->fRemoteIpCreated == TRUE) &&
                (!RM_IS_ZOMBIE(pRemoteIp))) 
            {
                PRM_TASK pUnloadTask= NULL;

                Status = arpAllocateTask(
                            &pRemoteIp->Hdr,                    // pParentObject
                            arpTaskUnloadRemoteIp,        // pfnHandler
                            0,                              // Timeout
                            "Task: Unload IP address",       // szDescription
                            &pUnloadTask,
                            pSR
                            );
                if (!FAIL(Status))
                {
                    (VOID)RmStartTask(
                            pUnloadTask,
                            0, // UserParam unused
                            pSR
                            );
                

                }
            }

            //
            // Complete the Send Arp Request
            //
            do
            {
                //
                // We check to see if a Unique ID has been filled in.
                //
                ENetAddr DestAddr;
                if (pSendArpTask->UniqueID == 0)
                {
                    pSendArpTask->IpStatus = IP_DEST_NET_UNREACHABLE;
                    break;
                }

                if (pSendArpTask->pSendArpCB->PhyAddrLen < sizeof (ENetAddr))
                {
                    pSendArpTask->IpStatus = IP_BUF_TOO_SMALL;
                    break;
                }

                //
                // Get the Ethernet version of the Unique ID
                //
                ASSERT(pSendArpTask->pSendArpCB->PhyAddr != NULL);
                nicGetMacAddressFromEuid(&pSendArpTask->UniqueID, &DestAddr);

                NdisMoveMemory(pSendArpTask->pSendArpCB->PhyAddr,&DestAddr, sizeof(DestAddr));
                pSendArpTask->pSendArpCB->PhyAddrLen = sizeof(ENetAddr);
              
                pSendArpTask->IpStatus = IP_SUCCESS;

            } while (FALSE);

            pSendArpTask->pSendArpCB->status = pSendArpTask->IpStatus ;

            ASSERT(pSendArpTask->pSendArpCB->CompletionRtn != NULL);

            pSendArpTask->pSendArpCB->CompletionRtn (pSendArpTask->pSendArpCB,pSendArpTask->IpStatus );

            
            
        }
        break; // RM_TASKOP_END:

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)
        
    RmUnlockAll(pSR);

    if (fDerefRemoteIp== TRUE)
    {
        RmTmpDereferenceObject(&pRemoteIp->Hdr, pSR);
    }


    return Status;
}





NDIS_STATUS
arpTaskResolveLocalIp(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    This routine is called to detect an IP address collision.
    When an IP address is set on this interface, it will attempt
    to resolve the IP address. If no machine responds to the ARP,
    it will succeed the AddAddress.

Arguments:

Return Value:


--*/

{
    ENTER("arpTaskResolveLocalIp", 0x42e587f3)

    ARPCB_LOCAL_IP *        pLocalIp = (ARPCB_LOCAL_IP *)RM_PARENT_OBJECT (pTask);
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*)RM_PARENT_OBJECT (pLocalIp);
    PARPCB_REMOTE_IP        pRemoteIp = ((PTASK_CONFLICT_IP)pTask)->pRemoteIp;
    BOOLEAN                 fFailIpAddAddress = FALSE;
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    BOOLEAN                 fDerefRemoteIp = FALSE;
    PTASK_CONFLICT_IP       pConflictTask = (PTASK_CONFLICT_IP)pTask;
    enum
    {
        PEND_AddressResolutionComplete 
    };




    switch(Code)
    {
        case RM_TASKOP_START:
        {
            REMOTE_DEST_KEY        Destination;
            UINT                 fRemoteIpCreated = FALSE;
            REMOTE_DEST_KEY_INIT(&Destination);
    
            //
            // Check to see if there is already a ResolveLocalIp Address Task
            // on this LocalIp
            //
            LOCKOBJ(pLocalIp,pSR);

            if (pLocalIp->pConflictTask == NULL)
            {
                // if the current task is going to become the offical task, then
                // add a DbgAssoc
                //
                pLocalIp->pConflictTask = pTask;

            }
            else
            {
                Status = NDIS_STATUS_FAILURE;
                break;
            }

     
            //
            //Create the Remote Ip structure that will be used during resolve.
            //
            Destination.IpAddress = pLocalIp->IpAddress;

            //
            // Should we acquire the lock
            //
           
            Status = RmLookupObjectInGroup(
                            &pIF->RemoteIpGroup,
                            RM_CREATE,
                            (PVOID) &Destination,
                            (PVOID) (&Destination),   // pCreateParams
                            (RM_OBJECT_HEADER**) &pRemoteIp,
                            &fRemoteIpCreated,                   // pfCreated  (unused)
                            pSR
                            );
            LOGSTATS_TotalArpCacheLookups(pIF, Status);

            if (FAIL(Status))
            {
                OBJLOG1(
                    pIF,
                    "Couldn't lookup/create RemoteIpp entry with addr 0x%lx\n",
                    Destination.IpAddress
                    );
                Status = NDIS_STATUS_FAILURE;
                pRemoteIp = NULL;
                
                break;
            }
            
            pConflictTask->fRemoteIpCreated = (fRemoteIpCreated==TRUE); 
            fDerefRemoteIp  = TRUE;

            // First check if pRemoteIp is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pRemoteIp))
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            // pRemoteIp is allocated. Now check if there is already a
            // send-pkts task attached to pRemoteIp.
            //

            // Now we check if there is an UnloadTask bound to pRemoteIP. This
            // is an IMPORTANT check -- because the unload task expects that
            // once it is bound to pRemoteIp, no new pSendPktsTasks will bind
            // themselves to pRemoteIp -- see arpTaskUnloadRemoteIp.
            //
            if (pRemoteIp->pUnloadTask != NULL)
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }


            //
            // If there is a resolution task going, we  wait for it to complete.
            //
            ASSERT (pRemoteIp->pResolutionTask == NULL);

            //
            // From this point on the Ref on the pRemote Ip will be derefed in this task.
            //
            pConflictTask->fLinkedRemoteIp= TRUE;
            
        #if RM_EXTRA_CHECKING
            RmLinkObjectsEx(
                &pRemoteIp->Hdr,
                &pTask->Hdr,
                0x34222bb1,
                ARPASSOC_REMOTEIP_RESOLVE_TASK,
                "    REMOTE_IP of 0x%p (%s)\n",
                ARPASSOC_TASK_TO_RESOLVE_REMOTEIP,
                "    TASK of 0x%p (%s)\n",
                pSR
                );
        #else // !RM_EXTRA_CHECKING
            RmLinkObjects(&pRemoteIp->Hdr, &pTask->Hdr, pSR);
        #endif // !RM_EXTRA_CHECKING

            pConflictTask->pRemoteIp = pRemoteIp; 


            if (pRemoteIp->pDest == NULL)
            {
                //
                // Let's start the address resolution task!
                //
                PRM_TASK pResolutionTask;
    
                DBGMARK(0xd0da6726);

                //
                // Let's start a resolution task and pend on it.
                //
                Status = arpAllocateTask(
                            &pRemoteIp->Hdr,                    // pParentObject
                            arpTaskResolveIpAddress,        // pfnHandler
                            0,                              // Timeout
                            "Task: ResolveIpAddress",       // szDescription
                            &pResolutionTask,
                            pSR
                            );
                if (FAIL(Status))
                {
                    // Couldn't allocate task. We fail with STATUS_RESOURCES
                    //
                    Status = NDIS_STATUS_RESOURCES;
                }
                else
                {
                    UNLOCKOBJ(pLocalIp,pSR);
                    RmPendTaskOnOtherTask(
                        pTask,
                        PEND_AddressResolutionComplete,
                        pResolutionTask,
                        pSR
                        );

    
                    (VOID)RmStartTask(
                            pResolutionTask,
                            0, // UserParam unused
                            pSR
                            );
                
                    Status = NDIS_STATUS_PENDING;
                }
            }
            else
            {
                //
                // if we already have a pDest, then we move on to the next stage
                // we do a fake suspend/resume so we move on to the next stage.
                //
                RmSuspendTask(pTask, PEND_AddressResolutionComplete, pSR);
                UNLOCKOBJ(pLocalIp, pSR);
                RmResumeTask(pTask, NDIS_STATUS_SUCCESS, pSR);

            }
          
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_AddressResolutionComplete:
                {
                    ARPCB_DEST *pDest = NULL;

                    
                    if (!ARP_ATPASSIVE())
                    {
                        // NOTE: we specify completion code PEND_AddressResolutionComplete
                        //       because we want to get back here (except
                        //       we'll be at passive).
                        //
                        RmSuspendTask(pTask, PEND_AddressResolutionComplete, pSR);
                        RmResumeTaskAsync(
                            pTask,
                            NDIS_STATUS_SUCCESS,
                            &(pConflictTask)->WorkItem,
                            pSR
                            );
                        Status = NDIS_STATUS_PENDING;
                        break;
                    }


                    // We ignore the status of address resolution -- instead
                    // we just check if there is a destination associated with
                    // pRemoteIp.
                    //
                    pDest = pRemoteIp->pDest;
                    pConflictTask->IpStatus=  IP_SUCCESS; 


                    if (pDest != NULL &&
                        pDest->Params.HwAddr.AddressType == NIC1394AddressType_FIFO )
                    {
                        // It is a Fifo destination, now match the unique ID
                        //
                        ARP1394_ADAPTER *pAdapter = (ARP1394_ADAPTER*)RM_PARENT_OBJECT(pIF);
                        UINT64 LocalUniqueId = pAdapter->info.LocalUniqueID;
                        UINT64 DestUniqueId = pDest->Params.HwAddr.FifoAddress.UniqueID ;

                        if(DestUniqueId != LocalUniqueId )
                        {

                            // The Unique Id's did not match.
                            // There is another card with this IP address 
                            //
                            pConflictTask->IpStatus=  IP_DUPLICATE_ADDRESS; 

                        }
                    
                    }
                        
                    //
                    // Call into Tcpip to indicate whether we found a conflict
                    //

                    ASSERT (pIF->ip.AddAddrCmplRtn!= NULL);

                    if (pIF->ip.AddAddrCmplRtn!= NULL)
                    {
                        pIF->ip.AddAddrCmplRtn (pLocalIp->IpAddress, 
                                                pLocalIp->pContext2,   
                                                pConflictTask->IpStatus);
                    }

                    
                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            //
            // if this task created the Remote Ip and the Remote Ip is still valid 
            // then delete it.
            //
            if ((pConflictTask->fRemoteIpCreated == TRUE) &&
                (!RM_IS_ZOMBIE(pRemoteIp) ) )
            {
                PRM_TASK pUnloadTask= NULL;

                Status = arpAllocateTask(
                            &pRemoteIp->Hdr,                    // pParentObject
                            arpTaskUnloadRemoteIp,        // pfnHandler
                            0,                              // Timeout
                            "Task: Unload IP address",       // szDescription
                            &pUnloadTask,
                            pSR
                            );
                if (!FAIL(Status))
                {
                    (VOID)RmStartTask(
                            pUnloadTask,
                            0, // UserParam unused
                            pSR
                            );
                
                }
            }


            // Clear out the pointer and association made above
            LOCKOBJ(pLocalIp,pSR);

            //
            //Add code to unload the Remote Ip structure once we are done with it.

            if (pLocalIp->pConflictTask == pTask)
            {
                // if the current task is going to become the offical task, then
                // add a DbgAssoc
                //
                pLocalIp->pConflictTask = NULL;

            }
            
            if (pConflictTask->fLinkedRemoteIp == TRUE)
            {
                // Unlink the Remote Ip from the current task

            #if RM_EXTRA_CHECKING
                RmUnlinkObjectsEx(
                    &pRemoteIp->Hdr,
                    &pTask->Hdr,
                    0x5ad067aa,
                    ARPASSOC_REMOTEIP_RESOLVE_TASK,
                    ARPASSOC_TASK_TO_RESOLVE_REMOTEIP,
                    pSR
                    );
            #else // !RM_EXTRA_CHECKING
                RmUnlinkObjects(&pRemoteIp->Hdr, &pTask->Hdr, pSR);
            #endif // !RM_EXTRA_CHECKING

            
                pConflictTask->pRemoteIp = NULL; 

            }

            UNLOCKOBJ (pLocalIp,pSR);


        }
        
        break; // RM_TASKOP_END:

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)
        
    RmUnlockAll(pSR);

    if (fDerefRemoteIp == TRUE)
    {
        RmTmpDereferenceObject(&pRemoteIp->Hdr, pSR);
    }
    return Status;
}



NDIS_STATUS
arpCheckForAddressConflict (
    IN  ARPCB_LOCAL_IP * pLocalIp,  // LOCKIN NOLOCKOUT
    IN  UINT                        AddressType,
    IN  IP_ADDRESS                  IpAddress,
    IN  IP_MASK                     Mask,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    This function check to see if there is another Destination on the Net with 
    the same IP address.

    It first creates a Task that will check for this Scenario.
    The Task will create a RemoteIp to represent the Destination.
    It will try and resolve the destination. If the Resolve Task succeeds then 
    arp1394 will invalidate the interface.

Arguments:

    pLocalIp        - The object to be initialized.
    AddressType     - One of the LLIP_ADDR_* constants.
    IpAddress       - The IP address of the object.
    Mask            - The mask associated with the IP address.

--*/
{

    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    PRM_TASK pTask = NULL;


    //
    // Allocate and start a task to unload pLocalIp;
    //
    do
    {

        Status = arpAllocateTask(
                    &pLocalIp->Hdr,             // pParentObject
                    arpTaskResolveLocalIp,       // pfnHandler
                    0,                              // Timeout
                    "Task: Resolve LocalIp", // szDescription
                    &pTask,
                    pSR
                    );

        if (Status != NDIS_STATUS_SUCCESS || pTask == NULL)
        {   
            pTask = NULL;
            break;
        }

        Status = RmStartTask(
                    pTask,
                    0, // UserParam (unused)
                    pSR
                    );

    } while (FALSE);

    return Status;
}
    


NDIS_STATUS
arpInitializeLocalIp(
    IN  ARPCB_LOCAL_IP * pLocalIp,  // LOCKIN NOLOCKOUT
    IN  UINT                        AddressType,
    IN  IP_ADDRESS                  IpAddress,
    IN  IP_MASK                     Mask,
    IN  PVOID                       pContext2,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Initialize the specified local ip object. This includines starting 
    address registration for the object.

Arguments:

    pLocalIp        - The object to be initialized.
    AddressType     - One of the LLIP_ADDR_* constants.
    IpAddress       - The IP address of the object.
    Mask            - The mask associated with the IP address.

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    PARP1394_INTERFACE pIF = (PARP1394_INTERFACE)RM_PARENT_OBJECT(pLocalIp);
    ENTER("InitailizeLocalIp", 0x8a0ff47c)
        

    RM_DBG_ASSERT_LOCKED(&pLocalIp->Hdr, pSR);

    pLocalIp->IpAddress         = IpAddress;
    pLocalIp->IpMask            = Mask;
    pLocalIp->IpAddressType     = AddressType;
    pLocalIp->AddAddressCount   = 1;
    pLocalIp->pContext2          = pContext2;

    if (arpCanTryMcap(IpAddress))
    {
        SET_LOCALIP_MCAP(pLocalIp,  ARPLOCALIP_MCAP_CAPABLE);
    }

    UNLOCKOBJ(pLocalIp, pSR);

    if (AddressType == LLIP_ADDR_LOCAL)
    {
        Status = arpCheckForAddressConflict (pLocalIp,AddressType,IpAddress,Mask,pSR);
    }

    EXIT()
    return Status;        
}


VOID
arpUnloadLocalIp(
    IN  ARPCB_LOCAL_IP * pLocalIp,  // LOCKIN NOLOCKOUT
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Starts a task to unload pLocalIp.
    The actual unload could happen asynchronously.

Arguments:

    pLocalIp        - The object to be unloaded.

--*/
{
    ARP1394_INTERFACE   *   pIF = (ARP1394_INTERFACE*) pLocalIp->Hdr.pParentObject;
    ENTER("arpDeinitializeLocalIp", 0x1db1015e)
    PRM_TASK pTask;
    NDIS_STATUS Status;

    TR_INFO(("Enter. pLocalIp = 0x%p\n", pLocalIp));

    RM_DBG_ASSERT_LOCKED(&pLocalIp->Hdr, pSR);

#if TODO // if it can be synchronously unloaded, no need to start a task
        // (on the other hand, I'm not sure we should bother)
    if (arpLocalIpReadyForSyncDeinit(pLocalIp, pSR))
    {
        arpSyncDeinitLocalIp(pLocalIp, pSR);    // Lock released on exit.
    }
#endif // TODO

    UNLOCKOBJ(pLocalIp, pSR);

    //
    // Allocate and start a task to unload pLocalIp;
    //

    Status = arpAllocateTask(
                &pLocalIp->Hdr,             // pParentObject
                arpTaskUnloadLocalIp,       // pfnHandler
                0,                              // Timeout
                "Task: unload LocalIp", // szDescription
                &pTask,
                pSR
                );


    if (FAIL(Status))
    {
        // TODO Need special allocation mechanism for unload-related tasks
        // that will block until a free task becomes available.
        // See notes.txt 03/09/1999 entry   "Special allocator for unload-related
        // tasks
        //
        TR_FATAL(("FATAL: couldn't alloc unload-local-ip task!\n"));
    }
    else
    {
        (void)RmStartTask(
                    pTask,
                    0, // UserParam (unused)
                    pSR
                    );
    }

    EXIT()
}


INT
arpQueryIpEntityId(
    ARP1394_INTERFACE *             pIF,                // LOCKIN LOCKOUT
    IN      UINT                    EntityType,
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    PRM_STACK_RECORD                pSR
)
/*++

Routine Description:

    Return  the entity ID for the specified EntityType.

Arguments:

    pIF                     - Interface
    EntityType              - QueryInfo entity type (AT_*)
    pNdisBuffer             - Space for returning information
    pBufferSize             - Pointer to size of above. On return, we fill
                              it with the actual bytes copied.
Return Value:

    TDI Status code.

--*/
{
    ENTER("arpQueryIpEntityId", 0x1ada17cb)
    UINT ReturnStatus;

    RM_DBG_ASSERT_LOCKED(&pIF->Hdr, pSR);

    if (*pBufferSize >= sizeof(UINT))
    {
        UINT EntityId;
        UINT ByteOffset = 0;
        TR_VERB(
            ("INFO GENERIC, ENTITY TYPE, BufferSize %d\n", *pBufferSize));

        EntityId = ((EntityType == AT_ENTITY) ? AT_ARP: IF_MIB);
        arpCopyToNdisBuffer(
                pNdisBuffer,
                (PUCHAR)&EntityId,
                sizeof(EntityId),
                &ByteOffset);

        // *pBufferSize = sizeof(UINT); << This was commented-out in atmarpc.sys
        *pBufferSize = 0; // To keep the same behavior as atmarpc.sys
        ReturnStatus = TDI_SUCCESS;
    }
    else
    {
        ReturnStatus = TDI_BUFFER_TOO_SMALL;
    }

    return ReturnStatus;
}


INT
arpQueryIpAddrXlatInfo(
    ARP1394_INTERFACE *             pIF,                // LOCKIN LOCKOUT
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    PRM_STACK_RECORD                pSR
)
/*++

Routine Description:

    Request for the number of entries in the address translation
    table, and the IF index.

Arguments:

    pIF                     - Interface
    pNdisBuffer             - Space for returning information
    pBufferSize             - Pointer to size of above. On return, we fill
                              it with the actual bytes copied.
    QueryContext            - Context value pertaining to the query.

Return Value:

    TDI Status code.

--*/
{
    UINT ReturnStatus;
    AddrXlatInfo    Info;
    ENTER("arpQueryIpXlatInfo", 0xd320b55a)

    RM_DBG_ASSERT_LOCKED(&pIF->Hdr, pSR);

    TR_INFO(("QueryInfo: AT Entity, for IF index, ATE size\n"));

    if (*pBufferSize >= sizeof(Info))
    {
        UINT ByteOffset = 0;

        ARP_ZEROSTRUCT(&Info);
        *pBufferSize = sizeof(Info);

        Info.axi_count =  RM_NUM_ITEMS_IN_GROUP(&pIF->RemoteIpGroup);
        Info.axi_index = pIF->ip.IFIndex;

        arpCopyToNdisBuffer(
                pNdisBuffer,
                (PUCHAR)&Info,
                sizeof(Info),
                &ByteOffset);

        ReturnStatus = TDI_SUCCESS;
    }
    else
    {
        ReturnStatus = TDI_BUFFER_TOO_SMALL;
    }

    EXIT()
    return ReturnStatus;
}


VOID
arpCopyDestInfoIntoInmeInfo (
    PUCHAR pinme_physaddr,
    PARPCB_DEST pDest
    )
/*++

Routine Description:

Copy the correct destination address to the location provided 
In the Fifo Send case, we need to report the Fake Mac Address
In all other cases, we'll report the first six bytes of the destination

Arguments:
    pinme_physaddr  - Location we need to fill up.
    pdest

Return Value:

    TDI Status code.

--*/

{
    PNIC1394_DESTINATION pNicDest = &pDest->Params.HwAddr;
    ENetAddr               FakeEnetAddress = {0,0,0,0,0,0};
    PUCHAR              pDestAddr = NULL;


    //
    // This assertion is important for this function to work. 
    // If it is changed, then we can no longer use FakeMac Addresses 
    // to identify remote nodes. We will have to revert back to using Unique IDs
    //
    ASSERT (sizeof(ENetAddr) == ARP1394_IP_PHYSADDR_LEN);

            
    if (NIC1394AddressType_FIFO == pNicDest->AddressType &&
        pDest->Params.ReceiveOnly== FALSE)
    {

        //
        // We are translating an entry that describes a SendFifo Destination
        //

        
        //
        // Use the same algorithm as nic1394 uses to get a 
        // MAC address to report back to IP
        //
        if (pNicDest->FifoAddress.UniqueID != 0)
        {
            nicGetMacAddressFromEuid(&pNicDest->FifoAddress.UniqueID, &FakeEnetAddress);
        }

        pDestAddr = (PUCHAR) &FakeEnetAddress;

    }   
    else
    {
        // We'll use the first six bytes of the NIC1394_DESTINATION
        //

        
        // We copy the 1st ARP1394_IP_PHYSADDR_LEN bytes of the address...
        // (In the case of a channel, only the 1st 4 bytes (UINT Channel)
        // are significant; The rest will be all zeros.)
        //
        pDestAddr = (PUCHAR)pNicDest;

    }


    NdisMoveMemory (pinme_physaddr, pDestAddr, ARP1394_IP_PHYSADDR_LEN);

}



arpQueryIpAddrXlatEntries(
    ARP1394_INTERFACE *             pIF,                // LOCKIN LOCKOUT
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    IN      PVOID                   QueryContext,
    PRM_STACK_RECORD                pSR
)
/*++

Routine Description:

    Return as many AddrXlat entries (aka arp entries) as will fit
    into the specified buffer.


Arguments:

    pIF                     - Interface
    pNdisBuffer             - Space for returning information
    pBufferSize             - Pointer to size of above. On return, we fill
                              it with the actual bytes copied.
    QueryContext            - Context value pertaining to the query.

Return Value:

    TDI Status code.

--*/
{
    //
    // Our context structure is laid out as follows
    //
    typedef struct
    {
        IP_ADDRESS IpAddr;

        // UINT TableSize; << TODO To deal with dynamic changes in table-size.

    } OUR_QUERY_CONTEXT;

    OUR_QUERY_CONTEXT * pOurCtxt;
    UINT                ReturnStatus;
    UINT                ByteOffset;
    UINT                BytesCopied;
    UINT                BufferSize;
    ARPCB_REMOTE_IP *   pRemoteIp;
    NDIS_STATUS         Status;
    ENTER("arpQueryIpXlatEntries", 0x61c86684)

    TR_INFO(("QueryInfo: AT Entity, for reading ATE\n"));
    RM_DBG_ASSERT_LOCKED(&pIF->Hdr, pSR);

    // See notes.txt entry ..
    //   03/04/1999   JosephJ  Size of the context passed in ArpIpQueryInfo.
    //
    ASSERT(sizeof(OUR_QUERY_CONTEXT) <= 16);

    BufferSize      = *pBufferSize;
    *pBufferSize    = 0;
    BytesCopied     = 0;
    ByteOffset      = 0;
    pOurCtxt        = (OUR_QUERY_CONTEXT*) QueryContext;
    pRemoteIp       = NULL;

    ReturnStatus = TDI_SUCCESS;

    //
    // Our context structure is supposed to be initialized with Zeros the 1st time
    // it's called.
    //
    if (pOurCtxt->IpAddr == 0)
    {
        //
        // This is a brand new context. So we get the 1st entry.
        //
        Status = RmGetNextObjectInGroup(
                    &pIF->RemoteIpGroup,
                    NULL,
                    &(PRM_OBJECT_HEADER)pRemoteIp,
                    pSR
                    );
        if (FAIL(Status))
        {
            // Presumably there are no entries.
            pRemoteIp = NULL;
        }
    }
    else
    {
        //
        // This is an ongoing context. Let's look up this IP address, which is
        // supposed to be the IP address of the next item in the arp table.
        //
        Status = RmLookupObjectInGroup(
                        &pIF->RemoteIpGroup,
                        0,                              // Flags
                        (PVOID) ULongToPtr (pOurCtxt->IpAddr),      // pKey
                        NULL,                           // pvCreateParams
                        &(PRM_OBJECT_HEADER)pRemoteIp,
                        NULL, // pfCreated
                        pSR
                        );
        if (FAIL(Status))
        {
            //
            // Ah well, things have changed since the last time we were called,
            // and now this entry is no longer around.
            //
            pRemoteIp = NULL;
        }
    }

    while (pRemoteIp != NULL)
    {
        ARPCB_REMOTE_IP *   pNextRemoteIp = NULL;
        IPNetToMediaEntry   ArpEntry;

        if (((INT)BufferSize - (INT)BytesCopied) < sizeof(ArpEntry))
        {
            //
            // out of space; Update the context, and set special return value.
            //
            ARP_ZEROSTRUCT(pOurCtxt);
            pOurCtxt->IpAddr = pRemoteIp->IpAddress;


            ReturnStatus = TDI_BUFFER_OVERFLOW;
            RmTmpDereferenceObject(&pRemoteIp->Hdr, pSR);
            pRemoteIp = NULL;
            break;
        }

        // Prepare the XlatEntry in ArpEntry.
        //
        {
            ARP_ZEROSTRUCT(&ArpEntry);

            ArpEntry.inme_index = pIF->ip.IFIndex;
            ArpEntry.inme_addr  = pRemoteIp->IpAddress;
            if (CHECK_REMOTEIP_RESOLVE_STATE(pRemoteIp, ARPREMOTEIP_RESOLVED))
            {
                ARPCB_DEST *pDest = pRemoteIp->pDest;

                TR_INFO(("ReadNext: found Remote IP Entry 0x%x, Addr %d.%d.%d.%d\n",
                            pRemoteIp,
                            ((PUCHAR)(&(pRemoteIp->IpAddress)))[0],
                            ((PUCHAR)(&(pRemoteIp->IpAddress)))[1],
                            ((PUCHAR)(&(pRemoteIp->IpAddress)))[2],
                            ((PUCHAR)(&(pRemoteIp->IpAddress)))[3]
                        ));
        
                // We assert that
                // IF lock is the same as pRemoteIp's and pDest's lock,
                // and that lock is locked.
                // We implicitly assert that pDest is non-NULl as well.
                //
                ASSERTEX(pRemoteIp->Hdr.pLock == pDest->Hdr.pLock, pRemoteIp);
                RM_DBG_ASSERT_LOCKED(&pRemoteIp->Hdr, pSR);

                ArpEntry.inme_physaddrlen =  ARP1394_IP_PHYSADDR_LEN;

                // We copy the 1st ARP1394_IP_PHYSADDR_LEN bytes of the address...
                // (In the case of a channel, only the 1st 4 bytes (UINT Channel)
                // are significant; The rest will be all zeros.)
                //
                ASSERT(sizeof(pDest->Params.HwAddr)>=ARP1394_IP_PHYSADDR_LEN);

                arpCopyDestInfoIntoInmeInfo (ArpEntry.inme_physaddr,pDest);
        
                if (CHECK_REMOTEIP_SDTYPE(pRemoteIp, ARPREMOTEIP_STATIC))
                {
                    ArpEntry.inme_type = INME_TYPE_STATIC;
                }
                else
                {
                    ArpEntry.inme_type = INME_TYPE_DYNAMIC;
                }
            }
            else
            {
                ArpEntry.inme_physaddrlen   = 0;
                ArpEntry.inme_type          = INME_TYPE_INVALID;
            }
        }

        // Copy into the supplied ndis buffer.
        //
        BytesCopied += sizeof(ArpEntry);
        pNdisBuffer = arpCopyToNdisBuffer(
                        pNdisBuffer,
                        (PUCHAR)&ArpEntry,
                        sizeof(ArpEntry),
                        &ByteOffset
                        );

        // Lookup next entry's IP address and save it in our context.
        //
        Status = RmGetNextObjectInGroup(
                        &pIF->RemoteIpGroup,
                        &pRemoteIp->Hdr,
                        &(PRM_OBJECT_HEADER)pNextRemoteIp,
                        pSR
                        );

        if (FAIL(Status))
        {
            //
            // we're presumably done. 
            //
            pNextRemoteIp = NULL;
        }

        // TmpDeref pRemoteIp and move on to the next one.
        //
        RmTmpDereferenceObject(&pRemoteIp->Hdr, pSR);
        pRemoteIp = pNextRemoteIp;

    }

    ASSERT(pRemoteIp == NULL);

    *pBufferSize = BytesCopied;


    EXIT()
    return ReturnStatus;
}


arpQueryIpMibStats(
    ARP1394_INTERFACE *             pIF,                // LOCKIN LOCKOUT
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    PRM_STACK_RECORD                pSR
)
/*++

Routine Description:

    Fill out Interface-level statistics.

Arguments:

    pIF                     - Interface
    pNdisBuffer             - Space for returning information
    pBufferSize             - Pointer to size of above. On return, we fill
                              it with the actual bytes copied.

Return Value:

    TDI Status code.

--*/
{
    ENTER("arpQueryIpMibStatus", 0xc5bc364f)
    UINT    ReturnStatus;
    UINT    BufferSize;
    
    TR_VERB(("QueryInfo: MIB statistics\n"));
    RM_DBG_ASSERT_LOCKED(&pIF->Hdr, pSR);

    BufferSize      = *pBufferSize;
    *pBufferSize    = 0;

    do
    {
        IFEntry             ife;
        ARP1394_ADAPTER *   pAdapter;
        UINT                ByteOffset;
        UINT                BytesCopied;
    
        //
        //  Check if we have enough space.
        //
        if (BufferSize < IFE_FIXED_SIZE)
        {
            ReturnStatus = TDI_BUFFER_TOO_SMALL;
            break;
        }
    
        ARP_ZEROSTRUCT(&ife);
        pAdapter        = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
        BytesCopied     = 0;
        ByteOffset      = 0;

        //
        // Fill out mib info...
        //

        ife.if_index    = pIF->ip.IFIndex;
        ife.if_mtu      = pIF->ip.MTU;
        ife.if_type     = IF_TYPE_IEEE1394;
        ife.if_speed    = pAdapter->info.Speed;
    
        // Set adminstatus and operstatus (computed from pIF->Hdr.State)
        //
        ife.if_adminstatus = IF_STATUS_UP;
        ife.if_operstatus = IF_OPER_STATUS_OPERATIONAL;
        
        if (CHECK_IF_PRIMARY_STATE(pIF, ARPIF_PS_DEINITING))
        {
            ife.if_adminstatus = IF_STATUS_DOWN;
        }
        if (!CHECK_IF_IP_STATE(pIF, ARPIF_IPS_OPEN))
        {
            ife.if_operstatus = IF_OPER_STATUS_NON_OPERATIONAL;
        }

        // Stats...
        //
        ife.if_lastchange       = pIF->stats.LastChangeTime;
        ife.if_inoctets         = pIF->stats.InOctets;
        ife.if_inucastpkts      = pIF->stats.InUnicastPkts;
        ife.if_innucastpkts     = pIF->stats.InNonUnicastPkts;
        ife.if_indiscards       = pIF->stats.InDiscards;
        ife.if_inerrors         = pIF->stats.InErrors;
        ife.if_inunknownprotos  = pIF->stats.UnknownProtos;
        ife.if_outoctets        = pIF->stats.OutOctets;
        ife.if_outucastpkts     = pIF->stats.OutUnicastPkts;
        ife.if_outnucastpkts    = pIF->stats.OutNonUnicastPkts;
        ife.if_outdiscards      = pIF->stats.OutDiscards;
        ife.if_outerrors        = pIF->stats.OutErrors;
        ife.if_outqlen          = pIF->stats.OutQlen;

        ife.if_descrlen         = pAdapter->info.DescriptionLength;

    
        ASSERT(ARP1394_IP_PHYSADDR_LEN <= sizeof(pAdapter->info.EthernetMacAddress));
        ife.if_physaddrlen = ARP1394_IP_PHYSADDR_LEN;

    #if 1 // MILLEN
        //
        //  Win98: winipcfg doesn't like more than 6 bytes repored here.
        //
        if (ife.if_physaddrlen > 6)
        {
            ife.if_physaddrlen = 6;
        }
    #endif// MILLEN


        //
        // Tell TCPIP that the Ethernet Address is the real physical address.
        // This helps us because now we have the same 'MAC' address whether 
        // we are in a network which is bridged to Ethernet or not.
        //
        NdisMoveMemory(
                ife.if_physaddr,
                &(pAdapter->info.EthernetMacAddress),
                ife.if_physaddrlen
                );
    
        arpCopyToNdisBuffer(
                pNdisBuffer,
                (PUCHAR)&ife,
                IFE_FIXED_SIZE,
                &ByteOffset);
    
        if (BufferSize >= (IFE_FIXED_SIZE + ife.if_descrlen))
        {
            if (ife.if_descrlen != 0)
            {
                arpCopyToNdisBuffer(
                        pNdisBuffer,
                        pAdapter->info.szDescription,
                        ife.if_descrlen,
                        &ByteOffset);
            }
            *pBufferSize = IFE_FIXED_SIZE + ife.if_descrlen;
            ReturnStatus = TDI_SUCCESS;
        }
        else
        {
            *pBufferSize = IFE_FIXED_SIZE;
            ReturnStatus = TDI_BUFFER_OVERFLOW;
        }

    } while (FALSE);

    EXIT()
    return ReturnStatus;
}


PNDIS_BUFFER
arpCopyToNdisBuffer(
    IN  PNDIS_BUFFER                pDestBuffer,
    IN  PUCHAR                      pDataSrc,
    IN  UINT                        LenToCopy,
    IN OUT  PUINT                   pOffsetInBuffer
)
/*++

Routine Description:

    Copy data into an NDIS buffer chain. Use up as much of the given
    NDIS chain as needed for "LenToCopy" bytes. After copying is over,
    return a pointer to the first NDIS buffer that has space for writing
    into (for the next Copy operation), and the offset within this from
    which to start writing.

Arguments:

    pDestBuffer     - First NDIS buffer in a chain of buffers
    pDataSrc        - Where to copy data from
    LenToCopy       - How much data to copy
    pOffsetInBuffer - Offset in pDestBuffer where we can start copying into.

Return Value:

    The NDIS buffer in the chain where the next Copy can be done. We also
    set *pOffsetInBuffer to the write offset in the returned NDIS buffer.

--*/
{
    //
    //  Size and destination for individual (contiguous) copy operations
    //
    UINT            CopySize;
    PUCHAR          pDataDst;

    //
    //  Start Virtual address for each NDIS buffer in chain.
    //
    PUCHAR          VirtualAddress;

    //
    //  Offset within pDestBuffer
    //
    UINT            OffsetInBuffer = *pOffsetInBuffer;

    //
    //  Bytes remaining in current buffer
    //
    UINT            DestSize;

    //
    //  Total Buffer Length
    //
    UINT            BufferLength;


    ASSERT(pDestBuffer != (PNDIS_BUFFER)NULL);
    ASSERT(pDataSrc != NULL);

#if MILLEN
    NdisQueryBuffer(
            pDestBuffer,
            &VirtualAddress,
            &BufferLength
            );
#else
    NdisQueryBufferSafe(
            pDestBuffer,
            &VirtualAddress,
            &BufferLength,
            NormalPagePriority
            );

    if (VirtualAddress == NULL)
    {
        return (NULL);
    }
#endif
    
    ASSERT(BufferLength >= OffsetInBuffer);

    pDataDst = VirtualAddress + OffsetInBuffer;
    DestSize = BufferLength - OffsetInBuffer;

    for (;;)
    {
        CopySize = LenToCopy;
        if (CopySize > DestSize)
        {
            CopySize = DestSize;
        }

        NdisMoveMemory(pDataDst, pDataSrc, CopySize);

        pDataDst += CopySize;
        pDataSrc += CopySize;

        LenToCopy -= CopySize;
        if (LenToCopy == 0)
        {
            break;
        }

        DestSize -= CopySize;

        if (DestSize == 0)
        {
            //
            //  Out of space in the current buffer. Move to the next.
            //
            pDestBuffer = NDIS_BUFFER_LINKAGE(pDestBuffer);

            if (pDestBuffer == NULL)
            {
                ASSERT(FALSE);
                return NULL;
            }
            else
            {
            #if MILLEN
                NdisQueryBuffer(
                        pDestBuffer,
                        &VirtualAddress,
                        &BufferLength
                        );
            #else // !MILLEN
                NdisQueryBufferSafe(
                        pDestBuffer,
                        &VirtualAddress,
                        &BufferLength,
                        NormalPagePriority
                        );
    
                if (VirtualAddress == NULL)
                {
                    return NULL;
                }
            #endif // !MILLEN
                pDataDst = VirtualAddress;
                DestSize = BufferLength;
            }
        }
    }

    *pOffsetInBuffer = (UINT) (pDataDst - VirtualAddress);

    return (pDestBuffer);
}


VOID
arpSendIpPkt(
    IN  ARP1394_INTERFACE       *   pIF,            // LOCKIN NOLOCKOUT (IF send lk)
    IN  PARPCB_DEST                 pDest,
    IN  PNDIS_PACKET                pNdisPacket
    )
/*++

    HOT PATH

Routine Description:

    Send a packet to the FIFO/channel associated with destination object pDest.

Arguments:

    pIF             - Our interface object
    pDest           - Destination object on which to send packet
    pNdisPacket     - Packet to send

--*/
{
    NDIS_STATUS Status;
    MYBOOL      fRet;
    ARP1394_ADAPTER *   pAdapter =
                            (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
    MYBOOL      fBridgeMode = ARP_BRIDGE_ENABLED(pAdapter);

    DBGMARK(0xdaab68c3);

    //
    // If we can't send now, we immediately call IP's send complete handler.
    //
    if (!ARP_CAN_SEND_ON_DEST(pDest))
    {
        ARP_FASTUNLOCK_IF_SEND_LOCK(pIF);

        if (ARP_DEST_IS_FIFO(pDest))
        {
            LOGSTATS_SendFifoCounts(pIF, pNdisPacket, NDIS_STATUS_FAILURE);
        }
        else
        {
            LOGSTATS_SendChannelCounts(pIF, pNdisPacket, NDIS_STATUS_FAILURE);
        }
        #if MILLEN
            ASSERT_PASSIVE();
        #endif // MILLEN
        NdisInterlockedIncrement (&ArpSendCompletes);
        NdisInterlockedIncrement (&ArpSendFailure);


        if (fBridgeMode)
        {
            // In bridge (ethernet emulation) mode, we created the
            // packets ourselves, so we delete them here, instead
            // of calling Ip's completion handler, which in fact
            // is NULL.
            //
            RM_DECLARE_STACK_RECORD(sr)
            arpFreeControlPacket(
                    pIF,
                    pNdisPacket,
                    &sr
                    );
        }
        else
        {
            (*(pIF->ip.TxCmpltHandler))(
                        pIF->ip.Context,
                        pNdisPacket,
                        NDIS_STATUS_FAILURE
                        );
        }
        return;                                         // EARLY RETURN
    }

    arpRefSendPkt( pNdisPacket, pDest);

    // Release the IF send lock.
    //
    ARP_FASTUNLOCK_IF_SEND_LOCK(pIF);


    // NOW (with IF send lock released), we prepare the IP packet for sending....
    //
    // We do this only if not in ethernet emulation (bridge) mode,
    // because all IP packets in bridge mode already have the
    // proper 1394 header on them.
    //
    if (!fBridgeMode)
    {
        PNDIS_BUFFER            pNdisBuffer;    // First buffer in the IP packet
    
    // TODO: is this safe? How about a check for the size by which this is possible!
    #if !MILLEN
        #define ARP_BACK_FILL_POSSIBLE(_pBuf) \
                    (((_pBuf)->MdlFlags & MDL_NETWORK_HEADER) != 0)
    #else // MILLEN
        #define ARP_BACK_FILL_POSSIBLE(_pBuf)   (0)
    #endif // MILLEN
    
        //
        //  We look at the first buffer in the IP packet, to see whether
        //  it has space reserved for low-layer headers. If so, we just
        //  use it up. Otherwise, we allocate a header buffer of our own.
        //
        NdisQueryPacket(pNdisPacket, NULL, NULL, &pNdisBuffer, NULL);

        ASSERTEX(pNdisBuffer != NULL, pNdisPacket);
        if (ARP_BACK_FILL_POSSIBLE(pNdisBuffer))
        {
            const ULONG EncapLength = sizeof(Arp1394_IpEncapHeader);
    
        #if MILLEN
    
            ASSERT(!"We shouldn't be here -- check ARP_BACK_FILL_POSSIBLE()");
    
        #else   // !MILLEN


            (PUCHAR)pNdisBuffer->MappedSystemVa -= EncapLength;
            pNdisBuffer->ByteOffset             -= EncapLength;
            pNdisBuffer->ByteCount              += EncapLength;
            NdisMoveMemory(
                pNdisBuffer->MappedSystemVa,
                &Arp1394_IpEncapHeader,
                EncapLength
                );


#define LOGSTATS_BackFills(_pIF, _pNdisPacket) \
    NdisInterlockedIncrement(&((_pIF)->stats.sendpkts.BackFills))

            LOGSTATS_BackFills(pIF, pNdisPacket);
    
        #endif  // !MILLEN
        }
        else
        {
            //
            // Backfill wasn't possible for this packet. Let's try to allocate
            // an encapsulation header buffer from the IF pool...
            //
    
            pNdisBuffer =  arpAllocateConstBuffer(&pIF->sendinfo.HeaderPool);
    
            if (pNdisBuffer != (PNDIS_BUFFER)NULL)
            {
                // Our send complete handler relies on this assertion to decide
                // whether backfill happened or not.
                //
                ASSERT(!ARP_BACK_FILL_POSSIBLE(pNdisBuffer));

                NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);
            }
            else
            {
                //
                // Oops, we couldn't allocate an encapsulation buffer!
                // We've already referenced the destination for sends.
                //

                //
                // Cop out for now (we haven't implemented all the  queuing
                // code for now) by calling our own send complete handler with
                // status failure.
                //
                // We use the special return value NDIS_STATUS_NOT_RESETTABLE
                // to indicate that we haven't inserted our own buffer,
                // (and so the packet shouldn't be "reset"). Ok this is a bit
                // hacky, but it works.
                //
                arpCompleteSentPkt(
                        NDIS_STATUS_NOT_RESETTABLE,
                        pIF,
                        pDest,
                        pNdisPacket
                        );

                return;                                 // EARLY RETURN
            }
        }
    }

    

    
    // Actually send the packet
    //
#if ARPDBG_FAKE_SEND
    arpDbgFakeNdisCoSendPackets(
            pDest->VcHdr.NdisVcHandle,
            &pNdisPacket,
            1,
            &pDest->Hdr,
            &pDest->VcHdr
        );
#else   // !ARPDBG_FAKE_SEND
    NdisCoSendPackets(
            pDest->VcHdr.NdisVcHandle,
            &pNdisPacket,
            1
        );
#endif  // !ARPDBG_FAKE_SEND

}


NDIS_STATUS
arpSlowIpTransmit(
    IN  ARP1394_INTERFACE       *   pIF,
    IN  PNDIS_PACKET                pNdisPacket,
    IN  REMOTE_DEST_KEY             Destination,
    IN  RouteCacheEntry *           pRCE        OPTIONAL
    )
/*++

Routine Description:

    This is the path taken (hopefully only for a small fraction of the packets)
    when something has prevented the packet from being immediately sent down to
    the miniport. Typically we're here for one of the following reasons:
    1. IP Address is not resolved yet.
    2. RCE entry has not been initialized yet.
    3. Couldn't allocate an encapsulation-header buffer.
    4. The Vc to the destination doesn't exist or is not ready for sending yet.


Arguments:

    pIF             - Our interface object
    pNdisPacket     - Packet to send
    Destination     - IP address of destination
    pRCE            - (OPTIONAL) Route Cache Entry associated with this
                      destination

Return Value:
    
    NDIS_STATUS_SUCCESS         on synchronous success.
    NDIS_STATUS_PENDING         if completion is asynchronous
    Other ndis status code      on other kinds of failure.

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
    ENTER("arpSlowIpTransmit", 0xe635299c)
    BOOLEAN fBridgeMode = ARP_BRIDGE_ENABLED(pAdapter);
    ULONG   LookupFlags = 0;
    UINT fRemoteIpCreated = FALSE;
    RM_DECLARE_STACK_RECORD(sr)

    DBGMARK(0x30b6f7e2);

    do
    {
        ARP_RCE_CONTEXT *   pArpRceContext  = NULL;
        ARPCB_REMOTE_IP *   pRemoteIp       = NULL;
        ARPCB_DEST      *   pDest           = NULL;

#define LOGSTATS_SlowSends(_pIF, _pNdisPacket) \
    NdisInterlockedIncrement(&((_pIF)->stats.sendpkts.SlowSends))
#define LOGSTATS_MediumSends(_pIF, _pNdisPacket) \
    NdisInterlockedIncrement(&((_pIF)->stats.sendpkts.MediumSends))

        //
        // If there is a RCE, we try to get the pRemoteIp from it  If not
        // successful, we'll need to actually lookup/create the pRemoteIp from the
        // IF RemoteIpGroup.
        //

        if (pRCE != NULL)
        {
            pArpRceContext  = ARP_OUR_CTXT_FROM_RCE(pRCE);

            // All RCE linkages are protected by the IF send lock.
            //
            ARP_READLOCK_IF_SEND_LOCK(pIF, &sr);
            pRemoteIp       = pArpRceContext->pRemoteIp;
            if (pRemoteIp != NULL)
            {
                RmTmpReferenceObject(&pRemoteIp->Hdr, &sr);
            }
            ARP_UNLOCK_IF_SEND_LOCK(pIF, &sr);
        }

        if (pRemoteIp == NULL)
        {
            //
            // Either there was no RCE or it was uninitialized.
            // We'll lookup/create the pRemoteIp based on the destination
            // IP address...
            //

            RM_ASSERT_NOLOCKS(&sr);

            //
            // Create the destination, this will cause us to resolve IP Addresses, etc/
            //                                        
            LookupFlags  = RM_CREATE; 


            if (fBridgeMode == TRUE)
            {
                //
                // do not create a remote IP struct, only look it up.
                // In bridge mode, Remote Structs are created while
                // translating ARP packets.
                //
                LookupFlags = 0;
            }
            // if in bridge mode
            // set flags to zero , else RM_CREATE

            Status = RmLookupObjectInGroup(
                            &pIF->RemoteIpGroup,
                            LookupFlags,
                            (PVOID) &Destination,
                            (PVOID) (&Destination),   // pCreateParams
                            (RM_OBJECT_HEADER**) &pRemoteIp,
                            &fRemoteIpCreated,                   // pfCreated  (unused)
                            &sr
                            );
            LOGSTATS_TotalArpCacheLookups(pIF, Status);
            if (FAIL(Status))
            {
                OBJLOG1(
                    pIF,
                    "Couldn't lookup/create localIp entry with addr 0x%lx\n",
                    Destination.IpAddress
                    );
                Status = NDIS_STATUS_FAILURE;
                break;
            }

          
            //
            // If there is a RCE, we make it point to pRemoteIp.
            //
            if (pRCE != NULL)
            {

                // All RCE linkages are protected by the IF send lock.
                //
                ARP_WRITELOCK_IF_SEND_LOCK(pIF, &sr);

                if (pArpRceContext->pRemoteIp != NULL)
                {
                    if (pArpRceContext->pRemoteIp != pRemoteIp)
                    {
                        ARPCB_REMOTE_IP *   pStaleRemoteIp;
                        //
                        // We've got a wierd situation here: initially
                        // pRCE didn't point to any pRemoteIp, so we looked up
                        // a pRemoteIp ourselves. Now that we've got the IF send
                        // lock, we find that pRCE is pointing to a different
                        // pRemoteIp than the one we looked up!
                        //
                        // What to do? We ignore pRemoteIp (the one we looked up)
                        // and instead use pArpRceContext->pRemoteIp...
                        //
                        ASSERTEX(!"RCE pRemoteIp mismatch", pArpRceContext);
                        pStaleRemoteIp = pRemoteIp;
                        pRemoteIp = pArpRceContext->pRemoteIp;
                        RmTmpReferenceObject(&pRemoteIp->Hdr, &sr);
                        ARP_UNLOCK_IF_SEND_LOCK(pIF, &sr);
                        RM_ASSERT_NOLOCKS(&sr);
                        RmTmpDereferenceObject(&pStaleRemoteIp->Hdr, &sr);
                        ARP_WRITELOCK_IF_SEND_LOCK(pIF, &sr);
                    }
                }
                else
                {
                    // Add the association between pRCE and pRemoteIp...
                    //
                    arpAddRce(pRemoteIp, pRCE, &sr);   // LOCKIN LOCKOUT (IF send lk)
                }

                ARP_UNLOCK_IF_SEND_LOCK(pIF, &sr);
            }
        }

        //
        // At this point, we should have a pRemoteIp, with a tmpref on it,
        // and no locks held.
        //
        ASSERT_VALID_REMOTE_IP(pRemoteIp);
        RM_ASSERT_NOLOCKS(&sr);

        //
        // Queue the packet on pRemoteIp's send pkt queue, and start the 
        // SendPkts task on this pRemoteIp if required.
        //
        {
        
            LOCKOBJ(pRemoteIp, &sr);

            // NOTE: This field is not always modified with the lock held -- in
            // the fast send path, it's simply set to true.
            // This field is used in garbage collecting pRemoteIps.
            //
            pRemoteIp->sendinfo.TimeLastChecked = 0;

            //
            // Stats.
            // TODO -- we need to directly deal with "medium sends"
            // instead of starting up a task just because the RCEs are NULL
            // -- mcast and udp pkts have null RCEs, it turns out.
            //

            if (    pRemoteIp->pDest != NULL
                 && ARP_CAN_SEND_ON_DEST(pRemoteIp->pDest))
            {
                LOGSTATS_MediumSends(pIF, pNdisPacket);
            }
            else
            {
                LOGSTATS_SlowSends(pIF, pNdisPacket);
            }

            
            if (pRemoteIp->pSendPktsTask == NULL)
            {
                PRM_TASK pTask;

                // There is no send-pkts task. Let's try to alloc and start one..
                Status = arpAllocateTask(
                            &pRemoteIp->Hdr,            // pParentObject
                            arpTaskSendPktsOnRemoteIp,      // pfnHandler
                            0,                              // Timeout
                            "Task: SendPktsOnRemoteIp", // szDescription
                            &pTask,
                            &sr
                            );
                if (FAIL(Status))
                {
                    // Oops, couldn't allocate task. We fail with STATUS_RESOURCES
                    UNLOCKOBJ(pRemoteIp, &sr);
                    Status = NDIS_STATUS_RESOURCES;
                    break;
                }

                //
                // Queue the pkt first, THEN start the task. This makes sure that
                // the packet WILL be taken care of.
                // TODO: Currently, it's possible that the RemoteIp's unload
                // task will not wait for send pkts to be cleared up IF it checks
                // BEFORE the task before is started. This hole needs
                // to be fixed.
                //
                arpQueuePktOnRemoteIp(
                    pRemoteIp,      // LOCKIN LOCKOUT
                    pNdisPacket,
                    &sr
                    );

                UNLOCKOBJ(pRemoteIp, &sr);

                (VOID) RmStartTask( pTask, 0, &sr);
            }
            else
            {
                //
                // There is already a send-pkts task. Simply queue the pkt.
                //
                arpQueuePktOnRemoteIp(
                    pRemoteIp,      // LOCKIN LOCKOUT
                    pNdisPacket,
                    &sr
                    );
                UNLOCKOBJ(pRemoteIp, &sr);
            }

            // We're done!
            // Remove the tmp reference on pRemoteIp, and set status to PENDING.
            //
            RM_ASSERT_NOLOCKS(&sr);
            RmTmpDereferenceObject(&pRemoteIp->Hdr, &sr);
            Status = NDIS_STATUS_PENDING;
        }

    } while (FALSE);
    
    RM_ASSERT_CLEAR(&sr)

    EXIT()
    return Status;
}



VOID
arpAddRce(
    IN  ARPCB_REMOTE_IP *pRemoteIp, // IF send lock WRITELOCKIN WRITELOCKOUT
    IN  RouteCacheEntry *pRce,
    IN  PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

        Link the RCE pRce with the remote ip object pRemoteIp.
--*/
{
    ARP_RCE_CONTEXT *   pArpRceContext;
    MYBOOL              fDoRef;

    pArpRceContext  = ARP_OUR_CTXT_FROM_RCE(pRce);
    fDoRef          = (pRemoteIp->sendinfo.pRceList == NULL);

    ASSERT(pArpRceContext->pRemoteIp == NULL);

    // Add pRce to pRemoteIP's list of RCEs.
    //
    pArpRceContext->pNextRce = pRemoteIp->sendinfo.pRceList;
    pRemoteIp->sendinfo.pRceList = pRce;

    // Add pointer from pRce to pRemoteIp
    //
    pArpRceContext->pRemoteIp = pRemoteIp;


    // The following macros are just so that we can make the proper debug association
    // depending on how closely we are tracking outstanding send packets.
    //
#if ARPDBG_REF_EVERY_RCE
    fDoRef = TRUE;
    #define OUR_EXTERNAL_ENTITY ((UINT_PTR) pRce)
    #define szARPSSOC_EXTLINK_RIP_TO_RCE_FORMAT "    Linked to pRce 0x%p\n"
#else // !ARPDBG_REF_EVERY_RCE
    #define OUR_EXTERNAL_ENTITY ((UINT_PTR)  &pRemoteIp->sendinfo)
    #define szARPSSOC_EXTLINK_RIP_TO_RCE_FORMAT "    Outstanding RCEs exist. &si=0x%p\n"
#endif // !ARPDBG_REF_EVERY_RCE


    if (fDoRef)
    {
        //
        // If ARPDBG_REF_EVERY_RCE
        //      We add an "external" link for EVERY RCE. We'll later remove this
        //      reference when the RCE is invalidated.
        // else
        //      Only a transition from zero to non-zero RCEs, we
        //      add an "external" link. We'll later remove this link when the
        //      transition from non-zero to zero happens.
        //

    #if RM_EXTRA_CHECKING

        RM_DECLARE_STACK_RECORD(sr)

        RmLinkToExternalEx(
            &pRemoteIp->Hdr,                            // pHdr
            0x22224c96,                             // LUID
            OUR_EXTERNAL_ENTITY,                    // External entity
            ARPASSOC_EXTLINK_RIP_TO_RCE,            // AssocID
            szARPSSOC_EXTLINK_RIP_TO_RCE_FORMAT,
            &sr
            );

    #else   // !RM_EXTRA_CHECKING

        RmLinkToExternalFast(&pRemoteIp->Hdr);

    #endif // !RM_EXTRA_CHECKING

    }

    #undef  OUR_EXTERNAL_ENTITY
    #undef  szARPSSOC_EXTLINK_RIP_TO_RCE
}


VOID
arpDelRce(
    IN  RouteCacheEntry *pRce,  // IF send lock WRITELOCKIN WRITELOCKOUTD
    IN  PRM_STACK_RECORD pSR
    )
/*++

Routine Description:

        Unlink RCE pRce from remote ip object pRemoteIp.

--*/
{
    ARPCB_REMOTE_IP *   pRemoteIp;
    ARP_RCE_CONTEXT *   pArpRceContext;
    MYBOOL              fDoDeref;
    RouteCacheEntry **  ppRce;

    pArpRceContext  = ARP_OUR_CTXT_FROM_RCE(pRce);
    pRemoteIp       = pArpRceContext->pRemoteIp;

    if (pRemoteIp == NULL)
    {
        // We haven't initialized this RCE yet. Nothing to do...
        //
        return;                                                 // EARLY RETURN
    }


    if (VALID_REMOTE_IP(pRemoteIp)== FALSE)
    {
        return;
    }

    // Remove pRce from pRemoteIP's list of RCEs.
    //
    for(
        ppRce = &pRemoteIp->sendinfo.pRceList;
        *ppRce != NULL;
        ppRce = &(ARP_OUR_CTXT_FROM_RCE(*ppRce)->pNextRce))
    {
        if (*ppRce == pRce) break;

    }
    if (*ppRce == pRce)
    {
        *ppRce =  pArpRceContext->pNextRce;
    }
    else
    {
        ASSERTEX(!"RCE Not in pRemoteIp's list!", pRce);
    }
    ARP_ZEROSTRUCT(pArpRceContext);

    fDoDeref        = (pRemoteIp->sendinfo.pRceList == NULL);

    // The following macros are just so that we can make the proper debug association
    // depending on how closely we are tracking outstanding send packets.
    //
#if ARPDBG_REF_EVERY_RCE
    fDoDeref = TRUE;
    #define OUR_EXTERNAL_ENTITY ((UINT_PTR) pRce)
#else // !ARPDBG_REF_EVERY_RCE
    #define OUR_EXTERNAL_ENTITY ((UINT_PTR)  &pRemoteIp->sendinfo)
#endif // !ARPDBG_REF_EVERY_RCE

    if (fDoDeref)
    {
        //
        // If ARPDBG_REF_EVERY_RCE
        //      We add an "external" link for EVERY RCE. We'll later remove this
        //      reference when the RCE is invalidated.
        // else
        //      Only a transition from zero to non-zero RCEs, we
        //      add an "external" link. We'll later remove this link when the
        //      transition from non-zero to zero happens.
        //

    #if RM_EXTRA_CHECKING

        RM_DECLARE_STACK_RECORD(sr)

        RmUnlinkFromExternalEx(
            &pRemoteIp->Hdr,                        // pHdr
            0x940df668,                             // LUID
            OUR_EXTERNAL_ENTITY,                    // External entity
            ARPASSOC_EXTLINK_RIP_TO_RCE,            // AssocID
            &sr
            );

    #else   // !RM_EXTRA_CHECKING

        RmUnlinkFromExternalFast(&pRemoteIp->Hdr);

    #endif // !RM_EXTRA_CHECKING

    }

    #undef  OUR_EXTERNAL_ENTITY
}


VOID
arpDelRceList(
    IN  PARPCB_REMOTE_IP  pRemoteIp,    // IF send lock WRITELOCKIN WRITELOCKOUTD
    IN  PRM_STACK_RECORD pSR
    )
/*++

Routine Description:
    Walks the RCE List, deleting each RoutCache Entry


--*/
{

    RouteCacheEntry *   pRce = pRemoteIp->sendinfo.pRceList;

    //
    // Delete all the Rce present on this remote Ip
    //

    while (pRce!= NULL)
    {
        //
        // Delete the Rce and reduce the Ref
        //
        arpDelRce (pRce, pSR);

        //
        // Get the next RCE
        //
        pRce = pRemoteIp->sendinfo.pRceList;
    }


}


NDIS_STATUS
arpTaskSendPktsOnRemoteIp(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for  sending queued packets on the pRemoteIp which
    is its parent object. If required it must start the registration task and/or
    the make-call task on the destination object.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    ENTER("TaskSendPktsOnRemoteIp", 0xbc285d98)
    NDIS_STATUS         Status;
    ARPCB_REMOTE_IP*    pRemoteIp;
    ARP1394_INTERFACE * pIF;
    ARPCB_DEST        * pDest;
    MYBOOL              fMakeCallIfRequired;
    PARP1394_ADAPTER    pAdapter;
    MYBOOL              fBridgeMode;

    // Following are the list of pending states for this task.
    //
    enum
    {
        PEND_AddressResolutionComplete,
        PEND_MakeCallComplete
    };

    Status              = NDIS_STATUS_FAILURE;
    pRemoteIp           = (ARPCB_REMOTE_IP*) RM_PARENT_OBJECT(pTask);
    pIF                 = (ARP1394_INTERFACE*) RM_PARENT_OBJECT(pRemoteIp);
    pAdapter            = (PARP1394_ADAPTER) RM_PARENT_OBJECT(pIF);
    pDest               = NULL;
    fMakeCallIfRequired = FALSE;
    fBridgeMode         = ARP_BRIDGE_ENABLED(pAdapter);
            


    ASSERT_VALID_INTERFACE(pIF);
    ASSERT_VALID_REMOTE_IP(pRemoteIp);

    DBGMARK(0x6f31a739);

    switch(Code)
    {
        case RM_TASKOP_START:
        {
            LOCKOBJ(pRemoteIp, pSR);

            // First check if pRemoteIp is still allocated, if not we go away.
            //
            if (RM_IS_ZOMBIE(pRemoteIp))
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            // pRemoteIp is allocated. Now check if there is already a
            // send-pkts task attached to pRemoteIp.
            //
            if (pRemoteIp->pSendPktsTask != NULL)
            {
                //
                // There is a sendpkts task. Nothing for us to do -- simply return.
                //
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            // Now we check if there is an UnloadTask bound to pRemoteIP. This
            // is an IMPORTANT check -- because the unload task expects that
            // once it is bound to pRemoteIp, no new pSendPktsTasks will bind
            // themselves to pRemoteIp -- see arpTaskUnloadRemoteIp.
            //
            if (pRemoteIp->pUnloadTask != NULL)
            {
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

            //
            // There is no sendpkts task going on. Let's
            // make this task THE sendpkts task.
            // 
            pRemoteIp->pSendPktsTask = pTask;

            //
            // Since we're THE sendpks task, add an association to pRemoteIp,
            // which will only get cleared when the  pRemoteIp->pSendPktsTask field
            // above is cleared.
            //
            DBG_ADDASSOC(
                &pRemoteIp->Hdr,                    // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_REMOTEIP_SENDPKTS_TASK,    // AssociationID
                "    Official sendpkts task 0x%p (%s)\n", // szFormat
                pSR
                );

            if (pRemoteIp->pDest == NULL)
            {   
                MYBOOL bIsDestNonUnicastAddr = FALSE;
                //
                // There is no pDest associated with pRemoteIp.
                // If this is an on-unicast address, we link the local ip
                // object to the broadcast object and proceed.
                // NOTE: arpIsNonUnicastIpAddress is not a trivial operation -- it
                // actually enumerates all local IP addresses. Fortunately we only
                // call it for the FIRST packet sent out to an unresolved address.
                //
                bIsDestNonUnicastAddr  = arpIsNonUnicastIpAddress(pIF, pRemoteIp->IpAddress, pSR);

                //
                // In the Bridge mode, we always have Dest structure for each
                // pRemoteIP. This is because they are created simultaeneously
                // when translating ARP packets
                //
                ASSERT (fBridgeMode == FALSE);
                
                if (bIsDestNonUnicastAddr == TRUE)
                {
                    ASSERT(pIF->pBroadcastDest != NULL); // Don't really expect it.

                    if (pIF->pBroadcastDest != NULL)
                    {
                        //
                        // Note: arpLinkRemoteIpToDest expects the locks
                        // on both pRemoteIp and pIF->pBroadcastDest to be
                        // held. We know that this is the case because both
                        // share the same lock, which is the IF lock.
                        //
                        RM_DBG_ASSERT_LOCKED(&pIF->pBroadcastDest->Hdr, pSR);
                        arpLinkRemoteIpToDest(
                                pRemoteIp,
                                pIF->pBroadcastDest,
                                pSR
                                );
                        SET_REMOTEIP_FCTYPE(pRemoteIp, ARPREMOTEIP_CHANNEL);
                        SET_REMOTEIP_SDTYPE(pRemoteIp, ARPREMOTEIP_DYNAMIC);
                #if 0
                        if (CHECK_REMOTEIP_MCAP(pRemoteIp,  ARPREMOTEIP_MCAP_CAPABLE))
                        {
                            SET_REMOTEIP_SDTYPE(pRemoteIp, ARPREMOTEIP_DYNAMIC);
                        }
                        else
                        {
                            //
                            // We don't age out broadcast addresses.
                            //
                            SET_REMOTEIP_SDTYPE(pRemoteIp, ARPREMOTEIP_STATIC);
                        }
                #endif // 0
                    }
                }
            }


            //
            // If there is a resolution task going, we  wait for it to complete.
            //
            if (pRemoteIp->pResolutionTask != NULL)
            {
                PRM_TASK pOtherTask = pRemoteIp->pResolutionTask;
                ASSERT (fBridgeMode == FALSE);
                TR_WARN(("Resolution task %p exists; pending on it.\n", pOtherTask));
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);

                UNLOCKOBJ(pRemoteIp, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    PEND_AddressResolutionComplete,
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }

            //
            // There is no address resolution task. Let's see if the
            // address has been resolved. If not, we need to start the address
            // resolution task.
            //
            if (pRemoteIp->pDest == NULL)
            {
                //
                // Let's start the address resolution task!
                //
                PRM_TASK pResolutionTask;
                ASSERT (fBridgeMode == FALSE);
                DBGMARK(0xd0da6726);

                //
                // Let's start a resolution task and pend on it.
                //
                Status = arpAllocateTask(
                            &pRemoteIp->Hdr,                    // pParentObject
                            arpTaskResolveIpAddress,        // pfnHandler
                            0,                              // Timeout
                            "Task: ResolveIpAddress",       // szDescription
                            &pResolutionTask,
                            pSR
                            );
                if (FAIL(Status))
                {
                    // Couldn't allocate task. We fail with STATUS_RESOURCES
                    //
                    Status = NDIS_STATUS_RESOURCES;
                }
                else
                {
                    UNLOCKOBJ(pRemoteIp, pSR);
                    RmPendTaskOnOtherTask(
                        pTask,
                        PEND_AddressResolutionComplete,
                        pResolutionTask,
                        pSR
                        );
    
                    (VOID)RmStartTask(
                            pResolutionTask,
                            0, // UserParam unused
                            pSR
                            );
                
                    Status = NDIS_STATUS_PENDING;
                }
                break;
            }

            pDest = pRemoteIp->pDest;

            //
            // We do have a pDest. Now see if there is a make call task on that
            // pDest, and if so, we pend on it.
            fMakeCallIfRequired = TRUE;


            //
            // We're here because there is no more async work to be done.
            // We simply return and finish synchronous work in the END
            // handler for this task.
            //
            
        } // START
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_AddressResolutionComplete:
                {
                    //
                    // There was address-resolution going on, but how it's
                    // complete. We should be go on to try to make a call now...
                    //
                    // If we're here, that means we're THE official SendPkts
                    // task. Let's assert that fact.
                    // (no need to get the lock on the object).
                    //
                    LOCKOBJ(pRemoteIp, pSR);
                    ASSERT(pRemoteIp->pSendPktsTask == pTask);

                    // We ignore the status of address resolution -- instead
                    // we just check if there is a destination associated with
                    // pRemoteIp.
                    //
                    pDest = pRemoteIp->pDest;
                    if (pDest == NULL)
                    {
                        // Nope -- no pDest. We fail the packets.
                        Status = NDIS_STATUS_FAILURE;
                    }
                    else
                    {
                        // Yup,  there is a destination. Now check if we need
                        // to make a call, etc...
                        //
                        fMakeCallIfRequired = TRUE;
                    }
                }
                break;

                case  PEND_MakeCallComplete:
                {
                    LOCKOBJ(pRemoteIp, pSR);
                    //
                    // If we're here, that means we're THE official SendPkts
                    // task. Let's assert that fact.
                    // (no need to get the lock on the object).
                    //
                    ASSERT(pRemoteIp->pSendPktsTask == pTask);

                    //
                    // There was a make-call task going on, but how it's
                    // complete. We're done with async processing.
                    // We actually send/fail queued packets in our END handler...
                    //
                    Status      = (NDIS_STATUS) UserParam;
                    ASSERT(!PEND(Status));
                }
                break;

                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);
                }
                break;
    

            } // end switch(RM_PEND_CODE(pTask))

        } // case RM_TASKOP_PENDCOMPLETE
        break;

        case RM_TASKOP_END:
        {
            LOCKOBJ(pRemoteIp, pSR);

            //
            // We're done. There should be no async activities left to do.
            // At this point, if we can't immediately send packets on the FIFO,
            // we simply fail all the packets.
            //

            //
            // We don't bother to look at the Status. Instead we go ahead and
            // try to send any queued packets.
            //

            //
            // If we're THE sentpkts task, we go on actually send the packets.
            //
            if (pRemoteIp->pSendPktsTask == pTask)
            {
                DBGMARK(0xc627713c);

                arpSendPktsQueuedOnRemoteIp(
                        pIF,
                        pRemoteIp,
                        pSR
                        );

                // Delete the association we added when we set
                // pRemoteIp->pSendPktsTask to pTask.
                //
                ASSERT(pRemoteIp->pSendPktsTask == pTask);
                ASSERT(IsListEmpty(&pRemoteIp->sendinfo.listSendPkts) ==TRUE);
                DBG_DELASSOC(
                    &pRemoteIp->Hdr,                    // pObject
                    pTask,                              // Instance1
                    pTask->Hdr.szDescription,           // Instance2
                    ARPASSOC_REMOTEIP_SENDPKTS_TASK,    // AssociationID
                    pSR
                    );
                pRemoteIp->pSendPktsTask = NULL;
                Status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                //
                // We weren't THE unload task, nothing left to do.
                //
                Status = NDIS_STATUS_SUCCESS;
            }
        }
        break; // RM_TASKOP_END:

        default:
        {
            ASSERTEX(!"Unexpected task op", pTask);
        }
        break;

    } // switch (Code)

    if (fMakeCallIfRequired)
    {
        //
        // If necessary, make a call. If a make-call is already in process, pend
        // on it.
        //

        // We rely on the fact that
        // we share the same lock as pDest, and therefore is locked...
        //
        RM_DBG_ASSERT_LOCKED(&pDest->Hdr, pSR);

        Status = arpMakeCallOnDest(pRemoteIp,
                                    pDest, 
                                    pTask, 
                                    PEND_MakeCallComplete, 
                                    pSR);

    }

    RmUnlockAll(pSR);

    EXIT()

    return Status;
}


VOID
arpCompleteSentPkt(
    IN  NDIS_STATUS             Status,
    IN  ARP1394_INTERFACE   *   pIF,
    IN  ARPCB_DEST          *   pDest,
    IN  PNDIS_PACKET            pNdisPacket
)
/*++

Routine Description:

    Handle the completion (by the miniport) of a packet sent on a FIFO or Channel VC.
    We strip out the encapsulation header we had tacked on prior to sending the
    packet. If the packet belongs to IP, we call IP's send complete handler, else
    we return it to our packet pool.

Arguments:

    Status      - Status of the completed send.
    pIF         - Interface object
    pDest       - Destination object on which packet was sent
    pNdisPacket - Ndis packet that was sent.

--*/
{
    PacketContext                   *PC;            // IP/ARP Info about this packet
    PNDIS_BUFFER                    pNdisBuffer;    // First Buffer in this packet
    ENTER("CompleteSentPkt", 0xc2b623b6)
    UINT                            TotalLength;
    MYBOOL                          IsFifo;
    MYBOOL                          IsControlPacket;


    ASSERT(pNdisPacket->Private.Head != NULL);

    NdisQueryPacket(
            pNdisPacket,
            NULL,           // we don't need PhysicalBufferCount
            NULL,           // we don't need BufferCount
            NULL,           // we don't need FirstBuffer (yet)
            &TotalLength
            );

    IsFifo = pDest->sendinfo.IsFifo;

    // Update stats...
    //
    {
        if (IsFifo)
        {
            LOGSTATS_SendFifoCounts(pIF, pNdisPacket, Status);
        }
        else
        {
            LOGSTATS_SendChannelCounts(pIF, pNdisPacket, Status);
        }

        if (Status == NDIS_STATUS_SUCCESS)
        {
            ARP_IF_STAT_ADD(pIF, OutOctets, TotalLength);

            if (IsFifo)
            {
                ARP_IF_STAT_INCR(pIF, OutUnicastPkts);
            }
            else
            {
                ARP_IF_STAT_INCR(pIF, OutNonUnicastPkts);
            }
        }
        else if (Status == NDIS_STATUS_RESOURCES)
        {
            ARP_IF_STAT_INCR(pIF, OutDiscards);
        }
        else
        {
            ARP_IF_STAT_INCR(pIF, OutErrors);
        }
    }

    PC = (PacketContext *)pNdisPacket->ProtocolReserved;

    TR_INFO(
        ("[%s]: pDest 0x%x, Pkt 0x%x, Status 0x%x:\n",
                ((PC->pc_common.pc_owner != PACKET_OWNER_LINK)? "IP": "ARP"),
                pDest, pNdisPacket, Status));

    NdisQueryPacket(pNdisPacket, NULL, NULL, &pNdisBuffer, NULL);
    ASSERT(pNdisBuffer != NULL);

    // Delete association added when sending packets.
    //
    {
        MYBOOL      DoDeref;
    
        DoDeref =(InterlockedDecrement(&pDest->sendinfo.NumOutstandingSends)==0);

        if (DoDeref)
        {
            MYBOOL TryResumeSuspendedCleanupTask = FALSE;

            // The count of outstanding sends has touched zero. Let's
            // check if there is a CleanupCall task waiting for all outstanding
            // sends to complete, and if it makes sense to do so, we
            // will resume it.
            //
            ARP_FASTREADLOCK_IF_SEND_LOCK(pIF);
            if (pDest->sendinfo.pSuspendedCleanupCallTask!=NULL)
            {
                // It's likely that we'll need to resume this task.
                //
                TryResumeSuspendedCleanupTask = TRUE;
            }
            else
            {
                // We do not need to resume any task. Nothing more to do...
                //
            }
            ARP_FASTUNLOCK_IF_SEND_LOCK(pIF);

            if (TryResumeSuspendedCleanupTask)
            {
                arpTryResumeSuspendedCleanupTask(pIF, pDest);
            }
        }
    
        // The following macros are just so that we can make the proper debug
        // association depending on how closely we are tracking outstanding send
        // packets.
        //
    #if ARPDBG_REF_EVERY_PACKET
        DoDeref = TRUE;
        #define OUR_EXTERNAL_ENTITY ((UINT_PTR) pNdisPacket)
    #else // !ARPDBG_REF_EVERY_PACKET
        #define OUR_EXTERNAL_ENTITY ((UINT_PTR)  &pDest->sendinfo)
    #endif // !ARPDBG_REF_EVERY_PACKET
    
    
        if (DoDeref)
        {
            //
            // If ARPDBG_REF_EVERY_PKT
            //      We remove the "external" link added for EVERY packet.
            // else
            //      Only a transition from non-zero to zero outstanding sends, we
            //      remove the "external" link.
            //
    
        #if RM_EXTRA_CHECKING
    
            RM_DECLARE_STACK_RECORD(sr)
    
            RmUnlinkFromExternalEx(
                &pDest->Hdr,                            // pHdr
                0x753db96f,                             // LUID
                OUR_EXTERNAL_ENTITY,                    // External entity
                ARPASSOC_EXTLINK_DEST_TO_PKT,           // AssocID
                &sr
                );
    
        #else   // !RM_EXTRA_CHECKING
    
            RmUnlinkFromExternalFast(&pDest->Hdr);
    
        #endif // !RM_EXTRA_CHECKING
    
        }
        #undef  OUR_EXTERNAL_ENTITY
    
    }

    //
    //  Check who generated this packet.
    //
    IsControlPacket = FALSE;

    if (PC->pc_common.pc_owner == PACKET_OWNER_LINK)
    {
        IsControlPacket = TRUE;
    }

    if (IsControlPacket)
    {
        arpHandleControlPktSendCompletion(pIF, pNdisPacket);
    }
    else
    {
        //
        //  Belongs to IP.
        //

        DBGMARK(0x2c48c626);

        //
        //  Now check if we had attached a header buffer or not.
        //  NOTE: We rely on the fact that if we DID attach a header buffer,
        //  ARP_BACK_FILL_POSSIBLE will be false for this buffer.
        //
        DBGMARK(0x2f3b96f3);
        if (ARP_BACK_FILL_POSSIBLE(pNdisBuffer))
        {
            const UINT  HeaderLength =  sizeof(Arp1394_IpEncapHeader);

            //
            //  We would have back-filled IP's buffer with the Ip encapsulation
            //  header.
            //  Remove the back-fill.
            //
            (PUCHAR)pNdisBuffer->MappedSystemVa += HeaderLength;
            pNdisBuffer->ByteOffset += HeaderLength;
            pNdisBuffer->ByteCount -= HeaderLength;
        }
        else if (Status != NDIS_STATUS_NOT_RESETTABLE)
        {
            //
            //  The first buffer is our header buffer. Remove
            //  it from the packet and return to our pool.
            //
            NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuffer);
            arpDeallocateConstBuffer(
                &pIF->sendinfo.HeaderPool,
                pNdisBuffer
                );
        }

        //  Inform IP of send completion.
        //  NOTE: we don't get here in bridge mode because we only use
        //  control packets in bridge mode.
        //
        #if MILLEN
            ASSERT_PASSIVE();
        #endif // MILLEN
        (*(pIF->ip.TxCmpltHandler))(
                    pIF->ip.Context,
                    pNdisPacket,
                    Status
                    );
    }

    EXIT()
}


VOID
arpTryResumeSuspendedCleanupTask(
    IN  ARP1394_INTERFACE   *   pIF,        // NOLOCKIN NOLOCKOUT
    IN  ARPCB_DEST          *   pDest       // NOLOCKIN NOLOCKOUT
    )
/*++

Routine Description:

    If there is a cleanup task associated with destination oject pDest that
    is suspended waiting for the outstanding send count to go to zero, AND
    if the outstanding send count has gone to zero, we resume the task. Otherwise
    we do nothing.

Arguments:

    pIF         - Interface object
    pDest       - Destination object.

--*/
{
    PRM_TASK pTask;
    ENTER("TryResumeSuspendedCleanupTask", 0x1eccb1aa)
    RM_DECLARE_STACK_RECORD(sr)

    ARP_WRITELOCK_IF_SEND_LOCK(pIF, &sr);
    pTask = pDest->sendinfo.pSuspendedCleanupCallTask;
    if (pTask != NULL)
    {
        ASSERT(!ARP_CAN_SEND_ON_DEST(pDest));
        if (pDest->sendinfo.NumOutstandingSends==0)
        {
            // We need to resume this task...
            //
            pDest->sendinfo.pSuspendedCleanupCallTask = NULL;

            // Clear the association added when pTask started waiting for
            // outstanding sends to complete.
            //
            DBG_DELASSOC(
                &pDest->Hdr,                        // pObject
                pTask,                              // Instance1
                pTask->Hdr.szDescription,           // Instance2
                ARPASSOC_DEST_CLEANUPCALLTASK_WAITING_ON_SENDS,
                &sr
                );
            RmTmpReferenceObject(&pTask->Hdr, &sr);
        }
        else
        {
            // There are other outstanding sends now. No need to do anything...
            //
            pTask = NULL;
        }
    }
    ARP_UNLOCK_IF_SEND_LOCK(pIF, &sr);


    if (pTask != NULL)
    {
        // Resume the CleanupCall task...
        //
        RmResumeTask(pTask, NDIS_STATUS_SUCCESS, &sr);
        RmTmpDereferenceObject(&pTask->Hdr, &sr);
    }

    RM_ASSERT_CLEAR(&sr);
    EXIT()
}

VOID
arpQueuePktOnRemoteIp(
    IN  PARPCB_REMOTE_IP    pRemoteIp,      // LOCKIN LOCKOUT
    IN  PNDIS_PACKET        pNdisPacket,
    IN  PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Appends pkt pNdisPacket on remote object pRemoteIp's queue.

--*/
{
    ARP_SEND_PKT_MPR_INFO *pOurPktInfo =
                        ARP_OUR_CTXT_FROM_SEND_PACKET(pNdisPacket);
    

    RM_DBG_ASSERT_LOCKED(&pRemoteIp->Hdr, pSR);

#if RM_EXTRA_CHECKING
    {
        //
        // If ARPDBG_REF_EVERY_PKT
        //      We add an dbgassociation for EVERY packet. We'll later remove
        //      this association when the send completes for this packet.
        // else
        //      Only a transition from zero to non-zero queued pkts, we
        //      add an dbg association. We'll later remove this association when
        //      the transition from non-zero to zero happens.
        //
        MYBOOL DoAssoc;

    #if ARPDBG_REF_EVERY_PACKET
        DoAssoc = TRUE;
        #define OUR_EXTERNAL_ENTITY ((UINT_PTR) pNdisPacket)
        #define szARPSSOC_QUEUED_PKT_FORMAT "    Queued pkt 0x%p\n"
    #else // !ARPDBG_REF_EVERY_PACKET
        #define OUR_EXTERNAL_ENTITY ((UINT_PTR)  &pDest->)
        #define szARPSSOC_QUEUED_PKT_FORMAT "    Outstanding pkts. &si=0x%p\n"
        DoAssoc =  IsListEmpty(&pRemoteIp->sendinfo.listSendPkts);
    #endif // !ARPDBG_REF_EVERY_PACKET
    
        if (DoAssoc)
        {
    
            RM_DECLARE_STACK_RECORD(sr)
    
            RmDbgAddAssociation(
                0x3c08a7f5,                             // LOCID
                &pRemoteIp->Hdr,                        // pHdr
                (UINT_PTR) OUR_EXTERNAL_ENTITY,         // Entity1
                0,                                      // Entity2
                ARPASSOC_PKTS_QUEUED_ON_REMOTEIP,       // AssocID
                szARPSSOC_QUEUED_PKT_FORMAT,
                &sr
                );
        }
    #undef  OUR_EXTERNAL_ENTITY
    #undef  szARPSSOC_EXTLINK_DEST_TO_PKT_FORMAT
    }
#endif // !RM_EXTRA_CHECKING
    DBGMARK(0x007a0585);

    InsertHeadList(
        &pRemoteIp->sendinfo.listSendPkts,
        &pOurPktInfo->linkQueue
        );
}



VOID
arpSendPktsQueuedOnRemoteIp(
    IN  ARP1394_INTERFACE   *   pIF,            // NOLOCKIN NOLOCKOUT
    IN  ARPCB_REMOTE_IP     *   pRemoteIp,      // NOLOCKIN NOLOCKOUT
    IN  PRM_STACK_RECORD    pSR
    )
/*++

Routine Description:

    Send all packets queued on remote ip object pRemoteIp. If packets can't
    be sent at this time for any reason, fail the sends.

    ASSUMPTION: We expect pIF and pRemoteIp to be around while we're in this
                function.

    ASSUMPTION: This is called with the lock held.                

--*/

{
    ENTER("SendPktsQueuedOnRemoteIp", 0x2b125d7f)

    DBGMARK(0xe4950c47);
    do
    {
        PARPCB_DEST pDest = NULL;

        if(RM_IS_ZOMBIE(pRemoteIp))
        {
            break;
        }


        pDest = pRemoteIp->pDest;

        if (pDest != NULL)
        {
            RmTmpReferenceObject(&pDest->Hdr, pSR);
        }

        //
        // Send or fail all packets in our queue.
        // TODO: Implement send multiple pkts.
        //
        while (!IsListEmpty(&pRemoteIp->sendinfo.listSendPkts))
        {
            PLIST_ENTRY                 plinkPkt;
            PNDIS_PACKET                pNdisPacket;
            ARP_SEND_PKT_MPR_INFO *     pOurPktCtxt;

            //
            // Extract pkt from tail and send it on it's merry way...
            //

            plinkPkt = RemoveTailList(&pRemoteIp->sendinfo.listSendPkts);

            // From link to our pkt context...
            //
            pOurPktCtxt = CONTAINING_RECORD(
                            plinkPkt,
                            ARP_SEND_PKT_MPR_INFO, 
                            linkQueue
                            );

            // From our pkt context to the ndis pkt.
            //
            pNdisPacket = ARP_SEND_PKT_FROM_OUR_CTXT(pOurPktCtxt);
    

        #if RM_EXTRA_CHECKING
            {
                //
                // If ARPDBG_REF_EVERY_PKT
                //      We delete thhe dbgassociation added for EVERY packet.
                // else
                //      Only a transition from non-zero zero queued pkts, we
                //      delete the dbg association added when the
                //      transition from zero to non-zero happened.
                //
                MYBOOL DoDelAssoc;
        
            #if ARPDBG_REF_EVERY_PACKET
                DoDelAssoc = TRUE;
                #define OUR_EXTERNAL_ENTITY ((UINT_PTR) pNdisPacket)
            #else // !ARPDBG_REF_EVERY_PACKET
                #define OUR_EXTERNAL_ENTITY ((UINT_PTR)  &pDest->)
                DoDelAssoc =  IsListEmpty(&pRemoteIp->sendinfo.listSendPkts);
            #endif // !ARPDBG_REF_EVERY_PACKET
            
                if (DoDelAssoc)
                {
            
                    RM_DECLARE_STACK_RECORD(sr)
            
                    RmDbgDeleteAssociation(
                        0x3c08a7f5,                             // LOCID
                        &pRemoteIp->Hdr,                        // pHdr
                        (UINT_PTR) OUR_EXTERNAL_ENTITY,         // Entity1
                        0,                                      // Entity2
                        ARPASSOC_PKTS_QUEUED_ON_REMOTEIP,       // AssocID
                        &sr
                        );
                }
            #undef  OUR_EXTERNAL_ENTITY
            }
        #endif // !RM_EXTRA_CHECKING

            UNLOCKOBJ(pRemoteIp, pSR);
            RM_ASSERT_NOLOCKS(pSR);
    
            if (pDest == NULL
                || (   g_DiscardNonUnicastPackets
                    &&  CHECK_REMOTEIP_FCTYPE( pRemoteIp, ARPREMOTEIP_CHANNEL)))

            {
                ARP1394_ADAPTER *   pAdapter =
                                    (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pIF);
                MYBOOL      fBridgeMode = ARP_BRIDGE_ENABLED(pAdapter);
            
                // Fail the packet right here...
                //
                // TODO: we current update the SendFifoCounts here, because
                // all non-unicast bcasts resolve to the already existing
                // broadcast channel. Once we have MCAP going, we need to keep
                // a flag in pRemoteIp indicating whether or not this is a
                // unicast address.
                //
                LOGSTATS_SendFifoCounts(pIF, pNdisPacket, NDIS_STATUS_FAILURE);
                  
                if (fBridgeMode)
                {
                    // In bridge (ethernet emulation) mode, we created the
                    // packets ourselves, so we delete them here, instead
                    // of calling Ip's completion handler, which in fact
                    // is NULL.
                    //
                    arpFreeControlPacket(
                            pIF,
                            pNdisPacket,
                            pSR
                            );
                }
                else
                {
                #if MILLEN
                    ASSERT_PASSIVE();
                #endif // MILLEN

                    NdisInterlockedIncrement (&ArpSendCompletes);
                    NdisInterlockedIncrement (&ArpSendFailure);


                    (*(pIF->ip.TxCmpltHandler))(
                                pIF->ip.Context,
                                pNdisPacket,
                                NDIS_STATUS_FAILURE
                                );
                }
            }
            else
            {
                // Get IF send lock (fast version)
                //
                ARP_FASTREADLOCK_IF_SEND_LOCK(pIF);
        
                arpSendIpPkt(
                    pIF,                // IF send lock: LOCKING NOLOCKOUT
                    pDest,
                    pNdisPacket
                    );
        
                // Note that we're locking pRemoteIp's lock, not the IF send lock
                // here. pRemoteIp->sendinfo.listSendPkts is protected by the
                // the following lock, not the IF send lock.
                //
            }
            LOCKOBJ(pRemoteIp, pSR);
        }

        if (pDest != NULL)
        {
            RmTmpDereferenceObject(&pDest->Hdr, pSR);
        }

    } while (FALSE);

    EXIT()
}


VOID
arpLogSendFifoCounts(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket,
    IN  NDIS_STATUS         Status
    )
/*++
    TODO:  Very similar to arpLogSendChannelCounts, consider merging these two 
            functions.
--*/
{
    PULONG  pCount;
    ULONG   SizeBin, TimeBin;

    arpGetPktCountBins(pIF, pNdisPacket, &SizeBin, &TimeBin);

    //
    // Increment the count
    if (Status == NDIS_STATUS_SUCCESS)
    {
        pCount = &(pIF->stats.sendpkts.SendFifoCounts.GoodCounts[SizeBin][TimeBin]);
    }
    else
    {
        pCount = &(pIF->stats.sendpkts.SendFifoCounts.BadCounts[SizeBin][TimeBin]);
    }
    NdisInterlockedIncrement(pCount);
}


VOID
arpLogRecvFifoCounts(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket
    )
{
    PULONG  pCount;
    ULONG   SizeBin;

    arpGetPktCountBins(pIF, pNdisPacket, &SizeBin, NULL);

    //
    // Increment the count
    pCount = &(pIF->stats.recvpkts.RecvFifoCounts.GoodCounts[SizeBin][0]);
    NdisInterlockedIncrement(pCount);
}


VOID
arpLogSendChannelCounts(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket,
    IN  NDIS_STATUS         Status
    )
{
    PULONG  pCount;
    ULONG   SizeBin, TimeBin;

    arpGetPktCountBins(pIF, pNdisPacket, &SizeBin, &TimeBin);

    //
    // Increment the count
    if (Status == NDIS_STATUS_SUCCESS)
    {
        pCount =&(pIF->stats.sendpkts.SendChannelCounts.GoodCounts[SizeBin][TimeBin]);
    }
    else
    {
        pCount =&(pIF->stats.sendpkts.SendChannelCounts.BadCounts[SizeBin][TimeBin]);
    }
    NdisInterlockedIncrement(pCount);
}


VOID
arpLogRecvChannelCounts(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket
    )
{
    PULONG  pCount;
    ULONG   SizeBin;

    arpGetPktCountBins(pIF, pNdisPacket, &SizeBin, NULL);

    //
    // Increment the count
    pCount = &(pIF->stats.recvpkts.RecvChannelCounts.GoodCounts[SizeBin][0]);
    NdisInterlockedIncrement(pCount);
}

VOID
arpGetPktCountBins(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket,
    OUT PULONG              pSizeBin,       
    OUT PULONG              pTimeBin        // OPTIONAL
    )
{
    ULONG   Size;
    ULONG   SizeBin;

    if (pTimeBin != NULL)
    {
        //
        // Compute the packet send duration
        //
    
        ULONG           StartSendTick, EndSendTick;
        LARGE_INTEGER   liTemp;
        ULONG           TimeDelta;
        ULONG           TimeBin;

        liTemp = KeQueryPerformanceCounter(NULL);
        EndSendTick = liTemp.LowPart;
        StartSendTick =  *(PULONG) ((pNdisPacket)->WrapperReservedEx);
        if (EndSendTick > StartSendTick)
        {
            TimeDelta = EndSendTick - StartSendTick;
        }
        else
        {
            TimeDelta = (ULONG) (((ULONG) -1) - (StartSendTick - EndSendTick));
        }

        // Convert from ticks to microseconds.
        // (Check that the frequence is non zero -- we could be in the middle
        // of a stats-reset, and don't want to cause a devide-by-zero exception).
        //
        liTemp =  pIF->stats.PerformanceFrequency;
        if (liTemp.QuadPart != 0)
        {
            ULONGLONG ll;
            ll = TimeDelta;
            ll *= 1000000;
            ll /=  liTemp.QuadPart;
            ASSERT(ll == (ULONG)ll);
            TimeDelta = (ULONG) ll;
        }
        else
        {
            TimeDelta = 0; // bogus value.
        }

        //
        // Compute the time bin based on the send duration
        //
        if (TimeDelta <= 100)
        {
            TimeBin = ARP1394_PKTTIME_100US;
        }
        else if (TimeDelta <= 1000)
        {
            TimeBin = ARP1394_PKTTIME_1MS;
        }
        else if (TimeDelta <= 10000)
        {
            TimeBin =   ARP1394_PKTTIME_10MS;
        }
        else if (TimeDelta <= 100000)
        {
            TimeBin =   ARP1394_PKTTIME_100MS;
        }
        else // (TimeDelta > 100000)
        {
            TimeBin = ARP1394_PKTTIME_G100MS;
        }

        *pTimeBin = TimeBin;
    }

    //
    // Compute the packet size
    NdisQueryPacket(
            pNdisPacket,
            NULL,
            NULL,
            NULL,
            &Size
            );

    //
    // Compute the size bin based on the packet size
    if (Size <= 128)
    {
        SizeBin =  ARP1394_PKTSIZE_128;
    }
    else if (Size <= 256)
    {
        SizeBin = ARP1394_PKTSIZE_256;
    }
    else if (Size <= 1024)
    {
        SizeBin = ARP1394_PKTSIZE_1K;
    }
    else if (Size <= 2048)
    {
        SizeBin = ARP1394_PKTSIZE_2K;
    }
    else // Size > 2048
    {
        SizeBin = ARP1394_PKTSIZE_G2K;
    }

    *pSizeBin = SizeBin;

}

// This table is used in the calculations to determine if a particular address is
// non-unicast.
// TODO: Make this and all other static data into const.
//
IP_MASK  g_ArpIPMaskTable[] =
{
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSA_MASK,
    CLASSB_MASK,
    CLASSB_MASK,
    CLASSB_MASK,
    CLASSB_MASK,
    CLASSC_MASK,
    CLASSC_MASK,
    CLASSD_MASK,
    CLASSE_MASK
};


#define ARP_IPNETMASK(a)    g_ArpIPMaskTable[(*(uchar *)&(a)) >> 4]


// Context passed to the enum function for checking if a particular
// address is non-unicast.
//
typedef struct
{
    IP_ADDRESS IpAddress;
    IP_ADDRESS BroadcastAddress;
    MYBOOL     IsNonUnicast;
    

} ARP_NONUNICAST_CTXT, *PARP_NONUNICAST_CTXT;


// The enum function for the above operation.
//
INT
arpCheckForNonUnicastAddress(
        PRM_OBJECT_HEADER   pHdr,
        PVOID               pvContext,
        PRM_STACK_RECORD    pSR
        )
{
    PARPCB_LOCAL_IP         pLocalIp;
    PARP_NONUNICAST_CTXT    pOurCtxt;
    IP_ADDRESS              Addr;
    IP_ADDRESS              BCast;
    IP_ADDRESS              LocalAddr;
    IP_MASK                 Mask;

    pLocalIp =  (PARPCB_LOCAL_IP) pHdr;

    // If this local ip address is non-unicast, skip it.
    //
    if (pLocalIp->IpAddressType != LLIP_ADDR_LOCAL)
    {
        return TRUE;                // *** EARLY RETURN *** (continue to enumerate)
    }

    pOurCtxt =   (PARP_NONUNICAST_CTXT) pvContext;
    Addr     =  pOurCtxt->IpAddress;
    LocalAddr=  pLocalIp->IpAddress;
    BCast    =  pOurCtxt->BroadcastAddress;

    // First check for subnet bcast.
    //
    Mask = pLocalIp->IpMask;
    if (IP_ADDR_EQUAL((LocalAddr & Mask) | (BCast & ~Mask), Addr))
    {
        pOurCtxt->IsNonUnicast = TRUE;
        return  FALSE;                  // Stop enumerating
    }

    // Now check all nets broadcast.
    Mask = ARP_IPNETMASK(LocalAddr);
    if (IP_ADDR_EQUAL((LocalAddr & Mask) | (BCast & ~Mask), Addr))
    {
        pOurCtxt->IsNonUnicast = TRUE;
        return FALSE;                   // Stop enumerating
    }

    return TRUE; // Continue to enumerate.
}



MYBOOL
arpIsNonUnicastEthAddress (
    IN  PARP1394_INTERFACE          pIF,        // LOCKIN LOCKOUT
    IN  ENetAddr*                   pAddr,
    IN  PRM_STACK_RECORD            pSR
)
/*++

Routine Description:

    Check if the given IP address is a non-unicast (broadcast or multicast) address
    for the interface.

    Copied from IP/ATM module (atmarpc.sys)

Arguments:

    Addr            - The Eth Address to be checked
    pInterface      - Pointer to our Interface structure

Return Value:

    TRUE if the address is a non-unicast address, FALSE otherwise.

--*/
{
    MYBOOL fIsNonUnicastEthAddress = FALSE;
    MYBOOL fIsMulticast  = FALSE; 
    MYBOOL fIsBroadcast = FALSE;
    
    fIsMulticast = ETH_IS_MULTICAST (pAddr);

    fIsBroadcast = ETH_IS_BROADCAST (pAddr);

    //
    // if it is either a Multicast or a Unicast address than 
    // it is a non-unicast address
    //
    fIsNonUnicastEthAddress  = (fIsMulticast  || fIsBroadcast );

    return (fIsNonUnicastEthAddress  );
}


MYBOOL
arpIsNonUnicastIpAddress(
    IN  PARP1394_INTERFACE          pIF,        // LOCKIN LOCKOUT
    IN  IP_ADDRESS                  Addr,
    IN  PRM_STACK_RECORD            pSR
)
/*++

Routine Description:

    Check if the given IP address is a non-unicast (broadcast or multicast) address
    for the interface.

    Copied from IP/ATM module (atmarpc.sys)

Arguments:

    Addr            - The IP Address to be checked
    pInterface      - Pointer to our Interface structure

Return Value:

    TRUE if the address is a non-unicast address, FALSE otherwise.

--*/
{
    IP_ADDRESS              BCast;
    IP_MASK                 Mask;
    // PIP_ADDRESS_ENTRY        pIpAddressEntry;
    IP_ADDRESS              LocalAddr;

    // Get the interface broadcast address.
    BCast = pIF->ip.BroadcastAddress;

    // Check for global broadcast and multicast.
    if (IP_ADDR_EQUAL(BCast, Addr) || CLASSD_ADDR(Addr))
        return TRUE;

    // Look through all our local ip addresses, checking for subnet and net
    // broadcast addresses.
    //
    {
        ARP_NONUNICAST_CTXT Ctxt;
        Ctxt.IsNonUnicast = FALSE;
        Ctxt.IpAddress  =   Addr;
        Ctxt.BroadcastAddress = BCast;

        RmEnumerateObjectsInGroup(
            &pIF->LocalIpGroup,
            arpCheckForNonUnicastAddress,
            &Ctxt,
            TRUE,                           // Choose strong enumeration
            pSR
            );

        return Ctxt.IsNonUnicast;
    }
}

VOID
arpRefSendPkt(
    PNDIS_PACKET    pNdisPacket,
    PARPCB_DEST     pDest               // LOCKIN LOCKOUT (readlock, IF Send lock)
    )
{
    MYBOOL      DoRef;
        
    // Note, we just have a READ lock on the IF send lock. So the following
    // needs to be an interlocked operation ...
    //
    DoRef =  (InterlockedIncrement(&pDest->sendinfo.NumOutstandingSends) == 1);

    // The following macros are just so that we can make the proper debug association
    // depending on how closely we are tracking outstanding send packets.
    //
#if ARPDBG_REF_EVERY_PACKET
    DoRef = TRUE;
    #define OUR_EXTERNAL_ENTITY ((UINT_PTR) pNdisPacket)
    #define szARPSSOC_EXTLINK_DEST_TO_PKT_FORMAT "    Outstanding send pkt 0x%p\n"
#else // !ARPDBG_REF_EVERY_PACKET
    #define OUR_EXTERNAL_ENTITY ((UINT_PTR)  &pDest->sendinfo)
    #define szARPSSOC_EXTLINK_DEST_TO_PKT_FORMAT "    Outstanding pkts. &si=0x%p\n"
#endif // !ARPDBG_REF_EVERY_PACKET


    if (DoRef)
    {
        //
        // If ARPDBG_REF_EVERY_PKT
        //      We add an "external" link for EVERY packet. We'll later remove this
        //      reference when the send completes for this packet.
        // else
        //      Only a transition from zero to non-zero outstanding sends, we
        //      add an "external" link. We'll later remove this link when the
        //      transition from non-zero to zero happens.
        //

    #if RM_EXTRA_CHECKING

        RM_DECLARE_STACK_RECORD(sr)

        RmLinkToExternalEx(
            &pDest->Hdr,                            // pHdr
            0x13f839b4,                             // LUID
            OUR_EXTERNAL_ENTITY,                    // External entity
            ARPASSOC_EXTLINK_DEST_TO_PKT,           // AssocID
            szARPSSOC_EXTLINK_DEST_TO_PKT_FORMAT,
            &sr
            );

    #else   // !RM_EXTRA_CHECKING

        RmLinkToExternalFast(&pDest->Hdr);

    #endif // !RM_EXTRA_CHECKING

    }
    #undef  OUR_EXTERNAL_ENTITY
    #undef  szARPSSOC_EXTLINK_DEST_TO_PKT_FORMAT
}

VOID
arpHandleControlPktSendCompletion(
    IN  ARP1394_INTERFACE   *   pIF,
    IN  PNDIS_PACKET            pNdisPacket
    )
{
    RM_DECLARE_STACK_RECORD(sr)

    arpFreeControlPacket(
            pIF,
            pNdisPacket,
            &sr
            );
}



BOOLEAN
arpCanTryMcap(
    IP_ADDRESS  IpAddress
    )
/*++
    Return TRUE IFF this is an MCAP compatible address.

    For now that means that it's a class D address, but not
    224.0.0.1 or 224.0.0.2

--*/
{
    // 1st check if it's a multicast address.
    //
    if ( (IpAddress & 0xf0) == 0xe0)
    {
        //
        // Then check for special multicast addresses 224.0.0.1 and 224.0.0.2
        // The ip/1395 rfc states that these two addresses must be
        // send on the broadcast channel.
        //
        if ( (IpAddress != 0x010000e0) && (IpAddress != 0x020000e0))
        {
            return TRUE;
        }
    }

    return FALSE;
}



VOID
arpLoopbackNdisPacket(
    PARP1394_INTERFACE pIF,
    PARPCB_DEST pBroadcastDest,
    PNDIS_PACKET pOldPacket
    )
/*++

Routine Description:
    if this is being sent to a broadcast destination, then allocate a new
    packet and loop it back up to the protocols.

Arguments:

    pIF - Pointer to the Interface on which the packet is sent
    pBroadcastDest - The Destination to which the packet is being sent.

Return Value:

    TRUE if the address is a non-unicast address, FALSE otherwise.

--*/
{
    PNDIS_PACKET    pNewPkt = NULL;
    const UINT      MacHeaderLength = sizeof(NIC1394_ENCAPSULATION_HEADER);
    PUCHAR          pPayloadDataVa = NULL;
    UINT            TotalLength  = 0;
    NDIS_STATUS     Status = NDIS_STATUS_FAILURE;
    UINT            HeadBufferLength  = 0;
    PUCHAR          pHeadBufferVa = NULL;  
    
    do
    {
        //Allocate the packet


        NdisAllocatePacket(
                &Status,
                &pNewPkt,
                pIF->arp.PacketPool
            );

        if (Status != NDIS_STATUS_SUCCESS || pNewPkt == NULL)
        {
            pNewPkt = NULL;
            break;

        }

        
        // set up the head and tail

        pNewPkt->Private.Head = pOldPacket->Private.Head;
        pNewPkt->Private.Tail = pOldPacket->Private.Tail;

        pNewPkt->Private.ValidCounts = FALSE;

        
        // indicate the packet with a status of resources

        NDIS_SET_PACKET_STATUS (pNewPkt,  NDIS_STATUS_RESOURCES);

        HeadBufferLength = NdisBufferLength (pNewPkt->Private.Head);
        pHeadBufferVa = NdisBufferVirtualAddressSafe (pNewPkt->Private.Head, NormalPagePriority );

        if (pHeadBufferVa ==NULL)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        if (HeadBufferLength <= MacHeaderLength)
        {
            // we need to go the next NdisBuffer to get the Start of data
            // 
            pPayloadDataVa = NdisBufferVirtualAddressSafe (pNewPkt->Private.Head->Next, NormalPagePriority );

            if (pPayloadDataVa == NULL)
            {
                Status = NDIS_STATUS_FAILURE;
                break;
            }
            if (HeadBufferLength != MacHeaderLength)
            {
                pPayloadDataVa += (MacHeaderLength - HeadBufferLength);            
            }
        }
        else
        {
            // The payload is within the Buffer
            pPayloadDataVa += MacHeaderLength ;

        }

        if (pOldPacket->Private.ValidCounts == TRUE)
        {
            TotalLength = pOldPacket->Private.TotalLength;

        }
        else
        {
            NdisQueryPacket(pOldPacket, NULL, NULL, NULL, &TotalLength);

        }

        
        pIF->ip.RcvHandler(
                pIF->ip.Context,
                (PVOID)(pPayloadDataVa),
                HeadBufferLength - MacHeaderLength,
                TotalLength - MacHeaderLength,
                (NDIS_HANDLE)pNewPkt,
                MacHeaderLength,
                TRUE, //IsChannel
                NULL
                );


    }while (FALSE);

    if (pNewPkt != NULL)
    {
        NdisFreePacket (pNewPkt);
        pNewPkt = NULL;            
    }



}



REMOTE_DEST_KEY
RemoteIPKeyFromIPAddress (
    IPAddr IpAddress
    )
/*++

Routine Description:
    Creates a RemoteIPKey structure from an IP Address
    by tagging two constant bytes

Arguments:


Return Value:
    New Remote Ip Key

--*/
{
    REMOTE_DEST_KEY RemoteIpKey ={0,0,0,0,0,0} ;

    ASSERT (sizeof (REMOTE_DEST_KEY)==sizeof(ENetAddr));
    
    RemoteIpKey.IpAddress = IpAddress;
    
    return RemoteIpKey;
}



NTSTATUS
arpDelArpEntry(
        PARP1394_INTERFACE           pIF,
        IPAddr                       IpAddress,
        PRM_STACK_RECORD            pSR
        )
{
    ENTER("DelArpEntry", 0x3427306a)
    NTSTATUS            NtStatus;

    TR_WARN(("DEL ARP ENTRY\n"));
    NtStatus                        = STATUS_UNSUCCESSFUL;

    do
    {
        NDIS_STATUS             Status;
        NIC1394_FIFO_ADDRESS    FifoAddress;
        PARPCB_REMOTE_IP        pRemoteIp;
        PRM_TASK                pUnloadObjectTask;
        REMOTE_DEST_KEY        RemoteDestKey;

        // If this is a Subnet broadcast IP address, then skip the delete
        //
#define ARP1394_SUBNET_BROADCAST_IP  0xffff0000      

        if ((IpAddress & ARP1394_SUBNET_BROADCAST_IP  ) == ARP1394_SUBNET_BROADCAST_IP  )
        {
            break;
        }
            
        LOCKOBJ(pIF, pSR);

        //
        // Initialize the RemoteDestKey
        //
        REMOTE_DEST_KEY_INIT(&RemoteDestKey);

        RemoteDestKey.IpAddress  = IpAddress;                 
        // 
        // Lookup the RemoteIp entry corresponding to this entry and unload
        // it.
        //
        Status = RmLookupObjectInGroup(
                        &pIF->RemoteIpGroup,
                        0,                                      // Flags
                        (PVOID) &RemoteDestKey,     // pKey
                        NULL,                                   // pvCreateParams
                        &(PRM_OBJECT_HEADER)pRemoteIp,
                        NULL, // pfCreated
                        pSR
                        );

        UNLOCKOBJ(pIF, pSR);

        if (FAIL(Status))
        {
            break;
        }

        //
        // Found pRemoteIp. Let's initiate the unload of pRemoteIp. We won't wait
        // around for it to complete.
        //
        Status =  arpAllocateTask(
                    &pRemoteIp->Hdr,        // pParentObject,
                    arpTaskUnloadRemoteIp,  // pfnHandler,
                    0,                      // Timeout,
                    "Task:Unload RemoteIp (DelArpEntry)",
                    &pUnloadObjectTask,
                    pSR
                    );
        RmTmpDereferenceObject(&pRemoteIp->Hdr, pSR);

        if (FAIL(Status))
        {
            TR_WARN(("Couldn't allocate unload remoteip task."));
            break;
        }
        
        RmStartTask(
            pUnloadObjectTask,
            0, // UserParam (unused)
            pSR
            );

        NtStatus = STATUS_SUCCESS; // always succeed

    } while (FALSE);

    EXIT()
    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\n13cfg.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    n13cfg.c

Abstract:

    This code is NOT part of ARP1394. Rather it is sample code that creates
    the config ROM unit directory for IP/1394-capable devices.

    It is here simply for safekeeping.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     03-19-99    Created

Notes:

--*/
#include <precomp.h>

#ifdef TESTPROGRAM

ULONG
Bus1394Crc16(
    IN ULONG data,
    IN ULONG check
    );


ULONG
Bus1394CalculateCrc(
    IN PULONG Quadlet,
    IN ULONG length
    );


// From \nt\private\ntos\dd\wdm\1394\bus\busdef.h

//SPEC_ID_KEY_SIGNITURE
//SOFTWARE_VERSION_KEY_SIGNITURE
//MODEL_KEY_SIGNITURE
#define SPEC_ID_KEY_SIGNATURE                   0x12
#define SOFTWARE_VERSION_KEY_SIGNATURE          0x13
// #define MODEL_ID_KEY_SIGNATURE                  0x17
//#define VENDOR_KEY_SIGNATURE                    0x81
#define TEXTUAL_LEAF_INDIRECT_KEY_SIGNATURE     0x81
#define MODEL_KEY_SIGNATURE                     0x82
//#define UNIT_DIRECTORY_KEY_SIGNATURE            0xd1
//#define UNIT_DEP_DIR_KEY_SIGNATURE              0xd4

    //
    // IEEE 1212 Offset entry definition
    //
    typedef struct _OFFSET_ENTRY {
        ULONG               OE_Offset:24;
        ULONG               OE_Key:8;
    } OFFSET_ENTRY, *POFFSET_ENTRY;
    
    //
    // IEEE 1212 Immediate entry definition
    //
    typedef struct _IMMEDIATE_ENTRY {
        ULONG               IE_Value:24;
        ULONG               IE_Key:8;
    } IMMEDIATE_ENTRY, *PIMMEDIATE_ENTRY;
    
    //
    // IEEE 1212 Directory definition
    //
    typedef struct _DIRECTORY_INFO {
        union {
            USHORT          DI_CRC;
            USHORT          DI_Saved_Length;
        } u;
        USHORT              DI_Length;
    } DIRECTORY_INFO, *PDIRECTORY_INFO;

#define bswap(_val)  SWAPBYTES_ULONG(_val)


// Some NIC1394-specific constants
//
#define NIC1394_UnitSpecIdValue         0x5E            // For "IANA"
#define NIC1394_UnitSwVersionValue      0x1             // IP/1394 Spec
#define NIC1394_ModelSpecIdValue        0x7bb0cf        // Random (TBD by Microsoft)
#define NIC1394_ModelName               L"NIC1394"

    
typedef struct _NIC1394_CONFIG_ROM
{
    // The Unit Directory
    //
    struct
    {
        DIRECTORY_INFO      Info;
        struct
        {
            IMMEDIATE_ENTRY     SpecId;
            IMMEDIATE_ENTRY     SwVersion;
            IMMEDIATE_ENTRY     ModelId;
            OFFSET_ENTRY        ModelIdTextOffset;
        } contents;

    } unit_dir;

    // The ModelId Text Leaf Directory
    //
    struct
    {
        DIRECTORY_INFO      Info;
        struct
        {
            IMMEDIATE_ENTRY     SpecId;
            ULONG               LanguageId;
            ULONG               Text[4]; // L"NIC1394"
        } contents;

    } model_text_dir;

} NIC1394_CONFIG_ROM, *PNIC1394_CONFIG_ROM;


VOID
InitializeNic1394ConfigRom(
    IN PNIC1394_CONFIG_ROM Nic1394ConfigRom
    )
/*++
    
Routine Description:

    This routine initializes the configuration ROM unit directory (and the
    leaf directories it references) for NIC1394, the IP/1394-capable device.

Arguments:

    Nic1394ConfigRom - Pointer to the unitialized config ROM structure.

Return Value:

    None

--*/
{
    PNIC1394_CONFIG_ROM pCR = Nic1394ConfigRom;
    INT i;

    RtlZeroMemory(pCR, sizeof(*pCR));

    //
    // Initialize the unit directory header.
    //
    pCR->unit_dir.Info.DI_Length =              sizeof(pCR->unit_dir.contents)/
                                                sizeof(ULONG);

    //
    // Initialize the entries of the unit directory.
    //
    pCR->unit_dir.contents.SpecId.IE_Key        = SPEC_ID_KEY_SIGNATURE;
    pCR->unit_dir.contents.SpecId.IE_Value      = NIC1394_UnitSpecIdValue;
    pCR->unit_dir.contents.SwVersion.IE_Key     = SOFTWARE_VERSION_KEY_SIGNATURE;
    pCR->unit_dir.contents.SwVersion.IE_Value   = NIC1394_UnitSwVersionValue;
    pCR->unit_dir.contents.ModelId.IE_Key       = MODEL_KEY_SIGNATURE;
    pCR->unit_dir.contents.ModelId.IE_Value     = NIC1394_ModelSpecIdValue;
    pCR->unit_dir.contents.ModelIdTextOffset.OE_Key
        = TEXTUAL_LEAF_INDIRECT_KEY_SIGNATURE;
    pCR->unit_dir.contents.ModelIdTextOffset.OE_Offset
        = ( FIELD_OFFSET(NIC1394_CONFIG_ROM, model_text_dir)
           -FIELD_OFFSET(NIC1394_CONFIG_ROM, unit_dir.contents.ModelIdTextOffset))
          / sizeof (ULONG);

    // Initialize the model text directory header.
    //
    pCR->model_text_dir.Info.DI_Length =    sizeof(pCR->model_text_dir.contents)/
                                            sizeof(ULONG);

    //
    // Initialize the model text directory contents
    //
    pCR->model_text_dir.contents.SpecId.IE_Key  = 0x80;     // For "text leaf"
    pCR->model_text_dir.contents.SpecId.IE_Value= 0x0;      // For "text leaf"
    pCR->model_text_dir.contents.LanguageId     = 0x409;    // For "unicode"
    ASSERT(sizeof(pCR->model_text_dir.contents.Text)>=sizeof(NIC1394_ModelName));
    RtlCopyMemory(
            pCR->model_text_dir.contents.Text,
            NIC1394_ModelName,
            sizeof(NIC1394_ModelName)
            );

    //
    // Now convert into over-the-wire format (watch out for the unicode string in
    // pCR->model_test_dir.contents.Text.
    //

    //
    // Byte swap the unicode strings here, cuz we're gonna byte swap
    // everything down below - so it'll come out a wash.
    //

    for (i=0; i < sizeof(pCR->model_text_dir.contents.Text)/sizeof(ULONG); i++)
    {
        pCR->model_text_dir.contents.Text[i] = 
            bswap(pCR->model_text_dir.contents.Text[i]);
    
    }

    //
    // Now we've got to byte swap the entire config rom so other
    // nodes can read it correctly from accross the bus.
    // We need to do this BEFORE computing the CRC.
    //

    for (i=0; i < (sizeof(*pCR)/sizeof(ULONG)); i++)
    {
        ((PULONG) pCR)[i] =  bswap(((PULONG) pCR)[i]);
    }

    //
    // Compute the following CRC:
    //
    //  pCR->unit_dir.Info.DI_CRC
    //  pCR->model_text_dir.Info.DI_CRC
    //
    // NOTE: we have bswapped all cfg rom, so we need to temporarily "unbswap"
    // the two DIRECTORY_INFOs to set the CRC.
    //
    {
        DIRECTORY_INFO Info;


        Info =  pCR->unit_dir.Info; // Struct copy.
        *(PULONG)&Info = bswap(*(PULONG)&Info);     // "unbswap"
        Info.u.DI_CRC =  (USHORT) Bus1394CalculateCrc(
                                        (PULONG)&(pCR->unit_dir.contents),
                                        Info.DI_Length
                                        );
        *(PULONG)(&pCR->unit_dir.Info) = bswap (*(PULONG)&Info); // "re-bswap"


        Info =  pCR->model_text_dir.Info; // Struct copy.
        *(PULONG)&Info = bswap(*(PULONG)&Info);             // "unbeswap"
        Info.u.DI_CRC =  (USHORT) Bus1394CalculateCrc(
                                        (PULONG)&(pCR->model_text_dir.contents),
                                        Info.DI_Length
                                        );
        *(PULONG)(&pCR->model_text_dir.Info) = bswap (*(PULONG)&Info); // "re-bswap"
    }
}

//
//  From bus\buspnp.c
//

ULONG
Bus1394CalculateCrc(
    IN PULONG Quadlet,
    IN ULONG length
    )

/*++

Routine Description:

    This routine calculates a CRC for the pointer to the Quadlet data.

Arguments:

    Quadlet - Pointer to data to CRC

    length - length of data to CRC

Return Value:

    returns the CRC

--*/

{
    
    LONG temp;
    ULONG index;

    temp = index = 0;

    while (index < length) {

        temp = Bus1394Crc16(Quadlet[index++], temp);

    }

    return (temp);

} 


ULONG
Bus1394Crc16(
    IN ULONG data,
    IN ULONG check
    )

/*++

Routine Description:

    This routine derives the 16 bit CRC as defined by IEEE 1212
    clause 8.1.5.  (ISO/IEC 13213) First edition 1994-10-05.

Arguments:

    data - ULONG data to derive CRC from

    check - check value

Return Value:

    Returns CRC.

--*/

{

    LONG shift, sum, next;


    for (next=check, shift=28; shift >= 0; shift -=4) {

        sum = ((next >> 12) ^ (data >> shift)) & 0xf;
        next = (next << 4) ^ (sum << 12) ^ (sum << 5) ^ (sum);

    }

    return (next & 0xFFFF);

}

void DumpCfgRomCRC(void)
{
    NIC1394_CONFIG_ROM Net1394ConfigRom;
    unsigned char *pb = (unsigned char*) &Net1394ConfigRom;
    INT i;

    InitializeNic1394ConfigRom(&Net1394ConfigRom);

    printf("unsigned char Net1394ConfigRom[%lu] = {", sizeof(Net1394ConfigRom));
    for (i=0; i<(sizeof(Net1394ConfigRom)-1); i++)
    {
        if ((i%8) == 0)
        {
            printf("\n\t");
        }
        printf("0x%02lx, ", pb[i]);
    }
    printf("0x%02lx\n};\n", pb[i]);
}
#endif // TESTPROGRAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\mcap.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    mcap.c

Abstract:

    ARP1394 MCAP protocol code.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     10-01-99    Created

Notes:

--*/
#include <precomp.h>

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_MCAP


//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================
NDIS_STATUS
arpParseMcapPkt(
    IN   PIP1394_MCAP_PKT pMcapPkt,
    IN   UINT                       cbBufferSize,
    OUT  PIP1394_MCAP_PKT_INFO      pPktInfo
    );


VOID
arpProcessMcapAdvertise(
    PARP1394_INTERFACE          pIF,    // NOLOCKIN NOLOCKOUT
    PIP1394_MCAP_PKT_INFO   pPktInfo,
    PRM_STACK_RECORD            pSR
    );

VOID
arpProcessMcapSolicit(
    PARP1394_INTERFACE          pIF,    // NOLOCKIN NOLOCKOUT
    PIP1394_MCAP_PKT_INFO   pPktInfo,
    PRM_STACK_RECORD            pSR
    );

VOID
arpUpdateMcapInfo(
    IN  PARP1394_INTERFACE          pIF,        // NOLOCKIN NOLOCKOUT
    IN  PIP1394_MCAP_PKT_INFO       pPktInfo,
    PRM_STACK_RECORD                pSR
    );

NDIS_STATUS
arpParseMcapPkt(
    IN   PIP1394_MCAP_PKT pMcapPkt,
    IN   UINT                       cbBufferSize,
    OUT  PIP1394_MCAP_PKT_INFO      pPktInfo
    );

NDIS_STATUS
arpParseMcapPkt(
    IN   PIP1394_MCAP_PKT pMcapPkt,
    IN   UINT                       cbBufferSize,
    OUT  PIP1394_MCAP_PKT_INFO      pPktInfo
    )
/*++
Routine Description:

    Parse the contents of IP/1394 MCAP packet data starting at
    pMcapPkt. Place the results into pPktInfo.

Arguments:

    pMcapPkt    - Contains the unaligned contents of an ip/1394 MCAP Pkt.
    pPktInfo    - Unitialized structure to be filled with the parsed contents of the
                  pkt.

Return Value:

    NDIS_STATUS_FAILURE if the parse failed (typically because of invalid pkt
                        contents.)
    NDIS_STATUS_SUCCESS on successful parsing.
    
--*/
{
    ENTER("arpParseMcapPkt", 0x95175d5a)
    NDIS_STATUS                 Status;
    DBGSTMT(CHAR *szError   = "General failure";)

    Status  = NDIS_STATUS_FAILURE;

    do
    {
        UINT OpCode; // MCAP op code (solicit/advertise)
        UINT Length; // Length of valid part of packet, including the encap header.
        UINT NumGds; // Number of group_descriptors;

        // Minimum size.
        //
        if (cbBufferSize < FIELD_OFFSET(IP1394_MCAP_PKT, group_descriptors))
        {
            DBGSTMT(szError = "Packet too small";)
            break;
        }

        // Ethertype
        //
        if (pMcapPkt->header.EtherType != H2N_USHORT(NIC1394_ETHERTYPE_MCAP))
        {
            DBGSTMT(szError = "header.EtherType!=MCAP";)
            break;
        }


        // length
        //
        {
            // pMcapPkt->length is the length of packet excluding the unfragmented
            // header.
            //
            Length =  (ULONG) N2H_USHORT(pMcapPkt->length) + sizeof(pMcapPkt->header);
            if (Length > cbBufferSize)
            {
                DBGSTMT(szError = "Length field too large";)
                break;
            }
            // Note: it's valid to have zero group descriptors.
            //
            if (Length < FIELD_OFFSET(IP1394_MCAP_PKT, group_descriptors))
            {
                DBGSTMT(szError = "Length field too small";)
                break;
            }
        }

        // reserved field
        //
        if (pMcapPkt->reserved != 0)
        {
            DBGSTMT(szError = "reserved != 0";)
            break;
        }

        // Opcode
        //
        {
            OpCode = N2H_USHORT(pMcapPkt->opcode);
    
            if (    OpCode !=  IP1394_MCAP_OP_ADVERTISE
                &&  OpCode !=  IP1394_MCAP_OP_SOLICIT)
            {
                DBGSTMT(szError = "Invalid opcode";)
                break;
            }
        }


        // Now we check the descriptors
        //
        {
            PIP1394_MCAP_GD pGd;
            DBGSTMT(PIP1394_MCAP_GD pGdEnd;)
            UINT u;
            
            // Note: we've already verified that Length is large enough.
            //
            NumGds = (Length - FIELD_OFFSET(IP1394_MCAP_PKT, group_descriptors))
                     / sizeof(IP1394_MCAP_GD);
            pGd = pMcapPkt->group_descriptors;
            DBGSTMT(pGdEnd = (PIP1394_MCAP_GD) (((PUCHAR) pMcapPkt) + cbBufferSize);)

            for (u=NumGds; u>0; u--, pGd++)
            {
                IP1394_MCAP_GD Gd;
                ASSERT(pGd < pGdEnd);
                Gd = *pGd;              // Unaligned struct copy.

                if (Gd.length != sizeof(Gd))
                {
                    // bad length
                    //
                    DBGSTMT(szError = "Bad GD: bad length";)
                    break;
                }

                if (Gd.type != IP1394_MCAP_GD_TYPE_V1)
                {
                    // bad type
                    //
                    DBGSTMT(szError = "Bad GD: bad type";)
                    break;
                }

                if (Gd.reserved != 0)
                {
                    // bad reserved
                    //
                    DBGSTMT(szError = "Bad GD: bad reserved";)
                    break;
                }

                if (Gd.channel > 63)
                {
                    // bad channel
                    //
                    DBGSTMT(szError = "Bad GD: bad channel";)
                    break;
                }

                // We don't check speed code to interop with unknown speeds.
                // (we map unknown speeds to the highest speed code we know about.

                if (Gd.reserved2 != 0)
                {
                    // bad reserved2
                    //
                    DBGSTMT(szError = "Bad GD: bad reserved2";)
                    break;
                }

                if (Gd.bandwidth != 0)
                {
                    // bad bandwidth
                    //
                    DBGSTMT(szError = "Bad GD: bad bandwidth";)
                    break;
                }


                {
                    UINT Addr = H2N_ULONG(Gd.group_address);
                    if ( (Addr & 0xf0000000) != 0xe0000000)
                    {
                        // Address is not class D
                        //
                        DBGSTMT(szError = "Bad GD: address not class D";)
                        break;
                    }
                    if (Addr == 0xe0000001 || Addr == 0xe0000002)
                    {
                        // 224.0.0.1 and 224.0.0.2 must be sent on the broadcast
                        // channel
                        //
                        DBGSTMT(szError = "Bad GD: Address 224.0.0.1 or 2";)
                        break;
                    }
                }
            }

            if (u!=0)
            {
                break;
            }
            
        }

        //
        // Pkt appears valid, let's fill out the parsed information....
        //
    
        ARP_ZEROSTRUCT(pPktInfo);

        pPktInfo->NumGroups     =  NumGds;
        pPktInfo->SenderNodeID  =  N2H_USHORT(pMcapPkt->header.NodeId);
        pPktInfo->OpCode        =  OpCode;

        // Parse the group descriptors...
        // If required, dynamically allocate space for the descriptors,
        // otherwise we use pPktInfo->GdSpace;
        //
        {
            PIP1394_MCAP_GD pGd;
            PIP1394_MCAP_GD_INFO    pGdi;
            UINT                    cb = NumGds * sizeof(*pGdi);
            UINT                    u;

            if (cb <= sizeof(pPktInfo->GdiSpace))
            {
                pGdi = pPktInfo->GdiSpace;
            }
            else
            {
                NdisAllocateMemoryWithTag(&pGdi, cb,  MTAG_MCAP_GD);
                if (pGdi == NULL)
                {
                    DBGSTMT(szError = "Allocation Failure";)
                    Status = NDIS_STATUS_RESOURCES;
                    break;
                }
            }
            pPktInfo->pGdis = pGdi;

            // Now parse...
            //
            pGd = pMcapPkt->group_descriptors;

            for (u=NumGds; u>0; u--, pGd++, pGdi++)
            {
                pGdi->Expiration    = pGd->expiration;
                pGdi->Channel       = pGd->channel;
                pGdi->SpeedCode     = pGd->speed;
                pGdi->GroupAddress  = pGd->group_address; // Leave in Network order

                if (pGdi->Channel >=  ARP_NUM_CHANNELS)
                {
                    TR_INFO(("Bad channel in GD 0x%p\n",  pGdi));
                    continue;
                }

                //
                // Although RFC doesn't stipulate a max expiry time, we
                // cap it ourselves, in case this is a rogue packet.
                //
                #define MAX_EXPIRATION 120
                if (pGdi->Expiration >=  MAX_EXPIRATION)
                {
                    TR_INFO(("Capping expiry time to %d sec\n",  MAX_EXPIRATION));
                    pGdi->Expiration =  MAX_EXPIRATION;
                    continue;
                }

                if (pGdi->SpeedCode >  SCODE_3200_RATE)
                {
                    //
                    // This is either a bad value, or a rate higher than we know
                    // about. We can't distinguish between the two, so we just set
                    // the speed to the highest we know about.
                    //
                    pGdi->SpeedCode = SCODE_3200_RATE;
                }
            }
        }

        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    if (FAIL(Status))
    {
        TR_WARN(("Bad mcap pkt data at 0x%p (%s)\n",  pMcapPkt, szError));
    }
    else
    {
    #if DBG
        UINT    Addr    = 0;
        UINT    Channel = 0;
        UINT    Exp     = 0;
        PUCHAR  pc      = (PUCHAR) &Addr;

        if (pPktInfo->NumGroups!=0)
        {
            Addr    = pPktInfo->pGdis[0].GroupAddress;
            Channel = pPktInfo->pGdis[0].Channel;
            Exp     = pPktInfo->pGdis[0].Expiration;
        }
    #endif // DBG

        TR_WARN(("Received MCAP PKT. NodeId=0x%04lx NumGrps=%lu."
                 " 1st=(Grp=%lu.%lu.%lu.%lu, Ch=%lu, TTL=%lu)\n",
                pPktInfo->SenderNodeID,
                pPktInfo->NumGroups,
                pc[0], pc[1], pc[2], pc[3],
                Channel,
                Exp
                ));
    }

    EXIT()

    return Status;
}


NDIS_STATUS
arpCreateMcapPkt(
    IN  PARP1394_INTERFACE          pIF,
    IN  PIP1394_MCAP_PKT_INFO       pPktInfo,
    OUT PNDIS_PACKET               *ppNdisPacket,
    PRM_STACK_RECORD                pSR
    )
/*++

Routine Description:

    Use information in pPktInfo to allocate and initialize an mcap packet.

Arguments:

    pPktInfo        -   Parsed version of the arp request/response packet.
    ppNdisPacket    -   Points to a place to store a pointer to the allocated packet.
                    

Return Value:

    NDIS_STATUS_RESOURCES  - If we couldn't allocate the packet.
    NDIS_STATUS_SUCCESS    - on success.
    
--*/
{
    UINT                NumGroups;              
    UINT                Length;
    NDIS_STATUS         Status;
    PIP1394_MCAP_PKT    pPktData;


    NumGroups                   = pPktInfo->NumGroups;
    Length                      = FIELD_OFFSET(IP1394_MCAP_PKT, group_descriptors);
    Length                     += NumGroups * sizeof(IP1394_MCAP_GD);

    Status = arpAllocateControlPacket(
                pIF,
                Length,
                ARP1394_PACKET_FLAGS_MCAP,
                ppNdisPacket,
                &pPktData,
                pSR
                );

    if (FAIL(Status)) return Status;                // ***** EARLY RETURN ******


    // Can't use ARP_ZEROSTRUCT because NumGroups may be zero.
    //
    NdisZeroMemory(pPktData, Length);
    
    pPktData->header.EtherType  = H2N_USHORT(NIC1394_ETHERTYPE_MCAP);
    pPktData->opcode            = (UCHAR)pPktInfo->OpCode;
    Length                     -= sizeof(pPktData->header); // Skip the header.
    pPktData->length            = H2N_USHORT(Length);


    // Construct the group descriptors.
    //  
    if (NumGroups)
    {
        PIP1394_MCAP_GD_INFO    pGdi = pPktInfo->pGdis;
        PIP1394_MCAP_GD         pGd  = pPktData->group_descriptors;

        for(;NumGroups; pGdi++, pGd++, NumGroups--)
        {
            ARP_ZEROSTRUCT(pGd);
            pGd->length         = (UCHAR) sizeof(*pGd);
            pGd->expiration     = (UCHAR) pGdi->Expiration;
            pGd->channel        = (UCHAR) pGdi->Channel;
            pGd->speed          = (UCHAR) pGdi->SpeedCode;
            pGd->group_address  = pGdi->GroupAddress;
        }
    }

    return NDIS_STATUS_SUCCESS;
}


#if 0
// Parsed version of the IP/1394 MCAP Group Descriptor 
//
typedef struct
{
    UINT                    Expiration;
    UINT                    Channel;
    UINT                    SpeedCode;
    IP_ADDRESS              GroupAddress;

}  IP1394_MCAP_GD_INFO, * PIP1394_MCAP_GD_INFO;


// Parsed version of an IP/1394 MCAP packet.
//
typedef struct
{
    UINT                    SenderNodeID;
    UINT                    OpCode;
    UINT                    NumGroups;
    PIP1394_MCAP_GD_INFO    pGdis;

    // Space for storing up-to 4 GD_INFOs
    //
    IP1394_MCAP_GD_INFO     GdiSpace[4];

} IP1394_MCAP_PKT_INFO, *PIP1394_MCAP_PKT_INFO;
#endif // 0



VOID
arpUpdateMcapInfo(
    IN  PARP1394_INTERFACE          pIF,        // NOLOCKIN NOLOCKOUT
    IN  PIP1394_MCAP_PKT_INFO       pPktInfo,
    PRM_STACK_RECORD                pSR
)
{
    ENTER("arpUpdateMcapInfo", 0xcac15343)
    PIP1394_MCAP_GD_INFO    pGdi;
    UINT                    NumGroups;
    UINT                    Current;
    UINT                    NodeId;
    RM_DECLARE_STACK_RECORD(sr)


    RM_ASSERT_OBJUNLOCKED(&pIF->Hdr, pSR);

    // Get the current time (in seconds).
    //
    Current = arpGetSystemTime();

    //
    //  Go through the group discriptors, updating our database.
    //
    NumGroups = pPktInfo->NumGroups;
    pGdi      = pPktInfo->pGdis;
    NodeId    = pPktInfo->SenderNodeID;

    for(;NumGroups; pGdi++, NumGroups--)
    {
        UINT        Expiration      =  pGdi->Expiration;
        UINT        Channel         =  pGdi->Channel;
        IP_ADDRESS  GroupAddress    = pGdi->GroupAddress;
        PMCAP_CHANNEL_INFO pMci;

        //
        // Process this group descriptor.
        //

        if (Channel >= ARP_NUM_CHANNELS)
        {
            ASSERT(FALSE); // we should have already screened this value.
            continue;
        }

        LOCKOBJ(pIF, &sr);
        
        pMci = &pIF->mcapinfo.rgChannelInfo[Channel];
        pMci->Channel = Channel;
        pMci->GroupAddress = GroupAddress;
        pMci->UpdateTime = Current;
        pMci->ExpieryTime = Current + Expiration; // Expiration is in seconds.
        pMci->Flags = 0;       // Reset flags.
        pMci->NodeId = NodeId; // TODO: check if existing node id is higher?

        UNLOCKOBJ(pIF, &sr);

    }

    RM_ASSERT_OBJUNLOCKED(&pIF->Hdr, pSR);
}


VOID
arpProcessMcapPkt(
    PARP1394_INTERFACE  pIF,    // NOLOCKIN NOLOCKOUT
    PIP1394_MCAP_PKT    pMcapPkt,
    UINT                cbBufferSize
    )
{
    NDIS_STATUS Status;
    IP1394_MCAP_PKT_INFO    PktInfo;
    ENTER("arpProcessMcapPkt", 0xc5ba8005)
    RM_DECLARE_STACK_RECORD(sr)

    DBGMARK(0x3cfaf454);

    Status = arpParseMcapPkt(
                pMcapPkt,
                cbBufferSize,
                &PktInfo
                );


    if (!FAIL(Status))
    {
        if (PktInfo.OpCode == IP1394_MCAP_OP_ADVERTISE)
        {
            arpProcessMcapAdvertise(pIF, &PktInfo, &sr);
        }
        else
        {
            ASSERT(PktInfo.OpCode ==  IP1394_MCAP_OP_SOLICIT);
            arpProcessMcapSolicit(pIF, &PktInfo, &sr);
        }
    }

    RM_ASSERT_CLEAR(&sr);

    EXIT()

}

VOID
arpProcessMcapAdvertise(
    PARP1394_INTERFACE          pIF,    // NOLOCKIN NOLOCKOUT
    PIP1394_MCAP_PKT_INFO   pPktInfo,
    PRM_STACK_RECORD            pSR
    )
{
    //
    // Update our database.
    //
    arpUpdateMcapInfo(
            pIF,        // NOLOCKIN NOLOCKOUT
            pPktInfo,
            pSR
            );
}

VOID
arpProcessMcapSolicit(
    PARP1394_INTERFACE          pIF,    // NOLOCKIN NOLOCKOUT
    PIP1394_MCAP_PKT_INFO   pPktInfo,
    PRM_STACK_RECORD            pSR
    )
{
    //
    // We ignore solicit messages.
    //
    //

}


MYBOOL
arpIsActiveMcapChannel(
        PMCAP_CHANNEL_INFO pMci,
        UINT CurrentTime
        )
{
    ENTER("IsActiveMcapChannel", 0x0)
    MYBOOL fOk = TRUE;
    
    // Check update time.
    //
    #define  ARP_MAX_MCAP_UPDATE_INTERVAL 60
    if ((pMci->UpdateTime+ARP_MAX_MCAP_UPDATE_INTERVAL) < CurrentTime)
    {
        TR_WARN(("McapDB: channel %lu update time crossed.\n",
                pMci->Channel
                ));
        fOk = FALSE;
    }

    // Check expire time.
    //
    if (pMci->ExpieryTime <= CurrentTime)
    {
        TR_WARN(("McapDB: channel %lu time expired.\n",
                pMci->Channel
                ));
        fOk = FALSE;
    }

    return fOk;
}

VOID
arpLocallyUpdateMcapInfo(
        PARP1394_INTERFACE pIF,
        UINT Channel,
        UINT GroupAddress,
        UINT CurrentTime,
        PRM_STACK_RECORD pSR
        )
{
    ENTER("arpLocallyUpdateMcapInfo", 0x0)
    PMCAP_CHANNEL_INFO pMci;

    LOCKOBJ(pIF, pSR);
    
    pMci = &pIF->mcapinfo.rgChannelInfo[Channel];
    pMci->Channel = Channel;
    pMci->GroupAddress = GroupAddress;
    pMci->UpdateTime = CurrentTime;
    pMci->ExpieryTime = CurrentTime + 60; // Expiration is in seconds.
    pMci->Flags = 0;       // Reset flags.
    pMci->NodeId = 0;  // NodeId; // TODO: get real node id.

    UNLOCKOBJ(pIF, pSR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\md5.c ===
//
// Copyright (c) 1998-1999, Microsoft Corporation, all rights reserved
//
// md5.c
//
// IEEE1394 ARP module
//
//
// 08/08/2000 ADube created.  
// 
// Purpose: Create a unique MAC address from 1394 EUID 
// 
//This file should use the same algorithm as nic1394 uses. 
//
// Derived from derived from the RSA Data  Security, 
// Inc. MD5 Message-Digest Algorithm 
//

#include <precomp.h>
#pragma hdrstop

/*
  been defined with C compiler flags.
 */
#ifndef PROTOTYPES
#define PROTOTYPES 1
#endif

/* POINTER defines a generic pointer type */
typedef unsigned char *POINTER;

/* UINT2 defines a two byte word */
typedef unsigned short int UINT2;

/* UINT4 defines a four byte word */
typedef unsigned long int UINT4;

/* PROTO_LIST is defined depending on how PROTOTYPES is defined above.
If using PROTOTYPES, then PROTO_LIST returns the list, otherwise it
  returns an empty list.
 */
#if PROTOTYPES
#define PROTO_LIST(list) list
#else
#define PROTO_LIST(list) ()
#endif


/* MD5 context. */

typedef struct _MD5_CTX{
  UINT4 state[4];                                   /* state (ABCD) */
  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
  unsigned char buffer[64];                         /* input buffer */
} MD5_CTX, MD_CTX;

typedef ENetAddr MAC_ADDRESS, *PMAC_ADDRESS;

void MD5Init PROTO_LIST ((MD5_CTX *));
void MD5Update PROTO_LIST
  ((MD5_CTX *, unsigned char *, unsigned int));
void MD5Final PROTO_LIST ((unsigned char [16], MD5_CTX *));


// Constants for MD5Transform routine.

#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21

static void MD5Transform PROTO_LIST ((UINT4 [4], unsigned char [64]));
static void Encode PROTO_LIST
  ((unsigned char *, UINT4 *, unsigned int));
static void Decode PROTO_LIST
  ((UINT4 *, unsigned char *, unsigned int));
static void MD5_memcpy PROTO_LIST ((POINTER, POINTER, unsigned int));
static void MD5_memset PROTO_LIST ((POINTER, int, unsigned int));

static unsigned char PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

// F, G, H and I are basic MD5 functions.
 
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))

// ROTATE_LEFT rotates x left n bits.
 
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))

// FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
// Rotation is separate from addition to prevent recomputation.
 
#define FF(a, b, c, d, x, s, ac) { \
 (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define GG(a, b, c, d, x, s, ac) { \
 (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define HH(a, b, c, d, x, s, ac) { \
 (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }
#define II(a, b, c, d, x, s, ac) { \
 (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \
 (a) = ROTATE_LEFT ((a), (s)); \
 (a) += (b); \
  }

// MD5 initialization. Begins an MD5 operation, writing a new context.
 
void 
MD5Init (
    MD5_CTX *context// context 
    )
{
  context->count[0] = context->count[1] = 0;
  // Load magic initialization constants.

  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
  context->state[3] = 0x10325476;
}

// MD5 block update operation. Continues an MD5 message-digest
//  operation, processing another message block, and updating the
//  context.
 
void 
MD5Update (
    MD5_CTX *context,   // context 
    unsigned char *input,   // input block 
    unsigned int inputLen   // length of input block 
    )
{
    unsigned int i, index, partLen;

    // Compute number of bytes mod 64 
    index = (unsigned int)((context->count[0] >> 3) & 0x3F);

    // Update number of bits 
    if ((context->count[0] += ((UINT4)inputLen << 3))
        < ((UINT4)inputLen << 3))
    {        
        context->count[1]++;
    }
    
    context->count[1] += ((UINT4)inputLen >> 29);

    partLen = 64 - index;

    // Transform as many times as possible.

    if (inputLen >= partLen) 
    {
        MD5_memcpy   ((POINTER)&context->buffer[index], 
                        (POINTER)input, 
                        partLen);

        MD5Transform (context->state, context->buffer);

        for (i = partLen; i + 63 < inputLen; i += 64)
        {
            MD5Transform (context->state, &input[i]);
        }

        index = 0;
    }
    else
    {
        i = 0;
    }
    // Buffer remaining input 
    MD5_memcpy
    ((POINTER)&context->buffer[index], (POINTER)&input[i],
    inputLen-i);
}

// MD5 finalization. Ends an MD5 message-digest operation, writing the
// the message digest and zeroizing the context.
 
void 
MD5Final (
    unsigned char digest[16],                         // message digest 
    MD5_CTX *context
    )                                       // context 
{
  unsigned char bits[8];
  unsigned int index, padLen;

  // Save number of bits 
  Encode (bits, context->count, 8);

  // Pad out to 56 mod 64.

  index = (unsigned int)((context->count[0] >> 3) & 0x3f);
  padLen = (index < 56) ? (56 - index) : (120 - index);
  MD5Update (context, PADDING, padLen);

  // Append length (before padding) 
  MD5Update (context, bits, 8);

  // Store state in digest 
  Encode (digest, context->state, 6);

  // Zeroize sensitive information.

  MD5_memset ((POINTER)context, 0, sizeof (*context));
}

// MD5 basic transformation. Transforms state based on block.
 
static 
void 
MD5Transform (
    UINT4 state[4],
    unsigned char block[64]
    )
{
  UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];

  Decode (x, block, 64);

  // Round 1 
  FF (a, b, c, d, x[ 0], S11, 0xd76aa478); // 1 
  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); // 2 
  FF (c, d, a, b, x[ 2], S13, 0x242070db); // 3 
  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); // 4 
  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); // 5 
  FF (d, a, b, c, x[ 5], S12, 0x4787c62a); // 6 
  FF (c, d, a, b, x[ 6], S13, 0xa8304613); // 7 
  FF (b, c, d, a, x[ 7], S14, 0xfd469501); // 8 
  FF (a, b, c, d, x[ 8], S11, 0x698098d8); // 9 
  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); // 10 
  FF (c, d, a, b, x[10], S13, 0xffff5bb1); // 11 
  FF (b, c, d, a, x[11], S14, 0x895cd7be); // 12 
  FF (a, b, c, d, x[12], S11, 0x6b901122); // 13 
  FF (d, a, b, c, x[13], S12, 0xfd987193); // 14 
  FF (c, d, a, b, x[14], S13, 0xa679438e); // 15 
  FF (b, c, d, a, x[15], S14, 0x49b40821); // 16 

 // Round 2 
  GG (a, b, c, d, x[ 1], S21, 0xf61e2562); // 17 
  GG (d, a, b, c, x[ 6], S22, 0xc040b340); // 18 
  GG (c, d, a, b, x[11], S23, 0x265e5a51); // 19 
  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); // 20 
  GG (a, b, c, d, x[ 5], S21, 0xd62f105d); // 21 
  GG (d, a, b, c, x[10], S22,  0x2441453); // 22 
  GG (c, d, a, b, x[15], S23, 0xd8a1e681); // 23 
  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); // 24 
  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); // 25 
  GG (d, a, b, c, x[14], S22, 0xc33707d6); // 26 
  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); // 27 
  GG (b, c, d, a, x[ 8], S24, 0x455a14ed); // 28 
  GG (a, b, c, d, x[13], S21, 0xa9e3e905); // 29 
  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); // 30 
  GG (c, d, a, b, x[ 7], S23, 0x676f02d9); // 31 
  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); // 32 

  // Round 3 
  HH (a, b, c, d, x[ 5], S31, 0xfffa3942); // 33 
  HH (d, a, b, c, x[ 8], S32, 0x8771f681); // 34 
  HH (c, d, a, b, x[11], S33, 0x6d9d6122); // 35 
  HH (b, c, d, a, x[14], S34, 0xfde5380c); // 36 
  HH (a, b, c, d, x[ 1], S31, 0xa4beea44); // 37 
  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); // 38 
  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); // 39 
  HH (b, c, d, a, x[10], S34, 0xbebfbc70); // 40 
  HH (a, b, c, d, x[13], S31, 0x289b7ec6); // 41 
  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); // 42 
  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); // 43 
  HH (b, c, d, a, x[ 6], S34,  0x4881d05); // 44 
  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); // 45 
  HH (d, a, b, c, x[12], S32, 0xe6db99e5); // 46 
  HH (c, d, a, b, x[15], S33, 0x1fa27cf8); // 47 
  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); // 48 

  // Round 4 
  II (a, b, c, d, x[ 0], S41, 0xf4292244); // 49 
  II (d, a, b, c, x[ 7], S42, 0x432aff97); // 50 
  II (c, d, a, b, x[14], S43, 0xab9423a7); // 51 
  II (b, c, d, a, x[ 5], S44, 0xfc93a039); // 52 
  II (a, b, c, d, x[12], S41, 0x655b59c3); // 53 
  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); // 54 
  II (c, d, a, b, x[10], S43, 0xffeff47d); // 55 
  II (b, c, d, a, x[ 1], S44, 0x85845dd1); // 56 
  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); // 57 
  II (d, a, b, c, x[15], S42, 0xfe2ce6e0); // 58 
  II (c, d, a, b, x[ 6], S43, 0xa3014314); // 59 
  II (b, c, d, a, x[13], S44, 0x4e0811a1); // 60 
  II (a, b, c, d, x[ 4], S41, 0xf7537e82); // 61 
  II (d, a, b, c, x[11], S42, 0xbd3af235); // 62 
  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); // 63 
  II (b, c, d, a, x[ 9], S44, 0xeb86d391); // 64 

  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;

  // Zeroize sensitive information.

  MD5_memset ((POINTER)x, 0, sizeof (x));
}

// Encodes input (UINT4) into output (unsigned char). Assumes len is
// a multiple of 4.
 
static 
void 
Encode (
    unsigned char *output,
    UINT4 *input,
    unsigned int len
    )
{
    unsigned int i, j;

    for (i = 0, j = 0; j < len; i++, j += 4) 
    {
        output[j] = (unsigned char)(input[i] & 0xff);
        output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
        output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
        output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
    }
}

// Decodes input (unsigned char) into output (UINT4). Assumes len is
// a multiple of 4.
 
static 
void 
Decode (
    UINT4 *output,
    unsigned char *input,
    unsigned int len
    )
{
  unsigned int i, j;

    for (i = 0, j = 0; j < len; i++, j += 4)
    {
    output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) << 8) |
                (((UINT4)input[j+2]) << 16) | (((UINT4)input[j+3]) << 24);
    }
}

// Note: Replace "for loop" with standard memcpy if possible.
 

static 
void 
MD5_memcpy (
    POINTER output,
    POINTER input,
    unsigned int len
    )
{
    unsigned int i;

    for (i = 0; i < len; i++)
    { 
        output[i] = input[i];
    }
}

// Note: Replace "for loop" with standard memset if possible.
 
static 
void 
MD5_memset (
    POINTER output,
    int value,
    unsigned int len
    )
{
    unsigned int i;

    for (i = 0; i < len; i++)
    {   
        ((char *)output)[i] = (char)value;
    }
}


#define ETH_IS_MULTICAST(Address) \
        (BOOLEAN)(((PUCHAR)(Address))[0] & ((UCHAR)0x01))


VOID
nicGetMacAddressFromEuid (
    UINT64 *pEuid,
    MAC_ADDRESS *pMacAddr
    )
/*
Taken directly from nic1394 and is intended to produce the same output as nic1394.

This is used to create display Correct HW addr in the arp -a output. 

We take the Unique ID and run it through the MD5 algorithm because this is what
nic1394 would have done to get the MAC address that it reports to us

I have the name as nicGet.. to imply that this should be the same alogorithm as nic1394's md5
algorithm

*/
{

    MD_CTX context;
    unsigned char digest[6];
    unsigned int len = 8;

    MD5Init (&context);
    MD5Update (&context, (unsigned char*)pEuid, len);
    MD5Final (digest, &context);

    NdisMoveMemory (pMacAddr, digest, 6);

    // Set the locally administered bit 
    // and clear the multicast bit.

    //
    // randomize the returned Mac Address
    // by xor ing the address with a random 
    // 0xf22f617c91e0 (a random number)
    //
    //pMacAddr->addr[0] ^= 0x00;
    pMacAddr->addr[0] |= 0x2;
    pMacAddr->addr[0] &= 0xf2;
    pMacAddr->addr[1] ^= 0x2f;
    pMacAddr->addr[2] ^= 0x61;
    pMacAddr->addr[3] ^= 0x7c;
    pMacAddr->addr[4] ^= 0x91;
    pMacAddr->addr[5] ^= 0x30;

    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\pkt.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    pkt.c

Abstract:

    ARP1394 ARP control packet management.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     07-01-99    Created

Notes:

--*/
#include <precomp.h>

//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_PKT

//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================

NDIS_STATUS
arpAllocateControlPacketPool(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    UINT                MaxBufferSize,
    PRM_STACK_RECORD    pSR
    )
/*++
Routine Description:

    Allocate & initialize the packet pool used for allocating control packets.
    Control packets are used for ARP and MCAP. This routine MUST be called
    BEFORE the first call to arpAllocateControlPacket.

Arguments:

    pIF             - The interface in which to allocate the pool. Only one such pool
                      is allocated per interface and it occupies a specific field of
                      pIF.
    MaxBufferSize   - Maximum data size of packets to be allocated using this
                      pool. Attempts to allocate a packet
                      (using arpAllocateControlPacket) with a size larger than
                      MaxBufferSize will fail.

Return Value:

    NDIS_STATUS_SUCCESS on success.
    Ndis error code on failure.
    
--*/
{
    NDIS_STATUS Status;
    NDIS_HANDLE PacketPool=NULL;
    NDIS_HANDLE BufferPool=NULL;
    ENTER("arpAllocateControlPacketPool", 0x71579254)

    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);
    ASSERT(pIF->arp.PacketPool == NULL);
    ASSERT(pIF->arp.BufferPool == NULL);
    ASSERT(pIF->arp.NumOutstandingPackets == 0);

    do
    {
        // Allocate the NDIS Packet Pool
        //
        NdisAllocatePacketPool(
                &Status,
                &PacketPool,
                ARP1394_MAX_PROTOCOL_PKTS,
                sizeof(struct PCCommon)
                );
    
        if (FAIL(Status))
        {
            PacketPool = NULL;
            break;
        }
    
        // Allocate the NDIS Buffer Pool
        //
        NdisAllocateBufferPool(
                &Status,
                &BufferPool,
                ARP1394_MAX_PROTOCOL_PKTS
                );
    
        if (FAIL(Status))
        {
            BufferPool = NULL;
            break;
        }
    
        //
        // We could allocate a lookaside list for the Protocol data, but we
        // choose to use NdisAllocateMemoryWithTag on demand instead. Protocol pkts
        // are not high-frequency things; plus we don't have support for lookaside
        // lists on win98 (although we could easily implement our own for 
        // win98, so that's not really an excuse).
        //
        pIF->arp.MaxBufferSize = MaxBufferSize;
    
        //  (DBG only) Add associations for the packet pool and buffer pool.
        //  These associations must be removed before the interface is deallocated.
        //
        DBG_ADDASSOC(
            &pIF->Hdr,                  // pObject
            PacketPool,                 // Instance1
            NULL,                       // Instance2
            ARPASSOC_IF_PROTOPKTPOOL,   // AssociationID
            "    Proto Packet Pool 0x%p\n",// szFormat
            pSR
            );
        DBG_ADDASSOC(
            &pIF->Hdr,                  // pObject
            BufferPool,                 // Instance1
            NULL,                       // Instance2
            ARPASSOC_IF_PROTOBUFPOOL,   // AssociationID
            "    Proto Buffer Pool 0x%p\n",// szFormat
            pSR
            );

        pIF->arp.PacketPool = PacketPool;
        pIF->arp.BufferPool = BufferPool;
        PacketPool = NULL;
        BufferPool = NULL;

    } while (FALSE);

    if (FAIL(Status))
    {
        if (PacketPool != NULL)
        {
            NdisFreePacketPool(PacketPool);
        }
    
        if (BufferPool != NULL)
        {
            NdisFreeBufferPool(BufferPool);
        }
    }
    else
    {
        ASSERT(PacketPool == NULL && BufferPool == NULL);
    }

    return Status;
}


VOID
arpFreeControlPacketPool(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    )
/*++
Routine Description:

    Free the previously allocated control packet pool. MUST be called AFTER the last
    call to arpFreeControlPacket. See arpAllocateControlPacketPool for more details.

Arguments:

    pIF     - The interface in which to free the pool.

--*/
{
    NDIS_HANDLE PacketPool;
    NDIS_HANDLE BufferPool;
    ENTER("arpFreeControlPacketPool", 0x3c3acf47)

    // Make sure the IF is locked.
    //
    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);

    // Make sure that there are no outstanding allocated packets.
    //
    ASSERT(pIF->arp.NumOutstandingPackets == 0);

    PacketPool = pIF->arp.PacketPool;
    BufferPool = pIF->arp.BufferPool;
    pIF->arp.PacketPool = NULL;
    pIF->arp.BufferPool = NULL;
    
    // (DBG only) Remove associations for the control and packet pools.
    //
    DBG_DELASSOC(
        &pIF->Hdr,                  // pObject
        PacketPool,                 // Instance1
        NULL,                       // Instance2
        ARPASSOC_IF_PROTOPKTPOOL,   // AssociationID
        pSR
        );
    DBG_DELASSOC(
        &pIF->Hdr,                  // pObject
        BufferPool,                 // Instance1
        NULL,                       // Instance2
        ARPASSOC_IF_PROTOBUFPOOL,   // AssociationID
        pSR
        );

    // Free the buffer and packet pools
    // 
    NdisFreeBufferPool(BufferPool);
    NdisFreePacketPool(PacketPool);
}


NDIS_STATUS
arpAllocateControlPacket(
    IN  PARP1394_INTERFACE  pIF,
    IN  UINT                cbBufferSize,
    IN  UINT                PktFlags,
    OUT PNDIS_PACKET        *ppNdisPacket,
    OUT PVOID               *ppvData,
        PRM_STACK_RECORD    pSR
    )
/*++
Routine Description:

    Allocate a control packet from the interfaces control packet pool. Also
    allocate and chain a SINGLE buffer of size cbBufferSize and return a pointer to
    this buffer in *ppvData.

    NOTE1: The packet and associated buffer MUST be freed
    by a subsequent call to arpFreeControlPacket -- do not free the packet & buffer
    by directly calling ndis apis.

    NOTE2: cbBufferSize must be <= the max-buffer-size specified when
    creating the pool (see arpAllocateControlPacketPool for details).

Arguments:

    pIF             - Interface whose control packet pool to use.
    cbBufferSize    - size of the control packet.
    ppNdisPacket    - Location to set to point to the allocated pkt.
    ppvData         - Location to set to point to the packet data (single buffer).

Return Value:

    NDIS_STATUS_SUCCESS     on success.
    NDIS_STATUS_RESOURCES   if buffers or pkts are currently not available.
    Other ndis error         on other kinds of failures.
--*/
{
    NDIS_STATUS             Status;
    PNDIS_PACKET            pNdisPacket = NULL;
    PNDIS_BUFFER            pNdisBuffer = NULL;
    PVOID                   pvData = NULL;
    ENTER("arpAllocateControlPacket", 0x8ccce6ea)

    //
    // NOTE: we don't care if pIF is locked or not.
    //


    pNdisPacket = NULL;
    pvData      = NULL;

    do
    {

        // Allocate space for the packet data.
        // TODO: here is where we could use a lookaside list instead
        // of NdisAllocateMemoryWithTag.
        //
        {
            if (cbBufferSize > pIF->arp.MaxBufferSize)
            {
                ASSERT(FALSE);
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
            NdisAllocateMemoryWithTag(
                &pvData,
                cbBufferSize,
                MTAG_PKT
                );
            if (pvData == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
        }

        // Allocate a buffer.
        //
        NdisAllocateBuffer(
                &Status,
                &pNdisBuffer,
                pIF->arp.BufferPool,
                pvData,
                cbBufferSize
            );

        if (FAIL(Status))
        {
            pNdisBuffer = NULL;
            break;
        }
        
        // Allocate a packet
        //
        NdisAllocatePacket(
                &Status,
                &pNdisPacket,
                pIF->arp.PacketPool
            );
    
        if (FAIL(Status))
        {
            pNdisPacket = NULL;
            break;
        }

        // Identify the packet as belonging to us (ARP).
        //
        {
            struct PacketContext    *PC;
            PC = (struct PacketContext *)pNdisPacket->ProtocolReserved;
            PC->pc_common.pc_owner = PACKET_OWNER_LINK;
            PC->pc_common.pc_flags = (UCHAR)PktFlags; // ARP1394_PACKET_FLAGS_CONTROL;
        }

        // Link the packet and buffer.
        //
        NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);

        InterlockedIncrement(&pIF->arp.NumOutstandingPackets);
        *ppNdisPacket   = pNdisPacket;
        *ppvData        = pvData;

        pNdisPacket = NULL;
        pNdisBuffer = NULL;
        pvData      = NULL;

    } while (FALSE);

    if (FAIL(Status))
    {
        if (pNdisPacket != NULL)
        {
            NdisFreePacket(pNdisPacket);
        }
        if (pNdisBuffer != NULL)
        {
            NdisFreeBuffer(pNdisBuffer);
        }
        if (pvData != NULL)
        {
            NdisFreeMemory(pvData, 0, 0);
        }
    }
    else
    {
        ASSERT(pNdisPacket == NULL
                && pNdisBuffer == NULL
                && pvData == NULL);
    }

    return Status;
}

VOID
arpFreeControlPacket(
    PARP1394_INTERFACE  pIF,
    PNDIS_PACKET        pNdisPacket,
    PRM_STACK_RECORD    pSR
    )
/*++
Routine Description:

    Free a packet previously allocated using arpAllocateControlPacket.

Arguments:

    pIF             - Interface whose control packet pool to use.
--*/
{
    PNDIS_BUFFER pNdisBuffer = NULL;
    PVOID        pvData = NULL;

    ENTER("arpFreeControlPacket", 0x01e7fbc7)

    // (DBG only) Verify that this packet belongs to us. 
    //
    #if DBG
    {
        struct PacketContext    *PC;
        PC = (struct PacketContext *)pNdisPacket->ProtocolReserved;
        ASSERT(PC->pc_common.pc_owner == PACKET_OWNER_LINK);
    }
    #endif // DBG

    // Decrement the allocated packet count.
    //
    {
        LONG Count;
        Count = InterlockedDecrement(&pIF->arp.NumOutstandingPackets);
        ASSERT(Count >= 0);
    }

    // Extract the buffer and data
    //
    {
        UINT TotalLength;
        UINT BufferLength;

        NdisQueryPacket(
                    pNdisPacket,
                    NULL,
                    NULL,
                    &pNdisBuffer,
                    &TotalLength
                    );
    
        if (TotalLength > 0)
        {
            NdisQueryBuffer(
                    pNdisBuffer,
                    &pvData,
                    &BufferLength
                    );
        }
        else
        {
            BufferLength = 0;
        }
    
        // There should only be a single buffer!
        //
        ASSERT(TotalLength!=0 && TotalLength == BufferLength);
    }

    // Free the data
    //
    if (pvData != NULL)
    {
        NdisFreeMemory(pvData, 0, 0);
    }
    // Free the buffer
    //
    if (pNdisBuffer != NULL)
    {
        NdisFreeBuffer(pNdisBuffer);
    }
    // Free the packet
    //
    if (pNdisPacket != NULL)
    {
        NdisFreePacket(pNdisPacket);
    }
}


NDIS_STATUS
arpAllocateEthernetPools(
    IN  PARP1394_INTERFACE  pIF,
    IN  PRM_STACK_RECORD    pSR
    )
{
    NDIS_STATUS Status;
    NDIS_HANDLE PacketPool=NULL;
    NDIS_HANDLE BufferPool=NULL;
    ENTER("arpAllocateEthernetPools", 0x9dc1d759)

    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);
    ASSERT(pIF->ethernet.PacketPool == NULL);
    ASSERT(pIF->ethernet.BufferPool == NULL);

    do
    {
        // Allocate the NDIS Packet Pool
        //
        NdisAllocatePacketPool(
                &Status,
                &PacketPool,
                ARP1394_MAX_ETHERNET_PKTS,
                sizeof(struct PCCommon)
                );
    
        if (FAIL(Status))
        {
            PacketPool = NULL;
            break;
        }
    
        // Allocate the NDIS Buffer Pool
        //
        NdisAllocateBufferPool(
                &Status,
                &BufferPool,
                2*ARP1394_MAX_ETHERNET_PKTS // two buffers per packet.
                );
    
        if (FAIL(Status))
        {
            BufferPool = NULL;
            break;
        }
    
        //  (DBG only) Add associations for the ethernet packet pool and buffer pool.
        //  These associations must be removed before the interface is deallocated.
        //
        DBG_ADDASSOC(
            &pIF->Hdr,                  // pObject
            PacketPool,                 // Instance1
            NULL,                       // Instance2
            ARPASSOC_IF_ETHPKTPOOL, // AssociationID
            "    Eth Packet Pool 0x%p\n",// szFormat
            pSR
            );
        DBG_ADDASSOC(
            &pIF->Hdr,                  // pObject
            BufferPool,                 // Instance1
            NULL,                       // Instance2
            ARPASSOC_IF_ETHBUFPOOL, // AssociationID
            "    Eth Buffer Pool 0x%p\n",// szFormat
            pSR
            );

        pIF->ethernet.PacketPool = PacketPool;
        pIF->ethernet.BufferPool = BufferPool;
        PacketPool = NULL;
        BufferPool = NULL;

    } while (FALSE);

    if (FAIL(Status))
    {
        if (PacketPool != NULL)
        {
            NdisFreePacketPool(PacketPool);
        }
    
        if (BufferPool != NULL)
        {
            NdisFreeBufferPool(BufferPool);
        }
    }
    else
    {
        ASSERT(PacketPool == NULL && BufferPool == NULL);
    }

    return Status;
}


VOID
arpFreeEthernetPools(
    IN  PARP1394_INTERFACE  pIF,
    IN  PRM_STACK_RECORD    pSR
    )
{
    NDIS_HANDLE PacketPool;
    NDIS_HANDLE BufferPool;
    ENTER("arpFreeEthernetPools", 0x3e780760)

    // Make sure the IF is locked.
    //
    RM_ASSERT_OBJLOCKED(&pIF->Hdr, pSR);

    PacketPool = pIF->ethernet.PacketPool;
    BufferPool = pIF->ethernet.BufferPool;
    pIF->ethernet.PacketPool = NULL;
    pIF->ethernet.BufferPool = NULL;
    
    // (DBG only) Remove associations for the control and packet pools.
    //
    DBG_DELASSOC(
        &pIF->Hdr,                  // pObject
        PacketPool,                 // Instance1
        NULL,                       // Instance2
        ARPASSOC_IF_ETHPKTPOOL, // AssociationID
        pSR
        );
    DBG_DELASSOC(
        &pIF->Hdr,                  // pObject
        BufferPool,                 // Instance1
        NULL,                       // Instance2
        ARPASSOC_IF_ETHBUFPOOL, // AssociationID
        pSR
        );

    // Free the buffer and packet pools
    // 
    NdisFreeBufferPool(BufferPool);
    NdisFreePacketPool(PacketPool);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\precomp.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

	Precompiled header file for ARP1394.SYS

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    josephj     11-10-98    created (adapted from atmarpc.sys precomp.h)

--*/
#include "ccdefs.h"

#ifdef TESTPROGRAM
	#include "rmtest.h"
#else // !TESTPROGRAM

#include <ndis.h>
#include <1394.h>
#include <nic1394.h>
#include <cxport.h>
#include <ip.h>
#include <arpinfo.h>
#include <tdiinfo.h>
#include <ipinfo.h>
#include <llinfo.h>
#include <basetsd.h>

// TODO: following is included
// if we  use the 
// ATMARPC_PNP_RECONFIG_REQUEST
// defined for atmarp. We currently
// don't use this structure
// (see arpPnPReconfigHandler).
//
// #include <atmarpif.h>

#include <tdistat.h>
#include <ipifcons.h>
#include <ntddip.h>
#include <llipif.h>
#include "nicarp.h"
#include <rfc2734.h>
#include <a13ioctl.h>
#include <xfilter.h>
//#include <ntddip.h> <- was in atmarpc, but I don't think it's needed here
#include "dbg.h"
#include "rm.h"
#include "priv.h"
#include "fake.h"


#endif // !TESTPROGRAM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\priv.h ===
/*++
Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    priv.h

Abstract:

    Private structure definitions and function templates for the 1394 ARP module.

Author:


Revision History:

    Who         When        What
    --------    --------    ----
    josephj     11-17-98    created

--*/

#define ARP1394_SYMBOLIC_NAME       L"\\DosDevices\\ARP1394"
#define ARP1394_DEVICE_NAME         L"\\Device\\ARP1394"
#define ARP1394_UL_NAME             L"ARP1394"
#define ARP1394_LL_NAME             L"TCPIP_ARP1394"

#define ARP1394_NDIS_MAJOR_VERSION      5
#define ARP1394_NDIS_MINOR_VERSION      0

// The physical address length, as reported to IP in the following places:
//                      
//      IFEntry.if_physaddr (on WIN98, IFEntry.if_physaddr is truncated to 6 bytes)
//      LLIPBindInfo.lip_addr
//      IPNetToMediaEntry.inme_physaddr
//
// Note that may be (and in fact currently is) less then the actual length of
// the actual IEEE1394 FIFO physical-address length.
//
#define ARP1394_IP_PHYSADDR_LEN         6 // TODO: make 8

// The levels of the various types of locks
//
enum
{
    LOCKLEVEL_GLOBAL=1, // Must start > 0.
    LOCKLEVEL_ADAPTER,
    LOCKLEVEL_IF_SEND

};

#define ARP1394_GLOBALS_SIG 'G31A'

// TODO: read this from configuration. Set default based on the ip/1394 standard.
//

#define ARP1394_ADAPTER_MTU         1520

#define ARP1394_MAX_PROTOCOL_PKTS   1000
#define ARP1394_MAX_PROTOCOL_PACKET_SIZE 1600 // We need to forward between ICS.

#define ARP1394_ADDRESS_RESOLUTION_TIMEOUT  1000 // Ms
#define ARP1394_MAX_ETHERNET_PKTS   4

// Delay between polling for connect status.
//
#define ARP1394_WAIT_FOR_CONNECT_STATUS_TIMEOUT             5000

//
// Packet flags for packets allocated by us.
// Go into protocol-context (pc_common.pc_flags) of the packet.
//
#define ARP1394_PACKET_FLAGS_ARP            0
#define ARP1394_PACKET_FLAGS_ICS            1
#define ARP1394_PACKET_FLAGS_MCAP           2
#define ARP1394_PACKET_FLAGS_DBGCOPY        3
#define ARP1394_PACKET_FLAGS_IOCTL          4


    
//
// Pre allocation constants to avoid low memory condition
// 
#define ARP1394_BACKUP_TASKS 4

// Forward references
//
typedef struct _ARP1394_INTERFACE ARP1394_INTERFACE;
typedef struct _ARPCB_LOCAL_IP      ARPCB_LOCAL_IP;
typedef struct _ARPCB_REMOTE_IP     ARPCB_REMOTE_IP;
typedef struct _ARPCB_REMOTE_ETH    ARPCB_REMOTE_ETH;
typedef struct _ARPCB_DEST          ARPCB_DEST, *PARPCB_DEST;


typedef IPAddr IP_ADDRESS, *PIP_ADDRESS;
typedef IPMask IP_MASK, *PIP_MASK;

typedef int MYBOOL; // Like BOOL

typedef struct _ARP1394_GLOBALS
{
    RM_OBJECT_HEADER            Hdr;

    RM_LOCK                     Lock;

    // Driver global state
    //
    struct
    {
        // Handle to Driver Object for ARP1394
        //
        PVOID                       pDriverObject;
    
        // Handle to the single device object representing this driver.
        //
        PVOID pDeviceObject;

    } driver;

    // Global NDIS State
    // 
    struct
    {
        // NDIS' protocol handle, returned in NdisRegisterProtocol
        //
        NDIS_HANDLE ProtocolHandle;
    
        // NDIS Protocol characteristics
        //
        NDIS_PROTOCOL_CHARACTERISTICS PC;
    
        // NDIS Client characteristics
        NDIS_CLIENT_CHARACTERISTICS CC;

    } ndis;

    // Global IP State
    //
    struct
    {
        //  Handle returned by IPRegisterARP
        //
        HANDLE                      ARPRegisterHandle;
    
        // Following are callback's into IP, set in IPRegisterARP
        //
        IP_ADD_INTERFACE            pAddInterfaceRtn;   // add an interface
        IP_DEL_INTERFACE            pDelInterfaceRtn;   // delete an interface
        IP_BIND_COMPLETE            pBindCompleteRtn;   // inform of bind cmpl
        IP_ADD_LINK                 pAddLinkRtn;
        IP_DELETE_LINK              pDeleteLinkRtn;

    } ip;

    // Global adapter list
    //
    struct {
        RM_GROUP Group;
    } adapters;

    // Global List of backup tasks
    SLIST_HEADER  BackupTasks;
    NDIS_SPIN_LOCK    BackupTaskLock;
    UINT           NumTasks;
}
ARP1394_GLOBALS;

extern ARP1394_GLOBALS  ArpGlobals;

typedef struct // ARP1394_ADAPTER
{
    RM_OBJECT_HEADER            Hdr;
    RM_LOCK                     Lock;

    //
    // PRIMARY_STATE flags (in Hdr.State)
    //
    //  PRIMARY_STATE is the primary state of the adapter.
    //

    #define ARPAD_PS_MASK               0x00f
    #define ARPAD_PS_DEINITED           0x000
    #define ARPAD_PS_INITED             0x001
    #define ARPAD_PS_FAILEDINIT         0x002
    #define ARPAD_PS_INITING            0x003
    #define ARPAD_PS_REINITING          0x004
    #define ARPAD_PS_DEINITING          0x005

    #define SET_AD_PRIMARY_STATE(_pAD, _IfState) \
                RM_SET_STATE(_pAD, ARPAD_PS_MASK, _IfState)
    
    #define CHECK_AD_PRIMARY_STATE(_pAD, _IfState) \
                RM_CHECK_STATE(_pAD, ARPAD_PS_MASK, _IfState)

    #define GET_AD_PRIMARY_STATE(_pAD) \
                RM_GET_STATE(_pAD, ARPAD_PS_MASK)


    //
    // ACTIVE_STATE flags (in Hdr.State)
    //
    // ACTIVE_STATE is a secondary state of the adapter.
    // Primary state takes precedence over secondary sate. For example,
    // the interface is REINITING and ACTIVE, one should not actively use the
    // interface.
    //
    // NOTE: When the primary state is INITED, the secondary state WILL be
    // ACTIVATED. It is thus usually only necessary to look at the primary state.
    //

    #define ARPAD_AS_MASK               0x0f0
    #define ARPAD_AS_DEACTIVATED        0x000
    #define ARPAD_AS_ACTIVATED          0x010
    #define ARPAD_AS_FAILEDACTIVATE     0x020
    #define ARPAD_AS_DEACTIVATING       0x030
    #define ARPAD_AS_ACTIVATING         0x040

    #define SET_AD_ACTIVE_STATE(_pAD, _IfState) \
                RM_SET_STATE(_pAD, ARPAD_AS_MASK, _IfState)
    
    #define CHECK_AD_ACTIVE_STATE(_pAD, _IfState) \
                RM_CHECK_STATE(_pAD, ARPAD_AS_MASK, _IfState)

    #define GET_AD_ACTIVE_STATE(_pAD) \
                RM_GET_STATE(_pAD, ARPAD_AS_MASK)


    // BRIDGE (Ethernet Emulation) state (in Hdr.State)
    //
    #define ARPAD_BS_MASK               0x100
    #define ARPAD_BS_ENABLED            0x100
 
    
    #define ARP_ENABLE_BRIDGE(_pAD) \
                RM_SET_STATE(_pAD, ARPAD_BS_MASK, ARPAD_BS_ENABLED)
    #define ARP_BRIDGE_ENABLED(_pAD) \
                RM_CHECK_STATE(_pAD, ARPAD_BS_MASK, ARPAD_BS_ENABLED)

    #define SET_BS_FLAG(_pAD, _IfState) \
                RM_SET_STATE(_pAD, ARPAD_BS_MASK, _IfState)
    
    #define CHECK_BS_FLAG(_pAD, _IfState) \
                RM_CHECK_STATE(_pAD, ARPAD_BS_MASK, _IfState)

    #define GET_BS_ACTIVE_STATE(_pAD) \
                RM_GET_STATE(_pAD, ARPAD_BS_MASK)

    #define ARPAD_POWER_MASK            0xf000
    #define ARPAD_POWER_LOW_POWER       0x1000
    #define ARPAD_POWER_NORMAL          0x0000

    #define SET_POWER_STATE(_pAD, _PoState) \
                RM_SET_STATE(_pAD, ARPAD_POWER_MASK , _PoState)
    
    #define CHECK_POWER_STATE(_pAD, _PoState) \
                RM_CHECK_STATE(_pAD, ARPAD_POWER_MASK, _PoState)

    #define GET_POWER_ACTIVE_STATE(_pAD) \
                RM_GET_STATE(_pAD, ARPAD_POWER_MASK)


    
    // NDIS bind info.
    //
    struct
    {
        NDIS_STRING                 ConfigName;
        NDIS_STRING                 DeviceName;
        PVOID                       IpConfigHandle;
        NDIS_HANDLE                 BindContext;

        // Init/Deinit/Reinit task
        //
        PRM_TASK pPrimaryTask;
    
        // Activate/Deactivate task
        //
        PRM_TASK pSecondaryTask;

        NDIS_HANDLE                 AdapterHandle;

        // This is read from the configuration information in the registry.
        // It is a multisz string, in theory it could contain the config-strings
        // of multiple interfaces, although IP/1394 only provides one.
        //
        NDIS_STRING                 IpConfigString;


    } bind;

    // Information about the adapter, obtained by querying it.
    // Note: MTU is the MTU reported by the adapter, and is not the same
    // as the MTU reported up to ip (the latter MTU is in the ARP1394_INTERFACE
    // structure).
    //
    struct
    {
        ULONG                       MTU;

        // Maximum speed, in bytes per second, that the local host controller
        // is capable of.
        //
        ULONG                       Speed;

    #if OBSOLETE
        // Minimum size (in bytes) of:
        //   -- Max individual async write to any remote node
        //   -- Max individual async write to any channel
        //   -- Max block we can receive on our recv FIFO
        //   -- Max block we can receive on any channel
        //
        ULONG                       MaxBlockSize;
    #endif // 0

        // max_rec (Maximum bus data record size)
        // size == 2^(max_rec+1).
        // (Macro  IP1394_MAXREC_TO_SIZE in rfc.h)
        //
        //
        ULONG                       MaxRec;

        ULONG                       MaxSpeedCode;

        //NIC1394_FIFO_ADDRESS      LocalHwAddress;
        UINT64                      LocalUniqueID;
        UCHAR *                     szDescription;
        UINT                        DescriptionLength; // including null termination.

        // This address is synthesized using the adapter's EU64 unique ID.
        //
        ENetAddr EthernetMacAddress;

    } info;

    struct 
    {

        //
        // Current Power State
        //
        NET_DEVICE_POWER_STATE  State;

        NDIS_EVENT Complete;

        //
        // Boolean variable to track the state on resume
        //
        BOOLEAN                 bReceivedSetPowerD0;
        BOOLEAN                 bReceivedAf;
        BOOLEAN                 bReceivedUnbind;
        BOOLEAN                 bResuming;
        BOOLEAN                 bFailedResume;
        
    }PoMgmt;

    // The IP interface control block (only one per adapter).
    //
    ARP1394_INTERFACE *pIF;

    // Bus Topology of the 1394 card below this adapter
    //
    EUID_TOPOLOGY EuidMap;

    //
    // Set when a Workitem is queued to query Node Addresses
    //
    MYBOOL fQueryAddress;

}
ARP1394_ADAPTER, *PARP1394_ADAPTER;


// This structure maintains a pool of buffers, all pointing to
// the same area of memory (whose contents are expected to be CONSTANT).
// The primary use of this structure is to maintain a pool of encapsulation headers
// buffers.
//
typedef struct _ARP_CONST_BUFFER_POOL
{
    NDIS_HANDLE             NdisHandle;         // Buffer pool handle
    PRM_OBJECT_HEADER       pOwningObject;      // ptr to object that owns this list

    // Following stuff just for statistics gathering.
    // TODO: consider conditionally-compiling this.
    //
    struct
    {
        UINT                TotBufAllocs;       // # allocs from buffer pool 
        UINT                TotCacheAllocs;     // # allocs from cache list
        UINT                TotAllocFails;      // # failed allocs

    } stats;

    UINT                    NumBuffersToCache;  // Number to keep inited and cached
    UINT                    MaxBuffers;         // Max number to allocate
    UINT                    cbMem;              // Size in bytes of mem below...
    const   VOID*           pvMem;              // Ptr to memory containg encap data
    UINT                    NumAllocd;          // # outstanding allocs from pool
    UINT                    NumInCache;         // # items sitting in cache.
    NDIS_SPIN_LOCK          NdisLock;           // Spinlock protecting the list below
    SLIST_HEADER            BufferList;         // List of available, inited bufs

} ARP_CONST_BUFFER_POOL;


// This structure is used when calling NdisRequest.
//
typedef struct _ARP_NDIS_REQUEST
{
    NDIS_REQUEST    Request;            // The NDIS request structure.
    NDIS_EVENT      Event;              // Event to signal when done.
    PRM_TASK        pTask;              // Task to resume when done.
    NDIS_STATUS     Status;             // Status of completed request.

} ARP_NDIS_REQUEST, *PARP_NDIS_REQUEST;


// Static set of information associated with a VC, mainly co-ndis call handlers.
//
typedef struct
{
    PCHAR                           Description;
    CO_SEND_COMPLETE_HANDLER        CoSendCompleteHandler;
    // CO_STATUS_HANDLER                CoStatusHandler;
    CO_RECEIVE_PACKET_HANDLER       CoReceivePacketHandler;
    // CO_AF_REGISTER_NOTIFY_HANDLER    CoAfRegisterNotifyHandler;


    // CL_MAKE_CALL_COMPLETE_HANDLER    ClMakeCallCompleteHandler;
    // CL_CLOSE_CALL_COMPLETE_HANDLER   ClCloseCallCompleteHandler;
    CL_INCOMING_CLOSE_CALL_HANDLER  ClIncomingCloseCallHandler;

    // Vc type is currently used just for stats. We may get rid of some of the
    // handlers above and use the vctype instead.
    //
    enum
    {
        ARPVCTYPE_SEND_FIFO,
        ARPVCTYPE_RECV_FIFO,
        ARPVCTYPE_BROADCAST_CHANNEL,
        ARPVCTYPE_MULTI_CHANNEL,
        ARPVCTYPE_ETHERNET,
        ARPVCTYPE_SEND_CHANNEL,
        ARPVCTYPE_RECV_CHANNEL,
    } VcType;

    BOOLEAN IsDestVc;
    
} ARP_STATIC_VC_INFO, *PARP_STATIC_VC_INFO;



// ARP's protocol vc context has this common header.
//
typedef struct
{
    PARP_STATIC_VC_INFO pStaticInfo;

    // Ndis VC handle associated with the VC. 
    //
    NDIS_HANDLE NdisVcHandle;

    // These two tasks are for making and tearingdown the VC, 
    // respectively.
    //
    PRM_TASK    pMakeCallTask;
    PRM_TASK    pCleanupCallTask;

} ARP_VC_HEADER, *PARP_VC_HEADER;

typedef struct
{
    // Channel number.
    //
    UINT            Channel;

    // IP multicast group address bound to this channel.
    //
    IP_ADDRESS      GroupAddress;

    // Absolute time at which this information was updated,
    // in seconds.
    //
    UINT            UpdateTime;

    // Absolute time at which this mapping will expire.
    // In seconds.
    //
    UINT            ExpieryTime;

    UINT            SpeedCode;

    // TBD
    //
    UINT            Flags;  // One of the MCAP_CHANNEL_FLAGS_*
    #define MCAP_CHANNEL_FLAGS_LOCALLY_ALLOCATED 0x1

    // NodeID of owner of this channel.
    //
    UINT            NodeId;

} MCAP_CHANNEL_INFO, *PMCAP_CHANNEL_INFO;


// The IP interface control block.
//
typedef struct _ARP1394_INTERFACE
{
    RM_OBJECT_HEADER Hdr;

    //
    // PRIMARY_STATE flags (in Hdr.State)
    //
    //  PRIMARY_STATE is the primary state of the interface.
    //

    #define ARPIF_PS_MASK               0x00f
    #define ARPIF_PS_DEINITED           0x000
    #define ARPIF_PS_INITED             0x001
    #define ARPIF_PS_FAILEDINIT         0x002
    #define ARPIF_PS_INITING            0x003
    #define ARPIF_PS_REINITING          0x004
    #define ARPIF_PS_DEINITING          0x005
    #define ARPIF_PS_LOW_POWER          0x006

    #define SET_IF_PRIMARY_STATE(_pIF, _IfState) \
                RM_SET_STATE(_pIF, ARPIF_PS_MASK, _IfState)
    
    #define CHECK_IF_PRIMARY_STATE(_pIF, _IfState) \
                RM_CHECK_STATE(_pIF, ARPIF_PS_MASK, _IfState)

    #define GET_IF_PRIMARY_STATE(_pIF) \
                RM_GET_STATE(_pIF, ARPIF_PS_MASK)


    //
    // ACTIVE_STATE flags (in Hdr.State)
    //
    // ACTIVE_STATE is a secondary state of the interface.
    // Primary state takes precedence over secondary sate. For example,
    // the interface is REINITING and ACTIVE, one should not actively use the
    // interface.
    //
    // NOTE: When the primary state is INITED, the secondary state WILL be
    // ACTIVATED. It is thus usually only necessary to look at the primary state.
    //

    #define ARPIF_AS_MASK               0x0f0
    #define ARPIF_AS_DEACTIVATED        0x000
    #define ARPIF_AS_ACTIVATED          0x010
    #define ARPIF_AS_FAILEDACTIVATE     0x020
    #define ARPIF_AS_DEACTIVATING       0x030
    #define ARPIF_AS_ACTIVATING         0x040
    
    #define SET_IF_ACTIVE_STATE(_pIF, _IfState) \
                RM_SET_STATE(_pIF, ARPIF_AS_MASK, _IfState)
    
    #define CHECK_IF_ACTIVE_STATE(_pIF, _IfState) \
                RM_CHECK_STATE(_pIF, ARPIF_AS_MASK, _IfState)

    #define GET_IF_ACTIVE_STATE(_pIF) \
                RM_GET_STATE(_pIF, ARPIF_AS_MASK)

    //
    // IP_STATE flags  (in Hdr.State)
    //
    // This state is set to OPEN when our open handler (ArpIpOpen) is called, and
    // to CLOSED when our close handler (ArpIpClose) is called
    //
    #define ARPIF_IPS_MASK              0xf00
    #define ARPIF_IPS_CLOSED            0x000
    #define ARPIF_IPS_OPEN              0x100
    
    #define SET_IF_IP_STATE(_pIF, _IfState) \
                RM_SET_STATE(_pIF, ARPIF_IPS_MASK, _IfState)
    
    #define CHECK_IF_IP_STATE(_pIF, _IfState) \
                RM_CHECK_STATE(_pIF, ARPIF_IPS_MASK, _IfState)

    #define GET_IF_IP_STATE(_pIF) \
                RM_GET_STATE(_pIF, ARPIF_IPS_MASK)


    // Init/Deinit/Reinit task
    //
    PRM_TASK pPrimaryTask;

    // Activate/Deactivate task
    //
    PRM_TASK pActDeactTask;

    // Maintenance task
    //
    PRM_TASK pMaintenanceTask;

    // Ndis-provided handlers and handles.
    //
    struct
    {
        // Cashed value of the adapter handle.
        //
        NDIS_HANDLE AdapterHandle;

        // The address family handle.
        //
        NDIS_HANDLE AfHandle;

    } ndis;

    // Stuff directly relating to interaction with IP.
    //
    struct
    {

        //
        // Following passed in from IP.
        //
        PVOID               Context;            // Use in calls to IP
        ULONG               IFIndex;            // Interface number
        IPRcvRtn            RcvHandler;     // Indicate Receive
        IPTxCmpltRtn        TxCmpltHandler; // Transmit Complete
        IPStatusRtn         StatusHandler;
        IPTDCmpltRtn        TDCmpltHandler; // Transfer Data Complete
        IPRcvCmpltRtn       RcvCmpltHandler;    // Receive Complete
        IPRcvPktRtn         RcvPktHandler;  // Indicate Receive Packet
        IPAddAddrCmpltRtn   AddAddrCmplRtn;  // called when arp detects address conflicts.

        IP_PNP              PnPEventHandler;

        //
        // Following passed up to IP.
        //
        ULONG                       MTU;            // Max Transmision Unit (bytes)

        NDIS_STRING                 ConfigString;


        // Following are for IP's query/set info functionality.
        //
        UINT                        ATInstance;     // Instance # for this AT Entity
        UINT                        IFInstance;     // Instance # for this IF Entity

        //
        // Other stuff ...
        //

        // Defaults to all-1's, but may be set by ip to be something different
        // (actually the only other possibility is all-0's, when the stack is
        // running in "BSD compatibility mode".
        // This field is used to decide where a given destination address is
        // unicast or not.
        //
        //
        IP_ADDRESS BroadcastAddress;

        // This address is used in filling out ARP requests.
        //
        IP_ADDRESS DefaultLocalAddress;

    } ip;

    // Statistics 
    //
    //  WARNING:   arpResetIfStats() zeros this entire structure, then
    //              selectively re-inits some fields, such as StatsResetTime.
    //
    struct
    {
        // Following for MIB stats
        //
        ULONG               LastChangeTime;     // Time of last state change
        ULONG               InOctets;           // Input octets
        ULONG               InUnicastPkts;      // Input Unicast packets
        ULONG               InNonUnicastPkts;   // Input Non-unicast packets
        ULONG               OutOctets;          // Output octets
        ULONG               OutUnicastPkts;     // Output Unicast packets
        ULONG               OutNonUnicastPkts;  // Output Non-unicast packets
        ULONG               InDiscards;
        ULONG               InErrors;
        ULONG               UnknownProtos;
        ULONG               OutDiscards;
        ULONG               OutErrors;
        ULONG               OutQlen;

        //
        // Following for our private statistics gathering.
        //

        // Timestamp since the last reset of statistics collection.
        // Set by a call to NdisGetCurrentSystemTime.
        //
        LARGE_INTEGER               StatsResetTime;     // In 100-nanoseconds.
        LARGE_INTEGER               PerformanceFrequency; // In Hz.

        //
        // Some send pkt stats
        //
        struct
        {
            UINT                    TotSends;
            UINT                    FastSends;
            UINT                    MediumSends;
            UINT                    SlowSends;
            UINT                    BackFills;
            // UINT                 HeaderBufUses;
            // UINT                 HeaderBufCacheHits;
            ARP1394_PACKET_COUNTS   SendFifoCounts;
            ARP1394_PACKET_COUNTS   SendChannelCounts;

        } sendpkts;
    
        //
        // Some recv pkt stats
        //
        struct
        {
            UINT                    TotRecvs;
            UINT                    NoCopyRecvs;
            UINT                    CopyRecvs;
            UINT                    ResourceRecvs;
            ARP1394_PACKET_COUNTS   RecvFifoCounts;
            ARP1394_PACKET_COUNTS   RecvChannelCounts;
        } recvpkts;
            

        //
        // Task statistics
        //
        struct
        {
            UINT    TotalTasks;
            UINT    CurrentTasks;
            UINT    TimeCounts[ARP1394_NUM_TASKTIME_SLOTS];

        } tasks;

        //
        // Arp cache stats
        //
        struct {
            UINT    TotalQueries;
            UINT    SuccessfulQueries;
            UINT    FailedQueries;
            UINT    TotalResponses;
            UINT    TotalLookups;
            // UINT TraverseRatio; << this is picked up by looking into the
            //                     << hash table data structure.

        } arpcache;

        //
        // Call stats
        //
        struct
        {
            //
            // FIFO-related call stats.
            //
            UINT    TotalSendFifoMakeCalls;
            UINT    SuccessfulSendFifoMakeCalls;
            UINT    FailedSendFifoMakeCalls;
            UINT    IncomingClosesOnSendFifos;
        
            //
            // Channel-related call stats.
            //
            UINT    TotalChannelMakeCalls;
            UINT    SuccessfulChannelMakeCalls;
            UINT    FailedChannelMakeCalls;
            UINT    IncomingClosesOnChannels;

        } calls;

    } stats;

    //  Group containing local ip addresses, of type  ARPCB_LOCAL_IP
    //
    RM_GROUP LocalIpGroup;

    // Group containing remote ip addresses, of type ARPCB_REMOTE_IP
    // (this is the arp cache)
    //
    RM_GROUP RemoteIpGroup;

    // Group containing remote ethernet destinations. This group is only used
    // if the adapter is operating in bridge mode.
    // This is the Ethernet address cache.
    //
    RM_GROUP RemoteEthGroup;

    // Group containing remote h/w distinations, of type ARPCB_DEST
    // (each ARPCB_DEST has a group of VCs)
    //
    RM_GROUP DestinationGroup;

    // Group containing the table (bridge only) of dhcp session, and their
    // associated physical addresses
    //
    RM_GROUP EthDhcpGroup;

    // Stuff relating to the receive FIFO, which is owned by the interface.
    //
    //
    struct {

        ARP_VC_HEADER VcHdr;
        
        // Address  offset of the receive VC
        //
        struct
        {
            ULONG               Off_Low;
            USHORT              Off_High;

        } offset;
    } recvinfo;

    // This maintains interface-wide information relevant to the send path.
    //
    struct
    {
        // Lock used exclusively for sending.
        // Protects the following:
        //      ??? this->sendinfo.listPktsWaitingForHeaders
        //      ??? this->sendinfo.NumSendPacketsWaiting
        //      pLocalIp->sendinfo
        //      pDest->sendinfo
        //
        //
        RM_LOCK     Lock;

        // List of send packets waiting for header buffers to become available.
        //
        LIST_ENTRY  listPktsWaitingForHeaders;

        // Length of the above list
        //
        UINT        NumSendPacketsWaiting;

        // Pool of header buffer pool. This is seralized by its OWN lock,
        // not by sendinfo.Lock.
        //
        ARP_CONST_BUFFER_POOL   HeaderPool;

        // Pool of Channel header buffers. This is serialized by its OWN lock,
        // not by sendinfo.Lock
        //
        ARP_CONST_BUFFER_POOL   ChannelHeaderPool;

    } sendinfo;

    
    //
    // Following 3 are "special" destinations ....
    //

    // Pointer to the broadcast-channel destination object.
    //
    PARPCB_DEST pBroadcastDest;

    // Pointer to the multi-channel destination object.
    //
    PARPCB_DEST pMultiChannelDest;

    // Pointer to the ethernet destination object.
    //
    PARPCB_DEST pEthernetDest;


    // Stuff relating to running the ARP protocol
    // (All serialized by the IF lock (not the IF SEND lock).
    //
    struct
    {
        // The NDIS packet pool for ARP pkts.
        //
        NDIS_HANDLE PacketPool;

        // The NDIS buffer pool for ARP pkts.
        //
        NDIS_HANDLE BufferPool;

        // Number of currently allocated packets.
        //
        LONG NumOutstandingPackets;

        // Maximum size of the packet that can be allocated from this pool.
        //
        UINT MaxBufferSize;

    } arp;

    // Stuff relating to the Ethernet VC, which is owned by the interface.
    //
    struct {

        // The NDIS packet pool for Ethernet pkts.
        //
        NDIS_HANDLE PacketPool;

        // The NDIS buffer pool for Ethernet packet headers.
        //
        NDIS_HANDLE BufferPool;
        
    } ethernet;

    #define ARP_NUM_CHANNELS 64
    struct
    {
        // Information about each channel. Information includes:
        // IP multicast group address and expiry time.
        //
        MCAP_CHANNEL_INFO rgChannelInfo[ARP_NUM_CHANNELS];

    } mcapinfo;

    struct 
    {

        PRM_TASK pAfPendingTask;

    } PoMgmt;

}

ARP1394_INTERFACE, *PARP1394_INTERFACE;

#define ARP_OBJECT_IS_INTERFACE(_pHdr) ((_pHdr)->Sig == MTAG_INTERFACE)
#define ASSERT_VALID_INTERFACE(_pIF) ASSERT((_pIF)->Hdr.Sig == MTAG_INTERFACE)

#define ARP_WRITELOCK_IF_SEND_LOCK(_pIF, _psr) \
                                RmDoWriteLock(&(_pIF)->sendinfo.Lock, (_psr))

#define ARP_READLOCK_IF_SEND_LOCK(_pIF, _psr) \
                                RmDoReadLock(&(_pIF)->sendinfo.Lock, (_psr))

#define ARP_UNLOCK_IF_SEND_LOCK(_pIF, _psr) \
                                RmDoUnlock(&(_pIF)->sendinfo.Lock, (_psr))

#define ARP_FASTREADLOCK_IF_SEND_LOCK(_pIF) \
        NdisAcquireSpinLock(&(_pIF)->sendinfo.Lock.OsLock)

#define ARP_FASTUNLOCK_IF_SEND_LOCK(_pIF) \
        NdisReleaseSpinLock(&(_pIF)->sendinfo.Lock.OsLock)

/*++
VOID
ARP_IF_STAT_INCR(
    IN  ARP1394_INTERFACE   *   _pIF
    IN  OPAQUE              StatsCounter
)
    Increment the specified StatsCounter on an Interface by 1.
--*/
#define ARP_IF_STAT_INCR(_pIF, StatsCounter)    \
            NdisInterlockedIncrement(&(_pIF)->stats.StatsCounter)


/*++
VOID
ARP_IF_STAT_ADD(
    IN  ARP1394_INTERFACE   *   _pIF
    IN  OPAQUE              StatsCounter,
    IN  ULONG               IncrValue
)
    Increment the specified StatsCounter on an Interface by the specified IncrValue.
    Take a lock on the interface to do so.
--*/
#if  BINARY_COMPATIBLE
    #define ARP_IF_STAT_ADD(_pIF, StatsCounter, IncrValue)  \
                ((_pIF)->stats.StatsCounter += (IncrValue))
#else // !BINARY_COMPATIBLE
    #define ARP_IF_STAT_ADD(_pIF, StatsCounter, IncrValue)  \
                InterlockedExchangeAdd(&(_pIF)->stats.StatsCounter, IncrValue)
#endif // !BINARY_COMPATIBLE



//
// This is the table used to store the DHCP entries used in the bridge mode
//

typedef struct _ARP1394_ETH_DHCP_ENTRY
{
    RM_OBJECT_HEADER Hdr;

    //
    // xid - per dhcp session (e.g discover, offer)
    //
    ULONG   xid;

    //
    // HW address in the dhcp packet.
    //
    ENetAddr requestorMAC;   

    //
    // New HW address that arp1394 inserts in the dhcp packet
    //
    ENetAddr newMAC;
  
    
    //
    // Time last checked to be used for aging purposes
    //
    UINT TimeLastChecked;

    //
    // Task used in unloading DhcpEntry
    //
    PRM_TASK pUnloadTask;
    
}ARP1394_ETH_DHCP_ENTRY, *PARP1394_ETH_DHCP_ENTRY;


typedef enum _ARP_RESUME_CAUSE {

    Cause_SetPowerD0,
    Cause_AfNotify,
    Cause_Unbind

} ARP_RESUME_CAUSE;
    


//=========================================================================
//                  N D I S      H A N D L E R S
//=========================================================================

INT
ArpNdBindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN  NDIS_HANDLE                 BindContext,
    IN  PNDIS_STRING                pDeviceName,
    IN  PVOID                       SystemSpecific1,
    IN  PVOID                       SystemSpecific2
);

VOID
ArpNdUnbindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 UnbindContext
);


VOID
ArpNdOpenAdapterComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status,
    IN  NDIS_STATUS                 OpenErrorStatus
);

VOID
ArpNdCloseAdapterComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status
);

VOID
ArpNdResetComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status
);

VOID
ArpNdReceiveComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext
);

VOID
ArpNdRequestComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PNDIS_REQUEST               pNdisRequest,
    IN  NDIS_STATUS                 Status
);

VOID
ArpNdStatus(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 GeneralStatus,
    IN  PVOID                       pStatusBuffer,
    IN  UINT                        StatusBufferSize
);

VOID
ArpNdStatusComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext
);

VOID
ArpNdSendComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PNDIS_PACKET                pNdisPacket,
    IN  NDIS_STATUS                 Status
);


//
// Following are some connectionless handlers we provide because we're calling
// connectionless entrypoints.
//

NDIS_STATUS
ArpNdReceive (
    NDIS_HANDLE  ProtocolBindingContext,
    NDIS_HANDLE Context,
    VOID *Header,
    UINT HeaderSize,
    VOID *Data,
    UINT Size,
    UINT TotalSize
    );

INT
ArpNdReceivePacket (
        NDIS_HANDLE  ProtocolBindingContext,
        PNDIS_PACKET Packet
        );



NDIS_STATUS
ArpNdPnPEvent(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PNET_PNP_EVENT              pNetPnPEvent
);

VOID
ArpNdUnloadProtocol(
    VOID
);


VOID
ArpCoSendComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PNDIS_PACKET                pNdisPacket
);

VOID
ArpCoStatus(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 ProtocolVcContext   OPTIONAL,
    IN  NDIS_STATUS                 GeneralStatus,
    IN  PVOID                       pStatusBuffer,
    IN  UINT                        StatusBufferSize
);


UINT
ArpCoReceivePacket(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PNDIS_PACKET                pNdisPacket
);


VOID
ArpCoAfRegisterNotify(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PCO_ADDRESS_FAMILY          pAddressFamily
);



NDIS_STATUS
ArpCoCreateVc(
    IN  NDIS_HANDLE                 ProtocolAfContext,
    IN  NDIS_HANDLE                 NdisVcHandle,
    OUT PNDIS_HANDLE                pProtocolVcContext
);

NDIS_STATUS
ArpCoDeleteVc(
    IN  NDIS_HANDLE                 ProtocolVcContext
);

NDIS_STATUS
ArpCoIncomingCall(
    IN      NDIS_HANDLE             ProtocolSapContext,
    IN      NDIS_HANDLE             ProtocolVcContext,
    IN OUT  PCO_CALL_PARAMETERS     pCallParameters
);

VOID
ArpCoCallConnected(
    IN  NDIS_HANDLE                 ProtocolVcContext
);

VOID
ArpCoIncomingClose(
    IN  NDIS_STATUS                 CloseStatus,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PVOID                       pCloseData  OPTIONAL,
    IN  UINT                        Size        OPTIONAL
);


VOID
ArpCoQosChange(
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS         pCallParameters
);


VOID
ArpCoOpenAfComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolAfContext,
    IN  NDIS_HANDLE                 NdisAfHandle
);


VOID
ArpCoCloseAfComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolAfContext
);


VOID
ArpCoMakeCallComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  NDIS_HANDLE                 NdisPartyHandle     OPTIONAL,
    IN  PCO_CALL_PARAMETERS         pCallParameters
);


VOID
ArpCoCloseCallComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  NDIS_HANDLE                 ProtocolPartyContext OPTIONAL
);


VOID
ArpCoModifyQosComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PCO_CALL_PARAMETERS         pCallParameters
);

NDIS_STATUS
ArpCoRequest(
    IN  NDIS_HANDLE                 ProtocolAfContext,
    IN  NDIS_HANDLE                 ProtocolVcContext   OPTIONAL,
    IN  NDIS_HANDLE                 ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST            pNdisRequest
);

VOID
ArpCoRequestComplete(
    IN  NDIS_STATUS                 Status,
    IN  NDIS_HANDLE                 ProtocolAfContext,
    IN  NDIS_HANDLE                 ProtocolVcContext   OPTIONAL,
    IN  NDIS_HANDLE                 ProtocolPartyContext    OPTIONAL,
    IN  PNDIS_REQUEST               pNdisRequest
);


//=========================================================================
//                  I P       H A N D L E R S
//=========================================================================

INT
ArpIpDynRegister(
    IN  PNDIS_STRING                pAdapterString,
    IN  PVOID                       IpContext,
    IN  struct _IP_HANDLERS *       pIpHandlers,
    IN  struct LLIPBindInfo *       pBindInfo,
    IN  UINT                        InterfaceNumber
    );

VOID
ArpIpOpen(
    IN  PVOID                       Context
    );

VOID
ArpIpClose(
    IN  PVOID                       Context
    );

UINT
ArpIpAddAddress(
    IN  PVOID                       Context,
    IN  UINT                        AddressType,
    IN  IP_ADDRESS                  IpAddress,
    IN  IP_MASK                     Mask,
    IN  PVOID                       Context2
    );

UINT
ArpIpDelAddress(
    IN  PVOID                       Context,
    IN  UINT                        AddressType,
    IN  IP_ADDRESS                  IpAddress,
    IN  IP_MASK                     Mask
    );

NDIS_STATUS
ArpIpMultiTransmit(
    IN  PVOID                       Context,
    IN  PNDIS_PACKET *              pNdisPacketArray,
    IN  UINT                        NumberOfPackets,
    IN  IP_ADDRESS                  Destination,
    IN  RouteCacheEntry *           pRCE        OPTIONAL,
    IN  VOID *                      ArpCtxt
    );

NDIS_STATUS
ArpIpTransmit(
    IN  PVOID                       Context,
    IN  PNDIS_PACKET                pNdisPacket,
    IN  IP_ADDRESS                  Destination,
    IN  RouteCacheEntry *           pRCE        OPTIONAL,
    IN  VOID *                      ArpCtxt
    );

NDIS_STATUS
ArpIpTransfer(
    IN  PVOID                       Context,
    IN  NDIS_HANDLE                 Context1,
    IN  UINT                        ArpHdrOffset,
    IN  UINT                        ProtoOffset,
    IN  UINT                        BytesWanted,
    IN  PNDIS_PACKET                pNdisPacket,
    OUT PUINT                       pTransferCount
    );

VOID
ArpIpInvalidate(
    IN  PVOID                       Context,
    IN  RouteCacheEntry *           pRCE
    );

INT
ArpIpQueryInfo(
    IN      PVOID                   Context,
    IN      TDIObjectID *           pID,
    IN      PNDIS_BUFFER            pNdisBuffer,
    IN OUT  PUINT                   pBufferSize,
    IN      PVOID                   QueryContext
    );

INT
ArpIpSetInfo(
    IN      PVOID                   Context,
    IN      TDIObjectID *           pID,
    IN      PVOID                   pBuffer,
    IN      UINT                    BufferSize
    );

INT
ArpIpGetEList(
    IN      PVOID                   Context,
    IN      TDIEntityID *           pEntityList,
    IN OUT  PUINT                   pEntityListSize
    );


VOID
ArpIpPnPComplete(
    IN  PVOID                       Context,
    IN  NDIS_STATUS                 Status,
    IN  PNET_PNP_EVENT              pNetPnPEvent
    );

NDIS_STATUS         
ArpSendARPApi(
    void * pInterface, 
    IPAddr Destination, 
    void * pControlBlock
    );



// The following structure has the general form of NDIS_CO_MEDIA_PARAMETERS.
// To properly track changes in NDIS_CO_MEDIA_PARAMETERS (however unlikeley!),
// code which uses any field in this structure should assert that the field is at
// the same offset as the corresponding NDIS structure.
// For example:
//  ASSERT(FIELD_OFFSET(ARP1394_CO_MEDIA_PARAMETERS,  Parameters)
//      == FIELD_OFFSET(CO_MEDIA_PARAMETERS,  MediaSpecific.Parameters))
//
//
typedef struct
{
    // First 3 fields of CO_MEDIA_PARAMETERS
    //
    ULONG                       Flags;              // TRANSMIT_VC and/or RECEIVE_VC
    ULONG                       ReceivePriority;    // 0 (unused)
    ULONG                       ReceiveSizeHint;    // 0 (unused)

    // Followed by 1st 2 fields of CO_SPECIFIC_PARAMETERS
    //
    ULONG   POINTER_ALIGNMENT   ParamType; // Set to NIC1394_MEDIA_SPECIFIC
    ULONG                       Length;    // Set to sizeof(NIC1394_MEDIA_PARAMETERS)

    // Followed by the NIC1394-specific media parameters.
    // Note: we can't directly put the NIC1394_MEDIA_PARAMETERS structure here because
    // it (currently) requires 8-byte alignment.
    //
    UCHAR                       Parameters[sizeof(NIC1394_MEDIA_PARAMETERS)];

} ARP1394_CO_MEDIA_PARAMETERS;

typedef enum _TASK_CAUSE {
    SetLowPower = 1,
    SetPowerOn
        
}TASK_CAUSE ;

typedef struct
{
    RM_TASK                     TskHdr;

    // Used to save the true return status (typically a failure status,
    // which we don't want to forget during async cleanup).
    //
    NDIS_STATUS ReturnStatus;

} TASK_ADAPTERINIT, *PTASK_ADAPTERINIT;

typedef struct
{
    RM_TASK                     TskHdr;
    ARP_NDIS_REQUEST            ArpNdisRequest;
    NIC1394_LOCAL_NODE_INFO     LocalNodeInfo;
    // Following is used to switch to PASSIVE before calling IP's add interface
    // Rtn.
    //
    NDIS_WORK_ITEM  WorkItem;

} TASK_ADAPTERACTIVATE, *PTASK_ADAPTERACTIVATE;

typedef struct
{
    RM_TASK TskHdr;
    NDIS_HANDLE pUnbindContext;

} TASK_ADAPTERSHUTDOWN, *PTASK_ADAPTERSHUTDOWN;

// This is the task structure to be used with arpTaskActivateInterface
//
typedef struct
{
    RM_TASK         TskHdr;


#if ARP_DEFERIFINIT
    // Following is used when waiting for the adapter to go to connected status
    //
    //
    NDIS_TIMER              Timer;
#endif // ARP_DEFERIFINIT

    // Following is used to switch to PASSIVE before calling IP's add interface
    // Rtn.
    //
    NDIS_WORK_ITEM  WorkItem;

} TASK_ACTIVATE_IF, *PTASK_ACTIVATE_IF;

// This is the task structure to be used with arpTaskDeactivateInterface
//
typedef struct
{
    RM_TASK         TskHdr;
    BOOLEAN         fPendingOnIpClose;
    TASK_CAUSE      Cause;   

    // Following is used to switch to PASSIVE before calling IP's del interface
    // Rtn.
    //
    NDIS_WORK_ITEM  WorkItem;

} TASK_DEACTIVATE_IF, *PTASK_DEACTIVATE_IF;

// This is the task structure to be used with arpTaskReinitInterface
//
typedef struct
{
    RM_TASK TskHdr;
    NDIS_HANDLE pUnbindContext;

    // Net PnP event to complete when reinit task is done.
    //
    PNET_PNP_EVENT pNetPnPEvent;

} TASK_REINIT_IF, *PTASK_REINIT_IF;

typedef struct
{
    RM_TASK                     TskHdr;

    // Ndis call params and media params for this call.
    //
    CO_CALL_PARAMETERS          CallParams;
    ARP1394_CO_MEDIA_PARAMETERS MediaParams;

} TASK_MAKECALL;

// This is the task structure to be used with arpTaskResolveIpAddress
//
typedef struct
{
    RM_TASK                     TskHdr;

    // Number of retry attempts left before we declare an address resolution failure.
    //
    UINT        RetriesLeft;

    // Used for the response timeout
    //
    NDIS_TIMER              Timer;

} TASK_RESOLVE_IP_ADDRESS, *PTASK_RESOLVE_IP_ADDRESS;

typedef struct
{
    RM_TASK         TskHdr;
    MYBOOL          Quit;   // If set, task will quit.
    NDIS_TIMER      Timer;  // Used for the periodically sending out packets.
    PNDIS_PACKET    p1394Pkt; // Used for testing forward to ethernet
    PNDIS_PACKET    pEthPkt;  // Used for sending connectionless ethernet pkts.
    UINT            Delay;    // Delay (ms) in between sending packets.
    UINT            PktType;  // Type of operation: do nothing, send over ethernet
                              // etc.
} TASK_ICS_TEST, *PTASK_ICS_TEST;


typedef struct
{
    RM_TASK         TskHdr;
    MYBOOL          Quit;   // If set, task will quit.
    NDIS_TIMER      Timer;  // Used for periodically waking up to do stuff.
    UINT            Delay;  // Current value of delay (seconds). Can change.
    UINT            RemoteIpMaintenanceTime; // Absolute time in seconds
    UINT            RemoteEthMaintenanceTime; // Absolute time in seconds
    UINT            LocalIpMaintenanceTime;  // Absolute time in seconds.
    UINT            McapDbMaintenanceTime; // Absolute time in seconds.
    UINT            DhcpTableMaintainanceTime; // Absolute time in seconds
    
} TASK_IF_MAINTENANCE, *PTASK_IF_MAINTENANCE;



typedef struct _TASK_BACKUP
{
    RM_TASK        Hdr;

    //
    // We are using Backup Task flag at position 31 because we do 
    // not want to conflict with the ResumeDelayed flags 
    // 
    #define ARP_BACKUP_TASK_MASK  0x80000000
    #define ARP_BACKUP_TASK_FLAG  0x80000000

    
    #define MARK_TASK_AS_BACKUP(_pT) \
                RM_SET_STATE(_pT, ARP_BACKUP_TASK_MASK  , ARP_BACKUP_TASK_FLAG )
    
    #define CHECK_TASK_IS_BACKUP(_pT) \
                RM_CHECK_STATE(_pT, ARP_BACKUP_TASK_MASK  , ARP_BACKUP_TASK_FLAG )

    #define GET_TASK_BACKUP_STATE(_pT) \
                RM_GET_STATE(_pT, ARP_BACKUP_TASK_MASK  )


    DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) SLIST_ENTRY      List;  // Linked list pointing to next task

} TASK_BACKUP, *PTASK_BACKUP;

// This structure is used to check whether the IP address assigned to 
// this interface is unique on the subnet
//
typedef struct TASK_CONFLICT_IP
{
    RM_TASK                     TskHdr;

    // Remote Ip used to resolve the Local IP address
    //
    ARPCB_REMOTE_IP             *pRemoteIp;

    //
    // Did this thread create the Remote Ip.
    //
    BOOLEAN                     fRemoteIpCreated;
    BOOLEAN                     fLinkedRemoteIp;
    //
    // IP Status to be indicated with the AddAddrCompletion routine
    //
    ULONG                           IpStatus;

    //
    // Work Item to bring us down to passive
    //
    NDIS_WORK_ITEM                  WorkItem;
}TASK_CONFLICT_IP,*PTASK_CONFLICT_IP;


// This is the task structure to be used with arpTaskResolveIpAddress
//
typedef struct
{
    RM_TASK                     TskHdr;

    NDIS_WORK_ITEM              WorkItem;

} TASK_UNLOAD_REMOTE, *PTASK_UNLOAD_REMOTE;


typedef void (*ArpRtn)(void *, IP_STATUS Status);

typedef struct ARPControlBlock {
   struct ARPControlBlock  *next;
   ArpRtn CompletionRtn;
   ulong status;
   ulong  PhyAddrLen;
   ulong *PhyAddr;

} ARPControlBlock;


typedef struct  _TASK_SEND_ARP_API
{
    RM_TASK                     TskHdr;

    // Remote Ip used to resolve the Local IP address
    //
    ARPCB_REMOTE_IP             *pRemoteIp;

    //
    // Did this thread create the Remote Ip.
    //
    BOOLEAN                     fRemoteIpCreated;
    BOOLEAN                     fLinkedRemoteIp;

    //
    // IP Status to be indicated with the AddAddrCompletion routine
    //
    ULONG                       IpStatus;

    //
    // Arp control block associated with this address
    //
    ARPControlBlock*            pSendArpCB;

    //
    // Destination 
    //
    IPAddr                      IPDest;

    //
    // Unique ID of the Destination
    //
    UINT64                      UniqueID;
    
}TASK_SEND_ARP_API, *PTASK_SEND_ARP_API;

//
// This task is used during a SetPower. 
// It contains structures that will be track of the 
// the numbero of calls that are closed /opened 
// and the events that need to be waited for.
//

typedef struct _CALL_COUNT
{
   // Count of Destination that will closeVc
    //
    ULONG           DestCount;

   // Event which the Close VC will wait on.
    //
    NDIS_EVENT      VcEvent;

} CALL_COUNT, *PCALL_COUNT;


typedef struct _TASK_POWER {
    RM_TASK         Hdr;

    // Status of the Task
    //  
    PNDIS_STATUS    pStatus;

    // Power state we are transitioning to
    //
    NET_DEVICE_POWER_STATE  PowerState;

    //
    //WorkItem to switch to passive

    NDIS_WORK_ITEM          WorkItem;

    //
    // Last working Stage of task - dbg purpose only 
    //
    UINT                    LastStage;

    //
    // Previous state of parent object. This is used so 
    // that the object can be placed back into its previous
    // state.
    //
    UINT PrevState;
} TASK_POWER, *PTASK_POWER;



//
// This structure is used to keep track of a close call
// that originated becuase of a SetPower
//


typedef struct _TASK_SET_POWER_CALL
{

    RM_TASK             Hdr;
    
    TASK_CAUSE    Cause;

    // The Call Call Count is used as place to count the number of outstanding close calls
    // It uses  DestCount as a place to store this information
    //
    PCALL_COUNT         pCount;

}TASK_SET_POWER_CALL, *PTASK_SET_POWER_CALL;


//
// ARP1394_TASK is the union of all tasks structures used in arp1394.
// arpAllocateTask allocates memory of sizeof(ARP1394_TASK), which is guaranteed
// to be large enough to hold any task.
// 
typedef union
{
    RM_TASK                 TskHdr;
    TASK_ADAPTERINIT        AdapterInit;
    TASK_ADAPTERSHUTDOWN    AdapterShutdown;
    TASK_ADAPTERACTIVATE    AdapterActivate;
    TASK_ACTIVATE_IF        ActivateIf;
    TASK_DEACTIVATE_IF      DeactivateIf;
    TASK_REINIT_IF          ReinitIf;
    TASK_MAKECALL           MakeFifoCall;
    TASK_RESOLVE_IP_ADDRESS ResolveIpAddress;
    TASK_IF_MAINTENANCE IfMaintenance;
    TASK_BACKUP         Backup;
    TASK_CONFLICT_IP    Conflict;
    TASK_SEND_ARP_API   SendArp;    
    TASK_UNLOAD_REMOTE  Unload;
    TASK_SET_POWER_CALL CloseCall;
    TASK_POWER          TaskPower;
}  ARP1394_TASK;

//
//  ---------------------------- DESTINATION (REMOTE) KEY --------------
//
#pragma pack (push, 1)
typedef union _REMOTE_DEST_KEY
{

    ENetAddr ENetAddress;
    IPAddr IpAddress;
    UCHAR  Addr[ARP_802_ADDR_LENGTH];

    struct
    {
        ULONG u32;
        USHORT u16;

    } u;

} REMOTE_DEST_KEY, *PREMOTE_DEST_KEY;

#pragma pack (pop)

#define REMOTE_DEST_IP_ADDRESS_FLAG 0xffff
#define IS_REMOTE_DEST_IP_ADDRESS(_R) ((_R)->u.u16 == REMOTE_DEST_IP_ADDRESS_FLAG )
#define REMOTE_DEST_IP_ADDRESS(_R) ((&(_R)->IpAddress))
#define REMOTE_DEST_ETH_ADDRESS(_R) ((&(_R)->ENetAddress))
#define REMOTE_DEST_KEY_INIT(_R) { (_R)->u.u32 = 0; (_R)->u.u16=REMOTE_DEST_IP_ADDRESS_FLAG ; };
//const REMOTE_DEST_KEY DefaultRemoteDestKey = {0,0,0,0,0xff,0xff};

//
//  ---------------------------- DESTINATION (REMOTE) IP CONTROL BLOCK --------------
//
//  Contains information about one destination (remote) IP address.
//
//  Parent Object: pInterface
//  Lock:          It's own lock.
//
//  There is atmost one ARP Table entry for a given IP address.
//
//  The IP Entry participates in two lists:
//  (1) A list of all entries that hash to the same bucket in the ARP Table
//  (2) A list of all entries that resolve to the same destination H/W Address --
//       this is only if the IP address is unicast.
//
//  A pointer to this structure is also used as our context value in the
//  Route Cache Entry prepared by the higher layer protocol(s).
//
//  Reference Count: We add one to its ref count for each of the following:
//  TBD:
//
typedef struct _ARPCB_REMOTE_IP
{
    RM_OBJECT_HEADER Hdr;       // Common header

    //
    // State flags for RemoteIp (in Hdr.State)
    //
    #define ARPREMOTEIP_RESOLVED_MASK   0x0f
    #define ARPREMOTEIP_UNRESOLVED      0x00
    #define ARPREMOTEIP_RESOLVED        0x01


    #define ARPREMOTEIP_SDTYPE_MASK     0x10  // "SD" == Static/Dynamic
    #define ARPREMOTEIP_STATIC          0x00
    #define ARPREMOTEIP_DYNAMIC         0x10

    #define ARPREMOTEIP_FCTYPE_MASK     0x20    // "FC" == FIFO/Channel
    #define ARPREMOTEIP_FIFO            0x00
    #define ARPREMOTEIP_CHANNEL         0x20

    #define ARPREMOTEIP_MCAP_MASK       0x40    // "FC" == FIFO/Channel
    #define ARPREMOTEIP_MCAP_CAPABLE    0x40

    #define SET_REMOTEIP_RESOLVE_STATE(_pRIp, _IfState) \
                RM_SET_STATE(_pRIp, ARPREMOTEIP_RESOLVED_MASK, _IfState)
    
    #define CHECK_REMOTEIP_RESOLVE_STATE(_pRIp, _IfState) \
                RM_CHECK_STATE(_pRIp, ARPREMOTEIP_RESOLVED_MASK, _IfState)

    #define SET_REMOTEIP_SDTYPE(_pRIp, _IfState) \
                RM_SET_STATE(_pRIp, ARPREMOTEIP_SDTYPE_MASK, _IfState)
    
    #define CHECK_REMOTEIP_SDTYPE(_pRIp, _IfState) \
                RM_CHECK_STATE(_pRIp, ARPREMOTEIP_SDTYPE_MASK, _IfState)

    #define SET_REMOTEIP_FCTYPE(_pRIp, _IfState) \
                RM_SET_STATE(_pRIp, ARPREMOTEIP_FCTYPE_MASK, _IfState)
    
    #define CHECK_REMOTEIP_FCTYPE(_pRIp, _IfState) \
                RM_CHECK_STATE(_pRIp, ARPREMOTEIP_FCTYPE_MASK, _IfState)

    #define SET_REMOTEIP_MCAP(_pRIp, _IfState) \
                RM_SET_STATE(_pRIp, ARPREMOTEIP_MCAP_MASK, _IfState)
    
    #define CHECK_REMOTEIP_MCAP(_pRIp, _IfState) \
                RM_CHECK_STATE(_pRIp, ARPREMOTEIP_MCAP_MASK, _IfState)


    
    
    IP_ADDRESS                      IpAddress;      // IP Address
    LIST_ENTRY                      linkSameDest;   // List of entries pointing to
                                                    // the same destination.
    ARPCB_DEST                      *pDest;         // Pointer to destination CB.

    REMOTE_DEST_KEY                 Key; // Ip address or Mac Address

#if TODO
            // Timers are: (all exclusive)
            // - Aging timer
            // - Waiting for ARP reply
            // - Waiting for InARP reply
            // - Delay after NAK
            // - Waiting for MARS MULTI
            // - Delay before marking for reval
#endif // TODO

    ULONG                           RetriesLeft;

    // The information in this struct is protected by the IF send lock,
    // EXCEPT as noted.
    //
    struct
    {
        // Singly-linked list of Route Cache Entries (no space in RCE to hold
        // a doubly-linked list, unfortunately.)
        //
        RouteCacheEntry *pRceList;

        // listSendPkts is NOT protected by the IF send lock. Instead it is protected
        // by this object(pRemoteIp)'s lock.
        //
        LIST_ENTRY                      listSendPkts;

        //  This entry is NOT protected by any lock. It is set to ZERO
        //  each time a packet is sent to this address and is set to the
        //  current system time periodically by the garbage collecting task.
        //
        UINT                            TimeLastChecked;

    }   sendinfo;

    PRM_TASK                        pSendPktsTask;// Points to the task  (if any)
                                            // Attempting to send queued packets.

    PRM_TASK                        pResolutionTask;// Points to the task  (if any)
                                                    // attempting to resolve
                                                    // this destination IP address.

    PRM_TASK                        pUnloadTask;    // Unload (shutdown) this object.

} ARPCB_REMOTE_IP, *PARPCB_REMOTE_IP;

#define ASSERT_VALID_REMOTE_IP(_pRemoteIp) \
                                 ASSERT((_pRemoteIp)->Hdr.Sig == MTAG_REMOTE_IP)

#define VALID_REMOTE_IP(_pRemoteIp)  ((_pRemoteIp)->Hdr.Sig == MTAG_REMOTE_IP)


//
//  --------------------- DESTINATION (REMOTE) ETHERNET CONTROL BLOCK --------------

// Creation Params -- passed into the function that creates an
// instance of a remote ethernet control block.
//
typedef struct
{
    ENetAddr                EthAddress;
    IP_ADDRESS              IpAddress;

} ARP_REMOTE_ETH_PARAMS, *PARP_REMOTE_ETH_PARAMS;

//
//  Contains information about one destination (remote) Ethernet address.
//
//  Parent Object: pInterface
//  Lock:          pInterface
//
//  There is atmost one Ethernet Table entry for a given Remote ethernet address.
//
//  The Ethernet entry participates in one group:
//   A list of all entries that hash to the same bucket in the Ethernet Table
//
typedef struct _ARPCB_REMOTE_ETH
{
    RM_OBJECT_HEADER Hdr;       // Common header
    IP_ADDRESS       IpAddress; // Remote IP address
    ENetAddr         EthAddress; // Remote Ethernet MAC addres
    PRM_TASK         pUnloadTask;   // Unload (shutdown) this object.

    //  This entry is NOT protected by any lock. It is set to ZERO
    //  each time a packet is sent to this address and is set to the
    //  current system time periodically by the garbage collecting task.
    //
    UINT                            TimeLastChecked;

} ARPCB_REMOTE_ETH, *PARPCB_REMOTE_ETH;

#define ASSERT_VALID_REMOTE_ETH(_pRemoteEth) \
                                 ASSERT((_pRemoteEth)->Hdr.Sig == MTAG_REMOTE_ETH)


//
//  ---------------------------- LOCAL IP CONTROL BLOCK --------------
//
//  Contains information about one local IP address.
//
//  Parent Object: pInterface
//  Lock:          uses parent's (pInterface's) lock.
//
typedef struct _ARPCB_LOCAL_IP
{
    RM_OBJECT_HEADER            Hdr;                // Common header

    //
    // State flags for LocalIp (in Hdr.State)
    //

    #define ARPLOCALIP_MCAP_MASK        0x40
    #define ARPLOCALIP_MCAP_CAPABLE     0x40

    #define SET_LOCALIP_MCAP(_pLIp, _IfState) \
                RM_SET_STATE(_pLIp, ARPLOCALIP_MCAP_MASK, _IfState)
    
    #define CHECK_LOCALIP_MCAP(_pLIp, _IfState) \
                RM_CHECK_STATE(_pLIp, ARPLOCALIP_MCAP_MASK, _IfState)


    UINT                        IpAddressType;      // One of the  LLIP_ADDR_* consts
    IP_ADDRESS                  IpAddress;          // The Address
    IP_MASK                     IpMask;             // Mask for the above.
    UINT                        AddAddressCount;    // No of times address was added
    PVOID                       pContext2;          // context passed into ArpIpAddAddress
    PRM_TASK                    pRegistrationTask;  // Points to the task (if any)
                                                    // that is doing the unsolicited
                                                    // ARP request to report and
                                                    // validate this IP address is
                                                    // owned by the local interface.
    PRM_TASK                    pUnloadTask;        // Unload (shutdown) this object.
    PRM_TASK                    pConflictTask;        // Task to check for Conflicts


    LIST_ENTRY                      linkSameDest;   // List of entries pointing to
    ARPCB_DEST                      *pDest;         // Pointer to destination CB.

} ARPCB_LOCAL_IP, *PARPCB_LOCAL_IP;

// Returns true IFF pLocalIp is in the process of going away (assumes
// pLocalIp's lock is held) ...
//
#define ARP_LOCAL_IP_IS_UNLOADING(pLocalIp)  (pLocalIp->pUnloadTask != NULL)


typedef struct
{
    NIC1394_DESTINATION     HwAddr;         // Must be 1st for hash function.
    UINT                    ChannelSeqNo;
    BOOLEAN                 ReceiveOnly;
    BOOLEAN                 AcquireChannel;

} ARP_DEST_PARAMS, *PARP_DEST_PARAMS;

//
//  ---------------------------- DESTINATION CONTROL BLOCK --------------
//
//  All information about an remote destination, including list of VCs to it.
//  This is used for both unicast destinations and multicast/broadcast
//  destinations.
//
//  Parent Object: PARCB_INTERFACE (Interface control block).
//  Lock:          uses parent's (Interface).
//
typedef struct _ARPCB_DEST
{
    RM_OBJECT_HEADER                Hdr;                // Common header

    LIST_ENTRY                      listIpToThisDest;   // List of IP entries that
                                                        // point to this entry
    LIST_ENTRY                      listLocalIp;        // List of local IP entries
                                                        // related to this dest. that
                                                        // (Currently only related to
                                                        // MCAP recv channels, but
                                                        // could be extended to
                                                        // using async stream for
                                                        // FIFO as well!).


    ARP_DEST_PARAMS                 Params;             // Dest HW Address, etc.

    ARP_VC_HEADER                   VcHdr;          // Single VC associated
                                                        // with this object.
    PRM_TASK                    pUnloadTask;        // Unload (shutdown) this object.

    // The following structure is protected by the IF send lock.
    // It contains all the information required for the fast send path.
    //
    struct
    {
        PRM_TASK            pSuspendedCleanupCallTask;
        UINT                NumOutstandingSends;
        BOOLEAN             OkToSend;
        BOOLEAN             IsFifo;
    
    } sendinfo;
    #define ARP_DEST_IS_FIFO(_pDest)        ((_pDest)->sendinfo.IsFifo != 0)
    #define ARP_CAN_SEND_ON_DEST(_pDest)    ((_pDest)->sendinfo.OkToSend != 0)

} ARPCB_DEST, *PARPCB_DEST;
#define ARP_OBJECT_IS_DEST(_pHdr) ((_pHdr)->Sig == MTAG_DEST)
#define ASSERT_VALID_DEST(_pDest) \
                                 ASSERTEX((_pDest)->Hdr.Sig == MTAG_DEST, (_pDest))


#if OBSOLETE
//
//  ---------------------------- RECV CHANNEL CONTROL BLOCK --------------
//
//  All information about a receive channel destination.
//
//  Parent Object: PARCB_INTERFACE (Interface control block).
//  Lock:          uses parent's (Interface).
//
typedef struct _ARPCB_RCVCH
{
    RM_OBJECT_HEADER                Hdr;                // Common header

    LIST_ENTRY                      listLIpToThisDest;  // List of Local IP entries
                                                        // that point to this entry

    NIC1394_DESTINATION             HwAddr;             // Destination HW Address.

    ARP_VC_HEADER                   VcHdr;          // Single VC associated
                                                        // with this object.
    PRM_TASK                    pUnloadTask;        // Unload (shutdown) this object.


} ARPCB_DEST, *PARPCB_RCVCH;
#endif // OBSOLETE


// Following sits in the miniport-reserved portion of send-pkts, before they
// are sent out. We have 4 UINT_PTRs of space available to us.
//
typedef struct
{
    LIST_ENTRY linkQueue;

    union
    {
        struct
        {
            IP_ADDRESS  IpAddress;
            ULONG       Flags;
            #define ARPSPI_BACKFILLED       0x1
            #define ARPSPI_HEADBUF          0x2
            #define ARPSPI_FIFOPKT          0x4
            #define ARPSPI_CHANNELPKT       0x8
        } IpXmit;
    };

} ARP_SEND_PKT_MPR_INFO;

//
// Various macros for getting and setting information saved in the
// MiniportReserved portion of packets waiting to be sent...
//

#define ARP_OUR_CTXT_FROM_SEND_PACKET(_pPkt) \
    ((ARP_SEND_PKT_MPR_INFO *) &(_pPkt)->MiniportReserved)

#define ARP_SEND_PKT_FROM_OUR_CTXT(_pCtxt) \
                CONTAINING_RECORD((_pCtxt), NDIS_PACKET, MiniportReserved)

// Our context in the IP RouteCacheEntry.
// (Max 2 UINT_PTRs available)
// Since we also want to keep the destination type (FIFO or CHANNEL) in the RCE,
// we resort to the questionable technique of saving the FIFO/CHANNEL info in
// LSB bit of the UINT_PTR used for storing the pointer to the RemoteIp object.
// We want to keep the FIFO/CHANNEL info in the RCE so that we can prepend
// the correct header block WITHOUT holding the send lock. We want to keep
// the send lock held for as little time as possible.
//
typedef struct
{
    ARPCB_REMOTE_IP *pRemoteIp;     // Ptr to pRemoteIp
    RouteCacheEntry *pNextRce;      // Ptr to next RCE associated with the above
                                    // RemoteIP
} ARP_RCE_CONTEXT;

#define ARP_OUR_CTXT_FROM_RCE(_pRCE) \
                ((ARP_RCE_CONTEXT*)  &(_pRCE)->rce_context)

// Parsed version of the IP/1394 ARP packet.
//
typedef struct
{
    NIC1394_FIFO_ADDRESS    SenderHwAddr;       // requires 8-byte alignment.
    UINT                    OpCode;
    UINT                    SenderMaxRec;
    UINT                    SenderMaxSpeedCode;
    IP_ADDRESS              SenderIpAddress;
    IP_ADDRESS              TargetIpAddress;
    UCHAR                   SourceNodeAdddress;
    UCHAR                   fPktHasNodeAddress;
    ENetAddr                 SourceMacAddress;                    
    
} IP1394_ARP_PKT_INFO, *PIP1394_ARP_PKT_INFO;


// Parsed version of the IP/1394 MCAP Group Descriptor 
//
typedef struct
{
    UINT                    Expiration;
    UINT                    Channel;
    UINT                    SpeedCode;
    IP_ADDRESS              GroupAddress;

}  IP1394_MCAP_GD_INFO, * PIP1394_MCAP_GD_INFO;


// Parsed version of an IP/1394 MCAP packet.
//
typedef struct
{
    UINT                    SenderNodeID;
    UINT                    OpCode;
    UINT                    NumGroups;
    PIP1394_MCAP_GD_INFO    pGdis;

    // Space for storing up-to 4 GD_INFOs
    //
    IP1394_MCAP_GD_INFO     GdiSpace[4];

} IP1394_MCAP_PKT_INFO, *PIP1394_MCAP_PKT_INFO;



typedef struct _EUID_NODE_MAC_TABLE_WORKITEM
{
    // WorkItem used in the request
    NDIS_WORK_ITEM WorkItem;

} EUID_NODE_MAC_TABLE_WORKITEM, *PEUID_NODE_MAC_TABLE_WORKITEM;


typedef struct _ARP1394_WORK_ITEM ARP1394_WORK_ITEM, *PARP1394_WORK_ITEM; 

typedef 
NDIS_STATUS    
(*ARP_WORK_ITEM_PROC)(
    struct _ARP1394_WORK_ITEM*, 
    PRM_OBJECT_HEADER, 
    PRM_STACK_RECORD
    );

typedef struct _ARP1394_WORK_ITEM
{

    union
    {
        EUID_TOPOLOGY Euid;
        NDIS_WORK_ITEM NdisWorkItem;
    }  u;


    ARP_WORK_ITEM_PROC pFunc;

} ARP1394_WORK_ITEM, *PARP1394_WORK_ITEM;


// Structure to express the information carried in an IP header
typedef struct _ARP_IP_HEADER_INFO
{

    UCHAR               protocol;
    IP_ADDRESS          ipSource, ipTarget;
    USHORT              headerSize;
    ULONG               IpHeaderOffset;
    ULONG               IpPktLength;

} ARP_IP_HEADER_INFO, *PARP_IP_HEADER_INFO;


//=========================================================================
//                  I N T E R N A L     P R O T O T Y P E S
//=========================================================================

NTSTATUS
ArpDeviceIoControl(
    IN  PDEVICE_OBJECT              pDeviceObject,
    IN  PIRP                        pIrp
);

NTSTATUS
ArpWmiDispatch(
    IN  PDEVICE_OBJECT              pDeviceObject,
    IN  PIRP                        pIrp
);

NTSTATUS
ArpHandleIoctlRequest(
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp
);


NDIS_STATUS
arpCfgGetInterfaceConfiguration(
        IN ARP1394_INTERFACE    *   pIF,
        IN PRM_STACK_RECORD pSR
);

NDIS_STATUS
arpCfgReadAdapterConfiguration(
    IN  ARP1394_ADAPTER *           pAdapter,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpCfgReadInterfaceConfiguration(
    IN  NDIS_HANDLE                 InterfaceConfigHandle,
    IN  ARP1394_INTERFACE *         pF,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpAllocateTask(
    IN  PRM_OBJECT_HEADER           pParentObject,
    IN  PFN_RM_TASK_HANDLER         pfnHandler,
    IN  UINT                        Timeout,
    IN  const char *                szDescription, OPTIONAL
    OUT PRM_TASK                    *ppTask,
    IN  PRM_STACK_RECORD            pSR
    );

VOID
arpFreeTask(
    IN  PRM_TASK                    pTask,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskInitInterface(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskDeinitInterface(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskReinitInterface(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskActivateInterface(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskDeactivateInterface(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskMakeRecvFifoCall(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskCleanupRecvFifoCall(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskMakeCallToDest(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskCleanupCallToDest(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskResolveIpAddress(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

PRM_OBJECT_HEADER
arpAdapterCreate(
        PRM_OBJECT_HEADER   pParentObject,
        PVOID               pCreateParams,
        PRM_STACK_RECORD    psr
        );

VOID
arpDeinitIf(
    PARP1394_INTERFACE  pIF,
    PRM_TASK            pCallingTask,   // OPTIONAL
    UINT                SuspendCode,    // OPTIONAL
    PRM_STACK_RECORD    pSR
    );


NDIS_STATUS
arpTaskUnloadLocalIp(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskUnloadRemoteIp(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskUnloadRemoteEth(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskUnloadDestination(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

VOID
arpObjectDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    );

VOID
arpAdapterDelete (
    PRM_OBJECT_HEADER pObj,
    PRM_STACK_RECORD psr
    );

NDIS_STATUS
arpCopyUnicodeString(
        OUT         PNDIS_STRING pDest,
        IN          PNDIS_STRING pSrc,
        BOOLEAN     fUpCase
        );

NDIS_STATUS
arpTaskInitializeAdapter(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskShutdownAdapter(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );


NDIS_STATUS
arpTaskActivateAdapter(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskDeactivateAdapter(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );


NDIS_STATUS
arpTaskInterfaceTimer(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskInterfaceTimer(
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpTaskIfMaintenance(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpInitializeConstBufferPool(
    IN      UINT                    NumBuffersToCache,
    IN      UINT                    MaxBuffers,
    IN      const VOID*             pvMem,
    IN      UINT                    cbMem,
    IN      PRM_OBJECT_HEADER       pOwningObject,
    IN OUT  ARP_CONST_BUFFER_POOL * pHdrPool,
    IN      PRM_STACK_RECORD        pSR
    );

VOID
arpDeinitializeConstBufferPool(
    IN      ARP_CONST_BUFFER_POOL * pHdrPool,
    IN      PRM_STACK_RECORD pSR
    );

PNDIS_BUFFER
arpAllocateConstBuffer(
    ARP_CONST_BUFFER_POOL       *   pHdrPool
    );

VOID
arpDeallocateConstBuffer(
    ARP_CONST_BUFFER_POOL       *   pHdrPool,
    PNDIS_BUFFER                    pNdisBuffer
    );

VOID
arpCompleteSentPkt(
    IN  NDIS_STATUS                 Status,
    IN  ARP1394_INTERFACE   *       pIF,
    IN  ARPCB_DEST          *       pDest,
    IN  PNDIS_PACKET                pNdisPacket
    );

NDIS_STATUS
arpParseArpPkt(
    IN   PIP1394_ARP_PKT      pArpPkt,
    IN   UINT                           cbBufferSize,
    OUT  PIP1394_ARP_PKT_INFO       pPktInfo
    );

VOID
arpPrepareArpPkt(
    IN      PIP1394_ARP_PKT_INFO    pArpPktInfo,
    // IN       UINT                        SenderMaxRec,
    OUT     PIP1394_ARP_PKT   pArpPkt
    );

NDIS_STATUS
arpPrepareArpResponse(
    IN      PARP1394_INTERFACE          pIF,            // NOLOCKIN NOLOCKOUT
    IN      PIP1394_ARP_PKT_INFO    pArpRequest,
    OUT     PIP1394_ARP_PKT_INFO    pArpResponse,
    IN      PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpAddOneStaticArpEntry(
    IN PARP1394_INTERFACE       pIF,    // LOCKIN LOCKOUT
    IN IP_ADDRESS               IpAddress,
    IN PNIC1394_FIFO_ADDRESS    pFifoAddr,
    IN PRM_STACK_RECORD pSR
    );

VOID
arpSetPrimaryIfTask(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    );

VOID
arpClearPrimaryIfTask(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    );

VOID
arpSetSecondaryIfTask(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    );

VOID
arpClearSecondaryIfTask(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    );

VOID
arpSetPrimaryAdapterTask(
    PARP1394_ADAPTER    pAdapter,           // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    );

VOID
arpClearPrimaryAdapterTask(
    PARP1394_ADAPTER    pAdapter,           // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               PrimaryState,
    PRM_STACK_RECORD    pSR
    );

VOID
arpSetSecondaryAdapterTask(
    PARP1394_ADAPTER    pAdapter,           // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    );

VOID
arpClearSecondaryAdapterTask(
    PARP1394_ADAPTER    pAdapter,           // LOCKIN LOCKOUT
    PRM_TASK            pTask, 
    ULONG               SecondaryState,
    PRM_STACK_RECORD    pSR
    );

NDIS_STATUS
arpTryReconfigureIf(
    PARP1394_INTERFACE pIF,
    PNET_PNP_EVENT pNetPnPEvent,
    PRM_STACK_RECORD pSR
    );

VOID
arpResetIfStats(
        IN  PARP1394_INTERFACE  pIF, // LOCKIN LOCKOUT
        IN  PRM_STACK_RECORD    pSR
        );

VOID
arpGetPktCountBins(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket,
    OUT PULONG              pSizeBin,
    OUT PULONG              pTimeBin
    );

VOID
arpLogSendFifoCounts(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket,
    IN  NDIS_STATUS         Status
    );

VOID
arpLogRecvFifoCounts(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket
    );

VOID
arpLogSendChannelCounts(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket,
    IN  NDIS_STATUS         Status
    );

VOID
arpLogRecvChannelCounts(
    IN  PARP1394_INTERFACE  pIF,            // NOLOCKIN NOLOCKOUT
    IN  PNDIS_PACKET        pNdisPacket
    );

NDIS_STATUS
arpInitializeVc(
    PARP1394_INTERFACE  pIF,
    PARP_STATIC_VC_INFO pVcInfo,
    PRM_OBJECT_HEADER   pOwner,
    PARP_VC_HEADER      pVcHdr,
    PRM_STACK_RECORD    pSR
    );

VOID
arpDeinitializeVc(
    PARP1394_INTERFACE  pIF,
    PARP_VC_HEADER      pVcHdr,
    PRM_OBJECT_HEADER   pOwner,     // NOLOCKIN NOLOCKOUT
    PRM_STACK_RECORD    pSR
    );

NDIS_STATUS
arpAllocateControlPacketPool(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    UINT                MaxBufferSize,
    PRM_STACK_RECORD    pSR
    );

VOID
arpFreeControlPacketPool(
    PARP1394_INTERFACE  pIF,            // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    );

NDIS_STATUS
arpAllocateControlPacket(
    IN  PARP1394_INTERFACE  pIF,
    IN  UINT                cbBufferSize,
    IN  UINT                PktFlags,
    OUT PNDIS_PACKET        *ppNdisPacket,
    OUT PVOID               *ppvData,
        PRM_STACK_RECORD    pSR
    );

VOID
arpFreeControlPacket(
    PARP1394_INTERFACE  pIF,
    PNDIS_PACKET        pNdisPacket,
    PRM_STACK_RECORD    pSR
    );

VOID
arpRefSendPkt(
    PNDIS_PACKET    pNdisPacket,
    PARPCB_DEST     pDest
    );

VOID
arpProcessArpPkt(
    PARP1394_INTERFACE  pIF,
    PIP1394_ARP_PKT     pArpPkt,
    UINT                cbBufferSize
    );

VOID
arpProcessMcapPkt(
    PARP1394_INTERFACE  pIF,
    PIP1394_MCAP_PKT    pMcapPkt,
    UINT                cbBufferSize
    );

VOID
arpLinkRemoteIpToDest(
    ARPCB_REMOTE_IP     *pRemoteIp,
    ARPCB_DEST          *pDest,
    PRM_STACK_RECORD    pSR
    );

VOID
arpUnlinkRemoteIpFromDest(
    ARPCB_REMOTE_IP     *pRemoteIp, // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    );

VOID
arpUnlinkAllRemoteIpsFromDest(
    ARPCB_DEST  *pDest, // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    );

VOID
arpLinkLocalIpToDest(
    ARPCB_LOCAL_IP  *   pLocalIp,
    ARPCB_DEST          *pDest,
    PRM_STACK_RECORD    pSR
    );

VOID
arpUnlinkLocalIpFromDest(
    ARPCB_LOCAL_IP  *pLocalIp,  // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    );

VOID
arpUnlinkAllLocalIpsFromDest(
    ARPCB_DEST  *pDest, // LOCKIN LOCKOUT
    PRM_STACK_RECORD    pSR
    );

#if 0

NDIS_STATUS
arpCopyAnsiStringToUnicodeString(
        OUT         PNDIS_STRING pDest,
        IN          PANSI_STRING pSrc
        );

NDIS_STATUS
arpCopyUnicodeStringToAnsiString(
        OUT         PANSI_STRING pDest,
        IN          PNDIS_STRING pSrc
        );
#endif // 0


VOID
arpUpdateReceiveMultichannels(
        PARP1394_INTERFACE  pIF,
        UINT                SecondsSinceLastCall,
        PRM_STACK_RECORD    pSR
        );

NDIS_STATUS
arpPrepareAndSendNdisRequest(
    IN  PARP1394_ADAPTER            pAdapter,
    IN  PARP_NDIS_REQUEST           pArpNdisRequest,
    IN  PRM_TASK                    pTask,              // OPTIONAL
    IN  UINT                        PendCode,
    IN  NDIS_OID                    Oid,
    IN  PVOID                       pBuffer,
    IN  ULONG                       BufferLength,
    IN  NDIS_REQUEST_TYPE           RequestType,
    IN  PRM_STACK_RECORD            pSR
    );
        

typedef enum
{
    ARP_ICS_FORWARD_TO_1394,
    ARP_ICS_FORWARD_TO_ETHERNET,

} ARP_ICS_FORWARD_DIRECTION;


VOID
arpEthReceivePacket(
    ARP1394_INTERFACE   *   pIF,
    PNDIS_PACKET Packet
    );


NDIS_STATUS
arpAllocateEthernetPools(
    IN  PARP1394_INTERFACE  pIF,
    IN  PRM_STACK_RECORD    pSR
    );

VOID
arpFreeEthernetPools(
    IN  PARP1394_INTERFACE  pIF,
    IN  PRM_STACK_RECORD    pSR
    );

VOID
arpDbgIncrementReentrancy(
    PLONG pReentrancyCount
    );

VOID
arpDbgDecrementReentrancy(
    PLONG pReentrancyCount
    );

VOID
arpHandleControlPktSendCompletion(
    IN  ARP1394_INTERFACE   *   pIF,
    IN  PNDIS_PACKET            pNdisPacket
    );

VOID
arpStartIfMaintenanceTask(
    IN  PARP1394_INTERFACE          pIF,  // NOLOCKIN NOLOCKOUT
    PRM_STACK_RECORD                pSR
    );

NDIS_STATUS
arpTryStopIfMaintenanceTask(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    IN  PRM_TASK                    pTask, // task to pend until M task completes
    IN  UINT                        PendCode, // Pend code to suspend task.
    PRM_STACK_RECORD                pSR
    );

UINT
arpGetSystemTime(VOID);


BOOLEAN
arpCanTryMcap(
    IP_ADDRESS  IpAddress
    );

UINT
arpFindAssignedChannel(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    IN  IP_ADDRESS                  IpAddress,
    IN  UINT                        CurrentTime,
    PRM_STACK_RECORD                pSR
    );

VOID
arpUpdateRemoteIpDest(
    IN  PARP1394_INTERFACE          pIF, // NOLOCKIN NOLOCKOUT
    IN  PARPCB_REMOTE_IP            pRemoteIp,
    IN  PARP_DEST_PARAMS            pDestParams,
    PRM_STACK_RECORD                pSR
    );

MYBOOL
arpIsActiveMcapChannel(
        PMCAP_CHANNEL_INFO pMci,
        UINT CurrentTime
        );

VOID
arpSendControlPkt(
    IN  ARP1394_INTERFACE       *   pIF,            // LOCKIN NOLOCKOUT (IF send lk)
    IN  PNDIS_PACKET                pNdisPacket,
    IN  PARPCB_DEST                 pDest,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpCreateMcapPkt(
    IN  PARP1394_INTERFACE          pIF,
    IN  PIP1394_MCAP_PKT_INFO       pPktInfo,
    OUT PNDIS_PACKET               *ppNdisPacket,
    PRM_STACK_RECORD                pSR
    );

UINT
arpProcessReceivedPacket(
    IN  PARP1394_INTERFACE      pIF,
    IN  PNDIS_PACKET            pNdisPacket,
    IN  MYBOOL                  IsChannel
);

VOID
arpUpdateArpCache(
    PARP1394_INTERFACE          pIF,    // NOLOCKIN NOLOCKOUT
    IP_ADDRESS                  RemoteIpAddress,
    ENetAddr                    *pRemoteEthAddress,
    PARP_DEST_PARAMS            pDestParams,
    MYBOOL                      fCreateIfRequired,
    PRM_STACK_RECORD            pSR
    );

UINT
arpEthernetReceivePacket(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 ProtocolVcContext,
    IN  PNDIS_PACKET                pNdisPacket
);

VOID
arpEthReceive1394Packet(
    IN  PARP1394_INTERFACE      pIF,
    IN  PNDIS_PACKET            pNdisPacket,
    IN  PVOID                   pvHeader,
    IN  UINT                    HeaderSize,
    IN  MYBOOL                  IsChannel
    );

NDIS_STATUS
arpSlowIpTransmit(
    IN  ARP1394_INTERFACE       *   pIF,
    IN  PNDIS_PACKET                pNdisPacket,
    IN  REMOTE_DEST_KEY            Destination,
    IN  RouteCacheEntry *           pRCE        OPTIONAL
    );

VOID
arpDelRceList(
    IN  PARPCB_REMOTE_IP  pRemoteIp,    // IF send lock WRITELOCKIN WRITELOCKOUTD
    IN  PRM_STACK_RECORD pSR
    );

VOID    
arpGenericWorkItem(
    struct _NDIS_WORK_ITEM * pWorkItem, 
    PVOID pContext
    );

VOID
arpQueueWorkItem (
    PARP1394_WORK_ITEM pWorkItem,
    ARP_WORK_ITEM_PROC pFunc,
    PRM_OBJECT_HEADER pHdr,
    PRM_STACK_RECORD pSR
    );

NDIS_STATUS
arpGetEuidTopology (
    IN PARP1394_ADAPTER pAdapter,
    PRM_STACK_RECORD pSR
    );

VOID
arpNdProcessBusReset(
    IN PARP1394_ADAPTER pAdapter
    );

VOID
arpReturnBackupTask (
    IN ARP1394_TASK* pTask
    );


VOID
arpAllocateBackupTasks (
    ARP1394_GLOBALS*                pGlobals 
    );



VOID
arpFreeBackupTasks (
    ARP1394_GLOBALS*                pGlobals 
    );



ARP1394_TASK *
arpGetBackupTask (
    IN ARP1394_GLOBALS*  pGlobals
    );


NTSTATUS
arpDelArpEntry(
        PARP1394_INTERFACE           pIF,
        IPAddr                       IpAddress,
        PRM_STACK_RECORD            pSR
        );

VOID
arpAddBackupTasks (
    IN ARP1394_GLOBALS* pGlobals,
    UINT Num
    );

VOID
arpRemoveBackupTasks (
    IN ARP1394_GLOBALS* pGlobals,
    UINT Num
     );

MYBOOL
arpNeedToCleanupDestVc(
        ARPCB_DEST *pDest   // LOCKING LOCKOUT
        );

VOID
arpLowPowerCloseAllCalls (
    ARP1394_INTERFACE *pIF,
    PRM_STACK_RECORD pSR
    );
    
VOID
arpDeactivateIf(
    PARP1394_INTERFACE  pIF,
    PRM_TASK            pCallingTask,   // OPTIONAL
    UINT                SuspendCode,    // OPTIONAL
    PRM_STACK_RECORD    pSR
    );

NDIS_STATUS
arpTaskLowPower(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpSetupSpecialDest(
    IN  PARP1394_INTERFACE      pIF,
    IN  NIC1394_ADDRESS_TYPE    AddressType,
    IN  PRM_TASK                pParentTask,
    IN  UINT                    PendCode,
    OUT PARPCB_DEST         *   ppSpecialDest,
    IN  PRM_STACK_RECORD        pSR
    );

NDIS_STATUS
arpResume (
    IN ARP1394_ADAPTER* pAdapter,
    IN ARP_RESUME_CAUSE Cause,
    IN PRM_STACK_RECORD pSR
    );   


NDIS_STATUS
arpTaskOnPower (
    IN  PRM_TASK                    pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,  // Unused
    IN  PRM_STACK_RECORD            pSR
    );

NDIS_STATUS
arpMakeCallOnDest(
    IN  PARPCB_REMOTE_IP            pRemoteIp,  
    IN  PARPCB_DEST                 pDest,
    IN  PRM_TASK                    pTaskToPend,
    IN  ULONG                       PEND_StageMakeCallComplete,
    IN  PRM_STACK_RECORD            pSR
    );


//=========================================================================
//                  G L O B A L    D A T A
//=========================================================================

extern
RM_STATIC_OBJECT_INFO
ArpGlobals_AdapterStaticInfo;

extern const
NIC1394_ENCAPSULATION_HEADER
Arp1394_IpEncapHeader;


// Warning -- FAIL(NDIS_STATUS_PENDING) == TRUE
//
#define FAIL(_Status) ((_Status) != NDIS_STATUS_SUCCESS)
#define PEND(_Status) ((_Status) == NDIS_STATUS_PENDING)

#if RM_EXTRA_CHECKING
#define LOCKHDR(_pHdr, _psr) \
            RmWriteLockObject((_pHdr), dbg_func_locid, (_psr))
#else // !RM_EXTRA_CHECKING
#define LOCKHDR(_pHdr, _psr) \
            RmWriteLockObject((_pHdr), (_psr))
#endif // !RM_EXTRA_CHECKING

#define LOCKOBJ(_pObj, _psr) \
            LOCKHDR(&(_pObj)->Hdr, (_psr))

#define UNLOCKHDR(_pHdr, _psr) \
            RmUnlockObject((_pHdr), (_psr))
#define UNLOCKOBJ(_pObj, _psr) \
            UNLOCKHDR(&(_pObj)->Hdr, (_psr))


#define ARP_ALLOCSTRUCT(_p, _tag) \
                NdisAllocateMemoryWithTag(&(_p), sizeof(*(_p)), (_tag))

#define ARP_FREE(_p)            NdisFreeMemory((_p), 0, 0)

#define ARP_ZEROSTRUCT(_p) \
                NdisZeroMemory((_p), sizeof(*(_p)))

#define ARRAY_LENGTH(_array) (sizeof(_array)/sizeof((_array)[0]))

#if RM_EXTRA_CHECKING
#define DBG_ADDASSOC(_phdr, _e1, _e2, _assoc, _fmt, _psr)\
                                    RmDbgAddAssociation(    \
                                        dbg_func_locid,     \
                                        (_phdr),            \
                                        (UINT_PTR) (_e1),   \
                                        (UINT_PTR) (_e2),   \
                                        (_assoc),           \
                                        (_fmt),             \
                                        (_psr)              \
                                        )

#define DBG_DELASSOC(_phdr, _e1, _e2, _assoc, _psr)         \
                                    RmDbgDeleteAssociation( \
                                        dbg_func_locid,     \
                                        (_phdr),            \
                                        (UINT_PTR) (_e1),   \
                                        (UINT_PTR) (_e2),   \
                                        (_assoc),           \
                                        (_psr)              \
                                        )

// (debug only) Enumeration of types of associations.
//
enum
{
    ARPASSOC_IP_OPEN,           // IP has called ArpIpOpen
    ARPASSOC_LINK_IPADDR_OF_DEST,       
    ARPASSOC_LINK_DEST_OF_IPADDR,
    ARPASSOC_LOCALIP_UNLOAD_TASK,
    ARPASSOC_REMOTEIP_UNLOAD_TASK,
    ARPASSOC_REMOTEETH_UNLOAD_TASK,
    ARPASSOC_DEST_UNLOAD_TASK,
    ARPASSOC_CBUFPOOL_ALLOC,
    ARPASSOC_EXTLINK_DEST_TO_PKT,
    ARPASSOC_EXTLINK_RIP_TO_RCE,
    ARPASSOC_EXTLINK_TO_NDISVCHANDLE,
    ARPASSOC_REMOTEIP_SENDPKTS_TASK,
    ARPASSOC_IF_MAKECALL_TASK,
    ARPASSOC_IF_CLEANUPCALL_TASK,
    ARPASSOC_DEST_MAKECALL_TASK,
    ARPASSOC_DEST_CLEANUPCALL_TASK,
    ARPASSOC_DEST_CLEANUPCALLTASK_WAITING_ON_SENDS,
    ARPASSOC_PKTS_QUEUED_ON_REMOTEIP,
    ARPASSOC_PRIMARY_IF_TASK,
    ARPASSOC_ACTDEACT_IF_TASK,
    ARPASSOC_IF_OPENAF,
    ARPASSOC_PRIMARY_AD_TASK,
    ARPASSOC_ACTDEACT_AD_TASK,
    ARPASSOC_LINK_IF_OF_BCDEST,
    ARPASSOC_LINK_BCDEST_OF_IF,
    ARPASSOC_IF_PROTOPKTPOOL,
    ARPASSOC_IF_PROTOBUFPOOL,
    ARPASSOC_RESOLUTION_IF_TASK,
    ARPASSOC_LINK_IF_OF_MCDEST,
    ARPASSOC_LINK_MCDEST_OF_IF,
    ARPASSOC_LINK_IF_OF_ETHDEST,
    ARPASSOC_LINK_ETHDEST_OF_IF,
    ARPASSOC_IF_ETHPKTPOOL,
    ARPASSOC_IF_ETHBUFPOOL,
    ARPASSOC_ETH_SEND_PACKET,
    ARPASSOC_IF_MAINTENANCE_TASK,
    ARPASSOC_WORK_ITEM,
    ARPASSOC_ETHDHCP_UNLOAD_TASK,
    ARPASSOC_REMOTEIP_RESOLVE_TASK,
    ARPASSOC_TASK_TO_RESOLVE_REMOTEIP

};

#else // !RM_EXTRA_CHECKING
#define DBG_ADDASSOC(_phdr, _e1, _e2, _assoc, _fmt, _psr) (0)
#define DBG_DELASSOC(_phdr, _e1, _e2, _assoc, _psr) (0)
#endif  // !RM_EXTRA_CHECKING

#define ARPDBG_REF_EVERY_PACKET 1
#define ARPDBG_REF_EVERY_RCE    1


// USHORT
// SWAPBYTES_USHORT(USHORT  Val )
//
#define SWAPBYTES_USHORT(Val)   \
                ((((Val) & 0xff) << 8) | (((Val) & 0xff00) >> 8))


// ULONG
// SWAPBYTES_ULONG(ULONG    Val )
//
#define SWAPBYTES_ULONG(Val)    \
                ((((Val) & 0x000000ff) << 24)   |   \
                 (((Val) & 0x0000ff00) << 8)    |   \
                 (((Val) & 0x00ff0000) >> 8)    |   \
                 (((Val) & 0xff000000) >> 24) )


#define N2H_USHORT(Val) SWAPBYTES_USHORT(Val)
#define H2N_USHORT(Val) SWAPBYTES_USHORT(Val)
#define N2H_ULONG(Val)  SWAPBYTES_ULONG(Val)
#define H2N_ULONG(Val)  SWAPBYTES_ULONG(Val)

#define ARP_ATPASSIVE()  (KeGetCurrentIrql()==PASSIVE_LEVEL)

#define LOGSTATS_NoCopyRecvs(_pIF, _pNdisPacket) \
    NdisInterlockedIncrement(&((_pIF)->stats.recvpkts.NoCopyRecvs))
#define LOGSTATS_CopyRecvs(_pIF, _pNdisPacket) \
    NdisInterlockedIncrement(&((_pIF)->stats.recvpkts.CopyRecvs))
#define LOGSTATS_ResourceRecvs(_pIF, _pNdisPacket) \
    NdisInterlockedIncrement(&((_pIF)->stats.recvpkts.ResourceRecvs))
#define LOGSTATS_TotRecvs(_pIF, _pNdisPacket) \
    NdisInterlockedIncrement(&((_pIF)->stats.recvpkts.TotRecvs))
#define LOGSTATS_RecvFifoCounts(_pIF, _pNdisPacket) \
            arpLogRecvFifoCounts(_pIF, _pNdisPacket)
#define LOGSTATS_RecvChannelCounts(_pIF, _pNdisPacket) \
            arpLogRecvChannelCounts(_pIF, _pNdisPacket)
#define LOGSTATS_TotalSendFifoMakeCalls(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.calls.TotalSendFifoMakeCalls))
#define LOGSTATS_SuccessfulSendFifoMakeCalls(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.calls.SuccessfulSendFifoMakeCalls))
#define LOGSTATS_FailedSendFifoMakeCalls(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.calls.FailedSendFifoMakeCalls))
#define LOGSTATS_IncomingClosesOnSendFifos(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.calls.IncomingClosesOnSendFifos))
#define LOGSTATS_TotalChannelMakeCalls(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.calls.TotalChannelMakeCalls))
#define LOGSTATS_SuccessfulChannelMakeCalls(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.calls.SuccessfulChannelMakeCalls))
#define LOGSTATS_FailedChannelMakeCalls(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.calls.FailedChannelMakeCalls))
#define LOGSTATS_IncomingClosesOnChannels(_pIF) \
    NdisInterlockedIncrement(&((_pIF)->stats.calls.IncomingClosesOnChannels))

#define IF_FROM_LOCALIP(_pLIp) \
    (PARP1394_INTERFACE) RM_PARENT_OBJECT(_pLIp)

#define IF_FROM_REMOTEIP(_pRIp) \
    (PARP1394_INTERFACE) RM_PARENT_OBJECT(_pRIp)

#define IF_FROM_DEST(_pDest) \
    (PARP1394_INTERFACE) RM_PARENT_OBJECT(_pDest)

#if RM_EXTRA_CHECKING


#define OBJLOG0(_pObj, _szFmt)                          \
                        RmDbgLogToObject(               \
                                &(_pObj)->Hdr,          \
                                NULL, (_szFmt),         \
                                0, 0, 0, 0, NULL, NULL  \
                                )

#define OBJLOG1(_pObj, _szFmt, _P1)                     \
                        RmDbgLogToObject(               \
                                &(_pObj)->Hdr,          \
                                NULL, (_szFmt),         \
                                (UINT_PTR) (_P1),       \
                                0, 0, 0, NULL, NULL     \
                                )

#define OBJLOG2(_pObj, _szFmt, _P1, _P2)                \
                        RmDbgLogToObject(               \
                                &(_pObj)->Hdr,          \
                                NULL, (_szFmt),         \
                                (UINT_PTR) (_P1),       \
                                (UINT_PTR) (_P2),       \
                                0, 0, NULL, NULL        \
                                )
    
#else // !RM_EXTRA_CHECKING

#define OBJLOG0(_pObj, _szFmt)                  (0)
#define OBJLOG1(_pObj, _szFmt, _P1)             (0)
#define OBJLOG2(_pObj, _szFmt, _P1, _P2)        (0)

#endif // !RM_EXTRA_CHECKING


#if ARP_DO_TIMESTAMPS
    void
    arpTimeStamp(
        char *szFormatString,
        UINT Val
        );
    #define  TIMESTAMPX(_FormatString) \
        arpTimeStamp("TIMESTAMP %lu:%lu.%lu ARP1394 " _FormatString "\n", 0)
    #if ARP_DO_ALL_TIMESTAMPS
        #define  TIMESTAMP(_FormatString) \
            arpTimeStamp("TIMESTAMP %lu:%lu.%lu ARP1394 " _FormatString "\n", 0)
        #define  TIMESTAMP1(_FormatString, _Val) \
            arpTimeStamp("TIMESTAMP %lu:%lu.%lu ARP1394 " _FormatString "\n", (_Val))
    #else
        #define  TIMESTAMP(_FormatString)
        #define  TIMESTAMP1(_FormatString, _Val)
    #endif
#else // !ARP_DO_TIMESTAMPS
    #define  TIMESTAMP(_FormatString)
    #define  TIMESTAMPX(_FormatString)
    #define  TIMESTAMP1(_FormatString, _Val)
#endif // !ARP_DO_TIMESTAMPS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\nt.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    nt.c

Abstract:

    NT System entry points for ARP1394.

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     11-05-98    Created

Notes:

--*/
#include <precomp.h>


// File-specific debugging defaults.
//
#define TM_CURRENT   TM_NT

// Global variables for this module.
//
ARP1394_GLOBALS  ArpGlobals;

// List of fixed resources used by ArpGlobals
//
enum
{
    RTYPE_GLOBAL_BACKUP_TASKS,
    RTYPE_GLOBAL_DEVICE_OBJECT,
    RTYPE_GLOBAL_NDIS_BINDING,
    RTYPE_GLOBAL_ADAPTER_LIST,
    RTYPE_GLOBAL_IP_BINDING
    
}; // ARP_GLOBAL_RESOURCES;

//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT              pDriverObject,
    IN  PUNICODE_STRING             pRegistryPath
);

VOID
ArpUnload(
    IN  PDRIVER_OBJECT              pDriverObject
);

NTSTATUS
ArpDispatch(
    IN  PDEVICE_OBJECT              pDeviceObject,
    IN  PIRP                        pIrp
);

RM_STATUS
arpResHandleGlobalDeviceObject(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
);

RM_STATUS
arpResHandleGlobalNdisBinding(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
);

RM_STATUS
arpResHandleGlobalIpBinding(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
);

RM_STATUS
arpResHandleGlobalAdapterList(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
);

RM_STATUS
arpResHandleGlobalBackupTasks(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                psr
);

//
// Identifies information pertaining to the use of the above resources.
// Following table MUST be in strict increasing order of the RTYPE_GLOBAL
// enum.
//
RM_RESOURCE_TABLE_ENTRY 
ArpGlobals_ResourceTable[] =
{
    {RTYPE_GLOBAL_BACKUP_TASKS,    arpResHandleGlobalBackupTasks},
    {RTYPE_GLOBAL_DEVICE_OBJECT,    arpResHandleGlobalDeviceObject},
    {RTYPE_GLOBAL_NDIS_BINDING,     arpResHandleGlobalNdisBinding},
    {RTYPE_GLOBAL_ADAPTER_LIST,     arpResHandleGlobalAdapterList},
    {RTYPE_GLOBAL_IP_BINDING,       arpResHandleGlobalIpBinding}
    
};

// Static informatiou about ArpGlobals.
//
RM_STATIC_OBJECT_INFO
ArpGlobals_StaticInfo = 
{
    0, // TypeUID
    0, // TypeFlags
    "ArpGlobals",   // TypeName
    0, // Timeout

    NULL, // pfnCreate
    NULL, // pfnDelete
    NULL, // pfnVerifyLock

    sizeof(ArpGlobals_ResourceTable)/sizeof(ArpGlobals_ResourceTable[1]),
    ArpGlobals_ResourceTable
};

BOOLEAN
arpAdapterCompareKey(
    PVOID           pKey,
    PRM_HASH_LINK   pItem
    )
/*++

Routine Description:

    Hash comparison function for ARP1394_ADAPTER.

Arguments:

    pKey        - Points to an NDIS_STRING containing  an adapter name.
    pItem       - Points to ARP1394_ADAPTER.Hdr.HashLink.

Return Value:

    TRUE IFF the key (adapter name) exactly matches the key of the specified 
    adapter object.

--*/
{
    ARP1394_ADAPTER *pA = CONTAINING_RECORD(pItem, ARP1394_ADAPTER, Hdr.HashLink);
    PNDIS_STRING pName = (PNDIS_STRING) pKey;

    //
    // TODO: maybe case-insensitive compare?
    //

    if (   (pA->bind.DeviceName.Length == pName->Length)
        && NdisEqualMemory(pA->bind.DeviceName.Buffer, pName->Buffer, pName->Length))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    
}


ULONG
arpAdapterHash(
    PVOID           pKey
    )
/*++

Routine Description:

    Hash function responsible for returning a hash of pKey, which
    we expect to be a pointer to an NDIS_STRING.

Return Value:

    ULONG-sized hash of the string.

--*/
{
    PNDIS_STRING pName = (PNDIS_STRING) pKey;
    WCHAR *pwch = pName->Buffer;
    WCHAR *pwchEnd = pName->Buffer + pName->Length/sizeof(*pwch);
    ULONG Hash  = 0;

    for (;pwch < pwchEnd; pwch++)
    {
        Hash ^= (Hash<<1) ^ *pwch;
    }

    return Hash;
}


// arpAdapter_HashInfo contains information required maintain a hashtable
// of ARP1394_ADAPTER objects.
//
RM_HASH_INFO
arpAdapter_HashInfo = 
{
    NULL, // pfnTableAllocator

    NULL, // pfnTableDeallocator

    arpAdapterCompareKey,   // fnCompare

    // Function to generate a ULONG-sized hash.
    //
    arpAdapterHash      // pfnHash

};


// ArpGlobals_AdapterStaticInfo contains static information about
// objects of type ARP1394_ADAPTER.
//
RM_STATIC_OBJECT_INFO
ArpGlobals_AdapterStaticInfo =
{
    0, // TypeUID
    0, // TypeFlags
    "Adapter",  // TypeName
    0, // Timeout

    arpAdapterCreate,   // pfnCreate
    arpAdapterDelete,       // pfnDelete
    NULL, // pfnVerifyLock

    0,    // Size of resource table
    NULL, // ResourceTable

    &arpAdapter_HashInfo
};


NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT              pDriverObject,
    IN  PUNICODE_STRING             pRegistryPath
)
/*++

Routine Description:

    This is the "init" routine, called by the system when the ARP
    module is loaded. We initialize all our global objects, fill in our
    Dispatch and Unload routine addresses in the driver object, and create
    a device object for receiving I/O requests on (IOCTLs).

Arguments:

    pDriverObject   - Pointer to the driver object created by the system.
    pRegistryPath   - Pointer to our global registry path. This is ignored.

Return Value:

    NT Status code: STATUS_SUCCESS if successful, error code otherwise.

--*/
{
    NTSTATUS    Status;
    BOOLEAN     AllocatedGlobals = FALSE;
    ENTER("DriverEntry", 0xbfcb7eb1)
    RM_DECLARE_STACK_RECORD(sr)

    TIMESTAMPX("==>DriverEntry");

    do
    {
        // Must be done before any RM apis are used.
        //
        RmInitializeRm();

        RmInitializeLock(
                    &ArpGlobals.Lock,
                    LOCKLEVEL_GLOBAL
                    );

        RmInitializeHeader(
                NULL,                   // pParentObject,
                &ArpGlobals.Hdr,
                ARP1394_GLOBALS_SIG,
                &ArpGlobals.Lock,
                &ArpGlobals_StaticInfo,
                NULL,                   // szDescription
                &sr
                );


        AllocatedGlobals = TRUE;

        //
        //  Initialize the Driver Object.
        //
        {
            INT i;

            pDriverObject->DriverUnload = ArpUnload;
            pDriverObject->FastIoDispatch = NULL;
            for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
            {
                pDriverObject->MajorFunction[i] = ArpDispatch;
            }
    
            pDriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = ArpWmiDispatch;
        
            ArpGlobals.driver.pDriverObject = pDriverObject;
        }

    #if 0 //  MILLEN
        TR_WARN((
            "&g_SkipAll =0x%p; &g_ulTracelevel=0x%p; &g_DiscardNonUnicastPackets=0x%p\n",
             &g_SkipAll,
             &g_ulTraceLevel,
             &g_DiscardNonUnicastPackets));
      #if DBG
        DbgBreakPoint();
      #endif // DBG
    #endif // 0

        Status = RmLoadGenericResource(
                    &ArpGlobals.Hdr,
                    RTYPE_GLOBAL_BACKUP_TASKS,
                    &sr
                    );

        if (FAIL(Status)) break;

        //
        // Create a device object for the driver.
        //
        Status = RmLoadGenericResource(
                    &ArpGlobals.Hdr,
                    RTYPE_GLOBAL_DEVICE_OBJECT,
                    &sr
                    );

        if (FAIL(Status)) break;

        //
        // Register ourselves with NDIS.
        //
        Status = RmLoadGenericResource(
                    &ArpGlobals.Hdr,
                    RTYPE_GLOBAL_NDIS_BINDING,
                    &sr
                    );

        if (FAIL(Status)) break;
    
        //
        // Create the Adapter List
        //
        Status = RmLoadGenericResource(
                    &ArpGlobals.Hdr,
                    RTYPE_GLOBAL_ADAPTER_LIST,
                    &sr);

        if (FAIL(Status)) break;

        
        //
        // Register ourselves with IP.
        //
        Status = RmLoadGenericResource(
                    &ArpGlobals.Hdr,
                    RTYPE_GLOBAL_IP_BINDING,
                    &sr
                    );



    } while (FALSE);

    
    if (FAIL(Status))
    {
        if (AllocatedGlobals)
        {
            RmUnloadAllGenericResources(
                    &ArpGlobals.Hdr,
                    &sr
                    );
            RmDeallocateObject(
                    &ArpGlobals.Hdr,
                    &sr
                    );
        }

        // Must be done after any RM apis are used and async activity complete.
        //
        RmDeinitializeRm();
    }

    RM_ASSERT_CLEAR(&sr)
    EXIT()

    TIMESTAMP("<==DriverEntry");

    return Status;
}


VOID
ArpUnload(
    IN  PDRIVER_OBJECT              pDriverObject
)
/*++

Routine Description:

    This routine is called by the system prior to unloading us.
    Currently, we just undo everything we did in DriverEntry,
    that is, de-register ourselves as an NDIS protocol, and delete
    the device object we had created.

Arguments:

    pDriverObject   - Pointer to the driver object created by the system.

Return Value:

    None

--*/
{
    ENTER("Unload", 0xc8482549)
    RM_DECLARE_STACK_RECORD(sr)

    TIMESTAMP("==>Unload");
    RmUnloadAllGenericResources(&ArpGlobals.Hdr, &sr);

    RmDeallocateObject(&ArpGlobals.Hdr, &sr);

    // Must be done after any RM apis are used and async activity complete.
    //
    RmDeinitializeRm();

    // TODO? Block(250);

    RM_ASSERT_CLEAR(&sr)

    EXIT()
    TIMESTAMP("<==Unload");
    return;
}


NTSTATUS
ArpDispatch(
    IN  PDEVICE_OBJECT              pDeviceObject,
    IN  PIRP                        pIrp
)
/*++

Routine Description:

    This routine is called by the system when there is an IRP
    to be processed.

Arguments:

    pDeviceObject       - Pointer to device object we created for ourselves.
    pIrp                - Pointer to IRP to be processed.

Return Value:

    NT Status code.

--*/
{
    NTSTATUS                NtStatus;               // Return value
    PIO_STACK_LOCATION      pIrpStack;
    PVOID                   pIoBuffer;          // Values in/out
    ULONG                   InputBufferLength;  // Length of input parameters
    ULONG                   OutputBufferLength; // Space for output values

    ENTER("Dispatch", 0x1dcf2679)

    //
    //  Initialize
    //
    NtStatus = STATUS_SUCCESS;

    pIrp->IoStatus.Status = STATUS_SUCCESS;
    pIrp->IoStatus.Information = 0;

    //
    //  Get all information in the IRP
    //
    pIoBuffer = pIrp->AssociatedIrp.SystemBuffer;
    pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    InputBufferLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    
    switch (pIrpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:
            TR_INFO(("IRP_MJ_CREATE\n"));
            break;

        case IRP_MJ_CLOSE:
            TR_INFO(("IRP_MJ_CLOSE\n"));
            break;

        case IRP_MJ_CLEANUP:
            TR_INFO(("IRP_MJ_CLEANUP\n"));
            break;

        case IRP_MJ_DEVICE_CONTROL:
            TR_INFO(("IRP_MJ_DEVICE_CONTROL\n"));

            //
            // Handle the Ioctl. 
            // This will fill in the Information field in the Irp
            //
            NtStatus =  ArpHandleIoctlRequest(pIrp, pIrpStack);
            break;

        default:
            TR_WARN(("IRP: Unknown major function 0x%p\n",
                        pIrpStack->MajorFunction));
            break;
    }

    if (NtStatus != STATUS_PENDING)
    {
        pIrp->IoStatus.Status = NtStatus;
        IoMarkIrpPending(pIrp);
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    }

    EXIT()

    return STATUS_PENDING;

}

RM_STATUS
arpResHandleGlobalDeviceObject(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                pSR
)
/*++

Routine Description:

    Responsible for loading and unloading of the RTYPE_GLOBAL_DEVICE_OBJECT resource.

Arguments:

    pObj            - Actually a pointer to an object of type ARP1394_GLOBALS.
    Op              - Operation (load/unload)
    pvUserParams    - (unused)

Return Value:

    NDIS_STATUS_SUCCESS on success
    NDIS failure code   otherwise.

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    ARP1394_GLOBALS     *pGlobals   = CONTAINING_RECORD(pObj, ARP1394_GLOBALS, Hdr);
    BOOLEAN             fCreatedSymbolicLink = FALSE;
    PDRIVER_OBJECT      pDriverObject = (PDRIVER_OBJECT) pGlobals->driver.pDriverObject;
    UNICODE_STRING  SymbolicName;

    ENTER("GlobalDeviceObject", 0x335f5f57)

    RtlInitUnicodeString(&SymbolicName, ARP1394_SYMBOLIC_NAME);

    if (Op == RM_RESOURCE_OP_LOAD)
    {
        TR_WARN(("LOADING"));

        do
        {
            PDEVICE_OBJECT      pDeviceObject;
            UNICODE_STRING          DeviceName;

            RtlInitUnicodeString(&DeviceName, ARP1394_DEVICE_NAME);
            pGlobals->driver.pDeviceObject = NULL;

            //
            //  Create a device object for the ARP1394 module.
            //
            Status = IoCreateDevice(
                        pDriverObject,
                        0,
                        &DeviceName,
                        FILE_DEVICE_NETWORK,
                        FILE_DEVICE_SECURE_OPEN,
                        FALSE,
                        &pDeviceObject
                        );
            
            if (FAIL(Status)) break;
        
            //
            //  Retain the device object pointer -- we'll need this
            //  if/when we are asked to unload ourselves.
            //
            pGlobals->driver.pDeviceObject = pDeviceObject;

            //
            // Set up a symbolic name for interaction with the user-mode
            // admin application.
            //
            {
        
                Status = IoCreateSymbolicLink(&SymbolicName, &DeviceName);
                if (FAIL(Status)) break;

                fCreatedSymbolicLink = TRUE;
            }

            //
            //  Initialize the Device Object.
            //
            pDeviceObject->Flags |= DO_BUFFERED_IO;

        } while (FALSE);
    }
    else if (Op == RM_RESOURCE_OP_UNLOAD)
    {
        TR_WARN(("UNLOADING"));
        //
        // Were unloading this "resource" -- we expect
        // that pGlobals->driver.pDeviceObject contains a valid
        // device object and that we have created a symbolic
        // link which we need to tear down.
        //
        ASSERTEX(pGlobals->driver.pDeviceObject != NULL, pGlobals);
        fCreatedSymbolicLink = TRUE;

        // Always return success on unload.
        //
        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        // Unexpected op code.
        //
        ASSERTEX(FALSE, pObj);
    }

    //
    // Release all resources either on unload or on failed load.
    //
    if (Op == RM_RESOURCE_OP_UNLOAD || FAIL(Status))
    {
        // If we've created a symbolic link, delete it.
        if (fCreatedSymbolicLink)
        {
            IoDeleteSymbolicLink(&SymbolicName);
        }

        // If we've created a device object, free it.
        if (pGlobals->driver.pDeviceObject)
        {
            IoDeleteDevice(pGlobals->driver.pDeviceObject);
            pGlobals->driver.pDeviceObject = NULL;
        }
    }

    EXIT()

    return Status;
}


RM_STATUS
arpResHandleGlobalNdisBinding(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                pSR
)
/*++

Routine Description:

    Responsible for loading and unloading of the  RTYPE_GLOBAL_NDIS_BINDING resource.

Arguments:

    pObj            - Actually a pointer to an object of type ARP1394_GLOBALS.
    Op              - Operation (load/unload)
    pvUserParams    - (unused)

Return Value:

    NDIS_STATUS_SUCCESS on success
    NDIS failure code   otherwise.

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    ARP1394_GLOBALS                 *pGlobals   = CONTAINING_RECORD(
                                                        pObj,
                                                        ARP1394_GLOBALS,
                                                        Hdr);
    PNDIS_PROTOCOL_CHARACTERISTICS  pNdisPC     = &(pGlobals->ndis.PC);
    PNDIS_CLIENT_CHARACTERISTICS    pNdisCC     = &(pGlobals->ndis.CC);
    ENTER("GlobalNdisBinding", 0x62b1181e)

    if (Op == RM_RESOURCE_OP_LOAD)
    {
        TR_WARN(("LOADING"));
        //
        //  Fill in our Protocol and Client characteristics structures.
        //

        NdisZeroMemory(pNdisPC, sizeof(*pNdisPC));
        pNdisPC->MajorNdisVersion               = ARP1394_NDIS_MAJOR_VERSION;
        pNdisPC->MinorNdisVersion               = ARP1394_NDIS_MINOR_VERSION;
        pNdisPC->OpenAdapterCompleteHandler     = ArpNdOpenAdapterComplete;
        pNdisPC->CloseAdapterCompleteHandler    = ArpNdCloseAdapterComplete;
        pNdisPC->ResetCompleteHandler           = ArpNdResetComplete;
        pNdisPC->RequestCompleteHandler         = ArpNdRequestComplete;
        pNdisPC->StatusHandler                  = ArpNdStatus;
        pNdisPC->StatusCompleteHandler          = ArpNdStatusComplete;

        pNdisPC->SendCompleteHandler            = ArpNdSendComplete;

        NdisInitUnicodeString(
            &pNdisPC->Name,
            ARP1394_LL_NAME
        );


        //
        // Following protocol context handlers are unused and set to NULL.
        //
        //  pNdisPC->TransferDataCompleteHandler
        //  pNdisPC->ReceiveHandler
        //  pNdisPC->ReceiveCompleteHandler
        //  pNdisPC->ReceivePacketHandler
        //
        pNdisPC->ReceiveCompleteHandler         = ArpNdReceiveComplete;
        pNdisPC->BindAdapterHandler             = ArpNdBindAdapter;

        pNdisPC->UnbindAdapterHandler           = ArpNdUnbindAdapter;
        pNdisPC->UnloadHandler                  = (UNLOAD_PROTOCOL_HANDLER)
                                                    ArpNdUnloadProtocol;
        pNdisPC->PnPEventHandler                = ArpNdPnPEvent;

        pNdisPC->CoSendCompleteHandler          = ArpCoSendComplete;
        pNdisPC->CoStatusHandler                = ArpCoStatus;
        pNdisPC->CoReceivePacketHandler         = ArpCoReceivePacket;
        pNdisPC->CoAfRegisterNotifyHandler      = ArpCoAfRegisterNotify;
    
        NdisZeroMemory(pNdisCC, sizeof(*pNdisCC));
        pNdisCC->MajorVersion                   = ARP1394_NDIS_MAJOR_VERSION;
        pNdisCC->MinorVersion                   = ARP1394_NDIS_MINOR_VERSION;
        pNdisCC->ClCreateVcHandler              = ArpCoCreateVc;
        pNdisCC->ClDeleteVcHandler              = ArpCoDeleteVc;
        pNdisCC->ClRequestHandler               = ArpCoRequest;
        pNdisCC->ClRequestCompleteHandler       = ArpCoRequestComplete;
        pNdisCC->ClOpenAfCompleteHandler        = ArpCoOpenAfComplete;
        pNdisCC->ClCloseAfCompleteHandler       = ArpCoCloseAfComplete;
        pNdisCC->ClMakeCallCompleteHandler      = ArpCoMakeCallComplete;
        pNdisCC->ClModifyCallQoSCompleteHandler = ArpCoModifyQosComplete;
        pNdisCC->ClIncomingCloseCallHandler     = ArpCoIncomingClose;
        pNdisCC->ClCallConnectedHandler         = ArpCoCallConnected;
        pNdisCC->ClCloseCallCompleteHandler     = ArpCoCloseCallComplete;

        //
        // Following client context handlers are unused and set to NULL.
        //
        //  pNdisCC->ClRegisterSapCompleteHandler
        //  pNdisCC->ClDeregisterSapCompleteHandler
        //  pNdisCC->ClAddPartyCompleteHandler
        //  pNdisCC->ClDropPartyCompleteHandler
        //  pNdisCC->ClIncomingCallHandler
        //  pNdisCC->ClIncomingCallQoSChangeHandler
        //  pNdisCC->ClIncomingDropPartyHandler
        //
        
        //
        //  Register ourselves as a protocol with NDIS.
        //
        NdisRegisterProtocol(
                    &Status,
                    &(pGlobals->ndis.ProtocolHandle),
                    pNdisPC,
                    sizeof(*pNdisPC)
                    );

        if (FAIL(Status))
        {
            NdisZeroMemory(&(pGlobals->ndis), sizeof(pGlobals->ndis));
        }
    }
    else if (Op == RM_RESOURCE_OP_UNLOAD)
    {
        //
        // Were unloading this "resource", i.e., cleaning up and
        // unregistering with NDIS.
        //
        TR_WARN(("UNLOADING"));

        ASSERTEX(pGlobals->ndis.ProtocolHandle != NULL, pGlobals);

        // Unregister ourselves from ndis
        //
        NdisDeregisterProtocol(
                        &Status,
                        pGlobals->ndis.ProtocolHandle
                        );

        NdisZeroMemory(&(pGlobals->ndis), sizeof(pGlobals->ndis));

    }
    else
    {
        // Unexpected op code.
        //
        ASSERT(FALSE);
    }
    

    EXIT()
    return Status;
}


RM_STATUS
arpResHandleGlobalIpBinding(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                pSR
)
/*++

Routine Description:

    Responsible for loading and unloading of the  RTYPE_GLOBAL_IP_BINDING resource.

Arguments:

    pObj            - Actually a pointer to an object of type ARP1394_GLOBALS.
    Op              - Operation (load/unload)
    pvUserParams    - (unused)

Return Value:

    NDIS_STATUS_SUCCESS on success
    NDIS failure code   otherwise.

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;
    ARP1394_GLOBALS                 *pGlobals   = CONTAINING_RECORD(
                                                        pObj,
                                                        ARP1394_GLOBALS,
                                                        Hdr);
    ENTER("GlobalIpBinding", 0xf9d36d49)

    if (Op == RM_RESOURCE_OP_LOAD)
    {
        //
        //  Register ourselves as an ARP Module with IP.
        //
        NDIS_STRING     ArpName;
        IP_CHANGE_INDEX        IpChangeIndex;
        IP_RESERVE_INDEX       IpReserveIndex;
        IP_DERESERVE_INDEX     IpDereserveIndex;
        TR_WARN(("LOADING"));

        NdisInitUnicodeString(&ArpName, ARP1394_UL_NAME);

        Status = IPRegisterARP(
                    &ArpName,
                    IP_ARP_BIND_VERSION,
                    ArpNdBindAdapter,
                    &(pGlobals->ip.pAddInterfaceRtn),
                    &(pGlobals->ip.pDelInterfaceRtn),
                    &(pGlobals->ip.pBindCompleteRtn),
                    &(pGlobals->ip.pAddLinkRtn),
                    &(pGlobals->ip.pDeleteLinkRtn),
                    //
                    // Following 3 are placeholders -- we don't use this information.
                    // See 10/14/1998 entry in ipatmc\notes.txt
                    //
                    &IpChangeIndex,
                    &IpReserveIndex,
                    &IpDereserveIndex,
                    &(pGlobals->ip.ARPRegisterHandle)
                    );

        if (FAIL(Status))
        {
            TR_WARN(("IPRegisterARP FAILS. Status = 0x%p", Status));
            NdisZeroMemory(&(pGlobals->ip), sizeof(pGlobals->ip));
        }
        else
        {
            TR_WARN(("IPRegisterARP Succeeds"));
        }
    }
    else if (Op == RM_RESOURCE_OP_UNLOAD)
    {
        //
        // Were unloading this "resource", i.e., unregistering with IP.
        //
        TR_WARN(("UNLOADING"));
        ASSERTEX(pGlobals->ip.ARPRegisterHandle != NULL, pGlobals);

        //
        // Unload all adapters (and disallow new adapter from being added)
        // *before calling IPDerigesterARP.
        //
        RmUnloadAllObjectsInGroup(
                    &pGlobals->adapters.Group,
                    arpAllocateTask,
                    arpTaskShutdownAdapter,
                    NULL,   // userParam
                    NULL, // pTask
                    0,    // uTaskPendCode
                    pSR
                    );

        Status = IPDeregisterARP(pGlobals->ip.ARPRegisterHandle);
        ASSERTEX(!FAIL(Status), pGlobals);
        NdisZeroMemory(&(pGlobals->ip), sizeof(pGlobals->ip));
    }
    else
    {
        // Unexpected op code.
        //
        ASSERT(FALSE);
    }

    EXIT()
    return Status;
}


RM_STATUS
arpResHandleGlobalAdapterList(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                pSR
)
/*++

Routine Description:

    Responsible for loading and unloading of the RTYPE_GLOBAL_ADAPTER_LIST resource.

Arguments:

    pObj            - Actually a pointer to an object of type ARP1394_GLOBALS.
    Op              - Operation (load/unload)
    pvUserParams    - (unused)

Return Value:

    NDIS_STATUS_SUCCESS on success
    NDIS failure code   otherwise.

--*/
{
    ARP1394_GLOBALS                 *pGlobals   = CONTAINING_RECORD(
                                                        pObj,
                                                        ARP1394_GLOBALS,
                                                        Hdr);
    ENTER("GlobalAdapterList", 0xb407e79e)

    if (Op == RM_RESOURCE_OP_LOAD)
    {
        //
        //  Allocate adapter list.
        //
        TR_WARN(("LOADING"));

        RmInitializeGroup(
                        pObj,                                   // pParentObject
                        &ArpGlobals_AdapterStaticInfo,          // pStaticInfo
                        &(pGlobals->adapters.Group),            // pGroup
                        "Adapter group",                        // szDescription
                        pSR                                     // pStackRecord
                        );
    }
    else if (Op == RM_RESOURCE_OP_UNLOAD)
    {
        //
        // We're unloading this "resource", i.e., unloading and deallocating the 
        // global adapter list. We first unload and free all the adapters
        // in the list, and then free the list itself.
        //
        TR_WARN(("UNLOADING"));
        
        //
        // We expect there to be no adapter objects at this point.
        //
        ASSERT(pGlobals->adapters.Group.HashTable.NumItems == 0);

        RmDeinitializeGroup(&pGlobals->adapters.Group, pSR);
        NdisZeroMemory(&(pGlobals->adapters), sizeof(pGlobals->adapters));
    }
    else
    {
        // Unexpected op code.
        //
        ASSERT(FALSE);
    }

    EXIT()

    return NDIS_STATUS_SUCCESS;
}



RM_STATUS
arpResHandleGlobalBackupTasks(
    PRM_OBJECT_HEADER               pObj,
    RM_RESOURCE_OPERATION           Op,
    PVOID                           pvUserParams,
    PRM_STACK_RECORD                pSR
)
/*++

Routine Description:

    Allocates 4 Tasks for each adapter to be used as a backup in case of a low mem
    condition.

Arguments:

    pObj            - Actually a pointer to an object of type ARP1394_GLOBALS.
    Op              - Operation (load/unload)
    pvUserParams    - (unused)

Return Value:

    NDIS_STATUS_SUCCESS on success
    NDIS failure code   otherwise.

--*/
{
    ARP1394_GLOBALS                 *pGlobals   = CONTAINING_RECORD(
                                                        pObj,
                                                        ARP1394_GLOBALS,
                                                        Hdr);
    ENTER("GlobalBackupTasks", 0xb64e5007)

    if (Op == RM_RESOURCE_OP_LOAD)
    {
        //
        //  Allocate adapter list.
        //
        TR_WARN(("LOADING"));

        arpAllocateBackupTasks(pGlobals); 
    }
    else if (Op == RM_RESOURCE_OP_UNLOAD)
    {
        //
        // We're unloading this "resource", i.e., unloading and deallocating the 
        // global adapter list. We first unload and free all the adapters
        // in the list, and then free the list itself.
        //
        TR_WARN(("UNLOADING"));
        
        //
        // We expect there to be no adapter objects at this point.
        //
        arpFreeBackupTasks(pGlobals); 
    
    }
    else
    {
        // Unexpected op code.
        //
        ASSERT(FALSE);
    }

    EXIT()

    return NDIS_STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\1394\arp\sys\nd.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    nd.c

Abstract:

    ARP1394 ndis handlers (excluding connection-oriented handlers).

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    josephj     12-01-98    Created, adapting code from atmarpc.sys

Notes:

--*/
#include <precomp.h>


//
// File-specific debugging defaults.
//
#define TM_CURRENT   TM_ND



//=========================================================================
//                  L O C A L   P R O T O T Y P E S
//=========================================================================

// ARP1394_BIND_PARAMS is used when creating an adapter object.
//
typedef struct
{
    PNDIS_STRING pDeviceName;
    PNDIS_STRING pArpConfigName;
    PVOID       IpConfigHandle;
    NDIS_HANDLE BindContext;

} ARP1394_BIND_PARAMS;


NDIS_STATUS
arpPnPReconfigHandler(
    IN ARP1394_ADAPTER  *   pAdapter,
    IN PNET_PNP_EVENT               pNetPnPEvent
    );

ENetAddr 
arpGetSecondaryMacAddress (
    IN ENetAddr  EthernetMacAddress
    );

NDIS_STATUS
arpGetEuidTopologyWorkItem(
    struct _ARP1394_WORK_ITEM* pWorkItem, 
    PRM_OBJECT_HEADER pObj ,
    PRM_STACK_RECORD pSR
    );


VOID
arpAddBackupTasks (
    IN ARP1394_GLOBALS* pGlobals,
    UINT Num
    );

VOID
arpRemoveBackupTasks (
    IN ARP1394_GLOBALS* pGlobals,
    UINT Num
     );

NDIS_STATUS
arpNdSetPower (
    ARP1394_ADAPTER *pAdapter,
    PNET_DEVICE_POWER_STATE   pPowerState,
    PRM_STACK_RECORD pSR
    );

NDIS_STATUS
arpResume (
    IN ARP1394_ADAPTER* pAdapter,
    IN ARP_RESUME_CAUSE Cause,
    IN PRM_STACK_RECORD pSR
);

const ENetAddr DummyENet = {0xba,0xdb,0xad,0xba,0xdb,0xad};
//=========================================================================
//      N D I S   H A N D L E R S
//=========================================================================

INT
ArpNdBindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN  NDIS_HANDLE                 BindContext,
    IN  PNDIS_STRING                pDeviceName,
    IN  PVOID                       SystemSpecific1,
    IN  PVOID                       SystemSpecific2
)
/*++

Routine Description:

    This is called by TCPIP when it has an adapter for which there is a
    binding to the ARP client.

    We first allocate an Adapter structure. Then we open our configuration
    section for this adapter and save the handle in the Adapter structure.
    Finally, we open the adapter.

    We don't do anything more for this adapter until NDIS notifies us of
    the presence of a Call manager (via our AfRegisterNotify handler).

Arguments:

    pStatus             - Place to return status of this call
    BindContext         - NDIS-supplied Bind context. IF this is NULL,
                            we are calling ourselves to open an adapter in
                            Ethernet emulation (bridge) mode.
    pDeviceName         - The name of the adapter we are requested to bind to
    SystemSpecific1     - Opaque to us; to be used to access configuration info
    SystemSpecific2     - Opaque to us; not used.

Return Value:

    Always TRUE. We set *pStatus to an error code if something goes wrong before we
    call NdisOpenAdapter, otherwise NDIS_STATUS_PENDING.

--*/
{
    NDIS_STATUS         Status;
    ARP1394_ADAPTER *   pAdapter;
#if DBG
    KIRQL EntryIrql =  KeGetCurrentIrql();
#endif // DBG

    ENTER("BindAdapter", 0x5460887b)
    RM_DECLARE_STACK_RECORD(sr)
    TIMESTAMP("==>BindAdapter");

    do 
    {
        PRM_TASK            pTask;
        ARP1394_BIND_PARAMS BindParams;

        // Setup initialization parameters
        //
        BindParams.pDeviceName          = pDeviceName;
        BindParams.pArpConfigName       = (PNDIS_STRING) SystemSpecific1;
        BindParams.IpConfigHandle       = SystemSpecific2;
        BindParams.BindContext          = BindContext;


        // Allocate and initialize adapter object.
        // This also sets up ref counts for all linkages, plus one
        // tempref for us, which we must deref when done.
        //
        Status =  RM_CREATE_AND_LOCK_OBJECT_IN_GROUP(
                            &ArpGlobals.adapters.Group,
                            pDeviceName,                // Key
                            &BindParams,                // Init params
                            &((PRM_OBJECT_HEADER)pAdapter),
                            NULL,   // pfCreated
                            &sr
                            );
        if (FAIL(Status))
        {
            TR_WARN(("FATAL: Couldn't create adapter object\n"));
            pAdapter = NULL;
            break;
        }

        // Allocate task to  complete the initialization.
        // The task is tmp ref'd for us, and we must deref it when we're done here.
        // We implicitly do this by calling RmStartTask below.
        //
        Status = arpAllocateTask(
                    &pAdapter->Hdr,             // pParentObject,
                    arpTaskInitializeAdapter,   // pfnHandler,
                    0,                          // Timeout,
                    "Task: Initialize Adapter", // szDescription
                    &pTask,
                    &sr
                    );

        if (FAIL(Status))
        {
            pTask = NULL;
            break;
        }

        UNLOCKOBJ(pAdapter, &sr);

        // Start the task to complete this initialization.
        // NO locks must be held at this time.
        // RmStartTask expect's a tempref on the task, which it deref's when done.
        // RmStartTask will free the task automatically, whether it completes
        // synchronously or asynchronously.
        //
        Status = RmStartTask(pTask, 0, &sr);

        LOCKOBJ(pAdapter, &sr);

    } while(FALSE);

    if (pAdapter)
    {
        UNLOCKOBJ(pAdapter, &sr);

        if (!PEND(Status) && FAIL(Status))
        {
            // At this point the adapter should be a "zombie object."
            //
            ASSERTEX(RM_IS_ZOMBIE(pAdapter), pAdapter);
        }

        RmTmpDereferenceObject(&pAdapter->Hdr, &sr);
    }

    *pStatus = Status;

#if DBG
    {
        KIRQL ExitIrql =  KeGetCurrentIrql();
        TR_INFO(("Exiting. EntryIrql=%lu, ExitIrql = %lu\n", EntryIrql, ExitIrql));
    }
#endif //DBG

    RM_ASSERT_CLEAR(&sr);
    EXIT()
    TIMESTAMP("<==BindAdapter");
    return 0;
}


VOID
ArpNdUnbindAdapter(
    OUT PNDIS_STATUS                pStatus,
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_HANDLE                 UnbindContext
)
/*++

Routine Description:

    This routine is called by NDIS when it wants us to unbind
    from an adapter. Or, this may be called from within our Unload
    handler. We undo the sequence of operations we performed
    in our BindAdapter handler.

Arguments:

    pStatus                 - Place to return status of this operation
    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to an ATMARP Adapter structure.
    UnbindContext           - This is NULL if this routine is called from
                              within our Unload handler. Otherwise (i.e.
                              NDIS called us), we retain this for later use
                              when calling NdisCompleteUnbindAdapter.

Return Value:

    None. We set *pStatus to NDIS_STATUS_PENDING always.

--*/
{
    ENTER("UnbindAdapter", 0x6bff4ab5)
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) ProtocolBindingContext;
    RM_DECLARE_STACK_RECORD(sr)

    TIMESTAMP("==>UnbindAdapter");
    
    // Get adapter lock and tmpref it.
    LOCKOBJ(pAdapter, &sr);
    RmTmpReferenceObject(&pAdapter->Hdr, &sr);

    do
    {
        NDIS_STATUS Status;
        PRM_TASK    pTask;

        if (CHECK_POWER_STATE(pAdapter,ARPAD_POWER_LOW_POWER)== TRUE)
        {
            //
            // Set the flag in case we are in the scenario wherein our Open Af has
            // not completed but we need to unbind. This can happen when the machine
            // is resuming from a low power state
            //
            pAdapter->PoMgmt.bReceivedUnbind = TRUE;;
        }


        // Allocate task to  complete the unbind.
        //
        Status = arpAllocateTask(
                    &pAdapter->Hdr,             // pParentObject,
                    arpTaskShutdownAdapter,     // pfnHandler,
                    0,                          // Timeout,
                    "Task: Shutdown Adapter",   // szDescription
                    &pTask,
                    &sr
                    );
    
        if (FAIL(Status))
        {
            // Ugly situation. We'll just leave things as they are...
            //
            pTask = NULL;
            TR_WARN(("FATAL: couldn't allocate unbind task!\n"));
            break;
        }

        
        // Start the task to complete the unbind.
        // No locks must be held. RmStartTask uses up the tmpref on the task
        // which was added by arpAllocateTask.
        //
        
        UNLOCKOBJ(pAdapter, &sr);
        Status = RmStartTask(pTask, (UINT_PTR) UnbindContext, &sr);
        LOCKOBJ(pAdapter, &sr);
    
    } while(FALSE);

    UNLOCKOBJ(pAdapter, &sr);
    RmTmpDereferenceObject(&pAdapter->Hdr, &sr);
    *pStatus = NDIS_STATUS_PENDING;

    RM_ASSERT_CLEAR(&sr);
    TIMESTAMP("<==UnbindAdapter");
    EXIT()
}


VOID
ArpNdOpenAdapterComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status,
    IN  NDIS_STATUS                 OpenErrorStatus
)
/*++

Routine Description:

    This is called by NDIS when a previous call to NdisOpenAdapter
    that had pended has completed. We now complete the BindAdapter
    that lead to this.

Arguments:

    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to an ARP1394_ADAPTER structure.
    Status                  - Status of OpenAdapter
    OpenErrorStatus         - Error code in case of failure.

--*/
{
    ENTER("OpenAdapterComplete", 0x06d9342c)
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) ProtocolBindingContext;
    RM_DECLARE_STACK_RECORD(sr)

    TIMESTAMP("==>OpenAdapterComplete");
    // We expect a nonzero task here (the bind task), which we unpend.
    // No need to grab locks or anything at this stage.
    //
    {
        TR_INFO((
            "BindCtxt=0x%p, status=0x%p, OpenErrStatus=0x%p",
            ProtocolBindingContext,
            Status,
            OpenErrorStatus
            ));

        // We don't pass on OpenErrorStatus, so we have just the status
        // to pass on, which we do directly as the UINT_PTR "Param".
        //
        RmResumeTask(pAdapter->bind.pSecondaryTask, (UINT_PTR) Status, &sr);
    }

    RM_ASSERT_CLEAR(&sr)
    EXIT()
    TIMESTAMP("<==OpenAdapterComplete");
}

VOID
ArpNdCloseAdapterComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status
)
/*++

Routine Description:

    This is called by NDIS when a previous call to NdisCloseAdapter
    that had pended has completed. The task that called NdisCloseAdapter
    would have suspended itself, so we simply resume it now.

Arguments:

    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to an ARP1394_ADAPTER structure.
    Status                  - Status of CloseAdapter

Return Value:

    None

--*/
{
    ENTER("CloseAdapterComplete", 0x889d22eb)
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) ProtocolBindingContext;
    RM_DECLARE_STACK_RECORD(sr)

    TIMESTAMP("==>CloseAdapterComplete");
    // We expect a nonzero task here (UNbind task), which we unpend.
    // No need to grab locks or anything at this stage.
    //
    RmResumeTask(pAdapter->bind.pSecondaryTask, (UINT_PTR) Status, &sr);

    TIMESTAMP("<==CloseAdapterComplete");

    RM_ASSERT_CLEAR(&sr)
    EXIT()
}

VOID
ArpNdResetComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 Status
)
/*++

Routine Description:

    This routine is called when the miniport indicates that a Reset
    operation has just completed. We ignore this event.

Arguments:

    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to our Adapter structure.
    Status                  - Status of the reset operation.

Return Value:

    None

--*/
{
    TIMESTAMP("===ResetComplete");
}

VOID
ArpNdReceiveComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext
)
/*++

Routine Description:

    This is called by NDIS when the miniport is done with receiving
    a bunch of packets, meaning that it is now time to start processing
    them. We simply pass this on to IP.

Arguments:

    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to an ARP1394_ADAPTER structure.

Return Value:

    None

--*/
{
    PARP1394_ADAPTER            pAdapter;
    PARP1394_INTERFACE          pIF;

    pAdapter = (PARP1394_ADAPTER)ProtocolBindingContext;
    pIF =  pAdapter->pIF;

    //
    // WARNING: for perf reasons, we don't do the clean thing of
    // locking the adapter, refing pIF, unlocking the adapter,
    // calling pIF->ip.RcvCmpltHandler, then derefing pIF.
    //
    if ((pIF != NULL) && (pIF->ip.Context != NULL))
    {
        #if MILLEN
            ASSERT_PASSIVE();
        #endif // MILLEN
        pIF->ip.RcvCmpltHandler();
    }
}


VOID
ArpNdRequestComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PNDIS_REQUEST               pNdisRequest,
    IN  NDIS_STATUS                 Status
)
/*++

Routine Description:

    This is called by NDIS when a previous call we made to NdisRequest() has
    completed.

Arguments:

    ProtocolBindingContext  - Pointer to our Adapter structure
    pNdisRequest            - The request that completed
    Status                  - Status of the request.

Return Value:

    None

--*/
{
    PARP_NDIS_REQUEST   pArpNdisRequest;
    PRM_TASK            pTask;
    ENTER("ArpNdRequestComplete", 0x8cdf7a6d)
    RM_DECLARE_STACK_RECORD(sr)

    pArpNdisRequest = CONTAINING_RECORD(pNdisRequest, ARP_NDIS_REQUEST, Request);
    pTask = pArpNdisRequest->pTask;
    pArpNdisRequest->Status = Status;

    if (pTask == NULL)
    {
        NdisSetEvent(&pArpNdisRequest->Event);
    }
    else
    {
        RmResumeTask(pTask, (UINT_PTR) Status, &sr);
    }

    EXIT()
}


VOID
ArpNdStatus(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  NDIS_STATUS                 GeneralStatus,
    IN  PVOID                       pStatusBuffer,
    IN  UINT                        StatusBufferSize
)
/*++

Routine Description:

    This routine is called when the miniport indicates an adapter-wide
    status change. We ignore this.

Arguments:

    <Ignored>

--*/
{
}

VOID
ArpNdStatusComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext
)
/*++

Routine Description:

    This routine is called when the miniport wants to tell us about
    completion of a status change (?). Ignore this.

Arguments:

    <Ignored>

Return Value:

    None

--*/
{
}


VOID
ArpNdSendComplete(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PNDIS_PACKET                pNdisPacket,
    IN  NDIS_STATUS                 Status
)
/*++

Routine Description:

    This is the Connection-less Send Complete handler, which signals
    completion of such a Send. Since we don't ever use this feature,
    we don't expect this routine to be called.

Arguments:

    <Ignored>

Return Value:

    None

--*/
{
    ASSERT(FALSE);
}


NDIS_STATUS
ArpNdReceive (
    NDIS_HANDLE  ProtocolBindingContext,
    NDIS_HANDLE Context,
    VOID *Header,
    UINT HeaderSize,
    VOID *Data,
    UINT Size,
    UINT TotalSize
    )
/*++
    TODO: We need to support this for ICS, because MILL NDIS calls this
    handler to indicate packets which have the STATUS_RESOURCES bit set.
--*/
{
    return NDIS_STATUS_NOT_RECOGNIZED;  
}

INT
ArpNdReceivePacket (
        NDIS_HANDLE  ProtocolBindingContext,
        PNDIS_PACKET Packet
        )
{

    return 0; // We return 0 because no one hangs on to this packet.
}


NDIS_STATUS
ArpNdPnPEvent(
    IN  NDIS_HANDLE                 ProtocolBindingContext,
    IN  PNET_PNP_EVENT              pNetPnPEvent
)
/*++

Routine Description:

    This is the NDIS entry point called when NDIS wants to inform
    us about a PNP/PM event happening on an adapter. If the event
    is for us, we consume it. Otherwise, we pass this event along
    to IP along the first Interface on this adapter.

    When IP is done with it, it will call our IfPnPEventComplete
    routine.

Arguments:

    ProtocolBindingContext  - Our context for this adapter binding, which
                              is a pointer to an ARP1394_ADAPTER structure.

    pNetPnPEvent            - Pointer to the event.

Return Value:

    None

--*/
{
    ENTER("PnPEvent", 0x2a517a8c)
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) ProtocolBindingContext;
    ARP1394_INTERFACE * pIF =  NULL;
    NDIS_STATUS                     Status;
    PIP_PNP_RECONFIG_REQUEST        pIpReconfigReq;
    ULONG                           Length;

    RM_DECLARE_STACK_RECORD(sr)

    do
    {
        pIpReconfigReq = (PIP_PNP_RECONFIG_REQUEST)pNetPnPEvent->Buffer;
        Length = pNetPnPEvent->BufferLength;

        TIMESTAMP1("==>PnPEvent 0x%lx", pNetPnPEvent->NetEvent);
        //
        //  Do we have a binding context?
        //
        if (pAdapter == NULL)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        //  Is this directed to us?
        //
        if (pNetPnPEvent->NetEvent == NetEventReconfigure)
        {

            if (Length < sizeof(IP_PNP_RECONFIG_REQUEST))
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            if (pIpReconfigReq->arpConfigOffset != 0)
            {
                Status = arpPnPReconfigHandler(pAdapter, pNetPnPEvent);
                break;
            }
        }

        //
        // 01/21/2000  JosephJ: The NIC1394 MCM doesn't close AF's when it's shut
        //              down by NDIS during a powering down event. So
        //              we work around this by claiming not to support
        //              PnP Power so that NDIS closes US as well.
        //
        if (pNetPnPEvent->NetEvent == NetEventSetPower)
        {
            PNET_DEVICE_POWER_STATE         pPowerState;
            pPowerState = (PNET_DEVICE_POWER_STATE) pNetPnPEvent->Buffer;

            Status = arpNdSetPower (pAdapter, pPowerState,&sr );

            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }

        }
        else
        {
                TIMESTAMPX("===PnPEvent (not SetPower)");
        }

        //
        //  This belongs to IP....
        //
        {
            LOCKOBJ(pAdapter, &sr);
            pIF =  pAdapter->pIF;
    
            if ((pIF != NULL) && (pIF->ip.Context != NULL))
            {
                RmTmpReferenceObject(&pIF->Hdr, &sr);
                UNLOCKOBJ(pAdapter, &sr);
                Status = pIF->ip.PnPEventHandler(
                            pIF->ip.Context,
                            pNetPnPEvent
                            );
                RmTmpDereferenceObject(&pIF->Hdr, &sr);
            }
            else
            {
                UNLOCKOBJ(pAdapter, &sr);
                Status = NDIS_STATUS_SUCCESS;
            }
        }
    }
    while (FALSE);

    TR_INFO((" pIF 0x%x, pEvent 0x%x, Evt 0x%x, Status 0x%x\n",
                 pIF, pNetPnPEvent, pNetPnPEvent->NetEvent, Status));


    RM_ASSERT_CLEAR(&sr)
    EXIT()

    TIMESTAMP("<==PnPEvent");
    return Status;
}

VOID
ArpNdUnloadProtocol(
    VOID
)
/*++

Routine Description:

    Unloads our  protocol module. We unbind from all adapters,
    and deregister from NDIS as a protocol.

Arguments:

    None.

Return Value:

    None

--*/
{
    ENTER("UnloadProtocol", 0x8143fec5)
    RM_DECLARE_STACK_RECORD(sr)

    TIMESTAMP("==>UnloadProtocol");
    RmUnloadAllGenericResources(&ArpGlobals.Hdr, &sr);

    RM_ASSERT_CLEAR(&sr)
    TIMESTAMP("<==UnloadProtocol");
    EXIT()
    return;
}


NDIS_STATUS
arpTaskInitializeAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for initializing an adapter.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pTask);
    PTASK_ADAPTERINIT pAdapterInitTask;

    enum
    {
        STAGE_BecomePrimaryTask,
        STAGE_ActivateAdapterComplete,
        STAGE_DeactivateAdapterComplete,
        STAGE_End

    } Stage;

    ENTER("TaskInitializeAdapter", 0xb6ada31d)

    pAdapterInitTask = (PTASK_ADAPTERINIT) pTask;
    ASSERT(sizeof(TASK_ADAPTERINIT) <= sizeof(ARP1394_TASK));

    // 
    // Message normalizing code
    //
    switch(Code)
    {

        case RM_TASKOP_START:
            Stage = STAGE_BecomePrimaryTask;
            break;

        case  RM_TASKOP_PENDCOMPLETE:
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            Stage = RM_PEND_CODE(pTask);
            break;

        case RM_TASKOP_END:
            Status = (NDIS_STATUS) UserParam;
            Stage= STAGE_End;
            break;

        default:
            ASSERT(FALSE);
            return NDIS_STATUS_FAILURE;                 // ** EARLY RETURN **

    }

    ASSERTEX(!PEND(Status), pTask);
        
    switch(Stage)
    {

        case  STAGE_BecomePrimaryTask:
        {
            // If there is a primary task, pend on it, else make ourselves
            // the primary task.
            //
            LOCKOBJ(pAdapter, pSR);
            if (pAdapter->bind.pPrimaryTask == NULL)
            {
                arpSetPrimaryAdapterTask(pAdapter, pTask, ARPAD_PS_INITING, pSR);
                UNLOCKOBJ(pAdapter, pSR);
            }
            else
            {
                PRM_TASK pOtherTask =  pAdapter->bind.pPrimaryTask;
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pAdapter, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    STAGE_BecomePrimaryTask, // we'll try again...
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }
        
            //
            // We're now the  primary task. Since we're starting out,
            // there should be NO activate/deactivate task.
            // (Note: we don't bother getting the adapter lock for these asserts).
            //
            ASSERT(pAdapter->bind.pPrimaryTask == pTask);
            ASSERT(pAdapter->bind.pSecondaryTask == NULL);

            //
            // Allocate and start the activate adapter task.
            //
            {
                PRM_TASK pActivateTask;

                Status = arpAllocateTask(
                            &pAdapter->Hdr,             // pParentObject,
                            arpTaskActivateAdapter,     // pfnHandler,
                            0,                          // Timeout,
                            "Task: Activate Adapter(init)", // szDescription
                            &pActivateTask,
                            pSR
                            );
            
                if (FAIL(Status))
                {
                    pActivateTask = NULL;
                    TR_WARN(("FATAL: couldn't alloc activate task!\n"));
                }
                else
                {
                    RmPendTaskOnOtherTask(
                        pTask,
                        STAGE_ActivateAdapterComplete,
                        pActivateTask,              // task to pend on
                        pSR
                        );
            
                    // RmStartTask uses up the tmpref on the task
                    // which was added by arpAllocateTask.
                    //
                    Status = RmStartTask(
                                pActivateTask,
                                0, // UserParam (unused)
                                pSR
                                );
                }
            }
         }


        if (PEND(Status)) break;
        
        // FALL THROUGH TO NEXT STAGE

        case STAGE_ActivateAdapterComplete:
        {
            //
            // We've run the active-adapter task. On failure, we need to
            // cleanup state by calling the deactivate-adapter task.
            //

            // Save away the failure code for later...
            //
            pAdapterInitTask->ReturnStatus = Status;

            if (FAIL(Status))
            {
                PRM_TASK pDeactivateTask;

                Status = arpAllocateTask(
                                &pAdapter->Hdr,             // pParentObject,
                                arpTaskDeactivateAdapter,       // pfnHandler,
                                0,                          // Timeout,
                                "Task: Deactivate Adapter(init)", // szDescription
                                &pDeactivateTask,
                                pSR
                                );
            
                if (FAIL(Status))
                {
                    pDeactivateTask = NULL;
                    ASSERT(FALSE); // TODO: use special dealloc task pool for this.
                    TR_WARN(("FATAL: couldn't alloc deactivate task!\n"));
                }
                else
                {

                    RmPendTaskOnOtherTask(
                        pTask,
                        STAGE_DeactivateAdapterComplete,
                        pDeactivateTask,                // task to pend on
                        pSR
                        );
            
                    // RmStartTask uses up the tmpref on the task
                    // which was added by arpAllocateTask.
                    //
                    Status = RmStartTask(
                                pDeactivateTask,
                                0, // UserParam (unused)
                                pSR
                                );
                }
            }
        }
        break;

        case STAGE_DeactivateAdapterComplete:
        {
            //
            // We've completed the deactivate adapter task which we started
            // because of some init-adapter failure.
            //

            // In general, we don't expect the deactivate task to return failure.
            //
            ASSERT(!FAIL(Status));

            // We expect the original status of the init to be a failure (that's
            // why we started the deinit in the first place!
            //
            ASSERT(FAIL(pAdapterInitTask->ReturnStatus));
            Status = pAdapterInitTask->ReturnStatus;

        }
        break;

        case STAGE_End:
        {
            NDIS_HANDLE                 BindContext;
            BOOLEAN                     BridgeEnabled = ARP_BRIDGE_ENABLED(pAdapter);

            //
            // We HAVE to be the primary task at this point, becase we simply
            // wait and retry until we become one.
            //

            // Clear the primary task in the adapter object.
            //
            LOCKOBJ(pAdapter, pSR);
            {
                ULONG InitState;
                InitState = FAIL(Status) ? ARPAD_PS_FAILEDINIT : ARPAD_PS_INITED;
                arpClearPrimaryAdapterTask(pAdapter, pTask, InitState, pSR);
            }
            BindContext = pAdapter->bind.BindContext;
            UNLOCKOBJ(pAdapter, pSR);


            // On failure, pAdapter should be deallocated.
            //
            if (FAIL(Status))
            {
                if(RM_IS_ZOMBIE(pAdapter))
                {
                    TR_WARN(("END: pAdapter is already deallocated.\n"));
                }
                else
                {
                    //
                    // On failure, free the adapter here itself, because we're
                    // not going to call the shutdown task.
                    //
                    RmFreeObjectInGroup(
                        &ArpGlobals.adapters.Group,
                        &(pAdapter->Hdr),
                        NULL,               // NULL pTask == synchronous.
                        pSR
                        );
                }
            }

            if (!BridgeEnabled)
            {
                // Signal IP that the bind is complete.
                //
                TIMESTAMP("===Calling IP's BindComplete routine");
                RM_ASSERT_NOLOCKS(pSR);
                ArpGlobals.ip.pBindCompleteRtn(
                                Status,
                                BindContext
                                );
            }
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskShutdownAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for shutting down an IP interface.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : UnbindContext

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pTask);
    TASK_ADAPTERSHUTDOWN *pMyTask = (TASK_ADAPTERSHUTDOWN*) pTask;
    enum
    {
        STAGE_BecomePrimaryTask,
        STAGE_DeactivateAdapterComplete,
        STAGE_End
    } Stage;

    ENTER("TaskShutdownAdapter", 0xe262e828)

    // 
    // Message normalizing code
    //
    switch(Code)
    {

        case RM_TASKOP_START:
            Stage = STAGE_BecomePrimaryTask;

            // Save away the UnbindContext (which we get as UserParam) in
            // the task's private context, for use later.
            //
            pMyTask->pUnbindContext = (NDIS_HANDLE) UserParam;

            break;

        case  RM_TASKOP_PENDCOMPLETE:
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            Stage = RM_PEND_CODE(pTask);
            break;

        case RM_TASKOP_END:
            Status = (NDIS_STATUS) UserParam;
            Stage= STAGE_End;
            break;

        default:
            ASSERT(FALSE);
            return NDIS_STATUS_FAILURE;                 // ** EARLY RETURN **
    }

    ASSERTEX(!PEND(Status), pTask);

    switch(Stage)
    {

        case  STAGE_BecomePrimaryTask:
        {
            // If there is a primary task, pend on it, else make ourselves
            // the primary task.
            // We could get in this situation if someone does a
            // "net stop arp1394" while we're in the middle of initializing or
            // shutting down the adapter.
            //
            //
            LOCKOBJ(pAdapter, pSR);
            if (pAdapter->bind.pPrimaryTask == NULL)
            {
                arpSetPrimaryAdapterTask(pAdapter, pTask, ARPAD_PS_DEINITING, pSR);
                UNLOCKOBJ(pAdapter, pSR);
            }
            else
            {
                PRM_TASK pOtherTask =  pAdapter->bind.pPrimaryTask;
                RmTmpReferenceObject(&pOtherTask->Hdr, pSR);
                UNLOCKOBJ(pAdapter, pSR);
                RmPendTaskOnOtherTask(
                    pTask,
                    STAGE_BecomePrimaryTask, // we'll try again...
                    pOtherTask,
                    pSR
                    );
                RmTmpDereferenceObject(&pOtherTask->Hdr, pSR);
                Status = NDIS_STATUS_PENDING;
                break;
            }
        
            //
            // We're now the  primary task. Since we're starting out,
            // there should be NO activate/deactivate task.
            // (Note: we don't bother getting the adapter lock for these asserts).
            //
            ASSERT(pAdapter->bind.pPrimaryTask == pTask);
            ASSERT(pAdapter->bind.pSecondaryTask == NULL);

            //
            // Allocate and start the deactivate adapter task.
            //
            {
                PRM_TASK pDeactivateTask;

                Status = arpAllocateTask(
                            &pAdapter->Hdr,             // pParentObject,
                            arpTaskDeactivateAdapter,       // pfnHandler,
                            0,                          // Timeout,
                            "Task: Deactivate Adapter(shutdown)",   // szDescription
                            &pDeactivateTask,
                            pSR
                            );
            
                if (FAIL(Status))
                {
                    pDeactivateTask = NULL;
                    TR_WARN(("FATAL: couldn't alloc deactivate task!\n"));
                }
                else
                {
                    RmPendTaskOnOtherTask(
                        pTask,
                        STAGE_DeactivateAdapterComplete,
                        pDeactivateTask,                // task to pend on
                        pSR
                        );
            
                    // RmStartTask uses up the tmpref on the task
                    // which was added by arpAllocateTask.
                    //
                    Status = RmStartTask(
                                pDeactivateTask,
                                0, // UserParam (unused)
                                pSR
                                );
                }
            }
         }
         break;

        case STAGE_DeactivateAdapterComplete:
        {
            // Nothing to do here -- we clean  up in STAGE_End.
            //
            break;
        }

        case STAGE_End:
        {
            //
            // We HAVE to be the primary task at this point, becase we simply
            // wait and retry until we become one.
            //
            ASSERT(pAdapter->bind.pPrimaryTask == pTask);

            // Clear the primary task in the adapter object.
            //
            LOCKOBJ(pAdapter, pSR);
            arpClearPrimaryAdapterTask(pAdapter, pTask, ARPAD_PS_DEINITED, pSR);
            UNLOCKOBJ(pAdapter, pSR);


            if(RM_IS_ZOMBIE(pAdapter))
            {
                TR_WARN(("END: pAdapter is already deallocated.\n"));
            }
            else
            {
                // Free the adapter.
                // (pAdapter will be allocated, but it will be in a "zombie" state).
                //
                RmFreeObjectInGroup(
                    &ArpGlobals.adapters.Group,
                    &(pAdapter->Hdr),
                    NULL,               // NULL pTask == synchronous.
                    pSR
                    );
            }
            // If there is an unbind-context, signal NDIS that the unbind is
            //  complete.
            //
            if (pMyTask->pUnbindContext)
            {
                TR_WARN(("END: Calling NdisCompleteUnbindAdapter. Status= 0x%lx\n",
                            Status));
                RM_ASSERT_NOLOCKS(pSR);
                TIMESTAMP("===Calling NdisCompleteUnbindAdapter");
                NdisCompleteUnbindAdapter(
                                pMyTask->pUnbindContext,
                                Status
                            );
            }
        }
        break;

        default:
        {
            ASSERTEX(!"Unknown task op", pTask);
        }
        break;

    } // switch (Code)

    RM_ASSERT_NOLOCKS(pSR);
    EXIT()

    return Status;
}


NDIS_STATUS
arpTaskActivateAdapter(
    IN  struct _RM_TASK *           pTask,
    IN  RM_TASK_OPERATION           Code,
    IN  UINT_PTR                    UserParam,
    IN  PRM_STACK_RECORD            pSR
    )
/*++

Routine Description:

    Task handler responsible for initializing an adapter.

Arguments:
    
    UserParam   for (Code ==  RM_TASKOP_START)          : unused

--*/
{
    NDIS_STATUS         Status      = NDIS_STATUS_FAILURE;
    ARP1394_ADAPTER *   pAdapter = (ARP1394_ADAPTER*) RM_PARENT_OBJECT(pTask);
    enum
    {
        PEND_OpenAdapter,
        PEND_GetAdapterInfo
    };
    ENTER("arpTaskActivateAdapter", 0xb6ada31d)

    switch(Code)
    {

        case RM_TASKOP_START:
        {
        
        #if MILLEN
            NDIS_MEDIUM                 Medium =  NdisMedium802_3;
        #else // !MILLEN
            NDIS_MEDIUM                 Medium = NdisMedium802_3;
        #endif // !MILLEN
            UINT                        SelMediumIndex = 0;
            NDIS_STATUS                 OpenStatus;

            //
            // Allocate Backup Tasks
            //
            arpAddBackupTasks (&ArpGlobals,ARP1394_BACKUP_TASKS);

            // Set ourselves as the secondary task.
            //
            LOCKOBJ(pAdapter, pSR);
            arpSetSecondaryAdapterTask(pAdapter, pTask, ARPAD_AS_ACTIVATING, pSR);
            UNLOCKOBJ(pAdapter, pSR);

            //
            // Suspend task and call NdisOpenAdapter...
            //

            RmSuspendTask(pTask, PEND_OpenAdapter, pSR);
            RM_ASSERT_NOLOCKS(pSR);
            NdisOpenAdapter(
                &Status,
                &OpenStatus,
                &pAdapter->bind.AdapterHandle,
                &SelMediumIndex,                    // selected medium index
                &Medium,                            // Array of medium types
                1,                                  // Size of Media list
                ArpGlobals.ndis.ProtocolHandle,
                (NDIS_HANDLE)pAdapter,              // our adapter bind context
                &pAdapter->bind.DeviceName,         // pDeviceName
                0,                                  // Open options
                (PSTRING)NULL                       // Addressing Info...
                );
    
            if (Status != NDIS_STATUS_PENDING)
            {
                ArpNdOpenAdapterComplete(
                        (NDIS_HANDLE)pAdapter,
                        Status,
                        OpenStatus
                        );
            }
            Status = NDIS_STATUS_PENDING;
        }
        break;

        case  RM_TASKOP_PENDCOMPLETE:
        {
            PTASK_ADAPTERACTIVATE pAdapterInitTask;
            pAdapterInitTask = (PTASK_ADAPTERACTIVATE) pTask;
            Status = (NDIS_STATUS) UserParam;
            ASSERT(!PEND(Status));
            ASSERT(sizeof(TASK_ADAPTERACTIVATE) <= sizeof(ARP1394_TASK));

            switch(RM_PEND_CODE(pTask))
            {
                case  PEND_OpenAdapter:
        
                    //
                    // The open adapter operation is complete. Get adapter
                    // information and notify IP on success. On failure,
                    // shutdown the adapter if required, and notify IP of
                    // the failure.
                    //
        
                    if (FAIL(Status))
                    {
                        // Set adapter handle to null -- it may not be hull.
                        // even though the open adapter has succeeded.
                        //
                        pAdapter->bind.AdapterHandle = NULL;
                        break;
                    }

                    // Successfully opened the adapter.
                    // Now get adapter information from miniport.
                    // (We use the TASK_ADAPTERINIT.ArpNdisRequest field,
                    // which is defined specifically for this use).
                    //
                    Status =  arpPrepareAndSendNdisRequest(
                                pAdapter,
                                &pAdapterInitTask->ArpNdisRequest,
                                NULL,  // pTask - Finish the request synchronously
                                PEND_GetAdapterInfo,
                                OID_1394_LOCAL_NODE_INFO,
                                &pAdapterInitTask->LocalNodeInfo,
                                sizeof(pAdapterInitTask->LocalNodeInfo),
                                NdisRequestQueryInformation,
                                pSR
                                );
                    ASSERT(!PEND(Status));
                    if (PEND(Status)) break;

                    // FALL THROUGH on synchronous completion of arpGetAdapterInfo...

                case PEND_GetAdapterInfo:

                    //
                    // Done with getting adapter info.
                    // We need to switch to passive before going further
                    //
                    if (!ARP_ATPASSIVE())
                    {

                        // We're not at passive level, but we need to be when we
                        // call IP's add interface. So we switch to passive...
                        // NOTE: we specify completion code PEND_GetAdapterInfo
                        //       because we want to get back here (except
                        //       we'll be at passive).
                        //
                        RmSuspendTask(pTask, PEND_GetAdapterInfo, pSR);
                        RmResumeTaskAsync(
                            pTask,
                            Status,
                            &pAdapterInitTask->WorkItem,
                            pSR
                            );
                        Status = NDIS_STATUS_PENDING;
                        break;
                    }
            
                    if (Status == NDIS_STATUS_SUCCESS)
                    {
                    

                        //
                        // Copy over adapter info into pAdapter->info...
                        // Then read configuration information.
                        //

                        LOCKOBJ(pAdapter, pSR);
                        ARP_ZEROSTRUCT(&pAdapter->info);

                        // OID_GEN_CO_VENDOR_DESCRIPTION
                        //
                        pAdapter->info.szDescription = "NIC1394";
                        pAdapter->info.DescriptionLength = sizeof("NIC1394");
                        // TODO -- when you do the real stuff, remember to free it.
                    
                        // Max Frame size
                        // TODO: fill in the real adapter's MTU.
                        //
                        pAdapter->info.MTU =  ARP1394_ADAPTER_MTU;
                    
                        
                        pAdapter->info.LocalUniqueID    = 
                                            pAdapterInitTask->LocalNodeInfo.UniqueID;

                        {
                            UINT MaxRec;
                            UINT MaxSpeedCode;
                            MaxSpeedCode =
                                    pAdapterInitTask->LocalNodeInfo.MaxRecvSpeed;
                            MaxRec = 
                                    pAdapterInitTask->LocalNodeInfo.MaxRecvBlockSize;

                        #if DBG
                            while (   !IP1394_IS_VALID_MAXREC(MaxRec)
                                || !IP1394_IS_VALID_SSPD(MaxSpeedCode)
                                || MaxSpeedCode == 0)
                            {
                                TR_WARN(("FATAL: Invalid maxrec(0x%x) or sspd(0x%x)!\n",
                                        MaxRec,
                                        MaxSpeedCode
                                        ));
                                TR_WARN(("        &maxrec=0x%p, &sspd=0x%p\n",
                                        &MaxRec,
                                        &MaxSpeedCode
                                        ));
                                DbgBreakPoint();
                            }

                            TR_WARN(("Selected maxrec=0x%x and sspd=0x%x.\n",
                                        MaxRec,
                                        MaxSpeedCode
                                        ));
                        #endif // DBG

                            pAdapter->info.MaxRec = MaxRec;
                            pAdapter->info.MaxSpeedCode = MaxSpeedCode;
                        }

                        // B TODO: we should get this from the NIC -- add
                        // to the IOCTL OR query the adapter for its 
                        // MAC address.
                        // For now we put a hardcoded MAC address.
                        //
                #define ARP_FAKE_ETH_ADDRESS(_AdapterNum)                   \
                        {                                                   \
                            0x02 | (((UCHAR)(_AdapterNum) & 0x3f) << 2),    \
                            ((UCHAR)(_AdapterNum) & 0x3f),                  \
                            0,0,0,0                                         \
                        }
                
                #define ARP_DEF_LOCAL_ETH_ADDRESS \
                                ARP_FAKE_ETH_ADDRESS(0x1)

        

                        UNLOCKOBJ(pAdapter, pSR);


                        //
                        // Query the adapter for its Mac Addrees
                        //
                        {
                            ENetAddr    LocalEthAddr;
                            ARP_NDIS_REQUEST ArpNdisRequest;
                            ARP_ZEROSTRUCT (&ArpNdisRequest);
                            
                            Status =  arpPrepareAndSendNdisRequest(
                                        pAdapter,
                                        &ArpNdisRequest,
                                        NULL,                   // pTask (NULL==BLOCK)
                                        0,                      // unused
                                        OID_802_3_CURRENT_ADDRESS,
                                        &LocalEthAddr,
                                        sizeof(LocalEthAddr),
                                        NdisRequestQueryInformation,
                                        pSR
                                        );
                            
                            if (Status == NDIS_STATUS_SUCCESS)
                            {
                            
                                pAdapter->info.EthernetMacAddress = LocalEthAddr;

                            }
                            else
                            {
                                //
                                // Failure means that we have failed to bind
                                break;
                            }
                            

        
                        }

                        //
                        // Query the adapter for its Speed
                        //
                        {
                            NDIS_CO_LINK_SPEED CoLinkSpeed;
                            ARP_NDIS_REQUEST ArpNdisRequest;
                            ARP_ZEROSTRUCT (&ArpNdisRequest);
                            
                            Status =  arpPrepareAndSendNdisRequest(
                                        pAdapter,
                                        &ArpNdisRequest,
                                        NULL,                   // pTask (NULL==BLOCK)
                                        0,                      // unused
                                        OID_GEN_CO_LINK_SPEED,
                                        &CoLinkSpeed,
                                        sizeof(CoLinkSpeed),
                                        NdisRequestQueryInformation,
                                        pSR
                                        );
     
                            
                            if (Status == NDIS_STATUS_SUCCESS)
                            {

                                //
                                // if nic1394 is in ethernet mode- it will fill in only one ULONG
                                // therefore rchoose outbound because it is the first ulong
                                // Multiply by 100 - thats what ethArp does.
                                //

                                pAdapter->info.Speed= (CoLinkSpeed.Outbound *100); 
                                

                            }
                            else
                            {
                                //
                                // Failure means that we have failed to bind
                                break;

                            }
                            

                        }
                        // Query the adapter for its Table of RemoteNodes
                        //
                        Status = arpGetEuidTopologyWorkItem(NULL, &pAdapter->Hdr, pSR);

                        if (Status != NDIS_STATUS_SUCCESS)
                        {
                            break;
                        }

                        
                        // Read Adapter Configuration Information
                        //
                        Status =  arpCfgReadAdapterConfiguration(pAdapter, pSR);

                        if (Status != NDIS_STATUS_SUCCESS)
                        {
                            break;
                        }

                    }

                    //
                    // NOTE: if we fail, a higher level task is responsible
                    // for "running the compensating transaction", i.e., running
                    // arpTaskDeactivateAdapter.
                    //

                // end case  PEND_OpenAdapter, PEND_GetAdapterInfo
                break;
    
                default:
                {
                    ASSERTEX(!"Unknown pend op", pTask);