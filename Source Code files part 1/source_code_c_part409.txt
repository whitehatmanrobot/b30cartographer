else {
        DWORD dwDisposition;
        if (ERROR_SUCCESS != (err = RegCreateHKCUKeyExU(
                hKey,
                pwszSubKeyName,
                0,                      // dwReserved
                NULL,                   // lpClass
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,                   // lpSecurityAttributes
                &hSubKey,
                &dwDisposition)))
            goto RegCreateKeyError;
    }

CommonReturn:
    return hSubKey;
ErrorReturn:
    hSubKey = NULL;
    goto CommonReturn;

SET_ERROR_VAR(RegCreateBackupRestoreKeyError, err)
SET_ERROR(ExistingSubKey, ERROR_FILE_EXISTS)
TRACE_ERROR(OpenNewSubKeyError)
SET_ERROR_VAR(RegOpenKeyError, err)
SET_ERROR_VAR(RegCreateKeyError, err)
}


STATIC BOOL RecursiveDeleteSubKey(
    IN HKEY hKey,
    IN LPCWSTR pwszSubKeyName,
    IN DWORD dwFlags            // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    )
{
    BOOL fResult;
    LONG err;

    while (TRUE) {
        HKEY hSubKey;
        DWORD cSubKeys;
        DWORD cchMaxSubKey;
        BOOL fDidDelete;

        if (ERROR_SUCCESS != OpenHKCUKeyExU(
                hKey,
                pwszSubKeyName,
                dwFlags,
                KEY_ALL_ACCESS,
                &hSubKey))
            break;

        GetSubKeyInfo(
            hSubKey,
            &cSubKeys,
            &cchMaxSubKey
            );

        fDidDelete = FALSE;
        if (cSubKeys && cchMaxSubKey) {
            LPWSTR pwszEnumSubKeyName;
            cchMaxSubKey++;

            if (pwszEnumSubKeyName = (LPWSTR) PkiNonzeroAlloc(
                    cchMaxSubKey * sizeof(WCHAR))) {
                if (ERROR_SUCCESS == RegEnumKeyExU(
                        hSubKey,
                        0,
                        pwszEnumSubKeyName,
                        &cchMaxSubKey,
                        NULL,               // lpdwReserved
                        NULL,               // lpszClass
                        NULL,               // lpcchClass
                        NULL                // lpftLastWriteTime
                        ))
                    fDidDelete = RecursiveDeleteSubKey(
                        hSubKey, pwszEnumSubKeyName, dwFlags);
                PkiFree(pwszEnumSubKeyName);
            }
        }
        RegCloseKey(hSubKey);
        if (!fDidDelete)
            break;
    }

    if (ERROR_SUCCESS != (err = RegDeleteKeyU(hKey, pwszSubKeyName)))
        goto RegDeleteKeyError;
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegDeleteKeyError, err)
}

//+=========================================================================
//  Trusted Publisher Registry Functions
//==========================================================================

STATIC BOOL OpenKeyAndReadDWORDValueFromRegistry(
    IN BOOL fMachine,
    IN LPCWSTR pwszRegPath,
    IN LPCWSTR pwszValueName,
    OUT DWORD *pdwValue
    )
{
    BOOL fResult;
    HKEY hKey = NULL;
    LONG err;

    if (ERROR_SUCCESS != (err = RegOpenHKCUKeyExU(
            fMachine ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
            pwszRegPath,
            0,                      // dwReserved
            KEY_READ,
            &hKey
            )))
        goto OpenKeyForDWORDValueError;

    if (!ILS_ReadDWORDValueFromRegistry(
            hKey,
            pwszValueName,
            pdwValue
            )) goto ReadDWORDValueError;

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKey);
    return fResult;
ErrorReturn:
    *pdwValue = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(OpenKeyForDWORDValueError, err)
TRACE_ERROR(ReadDWORDValueError)
}


//+-------------------------------------------------------------------------
//  On the Nth iteration these Safer Grade School programmers decided that the
//  value should be the 'OR' of the 3 different locations: HKLM\GPO, HKCU\GPO,
//  HKLM\Registry.
//--------------------------------------------------------------------------
BOOL
I_CryptReadTrustedPublisherDWORDValueFromRegistry(
    IN LPCWSTR pwszValueName,
    OUT DWORD *pdwValue
    )
{
    BOOL fResult = FALSE;
    DWORD dwValue = 0;
    DWORD dwRegValue = 0;

    if (OpenKeyAndReadDWORDValueFromRegistry(
            TRUE,                                       // fMachine
            CERT_TRUST_PUB_SAFER_GROUP_POLICY_REGPATH,
            pwszValueName,
            &dwRegValue
            )) {
        fResult = TRUE;
        dwValue |= dwRegValue;
    }

    if (OpenKeyAndReadDWORDValueFromRegistry(
            FALSE,                                      // fMachine
            CERT_TRUST_PUB_SAFER_GROUP_POLICY_REGPATH,
            pwszValueName,
            &dwRegValue
            )) {
        fResult = TRUE;
        dwValue |= dwRegValue;
    }

    if (OpenKeyAndReadDWORDValueFromRegistry(
            TRUE,                                       // fMachine
            CERT_TRUST_PUB_SAFER_LOCAL_MACHINE_REGPATH,
            pwszValueName,
            &dwRegValue
            )) {
        fResult = TRUE;
        dwValue |= dwRegValue;
    }

    *pdwValue = dwValue;
    return fResult;
}

//+=========================================================================
//  Win95 Registry Functions
//
//  Note, as of 10/17/97 the following is also done on NT to allow
//  registry hive roaming from NT to Win95 systems.
//
//  Certs, CRLs and CTLs are stored in SubKeys instead of as Key values.
//
//  Note: Win95 has the following registry limitations:
//   - Max single key value is 16K
//   - Max total values per key is 64K
//
//  For WIN95, write each cert, CRL, CTL to its own key when the
//  above limitations are exceeded. If encoded blob exceeds 12K, partition
//  and write to multiple SubKeys. Blobs are written to values named
//  "Blob". Partitioned blobs, have "BlobCount" and "BlobLength" values and
//  SubKeys named "Blob0", "Blob1", "Blob2" ... .
//
//  The IE4.0 version of crypt32 wrote the blob to a "File" if the blob
//  exceeded 12K. For backwards compatibility, continue to read "File" based
//  blobs. On write enabled, non-remote opens, "File" blobs are moved to
//  "Blob0", ... SubKeys and the file is deleted.
//
//  If CERT_REGISTRY_STORE_SERIALIZED_FLAG is set when the registry store
//  is opened, then, the entire store resides in a partitioned blob under the
//  "Serialized" subkey.
//==========================================================================
#define KEY_BLOB_VALUE_NAME             L"Blob"
#define KEY_FILE_VALUE_NAME             L"File"
#define KEY_BLOB_COUNT_VALUE_NAME       L"BlobCount"
#define KEY_BLOB_LENGTH_VALUE_NAME      L"BlobLength"
#define KEY_BLOB_N_SUBKEY_PREFIX        "Blob"
#define KEY_BLOB_N_SUBKEY_PREFIX_LENGTH 4
#define SYSTEM_STORE_SUBDIR             L"SystemCertificates"
#define FILETIME_ASCII_HEX_LEN          (2 * sizeof(FILETIME) + 1)
#define MAX_KEY_BLOB_VALUE_LEN          0x3000
#define MAX_NEW_FILE_CREATE_ATTEMPTS    100

#define SERIALIZED_SUBKEY_NAME          L"Serialized"


//+-------------------------------------------------------------------------
//  Read and allocate the element bytes by reading the file pointed to
//  by the SubKey's "File" value
//--------------------------------------------------------------------------
STATIC BOOL ReadKeyFileElementFromRegistry(
    IN HKEY hSubKey,
    IN DWORD dwFlags,           // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    )
{
    BOOL fResult;
    LPWSTR pwszFilename = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbBytesRead;
    BYTE *pbElement = NULL;
    DWORD cbElement;

    if (NULL == (pwszFilename = ILS_ReadSZValueFromRegistry(
            hSubKey, KEY_FILE_VALUE_NAME)))
        goto GetKeyFilenameError;

    if (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
              pwszFilename,
              GENERIC_READ,
              FILE_SHARE_READ,
              NULL,                   // lpsa
              OPEN_EXISTING,
              FILE_ATTRIBUTE_NORMAL |
                ((dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) ?
                    FILE_FLAG_BACKUP_SEMANTICS : 0),  
              NULL                    // hTemplateFile
              )))
        goto CreateFileError;

    cbElement = GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == cbElement) goto FileError;
    if (0 == cbElement) goto EmptyFile;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;
    if (!ReadFile(
            hFile,
            pbElement,
            cbElement,
            &cbBytesRead,
            NULL            // lpOverlapped
            )) goto FileError;

    fResult = TRUE;
CommonReturn:
    PkiFree(pwszFilename);
    if (INVALID_HANDLE_VALUE != hFile)
        ILS_CloseHandle(hFile);
    *ppbElement = pbElement;
    *pcbElement = cbElement;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    PkiFree(pbElement);
    pbElement = NULL;
    cbElement = 0;
    goto CommonReturn;

TRACE_ERROR(GetKeyFilenameError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreateFileError)
TRACE_ERROR(FileError)
SET_ERROR(EmptyFile, CRYPT_E_FILE_ERROR)
}

//+-------------------------------------------------------------------------
//  Read as multiple SubKeys containing the element bytes. The SubKeys
//  are named Blob0, Blob1, Blob2, ... BlobN.
//  Each BlobN SubKey has a value named "Blob" containing the bytes to be read.
//
//  The passed in SubKey is expected to have 2 values:
//      BlobCount - # of BlobN SubKeys
//      BlobLength - total length of all the concatenated Blob Subkey bytes
//
//  A single allocated element byte array is returned.
//--------------------------------------------------------------------------
STATIC BOOL ReadMultipleKeyBlobsFromRegistry(
    IN HKEY hSubKey,
    IN DWORD dwFlags,           // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    )
{
    BOOL fResult;
    LONG err;
    HKEY hBlobKey = NULL;
    BYTE *pbElement = NULL;
    DWORD cbElement;
    DWORD BlobCount;
    DWORD BlobLength;
    DWORD i;
    char szBlobN[KEY_BLOB_N_SUBKEY_PREFIX_LENGTH + 33];

    ILS_ReadDWORDValueFromRegistry(
            hSubKey,
            KEY_BLOB_COUNT_VALUE_NAME,
            &BlobCount
            );
    ILS_ReadDWORDValueFromRegistry(
            hSubKey,
            KEY_BLOB_LENGTH_VALUE_NAME,
            &BlobLength
            );

    if (0 == BlobCount || 0 == BlobLength)
        goto NoMultipleKeyBlobs;

    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(BlobLength)))
        goto OutOfMemory;

    cbElement = 0;
    strcpy(szBlobN, KEY_BLOB_N_SUBKEY_PREFIX);
    for (i = 0; i < BlobCount; i++) {
        DWORD cbData;
        DWORD dwType;

        _ltoa((long) i, szBlobN + KEY_BLOB_N_SUBKEY_PREFIX_LENGTH, 10);

        if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) {
            DWORD dwDisposition;

            if (ERROR_SUCCESS != (err = RegCreateKeyExA(
                    hSubKey,
                    szBlobN,
                    0,                      // dwReserved
                    NULL,                   // lpClass
                    REG_OPTION_BACKUP_RESTORE,
                    KEY_READ,
                    NULL,                   // lpSecurityAttributes
                    &hBlobKey,
                    &dwDisposition)))
                goto OpenBackupRestoreBlobNError;
        } else {
            if (ERROR_SUCCESS != (err = RegOpenKeyExA(
                    hSubKey,
                    szBlobN,
                    0,                  // dwReserved
                    KEY_READ,
                    &hBlobKey)))
                goto OpenBlobNError;
        }

        cbData = BlobLength - cbElement;
        if (0 == cbData)
            goto ExtraMultipleKeyBlobs;

        if (ERROR_SUCCESS != (err = RegQueryValueExU(
                hBlobKey,
                KEY_BLOB_VALUE_NAME,
                NULL,       // pdwReserved
                &dwType,
                pbElement + cbElement,
                &cbData)))
            goto RegQueryValueError;
        if (dwType != REG_BINARY)
            goto InvalidRegistryValue;

        cbElement += cbData;
        if (cbElement > BlobLength)
            goto UnexpectedError;

        RegCloseKey(hBlobKey);
        hBlobKey = NULL;
    }

    if (cbElement != BlobLength)
        goto MissingMultipleKeyBlobsBytes;

    assert(NULL == hBlobKey);

    fResult = TRUE;
CommonReturn:
    *ppbElement = pbElement;
    *pcbElement = cbElement;
    return fResult;
ErrorReturn:
    PkiFree(pbElement);
    ILS_CloseRegistryKey(hBlobKey);
    fResult = FALSE;
    pbElement = NULL;
    cbElement = 0;
    goto CommonReturn;

SET_ERROR(NoMultipleKeyBlobs, ERROR_FILE_NOT_FOUND)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(OpenBlobNError, err)
SET_ERROR_VAR(OpenBackupRestoreBlobNError, err)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
SET_ERROR(InvalidRegistryValue, CRYPT_E_FILE_ERROR)
SET_ERROR(ExtraMultipleKeyBlobs, CRYPT_E_FILE_ERROR)
SET_ERROR_VAR(RegQueryValueError, err)
SET_ERROR(MissingMultipleKeyBlobsBytes, CRYPT_E_FILE_ERROR)
}

//+-------------------------------------------------------------------------
//  Write as multiple BlobN SubKeys containing the element bytes.
//
//  See ReadMultipleKeyBlobsFromRegistry() for details.
//--------------------------------------------------------------------------
STATIC BOOL WriteMultipleKeyBlobsToRegistry(
    IN HKEY hSubKey,
    IN DWORD dwFlags,           // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    IN const BYTE *pbElement,
    IN DWORD cbElement
    )
{
    BOOL fResult;
    LONG err;
    HKEY hBlobKey = NULL;
    DWORD BlobCount = 0;
    DWORD BlobLength;
    DWORD i;
    DWORD dwErr;
    char szBlobN[KEY_BLOB_N_SUBKEY_PREFIX_LENGTH + 33];

    if (0 == cbElement)
        goto UnexpectedError;
    BlobCount = cbElement / MAX_KEY_BLOB_VALUE_LEN;
    if (cbElement % MAX_KEY_BLOB_VALUE_LEN)
        BlobCount++;

    BlobLength = 0;
    strcpy(szBlobN, KEY_BLOB_N_SUBKEY_PREFIX);
    for (i = 0; i < BlobCount; i++) {
        DWORD cbData;
        DWORD dwDisposition;

        _ltoa((long) i, szBlobN + KEY_BLOB_N_SUBKEY_PREFIX_LENGTH, 10);
        if (ERROR_SUCCESS != (err = RegCreateKeyExA(
                hSubKey,
                szBlobN,
                0,                      // dwReserved
                NULL,                   // lpClass
                (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) ?
                    REG_OPTION_BACKUP_RESTORE : REG_OPTION_NON_VOLATILE,
                KEY_WRITE,
                NULL,                   // lpSecurityAttributes
                &hBlobKey,
                &dwDisposition))) goto RegCreateKeyError;

        assert(cbElement > BlobLength);
        cbData = cbElement - BlobLength;
        if (cbData > MAX_KEY_BLOB_VALUE_LEN)
            cbData = MAX_KEY_BLOB_VALUE_LEN;

        if (ERROR_SUCCESS != (err = RegSetValueExU(
                hBlobKey,
                KEY_BLOB_VALUE_NAME,
                NULL,
                REG_BINARY,
                pbElement + BlobLength,
                cbData))) goto RegSetValueError;

        BlobLength += cbData;

        RegCloseKey(hBlobKey);
        hBlobKey = NULL;
    }

    assert(BlobLength == cbElement);

    if (!WriteDWORDValueToRegistry(
            hSubKey,
            KEY_BLOB_COUNT_VALUE_NAME,
            BlobCount))
        goto WriteDWORDError;
    if (!WriteDWORDValueToRegistry(
            hSubKey,
            KEY_BLOB_LENGTH_VALUE_NAME,
            BlobLength))
        goto WriteDWORDError;

    assert(NULL == hBlobKey);
    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    dwErr = GetLastError();

    ILS_CloseRegistryKey(hBlobKey);
    for (i = 0; i < BlobCount; i++) {
        _ltoa((long) i, szBlobN + KEY_BLOB_N_SUBKEY_PREFIX_LENGTH, 10);
        RegDeleteKeyA(hSubKey, szBlobN);
    }
    RegDeleteValueU(hSubKey, KEY_BLOB_COUNT_VALUE_NAME);
    RegDeleteValueU(hSubKey, KEY_BLOB_LENGTH_VALUE_NAME);

    fResult = FALSE;
    SetLastError(dwErr);
    goto CommonReturn;

SET_ERROR(UnexpectedError, E_UNEXPECTED)
SET_ERROR_VAR(RegCreateKeyError, err)
SET_ERROR_VAR(RegSetValueError, err)
TRACE_ERROR(WriteDWORDError)
}

//+-------------------------------------------------------------------------
//  If the SubKey has a "File" value, delete the file.
//
//  This is only applicable to obscure IE 4.0 cases.
//--------------------------------------------------------------------------
STATIC void DeleteKeyFile(
    IN HKEY hKey,
    IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
    IN DWORD dwFlags            // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    )
{
    HKEY hSubKey = NULL;

    if (ERROR_SUCCESS == OpenHKCUKeyExU(
            hKey,
            wszSubKeyName,
            dwFlags,
            KEY_ALL_ACCESS,
            &hSubKey
            )) {
        LPWSTR pwszFilename;
        if (pwszFilename = ILS_ReadSZValueFromRegistry(hSubKey,
                KEY_FILE_VALUE_NAME)) {
            SetFileAttributesU(pwszFilename, FILE_ATTRIBUTE_NORMAL);
            DeleteFileU(pwszFilename);
            PkiFree(pwszFilename);
        }
        RegDeleteValueU(hSubKey, KEY_FILE_VALUE_NAME);
        RegCloseKey(hSubKey);
    }
}

//+-------------------------------------------------------------------------
//  Get the context by either getting the SubKey's "Blob" value or getting
//  the SubKey's "BlobCount" and "BlobLength" values and then
//  reading and concatenating multiple Blob<N> SubKeys containing the bytes or
//  reading the file pointed to by the SubKey's "File" value.
//
//  If the "File" value is found and used, then, migrate to being stored
//  in the registry using multiple Blob<N> SubKeys.
//
//  If CERT_REGISTRY_STORE_REMOTE_FLAG is set, then, don't attempt to read
//  from the file.
//
//  If CERT_STORE_READONLY_FLAG is set, don't attempt to migrate from the
//  "File".
//--------------------------------------------------------------------------
STATIC BOOL ReadKeyElementFromRegistry(
        IN HKEY hKey,
        IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
        IN DWORD dwFlags,
        OUT BYTE **ppbElement,
        OUT DWORD *pcbElement
        )
{
    LONG err;
    BOOL fResult;
    BYTE *pbElement = NULL;
    DWORD cbElement;
    HKEY hSubKey = NULL;

    if (ERROR_SUCCESS != (err = OpenHKCUKeyExU(
            hKey,
            wszSubKeyName,
            dwFlags,
            KEY_READ,
            &hSubKey)))
        goto OpenHKCUKeyError;

    fResult = ILS_ReadBINARYValueFromRegistry(hSubKey, KEY_BLOB_VALUE_NAME,
         &pbElement, &cbElement);
    if (!fResult || 0 == cbElement) {
        PkiFree(pbElement);

        fResult = ReadMultipleKeyBlobsFromRegistry(hSubKey, dwFlags, &pbElement,
            &cbElement);
        if (!fResult && 0 == (dwFlags & CERT_REGISTRY_STORE_REMOTE_FLAG)) {
            // For backwards compatibility with IE4.0. See if it exists
            // in a file
            fResult = ReadKeyFileElementFromRegistry(hSubKey, dwFlags,
                &pbElement, &cbElement);
            if (fResult && 0 == (dwFlags & CERT_STORE_READONLY_FLAG)) {
                // Move from the file back to the registry.
                if (WriteMultipleKeyBlobsToRegistry(hSubKey, dwFlags, pbElement,
                        cbElement))
                    DeleteKeyFile(hKey, wszSubKeyName, dwFlags);
            }
        }

        if (!fResult)
            goto ReadKeyElementError;
    }

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    *ppbElement = pbElement;
    *pcbElement = cbElement;

    return fResult;
ErrorReturn:
    fResult = FALSE;
    PkiFree(pbElement);
    pbElement = NULL;
    cbElement = 0;
    goto CommonReturn;

SET_ERROR_VAR(OpenHKCUKeyError, err)
TRACE_ERROR(ReadKeyElementError)
}

STATIC BOOL ReadKeyFromRegistry(
        IN HKEY hKey,
        IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
        IN HCERTSTORE hCertStore,
        IN DWORD dwContextTypeFlags,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    BYTE *pbElement = NULL;
    DWORD cbElement;
    DWORD dwContextType = 0;
    const void *pvContext = NULL;

    if (!ReadKeyElementFromRegistry(
            hKey,
            wszSubKeyName,
            dwFlags,
            &pbElement,
            &cbElement
            ))
        goto ErrorReturn;

    if (!CertAddSerializedElementToStore(
            hCertStore,
            pbElement,
            cbElement,
            CERT_STORE_ADD_ALWAYS,
            0,                              // dwFlags
            dwContextTypeFlags,
            &dwContextType,
            &pvContext
            ))
        goto AddSerializedElementError;

    if (IsValidRegValueNameForContext(
            dwContextType,
            pvContext,
            wszSubKeyName
            ))
        FreeContext(dwContextType, pvContext);
    else {
        DeleteContextFromStore(dwContextType, pvContext);
        goto InvalidRegValueNameForContext;
    }

    CertPerfIncrementRegElementReadCount();

    fResult = TRUE;
CommonReturn:
    PkiFree(pbElement);

    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(AddSerializedElementError)
TRACE_ERROR(InvalidRegValueNameForContext)
}


//+-------------------------------------------------------------------------
//  Get the Certificates, CRLs or CTLs from the registry by reading as
//  SubKeys and not Key values as done by OpenFromRegistry.
//
//  If CERT_STORE_DELETE_FLAG is set, delete the file, if stored there.
//
//  If CERT_REGISTRY_STORE_REMOTE_FLAG is set, then, don't attempt to read
//  from the file.
//
//  If CERT_STORE_READONLY_FLAG is set, don't attempt to migrate from the
//  "File".
//--------------------------------------------------------------------------
STATIC BOOL OpenKeysFromRegistry(
    IN HCERTSTORE hCertStore,
    IN HKEY hKey,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    LONG err;
    DWORD cSubKeys;
    DWORD i;

    // see how many SubKeys in the registry
    if (!GetSubKeyInfo(hKey, &cSubKeys))
        goto GetSubKeyInfoError;

    for (i = 0; i < cSubKeys; i++) {
        WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN];
        DWORD cchSubKeyName = MAX_CERT_REG_VALUE_NAME_LEN;
        err = RegEnumKeyExU(
            hKey,
            i,
            wszSubKeyName,
            &cchSubKeyName,
            NULL,               // lpdwReserved
            NULL,               // lpszClass
            NULL,               // lpcchClass
            NULL                // lpftLastWriteTime
            );
        if (ERROR_SUCCESS != err) {
            if (ERROR_NO_MORE_ITEMS == err)
                break;
            else
                continue;
        } else if (dwFlags & CERT_STORE_DELETE_FLAG) {
            if (0 == (dwFlags & CERT_REGISTRY_STORE_REMOTE_FLAG))
                DeleteKeyFile(hKey, wszSubKeyName, dwFlags);
        } else
            // Ignore any read errors
            ReadKeyFromRegistry(
                hKey,
                wszSubKeyName,
                hCertStore,
                CERT_STORE_ALL_CONTEXT_FLAG,
                dwFlags
                );
    }
    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetSubKeyInfoError)
}

#if 0
//
// The following was done in IE4.0 on Win95
//

//+-------------------------------------------------------------------------
//  Create the filename to contain the encoded element. The filename will
//  be something like:
//      C:\Windows\SystemCertificates\
//          00112233445566778899AABBCCDDEEFF00112233.0011223344556677
//  Where:
//      C:\Windows              - obtained via GetWindowsDirectory
//      SystemCertificates      - subdirectory containing all file elements
//      00112233445566778899AABBCCDDEEFF00112233
//                              - wszSubKeyName (ascii hex sha1)
//      0011223344556677        - ascii hex of current filetime
//
//
//  In addition to creating the filename, also creates the
//  "SystemCertificates" directory under C:\Windows.
//--------------------------------------------------------------------------
STATIC LPWSTR CreateKeyFilename(
    IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
    IN LPFILETIME pft
    )
{
    LPWSTR pwszWindowsDir = NULL;
    DWORD cchWindowsDir;
    WCHAR rgwc[1];

    BYTE rgbft[sizeof(FILETIME)];
    WCHAR wszft[FILETIME_ASCII_HEX_LEN];

    LPWSTR pwszFilename = NULL;
    DWORD cchFilename;

    if (0 == (cchWindowsDir = GetWindowsDirectoryU(rgwc, 1)))
        goto GetWindowsDirError;
    cchWindowsDir++;    // bump to include null terminator
    if (NULL == (pwszWindowsDir = (LPWSTR) PkiNonzeroAlloc(
            cchWindowsDir * sizeof(WCHAR))))
        goto OutOfMemory;
    if (0 == GetWindowsDirectoryU(pwszWindowsDir, cchWindowsDir))
        goto GetWindowsDirError;

    // Convert filetime to ascii hex. First reverse the filetime bytes.
    memcpy(rgbft, pft, sizeof(rgbft));
    PkiAsn1ReverseBytes(rgbft, sizeof(rgbft));
    ILS_BytesToWStr(sizeof(rgbft), rgbft, wszft);

    // Get total length of filename and allocate
    cchFilename = cchWindowsDir + 1 +
        wcslen(SYSTEM_STORE_SUBDIR) + 1 +
        MAX_CERT_REG_VALUE_NAME_LEN + 1 +
        FILETIME_ASCII_HEX_LEN + 1;
    if (NULL == (pwszFilename = (LPWSTR) PkiNonzeroAlloc(
            cchFilename * sizeof(WCHAR))))
        goto OutOfMemory;

    // Create C:\Windows\SystemCertificates directory if it doesn't already
    // exist
    wcscpy(pwszFilename, pwszWindowsDir);
    cchWindowsDir = wcslen(pwszWindowsDir);
    if (cchWindowsDir && L'\\' != pwszWindowsDir[cchWindowsDir - 1])
        wcscat(pwszFilename, L"\\");
    wcscat(pwszFilename, SYSTEM_STORE_SUBDIR);
    if (0xFFFFFFFF == GetFileAttributesU(pwszFilename)) {
        if (!CreateDirectoryU(
            pwszFilename,
            NULL            // lpsa
            )) goto CreateDirError;
    }

    // Append \<AsciiHexSubKeyName>.<AsciiHexFileTime> to the above directory
    // name to complete the filename string
    wcscat(pwszFilename, L"\\");
    wcscat(pwszFilename, wszSubKeyName);
    wcscat(pwszFilename, L".");
    wcscat(pwszFilename, wszft);

CommonReturn:
    PkiFree(pwszWindowsDir);
    return pwszFilename;
ErrorReturn:
    PkiFree(pwszFilename);
    pwszFilename = NULL;
    goto CommonReturn;
TRACE_ERROR(GetWindowsDirError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreateDirError)
}

//+-------------------------------------------------------------------------
//  Write the bytes to a a file and update the SubKey's "File" value to
//  point to.
//
//  This code is here to show what was done in IE4.0.
//--------------------------------------------------------------------------
STATIC BOOL WriteKeyFileElementToRegistry(
    IN HKEY hSubKey,
    IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
    IN DWORD dwFlags,           // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    IN BYTE *pbElement,
    IN DWORD cbElement
    )
{
    BOOL fResult;
    LONG err;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    LPWSTR pwszFilename = NULL;
    SYSTEMTIME st;
    FILETIME ft;
    DWORD i;

    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    for (i = 0; i < MAX_NEW_FILE_CREATE_ATTEMPTS; i++) {
        DWORD cbBytesWritten;

        if (NULL == (pwszFilename = CreateKeyFilename(wszSubKeyName, &ft)))
            goto CreateKeyFilenameError;

        if (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
                  pwszFilename,
                  GENERIC_WRITE,
                  0,                        // fdwShareMode
                  NULL,                     // lpsa
                  CREATE_NEW,
                  FILE_ATTRIBUTE_NORMAL |
                    ((dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) ?
                        FILE_FLAG_BACKUP_SEMANTICS : 0),  
                  NULL                      // hTemplateFile
                  ))) {
            if (ERROR_FILE_EXISTS != GetLastError())
                goto CreateFileError;
            else {
                PkiFree(pwszFilename);
                pwszFilename = NULL;
                *((_int64 *) &ft) += 1;
                continue;
            }
        }

        if (!WriteFile(
                hFile,
                pbElement,
                cbElement,
                &cbBytesWritten,
                NULL            // lpOverlapped
                )) goto WriteFileError;

        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
        if (!SetFileAttributesU(pwszFilename,
                FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY ))
            goto SetFileAttributesError;

        if (ERROR_SUCCESS != (err = RegSetValueExU(
                hSubKey,
                KEY_FILE_VALUE_NAME,
                NULL,
                REG_SZ,
                (BYTE *) pwszFilename,
                (wcslen(pwszFilename) + 1) * sizeof(WCHAR))))
            goto RegSetValueError;
        else
            goto SuccessReturn;
    }

    goto ExceededMaxFileCreateAttemptsError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    if (INVALID_HANDLE_VALUE != hFile)
        ILS_CloseHandle(hFile);
    PkiFree(pwszFilename);

    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegSetValueError, err)
TRACE_ERROR(CreateKeyFilenameError)
TRACE_ERROR(CreateFileError)
TRACE_ERROR(WriteFileError)
TRACE_ERROR(SetFileAttributesError)
SET_ERROR(ExceededMaxFileCreateAttemptsError, CRYPT_E_FILE_ERROR)

}

#endif  // end of IE4.0 "File" support

//+-------------------------------------------------------------------------
//  If the length of the element is <= MAX_KEY_BLOB_VALUE_LEN, then,
//  write it as the SubKey's "Blob" value. Otherwise, write it as multiple
//  SubKeys each containing a "Blob" value no larger than
//  MAX_KEY_BLOB_VALUE_LEN.
//--------------------------------------------------------------------------
STATIC BOOL WriteKeyToRegistry(
        IN HKEY hKey,
        IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
        IN DWORD dwFlags,       //  CERT_STORE_BACKUP_RESTORE_FLAG may be set
        IN const BYTE *pbElement,
        IN DWORD cbElement
        )
{
    BOOL fResult;
    LONG err;
    HKEY hSubKey = NULL;
    DWORD dwDisposition;

    if (ERROR_SUCCESS != (err = RegCreateHKCUKeyExU(
            hKey,
            wszSubKeyName,
            NULL,
            NULL,
            (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) ?
                REG_OPTION_BACKUP_RESTORE : REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hSubKey,
            &dwDisposition))) goto RegCreateKeyError;

    if (MAX_KEY_BLOB_VALUE_LEN >= cbElement) {
        // Write as a single "Blob" value
        if (ERROR_SUCCESS != (err = RegSetValueExU(
                hSubKey,
                KEY_BLOB_VALUE_NAME,
                NULL,
                REG_BINARY,
                pbElement,
                cbElement))) goto RegSetValueError;
    } else {
        // Write as a multiple Blob<N> SubKeys
        if (!WriteMultipleKeyBlobsToRegistry(
                hSubKey, dwFlags, pbElement, cbElement))
            goto WriteMultipleKeyBlobsError;
//        if (!WriteKeyFileElementToRegistry(wszSubKeyName, hSubKey, dwFlags, pbElement, cbElement))
//            goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegCreateKeyError, err)
SET_ERROR_VAR(RegSetValueError, err)
TRACE_ERROR(WriteMultipleKeyBlobsError)
}

//+=========================================================================
//  Registry Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  First attempt to read as Key's value. If that fails for Win95, then,
//  read as a value in one or more SubKeys or as a
//  file with a SubKey pointing to it.
//
//  If CERT_REGISTRY_STORE_REMOTE_FLAG is set, then, don't attempt to read
//  from the file.
//
//  If CERT_STORE_READONLY_FLAG is set, don't attempt to migrate from the
//  "File".
//--------------------------------------------------------------------------
BOOL
ILS_ReadElementFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    )
{
    LONG err;
    BOOL fResult;
    HKEY hSubKey = NULL;
    DWORD dwType;
    BYTE *pbElement = NULL;
    DWORD cbElement;

    if (pwszContextName) {
        if (NULL == (hSubKey = OpenSubKey(
                hKey,
                pwszContextName,
                dwFlags | CERT_STORE_READONLY_FLAG
                )))
            goto OpenSubKeyError;
    } else
        hSubKey = hKey;

    err = RegQueryValueExU(
            hSubKey,
            wszHashName,
            NULL,       // pdwReserved
            &dwType,
            NULL,       // lpData
            &cbElement);
    // For Win95 Remote Registry Access:: returns ERROR_MORE_DATA
    if (!(ERROR_SUCCESS == err || ERROR_MORE_DATA == err)) {
        fResult = ReadKeyElementFromRegistry(
            hSubKey,
            wszHashName,
            dwFlags,
            &pbElement,
            &cbElement
            );
        goto CommonReturn;
    }
    if (dwType != REG_BINARY || cbElement == 0)
        goto InvalidRegistryValue;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;
    if (ERROR_SUCCESS != (err = RegQueryValueExU(
            hSubKey,
            wszHashName,
            NULL,       // pdwReserved
            &dwType,
            pbElement,
            &cbElement))) goto RegQueryValueError;

    fResult = TRUE;
CommonReturn:
    if (pwszContextName)
        ILS_CloseRegistryKey(hSubKey);
    *ppbElement = pbElement;
    *pcbElement = cbElement;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    PkiFree(pbElement);
    pbElement = NULL;
    cbElement = 0;
    goto CommonReturn;

TRACE_ERROR(OpenSubKeyError)
SET_ERROR_VAR(RegQueryValueError, err)
SET_ERROR(InvalidRegistryValue, CRYPT_E_FILE_ERROR)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  First delete as the Key's value. Then, for Win95 also delete as the
//  Key's SubKey and possibly file.
//--------------------------------------------------------------------------
BOOL
ILS_DeleteElementFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    HKEY hSubKey = NULL;

    if (NULL == (hSubKey = OpenSubKey(
            hKey,
            pwszContextName,
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG
            )))
        goto OpenSubKeyError;

    RegDeleteValueU(hSubKey, wszHashName);
    if (0 == (dwFlags & CERT_REGISTRY_STORE_REMOTE_FLAG))
        DeleteKeyFile(hSubKey, wszHashName, dwFlags);
    fResult = RecursiveDeleteSubKey(hSubKey, wszHashName, dwFlags);

CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OpenSubKeyError)
}

//+-------------------------------------------------------------------------
//  If the length of the element is less than the maximum allowed Win95 value
//  length, then, attempt to set the wszRegName SubKey's "Blob" value as
//  a single registry API call. Versus, first doing registry deletes.
//--------------------------------------------------------------------------
STATIC BOOL AtomicUpdateRegistry(
        IN HKEY hKey,
        IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
        IN DWORD dwFlags,       // CERT_STORE_BACKUP_RESTORE_FLAG may be set
        IN const BYTE *pbElement,
        IN DWORD cbElement
        )
{
    BOOL fResult;
    LONG err;
    HKEY hSubKey = NULL;
    DWORD dwDisposition = 0;

    if (MAX_KEY_BLOB_VALUE_LEN < cbElement)
        return FALSE;

    // In case the element still exists as a wszHashName value instead of as a
    // wszHashName subkey
    RegDeleteValueU(hKey, wszHashName);

    if (ERROR_SUCCESS != (err = RegCreateHKCUKeyExU(
            hKey,
            wszHashName,
            NULL,
            NULL,
            (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) ?
                REG_OPTION_BACKUP_RESTORE : REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hSubKey,
            &dwDisposition))) goto AtomicRegCreateKeyError;

    if (REG_OPENED_EXISTING_KEY == dwDisposition) {
        DWORD dwType;
        DWORD cbData;

        assert(hSubKey);
        err = RegQueryValueExU(
            hSubKey,
            KEY_BLOB_VALUE_NAME,
            NULL,       // pdwReserved
            &dwType,
            NULL,       // lpData
            &cbData);
        if (!(ERROR_SUCCESS == err || ERROR_MORE_DATA == err))
            // Most likely persisted as partioned "Blob0", "Blob1" values.
            // These can't be updated in a single atomic set value.
            goto AtomicQueryValueError;

        // "Blob" value exists. We can do an atomic update.
    }
    // else
    //  REG_CREATED_NEW_KEY

    assert(hSubKey);
    // Either update or create the "Blob" value
    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hSubKey,
            KEY_BLOB_VALUE_NAME,
            NULL,
            REG_BINARY,
            pbElement,
            cbElement))) goto AtomicRegSetValueError;
    fResult = TRUE;

CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(AtomicRegCreateKeyError, err)
SET_ERROR_VAR(AtomicQueryValueError, err)
SET_ERROR_VAR(AtomicRegSetValueError, err)
}

//+-------------------------------------------------------------------------
//  First attempt as an atomic registry update of the wszRegName's "Blob"
//  value. If that fails, then, delete everything and write as either a
//  single or partitioned blob value under the wszRegName's subkey.
//--------------------------------------------------------------------------
BOOL
ILS_WriteElementToRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,       //  CERT_REGISTRY_STORE_REMOTE_FLAG or
                            //  CERT_STORE_BACKUP_RESTORE_FLAG may be set
    IN const BYTE *pbElement,
    IN DWORD cbElement
    )
{
    BOOL fResult;
    HKEY hSubKey = NULL;

    if (NULL == (hSubKey = OpenSubKey(
            hKey,
            pwszContextName,
            dwFlags
            )))
        goto OpenSubKeyError;

    // See if we can do the update as a single, atomic, set registry value API
    // call.
    if (AtomicUpdateRegistry(
            hSubKey,
            wszHashName,
            dwFlags,
            pbElement,
            cbElement
            )) {
        fResult = TRUE;
        goto CommonReturn;
    }

    // If any version exists for this guy, get rid of it.
    ILS_DeleteElementFromRegistry(hKey, pwszContextName, wszHashName,
        dwFlags);

#if 1
    fResult = WriteKeyToRegistry(hSubKey, wszHashName, dwFlags,
        pbElement, cbElement);
#else
    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hSubKey,
            wszHashName,
            NULL,
            REG_BINARY,
            pbElement,
            cbElement))) {
        // Win95 returns:
        //  ERROR_INVALID_PARAMETER if exceeded single SubKey value byte
        //      limitation
        //  ERROR_OUTOFMEMORY if exceeded total SubKey values byte
        //      limitation
        if (ERROR_INVALID_PARAMETER == err ||
                ERROR_OUTOFMEMORY == err ||
                MAX_KEY_BLOB_VALUE_LEN < cbElement)
            return WriteKeyToRegistry(hSubKey, wszHashName, dwFlags,
                pbElement, cbElement);

         goto RegSetValueError;
    }
    fResult = TRUE;
#endif

CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenSubKeyError)
#if 1
#else
SET_ERROR_VAR(RegSetValueError, err)
#endif
}

BOOL
ILS_OpenAllElementsFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszContextName,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_ILS_OPEN_ELEMENT pfnOpenElement
    )
{
    BOOL fResult;
    HKEY hSubKey = NULL;
    LONG err;
    DWORD cSubKeys;
    DWORD i;

    dwFlags |= CERT_STORE_READONLY_FLAG;

    if (NULL == (hSubKey = OpenSubKey(
            hKey,
            pwszContextName,
            dwFlags
            )))
        goto OpenSubKeyError;

    // see how many SubKeys in the registry
    if (!GetSubKeyInfo(hSubKey, &cSubKeys))
        goto GetSubKeyInfoError;

    for (i = 0; i < cSubKeys; i++) {
        WCHAR wszHashName[MAX_HASH_NAME_LEN];
        DWORD cchHashName = MAX_HASH_NAME_LEN;
        BYTE *pbElement;
        DWORD cbElement;

        err = RegEnumKeyExU(
            hSubKey,
            i,
            wszHashName,
            &cchHashName,
            NULL,               // lpdwReserved
            NULL,               // lpszClass
            NULL,               // lpcchClass
            NULL                // lpftLastWriteTime
            );
        if (ERROR_SUCCESS != err) {
            if (ERROR_NO_MORE_ITEMS == err)
                break;
            else
                continue;
        }

        if (ILS_ReadElementFromRegistry(
                hSubKey,
                NULL,                   // pwszContextName
                wszHashName,
                dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG,
                &pbElement,
                &cbElement
                )) {
            fResult = pfnOpenElement(
                wszHashName,
                pbElement,
                cbElement,
                pvArg
                );

            PkiFree(pbElement);
            if (!fResult)
                goto CommonReturn;
        }
    }
    fResult = TRUE;

CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetSubKeyInfoError)
TRACE_ERROR(OpenSubKeyError)
}

//+-------------------------------------------------------------------------
//  Get the Certificates, CRLs or CTLs from the registry
//
//  If CERT_REGISTRY_STORE_REMOTE_FLAG is set, then, don't attempt to read
//  from the file.
//
//  If CERT_STORE_READONLY_FLAG is set, don't attempt to migrate from the
//  "File".
//
//  If any contexts are persisted as values instead of as subkeys, then,
//  if not READONLY, migrate from values to subkeys.
//--------------------------------------------------------------------------
STATIC BOOL OpenFromRegistry(
    IN HCERTSTORE hCertStore,
    IN HKEY hKeyT,
    IN DWORD dwFlags
    )
{
    BOOL    fOK = TRUE;
    LONG    err;
    DWORD   cValues, cchValuesNameMax, cbValuesMax;
    WCHAR * wszValueName = NULL;
    DWORD   i, dwType, cchHash;
    BYTE  * pbElement = NULL;
    DWORD   cbElement;

    // see how many and how big the registry is
    if (ERROR_SUCCESS != (err = RegQueryInfoKeyU(
            hKeyT,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            &cValues,
            &cchValuesNameMax,
            &cbValuesMax,
            NULL,
            NULL))) goto RegQueryInfoKeyError;


    if (cValues && cbValuesMax) {
        // allocate the memory needed to read the reg
        // Remote Registry calls on Win95 includes the NULL terminator, that's
        // why we add +2 and not just +1
        if (NULL == (wszValueName = (WCHAR *) PkiNonzeroAlloc(
                (cchValuesNameMax+2) * sizeof(WCHAR))))
            goto OutOfMemory;
        if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbValuesMax)))
            goto OutOfMemory;

        // enum the registry getting certs, CRLs or CTLs
        for (i=0; i<cValues; i++ ) {
            cbElement = cbValuesMax;
            // Remote Registry calls on Win95 includes the NULL terminator
            cchHash = cchValuesNameMax + 2;
            err = RegEnumValueU( hKeyT,
                                i,
                                wszValueName,
                                &cchHash,
                                NULL,
                                &dwType,
                                pbElement,
                                &cbElement);
            // any error get it set
            // but we want to continue to get all good certs
            if( err != ERROR_SUCCESS )
                continue;
            else {
                fOK &= CertAddSerializedElementToStore(
                    hCertStore,
                    pbElement,
                    cbElement,
                    CERT_STORE_ADD_ALWAYS,
                    0,                              // dwFlags
                    CERT_STORE_ALL_CONTEXT_FLAG,
                    NULL,                           // pdwContextType
                    NULL);                          // ppvContext

                CertPerfIncrementRegElementReadCount();
            }
        }

    }

    fOK &= OpenKeysFromRegistry(hCertStore, hKeyT, dwFlags);

    if (cValues && cbValuesMax && fOK &&
            0 == (dwFlags & CERT_STORE_READONLY_FLAG)) {
        // Migrate from values to subkeys. This allows registry roaming
        // from NT to Win95 without exceeding the Win95 registry
        // limitations

        HKEY hSubKey = NULL;
        while (TRUE) {
            if (NULL == (hSubKey = OpenSubKey(
                    hKeyT,
                    NULL,       // pwszSubKey
                    CERT_STORE_OPEN_EXISTING_FLAG |
                        (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
                    )))
                break;

            cbElement = cbValuesMax;
            // Remote Registry calls on Win95 includes the NULL terminator
            cchHash = cchValuesNameMax + 2;
            if (ERROR_SUCCESS != RegEnumValueU(
                    hSubKey,
                    0,                  // iValue
                    wszValueName,
                    &cchHash,
                    NULL,
                    &dwType,
                    pbElement,
                    &cbElement))
                break;

            if (!WriteKeyToRegistry(hSubKey, wszValueName, dwFlags,
                    pbElement, cbElement))
                break;
            if (ERROR_SUCCESS != RegDeleteValueU(hSubKey, wszValueName))
                break;
            RegCloseKey(hSubKey);
        }

        if (hSubKey)
            RegCloseKey(hSubKey);
    }

CommonReturn:
    // done with our memory
    PkiFree(wszValueName);
    PkiFree(pbElement);

    return fOK;
ErrorReturn:
    fOK = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(RegQueryInfoKeyError, err)
TRACE_ERROR(OutOfMemory)
}


STATIC BOOL MoveFromRegistryToRoamingFiles(
    IN HKEY hSubKey,
    IN LPCWSTR pwszStoreDirectory,
    IN LPCWSTR pwszContextName,
    IN DWORD dwFlags            // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    )
{
    BYTE *pbElement = NULL;
    DWORD cbElement;

    while (TRUE) {
        WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN];
        DWORD cchSubKeyName = MAX_CERT_REG_VALUE_NAME_LEN;

        if (ERROR_SUCCESS != RegEnumKeyExU(
                hSubKey,
                0,
                wszSubKeyName,
                &cchSubKeyName,
                NULL,               // lpdwReserved
                NULL,               // lpszClass
                NULL,               // lpcchClass
                NULL                // lpftLastWriteTime
                ))
            break;

        if (!ILS_ReadElementFromRegistry(
                hSubKey,
                NULL,               // pwszContextName
                wszSubKeyName,
                CERT_STORE_READONLY_FLAG |
                    (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG),
                &pbElement,
                &cbElement
                ))
            goto ReadElementFromRegistryError;

        if (!ILS_WriteElementToFile(
                pwszStoreDirectory,
                pwszContextName,
                wszSubKeyName,
                CERT_STORE_CREATE_NEW_FLAG |
                    (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG),
                pbElement,
                cbElement
                )) {
            if (ERROR_FILE_EXISTS != GetLastError())
                goto WriteElementToFileError;
        }

        PkiFree(pbElement);
        pbElement = NULL;

        if (!RecursiveDeleteSubKey(
                hSubKey,
                wszSubKeyName,
                dwFlags
                ))
            goto DeleteSubKeyError;
    }

CommonReturn:
    return TRUE;
ErrorReturn:
    PkiFree(pbElement);
    goto CommonReturn;

TRACE_ERROR(ReadElementFromRegistryError)
TRACE_ERROR(WriteElementToFileError)
TRACE_ERROR(DeleteSubKeyError)
}


typedef struct _READ_CONTEXT_CALLBACK_ARG {
    BOOL                        fOK;
    HCERTSTORE                  hCertStore;
} READ_CONTEXT_CALLBACK_ARG, *PREAD_CONTEXT_CALLBACK_ARG;

STATIC BOOL ReadContextCallback(
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN const BYTE *pbElement,
    IN DWORD cbElement,
    IN void *pvArg
    )
{
    BOOL fResult;
    PREAD_CONTEXT_CALLBACK_ARG pReadContextArg =
        (PREAD_CONTEXT_CALLBACK_ARG) pvArg;
    DWORD dwContextType = 0;
    const void *pvContext = NULL;

    fResult = CertAddSerializedElementToStore(
            pReadContextArg->hCertStore,
            pbElement,
            cbElement,
            CERT_STORE_ADD_ALWAYS,
            0,                              // dwFlags
            CERT_STORE_ALL_CONTEXT_FLAG,
            &dwContextType,
            &pvContext
            );

    if (fResult) {
        if (IsValidRegValueNameForContext(
                dwContextType,
                pvContext,
                wszHashName
                ))
            FreeContext(dwContextType, pvContext);
        else {
            DeleteContextFromStore(dwContextType, pvContext);
            pReadContextArg->fOK = FALSE;
        }
    } else
        pReadContextArg->fOK = FALSE;


    CertPerfIncrementRegElementReadCount();

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Get all the Certificates, CRLs and CTLs from the registry
//--------------------------------------------------------------------------
STATIC BOOL OpenAllFromRegistry(
    IN PREG_STORE pRegStore,
    IN HCERTSTORE hCertStore
    )
{
    BOOL fResult;
    HKEY hSubKey = NULL;
    DWORD i;

    for (i = 0; i < CONTEXT_COUNT; i++) {
        if (pRegStore->hKey) {
            if (NULL == (hSubKey = OpenSubKey(
                    pRegStore->hKey,
                    rgpwszContextSubKeyName[i],
                    pRegStore->dwFlags
                    ))) {
                if (ERROR_FILE_NOT_FOUND != GetLastError())
                    goto OpenSubKeyError;
            } else {
                // Ignore any registry errors
                OpenFromRegistry(hCertStore, hSubKey, pRegStore->dwFlags);
            }
        }

        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG) {
            READ_CONTEXT_CALLBACK_ARG ReadContextArg;

            ReadContextArg.fOK = TRUE;
            ReadContextArg.hCertStore = hCertStore;

            if (!ILS_OpenAllElementsFromDirectory(
                    pRegStore->pwszStoreDirectory,
                    rgpwszContextSubKeyName[i],
                    pRegStore->dwFlags,
                    (void *) &ReadContextArg,
                    ReadContextCallback
                    )) {
                DWORD dwErr = GetLastError();
                if (!(ERROR_PATH_NOT_FOUND == dwErr ||
                        ERROR_FILE_NOT_FOUND == dwErr))
                    goto OpenRoamingFilesError;
            }
            // Ignore any read context errors

            if (hSubKey &&
                    0 == (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)) {
                MoveFromRegistryToRoamingFiles(
                    hSubKey,
                    pRegStore->pwszStoreDirectory,
                    rgpwszContextSubKeyName[i],
                    pRegStore->dwFlags
                    );
            }
        }

        if (hSubKey) {
            ILS_CloseRegistryKey(hSubKey);
            hSubKey = NULL;
        }
    }

    if ((pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG) &&
            pRegStore->hKey &&
            0 == (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)) {
        // Move the Key Identifiers from the registry to roaming files
        if (hSubKey = OpenSubKey(
                pRegStore->hKey,
                KEYID_CONTEXT_NAME,
                pRegStore->dwFlags
                )) {
            MoveFromRegistryToRoamingFiles(
                hSubKey,
                pRegStore->pwszStoreDirectory,
                KEYID_CONTEXT_NAME,
                pRegStore->dwFlags
                );

            ILS_CloseRegistryKey(hSubKey);
            hSubKey = NULL;
        }
    }

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    ILS_CloseRegistryKey(hSubKey);
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenSubKeyError)
TRACE_ERROR(OpenRoamingFilesError)
}

//+-------------------------------------------------------------------------
//  Delete all the Certificates, CRLs and CTLs context subkeys. For Win95
//  also delete context files.
//
//  Also, if it exists, delete the "Serialized" subkey.
//--------------------------------------------------------------------------
STATIC BOOL DeleteAllFromRegistry(
    IN HKEY hKey,
    IN DWORD dwFlags        //  CERT_REGISTRY_STORE_REMOTE_FLAG or
                            //  CERT_STORE_BACKUP_RESTORE_FLAG may be set
    )
{
    BOOL fResult;
    DWORD i;

    for (i = 0; i < CONTEXT_COUNT; i++) {
        LPCWSTR pwszSubKeyName = rgpwszContextSubKeyName[i];
        if (0 == (dwFlags & CERT_REGISTRY_STORE_REMOTE_FLAG)) {
            // For WIN95, if a context is stored in a file, delete the
            // file
            HKEY hSubKey;
            if (NULL == (hSubKey = OpenSubKey(
                    hKey,
                    pwszSubKeyName,
                    CERT_STORE_OPEN_EXISTING_FLAG |
                        (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
                    ))) {
                if (ERROR_FILE_NOT_FOUND != GetLastError())
                    goto OpenContextSubKeyError;
                continue;
            }
            fResult = OpenKeysFromRegistry(
                NULL,       // hCertStore
                hSubKey,
                dwFlags
                );
            ILS_CloseRegistryKey(hSubKey);
            if (!fResult)
                goto DeleteKeysError;
        }

        if (!RecursiveDeleteSubKey(hKey, pwszSubKeyName, dwFlags)) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                goto DeleteSubKeyError;
        }
    }

    if (!RecursiveDeleteSubKey(hKey, SERIALIZED_SUBKEY_NAME, dwFlags)) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            goto DeleteSubKeyError;
    }


    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenContextSubKeyError)
TRACE_ERROR(DeleteKeysError)
TRACE_ERROR(DeleteSubKeyError)
}



//+=========================================================================
//  Serialized Registry Functions
//==========================================================================

static inline BOOL IsReadSerializedRegistry(
    IN PREG_STORE pRegStore
    )
{
    return (pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG);
}

static inline BOOL IsWriteSerializedRegistry(
    IN PREG_STORE pRegStore
    )
{
    if (0 == (pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG))
        return FALSE;

    pRegStore->fTouched = TRUE;
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Get all the Certificates, CRLs and CTLs from a single serialized
//  partitioned "blob" stored in the registry. The "blob" is stored under
//  the "Serialized" subkey.
//
//  Either called during initial open or with RegStore locked.
//--------------------------------------------------------------------------
STATIC BOOL OpenAllFromSerializedRegistry(
    IN PREG_STORE pRegStore,
    IN HCERTSTORE hCertStore
    )
{
    BOOL fResult;
    HKEY hSubKey = NULL;
    BYTE *pbStore = NULL;
    DWORD cbStore;

    assert(pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG);

    if (NULL == (hSubKey = OpenSubKey(
            pRegStore->hKey,
            SERIALIZED_SUBKEY_NAME,
            pRegStore->dwFlags
            )))
        goto OpenSubKeyError;

    if (!ReadMultipleKeyBlobsFromRegistry(
            hSubKey,
            pRegStore->dwFlags,
            &pbStore,
            &cbStore
            ))
        goto ReadError;

    if (!I_CertAddSerializedStore(
            hCertStore,
            pbStore,
            cbStore
            ))
        goto AddError;

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    PkiFree(pbStore);
    return fResult;
ErrorReturn:
    if (ERROR_FILE_NOT_FOUND == GetLastError())
        fResult = TRUE;
    else
        fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenSubKeyError)
TRACE_ERROR(ReadError)
TRACE_ERROR(AddError)
}


//+=========================================================================
//  Serialized Control Functions
//==========================================================================

STATIC BOOL IsEmptyStore(
    IN HCERTSTORE hCertStore
    )
{
    PCCERT_CONTEXT pCert;
    PCCRL_CONTEXT pCrl;
    PCCTL_CONTEXT pCtl;

    if (pCert = CertEnumCertificatesInStore(hCertStore, NULL)) {
        CertFreeCertificateContext(pCert);
        return FALSE;
    }

    if (pCrl = CertEnumCRLsInStore(hCertStore, NULL)) {
        CertFreeCRLContext(pCrl);
        return FALSE;
    }

    if (pCtl = CertEnumCTLsInStore(hCertStore, NULL)) {
        CertFreeCTLContext(pCtl);
        return FALSE;
    }

    return TRUE;

}

STATIC BOOL CommitAllToSerializedRegistry(
    IN PREG_STORE pRegStore,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    BOOL fTouched;
    CRYPT_DATA_BLOB SerializedData = {0, NULL};
    HKEY hSubKey = NULL;

    LockRegStore(pRegStore);

    assert(pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG);

    if (dwFlags & CERT_STORE_CTRL_COMMIT_FORCE_FLAG)
        fTouched = TRUE;
    else if (dwFlags & CERT_STORE_CTRL_COMMIT_CLEAR_FLAG)
        fTouched = FALSE;
    else
        fTouched = pRegStore->fTouched;

    if (fTouched) {
        BOOL fEmpty;

        if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
            goto AccessDenied;

        fEmpty = IsEmptyStore(pRegStore->hCertStore);
        if (!fEmpty) {
            if (!CertSaveStore(
                    pRegStore->hCertStore,
                    0,                      // dwEncodingType
                    CERT_STORE_SAVE_AS_STORE,
                    CERT_STORE_SAVE_TO_MEMORY,
                    &SerializedData,
                    0))                     // dwFlags
                goto SaveStoreError;
            assert(SerializedData.cbData);
            if (NULL == (SerializedData.pbData = (BYTE *) PkiNonzeroAlloc(
                    SerializedData.cbData)))
                goto OutOfMemory;
            if (!CertSaveStore(
                    pRegStore->hCertStore,
                    0,                      // dwEncodingType
                    CERT_STORE_SAVE_AS_STORE,
                    CERT_STORE_SAVE_TO_MEMORY,
                    &SerializedData,
                    0))                     // dwFlags
                goto SaveStoreError;
        }

        if (!RecursiveDeleteSubKey(
                pRegStore->hKey, SERIALIZED_SUBKEY_NAME, pRegStore->dwFlags)) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                goto DeleteSubKeyError;
        }

        if (!fEmpty) {
            if (NULL == (hSubKey = OpenSubKey(
                    pRegStore->hKey,
                    SERIALIZED_SUBKEY_NAME,
                    pRegStore->dwFlags
                    )))
                goto OpenSubKeyError;

            if (!WriteMultipleKeyBlobsToRegistry(
                    hSubKey,
                    pRegStore->dwFlags,
                    SerializedData.pbData,
                    SerializedData.cbData
                    ))
                goto WriteStoreError;
        }
    }
    pRegStore->fTouched = FALSE;
    fResult = TRUE;

CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    PkiFree(SerializedData.pbData);
    UnlockRegStore(pRegStore);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(SaveStoreError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DeleteSubKeyError)
TRACE_ERROR(OpenSubKeyError)
TRACE_ERROR(WriteStoreError)
}


//+-------------------------------------------------------------------------
//  Open the registry's store by reading its serialized certificates,
//  CRLs and CTLs and adding to the specified certificate store.
//
//  Note for an error return, the caller will free any certs, CRLs or CTLs
//  successfully added to the store.
//
//  Only return HKEY for success. For a CertOpenStore error the caller
//  will close the HKEY.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenRegStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    HKEY hKey = (HKEY) pvPara;
    PREG_STORE pRegStore = NULL;
    DWORD dwErr;

    assert(hKey);

    if (dwFlags & ~OPEN_REG_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    if (dwFlags & CERT_STORE_DELETE_FLAG) {
        if (DeleteAllFromRegistry(hKey, dwFlags)) {
            pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_DELETED_FLAG;
            return TRUE;
        } else
            return FALSE;
    }


    if (NULL == (pRegStore = (PREG_STORE) PkiZeroAlloc(sizeof(REG_STORE))))
        goto OutOfMemory;
    if (!Pki_InitializeCriticalSection(&pRegStore->CriticalSection)) {
        PkiFree(pRegStore);
        pRegStore = NULL;
        goto OutOfMemory;
    }
    pRegStore->hCertStore = hCertStore;
    pRegStore->dwFlags = dwFlags;

    CertPerfIncrementStoreRegTotalCount();
    CertPerfIncrementStoreRegCurrentCount();

    if (dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
        PCERT_REGISTRY_STORE_CLIENT_GPT_PARA pGptPara =
            (PCERT_REGISTRY_STORE_CLIENT_GPT_PARA) pvPara;
        DWORD cbRegPath = (wcslen(pGptPara->pwszRegPath) + 1) * sizeof(WCHAR);

        if (NULL == (pRegStore->GptPara.pwszRegPath =
                (LPWSTR) PkiNonzeroAlloc(cbRegPath)))
            goto OutOfMemory;
        memcpy(pRegStore->GptPara.pwszRegPath, pGptPara->pwszRegPath,
            cbRegPath);

        // Make a copy of the base hKey
        // BUG in NT4.0 and NT5.0. Doesn't support opening of the HKLM with
        // a NULL pwszSubKey
        if (HKEY_LOCAL_MACHINE == pGptPara->hKeyBase)
            pRegStore->GptPara.hKeyBase = HKEY_LOCAL_MACHINE;
        else if (NULL == (pRegStore->GptPara.hKeyBase = OpenSubKey(
                pGptPara->hKeyBase,
                NULL,       // pwszSubKey
                (dwFlags & ~CERT_STORE_CREATE_NEW_FLAG) |
                    CERT_STORE_OPEN_EXISTING_FLAG
                )))
            goto OpenSubKeyError;

        fResult = OpenAllFromGptRegistry(pRegStore,
            pRegStore->hCertStore);

#if 1
        // For subsequent opens, allow subkey create if it doesn't already
        // exist.
        pRegStore->dwFlags &= ~(CERT_STORE_OPEN_EXISTING_FLAG |
            CERT_STORE_CREATE_NEW_FLAG);
#else

        // For subsequent opens, allow subkey create if it doesn't already
        // exist. However, preserve open existing.
        pRegStore->dwFlags &= ~CERT_STORE_CREATE_NEW_FLAG;
#endif

    } else if (dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG) {
        PCERT_REGISTRY_STORE_ROAMING_PARA pRoamingPara =
            (PCERT_REGISTRY_STORE_ROAMING_PARA) pvPara;
        DWORD cbDir = (wcslen(pRoamingPara->pwszStoreDirectory) + 1) *
            sizeof(WCHAR);

        if (NULL == (pRegStore->pwszStoreDirectory = (LPWSTR) PkiNonzeroAlloc(
                cbDir)))
            goto OutOfMemory;
        memcpy(pRegStore->pwszStoreDirectory, pRoamingPara->pwszStoreDirectory,
            cbDir);

        dwFlags &= ~CERT_STORE_CREATE_NEW_FLAG;
        dwFlags |= CERT_STORE_OPEN_EXISTING_FLAG;
        pRegStore->dwFlags = dwFlags;
        if (pRoamingPara->hKey) {
            // Make a copy of the input hKey
            if (NULL == (pRegStore->hKey = OpenSubKey(
                    pRoamingPara->hKey,
                    NULL,       // pwszSubKey
                    dwFlags
                    )))
                goto OpenSubKeyError;
        }

        fResult = OpenAllFromRegistry(pRegStore, pRegStore->hCertStore);
    } else {
        // Make a copy of the input hKey
        if (NULL == (pRegStore->hKey = OpenSubKey(
                hKey,
                NULL,       // pwszSubKey
                (dwFlags & ~CERT_STORE_CREATE_NEW_FLAG) |
                    CERT_STORE_OPEN_EXISTING_FLAG
                )))
            goto OpenSubKeyError;

        if (dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG)
            fResult = OpenAllFromSerializedRegistry(pRegStore,
                pRegStore->hCertStore);
        else
            fResult = OpenAllFromRegistry(pRegStore, pRegStore->hCertStore);

        // For subsequent opens, allow subkey create if it doesn't already
        // exist.
        pRegStore->dwFlags &= ~(CERT_STORE_OPEN_EXISTING_FLAG |
            CERT_STORE_CREATE_NEW_FLAG);
    }
    if (!fResult)
        goto OpenAllError;


    pStoreProvInfo->cStoreProvFunc = REG_STORE_PROV_FUNC_COUNT;
    pStoreProvInfo->rgpvStoreProvFunc = (void **) rgpvRegStoreProvFunc;
    pStoreProvInfo->hStoreProv = (HCERTSTOREPROV) pRegStore;
    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    dwErr = GetLastError();
    RegStoreProvClose((HCERTSTOREPROV) pRegStore, 0);
    SetLastError(dwErr);

    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(OpenSubKeyError)
TRACE_ERROR(OpenAllError)
}


//+-------------------------------------------------------------------------
//  Close the registry's store by closing its opened registry subkeys
//--------------------------------------------------------------------------
STATIC void WINAPI RegStoreProvClose(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags
        )
{
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    if (pRegStore) {
        CertPerfDecrementStoreRegCurrentCount();

        FreeRegistryStoreChange(pRegStore);

        if (hWin95NotifyEvent)
            Win95StoreSignalAndFreeRegStoreResyncEntries(pRegStore);

        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            if (pRegStore->fTouched)
                CommitAllToGptRegistry(
                    pRegStore,
                    0               // dwFlags
                    );
            FreeGptStoreChangeInfo(&pRegStore->pGptStoreChangeInfo);
            GptStoreSignalAndFreeRegStoreResyncEntries(pRegStore);
            PkiFree(pRegStore->GptPara.pwszRegPath);
            // BUG in NT4.0 and NT5.0. Doesn't support opening of the HKLM with
            // a NULL pwszSubKey
            if (pRegStore->GptPara.hKeyBase &&
                    HKEY_LOCAL_MACHINE != pRegStore->GptPara.hKeyBase)
                RegCloseKey(pRegStore->GptPara.hKeyBase);
        } else if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG) {
            PkiFree(pRegStore->pwszStoreDirectory);
        } else if (pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG) {
            if (pRegStore->fTouched)
                CommitAllToSerializedRegistry(
                    pRegStore,
                    0               // dwFlags
                    );
        }

        if (pRegStore->hKey)
            RegCloseKey(pRegStore->hKey);
        if (pRegStore->hMyNotifyChange)
            CloseHandle(pRegStore->hMyNotifyChange);
        DeleteCriticalSection(&pRegStore->CriticalSection);
        PkiFree(pRegStore);
    }
}

//+-------------------------------------------------------------------------
//  Read the serialized copy of the context from either the registry or
//  a roaming file and create a new context.
//--------------------------------------------------------------------------
STATIC BOOL ReadContext(
    IN PREG_STORE pRegStore,
    IN DWORD dwContextType,
    IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
    OUT const void **ppvContext
    )
{
    BOOL fResult;
    BYTE *pbElement = NULL;
    DWORD cbElement;

    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG) {
        if (!ILS_ReadElementFromFile(
                pRegStore->pwszStoreDirectory,
                rgpwszContextSubKeyName[dwContextType],
                wszSubKeyName,
                pRegStore->dwFlags,
                &pbElement,
                &cbElement
                ))
            goto ReadElementFromFileError;
    } else {
        HKEY hKey;

        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            if (NULL == (hKey = OpenSubKey(
                    pRegStore->GptPara.hKeyBase,
                    pRegStore->GptPara.pwszRegPath,
                    pRegStore->dwFlags
                    )))
                goto OpenSubKeyError;
        } else
            hKey = pRegStore->hKey;

        fResult = ILS_ReadElementFromRegistry(
                hKey,
                rgpwszContextSubKeyName[dwContextType],
                wszSubKeyName,
                pRegStore->dwFlags,
                &pbElement,
                &cbElement
                );

        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            ILS_CloseRegistryKey(hKey);
        }

        if (!fResult)
            goto ReadElementFromRegistryError;
    }

    if (!CertAddSerializedElementToStore(
            NULL,                           // hCertStore,
            pbElement,
            cbElement,
            CERT_STORE_ADD_ALWAYS,
            0,                              // dwFlags
            rgdwContextTypeFlags[dwContextType],
            NULL,                           // pdwContextType
            ppvContext))
        goto AddSerializedElementError;

    CertPerfIncrementRegElementReadCount();

    fResult = TRUE;
CommonReturn:
    PkiFree(pbElement);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    *ppvContext = NULL;
    goto CommonReturn;

TRACE_ERROR(ReadElementFromFileError)
TRACE_ERROR(ReadElementFromRegistryError)
TRACE_ERROR(AddSerializedElementError)
TRACE_ERROR(OpenSubKeyError)
}

//+-------------------------------------------------------------------------
//  Write the serialized context and its properties to
//  the registry or a roaming file.
//
//  Called before the context is written to the store.
//--------------------------------------------------------------------------
STATIC BOOL WriteSerializedContext(
    IN PREG_STORE pRegStore,
    IN DWORD dwContextType,
    IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN],
    IN const BYTE *pbElement,
    IN DWORD cbElement
    )
{
    BOOL fResult;

    CertPerfIncrementRegElementWriteCount();

    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG)
        fResult = ILS_WriteElementToFile(
                pRegStore->pwszStoreDirectory,
                rgpwszContextSubKeyName[dwContextType],
                wszSubKeyName,
                pRegStore->dwFlags,
                pbElement,
                cbElement
                );
    else {
        HKEY hKey;

        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            if (NULL == (hKey = OpenSubKey(
                    pRegStore->GptPara.hKeyBase,
                    pRegStore->GptPara.pwszRegPath,
                    pRegStore->dwFlags
                    )))
                return FALSE;
        } else
            hKey = pRegStore->hKey;

        fResult = ILS_WriteElementToRegistry(
                hKey,
                rgpwszContextSubKeyName[dwContextType],
                wszSubKeyName,
                pRegStore->dwFlags,
                pbElement,
                cbElement
                );
        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            ILS_CloseRegistryKey(hKey);
        }

        if (hWin95NotifyEvent && fResult)
            PulseEvent(hWin95NotifyEvent);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Delete the context and its properties from the
//  the registry or a roaming file.
//
//  Called before the context is deleted from the store.
//--------------------------------------------------------------------------
STATIC BOOL DeleteContext(
    IN PREG_STORE pRegStore,
    IN DWORD dwContextType,
    IN const WCHAR wszSubKeyName[MAX_CERT_REG_VALUE_NAME_LEN]
    )
{
    BOOL fResult;

    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG)
        fResult = ILS_DeleteElementFromDirectory(
                pRegStore->pwszStoreDirectory,
                rgpwszContextSubKeyName[dwContextType],
                wszSubKeyName,
                pRegStore->dwFlags
                );
    else {
        HKEY hKey;

        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            if (NULL == (hKey = OpenSubKey(
                    pRegStore->GptPara.hKeyBase,
                    pRegStore->GptPara.pwszRegPath,
                    pRegStore->dwFlags
                    )))
                return FALSE;
        } else
            hKey = pRegStore->hKey;

        fResult = ILS_DeleteElementFromRegistry(
                hKey,
                rgpwszContextSubKeyName[dwContextType],
                wszSubKeyName,
                pRegStore->dwFlags
                );

        if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
            ILS_CloseRegistryKey(hKey);
        }

        if (hWin95NotifyEvent && fResult)
            PulseEvent(hWin95NotifyEvent);
    }

    CertPerfIncrementRegElementDeleteCount();

    if (!fResult) {
        DWORD dwErr = GetLastError();
        if (ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr)
            fResult = TRUE;
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Read the serialized copy of the certificate and its properties from
//  the registry and create a new certificate context.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvReadCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pStoreCertContext,
        IN DWORD dwFlags,
        OUT PCCERT_CONTEXT *ppProvCertContext
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];

    assert(pRegStore);
    if (IsReadSerializedRegistry(pRegStore))
        goto UnexpectedReadError;

    if (!GetCertRegValueName(pStoreCertContext, wsz))
        goto GetRegValueNameError;

    fResult = ReadContext(
        pRegStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        wsz,
        (const void **) ppProvCertContext
        );

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    *ppProvCertContext = NULL;
    goto CommonReturn;

SET_ERROR(UnexpectedReadError, E_UNEXPECTED)
TRACE_ERROR(GetRegValueNameError)
}

//+-------------------------------------------------------------------------
//  Serialize the encoded certificate and its properties and write to
//  the registry.
//
//  Called before the certificate is written to the store.
//
//  Note, don't set the IEDirtyFlag if setting a property.
//--------------------------------------------------------------------------

STATIC BOOL WINAPI RegStoreProvWriteCertEx(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags,
        IN BOOL fSetProperty
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];
    BYTE *pbElement = NULL;
    DWORD cbElement;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only update the store cache, don't write back to registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    if (!GetCertRegValueName(pCertContext, wsz))
        goto GetRegValueNameError;

    // get the size
    if (!CertSerializeCertificateStoreElement(
            pCertContext, 0, NULL, &cbElement))
        goto SerializeStoreElementError;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;

    // put it into the buffer
    if (!CertSerializeCertificateStoreElement(
            pCertContext, 0, pbElement, &cbElement))
        goto SerializeStoreElementError;

    // write it to the registry or roaming file
    fResult = WriteSerializedContext(
        pRegStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        wsz,
        pbElement,
        cbElement
        );

CommonReturn:
    PkiFree(pbElement);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetRegValueNameError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(SerializeStoreElementError)
}

STATIC BOOL WINAPI RegStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    return RegStoreProvWriteCertEx(
        hStoreProv,
        pCertContext,
        dwFlags,
        FALSE                       // fSetProperty
        );
}


//+-------------------------------------------------------------------------
//  Delete the specified certificate from the registry.
//
//  Called before the certificate is deleted from the store.
//+-------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only delete from store cache, not from registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    if (!GetCertRegValueName(pCertContext, wsz))
        goto GetRegValueNameError;

    // delete this cert
    fResult = DeleteContext(
        pRegStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        wsz
        );
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetRegValueNameError)
}

//+-------------------------------------------------------------------------
//  Read the specified certificate from the registry and update its
//  property.
//
//  Note, ignore the CERT_SHA1_HASH_PROP_ID property which is implicitly
//  set before we write the certificate to the registry. If we don't ignore,
//  we will have indefinite recursion.
//
//  Called before setting the property of the certificate in the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvSetCertProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    PCCERT_CONTEXT pProvCertContext = NULL;

    // This property is implicitly written whenever we do a CertWrite.
    if (CERT_SHA1_HASH_PROP_ID == dwPropId)
        return TRUE;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only update the store cache, don't write back to registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    // Create a certificate context from the current serialized value stored
    // in the registry.
    if (!RegStoreProvReadCert(
            hStoreProv,
            pCertContext,
            0,              // dwFlags
            &pProvCertContext)) goto ReadError;

    // Set the property in the above created certificate context.
    if (!CertSetCertificateContextProperty(
            pProvCertContext,
            dwPropId,
            dwFlags,
            pvData)) goto SetPropertyError;

    // Serialize and write the above updated certificate back to the
    // registry.
    if (!RegStoreProvWriteCertEx(
            hStoreProv,
            pProvCertContext,
            0,                  // dwFlags
            TRUE                // fSetProperty
            ))
        goto WriteError;
    fResult = TRUE;
CommonReturn:
    CertFreeCertificateContext(pProvCertContext);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(ReadError)
TRACE_ERROR(SetPropertyError)
TRACE_ERROR(WriteError)
}

//+-------------------------------------------------------------------------
//  Read the serialized copy of the CRL and its properties from
//  the registry and create a new CRL context.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvReadCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pStoreCrlContext,
        IN DWORD dwFlags,
        OUT PCCRL_CONTEXT *ppProvCrlContext
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];

    assert(pRegStore);
    if (IsReadSerializedRegistry(pRegStore))
        goto UnexpectedReadError;

    if (!GetCrlRegValueName(pStoreCrlContext, wsz))
        goto GetRegValueNameError;

    fResult = ReadContext(
        pRegStore,
        CERT_STORE_CRL_CONTEXT - 1,
        wsz,
        (const void **) ppProvCrlContext
        );

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    *ppProvCrlContext = NULL;
    goto CommonReturn;

SET_ERROR(UnexpectedReadError, E_UNEXPECTED)
TRACE_ERROR(GetRegValueNameError)
}

//+-------------------------------------------------------------------------
//  Serialize the encoded CRL and its properties and write to
//  the registry.
//
//  Called before the CRL is written to the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvWriteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];
    BYTE *pbElement = NULL;
    DWORD cbElement;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only update the store cache, don't write back to registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    if (!GetCrlRegValueName(pCrlContext, wsz))
        goto GetRegValueNameError;

    // get the size
    if (!CertSerializeCRLStoreElement(pCrlContext, 0, NULL, &cbElement))
        goto SerializeStoreElementError;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;

    // put it into the buffer
    if (!CertSerializeCRLStoreElement(pCrlContext, 0, pbElement, &cbElement))
        goto SerializeStoreElementError;

    // write it to the registry or roaming file
    fResult = WriteSerializedContext(
        pRegStore,
        CERT_STORE_CRL_CONTEXT - 1,
        wsz,
        pbElement,
        cbElement
        );

CommonReturn:
    PkiFree(pbElement);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetRegValueNameError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(SerializeStoreElementError)
}


//+-------------------------------------------------------------------------
//  Delete the specified CRL from the registry.
//
//  Called before the CRL is deleted from the store.
//+-------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvDeleteCrl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only delete from store cache, not from registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    if (!GetCrlRegValueName(pCrlContext, wsz))
        goto GetRegValueNameError;

    // delete this CRL
    fResult = DeleteContext(
        pRegStore,
        CERT_STORE_CRL_CONTEXT - 1,
        wsz
        );

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetRegValueNameError)
}

//+-------------------------------------------------------------------------
//  Read the specified CRL from the registry and update its
//  property.
//
//  Note, ignore the CERT_SHA1_HASH_PROP_ID property which is implicitly
//  set before we write the CRL to the registry. If we don't ignore,
//  we will have indefinite recursion.
//
//  Called before setting the property of the CRL in the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvSetCrlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCRL_CONTEXT pCrlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    PCCRL_CONTEXT pProvCrlContext = NULL;

    // This property is implicitly written whenever we do a CertWrite.
    if (CERT_SHA1_HASH_PROP_ID == dwPropId)
        return TRUE;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only update the store cache, don't write back to registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    // Create a certificate context from the current serialized value stored
    // in the registry.
    if (!RegStoreProvReadCrl(
            hStoreProv,
            pCrlContext,
            0,              // dwFlags
            &pProvCrlContext)) goto ReadError;

    // Set the property in the above created certificate context.
    if (!CertSetCRLContextProperty(
            pProvCrlContext,
            dwPropId,
            dwFlags,
            pvData)) goto SetPropertyError;

    // Serialize and write the above updated certificate back to the
    // registry.
    if (!RegStoreProvWriteCrl(
            hStoreProv,
            pProvCrlContext,
            0))                 //dwFlags
        goto WriteError;
    fResult = TRUE;
CommonReturn:
    CertFreeCRLContext(pProvCrlContext);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(ReadError)
TRACE_ERROR(SetPropertyError)
TRACE_ERROR(WriteError)
}

//+-------------------------------------------------------------------------
//  Read the serialized copy of the CTL and its properties from
//  the registry and create a new CTL context.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvReadCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pStoreCtlContext,
        IN DWORD dwFlags,
        OUT PCCTL_CONTEXT *ppProvCtlContext
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];

    assert(pRegStore);
    if (IsReadSerializedRegistry(pRegStore))
        goto UnexpectedReadError;

    if (!GetCtlRegValueName(pStoreCtlContext, wsz))
        goto GetRegValueNameError;

    fResult = ReadContext(
        pRegStore,
        CERT_STORE_CTL_CONTEXT - 1,
        wsz,
        (const void **) ppProvCtlContext
        );
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    *ppProvCtlContext = NULL;
    goto CommonReturn;

SET_ERROR(UnexpectedReadError, E_UNEXPECTED)
TRACE_ERROR(GetRegValueNameError)
}

//+-------------------------------------------------------------------------
//  Serialize the encoded CTL and its properties and write to
//  the registry.
//
//  Called before the CTL is written to the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvWriteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];
    BYTE *pbElement = NULL;
    DWORD cbElement;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only update the store cache, don't write back to registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    if (!GetCtlRegValueName(pCtlContext, wsz))
        goto GetRegValueNameError;

    // get the size
    if (!CertSerializeCTLStoreElement(pCtlContext, 0, NULL, &cbElement))
        goto SerializeStoreElementError;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;

    // put it into the buffer
    if (!CertSerializeCTLStoreElement(pCtlContext, 0, pbElement, &cbElement))
        goto SerializeStoreElementError;

    // write it to the registry or roaming file
    fResult = WriteSerializedContext(
        pRegStore,
        CERT_STORE_CTL_CONTEXT - 1,
        wsz,
        pbElement,
        cbElement
        );
CommonReturn:
    PkiFree(pbElement);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetRegValueNameError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(SerializeStoreElementError)
}


//+-------------------------------------------------------------------------
//  Delete the specified CTL from the registry.
//
//  Called before the CTL is deleted from the store.
//+-------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvDeleteCtl(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    WCHAR wsz[MAX_CERT_REG_VALUE_NAME_LEN];

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only delete from store cache, not from registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    if (!GetCtlRegValueName(pCtlContext, wsz))
        goto GetRegValueNameError;

    // delete this CTL
    fResult = DeleteContext(
        pRegStore,
        CERT_STORE_CTL_CONTEXT - 1,
        wsz
        );
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetRegValueNameError)
}

//+-------------------------------------------------------------------------
//  Read the specified CTL from the registry and update its
//  property.
//
//  Note, ignore the CERT_SHA1_HASH_PROP_ID property which is implicitly
//  set before we write the CTL to the registry. If we don't ignore,
//  we will have indefinite recursion.
//
//  Called before setting the property of the CTL in the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RegStoreProvSetCtlProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCTL_CONTEXT pCtlContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    PCCTL_CONTEXT pProvCtlContext = NULL;

    // This property is implicitly written whenever we do a CertWrite.
    if (CERT_SHA1_HASH_PROP_ID == dwPropId)
        return TRUE;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only update the store cache, don't write back to registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;
    if (IsWriteSerializedRegistry(pRegStore))
        return TRUE;

    // Create a CTL context from the current serialized value stored
    // in the registry.
    if (!RegStoreProvReadCtl(
            hStoreProv,
            pCtlContext,
            0,              // dwFlags
            &pProvCtlContext)) goto ReadError;

    // Set the property in the above created certificate context.
    if (!CertSetCTLContextProperty(
            pProvCtlContext,
            dwPropId,
            dwFlags,
            pvData)) goto SetPropertyError;

    // Serialize and write the above updated certificate back to the
    // registry.
    if (!RegStoreProvWriteCtl(
            hStoreProv,
            pProvCtlContext,
            0))                 //dwFlags
        goto WriteError;
    fResult = TRUE;
CommonReturn:
    CertFreeCTLContext(pProvCtlContext);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(ReadError)
TRACE_ERROR(SetPropertyError)
TRACE_ERROR(WriteError)
}

//+=========================================================================
//  Control functions
//==========================================================================

STATIC BOOL RegNotifyChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent,
    IN DWORD dwFlags
    )
{
    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG)
        return RegRegistryStoreChange(pRegStore, hEvent, dwFlags);
    else if (hWin95NotifyEvent)
        return RegWin95StoreChange(pRegStore, hEvent, dwFlags);
    else if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG)
        return RegGptStoreChange(pRegStore, hEvent, dwFlags);
    else
        return RegRegistryStoreChange(pRegStore, hEvent, dwFlags);
}

STATIC BOOL ResyncFromRegistry(
    IN PREG_STORE pRegStore,
    IN OPTIONAL HANDLE hEvent,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    HCERTSTORE hNewStore = NULL;
    HANDLE hMyNotifyChange;

    // Serialize resyncs
    LockRegStore(pRegStore);

    if (hEvent) {
        // Re-arm the specified event
        if (!RegNotifyChange(pRegStore, hEvent, dwFlags))
            goto NotifyChangeError;
    }

    hMyNotifyChange = pRegStore->hMyNotifyChange;
    if (hMyNotifyChange) {
        // Check if any changes since last resync
        if (WAIT_TIMEOUT == WaitForSingleObjectEx(
                hMyNotifyChange,
                0,                          // dwMilliseconds
                FALSE                       // bAlertable
                )) {
            // No change
            fResult = TRUE;
            goto CommonReturn;
        } else {
            // Re-arm our event handle
            if (!RegNotifyChange(pRegStore, hMyNotifyChange,
                    CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG))
                goto NotifyChangeError;
        }
    }

    if (NULL == (hNewStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            CERT_STORE_SHARE_CONTEXT_FLAG,           
            NULL                    // pvPara
            )))
        goto OpenMemoryStoreError;

    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG) {
        fResult = OpenAllFromGptRegistry(pRegStore, hNewStore);
        pRegStore->fTouched = FALSE;
    } else if (pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG) {
        fResult = OpenAllFromSerializedRegistry(pRegStore, hNewStore);
        pRegStore->fTouched = FALSE;
    } else
        fResult = OpenAllFromRegistry(pRegStore, hNewStore);

    if (!fResult) {
        if (ERROR_KEY_DELETED == GetLastError())
            fResult = TRUE;
    }

    if (fResult) {
        if (pRegStore->fProtected) {
            BOOL fProtected;

            // For the "Root" delete any roots that aren't in the protected root
            // list.
            if (!IPR_DeleteUnprotectedRootsFromStore(
                    hNewStore,
                    &fProtected
                    )) goto DeleteUnprotectedRootsError;
        }

        // Set fResync to inhibit the sync from writing back to the registry.
        pRegStore->fResync = TRUE;
        I_CertSyncStore(pRegStore->hCertStore, hNewStore);
        pRegStore->fResync = FALSE;
    }

CommonReturn:
    UnlockRegStore(pRegStore);
    if (hNewStore)
        CertCloseStore(hNewStore, 0);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(NotifyChangeError)
TRACE_ERROR(OpenMemoryStoreError)
TRACE_ERROR(DeleteUnprotectedRootsError)
}


STATIC BOOL RegistryNotifyChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    HANDLE hMyNotifyChange;
    BOOL fFirstNotify;

    LockRegStore(pRegStore);

    hMyNotifyChange = pRegStore->hMyNotifyChange;
    if (NULL == hMyNotifyChange) {
        // Create "my" event and register it to be signaled for any changes
        if (NULL == (hMyNotifyChange = CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL)))     // lpszEventName
            goto CreateEventError;

        // For the first notification, want to ensure the store is in sync.
        // Also does a RegNotifyChange
        if (!ResyncFromRegistry(pRegStore, hMyNotifyChange,
                CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG)) {
            DWORD dwErr = GetLastError();

            // Bug 484023 Certificate store event handle closed before
            // being removed from list.
            RegNotifyChange(pRegStore, hMyNotifyChange,
                REG_STORE_CTRL_CANCEL_NOTIFY_FLAG);

            CloseHandle(hMyNotifyChange);
            SetLastError(dwErr);
            goto ResyncFromRegistryError;
        }

        // Note, must update after making the above Resync call to
        // force the store to be resync'ed
        pRegStore->hMyNotifyChange = hMyNotifyChange;
        fFirstNotify = TRUE;
    } else
        fFirstNotify = FALSE;

    if (hEvent) {
        if (fFirstNotify ||
                0 != (dwFlags & REG_STORE_CTRL_CANCEL_NOTIFY_FLAG)) {
            if (!RegNotifyChange(pRegStore, hEvent, dwFlags))
                goto NotifyChangeError;
        } else {
            // For subsequent notification, want to ensure the store
            // is in sync. Also does a RegNotifyChange.
            if (!ResyncFromRegistry(pRegStore, hEvent, dwFlags))
                goto ResyncFromRegistryError;
        }
    }

    fResult = TRUE;
CommonReturn:
    UnlockRegStore(pRegStore);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateEventError)
TRACE_ERROR(ResyncFromRegistryError)
TRACE_ERROR(NotifyChangeError)
}


STATIC BOOL WINAPI RegStoreProvControl(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags,
        IN DWORD dwCtrlType,
        IN void const *pvCtrlPara
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;

    switch (dwCtrlType) {
        case CERT_STORE_CTRL_RESYNC:
            {
                HANDLE *phEvent = (HANDLE *) pvCtrlPara;
                HANDLE hEvent = phEvent ? *phEvent : NULL;
                fResult = ResyncFromRegistry(pRegStore, hEvent, dwFlags);
            }
            break;
        case CERT_STORE_CTRL_NOTIFY_CHANGE:
            {
                HANDLE *phEvent = (HANDLE *) pvCtrlPara;
                HANDLE hEvent = phEvent ? *phEvent : NULL;
                fResult = RegistryNotifyChange(pRegStore, hEvent, dwFlags);
            }
            break;
        case CERT_STORE_CTRL_COMMIT:
            if (pRegStore->dwFlags & CERT_REGISTRY_STORE_CLIENT_GPT_FLAG)
                fResult = CommitAllToGptRegistry(pRegStore, dwFlags);
            else if (pRegStore->dwFlags & CERT_REGISTRY_STORE_SERIALIZED_FLAG)
                fResult = CommitAllToSerializedRegistry(pRegStore, dwFlags);
            else
                fResult = TRUE;
            break;
        case CERT_STORE_CTRL_CANCEL_NOTIFY:
            {
                HANDLE *phEvent = (HANDLE *) pvCtrlPara;
                HANDLE hEvent = phEvent ? *phEvent : NULL;
                if (hEvent)
                    fResult = RegistryNotifyChange(pRegStore, hEvent,
                        REG_STORE_CTRL_CANCEL_NOTIFY_FLAG);
                else
                    fResult = TRUE;
            }
            break;
        default:
            goto NotSupported;
    }

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NotSupported, ERROR_CALL_NOT_IMPLEMENTED)
}


//+=========================================================================
//  System and physical store support functions
//==========================================================================

STATIC BOOL HasBackslash(
    IN LPCWSTR pwsz
    )
{
    WCHAR wch;

    if (NULL == pwsz)
        return FALSE;

    while (L'\0' != (wch = *pwsz++)) {
        if (L'\\' == wch)
            return TRUE;
    }
    return FALSE;
}

static inline LPCSTR GetSystemStoreLocationOID(
    IN DWORD dwFlags
    )
{
    return (LPCSTR)(DWORD_PTR) ((dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK) >>
        CERT_SYSTEM_STORE_LOCATION_SHIFT);
}

static inline DWORD GetSystemStoreLocationID(
    IN DWORD dwFlags
    )
{
    return ((dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK) >>
        CERT_SYSTEM_STORE_LOCATION_SHIFT);
}

static inline BOOL IsSystemStoreLocationInRegistry(
    IN DWORD dwFlags
    )
{
    DWORD dwID = GetSystemStoreLocationID(dwFlags);
    return (dwID < NUM_SYSTEM_STORE_LOCATION &&
        0 == (rgSystemStoreLocationInfo[dwID].dwFlags &
                NOT_IN_REGISTRY_SYSTEM_STORE_LOCATION_FLAG));
}

static inline BOOL IsRemotableSystemStoreLocationInRegistry(
    IN DWORD dwFlags
    )
{
    DWORD dwID = GetSystemStoreLocationID(dwFlags);
    return (dwID < NUM_SYSTEM_STORE_LOCATION &&
        0 != (rgSystemStoreLocationInfo[dwID].dwFlags &
                REMOTABLE_SYSTEM_STORE_LOCATION_FLAG));
}


static inline BOOL IsLMSystemStoreLocationInRegistry(
    IN DWORD dwFlags
    )
{
    DWORD dwID = GetSystemStoreLocationID(dwFlags);
    return (dwID < NUM_SYSTEM_STORE_LOCATION &&
        0 != (rgSystemStoreLocationInfo[dwID].dwFlags &
                LM_SYSTEM_STORE_LOCATION_FLAG));
}

static inline BOOL IsSerializedSystemStoreLocationInRegistry(
    IN DWORD dwFlags
    )
{
    DWORD dwID = GetSystemStoreLocationID(dwFlags);
    return (dwID < NUM_SYSTEM_STORE_LOCATION &&
        0 != (rgSystemStoreLocationInfo[dwID].dwFlags &
                SERIALIZED_SYSTEM_STORE_LOCATION_FLAG));
}

STATIC BOOL IsPredefinedSystemStore(
    IN LPCWSTR pwszSystemName,
    IN DWORD dwFlags
    )
{
    DWORD i;
    DWORD dwCheckFlag;
    DWORD dwLocID;
    DWORD dwPredefinedSystemFlags;

    dwLocID = GetSystemStoreLocationID(dwFlags);
    assert(NUM_SYSTEM_STORE_LOCATION > dwLocID);
    dwPredefinedSystemFlags =
        rgSystemStoreLocationInfo[dwLocID].dwPredefinedSystemFlags;

    for (i = 0, dwCheckFlag = 1; i < NUM_PREDEFINED_SYSTEM_STORE;
                                        i++, dwCheckFlag = dwCheckFlag << 1) {
        if ((dwCheckFlag & dwPredefinedSystemFlags) &&
                0 == _wcsicmp(rgpwszPredefinedSystemStore[i], pwszSystemName))
            return TRUE;
    }
    return FALSE;
}

#define UNICODE_SYSTEM_PROVIDER_FLAG    0x1
#define ASCII_SYSTEM_PROVIDER_FLAG      0x2
#define PHYSICAL_PROVIDER_FLAG          0x4

STATIC DWORD GetSystemProviderFlags(
    IN LPCSTR pszStoreProvider
    )
{
    DWORD dwFlags;

    if (0xFFFF < (DWORD_PTR) pszStoreProvider &&
            CONST_OID_STR_PREFIX_CHAR == pszStoreProvider[0])
        // Convert "#<number>" string to its corresponding constant OID value
        pszStoreProvider = (LPCSTR)(DWORD_PTR) atol(pszStoreProvider + 1);

    dwFlags = 0;
    if (CERT_STORE_PROV_SYSTEM_A == pszStoreProvider)
        dwFlags = ASCII_SYSTEM_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_SYSTEM_W == pszStoreProvider)
        dwFlags = UNICODE_SYSTEM_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_SYSTEM_REGISTRY_A == pszStoreProvider)
        dwFlags = ASCII_SYSTEM_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_SYSTEM_REGISTRY_W == pszStoreProvider)
        dwFlags = UNICODE_SYSTEM_PROVIDER_FLAG;
    else if (CERT_STORE_PROV_PHYSICAL_W == pszStoreProvider)
        dwFlags = UNICODE_SYSTEM_PROVIDER_FLAG | PHYSICAL_PROVIDER_FLAG;
    else if (0xFFFF < (DWORD_PTR) pszStoreProvider) {
        if (0 == _stricmp(sz_CERT_STORE_PROV_SYSTEM_W, pszStoreProvider))
            dwFlags = UNICODE_SYSTEM_PROVIDER_FLAG;
        else if (0 == _stricmp(sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W,
                pszStoreProvider))
            dwFlags = UNICODE_SYSTEM_PROVIDER_FLAG;
        else if (0 == _stricmp(sz_CERT_STORE_PROV_PHYSICAL_W,
                pszStoreProvider))
            dwFlags = UNICODE_SYSTEM_PROVIDER_FLAG | PHYSICAL_PROVIDER_FLAG;
    }

    return dwFlags;
}

STATIC LPCSTR ChangeAsciiToUnicodeProvider(
    IN LPCSTR pszStoreProvider
    )
{
    LPCSTR pszUnicodeProvider = NULL;

    if (0xFFFF < (DWORD_PTR) pszStoreProvider &&
            CONST_OID_STR_PREFIX_CHAR == pszStoreProvider[0])
        // Convert "#<number>" string to its corresponding constant OID value
        pszStoreProvider = (LPCSTR)(DWORD_PTR) atol(pszStoreProvider + 1);

    if (CERT_STORE_PROV_SYSTEM_A == pszStoreProvider)
        pszUnicodeProvider = CERT_STORE_PROV_SYSTEM_W;
    else if (CERT_STORE_PROV_SYSTEM_REGISTRY_A == pszStoreProvider)
        pszUnicodeProvider = CERT_STORE_PROV_SYSTEM_REGISTRY_W;

    assert(pszUnicodeProvider);
    return pszUnicodeProvider;
}


STATIC void FreeSystemNameInfo(
    IN PSYSTEM_NAME_INFO pInfo
    )
{
    DWORD i;
    for (i = 0; i < SYSTEM_NAME_PATH_COUNT; i++) {
        if (pInfo->rgpwszName[i]) {
            PkiFree(pInfo->rgpwszName[i]);
            pInfo->rgpwszName[i] = NULL;
        }
    }
}

//+-------------------------------------------------------------------------
//  If CERT_SYSTEM_STORE_RELOCATE_FLAG is set in dwFlags, then, treat the
//  parameter as a pointer to a relocate data structure consisting of
//  the relocate HKEY base and the pointer to the system name path.
//  Otherwise, treat the parameter as a pointer to the system name path.
//
//  Parses and validates the system name path according to the system store
//  location and the number of required System and Physical name components.
//  All name components are separated by the backslash, "\", character.
//
//  Depending on the system store location and the number of required System
//  and Physical name components, the system name path can have the following
//  name components:
//
//  CERT_SYSTEM_STORE_CURRENT_USER or
//  CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY
//      []
//      SystemName
//      SystemName\PhysicalName
//  CERT_SYSTEM_STORE_LOCAL_MACHINE or
//  CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY or
//  CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE
//      []
//      [[\\]ComputerName]
//      [[\\]ComputerName\]SystemName
//      [[\\]ComputerName\]SystemName\PhysicalName
//  CERT_SYSTEM_STORE_CURRENT_SERVICE
//      []
//      SystemName
//      SystemName\PhysicalName
//  CERT_SYSTEM_STORE_SERVICES
//      []
//      [\\ComputerName]
//      [[\\]ComputerName\]
//      [ServiceName]
//      [[\\]ComputerName\ServiceName]
//      [[\\]ComputerName\]ServiceName\SystemName
//      [[\\]ComputerName\]ServiceName\SystemName\PhysicalName
//  CERT_SYSTEM_STORE_USERS
//      []
//      [\\ComputerName]
//      [[\\]ComputerName\]
//      [UserName]
//      [[\\]ComputerName\UserName]
//      [[\\]ComputerName\]UserName\SystemName
//      [[\\]ComputerName\]UserName\SystemName\PhysicalName
//
//  For enumeration, where cReqName = 0, all store locations allow the no name
//  components option. CERT_SYSTEM_STORE_CURRENT_USER,
//  CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY,
//  CERT_SYSTEM_CURRENT_SERVICE only allow the no name component option.
//
//  The leading \\ before the ComputerName is optional.
//
//  A PhysicalName always requires a preceding SystemName.
//
//  For CERT_SYSTEM_STORE_SERVICES or CERT_SYSTEM_STORE_USERS,
//  for enumeration, if only a single
//  name component, then, interpretted as a ServiceName or UserName unless it
//  contains a leading \\ or a trailing \, in which case its interpretted as a
//  ComputerName. Otherwise, when not enumeration, the ServiceName or UserName
//  is required.
//--------------------------------------------------------------------------
STATIC BOOL ParseSystemStorePara(
    IN const void *pvPara,
    IN DWORD dwFlags,
    IN DWORD cReqName,      // 0 for enum, 1 for OpenSystem, 2 for OpenPhysical
    OUT PSYSTEM_NAME_INFO pInfo
    )
{
    LPCWSTR pwszPath;       // not allocated
    BOOL fResult;
    DWORD cMaxOptName;
    DWORD cMaxTotalName;
    DWORD cOptName;
    DWORD cTotalName;
    BOOL fHasComputerNameBackslashes;
    DWORD i;

    LPCWSTR pwszEnd;
    LPCWSTR pwsz;
    LPCWSTR rgpwszStart[SYSTEM_NAME_PATH_COUNT];
    DWORD cchName[SYSTEM_NAME_PATH_COUNT];

    memset(pInfo, 0, sizeof(*pInfo));
    if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pRelocatePara =
            (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvPara;

        if (NULL == pRelocatePara)
            goto NullRelocateParaError;

        if (NULL == pRelocatePara->hKeyBase)
            goto NullRelocateHKEYError;
        pInfo->hKeyBase = pRelocatePara->hKeyBase;
        pwszPath = pRelocatePara->pwszSystemStore;
    } else
        pwszPath = (LPCWSTR) pvPara;

    if (NULL == pwszPath || L'\0' == *pwszPath) {
        if (0 == cReqName)
            goto SuccessReturn;
        else
            goto MissingSystemName;
    }

    dwFlags &= CERT_SYSTEM_STORE_LOCATION_MASK;
    switch (dwFlags) {
        case CERT_SYSTEM_STORE_CURRENT_USER:
        case CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY:
        case CERT_SYSTEM_STORE_CURRENT_SERVICE:
            cMaxOptName = 0;
            break;
        case CERT_SYSTEM_STORE_LOCAL_MACHINE:
        case CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY:
        case CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE:
            cMaxOptName = 1;        // Allow ComputerName
            break;
        case CERT_SYSTEM_STORE_SERVICES:
        case CERT_SYSTEM_STORE_USERS:
            // Allow ComputerName and/or ServiceOrUserName
            cMaxOptName = 2;
            break;
        default:
            goto InvalidStoreLocation;
    }

    cMaxTotalName = cReqName + cMaxOptName;
    assert(cReqName <= SERVICE_NAME_INDEX);
    assert(cMaxTotalName <= SYSTEM_NAME_PATH_COUNT);
    if (0 == cMaxTotalName)
        goto MachineOrServiceNameNotAllowed;

    if (L'\\' == pwszPath[0] && L'\\' == pwszPath[1]) {
        pwszPath += 2;
        fHasComputerNameBackslashes = TRUE;
    } else
        fHasComputerNameBackslashes = FALSE;

    // Starting at the end, get up through cMaxTotalName strings separated
    // by backslashes. Note, don't parse the left-most name component. This
    // allows a ComputerName to contain embedded backslashes.
    pwszEnd = pwszPath + wcslen(pwszPath);
    pwsz = pwszEnd;

    cTotalName = 0;
    while (cTotalName < cMaxTotalName - 1) {
        while (pwsz > pwszPath && L'\\' != *pwsz)
            pwsz--;
        if (L'\\' != *pwsz) {
            // Left-most name component.
            assert(pwsz == pwszPath);
            break;
        }
        assert(L'\\' == *pwsz);
        cchName[cTotalName] = (DWORD)(pwszEnd - pwsz) - 1; // exclude "\"
        rgpwszStart[cTotalName] = pwsz + 1;         // exclude "\"
        cTotalName++;

        pwszEnd = pwsz;         // remember pointer to "\"
        if (pwsz == pwszPath)
            // Left-most name component is empty
            break;
        pwsz--;                 // skip before the "\"
    }
    // Left-most name component. Note, it may have embedded backslashes
    cchName[cTotalName] = (DWORD)(pwszEnd - pwszPath);
    rgpwszStart[cTotalName] = pwszPath;
    cTotalName++;

    if (cTotalName < cReqName)
        goto MissingSystemOrPhysicalName;

    // Allocate and copy the required name components
    for (i = 0; i < cReqName; i++) {
        if (0 == cchName[i])
            goto EmptySystemOrPhysicalName;
        if (NULL == (pInfo->rgpwszName[SERVICE_NAME_INDEX - cReqName + i] =
                ILS_AllocAndCopyString(rgpwszStart[i], cchName[i])))
            goto OutOfMemory;
    }

    cOptName = cTotalName - cReqName;
    assert(cOptName || cReqName);
    if (0 == cOptName) {
        assert(cReqName);
        // No ComputerName and/or ServiceName prefix

        // Check if left-most name component (SystemName) has any backslashes
        assert(pInfo->rgpwszName[SYSTEM_NAME_INDEX]);
        if (fHasComputerNameBackslashes || HasBackslash(
                pInfo->rgpwszName[SYSTEM_NAME_INDEX]))
            goto InvalidBackslashInSystemName;
        if (CERT_SYSTEM_STORE_SERVICES == dwFlags ||
                CERT_SYSTEM_STORE_USERS == dwFlags)
            // For non-enumeration, require the ServiceName
            goto MissingServiceOrUserName;
    } else {
        if (CERT_SYSTEM_STORE_SERVICES == dwFlags ||
                CERT_SYSTEM_STORE_USERS == dwFlags) {
            // ServiceName or UserName prefix

            if (0 == cchName[cReqName] ||
                    (1 == cOptName && fHasComputerNameBackslashes)) {
                if (0 != cReqName)
                    goto MissingServiceOrUserName;
                // else
                //  ComputerName only Enumeration with either:
                //      ComputerName\       <- trailing backslash
                //      \\ComputerName      <- leading backslashes
                //      \\ComputerName\     <- both
            } else {
                if (NULL == (pInfo->rgpwszName[SERVICE_NAME_INDEX] =
                        ILS_AllocAndCopyString(rgpwszStart[cReqName],
                            cchName[cReqName])))
                    goto OutOfMemory;
            }
        }

        if (CERT_SYSTEM_STORE_LOCAL_MACHINE == dwFlags ||
                CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY == dwFlags ||
                CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE == dwFlags ||
                2 == cOptName || fHasComputerNameBackslashes) {
            // ComputerName prefix
            DWORD cchComputer = cchName[cTotalName - 1];
            if (0 == cchComputer)
                goto EmptyComputerName;

            if (pInfo->hKeyBase)
                goto BothRemoteAndRelocateNotAllowed;

            if (NULL == (pInfo->rgpwszName[COMPUTER_NAME_INDEX] =
                    (LPWSTR) PkiNonzeroAlloc(
                    (2 + cchComputer + 1) * sizeof(WCHAR))))
                goto OutOfMemory;
            wcscpy(pInfo->rgpwszName[COMPUTER_NAME_INDEX], L"\\\\");
            memcpy((BYTE *) (pInfo->rgpwszName[COMPUTER_NAME_INDEX] + 2),
                (BYTE *) rgpwszStart[cTotalName -1],
                cchComputer * sizeof(WCHAR));
            *(pInfo->rgpwszName[COMPUTER_NAME_INDEX] + 2 + cchComputer) = L'\0';
        }
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    FreeSystemNameInfo(pInfo);
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(MissingSystemName, E_INVALIDARG)
SET_ERROR(NullRelocateParaError, E_INVALIDARG)
SET_ERROR(NullRelocateHKEYError, E_INVALIDARG)
SET_ERROR(MissingSystemOrPhysicalName, E_INVALIDARG)
SET_ERROR(InvalidStoreLocation, E_INVALIDARG)
SET_ERROR(MachineOrServiceNameNotAllowed, E_INVALIDARG)
SET_ERROR(EmptySystemOrPhysicalName, E_INVALIDARG)
SET_ERROR(InvalidBackslashInSystemName, E_INVALIDARG)
SET_ERROR(MissingServiceOrUserName, E_INVALIDARG)
SET_ERROR(EmptyComputerName, E_INVALIDARG)
SET_ERROR(BothRemoteAndRelocateNotAllowed, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
}

typedef struct _SYSTEM_NAME_GROUP {
    DWORD cName;
    LPCWSTR *rgpwszName;
} SYSTEM_NAME_GROUP, *PSYSTEM_NAME_GROUP;

//+-------------------------------------------------------------------------
//  Formats a System Name Path by concatenating together the name components
//  with an intervening "\" separator.
//--------------------------------------------------------------------------
STATIC LPWSTR FormatSystemNamePath(
    IN DWORD cNameGroup,
    IN SYSTEM_NAME_GROUP rgNameGroup[]
    )
{
    DWORD cchPath;
    LPWSTR pwszPath;
    BOOL fFirst;
    DWORD iGroup;

    // First, get total length of formatted path
    cchPath = 0;
    fFirst = TRUE;
    for (iGroup = 0; iGroup < cNameGroup; iGroup++) {
        DWORD iName;
        for (iName = 0; iName < rgNameGroup[iGroup].cName; iName++) {
            LPCWSTR pwszName = rgNameGroup[iGroup].rgpwszName[iName];
            if (pwszName && *pwszName) {
                if (fFirst)
                    fFirst = FALSE;
                else
                    cchPath++;          // "\" separator
                cchPath += wcslen(pwszName);
            }
        }
    }
    cchPath++;          // "\0" terminator

    if (NULL == (pwszPath = (LPWSTR) PkiNonzeroAlloc(cchPath * sizeof(WCHAR))))
        return NULL;

    // Now do concatenated copies with intervening '\'
    fFirst = TRUE;
    for (iGroup = 0; iGroup < cNameGroup; iGroup++) {
        DWORD iName;
        for (iName = 0; iName < rgNameGroup[iGroup].cName; iName++) {
            LPCWSTR pwszName = rgNameGroup[iGroup].rgpwszName[iName];
            if (pwszName && *pwszName) {
                if (fFirst) {
                    wcscpy(pwszPath, pwszName);
                    fFirst = FALSE;
                } else {
                    wcscat(pwszPath, L"\\");
                    wcscat(pwszPath, pwszName);
                }
            }
        }
    }
    if (fFirst)
        // Empty string
        *pwszPath = L'\0';
    return pwszPath;
}

//+-------------------------------------------------------------------------
//  If the SystemNameInfo has a non-NULL hKeyBase, then, the returned
//  pvPara is a pointer to a CERT_SYSTEM_STORE_RELOCATE_PARA containing both
//  the hKeyBase and the formatted system name path. Otherwise, returns
//  pointer to only the formatted system name path.
//
//  Calls the above FormatSystemNamePath() to do the actual formatting.
//--------------------------------------------------------------------------
STATIC void * FormatSystemNamePara(
    IN DWORD cNameGroup,
    IN SYSTEM_NAME_GROUP rgNameGroup[],
    IN PSYSTEM_NAME_INFO pSystemNameInfo
    )
{
    if (NULL == pSystemNameInfo->hKeyBase)
        return FormatSystemNamePath(cNameGroup, rgNameGroup);
    else {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pRelocatePara;

        if (NULL == (pRelocatePara =
                (PCERT_SYSTEM_STORE_RELOCATE_PARA) PkiNonzeroAlloc(
                    sizeof(CERT_SYSTEM_STORE_RELOCATE_PARA))))
            return NULL;

        pRelocatePara->hKeyBase = pSystemNameInfo->hKeyBase;

        if (NULL == (pRelocatePara->pwszSystemStore = FormatSystemNamePath(
                cNameGroup, rgNameGroup))) {
            PkiFree(pRelocatePara);
            return NULL;
        } else
            return pRelocatePara;
    }
}

STATIC void FreeSystemNamePara(
    IN void *pvSystemNamePara,
    IN PSYSTEM_NAME_INFO pSystemNameInfo
    )
{
    if (pvSystemNamePara) {
        if (pSystemNameInfo->hKeyBase) {
            PCERT_SYSTEM_STORE_RELOCATE_PARA pRelocatePara =
                (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvSystemNamePara;
            PkiFree((LPWSTR) pRelocatePara->pwszSystemStore);
        }
        PkiFree(pvSystemNamePara);
    }
}


//+-------------------------------------------------------------------------
//  Localizes the physical, system and service name components. If unable
//  to find a localized name string, uses the unlocalized name component.
//
//  Re-formats the system name path with intervening backslashes and
//  sets the store's CERT_STORE_LOCALIZED_NAME_PROP_ID property.
//--------------------------------------------------------------------------
STATIC void SetLocalizedNameStoreProperty(
    IN HCERTSTORE hCertStore,
    IN PSYSTEM_NAME_INFO pSystemNameInfo
    )
{
    LPWSTR pwszLocalizedPath = NULL;
    LPCWSTR rgpwszLocalizedName[SYSTEM_NAME_PATH_COUNT];
    SYSTEM_NAME_GROUP NameGroup;
    CRYPT_DATA_BLOB Property;
    DWORD i;

    // Except for the computer name, try to get localized name components.
    // If unable to find a localized name, use the original name component.
    for (i = 0; i < SYSTEM_NAME_PATH_COUNT; i++) {
        LPCWSTR pwszName;
        LPCWSTR pwszLocalizedName;

        pwszName = pSystemNameInfo->rgpwszName[i];
        if (NULL == pwszName || COMPUTER_NAME_INDEX == i)
            pwszLocalizedName = pwszName;
        else {
            // Returned pwszLocalizedName isn't allocated
            if (NULL == (pwszLocalizedName = CryptFindLocalizedName(
                    pwszName)) || L'\0' == *pwszLocalizedName)
                pwszLocalizedName = pwszName;
        }

        // Before formatting, need to reverse.
        rgpwszLocalizedName[SYSTEM_NAME_PATH_COUNT - 1 - i] =
            pwszLocalizedName;
    }

    NameGroup.cName = SYSTEM_NAME_PATH_COUNT;
    NameGroup.rgpwszName = rgpwszLocalizedName;
    if (NULL == (pwszLocalizedPath = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;

    Property.pbData = (BYTE *) pwszLocalizedPath;
    Property.cbData = (wcslen(pwszLocalizedPath) + 1) * sizeof(WCHAR);
    if (!CertSetStoreProperty(
            hCertStore,
            CERT_STORE_LOCALIZED_NAME_PROP_ID,
            0,                                  // dwFlags
            (const void *) &Property
            ))
        goto SetStorePropertyError;

CommonReturn:
    PkiFree(pwszLocalizedPath);
    return;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(FormatSystemNamePathError)
TRACE_ERROR(SetStorePropertyError)
}


//+-------------------------------------------------------------------------
//  For NT, get the formatted SID. For Win95, get the current user name.
//--------------------------------------------------------------------------
STATIC LPWSTR GetCurrentServiceOrUserName()
{
    LPWSTR pwszCurrentService = NULL;

    if (!FIsWinNT()) {
        DWORD cch = _MAX_PATH;
        if (NULL == (pwszCurrentService = (LPWSTR) PkiNonzeroAlloc(
                (cch + 1) * sizeof(WCHAR))))
            goto OutOfMemory;
        if (!GetUserNameU(pwszCurrentService, &cch))
            goto GetUserNameError;
    } else {
        DWORD cch = 256;
        if (NULL == (pwszCurrentService = (LPWSTR) PkiNonzeroAlloc(
                (cch + 1) * sizeof(WCHAR))))
            goto OutOfMemory;
        if (!GetUserTextualSidHKCU(pwszCurrentService, &cch)) {
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                goto GetUserTextualSidHKUCError;
            PkiFree(pwszCurrentService);
            if (NULL == (pwszCurrentService = (LPWSTR) PkiNonzeroAlloc(
                    (cch + 1) * sizeof(WCHAR))))
                goto OutOfMemory;
            if (!GetUserTextualSidHKCU(pwszCurrentService, &cch))
                goto GetUserTextualSidHKUCError;
        }
    }

CommonReturn:
    return pwszCurrentService;

ErrorReturn:
    if (pwszCurrentService)
        wcscpy(pwszCurrentService, DEFAULT_USER_NAME);
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetUserNameError)
TRACE_ERROR(GetUserTextualSidHKUCError)
}

//+-------------------------------------------------------------------------
//  For NT and Win95, get the computer name
//--------------------------------------------------------------------------
STATIC LPWSTR GetCurrentComputerName()
{
    LPWSTR pwszCurrentComputer = NULL;
    DWORD cch = _MAX_PATH;
    if (NULL == (pwszCurrentComputer = (LPWSTR) PkiNonzeroAlloc(
            (cch + 1) * sizeof(WCHAR))))
        goto OutOfMemory;
    if (!GetComputerNameU(pwszCurrentComputer, &cch))
        goto GetComputerNameError;

CommonReturn:
    return pwszCurrentComputer;

ErrorReturn:
    PkiFree(pwszCurrentComputer);
    pwszCurrentComputer = NULL;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetComputerNameError)
}

//+-------------------------------------------------------------------------
//  Uses the store location in the upper word of dwFlags, the parsed
//  System Name components consisting of: computer, service/user, system and
//  physical names, and the optional SubKey name to open the appropriate
//  registry key. If the Computer name is non-NULL, does a RegConnectRegistry
//  to connect a registry key on a remote computer. If the hKeyBase is
//  non-NULL, does a relocated open instead of using HKCU or HKLM.
//--------------------------------------------------------------------------
STATIC LPWSTR FormatSystemRegPath(
    IN PSYSTEM_NAME_INFO pInfo,
    IN OPTIONAL LPCWSTR pwszSubKeyName,
    IN DWORD dwFlags,
    OUT HKEY *phKey
    )
{
    LONG err;
    HKEY hKey = NULL;
    LPWSTR pwszRegPath = NULL;
    LPWSTR pwszCurrentService = NULL;
    DWORD dwStoreLocation;

    SYSTEM_NAME_GROUP rgNameGroup[3];
    DWORD cNameGroup;
    LPCWSTR rgpwszService[3];
    LPCWSTR rgpwszUser[2];
    LPCWSTR rgpwszStore[3];

    if (pwszSubKeyName) {
        cNameGroup = 3;
        rgNameGroup[2].cName = 1;
        rgNameGroup[2].rgpwszName = &pwszSubKeyName;
    } else
        cNameGroup = 2;

    dwStoreLocation = dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK;
    switch (dwStoreLocation) {
        case CERT_SYSTEM_STORE_CURRENT_SERVICE:
        case CERT_SYSTEM_STORE_SERVICES:
            rgNameGroup[0].cName = 3;
            rgNameGroup[0].rgpwszName = rgpwszService;
            rgpwszService[0] = SERVICES_REGPATH;
            rgpwszService[2] = SYSTEM_CERTIFICATES_SUBKEY_NAME;

            if (CERT_SYSTEM_STORE_CURRENT_SERVICE == dwStoreLocation) {
                assert(NULL == pInfo->rgpwszName[COMPUTER_NAME_INDEX]);
                assert(NULL == pInfo->rgpwszName[SERVICE_NAME_INDEX]);
                if (NULL == (pwszCurrentService =
                        GetCurrentServiceOrUserName()))
                    goto GetCurrentServiceNameError;
                rgpwszService[1] = pwszCurrentService;
            } else {
                if (NULL == pInfo->rgpwszName[SERVICE_NAME_INDEX]) {
                    // May be NULL for CertEnumSystemStore
                    assert(NULL == pInfo->rgpwszName[SYSTEM_NAME_INDEX]);
                    assert(NULL == pInfo->rgpwszName[PHYSICAL_NAME_INDEX]);
                    rgNameGroup[0].cName = 1;
                } else
                    rgpwszService[1] = pInfo->rgpwszName[SERVICE_NAME_INDEX];
            }
            break;
        case CERT_SYSTEM_STORE_CURRENT_USER:
        case CERT_SYSTEM_STORE_LOCAL_MACHINE:
            rgpwszUser[0] = SYSTEM_STORE_REGPATH;
            rgNameGroup[0].cName = 1;
            rgNameGroup[0].rgpwszName = rgpwszUser;
            break;
        case CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY:
        case CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY:
            rgpwszUser[0] = GROUP_POLICY_STORE_REGPATH;
            rgNameGroup[0].cName = 1;
            rgNameGroup[0].rgpwszName = rgpwszUser;
            break;
        case CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE:
            rgpwszUser[0] = ENTERPRISE_STORE_REGPATH;
            rgNameGroup[0].cName = 1;
            rgNameGroup[0].rgpwszName = rgpwszUser;
            break;
        case CERT_SYSTEM_STORE_USERS:
            if (NULL == pInfo->rgpwszName[USER_NAME_INDEX]) {
                // May be NULL for CertEnumSystemStore
                assert(NULL == pInfo->rgpwszName[SYSTEM_NAME_INDEX]);
                assert(NULL == pInfo->rgpwszName[PHYSICAL_NAME_INDEX]);
                rgNameGroup[0].cName = 0;
            } else {
                rgpwszUser[0] = pInfo->rgpwszName[USER_NAME_INDEX];
                rgpwszUser[1] = SYSTEM_STORE_REGPATH;
                rgNameGroup[0].cName = 2;
                rgNameGroup[0].rgpwszName = rgpwszUser;
            }
            break;
        default:
            goto InvalidArg;
    }

    rgNameGroup[1].rgpwszName = rgpwszStore;
    rgpwszStore[0] = pInfo->rgpwszName[SYSTEM_NAME_INDEX];
    if (pInfo->rgpwszName[PHYSICAL_NAME_INDEX]) {
        assert(pInfo->rgpwszName[SYSTEM_NAME_INDEX]);
        rgNameGroup[1].cName = 3;
        rgpwszStore[1] = PHYSICAL_STORES_SUBKEY_NAME;
        rgpwszStore[2] = pInfo->rgpwszName[PHYSICAL_NAME_INDEX];
    } else
        rgNameGroup[1].cName = 1;

    if (pInfo->rgpwszName[COMPUTER_NAME_INDEX]) {
        assert(IsRemotableSystemStoreLocationInRegistry(dwFlags));
        assert(NULL == pInfo->hKeyBase);
        if (ERROR_SUCCESS != (err = RegConnectRegistryU(
                pInfo->rgpwszName[COMPUTER_NAME_INDEX],
                (CERT_SYSTEM_STORE_USERS == dwStoreLocation) ?
                    HKEY_USERS : HKEY_LOCAL_MACHINE,
                &hKey)))
            goto RegConnectRegistryError;
    } else if (pInfo->hKeyBase) {
        assert(dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG);
        hKey = pInfo->hKeyBase;
    } else {
        switch (dwStoreLocation) {
            case CERT_SYSTEM_STORE_CURRENT_USER:
            case CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY:
                hKey = HKEY_CURRENT_USER;
                break;
            case CERT_SYSTEM_STORE_LOCAL_MACHINE:
            case CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY:
            case CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE:
            case CERT_SYSTEM_STORE_CURRENT_SERVICE:
            case CERT_SYSTEM_STORE_SERVICES:
                hKey = HKEY_LOCAL_MACHINE;
                break;
            case CERT_SYSTEM_STORE_USERS:
                hKey = HKEY_USERS;
                break;
            default:
                goto InvalidArg;
        }
    }

    if (NULL == (pwszRegPath = FormatSystemNamePath(
            cNameGroup,
            rgNameGroup
            )))
        goto FormatSystemNamePathError;

CommonReturn:
    PkiFree(pwszCurrentService);
    *phKey = hKey;
    return pwszRegPath;
ErrorReturn:
    pwszRegPath = NULL;
    goto CommonReturn;

TRACE_ERROR(GetCurrentServiceNameError)
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR_VAR(RegConnectRegistryError, err)
TRACE_ERROR(FormatSystemNamePathError)
}

STATIC HKEY OpenSystemRegPathKey(
    IN PSYSTEM_NAME_INFO pInfo,
    IN OPTIONAL LPCWSTR pwszSubKeyName,
    IN DWORD dwFlags
    )
{
    LPWSTR pwszRegPath;
    HKEY hKey = NULL;
    HKEY hKeyRegPath;

    if (NULL == (pwszRegPath = FormatSystemRegPath(
            pInfo,
            pwszSubKeyName,
            dwFlags,
            &hKey
            )))
        goto FormatSystemRegPathError;

    hKeyRegPath = OpenSubKey(
        hKey,
        pwszRegPath,
        dwFlags
        );

CommonReturn:
    PkiFree(pwszRegPath);
    if (pInfo->rgpwszName[COMPUTER_NAME_INDEX] && hKey)
        ILS_CloseRegistryKey(hKey);
    return hKeyRegPath;
ErrorReturn:
    hKeyRegPath = NULL;
    goto CommonReturn;

TRACE_ERROR(FormatSystemRegPathError)
}


STATIC HKEY OpenSystemStore(
    IN const void *pvPara,
    IN DWORD dwFlags
    )
{
    HKEY hKey;
    SYSTEM_NAME_INFO SystemNameInfo;

    if (!ParseSystemStorePara(
            pvPara,
            dwFlags,
            1,                  // cReqName
            &SystemNameInfo))   // zero'ed on error
        goto ParseSystemStoreParaError;

    hKey = OpenSystemRegPathKey(
        &SystemNameInfo,
        NULL,               // pwszSubKeyName
        dwFlags
        );

CommonReturn:
    FreeSystemNameInfo(&SystemNameInfo);
    return hKey;
ErrorReturn:
    hKey = NULL;
    goto CommonReturn;
TRACE_ERROR(ParseSystemStoreParaError)
}

STATIC HKEY OpenPhysicalStores(
    IN const void *pvPara,
    IN DWORD dwFlags
    )
{
    HKEY hKey;
    SYSTEM_NAME_INFO SystemNameInfo;

    if (!ParseSystemStorePara(
            pvPara,
            dwFlags,
            1,                  // cReqName
            &SystemNameInfo))   // zero'ed on error
        goto ParseSystemStoreParaError;

    hKey = OpenSystemRegPathKey(
        &SystemNameInfo,
        PHYSICAL_STORES_SUBKEY_NAME,
        dwFlags
        );

CommonReturn:
    FreeSystemNameInfo(&SystemNameInfo);
    return hKey;
ErrorReturn:
    hKey = NULL;
    goto CommonReturn;
TRACE_ERROR(ParseSystemStoreParaError)
}

//+-------------------------------------------------------------------------
//  Register a system store.
//
//  The upper word of the dwFlags parameter is used to specify the location of
//  the system store.
//
//  Set CERT_STORE_CREATE_NEW_FLAG to cause a failure if the system store
//  already exists in the store location.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertRegisterSystemStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN PCERT_SYSTEM_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fResult;
    HKEY hKey;

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[REGISTER_SYSTEM_STORE_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            return FALSE;

        fResult = ((PFN_REGISTER_SYSTEM_STORE) pvFuncAddr)(
            pvSystemStore,
            dwFlags,
            pStoreInfo,
            pvReserved
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        return fResult;
    }

    if (dwFlags & ~REGISTER_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    if (NULL == (hKey = OpenSystemStore(pvSystemStore, dwFlags)))
        goto OpenSystemStoreError;
    RegCloseKey(hKey);
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OpenSystemStoreError)
}

//+-------------------------------------------------------------------------
//  Register a physical store for the specified system store.
//
//  The upper word of the dwFlags parameter is used to specify the location of
//  the system store.
//
//  Set CERT_STORE_CREATE_NEW_FLAG to cause a failure if the physical store
//  already exists in the system store.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertRegisterPhysicalStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fResult;
    LONG err;
    HKEY hKey = NULL;

    SYSTEM_NAME_INFO SystemNameInfo;

    char szOID[34];
    LPCSTR pszOID;

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[REGISTER_PHYSICAL_STORE_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            return FALSE;

        fResult = ((PFN_REGISTER_PHYSICAL_STORE) pvFuncAddr)(
            pvSystemStore,
            dwFlags,
            pwszStoreName,
            pStoreInfo,
            pvReserved
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        return fResult;
    }

    if (!ParseSystemStorePara(
            pvSystemStore,
            dwFlags,
            1,                  // cReqName
            &SystemNameInfo))   // zero'ed on error
        goto ParseSystemStoreParaError;

    if (NULL == pwszStoreName || L'\0' == *pwszStoreName ||
            HasBackslash(pwszStoreName))
        goto InvalidArg;
    assert(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX]);
    assert(NULL == SystemNameInfo.rgpwszName[PHYSICAL_NAME_INDEX]);
    SystemNameInfo.rgpwszName[PHYSICAL_NAME_INDEX] = (LPWSTR) pwszStoreName;

    if (dwFlags & ~REGISTER_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    if (NULL == pStoreInfo ||
            sizeof(CERT_PHYSICAL_STORE_INFO) > pStoreInfo->cbSize)
        goto InvalidArg;

    if (NULL == (hKey = OpenSystemRegPathKey(
            &SystemNameInfo,
            NULL,               // pwszSubKeyName
            dwFlags
            )))
        goto OpenSystemRegPathKeyError;

    pszOID = pStoreInfo->pszOpenStoreProvider;
    if (0xFFFF >= (DWORD_PTR) pszOID) {
        // Convert to "#<number>" string
        szOID[0] = CONST_OID_STR_PREFIX_CHAR;
        _ltoa((long) ((DWORD_PTR) pszOID), szOID + 1, 10);
        pszOID = szOID;
    }
    if (ERROR_SUCCESS != (err = RegSetValueExA(
            hKey,
            "OpenStoreProvider",
            0,          // dwReserved
            REG_SZ,
            (BYTE *) pszOID,
            strlen(pszOID) + 1)))
        goto RegSetOpenStoreProviderError;

    if (!WriteDWORDValueToRegistry(
            hKey,
            L"OpenEncodingType",
            pStoreInfo->dwOpenEncodingType))
        goto WriteDWORDError;
    if (!WriteDWORDValueToRegistry(
            hKey,
            L"OpenFlags",
            pStoreInfo->dwOpenFlags))
        goto WriteDWORDError;

    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hKey,
            L"OpenParameters",
            0,          // dwReserved
            REG_BINARY,
            pStoreInfo->OpenParameters.pbData,
            pStoreInfo->OpenParameters.cbData)))
        goto RegSetOpenParametersError;

    if (!WriteDWORDValueToRegistry(
            hKey,
            L"Flags",
            pStoreInfo->dwFlags))
        goto WriteDWORDError;
    if (!WriteDWORDValueToRegistry(
            hKey,
            L"Priority",
            pStoreInfo->dwPriority))
        goto WriteDWORDError;

    fResult = TRUE;

CommonReturn:
    SystemNameInfo.rgpwszName[PHYSICAL_NAME_INDEX] = NULL;   // not allocated
    FreeSystemNameInfo(&SystemNameInfo);
    ILS_CloseRegistryKey(hKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(ParseSystemStoreParaError)
TRACE_ERROR(OpenSystemRegPathKeyError)
SET_ERROR_VAR(RegSetOpenStoreProviderError, err)
SET_ERROR_VAR(RegSetOpenParametersError, err)
TRACE_ERROR(WriteDWORDError)
}

//+-------------------------------------------------------------------------
//  Unregister the specified system store.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertUnregisterSystemStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    HKEY hKey = NULL;
    SYSTEM_NAME_INFO SystemNameInfo;
    LPWSTR pwszStore;       // not allocated

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[UNREGISTER_SYSTEM_STORE_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            return FALSE;

        fResult = ((PFN_UNREGISTER_SYSTEM_STORE) pvFuncAddr)(
            pvSystemStore,
            dwFlags
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        return fResult;
    }

    if (!ParseSystemStorePara(
            pvSystemStore,
            dwFlags,
            1,                      // cReqName
            &SystemNameInfo))       // zero'ed on error
        goto ParseSystemStoreParaError;

    if (dwFlags & ~UNREGISTER_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    // Delete the SystemRegistry components
    if (NULL == (hKey = OpenSystemRegPathKey(
            &SystemNameInfo,
            NULL,                   // pwszSubKeyName
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG
            )))
        goto OpenSystemRegPathKeyError;
    if (!DeleteAllFromRegistry(
            hKey,
            (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) |
                (SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX] ?
                    CERT_REGISTRY_STORE_REMOTE_FLAG : 0)
            ))
        goto DeleteAllError;

    RegCloseKey(hKey);
    hKey = NULL;

    // Open SystemCertificates SubKey preceding the store. In order to do this
    // the SYSTEM_NAME component must be NULL.
    assert(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX]);
    pwszStore = SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX];
    SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX] = NULL;
    hKey = OpenSystemRegPathKey(
            &SystemNameInfo,
            NULL,                   // pwszSubKeyName
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG
            );
    SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX] = pwszStore;
    if (NULL == hKey)
        goto OpenSystemRegPathKeyError;

    // Delete the remaining System components (such as PhysicalStores) and
    // the System store itself
    if (!RecursiveDeleteSubKey(hKey, pwszStore, dwFlags))
        goto DeleteSubKeyError;
    fResult = TRUE;

CommonReturn:
    FreeSystemNameInfo(&SystemNameInfo);
    ILS_CloseRegistryKey(hKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ParseSystemStoreParaError)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(DeleteAllError)
TRACE_ERROR(OpenSystemRegPathKeyError)
TRACE_ERROR(DeleteSubKeyError)
}

//+-------------------------------------------------------------------------
//  Unregister the physical store from the specified system store.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertUnregisterPhysicalStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName
    )
{
    BOOL fResult;
    HKEY hKey = NULL;

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[UNREGISTER_PHYSICAL_STORE_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            return FALSE;

        fResult = ((PFN_UNREGISTER_PHYSICAL_STORE) pvFuncAddr)(
            pvSystemStore,
            dwFlags,
            pwszStoreName
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        return fResult;
    }

    if (dwFlags & ~UNREGISTER_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    if (NULL == (hKey = OpenPhysicalStores(
            pvSystemStore,
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG
            )))
        goto OpenPhysicalStoresError;
    if (!RecursiveDeleteSubKey(hKey, pwszStoreName, dwFlags))
        goto DeleteSubKeyError;
    fResult = TRUE;

CommonReturn:
    ILS_CloseRegistryKey(hKey);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OpenPhysicalStoresError)
TRACE_ERROR(DeleteSubKeyError)
}

typedef struct _ENUM_REGISTERED_SYSTEM_STORE_LOCATION_INFO {
    DWORD                               dwLastError;
    void                                *pvArg;
    PFN_CERT_ENUM_SYSTEM_STORE_LOCATION pfnEnum;
} ENUM_REGISTERED_SYSTEM_STORE_LOCATION_INFO,
    *PENUM_REGISTERED_SYSTEM_STORE_LOCATION_INFO;

STATIC BOOL WINAPI EnumRegisteredSystemStoreLocationCallback(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN DWORD cValue,
    IN const DWORD rgdwValueType[],
    IN LPCWSTR const rgpwszValueName[],
    IN const BYTE * const rgpbValueData[],
    IN const DWORD rgcbValueData[],
    IN void *pvArg
    )
{
    PENUM_REGISTERED_SYSTEM_STORE_LOCATION_INFO pEnumRegisteredInfo =
        (PENUM_REGISTERED_SYSTEM_STORE_LOCATION_INFO) pvArg;

    LPCWSTR pwszLocation = L"";
    DWORD dwFlags;

    if (0 != pEnumRegisteredInfo->dwLastError)
        return FALSE;

    if (CONST_OID_STR_PREFIX_CHAR != *pszOID)
        return TRUE;
    dwFlags =
        (((DWORD) atol(pszOID + 1)) << CERT_SYSTEM_STORE_LOCATION_SHIFT) &
            CERT_SYSTEM_STORE_LOCATION_MASK;
    if (0 == dwFlags)
        return TRUE;

    // Try to find the SystemStoreLocation value
    while (cValue--) {
        if (0 == _wcsicmp(rgpwszValueName[cValue],
                    CRYPT_OID_SYSTEM_STORE_LOCATION_VALUE_NAME) &&
                REG_SZ == rgdwValueType[cValue]) {
            pwszLocation = (LPCWSTR) rgpbValueData[cValue];
            break;
        }
    }

    if (!pEnumRegisteredInfo->pfnEnum(
            pwszLocation,
            dwFlags,
            NULL,                                       // pvReserved
            pEnumRegisteredInfo->pvArg
            )) {
        if (0 == (pEnumRegisteredInfo->dwLastError = GetLastError()))
            pEnumRegisteredInfo->dwLastError = (DWORD) E_UNEXPECTED;
        return FALSE;
    } else
        return TRUE;
}

//+-------------------------------------------------------------------------
//  Enumerate the system store locations.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertEnumSystemStoreLocation(
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CERT_ENUM_SYSTEM_STORE_LOCATION pfnEnum
    )
{
    DWORD i;
    ENUM_REGISTERED_SYSTEM_STORE_LOCATION_INFO EnumRegisteredInfo;

    if (dwFlags & ~ENUM_FLAGS_MASK) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    // Enumerate through the predefined, crypt32.dll system store locations
    for (i = 0; i < ENUM_SYSTEM_STORE_LOCATION_CNT; i++) {
        if (!pfnEnum(
                rgEnumSystemStoreLocationInfo[i].pwszLocation,
                rgEnumSystemStoreLocationInfo[i].dwFlags,
                NULL,                                       // pvReserved
                pvArg
                ))
            return FALSE;
    }

    // Enumerate through the registered system store locations
    EnumRegisteredInfo.dwLastError = 0;
    EnumRegisteredInfo.pvArg = pvArg;
    EnumRegisteredInfo.pfnEnum = pfnEnum;
    CryptEnumOIDFunction(
            0,                              // dwEncodingType
            CRYPT_OID_ENUM_SYSTEM_STORE_FUNC,
            NULL,                           // pszOID
            0,                              // dwFlags
            (void *) &EnumRegisteredInfo,   // pvArg
            EnumRegisteredSystemStoreLocationCallback
            );

    if (0 != EnumRegisteredInfo.dwLastError) {
        SetLastError(EnumRegisteredInfo.dwLastError);
        return FALSE;
    } else
        return TRUE;
}

STATIC BOOL EnumServicesOrUsersSystemStore(
    IN OUT PSYSTEM_NAME_INFO pLocationNameInfo,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CERT_ENUM_SYSTEM_STORE pfnEnum
    )
{
    BOOL fResult;
    HKEY hKey = NULL;
    DWORD cSubKeys;
    DWORD cchMaxSubKey;
    LPWSTR pwszEnumServiceName = NULL;
    void *pvEnumServicePara = NULL;
    BOOL fDidEnum;

    assert(NULL == pLocationNameInfo->rgpwszName[SERVICE_NAME_INDEX]);

    // Opens ..\Cryptography\Services SubKey or HKEY_USERS SubKey
    if (NULL == (hKey = OpenSystemRegPathKey(
            pLocationNameInfo,
            NULL,               // pwszSubKeyName
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG
            )))
        goto OpenSystemRegPathKeyError;

    if (!GetSubKeyInfo(
            hKey,
            &cSubKeys,
            &cchMaxSubKey
            ))
        goto GetSubKeyInfoError;

    // Enumerates the ServiceOrUserNames
    fDidEnum = FALSE;
    if (cSubKeys && cchMaxSubKey) {
        DWORD i;

        LPCWSTR rgpwszEnumName[2];
        SYSTEM_NAME_GROUP EnumNameGroup;
        EnumNameGroup.cName = 2;
        EnumNameGroup.rgpwszName = rgpwszEnumName;

        cchMaxSubKey++;
        if (NULL == (pwszEnumServiceName = (LPWSTR) PkiNonzeroAlloc(
                cchMaxSubKey * sizeof(WCHAR))))
            goto OutOfMemory;

        rgpwszEnumName[0] = pLocationNameInfo->rgpwszName[COMPUTER_NAME_INDEX];
        rgpwszEnumName[1] = pwszEnumServiceName;

        for (i = 0; i < cSubKeys; i++) {
            DWORD cchEnumServiceName = cchMaxSubKey;
            LONG err;
            if (ERROR_SUCCESS != (err = RegEnumKeyExU(
                    hKey,
                    i,
                    pwszEnumServiceName,
                    &cchEnumServiceName,
                    NULL,               // lpdwReserved
                    NULL,               // lpszClass
                    NULL,               // lpcchClass
                    NULL                // lpftLastWriteTime
                    )) || 0 == cchEnumServiceName ||
                            L'\0' == *pwszEnumServiceName) {
                if (ERROR_NO_MORE_ITEMS == err)
                    break;
                else
                    continue;
            }

            if (NULL == (pvEnumServicePara = FormatSystemNamePara(
                        1, &EnumNameGroup, pLocationNameInfo)))
                goto FormatSystemNameParaError;

            if (!CertEnumSystemStore(
                    dwFlags,
                    pvEnumServicePara,
                    pvArg,
                    pfnEnum
                    )) {
                if (ERROR_FILE_NOT_FOUND != GetLastError())
                    goto EnumSystemStoreError;
            } else
                fDidEnum = TRUE;
            FreeSystemNamePara(pvEnumServicePara, pLocationNameInfo);
            pvEnumServicePara = NULL;
        }
    }

    if (!fDidEnum)
        goto NoSystemStores;
    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKey);
    PkiFree(pwszEnumServiceName);
    FreeSystemNamePara(pvEnumServicePara, pLocationNameInfo);
    FreeSystemNameInfo(pLocationNameInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenSystemRegPathKeyError)
TRACE_ERROR(GetSubKeyInfoError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(FormatSystemNameParaError)
TRACE_ERROR(EnumSystemStoreError)
SET_ERROR(NoSystemStores, ERROR_FILE_NOT_FOUND)
}

//+-------------------------------------------------------------------------
//  Enumerate the system stores.
//
//  The upper word of the dwFlags parameter is used to specify the location of
//  the system store.
//
//  All registry based system store locations have the predefined stores
//  of: My, Root, Trust and CA.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertEnumSystemStore(
    IN DWORD dwFlags,
    IN OPTIONAL void *pvSystemStoreLocationPara,
    IN void *pvArg,
    IN PFN_CERT_ENUM_SYSTEM_STORE pfnEnum
    )
{
    BOOL fResult;
    HKEY hKey = NULL;
    DWORD cSubKeys;
    DWORD cchMaxSubKey = 0;
    SYSTEM_NAME_INFO LocationNameInfo;
    LPWSTR pwszEnumSystemStore = NULL;
    void *pvEnumSystemPara = NULL;

    DWORD i;
    DWORD dwCheckFlag;
    DWORD dwLocID;
    DWORD dwPredefinedSystemFlags;

    CERT_SYSTEM_STORE_INFO NullSystemStoreInfo;
    LPCWSTR rgpwszEnumName[3];
    SYSTEM_NAME_GROUP EnumNameGroup;

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[ENUM_SYSTEM_STORE_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            return FALSE;

        fResult = ((PFN_ENUM_SYSTEM_STORE) pvFuncAddr)(
            dwFlags,
            pvSystemStoreLocationPara,
            pvArg,
            pfnEnum
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        return fResult;
    }

    if (!ParseSystemStorePara(
            pvSystemStoreLocationPara,
            dwFlags,
            0,                  // cReqName, none for enumeration
            &LocationNameInfo   // zero'ed for error
            ))
        goto ParseSystemStoreParaError;

    if (dwFlags & ~ENUM_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    dwLocID = GetSystemStoreLocationID(dwFlags);
    if ((CERT_SYSTEM_STORE_SERVICES_ID == dwLocID ||
             CERT_SYSTEM_STORE_USERS_ID == dwLocID)
                                &&
            NULL == LocationNameInfo.rgpwszName[SERVICE_NAME_INDEX])
        // Following frees rgpwszLocationName entries
        return EnumServicesOrUsersSystemStore(
            &LocationNameInfo,
            dwFlags,
            pvArg,
            pfnEnum
            );

    // Opens SystemCertificates subkey
    if (NULL == (hKey = OpenSystemRegPathKey(
            &LocationNameInfo,
            NULL,               // pwszSubKeyName
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG
            ))) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            goto OpenSystemRegPathKeyError;

        // Note, a registry entry isn't needed for the predefined stores
        cSubKeys = 0;
    } else if (!GetSubKeyInfo(
            hKey,
            &cSubKeys,
            &cchMaxSubKey
            ))
        goto GetSubKeyInfoError;

    memset(&NullSystemStoreInfo, 0, sizeof(NullSystemStoreInfo));
    NullSystemStoreInfo.cbSize = sizeof(NullSystemStoreInfo);
    EnumNameGroup.cName = 3;
    EnumNameGroup.rgpwszName = rgpwszEnumName;
    rgpwszEnumName[0] = LocationNameInfo.rgpwszName[COMPUTER_NAME_INDEX];
    rgpwszEnumName[1] = LocationNameInfo.rgpwszName[SERVICE_NAME_INDEX];

    // Enumerate the predefined system stores.
    assert(NUM_SYSTEM_STORE_LOCATION > dwLocID);
    dwPredefinedSystemFlags =
        rgSystemStoreLocationInfo[dwLocID].dwPredefinedSystemFlags;
    for (i = 0, dwCheckFlag = 1; i < NUM_PREDEFINED_SYSTEM_STORE;
                                        i++, dwCheckFlag = dwCheckFlag << 1) {
        if (0 == (dwCheckFlag & dwPredefinedSystemFlags))
            continue;
        rgpwszEnumName[2] = rgpwszPredefinedSystemStore[i];
        if (NULL == (pvEnumSystemPara = FormatSystemNamePara(
                1, &EnumNameGroup, &LocationNameInfo)))
            goto FormatSystemNameParaError;
        if (!pfnEnum(
                pvEnumSystemPara,
                dwFlags & CERT_SYSTEM_STORE_MASK,
                &NullSystemStoreInfo,
                NULL,               // pvReserved
                pvArg
                ))
            goto EnumCallbackError;
        FreeSystemNamePara(pvEnumSystemPara, &LocationNameInfo);
        pvEnumSystemPara = NULL;
    }

    // Enumerate the registered systems stores. Skip past any of the above
    // predefined stores
    if (cSubKeys && cchMaxSubKey) {
        cchMaxSubKey++;
        if (NULL == (pwszEnumSystemStore = (LPWSTR) PkiNonzeroAlloc(
                cchMaxSubKey * sizeof(WCHAR))))
            goto OutOfMemory;

        rgpwszEnumName[2] = pwszEnumSystemStore;

        for (i = 0; i < cSubKeys; i++) {
            DWORD cchEnumSystemStore = cchMaxSubKey;
            LONG err;

            if (ERROR_SUCCESS != (err = RegEnumKeyExU(
                    hKey,
                    i,
                    pwszEnumSystemStore,
                    &cchEnumSystemStore,
                    NULL,               // lpdwReserved
                    NULL,               // lpszClass
                    NULL,               // lpcchClass
                    NULL                // lpftLastWriteTime
                    )) || 0 == cchEnumSystemStore) {
                if (ERROR_NO_MORE_ITEMS == err)
                    break;
                else
                    continue;
            }

            if (IsPredefinedSystemStore(pwszEnumSystemStore, dwFlags))
                // Already enumerated above
                continue;
            if (NULL == (pvEnumSystemPara = FormatSystemNamePara(
                        1, &EnumNameGroup, &LocationNameInfo)))
                goto FormatSystemNameParaError;

            if (!pfnEnum(
                    pvEnumSystemPara,
                    dwFlags & CERT_SYSTEM_STORE_MASK,
                    &NullSystemStoreInfo,
                    NULL,               // pvReserved
                    pvArg
                    ))
                goto EnumCallbackError;
            FreeSystemNamePara(pvEnumSystemPara, &LocationNameInfo);
            pvEnumSystemPara = NULL;
        }
    }

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKey);
    PkiFree(pwszEnumSystemStore);
    FreeSystemNamePara(pvEnumSystemPara, &LocationNameInfo);
    FreeSystemNameInfo(&LocationNameInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ParseSystemStoreParaError)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OpenSystemRegPathKeyError)
TRACE_ERROR(GetSubKeyInfoError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(FormatSystemNameParaError)
TRACE_ERROR(EnumCallbackError)
}

typedef struct _ENUM_PHYSICAL_STORE_INFO ENUM_PHYSICAL_STORE_INFO,
    *PENUM_PHYSICAL_STORE_INFO;
struct _ENUM_PHYSICAL_STORE_INFO {
    CERT_PHYSICAL_STORE_INFO    RegistryInfo;
    LPWSTR                      pwszStoreName;
    PENUM_PHYSICAL_STORE_INFO   pNext;
};

STATIC void FreeEnumPhysicalStoreInfo(
    IN PENUM_PHYSICAL_STORE_INFO pStoreInfo
    )
{
    PCERT_PHYSICAL_STORE_INFO pRegistryInfo = &pStoreInfo->RegistryInfo;
    PkiFree(pRegistryInfo->OpenParameters.pbData);
    PkiFree(pRegistryInfo->pszOpenStoreProvider);
    PkiFree(pStoreInfo->pwszStoreName);
    PkiFree(pStoreInfo);
}


STATIC PENUM_PHYSICAL_STORE_INFO GetEnumPhysicalStoreInfo(
    IN HKEY hKey,
    IN LPCWSTR pwszStoreName,
    IN DWORD dwFlags            // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    )
{
    LONG err;
    HKEY hSubKey = NULL;
    PENUM_PHYSICAL_STORE_INFO pStoreInfo;
    PCERT_PHYSICAL_STORE_INFO pRegistryInfo;        // not allocated

    if (NULL == (pStoreInfo = (PENUM_PHYSICAL_STORE_INFO) PkiZeroAlloc(
            sizeof(ENUM_PHYSICAL_STORE_INFO))))
        return NULL;
    pRegistryInfo = &pStoreInfo->RegistryInfo;
    pRegistryInfo->cbSize = sizeof(*pRegistryInfo);

    if (NULL == (pStoreInfo->pwszStoreName =
            ILS_AllocAndCopyString(pwszStoreName)))
        goto OutOfMemory;

    if (ERROR_SUCCESS != (err = OpenHKCUKeyExU(
            hKey,
            pwszStoreName,
            dwFlags,
            KEY_READ,
            &hSubKey)))
        goto OpenHKCUKeyError;

    if (!ILS_ReadBINARYValueFromRegistry(
            hSubKey,
            L"OpenParameters",
            &pRegistryInfo->OpenParameters.pbData,
            &pRegistryInfo->OpenParameters.cbData
            )) {
        LPWSTR pwszParameters;
        if (pwszParameters = ILS_ReadSZValueFromRegistry(
                hSubKey,
                L"OpenParameters"
                )) {
            pRegistryInfo->OpenParameters.pbData = (BYTE *) pwszParameters;
            pRegistryInfo->OpenParameters.cbData =
                (wcslen(pwszParameters) + 1) * sizeof(WCHAR);
        } else {
            // Default to empty string
            if (NULL == (pRegistryInfo->OpenParameters.pbData =
                    (BYTE *) ILS_AllocAndCopyString(L"")))
                goto OutOfMemory;
            pRegistryInfo->OpenParameters.cbData = 0;
        }
    }

    if (NULL == (pRegistryInfo->pszOpenStoreProvider = ILS_ReadSZValueFromRegistry(
            hSubKey,
            "OpenStoreProvider"
            )))
        goto NoOpenStoreProviderError;

    ILS_ReadDWORDValueFromRegistry(
        hSubKey,
        L"OpenFlags",
        &pRegistryInfo->dwOpenFlags
        );

    ILS_ReadDWORDValueFromRegistry(
        hSubKey,
        L"OpenEncodingType",
        &pRegistryInfo->dwOpenEncodingType
        );

    ILS_ReadDWORDValueFromRegistry(
        hSubKey,
        L"Flags",
        &pRegistryInfo->dwFlags
        );

    ILS_ReadDWORDValueFromRegistry(
        hSubKey,
        L"Priority",
        &pRegistryInfo->dwPriority
        );

CommonReturn:
    ILS_CloseRegistryKey(hSubKey);
    return pStoreInfo;
ErrorReturn:
    FreeEnumPhysicalStoreInfo(pStoreInfo);
    pStoreInfo = NULL;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(OpenHKCUKeyError, err)
TRACE_ERROR(NoOpenStoreProviderError)
}


STATIC BOOL IsSelfPhysicalStoreInfo(
    IN PSYSTEM_NAME_INFO pSystemNameInfo,
    IN DWORD dwFlags,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    OUT DWORD *pdwSystemProviderFlags
    )
{
    BOOL fResult;
    DWORD dwSystemProviderFlags;
    LPWSTR pwszStoreName = (LPWSTR) pStoreInfo->OpenParameters.pbData;
    SYSTEM_NAME_INFO StoreNameInfo;

    LPWSTR pwszCurrentServiceName = NULL;
    LPWSTR pwszCurrentComputerName = NULL;

    DWORD dwSystemLocation;
    DWORD dwInfoLocation;
    BOOL fSameLocation;

    *pdwSystemProviderFlags = 0;

    dwSystemLocation = dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK;
    // Note, if the RELOCATE_FLAG is incorrectly set in the dwOpenFlags
    // then, never match
    dwInfoLocation = pStoreInfo->dwOpenFlags &
        (CERT_SYSTEM_STORE_LOCATION_MASK | CERT_SYSTEM_STORE_RELOCATE_FLAG);


    // Check if in same system store location
    fSameLocation = (dwSystemLocation == dwInfoLocation);
    if (!fSameLocation) {
        if (CERT_SYSTEM_STORE_CURRENT_SERVICE == dwInfoLocation)
            dwInfoLocation = CERT_SYSTEM_STORE_SERVICES;
        if (CERT_SYSTEM_STORE_CURRENT_SERVICE == dwSystemLocation)
            dwSystemLocation = CERT_SYSTEM_STORE_SERVICES;
        if (CERT_SYSTEM_STORE_CURRENT_USER == dwInfoLocation)
            dwInfoLocation = CERT_SYSTEM_STORE_USERS;
        if (CERT_SYSTEM_STORE_CURRENT_USER == dwSystemLocation)
            dwSystemLocation = CERT_SYSTEM_STORE_USERS;

        if (dwSystemLocation != dwInfoLocation)
            return FALSE;
    }

    // Check if SYSTEM or SYSTEM_REGISTRY store.
    dwSystemProviderFlags = GetSystemProviderFlags(
        pStoreInfo->pszOpenStoreProvider);
    if (0 == dwSystemProviderFlags ||
            (dwSystemProviderFlags & PHYSICAL_PROVIDER_FLAG))
        return FALSE;

    if (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG) {
        if (NULL == (pwszStoreName = MkWStr((LPSTR) pwszStoreName)))
            return FALSE;
    }

    if (!ParseSystemStorePara(
            pwszStoreName,
            pStoreInfo->dwOpenFlags,
            1,                  // cReq, 1 for OpenSystemStore
            &StoreNameInfo      // zero'ed for error
            ))
        goto ParseSystemStoreParaError;

    // Default to not self
    fResult = FALSE;

    if (StoreNameInfo.rgpwszName[COMPUTER_NAME_INDEX]) {
        if (NULL == pSystemNameInfo->rgpwszName[COMPUTER_NAME_INDEX]) {
            LPCWSTR pwszStoreComputerName;

            if (NULL == (pwszCurrentComputerName = GetCurrentComputerName()))
                goto GetCurrentComputerNameError;

            pwszStoreComputerName =
                StoreNameInfo.rgpwszName[COMPUTER_NAME_INDEX];
            assert(L'\\' == pwszStoreComputerName[0] &&
                L'\\' == pwszStoreComputerName[1]);
            if (!('\\' == pwszCurrentComputerName[0] &&
                    L'\\' == pwszCurrentComputerName[1]))
                pwszStoreComputerName += 2;
            if (0 != _wcsicmp(pwszStoreComputerName, pwszCurrentComputerName))
                goto CommonReturn;
        } else if (0 != _wcsicmp(StoreNameInfo.rgpwszName[COMPUTER_NAME_INDEX],
                pSystemNameInfo->rgpwszName[COMPUTER_NAME_INDEX]))
            goto CommonReturn;
    }
    // else
    //  Opening using none or the same computer name

    if (StoreNameInfo.rgpwszName[SERVICE_NAME_INDEX]) {
        if (NULL == pSystemNameInfo->rgpwszName[SERVICE_NAME_INDEX]) {
            if (NULL == (pwszCurrentServiceName =
                    GetCurrentServiceOrUserName()))
                goto GetCurrentServiceOrUserNameError;
            if (0 != _wcsicmp(StoreNameInfo.rgpwszName[SERVICE_NAME_INDEX],
                    pwszCurrentServiceName))
                goto CommonReturn;
        } else if (0 != _wcsicmp(StoreNameInfo.rgpwszName[SERVICE_NAME_INDEX],
                pSystemNameInfo->rgpwszName[SERVICE_NAME_INDEX]))
            goto CommonReturn;
    }
    // else
    //  Opening using none or the same service/user name

    assert(StoreNameInfo.rgpwszName[SYSTEM_NAME_INDEX] &&
         pSystemNameInfo->rgpwszName[SYSTEM_NAME_INDEX]);
    if (0 != _wcsicmp(StoreNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
            pSystemNameInfo->rgpwszName[SYSTEM_NAME_INDEX]))
        goto CommonReturn;

    // We have a match !!!
    fResult = TRUE;
    *pdwSystemProviderFlags = dwSystemProviderFlags;

CommonReturn:
    if (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG)
        FreeWStr(pwszStoreName);
    FreeSystemNameInfo(&StoreNameInfo);
    PkiFree(pwszCurrentServiceName);
    PkiFree(pwszCurrentComputerName);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetCurrentComputerNameError)
TRACE_ERROR(GetCurrentServiceOrUserNameError)
TRACE_ERROR(ParseSystemStoreParaError)
}

// List is sorted according to physical store priority
STATIC void AddToEnumPhysicalStoreList(
    IN PENUM_PHYSICAL_STORE_INFO *ppStoreInfoHead,
    IN PENUM_PHYSICAL_STORE_INFO pAddInfo
    )
{

    if (NULL == *ppStoreInfoHead)
        *ppStoreInfoHead = pAddInfo;
    else {
        PENUM_PHYSICAL_STORE_INFO pListInfo;
        DWORD dwPriority = pAddInfo->RegistryInfo.dwPriority;

        pListInfo = *ppStoreInfoHead;
        if (dwPriority > pListInfo->RegistryInfo.dwPriority) {
            // Insert at beginning before first entry
            pAddInfo->pNext = pListInfo;
            *ppStoreInfoHead = pAddInfo;
        } else {
            // Insert after the entry whose next entry has
            // lower priority or insert after the last entry
            while (pListInfo->pNext &&
                    dwPriority <= pListInfo->pNext->RegistryInfo.dwPriority)
                pListInfo = pListInfo->pNext;

            pAddInfo->pNext = pListInfo->pNext;
            pListInfo->pNext = pAddInfo;
        }
    }
}


STATIC void FreeEnumPhysicalStoreList(
    IN PENUM_PHYSICAL_STORE_INFO pStoreInfoHead
    )
{
    while (pStoreInfoHead) {
        PENUM_PHYSICAL_STORE_INFO pStoreInfo = pStoreInfoHead;
        pStoreInfoHead = pStoreInfo->pNext;
        FreeEnumPhysicalStoreInfo(pStoreInfo);
    }

}

// Returns NULL if unable to successfully get the Url. Returned string
// must be freed by calling CryptMemFree
STATIC LPWSTR GetUserDsUserCertificateUrl()
{
    DWORD dwErr;
    LPWSTR pwszUrl = NULL;
    HMODULE hDll = NULL;
    PFN_GET_USER_DS_STORE_URL pfnGetUserDsStoreUrl;

    if (NULL == (hDll = LoadLibraryA(sz_CRYPTNET_DLL)))
        goto LoadCryptNetDllError;

    if (NULL == (pfnGetUserDsStoreUrl =
            (PFN_GET_USER_DS_STORE_URL) GetProcAddress(hDll,
                sz_GetUserDsStoreUrl)))
        goto GetUserDsStoreUrlProcAddressError;

    if (!pfnGetUserDsStoreUrl(wsz_USER_CERTIFICATE_ATTR, &pwszUrl)) {
        dwErr = GetLastError();
        goto GetUserDsStoreUrlError;
    }

CommonReturn:
    if (hDll) {
        dwErr = GetLastError();
        FreeLibrary(hDll);
        SetLastError(dwErr);
    }
    return pwszUrl;
ErrorReturn:
    pwszUrl = NULL;
    goto CommonReturn;
TRACE_ERROR(LoadCryptNetDllError)
TRACE_ERROR(GetUserDsStoreUrlProcAddressError)
SET_ERROR_VAR(GetUserDsStoreUrlError, dwErr)
}

STATIC BOOL IsCurrentUserTrustedPublishersAllowed()
{
    DWORD dwFlags = 0;

    I_CryptReadTrustedPublisherDWORDValueFromRegistry(
        CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME,
        &dwFlags
        );

    return 0 == (dwFlags &
        (CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST |
            CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST));
}

STATIC BOOL IsLocalMachineTrustedPublishersAllowed()
{
    DWORD dwFlags = 0;

    I_CryptReadTrustedPublisherDWORDValueFromRegistry(
        CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME,
        &dwFlags
        );

    return 0 == (dwFlags & CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST);
}


//+-------------------------------------------------------------------------
//  Unless, CERT_STORE_OPEN_EXISTING_FLAG or CERT_STORE_READONLY_FLAG is
//  set, the pvSystemStore will be created if it doesn't already exist.
//
//  Note, depending on the store location and possibly the store name, there
//  are predefined physical stores of .Default, .LocalMachine, .GroupPolicy,
//  .Enterprise
//--------------------------------------------------------------------------
STATIC BOOL EnumPhysicalStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum
    )
{
    BOOL fResult;
    LONG *plDepth = NULL;    // allocated per thread, don't free here
    HKEY hKey = NULL;
    DWORD cSubKeys;
    DWORD cchMaxSubKey = 0;
    LPWSTR pwszStoreName = NULL;
    PENUM_PHYSICAL_STORE_INFO pStoreInfoHead = NULL;
    PENUM_PHYSICAL_STORE_INFO pStoreInfo;       // not allocated
    SYSTEM_NAME_INFO SystemNameInfo;

    DWORD dwStoreLocationID;
    DWORD dwPredefinedPhysicalFlags;

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[ENUM_PHYSICAL_STORE_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            return FALSE;

        fResult = ((PFN_ENUM_PHYSICAL_STORE) pvFuncAddr)(
            pvSystemStore,
            dwFlags,
            pvArg,
            pfnEnum
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        return fResult;
    }

    if (!ParseSystemStorePara(
            pvSystemStore,
            dwFlags,
            1,                      // cReqName
            &SystemNameInfo))       // zero'ed on error
        goto ParseSystemStoreParaError;

    if (dwFlags & ~ENUM_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    // Check for cross store recursion by checking the thread's enum
    // depth
    if (NULL == (plDepth = (LONG *) I_CryptGetTls(
            hTlsEnumPhysicalStoreDepth))) {
        if (NULL == (plDepth = (LONG *) PkiNonzeroAlloc(sizeof(*plDepth))))
            goto OutOfMemory;
        *plDepth = 1;
        I_CryptSetTls(hTlsEnumPhysicalStoreDepth, plDepth);
    } else {
        *plDepth += 1;
        if (MAX_ENUM_PHYSICAL_STORE_DEPTH < *plDepth)
            goto ExceededEnumPhysicalStoreDepth_PossibleCrossStoreRecursion;
    }

    if (IsClientGptStore(&SystemNameInfo, dwFlags)) {
        cSubKeys = 0;
    } else if (NULL == (hKey = OpenSystemRegPathKey(
            &SystemNameInfo,
            PHYSICAL_STORES_SUBKEY_NAME,
            dwFlags | CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG
            ))) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            goto OpenPhysicalStoresError;

        // Check if we have a system store without the "PhysicalStores" subkey
        if (NULL == (hKey = OpenSystemRegPathKey(
                &SystemNameInfo,
                NULL,               // pwszSubKeyName
                dwFlags
                ))) {
            if (dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG)
                hKey = OpenSystemRegPathKey(
                    &SystemNameInfo,
                    NULL,               // pwszSubKeyName
                    dwFlags | CERT_STORE_OPEN_EXISTING_FLAG |
                        CERT_STORE_READONLY_FLAG
                    );
        }

        if (NULL == hKey) {
            // Note, the predefined stores don't need to exist in the
            // registry
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                goto OpenSystemStoreError;
        } else {
            RegCloseKey(hKey);
            hKey = NULL;
        }

        cSubKeys = 0;
    } else if (!GetSubKeyInfo(
            hKey,
            &cSubKeys,
            &cchMaxSubKey
            ))
        goto GetSubKeyInfoError;

    // Get flags containing list of predefined physical stores according to
    // store name and/or store location
    dwStoreLocationID = GetSystemStoreLocationID(dwFlags);
    if (0 == _wcsicmp(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
                wsz_MY_STORE) ||
            0 == _wcsicmp(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
                wsz_REQUEST_STORE))
        // Only .Default is predefined for "My" or "Request" store
        dwPredefinedPhysicalFlags = MY_PHYSICAL_FLAGS;
    else if (0 == _wcsicmp(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
             wsz_ROOT_STORE)) {
        if (CERT_SYSTEM_STORE_CURRENT_USER_ID == dwStoreLocationID) {
            if (IPR_IsCurrentUserRootsAllowed()) {
                // .Default and .LocalMachine physical stores are predefined
                dwPredefinedPhysicalFlags = CURRENT_USER_ROOT_PHYSICAL_FLAGS;
            } else {
                // Don't read the CurrentUser's SystemRegistry
                dwPredefinedPhysicalFlags = CURRENT_USER_ROOT_PHYSICAL_FLAGS &
                    ~DEFAULT_PHYSICAL_FLAG;
                // Since we won't be reading the SystemRegistry, ensure
                // the protected list of roots is initialized.
                IPR_InitProtectedRootInfo();
            }
            // Only the predefined physical stores are allowed for Root
            cSubKeys = 0;
        } else if (CERT_SYSTEM_STORE_LOCAL_MACHINE_ID == dwStoreLocationID) {
            if (IPR_IsAuthRootsAllowed()) {
                // .Default, .AuthRoot, .GroupPolicy and .Enterprise
                // physical stores are predefined
                dwPredefinedPhysicalFlags = LOCAL_MACHINE_ROOT_PHYSICAL_FLAGS;
            } else {
                // Don't read the AuthRoot's SystemRegistry
                dwPredefinedPhysicalFlags = LOCAL_MACHINE_ROOT_PHYSICAL_FLAGS &
                    ~AUTH_ROOT_PHYSICAL_FLAG;
            }
            // Only the predefined physical stores are allowed for Root
            cSubKeys = 0;
        } else if (CERT_SYSTEM_STORE_USERS_ID == dwStoreLocationID) {
            // Only .LocalMachine physical stores is predefined

            dwPredefinedPhysicalFlags = USERS_ROOT_PHYSICAL_FLAGS;
            // Only the predefined physical stores are allowed for Root
            cSubKeys = 0;
        } else {
            // According to store location.
            dwPredefinedPhysicalFlags =
                rgSystemStoreLocationInfo[
                    dwStoreLocationID].dwPredefinedPhysicalFlags;
        }
    } else if (0 == _wcsicmp(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
                         wsz_TRUST_PUB_STORE) ||
               0 == _wcsicmp(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
                         wsz_DISALLOWED_STORE)) {
        if (CERT_SYSTEM_STORE_CURRENT_USER_ID == dwStoreLocationID) {
            if (IsCurrentUserTrustedPublishersAllowed()) {
                // .Default, .GroupPolicy and .LocalMachine physical stores
                // are predefined
                dwPredefinedPhysicalFlags =
                    CURRENT_USER_TRUST_PUB_PHYSICAL_FLAGS;
            } else {
                // Don't read the CurrentUser's SystemRegistry
                dwPredefinedPhysicalFlags =
                    CURRENT_USER_TRUST_PUB_PHYSICAL_FLAGS &
                        ~DEFAULT_PHYSICAL_FLAG;
            }
            // Only the predefined physical stores are allowed for
            // HKCU TrustedPublisher
            cSubKeys = 0;
        } else if (CERT_SYSTEM_STORE_LOCAL_MACHINE_ID == dwStoreLocationID) {
            if (IsLocalMachineTrustedPublishersAllowed()) {
                // .Default, .GroupPolicy and .Enterprise
                // physical stores are predefined
                dwPredefinedPhysicalFlags =
                    LOCAL_MACHINE_TRUST_PUB_PHYSICAL_FLAGS;
            } else {
                // Don't read the LocalMachine's SystemRegistry
                dwPredefinedPhysicalFlags =
                    LOCAL_MACHINE_TRUST_PUB_PHYSICAL_FLAGS &
                    ~DEFAULT_PHYSICAL_FLAG;
            }
            // Only the predefined physical stores are allowed for
            // HKLM TrustedPublisher
            cSubKeys = 0;
        } else {
            // According to store location.
            dwPredefinedPhysicalFlags =
                rgSystemStoreLocationInfo[
                    dwStoreLocationID].dwPredefinedPhysicalFlags;
        }
    } else if (0 == _wcsicmp(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
             wsz_USER_DS_STORE)) {
        // Only .UserCertificate is predefined for "UserDS"
        dwPredefinedPhysicalFlags = USER_DS_PHYSICAL_FLAGS;
    } else
        // According to store location
        dwPredefinedPhysicalFlags =
            rgSystemStoreLocationInfo[
                dwStoreLocationID].dwPredefinedPhysicalFlags;


    if (cSubKeys && cchMaxSubKey) {
        DWORD i;

        cchMaxSubKey++;
        if (NULL == (pwszStoreName = (LPWSTR) PkiNonzeroAlloc(
                cchMaxSubKey * sizeof(WCHAR))))
            goto OutOfMemory;

        for (i = 0; i < cSubKeys; i++) {
            DWORD cchStoreName = cchMaxSubKey;
            LONG err;

            if (ERROR_SUCCESS != (err = RegEnumKeyExU(
                    hKey,
                    i,
                    pwszStoreName,
                    &cchStoreName,
                    NULL,               // lpdwReserved
                    NULL,               // lpszClass
                    NULL,               // lpcchClass
                    NULL                // lpftLastWriteTime
                    )) || 0 == cchStoreName) {
                if (ERROR_NO_MORE_ITEMS == err)
                    break;
                else
                    continue;
            }

            if (NULL == (pStoreInfo = GetEnumPhysicalStoreInfo(
                    hKey,
                    pwszStoreName,
                    dwFlags
                    )))
                continue;
            AddToEnumPhysicalStoreList(&pStoreInfoHead, pStoreInfo);
        }
    }

    for (pStoreInfo = pStoreInfoHead; pStoreInfo;
                                            pStoreInfo = pStoreInfo->pNext) {
        PCERT_PHYSICAL_STORE_INFO pRegistryInfo = &pStoreInfo->RegistryInfo;
        BOOL fSelfPhysicalStoreInfo;
        DWORD dwSystemProviderFlags;
        char szOID[34];

        if (IsSelfPhysicalStoreInfo(
                &SystemNameInfo,
                dwFlags,
                pRegistryInfo,
                &dwSystemProviderFlags)) {
            assert((dwSystemProviderFlags & UNICODE_SYSTEM_PROVIDER_FLAG) ||
                (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG));
            // Force to use SYSTEM_REGISTRY provider to inhibit recursion.
            PkiFree(pRegistryInfo->pszOpenStoreProvider);
            if (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG) {
                // Convert to "#<number>" string
                szOID[0] = CONST_OID_STR_PREFIX_CHAR;
                _ltoa((long) ((DWORD_PTR)CERT_STORE_PROV_SYSTEM_REGISTRY_A), szOID + 1, 10);
                pRegistryInfo->pszOpenStoreProvider = szOID;
            } else
                pRegistryInfo->pszOpenStoreProvider =
                    sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W;

            dwPredefinedPhysicalFlags &= ~DEFAULT_PHYSICAL_FLAG;
            fSelfPhysicalStoreInfo = TRUE;
        } else {
            if (0 != dwPredefinedPhysicalFlags) {
                // Check if matches one of the predefined physical stores

                DWORD i;
                DWORD dwCheckFlag;
                for (i = 0, dwCheckFlag = 1; i < NUM_PREDEFINED_PHYSICAL;
                                        i++, dwCheckFlag = dwCheckFlag << 1) {
                    if ((dwCheckFlag & dwPredefinedPhysicalFlags) &&
                            0 == _wcsicmp(pStoreInfo->pwszStoreName,
                                rgpwszPredefinedPhysical[i])) {
                        dwPredefinedPhysicalFlags &= ~dwCheckFlag;
                        break;
                    }
                }
            }
            fSelfPhysicalStoreInfo = FALSE;
        }

        if (dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG) {
            pRegistryInfo->dwOpenFlags |= CERT_STORE_MAXIMUM_ALLOWED_FLAG;
            pRegistryInfo->dwOpenFlags &= ~CERT_STORE_READONLY_FLAG;
        }
        if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) {
            pRegistryInfo->dwOpenFlags |= CERT_STORE_BACKUP_RESTORE_FLAG;
        }
        fResult = pfnEnum(
            pvSystemStore,
            dwFlags & CERT_SYSTEM_STORE_MASK,
            pStoreInfo->pwszStoreName,
            &pStoreInfo->RegistryInfo,
            NULL,                           // pvReserved
            pvArg
            );

        if (fSelfPhysicalStoreInfo) {
            // Not allocated. Set to NULL to inhibit subsequent free.
            pRegistryInfo->pszOpenStoreProvider = NULL;
        }

        if (!fResult)
            goto EnumCallbackError;
    }


    if (0 != dwPredefinedPhysicalFlags) {
        CERT_PHYSICAL_STORE_INFO SelfInfo;
        LPWSTR pwszLocalStore;
        DWORD cbLocalStore;
        DWORD i;
        DWORD dwCheckFlag;

        if (SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX]) {
            // Format local store name without the ComputerName
            LPCWSTR rgpwszGroupName[2];
            SYSTEM_NAME_GROUP NameGroup;
            NameGroup.cName = 2;
            NameGroup.rgpwszName = rgpwszGroupName;

            assert(IsRemotableSystemStoreLocationInRegistry(dwFlags));
            rgpwszGroupName[0] = SystemNameInfo.rgpwszName[SERVICE_NAME_INDEX];
            rgpwszGroupName[1] = SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX];
            if (NULL == (pwszLocalStore = FormatSystemNamePath(1, &NameGroup)))
                goto FormatSystemNamePathError;
        } else {
            if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
                PCERT_SYSTEM_STORE_RELOCATE_PARA pRelocatePara =
                    (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvSystemStore;
                pwszLocalStore = (LPWSTR) pRelocatePara->pwszSystemStore;
            } else
                pwszLocalStore = (LPWSTR) pvSystemStore;
        }
        cbLocalStore = (wcslen(pwszLocalStore) + 1) * sizeof(WCHAR);

        memset(&SelfInfo, 0, sizeof(SelfInfo));
        SelfInfo.cbSize = sizeof(SelfInfo);

        fResult = TRUE;
        for (i = 0, dwCheckFlag = 1; i < NUM_PREDEFINED_PHYSICAL;
                                        i++, dwCheckFlag = dwCheckFlag << 1) {
            LPWSTR pwszUserDsUserCertificateUrl;
            if (0 == (dwCheckFlag & dwPredefinedPhysicalFlags))
                continue;

            SelfInfo.pszOpenStoreProvider = sz_CERT_STORE_PROV_SYSTEM_W;
            SelfInfo.OpenParameters.pbData =
                (BYTE *) SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX];
            SelfInfo.OpenParameters.cbData =
                (wcslen(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX]) + 1) *
                    sizeof(WCHAR);
            SelfInfo.dwFlags = 0;
            pwszUserDsUserCertificateUrl = NULL;
            switch (i) {
                case DEFAULT_PHYSICAL_INDEX:
                    SelfInfo.pszOpenStoreProvider =
                        sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W;
                    SelfInfo.dwOpenFlags = dwFlags &
                        CERT_SYSTEM_STORE_LOCATION_MASK;
                    if (0 == _wcsicmp(
                        SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
                            wsz_MY_STORE))
                        SelfInfo.dwOpenFlags |= CERT_STORE_UPDATE_KEYID_FLAG;
                    SelfInfo.OpenParameters.pbData = (BYTE *) pwszLocalStore;
                    SelfInfo.OpenParameters.cbData = cbLocalStore;
                    SelfInfo.dwFlags = CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG;
                    break;
                case AUTH_ROOT_PHYSICAL_INDEX:
                    SelfInfo.pszOpenStoreProvider =
                        sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W;
                    SelfInfo.dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
                    SelfInfo.OpenParameters.pbData =
                        (BYTE *) wsz_AUTH_ROOT_STORE;
                    SelfInfo.OpenParameters.cbData =
                        (wcslen(wsz_AUTH_ROOT_STORE) + 1) * sizeof(WCHAR);
                    SelfInfo.dwFlags = CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG;
                    break;
                case GROUP_POLICY_PHYSICAL_INDEX:
                    if (CERT_SYSTEM_STORE_LOCAL_MACHINE_ID ==
                            dwStoreLocationID)
                        SelfInfo.dwOpenFlags =
                            CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY |
                                CERT_STORE_READONLY_FLAG;
                    else
                        SelfInfo.dwOpenFlags =
                            CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY |
                                CERT_STORE_READONLY_FLAG;
                    break;
                case LOCAL_MACHINE_PHYSICAL_INDEX:
                    SelfInfo.dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE |
                        CERT_STORE_READONLY_FLAG;
                    break;
                case DS_USER_CERT_PHYSICAL_INDEX:
                    if (NULL == (pwszUserDsUserCertificateUrl =
                            GetUserDsUserCertificateUrl()))
                        continue;
                    SelfInfo.pszOpenStoreProvider = sz_CERT_STORE_PROV_LDAP_W;
                    SelfInfo.dwOpenFlags = 0;
                    SelfInfo.OpenParameters.pbData =
                        (BYTE *) pwszUserDsUserCertificateUrl;
                    SelfInfo.OpenParameters.cbData = (wcslen(
                        pwszUserDsUserCertificateUrl) + 1) * sizeof(WCHAR);
                    SelfInfo.dwFlags = CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG;
                    break;
                case LMGP_PHYSICAL_INDEX:
                    SelfInfo.dwOpenFlags =
                        CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY |
                            CERT_STORE_READONLY_FLAG;
                    break;
                case ENTERPRISE_PHYSICAL_INDEX:
                    SelfInfo.dwOpenFlags =
                        CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE |
                            CERT_STORE_READONLY_FLAG;
                    break;
                default:
                    assert(i < NUM_PREDEFINED_PHYSICAL);
                    continue;

            }

            if (dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG) {
                SelfInfo.dwOpenFlags |= CERT_STORE_MAXIMUM_ALLOWED_FLAG;
                SelfInfo.dwOpenFlags &= ~CERT_STORE_READONLY_FLAG;
            }
            if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) {
                SelfInfo.dwOpenFlags |= CERT_STORE_BACKUP_RESTORE_FLAG;
            }

            fResult = pfnEnum(
                    pvSystemStore,
                    (dwFlags & CERT_SYSTEM_STORE_MASK) |
                        CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG,
                    rgpwszPredefinedPhysical[i],        // pwszStoreName
                    &SelfInfo,
                    NULL,                               // pvReserved
                    pvArg
                    );
            if (pwszUserDsUserCertificateUrl)
                CryptMemFree(pwszUserDsUserCertificateUrl);
            if (!fResult)
                break;
        }

        if (SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX])
            PkiFree(pwszLocalStore);
        if (!fResult)
            goto EnumCallbackError;
    }

    fResult = TRUE;
CommonReturn:
    if (plDepth)
        *plDepth -= 1;
    ILS_CloseRegistryKey(hKey);
    FreeSystemNameInfo(&SystemNameInfo);
    PkiFree(pwszStoreName);
    FreeEnumPhysicalStoreList(pStoreInfoHead);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ParseSystemStoreParaError)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
SET_ERROR(ExceededEnumPhysicalStoreDepth_PossibleCrossStoreRecursion, E_UNEXPECTED)
TRACE_ERROR(OpenPhysicalStoresError)
TRACE_ERROR(OpenSystemStoreError)
TRACE_ERROR(GetSubKeyInfoError)
TRACE_ERROR(FormatSystemNamePathError)
TRACE_ERROR(EnumCallbackError)
}

//+-------------------------------------------------------------------------
//  Enumerate the physical stores for the specified system store.
//
//  The upper word of the dwFlags parameter is used to specify the location of
//  the system store.
//
//  If the system store location only supports system stores and doesn't
//  support physical stores, LastError is set to ERROR_CALL_NOT_IMPLEMENTED.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertEnumPhysicalStore(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum
    )
{
    return EnumPhysicalStore(
        pvSystemStore,
        dwFlags | CERT_STORE_OPEN_EXISTING_FLAG | CERT_STORE_READONLY_FLAG,
        pvArg,
        pfnEnum
        );
}

STATIC BOOL IsHKCUStore(
    IN LPCWSTR pwszStoreName,
    IN PSYSTEM_NAME_INFO pInfo,
    IN DWORD dwFlags
    )
{
    DWORD dwStoreLocation = dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK;

    if (CERT_SYSTEM_STORE_CURRENT_USER != dwStoreLocation ||
            0 != _wcsicmp(pInfo->rgpwszName[SYSTEM_NAME_INDEX], pwszStoreName))
        return FALSE;

    if (dwFlags & (CERT_SYSTEM_STORE_RELOCATE_FLAG | CERT_STORE_DELETE_FLAG))
        return FALSE;

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Open the system registry store provider (unicode version)
//
//  Open the system registry store specified by its name. For example,
//  L"My".
//
//  pvPara contains the LPCWSTR system registry store name.
//
//  Note for an error return, the caller will free any certs, CRLs or CTLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenSystemRegistryStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    LONG err;
    HKEY hKey = NULL;
    SYSTEM_NAME_INFO SystemNameInfo;
    BOOL fUserRoot;
    HKEY hHKCURoot = NULL;
    DWORD dwOpenRegFlags;
    const void *pvOpenRegPara;
    LPWSTR pwszRoamingDirectory = NULL;
    CERT_REGISTRY_STORE_ROAMING_PARA RoamingStorePara;

    CERT_REGISTRY_STORE_CLIENT_GPT_PARA ClientGptStorePara;
    memset(&ClientGptStorePara, 0, sizeof(ClientGptStorePara));

    if (dwFlags & CERT_STORE_UNSAFE_PHYSICAL_FLAG) {
        if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
            SetLastError((DWORD) E_INVALIDARG);
            return FALSE;
        }

        dwFlags &= ~CERT_STORE_UNSAFE_PHYSICAL_FLAG;
    }

    if (!ParseSystemStorePara(
            pvPara,
            dwFlags,
            1,                  // cReqName
            &SystemNameInfo))   // zero'ed on error
        goto ParseSystemStoreParaError;

    if (dwFlags & ~OPEN_SYS_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    // Check for the CurrentUser "Root" store.
    fUserRoot = FALSE;
    if (0 == _wcsicmp(SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX],
            wsz_ROOT_STORE) &&
                0 == (dwFlags & CERT_SYSTEM_STORE_UNPROTECTED_FLAG)) {
        DWORD dwStoreLocation = dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK;

        // Note, LOCAL_MACHINE check is needed to prevent use of relocation
        // to access the current user's root store
        if (CERT_SYSTEM_STORE_CURRENT_USER == dwStoreLocation) {
            fUserRoot = TRUE;
            if (NULL == SystemNameInfo.hKeyBase) {
                if (ERROR_SUCCESS != (err = RegOpenHKCUEx(
                        &hHKCURoot,
                        REG_HKCU_DISABLE_DEFAULT_FLAG
                        )))
                    goto RegOpenHKCUExRootError;

                SystemNameInfo.hKeyBase = hHKCURoot;
                dwFlags |= CERT_SYSTEM_STORE_RELOCATE_FLAG;
            }
        } else if (CERT_SYSTEM_STORE_USERS == dwStoreLocation ||
                ((dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) &&
                    CERT_SYSTEM_STORE_LOCAL_MACHINE == dwStoreLocation))
            goto RootAccessDenied;
    }

    if (IsClientGptStore(&SystemNameInfo, dwFlags)) {
        DWORD dwStoreLocation;

        assert(!fUserRoot);
        if (NULL == (ClientGptStorePara.pwszRegPath = FormatSystemRegPath(
                &SystemNameInfo,
                NULL,               // pwszSubKeyName
                dwFlags,
                &ClientGptStorePara.hKeyBase)))
            goto FormatSystemRegPathError;
        pvOpenRegPara = (const void *) &ClientGptStorePara;

        dwOpenRegFlags =
            dwFlags & ~(CERT_SYSTEM_STORE_MASK |
                CERT_STORE_SET_LOCALIZED_NAME_FLAG);
        dwOpenRegFlags |= CERT_REGISTRY_STORE_CLIENT_GPT_FLAG;
            // | CERT_REGISTRY_STORE_SERIALIZED_FLAG;

        dwStoreLocation = dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK;
        if (CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY == dwStoreLocation)
            dwOpenRegFlags |= CERT_REGISTRY_STORE_LM_GPT_FLAG;

        if (SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX])
            dwOpenRegFlags |= CERT_REGISTRY_STORE_REMOTE_FLAG;
    } else {
        BOOL fIsHKCUMyStore;

        fIsHKCUMyStore = IsHKCUStore(wsz_MY_STORE, &SystemNameInfo, dwFlags);

        if (fIsHKCUMyStore) {
            pwszRoamingDirectory =
                ILS_GetRoamingStoreDirectory(ROAMING_MY_STORE_SUBDIR);
        } else if (IsHKCUStore(wsz_REQUEST_STORE, &SystemNameInfo, dwFlags)) {
            pwszRoamingDirectory =
                ILS_GetRoamingStoreDirectory(ROAMING_REQUEST_STORE_SUBDIR);
        }

        if (NULL != pwszRoamingDirectory) {
            // OK for this to fail. After the first open, all contexts should
            // be persisted in files and not the registry.
            hKey = OpenSystemRegPathKey(
                &SystemNameInfo,
                NULL,               // pwszSubKeyName
                (dwFlags & ~CERT_STORE_CREATE_NEW_FLAG) |
                    CERT_STORE_OPEN_EXISTING_FLAG
                );

            RoamingStorePara.hKey = hKey;
            RoamingStorePara.pwszStoreDirectory = pwszRoamingDirectory;
            pvOpenRegPara = (const void *) &RoamingStorePara;

            dwOpenRegFlags =
                dwFlags & ~(CERT_SYSTEM_STORE_MASK |
                    CERT_STORE_CREATE_NEW_FLAG |
                    CERT_STORE_SET_LOCALIZED_NAME_FLAG);
            dwOpenRegFlags |= CERT_REGISTRY_STORE_ROAMING_FLAG;
        } else {
            if (NULL == (hKey = OpenSystemRegPathKey(
                    &SystemNameInfo,
                    NULL,               // pwszSubKeyName
                    dwFlags)))
                goto OpenSystemStoreError;
            pvOpenRegPara = (const void *) hKey;

            dwOpenRegFlags =
                dwFlags & ~(CERT_SYSTEM_STORE_MASK |
                    CERT_STORE_CREATE_NEW_FLAG |
                    CERT_STORE_SET_LOCALIZED_NAME_FLAG);
            if (SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX])
                dwOpenRegFlags |= CERT_REGISTRY_STORE_REMOTE_FLAG;
            if (IsSerializedSystemStoreLocationInRegistry(dwFlags)) {
                assert(!fUserRoot);
                dwOpenRegFlags |= CERT_REGISTRY_STORE_SERIALIZED_FLAG;
            }
        }
    }

    if (fUserRoot)
        IPR_InitProtectedRootInfo();

    if (!I_CertDllOpenRegStoreProv(
            NULL,                       // lpszStoreProvider
            dwEncodingType,
            hCryptProv,
            dwOpenRegFlags,
            pvOpenRegPara,
            hCertStore,
            pStoreProvInfo))
        goto OpenRegStoreProvError;

    if (fUserRoot) {
        PREG_STORE pRegStore = (PREG_STORE) pStoreProvInfo->hStoreProv;

        // Set count to 0 to inhibit any callbacks from being called.
        pStoreProvInfo->cStoreProvFunc = 0;

        // For the "Root" delete any roots that aren't in the protected root
        // list.
        if (!IPR_DeleteUnprotectedRootsFromStore(
                hCertStore,
                &pRegStore->fProtected
                )) goto DeleteUnprotectedRootsError;

        // For the "Root" replace some of the provider callback functions
        // that first prompt the user directly (if not protected) or
        // prompt the user via the system service (if protected).
        pStoreProvInfo->cStoreProvFunc = ROOT_STORE_PROV_FUNC_COUNT;
        pStoreProvInfo->rgpvStoreProvFunc = (void **) rgpvRootStoreProvFunc;
    }

    if (dwFlags & CERT_STORE_SET_LOCALIZED_NAME_FLAG)
        SetLocalizedNameStoreProperty(hCertStore, &SystemNameInfo);

    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_SYSTEM_STORE_FLAG;
    if (IsLMSystemStoreLocationInRegistry(dwFlags))
        pStoreProvInfo->dwStoreProvFlags |=
            CERT_STORE_PROV_LM_SYSTEM_STORE_FLAG;

    fResult = TRUE;
CommonReturn:
    if (SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX] &&
            ClientGptStorePara.hKeyBase)
        ILS_CloseRegistryKey(ClientGptStorePara.hKeyBase);
    PkiFree(ClientGptStorePara.pwszRegPath);

    FreeSystemNameInfo(&SystemNameInfo);
    PkiFree(pwszRoamingDirectory);
    ILS_CloseRegistryKey(hKey);
    if (hHKCURoot) {
        DWORD dwErr = GetLastError();
        RegCloseHKCU(hHKCURoot);
        SetLastError(dwErr);
    }
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ParseSystemStoreParaError)
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(RootAccessDenied, E_ACCESSDENIED)
SET_ERROR_VAR(RegOpenHKCUExRootError, err)
TRACE_ERROR(FormatSystemRegPathError)
TRACE_ERROR(OpenSystemStoreError)
TRACE_ERROR(OpenRegStoreProvError)
TRACE_ERROR(DeleteUnprotectedRootsError)
}

//+-------------------------------------------------------------------------
//  Open the system registry store provider (ascii version)
//
//  Open the system registry store specified by its name. For example,
//  "My".
//
//  pvPara contains the LPCSTR system store name.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenSystemRegistryStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    LPCSTR pszStoreName;    // not allocated
    LPWSTR pwszStoreName;

    CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;

    if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pInPara;

        if (dwFlags & CERT_STORE_UNSAFE_PHYSICAL_FLAG) {
            SetLastError((DWORD) E_INVALIDARG);
            return FALSE;
        }

        assert(pvPara);
        pInPara = (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvPara;
        RelocatePara.hKeyBase = pInPara->hKeyBase;
        pszStoreName = pInPara->pszSystemStore;
    } else
        pszStoreName = (LPCSTR) pvPara;

    assert(pszStoreName);

    if (NULL == (pwszStoreName = MkWStr((LPSTR) pszStoreName)))
        fResult = FALSE;
    else {
        const void *pvParaW;

        if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
            RelocatePara.pwszSystemStore = pwszStoreName;
            pvParaW = (const void *) &RelocatePara;
        } else
            pvParaW = (const void *) pwszStoreName;

        fResult = I_CertDllOpenSystemRegistryStoreProvW(
            NULL,                       // lpszStoreProvider
            dwEncodingType,
            hCryptProv,
            dwFlags,
            pvParaW,
            hCertStore,
            pStoreProvInfo
            );
        FreeWStr(pwszStoreName);
    }
    return fResult;
}

typedef struct _OPEN_PHYSICAL_STORE_INFO {
    HCERTSTORE      hCollectionStore;
    LPCWSTR         pwszComputerName;       // NULL implies local
    LPCWSTR         pwszServiceName;        // NULL implies current
    LPCWSTR         pwszPhysicalName;       // NULL implies any
    HKEY            hKeyBase;               // non-NULL, relocatable
    DWORD           dwFlags;
    BOOL            fDidOpen;
} OPEN_PHYSICAL_STORE_INFO, *POPEN_PHYSICAL_STORE_INFO;


STATIC BOOL WINAPI OpenPhysicalStoreCallback(
    IN const void *pvSystemStore,
    IN DWORD dwFlags,
    IN LPCWSTR pwszStoreName,
    IN PCERT_PHYSICAL_STORE_INFO pStoreInfo,
    IN OPTIONAL void *pvReserved,
    IN OPTIONAL void *pvArg
    )
{
    BOOL fResult;
    HCERTSTORE hPhysicalStore = NULL;
    POPEN_PHYSICAL_STORE_INFO pOpenInfo =
        (POPEN_PHYSICAL_STORE_INFO) pvArg;
    void *pvOpenParameters;
    LPWSTR pwszRemoteOpenParameters = NULL;
    LPCSTR pszOpenStoreProvider;
    DWORD dwOpenFlags;
    DWORD dwAddFlags;

    CERT_SYSTEM_STORE_RELOCATE_PARA RelocateOpenParameters;

    if ((pStoreInfo->dwFlags & CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG)
                        ||
            (pOpenInfo->pwszPhysicalName &&
                0 != _wcsicmp(pOpenInfo->pwszPhysicalName, pwszStoreName))
                        ||
            (pOpenInfo->pwszComputerName &&
                (pStoreInfo->dwFlags &
                    CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG)))
        return TRUE;

    pvOpenParameters = pStoreInfo->OpenParameters.pbData;
    assert(pvOpenParameters);
    dwOpenFlags = pStoreInfo->dwOpenFlags;
    pszOpenStoreProvider = pStoreInfo->pszOpenStoreProvider;

    if (!(dwFlags & CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG)) {
        // The parameters for the physical were read from the registry.
        // Set the unsafe flag to alert the physical store provider to be
        // called.
        dwOpenFlags |= CERT_STORE_UNSAFE_PHYSICAL_FLAG;

        // Check for potentially unsafe open flags
        if (dwOpenFlags & (
                CERT_STORE_NO_CRYPT_RELEASE_FLAG            |
                CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG |
                CERT_STORE_DELETE_FLAG                      |
                CERT_STORE_SHARE_STORE_FLAG                 |
                CERT_STORE_SHARE_CONTEXT_FLAG               |
                CERT_STORE_MANIFOLD_FLAG                    |
                CERT_STORE_BACKUP_RESTORE_FLAG
                ))
            goto UnsafeOpenPhysicalFlagsError;

        // Following flags can be set
        //  CERT_STORE_SET_LOCALIZED_NAME_FLAG
        //  CERT_STORE_UNSAFE_PHYSICAL_FLAG
        //  CERT_STORE_ENUM_ARCHIVED_FLAG
        //  CERT_STORE_UPDATE_KEYID_FLAG
        //  CERT_STORE_READONLY_FLAG
        //  CERT_STORE_OPEN_EXISTING_FLAG
        //  CERT_STORE_CREATE_NEW_FLAG
        //  CERT_STORE_MAXIMUM_ALLOWED_FLAG
    }

    if (pOpenInfo->pwszComputerName || pOpenInfo->pwszServiceName) {
        // Possibly insert the \\ComputerName\ServiceName before the
        // OpenParameters

        LPCWSTR pwszComputerName = NULL;
        LPCWSTR pwszServiceName = NULL;
        LPWSTR pwszSystemStore = (LPWSTR) pvOpenParameters;
        DWORD dwSystemProviderFlags =
            GetSystemProviderFlags(pszOpenStoreProvider);

        if (0 != dwSystemProviderFlags) {
            SYSTEM_NAME_INFO ProviderNameInfo;
            DWORD cReqName;

            if (dwOpenFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG)
                goto RelocateFlagSetInPhysicalStoreInfoError;

            if (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG) {
                if (NULL == (pwszSystemStore =
                        MkWStr((LPSTR) pvOpenParameters)))
                    goto OutOfMemory;
            }

            if (dwSystemProviderFlags & PHYSICAL_PROVIDER_FLAG)
                cReqName = 2;
            else
                cReqName = 1;

            ParseSystemStorePara(
                    pwszSystemStore,
                    dwOpenFlags,
                    cReqName,
                    &ProviderNameInfo      // zero'ed on error
                    );
            if (ProviderNameInfo.rgpwszName[COMPUTER_NAME_INDEX]) {
                // Already has \\ComputerName\ prefix. For Services or
                // Users, already has ServiceName\ prefix.
                ;
            } else if (ProviderNameInfo.rgpwszName[SYSTEM_NAME_INDEX]) {
                // Needed above check if ParseSystemStorePara failed.
                pwszComputerName = pOpenInfo->pwszComputerName;

                if (pOpenInfo->pwszServiceName) {
                    // If the provider store is located in CURRENT_SERVICE or
                    // CURRENT_USER use outer store's SERVICE_NAME and change
                    // store location accordingly

                    DWORD dwOpenLocation =
                        dwOpenFlags & CERT_SYSTEM_STORE_LOCATION_MASK;
                    if (CERT_SYSTEM_STORE_CURRENT_SERVICE == dwOpenLocation) {
                        pwszServiceName = pOpenInfo->pwszServiceName;
                        dwOpenFlags =
                            (dwOpenFlags & ~CERT_SYSTEM_STORE_LOCATION_MASK) |
                                CERT_SYSTEM_STORE_SERVICES;
                    } else if (CERT_SYSTEM_STORE_CURRENT_USER ==
                            dwOpenLocation) {
                        pwszServiceName = pOpenInfo->pwszServiceName;
                        dwOpenFlags =
                            (dwOpenFlags & ~CERT_SYSTEM_STORE_LOCATION_MASK) |
                                CERT_SYSTEM_STORE_USERS;
                    }

                }
            }
            FreeSystemNameInfo(&ProviderNameInfo);
        } else if (pStoreInfo->dwFlags &
                CERT_PHYSICAL_STORE_INSERT_COMPUTER_NAME_ENABLE_FLAG)
            pwszComputerName = pOpenInfo->pwszComputerName;

        if (pwszComputerName || pwszServiceName) {
            // Insert \\ComputerName\ServiceName before and re-format
            // open parameters
            LPCWSTR rgpwszName[3];
            SYSTEM_NAME_GROUP NameGroup;

            assert(pwszSystemStore);

            NameGroup.cName = 3;
            NameGroup.rgpwszName = rgpwszName;
            rgpwszName[0] = pwszComputerName;
            rgpwszName[1] = pwszServiceName;
            rgpwszName[2] = pwszSystemStore;
            pwszRemoteOpenParameters = FormatSystemNamePath(1, &NameGroup);
            pvOpenParameters = pwszRemoteOpenParameters;

            if (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG)
                pszOpenStoreProvider = ChangeAsciiToUnicodeProvider(
                    pszOpenStoreProvider);
        }

        if (dwSystemProviderFlags & ASCII_SYSTEM_PROVIDER_FLAG) {
            FreeWStr(pwszSystemStore);
            if (NULL == pszOpenStoreProvider)
                goto UnableToChangeToUnicodeProvider;
        }
        if (NULL == pvOpenParameters)
            goto FormatSystemNamePathError;
    }

    if (NULL != pOpenInfo->hKeyBase &&
            0 != GetSystemProviderFlags(pszOpenStoreProvider)) {
        if (dwOpenFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG)
            goto RelocateFlagSetInPhysicalStoreInfoError;

        // Inherit outer store's hKeyBase and convert to a relocated
        // physical store
        RelocateOpenParameters.hKeyBase = pOpenInfo->hKeyBase;
        RelocateOpenParameters.pvSystemStore = pvOpenParameters;
        pvOpenParameters = &RelocateOpenParameters;
        dwOpenFlags |= CERT_SYSTEM_STORE_RELOCATE_FLAG;
    }

    if (NULL == (hPhysicalStore = CertOpenStore(
            pszOpenStoreProvider,
            pStoreInfo->dwOpenEncodingType,
            0,                                  // hCryptProv
            dwOpenFlags | (pOpenInfo->dwFlags &
                                 (CERT_STORE_READONLY_FLAG |
                                  CERT_STORE_OPEN_EXISTING_FLAG |
                                  CERT_STORE_MANIFOLD_FLAG |
                                  CERT_STORE_SHARE_CONTEXT_FLAG |
                                  CERT_STORE_SHARE_STORE_FLAG |
                                  CERT_STORE_BACKUP_RESTORE_FLAG |
                                  CERT_STORE_UPDATE_KEYID_FLAG |
                                  CERT_STORE_ENUM_ARCHIVED_FLAG)),
            pvOpenParameters))) {
        DWORD dwErr = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwErr || ERROR_PROC_NOT_FOUND == dwErr ||
                ERROR_GEN_FAILURE == dwErr) {
            if (pOpenInfo->pwszPhysicalName &&
                    (dwFlags & CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG)) {
                // For a predefined physical convert to an empty collection
                CertAddStoreToCollection(
                    pOpenInfo->hCollectionStore,
                    NULL,           // hSiblingStore, NULL implies convert only
                    0,              // dwFlags
                    0               // dwPriority
                    );
                goto OpenReturn;
            } else
                goto SuccessReturn;
        } else
            goto OpenPhysicalStoreError;
    }

    dwAddFlags = pStoreInfo->dwFlags;
    if ((dwOpenFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG) &&
            0 == (dwAddFlags & CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG) &&
            pOpenInfo->pwszPhysicalName) {
        DWORD dwAccessStateFlags;
        DWORD cbData = sizeof(dwAccessStateFlags);

        if (CertGetStoreProperty(
                hPhysicalStore,
                CERT_ACCESS_STATE_PROP_ID,
                &dwAccessStateFlags,
                &cbData
                )) {
            if (dwAccessStateFlags & CERT_ACCESS_STATE_WRITE_PERSIST_FLAG)
                dwAddFlags |= CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG;
        }
    }

    if (!CertAddStoreToCollection(
            pOpenInfo->hCollectionStore,
            hPhysicalStore,
            dwAddFlags,
            pStoreInfo->dwPriority))
        goto AddStoreToCollectionError;

OpenReturn:
    pOpenInfo->fDidOpen = TRUE;
SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(pwszRemoteOpenParameters);
    if (hPhysicalStore)
        CertCloseStore(hPhysicalStore, 0);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR(UnableToChangeToUnicodeProvider, E_UNEXPECTED)
TRACE_ERROR(OpenPhysicalStoreError)
TRACE_ERROR(AddStoreToCollectionError)
TRACE_ERROR(FormatSystemNamePathError)
SET_ERROR(UnsafeOpenPhysicalFlagsError, E_INVALIDARG)
SET_ERROR(RelocateFlagSetInPhysicalStoreInfoError, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Open the system store provider (unicode version)
//
//  Open the system store specified by its name. For example,
//  L"My".
//
//  pvPara contains the LPCWSTR system store name.
//
//  Note for an error return, the caller will free any certs, CRLs or CTLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenSystemStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    SYSTEM_NAME_INFO SystemNameInfo;

    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_SYSTEM_STORE_FLAG;
    if (IsLMSystemStoreLocationInRegistry(dwFlags))
        pStoreProvInfo->dwStoreProvFlags |=
            CERT_STORE_PROV_LM_SYSTEM_STORE_FLAG;

    if (!IsSystemStoreLocationInRegistry(dwFlags)) {
        void *pvFuncAddr;

        assert(NULL == pStoreProvInfo->hStoreProvFuncAddr2);
        if (!CryptGetOIDFunctionAddress(
                rghFuncSet[OPEN_SYSTEM_STORE_PROV_FUNC_SET],
                0,                      // dwEncodingType,
                GetSystemStoreLocationOID(dwFlags),
                0,                      // dwFlags
                &pvFuncAddr,
                &pStoreProvInfo->hStoreProvFuncAddr2))
            return FALSE;

        fResult = ((PFN_CERT_DLL_OPEN_STORE_PROV_FUNC) pvFuncAddr)(
            lpszStoreProvider,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            pvPara,
            hCertStore,
            pStoreProvInfo
            );
        // Note, hStoreProvFuncAddr2 is CryptFreeOIDFunctionAddress'ed by
        // CertCloseStore()
        return fResult;
    }

    if (dwFlags & CERT_STORE_UNSAFE_PHYSICAL_FLAG) {
        if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
            SetLastError((DWORD) E_INVALIDARG);
            return FALSE;
        }

        dwFlags &= ~CERT_STORE_UNSAFE_PHYSICAL_FLAG;
    }

    if (!ParseSystemStorePara(
            pvPara,
            dwFlags,
            1,                      // cReqName
            &SystemNameInfo))       // zero'ed on error
        goto ParseSystemStoreParaError;

    if (dwFlags & ~OPEN_SYS_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    if (dwFlags & CERT_STORE_DELETE_FLAG) {
        // Need to clear out CERT_STORE_NO_CRYPT_RELEASE_FLAG
        if (!CertUnregisterSystemStore(
                pvPara,
                dwFlags & UNREGISTER_FLAGS_MASK
                ))
            goto UnregisterSystemStoreError;
        pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_DELETED_FLAG;
    } else {
        OPEN_PHYSICAL_STORE_INFO OpenInfo;

        if (dwFlags & CERT_STORE_CREATE_NEW_FLAG) {
            HKEY hKey;
            if (NULL == (hKey = OpenSystemStore(pvPara, dwFlags)))
                goto OpenSystemStoreError;
            RegCloseKey(hKey);
            dwFlags &= ~CERT_STORE_CREATE_NEW_FLAG;
        }

        OpenInfo.hCollectionStore = hCertStore;
        OpenInfo.pwszComputerName =
            SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX];
        OpenInfo.pwszServiceName =
            SystemNameInfo.rgpwszName[SERVICE_NAME_INDEX];
        OpenInfo.pwszPhysicalName = NULL;       // NULL implies any
        OpenInfo.hKeyBase = SystemNameInfo.hKeyBase;
        OpenInfo.dwFlags = dwFlags & ~CERT_STORE_SET_LOCALIZED_NAME_FLAG;
        OpenInfo.fDidOpen = FALSE;

        // Need to clear out CERT_STORE_NO_CRYPT_RELEASE_FLAG
        if (!EnumPhysicalStore(
                pvPara,
                dwFlags & ENUM_FLAGS_MASK,
                &OpenInfo,
                OpenPhysicalStoreCallback
                ))
            goto EnumPhysicalStoreError;

        if (!OpenInfo.fDidOpen) {
            if (IsPredefinedSystemStore(
                    SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX], dwFlags))
                // Convert to a collection store
                CertAddStoreToCollection(
                    hCertStore,
                    NULL,           // hSiblingStore, NULL implies convert only
                    0,              // dwFlags
                    0               // dwPriority
                    );
            else
                goto PhysicalStoreNotFound;
        }

        if (dwFlags & CERT_STORE_SET_LOCALIZED_NAME_FLAG)
            SetLocalizedNameStoreProperty(hCertStore, &SystemNameInfo);
    }

    fResult = TRUE;
CommonReturn:
    FreeSystemNameInfo(&SystemNameInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ParseSystemStoreParaError)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(UnregisterSystemStoreError)
TRACE_ERROR(OpenSystemStoreError)
TRACE_ERROR(EnumPhysicalStoreError)
SET_ERROR(PhysicalStoreNotFound, ERROR_FILE_NOT_FOUND)
}

//+-------------------------------------------------------------------------
//  Open the system store provider (ascii version)
//
//  Open the system store specified by its name. For example,
//  "My".
//
//  pvPara contains the LPCSTR system store name.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenSystemStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    LPCSTR pszStoreName;    // not allocated
    LPWSTR pwszStoreName;

    CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;

    if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pInPara;

        if (dwFlags & CERT_STORE_UNSAFE_PHYSICAL_FLAG) {
            SetLastError((DWORD) E_INVALIDARG);
            return FALSE;
        }

        assert(pvPara);
        pInPara = (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvPara;
        RelocatePara.hKeyBase = pInPara->hKeyBase;
        pszStoreName = pInPara->pszSystemStore;
    } else
        pszStoreName = (LPCSTR) pvPara;

    assert(pszStoreName);

    if (NULL == (pwszStoreName = MkWStr((LPSTR) pszStoreName)))
        fResult = FALSE;
    else {
        const void *pvParaW;

        if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
            RelocatePara.pwszSystemStore = pwszStoreName;
            pvParaW = (const void *) &RelocatePara;
        } else
            pvParaW = (const void *) pwszStoreName;

        fResult = I_CertDllOpenSystemStoreProvW(
            NULL,                       // lpszStoreProvider
            dwEncodingType,
            hCryptProv,
            dwFlags,
            pvParaW,
            hCertStore,
            pStoreProvInfo
            );
        FreeWStr(pwszStoreName);
    }
    return fResult;
}


//+-------------------------------------------------------------------------
//  Open the physical store provider (unicode version)
//
//  Open the physical store in the specified system store. For example,
//  L"My\.Default".
//
//  pvPara contains the LPCWSTR pwszSystemAndPhysicalName which is the
//  concatenation of the system and physical store names with an
//  intervening "\".
//
//  Note for an error return, the caller will free any certs, CRLs or CTLs
//  successfully added to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertDllOpenPhysicalStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    LPCWSTR pwszBoth;           // not allocated
    LPWSTR pwszSystem = NULL;   // allocated
    DWORD cchSystem;
    LPCWSTR pwszPhysical;       // not allocated

    void *pvSystemPara;         // not allocated
    CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;

    if (dwFlags & CERT_STORE_UNSAFE_PHYSICAL_FLAG) {
        if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG)
            goto InvalidArg;

        dwFlags &= ~CERT_STORE_UNSAFE_PHYSICAL_FLAG;
    }

    if (dwFlags & ~OPEN_PHY_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pInPara;

        if (NULL == pvPara)
            goto InvalidArg;
        pInPara = (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvPara;
        pwszBoth = pInPara->pwszSystemStore;
    } else
        pwszBoth = (LPCWSTR) pvPara;

    // Extract the system and physical name components by starting at
    // the end and searching backwards for the first "\"
    if (NULL == pwszBoth)
        goto InvalidArg;
    pwszPhysical = pwszBoth + wcslen(pwszBoth);
    while (pwszPhysical > pwszBoth && L'\\' != *pwszPhysical)
        pwszPhysical--;

    cchSystem = (DWORD)(pwszPhysical - pwszBoth);
    pwszPhysical++;     // advance past "\"
    if (0 < cchSystem && L'\0' != *pwszPhysical) {
        if (NULL == (pwszSystem = ILS_AllocAndCopyString(pwszBoth, cchSystem)))
            goto OutOfMemory;
    } else
        // Missing "\" or empty System or Physical Name.
        goto InvalidArg;

    if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG) {
        PCERT_SYSTEM_STORE_RELOCATE_PARA pInPara =
            (PCERT_SYSTEM_STORE_RELOCATE_PARA) pvPara;
        RelocatePara.hKeyBase = pInPara->hKeyBase;
        RelocatePara.pwszSystemStore = pwszSystem;
        pvSystemPara = &RelocatePara;
    } else
        pvSystemPara = pwszSystem;

    if (dwFlags & CERT_STORE_DELETE_FLAG) {
        // Need to clear out CERT_STORE_NO_CRYPT_RELEASE_FLAG
        if (!CertUnregisterPhysicalStore(
                pvSystemPara,
                dwFlags & UNREGISTER_FLAGS_MASK,
                pwszPhysical
                ))
            goto UnregisterPhysicalStoreError;
        pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_DELETED_FLAG;
    } else {
        SYSTEM_NAME_INFO SystemNameInfo;
        OPEN_PHYSICAL_STORE_INFO OpenInfo;

        // Note, already removed PhysicalName above. That's why
        // cReqName is 1 and not 2.
        if (!ParseSystemStorePara(
                pvSystemPara,
                dwFlags,
                1,                      // cReqName
                &SystemNameInfo))       // zero'ed on error
            goto ParseSystemStoreParaError;

        OpenInfo.hCollectionStore = hCertStore;
        OpenInfo.pwszComputerName =
            SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX];
        OpenInfo.pwszServiceName =
            SystemNameInfo.rgpwszName[SERVICE_NAME_INDEX];
        OpenInfo.pwszPhysicalName = pwszPhysical;
        OpenInfo.hKeyBase = SystemNameInfo.hKeyBase;
        OpenInfo.dwFlags = dwFlags & ~CERT_STORE_SET_LOCALIZED_NAME_FLAG;
        OpenInfo.fDidOpen = FALSE;

        // For .Default physical store, allow the store to be created.
        // Otherwise, the store must already exist.
        if (0 != _wcsicmp(CERT_PHYSICAL_STORE_DEFAULT_NAME, pwszPhysical))
            dwFlags |= CERT_STORE_OPEN_EXISTING_FLAG |
                CERT_STORE_READONLY_FLAG;

        // Need to clear out CERT_STORE_NO_CRYPT_RELEASE_FLAG
        fResult = EnumPhysicalStore(
                pvSystemPara,
                dwFlags & ENUM_FLAGS_MASK,
                &OpenInfo,
                OpenPhysicalStoreCallback
                );

        if (dwFlags & CERT_STORE_SET_LOCALIZED_NAME_FLAG) {
            assert(NULL == SystemNameInfo.rgpwszName[PHYSICAL_NAME_INDEX]);
            SystemNameInfo.rgpwszName[PHYSICAL_NAME_INDEX] =
                (LPWSTR) pwszPhysical;
            SetLocalizedNameStoreProperty(hCertStore, &SystemNameInfo);
            SystemNameInfo.rgpwszName[PHYSICAL_NAME_INDEX] = NULL;
        }

        FreeSystemNameInfo(&SystemNameInfo);
        if (!fResult)
            goto EnumPhysicalStoreError;
        if (!OpenInfo.fDidOpen)
            goto PhysicalStoreNotFound;

    }

    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_SYSTEM_STORE_FLAG;
    if (IsLMSystemStoreLocationInRegistry(dwFlags))
        pStoreProvInfo->dwStoreProvFlags |=
            CERT_STORE_PROV_LM_SYSTEM_STORE_FLAG;

    fResult = TRUE;
CommonReturn:
    PkiFree(pwszSystem);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(UnregisterPhysicalStoreError)
TRACE_ERROR(ParseSystemStoreParaError)
TRACE_ERROR(EnumPhysicalStoreError)
SET_ERROR(PhysicalStoreNotFound, ERROR_FILE_NOT_FOUND)
}



//+=========================================================================
//  "ROOT" STORE
//==========================================================================

//+-------------------------------------------------------------------------
//  For "Root": prompt before adding a cert.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RootStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    PCCERT_CONTEXT pProvCertContext = NULL;
    BYTE *pbSerializedElement = NULL;
    DWORD cbSerializedElement;

    assert(pRegStore);
    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;

    if (pRegStore->fProtected) {
        if (!CertSerializeCertificateStoreElement(
                pCertContext,
                0,              // dwFlags
                NULL,           // pbElement
                &cbSerializedElement
                )) goto SerializeCertError;
        if (NULL == (pbSerializedElement = (BYTE *) PkiNonzeroAlloc(
                cbSerializedElement)))
            goto OutOfMemory;
        if (!CertSerializeCertificateStoreElement(
                pCertContext,
                0,              // dwFlags
                pbSerializedElement,
                &cbSerializedElement
                )) goto SerializeCertError;

        fResult = I_CertProtectFunction(
            CERT_PROT_ADD_ROOT_FUNC_ID,
            0,                          // dwFlags
            NULL,                       // pwszIn
            pbSerializedElement,
            cbSerializedElement,
            NULL,                       // ppbOut
            NULL                        // pcbOut
            );
    } else {
        // If the certificate doesn't already exist, then, prompt the user
        if (!RegStoreProvReadCert(
                hStoreProv,
                pCertContext,
                0,              // dwFlags
                &pProvCertContext)) {
            if (IDYES != IPR_ProtectedRootMessageBox(
                    NULL,                               // hRpc
                    pCertContext,
                    IDS_ROOT_MSG_BOX_ADD_ACTION,
                    0))
                goto Cancelled;
        }

        fResult = RegStoreProvWriteCert(
            hStoreProv,
            pCertContext,
            dwFlags
            );
    }

CommonReturn:
    CertFreeCertificateContext(pProvCertContext);
    PkiFree(pbSerializedElement);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
SET_ERROR(Cancelled, ERROR_CANCELLED)
TRACE_ERROR(SerializeCertError)
TRACE_ERROR(OutOfMemory)
}


//+-------------------------------------------------------------------------
//  For "Root": prompt before deleting a cert.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI RootStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    BOOL fResult;
    PREG_STORE pRegStore = (PREG_STORE) hStoreProv;
    PCCERT_CONTEXT pProvCertContext = NULL;

    assert(pRegStore);
    if (IsInResync(pRegStore))
        // Only delete from store cache, not from registry
        return TRUE;

    if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
        goto AccessDenied;

    if (pRegStore->fProtected) {
        BYTE    rgbHash[MAX_HASH_LEN];
        DWORD   cbHash = MAX_HASH_LEN;

        // get the thumbprint
        if(!CertGetCertificateContextProperty(
                pCertContext,
                CERT_SHA1_HASH_PROP_ID,
                rgbHash,
                &cbHash
                )) goto GetCertHashPropError;
        fResult = I_CertProtectFunction(
            CERT_PROT_DELETE_ROOT_FUNC_ID,
            0,                          // dwFlags
            NULL,                       // pwszIn
            rgbHash,
            cbHash,
            NULL,                       // ppbOut
            NULL                        // pcbOut
            );
    } else {
        // Prompt the user before deleting
        if (RegStoreProvReadCert(
                hStoreProv,
                pCertContext,
                0,              // dwFlags
                &pProvCertContext)) {
            if (IDYES != IPR_ProtectedRootMessageBox(
                    NULL,                               // hRpc
                    pCertContext,
                    IDS_ROOT_MSG_BOX_DELETE_ACTION,
                    0))
                goto Cancelled;

            fResult = RegStoreProvDeleteCert(
                hStoreProv,
                pCertContext,
                dwFlags
                );
        } else
            fResult = TRUE;
    }

CommonReturn:
    CertFreeCertificateContext(pProvCertContext);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
SET_ERROR(Cancelled, ERROR_CANCELLED)
TRACE_ERROR(GetCertHashPropError)
}

//+=========================================================================
// Change Notify Support Functions
//==========================================================================

#if 0
typedef VOID (NTAPI * WAITORTIMERCALLBACKFUNC) (PVOID, BOOLEAN );
typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK ;


WINBASEAPI
BOOL
WINAPI
RegisterWaitForSingleObject(
    PHANDLE hNewWaitObject,
    HANDLE hObject,
    WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    );

WINBASEAPI
BOOL
WINAPI
UnregisterWait(
    HANDLE WaitHandle
    );

WINBASEAPI
BOOL
WINAPI
UnregisterWaitEx(
    HANDLE WaitHandle,
    HANDLE CompletionEvent      // INVALID_HANDLE_VALUE => create event
                                // to wait for
    );
#endif


typedef BOOL (WINAPI *PFN_ILS_REGISTER_WAIT_FOR_SINGLE_OBJECT)(
    PHANDLE hNewWaitObject,
    HANDLE hObject,
    ILS_WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    );

typedef BOOL (WINAPI *PFN_ILS_UNREGISTER_WAIT_EX)(
    HANDLE WaitHandle,
    HANDLE CompletionEvent      // INVALID_HANDLE_VALUE => create event
                                // to wait for
    );

#define sz_KERNEL32_DLL                 "kernel32.dll"
#define sz_RegisterWaitForSingleObject  "RegisterWaitForSingleObject"
#define sz_UnregisterWaitEx             "UnregisterWaitEx"

static HMODULE hKernel32Dll = NULL;
PFN_ILS_REGISTER_WAIT_FOR_SINGLE_OBJECT pfnILS_RegisterWaitForSingleObject;
PFN_ILS_UNREGISTER_WAIT_EX pfnILS_UnregisterWaitEx;

#define ILS_REG_WAIT_EXIT_HANDLE_INDEX      0
#define ILS_REG_WAIT_OBJECT_HANDLE_INDEX    1
#define ILS_REG_WAIT_HANDLE_COUNT           2

typedef struct _ILS_REG_WAIT_INFO {
    HANDLE                  hThread;
    DWORD                   dwThreadId;
    HANDLE                  rghWait[ILS_REG_WAIT_HANDLE_COUNT];
    ILS_WAITORTIMERCALLBACK Callback;
    PVOID                   Context;
    ULONG                   dwMilliseconds;
    HANDLE                  hDoneEvent;
} ILS_REG_WAIT_INFO, *PILS_REG_WAIT_INFO;


DWORD WINAPI ILS_WaitForThreadProc(
    LPVOID lpThreadParameter
    )
{
    PILS_REG_WAIT_INFO pWaitInfo = (PILS_REG_WAIT_INFO) lpThreadParameter;
    DWORD cWait;

    if (pWaitInfo->rghWait[ILS_REG_WAIT_OBJECT_HANDLE_INDEX])
        cWait = ILS_REG_WAIT_HANDLE_COUNT;
    else
        cWait = ILS_REG_WAIT_HANDLE_COUNT - 1;

    while (TRUE) {
        DWORD dwWaitObject;

        dwWaitObject = WaitForMultipleObjectsEx(
            cWait,
            pWaitInfo->rghWait,
            FALSE,      // bWaitAll
            pWaitInfo->dwMilliseconds,
            FALSE       // bAlertable
            );

        switch (dwWaitObject) {
            case WAIT_OBJECT_0 + ILS_REG_WAIT_OBJECT_HANDLE_INDEX:
                pWaitInfo->Callback(pWaitInfo->Context, TRUE);
                break;
            case WAIT_TIMEOUT:
                pWaitInfo->Callback(pWaitInfo->Context, FALSE);
                break;
            case WAIT_OBJECT_0 + ILS_REG_WAIT_EXIT_HANDLE_INDEX:
                if (pWaitInfo->hDoneEvent) {
                    SetEvent(pWaitInfo->hDoneEvent);
                }
                goto CommonReturn;
                break;
            default:
                goto InvalidWaitForObject;
        }
    }

CommonReturn:
    return 0;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(InvalidWaitForObject)
}


BOOL
WINAPI
ILS_RegisterWaitForSingleObject(
    PHANDLE hNewWaitObject,
    HANDLE hObject,
    ILS_WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    )
{
    BOOL fResult;
    PILS_REG_WAIT_INFO pWaitInfo = NULL;
    HANDLE hDupObject = NULL;

    if ( dwMilliseconds == 0 )
    {
        dwMilliseconds = INFINITE ;
    }

    if (NULL == (pWaitInfo = (PILS_REG_WAIT_INFO) PkiZeroAlloc(
            sizeof(ILS_REG_WAIT_INFO))))
        goto OutOfMemory;

    if (hObject) {
        if (!DuplicateHandle(
                GetCurrentProcess(),
                hObject,
                GetCurrentProcess(),
                &hDupObject,
                0,                      // dwDesiredAccess
                FALSE,                  // bInheritHandle
                DUPLICATE_SAME_ACCESS
                ) || NULL == hDupObject)
            goto DuplicateEventError;
        pWaitInfo->rghWait[ILS_REG_WAIT_OBJECT_HANDLE_INDEX] = hDupObject;
    }
    pWaitInfo->Callback = Callback;
    pWaitInfo->Context = Context;
    pWaitInfo->dwMilliseconds = dwMilliseconds;

    // Create event to be signaled to terminate the thread
    if (NULL == (pWaitInfo->rghWait[ILS_REG_WAIT_EXIT_HANDLE_INDEX] =
            CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL)))     // lpszEventName
        goto CreateThreadExitEventError;

    // Create the thread to do the wait for
    if (NULL == (pWaitInfo->hThread = CreateThread(
            NULL,           // lpThreadAttributes
            0,              // dwStackSize
            ILS_WaitForThreadProc,
            pWaitInfo,
            0,              // dwCreationFlags
            &pWaitInfo->dwThreadId
            )))
        goto CreateThreadError;

    fResult = TRUE;

CommonReturn:
    *hNewWaitObject = (HANDLE) pWaitInfo;
    return fResult;

ErrorReturn:
    if (pWaitInfo) {
        DWORD dwErr = GetLastError();

        for (DWORD i = 0; i < ILS_REG_WAIT_HANDLE_COUNT; i++) {
            if (pWaitInfo->rghWait[i])
                CloseHandle(pWaitInfo->rghWait[i]);
        }
        PkiFree(pWaitInfo);
        pWaitInfo = NULL;

        SetLastError(dwErr);
    }
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DuplicateEventError)
TRACE_ERROR(CreateThreadExitEventError)
TRACE_ERROR(CreateThreadError)
}


BOOL
WINAPI
ILS_UnregisterWait(
    HANDLE WaitHandle
    )
{
    PILS_REG_WAIT_INFO pWaitInfo = (PILS_REG_WAIT_INFO) WaitHandle;

    if (pWaitInfo->dwThreadId != GetCurrentThreadId()) {
        DWORD cWait;
        HANDLE rghWait[2];

        // On Win98 at ProcessDetach it might switch to one of the
        // threads we created.
        //
        // Alternatively, we may be called from the callback itself via
        // ILS_ExitWait()

        // Create event to be signaled by thread when its done executing
        pWaitInfo->hDoneEvent = CreateEvent(
            NULL,
            FALSE,
            FALSE,
            NULL
            );

        // Wake up the wait for thread.
        SetEvent(pWaitInfo->rghWait[ILS_REG_WAIT_EXIT_HANDLE_INDEX]);

        // Wait for either the thread to exit or the thread to signal us.
        // We can't just wait on the thread handle because the
        // loader lock might already be held if we are being called
        // from a PROCESS_DETACH (in WinINet's DllMain for example).
        rghWait[0] = pWaitInfo->hThread;
        if (pWaitInfo->hDoneEvent) {
            rghWait[1] = pWaitInfo->hDoneEvent;
            cWait = 2;
        } else {
            cWait = 1;
        }

        WaitForMultipleObjectsEx(
            cWait,
            rghWait,
            FALSE,      // bWaitAll
            INFINITE,
            FALSE       // bAlertable
            );

        if (pWaitInfo->hDoneEvent)
            CloseHandle(pWaitInfo->hDoneEvent);
    }

    CloseHandle(pWaitInfo->hThread);
    for (DWORD i = 0; i < ILS_REG_WAIT_HANDLE_COUNT; i++) {
        if (pWaitInfo->rghWait[i])
            CloseHandle(pWaitInfo->rghWait[i]);
    }
    PkiFree(pWaitInfo);

    return TRUE;
}

BOOL
WINAPI
ILS_UnregisterWaitEx(
    HANDLE WaitHandle,
    HANDLE CompletionEvent      // INVALID_HANDLE_VALUE => create event
                                // to wait for
    )
{
    assert(CompletionEvent == INVALID_HANDLE_VALUE);
    return ILS_UnregisterWait(WaitHandle);
}

// Called from the callback function
BOOL
WINAPI
ILS_ExitWait(
    HANDLE WaitHandle,
    HMODULE hLibModule
    )
{
    ILS_UnregisterWait(WaitHandle);
    if (hLibModule)
        FreeLibraryAndExitThread(hLibModule, 0);
    else
        ExitThread(0);
}

STATIC void RegWaitForProcessAttach()
{
    if (NULL == (hKernel32Dll = LoadLibraryA(sz_KERNEL32_DLL)))
        goto LoadKernel32DllError;

    if (NULL == (pfnILS_RegisterWaitForSingleObject =
            (PFN_ILS_REGISTER_WAIT_FOR_SINGLE_OBJECT) GetProcAddress(
                hKernel32Dll, sz_RegisterWaitForSingleObject)))
        goto GetRegisterWaitForSingleObjectProcAddressError;
    if (NULL == (pfnILS_UnregisterWaitEx =
            (PFN_ILS_UNREGISTER_WAIT_EX) GetProcAddress(
                hKernel32Dll, sz_UnregisterWaitEx)))
        goto GetUnregisterWaitExProcAddressError;

CommonReturn:
    return;
ErrorReturn:
    pfnILS_RegisterWaitForSingleObject = ILS_RegisterWaitForSingleObject;
    pfnILS_UnregisterWaitEx = ILS_UnregisterWaitEx;
    goto CommonReturn;

TRACE_ERROR(LoadKernel32DllError)
TRACE_ERROR(GetRegisterWaitForSingleObjectProcAddressError)
TRACE_ERROR(GetUnregisterWaitExProcAddressError)
}

STATIC void RegWaitForProcessDetach()
{
    if (hKernel32Dll) {
        FreeLibrary(hKernel32Dll);
        hKernel32Dll = NULL;
    }
}


// Upon entry/exit, the resync list is locked by the caller
void ILS_RemoveEventFromResyncList(
    IN HANDLE hEvent,
    IN OUT DWORD *pcEntry,
    IN OUT PILS_RESYNC_ENTRY *ppEntry
    )
{
    DWORD cOrigEntry = *pcEntry;
    DWORD cNewEntry = 0;
    PILS_RESYNC_ENTRY pEntry = *ppEntry;
    DWORD i;

    for (i = 0; i < cOrigEntry; i++) {
        if (pEntry[i].hOrigEvent == hEvent) {
            HANDLE hDupEvent;

            hDupEvent = pEntry[i].hDupEvent;
            if (hDupEvent)
                CloseHandle(hDupEvent);
        } else {
            if (i != cNewEntry)
                pEntry[cNewEntry] = pEntry[i];
            cNewEntry++;
        }
    }

    *pcEntry = cNewEntry;
}

// Upon entry/exit, the resync list is locked by the caller
BOOL ILS_AddRemoveEventToFromResyncList(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent,
    IN DWORD dwFlags,
    IN OUT DWORD *pcEntry,
    IN OUT PILS_RESYNC_ENTRY *ppEntry
    )
{
    BOOL fResult;
    HANDLE hDupEvent = NULL;
    DWORD cEntry;
    PILS_RESYNC_ENTRY pEntry;
    DWORD i;

    assert(hEvent);

    if (dwFlags & REG_STORE_CTRL_CANCEL_NOTIFY_FLAG) {
        ILS_RemoveEventFromResyncList(
            hEvent,
            pcEntry,
            ppEntry
            );
        return TRUE;
    }

    cEntry = *pcEntry;
    pEntry = *ppEntry;

    // First check if the hEvent is already in the list
    for (i = 0; i < cEntry; i++) {
        if (hEvent == pEntry[i].hOrigEvent)
            return TRUE;
    }

    if (0 == (dwFlags & CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG)) {
        if (!DuplicateHandle(
                GetCurrentProcess(),
                hEvent,
                GetCurrentProcess(),
                &hDupEvent,
                0,                      // dwDesiredAccess
                FALSE,                  // bInheritHandle
                DUPLICATE_SAME_ACCESS
                ) || NULL == hDupEvent)
            goto DuplicateEventError;
    }

    if (NULL == (pEntry = (PILS_RESYNC_ENTRY) PkiRealloc(pEntry,
            (cEntry + 1) * sizeof(ILS_RESYNC_ENTRY))))
        goto OutOfMemory;
    pEntry[cEntry].hOrigEvent = hEvent;
    pEntry[cEntry].pRegStore = pRegStore;
    pEntry[cEntry].hDupEvent = hDupEvent;
    *pcEntry = cEntry + 1;
    *ppEntry = pEntry;
    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    if (hDupEvent)
        ILS_CloseHandle(hDupEvent);
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DuplicateEventError)
TRACE_ERROR(OutOfMemory)
}

// Upon entry/exit, the resync list is locked by the caller
void ILS_SignalEventsOnResyncList(
    IN OUT DWORD *pcEntry,
    IN OUT PILS_RESYNC_ENTRY *ppEntry
    )
{
    DWORD cEntry = *pcEntry;
    PILS_RESYNC_ENTRY pEntry = *ppEntry;

    while (cEntry--) {
        HANDLE hDupEvent;

        hDupEvent = pEntry[cEntry].hDupEvent;
        if (hDupEvent) {
            SetEvent(hDupEvent);
            CloseHandle(hDupEvent);
        } else
            SetEvent(pEntry[cEntry].hOrigEvent);
    }

    PkiFree(pEntry);

    *pcEntry = 0;
    *ppEntry = NULL;
}

// Upon entry/exit, the resync list is locked by the caller
void ILS_SignalAndFreeRegStoreResyncEntries(
    IN PREG_STORE pRegStore,
    IN OUT DWORD *pcEntry,
    IN OUT PILS_RESYNC_ENTRY *ppEntry
    )
{
    DWORD cOrigEntry = *pcEntry;
    DWORD cNewEntry = 0;
    PILS_RESYNC_ENTRY pEntry = *ppEntry;
    DWORD i;

    for (i = 0; i < cOrigEntry; i++) {
        if (pEntry[i].pRegStore == pRegStore) {
            HANDLE hDupEvent;

            hDupEvent = pEntry[i].hDupEvent;
            if (hDupEvent) {
                SetEvent(hDupEvent);
                CloseHandle(hDupEvent);
            } else
                SetEvent(pEntry[i].hOrigEvent);
        } else {
            if (i != cNewEntry)
                pEntry[cNewEntry] = pEntry[i];
            cNewEntry++;
        }
    }

    *pcEntry = cNewEntry;
}

STATIC BOOL ILS_RegNotifyChangeKeyValue(
    IN HKEY hKey,
    IN HANDLE hEvent
    )
{
    BOOL fResult;
    LONG err;

    err = RegNotifyChangeKeyValue(
        hKey,
        TRUE,                       // bWatchSubtree
        REG_NOTIFY_CHANGE_NAME |
        REG_NOTIFY_CHANGE_LAST_SET,
        hEvent,
        TRUE                        // fAsynchronus
        );
    if (!(ERROR_SUCCESS == err || ERROR_KEY_DELETED == err))
        goto RegNotifyChangeKeyValueError;

    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegNotifyChangeKeyValueError, err)
}


//+=========================================================================
//  Client "GPT" Store Data Structures and Functions
//==========================================================================

static PGPT_STORE_CHANGE_INFO pLMGptStoreChangeInfo;

typedef HANDLE (WINAPI *PFN_ENTER_CRITICAL_POLICY_SECTION)(
    IN BOOL bMachine
    );
typedef BOOL (WINAPI *PFN_LEAVE_CRITICAL_POLICY_SECTION)(
    IN HANDLE hSection
    );

typedef BOOL (WINAPI *PFN_REGISTER_GP_NOTIFICATION)(
    IN HANDLE hEvent,
    IN BOOL bMachine
    );

typedef BOOL (WINAPI *PFN_UNREGISTER_GP_NOTIFICATION)(
    IN HANDLE hEvent
    );

#define sz_USERENV_DLL                  "userenv.dll"
#define sz_EnterCriticalPolicySection   "EnterCriticalPolicySection"
#define sz_LeaveCriticalPolicySection   "LeaveCriticalPolicySection"
#define sz_RegisterGPNotification       "RegisterGPNotification"
#define sz_UnregisterGPNotification     "UnregisterGPNotification"

static fLoadedUserEnvDll = FALSE;
static HMODULE hUserEnvDll = NULL;
static PFN_ENTER_CRITICAL_POLICY_SECTION pfnEnterCriticalPolicySection = NULL;
static PFN_LEAVE_CRITICAL_POLICY_SECTION pfnLeaveCriticalPolicySection = NULL;
static PFN_REGISTER_GP_NOTIFICATION pfnRegisterGPNotification = NULL;
static PFN_UNREGISTER_GP_NOTIFICATION pfnUnregisterGPNotification = NULL;


//+-------------------------------------------------------------------------
//  Lock and unlock GPT_STORE functions
//--------------------------------------------------------------------------
static inline void GptStoreLock()
{
    EnterCriticalSection(&ILS_CriticalSection);
}
static inline void GptStoreUnlock()
{
    LeaveCriticalSection(&ILS_CriticalSection);
}

STATIC void GptLoadUserEnvDll()
{
    HMODULE hDll;
    if (fLoadedUserEnvDll)
        return;

    // Do load library without holding a lock
    hDll = LoadLibraryA(sz_USERENV_DLL);

    GptStoreLock();
    if (fLoadedUserEnvDll) {
        if (hDll)
            FreeLibrary(hDll);
        goto CommonReturn;
    }

    if (NULL == hDll)
        goto LoadUserEnvDllError;

    if (pfnEnterCriticalPolicySection =
            (PFN_ENTER_CRITICAL_POLICY_SECTION) GetProcAddress(
                hDll, sz_EnterCriticalPolicySection)) {
        if (NULL == (pfnLeaveCriticalPolicySection =
                (PFN_LEAVE_CRITICAL_POLICY_SECTION) GetProcAddress(
                    hDll, sz_LeaveCriticalPolicySection))) {
            pfnEnterCriticalPolicySection = NULL;
#if DBG
            DWORD dwErr = GetLastError();
            DbgPrintf(DBG_SS_CRYPT32,
                "userenv.dll:: GetProcAddress(%s) returned error: %d 0x%x\n",
                    sz_LeaveCriticalPolicySection, dwErr, dwErr);
#endif
        }
    } else {
#if DBG
        DWORD dwErr = GetLastError();
        DbgPrintf(DBG_SS_CRYPT32,
            "userenv.dll:: GetProcAddress(%s) returned error: %d 0x%x\n",
                sz_EnterCriticalPolicySection, dwErr, dwErr);
#endif
    }

    if (pfnRegisterGPNotification = 
        (PFN_REGISTER_GP_NOTIFICATION) GetProcAddress(
                hDll, sz_RegisterGPNotification)) {
        if (NULL == (pfnUnregisterGPNotification =
                (PFN_UNREGISTER_GP_NOTIFICATION) GetProcAddress(
                    hDll, sz_UnregisterGPNotification))) {
            pfnRegisterGPNotification = NULL; 
#if DBG
            DWORD dwErr = GetLastError();
            DbgPrintf(DBG_SS_CRYPT32,
                "userenv.dll:: GetProcAddress(%s) returned error: %d 0x%x\n",
                    sz_UnregisterGPNotification, dwErr, dwErr);
#endif
        }
    } else {
#if DBG
        DWORD dwErr = GetLastError();
        DbgPrintf(DBG_SS_CRYPT32,
            "userenv.dll:: GetProcAddress(%s) returned error: %d 0x%x\n",
                sz_RegisterGPNotification, dwErr, dwErr);
#endif
    }

    if (pfnEnterCriticalPolicySection || pfnRegisterGPNotification)
        hUserEnvDll = hDll;
    else
        FreeLibrary(hDll);

CommonReturn:
    fLoadedUserEnvDll = TRUE;
    GptStoreUnlock();

    return;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(LoadUserEnvDllError)
}

STATIC HANDLE GptStoreEnterCriticalPolicySection(
    IN BOOL bMachine
    )
{
#if 1
    // ATTENTION:: entering this critical section is causing numerous hanging,
    // deadlock problems
    return NULL;
#else
    HANDLE hSection;

    GptLoadUserEnvDll();
    if (NULL == pfnEnterCriticalPolicySection)
        return NULL;

    assert(hUserEnvDll);
    assert(pfnLeaveCriticalPolicySection);
    if (NULL == (hSection = pfnEnterCriticalPolicySection(bMachine)))
        goto EnterCriticalPolicySectionError;

CommonReturn:
    return hSection;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(EnterCriticalPolicySectionError)
#endif
}

STATIC void GptStoreLeaveCriticalPolicySection(
    IN HANDLE hSection
    )
{
    if (hSection) {
        assert(hUserEnvDll);
        assert(pfnLeaveCriticalPolicySection);
        if (!pfnLeaveCriticalPolicySection(hSection))
            goto LeaveCriticalPolicySectionError;
    }

CommonReturn:
    return;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(LeaveCriticalPolicySectionError)
}

STATIC void GptStoreSignalAndFreeRegStoreResyncEntries(
    IN PREG_STORE pRegStore
    )
{
    GptStoreLock();
    if (pLMGptStoreChangeInfo)
        ILS_SignalAndFreeRegStoreResyncEntries(
            pRegStore,
            &pLMGptStoreChangeInfo->cNotifyEntry,
            &pLMGptStoreChangeInfo->rgNotifyEntry
            );
    GptStoreUnlock();
}

STATIC void GptStoreProcessAttach()
{
}

STATIC void GptStoreProcessDetach()
{
    FreeGptStoreChangeInfo(&pLMGptStoreChangeInfo);

    if (hUserEnvDll) {
        FreeLibrary(hUserEnvDll);
        hUserEnvDll = NULL;
    }
}

STATIC VOID NTAPI GptWaitForCallback(
    PVOID Context,
    BOOLEAN fWaitOrTimedOut        // ???
    )
{
    PGPT_STORE_CHANGE_INFO pInfo = (PGPT_STORE_CHANGE_INFO) Context;
    DWORD cEntry;
    PILS_RESYNC_ENTRY pEntry;

    assert(pInfo);
    assert(LM_GPT_CHANGE_INFO_TYPE == pInfo->dwType ||
        CU_GPT_CHANGE_INFO_TYPE == pInfo->dwType);

    if (NULL == pInfo)
        return;
    if (!(LM_GPT_CHANGE_INFO_TYPE == pInfo->dwType ||
            CU_GPT_CHANGE_INFO_TYPE == pInfo->dwType))
        return;

    if (pInfo->hGPNotificationEvent) {
        // We are called for all GPNotification events.
        // Check that we also have a registry change notify.

        if (pInfo->hPoliciesKey) {
            assert(pInfo->hPoliciesEvent);
            if (WAIT_OBJECT_0 != WaitForSingleObjectEx(
                    pInfo->hPoliciesEvent,
                    0,                          // dwMilliseconds
                    FALSE                       // bAlertable
                    ))
                return;
            // When policy is applied, the registry key is deleted before
            // reapplying policy.
            ILS_CloseRegistryKey(pInfo->hPoliciesKey);
        }

        // Re-Open the Software\Policies\Microsoft\SystemCertificates registry
        // key
        //
        // Ignore BACKUP_RESTORE case, in a different thread
        pInfo->hPoliciesKey = OpenSubKey(
            pInfo->hKeyBase,
            GROUP_POLICY_STORE_REGPATH,
            CERT_STORE_READONLY_FLAG
            );
    }

    if (pInfo->hPoliciesKey) {
        assert(pInfo->hPoliciesEvent);
        // Re-arm the registry notify
        ILS_RegNotifyChangeKeyValue(
            pInfo->hPoliciesKey,
            pInfo->hPoliciesEvent
            );
    }

    // Minimize window of potential deadlock by only getting the values
    // while holding the lock.
    if (pInfo->pRegStore) {
        assert(CU_GPT_CHANGE_INFO_TYPE == pInfo->dwType);

        CertPerfIncrementChangeNotifyCuGpCount();

        LockRegStore(pInfo->pRegStore);
    } else {
        assert(LM_GPT_CHANGE_INFO_TYPE == pInfo->dwType);

        CertPerfIncrementChangeNotifyLmGpCount();

        GptStoreLock();
    }

            cEntry = pInfo->cNotifyEntry;
            pEntry = pInfo->rgNotifyEntry;

            pInfo->cNotifyEntry = 0;
            pInfo->rgNotifyEntry = NULL;

    ILS_SignalEventsOnResyncList(&cEntry, &pEntry);


    if (pInfo->pRegStore)
        UnlockRegStore(pInfo->pRegStore);
    else
        GptStoreUnlock();


    CertPerfIncrementChangeNotifyCount();
}

STATIC void FreeGptStoreChangeInfo(
    IN OUT PGPT_STORE_CHANGE_INFO *ppInfo
    )
{
    PGPT_STORE_CHANGE_INFO pInfo = *ppInfo;

    if (NULL == pInfo)
        return;
    if (!(LM_GPT_CHANGE_INFO_TYPE == pInfo->dwType ||
            CU_GPT_CHANGE_INFO_TYPE == pInfo->dwType))
        return;

    // Unregister the wait for callback
    if (pInfo->hRegWaitFor)
        pfnILS_UnregisterWaitEx(pInfo->hRegWaitFor, INVALID_HANDLE_VALUE);

    if (pInfo->hGPNotificationEvent) {
        assert(hUserEnvDll && pfnUnregisterGPNotification);
        pfnUnregisterGPNotification(
            pInfo->hGPNotificationEvent);
        CloseHandle(pInfo->hGPNotificationEvent);
    }

    ILS_CloseRegistryKey(pInfo->hPoliciesKey);

    if (pInfo->hPoliciesEvent)
        CloseHandle(pInfo->hPoliciesEvent);

    // To inhibit any potential deadlock, do following without entering
    // the critical section
    ILS_SignalEventsOnResyncList(
        &pInfo->cNotifyEntry,
        &pInfo->rgNotifyEntry
        );

    PkiFree(pInfo);
    *ppInfo = NULL;
}

STATIC PGPT_STORE_CHANGE_INFO CreateGptStoreChangeInfo(
    IN PREG_STORE pRegStore,
    IN BOOL fMachine
    )
{
    PGPT_STORE_CHANGE_INFO pInfo = NULL;
    DWORD dwErr;
    BOOL fGPNotify = FALSE;

    GptLoadUserEnvDll();

    if (NULL == (pInfo = (PGPT_STORE_CHANGE_INFO) PkiZeroAlloc(
            sizeof(GPT_STORE_CHANGE_INFO))))
        goto OutOfMemory;

    if (fMachine) {
        pInfo->dwType = LM_GPT_CHANGE_INFO_TYPE;
        // pInfo->pRegStore = NULL;
    } else {
        pInfo->dwType = CU_GPT_CHANGE_INFO_TYPE;
        pInfo->pRegStore = pRegStore;
    }

    pInfo->hKeyBase = pRegStore->GptPara.hKeyBase;

    // Create our own event to be notified on a change
    if (NULL == (pInfo->hPoliciesEvent = CreateEvent(
            NULL,       // lpsa
            FALSE,      // fManualReset
            FALSE,      // fInitialState
            NULL)))     // lpszEventName
        goto CreateEventError;

    // If the RegisterGPNotification API exists in userenv.dll, use it.
    if (pfnRegisterGPNotification) {
        if (NULL == (pInfo->hGPNotificationEvent = CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL)))     // lpszEventName
            goto CreateEventError;
        if (pfnRegisterGPNotification(
                pInfo->hGPNotificationEvent,
                fMachine
                ))
            fGPNotify = TRUE;
        else {
#if DBG
            dwErr = GetLastError();
            DbgPrintf(DBG_SS_CRYPT32,
                "RegisterGPNotification returned error: %d 0x%x\n",
                    dwErr, dwErr);
#endif
            CloseHandle(pInfo->hGPNotificationEvent);
            pInfo->hGPNotificationEvent = NULL;
        }
    }

    // Open the Software\Policies\Microsoft\SystemCertificates registry key
    //
    // Ignore BACKUP_RESTORE case
    if (NULL == (pInfo->hPoliciesKey = OpenSubKey(
            pInfo->hKeyBase,
            GROUP_POLICY_STORE_REGPATH,
            CERT_STORE_READONLY_FLAG
            ))) {
        if (!fGPNotify) {
            // Ignore error if subkey doesn't exist.
            if (ERROR_FILE_NOT_FOUND == GetLastError())
                goto SuccessReturn;
            goto OpenSubKeyError;
        }
    } else {
        // Arm the registry notify
        if (!ILS_RegNotifyChangeKeyValue(
                pInfo->hPoliciesKey,
                pInfo->hPoliciesEvent
                ))
            goto RegNotifyChangeKeyValueError;
    }

    if (!pfnILS_RegisterWaitForSingleObject(
            &pInfo->hRegWaitFor,
            fGPNotify ? pInfo->hGPNotificationEvent : pInfo->hPoliciesEvent,
            GptWaitForCallback,
            (PVOID) pInfo,
            INFINITE,  // no timeout
            WT_EXECUTEINWAITTHREAD
            )) {
        pInfo->hRegWaitFor = NULL;
        dwErr = GetLastError();
        goto RegisterWaitForError;
    }

SuccessReturn:
CommonReturn:
    return pInfo;
ErrorReturn:
    dwErr = GetLastError();

    FreeGptStoreChangeInfo(&pInfo);

    SetLastError(dwErr);
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreateEventError)
TRACE_ERROR(OpenSubKeyError)
TRACE_ERROR(RegNotifyChangeKeyValueError)
SET_ERROR_VAR(RegisterWaitForError, dwErr)
}

// For LocalMachine: a single store change info data structure for all LMGP
// stores.
//
// For CurrentUser: each CUCP store has its own store change info.
STATIC BOOL RegGptStoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    PGPT_STORE_CHANGE_INFO pInfo;

    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_REMOTE_FLAG) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_LM_GPT_FLAG) {
        if (NULL == (pInfo = pLMGptStoreChangeInfo)) {
            if (NULL == (pInfo = CreateGptStoreChangeInfo(
                    pRegStore,
                    TRUE        // fMachine
                    )))
                goto CreateChangeInfoError;

            GptStoreLock();
            if (pLMGptStoreChangeInfo) {
                GptStoreUnlock();
                FreeGptStoreChangeInfo(&pInfo);
                pInfo = pLMGptStoreChangeInfo;
            } else {
                pLMGptStoreChangeInfo = pInfo;
                GptStoreUnlock();
            }
        }

        assert(LM_GPT_CHANGE_INFO_TYPE == pInfo->dwType);
        GptStoreLock();
        fResult = ILS_AddRemoveEventToFromResyncList(
            pRegStore,
            hEvent,
            dwFlags,
            &pInfo->cNotifyEntry,
            &pInfo->rgNotifyEntry
            );
        GptStoreUnlock();
    } else {
        if (NULL == (pInfo = pRegStore->pGptStoreChangeInfo)) {
            if (NULL == (pInfo = CreateGptStoreChangeInfo(
                    pRegStore,
                    FALSE       // fMachine
                    )))
                goto CreateChangeInfoError;

            LockRegStore(pRegStore);
            if (pRegStore->pGptStoreChangeInfo) {
                UnlockRegStore(pRegStore);
                FreeGptStoreChangeInfo(&pInfo);
                pInfo = pRegStore->pGptStoreChangeInfo;
            } else {
                pRegStore->pGptStoreChangeInfo = pInfo;
                UnlockRegStore(pRegStore);
            }
        }

        assert(CU_GPT_CHANGE_INFO_TYPE == pInfo->dwType);
        LockRegStore(pRegStore);
        fResult = ILS_AddRemoveEventToFromResyncList(
            pRegStore,
            hEvent,
            dwFlags,
            &pInfo->cNotifyEntry,
            &pInfo->rgNotifyEntry
            );
        UnlockRegStore(pRegStore);
    }

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateChangeInfoError)
}

STATIC BOOL OpenAllFromGptRegistry(
    IN PREG_STORE pRegStore,
    IN HCERTSTORE hCertStore
    )
{
    BOOL fResult;
    HANDLE hSection = NULL;

    LockRegStore(pRegStore);

    if (0 == (pRegStore->dwFlags & CERT_REGISTRY_STORE_REMOTE_FLAG))
        hSection = GptStoreEnterCriticalPolicySection(
            pRegStore->dwFlags & CERT_REGISTRY_STORE_LM_GPT_FLAG
            );

    assert(NULL == pRegStore->hKey);
    if (NULL == (pRegStore->hKey = OpenSubKey(
            pRegStore->GptPara.hKeyBase,
            pRegStore->GptPara.pwszRegPath,
            pRegStore->dwFlags
            ))) {
        if (ERROR_FILE_NOT_FOUND != GetLastError() ||
                (pRegStore->dwFlags & CERT_STORE_OPEN_EXISTING_FLAG))
            goto OpenSubKeyError;
        fResult = TRUE;
        goto CommonReturn;
    }

//    fResult = OpenAllFromSerializedRegistry(pRegStore, hCertStore);

    // Ignore any errors
    OpenAllFromRegistry(pRegStore, hCertStore);
    fResult = TRUE;

CommonReturn:
    ILS_CloseRegistryKey(pRegStore->hKey);
    pRegStore->hKey = NULL;
    GptStoreLeaveCriticalPolicySection(hSection);
    UnlockRegStore(pRegStore);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenSubKeyError)
}

STATIC BOOL CommitAllToGptRegistry(
    IN PREG_STORE pRegStore,
    IN DWORD dwFlags
    )
{
#if 1
    return TRUE;
#else
    BOOL fResult;
    BOOL fTouched;
    DWORD dwSaveFlags;

    LockRegStore(pRegStore);

    if (dwFlags & CERT_STORE_CTRL_COMMIT_FORCE_FLAG)
        fTouched = TRUE;
    else if (dwFlags & CERT_STORE_CTRL_COMMIT_CLEAR_FLAG)
        fTouched = FALSE;
    else
        fTouched = pRegStore->fTouched;

    if (fTouched) {
        if (pRegStore->dwFlags & CERT_STORE_READONLY_FLAG)
            goto AccessDenied;
    } else {
        pRegStore->fTouched = FALSE;
        fResult = TRUE;
        goto CommonReturn;
    }

    assert(NULL == pRegStore->hKey);
    if (NULL == (pRegStore->hKey = OpenSubKey(
            pRegStore->GptPara.hKeyBase,
            pRegStore->GptPara.pwszRegPath,
            pRegStore->dwFlags
            )))
        goto OpenSubKeyError;

    dwSaveFlags = pRegStore->dwFlags;
    pRegStore->dwFlags &= ~CERT_STORE_OPEN_EXISTING_FLAG;
    fResult = CommitAllToSerializedRegistry(pRegStore, dwFlags);
    pRegStore->dwFlags = dwSaveFlags;
CommonReturn:
    ILS_CloseRegistryKey(pRegStore->hKey);
    pRegStore->hKey = NULL;
    UnlockRegStore(pRegStore);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(OpenSubKeyError)
#endif
}


//+=========================================================================
//  Win95 Notify Store Data Structures and Functions
//
//  Win95/Win98 don't support registry change notification.
//
//  On Win95 we pulse an event each time a store context element is written
//  or deleted.
//==========================================================================
static BOOL fWin95StoreInitialized;
static HANDLE hWin95RegWaitFor;

static DWORD cWin95StoreResyncEntry;
static ILS_RESYNC_ENTRY *pWin95StoreResyncEntry;


//+-------------------------------------------------------------------------
//  Lock and unlock WIN95_STORE functions
//--------------------------------------------------------------------------
static inline void Win95StoreLock()
{
    EnterCriticalSection(&ILS_CriticalSection);
}
static inline void Win95StoreUnlock()
{
    LeaveCriticalSection(&ILS_CriticalSection);
}

STATIC void Win95StoreSignalAndFreeRegStoreResyncEntries(
    IN PREG_STORE pRegStore
    )
{
    if (NULL == hWin95NotifyEvent)
        return;

    Win95StoreLock();

    ILS_SignalAndFreeRegStoreResyncEntries(
        pRegStore,
        &cWin95StoreResyncEntry,
        &pWin95StoreResyncEntry
        );

    Win95StoreUnlock();
}

STATIC void Win95StoreProcessAttach()
{
    if (FIsWinNT())
        return;

    hWin95NotifyEvent = CreateEventA(
            NULL,           // lpsa
            TRUE,           // fManualReset
            FALSE,          // fInitialState
            "Win95CertStoreNotifyEvent"
            );
    if (NULL == hWin95NotifyEvent)
        goto CreateWin95NotifyEventError;

CommonReturn:
    return;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(CreateWin95NotifyEventError)
}

STATIC void Win95StoreProcessDetach()
{
    if (NULL == hWin95NotifyEvent)
        return;

    if (fWin95StoreInitialized) {
        // Unregister the wait for callback
        assert(hWin95RegWaitFor);
        pfnILS_UnregisterWaitEx(hWin95RegWaitFor, INVALID_HANDLE_VALUE);

        // To inhibit any potential deadlock, do following without entering
        // the critical section
        ILS_SignalEventsOnResyncList(
            &cWin95StoreResyncEntry,
            &pWin95StoreResyncEntry
            );

        fWin95StoreInitialized = FALSE;
    }

    CloseHandle(hWin95NotifyEvent);
}

STATIC VOID NTAPI Win95WaitForCallback(
    PVOID Context,
    BOOLEAN fWaitOrTimedOut        // ???
    )
{
    DWORD cEntry;
    PILS_RESYNC_ENTRY pEntry;

    Win95StoreLock();
        cEntry = cWin95StoreResyncEntry;
        pEntry = pWin95StoreResyncEntry;

        cWin95StoreResyncEntry = 0;
        pWin95StoreResyncEntry = NULL;
    Win95StoreUnlock();

    ILS_SignalEventsOnResyncList(
        &cEntry,
        &pEntry
        );
}

STATIC BOOL Win95StoreChangeInit()
{
    BOOL fResult;
    DWORD dwErr;
    HANDLE hRegWaitFor;

    if (fWin95StoreInitialized)
        return TRUE;

    Win95StoreLock();

    if (fWin95StoreInitialized)
        goto SuccessReturn;

    assert(hWin95NotifyEvent);
    if (!pfnILS_RegisterWaitForSingleObject(
            &hRegWaitFor,
            hWin95NotifyEvent,
            Win95WaitForCallback,
            NULL,                   // Context
            INFINITE,               // no timeout
            0                       // no flags (normal)
            )) {
        dwErr = GetLastError();
        goto RegisterWaitForError;
    }

    hWin95RegWaitFor = hRegWaitFor;

SuccessReturn:
    fResult = TRUE;
    fWin95StoreInitialized = TRUE;

CommonReturn:
    Win95StoreUnlock();
    return fResult;;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegisterWaitForError, dwErr)
}

STATIC BOOL RegWin95StoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent,
    IN DWORD dwFlags
    )
{
    BOOL fResult;

    assert(hWin95NotifyEvent);

    if (!Win95StoreChangeInit())
        return FALSE;

    Win95StoreLock();
    fResult = ILS_AddRemoveEventToFromResyncList(
            pRegStore,
            hEvent,
            dwFlags,
            &cWin95StoreResyncEntry,
            &pWin95StoreResyncEntry
            );
    Win95StoreUnlock();
    return fResult;
}



//+=========================================================================
// Roaming Store Functions
//==========================================================================

#if 0
SHSTDAPI SHGetFolderPathW(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR lpszPath);
#endif

typedef HRESULT (STDAPICALLTYPE *PFN_GET_FOLDER_PATH) (
    HWND hwnd,
    int csidl,
    HANDLE hToken,
    DWORD dwFlags,
    LPWSTR lpszPath
    );

#define sz_SHELL32_DLL              "shell32.dll"
#define sz_GetFolderPath            "SHGetFolderPathW"

static fLoadedShell32Dll = FALSE;
static HMODULE hShell32Dll = NULL;
static PFN_GET_FOLDER_PATH pfnGetFolderPath = NULL;

#if 0
// from \nt\public\internal\ds\inc\userenvp.h
USERENVAPI
DWORD 
WINAPI
GetUserAppDataPathW(
    IN HANDLE hToken,
    IN BOOL fLocalAppData,
    OUT LPWSTR lpFolderPath
    );
#endif

typedef DWORD (WINAPI *PFN_GET_USER_APP_DATA_PATH) (
    IN HANDLE hToken,
    IN BOOL fLocalAppData,
    OUT LPWSTR lpFolderPath
    );

#define sz_ROAMING_USERENV_DLL      "userenv.dll"
#define wsz_ROAMING_USERENV_DLL     L"userenv.dll"
// From \nt\ds\security\gina\userenv\main\userenv.def
//  GetUserAppDataPathW          @149    NONAME ;Internal
#define ORDINAL_GetUserAppDataPath  149
// First version to support GetUserAppDataPath
#define ROAMING_USERENV_DLL_VER_MS  ((    5 << 16) |   1 )
#define ROAMING_USERENV_DLL_VER_LS  (( 2465 << 16) |   0 )

static fLoadedRoamingUserenvDll = FALSE;
static HMODULE hRoamingUserenvDll = NULL;
static PFN_GET_USER_APP_DATA_PATH pfnGetUserAppDataPath = NULL;

static inline void RoamingStoreLock()
{
    EnterCriticalSection(&ILS_CriticalSection);
}
static inline void RoamingStoreUnlock()
{
    LeaveCriticalSection(&ILS_CriticalSection);
}

STATIC void RoamingStoreProcessAttach()
{
}

STATIC void RoamingStoreProcessDetach()
{
    if (hShell32Dll) {
        FreeLibrary(hShell32Dll);
        hShell32Dll = NULL;
    }

    if (hRoamingUserenvDll) {
        FreeLibrary(hRoamingUserenvDll);
        hRoamingUserenvDll = NULL;
    }
}

STATIC void RoamingStoreLoadShell32Dll()
{
    if (fLoadedShell32Dll)
        return;

    RoamingStoreLock();
    if (fLoadedShell32Dll)
        goto CommonReturn;

    if (NULL == (hShell32Dll = LoadLibraryA(sz_SHELL32_DLL)))
        goto LoadShell32DllError;

    if (NULL == (pfnGetFolderPath =
            (PFN_GET_FOLDER_PATH) GetProcAddress(hShell32Dll,
                sz_GetFolderPath)))
        goto GetFolderPathProcAddressError;

CommonReturn:
    fLoadedShell32Dll = TRUE;
    RoamingStoreUnlock();
    return;

ErrorReturn:
    if (hShell32Dll) {
        FreeLibrary(hShell32Dll);
        hShell32Dll = NULL;
        pfnGetFolderPath = NULL;
    }
    goto CommonReturn;
TRACE_ERROR(LoadShell32DllError)
TRACE_ERROR(GetFolderPathProcAddressError)
}

STATIC void RoamingStoreLoadUserenvDll()
{
    DWORD dwFileVersionMS;
    DWORD dwFileVersionLS;

    if (fLoadedRoamingUserenvDll)
        return;

    RoamingStoreLock();
    if (fLoadedRoamingUserenvDll)
        goto CommonReturn;

    // GetUserAppDataPath() not supported until later versions of userenv.dll
    // in WXP
    if (!I_CryptGetFileVersion(
            wsz_ROAMING_USERENV_DLL,
            &dwFileVersionMS,
            &dwFileVersionLS
            ))
        goto GetUserenvFileVersionError;
    if (ROAMING_USERENV_DLL_VER_MS < dwFileVersionMS)
        ;
    else if (ROAMING_USERENV_DLL_VER_MS == dwFileVersionMS &&
                ROAMING_USERENV_DLL_VER_LS <= dwFileVersionLS)
        ;
    else
        goto Userenv_GetUserAppDataPathNotSupported;

    if (NULL == (hRoamingUserenvDll = LoadLibraryA(sz_ROAMING_USERENV_DLL)))
        goto LoadUserenvDllError;

    if (NULL == (pfnGetUserAppDataPath =
            (PFN_GET_USER_APP_DATA_PATH) GetProcAddress(hRoamingUserenvDll,
                (LPCSTR) ORDINAL_GetUserAppDataPath)))
        goto GetUserAppDataPathProcAddressError;

CommonReturn:
    fLoadedRoamingUserenvDll = TRUE;
    RoamingStoreUnlock();
    return;

ErrorReturn:
    if (hRoamingUserenvDll) {
        FreeLibrary(hRoamingUserenvDll);
        hRoamingUserenvDll = NULL;
        pfnGetUserAppDataPath = NULL;
    }
    goto CommonReturn;
TRACE_ERROR(GetUserenvFileVersionError)
SET_ERROR_VAR(Userenv_GetUserAppDataPathNotSupported, ERROR_NOT_SUPPORTED)
TRACE_ERROR(LoadUserenvDllError)
TRACE_ERROR(GetUserAppDataPathProcAddressError)
}

STATIC HANDLE GetRoamingToken()
{
    HANDLE hToken = NULL;
    DWORD dwErr;

    if (!FIsWinNT()) {
        return NULL;
    }

    //
    // first, attempt to look at the thread token.  If none exists,
    // which is true if the thread is not impersonating, try the
    // process token.
    //

    if (!OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY | TOKEN_IMPERSONATE,
                TRUE,
                &hToken
                )) {
        dwErr = GetLastError();
        if (ERROR_NO_TOKEN != dwErr)
            goto OpenThreadTokenError;

        if (!OpenProcessToken(GetCurrentProcess(),
                TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_DUPLICATE, &hToken)) {
            dwErr = GetLastError();
            goto OpenProcessTokenError;
        }
    }

CommonReturn:
    return hToken;
ErrorReturn:
    hToken = NULL;
    goto CommonReturn;
SET_ERROR_VAR(OpenThreadTokenError, dwErr)
SET_ERROR_VAR(OpenProcessTokenError, dwErr)
}

STATIC
DWORD 
FastGetUserAppDataPath(
    IN HANDLE hToken, 
    OUT WCHAR wszFolderPath[MAX_PATH]
    )
{
    DWORD dwErr;

    RoamingStoreLoadUserenvDll();
    if (NULL == hRoamingUserenvDll)
        goto ErrorReturn;
    assert(pfnGetUserAppDataPath);

    wszFolderPath[0] = L'\0';
    __try {
        dwErr = pfnGetUserAppDataPath(
                hToken,
                FALSE,
                wszFolderPath
                );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwErr = GetExceptionCode();
        goto GetUserAppDataPathException;
    }

    if (ERROR_SUCCESS != dwErr || L'\0' == wszFolderPath[0])
        goto GetUserAppDataPathError;

#if DBG
        DbgPrintf(DBG_SS_CRYPT32, "userenv!GetUserAppDataPath:: %S\n",
            wszFolderPath);
#endif

    dwErr = ERROR_SUCCESS;
CommonReturn:
    return dwErr;
ErrorReturn:
    dwErr = ERROR_FILE_NOT_FOUND;
    goto CommonReturn;

SET_ERROR_VAR(GetUserAppDataPathException, dwErr)
SET_ERROR_VAR(GetUserAppDataPathError, dwErr)
}

STATIC
DWORD 
SlowGetUserAppDataPath(
    IN HANDLE hToken, 
    OUT WCHAR wszFolderPath[MAX_PATH]
    )
{
    DWORD dwErr;
    HRESULT hr;

    RoamingStoreLoadShell32Dll();
    if (NULL == hShell32Dll)
        goto ErrorReturn;
    assert(pfnGetFolderPath);

    wszFolderPath[0] = L'\0';
    hr = pfnGetFolderPath(
            NULL,                   // hwndOwner
            CSIDL_APPDATA | CSIDL_FLAG_CREATE,
            hToken,
            0,                      // dwFlags
            wszFolderPath
            );
    if (S_OK != hr || L'\0' == wszFolderPath[0])
        goto GetFolderPathError;

#if DBG
        DbgPrintf(DBG_SS_CRYPT32, "SHFolderPath(CSIDL_APPDATA):: %S\n",
            wszFolderPath);
#endif

    dwErr = ERROR_SUCCESS;
CommonReturn:
    return dwErr;
ErrorReturn:
    dwErr = ERROR_FILE_NOT_FOUND;
    goto CommonReturn;

SET_ERROR_VAR(GetFolderPathError, hr)
}

LPWSTR
ILS_GetRoamingStoreDirectory(
    IN LPCWSTR pwszStoreName
    )
{
    DWORD dwErr;
    HANDLE hToken = NULL;
    LPWSTR pwszDir = NULL;
    WCHAR wszFolderPath[MAX_PATH];
    LPCWSTR rgpwszName[] = { wszFolderPath, pwszStoreName };
    SYSTEM_NAME_GROUP NameGroup;

    hToken = GetRoamingToken();

    dwErr = FastGetUserAppDataPath(hToken, wszFolderPath);
    if (ERROR_SUCCESS != dwErr)
        dwErr = SlowGetUserAppDataPath(hToken, wszFolderPath);
    if (ERROR_SUCCESS != dwErr)
        goto GetUserAppDataPathError;

    NameGroup.cName = sizeof(rgpwszName) / sizeof(rgpwszName[0]);
    NameGroup.rgpwszName = rgpwszName;
    if (NULL == (pwszDir = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;

CommonReturn:
    if (hToken)
        ILS_CloseHandle(hToken);
    return pwszDir;
ErrorReturn:
    pwszDir = NULL;
    goto CommonReturn;

SET_ERROR_VAR(GetUserAppDataPathError, dwErr)
TRACE_ERROR(FormatSystemNamePathError)
}

static DWORD rgdwCreateFileRetryMilliseconds[] =
    { 1, 10, 100, 500, 1000, 5000 };

#define MAX_CREATE_FILE_RETRY_COUNT     \
            (sizeof(rgdwCreateFileRetryMilliseconds) / \
                sizeof(rgdwCreateFileRetryMilliseconds[0]))

BOOL
ILS_ReadElementFromFile(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,           // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    )
{
    BOOL fResult;
    DWORD dwErr;
    LPWSTR pwszFilename = NULL;
    LPCWSTR rgpwszName[] = { pwszStoreDir, pwszContextName, wszHashName };
    SYSTEM_NAME_GROUP NameGroup;

    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbBytesRead;
    BYTE *pbElement = NULL;
    DWORD cbElement;
    DWORD dwRetryCount;

    NameGroup.cName = sizeof(rgpwszName) / sizeof(rgpwszName[0]);
    NameGroup.rgpwszName = rgpwszName;
    if (NULL == (pwszFilename = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;

    dwRetryCount = 0;
    while (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
              pwszFilename,
              GENERIC_READ,
              FILE_SHARE_READ,
              NULL,                   // lpsa
              OPEN_EXISTING,
              FILE_ATTRIBUTE_NORMAL |
                ((dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) ?
                    FILE_FLAG_BACKUP_SEMANTICS : 0),  
              NULL                    // hTemplateFile
              ))) {
        dwErr = GetLastError();
        if ((ERROR_SHARING_VIOLATION == dwErr ||
                ERROR_ACCESS_DENIED == dwErr) &&
                MAX_CREATE_FILE_RETRY_COUNT > dwRetryCount) {
            Sleep(rgdwCreateFileRetryMilliseconds[dwRetryCount]);
            dwRetryCount++;
        } else {
            if (ERROR_PATH_NOT_FOUND == dwErr)
                dwErr = ERROR_FILE_NOT_FOUND;
            goto CreateFileError;
        }
    }

    cbElement = GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == cbElement) goto FileSizeError;
    if (0 == cbElement) goto EmptyFile;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;
    if (!ReadFile(
            hFile,
            pbElement,
            cbElement,
            &cbBytesRead,
            NULL            // lpOverlapped
            )) {
        dwErr = GetLastError();
        goto FileError;
    }

    fResult = TRUE;
CommonReturn:
    PkiFree(pwszFilename);
    if (INVALID_HANDLE_VALUE != hFile)
        ILS_CloseHandle(hFile);
    *ppbElement = pbElement;
    *pcbElement = cbElement;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    PkiFree(pbElement);
    pbElement = NULL;
    cbElement = 0;
    goto CommonReturn;

TRACE_ERROR(FormatSystemNamePathError)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(CreateFileError, dwErr)
TRACE_ERROR(FileSizeError)
SET_ERROR_VAR(FileError, dwErr)
SET_ERROR(EmptyFile, CRYPT_E_FILE_ERROR)
}

BOOL
ILS_WriteElementToFile(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags,       // CERT_STORE_CREATE_NEW_FLAG or
                            // CERT_STORE_BACKUP_RESTORE_FLAG may be set
    IN const BYTE *pbElement,
    IN DWORD cbElement
    )
{
    BOOL fResult;
    DWORD dwErr;
    LPWSTR pwszDir = NULL;
    LPWSTR pwszFilename = NULL;
    LPCWSTR rgpwszName[] = { pwszStoreDir, pwszContextName, wszHashName };
    SYSTEM_NAME_GROUP NameGroup;

    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbBytesWritten;
    DWORD dwRetryCount;

    NameGroup.cName = sizeof(rgpwszName) / sizeof(rgpwszName[0]);
    NameGroup.rgpwszName = rgpwszName;
    if (NULL == (pwszFilename = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;
    NameGroup.cName--;
    if (NULL == (pwszDir = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;

    if (!I_RecursiveCreateDirectory(pwszDir, NULL))
        goto CreateDirError;

    dwRetryCount = 0;
    while (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
            pwszFilename,
            GENERIC_WRITE,
            0,                        // fdwShareMode
            NULL,                     // lpsa
            (dwFlags & CERT_STORE_CREATE_NEW_FLAG) ?
                CREATE_NEW : CREATE_ALWAYS,
            FILE_ATTRIBUTE_SYSTEM |
                ((dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) ?
                    FILE_FLAG_BACKUP_SEMANTICS : 0),  
            NULL                      // hTemplateFile
            ))) {
        dwErr = GetLastError();
        if ((ERROR_SHARING_VIOLATION == dwErr ||
                ERROR_ACCESS_DENIED == dwErr) &&
                MAX_CREATE_FILE_RETRY_COUNT > dwRetryCount) {
            Sleep(rgdwCreateFileRetryMilliseconds[dwRetryCount]);
            dwRetryCount++;
        } else
            goto CreateFileError;
    }

    if (!WriteFile(
            hFile,
            pbElement,
            cbElement,
            &cbBytesWritten,
            NULL            // lpOverlapped
            )) {
        dwErr = GetLastError();
        goto WriteFileError;
    }

    fResult = TRUE;
CommonReturn:
    if (INVALID_HANDLE_VALUE != hFile)
        ILS_CloseHandle(hFile);
    PkiFree(pwszFilename);
    PkiFree(pwszDir);

    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FormatSystemNamePathError)
TRACE_ERROR(CreateDirError)
SET_ERROR_VAR(CreateFileError, dwErr)
SET_ERROR_VAR(WriteFileError, dwErr)
}

BOOL
ILS_DeleteElementFromDirectory(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    DWORD dwErr;
    LPWSTR pwszFilename = NULL;
    LPCWSTR rgpwszName[] = { pwszStoreDir, pwszContextName, wszHashName };
    SYSTEM_NAME_GROUP NameGroup;
    DWORD dwRetryCount;

    NameGroup.cName = sizeof(rgpwszName) / sizeof(rgpwszName[0]);
    NameGroup.rgpwszName = rgpwszName;
    if (NULL == (pwszFilename = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;

    dwRetryCount = 0;
    while (!DeleteFileU(pwszFilename)) {
        dwErr = GetLastError();
        if ((ERROR_SHARING_VIOLATION == dwErr ||
                ERROR_ACCESS_DENIED == dwErr) &&
                MAX_CREATE_FILE_RETRY_COUNT > dwRetryCount) {
            Sleep(rgdwCreateFileRetryMilliseconds[dwRetryCount]);
            dwRetryCount++;
        } else
            goto DeleteFileError;
    }

    fResult = TRUE;

CommonReturn:
    PkiFree(pwszFilename);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FormatSystemNamePathError)
SET_ERROR_VAR(DeleteFileError, dwErr)
}


BOOL
ILS_OpenAllElementsFromDirectory(
    IN LPCWSTR pwszStoreDir,
    IN LPCWSTR pwszContextName,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_ILS_OPEN_ELEMENT pfnOpenElement
    )
{
    BOOL fResult;
    DWORD dwErr;
    LPWSTR pwszDir = NULL;
    LPCWSTR rgpwszName[] = { pwszStoreDir, pwszContextName, L"*" };
    SYSTEM_NAME_GROUP NameGroup;

    HANDLE hFindFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW FindFileData;

    NameGroup.cName = sizeof(rgpwszName) / sizeof(rgpwszName[0]);
    NameGroup.rgpwszName = rgpwszName;
    if (NULL == (pwszDir = FormatSystemNamePath(1, &NameGroup)))
        goto FormatSystemNamePathError;

    if (INVALID_HANDLE_VALUE == (hFindFile = FindFirstFileU(
            pwszDir,
            &FindFileData
            ))) {
        dwErr = GetLastError();
        if (!(ERROR_PATH_NOT_FOUND == dwErr || ERROR_FILE_NOT_FOUND == dwErr))
            goto FindFirstFileError;

        if (dwFlags & CERT_STORE_READONLY_FLAG)
            goto FindFirstFileError;

        // Attempt to create the directory. Need to remove trailing L"*".
        PkiFree(pwszDir);
        NameGroup.cName--;
        if (NULL == (pwszDir = FormatSystemNamePath(1, &NameGroup)))
            goto FormatSystemNamePathError;
        if (!I_RecursiveCreateDirectory(pwszDir, NULL))
            goto CreateDirError;

        goto SuccessReturn;
    }

    while (TRUE) {
        if (0 == (FILE_ATTRIBUTE_DIRECTORY & FindFileData.dwFileAttributes) &&
                0 == FindFileData.nFileSizeHigh &&
                0 != FindFileData.nFileSizeLow &&
                L'\0' != FindFileData.cFileName[0]) {
            BYTE *pbElement;
            DWORD cbElement;

            if (ILS_ReadElementFromFile(
                    pwszStoreDir,
                    pwszContextName,
                    FindFileData.cFileName,
                    dwFlags,
                    &pbElement,
                    &cbElement
                    )) {
                fResult = pfnOpenElement(
                    FindFileData.cFileName,
                    pbElement,
                    cbElement,
                    pvArg
                    );

                PkiFree(pbElement);
                if (!fResult)
                    goto CommonReturn;
            }
        }


        if (!FindNextFileU(hFindFile, &FindFileData)) {
            dwErr = GetLastError();
            if (ERROR_NO_MORE_FILES == dwErr)
                goto SuccessReturn;
            else
                goto FindNextFileError;
        }
    }

SuccessReturn:
    fResult = TRUE;

CommonReturn:
    PkiFree(pwszDir);
    if (INVALID_HANDLE_VALUE != hFindFile) {
        dwErr = GetLastError();
        FindClose(hFindFile);
        SetLastError(dwErr);
    }
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FormatSystemNamePathError)
SET_ERROR_VAR(FindFirstFileError, dwErr)
TRACE_ERROR(CreateDirError)
SET_ERROR_VAR(FindNextFileError, dwErr)
}

//+=========================================================================
// Registry or Roaming Store Change Notify Functions
//==========================================================================

STATIC VOID NTAPI RegistryStoreChangeCallback(
    PVOID Context,
    BOOLEAN fWaitOrTimedOut        // ???
    )
{
    BOOL fRearm;
    DWORD dwErr = 0;
    PREG_STORE pRegStore = (PREG_STORE) Context;
    PREGISTRY_STORE_CHANGE_INFO pInfo;

    DWORD cEntry;
    PILS_RESYNC_ENTRY pEntry;

    pInfo = pRegStore->pRegistryStoreChangeInfo;
    assert(pInfo);
    if (NULL == pInfo)
        return;

    CertPerfIncrementChangeNotifyCount();

    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG) {
        fRearm = FindNextChangeNotification(pInfo->hChange);

        CertPerfIncrementChangeNotifyCuMyCount();

    } else {
        fRearm = ILS_RegNotifyChangeKeyValue(pRegStore->hKey, pInfo->hChange);

        CertPerfIncrementChangeNotifyRegCount();

    }
    if (!fRearm)
        dwErr = GetLastError();

    // Minimize window of potential deadlock by only getting the values
    // while holding the lock.
    LockRegStore(pRegStore);
    cEntry = pInfo->cNotifyEntry;
    pEntry = pInfo->rgNotifyEntry;

    pInfo->cNotifyEntry = 0;
    pInfo->rgNotifyEntry = NULL;
    UnlockRegStore(pRegStore);

    ILS_SignalEventsOnResyncList(&cEntry, &pEntry);


    if (!fRearm)
        goto RegistryStoreChangeRearmError;
CommonReturn:
    return;
ErrorReturn:
    goto CommonReturn;
SET_ERROR_VAR(RegistryStoreChangeRearmError, dwErr)
}

// Upon entry/exit the pRegStore is locked
STATIC BOOL InitRegistryStoreChange(
    IN PREG_STORE pRegStore
    )
{
    BOOL fResult;
    DWORD dwErr;
    BOOL fRoaming;
    PREGISTRY_STORE_CHANGE_INFO pInfo = NULL;
    HANDLE hChange = INVALID_HANDLE_VALUE;
    HANDLE hRegWaitFor;

    fRoaming = (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG);

    assert(NULL == pRegStore->pRegistryStoreChangeInfo);
    if (NULL == (pInfo = (PREGISTRY_STORE_CHANGE_INFO) PkiZeroAlloc(
            sizeof(REGISTRY_STORE_CHANGE_INFO))))
        goto OutOfMemory;
    pInfo->dwType = REG_CHANGE_INFO_TYPE;

    if (fRoaming) {
        if (INVALID_HANDLE_VALUE == (hChange = FindFirstChangeNotificationU(
                pRegStore->pwszStoreDirectory,
                TRUE,                           // bWatchSubtree
                FILE_NOTIFY_CHANGE_FILE_NAME |
                    FILE_NOTIFY_CHANGE_DIR_NAME |
                    FILE_NOTIFY_CHANGE_SIZE |
                    FILE_NOTIFY_CHANGE_LAST_WRITE
                ))) {
            dwErr = GetLastError();
            goto FindFirstChangeNotificationError;
        }
    } else {
        if (NULL == (hChange = CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL)))     // lpszEventName
            goto CreateEventError;
        assert(pRegStore->hKey);
        if (!ILS_RegNotifyChangeKeyValue(pRegStore->hKey, hChange))
            goto RegNotifyChangeKeyValueError;
    }
    pInfo->hChange = hChange;

    // The following must be set before the following register.
    // The thread may be scheduled to run before the function returns.
    pRegStore->pRegistryStoreChangeInfo = pInfo;

    if (!pfnILS_RegisterWaitForSingleObject(
            &hRegWaitFor,
            hChange,
            RegistryStoreChangeCallback,
            (PVOID) pRegStore,
            INFINITE,                                      // no timeout
            WT_EXECUTEINWAITTHREAD
            )) {
        pRegStore->pRegistryStoreChangeInfo = NULL;
        dwErr = GetLastError();
        goto RegisterWaitForError;
    }

    pInfo->hRegWaitFor = hRegWaitFor;
    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    if (INVALID_HANDLE_VALUE != hChange && hChange) {
        dwErr = GetLastError();

        if (fRoaming)
            FindCloseChangeNotification(hChange);
        else
            CloseHandle(hChange);

        SetLastError(dwErr);
    }
    PkiFree(pInfo);
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(FindFirstChangeNotificationError, dwErr)
TRACE_ERROR(CreateEventError)
TRACE_ERROR(RegNotifyChangeKeyValueError)
SET_ERROR_VAR(RegisterWaitForError, dwErr)
}

STATIC BOOL RegRegistryStoreChange(
    IN PREG_STORE pRegStore,
    IN HANDLE hEvent,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    PREGISTRY_STORE_CHANGE_INFO pInfo;

    LockRegStore(pRegStore);

    if (NULL == (pInfo = pRegStore->pRegistryStoreChangeInfo)) {
        if (!InitRegistryStoreChange(pRegStore))
            goto ChangeInitError;
        pInfo = pRegStore->pRegistryStoreChangeInfo;
        assert(pInfo);
        assert(REG_CHANGE_INFO_TYPE == pInfo->dwType);
    }

    if (!ILS_AddRemoveEventToFromResyncList(
            pRegStore,
            hEvent,
            dwFlags,
            &pInfo->cNotifyEntry,
            &pInfo->rgNotifyEntry
            ))
        goto AddRemoveEventError;

    fResult = TRUE;

CommonReturn:
    UnlockRegStore(pRegStore);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ChangeInitError)
TRACE_ERROR(AddRemoveEventError)
}


STATIC void FreeRegistryStoreChange(
    IN PREG_STORE pRegStore
    )
{
    PREGISTRY_STORE_CHANGE_INFO pInfo;
    if (NULL == (pInfo = pRegStore->pRegistryStoreChangeInfo))
        return;
    if (REG_CHANGE_INFO_TYPE != pInfo->dwType)
        return;

    assert(pInfo->hRegWaitFor);
    pfnILS_UnregisterWaitEx(pInfo->hRegWaitFor, INVALID_HANDLE_VALUE);

    assert(pInfo->hChange);
    if (pRegStore->dwFlags & CERT_REGISTRY_STORE_ROAMING_FLAG)
        FindCloseChangeNotification(pInfo->hChange);
    else
        CloseHandle(pInfo->hChange);

    ILS_SignalEventsOnResyncList(
        &pInfo->cNotifyEntry,
        &pInfo->rgNotifyEntry
        );

    PkiFree(pInfo);
    pRegStore->pRegistryStoreChangeInfo = NULL;
}


//+=========================================================================
// Key Identifier Functions
//==========================================================================

STATIC HKEY OpenKeyIdStoreSubKey(
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName
    )
{
    SYSTEM_NAME_INFO SystemNameInfo;
    memset(&SystemNameInfo, 0, sizeof(SystemNameInfo));
    SystemNameInfo.rgpwszName[SYSTEM_NAME_INDEX] = wsz_MY_STORE;
    SystemNameInfo.rgpwszName[COMPUTER_NAME_INDEX] = (LPWSTR) pwszComputerName;

    return OpenSystemRegPathKey(
        &SystemNameInfo,
        NULL,               // pwszSubKeyName
        dwFlags
        );
}

BOOL
ILS_ReadKeyIdElement(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName,
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    )
{
    BOOL fResult;
    BYTE *pbElement = NULL;
    DWORD cbElement = 0;
    WCHAR wszHashName[MAX_HASH_NAME_LEN];

    if (0 == pKeyIdentifier->cbData || MAX_HASH_LEN < pKeyIdentifier->cbData)
        goto InvalidArg;
    ILS_BytesToWStr(pKeyIdentifier->cbData, pKeyIdentifier->pbData, wszHashName);

    if (!fLocalMachine) {
        LPWSTR pwszRoamingStoreDir;
        if (pwszRoamingStoreDir = ILS_GetRoamingStoreDirectory(
                ROAMING_MY_STORE_SUBDIR)) {
            // Ignore BACKUP_RESTORE
            fResult = ILS_ReadElementFromFile(
                pwszRoamingStoreDir,
                KEYID_CONTEXT_NAME,
                wszHashName,
                0,                          // dwFlags
                &pbElement,
                &cbElement
                );
            PkiFree(pwszRoamingStoreDir);
            if (!fResult) {
                if (ERROR_FILE_NOT_FOUND != GetLastError())
                    goto ReadElementFromFileError;
            } else
                goto CommonReturn;
        }
    }

    {
        HKEY hKey;
        DWORD dwOpenFlags;

        if (fLocalMachine)
            dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        else
            dwOpenFlags = CERT_SYSTEM_STORE_CURRENT_USER;
        if (NULL == (hKey = OpenKeyIdStoreSubKey(
                dwOpenFlags | CERT_STORE_READONLY_FLAG,
                pwszComputerName
                )))
            goto OpenKeyIdStoreSubKeyError;

        // Ignore BACKUP_RESTORE
        fResult = ILS_ReadElementFromRegistry(
            hKey,
            KEYID_CONTEXT_NAME,
            wszHashName,
            0,                          // dwFlags
            &pbElement,
            &cbElement
            );

        ILS_CloseRegistryKey(hKey);
        if (!fResult)
            goto ReadElementFromRegistryError;
    }

    fResult = TRUE;

CommonReturn:
    *ppbElement = pbElement;
    *pcbElement = cbElement;
    return fResult;

ErrorReturn:
    assert(NULL == pbElement && 0 == cbElement);
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(ReadElementFromFileError)
TRACE_ERROR(OpenKeyIdStoreSubKeyError)
TRACE_ERROR(ReadElementFromRegistryError)
}

BOOL
ILS_WriteKeyIdElement(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN const BYTE *pbElement,
    IN DWORD cbElement
    )
{
    BOOL fResult;
    WCHAR wszHashName[MAX_HASH_NAME_LEN];

    if (0 == pKeyIdentifier->cbData || MAX_HASH_LEN < pKeyIdentifier->cbData)
        goto InvalidArg;
    ILS_BytesToWStr(pKeyIdentifier->cbData, pKeyIdentifier->pbData, wszHashName);

    if (!fLocalMachine) {
        LPWSTR pwszRoamingStoreDir;
        if (pwszRoamingStoreDir = ILS_GetRoamingStoreDirectory(
                ROAMING_MY_STORE_SUBDIR)) {
            // Ignore BACKUP_RESTORE
            fResult = ILS_WriteElementToFile(
                pwszRoamingStoreDir,
                KEYID_CONTEXT_NAME,
                wszHashName,
                0,                          // dwFlags
                pbElement,
                cbElement
                );
            PkiFree(pwszRoamingStoreDir);
            if (!fResult)
                goto WriteElementToFileError;
            else
                goto CommonReturn;
        }
    }

    {
        HKEY hKey;
        DWORD dwOpenFlags;

        if (fLocalMachine)
            dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        else
            dwOpenFlags = CERT_SYSTEM_STORE_CURRENT_USER;
        if (NULL == (hKey = OpenKeyIdStoreSubKey(
                dwOpenFlags,
                pwszComputerName
                )))
            goto OpenKeyIdStoreSubKeyError;

        // Ignore BACKUP_RESTORE
        fResult = ILS_WriteElementToRegistry(
            hKey,
            KEYID_CONTEXT_NAME,
            wszHashName,
            0,                          // dwFlags
            pbElement,
            cbElement
            );

        ILS_CloseRegistryKey(hKey);
        if (!fResult)
            goto WriteElementToRegistryError;
    }

    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(WriteElementToFileError)
TRACE_ERROR(OpenKeyIdStoreSubKeyError)
TRACE_ERROR(WriteElementToRegistryError)
}


BOOL
ILS_DeleteKeyIdElement(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName
    )
{
    BOOL fResult;
    WCHAR wszHashName[MAX_HASH_NAME_LEN];

    if (0 == pKeyIdentifier->cbData || MAX_HASH_LEN < pKeyIdentifier->cbData)
        goto InvalidArg;
    ILS_BytesToWStr(pKeyIdentifier->cbData, pKeyIdentifier->pbData, wszHashName);

    if (!fLocalMachine) {
        LPWSTR pwszRoamingStoreDir;
        if (pwszRoamingStoreDir = ILS_GetRoamingStoreDirectory(
                ROAMING_MY_STORE_SUBDIR)) {
            // Ignore BACKUP_RESTORE
            fResult = ILS_DeleteElementFromDirectory(
                pwszRoamingStoreDir,
                KEYID_CONTEXT_NAME,
                wszHashName,
                0                           // dwFlags
                );
            PkiFree(pwszRoamingStoreDir);
            if (!fResult)
                goto DeleteElementFromDirectoryError;
            else
                goto CommonReturn;
        }
    }

    {
        HKEY hKey;
        DWORD dwOpenFlags;

        if (fLocalMachine)
            dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        else
            dwOpenFlags = CERT_SYSTEM_STORE_CURRENT_USER;
        if (NULL == (hKey = OpenKeyIdStoreSubKey(
                dwOpenFlags,
                pwszComputerName
                )))
            goto OpenKeyIdStoreSubKeyError;

        // Ignore BACKUP_RESTORE
        fResult = ILS_DeleteElementFromRegistry(
            hKey,
            KEYID_CONTEXT_NAME,
            wszHashName,
            0                           // dwFlags
            );

        ILS_CloseRegistryKey(hKey);
        if (!fResult)
            goto DeleteElementFromRegistryError;
    }

    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(DeleteElementFromDirectoryError)
TRACE_ERROR(OpenKeyIdStoreSubKeyError)
TRACE_ERROR(DeleteElementFromRegistryError)
}

typedef struct _OPEN_KEYID_CALLBACK_ARG {
    void                        *pvArg;
    PFN_ILS_OPEN_KEYID_ELEMENT  pfnOpenKeyId;
} OPEN_KEYID_CALLBACK_ARG, *POPEN_KEYID_CALLBACK_ARG;

STATIC BOOL OpenKeyIdElementCallback(
    IN const WCHAR wszHashName[MAX_HASH_NAME_LEN],
    IN const BYTE *pbElement,
    IN DWORD cbElement,
    IN void *pvArg
    )
{
    POPEN_KEYID_CALLBACK_ARG pKeyIdArg = (POPEN_KEYID_CALLBACK_ARG) pvArg;

    DWORD cbHash;
    BYTE rgbHash[MAX_HASH_LEN];
    CRYPT_HASH_BLOB KeyIdentifier;

    WStrToBytes(wszHashName, rgbHash, &cbHash);
    KeyIdentifier.cbData = cbHash;
    KeyIdentifier.pbData = rgbHash;

    return pKeyIdArg->pfnOpenKeyId(
        &KeyIdentifier,
        pbElement,
        cbElement,
        pKeyIdArg->pvArg
        );
}

BOOL
ILS_OpenAllKeyIdElements(
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN void *pvArg,
    IN PFN_ILS_OPEN_KEYID_ELEMENT pfnOpenKeyId
    )
{
    BOOL fResult;
    BOOL fOpenFile = FALSE;

    OPEN_KEYID_CALLBACK_ARG KeyIdArg = { pvArg, pfnOpenKeyId };

    if (!fLocalMachine) {
        LPWSTR pwszRoamingStoreDir;
        if (pwszRoamingStoreDir = ILS_GetRoamingStoreDirectory(
                ROAMING_MY_STORE_SUBDIR)) {
            // Ignore BACKUP_RESTORE
            fResult = ILS_OpenAllElementsFromDirectory(
                pwszRoamingStoreDir,
                KEYID_CONTEXT_NAME,
                0,                          // dwFlags
                (void *) &KeyIdArg,
                OpenKeyIdElementCallback
                );
            PkiFree(pwszRoamingStoreDir);
            if (!fResult)
                goto ErrorReturn;
            else
                fOpenFile = TRUE;
        }
    }

    {
        HKEY hKey;
        DWORD dwOpenFlags;

        if (fLocalMachine)
            dwOpenFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
        else
            dwOpenFlags = CERT_SYSTEM_STORE_CURRENT_USER;
        if (NULL == (hKey = OpenKeyIdStoreSubKey(
                dwOpenFlags | CERT_STORE_READONLY_FLAG,
                pwszComputerName
                )))
            goto OpenKeyIdStoreSubKeyError;

        // Ignore BACKUP_RESTORE
        fResult = ILS_OpenAllElementsFromRegistry(
            hKey,
            KEYID_CONTEXT_NAME,
            0,                          // dwFlags
            (void *) &KeyIdArg,
            OpenKeyIdElementCallback
            );

        ILS_CloseRegistryKey(hKey);
    }

CommonReturn:
    if (fOpenFile)
        // Ignore any registry errors
        return TRUE;
    else
        return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenKeyIdStoreSubKeyError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\memory.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       memory.cpp
//
//  Contents:   Crypt32 Memory Management Routines
//
//  History:    22-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Function:   CryptMemAlloc
//
//  Synopsis:   Allocates memory
//
//----------------------------------------------------------------------------
LPVOID WINAPI CryptMemAlloc (
                   IN ULONG cbSize
                   )
{
    return( malloc( cbSize ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptMemRealloc
//
//  Synopsis:   reallocates memory
//
//----------------------------------------------------------------------------
LPVOID WINAPI CryptMemRealloc (
                   IN LPVOID pv,
                   IN ULONG cbSize
                   )
{
    return( realloc( pv, cbSize ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptMemFree
//
//  Synopsis:   free memory
//
//----------------------------------------------------------------------------
VOID WINAPI CryptMemFree (
                 IN LPVOID pv
                 )
{
    free( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\logstor.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       logstor.h
//
//  Contents:   Public functions in logstor.cpp
//
//  History:    15-Sep-00   philh   created
//--------------------------------------------------------------------------

#ifndef __LOGSTOR_H__
#define __LOGSTOR_H__

//+-------------------------------------------------------------------------
//  Register wait for callback functions
//--------------------------------------------------------------------------
typedef VOID (NTAPI * ILS_WAITORTIMERCALLBACK) (PVOID, BOOLEAN );

BOOL
WINAPI
ILS_RegisterWaitForSingleObject(
    PHANDLE hNewWaitObject,
    HANDLE hObject,
    ILS_WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    );

BOOL
WINAPI
ILS_UnregisterWait(
    HANDLE WaitHandle
    );

BOOL
WINAPI
ILS_ExitWait(
    HANDLE WaitHandle,
    HMODULE hLibModule
    );

//+-------------------------------------------------------------------------
//  Registry support functions
//--------------------------------------------------------------------------

void
ILS_EnableBackupRestorePrivileges();

void
ILS_CloseRegistryKey(
    IN HKEY hKey
    );

BOOL
ILS_ReadDWORDValueFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszValueName,
    IN DWORD *pdwValue
    );

BOOL
ILS_ReadBINARYValueFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszValueName,
    OUT BYTE **ppbValue,
    OUT DWORD *pcbValue
    );

//+-------------------------------------------------------------------------
//  Get and allocate the REG_SZ value
//--------------------------------------------------------------------------
LPWSTR ILS_ReadSZValueFromRegistry(
    IN HKEY hKey,
    IN LPCWSTR pwszValueName
    );
LPSTR ILS_ReadSZValueFromRegistry(
    IN HKEY hKey,
    IN LPCSTR pszValueName
    );

//+-------------------------------------------------------------------------
//  Key Identifier registry and roaming file support functions
//--------------------------------------------------------------------------
BOOL
ILS_ReadKeyIdElement(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName,
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    );
BOOL
ILS_WriteKeyIdElement(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN const BYTE *pbElement,
    IN DWORD cbElement
    );
BOOL
ILS_DeleteKeyIdElement(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName
    );

typedef BOOL (*PFN_ILS_OPEN_KEYID_ELEMENT)(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN const BYTE *pbElement,
    IN DWORD cbElement,
    IN void *pvArg
    );

BOOL
ILS_OpenAllKeyIdElements(
    IN BOOL fLocalMachine,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN void *pvArg,
    IN PFN_ILS_OPEN_KEYID_ELEMENT pfnOpenKeyId
    );

//+-------------------------------------------------------------------------
//  Misc alloc and copy functions
//--------------------------------------------------------------------------
LPWSTR ILS_AllocAndCopyString(
    IN LPCWSTR pwszSrc,
    IN LONG cchSrc = -1
    );

//+-------------------------------------------------------------------------
//  Converts the bytes into UNICODE ASCII HEX
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
void ILS_BytesToWStr(DWORD cb, void* pv, LPWSTR wsz);

#endif  // __LOGSTOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\oidconv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       oidconv.cpp
//
//  Contents:   Object ID (OID) Conv Functions
//
//  Functions:  I_CryptOIDConvDllMain
//              I_CryptSetEncodedOID
//              I_CryptGetEncodedOID
//
//  Comments:
//
//  History:    08_Feb-98    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

typedef struct _OID_HASH_BUCKET_ENTRY
    OID_HASH_BUCKET_ENTRY, *POID_HASH_BUCKET_ENTRY;

// pbEncodedOID immediately follows the data structure. pszDotOID
// is at pbEncodedOID + cbEncodedOID. pszDotOID is null terminated.
// cchDotOID doesn't include the null terminator.
struct _OID_HASH_BUCKET_ENTRY {
    DWORD                   cbEncodedOID;
    DWORD                   cchDotOID;
    POID_HASH_BUCKET_ENTRY  pEncodedNext;
    POID_HASH_BUCKET_ENTRY  pDotNext;
};

static inline BYTE * GetEncodedOIDPointer(
    IN POID_HASH_BUCKET_ENTRY pEntry
    )
{
    return ((BYTE *) pEntry) + sizeof(OID_HASH_BUCKET_ENTRY);
}
static inline LPSTR GetDotOIDPointer(
    IN POID_HASH_BUCKET_ENTRY pEntry
    )
{
    return (LPSTR) (((BYTE *) pEntry) + sizeof(OID_HASH_BUCKET_ENTRY) +
        pEntry->cbEncodedOID);
}

// Some prime numbers: 11, 13, 19, 23, 29, 31, 47, 53, 61, 73, 97,
//                     101, 127, 251, 509

#define ENCODED_OID_HASH_BUCKET_COUNT   47
#define DOT_OID_HASH_BUCKET_COUNT       31

static POID_HASH_BUCKET_ENTRY
            rgpEncodedOIDHashBucket[ENCODED_OID_HASH_BUCKET_COUNT];
static POID_HASH_BUCKET_ENTRY rgpDotOIDHashBucket[DOT_OID_HASH_BUCKET_COUNT];

static CRITICAL_SECTION OIDHashBucketCriticalSection;

static BOOL OIDHashBucketProcessAttach()
{
    return Pki_InitializeCriticalSection(&OIDHashBucketCriticalSection);
}

static void OIDHashBucketProcessDetach()
{
    DWORD i;
    for (i = 0; i < DOT_OID_HASH_BUCKET_COUNT; i++) {
        POID_HASH_BUCKET_ENTRY pEntry = rgpDotOIDHashBucket[i];
        while (pEntry) {
            POID_HASH_BUCKET_ENTRY pFreeEntry = pEntry;
            pEntry = pEntry->pDotNext;
            PkiFree(pFreeEntry);
        }
    }

    DeleteCriticalSection(&OIDHashBucketCriticalSection);
}

BOOL
WINAPI
I_CryptOIDConvDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL fRet = TRUE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        fRet = OIDHashBucketProcessAttach();
        break;

    case DLL_PROCESS_DETACH:
        OIDHashBucketProcessDetach();
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return fRet;
}

extern HCRYPTASN1MODULE hX509Asn1Module;  // From wincert.cpp
static inline ASN1encoding_t GetEncoder(void)
{
    return I_CryptGetAsn1Encoder(hX509Asn1Module);
}
static inline ASN1decoding_t GetDecoder(void)
{
    return I_CryptGetAsn1Decoder(hX509Asn1Module);
}

static DWORD GetOIDHashBucketIndex(
    IN DWORD cHashBucket,
    IN const BYTE *pb,
    IN DWORD cb
    )
{
    DWORD dwIndex;

    dwIndex = 0;
    while (cb--) {
        if (dwIndex & 0x80000000)
            dwIndex = (dwIndex << 1) | 1;
        else
            dwIndex = dwIndex << 1;
        dwIndex += *pb++;
    }
    return dwIndex % cHashBucket;
}

static POID_HASH_BUCKET_ENTRY FindOIDHashBucketEntryFromEncodedOID(
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    POID_HASH_BUCKET_ENTRY pEntry;
    BYTE *pbEncodedOID = pEncodedOid->value;
    DWORD cbEncodedOID = pEncodedOid->length;
    DWORD dwIndex;

    dwIndex = GetOIDHashBucketIndex(
        ENCODED_OID_HASH_BUCKET_COUNT,
        pbEncodedOID,
        cbEncodedOID
        );

    for (pEntry = rgpEncodedOIDHashBucket[dwIndex]; pEntry;
                                            pEntry = pEntry->pEncodedNext) {
        if (cbEncodedOID == pEntry->cbEncodedOID &&
                0 == memcmp(pbEncodedOID, GetEncodedOIDPointer(pEntry),
                        cbEncodedOID))
            return pEntry;
    }

    return NULL;
}

static POID_HASH_BUCKET_ENTRY FindOIDHashBucketEntryFromDotOID(
    IN LPSTR pszDotOID
    )
{
    POID_HASH_BUCKET_ENTRY pEntry;
    DWORD cchDotOID = strlen(pszDotOID);
    DWORD dwIndex;

    dwIndex = GetOIDHashBucketIndex(
        DOT_OID_HASH_BUCKET_COUNT,
        (const BYTE *) pszDotOID,
        cchDotOID
        );

    for (pEntry = rgpDotOIDHashBucket[dwIndex]; pEntry;
                                            pEntry = pEntry->pDotNext) {
        if (cchDotOID == pEntry->cchDotOID &&
                0 == memcmp(pszDotOID, GetDotOIDPointer(pEntry), cchDotOID))
            return pEntry;
    }

    return NULL;
}


// If after entering the critical section, the entry already exists, then,
// return it and free the input entry. Otherwise, add the input entry and
// return it.
static POID_HASH_BUCKET_ENTRY AddOIDHashBucketEntry(
    IN POID_HASH_BUCKET_ENTRY pEntry
    )
{
    POID_HASH_BUCKET_ENTRY pFindEntry;
    ASN1encodedOID_t EncodedOid;

    EnterCriticalSection(&OIDHashBucketCriticalSection);

    EncodedOid.value = GetEncodedOIDPointer(pEntry);
    EncodedOid.length = (ASN1uint16_t) pEntry->cbEncodedOID;
    if (pFindEntry = FindOIDHashBucketEntryFromEncodedOID(&EncodedOid)) {
        PkiFree(pEntry);
        pEntry = pFindEntry;
    } else {
        DWORD dwIndex;

        dwIndex = GetOIDHashBucketIndex(
            ENCODED_OID_HASH_BUCKET_COUNT,
            GetEncodedOIDPointer(pEntry),
            pEntry->cbEncodedOID
            );
        pEntry->pEncodedNext = rgpEncodedOIDHashBucket[dwIndex];
        // Since we do finds outside of CriticalSection, must update
        // the following last!!!
        rgpEncodedOIDHashBucket[dwIndex] = pEntry;

        dwIndex = GetOIDHashBucketIndex(
            DOT_OID_HASH_BUCKET_COUNT,
            (const BYTE *) GetDotOIDPointer(pEntry),
            pEntry->cchDotOID
            );
        pEntry->pDotNext = rgpDotOIDHashBucket[dwIndex];
        // Since we do finds outside of CriticalSection, must update
        // the following last!!!
        rgpDotOIDHashBucket[dwIndex] = pEntry;
    }

    LeaveCriticalSection(&OIDHashBucketCriticalSection);

    return pEntry;
}


static POID_HASH_BUCKET_ENTRY CreateOIDHashBucketEntry(
    IN const BYTE *pbEncodedOID,
    IN DWORD cbEncodedOID,
    IN LPSTR pszDotOID,
    IN DWORD cchDotOID
    )
{
    POID_HASH_BUCKET_ENTRY pEntry;
    DWORD cbEntry;

    cbEntry = sizeof(OID_HASH_BUCKET_ENTRY) + cbEncodedOID + cchDotOID + 1;
    if (NULL == (pEntry = (POID_HASH_BUCKET_ENTRY) PkiZeroAlloc(cbEntry)))
        return NULL;

    pEntry->cbEncodedOID = cbEncodedOID;
    pEntry->cchDotOID = cchDotOID;
    memcpy(GetEncodedOIDPointer(pEntry), pbEncodedOID, cbEncodedOID);
    memcpy(GetDotOIDPointer(pEntry), pszDotOID, cchDotOID + 1);

    return pEntry;
}

static POID_HASH_BUCKET_ENTRY CreateOIDHashBucketEntryFromEncodedOID(
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    POID_HASH_BUCKET_ENTRY pEntry;
    ASN1decoding_t pDec = GetDecoder();
    const BYTE *pbEncodedOID;       // not allocated
    DWORD cbEncodedOID;
    LPSTR pszDotOID = NULL; 
    DWORD cchDotOID;

    if (NULL == (pszDotOID = PkiAsn1EncodedOidToDotVal(pDec, pEncodedOid)))
        goto EncodedOidToDotValError;
    cchDotOID = (DWORD) strlen(pszDotOID);

    pbEncodedOID = pEncodedOid->value;
    cbEncodedOID = pEncodedOid->length;
    pEntry = CreateOIDHashBucketEntry(
        pbEncodedOID,
        cbEncodedOID,
        pszDotOID,
        cchDotOID
        );

CommonReturn:
    PkiAsn1FreeDotVal(pDec, pszDotOID);
    return pEntry;

ErrorReturn:
    pEntry = NULL;
    goto CommonReturn;

TRACE_ERROR(EncodedOidToDotValError)
}

static POID_HASH_BUCKET_ENTRY CreateOIDHashBucketEntryFromDotOID(
    IN LPSTR pszDotOID
    )
{
    POID_HASH_BUCKET_ENTRY pEntry;
    ASN1encoding_t pEnc = GetEncoder();
    ASN1encodedOID_t EncodedOid;
    memset(&EncodedOid, 0, sizeof(EncodedOid));

    const BYTE *pbEncodedOID;
    DWORD cbEncodedOID;

    if (NULL == pszDotOID || '\0' == *pszDotOID)
        goto EmptyDotOIDError;
    if (!PkiAsn1DotValToEncodedOid(pEnc, pszDotOID, &EncodedOid))
        goto DotValToEncodedOidError;
    pbEncodedOID = EncodedOid.value;
    cbEncodedOID = EncodedOid.length;

    pEntry = CreateOIDHashBucketEntry(
        pbEncodedOID,
        cbEncodedOID,
        pszDotOID,
        strlen(pszDotOID)
        );

CommonReturn:
    PkiAsn1FreeEncodedOid(pEnc, &EncodedOid);
    return pEntry;
ErrorReturn:
    pEntry = NULL;
    goto CommonReturn;

SET_ERROR(EmptyDotOIDError, E_INVALIDARG)
SET_ERROR_VAR(DotValToEncodedOidError, PkiAsn1ErrToHr(ASN1_ERR_BADARGS))
}



//+-------------------------------------------------------------------------
//  Set/Get Encoded OID
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptSetEncodedOID(
        IN LPSTR pszObjId,
        OUT ASN1encodedOID_t *pEncodedOid
        )
{
    BOOL fResult;
    POID_HASH_BUCKET_ENTRY pEntry;

    if (NULL == (pEntry = FindOIDHashBucketEntryFromDotOID(pszObjId))) {
        if (NULL == (pEntry = CreateOIDHashBucketEntryFromDotOID(pszObjId)))
            goto CreateOIDHashBucketEntryError;
        pEntry = AddOIDHashBucketEntry(pEntry);
    }

    pEncodedOid->length = (ASN1uint16_t) pEntry->cbEncodedOID;
    pEncodedOid->value = GetEncodedOIDPointer(pEntry);
    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    pEncodedOid->length = 0;
    pEncodedOid->value = NULL;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(CreateOIDHashBucketEntryError)    
}


static const LPCSTR pszInvalidOID = "";

void
WINAPI
I_CryptGetEncodedOID(
        IN ASN1encodedOID_t *pEncodedOid,
        IN DWORD dwFlags,
        OUT LPSTR *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    POID_HASH_BUCKET_ENTRY pEntry;
    LONG lRemainExtra = *plRemainExtra;
    LPSTR pszDotOID;
    DWORD cchDotOID;

    if ((dwFlags & CRYPT_DECODE_SHARE_OID_STRING_FLAG) &&
            lRemainExtra < 0)
        // Length only calculation. Don't need any extra bytes.
        return;

    if (NULL == (pEntry = FindOIDHashBucketEntryFromEncodedOID(pEncodedOid))) {
        if (pEntry = CreateOIDHashBucketEntryFromEncodedOID(pEncodedOid))
            pEntry = AddOIDHashBucketEntry(pEntry);
    }

    if (pEntry) {
        pszDotOID = GetDotOIDPointer(pEntry);
        cchDotOID = pEntry->cchDotOID + 1;
    } else {
        pszDotOID = (LPSTR) pszInvalidOID;
        cchDotOID = strlen(pszInvalidOID) + 1;
    }

    if (dwFlags & CRYPT_DECODE_SHARE_OID_STRING_FLAG) {
        assert(lRemainExtra >= 0);
        *ppszObjId = pszDotOID;
    } else {
        LONG lAlignExtra = INFO_LEN_ALIGN(cchDotOID);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            memcpy(*ppbExtra, pszDotOID, cchDotOID);
            *ppszObjId = (LPSTR) *ppbExtra;
            *ppbExtra += lAlignExtra;
        }

        *plRemainExtra = lRemainExtra;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\newstor.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       newstor.cpp
//
//  Contents:   Certificate, CRL and CTL Store APIs
//
//  Functions:  CertStoreDllMain
//              CertOpenStore
//              CertDuplicateStore
//              CertCloseStore
//              CertSaveStore
//              CertControlStore
//              CertAddStoreToCollection
//              CertRemoveStoreFromCollection
//              CertSetStoreProperty
//              CertGetStoreProperty
//              CertGetSubjectCertificateFromStore
//              CertEnumCertificatesInStore
//              CertFindCertificateInStore
//              CertGetIssuerCertificateFromStore
//              CertVerifySubjectCertificateContext
//              CertDuplicateCertificateContext
//              CertCreateCertificateContext
//              CertFreeCertificateContext
//              CertSetCertificateContextProperty
//              CertGetCertificateContextProperty
//              CertEnumCertificateContextProperties
//              CertCreateCTLEntryFromCertificateContextProperties
//              CertSetCertificateContextPropertiesFromCTLEntry
//              CertGetCRLFromStore
//              CertEnumCRLsInStore
//              CertFindCRLInStore
//              CertDuplicateCRLContext
//              CertCreateCRLContext
//              CertFreeCRLContext
//              CertSetCRLContextProperty
//              CertGetCRLContextProperty
//              CertEnumCRLContextProperties
//              CertFindCertificateInCRL
//              CertAddEncodedCertificateToStore
//              CertAddCertificateContextToStore
//              CertSerializeCertificateStoreElement
//              CertDeleteCertificateFromStore
//              CertAddEncodedCRLToStore
//              CertAddCRLContextToStore
//              CertSerializeCRLStoreElement
//              CertDeleteCRLFromStore
//              CertAddSerializedElementToStore
//
//              CertDuplicateCTLContext
//              CertCreateCTLContext
//              CertFreeCTLContext
//              CertSetCTLContextProperty
//              CertGetCTLContextProperty
//              CertEnumCTLContextProperties
//              CertEnumCTLsInStore
//              CertFindSubjectInCTL
//              CertFindCTLInStore
//              CertAddEncodedCTLToStore
//              CertAddCTLContextToStore
//              CertSerializeCTLStoreElement
//              CertDeleteCTLFromStore
//
//              CertAddCertificateLinkToStore
//              CertAddCRLLinkToStore
//              CertAddCTLLinkToStore
//
//              CertCreateContext
//
//              I_CertAddSerializedStore
//              CryptAcquireCertificatePrivateKey
//              I_CertSyncStore
//              I_CertSyncStoreEx
//              I_CertUpdateStore
//
//              CryptGetKeyIdentifierProperty
//              CryptSetKeyIdentifierProperty
//              CryptEnumKeyIdentifierProperties
//
//  History:    17-Feb-96    philh   created
//              29-Dec-96    philh   redo using provider functions
//              01-May-97    philh   added CTL functions
//              01-Aug-97    philh   NT 5.0 Changes. Support context links,
//                                   collections and external stores.
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

HMODULE hCertStoreInst;

// Maximum # of verified CRLs allowed per issuer.
// This array of CRLs is passed to CertHelperVerifyRevocation
#define MAX_CRL_LIST    64

//+-------------------------------------------------------------------------
//  Store data structure definitions
//--------------------------------------------------------------------------

// Assumes
//  0 - Certificates
//  1 - CRLs
//  2 - CTLs
#define CONTEXT_COUNT       3

typedef struct _CONTEXT_ELEMENT CONTEXT_ELEMENT, *PCONTEXT_ELEMENT;
typedef struct _PROP_ELEMENT PROP_ELEMENT, *PPROP_ELEMENT;

typedef struct _CERT_STORE CERT_STORE, *PCERT_STORE;
typedef struct _SHARE_STORE SHARE_STORE, *PSHARE_STORE;
typedef struct _CERT_STORE_LINK CERT_STORE_LINK, *PCERT_STORE_LINK;

typedef struct _COLLECTION_STACK_ENTRY COLLECTION_STACK_ENTRY,
    *PCOLLECTION_STACK_ENTRY;

// Used to maintain collection state across context find next calls.
//
// Ref count on pStoreLink. No ref count on pCollection.
// pStoreLink may be NULL.
struct _COLLECTION_STACK_ENTRY {
    PCERT_STORE                 pCollection;
    PCERT_STORE_LINK            pStoreLink;
    PCOLLECTION_STACK_ENTRY     pPrev;
};

typedef struct _CONTEXT_CACHE_INFO {
    PPROP_ELEMENT               pPropHead;
} CONTEXT_CACHE_INFO;

typedef struct _CONTEXT_EXTERNAL_INFO {
    // For ELEMENT_FIND_NEXT_FLAG
    void                        *pvProvInfo;
} CONTEXT_EXTERNAL_INFO;

typedef struct _CONTEXT_COLLECTION_INFO {
    // For Find
    PCOLLECTION_STACK_ENTRY     pCollectionStack;
} CONTEXT_COLLECTION_INFO;

#define ELEMENT_DELETED_FLAG                    0x00010000

// Only set for external elements
#define ELEMENT_FIND_NEXT_FLAG                  0x00020000

// Set during CertCloseStore if ELEMENT_FIND_NEXT_FLAG was set.
#define ELEMENT_CLOSE_FIND_NEXT_FLAG            0x00040000

// Set if the element has a CERT_ARCHIVED_PROP_ID
#define ELEMENT_ARCHIVED_FLAG                   0x00080000

// A cache element is the actual context element. Its the only element,
// where pEle points to itself. All other elements will eventually
// point to a cache element. Cache elements may only reside in a cache
// store. The pProvStore is the same as the pStore. Note, during a
// context add, a cache element may temporarily be in a collection store
// during the call to the provider's add callback.
//
// A link context element is a link to another element, including a link
// to another link context element. Link context elements may only reside
// in a cache store. The pProvStore is the same as the linked to element's
// pProvStore.
//
// An external element is a link to the element returned by a provider
// that stores elements externally. External elements may only reside in
// an external store. The pProvStore is the external store's
// provider. The store doesn't hold a reference on an external element,
// its ELEMENT_DELETED_FLAG is always set.
//
// A collection element is a link to an element in a cache or external store.
// Its returned when finding in or adding to a collection store. The store
// doesn't hold a reference on a collection element, its
// ELEMENT_DELETED_FLAG is always set.
//
#define ELEMENT_TYPE_CACHE                      1
#define ELEMENT_TYPE_LINK_CONTEXT               2
#define ELEMENT_TYPE_EXTERNAL                   3
#define ELEMENT_TYPE_COLLECTION                 4


#define MAX_LINK_DEPTH  100

typedef struct _CONTEXT_NOCOPY_INFO {
    PFN_CRYPT_FREE      pfnFree;
    void                *pvFree;
} CONTEXT_NOCOPY_INFO, *PCONTEXT_NOCOPY_INFO;


// Identical contexts (having the same SHA1 hash) can share the same encoded
// byte array and decoded info data structure.
//
// CreateShareElement() creates with dwRefCnt of 1. FindShareElement() finds
// an existing and increments dwRefCnt. ReleaseShareElement() decrements
// dwRefCnt and frees when 0.
typedef struct _SHARE_ELEMENT SHARE_ELEMENT, *PSHARE_ELEMENT;
struct _SHARE_ELEMENT {
    BYTE                rgbSha1Hash[SHA1_HASH_LEN];
    DWORD               dwContextType;
    BYTE                *pbEncoded;         // allocated
    DWORD               cbEncoded;
    void                *pvInfo;            // allocated

    DWORD               dwRefCnt;
    PSHARE_ELEMENT      pNext;
    PSHARE_ELEMENT      pPrev;
};

// The CONTEXT_ELEMENT is inserted before the CERT_CONTEXT, CRL_CONTEXT or
// CTL_CONTEXT. The dwContextType used is 0 based and not 1 based. For
// example, dwContextType = CERT_STORE_CERTIFICATE_CONTEXT - 1.
struct _CONTEXT_ELEMENT {
    DWORD               dwElementType;
    DWORD               dwContextType;
    DWORD               dwFlags;
    LONG                lRefCnt;

    // For ELEMENT_TYPE_CACHE, pEle points to itself. Otherwise, pEle points
    // to the element being linked to and the pEle is addRef'ed. The
    // cached element is found by iterating through the pEle's until pEle
    // points to itself.
    PCONTEXT_ELEMENT    pEle;
    PCERT_STORE         pStore;
    PCONTEXT_ELEMENT    pNext;
    PCONTEXT_ELEMENT    pPrev;
    PCERT_STORE         pProvStore;
    PCONTEXT_NOCOPY_INFO pNoCopyInfo;

    // When nonNULL, the context's pbEncoded and pInfo aren't allocated.
    // Instead, use the shared element's pbEncoded and pInfo. When
    // context element is freed, the pSharedEle is ReleaseShareElement()'ed.
    PSHARE_ELEMENT      pShareEle;          // RefCnt'ed

    union {
        CONTEXT_CACHE_INFO      Cache;      // ELEMENT_TYPE_CACHE
        CONTEXT_EXTERNAL_INFO   External;   // ELEMENT_TYPE_EXTERNAL
        CONTEXT_COLLECTION_INFO Collection; // ELEMENT_TYPE_COLLECTION
    };
};

// For CRL, follows the above CONTEXT_ELEMENT
typedef struct _CRL_CONTEXT_SUFFIX {
    PCRL_ENTRY          *ppSortedEntry;
} CRL_CONTEXT_SUFFIX, *PCRL_CONTEXT_SUFFIX;


typedef struct _HASH_BUCKET_ENTRY HASH_BUCKET_ENTRY, *PHASH_BUCKET_ENTRY;
struct _HASH_BUCKET_ENTRY {
    union {
        DWORD               dwEntryIndex;
        DWORD               dwEntryOffset;
        const BYTE          *pbEntry;
    };
    union {
        PHASH_BUCKET_ENTRY  pNext;
        DWORD               iNext;
    };
};

typedef struct _SORTED_CTL_FIND_INFO {
    DWORD                   cHashBucket;
    BOOL                    fHashedIdentifier;

    // Encoded sequence of TrustedSubjects
    const BYTE              *pbEncodedSubjects;         // not allocated
    DWORD                   cbEncodedSubjects;

    // Following is NON-NULL for a szOID_SORTED_CTL extension
    const BYTE              *pbEncodedHashBucket;       // not allocated

    // Following are NON-NULL when there isn't a szOID_SORTED_CTL extension
    DWORD                   *pdwHashBucketHead;         // allocated
    PHASH_BUCKET_ENTRY      pHashBucketEntry;           // allocated
} SORTED_CTL_FIND_INFO, *PSORTED_CTL_FIND_INFO;

// For CTL, follows the above CONTEXT_ELEMENT
typedef struct _CTL_CONTEXT_SUFFIX {
    PCTL_ENTRY              *ppSortedEntry;             // allocated

    BOOL                    fFastCreate;
    // Following only applicable for a FastCreateCtlElement
    PCTL_ENTRY              pCTLEntry;                  // allocated
    PCERT_EXTENSIONS        pExtInfo;                   // allocated
    PSORTED_CTL_FIND_INFO   pSortedCtlFindInfo;         // not allocated
} CTL_CONTEXT_SUFFIX, *PCTL_CONTEXT_SUFFIX;

struct _PROP_ELEMENT {
    DWORD               dwPropId;
    DWORD               dwFlags;
    BYTE                *pbData;
    DWORD               cbData;
    PPROP_ELEMENT       pNext;
    PPROP_ELEMENT       pPrev;
};


#define STORE_LINK_DELETED_FLAG        0x00010000
struct _CERT_STORE_LINK {
    DWORD               dwFlags;
    LONG                lRefCnt;

    // Whatever is passed to CertAddStoreToCollection
    DWORD               dwUpdateFlags;
    DWORD               dwPriority;

    PCERT_STORE         pCollection;
    PCERT_STORE         pSibling;       // CertStoreDuplicate'd.
    PCERT_STORE_LINK    pNext;
    PCERT_STORE_LINK    pPrev;
};


// Store types
#define STORE_TYPE_CACHE            1
#define STORE_TYPE_EXTERNAL         2
#define STORE_TYPE_COLLECTION       3

// CACHE store may have CACHE or LINK_CONTEXT elements. Until deleted,
// the store has a reference count to.

// EXTERNAL store only has EXTERNAL elements. These elements are always
// deleted, wherein, the store doesn't hold a refCnt.

// COLLECTION store has COLLECTION elements. These elements
// are always deleted, wherein, the store doesn't hold a refCnt.


struct _CERT_STORE {
    DWORD               dwStoreType;
    LONG                lRefCnt;
    HCRYPTPROV          hCryptProv;
    DWORD               dwFlags;
    DWORD               dwState;
    CRITICAL_SECTION    CriticalSection;
    PCONTEXT_ELEMENT    rgpContextListHead[CONTEXT_COUNT];
    PCERT_STORE_LINK    pStoreListHead;                     // COLLECTION
    PPROP_ELEMENT       pPropHead;      // properties for entire store

    // For CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG
    // Incremented for each context duplicated
    LONG                lDeferCloseRefCnt;

    // Event handle set by CertControlStore(CERT_STORE_CTRL_AUTO_RESYNC)
    HANDLE              hAutoResyncEvent;

    // The following is set for a shared store
    PSHARE_STORE        pShareStore;

    // Store provider info
    LONG                lStoreProvRefCnt;
    HANDLE              hStoreProvWait;
    HCRYPTOIDFUNCADDR   hStoreProvFuncAddr;
    CERT_STORE_PROV_INFO StoreProvInfo;
};

    

//+-------------------------------------------------------------------------
//  Store states
//--------------------------------------------------------------------------
#define STORE_STATE_DELETED         0
#define STORE_STATE_NULL            1
#define STORE_STATE_OPENING         2
#define STORE_STATE_OPEN            3
#define STORE_STATE_DEFER_CLOSING   4
#define STORE_STATE_CLOSING         5
#define STORE_STATE_CLOSED          6

// LocalMachine System stores opened for SHARE and MAXIMUM_ALLOWED can
// be shared. 
struct _SHARE_STORE {
    LPWSTR              pwszStore;  // not a separate allocation, string
                                    // follows struct
    PCERT_STORE         pStore;     // store holds lRefCnt
    PSHARE_STORE        pNext;
    PSHARE_STORE        pPrev;
};

//+-------------------------------------------------------------------------
//  Share stores.
//
//  A shared stored is identified by its UNICODE name. Simply maintain a
//  linked list of share stores.
//
//  Shared stores are restricted to LocalMachine System Stores opened
//  with CERT_STORE_SHARE_STORE_FLAG, CERT_STORE_SHARE_CONTEXT_FLAG and
//  CERT_STORE_MAXIMUM_ALLOWED_FLAG.
//--------------------------------------------------------------------------
STATIC PSHARE_STORE pShareStoreHead;
STATIC CRITICAL_SECTION ShareStoreCriticalSection;


//+-------------------------------------------------------------------------
//  Key Identifier Element
//--------------------------------------------------------------------------
typedef struct _KEYID_ELEMENT {
    CRYPT_HASH_BLOB     KeyIdentifier;
    PPROP_ELEMENT       pPropHead;
} KEYID_ELEMENT, *PKEYID_ELEMENT;


//+-------------------------------------------------------------------------
//  The "Find ANY" INFO data structure.
//
//  0 is the ANY dwFindType for all context types.
//--------------------------------------------------------------------------
static CCERT_STORE_PROV_FIND_INFO FindAnyInfo = {
    sizeof(CCERT_STORE_PROV_FIND_INFO),         // cbSize
    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,    // dwMsgAndCertEncodingType
    0,                                          // dwFindFlags
    0,                                          // dwFindType
    NULL                                        // pvFindPara
};

//+-------------------------------------------------------------------------
//  NULL Store.
//
//  HANDLE of all CONTEXTs created by CertCreateCertificateContext or
//  CertCreateCRLContext. Created CONTEXTs are immediately added to the
//  NULL store's free list. (ie, the store doesn't have a RefCnt on the
//  CONTEXT.)
//--------------------------------------------------------------------------
static CERT_STORE NullCertStore;

//+-------------------------------------------------------------------------
//  Bug in rsabase.dll. Its not thread safe across multiple crypt prov
//  handles.
//--------------------------------------------------------------------------
static CRITICAL_SECTION     CryptProvCriticalSection;

//+-------------------------------------------------------------------------
//  Store file definitions
//
//  The file consist of the FILE_HDR followed by 1 or more FILE_ELEMENTs.
//  Each FILE_ELEMENT has a FILE_ELEMENT_HDR + its value.
//
//  First the CERT elements are written. If a CERT has any properties, then,
//  the PROP elements immediately precede the CERT's element. Next the CRL
//  elements are written. If a CRL has any properties, then, the PROP elements
//  immediately precede the CRL's element. Likewise for CTL elements and its
//  properties. Finally, the END element is written.
//--------------------------------------------------------------------------
typedef struct _FILE_HDR {
    DWORD               dwVersion;
    DWORD               dwMagic;
} FILE_HDR, *PFILE_HDR;

#define CERT_FILE_VERSION_0             0
#define CERT_MAGIC ((DWORD)'C'+((DWORD)'E'<<8)+((DWORD)'R'<<16)+((DWORD)'T'<<24))

// The element's data follows the HDR
typedef struct _FILE_ELEMENT_HDR {
    DWORD               dwEleType;
    DWORD               dwEncodingType;
    DWORD               dwLen;
} FILE_ELEMENT_HDR, *PFILE_ELEMENT_HDR;

#define FILE_ELEMENT_END_TYPE           0
// FILE_ELEMENT_PROP_TYPEs              !(0 | CERT | CRL | CTL | KEYID)
// Note CERT_KEY_CONTEXT_PROP_ID (and CERT_KEY_PROV_HANDLE_PROP_ID)
// isn't written
#define FILE_ELEMENT_CERT_TYPE          32
#define FILE_ELEMENT_CRL_TYPE           33
#define FILE_ELEMENT_CTL_TYPE           34
#define FILE_ELEMENT_KEYID_TYPE         35

//#define MAX_FILE_ELEMENT_DATA_LEN       (4096 * 16)
#define MAX_FILE_ELEMENT_DATA_LEN       0xFFFFFFFF

//+-------------------------------------------------------------------------
//  Used when reading an element
//--------------------------------------------------------------------------
#define CSError     0
#define CSContinue  1
#define CSEnd       2

//+-------------------------------------------------------------------------
//  Share elements.
//
//  A share element is identifed by its sha1 hash. It contains the context's
//  encoded bytes and decoded info. Multiple contexts can point to the
//  same refcounted share element. The share elements are stored in a
//  hash bucket array of linked lists. The first byte of the element's sha1
//  hash is used as the index into the array.
//
//  Note, the actual index is the first byte modulus BUCKET_COUNT.
//--------------------------------------------------------------------------
#define SHARE_ELEMENT_HASH_BUCKET_COUNT  64
static PSHARE_ELEMENT rgpShareElementHashBucket[SHARE_ELEMENT_HASH_BUCKET_COUNT];
static CRITICAL_SECTION  ShareElementCriticalSection;

//+-------------------------------------------------------------------------
//  Read, Write & Skip to memory/file function definitions
//--------------------------------------------------------------------------
typedef BOOL (* PFNWRITE)(HANDLE h, void * p, DWORD cb);
typedef BOOL (* PFNREAD)(HANDLE h, void * p, DWORD cb);
typedef BOOL (* PFNSKIP)(HANDLE h, DWORD cb);


//+-------------------------------------------------------------------------
//  Store Provider Functions
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenMsgStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

STATIC BOOL WINAPI OpenMemoryStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_NO_PERSIST_FLAG;
    return TRUE;
}

STATIC BOOL WINAPI OpenFileStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

STATIC BOOL WINAPI OpenPKCS7StoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

STATIC BOOL WINAPI OpenSerializedStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

STATIC BOOL WINAPI OpenFilenameStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

STATIC BOOL WINAPI OpenFilenameStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

STATIC BOOL WINAPI OpenCollectionStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;

    pStore->dwStoreType = STORE_TYPE_COLLECTION;
    return TRUE;
}

// from regstor.cpp
extern BOOL WINAPI I_CertDllOpenRegStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );
extern BOOL WINAPI I_CertDllOpenSystemStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );
extern BOOL WINAPI I_CertDllOpenSystemStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

extern BOOL WINAPI I_CertDllOpenSystemRegistryStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );
extern BOOL WINAPI I_CertDllOpenSystemRegistryStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );
extern BOOL WINAPI I_CertDllOpenPhysicalStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        );

static HCRYPTOIDFUNCSET hOpenStoreProvFuncSet;
static const CRYPT_OID_FUNC_ENTRY OpenStoreProvFuncTable[] = {
    CERT_STORE_PROV_MSG, OpenMsgStoreProv,
    CERT_STORE_PROV_MEMORY, OpenMemoryStoreProv,
    CERT_STORE_PROV_FILE, OpenFileStoreProv,
    CERT_STORE_PROV_REG, I_CertDllOpenRegStoreProv,

    CERT_STORE_PROV_PKCS7, OpenPKCS7StoreProv,
    CERT_STORE_PROV_SERIALIZED, OpenSerializedStoreProv,
    CERT_STORE_PROV_FILENAME_A, OpenFilenameStoreProvA,
    CERT_STORE_PROV_FILENAME_W, OpenFilenameStoreProvW,
    CERT_STORE_PROV_SYSTEM_A, I_CertDllOpenSystemStoreProvA,
    CERT_STORE_PROV_SYSTEM_W, I_CertDllOpenSystemStoreProvW,
    CERT_STORE_PROV_COLLECTION, OpenCollectionStoreProv,
    CERT_STORE_PROV_SYSTEM_REGISTRY_A, I_CertDllOpenSystemRegistryStoreProvA,
    CERT_STORE_PROV_SYSTEM_REGISTRY_W, I_CertDllOpenSystemRegistryStoreProvW,
    CERT_STORE_PROV_PHYSICAL_W, I_CertDllOpenPhysicalStoreProvW,
    CERT_STORE_PROV_SMART_CARD_W, SmartCardProvOpenStore,

    sz_CERT_STORE_PROV_MEMORY, OpenMemoryStoreProv,
    sz_CERT_STORE_PROV_SYSTEM_W, I_CertDllOpenSystemStoreProvW,
    sz_CERT_STORE_PROV_FILENAME_W, OpenFilenameStoreProvW,
    sz_CERT_STORE_PROV_PKCS7, OpenPKCS7StoreProv,
    sz_CERT_STORE_PROV_SERIALIZED, OpenSerializedStoreProv,
    sz_CERT_STORE_PROV_COLLECTION, OpenCollectionStoreProv,
    sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W, I_CertDllOpenSystemRegistryStoreProvW,
    sz_CERT_STORE_PROV_PHYSICAL_W, I_CertDllOpenPhysicalStoreProvW,
    sz_CERT_STORE_PROV_SMART_CARD_W, SmartCardProvOpenStore
};
#define OPEN_STORE_PROV_FUNC_COUNT (sizeof(OpenStoreProvFuncTable) / \
                                    sizeof(OpenStoreProvFuncTable[0]))


//+-------------------------------------------------------------------------
//  NULL Store: initialization and free
//--------------------------------------------------------------------------
STATIC BOOL InitNullCertStore()
{
    BOOL fRet;

    memset(&NullCertStore, 0, sizeof(NullCertStore));
    NullCertStore.dwStoreType = STORE_TYPE_CACHE;
    NullCertStore.lRefCnt = 1;
    NullCertStore.dwState = STORE_STATE_NULL;
    fRet = Pki_InitializeCriticalSection(&NullCertStore.CriticalSection);
    NullCertStore.StoreProvInfo.dwStoreProvFlags =
        CERT_STORE_PROV_NO_PERSIST_FLAG;

    return fRet;
}
STATIC void FreeNullCertStore()
{
    DeleteCriticalSection(&NullCertStore.CriticalSection);
}

//+-------------------------------------------------------------------------
//  CryptProv: initialization and free
//--------------------------------------------------------------------------
STATIC BOOL InitCryptProv()
{
    return Pki_InitializeCriticalSection(&CryptProvCriticalSection);
}
STATIC void FreeCryptProv()
{
    DeleteCriticalSection(&CryptProvCriticalSection);
}

extern
BOOL
WINAPI
I_RegStoreDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved);

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
CertStoreDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    if (!I_RegStoreDllMain(hInst, ulReason, lpReserved))
        return FALSE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        // Used for "root" system store's message box
        hCertStoreInst = hInst;

        if (NULL == (hOpenStoreProvFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_OPEN_STORE_PROV_FUNC, 0)))
            goto CryptInitOIDFunctionSetError;

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                0,                          // dwEncodingType
                CRYPT_OID_OPEN_STORE_PROV_FUNC,
                OPEN_STORE_PROV_FUNC_COUNT,
                OpenStoreProvFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;

        if (!Pki_InitializeCriticalSection(&ShareElementCriticalSection))
            goto InitShareElementCritSectionError;
        if (!Pki_InitializeCriticalSection(&ShareStoreCriticalSection))
            goto InitShareStoreCritSectionError;
        if (!InitNullCertStore())
            goto InitNullCertStoreError;
        if (!InitCryptProv())
            goto InitCryptProvError;

        break;

    case DLL_PROCESS_DETACH:
        FreeCryptProv();
        FreeNullCertStore();
        DeleteCriticalSection(&ShareElementCriticalSection);
        DeleteCriticalSection(&ShareStoreCriticalSection);
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

InitCryptProvError:
    FreeNullCertStore();
InitNullCertStoreError:
    DeleteCriticalSection(&ShareStoreCriticalSection);
InitShareStoreCritSectionError:
    DeleteCriticalSection(&ShareElementCriticalSection);
InitShareElementCritSectionError:
ErrorReturn:
    I_RegStoreDllMain(hInst, DLL_PROCESS_DETACH, NULL);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInitOIDFunctionSetError)
TRACE_ERROR(CryptInstallOIDFunctionAddressError)
}


//+=========================================================================
//  Context Type Tables
//==========================================================================

//+-------------------------------------------------------------------------
//  Provider callback function indices
//--------------------------------------------------------------------------
static const DWORD rgdwStoreProvFindIndex[CONTEXT_COUNT] = {
    CERT_STORE_PROV_FIND_CERT_FUNC,
    CERT_STORE_PROV_FIND_CRL_FUNC,
    CERT_STORE_PROV_FIND_CTL_FUNC
};

static const DWORD rgdwStoreProvWriteIndex[CONTEXT_COUNT] = {
    CERT_STORE_PROV_WRITE_CERT_FUNC,
    CERT_STORE_PROV_WRITE_CRL_FUNC,
    CERT_STORE_PROV_WRITE_CTL_FUNC
};

static const DWORD rgdwStoreProvDeleteIndex[CONTEXT_COUNT] = {
    CERT_STORE_PROV_DELETE_CERT_FUNC,
    CERT_STORE_PROV_DELETE_CRL_FUNC,
    CERT_STORE_PROV_DELETE_CTL_FUNC
};

static const DWORD rgdwStoreProvFreeFindIndex[CONTEXT_COUNT] = {
    CERT_STORE_PROV_FREE_FIND_CERT_FUNC,
    CERT_STORE_PROV_FREE_FIND_CRL_FUNC,
    CERT_STORE_PROV_FREE_FIND_CTL_FUNC
};

static const DWORD rgdwStoreProvGetPropertyIndex[CONTEXT_COUNT] = {
    CERT_STORE_PROV_GET_CERT_PROPERTY_FUNC,
    CERT_STORE_PROV_GET_CRL_PROPERTY_FUNC,
    CERT_STORE_PROV_GET_CTL_PROPERTY_FUNC
};

static const DWORD rgdwStoreProvSetPropertyIndex[CONTEXT_COUNT] = {
    CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC,
    CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC,
    CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC
};

//+-------------------------------------------------------------------------
//  Context data structure length and field offsets
//--------------------------------------------------------------------------
static const DWORD rgcbContext[CONTEXT_COUNT] = {
    sizeof(CERT_CONTEXT),
    sizeof(CRL_CONTEXT),
    sizeof(CTL_CONTEXT)
};

static const DWORD rgOffsetofStoreHandle[CONTEXT_COUNT] = {
    offsetof(CERT_CONTEXT, hCertStore),
    offsetof(CRL_CONTEXT, hCertStore),
    offsetof(CTL_CONTEXT, hCertStore)
};

static const DWORD rgOffsetofEncodingType[CONTEXT_COUNT] = {
    offsetof(CERT_CONTEXT, dwCertEncodingType),
    offsetof(CRL_CONTEXT, dwCertEncodingType),
    offsetof(CTL_CONTEXT, dwMsgAndCertEncodingType)
};

static const DWORD rgOffsetofEncodedPointer[CONTEXT_COUNT] = {
    offsetof(CERT_CONTEXT, pbCertEncoded),
    offsetof(CRL_CONTEXT, pbCrlEncoded),
    offsetof(CTL_CONTEXT, pbCtlEncoded)
};

static const DWORD rgOffsetofEncodedCount[CONTEXT_COUNT] = {
    offsetof(CERT_CONTEXT, cbCertEncoded),
    offsetof(CRL_CONTEXT, cbCrlEncoded),
    offsetof(CTL_CONTEXT, cbCtlEncoded)
};

//+-------------------------------------------------------------------------
//  Find Types
//--------------------------------------------------------------------------
static const DWORD rgdwFindTypeToFindExisting[CONTEXT_COUNT] = {
    CERT_FIND_EXISTING,
    CRL_FIND_EXISTING,
    CTL_FIND_EXISTING
};

//+-------------------------------------------------------------------------
//  File Element Types
//--------------------------------------------------------------------------
static const DWORD rgdwFileElementType[CONTEXT_COUNT] = {
    FILE_ELEMENT_CERT_TYPE,
    FILE_ELEMENT_CRL_TYPE,
    FILE_ELEMENT_CTL_TYPE
};

//+-------------------------------------------------------------------------
//  Share Element Decode Struct Types
//--------------------------------------------------------------------------
static const LPCSTR rgpszShareElementStructType[CONTEXT_COUNT] = {
    X509_CERT_TO_BE_SIGNED,
    X509_CERT_CRL_TO_BE_SIGNED,
    0
};

//+=========================================================================
//  Context Type Specific Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  CERT_CONTEXT Element
//--------------------------------------------------------------------------

// pbCertEncoded has already been allocated
STATIC PCONTEXT_ELEMENT CreateCertElement(
    IN PCERT_STORE pStore,
    IN DWORD dwCertEncodingType,
    IN BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded,
    IN OPTIONAL PSHARE_ELEMENT pShareEle
    );
STATIC void FreeCertElement(IN PCONTEXT_ELEMENT pEle);

STATIC BOOL IsSameCert(
    IN PCCERT_CONTEXT pCert,
    IN PCCERT_CONTEXT pNew
    );

STATIC BOOL CompareCertElement(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    );

STATIC BOOL IsNewerCertElement(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    );

static inline PCONTEXT_ELEMENT ToContextElement(
    IN PCCERT_CONTEXT pCertContext
    )
{
    if (pCertContext)
        return (PCONTEXT_ELEMENT)
            (((BYTE *) pCertContext) - sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}
static inline PCCERT_CONTEXT ToCertContext(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle)
        return (PCCERT_CONTEXT)
            (((BYTE *) pEle) + sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}

//+-------------------------------------------------------------------------
//  CRL_CONTEXT Element
//--------------------------------------------------------------------------

// pbCrlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT CreateCrlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwCertEncodingType,
    IN BYTE *pbCrlEncoded,
    IN DWORD cbCrlEncoded,
    IN OPTIONAL PSHARE_ELEMENT pShareEle
    );
STATIC void FreeCrlElement(IN PCONTEXT_ELEMENT pEle);
STATIC BOOL CompareCrlElement(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    );

STATIC BOOL IsNewerCrlElement(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    );

static inline PCONTEXT_ELEMENT ToContextElement(
    IN PCCRL_CONTEXT pCrlContext
    )
{
    if (pCrlContext)
        return (PCONTEXT_ELEMENT)
            (((BYTE *) pCrlContext) - sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}
static inline PCCRL_CONTEXT ToCrlContext(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle)
        return (PCCRL_CONTEXT)
            (((BYTE *) pEle) + sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}

static inline PCRL_CONTEXT_SUFFIX ToCrlContextSuffix(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle)
        return (PCRL_CONTEXT_SUFFIX)
            (((BYTE *) pEle) + sizeof(CONTEXT_ELEMENT) + sizeof(CRL_CONTEXT));
    else
        return NULL;
}

//+-------------------------------------------------------------------------
//  CTL_CONTEXT Element
//--------------------------------------------------------------------------

// pbCtlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT CreateCtlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded,
    IN OPTIONAL PSHARE_ELEMENT pShareEle
    );
STATIC void FreeCtlElement(IN PCONTEXT_ELEMENT pEle);
STATIC BOOL CompareCtlElement(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    );

STATIC BOOL IsNewerCtlElement(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    );

static inline PCONTEXT_ELEMENT ToContextElement(
    IN PCCTL_CONTEXT pCtlContext
    )
{
    if (pCtlContext)
        return (PCONTEXT_ELEMENT)
            (((BYTE *) pCtlContext) - sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}
static inline PCCTL_CONTEXT ToCtlContext(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle)
        return (PCCTL_CONTEXT)
            (((BYTE *) pEle) + sizeof(CONTEXT_ELEMENT));
    else
        return NULL;
}

static inline PCTL_CONTEXT_SUFFIX ToCtlContextSuffix(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle)
        return (PCTL_CONTEXT_SUFFIX)
            (((BYTE *) pEle) + sizeof(CONTEXT_ELEMENT) + sizeof(CTL_CONTEXT));
    else
        return NULL;
}

//+=========================================================================
//  Context Type Function Tables
//==========================================================================
typedef PCONTEXT_ELEMENT (*PFN_CREATE_ELEMENT)(
    IN PCERT_STORE pStore,
    IN DWORD dwCertEncodingType,
    IN BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded,
    IN OPTIONAL PSHARE_ELEMENT pShareEle
    );

static PFN_CREATE_ELEMENT const rgpfnCreateElement[CONTEXT_COUNT] = {
    CreateCertElement,
    CreateCrlElement,
    CreateCtlElement
};

typedef void (*PFN_FREE_ELEMENT)(
    IN PCONTEXT_ELEMENT pEle
    );

static PFN_FREE_ELEMENT const rgpfnFreeElement[CONTEXT_COUNT] = {
    FreeCertElement,
    FreeCrlElement,
    FreeCtlElement
};

typedef BOOL (*PFN_COMPARE_ELEMENT)(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    );

static PFN_COMPARE_ELEMENT const rgpfnCompareElement[CONTEXT_COUNT] = {
    CompareCertElement,
    CompareCrlElement,
    CompareCtlElement
};

typedef BOOL (*PFN_IS_NEWER_ELEMENT)(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    );

static PFN_IS_NEWER_ELEMENT const rgpfnIsNewerElement[CONTEXT_COUNT] = {
    IsNewerCertElement,
    IsNewerCrlElement,
    IsNewerCtlElement
};

//+=========================================================================
//  Store Link Functions
//==========================================================================

STATIC PCERT_STORE_LINK CreateStoreLink(
    IN PCERT_STORE pCollection,
    IN PCERT_STORE pSibling,
    IN DWORD dwUpdateFlags,
    IN DWORD dwPriority
    );
STATIC void FreeStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    );
STATIC void RemoveStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    );
STATIC void RemoveAndFreeStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    );

static inline void AddRefStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    )
{
    InterlockedIncrement(&pStoreLink->lRefCnt);
}

STATIC void ReleaseStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    );

//+=========================================================================
//  Context Element Functions
//==========================================================================

STATIC DWORD GetContextEncodingType(
    IN PCONTEXT_ELEMENT pEle
    );

STATIC void GetContextEncodedInfo(
    IN PCONTEXT_ELEMENT pEle,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    );

STATIC PCONTEXT_ELEMENT GetCacheElement(
    IN PCONTEXT_ELEMENT pCacheEle
    );

STATIC void AddContextElement(
    IN PCONTEXT_ELEMENT pEle
    );
STATIC void RemoveContextElement(
    IN PCONTEXT_ELEMENT pEle
    );
STATIC void FreeContextElement(
    IN PCONTEXT_ELEMENT pEle
    );
STATIC void RemoveAndFreeContextElement(
    IN PCONTEXT_ELEMENT pEle
    );

STATIC void AddRefContextElement(
    IN PCONTEXT_ELEMENT pEle
    );
STATIC void AddRefDeferClose(
    IN PCONTEXT_ELEMENT pEle
    );
STATIC void ReleaseContextElement(
    IN PCONTEXT_ELEMENT pEle
    );
STATIC BOOL DeleteContextElement(
    IN PCONTEXT_ELEMENT pEle
    );

// Returns TRUE if both elements have identical SHA1 hash.
STATIC BOOL IsIdenticalContextElement(
    IN PCONTEXT_ELEMENT pEle1,
    IN PCONTEXT_ELEMENT pEle2
    );

STATIC BOOL SerializeStoreElement(
    IN HANDLE h,
    IN PFNWRITE pfn,
    IN PCONTEXT_ELEMENT pEle
    );

STATIC BOOL SerializeContextElement(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwFlags,
    OUT BYTE *pbElement,
    IN OUT DWORD *pcbElement
    );

STATIC PCONTEXT_ELEMENT CreateLinkElement(
    IN DWORD dwContextType
    );

static inline void FreeLinkElement(
    IN PCONTEXT_ELEMENT pLinkEle
    )
{
    PkiFree(pLinkEle);
}

STATIC void FreeLinkContextElement(
    IN PCONTEXT_ELEMENT pLinkEle
    );

// Upon entry no locks
STATIC void RemoveAndFreeLinkElement(
    IN PCONTEXT_ELEMENT pEle
    );

STATIC PCONTEXT_ELEMENT FindElementInStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle
    );

STATIC PCONTEXT_ELEMENT CheckAutoResyncAndFindElementInStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle
    );

STATIC BOOL AddLinkContextToCacheStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    );

// pEle is used or freed for success only, Otherwise, its left alone and
// will be freed by the caller.
//
// This routine may be called recursively
STATIC BOOL AddElementToStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    );

STATIC BOOL AddEncodedContextToStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    );

STATIC BOOL AddContextToStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pSrcEle,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    );

//+=========================================================================
//  PROP_ELEMENT Functions
//==========================================================================
// pbData has already been allocated
STATIC PPROP_ELEMENT CreatePropElement(
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN BYTE *pbData,
    IN DWORD cbData
    );
STATIC void FreePropElement(IN PPROP_ELEMENT pEle);

// Upon entry/exit: Store/Element is locked
STATIC PPROP_ELEMENT FindPropElement(
    IN PPROP_ELEMENT pPropEle,
    IN DWORD dwPropId
    );
STATIC PPROP_ELEMENT FindPropElement(
    IN PCONTEXT_ELEMENT pCacheEle,
    IN DWORD dwPropId
    );

// Upon entry/exit: Store/Element is locked
STATIC void AddPropElement(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN PPROP_ELEMENT pPropEle
    );
STATIC void AddPropElement(
    IN OUT PCONTEXT_ELEMENT pCacheEle,
    IN PPROP_ELEMENT pPropEle
    );

// Upon entry/exit: Store/Element is locked
STATIC void RemovePropElement(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN PPROP_ELEMENT pPropEle
    );
STATIC void RemovePropElement(
    IN OUT PCONTEXT_ELEMENT pCacheEle,
    IN PPROP_ELEMENT pPropEle
    );

//+=========================================================================
//  Property Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Set the property for the specified element
//--------------------------------------------------------------------------
STATIC BOOL SetProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData,
    IN BOOL fInhibitProvSet = FALSE
    );

//+-------------------------------------------------------------------------
//  Get the property for the specified element
//--------------------------------------------------------------------------
STATIC BOOL GetProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );

// Upon entry/exit the store is locked
STATIC void DeleteProperty(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN DWORD dwPropId
    );
STATIC void DeleteProperty(
    IN OUT PCONTEXT_ELEMENT pCacheEle,
    IN DWORD dwPropId
    );

//+-------------------------------------------------------------------------
//  Serialize a Property
//--------------------------------------------------------------------------
STATIC BOOL SerializeProperty(
    IN HANDLE h,
    IN PFNWRITE pfn,
    IN PCONTEXT_ELEMENT pEle
    );

#define COPY_PROPERTY_USE_EXISTING_FLAG     0x1
#define COPY_PROPERTY_INHIBIT_PROV_SET_FLAG 0x2
#define COPY_PROPERTY_SYNC_FLAG             0x4
STATIC BOOL CopyProperties(
    IN PCONTEXT_ELEMENT pSrcEle,
    IN PCONTEXT_ELEMENT pDstEle,
    IN DWORD dwFlags
    );

//+-------------------------------------------------------------------------
//  Get the first or next PropId for the specified element
//
//  Set dwPropId = 0, to get the first. Returns 0, if no more properties.
//--------------------------------------------------------------------------
STATIC DWORD EnumProperties(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId
    );

//+-------------------------------------------------------------------------
//  Get or set the caller properties for a store or KeyId element.
//--------------------------------------------------------------------------
STATIC BOOL GetCallerProperty(
    IN PPROP_ELEMENT pPropHead,
    IN DWORD dwPropId,
    BOOL fAlloc,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );

BOOL SetCallerProperty(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    );

//+-------------------------------------------------------------------------
//  CRYPT_KEY_PROV_INFO: Encode and Decode Functions
//--------------------------------------------------------------------------
#define ENCODE_LEN_ALIGN(Len)  ((Len + 7) & ~7)

typedef struct _SERIALIZED_KEY_PROV_PARAM {
    DWORD           dwParam;
    DWORD           offbData;
    DWORD           cbData;
    DWORD           dwFlags;
} SERIALIZED_KEY_PROV_PARAM, *PSERIALIZED_KEY_PROV_PARAM;

typedef struct _SERIALIZED_KEY_PROV_INFO {
    DWORD           offwszContainerName;
    DWORD           offwszProvName;
    DWORD           dwProvType;
    DWORD           dwFlags;
    DWORD           cProvParam;
    DWORD           offrgProvParam;
    DWORD           dwKeySpec;
} SERIALIZED_KEY_PROV_INFO, *PSERIALIZED_KEY_PROV_INFO;

#define MAX_PROV_PARAM          0x00000100
#define MAX_PROV_PARAM_CBDATA   0x00010000

STATIC BOOL AllocAndEncodeKeyProvInfo(
    IN PCRYPT_KEY_PROV_INFO pKeyProvInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    );

STATIC BOOL DecodeKeyProvInfo(
    IN PSERIALIZED_KEY_PROV_INFO pSerializedInfo,
    IN DWORD cbSerialized,
    OUT PCRYPT_KEY_PROV_INFO pInfo,
    OUT DWORD *pcbInfo
    );

//+=========================================================================
//  KEYID_ELEMENT Functions
//==========================================================================
// pbKeyIdEncoded has already been allocated
STATIC PKEYID_ELEMENT CreateKeyIdElement(
    IN BYTE *pbKeyIdEncoded,
    IN DWORD cbKeyIdEncoded
    );
STATIC void FreeKeyIdElement(IN PKEYID_ELEMENT pEle);

//+=========================================================================
// Key Identifier Property Functions
//
// If dwPropId == 0, check if the element has a KEY_PROV_INFO property
//==========================================================================
STATIC void SetCryptKeyIdentifierKeyProvInfoProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId = 0,
    IN const void *pvData = NULL
    );

STATIC BOOL GetKeyIdProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );

//+-------------------------------------------------------------------------
//  Alloc and NOCOPY Decode
//--------------------------------------------------------------------------
STATIC void *AllocAndDecodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags = CRYPT_DECODE_NOCOPY_FLAG
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            dwFlags |
                CRYPT_DECODE_SHARE_OID_STRING_FLAG | CRYPT_DECODE_ALLOC_FLAG,
            &PkiDecodePara,
            (void *) &pvStructInfo,
            &cbStructInfo
            ))
        goto ErrorReturn;

CommonReturn:
    return pvStructInfo;
ErrorReturn:
    pvStructInfo = NULL;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Allocates and returns the specified cryptographic message parameter.
//--------------------------------------------------------------------------
STATIC void *AllocAndGetMsgParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT DWORD *pcbData
    )
{
    void *pvData;
    DWORD cbData;

    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            NULL,           // pvData
            &cbData) || 0 == cbData)
        goto GetParamError;
    if (NULL == (pvData = PkiNonzeroAlloc(cbData)))
        goto OutOfMemory;
    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            pvData,
            &cbData)) {
        PkiFree(pvData);
        goto GetParamError;
    }

CommonReturn:
    *pcbData = cbData;
    return pvData;
ErrorReturn:
    pvData = NULL;
    cbData = 0;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetParamError)
}

//+-------------------------------------------------------------------------
//  First try to get the EncodingType from the lower 16 bits. If 0, get
//  from the upper 16 bits.
//--------------------------------------------------------------------------
static inline DWORD GetCertEncodingType(
    IN DWORD dwEncodingType
    )
{
    if (0 == dwEncodingType)
        return X509_ASN_ENCODING;
    else
        return (dwEncodingType & CERT_ENCODING_TYPE_MASK) ?
            (dwEncodingType & CERT_ENCODING_TYPE_MASK) :
            ((dwEncodingType >> 16) & CERT_ENCODING_TYPE_MASK);
}

STATIC DWORD AdjustEncodedLength(
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbDER,
    IN DWORD cbDER
    )
{
    if (X509_ASN_ENCODING == GET_CERT_ENCODING_TYPE(dwCertEncodingType))
        return Asn1UtilAdjustEncodedLength(pbDER, cbDER);
    else
        return cbDER;
}


//+-------------------------------------------------------------------------
//  Read, Write and Skip file functions
//--------------------------------------------------------------------------
BOOL WriteToFile(HANDLE h, void * p, DWORD cb) {

    DWORD   cbBytesWritten;

    return(WriteFile(h, p, cb, &cbBytesWritten, NULL));
}
BOOL ReadFromFile(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    DWORD   cbBytesRead;

    return(ReadFile(h, p, cb, &cbBytesRead, NULL));
}

BOOL SkipInFile(
    IN HANDLE h,
    IN DWORD cb
    )
{
    DWORD dwLoFilePointer;
    LONG lHiFilePointer;
    LONG lDistanceToMove;

    lDistanceToMove = (LONG) cb;
    lHiFilePointer = 0;
    dwLoFilePointer = SetFilePointer(
        h,
        lDistanceToMove,
        &lHiFilePointer,
        FILE_CURRENT
        );
    if (0xFFFFFFFF == dwLoFilePointer && NO_ERROR != GetLastError())
        return FALSE;
    else
        return TRUE;
}


//+-------------------------------------------------------------------------
//  Read, Write and Skip memory fucntions
//--------------------------------------------------------------------------
typedef struct _MEMINFO {
    BYTE *  pByte;
    DWORD   cb;
    DWORD   cbSeek;
} MEMINFO, * PMEMINFO;

BOOL WriteToMemory(HANDLE h, void * p, DWORD cb)
{
    PMEMINFO pMemInfo = (PMEMINFO) h;

    // See if we have room. The caller will detect an error after the final
    // write
    if (pMemInfo->cbSeek + cb <= pMemInfo->cb) {
      // Handle MappedFile Exceptions
      __try {

        // copy the bytes
        memcpy(&pMemInfo->pByte[pMemInfo->cbSeek], p, cb);

      } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        return FALSE;
      }
    }

    pMemInfo->cbSeek += cb;

    return(TRUE);
}

BOOL ReadFromMemory(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    PMEMINFO pMemInfo = (PMEMINFO) h;
    BOOL fResult;

    fResult = !((pMemInfo->cb - pMemInfo->cbSeek) < cb);
    cb = min((pMemInfo->cb - pMemInfo->cbSeek), cb);

  // Handle MappedFile Exceptions
  __try {

    // copy the bytes
    memcpy(p, &pMemInfo->pByte[pMemInfo->cbSeek], cb);

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    SetLastError(GetExceptionCode());
    return FALSE;
  }

    pMemInfo->cbSeek += cb;

    if(!fResult)
        SetLastError(ERROR_END_OF_MEDIA);

    return(fResult);
}

BOOL SkipInMemory(
    IN HANDLE h,
    IN DWORD cb
    )
{
    PMEMINFO pMemInfo = (PMEMINFO) h;
    BOOL fResult;

    fResult = !((pMemInfo->cb - pMemInfo->cbSeek) < cb);
    cb = min((pMemInfo->cb - pMemInfo->cbSeek), cb);

    pMemInfo->cbSeek += cb;

    if(!fResult)
        SetLastError(ERROR_END_OF_MEDIA);

    return(fResult);
}


//+-------------------------------------------------------------------------
//  Lock and unlock functions
//--------------------------------------------------------------------------
STATIC void LockStore(IN PCERT_STORE pStore)
{
    EnterCriticalSection(&pStore->CriticalSection);
}
STATIC void UnlockStore(IN PCERT_STORE pStore)
{
    LeaveCriticalSection(&pStore->CriticalSection);
}

//+-------------------------------------------------------------------------
//  Reference count calls to provider functions. This is necessary since
//  the store provider functions are called without a lock on the
//  store. CertCloseStore waits until the provider reference count
//  is decremented to zero before completing the close.
//
//  Also used to reference count use of the store's CryptProv handle when
//  used without a store lock.
//--------------------------------------------------------------------------

// Upon entry/exit the store is locked
static inline void AddRefStoreProv(IN PCERT_STORE pStore)
{
    pStore->lStoreProvRefCnt++;
}

// Upon entry/exit the store is locked
static inline void ReleaseStoreProv(IN PCERT_STORE pStore)
{
    if (0 == --pStore->lStoreProvRefCnt && pStore->hStoreProvWait)
        SetEvent(pStore->hStoreProvWait);
}

//+-------------------------------------------------------------------------
//  Try to get the store's CryptProv handle.
//  If we get the store's CryptProv handle,
//  then, increment the provider reference count to force another
//  thread's CertCloseStore to wait until we make a call to ReleaseCryptProv.
//
//  Leave while still in the CryptProvCriticalSection.
//
//  ReleaseCryptProv() must always be called.
//
//  Note, if returned hCryptProv is NULL, the called CertHelper functions
//  will acquire and use the appropriate default provider.
//--------------------------------------------------------------------------
#define RELEASE_STORE_CRYPT_PROV_FLAG   0x1

STATIC HCRYPTPROV GetCryptProv(
    IN PCERT_STORE pStore,
    OUT DWORD *pdwFlags
    )
{
    HCRYPTPROV hCryptProv;

    LockStore(pStore);
    hCryptProv = pStore->hCryptProv;
    if (hCryptProv) {
        AddRefStoreProv(pStore);
        *pdwFlags = RELEASE_STORE_CRYPT_PROV_FLAG;
    } else
        *pdwFlags = 0;
    UnlockStore(pStore);

    EnterCriticalSection(&CryptProvCriticalSection);
    return hCryptProv;
}

STATIC void ReleaseCryptProv(
    IN PCERT_STORE pStore,
    IN DWORD dwFlags
    )
{
    LeaveCriticalSection(&CryptProvCriticalSection);

    if (dwFlags & RELEASE_STORE_CRYPT_PROV_FLAG) {
        LockStore(pStore);
        ReleaseStoreProv(pStore);
        UnlockStore(pStore);
    }
}

//+-------------------------------------------------------------------------
//  Forward references
//--------------------------------------------------------------------------
STATIC BOOL IsEmptyStore(
    IN PCERT_STORE pStore
    );
STATIC BOOL CloseStore(
    IN PCERT_STORE pStore,
    DWORD dwFlags
    );

void ArchiveManifoldCertificatesInStore(
    IN PCERT_STORE pStore
    );

//+-------------------------------------------------------------------------
//  Share Store Functions
//--------------------------------------------------------------------------

// If the sharable LocalMachine store is already open, its returned with its
// RefCnt bumped
STATIC PCERT_STORE FindShareStore(
    IN LPCWSTR pwszStore
    )
{
    PCERT_STORE pStore = NULL;
    PSHARE_STORE pShare;

    EnterCriticalSection(&ShareStoreCriticalSection);

    for (pShare = pShareStoreHead; pShare; pShare = pShare->pNext) {
        if (0 == _wcsicmp(pShare->pwszStore, pwszStore)) {
            pStore = pShare->pStore;
            InterlockedIncrement(&pStore->lRefCnt);
            break;
        }
    }

    LeaveCriticalSection(&ShareStoreCriticalSection);

    return pStore;
}

// The LocalMachine store is added to the linked list of opened, sharable
// stores.
STATIC void CreateShareStore(
    IN LPCWSTR pwszStore,
    IN PCERT_STORE pStore
    )
{
    PSHARE_STORE pShare;
    DWORD cbwszStore;

    cbwszStore = (wcslen(pwszStore) + 1) * sizeof(WCHAR);

    if (NULL == (pShare = (PSHARE_STORE) PkiZeroAlloc(
            sizeof(SHARE_STORE) + cbwszStore)))
        return;

    pShare->pwszStore = (LPWSTR) &pShare[1];
    memcpy(pShare->pwszStore, pwszStore, cbwszStore);
    pShare->pStore = pStore;
    pStore->pShareStore = pShare;

    EnterCriticalSection(&ShareStoreCriticalSection);

    if (pShareStoreHead) {
        pShare->pNext = pShareStoreHead;
        assert(NULL == pShareStoreHead->pPrev);
        pShareStoreHead->pPrev = pShare;
    }
    pShareStoreHead = pShare;

    LeaveCriticalSection(&ShareStoreCriticalSection);
}

// Upon input/exit, Store is locked.
// Returns TRUE if share store was closed and freed
STATIC BOOL CloseShareStore(
    IN PCERT_STORE pStore
    )
{
    BOOL fClose;

    EnterCriticalSection(&ShareStoreCriticalSection);

    // Check if we had a FindShareStore after the store's lRefCnt
    // was decremented to 0.
    InterlockedIncrement(&pStore->lRefCnt);
    if (0 == InterlockedDecrement(&pStore->lRefCnt)) {
        PSHARE_STORE pShare;

        pShare = pStore->pShareStore;
        assert(pShare);
        if (pShare) {
            if (pShare->pNext)
                pShare->pNext->pPrev = pShare->pPrev;

            if (pShare->pPrev)
                pShare->pPrev->pNext = pShare->pNext;
            else {
                assert(pShareStoreHead == pShare);
                pShareStoreHead = pShare->pNext;
            }

            PkiFree(pShare);
        }

        pStore->pShareStore = NULL;
        fClose = TRUE;
    } else
        fClose = FALSE;

    LeaveCriticalSection(&ShareStoreCriticalSection);

    return fClose;
}

//+-------------------------------------------------------------------------
//  Open the cert store using the specified store provider.
//
//  hCryptProv specifies the crypto provider to use to create the hash
//  properties or verify the signature of a subject certificate or CRL.
//  The store doesn't need to use a private
//  key. If the CERT_STORE_NO_CRYPT_RELEASE_FLAG isn't set, hCryptProv is
//  CryptReleaseContext'ed on the final CertCloseStore.
//
//  Note, if the open fails, hCryptProv is released if it would have been
//  released when the store was closed.
//
//  If hCryptProv is zero, then, the default provider and container for the
//  PROV_RSA_FULL provider type is CryptAcquireContext'ed with
//  CRYPT_VERIFYCONTEXT access. The CryptAcquireContext is deferred until
//  the first create hash or verify signature. In addition, once acquired,
//  the default provider isn't released until process exit when crypt32.dll
//  is unloaded. The acquired default provider is shared across all stores
//  and threads.
//
//  Use of the dwEncodingType parameter is provider dependent. The type
//  definition for pvPara also depends on the provider.
//--------------------------------------------------------------------------
HCERTSTORE
WINAPI
CertOpenStore(
    IN LPCSTR lpszStoreProvider,
    IN DWORD dwEncodingType,
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwFlags,
    IN const void *pvPara
    )
{
    PCERT_STORE pStore;
    PFN_CERT_DLL_OPEN_STORE_PROV_FUNC pfnOpenStoreProv;
    BOOL fShareStore = FALSE;

    // LocalMachine System stores opened for SHARE and MAXIMUM_ALLOWED can
    // be shared. 
    if ((CERT_SYSTEM_STORE_LOCAL_MACHINE |
            CERT_STORE_SHARE_STORE_FLAG |
            CERT_STORE_SHARE_CONTEXT_FLAG |
            CERT_STORE_MAXIMUM_ALLOWED_FLAG
            ) == dwFlags
                    &&
            0 == hCryptProv
            ) {
        if (0xFFFF < (DWORD_PTR) lpszStoreProvider) {
            if (0 == _stricmp(sz_CERT_STORE_PROV_SYSTEM_W,
                    lpszStoreProvider))
                fShareStore = TRUE;
        } else {
            if (CERT_STORE_PROV_SYSTEM_W == lpszStoreProvider)
                fShareStore = TRUE;
        }

        if (fShareStore) {
            if (pStore = FindShareStore((LPCWSTR) pvPara))
                return (HCERTSTORE) pStore;
        }
                
    }

    pStore = (PCERT_STORE) PkiZeroAlloc(sizeof(*pStore));
    if (pStore) {
        if (!Pki_InitializeCriticalSection(&pStore->CriticalSection)) {
            PkiFree(pStore);
            pStore = NULL;
        }
    }
    if (pStore == NULL) {
        if (hCryptProv && (dwFlags & CERT_STORE_NO_CRYPT_RELEASE_FLAG) == 0)
            CryptReleaseContext(hCryptProv, 0);
        return NULL;
    }

    CertPerfIncrementStoreTotalCount();
    CertPerfIncrementStoreCurrentCount();

    pStore->StoreProvInfo.cbSize = sizeof(CERT_STORE_PROV_INFO);
    pStore->dwStoreType = STORE_TYPE_CACHE;
    pStore->lRefCnt = 1;
    pStore->dwState = STORE_STATE_OPENING;
    pStore->hCryptProv = hCryptProv;
    pStore->dwFlags = dwFlags;

    if (CERT_STORE_PROV_MEMORY == lpszStoreProvider)
        pStore->StoreProvInfo.dwStoreProvFlags |=
            CERT_STORE_PROV_NO_PERSIST_FLAG;
    else {
        if (!CryptGetOIDFunctionAddress(
                hOpenStoreProvFuncSet,
                0,                      // dwEncodingType,
                lpszStoreProvider,
                0,                      // dwFlags
                (void **) &pfnOpenStoreProv,
                &pStore->hStoreProvFuncAddr))
            goto GetOIDFuncAddrError;
        if (!pfnOpenStoreProv(
                lpszStoreProvider,
                dwEncodingType,
                hCryptProv,
                dwFlags & ~CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                pvPara,
                (HCERTSTORE) pStore,
                &pStore->StoreProvInfo)) {
            if (0 == (dwFlags & CERT_STORE_MAXIMUM_ALLOWED_FLAG))
                goto OpenStoreProvError;

            pStore->hCryptProv = NULL;
            CertCloseStore((HCERTSTORE) pStore, 0);

            return CertOpenStore(
                lpszStoreProvider,
                dwEncodingType,
                hCryptProv,
                (dwFlags & ~CERT_STORE_MAXIMUM_ALLOWED_FLAG) |
                    CERT_STORE_READONLY_FLAG,
                pvPara
                );
        }

        if (pStore->StoreProvInfo.dwStoreProvFlags &
                CERT_STORE_PROV_EXTERNAL_FLAG) {
            assert(STORE_TYPE_CACHE == pStore->dwStoreType &&
                IsEmptyStore(pStore));
            pStore->dwStoreType = STORE_TYPE_EXTERNAL;
        }

        if ((dwFlags & CERT_STORE_MANIFOLD_FLAG) &&
                STORE_TYPE_CACHE == pStore->dwStoreType)
            ArchiveManifoldCertificatesInStore(pStore);
    }

    if (dwFlags & CERT_STORE_DELETE_FLAG) {
        if (0 == (pStore->StoreProvInfo.dwStoreProvFlags &
                CERT_STORE_PROV_DELETED_FLAG))
            goto DeleteNotSupported;
        CertCloseStore((HCERTSTORE) pStore, 0);
        pStore = NULL;
        SetLastError(0);
    } else {
        pStore->dwState = STORE_STATE_OPEN;

        if (fShareStore)
            CreateShareStore((LPCWSTR) pvPara, pStore);

    }

CommonReturn:
    return (HCERTSTORE) pStore;

ErrorReturn:
    CertCloseStore((HCERTSTORE) pStore, 0);
    pStore = NULL;
    if (dwFlags & CERT_STORE_DELETE_FLAG) {
        if (0 == GetLastError())
            SetLastError((DWORD) E_UNEXPECTED);
    }
    goto CommonReturn;

TRACE_ERROR(GetOIDFuncAddrError)
TRACE_ERROR(OpenStoreProvError)
SET_ERROR(DeleteNotSupported, ERROR_CALL_NOT_IMPLEMENTED)
}

//+-------------------------------------------------------------------------
//  Duplicate a cert store handle
//--------------------------------------------------------------------------
HCERTSTORE
WINAPI
CertDuplicateStore(
    IN HCERTSTORE hCertStore
    )
{
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;
    assert(pStore->dwState == STORE_STATE_OPEN ||
        pStore->dwState == STORE_STATE_OPENING ||
        pStore->dwState == STORE_STATE_DEFER_CLOSING ||
        pStore->dwState == STORE_STATE_NULL);
    InterlockedIncrement(&pStore->lRefCnt);
    return hCertStore;
}

//+-------------------------------------------------------------------------
//  Checks if the store has any Certs, CRLs, CTLs, collection stores or
//  links
//--------------------------------------------------------------------------
STATIC BOOL IsEmptyStore(
    IN PCERT_STORE pStore
    )
{
    DWORD i;

    // Check that all the context lists are empty
    for (i = 0; i < CONTEXT_COUNT; i++) {
        if (pStore->rgpContextListHead[i])
            return FALSE;
    }

    // For collection, check that all stores have been removed
    if (pStore->pStoreListHead)
        return FALSE;

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Free the store if empty
//
//  Store is locked upon input and unlocked or freed upon returning
//--------------------------------------------------------------------------
STATIC void FreeStore(
    IN PCERT_STORE pStore)
{
    if (STORE_STATE_DEFER_CLOSING == pStore->dwState) {
        // Check if duplicated context reference count is zero.
        InterlockedIncrement(&pStore->lDeferCloseRefCnt);
        if (InterlockedDecrement(&pStore->lDeferCloseRefCnt) == 0)
            CloseStore(pStore, 0);
        else
            UnlockStore(pStore);
    } else if (STORE_STATE_CLOSED == pStore->dwState && IsEmptyStore(pStore)) {
        UnlockStore(pStore);
        pStore->dwState = STORE_STATE_DELETED;
        assert(NULL == pStore->pShareStore);
        if (pStore->hAutoResyncEvent)
            CloseHandle(pStore->hAutoResyncEvent);
        DeleteCriticalSection(&pStore->CriticalSection);
        PkiFree(pStore);
    } else
        UnlockStore(pStore);
}

//  Store is locked upon input and unlocked or freed upon returning
STATIC BOOL CloseStore(
    IN PCERT_STORE pStore,
    DWORD dwFlags
    )
{
    DWORD dwFailFlags = 0;
    DWORD i;
    PCONTEXT_ELEMENT pFreeLinkEleHead;
    PCERT_STORE_LINK pStoreLink;
    PCERT_STORE_LINK pFreeStoreLinkHead;
    PPROP_ELEMENT pPropEle;
    DWORD cStoreProvFunc;
    BOOL fFreeFindNext;

    PFN_CERT_STORE_PROV_CLOSE pfnStoreProvClose;
    HCRYPTPROV hCryptProv;

    assert(pStore);
    assert(NULL == pStore->pShareStore);

    CertPerfDecrementStoreCurrentCount();

    // Assert that another thread isn't already waiting for a provider
    // function to complete.
    assert(NULL == pStore->hStoreProvWait);
    // Assert that another thread isn't already waiting for a provider
    // to return from its close callback.
    assert(pStore->dwState != STORE_STATE_CLOSING &&
         pStore->dwState != STORE_STATE_CLOSED);
    if (pStore->hStoreProvWait || pStore->dwState == STORE_STATE_CLOSING ||
            pStore->dwState == STORE_STATE_CLOSED)
        goto UnexpectedError;

    assert(pStore->dwState == STORE_STATE_OPEN ||
        pStore->dwState == STORE_STATE_OPENING ||
        pStore->dwState == STORE_STATE_DEFER_CLOSING);
    pStore->dwState = STORE_STATE_CLOSING;

    cStoreProvFunc = pStore->StoreProvInfo.cStoreProvFunc;
    // By setting the following to 0 inhibits anyone else from calling
    // the provider's functions.
    pStore->StoreProvInfo.cStoreProvFunc = 0;
    if (cStoreProvFunc > CERT_STORE_PROV_CLOSE_FUNC)
        pfnStoreProvClose = (PFN_CERT_STORE_PROV_CLOSE)
                pStore->StoreProvInfo.rgpvStoreProvFunc[
                    CERT_STORE_PROV_CLOSE_FUNC];
    else
        pfnStoreProvClose = NULL;

    hCryptProv = pStore->hCryptProv;
    // By setting the following to 0 inhibits anyone else from using
    // the store's CryptProv handle
    pStore->hCryptProv = 0;

    fFreeFindNext = FALSE;
    if (STORE_TYPE_EXTERNAL == pStore->dwStoreType) {
        // Check if any FIND_NEXT external elements are remaining to be freed
        for (i = 0; i < CONTEXT_COUNT; i++) {
            PCONTEXT_ELEMENT pEle = pStore->rgpContextListHead[i];
            for ( ; pEle; pEle = pEle->pNext) {
                if (pEle->dwFlags & ELEMENT_FIND_NEXT_FLAG) {
                    pEle->dwFlags &= ~ELEMENT_FIND_NEXT_FLAG;
                    pEle->dwFlags |= ELEMENT_CLOSE_FIND_NEXT_FLAG;
                    AddRefContextElement(pEle);
                    fFreeFindNext = TRUE;
                }
            }
        }
    }

    if (pStore->lStoreProvRefCnt) {
        // Wait for all the provider functions to complete and all
        // uses of the hCryptProv handle to finish
        if (NULL == (pStore->hStoreProvWait = CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL))) {   // lpszEventName
            assert(pStore->hStoreProvWait);
            goto UnexpectedError;
        }

        while (pStore->lStoreProvRefCnt) {
            UnlockStore(pStore);
            WaitForSingleObject(pStore->hStoreProvWait, INFINITE);
            LockStore(pStore);
        }
        CloseHandle(pStore->hStoreProvWait);
        pStore->hStoreProvWait = NULL;
    }

    if (fFreeFindNext) {
        // Call the provider to free the FIND_NEXT element. Must call
        // without holding a store lock.
        for (i = 0; i < CONTEXT_COUNT; i++) {
            const DWORD dwStoreProvFreeFindIndex =
                rgdwStoreProvFreeFindIndex[i];
            PCONTEXT_ELEMENT pEle = pStore->rgpContextListHead[i];
            while (pEle) {
                if (pEle->dwFlags & ELEMENT_CLOSE_FIND_NEXT_FLAG) {
                    PCONTEXT_ELEMENT pEleFree = pEle;
                    PFN_CERT_STORE_PROV_FREE_FIND_CERT pfnStoreProvFreeFindCert;

                    pEle = pEle->pNext;
                    while (pEle && 0 ==
                            (pEle->dwFlags & ELEMENT_CLOSE_FIND_NEXT_FLAG))
                        pEle = pEle->pNext;

                    UnlockStore(pStore);
                    if (dwStoreProvFreeFindIndex < cStoreProvFunc &&
                            NULL != (pfnStoreProvFreeFindCert =
                                (PFN_CERT_STORE_PROV_FREE_FIND_CERT)
                            pStore->StoreProvInfo.rgpvStoreProvFunc[
                                dwStoreProvFreeFindIndex]))
                        pfnStoreProvFreeFindCert(
                            pStore->StoreProvInfo.hStoreProv,
                            ToCertContext(pEleFree->pEle),
                            pEleFree->External.pvProvInfo,
                            0                       // dwFlags
                            );
                    ReleaseContextElement(pEleFree);
                    LockStore(pStore);
                } else
                    pEle = pEle->pNext;
            }
        }
    }

    if (pfnStoreProvClose) {
        // To prevent any type of deadlock, call the provider functions
        // without a lock on the store.
        //
        // Note our state is CLOSING, not CLOSED. This prevents any other
        // calls to FreeStore() from prematurely deleting the store.
        UnlockStore(pStore);
        pfnStoreProvClose(pStore->StoreProvInfo.hStoreProv, dwFlags);
        LockStore(pStore);
    }

    if (pStore->hStoreProvFuncAddr)
        CryptFreeOIDFunctionAddress(pStore->hStoreProvFuncAddr, 0);
    if (pStore->StoreProvInfo.hStoreProvFuncAddr2)
        CryptFreeOIDFunctionAddress(
            pStore->StoreProvInfo.hStoreProvFuncAddr2, 0);

    // Since hCryptProv was passed to the provider it must be released
    // last!!!
    if (hCryptProv &&
            0 == (pStore->dwFlags & CERT_STORE_NO_CRYPT_RELEASE_FLAG))
        CryptReleaseContext(hCryptProv, 0);

    // Iterate through the elements. If the element hasn't already been
    // deleted, remove the store's reference on the element. Remove and
    // free if no other references.
    pFreeLinkEleHead = NULL;
    for (i = 0; i < CONTEXT_COUNT; i++) {
        PCONTEXT_ELEMENT pEle = pStore->rgpContextListHead[i];
        while (pEle) {
            PCONTEXT_ELEMENT pEleNext = pEle->pNext;
            if (0 == (pEle->dwFlags & ELEMENT_DELETED_FLAG)) {
                if (0 == InterlockedDecrement(&pEle->lRefCnt)) {
                    if (ELEMENT_TYPE_LINK_CONTEXT == pEle->dwElementType) {
                        // The LINK_CONTEXT can't be freed while holding
                        // the store lock. Will free later after unlocking.
                        RemoveContextElement(pEle);
                        pEle->pNext = pFreeLinkEleHead;
                        pFreeLinkEleHead = pEle;
                    } else {
                        assert(ELEMENT_TYPE_CACHE == pEle->dwElementType);
                        RemoveAndFreeContextElement(pEle);
                    }
                } else
                    //  Still a reference on the element
                    pEle->dwFlags |= ELEMENT_DELETED_FLAG;
            }
            // else
            //  A previous delete has already removed the store's reference

            pEle = pEleNext;
        }
    }

    // Iterate through the store links. If the store link hasn't already been
    // deleted, remove the store's reference on the link. Remove and free
    // if no other references.
    pFreeStoreLinkHead = NULL;
    pStoreLink = pStore->pStoreListHead;
    while (pStoreLink) {
        PCERT_STORE_LINK pStoreLinkNext = pStoreLink->pNext;

        if (0 == (pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG)) {
            if (0 == InterlockedDecrement(&pStoreLink->lRefCnt)) {
                // The STORE_LINK can't be freed while holding
                // the store lock. Will free later after unlocking.
                RemoveStoreLink(pStoreLink);
                pStoreLink->pNext = pFreeStoreLinkHead;
                pFreeStoreLinkHead = pStoreLink;
            } else
                //  Still a reference on the store link
                pStoreLink->dwFlags |= STORE_LINK_DELETED_FLAG;
        }
        // else
        //  A previous delete has already removed the store's reference

        pStoreLink = pStoreLinkNext;
    }

    if (pFreeLinkEleHead || pFreeStoreLinkHead) {
        // Unlock the store before freeing links
        UnlockStore(pStore);
        while (pFreeLinkEleHead) {
            PCONTEXT_ELEMENT pEle = pFreeLinkEleHead;
            pFreeLinkEleHead = pFreeLinkEleHead->pNext;
            FreeLinkContextElement(pEle);
        }

        while (pFreeStoreLinkHead) {
            pStoreLink = pFreeStoreLinkHead;
            pFreeStoreLinkHead = pFreeStoreLinkHead->pNext;

            if (pStore->hAutoResyncEvent) {
                CertControlStore(
                    (HCERTSTORE) pStoreLink->pSibling,
                    0,                              // dwFlags
                    CERT_STORE_CTRL_CANCEL_NOTIFY,
                    &pStore->hAutoResyncEvent
                    );
            }

            FreeStoreLink(pStoreLink);
        }

        LockStore(pStore);
    }

    // Free the store's property elements
    while (pPropEle = pStore->pPropHead) {
        RemovePropElement(&pStore->pPropHead, pPropEle);
        FreePropElement(pPropEle);
    }

    if (dwFlags & CERT_CLOSE_STORE_CHECK_FLAG) {
        if (!IsEmptyStore(pStore))
            dwFailFlags = CERT_CLOSE_STORE_CHECK_FLAG;
    }

    if (dwFlags & CERT_CLOSE_STORE_FORCE_FLAG) {
        UnlockStore(pStore);

        for (i = 0; i < CONTEXT_COUNT; i++) {
            PCONTEXT_ELEMENT pEle;
            while (pEle = pStore->rgpContextListHead[i]) {
                if (ELEMENT_TYPE_CACHE == pEle->dwElementType)
                    RemoveAndFreeContextElement(pEle);
                else
                    RemoveAndFreeLinkElement(pEle);
            }
        }

        while (pStoreLink = pStore->pStoreListHead)
            RemoveAndFreeStoreLink(pStoreLink);

        LockStore(pStore);
        assert(IsEmptyStore(pStore));
    }

    pStore->dwState = STORE_STATE_CLOSED;
    // Either frees or unlocks the store
    FreeStore(pStore);

    if (dwFlags & dwFailFlags) {
        SetLastError((DWORD) CRYPT_E_PENDING_CLOSE);
        return FALSE;
    } else
        return TRUE;

UnexpectedError:
    UnlockStore(pStore);
    SetLastError((DWORD) E_UNEXPECTED);
    return FALSE;
}

//+-------------------------------------------------------------------------
//  Close a cert store handle.
//
//  There needs to be a corresponding close for each open and duplicate.
//
//  Even on the final close, the cert store isn't freed until all of its
//  certificate, CRL and CTL contexts have also been freed.
//
//  On the final close, the hCryptProv passed to CertOpenStore is
//  CryptReleaseContext'ed.
//
//  LastError is preserved unless CERT_CLOSE_STORE_CHECK_FLAG is set and FALSE
//  is returned.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertCloseStore(
    IN HCERTSTORE hCertStore,
    DWORD dwFlags
    )
{
    BOOL fResult;
    BOOL fClose;
    BOOL fPendingError = FALSE;
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;
    DWORD dwErr = GetLastError();   // For success, don't globber LastError

    if (pStore == NULL)
        return TRUE;

    if (dwFlags & CERT_CLOSE_STORE_FORCE_FLAG) {
        LockStore(pStore);
        if (pStore->lRefCnt != 1) {
            if (dwFlags & CERT_CLOSE_STORE_CHECK_FLAG)
                fPendingError = TRUE;
        }
        pStore->lRefCnt = 0;
    } else if (InterlockedDecrement(&pStore->lRefCnt) == 0) {
        LockStore(pStore);
        if (pStore->dwFlags & CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG) {
            // Check if duplicated context reference count is zero.
            InterlockedIncrement(&pStore->lDeferCloseRefCnt);
            if (InterlockedDecrement(&pStore->lDeferCloseRefCnt) != 0) {
                assert(pStore->dwState == STORE_STATE_OPEN ||
                    pStore->dwState == STORE_STATE_OPENING ||
                    pStore->dwState == STORE_STATE_DEFER_CLOSING);
                pStore->dwState = STORE_STATE_DEFER_CLOSING;
                UnlockStore(pStore);
                goto PendingCloseReturn;
            }
        }
    } else
        // Still holding a reference count on the store
        goto PendingCloseReturn;

    if (pStore->pShareStore) {
        assert(0 == (dwFlags & CERT_CLOSE_STORE_FORCE_FLAG));
        // There's a window where the shared store's RefCnt can be incremented
        // before being removed from the linked list of share stores.
        fClose = CloseShareStore(pStore);
    } else
        fClose = TRUE;


    // Don't allow the NULL store to be closed
    assert(pStore->dwState != STORE_STATE_NULL);
    if (pStore->dwState == STORE_STATE_NULL) {
        pStore->lRefCnt = 1;
        UnlockStore(pStore);
        SetLastError((DWORD) E_UNEXPECTED);
        return FALSE;
    }

    // CloseStore() unlocks or frees store
    if (fClose)
        fResult = CloseStore(pStore, dwFlags);
    else {
        fResult = TRUE;
        UnlockStore(pStore);
    }

    if (fResult) {
        if (fPendingError) {
            fResult = FALSE;
            SetLastError((DWORD) CRYPT_E_PENDING_CLOSE);
        } else
            SetLastError(dwErr);
    }
    return fResult;

PendingCloseReturn:
    if (dwFlags & CERT_CLOSE_STORE_CHECK_FLAG) {
        SetLastError((DWORD) CRYPT_E_PENDING_CLOSE);
        fResult = FALSE;
    } else
        fResult = TRUE;
    return fResult;
}

//+=========================================================================
//  ArchiveManifoldCertificatesInStore
//==========================================================================

#define SORTED_MANIFOLD_ALLOC_COUNT     25

typedef struct _SORTED_MANIFOLD_ENTRY {
    PCCERT_CONTEXT      pCert;
    CRYPT_OBJID_BLOB    Value;
} SORTED_MANIFOLD_ENTRY, *PSORTED_MANIFOLD_ENTRY;

//+-------------------------------------------------------------------------
//  Called by qsort.
//
//  The Manifold entries are sorted according to manifold value and
//  the certificate's NotAfter and NotBefore times.
//--------------------------------------------------------------------------
STATIC int __cdecl CompareManifoldEntry(
    IN const void *pelem1,
    IN const void *pelem2
    )
{
    PSORTED_MANIFOLD_ENTRY p1 = (PSORTED_MANIFOLD_ENTRY) pelem1;
    PSORTED_MANIFOLD_ENTRY p2 = (PSORTED_MANIFOLD_ENTRY) pelem2;

    DWORD cb1 = p1->Value.cbData;
    DWORD cb2 = p2->Value.cbData;

    if (cb1 == cb2) {
        int iCmp;

        if (0 == cb1)
            iCmp = 0;
        else
            iCmp = memcmp(p1->Value.pbData, p2->Value.pbData, cb1);

        if (0 != iCmp)
            return iCmp;

        // Same manifold value. Compare the certificate NotAfter and
        // NotBefore times.
        iCmp = CompareFileTime(&p1->pCert->pCertInfo->NotAfter,
            &p2->pCert->pCertInfo->NotAfter);
        if (0 == iCmp)
            iCmp = CompareFileTime(&p1->pCert->pCertInfo->NotBefore,
                &p2->pCert->pCertInfo->NotBefore);
        return iCmp;
    } else if (cb1 < cb2)
        return -1;
    else
        return 1;
}

void ArchiveManifoldCertificatesInStore(
    IN PCERT_STORE pStore
    )
{
    PCONTEXT_ELEMENT pEle;
    DWORD cAlloc = 0;
    DWORD cManifold = 0;
    PSORTED_MANIFOLD_ENTRY pManifold = NULL;

    assert(STORE_TYPE_CACHE == pStore->dwStoreType);
    LockStore(pStore);

    // Create an array of non-archived certificates having the Manifold
    // extension
    pEle = pStore->rgpContextListHead[CERT_STORE_CERTIFICATE_CONTEXT - 1];
    for ( ; pEle; pEle = pEle->pNext) {
        PCCERT_CONTEXT pCert;
        PCERT_INFO pCertInfo;
        PCERT_EXTENSION pExt;

        assert(ELEMENT_TYPE_CACHE == pEle->dwElementType ||
            ELEMENT_TYPE_LINK_CONTEXT == pEle->dwElementType);

        // Skip past deleted or archived elements
        if (pEle->dwFlags & (ELEMENT_DELETED_FLAG | ELEMENT_ARCHIVED_FLAG))
            continue;

        pCert = ToCertContext(pEle);
        pCertInfo = pCert->pCertInfo;

        if (pExt = CertFindExtension(
                szOID_CERT_MANIFOLD,
                pCertInfo->cExtension,
                pCertInfo->rgExtension
                )) {
            if (cManifold >= cAlloc) {
                PSORTED_MANIFOLD_ENTRY pNewManifold;

                if (NULL == (pNewManifold = (PSORTED_MANIFOLD_ENTRY) PkiRealloc(
                        pManifold, (cAlloc + SORTED_MANIFOLD_ALLOC_COUNT) *
                            sizeof(SORTED_MANIFOLD_ENTRY))))
                    continue;
                pManifold = pNewManifold;
                cAlloc += SORTED_MANIFOLD_ALLOC_COUNT;
            }
            pManifold[cManifold].pCert =
                CertDuplicateCertificateContext(pCert);
            pManifold[cManifold].Value = pExt->Value;
            cManifold++;
        }
    }

    UnlockStore(pStore);

    if (cManifold) {
        const CRYPT_DATA_BLOB ManifoldBlob = { 0, NULL };

        // Sort the Manifold entries according to manifold value and
        // the certificate's NotAfter and NotBefore times.
        qsort(pManifold, cManifold, sizeof(SORTED_MANIFOLD_ENTRY),
            CompareManifoldEntry);

        // Set the Archive property for previous entries having the same
        // manifold value.
        for (DWORD i = 0; i < cManifold - 1; i++) {
            if (pManifold[i].Value.cbData == pManifold[i+1].Value.cbData &&
                    (0 == pManifold[i].Value.cbData ||
                        0 == memcmp(pManifold[i].Value.pbData,
                            pManifold[i+1].Value.pbData,
                            pManifold[i].Value.cbData)))
                CertSetCertificateContextProperty(
                    pManifold[i].pCert,
                    CERT_ARCHIVED_PROP_ID,
                    CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG,
                    (const void *) &ManifoldBlob
                    );
        }

        while (cManifold--)
            CertFreeCertificateContext(pManifold[cManifold].pCert);

        PkiFree(pManifold);
    }
}

//+-------------------------------------------------------------------------
//  Write the CERT, CRL, CTL, PROP or END element to the file or memory
//
//  Upon entry/exit the store is locked.
//--------------------------------------------------------------------------
STATIC BOOL WriteStoreElement(
    IN HANDLE h,
    IN PFNWRITE pfnWrite,
    IN DWORD dwEncodingType,
    IN DWORD dwEleType,
    IN BYTE *pbData,
    IN DWORD cbData
    )
{
    FILE_ELEMENT_HDR EleHdr;
    BOOL fResult;

    EleHdr.dwEleType = dwEleType;
    EleHdr.dwEncodingType = dwEncodingType;
    EleHdr.dwLen = cbData;
    assert(cbData <= MAX_FILE_ELEMENT_DATA_LEN);
    fResult = pfnWrite(
        h,
        &EleHdr,
        sizeof(EleHdr)
        );
    if (fResult && cbData > 0)
        fResult = pfnWrite(
                h,
                pbData,
                cbData
                );

    return fResult;
}

//+-------------------------------------------------------------------------
//  Serialize the certs, CRLs, CTLs and properties in the store. Prepend with a
//  file header and append with an end element.
//--------------------------------------------------------------------------
STATIC BOOL SerializeStore(
    IN HANDLE h,
    IN PFNWRITE pfnWrite,
    IN PCERT_STORE pStore
    )
{
    BOOL fResult;

    DWORD i;
    FILE_HDR FileHdr;

    FileHdr.dwVersion = CERT_FILE_VERSION_0;
    FileHdr.dwMagic = CERT_MAGIC;
    if (!pfnWrite(h, &FileHdr, sizeof(FileHdr))) goto WriteError;

    for (i = 0; i < CONTEXT_COUNT; i++) {
        PCONTEXT_ELEMENT pEle = NULL;
        while (pEle = FindElementInStore(pStore, i, &FindAnyInfo, pEle)) {
            if (!SerializeStoreElement(h, pfnWrite, pEle)) {
                ReleaseContextElement(pEle);
                goto SerializeError;
            }
        }
    }

    if (!WriteStoreElement(
            h,
            pfnWrite,
            0,                      // dwEncodingType
            FILE_ELEMENT_END_TYPE,
            NULL,                   // pbData
            0                       // cbData
            )) goto WriteError;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(WriteError)
TRACE_ERROR(SerializeError)
}


//+-------------------------------------------------------------------------
//  Called by CertStoreSaveEx for CERT_STORE_SAVE_AS_STORE
//--------------------------------------------------------------------------
STATIC BOOL SaveAsStore(
    IN PCERT_STORE pStore,
    IN DWORD dwSaveTo,
    IN OUT void *pvSaveToPara,
    IN DWORD dwFlags
    )
{
    BOOL fResult;

    switch (dwSaveTo) {
        case CERT_STORE_SAVE_TO_FILE:
            fResult = SerializeStore(
                (HANDLE) pvSaveToPara,
                WriteToFile,
                pStore);
            break;
        case CERT_STORE_SAVE_TO_MEMORY:
            {
                PCRYPT_DATA_BLOB pData = (PCRYPT_DATA_BLOB) pvSaveToPara;
                MEMINFO MemInfo;

                MemInfo.pByte = pData->pbData;
                if (NULL == pData->pbData)
                    MemInfo.cb = 0;
                else
                    MemInfo.cb = pData->cbData;
                MemInfo.cbSeek = 0;

                if (fResult = SerializeStore(
                        (HANDLE) &MemInfo,
                        WriteToMemory,
                        pStore)) {
                    if (MemInfo.cbSeek > MemInfo.cb && pData->pbData) {
                        SetLastError((DWORD) ERROR_MORE_DATA);
                        fResult = FALSE;
                    }
                    pData->cbData = MemInfo.cbSeek;
                } else
                    pData->cbData = 0;
            }
            break;
        default:
            SetLastError((DWORD) E_UNEXPECTED);
            fResult = FALSE;
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Following routines support the SaveAsPKCS7 function
//--------------------------------------------------------------------------

STATIC void FreeSaveAsPKCS7Info(
    IN PCMSG_SIGNED_ENCODE_INFO pInfo,
    IN PCCERT_CONTEXT *ppCert,
    IN PCCRL_CONTEXT *ppCrl
    )
{
    DWORD dwIndex;

    dwIndex = pInfo->cCertEncoded;
    while (dwIndex--)
        CertFreeCertificateContext(ppCert[dwIndex]);
    PkiFree(ppCert);
    PkiFree(pInfo->rgCertEncoded);
    pInfo->cCertEncoded = 0;
    pInfo->rgCertEncoded = NULL;

    dwIndex = pInfo->cCrlEncoded;
    while (dwIndex--)
        CertFreeCRLContext(ppCrl[dwIndex]);
    PkiFree(ppCrl);
    PkiFree(pInfo->rgCrlEncoded);
    pInfo->cCrlEncoded = 0;
    pInfo->rgCrlEncoded = NULL;
}

#define SAVE_AS_PKCS7_ALLOC_COUNT    50

// Upon entry: store is unlocked
STATIC BOOL InitSaveAsPKCS7Info(
    IN PCERT_STORE pStore,
    IN OUT PCMSG_SIGNED_ENCODE_INFO pInfo,
    OUT PCCERT_CONTEXT **pppCert,
    OUT PCCRL_CONTEXT **pppCrl
    )
{
    BOOL fResult;
    DWORD cAlloc;
    DWORD dwIndex;
    PCRYPT_DATA_BLOB pBlob;

    PCCERT_CONTEXT pCert = NULL;
    PCCERT_CONTEXT *ppCert = NULL;
    PCCRL_CONTEXT pCrl = NULL;
    PCCRL_CONTEXT *ppCrl = NULL;

    memset(pInfo, 0, sizeof(CMSG_SIGNED_ENCODE_INFO));
    pInfo->cbSize = sizeof(CMSG_SIGNED_ENCODE_INFO);

    dwIndex = 0;
    cAlloc = 0;
    pBlob = NULL;
    while (pCert = CertEnumCertificatesInStore((HCERTSTORE) pStore, pCert)) {
        if (dwIndex >= cAlloc) {
            PCRYPT_DATA_BLOB pNewBlob;
            PCCERT_CONTEXT *ppNewCert;

            if (NULL == (pNewBlob = (PCRYPT_DATA_BLOB) PkiRealloc(
                    pBlob, (cAlloc + SAVE_AS_PKCS7_ALLOC_COUNT) *
                        sizeof(CRYPT_DATA_BLOB))))
                goto OutOfMemory;
            pBlob = pNewBlob;
            pInfo->rgCertEncoded = pBlob;

            if (NULL == (ppNewCert = (PCCERT_CONTEXT *) PkiRealloc(
                    ppCert, (cAlloc + SAVE_AS_PKCS7_ALLOC_COUNT) *
                        sizeof(PCCERT_CONTEXT))))
                goto OutOfMemory;
            ppCert = ppNewCert;

            cAlloc += SAVE_AS_PKCS7_ALLOC_COUNT;
        }
        ppCert[dwIndex] = CertDuplicateCertificateContext(pCert);
        pBlob[dwIndex].pbData = pCert->pbCertEncoded;
        pBlob[dwIndex].cbData = pCert->cbCertEncoded;
        pInfo->cCertEncoded = ++dwIndex;
    }

    dwIndex = 0;
    cAlloc = 0;
    pBlob = NULL;
    while (pCrl = CertEnumCRLsInStore((HCERTSTORE) pStore, pCrl)) {
        if (dwIndex >= cAlloc) {
            PCRYPT_DATA_BLOB pNewBlob;
            PCCRL_CONTEXT *ppNewCrl;

            if (NULL == (pNewBlob = (PCRYPT_DATA_BLOB) PkiRealloc(
                    pBlob, (cAlloc + SAVE_AS_PKCS7_ALLOC_COUNT) *
                        sizeof(CRYPT_DATA_BLOB))))
                goto OutOfMemory;
            pBlob = pNewBlob;
            pInfo->rgCrlEncoded = pBlob;

            if (NULL == (ppNewCrl = (PCCRL_CONTEXT *) PkiRealloc(
                    ppCrl, (cAlloc + SAVE_AS_PKCS7_ALLOC_COUNT) *
                        sizeof(PCCRL_CONTEXT))))
                goto OutOfMemory;
            ppCrl = ppNewCrl;

            cAlloc += SAVE_AS_PKCS7_ALLOC_COUNT;
        }
        ppCrl[dwIndex] = CertDuplicateCRLContext(pCrl);
        pBlob[dwIndex].pbData = pCrl->pbCrlEncoded;
        pBlob[dwIndex].cbData = pCrl->cbCrlEncoded;
        pInfo->cCrlEncoded = ++dwIndex;
    }

    fResult = TRUE;
CommonReturn:
    *pppCert = ppCert;
    *pppCrl = ppCrl;
    return fResult;
ErrorReturn:
    if (pCert)
        CertFreeCertificateContext(pCert);
    if (pCrl)
        CertFreeCRLContext(pCrl);
    FreeSaveAsPKCS7Info(pInfo, ppCert, ppCrl);
    ppCert = NULL;
    ppCrl = NULL;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
}

STATIC BOOL EncodePKCS7(
    IN DWORD dwEncodingType,
    IN PCMSG_SIGNED_ENCODE_INFO pInfo,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult = TRUE;
    DWORD cbEncoded;

    if (NULL == pbEncoded)
        cbEncoded = 0;
    else
        cbEncoded = *pcbEncoded;

    if (0 == cbEncoded)
        cbEncoded = CryptMsgCalculateEncodedLength(
            dwEncodingType,
            0,                      // dwFlags
            CMSG_SIGNED,
            pInfo,
            NULL,                   // pszInnerContentObjID
            0                       // cbData
            );
    else {
        HCRYPTMSG hMsg;
        if (NULL == (hMsg = CryptMsgOpenToEncode(
                dwEncodingType,
                0,                  // dwFlags
                CMSG_SIGNED,
                pInfo,
                NULL,               // pszInnerContentObjID
                NULL                // pStreamInfo
                )))
            cbEncoded = 0;
        else {
            if (CryptMsgUpdate(
                    hMsg,
                    NULL,       // pbData
                    0,          // cbData
                    TRUE        // fFinal
                    ))
                fResult = CryptMsgGetParam(
                    hMsg,
                    CMSG_CONTENT_PARAM,
                    0,              // dwIndex
                    pbEncoded,
                    &cbEncoded);
            else
                cbEncoded = 0;
            CryptMsgClose(hMsg);
        }

    }

    if (fResult) {
        if (0 == cbEncoded)
            fResult = FALSE;
        else if (pbEncoded && cbEncoded > *pcbEncoded) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        }
    }
    *pcbEncoded = cbEncoded;
    return fResult;
}


//+-------------------------------------------------------------------------
//  Called by CertStoreSaveEx for CERT_STORE_SAVE_AS_PKCS7
//--------------------------------------------------------------------------
STATIC BOOL SaveAsPKCS7(
    IN PCERT_STORE pStore,
    IN DWORD dwEncodingType,
    IN DWORD dwSaveTo,
    IN OUT void *pvSaveToPara,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    CMSG_SIGNED_ENCODE_INFO SignedEncodeInfo;
    PCCERT_CONTEXT *ppCert;
    PCCRL_CONTEXT *ppCrl;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    if (0 == GET_CERT_ENCODING_TYPE(dwEncodingType) ||
            0 == GET_CMSG_ENCODING_TYPE(dwEncodingType)) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    if (!InitSaveAsPKCS7Info(
            pStore,
            &SignedEncodeInfo,
            &ppCert,
            &ppCrl)) goto InitInfoError;

    switch (dwSaveTo) {
        case CERT_STORE_SAVE_TO_FILE:
            if (!EncodePKCS7(
                    dwEncodingType,
                    &SignedEncodeInfo,
                    NULL,               // pbEncoded
                    &cbEncoded)) goto EncodePKCS7Error;
            if (NULL == (pbEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
                goto OutOfMemory;
            if (!EncodePKCS7(
                    dwEncodingType,
                    &SignedEncodeInfo,
                    pbEncoded,
                    &cbEncoded))
                goto EncodePKCS7Error;
             else {
                DWORD cbBytesWritten;
                if (!WriteFile(
                        (HANDLE) pvSaveToPara,
                        pbEncoded,
                        cbEncoded,
                        &cbBytesWritten,
                        NULL            // lpOverlapped
                        )) goto WriteError;
            }
            break;
        case CERT_STORE_SAVE_TO_MEMORY:
            {
                PCRYPT_DATA_BLOB pData = (PCRYPT_DATA_BLOB) pvSaveToPara;
                if (!EncodePKCS7(
                        dwEncodingType,
                        &SignedEncodeInfo,
                        pData->pbData,
                        &pData->cbData)) goto EncodePKCS7Error;
            }
            break;
        default:
            goto UnexpectedError;
    }

    fResult = TRUE;
CommonReturn:
    FreeSaveAsPKCS7Info(&SignedEncodeInfo, ppCert, ppCrl);
    PkiFree(pbEncoded);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(InitInfoError)
TRACE_ERROR(EncodePKCS7Error)
TRACE_ERROR(WriteError)
TRACE_ERROR(OutOfMemory)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
}

//+-------------------------------------------------------------------------
//  Save the cert store. Enhanced version with lots of options.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSaveStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwEncodingType,
    IN DWORD dwSaveAs,
    IN DWORD dwSaveTo,
    IN OUT void *pvSaveToPara,
    IN DWORD dwFlags
    )
{
    assert(pvSaveToPara);
    switch (dwSaveTo) {
        case CERT_STORE_SAVE_TO_FILENAME_A:
            {
                BOOL fResult;
                LPWSTR pwszFilename;
                if (NULL == (pwszFilename = MkWStr((LPSTR) pvSaveToPara)))
                    return FALSE;
                fResult = CertSaveStore(
                    hCertStore,
                    dwEncodingType,
                    dwSaveAs,
                    CERT_STORE_SAVE_TO_FILENAME_W,
                    (void *) pwszFilename,
                    dwFlags);
                FreeWStr(pwszFilename);
                return fResult;
            }
            break;
        case CERT_STORE_SAVE_TO_FILENAME_W:
            {
                BOOL fResult;
                HANDLE hFile;
                if (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
                          (LPWSTR) pvSaveToPara,
                          GENERIC_WRITE,
                          0,                        // fdwShareMode
                          NULL,                     // lpsa
                          CREATE_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL                      // hTemplateFile
                          )))
                    return FALSE;
                fResult = CertSaveStore(
                    hCertStore,
                    dwEncodingType,
                    dwSaveAs,
                    CERT_STORE_SAVE_TO_FILE,
                    (void *) hFile,
                    dwFlags);
                CloseHandle(hFile);
                return fResult;
            }
            break;
        case CERT_STORE_SAVE_TO_FILE:
        case CERT_STORE_SAVE_TO_MEMORY:
            break;
        default:
            SetLastError((DWORD) E_INVALIDARG);
            return FALSE;
    }

    switch (dwSaveAs) {
        case CERT_STORE_SAVE_AS_STORE:
            return SaveAsStore(
                (PCERT_STORE) hCertStore,
                dwSaveTo,
                pvSaveToPara,
                dwFlags);
            break;
        case CERT_STORE_SAVE_AS_PKCS7:
            return SaveAsPKCS7(
                (PCERT_STORE) hCertStore,
                dwEncodingType,
                dwSaveTo,
                pvSaveToPara,
                dwFlags);
            break;
        default:
            SetLastError((DWORD) E_INVALIDARG);
            return FALSE;
    }
}

//+=========================================================================
//  Share Element Find, Create and Release functions
//==========================================================================

static inline DWORD GetShareElementHashBucketIndex(
    IN BYTE *pbSha1Hash
    )
{
    return pbSha1Hash[0] % SHARE_ELEMENT_HASH_BUCKET_COUNT;
}


// Find existing share element identified by its sha1 hash.
// For a match, the returned share element is AddRef'ed.
//
// The dwContextType is a sanity check. Different context types should never
// match.
STATIC PSHARE_ELEMENT FindShareElement(
    IN BYTE *pbSha1Hash,
    IN DWORD dwContextType
    )
{
    PSHARE_ELEMENT pShareEle;
    DWORD dwBucketIndex = GetShareElementHashBucketIndex(pbSha1Hash);

    EnterCriticalSection(&ShareElementCriticalSection);

    for (pShareEle = rgpShareElementHashBucket[dwBucketIndex];
                NULL != pShareEle;
                pShareEle = pShareEle->pNext)
    {
        if (0 == memcmp(pbSha1Hash, pShareEle->rgbSha1Hash, SHA1_HASH_LEN) &&
                dwContextType == pShareEle->dwContextType) {
            pShareEle->dwRefCnt++;
            break;
        }
    }

    LeaveCriticalSection(&ShareElementCriticalSection);

    return pShareEle;
}

// Upon input pbEncoded has been allocated. Not freed on a NULL error
// return.
//
// The returned share element has been AddRef'ed
STATIC PSHARE_ELEMENT CreateShareElement(
    IN BYTE *pbSha1Hash,
    IN DWORD dwContextType,
    IN DWORD dwEncodingType,
    IN BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    PSHARE_ELEMENT pShareEle = NULL;
    DWORD dwBucketIndex = GetShareElementHashBucketIndex(pbSha1Hash);
    LPCSTR pszStructType;

    if (NULL == (pShareEle = (PSHARE_ELEMENT) PkiZeroAlloc(
            sizeof(SHARE_ELEMENT))))
        goto OutOfMemory;
    memcpy(pShareEle->rgbSha1Hash, pbSha1Hash, SHA1_HASH_LEN);
    pShareEle->dwContextType = dwContextType;
    pShareEle->pbEncoded = pbEncoded;
    pShareEle->cbEncoded = cbEncoded;

    // Decode according to the context type. Note, a CTL share element
    // doesn't have a decoded CTL.
    pszStructType = rgpszShareElementStructType[dwContextType];
    if (pszStructType) {
        if (NULL == (pShareEle->pvInfo =  AllocAndDecodeObject(
                dwEncodingType,
                pszStructType,
                pbEncoded,
                cbEncoded
                )))
            goto DecodeError;
    }

    pShareEle->dwRefCnt = 1;

    // Insert at beginning of share element's hash bucket list
    EnterCriticalSection(&ShareElementCriticalSection);
    if (rgpShareElementHashBucket[dwBucketIndex]) {
        assert(NULL == rgpShareElementHashBucket[dwBucketIndex]->pPrev);
        rgpShareElementHashBucket[dwBucketIndex]->pPrev = pShareEle;

        pShareEle->pNext = rgpShareElementHashBucket[dwBucketIndex];
    }

    rgpShareElementHashBucket[dwBucketIndex] = pShareEle;
    LeaveCriticalSection(&ShareElementCriticalSection);

    switch (dwContextType) {
        case CERT_STORE_CERTIFICATE_CONTEXT - 1:
            CertPerfIncrementCertElementCurrentCount();
            CertPerfIncrementCertElementTotalCount();
            break;
        case CERT_STORE_CRL_CONTEXT - 1:
            CertPerfIncrementCrlElementCurrentCount();
            CertPerfIncrementCrlElementTotalCount();
            break;
        case CERT_STORE_CTL_CONTEXT - 1:
            CertPerfIncrementCtlElementCurrentCount();
            CertPerfIncrementCtlElementTotalCount();
            break;
    }

CommonReturn:
    return pShareEle;
ErrorReturn:
    if (pShareEle) {
        PkiFree(pShareEle->pvInfo);
        PkiFree(pShareEle);
        pShareEle = NULL;
    }
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DecodeError)
}

STATIC void ReleaseShareElement(
    IN PSHARE_ELEMENT pShareEle
    )
{
    EnterCriticalSection(&ShareElementCriticalSection);

    if (0 == --pShareEle->dwRefCnt) {
        if (pShareEle->pNext)
            pShareEle->pNext->pPrev = pShareEle->pPrev;
        if (pShareEle->pPrev)
            pShareEle->pPrev->pNext = pShareEle->pNext;
        else {
            DWORD dwBucketIndex =
                GetShareElementHashBucketIndex(pShareEle->rgbSha1Hash);
            assert(rgpShareElementHashBucket[dwBucketIndex] == pShareEle);
            if (rgpShareElementHashBucket[dwBucketIndex] == pShareEle)
                rgpShareElementHashBucket[dwBucketIndex] = pShareEle->pNext;

        }

        switch (pShareEle->dwContextType) {
            case CERT_STORE_CERTIFICATE_CONTEXT - 1:
                CertPerfDecrementCertElementCurrentCount();
                break;
            case CERT_STORE_CRL_CONTEXT - 1:
                CertPerfDecrementCrlElementCurrentCount();
                break;
            case CERT_STORE_CTL_CONTEXT - 1:
                CertPerfDecrementCtlElementCurrentCount();
                break;
        }

        PkiFree(pShareEle->pbEncoded);
        PkiFree(pShareEle->pvInfo);
        PkiFree(pShareEle);
    }

    LeaveCriticalSection(&ShareElementCriticalSection);
}

//+-------------------------------------------------------------------------
//  Read and allocate the store element. Possibly adjust the cbEncoded to
//  excluded trailing bytes.
//--------------------------------------------------------------------------
STATIC ReadStoreElement(
    IN HANDLE h,
    IN PFNREAD pfnRead,
    IN DWORD dwEncodingType,
    OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded = *pcbEncoded;

    if (NULL == (pbEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
        goto OutOfMemory;
    if (!pfnRead(
            h,
            pbEncoded,
            cbEncoded))
        goto ReadError;
    cbEncoded = AdjustEncodedLength(dwEncodingType, pbEncoded, cbEncoded);

    fResult = TRUE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;
ErrorReturn:
    PkiFree(pbEncoded);
    pbEncoded = NULL;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(ReadError)
}

//+-------------------------------------------------------------------------
//  Create the store element.
//
//  If CERT_STORE_SHARE_CONTEXT_FLAG is set, a share element is either found
//  or created.
//
//  Normally, the sha1 hash will have been read as a serialized property
//  and passed in and won't need to be calculated here. Also, for a
//  found share element, the encoded element bytes can be skipped instead
//  of being allocated and read.
//
//  In all cases, the context specific CreateElement function is called.
//--------------------------------------------------------------------------
STATIC PCONTEXT_ELEMENT CreateStoreElement(
    IN HANDLE h,
    IN PFNREAD pfnRead,
    IN PFNSKIP pfnSkip,
    IN PCERT_STORE pStore,
    IN DWORD dwEncodingType,
    IN DWORD dwContextType,
    IN DWORD cbEncoded,
    IN OPTIONAL BYTE *pbSha1Hash
    )
{
    PCONTEXT_ELEMENT pEle = NULL;
    PSHARE_ELEMENT pShareEle = NULL;
    BYTE *pbEncoded = NULL;

    assert(pStore);
    if (pStore->dwFlags & CERT_STORE_SHARE_CONTEXT_FLAG) {
        BYTE rgbSha1Hash[SHA1_HASH_LEN];

        if (NULL == pbSha1Hash) {
            DWORD cbData;

            if (!ReadStoreElement(h, pfnRead, dwEncodingType,
                    &pbEncoded, &cbEncoded))
                goto ReadError;

            cbData = SHA1_HASH_LEN;
            if (!CryptHashCertificate(
                    0,                  // hCryptProv
                    CALG_SHA1,
                    0,                  // dwFlags
                    pbEncoded,
                    cbEncoded,
                    rgbSha1Hash,
                    &cbData) || SHA1_HASH_LEN != cbData)
                goto HashError;
            pbSha1Hash = rgbSha1Hash;
        }

        pShareEle = FindShareElement(pbSha1Hash, dwContextType);

        if (pShareEle) {
            if (NULL == pbEncoded) {
                if (!pfnSkip(
                        h,
                        cbEncoded))
                    goto SkipError;
            } else
                PkiFree(pbEncoded);
            pbEncoded = pShareEle->pbEncoded;
            cbEncoded = pShareEle->cbEncoded;
        } else {
            if (NULL == pbEncoded) {
                if (!ReadStoreElement(h, pfnRead, dwEncodingType,
                        &pbEncoded, &cbEncoded))
                    goto ReadError;
            }
            if (NULL == (pShareEle = CreateShareElement(
                    pbSha1Hash,
                    dwContextType,
                    dwEncodingType,
                    pbEncoded,
                    cbEncoded
                    )))
                goto CreateShareElementError;
            assert(pbEncoded == pShareEle->pbEncoded);
            assert(cbEncoded == pShareEle->cbEncoded);
        }
    } else {
        if (!ReadStoreElement(h, pfnRead, dwEncodingType,
                &pbEncoded, &cbEncoded))
            goto ReadError;
    }

    if (NULL == (pEle = rgpfnCreateElement[dwContextType](
            pStore,
            dwEncodingType,
            pbEncoded,
            cbEncoded,
            pShareEle
            )))
        goto CreateElementError;
CommonReturn:
    return pEle;

ErrorReturn:
    if (pShareEle) {
        if (pbEncoded != pShareEle->pbEncoded)
            PkiFree(pbEncoded);
        ReleaseShareElement(pShareEle);
    } else {
        PkiFree(pbEncoded);
    }

    assert(NULL == pEle);
    goto CommonReturn;

TRACE_ERROR(ReadError)
TRACE_ERROR(HashError)
TRACE_ERROR(SkipError)
TRACE_ERROR(CreateShareElementError)
TRACE_ERROR(CreateElementError)
}

//+-------------------------------------------------------------------------
//  Loads a serialized certificate, CRL or CTL with properties into a store.
//
//  Also supports decoding of KeyIdentifier properties.
//--------------------------------------------------------------------------
STATIC DWORD LoadStoreElement(
    IN HANDLE h,
    IN PFNREAD pfnRead,
    IN PFNSKIP pfnSkip,
    IN DWORD cbReadSize,
    IN OPTIONAL PCERT_STORE pStore,         // NULL for fKeyIdAllowed
    IN DWORD dwAddDisposition,
    IN DWORD dwContextTypeFlags,
    OUT OPTIONAL DWORD *pdwContextType,
    OUT OPTIONAL const void **ppvContext,
    IN BOOL fKeyIdAllowed = FALSE
    )
{
    BYTE *pbEncoded = NULL;
    PCONTEXT_ELEMENT pContextEle = NULL;
    PCONTEXT_ELEMENT pStoreEle = NULL;
    PPROP_ELEMENT pPropHead = NULL;
    BYTE *pbSha1Hash = NULL;                // not allocated
    FILE_ELEMENT_HDR EleHdr;
    BOOL fIsProp;
    DWORD csStatus;
    DWORD dwContextType;

    do {
        fIsProp = FALSE;

        if (!pfnRead(
                h,
                &EleHdr,
                sizeof(EleHdr))) goto ReadError;

        if (EleHdr.dwEleType == FILE_ELEMENT_END_TYPE) {
            if (pPropHead != NULL)
                goto PrematureEndError;

            csStatus = CSEnd;
            goto ZeroOutParameterReturn;
        }

        if (EleHdr.dwLen > cbReadSize)
            goto ExceedReadSizeError;

        switch (EleHdr.dwEleType) {
            case FILE_ELEMENT_CERT_TYPE:
                dwContextType = CERT_STORE_CERTIFICATE_CONTEXT;
                break;
            case FILE_ELEMENT_CRL_TYPE:
                dwContextType = CERT_STORE_CRL_CONTEXT;
                break;
            case FILE_ELEMENT_CTL_TYPE:
                dwContextType = CERT_STORE_CTL_CONTEXT;
                break;
            default:
                dwContextType = 0;
        }

        if (0 != dwContextType) {
            if (0 == (dwContextTypeFlags & (1 << dwContextType)))
                goto ContextNotAllowedError;
            if (NULL == (pContextEle = CreateStoreElement(
                    h,
                    pfnRead,
                    pfnSkip,
                    pStore,
                    EleHdr.dwEncodingType,
                    dwContextType - 1,
                    EleHdr.dwLen,
                    pbSha1Hash
                    )))
                goto CreateStoreElementError;

            pbEncoded = NULL;
            pContextEle->Cache.pPropHead = pPropHead;
            pPropHead = NULL;
            if (!AddElementToStore(pStore, pContextEle, dwAddDisposition,
                    ppvContext ? &pStoreEle : NULL))
                goto AddStoreElementError;
            else
                pContextEle = NULL;

            if (pdwContextType)
                *pdwContextType = dwContextType;
            if (ppvContext)
                *((PCCERT_CONTEXT *) ppvContext) = ToCertContext(pStoreEle);
        } else {
            // EleHdr.dwLen may be 0 for a property
            if (EleHdr.dwLen > 0) {
                if (NULL == (pbEncoded = (BYTE *) PkiNonzeroAlloc(
                        EleHdr.dwLen)))
                    goto OutOfMemory;
                if (!pfnRead(
                        h,
                        pbEncoded,
                        EleHdr.dwLen)) goto ReadError;
            }

            if (EleHdr.dwEleType == FILE_ELEMENT_KEYID_TYPE) {
                PKEYID_ELEMENT pKeyIdEle;

                if (!fKeyIdAllowed)
                    goto KeyIdNotAllowedError;
                if (NULL == (pKeyIdEle = CreateKeyIdElement(
                        pbEncoded,
                        EleHdr.dwLen
                        )))
                    goto CreateKeyIdElementError;
                pbEncoded = NULL;
                pKeyIdEle->pPropHead = pPropHead;
                pPropHead = NULL;
                assert(ppvContext);
                if (ppvContext)
                    *((PKEYID_ELEMENT *) ppvContext) = pKeyIdEle;

            } else if (EleHdr.dwEleType > CERT_LAST_USER_PROP_ID) {
                // Silently discard any IDs exceeding 0xFFFF. The
                // FIRST_USER_PROP_ID used to start at 0x10000.
                fIsProp = TRUE;
                PkiFree(pbEncoded);
                pbEncoded = NULL;
            } else if (EleHdr.dwEleType == CERT_KEY_CONTEXT_PROP_ID) {
                goto InvalidPropId;
            } else {
                PPROP_ELEMENT pPropEle;

                fIsProp = TRUE;
                if (NULL == (pPropEle = CreatePropElement(
                        EleHdr.dwEleType,
                        0,                  // dwFlags
                        pbEncoded,
                        EleHdr.dwLen
                        ))) goto CreatePropElementError;

                if (CERT_SHA1_HASH_PROP_ID == EleHdr.dwEleType &&
                        SHA1_HASH_LEN == EleHdr.dwLen)
                    pbSha1Hash = pbEncoded;

                pbEncoded = NULL;
                AddPropElement(&pPropHead, pPropEle);
            }
        }
    } while (fIsProp);

    assert(pPropHead == NULL);
    assert(pbEncoded == NULL);
    assert(pContextEle == NULL);

    csStatus = CSContinue;
CommonReturn:
    return csStatus;
ErrorReturn:
    PkiFree(pbEncoded);
    if (pContextEle)
        FreeContextElement(pContextEle);
    while (pPropHead) {
        PPROP_ELEMENT pEle = pPropHead;
        pPropHead = pPropHead->pNext;
        FreePropElement(pEle);
    }
    csStatus = CSError;
ZeroOutParameterReturn:
    if (pdwContextType)
        *pdwContextType = 0;
    if (ppvContext)
        *ppvContext = NULL;
    goto CommonReturn;

TRACE_ERROR(ReadError)
SET_ERROR(PrematureEndError, CRYPT_E_FILE_ERROR)
SET_ERROR(ExceedReadSizeError, CRYPT_E_FILE_ERROR)
TRACE_ERROR(OutOfMemory)
SET_ERROR(ContextNotAllowedError, E_INVALIDARG)
TRACE_ERROR(CreateStoreElementError)
TRACE_ERROR(AddStoreElementError)
TRACE_ERROR(CreatePropElementError)
SET_ERROR(KeyIdNotAllowedError, E_INVALIDARG)
TRACE_ERROR(CreateKeyIdElementError)
SET_ERROR(InvalidPropId, CRYPT_E_FILE_ERROR)
}

//+-------------------------------------------------------------------------
//  Add the serialized certificate, CRL or CTL element to the store.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertAddSerializedElementToStore(
    IN HCERTSTORE hCertStore,
    IN const BYTE *pbElement,
    IN DWORD cbElement,
    IN DWORD dwAddDisposition,
    IN DWORD dwFlags,
    IN DWORD dwContextTypeFlags,
    OUT OPTIONAL DWORD *pdwContextType,
    OUT OPTIONAL const void **ppvContext
    )
{
    MEMINFO MemInfo;
    DWORD csStatus;
    PCERT_STORE pStore =
        hCertStore ? (PCERT_STORE) hCertStore : &NullCertStore;

    MemInfo.pByte = (BYTE*) pbElement;
    MemInfo.cb = cbElement;
    MemInfo.cbSeek = 0;

    csStatus = LoadStoreElement(
        (HANDLE) &MemInfo,
        ReadFromMemory,
        SkipInMemory,
        cbElement,
        pStore,
        dwAddDisposition,
        dwContextTypeFlags,
        pdwContextType,
        ppvContext);
    if (CSContinue == csStatus)
        return TRUE;
    else {
        if (CSEnd == csStatus)
            SetLastError((DWORD) CRYPT_E_NOT_FOUND);
        return FALSE;
    }
}


//+=========================================================================
//  Store Control APIs
//==========================================================================

STATIC BOOL EnableAutoResync(
    IN PCERT_STORE pStore
    )
{
    BOOL fResult;
    HANDLE hEvent;

    fResult = TRUE;
    hEvent = NULL;
    LockStore(pStore);
    if (NULL == pStore->hAutoResyncEvent) {
        // Create event to be notified
        if (hEvent = CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL))      // lpszEventName
            pStore->hAutoResyncEvent = hEvent;
        else
            fResult = FALSE;
    }
    UnlockStore(pStore);
    if (!fResult)
        goto CreateEventError;

    if (hEvent) {
        if (!CertControlStore(
                (HCERTSTORE) pStore,
                CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG,
                CERT_STORE_CTRL_NOTIFY_CHANGE,
                &hEvent
                )) {
            DWORD dwErr = GetLastError();

            // Bug 484023 Certificate store event handle closed before
            // being removed from list.
            CertControlStore(
                (HCERTSTORE) pStore,
                0,                      // dwFlags
                CERT_STORE_CTRL_CANCEL_NOTIFY,
                &hEvent
                );

            LockStore(pStore);
            pStore->hAutoResyncEvent = NULL;
            UnlockStore(pStore);
            CloseHandle(hEvent);
            SetLastError(dwErr);
            goto CtrlNotifyChangeError;
        }
    }

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(CreateEventError)
TRACE_ERROR(CtrlNotifyChangeError)
}

// For a collection, iterates through all the sibling stores. For an error,
// continues on to the remaining stores. LastError is updated with the
// LastError of the first failing store.
STATIC BOOL ControlCollectionStore(
    IN PCERT_STORE pCollection,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara
    )
{
    BOOL fResult = TRUE;
    BOOL fOneSiblingSuccess = FALSE;
    DWORD dwError = ERROR_CALL_NOT_IMPLEMENTED;

    PCERT_STORE_LINK pStoreLink;
    PCERT_STORE_LINK pPrevStoreLink = NULL;

    // Iterate through all the siblings and call the control function
    LockStore(pCollection);
    pStoreLink = pCollection->pStoreListHead;
    for (; pStoreLink; pStoreLink = pStoreLink->pNext) {
        // Advance past deleted store link
        if (pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG)
            continue;

        AddRefStoreLink(pStoreLink);
        UnlockStore(pCollection);
        if (pPrevStoreLink)
            ReleaseStoreLink(pPrevStoreLink);
        pPrevStoreLink = pStoreLink;

        if (CertControlStore(
                (HCERTSTORE) pStoreLink->pSibling,
                dwFlags,
                dwCtrlType,
                pvCtrlPara
                )) {
            fOneSiblingSuccess = TRUE;
            if (ERROR_CALL_NOT_IMPLEMENTED == dwError)
                fResult = TRUE;
        } else if (ERROR_CALL_NOT_IMPLEMENTED == dwError) {
            dwError = GetLastError();
            if (!fOneSiblingSuccess || ERROR_CALL_NOT_IMPLEMENTED != dwError)
                fResult = FALSE;
        }

        LockStore(pCollection);
    }
    UnlockStore(pCollection);

    if (pPrevStoreLink)
        ReleaseStoreLink(pPrevStoreLink);
    if (!fResult)
        SetLastError(dwError);
    return fResult;
}

BOOL
WINAPI
CertControlStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara
    )
{
    BOOL fResult;
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;
    PFN_CERT_STORE_PROV_CONTROL pfnStoreProvControl;

    if (CERT_STORE_CTRL_AUTO_RESYNC == dwCtrlType)
        return EnableAutoResync(pStore);

    if (STORE_TYPE_COLLECTION == pStore->dwStoreType)
        return ControlCollectionStore(
            pStore,
            dwFlags,
            dwCtrlType,
            pvCtrlPara
            );

    // Check if the store supports the control callback
    if (pStore->StoreProvInfo.cStoreProvFunc <=
            CERT_STORE_PROV_CONTROL_FUNC  ||
        NULL == (pfnStoreProvControl = (PFN_CERT_STORE_PROV_CONTROL)
            pStore->StoreProvInfo.rgpvStoreProvFunc[
                CERT_STORE_PROV_CONTROL_FUNC]))
        goto ProvControlNotSupported;

    // The caller is holding a reference count on the store.
    if (!pfnStoreProvControl(
            pStore->StoreProvInfo.hStoreProv,
            dwFlags,
            dwCtrlType,
            pvCtrlPara
            ))
        goto StoreProvControlError;

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(ProvControlNotSupported, ERROR_CALL_NOT_IMPLEMENTED)
TRACE_ERROR(StoreProvControlError)
}

//+=========================================================================
//  Store Collection APIs
//==========================================================================

BOOL
WINAPI
CertAddStoreToCollection(
    IN HCERTSTORE hCollectionStore,
    IN OPTIONAL HCERTSTORE hSiblingStore,
    IN DWORD dwUpdateFlags,
    IN DWORD dwPriority
    )
{
    BOOL fResult;
    PCERT_STORE pCollection = (PCERT_STORE) hCollectionStore;
    PCERT_STORE pSibling = (PCERT_STORE) hSiblingStore;

    PCERT_STORE_LINK pAddLink = NULL;

    LockStore(pCollection);
    if (STORE_TYPE_COLLECTION == pCollection->dwStoreType)
        fResult = TRUE;
    else if (STORE_TYPE_CACHE == pCollection->dwStoreType &&
            STORE_STATE_OPENING == pCollection->dwState &&
            IsEmptyStore(pCollection)) {
        pCollection->dwStoreType = STORE_TYPE_COLLECTION;
        fResult = TRUE;
    } else
        fResult = FALSE;
    UnlockStore(pCollection);
    if (!fResult)
        goto InvalidCollectionStore;
    if (NULL == hSiblingStore)
        goto CommonReturn;

    // Create a link to the store to be added. It duplicates pSibling.
    if (NULL == (pAddLink = CreateStoreLink(
            pCollection,
            pSibling,
            dwUpdateFlags,
            dwPriority)))
        goto CreateStoreLinkError;

    LockStore(pCollection);

    if (NULL == pCollection->pStoreListHead)
        pCollection->pStoreListHead = pAddLink;
    else {
        PCERT_STORE_LINK pLink;

        pLink = pCollection->pStoreListHead;
        if (dwPriority > pLink->dwPriority) {
            // Insert at beginning before first link
            pAddLink->pNext = pLink;
            pLink->pPrev = pAddLink;
            pCollection->pStoreListHead = pAddLink;
        } else {
            // Insert after the link whose next link has
            // lower priority or insert after the last link
            while (pLink->pNext && dwPriority <= pLink->pNext->dwPriority)
                pLink = pLink->pNext;

            pAddLink->pPrev = pLink;
            pAddLink->pNext = pLink->pNext;
            if (pLink->pNext)
                pLink->pNext->pPrev = pAddLink;
            pLink->pNext = pAddLink;
        }
    }

    UnlockStore(pCollection);
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidCollectionStore, E_INVALIDARG)
TRACE_ERROR(CreateStoreLinkError)
}

void
WINAPI
CertRemoveStoreFromCollection(
    IN HCERTSTORE hCollectionStore,
    IN HCERTSTORE hSiblingStore
    )
{
    PCERT_STORE pCollection = (PCERT_STORE) hCollectionStore;
    PCERT_STORE pSibling = (PCERT_STORE) hSiblingStore;
    PCERT_STORE_LINK pLink;

    LockStore(pCollection);
    assert(STORE_TYPE_COLLECTION == pCollection->dwStoreType);
    pLink = pCollection->pStoreListHead;
    for (; pLink; pLink = pLink->pNext) {
        if (pSibling == pLink->pSibling &&
                0 == (pLink->dwFlags & STORE_LINK_DELETED_FLAG)) {
            // Remove the collection's reference
            pLink->dwFlags |= STORE_LINK_DELETED_FLAG;

            UnlockStore(pCollection);
            ReleaseStoreLink(pLink);
            return;
        }
    }

    UnlockStore(pCollection);
}

//+=========================================================================
//  Cert Store Property Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Set a store property.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSetStoreProperty(
    IN HCERTSTORE hCertStore,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    )
{
    BOOL fResult;
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;

    LockStore(pStore);

    fResult = SetCallerProperty(
        &pStore->pPropHead,
        dwPropId,
        dwFlags,
        pvData
        );

    UnlockStore(pStore);
    return fResult;
}


//+-------------------------------------------------------------------------
//  Get a store property.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertGetStoreProperty(
    IN HCERTSTORE hCertStore,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;

    if (dwPropId == CERT_ACCESS_STATE_PROP_ID) {
        DWORD dwAccessStateFlags;
        DWORD cbIn;

        dwAccessStateFlags = 0;
        if (0 == (pStore->dwFlags & CERT_STORE_READONLY_FLAG) &&
                0 == (pStore->StoreProvInfo.dwStoreProvFlags &
                     CERT_STORE_PROV_NO_PERSIST_FLAG))
        {
            if (STORE_TYPE_COLLECTION == pStore->dwStoreType) {
                // If all its children are READONLY, then NO WRITE_PERSIST

                PCERT_STORE_LINK pStoreLink;
                PCERT_STORE_LINK pPrevStoreLink = NULL;
                LockStore(pStore);
                for (pStoreLink = pStore->pStoreListHead;
                                pStoreLink; pStoreLink = pStoreLink->pNext) {

                    DWORD dwSiblingAccessStateFlags;
                    DWORD cbSiblingData;

                    // Advance past deleted store link
                    if (pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG)
                        continue;

                    AddRefStoreLink(pStoreLink);
                    UnlockStore(pStore);
                    if (pPrevStoreLink)
                        ReleaseStoreLink(pPrevStoreLink);
                    pPrevStoreLink = pStoreLink;

                    dwSiblingAccessStateFlags = 0;
                    cbSiblingData = sizeof(dwSiblingAccessStateFlags);
                    CertGetStoreProperty(
                        (HCERTSTORE) pStoreLink->pSibling,
                        CERT_ACCESS_STATE_PROP_ID,
                        &dwSiblingAccessStateFlags,
                        &cbSiblingData
                        );
                    LockStore(pStore);

                    if (dwSiblingAccessStateFlags &
                            CERT_ACCESS_STATE_WRITE_PERSIST_FLAG) {
                        dwAccessStateFlags =
                            CERT_ACCESS_STATE_WRITE_PERSIST_FLAG;
                        break;
                    }
                }
                UnlockStore(pStore);
                if (pPrevStoreLink)
                    ReleaseStoreLink(pPrevStoreLink);
            } else
                dwAccessStateFlags = CERT_ACCESS_STATE_WRITE_PERSIST_FLAG;
        }

        if (pStore->StoreProvInfo.dwStoreProvFlags &
                CERT_STORE_PROV_SYSTEM_STORE_FLAG)
            dwAccessStateFlags |= CERT_ACCESS_STATE_SYSTEM_STORE_FLAG;

        if (pStore->StoreProvInfo.dwStoreProvFlags &
                CERT_STORE_PROV_LM_SYSTEM_STORE_FLAG)
            dwAccessStateFlags |= CERT_ACCESS_STATE_LM_SYSTEM_STORE_FLAG;

        fResult = TRUE;
        if (pvData == NULL)
            cbIn = 0;
        else
            cbIn = *pcbData;
        if (cbIn < sizeof(DWORD)) {
            if (pvData) {
                SetLastError((DWORD) ERROR_MORE_DATA);
                fResult = FALSE;
            }
        } else
            *((DWORD * ) pvData) = dwAccessStateFlags;
        *pcbData = sizeof(DWORD);
        return fResult;
    }

    LockStore(pStore);

    fResult = GetCallerProperty(
        pStore->pPropHead,
        dwPropId,
        FALSE,                  // fAlloc
        pvData,
        pcbData
        );

    UnlockStore(pStore);
    return fResult;
}

//+=========================================================================
//  Certificate APIs
//==========================================================================

BOOL
WINAPI
CertAddEncodedCertificateToStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCERT_CONTEXT *ppCertContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle = NULL;
    fResult = AddEncodedContextToStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        dwCertEncodingType,
        pbCertEncoded,
        cbCertEncoded,
        dwAddDisposition,
        ppCertContext ? &pStoreEle : NULL
        );
    if (ppCertContext)
        *ppCertContext = ToCertContext(pStoreEle);
    return fResult;
}

BOOL
WINAPI
CertAddCertificateContextToStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCERT_CONTEXT *ppStoreContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle = NULL;

    fResult = AddContextToStore(
        (PCERT_STORE) hCertStore,
        ToContextElement(pCertContext),
        pCertContext->dwCertEncodingType,
        pCertContext->pbCertEncoded,
        pCertContext->cbCertEncoded,
        dwAddDisposition,
        ppStoreContext ? &pStoreEle : NULL
        );
    if (ppStoreContext)
        *ppStoreContext = ToCertContext(pStoreEle);
    return fResult;
}

BOOL
WINAPI
CertAddCertificateLinkToStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCERT_CONTEXT *ppStoreContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle = NULL;

    fResult = AddLinkContextToCacheStore(
        (PCERT_STORE) hCertStore,
        ToContextElement(pCertContext),
        dwAddDisposition,
        ppStoreContext ? &pStoreEle : NULL
        );
    if (ppStoreContext)
        *ppStoreContext = ToCertContext(pStoreEle);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Serialize the certificate context's encoded certificate and its
//  properties.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSerializeCertificateStoreElement(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwFlags,
    OUT BYTE *pbElement,
    IN OUT DWORD *pcbElement
    )
{
    return SerializeContextElement(
        ToContextElement(pCertContext),
        dwFlags,
        pbElement,
        pcbElement
        );
}

//+-------------------------------------------------------------------------
//  Delete the specified certificate from the store.
//
//  All subsequent gets or finds for the certificate will fail. However,
//  memory allocated for the certificate isn't freed until all of its contexts
//  have also been freed.
//
//  The pCertContext is obtained from a get, find or duplicate.
//
//  Some store provider implementations might also delete the issuer's CRLs
//  if this is the last certificate for the issuer in the store.
//
//  NOTE: the pCertContext is always CertFreeCertificateContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertDeleteCertificateFromStore(
    IN PCCERT_CONTEXT pCertContext
    )
{
    assert(NULL == pCertContext || (CERT_STORE_CERTIFICATE_CONTEXT - 1) ==
        ToContextElement(pCertContext)->dwContextType);
    return DeleteContextElement(ToContextElement(pCertContext));
}

//+-------------------------------------------------------------------------
//  Get the subject certificate context uniquely identified by its Issuer and
//  SerialNumber from the store.
//
//  If the certificate isn't found, NULL is returned. Otherwise, a pointer to
//  a read only CERT_CONTEXT is returned. CERT_CONTEXT must be freed by calling
//  CertFreeCertificateContext. CertDuplicateCertificateContext can be called to make a
//  duplicate.
//
//  The returned certificate might not be valid. Normally, it would be
//  verified when getting its issuer certificate (CertGetIssuerCertificateFromStore).
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CertGetSubjectCertificateFromStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pCertId           // Only the Issuer and SerialNumber
                                    // fields are used
    )
{
    CERT_STORE_PROV_FIND_INFO FindInfo;

    if (pCertId == NULL) {
        SetLastError((DWORD) E_INVALIDARG);
        return NULL;
    }

    FindInfo.cbSize = sizeof(FindInfo);
    FindInfo.dwMsgAndCertEncodingType = dwCertEncodingType,
    FindInfo.dwFindFlags = 0;
    FindInfo.dwFindType = CERT_FIND_SUBJECT_CERT;
    FindInfo.pvFindPara = pCertId;

    return ToCertContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        &FindInfo,
        NULL                                // pPrevEle
        ));
}

//+-------------------------------------------------------------------------
//  Enumerate the certificate contexts in the store.
//
//  If a certificate isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT is returned. CERT_CONTEXT
//  must be freed by calling CertFreeCertificateContext or is freed when passed as the
//  pPrevCertContext on a subsequent call. CertDuplicateCertificateContext
//  can be called to make a duplicate.
//
//  pPrevCertContext MUST BE NULL to enumerate the first
//  certificate in the store. Successive certificates are enumerated by setting
//  pPrevCertContext to the CERT_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCertContext is always CertFreeCertificateContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CertEnumCertificatesInStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pPrevCertContext
    )
{
    return ToCertContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        &FindAnyInfo,
        ToContextElement(pPrevCertContext)
        ));
}

//+-------------------------------------------------------------------------
//  Find the first or next certificate context in the store.
//
//  The certificate is found according to the dwFindType and its pvFindPara.
//  See below for a list of the find types and its parameters.
//
//  Currently dwFindFlags is only used for CERT_FIND_SUBJECT_ATTR or
//  CERT_FIND_ISSUER_ATTR. Otherwise, must be set to 0.
//
//  Usage of dwCertEncodingType depends on the dwFindType.
//
//  If the first or next certificate isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT is returned. CERT_CONTEXT
//  must be freed by calling CertFreeCertificateContext or is freed when passed as the
//  pPrevCertContext on a subsequent call. CertDuplicateCertificateContext
//  can be called to make a duplicate.
//
//  pPrevCertContext MUST BE NULL on the first
//  call to find the certificate. To find the next certificate, the
//  pPrevCertContext is set to the CERT_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCertContext is always CertFreeCertificateContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CertFindCertificateInStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCERT_CONTEXT pPrevCertContext
    )
{
    CERT_STORE_PROV_FIND_INFO FindInfo;

    FindInfo.cbSize = sizeof(FindInfo);
    FindInfo.dwMsgAndCertEncodingType = dwCertEncodingType;
    FindInfo.dwFindFlags = dwFindFlags;
    FindInfo.dwFindType = dwFindType;
    FindInfo.pvFindPara = pvFindPara;

    return ToCertContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CERTIFICATE_CONTEXT - 1,
        &FindInfo,
        ToContextElement(pPrevCertContext)
        ));
}

//+-------------------------------------------------------------------------
//  Perform the revocation check on the subject certificate
//  using the issuer certificate and store
//--------------------------------------------------------------------------
STATIC void VerifySubjectCertRevocation(
    IN PCCERT_CONTEXT pSubject,
    IN PCCERT_CONTEXT pIssuer,
    IN HCERTSTORE hIssuerStore,
    IN OUT DWORD *pdwFlags
    )
{

    PCCRL_CONTEXT rgpCrlContext[MAX_CRL_LIST];
    PCRL_INFO rgpCrlInfo[MAX_CRL_LIST];
    PCCRL_CONTEXT pCrlContext = NULL;
    DWORD cCrl = 0;

    assert(pIssuer && hIssuerStore);
    assert(*pdwFlags & CERT_STORE_REVOCATION_FLAG);

    while (TRUE) {
        DWORD dwFlags = CERT_STORE_SIGNATURE_FLAG;
        pCrlContext = CertGetCRLFromStore(
            hIssuerStore,
            pIssuer,
            pCrlContext,
            &dwFlags
            );

        if (pCrlContext == NULL) break;
        if (cCrl == MAX_CRL_LIST) {
            assert(cCrl > MAX_CRL_LIST);
            CertFreeCRLContext(pCrlContext);
            break;
        }

        if (dwFlags == 0) {
            rgpCrlContext[cCrl] = CertDuplicateCRLContext(pCrlContext);
            rgpCrlInfo[cCrl] = pCrlContext->pCrlInfo;
            cCrl++;
        } else {
            // Need to log or remove a bad CRL from the store
            ;
        }
    }
    if (cCrl == 0)
        *pdwFlags |= CERT_STORE_NO_CRL_FLAG;
    else {
        if (CertVerifyCRLRevocation(
                pSubject->dwCertEncodingType,
                pSubject->pCertInfo,
                cCrl,
                rgpCrlInfo
                ))
            *pdwFlags &= ~CERT_STORE_REVOCATION_FLAG;

        while (cCrl--)
            CertFreeCRLContext(rgpCrlContext[cCrl]);
    }
}

#ifdef CMS_PKCS7
//+-------------------------------------------------------------------------
//  If the verify certificate signature fails with CRYPT_E_MISSING_PUBKEY_PARA,
//  build a certificate chain. Retry. Hopefully, the issuer's
//  CERT_PUBKEY_ALG_PARA_PROP_ID property gets set while building the chain.
//--------------------------------------------------------------------------
STATIC BOOL VerifyCertificateSignatureWithChainPubKeyParaInheritance(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwCertEncodingType,
    IN DWORD        dwSubjectType,
    IN void         *pvSubject,
    IN PCCERT_CONTEXT pIssuer
    );
#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
//  Perform the enabled verification checks on the subject certificate
//  using the issuer
//--------------------------------------------------------------------------
STATIC void VerifySubjectCert(
    IN PCCERT_CONTEXT pSubject,
    IN OPTIONAL PCCERT_CONTEXT pIssuer,
    IN OUT DWORD *pdwFlags
    )
{
    if (*pdwFlags & CERT_STORE_TIME_VALIDITY_FLAG) {
        if (CertVerifyTimeValidity(NULL,
                pSubject->pCertInfo) == 0)
            *pdwFlags &= ~CERT_STORE_TIME_VALIDITY_FLAG;
    }

    if (pIssuer == NULL) {
        if (*pdwFlags & (CERT_STORE_SIGNATURE_FLAG |
                         CERT_STORE_REVOCATION_FLAG))
            *pdwFlags |= CERT_STORE_NO_ISSUER_FLAG;
        return;
    }

    if (*pdwFlags & CERT_STORE_SIGNATURE_FLAG) {
        PCERT_STORE pStore = (PCERT_STORE) pIssuer->hCertStore;
        HCRYPTPROV hProv;
        DWORD dwProvFlags;

        // Attempt to get the store's crypt provider. Serialize crypto
        // operations by entering critical section.
        hProv = GetCryptProv(pStore, &dwProvFlags);
#if 0
        // Slow down the provider while holding the provider reference
        // count
        Sleep(1700);
#endif

#ifdef CMS_PKCS7
        if (VerifyCertificateSignatureWithChainPubKeyParaInheritance(
                hProv,
                pSubject->dwCertEncodingType,
                CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT,
                (void *) pSubject,
                pIssuer
                ))
#else
        if (CryptVerifyCertificateSignature(
                hProv,
                pSubject->dwCertEncodingType,
                pSubject->pbCertEncoded,
                pSubject->cbCertEncoded,
                &pIssuer->pCertInfo->SubjectPublicKeyInfo
                ))
#endif  // CMS_PKCS7
            *pdwFlags &= ~CERT_STORE_SIGNATURE_FLAG;

        // For the store's crypt provider, release reference count. Leave
        // crypto operations critical section.
        ReleaseCryptProv(pStore, dwProvFlags);
    }

    if (*pdwFlags & CERT_STORE_REVOCATION_FLAG) {
        *pdwFlags &= ~CERT_STORE_NO_CRL_FLAG;

        VerifySubjectCertRevocation(
            pSubject,
            pIssuer,
            pIssuer->hCertStore,
            pdwFlags
            );

        if (*pdwFlags & CERT_STORE_NO_CRL_FLAG) {
            PCONTEXT_ELEMENT pIssuerEle = ToContextElement(pIssuer);

            if (ELEMENT_TYPE_LINK_CONTEXT == pIssuerEle->dwElementType) {
                // Skip past the link elements. A store containing a link
                // may not have any CRLs. Try the store containing the
                // real issuer element.

                DWORD dwInnerDepth = 0;
                for ( ; ELEMENT_TYPE_LINK_CONTEXT ==
                             pIssuerEle->dwElementType;
                                            pIssuerEle = pIssuerEle->pEle) {
                    dwInnerDepth++;
                    assert(dwInnerDepth <= MAX_LINK_DEPTH);
                    assert(pIssuerEle != pIssuerEle->pEle);
                    if (dwInnerDepth > MAX_LINK_DEPTH)
                        break;
                }
                if ((HCERTSTORE) pIssuerEle->pStore != pIssuer->hCertStore) {
                    *pdwFlags &= ~CERT_STORE_NO_CRL_FLAG;
                    VerifySubjectCertRevocation(
                        pSubject,
                        pIssuer,
                        (HCERTSTORE) pIssuerEle->pStore,
                        pdwFlags
                        );
                }
            }
        }
    }
}

//+-------------------------------------------------------------------------
//  Get the certificate context from the store for the first or next issuer
//  of the specified subject certificate. Perform the enabled
//  verification checks on the subject. (Note, the checks are on the subject
//  using the returned issuer certificate.)
//
//  If the first or next issuer certificate isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT is returned. CERT_CONTEXT
//  must be freed by calling CertFreeCertificateContext or is freed when passed as the
//  pPrevIssuerContext on a subsequent call. CertDuplicateCertificateContext
//  can be called to make a duplicate.
//
//  The pSubjectContext may have been obtained from this store, another store
//  or created by the caller application. When created by the caller, the
//  CertCreateCertificateContext function must have been called.
//
//  An issuer may have multiple certificates. This may occur when the validity
//  period is about to change. pPrevIssuerContext MUST BE NULL on the first
//  call to get the issuer. To get the next certificate for the issuer, the
//  pPrevIssuerContext is set to the CERT_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevIssuerContext is always CertFreeCertificateContext'ed by
//  this function, even for an error.
//
//  The following flags can be set in *pdwFlags to enable verification checks
//  on the subject certificate context:
//      CERT_STORE_SIGNATURE_FLAG     - use the public key in the returned
//                                      issuer certificate to verify the
//                                      signature on the subject certificate.
//                                      Note, if pSubjectContext->hCertStore ==
//                                      hCertStore, the store provider might
//                                      be able to eliminate a redo of
//                                      the signature verify.
//      CERT_STORE_TIME_VALIDITY_FLAG - get the current time and verify that
//                                      its within the subject certificate's
//                                      validity period
//      CERT_STORE_REVOCATION_FLAG    - check if the subject certificate is on
//                                      the issuer's revocation list
//
//  If an enabled verification check fails, then, its flag is set upon return.
//  If CERT_STORE_REVOCATION_FLAG was enabled and the issuer doesn't have a
//  CRL in the store, then, CERT_STORE_NO_CRL_FLAG is set in addition to
//  the CERT_STORE_REVOCATION_FLAG.
//
//  If CERT_STORE_SIGNATURE_FLAG or CERT_STORE_REVOCATION_FLAG is set, then,
//  CERT_STORE_NO_ISSUER_FLAG is set if it doesn't have an issuer certificate
//  in the store.
//
//  For a verification check failure, a pointer to the issuer's CERT_CONTEXT
//  is still returned and SetLastError isn't updated.
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CertGetIssuerCertificateFromStore(
    IN HCERTSTORE hCertStore,
    IN PCCERT_CONTEXT pSubjectContext,
    IN OPTIONAL PCCERT_CONTEXT pPrevIssuerContext,
    IN OUT DWORD *pdwFlags
    )
{
    PCCERT_CONTEXT pIssuerContext;

    if (*pdwFlags & ~(CERT_STORE_SIGNATURE_FLAG |
                      CERT_STORE_TIME_VALIDITY_FLAG |
                      CERT_STORE_REVOCATION_FLAG))
        goto InvalidArg;

    // Check if self signed certificate, issuer == subject
    if (CertCompareCertificateName(
            pSubjectContext->dwCertEncodingType,
            &pSubjectContext->pCertInfo->Subject,
            &pSubjectContext->pCertInfo->Issuer
            )) {
        VerifySubjectCert(
            pSubjectContext,
            pSubjectContext,
            pdwFlags
            );
        SetLastError((DWORD) CRYPT_E_SELF_SIGNED);
        goto ErrorReturn;
    } else {
        CERT_STORE_PROV_FIND_INFO FindInfo;
        FindInfo.cbSize = sizeof(FindInfo);
        FindInfo.dwMsgAndCertEncodingType = pSubjectContext->dwCertEncodingType;
        FindInfo.dwFindFlags = 0;
        FindInfo.dwFindType = CERT_FIND_ISSUER_OF;
        FindInfo.pvFindPara = pSubjectContext;

        if (pIssuerContext = ToCertContext(CheckAutoResyncAndFindElementInStore(
                (PCERT_STORE) hCertStore,
                CERT_STORE_CERTIFICATE_CONTEXT - 1,
                &FindInfo,
                ToContextElement(pPrevIssuerContext)
                )))
            VerifySubjectCert(
                pSubjectContext,
                pIssuerContext,
                pdwFlags
                );
    }

CommonReturn:
    return pIssuerContext;

ErrorReturn:
    if (pPrevIssuerContext)
        CertFreeCertificateContext(pPrevIssuerContext);
    pIssuerContext = NULL;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Perform the enabled verification checks on the subject certificate
//  using the issuer. Same checks and flags definitions as for the above
//  CertGetIssuerCertificateFromStore.
//
//  For a verification check failure, SUCCESS is still returned.
//
//  pIssuer must come from a store that is still open.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertVerifySubjectCertificateContext(
    IN PCCERT_CONTEXT pSubject,
    IN OPTIONAL PCCERT_CONTEXT pIssuer,
    IN OUT DWORD *pdwFlags
    )
{
    if (*pdwFlags & ~(CERT_STORE_SIGNATURE_FLAG |
                      CERT_STORE_TIME_VALIDITY_FLAG |
                      CERT_STORE_REVOCATION_FLAG)) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }
    if (*pdwFlags & (CERT_STORE_SIGNATURE_FLAG | CERT_STORE_REVOCATION_FLAG)) {
        if (pIssuer == NULL) {
            SetLastError((DWORD) E_INVALIDARG);
            return FALSE;
        }
    }

    VerifySubjectCert(
        pSubject,
        pIssuer,
        pdwFlags
        );
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Duplicate a certificate context
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CertDuplicateCertificateContext(
    IN PCCERT_CONTEXT pCertContext
    )
{
    if (pCertContext)
        AddRefContextElement(ToContextElement(pCertContext));
    return pCertContext;
}

//+-------------------------------------------------------------------------
//  Create a certificate context from the encoded certificate. The created
//  context isn't put in a store.
//
//  Makes a copy of the encoded certificate in the created context.
//
//  If unable to decode and create the certificate context, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT is returned.
//  CERT_CONTEXT must be freed by calling CertFreeCertificateContext.
//  CertDuplicateCertificateContext can be called to make a duplicate.
//
//  CertSetCertificateContextProperty and CertGetCertificateContextProperty can be called
//  to store properties for the certificate.
//--------------------------------------------------------------------------
PCCERT_CONTEXT
WINAPI
CertCreateCertificateContext(
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded
    )
{
    PCCERT_CONTEXT pCertContext;

    CertAddEncodedCertificateToStore(
        NULL,                   // hCertStore
        dwCertEncodingType,
        pbCertEncoded,
        cbCertEncoded,
        CERT_STORE_ADD_ALWAYS,
        &pCertContext
        );
    return pCertContext;
}

//+-------------------------------------------------------------------------
//  Free a certificate context
//
//  There needs to be a corresponding free for each context obtained by a
//  get, find, duplicate or create.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertFreeCertificateContext(
    IN PCCERT_CONTEXT pCertContext
    )
{
    ReleaseContextElement(ToContextElement(pCertContext));
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Set the property for the specified certificate context.
//
//  If the certificate context was obtained from a store, then, the property
//  is added to the store.
//
//  The type definition for pvData depends on the dwPropId value. There are
//  three predefined types:
//      CERT_KEY_PROV_HANDLE_PROP_ID - a HCRYPTPROV for the certificate's
//      private key is passed in pvData. If the
//      CERT_STORE_NO_CRYPT_RELEASE_FLAG isn't set, HCRYPTPROV is implicitly
//      released when either the property is set to NULL or on the final
//      free of the CertContext.
//
//      CERT_KEY_PROV_INFO_PROP_ID - a PCRYPT_KEY_PROV_INFO for the certificate's
//      private key is passed in pvData.
//
//      CERT_SHA1_HASH_PROP_ID       -
//      CERT_MD5_HASH_PROP_ID        -
//      CERT_SIGNATURE_HASH_PROP_ID  - normally, a hash property is implicitly
//      set by doing a CertGetCertificateContextProperty. pvData points to a
//      CRYPT_HASH_BLOB.
//
//  For all the other PROP_IDs: an encoded PCRYPT_DATA_BLOB is passed in pvData.
//
//  If the property already exists, then, the old value is deleted and silently
//  replaced. Setting, pvData to NULL, deletes the property.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSetCertificateContextProperty(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    )
{
    return SetProperty(
        ToContextElement(pCertContext),
        dwPropId,
        dwFlags,
        pvData
        );
}

//+-------------------------------------------------------------------------
//  Get the property for the specified certificate context.
//
//  For CERT_KEY_PROV_HANDLE_PROP_ID, pvData points to a HCRYPTPROV.
//
//  For CERT_KEY_PROV_INFO_PROP_ID, pvData points to a CRYPT_KEY_PROV_INFO structure.
//  Elements pointed to by fields in the pvData structure follow the
//  structure. Therefore, *pcbData may exceed the size of the structure.
//
//  For CERT_SHA1_HASH_PROP_ID or CERT_MD5_HASH_PROP_ID, if the hash
//  doesn't already exist, then, its computed via CryptHashCertificate()
//  and then set. pvData points to the computed hash. Normally, the length
//  is 20 bytes for SHA and 16 for MD5.
//  MD5.
//
//  For CERT_SIGNATURE_HASH_PROP_ID, if the hash
//  doesn't already exist, then, its computed via CryptHashToBeSigned()
//  and then set. pvData points to the computed hash. Normally, the length
//  is 20 bytes for SHA and 16 for MD5.
//
//  For all other PROP_IDs, pvData points to an encoded array of bytes.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertGetCertificateContextProperty(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    return GetProperty(
        ToContextElement(pCertContext),
            dwPropId,
            pvData,
            pcbData
            );
}

//+-------------------------------------------------------------------------
//  Enumerate the properties for the specified certificate context.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertEnumCertificateContextProperties(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId
    )
{
    return EnumProperties(
        ToContextElement(pCertContext),
        dwPropId
        );
}


//+=========================================================================
//  CRL APIs
//==========================================================================

BOOL
WINAPI
CertAddEncodedCRLToStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbCrlEncoded,
    IN DWORD cbCrlEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCRL_CONTEXT *ppCrlContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle = NULL;
    fResult = AddEncodedContextToStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CRL_CONTEXT - 1,
        dwCertEncodingType,
        pbCrlEncoded,
        cbCrlEncoded,
        dwAddDisposition,
        ppCrlContext ? &pStoreEle : NULL
        );
    if (ppCrlContext)
        *ppCrlContext = ToCrlContext(pStoreEle);
    return fResult;
}

BOOL
WINAPI
CertAddCRLContextToStore(
    IN HCERTSTORE hCertStore,
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCRL_CONTEXT *ppStoreContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle = NULL;

    fResult = AddContextToStore(
        (PCERT_STORE) hCertStore,
        ToContextElement(pCrlContext),
        pCrlContext->dwCertEncodingType,
        pCrlContext->pbCrlEncoded,
        pCrlContext->cbCrlEncoded,
        dwAddDisposition,
        ppStoreContext ? &pStoreEle : NULL
        );
    if (ppStoreContext)
        *ppStoreContext = ToCrlContext(pStoreEle);
    return fResult;
}

BOOL
WINAPI
CertAddCRLLinkToStore(
    IN HCERTSTORE hCertStore,
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCRL_CONTEXT *ppStoreContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle = NULL;

    fResult = AddLinkContextToCacheStore(
        (PCERT_STORE) hCertStore,
        ToContextElement(pCrlContext),
        dwAddDisposition,
        ppStoreContext ? &pStoreEle : NULL
        );
    if (ppStoreContext)
        *ppStoreContext = ToCrlContext(pStoreEle);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Serialize the CRL context's encoded CRL and its properties.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSerializeCRLStoreElement(
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwFlags,
    OUT BYTE *pbElement,
    IN OUT DWORD *pcbElement
    )
{
    return SerializeContextElement(
        ToContextElement(pCrlContext),
        dwFlags,
        pbElement,
        pcbElement
        );
}

//+-------------------------------------------------------------------------
//  Delete the specified CRL from the store.
//
//  All subsequent gets for the CRL will fail. However,
//  memory allocated for the CRL isn't freed until all of its contexts
//  have also been freed.
//
//  The pCrlContext is obtained from a get or duplicate.
//
//  NOTE: the pCrlContext is always CertFreeCRLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertDeleteCRLFromStore(
    IN PCCRL_CONTEXT pCrlContext
    )
{
    assert(NULL == pCrlContext || (CERT_STORE_CRL_CONTEXT - 1) ==
        ToContextElement(pCrlContext)->dwContextType);
    return DeleteContextElement(ToContextElement(pCrlContext));
}

//+-------------------------------------------------------------------------
//  Perform the enabled verification checks on the CRL using the issuer
//--------------------------------------------------------------------------
STATIC void VerifyCrl(
    IN PCCRL_CONTEXT pCrl,
    IN OPTIONAL PCCERT_CONTEXT pIssuer,
    IN OUT DWORD *pdwFlags
    )
{
    if (*pdwFlags & CERT_STORE_TIME_VALIDITY_FLAG) {
        if (CertVerifyCRLTimeValidity(NULL,
                pCrl->pCrlInfo) == 0)
            *pdwFlags &= ~CERT_STORE_TIME_VALIDITY_FLAG;
    }

    if (*pdwFlags & (CERT_STORE_BASE_CRL_FLAG | CERT_STORE_DELTA_CRL_FLAG)) {
        PCERT_EXTENSION pDeltaExt;

        pDeltaExt = CertFindExtension(
            szOID_DELTA_CRL_INDICATOR,
            pCrl->pCrlInfo->cExtension,
            pCrl->pCrlInfo->rgExtension
            );

        if (*pdwFlags & CERT_STORE_DELTA_CRL_FLAG) {
            if (NULL != pDeltaExt)
                *pdwFlags &= ~CERT_STORE_DELTA_CRL_FLAG;
        }

        if (*pdwFlags & CERT_STORE_BASE_CRL_FLAG) {
            if (NULL == pDeltaExt)
                *pdwFlags &= ~CERT_STORE_BASE_CRL_FLAG;
        }
    }

    if (pIssuer == NULL) {
        if (*pdwFlags & CERT_STORE_SIGNATURE_FLAG)
            *pdwFlags |= CERT_STORE_NO_ISSUER_FLAG;
        return;
    }

    if (*pdwFlags & CERT_STORE_SIGNATURE_FLAG) {
        PCERT_STORE pStore = (PCERT_STORE) pIssuer->hCertStore;
        HCRYPTPROV hProv;
        DWORD dwProvFlags;

        // Attempt to get the store's crypt provider. Serialize crypto
        // operations by entering critical section.
        hProv = GetCryptProv(pStore, &dwProvFlags);
#ifdef CMS_PKCS7
        if (VerifyCertificateSignatureWithChainPubKeyParaInheritance(
                hProv,
                pCrl->dwCertEncodingType,
                CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL,
                (void *) pCrl,
                pIssuer
                ))
#else
        if (CryptVerifyCertificateSignature(
                hProv,
                pCrl->dwCertEncodingType,
                pCrl->pbCrlEncoded,
                pCrl->cbCrlEncoded,
                &pIssuer->pCertInfo->SubjectPublicKeyInfo
                ))
#endif  // CMS_PKCS7
            *pdwFlags &= ~CERT_STORE_SIGNATURE_FLAG;
        // For the store's crypt provider, release reference count. Leave
        // crypto operations critical section.
        ReleaseCryptProv(pStore, dwProvFlags);
    }
}

//+-------------------------------------------------------------------------
//  Get the first or next CRL context from the store for the specified
//  issuer certificate. Perform the enabled verification checks on the CRL.
//
//  If the first or next CRL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CRL_CONTEXT is returned. CRL_CONTEXT
//  must be freed by calling CertFreeCRLContext or is freed when passed as the
//  pPrevCrlContext on a subsequent call. CertDuplicateCRLContext
//  can be called to make a duplicate.
//
//  The pIssuerContext may have been obtained from this store, another store
//  or created by the caller application. When created by the caller, the
//  CertCreateCertificateContext function must have been called.
//
//  If pIssuerContext == NULL, finds all the CRLs in the store.
//
//  An issuer may have multiple CRLs. For example, it generates delta CRLs
//  using a X.509 v3 extension. pPrevCrlContext MUST BE NULL on the first
//  call to get the CRL. To get the next CRL for the issuer, the
//  pPrevCrlContext is set to the CRL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCrlContext is always CertFreeCRLContext'ed by
//  this function, even for an error.
//
//  The following flags can be set in *pdwFlags to enable verification checks
//  on the returned CRL:
//      CERT_STORE_SIGNATURE_FLAG     - use the public key in the
//                                      issuer's certificate to verify the
//                                      signature on the returned CRL.
//                                      Note, if pIssuerContext->hCertStore ==
//                                      hCertStore, the store provider might
//                                      be able to eliminate a redo of
//                                      the signature verify.
//      CERT_STORE_TIME_VALIDITY_FLAG - get the current time and verify that
//                                      its within the CRL's ThisUpdate and
//                                      NextUpdate validity period.
//      CERT_STORE_BASE_CRL_FLAG      - get base CRL. 
//      CERT_STORE_DELTA_CRL_FLAG     - get delta CRL.
//
//  If only one of CERT_STORE_BASE_CRL_FLAG or CERT_STORE_DELTA_CRL_FLAG is
//  set, then, only returns either a base or delta CRL. In any case, the
//  appropriate base or delta flag will be cleared upon returned. If both
//  flags are set, then, only one of flags will be cleared.
//
//  If an enabled verification check fails, then, its flag is set upon return.
//
//  If pIssuerContext == NULL, then, an enabled CERT_STORE_SIGNATURE_FLAG
//  always fails and the CERT_STORE_NO_ISSUER_FLAG is also set.
//
//  For a verification check failure, a pointer to the first or next
//  CRL_CONTEXT is still returned and SetLastError isn't updated.
//--------------------------------------------------------------------------
PCCRL_CONTEXT
WINAPI
CertGetCRLFromStore(
    IN HCERTSTORE hCertStore,
    IN OPTIONAL PCCERT_CONTEXT pIssuerContext,
    IN PCCRL_CONTEXT pPrevCrlContext,
    IN OUT DWORD *pdwFlags
    )
{
    CERT_STORE_PROV_FIND_INFO FindInfo;
    DWORD dwMsgAndCertEncodingType;
    PCCRL_CONTEXT pCrlContext;

    if (*pdwFlags & ~(CERT_STORE_SIGNATURE_FLAG     |
                      CERT_STORE_TIME_VALIDITY_FLAG |
                      CERT_STORE_BASE_CRL_FLAG      |
                      CERT_STORE_DELTA_CRL_FLAG))
        goto InvalidArg;

    if (NULL == pIssuerContext)
        dwMsgAndCertEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
    else
        dwMsgAndCertEncodingType = pIssuerContext->dwCertEncodingType;

    FindInfo.cbSize = sizeof(FindInfo);
    FindInfo.dwMsgAndCertEncodingType = dwMsgAndCertEncodingType;

    FindInfo.dwFindFlags = 0;
    if (*pdwFlags & CERT_STORE_BASE_CRL_FLAG)
        FindInfo.dwFindFlags |= CRL_FIND_ISSUED_BY_BASE_FLAG;
    if (*pdwFlags & CERT_STORE_DELTA_CRL_FLAG)
        FindInfo.dwFindFlags |= CRL_FIND_ISSUED_BY_DELTA_FLAG;

    FindInfo.dwFindType = CRL_FIND_ISSUED_BY;
    FindInfo.pvFindPara = pIssuerContext;

    if (pCrlContext = ToCrlContext(CheckAutoResyncAndFindElementInStore(
            (PCERT_STORE) hCertStore,
            CERT_STORE_CRL_CONTEXT - 1,
            &FindInfo,
            ToContextElement(pPrevCrlContext)
            )))
        VerifyCrl(
            pCrlContext,
            pIssuerContext,
            pdwFlags
            );

CommonReturn:
    return pCrlContext;

ErrorReturn:
    if (pPrevCrlContext)
        CertFreeCRLContext(pPrevCrlContext);
    pCrlContext = NULL;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Enumerate the CRL contexts in the store.
//
//  If a CRL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CRL_CONTEXT is returned. CRL_CONTEXT
//  must be freed by calling CertFreeCRLContext or is freed when passed as the
//  pPrevCrlContext on a subsequent call. CertDuplicateCRLContext
//  can be called to make a duplicate.
//
//  pPrevCrlContext MUST BE NULL to enumerate the first
//  CRL in the store. Successive CRLs are enumerated by setting
//  pPrevCrlContext to the CRL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCrlContext is always CertFreeCRLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
PCCRL_CONTEXT
WINAPI
CertEnumCRLsInStore(
    IN HCERTSTORE hCertStore,
    IN PCCRL_CONTEXT pPrevCrlContext
    )
{
    return ToCrlContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CRL_CONTEXT - 1,
        &FindAnyInfo,
        ToContextElement(pPrevCrlContext)
        ));
}

//+-------------------------------------------------------------------------
//  Find the first or next CRL context in the store.
//
//  The CRL is found according to the dwFindType and its pvFindPara.
//  See below for a list of the find types and its parameters.
//
//  Currently dwFindFlags isn't used and must be set to 0.
//
//  Usage of dwCertEncodingType depends on the dwFindType.
//
//  If the first or next CRL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CRL_CONTEXT is returned. CRL_CONTEXT
//  must be freed by calling CertFreeCRLContext or is freed when passed as the
//  pPrevCrlContext on a subsequent call. CertDuplicateCRLContext
//  can be called to make a duplicate.
//
//  pPrevCrlContext MUST BE NULL on the first
//  call to find the CRL. To find the next CRL, the
//  pPrevCrlContext is set to the CRL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCrlContext is always CertFreeCRLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
PCCRL_CONTEXT
WINAPI
CertFindCRLInStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCRL_CONTEXT pPrevCrlContext
    )
{
    CERT_STORE_PROV_FIND_INFO FindInfo;

    FindInfo.cbSize = sizeof(FindInfo);
    FindInfo.dwMsgAndCertEncodingType = dwCertEncodingType;
    FindInfo.dwFindFlags = dwFindFlags;
    FindInfo.dwFindType = dwFindType;
    FindInfo.pvFindPara = pvFindPara;

    return ToCrlContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CRL_CONTEXT - 1,
        &FindInfo,
        ToContextElement(pPrevCrlContext)
        ));
}

//+-------------------------------------------------------------------------
//  Duplicate a CRL context
//--------------------------------------------------------------------------
PCCRL_CONTEXT
WINAPI
CertDuplicateCRLContext(
    IN PCCRL_CONTEXT pCrlContext
    )
{
    if (pCrlContext)
        AddRefContextElement(ToContextElement(pCrlContext));
    return pCrlContext;
}

//+-------------------------------------------------------------------------
//  Create a CRL context from the encoded CRL. The created
//  context isn't put in a store.
//
//  Makes a copy of the encoded CRL in the created context.
//
//  If unable to decode and create the CRL context, NULL is returned.
//  Otherwise, a pointer to a read only CRL_CONTEXT is returned.
//  CRL_CONTEXT must be freed by calling CertFreeCRLContext.
//  CertDuplicateCRLContext can be called to make a duplicate.
//
//  CertSetCRLContextProperty and CertGetCRLContextProperty can be called
//  to store properties for the CRL.
//--------------------------------------------------------------------------
PCCRL_CONTEXT
WINAPI
CertCreateCRLContext(
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbCrlEncoded,
    IN DWORD cbCrlEncoded
    )
{
    PCCRL_CONTEXT pCrlContext;

    CertAddEncodedCRLToStore(
        NULL,                   // hCertStore
        dwCertEncodingType,
        pbCrlEncoded,
        cbCrlEncoded,
        CERT_STORE_ADD_ALWAYS,
        &pCrlContext
        );
    return pCrlContext;
}


//+-------------------------------------------------------------------------
//  Free a CRL context
//
//  There needs to be a corresponding free for each context obtained by a
//  get, duplicate or create.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertFreeCRLContext(
    IN PCCRL_CONTEXT pCrlContext
    )
{
    ReleaseContextElement(ToContextElement(pCrlContext));
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Set the property for the specified CRL context.
//
//  Same Property Ids and semantics as CertSetCertificateContextProperty.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSetCRLContextProperty(
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    )
{
    return SetProperty(
        ToContextElement(pCrlContext),
        dwPropId,
        dwFlags,
        pvData
        );
}

//+-------------------------------------------------------------------------
//  Get the property for the specified CRL context.
//
//  Same Property Ids and semantics as CertGetCertificateContextProperty.
//
//  CERT_SHA1_HASH_PROP_ID, CERT_MD5_HASH_PROP_ID or
//  CERT_SIGNATURE_HASH_PROP_ID is the predefined property of most interest.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertGetCRLContextProperty(
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    return GetProperty(
        ToContextElement(pCrlContext),
        dwPropId,
        pvData,
        pcbData
        );
}

//+-------------------------------------------------------------------------
//  Enumerate the properties for the specified CRL context.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertEnumCRLContextProperties(
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwPropId
    )
{
    return EnumProperties(
        ToContextElement(pCrlContext),
        dwPropId
        );
}

//+-------------------------------------------------------------------------
//  Called by qsort.
//
//  Compare's the CRL entry's serial numbers. Note, since we won't be adding
//  any entries, don't need to worry about leading 0's or ff's. Also, ASN.1
//  decoding should have removed them.
//
//  The elements being sorted are pointers to the CRL entries. Not the
//  CRL entries.
//--------------------------------------------------------------------------
STATIC int __cdecl CompareCrlEntry(
    IN const void *pelem1,
    IN const void *pelem2
    )
{
    PCRL_ENTRY p1 = *((PCRL_ENTRY *) pelem1);
    PCRL_ENTRY p2 = *((PCRL_ENTRY *) pelem2);

    DWORD cb1 = p1->SerialNumber.cbData;
    DWORD cb2 = p2->SerialNumber.cbData;

    if (cb1 == cb2) {
        if (0 == cb1)
            return 0;
        else
            return memcmp(p1->SerialNumber.pbData, p2->SerialNumber.pbData,
                cb1);
    } else if (cb1 < cb2)
        return -1;
    else
        return 1;
}

//+-------------------------------------------------------------------------
//  Called by bsearch.
//
//  Compare's the key's serial number with the CRL entry's serial number
//
//  The elements being searched are pointers to the CRL entries. Not the
//  CRL entries.
//--------------------------------------------------------------------------
STATIC int __cdecl CompareCrlEntrySerialNumber(
    IN const void *pkey,
    IN const void *pvalue
    )
{
    PCRYPT_INTEGER_BLOB pSerialNumber = (PCRYPT_INTEGER_BLOB) pkey;
    PCRL_ENTRY pCrlEntry = *((PCRL_ENTRY *) pvalue);

    DWORD cb1 = pSerialNumber->cbData;
    DWORD cb2 = pCrlEntry->SerialNumber.cbData;

    if (cb1 == cb2) {
        if (0 == cb1)
            return 0;
        else
            return memcmp(pSerialNumber->pbData,
                pCrlEntry->SerialNumber.pbData, cb1);
    } else if (cb1 < cb2)
        return -1;
    else
        return 1;
}

//+-------------------------------------------------------------------------
//  Search the CRL's list of entries for the specified certificate.
//
//  TRUE is returned if we were able to search the list. Otherwise, FALSE is
//  returned,
//
//  For success, if the certificate was found in the list, *ppCrlEntry is
//  updated with a pointer to the entry. Otherwise, *ppCrlEntry is set to NULL.
//  The returned entry isn't allocated and must not be freed.
//
//  dwFlags and pvReserved currently aren't used and must be set to 0 or NULL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertFindCertificateInCRL(
    IN PCCERT_CONTEXT pCert,
    IN PCCRL_CONTEXT pCrlContext,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT PCRL_ENTRY *ppCrlEntry
    )
{
    BOOL fResult;
    PCRL_INFO pInfo = pCrlContext->pCrlInfo;
    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;
    PCRL_ENTRY *ppSortedEntry;
    DWORD cEntry;
    PCRL_ENTRY *ppFoundEntry;

    *ppCrlEntry = NULL;

    // Get qsorted pointers to the CRL Entries
    if (0 == (cEntry = pInfo->cCRLEntry))
        goto SuccessReturn;

    if (NULL == (pCacheEle = GetCacheElement(ToContextElement(pCrlContext))))
        goto NoCacheElementError;
    pCacheStore = pCacheEle->pStore;

    LockStore(pCacheStore);
    if (NULL == (ppSortedEntry =
            ToCrlContextSuffix(pCacheEle)->ppSortedEntry)) {
        if (ppSortedEntry = (PCRL_ENTRY *) PkiNonzeroAlloc(
                cEntry * sizeof(PCRL_ENTRY))) {
            // Initialize the array of entry pointers
            DWORD c = cEntry;
            PCRL_ENTRY p = pInfo->rgCRLEntry;
            PCRL_ENTRY *pp = ppSortedEntry;

            for ( ; c > 0; c--, p++, pp++)
                *pp = p;

            // Now sort the CRL entry pointers
            qsort(ppSortedEntry, cEntry, sizeof(PCRL_ENTRY), CompareCrlEntry);

            ToCrlContextSuffix(pCacheEle)->ppSortedEntry = ppSortedEntry;
        }
    }
    UnlockStore(pCacheStore);
    if (NULL == ppSortedEntry)
        goto OutOfMemory;

    // Search the sorted subject entry pointers
    if (ppFoundEntry = (PCRL_ENTRY *) bsearch(&pCert->pCertInfo->SerialNumber,
            ppSortedEntry, cEntry, sizeof(PCRL_ENTRY),
                CompareCrlEntrySerialNumber))
        *ppCrlEntry = *ppFoundEntry;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    *ppCrlEntry = (PCRL_ENTRY) 1;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(NoCacheElementError)
TRACE_ERROR(OutOfMemory)
}


//+=========================================================================
//  CTL APIs
//==========================================================================
BOOL
WINAPI
CertAddEncodedCTLToStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN const BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCTL_CONTEXT *ppCtlContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle = NULL;
    fResult = AddEncodedContextToStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CTL_CONTEXT - 1,
        dwMsgAndCertEncodingType,
        pbCtlEncoded,
        cbCtlEncoded,
        dwAddDisposition,
        ppCtlContext ? &pStoreEle : NULL
        );
    if (ppCtlContext)
        *ppCtlContext = ToCtlContext(pStoreEle);
    return fResult;
}

BOOL
WINAPI
CertAddCTLContextToStore(
    IN HCERTSTORE hCertStore,
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCTL_CONTEXT *ppStoreContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle = NULL;

    fResult = AddContextToStore(
        (PCERT_STORE) hCertStore,
        ToContextElement(pCtlContext),
        pCtlContext->dwMsgAndCertEncodingType,
        pCtlContext->pbCtlEncoded,
        pCtlContext->cbCtlEncoded,
        dwAddDisposition,
        ppStoreContext ? &pStoreEle : NULL
        );
    if (ppStoreContext)
        *ppStoreContext = ToCtlContext(pStoreEle);
    return fResult;
}

BOOL
WINAPI
CertAddCTLLinkToStore(
    IN HCERTSTORE hCertStore,
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCCTL_CONTEXT *ppStoreContext
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pStoreEle = NULL;

    fResult = AddLinkContextToCacheStore(
        (PCERT_STORE) hCertStore,
        ToContextElement(pCtlContext),
        dwAddDisposition,
        ppStoreContext ? &pStoreEle : NULL
        );
    if (ppStoreContext)
        *ppStoreContext = ToCtlContext(pStoreEle);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Serialize the CTL context's encoded CTL and its properties.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSerializeCTLStoreElement(
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwFlags,
    OUT BYTE *pbElement,
    IN OUT DWORD *pcbElement
    )
{
    return SerializeContextElement(
        ToContextElement(pCtlContext),
        dwFlags,
        pbElement,
        pcbElement
        );
}

//+-------------------------------------------------------------------------
//  Delete the specified CTL from the store.
//
//  All subsequent gets for the CTL will fail. However,
//  memory allocated for the CTL isn't freed until all of its contexts
//  have also been freed.
//
//  The pCtlContext is obtained from a get or duplicate.
//
//  NOTE: the pCtlContext is always CertFreeCTLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertDeleteCTLFromStore(
    IN PCCTL_CONTEXT pCtlContext
    )
{
    assert(NULL == pCtlContext || (CERT_STORE_CTL_CONTEXT - 1) ==
        ToContextElement(pCtlContext)->dwContextType);
    return DeleteContextElement(ToContextElement(pCtlContext));
}

//+-------------------------------------------------------------------------
//  Duplicate a CTL context
//--------------------------------------------------------------------------
PCCTL_CONTEXT
WINAPI
CertDuplicateCTLContext(
    IN PCCTL_CONTEXT pCtlContext
    )
{
    if (pCtlContext)
        AddRefContextElement(ToContextElement(pCtlContext));
    return pCtlContext;
}


//+-------------------------------------------------------------------------
//  Create a CTL context from the encoded CTL. The created
//  context isn't put in a store.
//
//  Makes a copy of the encoded CTL in the created context.
//
//  If unable to decode and create the CTL context, NULL is returned.
//  Otherwise, a pointer to a read only CTL_CONTEXT is returned.
//  CTL_CONTEXT must be freed by calling CertFreeCTLContext.
//  CertDuplicateCTLContext can be called to make a duplicate.
//
//  CertSetCTLContextProperty and CertGetCTLContextProperty can be called
//  to store properties for the CTL.
//--------------------------------------------------------------------------
PCCTL_CONTEXT
WINAPI
CertCreateCTLContext(
    IN DWORD dwMsgAndCertEncodingType,
    IN const BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded
    )
{
    PCCTL_CONTEXT pCtlContext;

    CertAddEncodedCTLToStore(
        NULL,                   // hCertStore
        dwMsgAndCertEncodingType,
        pbCtlEncoded,
        cbCtlEncoded,
        CERT_STORE_ADD_ALWAYS,
        &pCtlContext
        );
    return pCtlContext;
}


//+-------------------------------------------------------------------------
//  Free a CTL context
//
//  There needs to be a corresponding free for each context obtained by a
//  get, duplicate or create.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertFreeCTLContext(
    IN PCCTL_CONTEXT pCtlContext
    )
{
    ReleaseContextElement(ToContextElement(pCtlContext));
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Set the property for the specified CTL context.
//
//  Same Property Ids and semantics as CertSetCertificateContextProperty.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSetCTLContextProperty(
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    )
{
    return SetProperty(
        ToContextElement(pCtlContext),
        dwPropId,
        dwFlags,
        pvData
        );
}

//+-------------------------------------------------------------------------
//  Get the property for the specified CTL context.
//
//  Same Property Ids and semantics as CertGetCertificateContextProperty.
//
//  CERT_SHA1_HASH_PROP_ID or CERT_MD5_HASH_PROP_ID is the predefined
//  property of most interest.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertGetCTLContextProperty(
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    return GetProperty(
        ToContextElement(pCtlContext),
        dwPropId,
        pvData,
        pcbData
        );
}

//+-------------------------------------------------------------------------
//  Enumerate the properties for the specified CTL context.
//--------------------------------------------------------------------------
DWORD
WINAPI
CertEnumCTLContextProperties(
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwPropId
    )
{
    return EnumProperties(
        ToContextElement(pCtlContext),
        dwPropId
        );
}


//+-------------------------------------------------------------------------
//  Enumerate the CTL contexts in the store.
//
//  If a CTL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CTL_CONTEXT is returned. CTL_CONTEXT
//  must be freed by calling CertFreeCTLContext or is freed when passed as the
//  pPrevCtlContext on a subsequent call. CertDuplicateCTLContext
//  can be called to make a duplicate.
//
//  pPrevCtlContext MUST BE NULL to enumerate the first
//  CTL in the store. Successive CTLs are enumerated by setting
//  pPrevCtlContext to the CTL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCtlContext is always CertFreeCTLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
PCCTL_CONTEXT
WINAPI
CertEnumCTLsInStore(
    IN HCERTSTORE hCertStore,
    IN PCCTL_CONTEXT pPrevCtlContext
    )
{
    return ToCtlContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CTL_CONTEXT - 1,
        &FindAnyInfo,
        ToContextElement(pPrevCtlContext)
        ));
}

STATIC BOOL CompareAlgorithmIdentifier(
    IN DWORD dwEncodingType,
    IN PCRYPT_ALGORITHM_IDENTIFIER pAlg1,
    IN PCRYPT_ALGORITHM_IDENTIFIER pAlg2
    )
{
    BOOL fResult = FALSE;
    if (NULL == pAlg1->pszObjId) {
        if (NULL == pAlg2->pszObjId)
            // Both are NULL
            fResult = TRUE;
        // else
        //  One of the OIDs is NULL
    } else if (pAlg2->pszObjId) {
        if (0 == strcmp(pAlg1->pszObjId, pAlg2->pszObjId)) {
            DWORD cb1 = pAlg1->Parameters.cbData;
            BYTE *pb1 = pAlg1->Parameters.pbData;
            DWORD cb2 = pAlg2->Parameters.cbData;
            BYTE *pb2 = pAlg2->Parameters.pbData;

            if (X509_ASN_ENCODING == GET_CERT_ENCODING_TYPE(dwEncodingType)) {
                // Check for NULL parameters: {0x05, 0x00}
                if (2 == cb1 && 0x05 == pb1[0] && 0x00 == pb1[1])
                    cb1 = 0;
                if (2 == cb2 && 0x05 == pb2[0] && 0x00 == pb2[1])
                    cb2 = 0;
            }
            if (cb1 == cb2) {
                if (0 == cb1 || 0 == memcmp(pb1, pb2, cb1))
                    fResult = TRUE;
            }
        }
    }
    // else
    //  One of the OIDs is NULL
    return fResult;
}

//+-------------------------------------------------------------------------
//  Called by qsort. Compare's the CTL entry's SubjectIdentifier.
//
//  The elements being sorted are pointers to the CTL entries. Not the
//  CTL entries.
//--------------------------------------------------------------------------
STATIC int __cdecl CompareCtlEntry(
    IN const void *pelem1,
    IN const void *pelem2
    )
{
    PCTL_ENTRY p1 = *((PCTL_ENTRY *) pelem1);
    PCTL_ENTRY p2 = *((PCTL_ENTRY *) pelem2);

    DWORD cb1 = p1->SubjectIdentifier.cbData;
    DWORD cb2 = p2->SubjectIdentifier.cbData;

    if (cb1 == cb2) {
        if (0 == cb1)
            return 0;
        else
            return memcmp(p1->SubjectIdentifier.pbData,
                p2->SubjectIdentifier.pbData, cb1);
    } else if (cb1 < cb2)
        return -1;
    else
        return 1;
}

//+-------------------------------------------------------------------------
//  Called by bsearch. Compare's the key's SubjectIdentifier with the CTL
//  entry's SubjectIdentifier.
//
//  The elements being searched are pointers to the CTL entries. Not the
//  CTL entries.
//--------------------------------------------------------------------------
STATIC int __cdecl CompareCtlEntrySubjectIdentifier(
    IN const void *pkey,
    IN const void *pvalue
    )
{
    PCRYPT_DATA_BLOB pSubjectIdentifier = (PCRYPT_DATA_BLOB) pkey;
    PCTL_ENTRY pCtlEntry = *((PCTL_ENTRY *) pvalue);

    DWORD cb1 = pSubjectIdentifier->cbData;
    DWORD cb2 = pCtlEntry->SubjectIdentifier.cbData;

    if (cb1 == cb2) {
        if (0 == cb1)
            return 0;
        else
            return memcmp(pSubjectIdentifier->pbData,
                pCtlEntry->SubjectIdentifier.pbData, cb1);
    } else if (cb1 < cb2)
        return -1;
    else
        return 1;
}

//+-------------------------------------------------------------------------
//  Attempt to find the specified subject in the CTL.
//
//  For CTL_CERT_SUBJECT_TYPE, pvSubject points to a CERT_CONTEXT. The CTL's
//  SubjectAlgorithm is examined to determine the representation of the
//  subject's identity. Initially, only SHA1 or MD5 hash will be supported.
//  The appropriate hash property is obtained from the CERT_CONTEXT.
//
//  For CTL_ANY_SUBJECT_TYPE, pvSubject points to the CTL_ANY_SUBJECT_INFO
//  structure which contains the SubjectAlgorithm to be matched in the CTL
//  and the SubjectIdentifer to be matched in one of the CTL entries.
//
//  The cetificate's hash or the CTL_ANY_SUBJECT_INFO's SubjectIdentifier
//  is used as the key in searching the subject entries. A binary
//  memory comparison is done between the key and the entry's SubjectIdentifer.
//
//  dwEncodingType isn't used for either of the above SubjectTypes.
//--------------------------------------------------------------------------
PCTL_ENTRY
WINAPI
CertFindSubjectInCTL(
    IN DWORD dwEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwFlags
    )
{
    PCTL_ENTRY *ppSubjectEntry;
    PCTL_ENTRY pSubjectEntry;
    PCTL_INFO pInfo = pCtlContext->pCtlInfo;

    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;

    BYTE rgbHash[MAX_HASH_LEN];
    CRYPT_DATA_BLOB Key;
    PCTL_ENTRY *ppSortedEntry;
    DWORD cEntry;

    // Get Key to be used in bsearch
    switch (dwSubjectType) {
        case CTL_CERT_SUBJECT_TYPE:
            {
                DWORD Algid;
                DWORD dwPropId;

                if (NULL == pInfo->SubjectAlgorithm.pszObjId)
                    goto NoSubjectAlgorithm;
                Algid = CertOIDToAlgId(pInfo->SubjectAlgorithm.pszObjId);
                switch (Algid) {
                    case CALG_SHA1:
                        dwPropId = CERT_SHA1_HASH_PROP_ID;
                        break;
                    case CALG_MD5:
                        dwPropId = CERT_MD5_HASH_PROP_ID;
                        break;
                    default:
                        goto UnknownAlgid;
                }

                Key.cbData = MAX_HASH_LEN;
                if (!CertGetCertificateContextProperty(
                        (PCCERT_CONTEXT) pvSubject,
                        dwPropId,
                        rgbHash,
                        &Key.cbData) || 0 == Key.cbData)
                    goto GetHashError;
                Key.pbData = rgbHash;
            }
            break;
        case CTL_ANY_SUBJECT_TYPE:
            {
                PCTL_ANY_SUBJECT_INFO pAnyInfo =
                    (PCTL_ANY_SUBJECT_INFO) pvSubject;
                if (pAnyInfo->SubjectAlgorithm.pszObjId &&
                        !CompareAlgorithmIdentifier(
                            (pCtlContext->dwMsgAndCertEncodingType >> 16) &
                                CERT_ENCODING_TYPE_MASK,
                            &pAnyInfo->SubjectAlgorithm,
                            &pInfo->SubjectAlgorithm))
                    goto NotFoundError;

                Key = pAnyInfo->SubjectIdentifier;
            }
            break;
        default:
            goto InvalidSubjectType;
    }


    // Get qsorted pointers to the Subject Entries
    if (0 == (cEntry = pInfo->cCTLEntry))
        goto NoEntryError;

    if (NULL == (pCacheEle = GetCacheElement(ToContextElement(pCtlContext))))
        goto NoCacheElementError;
    pCacheStore = pCacheEle->pStore;

    LockStore(pCacheStore);
    if (NULL == (ppSortedEntry =
            ToCtlContextSuffix(pCacheEle)->ppSortedEntry)) {
        if (ppSortedEntry = (PCTL_ENTRY *) PkiNonzeroAlloc(
                cEntry * sizeof(PCTL_ENTRY))) {
            // Initialize the array of entry pointers
            DWORD c = cEntry;
            PCTL_ENTRY p = pInfo->rgCTLEntry;
            PCTL_ENTRY *pp = ppSortedEntry;

            for ( ; c > 0; c--, p++, pp++)
                *pp = p;

            // Now sort the subject entry pointers
            qsort(ppSortedEntry, cEntry, sizeof(PCTL_ENTRY), CompareCtlEntry);

            ToCtlContextSuffix(pCacheEle)->ppSortedEntry = ppSortedEntry;
        }
    }
    UnlockStore(pCacheStore);
    if (NULL == ppSortedEntry)
        goto OutOfMemory;

    // Search the sorted subject entry pointers
    if (NULL == (ppSubjectEntry = (PCTL_ENTRY *) bsearch(&Key,
            ppSortedEntry, cEntry, sizeof(PCTL_ENTRY),
            CompareCtlEntrySubjectIdentifier)))
        goto NotFoundError;
    pSubjectEntry = *ppSubjectEntry;

CommonReturn:
    return pSubjectEntry;

NotFoundError:
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);
ErrorReturn:
    pSubjectEntry = NULL;
    goto CommonReturn;

SET_ERROR(NoSubjectAlgorithm, CRYPT_E_NOT_FOUND)
SET_ERROR(UnknownAlgid, NTE_BAD_ALGID)
SET_ERROR(NoEntryError, CRYPT_E_NOT_FOUND)
TRACE_ERROR(NoCacheElementError)
TRACE_ERROR(GetHashError)
SET_ERROR(InvalidSubjectType, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
}


//+-------------------------------------------------------------------------
//  Find the first or next CTL context in the store.
//
//  The CTL is found according to the dwFindType and its pvFindPara.
//  See below for a list of the find types and its parameters.
//
//  Currently dwFindFlags isn't used and must be set to 0.
//
//  Usage of dwMsgAndCertEncodingType depends on the dwFindType.
//
//  If the first or next CTL isn't found, NULL is returned.
//  Otherwise, a pointer to a read only CTL_CONTEXT is returned. CTL_CONTEXT
//  must be freed by calling CertFreeCTLContext or is freed when passed as the
//  pPrevCtlContext on a subsequent call. CertDuplicateCTLContext
//  can be called to make a duplicate.
//
//  pPrevCtlContext MUST BE NULL on the first
//  call to find the CTL. To find the next CTL, the
//  pPrevCtlContext is set to the CTL_CONTEXT returned by a previous call.
//
//  NOTE: a NON-NULL pPrevCtlContext is always CertFreeCTLContext'ed by
//  this function, even for an error.
//--------------------------------------------------------------------------
PCCTL_CONTEXT
WINAPI
CertFindCTLInStore(
    IN HCERTSTORE hCertStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFindFlags,
    IN DWORD dwFindType,
    IN const void *pvFindPara,
    IN PCCTL_CONTEXT pPrevCtlContext
    )
{
    CERT_STORE_PROV_FIND_INFO FindInfo;

    FindInfo.cbSize = sizeof(FindInfo);
    FindInfo.dwMsgAndCertEncodingType = dwMsgAndCertEncodingType;
    FindInfo.dwFindFlags = dwFindFlags;
    FindInfo.dwFindType = dwFindType;
    FindInfo.pvFindPara = pvFindPara;

    return ToCtlContext(CheckAutoResyncAndFindElementInStore(
        (PCERT_STORE) hCertStore,
        CERT_STORE_CTL_CONTEXT - 1,
        &FindInfo,
        ToContextElement(pPrevCtlContext)
        ));
}




//+=========================================================================
//  CERT_CONTEXT Functions
//==========================================================================

// pbCertEncoded has already been allocated
STATIC PCONTEXT_ELEMENT CreateCertElement(
    IN PCERT_STORE pStore,
    IN DWORD dwCertEncodingType,
    IN BYTE *pbCertEncoded,
    IN DWORD cbCertEncoded,
    IN OPTIONAL PSHARE_ELEMENT pShareEle
    )
{
    PCONTEXT_ELEMENT pEle = NULL;
    PCERT_CONTEXT pCert;
    PCERT_INFO pInfo = NULL;


    if (0 == GET_CERT_ENCODING_TYPE(dwCertEncodingType)) {
        SetLastError((DWORD) E_INVALIDARG);
        goto ErrorReturn;
    }

    if (NULL == pShareEle) {
        cbCertEncoded = AdjustEncodedLength(
            dwCertEncodingType, pbCertEncoded, cbCertEncoded);

        if (NULL == (pInfo = (PCERT_INFO) AllocAndDecodeObject(
                dwCertEncodingType,
                X509_CERT_TO_BE_SIGNED,
                pbCertEncoded,
                cbCertEncoded))) goto ErrorReturn;
    }

    // Allocate and initialize the cert element structure
    pEle = (PCONTEXT_ELEMENT) PkiZeroAlloc(sizeof(CONTEXT_ELEMENT) +
        sizeof(CERT_CONTEXT));
    if (pEle == NULL) goto ErrorReturn;

    pEle->dwElementType = ELEMENT_TYPE_CACHE;
    pEle->dwContextType = CERT_STORE_CERTIFICATE_CONTEXT - 1;
    pEle->lRefCnt = 1;
    pEle->pEle = pEle;
    pEle->pStore = pStore;
    pEle->pProvStore = pStore;

    pCert = (PCERT_CONTEXT) ToCertContext(pEle);
    pCert->dwCertEncodingType =
        dwCertEncodingType & CERT_ENCODING_TYPE_MASK;
    pCert->pbCertEncoded = pbCertEncoded;
    pCert->cbCertEncoded = cbCertEncoded;
    if (pShareEle) {
        pEle->pShareEle = pShareEle;
        assert(pShareEle->pvInfo);
        pCert->pCertInfo = (PCERT_INFO) pShareEle->pvInfo;
        assert(pbCertEncoded == pShareEle->pbEncoded);
        assert(cbCertEncoded == pShareEle->cbEncoded);
    } else {
        pCert->pCertInfo = pInfo;

        CertPerfIncrementCertElementCurrentCount();
        CertPerfIncrementCertElementTotalCount();
    }
    pCert->hCertStore = (HCERTSTORE) pStore;

CommonReturn:
    return pEle;
ErrorReturn:
    if (pEle) {
        PkiFree(pEle);
        pEle = NULL;
    }
    PkiFree(pInfo);
    goto CommonReturn;
}

STATIC void FreeCertElement(IN PCONTEXT_ELEMENT pEle)
{
    PCCERT_CONTEXT pCert = ToCertContext(pEle);
    if (pEle->pShareEle)
        ReleaseShareElement(pEle->pShareEle);
    else {
        PkiFree(pCert->pbCertEncoded);
        PkiFree(pCert->pCertInfo);

        CertPerfDecrementCertElementCurrentCount();
    }
    PkiFree(pEle);
}

STATIC BOOL CompareCertHash(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwPropId,
    IN PCRYPT_HASH_BLOB pHash
    )
{
    BYTE rgbHash[MAX_HASH_LEN];
    DWORD cbHash = MAX_HASH_LEN;
    CertGetCertificateContextProperty(
        pCert,
        dwPropId,
        rgbHash,
        &cbHash
        );
    if (cbHash == pHash->cbData &&
            memcmp(rgbHash, pHash->pbData, cbHash) == 0)
        return TRUE;
    else
        return FALSE;
}

STATIC BOOL CompareNameStrW(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN LPCWSTR pwszFind
    )
{
    BOOL fResult = FALSE;
    DWORD cwszFind;
    LPWSTR pwszName = NULL;
    DWORD cwszName;

    if (pwszFind == NULL || *pwszFind == L'\0')
        return TRUE;

    cwszName = CertNameToStrW(
        dwCertEncodingType,
        pName,
        CERT_SIMPLE_NAME_STR,
        NULL,                   // pwsz
        0                       // cwsz
        );
    if (pwszName = (LPWSTR) PkiNonzeroAlloc(cwszName * sizeof(WCHAR))) {
        cwszName = CertNameToStrW(
            dwCertEncodingType,
            pName,
            CERT_SIMPLE_NAME_STR,
            pwszName,
            cwszName) - 1;
        cwszFind = wcslen(pwszFind);

        // Start at end of the certificate's name and slide one character
        // to the left until a match or reach the beginning of the
        // certificate name.
        for ( ; cwszName >= cwszFind; cwszName--) {
            pwszName[cwszName] = L'\0';
            if (CSTR_EQUAL == CompareStringU(
                    LOCALE_USER_DEFAULT,
                    NORM_IGNORECASE,
                    pwszFind,
                    -1,
                    &pwszName[cwszName - cwszFind],
                    -1
                    )) {
                fResult = TRUE;
                break;
            }
        }

        PkiFree(pwszName);
    }
    return fResult;
}

STATIC BOOL CompareNameStrA(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pName,
    IN LPCSTR pszFind
    )
{
    BOOL fResult = FALSE;
    DWORD cszFind;
    LPSTR pszName = NULL;
    DWORD cszName;

    if (pszFind == NULL || *pszFind == '\0')
        return TRUE;

    cszName = CertNameToStrA(
        dwCertEncodingType,
        pName,
        CERT_SIMPLE_NAME_STR,
        NULL,                   // psz
        0                       // csz
        );
    if (pszName = (LPSTR) PkiNonzeroAlloc(cszName)) {
        cszName = CertNameToStrA(
            dwCertEncodingType,
            pName,
            CERT_SIMPLE_NAME_STR,
            pszName,
            cszName) - 1;
        cszFind = strlen(pszFind);

        // Start at end of the certificate's name and slide one character
        // to the left until a match or reach the beginning of the
        // certificate name.
        for ( ; cszName >= cszFind; cszName--) {
            pszName[cszName] = '\0';
            if (CSTR_EQUAL == CompareStringA(
                    LOCALE_USER_DEFAULT,
                    NORM_IGNORECASE,
                    pszFind,
                    -1,
                    &pszName[cszName - cszFind],
                    -1
                    )) {
                fResult = TRUE;
                break;
            }
        }

        PkiFree(pszName);
    }
    return fResult;
}

STATIC BOOL CompareCtlUsageIdentifiers(
    IN PCTL_USAGE pPara,
    IN DWORD cUsage,
    IN PCTL_USAGE pUsage,
    IN BOOL fOrUsage
    )
{
    if (pPara && pPara->cUsageIdentifier) {
        DWORD cId1 = pPara->cUsageIdentifier;
        LPSTR *ppszId1 = pPara->rgpszUsageIdentifier;
        for ( ; cId1 > 0; cId1--, ppszId1++) {
            DWORD i;
            for (i = 0; i < cUsage; i++) {
                DWORD cId2 = pUsage[i].cUsageIdentifier;
                LPSTR *ppszId2 = pUsage[i].rgpszUsageIdentifier;
                for ( ; cId2 > 0; cId2--, ppszId2++) {
                    if (0 == strcmp(*ppszId1, *ppszId2)) {
                        if (fOrUsage)
                            return TRUE;
                        break;
                    }
                }
                if (cId2 > 0)
                    break;
            }
            if (i == cUsage && !fOrUsage)
                return FALSE;
        }

        if (fOrUsage)
            // For the "OR" option we're here without any match
            return FALSE;
        // else
        //  For the "AND" option we have matched all the specified
        //  identifiers
    }
    return TRUE;
}

STATIC BOOL CompareCertUsage(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwFindFlags,
    IN PCTL_USAGE pPara
    )
{
    BOOL fResult;
    PCERT_INFO pInfo = pCert->pCertInfo;
    PCERT_EXTENSION pExt;       // not allocated
    DWORD cbData;

    PCTL_USAGE pExtUsage = NULL;
    PCTL_USAGE pPropUsage = NULL;
    BYTE *pbPropData = NULL;

    CTL_USAGE rgUsage[2];   // Ext and/or Prop
    DWORD cUsage = 0;

    if (CERT_FIND_VALID_CTL_USAGE_FLAG & dwFindFlags)
        return IFC_IsEndCertValidForUsages(
            pCert,
            pPara,
            0 != (dwFindFlags & CERT_FIND_OR_CTL_USAGE_FLAG));

    if (0 == (CERT_FIND_PROP_ONLY_CTL_USAGE_FLAG & dwFindFlags)) {
        // Is there an Enhanced Key Usage Extension ??
        if (pExt = CertFindExtension(
                szOID_ENHANCED_KEY_USAGE,
                pInfo->cExtension,
                pInfo->rgExtension
                )) {
            if (pExtUsage = (PCTL_USAGE) AllocAndDecodeObject(
                    pCert->dwCertEncodingType,
                    X509_ENHANCED_KEY_USAGE,
                    pExt->Value.pbData,
                    pExt->Value.cbData))
                rgUsage[cUsage++] = *pExtUsage;
        }
    }

    if (0 == (CERT_FIND_EXT_ONLY_CTL_USAGE_FLAG & dwFindFlags)) {
        // Is there an Enhanced Key Usage (CTL Usage) property ??
        if (CertGetCertificateContextProperty(
                pCert,
                CERT_CTL_USAGE_PROP_ID,
                NULL,                       // pvData
                &cbData) && cbData) {
            if (pbPropData = (BYTE *) PkiNonzeroAlloc(cbData)) {
                if (CertGetCertificateContextProperty(
                        pCert,
                        CERT_CTL_USAGE_PROP_ID,
                        pbPropData,
                        &cbData)) {
                    if (pPropUsage = (PCTL_USAGE) AllocAndDecodeObject(
                            pCert->dwCertEncodingType,
                            X509_ENHANCED_KEY_USAGE,
                            pbPropData,
                            cbData))
                        rgUsage[cUsage++] = *pPropUsage;
                }
            }
        }
    }

    if (cUsage > 0) {
        if (dwFindFlags & CERT_FIND_NO_CTL_USAGE_FLAG)
            fResult = FALSE;
        else
            fResult = CompareCtlUsageIdentifiers(pPara, cUsage, rgUsage,
                0 != (dwFindFlags & CERT_FIND_OR_CTL_USAGE_FLAG));
    } else if (dwFindFlags & (CERT_FIND_OPTIONAL_CTL_USAGE_FLAG |
            CERT_FIND_NO_CTL_USAGE_FLAG))
        fResult = TRUE;
    else
        fResult = FALSE;

    PkiFree(pExtUsage);
    PkiFree(pPropUsage);
    PkiFree(pbPropData);

    return fResult;
}

STATIC BOOL IsSameCert(
    IN PCCERT_CONTEXT pCert,
    IN PCCERT_CONTEXT pNew
    )
{
    BYTE rgbCertHash[SHA1_HASH_LEN];
    DWORD cbCertHash = SHA1_HASH_LEN;
    BYTE rgbNewHash[SHA1_HASH_LEN];
    DWORD cbNewHash = SHA1_HASH_LEN;

    CertGetCertificateContextProperty(
        pCert,
        CERT_SHA1_HASH_PROP_ID,
        rgbCertHash,
        &cbCertHash
        );

    CertGetCertificateContextProperty(
        pNew,
        CERT_SHA1_HASH_PROP_ID,
        rgbNewHash,
        &cbNewHash
        );

    if (SHA1_HASH_LEN == cbCertHash && SHA1_HASH_LEN == cbNewHash &&
            0 == memcmp(rgbCertHash, rgbNewHash, SHA1_HASH_LEN))
        return TRUE;
    else
        return FALSE;
}

STATIC BOOL CompareCertElement(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    )
{
    PCCERT_CONTEXT pCert = ToCertContext(pEle);
    DWORD dwCmp = (pFindInfo->dwFindType >> CERT_COMPARE_SHIFT) &
        CERT_COMPARE_MASK;
    const void *pvFindPara = pFindInfo->pvFindPara;

    if (fArchived) {
        switch (dwCmp) {
            case CERT_COMPARE_SHA1_HASH:
            case CERT_COMPARE_MD5_HASH:
            case CERT_COMPARE_SIGNATURE_HASH:
            case CERT_COMPARE_SUBJECT_CERT:
#ifdef CMS_PKCS7
            case CERT_COMPARE_CERT_ID:
#endif  // CMS_PKCS7
            case CERT_COMPARE_PUBKEY_MD5_HASH:
                break;
            default:
                return FALSE;
        }
    }

    switch (dwCmp) {
        case CERT_COMPARE_ANY:
            return TRUE;
            break;

        case CERT_COMPARE_SHA1_HASH:
        case CERT_COMPARE_MD5_HASH:
        case CERT_COMPARE_SIGNATURE_HASH:
        case CERT_COMPARE_KEY_IDENTIFIER:
        case CERT_COMPARE_PUBKEY_MD5_HASH:
            {
                DWORD dwPropId;
                switch (dwCmp) {
                    case CERT_COMPARE_SHA1_HASH:
                        dwPropId = CERT_SHA1_HASH_PROP_ID;
                        break;
                    case CERT_COMPARE_SIGNATURE_HASH:
                        dwPropId = CERT_SIGNATURE_HASH_PROP_ID;
                        break;
                    case CERT_COMPARE_KEY_IDENTIFIER:
                        dwPropId = CERT_KEY_IDENTIFIER_PROP_ID;
                        break;
                    case CERT_COMPARE_PUBKEY_MD5_HASH:
                        dwPropId = CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID;
                        break;
                    case CERT_COMPARE_MD5_HASH:
                    default:
                        dwPropId = CERT_MD5_HASH_PROP_ID;
                }
                return CompareCertHash(pCert, dwPropId,
                    (PCRYPT_HASH_BLOB) pvFindPara);
            }
            break;

        case CERT_COMPARE_NAME:
            {
                PCERT_NAME_BLOB pName;
                DWORD dwInfo = pFindInfo->dwFindType & 0xFF;
                DWORD dwCertEncodingType =
                    pFindInfo->dwMsgAndCertEncodingType &
                        CERT_ENCODING_TYPE_MASK;

                if (dwInfo == CERT_INFO_SUBJECT_FLAG)
                    pName = &pCert->pCertInfo->Subject;
                else if (dwInfo == CERT_INFO_ISSUER_FLAG)
                    pName = &pCert->pCertInfo->Issuer;
                else goto BadParameter;

                return dwCertEncodingType == pCert->dwCertEncodingType &&
                        CertCompareCertificateName(dwCertEncodingType,
                            pName, (PCERT_NAME_BLOB) pvFindPara);
            }
            break;

        case CERT_COMPARE_ATTR:
            {
                PCERT_NAME_BLOB pName;
                DWORD dwInfo = pFindInfo->dwFindType & 0xFF;
                DWORD dwCertEncodingType =
                    pFindInfo->dwMsgAndCertEncodingType &
                        CERT_ENCODING_TYPE_MASK;

                if (dwInfo == CERT_INFO_SUBJECT_FLAG)
                    pName = &pCert->pCertInfo->Subject;
                else if (dwInfo == CERT_INFO_ISSUER_FLAG)
                    pName = &pCert->pCertInfo->Issuer;
                else goto BadParameter;

                return dwCertEncodingType == pCert->dwCertEncodingType &&
                        CertIsRDNAttrsInCertificateName(dwCertEncodingType,
                            pFindInfo->dwFindFlags, pName,
                        (PCERT_RDN) pvFindPara);
            }
            break;

        case CERT_COMPARE_PROPERTY:
            {
                DWORD dwPropId = *((DWORD *) pvFindPara);
                DWORD cbData = 0;
                return CertGetCertificateContextProperty(
                        pCert,
                        dwPropId,
                        NULL,       //pvData
                        &cbData);
            }
            break;

        case CERT_COMPARE_PUBLIC_KEY:
            {
                return CertComparePublicKeyInfo(
                        pCert->dwCertEncodingType,
                        &pCert->pCertInfo->SubjectPublicKeyInfo,
                        (PCERT_PUBLIC_KEY_INFO) pvFindPara);
            }
            break;

        case CERT_COMPARE_NAME_STR_A:
        case CERT_COMPARE_NAME_STR_W:
            {
                PCERT_NAME_BLOB pName;
                DWORD dwInfo = pFindInfo->dwFindType & 0xFF;
                DWORD dwCertEncodingType =
                    pFindInfo->dwMsgAndCertEncodingType &
                        CERT_ENCODING_TYPE_MASK;

                if (dwInfo == CERT_INFO_SUBJECT_FLAG)
                    pName = &pCert->pCertInfo->Subject;
                else if (dwInfo == CERT_INFO_ISSUER_FLAG)
                    pName = &pCert->pCertInfo->Issuer;
                else goto BadParameter;

                if (dwCertEncodingType == pCert->dwCertEncodingType) {
                    if (dwCmp == CERT_COMPARE_NAME_STR_W)
                        return CompareNameStrW(dwCertEncodingType,
                                pName, (LPCWSTR) pvFindPara);
                    else
                        return CompareNameStrA(dwCertEncodingType,
                                pName, (LPCSTR) pvFindPara);
                } else
                    return FALSE;
            }
            break;

        case CERT_COMPARE_KEY_SPEC:
            {
                DWORD dwKeySpec;
                DWORD cbData = sizeof(dwKeySpec);

                return CertGetCertificateContextProperty(
                            pCert,
                            CERT_KEY_SPEC_PROP_ID,
                            &dwKeySpec,
                            &cbData) &&
                        dwKeySpec == *((DWORD *) pvFindPara);
            }
            break;

        case CERT_COMPARE_CTL_USAGE:
            return CompareCertUsage(pCert, pFindInfo->dwFindFlags,
                (PCTL_USAGE) pvFindPara);
            break;

        case CERT_COMPARE_SUBJECT_CERT:
            {
                DWORD dwCertEncodingType =
                    pFindInfo->dwMsgAndCertEncodingType &
                        CERT_ENCODING_TYPE_MASK;
                PCERT_INFO pCertId = (PCERT_INFO) pvFindPara;
                CRYPT_HASH_BLOB KeyId;

                if (dwCertEncodingType != pCert->dwCertEncodingType)
                    return FALSE;
                if (Asn1UtilExtractKeyIdFromCertInfo(
                        pCertId,
                        &KeyId
                        ))
                    return CompareCertHash(pCert,
                        CERT_KEY_IDENTIFIER_PROP_ID,
                        &KeyId
                        );
                else
                    return CertCompareCertificate(
                        dwCertEncodingType,
                        pCertId,
                        pCert->pCertInfo);
            }
            break;

        case CERT_COMPARE_ISSUER_OF:
            {
                PCCERT_CONTEXT pSubject =
                    (PCCERT_CONTEXT) pvFindPara;
                return pSubject->dwCertEncodingType ==
                        pCert->dwCertEncodingType &&
                    CertCompareCertificateName(
                        pSubject->dwCertEncodingType,
                        &pSubject->pCertInfo->Issuer,
                        &pCert->pCertInfo->Subject);
            }
            break;

        case CERT_COMPARE_EXISTING:
            return IsSameCert((PCCERT_CONTEXT) pvFindPara, pCert);
            break;

#ifdef CMS_PKCS7
        case CERT_COMPARE_CERT_ID:
            {
                PCERT_ID pCertId = (PCERT_ID) pvFindPara;
                switch (pCertId->dwIdChoice) {
                    case CERT_ID_ISSUER_SERIAL_NUMBER:
                        {
                            PCRYPT_INTEGER_BLOB pCertSerialNumber =
                                &pCert->pCertInfo->SerialNumber;
                            PCERT_NAME_BLOB pCertIssuer =
                                &pCert->pCertInfo->Issuer;

                            PCRYPT_INTEGER_BLOB pParaSerialNumber =
                                &pCertId->IssuerSerialNumber.SerialNumber;
                            PCERT_NAME_BLOB pParaIssuer =
                                &pCertId->IssuerSerialNumber.Issuer;

                            if (CertCompareIntegerBlob(pCertSerialNumber,
                                    pParaSerialNumber)
                                        &&
                                pCertIssuer->cbData == pParaIssuer->cbData
                                        &&
                                memcmp(pCertIssuer->pbData,
                                    pParaIssuer->pbData,
                                        pCertIssuer->cbData) == 0)
                                return TRUE;
                            else
                                return FALSE;
                        }
                        break;
                    case CERT_ID_KEY_IDENTIFIER:
                        return CompareCertHash(pCert,
                            CERT_KEY_IDENTIFIER_PROP_ID,
                            &pCertId->KeyId
                            );
                        break;
                    case CERT_ID_SHA1_HASH:
                        return CompareCertHash(pCert,
                            CERT_SHA1_HASH_PROP_ID,
                            &pCertId->HashId
                            );
                        break;
                    default:
                        goto BadParameter;
                }
            }
            break;
#endif  // CMS_PKCS7

        case CERT_COMPARE_CROSS_CERT_DIST_POINTS:
            {
                DWORD cbData = 0;
                if (CertFindExtension(
                            szOID_CROSS_CERT_DIST_POINTS,
                            pCert->pCertInfo->cExtension,
                            pCert->pCertInfo->rgExtension) ||
                    CertGetCertificateContextProperty(
                            pCert,
                            CERT_CROSS_CERT_DIST_POINTS_PROP_ID,
                            NULL,       // pvData
                            &cbData))
                    return TRUE;
                else
                    return FALSE;
            }
            break;

        default:
            goto BadParameter;
    }

BadParameter:
    SetLastError((DWORD) E_INVALIDARG);
    return FALSE;
}

STATIC BOOL IsNewerCertElement(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    )
{
    PCCERT_CONTEXT pNewCert = ToCertContext(pNewEle);
    PCCERT_CONTEXT pExistingCert = ToCertContext(pExistingEle);

    // CompareFileTime returns +1 if first time > second time
    return (0 < CompareFileTime(
        &pNewCert->pCertInfo->NotBefore,
        &pExistingCert->pCertInfo->NotBefore
        ));
}

//+=========================================================================
//  CRL_CONTEXT Functions
//==========================================================================

// pbCrlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT CreateCrlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwCertEncodingType,
    IN BYTE *pbCrlEncoded,
    IN DWORD cbCrlEncoded,
    IN OPTIONAL PSHARE_ELEMENT pShareEle
    )
{
    PCONTEXT_ELEMENT pEle = NULL;
    PCRL_CONTEXT pCrl;
    PCRL_CONTEXT_SUFFIX pCrlSuffix;
    PCRL_INFO pInfo = NULL;

    if (0 == GET_CERT_ENCODING_TYPE(dwCertEncodingType)) {
        SetLastError((DWORD) E_INVALIDARG);
        goto ErrorReturn;
    }

    if (NULL == pShareEle) {
        cbCrlEncoded = AdjustEncodedLength(
            dwCertEncodingType, pbCrlEncoded, cbCrlEncoded);

        if (NULL == (pInfo = (PCRL_INFO) AllocAndDecodeObject(
                dwCertEncodingType,
                X509_CERT_CRL_TO_BE_SIGNED,
                pbCrlEncoded,
                cbCrlEncoded))) goto ErrorReturn;
    }

    // Allocate and initialize the CRL element structure
    pEle = (PCONTEXT_ELEMENT) PkiZeroAlloc(sizeof(CONTEXT_ELEMENT) +
        sizeof(CRL_CONTEXT) + sizeof(CRL_CONTEXT_SUFFIX));
    if (pEle == NULL) goto ErrorReturn;

    pEle->dwElementType = ELEMENT_TYPE_CACHE;
    pEle->dwContextType = CERT_STORE_CRL_CONTEXT - 1;
    pEle->lRefCnt = 1;
    pEle->pEle = pEle;
    pEle->pStore = pStore;
    pEle->pProvStore = pStore;

    pCrl = (PCRL_CONTEXT) ToCrlContext(pEle);
    pCrl->dwCertEncodingType =
        dwCertEncodingType & CERT_ENCODING_TYPE_MASK;
    pCrl->pbCrlEncoded = pbCrlEncoded;
    pCrl->cbCrlEncoded = cbCrlEncoded;
    if (pShareEle) {
        pEle->pShareEle = pShareEle;
        assert(pShareEle->pvInfo);
        pCrl->pCrlInfo = (PCRL_INFO) pShareEle->pvInfo;
        assert(pbCrlEncoded == pShareEle->pbEncoded);
        assert(cbCrlEncoded == pShareEle->cbEncoded);
    } else {
        pCrl->pCrlInfo = pInfo;

        CertPerfIncrementCrlElementCurrentCount();
        CertPerfIncrementCrlElementTotalCount();
    }
    pCrl->hCertStore = (HCERTSTORE) pStore;

    pCrlSuffix = ToCrlContextSuffix(pEle);
    pCrlSuffix->ppSortedEntry = NULL;

CommonReturn:
    return pEle;

ErrorReturn:
    if (pEle) {
        PkiFree(pEle);
        pEle = NULL;
    }
    PkiFree(pInfo);
    goto CommonReturn;
}

STATIC void FreeCrlElement(IN PCONTEXT_ELEMENT pEle)
{
    PCCRL_CONTEXT pCrl = ToCrlContext(pEle);
    PCRL_CONTEXT_SUFFIX pCrlSuffix = ToCrlContextSuffix(pEle);
    if (pEle->pShareEle)
        ReleaseShareElement(pEle->pShareEle);
    else {
        PkiFree(pCrl->pbCrlEncoded);
        PkiFree(pCrl->pCrlInfo);

        CertPerfDecrementCrlElementCurrentCount();
    }
    PkiFree(pCrlSuffix->ppSortedEntry);
    PkiFree(pEle);
}

STATIC BOOL IsSameEncodedCrlExtension(
    IN LPCSTR pszObjId,
    IN PCCRL_CONTEXT pCrl,
    IN PCCRL_CONTEXT pNew
    )
{
    PCERT_EXTENSION pCrlExt;
    PCERT_EXTENSION pNewExt;

    // If they exist, compare the encoded extensions.
    pNewExt = CertFindExtension(
        pszObjId,
        pNew->pCrlInfo->cExtension,
        pNew->pCrlInfo->rgExtension
        );
    pCrlExt = CertFindExtension(
        pszObjId,
        pCrl->pCrlInfo->cExtension,
        pCrl->pCrlInfo->rgExtension
        );

    if (pNewExt) {
        if (pCrlExt) {
            DWORD dwCertEncodingType = pCrl->dwCertEncodingType;
            DWORD cbNewExt = pNewExt->Value.cbData;
            BYTE *pbNewExt = pNewExt->Value.pbData;
            DWORD cbCrlExt = pCrlExt->Value.cbData;
            BYTE *pbCrlExt = pCrlExt->Value.pbData;

            // Before comparing, adjust lengths to only include the
            // encoded bytes
            cbNewExt = AdjustEncodedLength(dwCertEncodingType,
                pbNewExt, cbNewExt);
            cbCrlExt = AdjustEncodedLength(dwCertEncodingType,
                pbCrlExt, cbCrlExt);

            if (cbNewExt != cbCrlExt ||
                    0 != memcmp(pbNewExt, pbCrlExt, cbNewExt))
                return FALSE;
        } else
            // Only one has the extension
            return FALSE;
    } else if (pCrlExt)
        // Only one has the extension
        return FALSE;
    // else
        // Neither has the extension

    return TRUE;
}

STATIC BOOL IsSameCrl(
    IN PCCRL_CONTEXT pCrl,
    IN PCCRL_CONTEXT pNew
    )
{
    DWORD dwCertEncodingType;
    PCERT_EXTENSION pCrlDeltaExt;
    PCERT_EXTENSION pNewDeltaExt;

    // Check: encoding type and issuer name
    dwCertEncodingType = pNew->dwCertEncodingType;
    if (dwCertEncodingType != pCrl->dwCertEncodingType ||
            !CertCompareCertificateName(
                dwCertEncodingType,
                &pCrl->pCrlInfo->Issuer,
                &pNew->pCrlInfo->Issuer))
        return FALSE;

    // Check that both are either base or delta CRLs
    pNewDeltaExt = CertFindExtension(
        szOID_DELTA_CRL_INDICATOR,
        pNew->pCrlInfo->cExtension,
        pNew->pCrlInfo->rgExtension
        );
    pCrlDeltaExt = CertFindExtension(
        szOID_DELTA_CRL_INDICATOR,
        pCrl->pCrlInfo->cExtension,
        pCrl->pCrlInfo->rgExtension
        );
    if (pNewDeltaExt) {
        if (NULL == pCrlDeltaExt)
            // Only one has a Delta extension
            return FALSE;
        // else
            // Both have a Delta extension
    } else if (pCrlDeltaExt)
        // Only one has a Delta extension
        return FALSE;
    // else
        // Neither has a Delta extension
    

    // If they exist, compare encoded AuthorityKeyIdentifier and
    // IssuingDistributionPoint extensions.
    if (!IsSameEncodedCrlExtension(
            szOID_AUTHORITY_KEY_IDENTIFIER2,
            pCrl,
            pNew
            ))
        return FALSE;

    if (!IsSameEncodedCrlExtension(
            szOID_ISSUING_DIST_POINT,
            pCrl,
            pNew
            ))
        return FALSE;

    return TRUE;
}

STATIC BOOL IsIssuedByCrl(
    IN PCCRL_CONTEXT pCrl,
    IN PCCERT_CONTEXT pIssuer,
    IN PCERT_NAME_BLOB pIssuerName,
    IN DWORD dwFindFlags
    )
{
    DWORD dwCertEncodingType;

    if (dwFindFlags &
            (CRL_FIND_ISSUED_BY_DELTA_FLAG | CRL_FIND_ISSUED_BY_BASE_FLAG)) {
        PCERT_EXTENSION pDeltaExt;

        pDeltaExt = CertFindExtension(
            szOID_DELTA_CRL_INDICATOR,
            pCrl->pCrlInfo->cExtension,
            pCrl->pCrlInfo->rgExtension
            );

        if (pDeltaExt) {
            if (0 == (dwFindFlags & CRL_FIND_ISSUED_BY_DELTA_FLAG))
                return FALSE;
        } else {
            if (0 == (dwFindFlags & CRL_FIND_ISSUED_BY_BASE_FLAG))
                return FALSE;
        }
    }

    if (NULL == pIssuer)
        return TRUE;

    dwCertEncodingType = pIssuer->dwCertEncodingType;
    if (dwCertEncodingType != pCrl->dwCertEncodingType ||
            !CertCompareCertificateName(
                dwCertEncodingType,
                &pCrl->pCrlInfo->Issuer,
                pIssuerName))
        return FALSE;

    if (dwFindFlags & CRL_FIND_ISSUED_BY_AKI_FLAG) {
        PCERT_EXTENSION pCrlAKIExt;

        pCrlAKIExt = CertFindExtension(
            szOID_AUTHORITY_KEY_IDENTIFIER2,
            pCrl->pCrlInfo->cExtension,
            pCrl->pCrlInfo->rgExtension
            );
        if (pCrlAKIExt) {
            PCERT_AUTHORITY_KEY_ID2_INFO pInfo;
            BOOL fResult;
    
            if (NULL == (pInfo =
                (PCERT_AUTHORITY_KEY_ID2_INFO) AllocAndDecodeObject(
                    dwCertEncodingType,
                    X509_AUTHORITY_KEY_ID2,
                    pCrlAKIExt->Value.pbData,
                    pCrlAKIExt->Value.cbData
                    )))
                return FALSE;

            if (pInfo->KeyId.cbData)
                fResult = CompareCertHash(
                    pIssuer,
                    CERT_KEY_IDENTIFIER_PROP_ID,
                    &pInfo->KeyId
                    );
            else
                fResult = TRUE;

            PkiFree(pInfo);
            if (!fResult)
                return FALSE;
        }
    }

    if (dwFindFlags & CRL_FIND_ISSUED_BY_SIGNATURE_FLAG) {
        DWORD dwFlags;

        dwFlags = CERT_STORE_SIGNATURE_FLAG;
        VerifyCrl(pCrl, pIssuer, &dwFlags);
        if (0 != dwFlags)
            return FALSE;
    }

    return TRUE;
}

STATIC BOOL CompareCrlElement(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    )
{
    PCCRL_CONTEXT pCrl = ToCrlContext(pEle);
    DWORD dwFindType = pFindInfo->dwFindType;
    const void *pvFindPara = pFindInfo->pvFindPara;

    if (fArchived)
        return FALSE;

    switch (dwFindType) {
        case CRL_FIND_ANY:
            return TRUE;
            break;

        case CRL_FIND_ISSUED_BY:
            {
                PCCERT_CONTEXT pIssuer = (PCCERT_CONTEXT) pvFindPara;

                return IsIssuedByCrl(
                    pCrl,
                    pIssuer,
                    (NULL != pIssuer) ? &pIssuer->pCertInfo->Subject : NULL,
                    pFindInfo->dwFindFlags
                    );
            }
            break;

        case CRL_FIND_ISSUED_FOR:
            {
                PCRL_FIND_ISSUED_FOR_PARA pPara =
                    (PCRL_FIND_ISSUED_FOR_PARA) pvFindPara;

                return IsIssuedByCrl(
                    pCrl,
                    pPara->pIssuerCert,
                    &pPara->pSubjectCert->pCertInfo->Issuer,
                    pFindInfo->dwFindFlags
                    );
            }
            break;

        case CRL_FIND_EXISTING:
            return IsSameCrl(pCrl, (PCCRL_CONTEXT) pvFindPara);
            break;

        default:
            goto BadParameter;
    }

BadParameter:
    SetLastError((DWORD) E_INVALIDARG);
    return FALSE;
}

STATIC BOOL IsNewerCrlElement(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    )
{
    PCCRL_CONTEXT pNewCrl = ToCrlContext(pNewEle);
    PCCRL_CONTEXT pExistingCrl = ToCrlContext(pExistingEle);

    // CompareFileTime returns +1 if first time > second time
    return (0 < CompareFileTime(
        &pNewCrl->pCrlInfo->ThisUpdate,
        &pExistingCrl->pCrlInfo->ThisUpdate
        ));
}

STATIC BOOL IsSameAltNameEntry(
    IN PCERT_ALT_NAME_ENTRY pE1,
    IN PCERT_ALT_NAME_ENTRY pE2
    )
{
    DWORD dwAltNameChoice;

    dwAltNameChoice = pE1->dwAltNameChoice;
    if (dwAltNameChoice != pE2->dwAltNameChoice)
        return FALSE;

    switch (dwAltNameChoice) {
        case CERT_ALT_NAME_OTHER_NAME:
            if (0 == strcmp(pE1->pOtherName->pszObjId,
                    pE2->pOtherName->pszObjId)
                            &&
                    pE1->pOtherName->Value.cbData ==
                        pE2->pOtherName->Value.cbData
                                &&
                    0 == memcmp(pE1->pOtherName->Value.pbData,
                        pE2->pOtherName->Value.pbData,
                        pE1->pOtherName->Value.cbData))
                return TRUE;
            break;
        case CERT_ALT_NAME_RFC822_NAME:
        case CERT_ALT_NAME_DNS_NAME:
        case CERT_ALT_NAME_URL:
            if (0 == _wcsicmp(pE1->pwszRfc822Name, pE2->pwszRfc822Name))
                return TRUE;
            break;
        case CERT_ALT_NAME_X400_ADDRESS:
        case CERT_ALT_NAME_EDI_PARTY_NAME:
            // Not implemented
            break;
        case CERT_ALT_NAME_DIRECTORY_NAME:
        case CERT_ALT_NAME_IP_ADDRESS:
            if (pE1->DirectoryName.cbData == pE2->DirectoryName.cbData &&
                    0 == memcmp(pE1->DirectoryName.pbData,
                             pE2->DirectoryName.pbData,
                             pE1->DirectoryName.cbData))
                return TRUE;
            break;
        case CERT_ALT_NAME_REGISTERED_ID:
            if (0 == strcmp(pE1->pszRegisteredID, pE2->pszRegisteredID))
                return TRUE;
            break;
        default:
            break;
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//  Is the specified CRL valid for the certificate.
//
//  Returns TRUE if the CRL's list of entries would contain the certificate
//  if it was revoked. Note, doesn't check that the certificate is in the
//  list of entries.
//
//  If the CRL has an Issuing Distribution Point (IDP) extension, checks
//  that it's valid for the subject certificate.
//
//  dwFlags and pvReserved currently aren't used and must be set to 0 and NULL.
//--------------------------------------------------------------------------
WINCRYPT32API
BOOL
WINAPI
CertIsValidCRLForCertificate(
    IN PCCERT_CONTEXT pCert,
    IN PCCRL_CONTEXT pCrl,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    BOOL fResult;
    PCERT_EXTENSION pIDPExt;                        // not allocated
    PCERT_EXTENSION pCDPExt;                        // not allocated
    PCERT_EXTENSION pBasicConstraintsExt;           // not allocated
    PCRL_ISSUING_DIST_POINT pIDPInfo = NULL;
    PCRL_DIST_POINTS_INFO pCDPInfo = NULL;
    PCERT_BASIC_CONSTRAINTS2_INFO pBasicConstraintsInfo = NULL;

    DWORD cIDPAltEntry;
    PCERT_ALT_NAME_ENTRY pIDPAltEntry;              // not allocated

    pIDPExt = CertFindExtension(
        szOID_ISSUING_DIST_POINT,
        pCrl->pCrlInfo->cExtension,
        pCrl->pCrlInfo->rgExtension
        );
    if (NULL == pIDPExt)
        return TRUE;

    if (NULL == (pIDPInfo = (PCRL_ISSUING_DIST_POINT) AllocAndDecodeObject(
            pCrl->dwCertEncodingType,
            X509_ISSUING_DIST_POINT,
            pIDPExt->Value.pbData,
            pIDPExt->Value.cbData
            )))
        goto IDPDecodeError;

    // Ignore IDPs having OnlySomeReasonFlags or an indirect CRL
    if (0 != pIDPInfo->OnlySomeReasonFlags.cbData ||
            pIDPInfo->fIndirectCRL)
        goto UnsupportedIDPError;

    if (!(CRL_DIST_POINT_NO_NAME ==
                pIDPInfo->DistPointName.dwDistPointNameChoice ||
            CRL_DIST_POINT_FULL_NAME ==
                pIDPInfo->DistPointName.dwDistPointNameChoice))
        goto UnsupportedIDPError;

    if (pIDPInfo->fOnlyContainsUserCerts ||
            pIDPInfo->fOnlyContainsCACerts) {
        // Determine if the cert is an end entity or a CA.

        // Default to an end entity
        BOOL fCA = FALSE;

        pBasicConstraintsExt = CertFindExtension(
            szOID_BASIC_CONSTRAINTS2,
            pCert->pCertInfo->cExtension,
            pCert->pCertInfo->rgExtension
            );

        if (pBasicConstraintsExt) {
            if (NULL == (pBasicConstraintsInfo =
                    (PCERT_BASIC_CONSTRAINTS2_INFO) AllocAndDecodeObject(
                        pCert->dwCertEncodingType,
                        X509_BASIC_CONSTRAINTS2,
                        pBasicConstraintsExt->Value.pbData,
                        pBasicConstraintsExt->Value.cbData
                        )))
                goto BasicConstraintsDecodeError;
            fCA = pBasicConstraintsInfo->fCA;
        }

        if (pIDPInfo->fOnlyContainsUserCerts && fCA)
            goto OnlyContainsUserCertsError;
        if (pIDPInfo->fOnlyContainsCACerts && !fCA)
            goto OnlyContainsCACertsError;
    }

    if (CRL_DIST_POINT_FULL_NAME !=
            pIDPInfo->DistPointName.dwDistPointNameChoice)
        // The IDP doesn't have any name choice to check
        goto SuccessReturn;

    cIDPAltEntry = pIDPInfo->DistPointName.FullName.cAltEntry;

    if (0 == cIDPAltEntry)
        // The IDP doesn't have any DistPoint entries to check
        goto SuccessReturn;

    pIDPAltEntry = pIDPInfo->DistPointName.FullName.rgAltEntry;

    pCDPExt = CertFindExtension(
        szOID_CRL_DIST_POINTS,
        pCert->pCertInfo->cExtension,
        pCert->pCertInfo->rgExtension
        );
    if (NULL == pCDPExt)
        goto NoCDPError;

    if (NULL == (pCDPInfo = (PCRL_DIST_POINTS_INFO) AllocAndDecodeObject(
            pCert->dwCertEncodingType,
            X509_CRL_DIST_POINTS,
            pCDPExt->Value.pbData,
            pCDPExt->Value.cbData
            )))
        goto CDPDecodeError;

    for ( ; 0 < cIDPAltEntry; pIDPAltEntry++, cIDPAltEntry--) {
        DWORD cCDPDistPoint;
        PCRL_DIST_POINT pCDPDistPoint;

        cCDPDistPoint = pCDPInfo->cDistPoint;
        pCDPDistPoint = pCDPInfo->rgDistPoint;
        for ( ; 0 < cCDPDistPoint; pCDPDistPoint++, cCDPDistPoint--) {
            DWORD cCDPAltEntry;
            PCERT_ALT_NAME_ENTRY pCDPAltEntry;

            if (0 != pCDPDistPoint->ReasonFlags.cbData)
                continue;
            if (0 != pCDPDistPoint->CRLIssuer.cAltEntry)
                continue;
            if (CRL_DIST_POINT_FULL_NAME !=
                    pCDPDistPoint->DistPointName.dwDistPointNameChoice)
                continue;

            cCDPAltEntry = pCDPDistPoint->DistPointName.FullName.cAltEntry;
            pCDPAltEntry = pCDPDistPoint->DistPointName.FullName.rgAltEntry;
            for ( ; 0 < cCDPAltEntry; pCDPAltEntry++, cCDPAltEntry--) {
                if (IsSameAltNameEntry(pIDPAltEntry, pCDPAltEntry))
                    goto SuccessReturn;
            }
        }
    }

    goto NoAltNameMatchError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(pIDPInfo);
    PkiFree(pCDPInfo);
    PkiFree(pBasicConstraintsInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NoCDPError, CRYPT_E_NO_MATCH)
TRACE_ERROR(IDPDecodeError)
SET_ERROR(UnsupportedIDPError, E_NOTIMPL)
TRACE_ERROR(BasicConstraintsDecodeError)
SET_ERROR(OnlyContainsUserCertsError, CRYPT_E_NO_MATCH)
SET_ERROR(OnlyContainsCACertsError, CRYPT_E_NO_MATCH)
TRACE_ERROR(CDPDecodeError)
SET_ERROR(NoAltNameMatchError, CRYPT_E_NO_MATCH)
}


//+=========================================================================
//  CTL_CONTEXT Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  If both msg and cert encoding types are present, or neither are present,
//  return without any changes. Otherwise, set the missing encoding type
//  with the encoding type that is present.
//--------------------------------------------------------------------------
STATIC DWORD GetCtlEncodingType(IN DWORD dwMsgAndCertEncodingType)
{
    if (0 == dwMsgAndCertEncodingType)
        return 0;
    else if (0 == (dwMsgAndCertEncodingType & CMSG_ENCODING_TYPE_MASK))
        return dwMsgAndCertEncodingType |
            ((dwMsgAndCertEncodingType << 16) & CMSG_ENCODING_TYPE_MASK);
    else if (0 == (dwMsgAndCertEncodingType & CERT_ENCODING_TYPE_MASK))
        return dwMsgAndCertEncodingType |
            ((dwMsgAndCertEncodingType >> 16) & CERT_ENCODING_TYPE_MASK);
    else
        // Both specified
        return dwMsgAndCertEncodingType;
}

#if 0

// pbCtlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT SlowCreateCtlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded
    )
{
    DWORD dwEncodingType;
    HCRYPTPROV hProv = 0;
    DWORD dwProvFlags = 0;
    HCRYPTMSG hMsg = NULL;
    BYTE *pbContent = NULL;
    DWORD cbContent;
    PCTL_INFO pInfo = NULL;
    PCONTEXT_ELEMENT pEle = NULL;
    PCTL_CONTEXT pCtl;
    PCTL_CONTEXT_SUFFIX pCtlSuffix;

    // Attempt to get the store's crypt provider. Serialize crypto
    // operations.
    hProv = GetCryptProv(pStore, &dwProvFlags);

    if (0 == (dwMsgAndCertEncodingType = GetCtlEncodingType(
             dwMsgAndCertEncodingType)))
        goto InvalidArg;

    // The message encoding type takes precedence
    dwEncodingType = (dwMsgAndCertEncodingType >> 16) & CERT_ENCODING_TYPE_MASK;

    // Assumption:: only definite length encoded PKCS #7
    cbCtlEncoded = AdjustEncodedLength(
        dwEncodingType, pbCtlEncoded, cbCtlEncoded);

    // First decode as a PKCS#7 SignedData message
    if (NULL == (hMsg = CryptMsgOpenToDecode(
            dwMsgAndCertEncodingType,
            0,                          // dwFlags
            0,                          // dwMsgType
            hProv,
            NULL,                       // pRecipientInfo
            NULL                        // pStreamInfo
            ))) goto MsgOpenToDecodeError;
    if (!CryptMsgUpdate(
            hMsg,
            pbCtlEncoded,
            cbCtlEncoded,
            TRUE                    // fFinal
            )) goto MsgUpdateError;
    else {
        // Verify that the outer ContentType is SignedData and the inner
        // ContentType is a CertificateTrustList
        DWORD dwMsgType = 0;
        DWORD cbData;
        char szInnerContentType[64];
        assert(sizeof(szInnerContentType) > strlen(szOID_CTL));

        cbData = sizeof(dwMsgType);
        if (!CryptMsgGetParam(
                hMsg,
                CMSG_TYPE_PARAM,
                0,                  // dwIndex
                &dwMsgType,
                &cbData
                )) goto GetTypeError;
        if (CMSG_SIGNED != dwMsgType)
            goto UnexpectedMsgTypeError;

        cbData = sizeof(szInnerContentType);
        if (!CryptMsgGetParam(
                hMsg,
                CMSG_INNER_CONTENT_TYPE_PARAM,
                0,                  // dwIndex
                szInnerContentType,
                &cbData
                )) goto GetInnerContentTypeError;
        if (0 != strcmp(szInnerContentType, szOID_CTL))
            goto UnexpectedInnerContentTypeError;

    }

    // Get the inner content.
    if (NULL == (pbContent = (BYTE *) AllocAndGetMsgParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            &cbContent))) goto GetContentError;

    // Decode inner content
    if (NULL == (pInfo = (PCTL_INFO) AllocAndDecodeObject(
                dwEncodingType,
                PKCS_CTL,
                pbContent,
                cbContent))) goto DecodeError;

    // Allocate and initialize the CTL element structure
    if (NULL == (pEle = (PCONTEXT_ELEMENT) PkiZeroAlloc(
            sizeof(CONTEXT_ELEMENT) + sizeof(CTL_CONTEXT) +
            sizeof(CTL_CONTEXT_SUFFIX))))
        goto OutOfMemory;

    pEle->dwElementType = ELEMENT_TYPE_CACHE;
    pEle->dwContextType = CERT_STORE_CTL_CONTEXT - 1;
    pEle->lRefCnt = 1;
    pEle->pEle = pEle;
    pEle->pStore = pStore;
    pEle->pProvStore = pStore;

    pCtl = (PCTL_CONTEXT) ToCtlContext(pEle);
    pCtl->dwMsgAndCertEncodingType =
        dwMsgAndCertEncodingType;
    pCtl->pbCtlEncoded = pbCtlEncoded;
    pCtl->cbCtlEncoded = cbCtlEncoded;
    pCtl->pCtlInfo = pInfo;
    pCtl->hCertStore = (HCERTSTORE) pStore;
    pCtl->hCryptMsg = hMsg;
    pCtl->pbCtlContent = pbContent;
    pCtl->cbCtlContent = cbContent;

    pCtlSuffix = ToCtlContextSuffix(pEle);
    pCtlSuffix->ppSortedEntry = NULL;
    pCtlSuffix->pSortedCtlFindInfo = NULL;

CommonReturn:
    // For the store's crypt provider, release reference count. Leave
    // crypto operations critical section.
    //
    // Also, any subsequent CryptMsg cryptographic operations will
    // be done outside of critical section. This critical section is needed
    // because CAPI 1.0 isn't thread safe. This should be fixed!!!! ?????
    ReleaseCryptProv(pStore, dwProvFlags);
    return pEle;

ErrorReturn:
    if (hMsg)
        CryptMsgClose(hMsg);
    PkiFree(pInfo);
    PkiFree(pbContent);
    if (pEle) {
        PkiFree(pEle);
        pEle = NULL;
    }
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(MsgOpenToDecodeError)
TRACE_ERROR(MsgUpdateError)
TRACE_ERROR(GetTypeError)
SET_ERROR(UnexpectedMsgTypeError, CRYPT_E_UNEXPECTED_MSG_TYPE)
TRACE_ERROR(GetInnerContentTypeError)
SET_ERROR(UnexpectedInnerContentTypeError, CRYPT_E_UNEXPECTED_MSG_TYPE)
TRACE_ERROR(GetContentError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DecodeError)
}

void
StoreMessageBox(
    IN LPSTR pszText
    )
{
    MessageBoxA(
        NULL,           // hwndOwner
        pszText,
        "Check FastCreateCtlElement",
        MB_TOPMOST | MB_OK | MB_ICONQUESTION |
            MB_SERVICE_NOTIFICATION
        );
}
#endif

// pbCtlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT FastCreateCtlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN const BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded,
    IN OPTIONAL PSHARE_ELEMENT pShareEle,
    IN DWORD dwFlags
    );

// pbCtlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT CreateCtlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded,
    IN OPTIONAL PSHARE_ELEMENT pShareEle
    )
{
#if 1
    return FastCreateCtlElement(
        pStore,
        dwMsgAndCertEncodingType,
        pbCtlEncoded,
        cbCtlEncoded,
        pShareEle,
        0                                   // dwFlags
        );
#else
    PCONTEXT_ELEMENT pSlowEle;
    PCONTEXT_ELEMENT pFastEle;

    pFastEle = FastCreateCtlElement(
        pStore,
        dwMsgAndCertEncodingType,
        pbCtlEncoded,
        cbCtlEncoded,
        pShareEle,
        0                   // dwFlags
        );

    pSlowEle = NULL;
    if (cbCtlEncoded) {
        BYTE *pbSlowCtlEncoded = NULL;

        pbSlowCtlEncoded = (BYTE *) PkiNonzeroAlloc(cbCtlEncoded);
        if (pbSlowCtlEncoded) {
            memcpy(pbSlowCtlEncoded, pbCtlEncoded, cbCtlEncoded);
            pSlowEle = SlowCreateCtlElement(
                &NullCertStore,
                dwMsgAndCertEncodingType,
                pbSlowCtlEncoded,
                cbCtlEncoded
                );
            if (NULL == pSlowEle)
                PkiFree(pbSlowCtlEncoded);
        }
    }

    if (NULL == pFastEle) {
        if (pSlowEle)
            StoreMessageBox("fast failed, slow succeeded");
    } else if (NULL == pSlowEle) {
        StoreMessageBox("fast succeeded, slow failed");
    } else {
        PCTL_INFO pFastInfo = ToCtlContext(pFastEle)->pCtlInfo;
        PCTL_INFO pSlowInfo = ToCtlContext(pSlowEle)->pCtlInfo;

        // Check that headers match
        if (pFastInfo->dwVersion != pSlowInfo->dwVersion ||
                pFastInfo->SubjectUsage.cUsageIdentifier !=
                    pSlowInfo->SubjectUsage.cUsageIdentifier ||
                0 != CompareFileTime(&pFastInfo->ThisUpdate,
                    &pSlowInfo->ThisUpdate) ||
                0 != CompareFileTime(&pFastInfo->NextUpdate,
                    &pSlowInfo->NextUpdate) ||
                0 != strcmp(pFastInfo->SubjectAlgorithm.pszObjId,
                        pSlowInfo->SubjectAlgorithm.pszObjId) ||
                pFastInfo->SubjectAlgorithm.Parameters.cbData !=
                        pSlowInfo->SubjectAlgorithm.Parameters.cbData)
            StoreMessageBox("fast and slow info doesn't match\n");
        else {
            // Check that the extensions match
            DWORD cFastExt = pFastInfo->cExtension;
            PCERT_EXTENSION pFastExt = pFastInfo->rgExtension;
            DWORD cSlowExt = pSlowInfo->cExtension;
            PCERT_EXTENSION pSlowExt = pSlowInfo->rgExtension;

            if (cFastExt != cSlowExt)
                StoreMessageBox("fast and slow extension count doesn't match");
            else {
                for ( ; cFastExt; cFastExt--, pFastExt++, pSlowExt++) {
                    if (0 != strcmp(pFastExt->pszObjId, pSlowExt->pszObjId) ||
                                pFastExt->fCritical != pSlowExt->fCritical ||
                            pFastExt->Value.cbData != pSlowExt->Value.cbData) {
                        StoreMessageBox(
                            "fast and slow extension doesn't match");
                        goto Done;
                    }
                    if (pFastExt->Value.cbData && 0 != memcmp(
                            pFastExt->Value.pbData, pSlowExt->Value.pbData,
                                pFastExt->Value.cbData)) {
                        StoreMessageBox(
                            "fast and slow extension doesn't match");
                        goto Done;
                    }
                }
            }
        }

        if (pFastInfo->cCTLEntry != pSlowInfo->cCTLEntry)
            StoreMessageBox("fast and slow entry count doesn't match");
        else {
            DWORD cEntry = pFastInfo->cCTLEntry;
            PCTL_ENTRY pFastEntry = pFastInfo->rgCTLEntry;
            PCTL_ENTRY pSlowEntry = pSlowInfo->rgCTLEntry;

            for ( ; cEntry; cEntry--, pFastEntry++, pSlowEntry++) {
                if (pFastEntry->SubjectIdentifier.cbData !=
                        pSlowEntry->SubjectIdentifier.cbData ||
                    0 != memcmp(pFastEntry->SubjectIdentifier.pbData,
                            pSlowEntry->SubjectIdentifier.pbData,
                            pFastEntry->SubjectIdentifier.cbData)) {
                    StoreMessageBox(
                        "fast and slow SubjectIdentifier doesn't match");
                    goto Done;
                }

                if (pFastEntry->cAttribute != pSlowEntry->cAttribute) {
                    StoreMessageBox(
                        "fast and slow Attribute Count doesn't match");
                    goto Done;
                } else if (0 < pFastEntry->cAttribute) {
                    DWORD cAttr = pFastEntry->cAttribute;
                    PCRYPT_ATTRIBUTE pFastAttr = pFastEntry->rgAttribute;
                    PCRYPT_ATTRIBUTE pSlowAttr = pSlowEntry->rgAttribute;

                    for ( ; cAttr; cAttr--, pFastAttr++, pSlowAttr++) {
                        if (0 != strcmp(pFastAttr->pszObjId,
                                    pSlowAttr->pszObjId)) {
                            StoreMessageBox(
                                "fast and slow Attribute OID doesn't match");
                            goto Done;
                        }

                        if (pFastAttr->cValue != pSlowAttr->cValue) {
                            StoreMessageBox(
                                "fast and slow Value Count doesn't match");
                            goto Done;
                        }

                        if (0 < pFastAttr->cValue) {
                            DWORD cValue = pFastAttr->cValue;
                            PCRYPT_ATTR_BLOB pFastValue = pFastAttr->rgValue;
                            PCRYPT_ATTR_BLOB pSlowValue = pSlowAttr->rgValue;

                            for ( ; cValue;
                                        cValue--, pFastValue++, pSlowValue++) {
                                if (pFastValue->cbData !=
                                        pSlowValue->cbData ||
                                    0 != memcmp(pFastValue->pbData,
                                            pSlowValue->pbData,
                                            pFastValue->cbData)) {
                                    StoreMessageBox(
                                        "fast and slow Value doesn't match");
                                    goto Done;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    

Done:
    if (pSlowEle)
        FreeContextElement(pSlowEle);

    return pFastEle;
        
#endif
}

STATIC void FreeCtlElement(IN PCONTEXT_ELEMENT pEle)
{
    PCCTL_CONTEXT pCtl = ToCtlContext(pEle);
    PCTL_CONTEXT_SUFFIX pCtlSuffix = ToCtlContextSuffix(pEle);

    if (pEle->pShareEle)
        ReleaseShareElement(pEle->pShareEle);
    else {
        PkiFree(pCtl->pbCtlEncoded);

        CertPerfDecrementCtlElementCurrentCount();
    }

    PkiFree(pCtl->pCtlInfo);
    PkiFree(pCtlSuffix->ppSortedEntry);
    CryptMsgClose(pCtl->hCryptMsg);

    if (pCtlSuffix->fFastCreate) {
        PSORTED_CTL_FIND_INFO pSortedCtlFindInfo =
            pCtlSuffix->pSortedCtlFindInfo;

        PkiFree(pCtlSuffix->pCTLEntry);
        PkiFree(pCtlSuffix->pExtInfo);

        if (pSortedCtlFindInfo) {
            PkiFree(pSortedCtlFindInfo->pdwHashBucketHead);
            PkiFree(pSortedCtlFindInfo->pHashBucketEntry);
        }
    } else
        PkiFree(pCtl->pbCtlContent);

    PkiFree(pEle);
}

STATIC BOOL CompareCtlHash(
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwPropId,
    IN PCRYPT_HASH_BLOB pHash
    )
{
    BYTE rgbHash[MAX_HASH_LEN];
    DWORD cbHash = MAX_HASH_LEN;
    CertGetCTLContextProperty(
        pCtl,
        dwPropId,
        rgbHash,
        &cbHash
        );
    if (cbHash == pHash->cbData &&
            memcmp(rgbHash, pHash->pbData, cbHash) == 0)
        return TRUE;
    else
        return FALSE;
}

STATIC BOOL CompareCtlUsage(
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFindFlags,
    IN PCTL_FIND_USAGE_PARA pPara
    )
{
    PCTL_INFO pInfo = pCtl->pCtlInfo;

    if (NULL == pPara ||
             pPara->cbSize < (offsetof(CTL_FIND_USAGE_PARA, SubjectUsage) +
                sizeof(pPara->SubjectUsage)))
        return TRUE;
    if ((CTL_FIND_SAME_USAGE_FLAG & dwFindFlags) &&
            pPara->SubjectUsage.cUsageIdentifier !=
                pInfo->SubjectUsage.cUsageIdentifier)
        return FALSE;
    if (!CompareCtlUsageIdentifiers(&pPara->SubjectUsage,
            1, &pInfo->SubjectUsage, FALSE))
        return FALSE;

    assert(offsetof(CTL_FIND_USAGE_PARA, ListIdentifier) >
        offsetof(CTL_FIND_USAGE_PARA, SubjectUsage));
    if (pPara->cbSize < offsetof(CTL_FIND_USAGE_PARA, ListIdentifier) +
            sizeof(pPara->ListIdentifier))
        return TRUE;
    if (pPara->ListIdentifier.cbData) {
        DWORD cb = pPara->ListIdentifier.cbData;
        if (CTL_FIND_NO_LIST_ID_CBDATA == cb)
            cb = 0;
        if (cb != pInfo->ListIdentifier.cbData)
            return FALSE;
        if (0 != cb && 0 != memcmp(pPara->ListIdentifier.pbData,
                pInfo->ListIdentifier.pbData, cb))
            return FALSE;
    }

    assert(offsetof(CTL_FIND_USAGE_PARA, pSigner) >
        offsetof(CTL_FIND_USAGE_PARA, ListIdentifier));
    if (pPara->cbSize < offsetof(CTL_FIND_USAGE_PARA, pSigner) +
            sizeof(pPara->pSigner))
        return TRUE;
    if (CTL_FIND_NO_SIGNER_PTR == pPara->pSigner) {
        DWORD cbData;
        DWORD dwSignerCount;

        cbData = sizeof(dwSignerCount);
        if (!CryptMsgGetParam(
                pCtl->hCryptMsg,
                CMSG_SIGNER_COUNT_PARAM,
                0,                      // dwIndex
                &dwSignerCount,
                &cbData) || 0 != dwSignerCount)
            return FALSE;
    } else if (pPara->pSigner) {
        DWORD dwCertEncodingType;
        PCERT_INFO pCertId1 = pPara->pSigner;
        HCRYPTMSG hMsg = pCtl->hCryptMsg;
        DWORD cbData;
        DWORD dwSignerCount;
        DWORD i;

        dwCertEncodingType = GetCertEncodingType(dwMsgAndCertEncodingType);
        if (dwCertEncodingType != GET_CERT_ENCODING_TYPE(
                pCtl->dwMsgAndCertEncodingType))
            return FALSE;

        cbData = sizeof(dwSignerCount);
        if (!CryptMsgGetParam(
                hMsg,
                CMSG_SIGNER_COUNT_PARAM,
                0,                      // dwIndex
                &dwSignerCount,
                &cbData) || 0 == dwSignerCount)
            return FALSE;
        for (i = 0; i < dwSignerCount; i++) {
            BOOL fResult;
            PCERT_INFO pCertId2;
            if (NULL == (pCertId2 = (PCERT_INFO) AllocAndGetMsgParam(
                    hMsg,
                    CMSG_SIGNER_CERT_INFO_PARAM,
                    i,
                    &cbData)))
                continue;
            fResult = CertCompareCertificate(
                dwCertEncodingType,
                pCertId1,
                pCertId2);
            PkiFree(pCertId2);
            if (fResult)
                break;
        }
        if (i == dwSignerCount)
            return FALSE;
    }

    return TRUE;
}

STATIC BOOL CompareCtlSubject(
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwMsgAndCertEncodingType,
    IN DWORD dwFindFlags,
    IN PCTL_FIND_SUBJECT_PARA pPara
    )
{
    if (NULL == pPara ||
             pPara->cbSize < (offsetof(CTL_FIND_SUBJECT_PARA, pUsagePara) +
                sizeof(pPara->pUsagePara)))
        return TRUE;
    if (pPara->pUsagePara && !CompareCtlUsage(pCtl,
            dwMsgAndCertEncodingType, dwFindFlags, pPara->pUsagePara))
        return FALSE;

    assert(offsetof(CTL_FIND_SUBJECT_PARA, pvSubject) >
        offsetof(CTL_FIND_SUBJECT_PARA, pUsagePara));
    if (pPara->cbSize < offsetof(CTL_FIND_SUBJECT_PARA, pvSubject) +
            sizeof(pPara->pvSubject))
        return TRUE;
    if (pPara->pvSubject && NULL == CertFindSubjectInCTL(
            dwMsgAndCertEncodingType,
            pPara->dwSubjectType,
            pPara->pvSubject,
            pCtl,
            0))                     // dwFlags
        return FALSE;

    return TRUE;
}

STATIC BOOL IsSameCtl(
    IN PCCTL_CONTEXT pCtl,
    IN PCCTL_CONTEXT pNew
    )
{
    PCTL_INFO pInfo = pNew->pCtlInfo;
    HCRYPTMSG hMsg = pNew->hCryptMsg;
    CTL_FIND_USAGE_PARA FindPara;
    DWORD dwFindFlags;

    DWORD cbData;
    DWORD dwSignerCount;
    DWORD i;

    cbData = sizeof(dwSignerCount);
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_SIGNER_COUNT_PARAM,
            0,                      // dwIndex
            &dwSignerCount,
            &cbData))
        return FALSE;

    memset(&FindPara, 0, sizeof(FindPara));
    FindPara.cbSize = sizeof(FindPara);
    FindPara.SubjectUsage = pInfo->SubjectUsage;
    FindPara.ListIdentifier = pInfo->ListIdentifier;
    if (0 == FindPara.ListIdentifier.cbData)
        FindPara.ListIdentifier.cbData = CTL_FIND_NO_LIST_ID_CBDATA;
    dwFindFlags = CTL_FIND_SAME_USAGE_FLAG;

    if (0 == dwSignerCount) {
        FindPara.pSigner = CTL_FIND_NO_SIGNER_PTR;
        return CompareCtlUsage(
            pCtl,
            pNew->dwMsgAndCertEncodingType,
            dwFindFlags,
            &FindPara
            );
    } else {
        for (i = 0; i < dwSignerCount; i++) {
            BOOL fResult;
            PCERT_INFO pSigner;

            if (NULL == (pSigner = (PCERT_INFO) AllocAndGetMsgParam(
                    hMsg,
                    CMSG_SIGNER_CERT_INFO_PARAM,
                    i,
                    &cbData)))
                continue;
            FindPara.pSigner = pSigner;
            fResult = CompareCtlUsage(
                    pCtl,
                    pNew->dwMsgAndCertEncodingType,
                    dwFindFlags,
                    &FindPara
                    );
            PkiFree(pSigner);
            if (fResult)
                return TRUE;
        }
    }
    return FALSE;
}

STATIC BOOL CompareCtlElement(
    IN PCONTEXT_ELEMENT pEle,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN BOOL fArchived
    )
{
    PCCTL_CONTEXT pCtl = ToCtlContext(pEle);
    DWORD dwFindType = pFindInfo->dwFindType;
    const void *pvFindPara = pFindInfo->pvFindPara;

    if (fArchived) {
        switch (dwFindType) {
            case CTL_FIND_SHA1_HASH:
            case CTL_FIND_MD5_HASH:
                break;
            default:
                return FALSE;
        }
    }

    switch (dwFindType) {
        case CTL_FIND_ANY:
            return TRUE;
            break;
        case CTL_FIND_SHA1_HASH:
        case CTL_FIND_MD5_HASH:
            {
                DWORD dwPropId;
                if (dwFindType == CTL_FIND_SHA1_HASH)
                    dwPropId = CERT_SHA1_HASH_PROP_ID;
                else
                    dwPropId = CERT_MD5_HASH_PROP_ID;
                return CompareCtlHash(pCtl, dwPropId,
                    (PCRYPT_HASH_BLOB) pvFindPara);
            }
            break;
        case CTL_FIND_USAGE:
            return CompareCtlUsage(pCtl, pFindInfo->dwMsgAndCertEncodingType,
                pFindInfo->dwFindFlags, (PCTL_FIND_USAGE_PARA) pvFindPara);
            break;
        case CTL_FIND_SUBJECT:
            return CompareCtlSubject(pCtl, pFindInfo->dwMsgAndCertEncodingType,
                pFindInfo->dwFindFlags, (PCTL_FIND_SUBJECT_PARA) pvFindPara);
            break;

        case CTL_FIND_EXISTING:
            {
                PCCTL_CONTEXT pNew = (PCCTL_CONTEXT) pFindInfo->pvFindPara;
                return IsSameCtl(pCtl, pNew);
            }
            break;

        default:
            goto BadParameter;
    }

BadParameter:
    SetLastError((DWORD) E_INVALIDARG);
    return FALSE;
}

STATIC BOOL IsNewerCtlElement(
    IN PCONTEXT_ELEMENT pNewEle,
    IN PCONTEXT_ELEMENT pExistingEle
    )
{
    PCCTL_CONTEXT pNewCtl = ToCtlContext(pNewEle);
    PCCTL_CONTEXT pExistingCtl = ToCtlContext(pExistingEle);

    // CompareFileTime returns +1 if first time > second time
    return (0 < CompareFileTime(
        &pNewCtl->pCtlInfo->ThisUpdate,
        &pExistingCtl->pCtlInfo->ThisUpdate
        ));
}


//+=========================================================================
//  Store Link Functions
//==========================================================================

STATIC PCERT_STORE_LINK CreateStoreLink(
    IN PCERT_STORE pCollection,
    IN PCERT_STORE pSibling,
    IN DWORD dwUpdateFlags,
    IN DWORD dwPriority
    )
{
    PCERT_STORE_LINK pLink;
    if (NULL == (pLink = (PCERT_STORE_LINK) PkiZeroAlloc(
            sizeof(CERT_STORE_LINK))))
        return NULL;

    pLink->lRefCnt = 1;
    pLink->dwUpdateFlags = dwUpdateFlags;
    pLink->dwPriority = dwPriority;
    pLink->pCollection = pCollection;
    pLink->pSibling = (PCERT_STORE) CertDuplicateStore((HCERTSTORE) pSibling);

    if (pSibling->dwFlags & CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG)
        InterlockedIncrement(&pSibling->lDeferCloseRefCnt);

    return pLink;
}

// Not locked upon entry
STATIC void FreeStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    )
{
    PCERT_STORE pSibling = pStoreLink->pSibling;

    if (pSibling->dwFlags & CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG)
        InterlockedDecrement(&pSibling->lDeferCloseRefCnt);

    CertCloseStore((HCERTSTORE) pSibling, 0);
    PkiFree(pStoreLink);
}


STATIC void RemoveStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    )
{
    PCERT_STORE pCollection = pStoreLink->pCollection;


    LockStore(pCollection);

    // Remove store link from the store's collection
    if (pStoreLink->pNext)
        pStoreLink->pNext->pPrev = pStoreLink->pPrev;
    if (pStoreLink->pPrev)
        pStoreLink->pPrev->pNext = pStoreLink->pNext;
    else if (pStoreLink == pCollection->pStoreListHead)
        pCollection->pStoreListHead = pStoreLink->pNext;
    // else
    //  Not on any list

    // Unlocks the store or deletes the store if this was the
    // last link in a closed store
    FreeStore(pCollection);
}

STATIC void RemoveAndFreeStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    )
{
    RemoveStoreLink(pStoreLink);
    FreeStoreLink(pStoreLink);
}

STATIC void ReleaseStoreLink(
    IN PCERT_STORE_LINK pStoreLink
    )
{
    if (0 == InterlockedDecrement(&pStoreLink->lRefCnt)) {
        assert(pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG);
        assert(pStoreLink->pSibling);
        RemoveAndFreeStoreLink(pStoreLink);
    }
}


//+=========================================================================
//  Context Element Functions
//==========================================================================

STATIC DWORD GetContextEncodingType(
    IN PCONTEXT_ELEMENT pEle
    )
{
    DWORD dwContextType = pEle->dwContextType;
    DWORD *pdwEncodingType;

    pdwEncodingType = (DWORD *) ((BYTE *) pEle + sizeof(CONTEXT_ELEMENT) +
        rgOffsetofEncodingType[dwContextType]);
    return *pdwEncodingType;
}

STATIC void GetContextEncodedInfo(
    IN PCONTEXT_ELEMENT pEle,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    DWORD dwContextType = pEle->dwContextType;
    BYTE **ppbSrcEncoded;
    DWORD *pcbSrcEncoded;

    ppbSrcEncoded = (BYTE **) ((BYTE *) pEle + sizeof(CONTEXT_ELEMENT) +
        rgOffsetofEncodedPointer[dwContextType]);
    *ppbEncoded = *ppbSrcEncoded;

    pcbSrcEncoded = (DWORD *) ((BYTE *) pEle + sizeof(CONTEXT_ELEMENT) +
        rgOffsetofEncodedCount[dwContextType]);
    *pcbEncoded = *pcbSrcEncoded;
}



STATIC PCONTEXT_ELEMENT GetCacheElement(
    IN PCONTEXT_ELEMENT pCacheEle
    )
{
    DWORD dwInnerDepth;

    // Skip past any links to get to the cache element
    dwInnerDepth = 0;
    for ( ; pCacheEle != pCacheEle->pEle; pCacheEle = pCacheEle->pEle) {
        dwInnerDepth++;
        assert(dwInnerDepth <= MAX_LINK_DEPTH);
        assert(ELEMENT_TYPE_CACHE != pCacheEle->dwElementType);
        if (dwInnerDepth > MAX_LINK_DEPTH)
            goto ExceededMaxLinkDepth;
    }

    assert(pCacheEle);
    assert(ELEMENT_TYPE_CACHE == pCacheEle->dwElementType);

CommonReturn:
    return pCacheEle;
ErrorReturn:
    pCacheEle = NULL;
    goto CommonReturn;
SET_ERROR(ExceededMaxLinkDepth, E_UNEXPECTED)
}


STATIC void AddContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    PCERT_STORE pStore = pEle->pStore;
    DWORD dwContextType = pEle->dwContextType;

    LockStore(pStore);

    pEle->pNext = pStore->rgpContextListHead[dwContextType];
    pEle->pPrev = NULL;
    if (pStore->rgpContextListHead[dwContextType])
        pStore->rgpContextListHead[dwContextType]->pPrev = pEle;
    pStore->rgpContextListHead[dwContextType] = pEle;

    UnlockStore(pStore);
}


STATIC void RemoveContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    PCERT_STORE pStore = pEle->pStore;
    DWORD dwContextType = pEle->dwContextType;

    LockStore(pStore);

    // Remove context from the store's list
    if (pEle->pNext)
        pEle->pNext->pPrev = pEle->pPrev;
    if (pEle->pPrev)
        pEle->pPrev->pNext = pEle->pNext;
    else if (pEle == pStore->rgpContextListHead[dwContextType])
        pStore->rgpContextListHead[dwContextType] = pEle->pNext;
    // else
    //  Not on any list

    // Unlocks the store or deletes the store if this was the
    // last context in a closed store
    FreeStore(pStore);
}

STATIC void FreeContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    PPROP_ELEMENT pPropEle;
    PCONTEXT_NOCOPY_INFO pNoCopyInfo;

    // Free its property elements
    while ((pPropEle = pEle->Cache.pPropHead) != NULL) {
        RemovePropElement(pEle, pPropEle);
        FreePropElement(pPropEle);
    }

    // For NOCOPY of the pbEncoded, call the NOCOPY pfnFree callback
    if (pNoCopyInfo = pEle->pNoCopyInfo) {
        PFN_CRYPT_FREE pfnFree;
        BYTE **ppbEncoded;

        if (pfnFree = pNoCopyInfo->pfnFree) {
            assert(pNoCopyInfo->pvFree);
            pfnFree(pNoCopyInfo->pvFree);
        }

        // Inhibit following rgpfnFreeElement[] from freeing pbEncoded
        ppbEncoded = (BYTE **) ((BYTE *) pEle + sizeof(CONTEXT_ELEMENT) +
            rgOffsetofEncodedPointer[pEle->dwContextType]);
        *ppbEncoded = NULL;
        PkiFree(pNoCopyInfo);
    }

    rgpfnFreeElement[pEle->dwContextType](pEle);
}

STATIC void RemoveAndFreeContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    RemoveContextElement(pEle);
    FreeContextElement(pEle);
}

STATIC void AddRefContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    InterlockedIncrement(&pEle->lRefCnt);
    if (pEle->pStore->dwFlags & CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG)
        InterlockedIncrement(&pEle->pStore->lDeferCloseRefCnt);
}

STATIC void AddRefDeferClose(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (pEle->pStore->dwFlags & CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG)
        InterlockedIncrement(&pEle->pStore->lDeferCloseRefCnt);
}

STATIC void ReleaseContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    DWORD dwErr;
    PCERT_STORE pStore;
    DWORD dwStoreFlags;

    if (pEle == NULL)
        return;

    pStore = pEle->pStore;
    dwStoreFlags = pStore->dwFlags;

    if (0 == InterlockedDecrement(&pEle->lRefCnt)) {
        // Check that the store still doesn't hold a reference
        assert(pEle->dwFlags & ELEMENT_DELETED_FLAG);

        if (dwStoreFlags & CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG)
            InterlockedDecrement(&pStore->lDeferCloseRefCnt);

        dwErr = GetLastError();
        if (ELEMENT_TYPE_CACHE == pEle->dwElementType)
            RemoveAndFreeContextElement(pEle);
        else
            RemoveAndFreeLinkElement(pEle);
        SetLastError(dwErr);
    } else if (dwStoreFlags & CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG) {
        LockStore(pStore);
        if (0 == InterlockedDecrement(&pStore->lDeferCloseRefCnt)) {
            if (STORE_STATE_DEFER_CLOSING == pStore->dwState) {
                dwErr = GetLastError();
                CloseStore(pStore, 0);
                SetLastError(dwErr);
                return;
            }
        }
        UnlockStore(pStore);
    }
}

STATIC BOOL DeleteContextElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    BOOL fResult;

    if (NULL == pEle) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    switch (pEle->dwElementType) {
        case ELEMENT_TYPE_LINK_CONTEXT:
            // Only delete the link itself
            break;

        case ELEMENT_TYPE_COLLECTION:
            // Delete element pointed to
            assert(pEle != pEle->pEle);
            if (pEle != pEle->pEle) {
                // Since delete releases refCnt, need to do an extra
                // addRef here.
                AddRefContextElement(pEle->pEle);
                if (!DeleteContextElement(pEle->pEle))
                    goto DeleteCacheCollectionError;
            } else
                goto InvalidElement;
            break;

        case ELEMENT_TYPE_CACHE:
        case ELEMENT_TYPE_EXTERNAL:
            {
                PCERT_STORE pProvStore = pEle->pProvStore;
                const DWORD dwStoreProvDeleteIndex =
                    rgdwStoreProvDeleteIndex[pEle->dwContextType];
                PFN_CERT_STORE_PROV_DELETE_CERT pfnStoreProvDeleteCert;

                assert(STORE_TYPE_CACHE == pProvStore->dwStoreType ||
                    STORE_TYPE_EXTERNAL == pProvStore->dwStoreType);

                fResult = TRUE;
                LockStore(pProvStore);
                // Check if we need to call the store provider's writethru
                // function.
                if (dwStoreProvDeleteIndex <
                        pProvStore->StoreProvInfo.cStoreProvFunc &&
                            NULL != (pfnStoreProvDeleteCert =
                                (PFN_CERT_STORE_PROV_DELETE_CERT)
                            pProvStore->StoreProvInfo.rgpvStoreProvFunc[
                                dwStoreProvDeleteIndex])) {

                    // Since we can't hold a lock while calling the provider
                    // function, bump the store's provider reference count
                    // to inhibit the closing of the store and freeing of
                    // the provider functions.
                    //
                    // When the store is closed,
                    // pProvStore->StoreProvInfo.cStoreProvFunc is set to 0.
                    AddRefStoreProv(pProvStore);
                    UnlockStore(pProvStore);

                    // Check if its OK to delete from the store.
                    fResult = pfnStoreProvDeleteCert(
                            pProvStore->StoreProvInfo.hStoreProv,
                            ToCertContext(pEle->pEle),
                            0                       // dwFlags
                            );
                    LockStore(pProvStore);
                    ReleaseStoreProv(pProvStore);
                }
                UnlockStore(pProvStore);
                if (!fResult)
                    goto StoreProvDeleteError;
            }
            break;
        default:
            goto InvalidElementType;
    }

    LockStore(pEle->pStore);
    if (0 == (pEle->dwFlags & ELEMENT_DELETED_FLAG)) {
        // On the store's list. There should be at least two reference
        // counts on the context, the store's and the caller's.
        assert(pEle->pStore->dwState == STORE_STATE_OPEN ||
            pEle->pStore->dwState == STORE_STATE_OPENING ||
            pEle->pStore->dwState == STORE_STATE_DEFER_CLOSING ||
            pEle->pStore->dwState == STORE_STATE_CLOSING);

        // Remove the store's reference
        if (0 == InterlockedDecrement(&pEle->lRefCnt)) {
            assert(pEle->lRefCnt > 0);
            // Put back the reference to allow the ReleaseContextElement
            // to do the context remove and free
            pEle->lRefCnt = 1;
        }
        pEle->dwFlags |= ELEMENT_DELETED_FLAG;
    }
    UnlockStore(pEle->pStore);

    fResult = TRUE;
CommonReturn:
    // Release the caller's reference on the context
    ReleaseContextElement(pEle);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DeleteCacheCollectionError)
SET_ERROR(InvalidElement, E_INVALIDARG)
TRACE_ERROR(StoreProvDeleteError)
SET_ERROR(InvalidElementType, E_INVALIDARG)
}


// Returns TRUE if both elements have identical SHA1 hash.
STATIC BOOL IsIdenticalContextElement(
    IN PCONTEXT_ELEMENT pEle1,
    IN PCONTEXT_ELEMENT pEle2
    )
{
    BYTE rgbHash1[SHA1_HASH_LEN];
    BYTE rgbHash2[SHA1_HASH_LEN];
    DWORD cbHash;

    cbHash = SHA1_HASH_LEN;
    if (!GetProperty(
            pEle1,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash1,
            &cbHash
            ) || SHA1_HASH_LEN != cbHash)
        return FALSE;

    if (!GetProperty(
            pEle2,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash2,
            &cbHash
            ) || SHA1_HASH_LEN != cbHash)
        return FALSE;

    if (0 == memcmp(rgbHash1, rgbHash2, SHA1_HASH_LEN))
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Serialize a store element and its properties
//--------------------------------------------------------------------------
STATIC BOOL SerializeStoreElement(
    IN HANDLE h,
    IN PFNWRITE pfn,
    IN PCONTEXT_ELEMENT pEle
    )
{
    BOOL fResult;
    BYTE *pbEncoded;
    DWORD cbEncoded;

    if (!SerializeProperty(
            h,
            pfn,
            pEle
            ))
        goto SerializePropertyError;

    GetContextEncodedInfo(pEle, &pbEncoded, &cbEncoded);
    if (!WriteStoreElement(
            h,
            pfn,
            GetContextEncodingType(pEle),
            rgdwFileElementType[pEle->dwContextType],
            pbEncoded,
            cbEncoded
            ))
        goto WriteElementError;
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(SerializePropertyError);
TRACE_ERROR(WriteElementError);
}

//+-------------------------------------------------------------------------
//  Serialize the context's encoded data and its properties.
//--------------------------------------------------------------------------
STATIC BOOL SerializeContextElement(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwFlags,
    OUT BYTE *pbElement,
    IN OUT DWORD *pcbElement
    )
{
    BOOL fResult;
    MEMINFO MemInfo;

    MemInfo.pByte = pbElement;
    if (pbElement == NULL)
        MemInfo.cb = 0;
    else
        MemInfo.cb = *pcbElement;
    MemInfo.cbSeek = 0;

    if (fResult = SerializeStoreElement(
            (HANDLE) &MemInfo,
            WriteToMemory,
            pEle)) {
        if (MemInfo.cbSeek > MemInfo.cb && pbElement) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        }
        *pcbElement = MemInfo.cbSeek;
    } else
        *pcbElement = 0;

    return fResult;
}

//+=========================================================================
//  Collection Stack Functions
//==========================================================================

// No locks upon entry
STATIC BOOL PushCollectionStack(
    IN OUT PCOLLECTION_STACK_ENTRY *ppStack,
    IN PCERT_STORE pCollection
    )
{
    PCOLLECTION_STACK_ENTRY pNew;
    PCERT_STORE_LINK pStoreLink;

    if (NULL == (pNew = (PCOLLECTION_STACK_ENTRY) PkiZeroAlloc(
            sizeof(COLLECTION_STACK_ENTRY))))
        return FALSE;

    LockStore(pCollection);

    pStoreLink = pCollection->pStoreListHead;
    // Advance past deleted store links
    while (pStoreLink && (pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG))
        pStoreLink = pStoreLink->pNext;

    if (pStoreLink)
        AddRefStoreLink(pStoreLink);
    UnlockStore(pCollection);

    pNew->pCollection = pCollection;
    pNew->pStoreLink = pStoreLink;
    pNew->pPrev = *ppStack;
    *ppStack = pNew;
    return TRUE;
};


// No locks upon entry
STATIC void AdvanceToNextStackStoreLink(
    IN PCOLLECTION_STACK_ENTRY pStack
    )
{
    PCERT_STORE pStackCollectionStore;
    PCERT_STORE_LINK pStoreLink;

    if (NULL == pStack)
        return;
    pStoreLink = pStack->pStoreLink;
    if (NULL == pStoreLink)
        return;

    pStackCollectionStore = pStack->pCollection;
    assert(pStackCollectionStore);
    LockStore(pStackCollectionStore);
    pStoreLink = pStoreLink->pNext;

    // Advance past deleted store links
    while (pStoreLink && (pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG))
        pStoreLink = pStoreLink->pNext;

    if (pStoreLink)
        AddRefStoreLink(pStoreLink);
    UnlockStore(pStackCollectionStore);

    ReleaseStoreLink(pStack->pStoreLink);
    pStack->pStoreLink = pStoreLink;
}

// No locks upon entry
STATIC void PopCollectionStack(
    IN OUT PCOLLECTION_STACK_ENTRY *ppStack
    )
{
    PCOLLECTION_STACK_ENTRY pStack = *ppStack;
    if (pStack) {
        PCOLLECTION_STACK_ENTRY pPrevStack;
        if (pStack->pStoreLink)
            ReleaseStoreLink(pStack->pStoreLink);
        pPrevStack = pStack->pPrev;
        *ppStack = pPrevStack;
        PkiFree(pStack);

        if (pPrevStack)
            AdvanceToNextStackStoreLink(pPrevStack);
    }
}

// No locks upon entry
STATIC void ClearCollectionStack(
    IN PCOLLECTION_STACK_ENTRY pStack
    )
{
    while (pStack) {
        PCOLLECTION_STACK_ENTRY pFreeStack;

        if (pStack->pStoreLink)
            ReleaseStoreLink(pStack->pStoreLink);
        pFreeStack = pStack;
        pStack = pStack->pPrev;
        PkiFree(pFreeStack);
    }
}

//+=========================================================================
//  Link Element Functions
//==========================================================================

STATIC PCONTEXT_ELEMENT CreateLinkElement(
    IN DWORD dwContextType
    )
{
    PCONTEXT_ELEMENT pLinkEle;
    const DWORD cbContext = rgcbContext[dwContextType];

    if (NULL == (pLinkEle = (PCONTEXT_ELEMENT) PkiZeroAlloc(
            sizeof(CONTEXT_ELEMENT) + cbContext)))
        return NULL;
    pLinkEle->dwContextType = dwContextType;
    return pLinkEle;
}

static inline void SetStoreHandle(
    IN PCONTEXT_ELEMENT pEle
    )
{
    HCERTSTORE *phStore;
    phStore = (HCERTSTORE *) ((BYTE *) pEle + sizeof(CONTEXT_ELEMENT) +
        rgOffsetofStoreHandle[pEle->dwContextType]);
    *phStore = (HCERTSTORE) pEle->pStore;
}

// The store doesn't hold a reference on the external element.
// Therefore, its lRefCnt is 1 and the ELEMENT_DELETED_FLAG is set.
STATIC void InitAndAddExternalElement(
    IN PCONTEXT_ELEMENT pLinkEle,
    IN PCERT_STORE pStore,          // EXTERNAL
    IN PCONTEXT_ELEMENT pProvEle,   // already AddRef'ed
    IN DWORD dwFlags,
    IN OPTIONAL void *pvProvInfo
    )
{
    const DWORD cbContext = rgcbContext[pLinkEle->dwContextType];

    assert(STORE_TYPE_EXTERNAL == pStore->dwStoreType);

    pLinkEle->dwElementType = ELEMENT_TYPE_EXTERNAL;
    pLinkEle->dwFlags = dwFlags | ELEMENT_DELETED_FLAG;
    pLinkEle->lRefCnt = 1;

    pLinkEle->pEle = pProvEle;
    pLinkEle->pStore = pStore;
    pLinkEle->pProvStore = pStore;
    pLinkEle->External.pvProvInfo = pvProvInfo;

    memcpy(((BYTE *) pLinkEle) + sizeof(CONTEXT_ELEMENT),
        ((BYTE *) pProvEle) + sizeof(CONTEXT_ELEMENT),
        cbContext);
    SetStoreHandle(pLinkEle);

    AddContextElement(pLinkEle);
    AddRefDeferClose(pLinkEle);
}

// The store doesn't hold a reference on the collection element.
// Therefore, its RefCount is 1 and the ELEMENT_DELETED_FLAG is set.
STATIC void InitAndAddCollectionElement(
    IN PCONTEXT_ELEMENT pLinkEle,
    IN PCERT_STORE pStore,              // COLLECTION
    IN PCONTEXT_ELEMENT pSiblingEle,    // already AddRef'ed
    IN OPTIONAL PCOLLECTION_STACK_ENTRY pCollectionStack
    )
{
    const DWORD cbContext = rgcbContext[pLinkEle->dwContextType];

    assert(STORE_TYPE_COLLECTION == pStore->dwStoreType);

    pLinkEle->dwElementType = ELEMENT_TYPE_COLLECTION;
    pLinkEle->dwFlags = ELEMENT_DELETED_FLAG;
    pLinkEle->lRefCnt = 1;

    pLinkEle->pEle = pSiblingEle;
    pLinkEle->pStore = pStore;
    pLinkEle->pProvStore = pSiblingEle->pProvStore;
    pLinkEle->Collection.pCollectionStack = pCollectionStack;

    memcpy(((BYTE *) pLinkEle) + sizeof(CONTEXT_ELEMENT),
        ((BYTE *) pSiblingEle) + sizeof(CONTEXT_ELEMENT),
        cbContext);
    SetStoreHandle(pLinkEle);

    AddContextElement(pLinkEle);
    AddRefDeferClose(pLinkEle);
}

// The store holds a reference on the link context element.
// Therefore, the ELEMENT_DELETED_FLAG is clear.
STATIC void InitAndAddLinkContextElement(
    IN PCONTEXT_ELEMENT pLinkEle,
    IN PCERT_STORE pStore,              // CACHE
    IN PCONTEXT_ELEMENT pContextEle     // already AddRef'ed
    )
{
    const DWORD cbContext = rgcbContext[pLinkEle->dwContextType];

    assert(STORE_TYPE_CACHE == pStore->dwStoreType);

    pLinkEle->dwElementType = ELEMENT_TYPE_LINK_CONTEXT;
    pLinkEle->lRefCnt = 1;

    pLinkEle->pEle = pContextEle;
    pLinkEle->pStore = pStore;
    pLinkEle->pProvStore = pContextEle->pProvStore;

    memcpy(((BYTE *) pLinkEle) + sizeof(CONTEXT_ELEMENT),
        ((BYTE *) pContextEle) + sizeof(CONTEXT_ELEMENT),
        cbContext);
    SetStoreHandle(pLinkEle);

    AddContextElement(pLinkEle);
}

// Upon entry no locks
STATIC void RemoveAndFreeLinkElement(
    IN PCONTEXT_ELEMENT pEle
    )
{
    if (ELEMENT_TYPE_EXTERNAL == pEle->dwElementType) {
        PCERT_STORE pProvStore = pEle->pProvStore;
        const DWORD dwStoreProvFreeFindIndex =
            rgdwStoreProvFreeFindIndex[pEle->dwContextType];
        PFN_CERT_STORE_PROV_FREE_FIND_CERT pfnStoreProvFreeFindCert;

        assert(pEle->pStore == pEle->pProvStore);
        assert(STORE_TYPE_EXTERNAL == pProvStore->dwStoreType);

        LockStore(pProvStore);
        // Check if we need to call the store provider's free find cert
        // function.
        if (pEle->dwFlags & ELEMENT_FIND_NEXT_FLAG) {
            pEle->dwFlags &= ~ELEMENT_FIND_NEXT_FLAG;

            if (dwStoreProvFreeFindIndex <
                    pProvStore->StoreProvInfo.cStoreProvFunc &&
                        NULL != (pfnStoreProvFreeFindCert =
                            (PFN_CERT_STORE_PROV_FREE_FIND_CERT)
                        pProvStore->StoreProvInfo.rgpvStoreProvFunc[
                            dwStoreProvFreeFindIndex])) {

                // Since we can't hold a lock while calling the provider
                // function, bump the store's provider reference count
                // to inhibit the closing of the store and freeing of
                // the provider functions.
                //
                // When the store is closed,
                // pProvStore->StoreProvInfo.cStoreProvFunc is set to 0.
                AddRefStoreProv(pProvStore);
                UnlockStore(pProvStore);

                pfnStoreProvFreeFindCert(
                    pProvStore->StoreProvInfo.hStoreProv,
                    ToCertContext(pEle->pEle),
                    pEle->External.pvProvInfo,
                    0                       // dwFlags
                    );
                LockStore(pProvStore);
                ReleaseStoreProv(pProvStore);
            }
        }
        UnlockStore(pProvStore);
    } else if (ELEMENT_TYPE_COLLECTION == pEle->dwElementType) {
        if (pEle->Collection.pCollectionStack)
            ClearCollectionStack(pEle->Collection.pCollectionStack);
    }

    ReleaseContextElement(pEle->pEle);

    // Remove from store
    RemoveContextElement(pEle);
    FreeLinkElement(pEle);
}

STATIC void FreeLinkContextElement(
    IN PCONTEXT_ELEMENT pLinkEle
    )
{
    ReleaseContextElement(pLinkEle->pEle);
    FreeLinkElement(pLinkEle);
}

//+=========================================================================
//  Find Element Functions
//==========================================================================

// For Add, called with store already locked and store remains locked. The
// find type for the Add is FIND_EXISTING.
// CacheStore may contain either cache or context link elements
STATIC PCONTEXT_ELEMENT FindElementInCacheStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle,
    IN BOOL fForceEnumArchived = FALSE
    )
{
    PCONTEXT_ELEMENT pEle;

    assert(STORE_TYPE_CACHE == pStore->dwStoreType);
    LockStore(pStore);

    if (pPrevEle) {
        if (pPrevEle->pStore != pStore ||
                pPrevEle->dwContextType != dwContextType) {
            UnlockStore(pStore);
            goto InvalidPreviousContext;
        }
        pEle = pPrevEle->pNext;
    } else if (STORE_STATE_NULL == pStore->dwState)
        // For NULL store, all elements are already deleted
        pEle = NULL;
    else
        pEle = pStore->rgpContextListHead[dwContextType];

    for ( ; pEle; pEle = pEle->pNext) {
        PCONTEXT_ELEMENT pCacheEle;
        BOOL fArchived;

        assert(ELEMENT_TYPE_CACHE == pEle->dwElementType ||
            ELEMENT_TYPE_LINK_CONTEXT == pEle->dwElementType);

        // Skip past deleted elements
        if (pEle->dwFlags & ELEMENT_DELETED_FLAG)
            continue;

        if (ELEMENT_TYPE_CACHE == pEle->dwElementType)
            pCacheEle = pEle;
        else {
            pCacheEle = GetCacheElement(pEle);
            if (NULL == pCacheEle)
                pCacheEle = pEle;
        }
        fArchived = ((pCacheEle->dwFlags & ELEMENT_ARCHIVED_FLAG) &&
            0 == (pStore->dwFlags & CERT_STORE_ENUM_ARCHIVED_FLAG) &&
            !fForceEnumArchived);

        AddRefContextElement(pEle);
        UnlockStore(pStore);

      // Handle MappedFile Exceptions
      __try {

        if (rgpfnCompareElement[dwContextType](pEle, pFindInfo, fArchived))
            goto CommonReturn;

      } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
        goto ErrorReturn;
      }

        if (pPrevEle)
            ReleaseContextElement(pPrevEle);
        pPrevEle = pEle;

        LockStore(pStore);
    }

    UnlockStore(pStore);
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);

CommonReturn:
    if (pPrevEle)
        ReleaseContextElement(pPrevEle);
    return pEle;

ErrorReturn:
    pEle = NULL;
    goto CommonReturn;

SET_ERROR(InvalidPreviousContext, E_INVALIDARG)
}

STATIC PCONTEXT_ELEMENT FindElementInExternalStore(
    IN PCERT_STORE pStore,      //  EXTERNAL
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle
    )
{
    PCONTEXT_ELEMENT pEle = NULL;
    const DWORD dwStoreProvFindIndex = rgdwStoreProvFindIndex[dwContextType];

    // All the context types have the same find callback signature.
    PFN_CERT_STORE_PROV_FIND_CERT pfnStoreProvFind;

    void *pvProvInfo;
    PCONTEXT_ELEMENT pPrevProvEle = NULL;
    PCCERT_CONTEXT pProvCertContext;

    assert(STORE_TYPE_EXTERNAL == pStore->dwStoreType);

    if (NULL == (pEle = CreateLinkElement(dwContextType)))
        goto CreateLinkElementError;

    if (pPrevEle) {
        BOOL fResult;

        if (pPrevEle->pStore != pStore ||
                pPrevEle->dwContextType != dwContextType)
            goto InvalidPreviousContext;
        assert(ELEMENT_TYPE_EXTERNAL == pPrevEle->dwElementType);

        LockStore(pStore);
        fResult = pPrevEle->dwFlags & ELEMENT_FIND_NEXT_FLAG;
        if (fResult) {
            assert(dwStoreProvFindIndex <
                pStore->StoreProvInfo.cStoreProvFunc &&
                pStore->StoreProvInfo.rgpvStoreProvFunc[dwStoreProvFindIndex]);
            pvProvInfo = pPrevEle->External.pvProvInfo;
            pPrevEle->External.pvProvInfo = NULL;
            pPrevEle->dwFlags &= ~ELEMENT_FIND_NEXT_FLAG;
            pPrevProvEle = pPrevEle->pEle;
            assert(pPrevProvEle);
        }
        UnlockStore(pStore);
        if (!fResult)
            goto InvalidExternalFindNext;
    } else {
        pvProvInfo = NULL;
        pPrevProvEle = NULL;
    }


    // Check if external store supports the context type
    if (dwStoreProvFindIndex >= pStore->StoreProvInfo.cStoreProvFunc ||
        NULL == (pfnStoreProvFind = (PFN_CERT_STORE_PROV_FIND_CERT)
            pStore->StoreProvInfo.rgpvStoreProvFunc[dwStoreProvFindIndex]))
        goto ProvFindNotSupported;

    pProvCertContext = NULL;
    if (!pfnStoreProvFind(
            pStore->StoreProvInfo.hStoreProv,
            pFindInfo,
            ToCertContext(pPrevProvEle),
            0,                      // dwFlags
            &pvProvInfo,
            &pProvCertContext) || NULL == pProvCertContext)
        goto ErrorReturn;

    InitAndAddExternalElement(
        pEle,
        pStore,
        ToContextElement(pProvCertContext),
        ELEMENT_FIND_NEXT_FLAG,
        pvProvInfo
        );

CommonReturn:
    if (pPrevEle)
        ReleaseContextElement(pPrevEle);
    return pEle;

ErrorReturn:
    if (pEle) {
        FreeLinkElement(pEle);
        pEle = NULL;
    }
    goto CommonReturn;

SET_ERROR(InvalidPreviousContext, E_INVALIDARG)
SET_ERROR(InvalidExternalFindNext, E_INVALIDARG)
SET_ERROR(ProvFindNotSupported, ERROR_CALL_NOT_IMPLEMENTED)
TRACE_ERROR(CreateLinkElementError)
}

STATIC PCONTEXT_ELEMENT FindElementInCollectionStore(
    IN PCERT_STORE pCollection,
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle,
    IN BOOL fFindForAdd = FALSE
    )
{
    PCONTEXT_ELEMENT pEle = NULL;
    PCOLLECTION_STACK_ENTRY pStack = NULL;

    if (pPrevEle) {
        // Get previous element's collection stack

        if (pPrevEle->pStore != pCollection ||
                pPrevEle->dwContextType != dwContextType)
            goto InvalidPreviousContext;

        LockStore(pCollection);
        pStack = pPrevEle->Collection.pCollectionStack;
        pPrevEle->Collection.pCollectionStack = NULL;
        UnlockStore(pCollection);

        if (NULL == pStack)
            goto InvalidCollectionFindNext;

        // Note, pStack->pCollection is only equal to pCollection
        // for a single level collection.
        assert(pStack->pStoreLink);
        assert(ELEMENT_TYPE_EXTERNAL == pPrevEle->dwElementType ||
            ELEMENT_TYPE_COLLECTION == pPrevEle->dwElementType);
    } else {
        // Initialize collection stack with the collection store's
        // first link
        if (!PushCollectionStack(&pStack, pCollection))
            goto PushStackError;
    }

    while (pStack) {
        PCERT_STORE pStackCollectionStore;
        PCERT_STORE_LINK pStoreLink;
        PCERT_STORE pFindStore;

        pStackCollectionStore = pStack->pCollection;
        pStoreLink = pStack->pStoreLink;    // may be NULL
        if (NULL == pPrevEle) {
            LockStore(pStackCollectionStore);

            // Advance past any deleted store links
            //
            // Also if doing a find before doing an add to a collection,
            // check that the store link allows an ADD
            while (pStoreLink &&
                ((pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG) ||
                    (fFindForAdd && 0 == (pStoreLink->dwUpdateFlags &
                        CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG))))
                pStoreLink = pStoreLink->pNext;
            if (pStoreLink && pStoreLink != pStack->pStoreLink)
                AddRefStoreLink(pStoreLink);

            UnlockStore(pStackCollectionStore);

            if (NULL == pStoreLink) {
                // Reached end of collection's store links
                PopCollectionStack(&pStack);
                continue;
            } else if (pStoreLink != pStack->pStoreLink) {
                ReleaseStoreLink(pStack->pStoreLink);
                pStack->pStoreLink = pStoreLink;
            }
        }

        assert(pStoreLink);
        pFindStore = pStoreLink->pSibling;
        if (STORE_TYPE_COLLECTION == pFindStore->dwStoreType) {
            assert(NULL == pPrevEle);
            // Add inner collection store to stack
            if (!PushCollectionStack(&pStack, pFindStore))
                goto PushStackError;
        } else if (STORE_TYPE_CACHE == pFindStore->dwStoreType ||
                STORE_TYPE_EXTERNAL == pFindStore->dwStoreType) {
            PCONTEXT_ELEMENT pPrevSiblingEle;
            PCONTEXT_ELEMENT pSiblingEle;

            if (pPrevEle) {
                assert(ELEMENT_TYPE_COLLECTION ==
                    pPrevEle->dwElementType);
                pPrevSiblingEle = pPrevEle->pEle;
                // FindElementInCacheStore or FindElementInExternalStore
                // does an implicit Free
                AddRefContextElement(pPrevSiblingEle);
            } else
                pPrevSiblingEle = NULL;

            if (pSiblingEle = FindElementInStore(
                    pFindStore,
                    dwContextType,
                    pFindInfo,
                    pPrevSiblingEle
                    )) {
                if (NULL == (pEle =
                        CreateLinkElement(dwContextType))) {
                    ReleaseContextElement(pSiblingEle);
                    goto CreateLinkElementError;
                }

                InitAndAddCollectionElement(
                    pEle,
                    pCollection,
                    pSiblingEle,
                    pStack
                    );
                goto CommonReturn;
            }

            if (pPrevEle) {
                ReleaseContextElement(pPrevEle);
                pPrevEle = NULL;
            }

            // Advance to the next store link in the collection
            AdvanceToNextStackStoreLink(pStack);
        } else
            goto InvalidStoreType;
    }
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);

CommonReturn:
    if (pPrevEle)
        ReleaseContextElement(pPrevEle);
    return pEle;
ErrorReturn:
    ClearCollectionStack(pStack);
    pEle = NULL;
    goto CommonReturn;

SET_ERROR(InvalidPreviousContext, E_INVALIDARG)
SET_ERROR(InvalidCollectionFindNext, E_INVALIDARG)
TRACE_ERROR(PushStackError)
TRACE_ERROR(CreateLinkElementError)
SET_ERROR(InvalidStoreType, E_INVALIDARG)
}

STATIC PCONTEXT_ELEMENT FindElementInStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle
    )
{
    assert(pStore->dwState == STORE_STATE_OPEN ||
        pStore->dwState == STORE_STATE_OPENING ||
        pStore->dwState == STORE_STATE_DEFER_CLOSING ||
        pStore->dwState == STORE_STATE_CLOSING ||
        pStore->dwState == STORE_STATE_NULL);

    switch (pStore->dwStoreType) {
        case STORE_TYPE_CACHE:
            return FindElementInCacheStore(
                pStore,
                dwContextType,
                pFindInfo,
                pPrevEle
                );
            break;
        case STORE_TYPE_EXTERNAL:
            return FindElementInExternalStore(
                pStore,
                dwContextType,
                pFindInfo,
                pPrevEle
                );
            break;
        case STORE_TYPE_COLLECTION:
            return FindElementInCollectionStore(
                pStore,
                dwContextType,
                pFindInfo,
                pPrevEle
                );
            break;
        default:
            goto InvalidStoreType;
    }

ErrorReturn:
    return NULL;
SET_ERROR(InvalidStoreType, E_INVALIDARG)
}


STATIC void AutoResyncStore(
    IN PCERT_STORE pStore
    )
{
    if (pStore->hAutoResyncEvent) {
        if (WAIT_OBJECT_0 == WaitForSingleObjectEx(
                pStore->hAutoResyncEvent,
                0,                          // dwMilliseconds
                FALSE                       // bAlertable
                ))
            CertControlStore(
                (HCERTSTORE) pStore,
                CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG,
                CERT_STORE_CTRL_RESYNC,
                &pStore->hAutoResyncEvent
                );

    } else if (STORE_TYPE_COLLECTION == pStore->dwStoreType) {
        // Iterate through all the siblings and attempt to AutoResync

        PCERT_STORE_LINK pStoreLink;
        PCERT_STORE_LINK pPrevStoreLink = NULL;

        LockStore(pStore);
        pStoreLink = pStore->pStoreListHead;
        for (; pStoreLink; pStoreLink = pStoreLink->pNext) {
            // Advance past deleted store link
            if (pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG)
                continue;

            AddRefStoreLink(pStoreLink);
            UnlockStore(pStore);

            if (pPrevStoreLink)
                ReleaseStoreLink(pPrevStoreLink);
            pPrevStoreLink = pStoreLink;

            AutoResyncStore(pStoreLink->pSibling);

            LockStore(pStore);
        }
        UnlockStore(pStore);

        if (pPrevStoreLink)
            ReleaseStoreLink(pPrevStoreLink);
    }
}

STATIC PCONTEXT_ELEMENT CheckAutoResyncAndFindElementInStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN PCCERT_STORE_PROV_FIND_INFO pFindInfo,
    IN OPTIONAL PCONTEXT_ELEMENT pPrevEle
    )
{
    if (NULL == pPrevEle)
        AutoResyncStore(pStore);

    return FindElementInStore(
        pStore,
        dwContextType,
        pFindInfo,
        pPrevEle
        );
}

//+=========================================================================
//  Add Element Functions
//==========================================================================

STATIC void SetFindInfoToFindExisting(
    IN PCONTEXT_ELEMENT pEle,
    IN OUT PCERT_STORE_PROV_FIND_INFO pFindInfo
    )
{
    memset(pFindInfo, 0, sizeof(*pFindInfo));
    pFindInfo->cbSize = sizeof(*pFindInfo);
    pFindInfo->dwFindType = rgdwFindTypeToFindExisting[pEle->dwContextType];
    pFindInfo->pvFindPara = ToCertContext(pEle);
}


STATIC BOOL AddLinkContextToCacheStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pLinkEle = NULL;
    PCONTEXT_ELEMENT pGetEle = NULL;

    if (STORE_TYPE_CACHE != pStore->dwStoreType)
        goto InvalidStoreType;

    // Note, CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES or
    // CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES
    // isn't allowed for adding links
    if (!(CERT_STORE_ADD_NEW == dwAddDisposition ||
            CERT_STORE_ADD_USE_EXISTING == dwAddDisposition ||
            CERT_STORE_ADD_REPLACE_EXISTING == dwAddDisposition ||
            CERT_STORE_ADD_ALWAYS == dwAddDisposition ||
            CERT_STORE_ADD_NEWER == dwAddDisposition))
        goto InvalidAddDisposition;

    LockStore(pStore);
    if (CERT_STORE_ADD_ALWAYS != dwAddDisposition) {
        // Check if the context is already in the store.
        CERT_STORE_PROV_FIND_INFO FindInfo;

        // Check if the context element is already in the store
        SetFindInfoToFindExisting(pEle, &FindInfo);
        if (pGetEle = FindElementInCacheStore(
                pStore,
                pEle->dwContextType,
                &FindInfo,
                NULL                // pPrevEle
                )) {
            UnlockStore(pStore);
            switch (dwAddDisposition) {
            case CERT_STORE_ADD_NEW:
                goto NotNewError;
                break;
            case CERT_STORE_ADD_NEWER:
                if (!rgpfnIsNewerElement[pEle->dwContextType](pEle, pGetEle))
                    goto NotNewError;
                // fall through
            case CERT_STORE_ADD_REPLACE_EXISTING:
                if (DeleteContextElement(pGetEle))
                    // Try again. It shouldn't be in the store.
                    return AddLinkContextToCacheStore(
                        pStore,
                        pEle,
                        dwAddDisposition,
                        ppStoreEle);
                else {
                    // Provider didn't allow the delete
                    pGetEle = NULL;
                    goto DeleteError;
                }
                break;
            case CERT_STORE_ADD_USE_EXISTING:
                if (ppStoreEle)
                    *ppStoreEle = pGetEle;
                else
                    ReleaseContextElement(pGetEle);
                return TRUE;
                break;
            default:
                goto InvalidArg;
                break;
            }
        }
    }

    if (NULL == (pLinkEle = CreateLinkElement(pEle->dwContextType))) {
        UnlockStore(pStore);
        goto CreateLinkElementError;
    }

    AddRefContextElement(pEle);

    InitAndAddLinkContextElement(
        pLinkEle,
        pStore,
        pEle
        );
    if (ppStoreEle) {
        AddRefContextElement(pLinkEle);
        *ppStoreEle = pLinkEle;
    }
    UnlockStore(pStore);
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    if (pGetEle)
        ReleaseContextElement(pGetEle);

    if (ppStoreEle)
        *ppStoreEle = NULL;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidStoreType, E_INVALIDARG)
SET_ERROR(InvalidAddDisposition, E_INVALIDARG)
SET_ERROR(NotNewError, CRYPT_E_EXISTS)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(DeleteError)
TRACE_ERROR(CreateLinkElementError)
}

// pEle is used or freed for success only, Otherwise, its left alone and
// will be freed by the caller.
//
// This routine may be called recursively
//
// For pStore != pEle->pStore, pEle->pStore is the outer collection store.
// pStore is the cache store.
STATIC BOOL AddElementToCacheStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pGetEle = NULL;
    PCONTEXT_ELEMENT pCollectionEle;
    PCERT_STORE pCollectionStore = NULL;
    const DWORD dwStoreProvWriteIndex =
        rgdwStoreProvWriteIndex[pEle->dwContextType];
    PFN_CERT_STORE_PROV_WRITE_CERT pfnStoreProvWriteCert;

    BOOL fUpdateKeyId;

    LockStore(pStore);
    assert(STORE_STATE_DELETED != pStore->dwState &&
        STORE_STATE_CLOSED != pStore->dwState);
    if (STORE_STATE_NULL == pStore->dwState) {
        // CertCreate*Context, CertAddSerializedElementToStore
        // or CertAddEncoded*ToStore with hCertStore == NULL.
        pEle->dwFlags |= ELEMENT_DELETED_FLAG;
        dwAddDisposition = CERT_STORE_ADD_ALWAYS;
    }
    assert(CERT_STORE_ADD_NEW == dwAddDisposition ||
        CERT_STORE_ADD_USE_EXISTING == dwAddDisposition ||
        CERT_STORE_ADD_REPLACE_EXISTING == dwAddDisposition ||
        CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES ==
            dwAddDisposition ||
        CERT_STORE_ADD_ALWAYS == dwAddDisposition ||
        CERT_STORE_ADD_NEWER == dwAddDisposition ||
        CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES == dwAddDisposition);

    if (CERT_STORE_ADD_ALWAYS != dwAddDisposition) {
        // Check if the context is already in the store.
        CERT_STORE_PROV_FIND_INFO FindInfo;

        // Check if the context element is already in the store
        SetFindInfoToFindExisting(pEle, &FindInfo);
        if (pGetEle = FindElementInCacheStore(
                pStore,
                pEle->dwContextType,
                &FindInfo,
                NULL                // pPrevEle
                )) {
            UnlockStore(pStore);

            if (CERT_STORE_ADD_NEWER == dwAddDisposition ||
                    CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES ==
                        dwAddDisposition) {
                if (!rgpfnIsNewerElement[pEle->dwContextType](pEle, pGetEle))
                    goto NotNewError;
            }

            if (CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES ==
                        dwAddDisposition ||
                    CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES ==
                        dwAddDisposition) {
                // If element in the store isn't identical to the one being
                // added, then, inherit properties from and delete the
                // element in the store.
                if (!IsIdenticalContextElement(pEle, pGetEle)) {
                    if (!CopyProperties(
                            pGetEle,
                            pEle,
                            COPY_PROPERTY_USE_EXISTING_FLAG |
                                COPY_PROPERTY_INHIBIT_PROV_SET_FLAG
                            ))
                        goto CopyPropertiesError;
                    dwAddDisposition = CERT_STORE_ADD_REPLACE_EXISTING;
                }
            }


            switch (dwAddDisposition) {
            case CERT_STORE_ADD_NEW:
                goto NotNewError;
                break;
            case CERT_STORE_ADD_REPLACE_EXISTING:
            case CERT_STORE_ADD_NEWER:
                if (DeleteContextElement(pGetEle))
                    // Try again. It shouldn't be in the store.
                    return AddElementToCacheStore(
                        pStore,
                        pEle,
                        dwAddDisposition,
                        ppStoreEle);
                else {
                    // Provider didn't allow the delete
                    pGetEle = NULL;
                    goto DeleteError;
                }
                break;
            case CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES:
            case CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES:
            case CERT_STORE_ADD_USE_EXISTING:
                // For USE_EXISTING, copy any new non-existing properties.
                // Otherwise, copy all properties, replacing existing
                // properties.
                if (!CopyProperties(
                        pEle,
                        pGetEle,
                        CERT_STORE_ADD_USE_EXISTING == dwAddDisposition ?
                            COPY_PROPERTY_USE_EXISTING_FLAG : 0
                        ))
                    goto CopyPropertiesError;
                if (ppStoreEle) {
                    if (pStore != pEle->pStore) {
                        assert(STORE_TYPE_COLLECTION ==
                            pEle->pStore->dwStoreType);
                        if (NULL == (*ppStoreEle = CreateLinkElement(
                                pEle->dwContextType)))
                            goto CreateLinkElementError;
                        InitAndAddCollectionElement(
                            *ppStoreEle,
                            pEle->pStore,
                            pGetEle,
                            NULL                // pCollectionStack
                            );
                    } else
                        *ppStoreEle = pGetEle;
                } else
                    ReleaseContextElement(pGetEle);
                FreeContextElement(pEle);
                return TRUE;
                break;
            default:
                goto InvalidArg;
                break;
            }
        }
    }


    // The element doesn't exist in the store.
    // Check if we need to write through to the provider.
    if (pStore->StoreProvInfo.cStoreProvFunc >
            dwStoreProvWriteIndex  &&
        NULL != (pfnStoreProvWriteCert = (PFN_CERT_STORE_PROV_WRITE_CERT)
            pStore->StoreProvInfo.rgpvStoreProvFunc[
                dwStoreProvWriteIndex])) {
        // Don't ever call the provider holding a lock!!
        // Also, the caller is holding a reference count on the store.
        UnlockStore(pStore);
        if (!pfnStoreProvWriteCert(
                pStore->StoreProvInfo.hStoreProv,
                ToCertContext(pEle),
                (dwAddDisposition << 16) | CERT_STORE_PROV_WRITE_ADD_FLAG))
            goto StoreProvWriteError;
        LockStore(pStore);
        if (CERT_STORE_ADD_ALWAYS != dwAddDisposition) {
            // Check if the certificate was added while the store was unlocked
            CERT_STORE_PROV_FIND_INFO FindInfo;

            // Check if the context element is already in the store
            SetFindInfoToFindExisting(pEle, &FindInfo);
            if (pGetEle = FindElementInCacheStore(
                    pStore,
                    pEle->dwContextType,
                    &FindInfo,
                    NULL                // pPrevEle
                    )) {
                // Try again
                UnlockStore(pStore);
                ReleaseContextElement(pGetEle);
                return AddElementToCacheStore(pStore, pEle, dwAddDisposition,
                    ppStoreEle);
            }
        }
    }

    pCollectionEle = NULL;
    fUpdateKeyId = (pStore->dwFlags & CERT_STORE_UPDATE_KEYID_FLAG) &&
        STORE_STATE_OPENING != pStore->dwState;
    if (pStore != pEle->pStore) {
        assert(STORE_TYPE_COLLECTION == pEle->pStore->dwStoreType);
        if (ppStoreEle) {
            if (NULL == (pCollectionEle =
                    CreateLinkElement(pEle->dwContextType))) {
                UnlockStore(pStore);
                goto CreateLinkElementError;
            }
            pCollectionStore = pEle->pStore;
        }

        // Update the element's store. This is needed when adding to a store in
        // a collection
        pEle->pProvStore = pStore;
        pEle->pStore = pStore;
        SetStoreHandle(pEle);
    }

    if (FindPropElement(pEle, CERT_ARCHIVED_PROP_ID))
        pEle->dwFlags |= ELEMENT_ARCHIVED_FLAG;

    // Finally, add the element to the store.
    AddContextElement(pEle);
    AddRefContextElement(pEle); // needed for fUpdateKeyId

    if (pCollectionEle) {
        assert(pCollectionStore && ppStoreEle);
        AddRefContextElement(pEle);
        UnlockStore(pStore);
        InitAndAddCollectionElement(
            pCollectionEle,
            pCollectionStore,
            pEle,
            NULL                // pCollectionStack
            );
        *ppStoreEle = pCollectionEle;
    } else {
        if (STORE_STATE_NULL == pStore->dwState) {
            if (ppStoreEle)
                // Since the NULL store doesn't hold a reference, use it.
                *ppStoreEle = pEle;
            else
                ReleaseContextElement(pEle);
        } else if (ppStoreEle) {
            AddRefContextElement(pEle);
            *ppStoreEle = pEle;
        }
        UnlockStore(pStore);
    }
    fResult = TRUE;

    if (fUpdateKeyId)
        SetCryptKeyIdentifierKeyProvInfoProperty(pEle);
    ReleaseContextElement(pEle);

CommonReturn:
    return fResult;

ErrorReturn:
    if (pGetEle)
        ReleaseContextElement(pGetEle);

    if (ppStoreEle)
        *ppStoreEle = NULL;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NotNewError, CRYPT_E_EXISTS)
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(DeleteError)
TRACE_ERROR(CopyPropertiesError)
TRACE_ERROR(CreateLinkElementError)
TRACE_ERROR(StoreProvWriteError)
}


// pEle is used or freed for success only, Otherwise, its left alone and
// will be freed by the caller.
//
// This routine may be called recursively
//
// The caller is holding a reference count on the store
//
// For pStore != pEle->pStore, pEle->pStore is the outer collection store.
// pStore is the external store.
STATIC BOOL AddElementToExternalStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    BOOL fResult;

    const DWORD dwStoreProvWriteIndex =
        rgdwStoreProvWriteIndex[pEle->dwContextType];
    PFN_CERT_STORE_PROV_WRITE_CERT pfnStoreProvWriteCert;
    PCONTEXT_ELEMENT pExternalEle = NULL;
    PCONTEXT_ELEMENT pCollectionEle = NULL;
    PCERT_STORE pEleStore;
    BOOL fUpdateKeyId;

    // Check if the store supports the write callback
    if (pStore->StoreProvInfo.cStoreProvFunc <=
            dwStoreProvWriteIndex  ||
        NULL == (pfnStoreProvWriteCert = (PFN_CERT_STORE_PROV_WRITE_CERT)
            pStore->StoreProvInfo.rgpvStoreProvFunc[
                dwStoreProvWriteIndex]))
        goto ProvWriteNotSupported;

    // Remember the Element's store.
    pEleStore = pEle->pStore;
    fUpdateKeyId = pStore->dwFlags & CERT_STORE_UPDATE_KEYID_FLAG;
    if (ppStoreEle) {
        if (NULL == (pExternalEle = CreateLinkElement(pEle->dwContextType)))
            goto CreateLinkElementError;
        if (pStore != pEleStore) {
            assert(STORE_TYPE_COLLECTION == pEleStore->dwStoreType);
            if (NULL == (pCollectionEle =
                    CreateLinkElement(pEle->dwContextType)))
                goto CreateLinkElementError;
        }
    }

    // Update the Element to use the NULL store.
    pEle->pProvStore = &NullCertStore;
    pEle->pStore = &NullCertStore;
    SetStoreHandle(pEle);

    // Also, the caller is holding a reference count on the store.
    if (!pfnStoreProvWriteCert(
            pStore->StoreProvInfo.hStoreProv,
            ToCertContext(pEle),
            (dwAddDisposition << 16) | CERT_STORE_PROV_WRITE_ADD_FLAG)) {
        // Restore the Element's store
        pEle->pProvStore = pEleStore;
        pEle->pStore = pEleStore;
        SetStoreHandle(pEle);
        goto StoreProvWriteError;
    }

    // Add to the NULL store
    pEle->dwFlags |= ELEMENT_DELETED_FLAG;
    AddContextElement(pEle);
    AddRefContextElement(pEle); // needed for fUpdateKeyId

    if (ppStoreEle) {
        InitAndAddExternalElement(
            pExternalEle,
            pStore,                 // pProvStore
            pEle,
            0,                      // dwFlags
            NULL                    // pvProvInfo
            );
        if (pStore != pEleStore) {
            InitAndAddCollectionElement(
                pCollectionEle,
                pEleStore,
                pExternalEle,
                NULL                // pCollectionStack
                );
            *ppStoreEle = pCollectionEle;
        } else
            *ppStoreEle = pExternalEle;
    } else
        ReleaseContextElement(pEle);

    if (fUpdateKeyId)
        SetCryptKeyIdentifierKeyProvInfoProperty(pEle);
    ReleaseContextElement(pEle);

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    if (pExternalEle)
        FreeLinkElement(pExternalEle);
    if (pCollectionEle)
        FreeLinkElement(pCollectionEle);
    if (ppStoreEle)
        *ppStoreEle = NULL;
    goto CommonReturn;

TRACE_ERROR(CreateLinkElementError)
TRACE_ERROR(StoreProvWriteError)
SET_ERROR(ProvWriteNotSupported, E_NOTIMPL)
}



// pEle is used or freed for success only, Otherwise, its left alone and
// will be freed by the caller.
//
// This routine may be called recursively
STATIC BOOL AddElementToCollectionStore(
    IN PCERT_STORE pCollection,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    BOOL fResult;
    PCERT_STORE pOuterCollection;
    PCONTEXT_ELEMENT pGetEle = NULL;
    PCERT_STORE_LINK pStoreLink;
    PCERT_STORE_LINK pPrevStoreLink = NULL;
    DWORD dwAddErr;

    pOuterCollection = pEle->pStore;

    // Only need to do the find once for the outer most collection
    if (pOuterCollection == pCollection &&
            CERT_STORE_ADD_ALWAYS != dwAddDisposition) {
        CERT_STORE_PROV_FIND_INFO FindInfo;

        // Check if the context element is already in any of the collection's
        // stores
        SetFindInfoToFindExisting(pEle, &FindInfo);

        if (pGetEle = FindElementInCollectionStore(
                pCollection,
                pEle->dwContextType,
                &FindInfo,
                NULL,               // pPrevEle
                FALSE               // fFindForAdd
                )) {

            if (CERT_STORE_ADD_NEWER == dwAddDisposition ||
                    CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES ==
                        dwAddDisposition) {
                if (!rgpfnIsNewerElement[pEle->dwContextType](pEle, pGetEle))
                    goto NotNewError;
            }

            switch (dwAddDisposition) {
            case CERT_STORE_ADD_NEW:
                goto NotNewError;
                break;
            case CERT_STORE_ADD_REPLACE_EXISTING:
            case CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES:
            case CERT_STORE_ADD_USE_EXISTING:
            case CERT_STORE_ADD_NEWER:
            case CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES:
                // For success pEle will be used or freed by the called function
                // Add to either the cache or external store

                assert(STORE_TYPE_CACHE == pGetEle->pProvStore->dwStoreType ||
                    STORE_TYPE_EXTERNAL == pGetEle->pProvStore->dwStoreType);
                fResult = AddElementToStore(
                    pGetEle->pProvStore,
                    pEle,
                    dwAddDisposition,
                    ppStoreEle
                    );
                goto CommonReturn;
            default:
                goto InvalidArg;
                break;
            }
        }
    }

    // The element doesn't exist in any of the collection's stores.

    // Iterate and try to add to first where adding is allowed

    LockStore(pCollection);
    dwAddErr = (DWORD) E_ACCESSDENIED;
    pStoreLink = pCollection->pStoreListHead;
    for (; pStoreLink; pStoreLink = pStoreLink->pNext) {
        // Advance past deleted store links and links not enabling adds
        if ((pStoreLink->dwFlags & STORE_LINK_DELETED_FLAG) ||
                0 == (pStoreLink->dwUpdateFlags &
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG))
            continue;

        AddRefStoreLink(pStoreLink);
        UnlockStore(pCollection);
        if (pPrevStoreLink)
            ReleaseStoreLink(pPrevStoreLink);
        pPrevStoreLink = pStoreLink;

        if (AddElementToStore(
                pStoreLink->pSibling,
                pEle,
                dwAddDisposition,
                ppStoreEle
                )) {
            fResult = TRUE;
            goto CommonReturn;
        } else if (E_ACCESSDENIED == dwAddErr) {
            DWORD dwErr = GetLastError();
            if (0 != dwErr)
                dwAddErr = dwErr;
        }

        LockStore(pCollection);
    }
    UnlockStore(pCollection);
    goto NoAddEnabledStore;

CommonReturn:
    if (pGetEle)
        ReleaseContextElement(pGetEle);
    if (pPrevStoreLink)
        ReleaseStoreLink(pPrevStoreLink);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    if (ppStoreEle)
        *ppStoreEle = NULL;
    goto CommonReturn;

SET_ERROR(NotNewError, CRYPT_E_EXISTS)
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR_VAR(NoAddEnabledStore, dwAddErr)
}



// pEle is used or freed for success only, Otherwise, its left alone and
// will be freed by the caller.
//
// This routine may be called recursively
//
// For pStore != pEle->pStore, pEle->pStore is the outer collection store.
// pStore is the inner store
STATIC BOOL AddElementToStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    // Check for valid disposition values
    if (!(CERT_STORE_ADD_NEW == dwAddDisposition ||
            CERT_STORE_ADD_USE_EXISTING == dwAddDisposition ||
            CERT_STORE_ADD_REPLACE_EXISTING == dwAddDisposition ||
            CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES ==
                dwAddDisposition ||
            CERT_STORE_ADD_ALWAYS == dwAddDisposition ||
            CERT_STORE_ADD_NEWER == dwAddDisposition ||
            CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES == dwAddDisposition)) {
        *ppStoreEle = NULL;
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    switch (pStore->dwStoreType) {
        case STORE_TYPE_CACHE:
            return AddElementToCacheStore(
                pStore,
                pEle,
                dwAddDisposition,
                ppStoreEle
                );
            break;
        case STORE_TYPE_EXTERNAL:
            return AddElementToExternalStore(
                pStore,
                pEle,
                dwAddDisposition,
                ppStoreEle
                );
            break;
        case STORE_TYPE_COLLECTION:
            return AddElementToCollectionStore(
                pStore,
                pEle,
                dwAddDisposition,
                ppStoreEle
                );
            break;
        default:
            goto InvalidStoreType;
    }

ErrorReturn:
    return NULL;
SET_ERROR(InvalidStoreType, E_INVALIDARG)
}

STATIC BOOL AddEncodedContextToStore(
    IN PCERT_STORE pStore,
    IN DWORD dwContextType,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    BOOL fResult;
    BYTE *pbAllocEncoded = NULL;
    PCONTEXT_ELEMENT pEle = NULL;
    DWORD dwExceptionCode;

  // Handle MappedFile Exceptions
  __try {

    if (NULL == pStore)
        pStore = &NullCertStore;

    if (NULL == (pbAllocEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
        goto OutOfMemory;

    // If pbEncoded is a MappedFile, the following copy may raise
    // an exception
    memcpy(pbAllocEncoded, pbEncoded, cbEncoded);

    if (NULL == (pEle = rgpfnCreateElement[dwContextType](
            pStore,
            dwCertEncodingType,
            pbAllocEncoded,
            cbEncoded,
            NULL                    // pShareEle
            )))
        goto CreateElementError;

    if (!AddElementToStore(
            pStore,
            pEle,
            dwAddDisposition,
            ppStoreEle
            ))
        goto AddElementError;

    fResult = TRUE;

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

CommonReturn:
    return fResult;

ErrorReturn:
    if (pEle)
        FreeContextElement(pEle);
    else
        PkiFree(pbAllocEncoded);

    if (ppStoreEle)
        *ppStoreEle = NULL;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreateElementError)
TRACE_ERROR(AddElementError)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}

STATIC BOOL AddContextToStore(
    IN PCERT_STORE pStore,
    IN PCONTEXT_ELEMENT pSrcEle,
    IN DWORD dwCertEncodingType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwAddDisposition,
    OUT OPTIONAL PCONTEXT_ELEMENT *ppStoreEle
    )
{
    BOOL fResult;
    BYTE *pbAllocEncoded = NULL;
    PCONTEXT_ELEMENT pEle = NULL;
    DWORD dwExceptionCode;

  // Handle MappedFile Exceptions
  __try {

    if (NULL == pStore)
        pStore = &NullCertStore;

    if (NULL == (pbAllocEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
        goto OutOfMemory;

    // If pbEncoded is a MappedFile, the following copy may raise
    // an exception
    memcpy(pbAllocEncoded, pbEncoded, cbEncoded);
    if (NULL == (pEle = rgpfnCreateElement[pSrcEle->dwContextType](
                pStore,
                dwCertEncodingType,
                pbAllocEncoded,
                cbEncoded,
                NULL                    // pShareEle
                )))
        goto CreateElementError;

    if (!CopyProperties(
                pSrcEle,
                pEle,
                COPY_PROPERTY_INHIBIT_PROV_SET_FLAG
                ))
        goto CopyPropertiesError;

    if (!AddElementToStore(
                pStore,
                pEle,
                dwAddDisposition,
                ppStoreEle
                ))
        goto AddElementError;

    fResult = TRUE;

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

CommonReturn:
    return fResult;

ErrorReturn:
    if (pEle)
        FreeContextElement(pEle);
    else
        PkiFree(pbAllocEncoded);

    if (ppStoreEle)
        *ppStoreEle = NULL;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreateElementError)
TRACE_ERROR(CopyPropertiesError)
TRACE_ERROR(AddElementError)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}

//+=========================================================================
//  PROP_ELEMENT Functions
//==========================================================================

// pbData has already been allocated
STATIC PPROP_ELEMENT CreatePropElement(
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN BYTE *pbData,
    IN DWORD cbData
    )
{
    PPROP_ELEMENT pEle = NULL;

    // Allocate and initialize the prop element structure
    pEle = (PPROP_ELEMENT) PkiZeroAlloc(sizeof(PROP_ELEMENT));
    if (pEle == NULL) return NULL;
    pEle->dwPropId = dwPropId;
    pEle->dwFlags = dwFlags;
    pEle->pbData = pbData;
    pEle->cbData = cbData;
    pEle->pNext = NULL;
    pEle->pPrev = NULL;

    return pEle;
}

STATIC void FreePropElement(IN PPROP_ELEMENT pEle)
{
    if (pEle->dwPropId == CERT_KEY_CONTEXT_PROP_ID) {
        HCRYPTPROV hProv = ((PCERT_KEY_CONTEXT) pEle->pbData)->hCryptProv;
        if (hProv && (pEle->dwFlags & CERT_STORE_NO_CRYPT_RELEASE_FLAG) == 0) {
            DWORD dwErr = GetLastError();
            CryptReleaseContext(hProv, 0);
            SetLastError(dwErr);
        }
    }
    PkiFree(pEle->pbData);
    PkiFree(pEle);
}

// Upon entry/exit: Store/Element is locked
STATIC PPROP_ELEMENT FindPropElement(
    IN PPROP_ELEMENT pPropEle,
    IN DWORD dwPropId
    )
{
    while (pPropEle) {
        if (pPropEle->dwPropId == dwPropId)
            return pPropEle;
        pPropEle = pPropEle->pNext;
    }

    return NULL;
}
STATIC PPROP_ELEMENT FindPropElement(
    IN PCONTEXT_ELEMENT pCacheEle,
    IN DWORD dwPropId
    )
{
    assert(ELEMENT_TYPE_CACHE == pCacheEle->dwElementType);
    return FindPropElement(pCacheEle->Cache.pPropHead, dwPropId);
}

// Upon entry/exit: Store/Element is locked
STATIC void AddPropElement(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN PPROP_ELEMENT pPropEle
    )
{
    // Insert property in the certificate/CRL/CTL's list of properties
    pPropEle->pNext = *ppPropHead;
    pPropEle->pPrev = NULL;
    if (*ppPropHead)
        (*ppPropHead)->pPrev = pPropEle;
    *ppPropHead = pPropEle;
}
STATIC void AddPropElement(
    IN OUT PCONTEXT_ELEMENT pCacheEle,
    IN PPROP_ELEMENT pPropEle
    )
{
    assert(ELEMENT_TYPE_CACHE == pCacheEle->dwElementType);
    AddPropElement(&pCacheEle->Cache.pPropHead, pPropEle);
}


// Upon entry/exit: Store/Element is locked
STATIC void RemovePropElement(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN PPROP_ELEMENT pPropEle
    )
{
    if (pPropEle->pNext)
        pPropEle->pNext->pPrev = pPropEle->pPrev;
    if (pPropEle->pPrev)
        pPropEle->pPrev->pNext = pPropEle->pNext;
    else if (pPropEle == *ppPropHead)
        *ppPropHead = pPropEle->pNext;
    // else
    //  Not on any list
}
STATIC void RemovePropElement(
    IN OUT PCONTEXT_ELEMENT pCacheEle,
    IN PPROP_ELEMENT pPropEle
    )
{
    assert(ELEMENT_TYPE_CACHE == pCacheEle->dwElementType);
    RemovePropElement(&pCacheEle->Cache.pPropHead, pPropEle);
}


//+=========================================================================
//  Property Functions
//==========================================================================

// Upon entry/exit the store is locked
STATIC void DeleteProperty(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN DWORD dwPropId
    )
{
    PPROP_ELEMENT pPropEle;

    // Delete the property
    pPropEle = FindPropElement(*ppPropHead, dwPropId);
    if (pPropEle) {
        RemovePropElement(ppPropHead, pPropEle);
        FreePropElement(pPropEle);
    }
}
STATIC void DeleteProperty(
    IN OUT PCONTEXT_ELEMENT pCacheEle,
    IN DWORD dwPropId
    )
{
    DeleteProperty(&pCacheEle->Cache.pPropHead, dwPropId);
}

//+-------------------------------------------------------------------------
//  Set the property for the specified element
//--------------------------------------------------------------------------
STATIC BOOL SetProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData,
    IN BOOL fInhibitProvSet
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;
    PPROP_ELEMENT pPropEle;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CERT_KEY_CONTEXT KeyContext;

    if (dwPropId == 0 || dwPropId > CERT_LAST_USER_PROP_ID) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    if (dwFlags & CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG)
        fInhibitProvSet = TRUE;

    if (NULL == (pCacheEle = GetCacheElement(pEle)))
        return FALSE;
    pCacheStore = pCacheEle->pStore;

    LockStore(pCacheStore);
    if (dwPropId == CERT_KEY_PROV_HANDLE_PROP_ID ||
            dwPropId == CERT_KEY_SPEC_PROP_ID) {
        // Map to the CERT_KEY_CONTEXT_PROP_ID and update its
        // hCryptProv and/or dwKeySpec field(s).
        DWORD cbData = sizeof(KeyContext);
        if ((fResult = GetProperty(
                pCacheEle,
                CERT_KEY_CONTEXT_PROP_ID,
                &KeyContext,
                &cbData))) {
            if (dwPropId == CERT_KEY_SPEC_PROP_ID) {
                // Inhibit hCryptProv from being closed by the subsequent
                // DeleteProperty. Also, use the existing dwFlags.
                pPropEle = FindPropElement(pCacheEle,
                    CERT_KEY_CONTEXT_PROP_ID);
                assert(pPropEle);
                if (pPropEle) {
                    dwFlags = pPropEle->dwFlags;
                    pPropEle->dwFlags = CERT_STORE_NO_CRYPT_RELEASE_FLAG;
                }
            }
        } else {
            memset(&KeyContext, 0, sizeof(KeyContext));
            KeyContext.cbSize = sizeof(KeyContext);
            if (pvData && dwPropId != CERT_KEY_SPEC_PROP_ID) {
                // Try to get the KeySpec from a CERT_KEY_PROV_INFO_PROP_ID.
                // Need to do without any locks.
                UnlockStore(pCacheStore);
                cbData = sizeof(DWORD);
                GetProperty(
                    pEle,
                    CERT_KEY_SPEC_PROP_ID,
                    &KeyContext.dwKeySpec,
                    &cbData);
                LockStore(pCacheStore);

                // Check if CERT_KEY_CONTEXT_PROP_ID was added while store
                // was unlocked.
                if (FindPropElement(pCacheEle, CERT_KEY_CONTEXT_PROP_ID)) {
                    // We now have a CERT_KEY_CONTEXT_PROP_ID property.
                    // Try again
                    UnlockStore(pCacheStore);
                    return SetProperty(
                        pEle,
                        dwPropId,
                        dwFlags,
                        pvData,
                        fInhibitProvSet
                        );
                }
            }
        }
        if (dwPropId == CERT_KEY_PROV_HANDLE_PROP_ID) {
            KeyContext.hCryptProv = (HCRYPTPROV) pvData;
        } else {
            if (pvData)
                KeyContext.dwKeySpec = *((DWORD *) pvData);
            else
                KeyContext.dwKeySpec = 0;
        }
        if (fResult || pvData)
            // CERT_KEY_CONTEXT_PROP_ID exists or we are creating a
            // new CERT_KEY_CONTEXT_PROP_ID
            pvData = &KeyContext;
        dwPropId = CERT_KEY_CONTEXT_PROP_ID;
    } else if (dwPropId == CERT_KEY_CONTEXT_PROP_ID) {
        if (pvData) {
            PCERT_KEY_CONTEXT pKeyContext = (PCERT_KEY_CONTEXT) pvData;
            if (pKeyContext->cbSize != sizeof(CERT_KEY_CONTEXT))
                goto InvalidArg;
        }
    } else if (!fInhibitProvSet) {
        // Check if we need to call the store provider's writethru function.
        // Note, since the above properties aren't persisted they don't
        // need to be checked.

        const DWORD dwStoreProvSetPropertyIndex =
            rgdwStoreProvSetPropertyIndex[pEle->dwContextType];
        PCERT_STORE pProvStore = pEle->pProvStore;
        PFN_CERT_STORE_PROV_SET_CERT_PROPERTY pfnStoreProvSetProperty;

        // Use provider store. May be in a collection.
        UnlockStore(pCacheStore);
        LockStore(pProvStore);

        if (dwStoreProvSetPropertyIndex <
                pProvStore->StoreProvInfo.cStoreProvFunc &&
            NULL != (pfnStoreProvSetProperty =
                (PFN_CERT_STORE_PROV_SET_CERT_PROPERTY)
                    pProvStore->StoreProvInfo.rgpvStoreProvFunc[
                        dwStoreProvSetPropertyIndex])) {
            // Since we can't hold a lock while calling the provider function,
            // bump the store's provider reference count to inhibit the closing
            // of the store and freeing of the provider functions.
            //
            // When the store is closed, pStore->StoreProvInfo.cStoreProvFunc
            // is set to 0.
            AddRefStoreProv(pProvStore);
            UnlockStore(pProvStore);
#if 0
            // Slow down the provider while holding the provider reference
            // count.
            Sleep(1500);
#endif

            // Note: PFN_CERT_STORE_PROV_SET_CRL_PROPERTY has the same signature
            // except, PCCRL_CONTEXT replaces the PCCERT_CONTEXT parameter.
            fResult = pfnStoreProvSetProperty(
                    pProvStore->StoreProvInfo.hStoreProv,
                    ToCertContext(pEle->pEle),
                    dwPropId,
                    dwFlags,
                    pvData);
            LockStore(pProvStore);
            ReleaseStoreProv(pProvStore);
            UnlockStore(pProvStore);
            LockStore(pCacheStore);
            if (!fResult && !IS_CERT_HASH_PROP_ID(dwPropId) &&
                    !IS_CHAIN_HASH_PROP_ID(dwPropId) &&
                    0 == (dwFlags & CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG))
                goto StoreProvSetCertPropertyError;
            // else
            //  Silently ignore any complaints about setting the
            //  property.
        } else {
            UnlockStore(pProvStore);
            LockStore(pCacheStore);
        }
    }

    if (pvData != NULL) {
        // First, delete the property
        DeleteProperty(pCacheEle, dwPropId);

        if (dwPropId == CERT_KEY_CONTEXT_PROP_ID) {
            cbEncoded = sizeof(CERT_KEY_CONTEXT);
            if (NULL == (pbEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
                goto OutOfMemory;
            memcpy(pbEncoded, (BYTE *) pvData, cbEncoded);
        } else if (dwPropId == CERT_KEY_PROV_INFO_PROP_ID) {
            if (!AllocAndEncodeKeyProvInfo(
                    (PCRYPT_KEY_PROV_INFO) pvData,
                    &pbEncoded,
                    &cbEncoded
                    )) goto AllocAndEncodeKeyProvInfoError;
        } else {
            PCRYPT_DATA_BLOB pDataBlob = (PCRYPT_DATA_BLOB) pvData;
            cbEncoded = pDataBlob->cbData;
            if (cbEncoded) {
                if (NULL == (pbEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
                    goto OutOfMemory;
                memcpy(pbEncoded, pDataBlob->pbData, cbEncoded);
            }
        }

        if (NULL == (pPropEle = CreatePropElement(
                dwPropId,
                dwFlags,
                pbEncoded,
                cbEncoded))) goto CreatePropElementError;
        AddPropElement(pCacheEle, pPropEle);
        if (CERT_ARCHIVED_PROP_ID == dwPropId)
            pCacheEle->dwFlags |= ELEMENT_ARCHIVED_FLAG;

    } else {
        // Delete the property
        DeleteProperty(pCacheEle, dwPropId);
        if (CERT_ARCHIVED_PROP_ID == dwPropId)
            pCacheEle->dwFlags &= ~ELEMENT_ARCHIVED_FLAG;
    }

    fResult = TRUE;
CommonReturn:
    UnlockStore(pCacheStore);

    if (fResult && pvData && !fInhibitProvSet &&
            ((pCacheStore->dwFlags & CERT_STORE_UPDATE_KEYID_FLAG) ||
                (pEle->pStore->dwFlags & CERT_STORE_UPDATE_KEYID_FLAG)))
        SetCryptKeyIdentifierKeyProvInfoProperty(
            pEle,
            dwPropId,
            pvData
            );
    return fResult;

ErrorReturn:
    PkiFree(pbEncoded);
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(StoreProvSetCertPropertyError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(AllocAndEncodeKeyProvInfoError)
TRACE_ERROR(CreatePropElementError)
}

STATIC BOOL AllocAndGetProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    OUT void **ppvData,
    OUT DWORD *pcbData
    )
{
    BOOL fResult;
    void *pvData = NULL;
    DWORD cbData;
    if (!GetProperty(
            pEle,
            dwPropId,
            NULL,               // pvData
            &cbData)) goto GetPropertyError;
    if (cbData) {
        if (NULL == (pvData = PkiNonzeroAlloc(cbData))) goto OutOfMemory;
        if (!GetProperty(
                pEle,
                dwPropId,
                pvData,
                &cbData)) goto GetPropertyError;
    }
    fResult = TRUE;
CommonReturn:
    *ppvData = pvData;
    *pcbData = cbData;
    return fResult;

ErrorReturn:
    PkiFree(pvData);
    pvData = NULL;
    cbData = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetPropertyError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Get the property for the specified element
//
//  Note the pEle's cache store may be locked on entry by the above
//  SetProperty for a CERT_KEY_CONTEXT_PROP_ID.
//--------------------------------------------------------------------------
STATIC BOOL GetProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;
    PCERT_STORE pProvStore;
    DWORD cbIn;

    if (pvData == NULL)
        cbIn = 0;
    else
        cbIn = *pcbData;
    *pcbData = 0;

    if (dwPropId == CERT_KEY_PROV_HANDLE_PROP_ID ||
            dwPropId == CERT_KEY_SPEC_PROP_ID) {
        // These two properties are fields within CERT_KEY_CONTEXT_PROP_ID.

        BOOL fResult;
        CERT_KEY_CONTEXT KeyContext;
        DWORD cbData;
        BYTE *pbData;

        cbData = sizeof(KeyContext);
        fResult = GetProperty(
            pEle,
            CERT_KEY_CONTEXT_PROP_ID,
            &KeyContext,
            &cbData
            );
        if (fResult && sizeof(KeyContext) != cbData) {
            SetLastError((DWORD) CRYPT_E_NOT_FOUND);
            fResult = FALSE;
        }

        if (dwPropId == CERT_KEY_PROV_HANDLE_PROP_ID) {
            cbData = sizeof(HCRYPTPROV);
            pbData = (BYTE *) &KeyContext.hCryptProv;
        } else {
            if (!fResult) {
                // Try to get the dwKeySpec from the CERT_KEY_PROV_INFO_PROP_ID
                PCRYPT_KEY_PROV_INFO pInfo;
                if (fResult = AllocAndGetProperty(
                        pEle,
                        CERT_KEY_PROV_INFO_PROP_ID,
                        (void **) &pInfo,
                        &cbData)) {
                    KeyContext.dwKeySpec = pInfo->dwKeySpec;
                    PkiFree(pInfo);
                }
            }
            cbData = sizeof(DWORD);
            pbData = (BYTE *) &KeyContext.dwKeySpec;
        }

        if (fResult) {
            *pcbData = cbData;
            if (cbIn < cbData) {
                if (pvData) {
                    SetLastError((DWORD) ERROR_MORE_DATA);
                    fResult = FALSE;
                }
            } else if (cbData)
                memcpy((BYTE *) pvData, pbData, cbData);
        }
        return fResult;
    } else if (dwPropId == CERT_ACCESS_STATE_PROP_ID) {
        DWORD dwAccessStateFlags;

        pProvStore = pEle->pProvStore;
        if ((pProvStore->dwFlags & CERT_STORE_READONLY_FLAG) ||
                (pProvStore->StoreProvInfo.dwStoreProvFlags &
                     CERT_STORE_PROV_NO_PERSIST_FLAG))
            dwAccessStateFlags = 0;
        else
            dwAccessStateFlags = CERT_ACCESS_STATE_WRITE_PERSIST_FLAG;

        if ((pEle->pStore->StoreProvInfo.dwStoreProvFlags &
                CERT_STORE_PROV_SYSTEM_STORE_FLAG) ||
            (pProvStore->StoreProvInfo.dwStoreProvFlags &
                CERT_STORE_PROV_SYSTEM_STORE_FLAG))
            dwAccessStateFlags |= CERT_ACCESS_STATE_SYSTEM_STORE_FLAG;

        if ((pEle->pStore->StoreProvInfo.dwStoreProvFlags &
                CERT_STORE_PROV_LM_SYSTEM_STORE_FLAG) ||
            (pProvStore->StoreProvInfo.dwStoreProvFlags &
                CERT_STORE_PROV_LM_SYSTEM_STORE_FLAG))
            dwAccessStateFlags |= CERT_ACCESS_STATE_LM_SYSTEM_STORE_FLAG;

        *pcbData = sizeof(DWORD);
        if (cbIn < sizeof(DWORD)) {
            if (pvData) {
                SetLastError((DWORD) ERROR_MORE_DATA);
                return FALSE;
            }
        } else
            *((DWORD * ) pvData) = dwAccessStateFlags;
        return TRUE;
    }

    if (NULL == (pCacheEle = GetCacheElement(pEle)))
        return FALSE;
    pCacheStore = pCacheEle->pStore;

    LockStore(pCacheStore);
    PPROP_ELEMENT pPropEle = FindPropElement(pCacheEle, dwPropId);
    if (pPropEle) {
        BOOL fResult;
        DWORD cbData = pPropEle->cbData;

        if (dwPropId == CERT_KEY_PROV_INFO_PROP_ID) {
            *pcbData = cbIn;
            fResult = DecodeKeyProvInfo(
                (PSERIALIZED_KEY_PROV_INFO) pPropEle->pbData,
                cbData,
                (PCRYPT_KEY_PROV_INFO) pvData,
                pcbData
                );
        } else {
            fResult = TRUE;
            if (cbIn < cbData) {
                if (pvData) {
                    SetLastError((DWORD) ERROR_MORE_DATA);
                    fResult = FALSE;
                }
            } else if (cbData)
                memcpy((BYTE *) pvData, pPropEle->pbData, cbData);
            *pcbData = cbData;
        }
        UnlockStore(pCacheStore);
        return fResult;
    } else
        UnlockStore(pCacheStore);

    // We're here with property not found and store unlocked.

    // For CERT_*_HASH_PROP_ID: compute its hash and do a SetProperty
    // Also, compute the MD5 hash of the public key bits.
    if (IS_CERT_HASH_PROP_ID(dwPropId)
                    ||
            ((CERT_STORE_CERTIFICATE_CONTEXT - 1) == pEle->dwContextType
                                &&
                (CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID == dwPropId ||
                    CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID == dwPropId ||
                    CERT_SUBJECT_NAME_MD5_HASH_PROP_ID == dwPropId))) {
        BOOL fResult;
        PCERT_STORE pEleStore;

        BYTE *pbEncoded;
        DWORD cbEncoded;
        BYTE Hash[MAX_HASH_LEN];
        CRYPT_DATA_BLOB HashBlob;

        BYTE *pbAlloc = NULL;


        switch (dwPropId) {
        case CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID:
            {
                PCRYPT_BIT_BLOB pPublicKey;

                assert((CERT_STORE_CERTIFICATE_CONTEXT - 1) ==
                    pEle->dwContextType);
                pPublicKey =
                    &(ToCertContext(pEle)->pCertInfo->SubjectPublicKeyInfo.PublicKey);
                pbEncoded = pPublicKey->pbData;
                cbEncoded = pPublicKey->cbData;
            }
            break;
        case CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID:
            {
                PCERT_NAME_BLOB pIssuer;
                PCRYPT_INTEGER_BLOB pSerialNumber;

                assert((CERT_STORE_CERTIFICATE_CONTEXT - 1) ==
                    pEle->dwContextType);
                pIssuer = &(ToCertContext(pEle)->pCertInfo->Issuer);
                pSerialNumber = &(ToCertContext(pEle)->pCertInfo->SerialNumber);

                cbEncoded = pIssuer->cbData + pSerialNumber->cbData;
                if (0 == cbEncoded)
                    pbAlloc = NULL;
                else {
                    if (NULL == (pbAlloc = (BYTE *) PkiNonzeroAlloc(
                            cbEncoded)))
                        return FALSE;

                    if (pIssuer->cbData)
                        memcpy(pbAlloc, pIssuer->pbData, pIssuer->cbData);
                    if (pSerialNumber->cbData)
                        memcpy(pbAlloc + pIssuer->cbData,
                            pSerialNumber->pbData, pSerialNumber->cbData);
                }

                pbEncoded = pbAlloc;
            }
            break;
        case CERT_SUBJECT_NAME_MD5_HASH_PROP_ID:
            {
                PCERT_NAME_BLOB pSubject;

                assert((CERT_STORE_CERTIFICATE_CONTEXT - 1) ==
                    pEle->dwContextType);
                pSubject = &(ToCertContext(pEle)->pCertInfo->Subject);
                pbEncoded = pSubject->pbData;
                cbEncoded = pSubject->cbData;
            }
            break;
        default:
            GetContextEncodedInfo(
                pEle,
                &pbEncoded,
                &cbEncoded
                );
        }

        pEleStore = pEle->pStore;

        HashBlob.pbData = Hash;
        HashBlob.cbData = sizeof(Hash);
        if (CERT_SIGNATURE_HASH_PROP_ID == dwPropId)
            fResult = CryptHashToBeSigned(
                0,                              // hCryptProv
                GetContextEncodingType(pEle),
                pbEncoded,
                cbEncoded,
                Hash,
                &HashBlob.cbData);
        else
            fResult = CryptHashCertificate(
                0,                              // hCryptProv
                dwPropId == CERT_SHA1_HASH_PROP_ID ? CALG_SHA1 : CALG_MD5,
                0,                  //dwFlags
                pbEncoded,
                cbEncoded,
                Hash,
                &HashBlob.cbData);

        if (pbAlloc)
            PkiFree(pbAlloc);

        if (!fResult) {
            assert(HashBlob.cbData <= MAX_HASH_LEN);
            return FALSE;
        }
        assert(HashBlob.cbData);
        if (HashBlob.cbData == 0)
            return FALSE;
        if (!SetProperty(
                pEle,
                dwPropId,
                0,                      // dwFlags
                &HashBlob
                )) return FALSE;

        *pcbData = cbIn;
        return GetProperty(
            pEle,
            dwPropId,
            pvData,
            pcbData);
    } else if (CERT_KEY_IDENTIFIER_PROP_ID == dwPropId) {
        *pcbData = cbIn;
        return GetKeyIdProperty(
            pEle,
            dwPropId,
            pvData,
            pcbData);
    }

    // We're here with property not found and not a hash or KeyId property

    // Since the cache store may be locked when called from SetProperty for
    // a CERT_KEY_CONTEXT_PROP_ID and since this property isn't persisted,
    // don't look in the external store for this property.
    pProvStore = pEle->pProvStore;
    if (STORE_TYPE_EXTERNAL == pProvStore->dwStoreType &&
            CERT_KEY_CONTEXT_PROP_ID != dwPropId) {
        // Check if provider supports getting a non-cached property
        const DWORD dwStoreProvGetPropertyIndex =
            rgdwStoreProvGetPropertyIndex[pEle->dwContextType];
        PFN_CERT_STORE_PROV_GET_CERT_PROPERTY pfnStoreProvGetProperty;

        LockStore(pProvStore);
        if (dwStoreProvGetPropertyIndex <
                pProvStore->StoreProvInfo.cStoreProvFunc &&
                    NULL != (pfnStoreProvGetProperty =
                        (PFN_CERT_STORE_PROV_GET_CERT_PROPERTY)
                    pProvStore->StoreProvInfo.rgpvStoreProvFunc[
                        dwStoreProvGetPropertyIndex])) {
            BOOL fResult;

            // Since we can't hold a lock while calling the provider
            // function, bump the store's provider reference count
            // to inhibit the closing of the store and freeing of
            // the provider functions.
            //
            // When the store is closed,
            // pProvStore->StoreProvInfo.cStoreProvFunc is set to 0.
            AddRefStoreProv(pProvStore);
            UnlockStore(pProvStore);

            *pcbData = cbIn;
            fResult = pfnStoreProvGetProperty(
                pProvStore->StoreProvInfo.hStoreProv,
                ToCertContext(pEle->pEle),
                dwPropId,
                0,                  // dwFlags
                pvData,
                pcbData
                );
            LockStore(pProvStore);
            ReleaseStoreProv(pProvStore);
            UnlockStore(pProvStore);
            return fResult;
        } else
            UnlockStore(pProvStore);
    }

    SetLastError((DWORD) CRYPT_E_NOT_FOUND);
    return FALSE;
}

//+-------------------------------------------------------------------------
//  Serialize a Property
//--------------------------------------------------------------------------
STATIC BOOL SerializeProperty(
    IN HANDLE h,
    IN PFNWRITE pfn,
    IN PCONTEXT_ELEMENT pEle
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;
    PPROP_ELEMENT pPropEle;

    if (NULL == (pCacheEle = GetCacheElement(pEle)))
        return FALSE;
    pCacheStore = pCacheEle->pStore;

    LockStore(pCacheStore);
    fResult = TRUE;
    for (pPropEle = pCacheEle->Cache.pPropHead; pPropEle;
                                            pPropEle = pPropEle->pNext) {
        if (pPropEle->dwPropId != CERT_KEY_CONTEXT_PROP_ID) {
            if(!WriteStoreElement(
                    h,
                    pfn,
                    GetContextEncodingType(pCacheEle),
                    pPropEle->dwPropId,
                    pPropEle->pbData,
                    pPropEle->cbData
                    )) {
                fResult = FALSE;
                break;
            }
        }
    }
    UnlockStore(pCacheStore);
    return(fResult);
}

//+-------------------------------------------------------------------------
//  Get the first or next PropId for the specified element.
//
//  Only enumerates cached properties. Doesn't try to enumerate any external
//  properties.
//
//  Set dwPropId = 0, to get the first. Returns 0, if no more properties.
//--------------------------------------------------------------------------
STATIC DWORD EnumProperties(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId
    )
{
    PPROP_ELEMENT pPropEle;
    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;

    if (NULL == (pCacheEle = GetCacheElement(pEle)))
        return 0;
    pCacheStore = pCacheEle->pStore;

    LockStore(pCacheStore);
    if (0 == dwPropId)
        pPropEle = pCacheEle->Cache.pPropHead;
    else {
        pPropEle = FindPropElement(pCacheEle, dwPropId);
        if (pPropEle)
            pPropEle = pPropEle->pNext;
    }

    if (pPropEle)
        dwPropId = pPropEle->dwPropId;
    else
        dwPropId = 0;
    UnlockStore(pCacheStore);
    return dwPropId;
}

STATIC BOOL CopyProperties(
    IN PCONTEXT_ELEMENT pSrcEle,
    IN PCONTEXT_ELEMENT pDstEle,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    DWORD dwPropId;

    if (dwFlags & COPY_PROPERTY_SYNC_FLAG) {
        // Delete any properties from the Dst element that don't exist
        // in the Src element.

        DWORD dwNextPropId;
        dwNextPropId = EnumProperties(pDstEle, 0);
        while (dwNextPropId) {
            PPROP_ELEMENT pPropEle;
            PCONTEXT_ELEMENT pSrcCacheEle;
            PCERT_STORE pSrcCacheStore;
            PCONTEXT_ELEMENT pDstCacheEle;
            PCERT_STORE pDstCacheStore;

            dwPropId = dwNextPropId;
            dwNextPropId = EnumProperties(pDstEle, dwNextPropId);

            // Don't delete hCryptProv or KeySpec or hash properties
            if (CERT_KEY_CONTEXT_PROP_ID == dwPropId ||
                    IS_CERT_HASH_PROP_ID(dwPropId) ||
                    IS_CHAIN_HASH_PROP_ID(dwPropId))
                continue;
#ifdef CMS_PKCS7
            if (CERT_PUBKEY_ALG_PARA_PROP_ID == dwPropId)
                continue;
#endif  // CMS_PKCS7

            if (NULL == (pSrcCacheEle = GetCacheElement(pSrcEle)))
                continue;
            pSrcCacheStore = pSrcCacheEle->pStore;

            // Don't delete if the src also has the property
            LockStore(pSrcCacheStore);
            pPropEle = FindPropElement(pSrcCacheEle, dwPropId);
            UnlockStore(pSrcCacheStore);
            if (pPropEle)
                continue;

            // Don't delete any non persisted properties
            if (NULL == (pDstCacheEle = GetCacheElement(pDstEle)))
                continue;
            pDstCacheStore = pDstCacheEle->pStore;

            LockStore(pDstCacheStore);
            pPropEle = FindPropElement(pDstCacheEle, dwPropId);
            UnlockStore(pDstCacheStore);
            if (NULL == pPropEle || 0 != (pPropEle->dwFlags &
                    CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG))
                continue;

            SetProperty(
                pDstEle,
                dwPropId,
                0,                              // dwFlags
                NULL,                           // NULL deletes
                dwFlags & COPY_PROPERTY_INHIBIT_PROV_SET_FLAG // fInhibitProvSet
                );
        }
    }

    fResult = TRUE;
    dwPropId = 0;
    while (dwPropId = EnumProperties(pSrcEle, dwPropId)) {
        void *pvData;
        DWORD cbData;

        // Don't copy hCryptProv or KeySpec
        if (CERT_KEY_CONTEXT_PROP_ID == dwPropId)
            continue;
        if (dwFlags & COPY_PROPERTY_USE_EXISTING_FLAG) {
            PPROP_ELEMENT pPropEle;
            PCONTEXT_ELEMENT pDstCacheEle;
            PCERT_STORE pDstCacheStore;

            // For existing, don't copy any hash properties
            if (IS_CERT_HASH_PROP_ID(dwPropId) ||
                    IS_CHAIN_HASH_PROP_ID(dwPropId))
                continue;

            if (NULL == (pDstCacheEle = GetCacheElement(pDstEle)))
                continue;
            pDstCacheStore = pDstCacheEle->pStore;

            // Don't copy if the destination already has the property
            LockStore(pDstCacheStore);
            pPropEle = FindPropElement(pDstCacheEle, dwPropId);
            UnlockStore(pDstCacheStore);
            if (pPropEle)
                continue;
        }

        if (!AllocAndGetProperty(
                pSrcEle,
                dwPropId,
                &pvData,
                &cbData)) {
            if (CRYPT_E_NOT_FOUND == GetLastError()) {
                // Its been deleted after we did the Enum. Start over
                // from the beginning.
                dwPropId = 0;
                continue;
            } else {
                fResult = FALSE;
                break;
            }
        } else {
            CRYPT_DATA_BLOB DataBlob;
            void *pvSetData;

            if (CERT_KEY_PROV_INFO_PROP_ID == dwPropId)
                pvSetData = pvData;
            else {
                DataBlob.pbData = (BYTE *) pvData;
                DataBlob.cbData = cbData;
                pvSetData = &DataBlob;
            }
            fResult = SetProperty(
                pDstEle,
                dwPropId,
                0,                                              // dwFlags
                pvSetData,
                dwFlags & COPY_PROPERTY_INHIBIT_PROV_SET_FLAG // fInhibitProvSet
                );
            if (pvData)
                PkiFree(pvData);
            if (!fResult)
                break;
        }
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  Get or set the caller properties for a store or KeyId element.
//
//  Upon entry/exit, properties are locked by caller.
//--------------------------------------------------------------------------
STATIC BOOL GetCallerProperty(
    IN PPROP_ELEMENT pPropHead,
    IN DWORD dwPropId,
    BOOL fAlloc,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    PPROP_ELEMENT pPropEle;
    DWORD cbData;
    void *pvDstData = NULL;
    DWORD cbDstData;

    if (NULL == (pPropEle = FindPropElement(pPropHead, dwPropId)))
        goto PropertyNotFound;

    if (dwPropId == CERT_KEY_CONTEXT_PROP_ID ||
            dwPropId == CERT_KEY_PROV_HANDLE_PROP_ID)
        goto InvalidPropId;

    cbData = pPropEle->cbData;
    if (fAlloc) {
        if (dwPropId == CERT_KEY_PROV_INFO_PROP_ID) {
            if (!DecodeKeyProvInfo(
                    (PSERIALIZED_KEY_PROV_INFO) pPropEle->pbData,
                    cbData,
                    NULL,               // pInfo
                    &cbDstData
                    ))
                goto DecodeKeyProvInfoError;
        } else
            cbDstData = cbData;
        if (cbDstData) {
            if (NULL == (pvDstData = PkiDefaultCryptAlloc(cbDstData)))
                goto OutOfMemory;
        }
        *((void **) pvData) = pvDstData;
    } else {
        pvDstData = pvData;
        if (NULL == pvData)
            cbDstData = 0;
        else
            cbDstData = *pcbData;
    }

    if (dwPropId == CERT_KEY_PROV_INFO_PROP_ID) {
        fResult = DecodeKeyProvInfo(
            (PSERIALIZED_KEY_PROV_INFO) pPropEle->pbData,
            cbData,
            (PCRYPT_KEY_PROV_INFO) pvDstData,
            &cbDstData
            );
    } else {
        fResult = TRUE;
        if (pvDstData) {
            if (cbDstData < cbData) {
                SetLastError((DWORD) ERROR_MORE_DATA);
                fResult = FALSE;
            } else if (cbData) {
                memcpy((BYTE *) pvDstData, pPropEle->pbData, cbData);
            }
        }
        cbDstData = cbData;
    }

    if (!fResult && fAlloc)
        goto UnexpectedError;

CommonReturn:
    *pcbData = cbDstData;
    return fResult;

ErrorReturn:
    if (fAlloc) {
        *((void **) pvData) = NULL;
        PkiDefaultCryptFree(pvDstData);
    }
    cbDstData = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(PropertyNotFound, CRYPT_E_NOT_FOUND)
SET_ERROR(InvalidPropId, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DecodeKeyProvInfoError)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
}

BOOL SetCallerProperty(
    IN OUT PPROP_ELEMENT *ppPropHead,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN const void *pvData
    )
{
    BOOL fResult;

    if (pvData != NULL) {
        DWORD cbEncoded = 0;
        BYTE *pbEncoded = NULL;
        PPROP_ELEMENT pPropEle;

        // First, delete the property
        DeleteProperty(ppPropHead, dwPropId);

        if (dwPropId == CERT_KEY_CONTEXT_PROP_ID ||
                dwPropId == CERT_KEY_PROV_HANDLE_PROP_ID) {
            goto InvalidPropId;
        } else if (dwPropId == CERT_KEY_PROV_INFO_PROP_ID) {
            if (!AllocAndEncodeKeyProvInfo(
                    (PCRYPT_KEY_PROV_INFO) pvData,
                    &pbEncoded,
                    &cbEncoded
                    )) goto AllocAndEncodeKeyProvInfoError;
        } else {
            PCRYPT_DATA_BLOB pDataBlob = (PCRYPT_DATA_BLOB) pvData;
            cbEncoded = pDataBlob->cbData;
            if (cbEncoded) {
                if (NULL == (pbEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
                    goto OutOfMemory;
                memcpy(pbEncoded, pDataBlob->pbData, cbEncoded);
            }
        }

        if (NULL == (pPropEle = CreatePropElement(
                dwPropId,
                dwFlags,
                pbEncoded,
                cbEncoded))) {
            PkiFree(pbEncoded);
            goto CreatePropElementError;
        }
        AddPropElement(ppPropHead, pPropEle);
    } else
        // Delete the property
        DeleteProperty(ppPropHead, dwPropId);

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidPropId, E_INVALIDARG)
TRACE_ERROR(AllocAndEncodeKeyProvInfoError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreatePropElementError)
}

//+-------------------------------------------------------------------------
//  CRYPT_KEY_PROV_INFO: Encode and Decode Functions
//--------------------------------------------------------------------------
STATIC BOOL AllocAndEncodeKeyProvInfo(
    IN PCRYPT_KEY_PROV_INFO pKeyProvInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    BYTE *pbEncoded;
    DWORD cbEncoded;
    DWORD cbContainerName;
    DWORD cbProvName;

    PCRYPT_KEY_PROV_PARAM pParam;
    PSERIALIZED_KEY_PROV_INFO pDstInfo;
    DWORD Off;
    DWORD cParam;

    // Get overall length
    cbEncoded = sizeof(SERIALIZED_KEY_PROV_INFO) +
        pKeyProvInfo->cProvParam * sizeof(SERIALIZED_KEY_PROV_PARAM);

    for (cParam = pKeyProvInfo->cProvParam, pParam = pKeyProvInfo->rgProvParam;
                                            cParam > 0; cParam--, pParam++) {
        if (pParam->cbData)
            cbEncoded += ENCODE_LEN_ALIGN(pParam->cbData);
    }

    if (pKeyProvInfo->pwszContainerName) {
        cbContainerName = (wcslen(pKeyProvInfo->pwszContainerName) + 1) *
            sizeof(WCHAR);
        cbEncoded += ENCODE_LEN_ALIGN(cbContainerName);
    } else
        cbContainerName = 0;

    if (pKeyProvInfo->pwszProvName) {
        cbProvName = (wcslen(pKeyProvInfo->pwszProvName) + 1) *
            sizeof(WCHAR);
        cbEncoded += ENCODE_LEN_ALIGN(cbProvName);
    } else
        cbProvName = 0;

    assert(cbEncoded <= MAX_FILE_ELEMENT_DATA_LEN);

    // Allocate
    pbEncoded = (BYTE *) PkiZeroAlloc(cbEncoded);
    if (pbEncoded == NULL) {
        *ppbEncoded = NULL;
        *pcbEncoded = 0;
        return FALSE;
    }

    Off = sizeof(SERIALIZED_KEY_PROV_INFO);

    pDstInfo = (PSERIALIZED_KEY_PROV_INFO) pbEncoded;
    // pDstInfo->offwszContainerName
    // pDstInfo->offwszProvName;
    pDstInfo->dwProvType            = pKeyProvInfo->dwProvType;
    pDstInfo->dwFlags               = pKeyProvInfo->dwFlags;
    pDstInfo->cProvParam            = pKeyProvInfo->cProvParam;
    // pDstInfo->offrgProvParam;
    pDstInfo->dwKeySpec             = pKeyProvInfo->dwKeySpec;

    if (pKeyProvInfo->cProvParam) {
        PSERIALIZED_KEY_PROV_PARAM pDstParam;

        pDstParam = (PSERIALIZED_KEY_PROV_PARAM) (pbEncoded + Off);
        pDstInfo->offrgProvParam = Off;
        Off += pKeyProvInfo->cProvParam * sizeof(SERIALIZED_KEY_PROV_PARAM);

        for (cParam = pKeyProvInfo->cProvParam,
             pParam = pKeyProvInfo->rgProvParam;
                                        cParam > 0;
                                            cParam--, pParam++, pDstParam++) {
            pDstParam->dwParam = pParam->dwParam;
            // pDstParam->offbData
            pDstParam->cbData = pParam->cbData;
            pDstParam->dwFlags = pParam->dwFlags;
            if (pParam->cbData) {
                memcpy(pbEncoded + Off, pParam->pbData,  pParam->cbData);
                pDstParam->offbData = Off;
                Off += ENCODE_LEN_ALIGN(pParam->cbData);
            }
        }
    }

    if (cbContainerName) {
        memcpy(pbEncoded + Off, (BYTE *) pKeyProvInfo->pwszContainerName,
            cbContainerName);
        pDstInfo->offwszContainerName = Off;
        Off += ENCODE_LEN_ALIGN(cbContainerName);
    }
    if (cbProvName) {
        memcpy(pbEncoded + Off, (BYTE *) pKeyProvInfo->pwszProvName,
            cbProvName);
        pDstInfo->offwszProvName = Off;
        Off += ENCODE_LEN_ALIGN(cbProvName);
    }

    assert(Off == cbEncoded);

    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return TRUE;
}

STATIC BOOL DecodeKeyProvInfoString(
    IN BYTE *pbSerialized,
    IN DWORD cbSerialized,
    IN DWORD off,
    OUT LPWSTR *ppwsz,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemain
    )
{
    BOOL fResult;
    LONG lRemain = *plRemain;
    LPWSTR pwszDst = (LPWSTR) *ppbExtra;

    if (0 != off) {
        LPWSTR pwszSrc = (LPWSTR) (pbSerialized + off);
        LPWSTR pwszEnd = (LPWSTR) (pbSerialized + cbSerialized);

        if (0 <= lRemain)
            *ppwsz = pwszDst;

        while (TRUE) {
            if (pwszSrc + 1 > pwszEnd)
                goto InvalidData;
            lRemain -= sizeof(WCHAR);
            if (0 <= lRemain)
                *pwszDst++ = *pwszSrc;
            if (L'\0' == *pwszSrc++)
                break;
        }
    } else if (0 <= lRemain)
        *ppwsz = NULL;

    fResult = TRUE;
CommonReturn:
    *ppbExtra = (BYTE *) pwszDst;
    *plRemain = lRemain;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
    
SET_ERROR(InvalidData, ERROR_INVALID_DATA)
}


STATIC BOOL DecodeKeyProvInfo(
    IN PSERIALIZED_KEY_PROV_INFO pSerializedInfo,
    IN DWORD cbSerialized,
    OUT PCRYPT_KEY_PROV_INFO pInfo,
    OUT DWORD *pcbInfo
    )
{
    BOOL fResult;
    DWORD cParam;
    DWORD cbInfo;
    BYTE *pbSerialized;
    LONG lRemain;
    BYTE *pbExtra;
    DWORD dwExceptionCode;

    __try {

        if (sizeof(SERIALIZED_KEY_PROV_INFO) > cbSerialized)
            goto InvalidData;

        if (NULL == pInfo)
            cbInfo = 0;
        else
            cbInfo = *pcbInfo;
        lRemain = cbInfo;
        cParam = pSerializedInfo->cProvParam;
        pbSerialized = (BYTE *) pSerializedInfo;

        lRemain -= sizeof(CRYPT_KEY_PROV_INFO);
        if (0 <= lRemain) {
            pbExtra = (BYTE *) pInfo + sizeof(CRYPT_KEY_PROV_INFO);
            memset(pInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

            // pInfo->pwszContainerName
            // pInfo->pwszProvName
            pInfo->dwProvType = pSerializedInfo->dwProvType;
            pInfo->dwFlags = pSerializedInfo->dwFlags;
            pInfo->cProvParam = cParam;
            // pInfo->rgProvParam
            pInfo->dwKeySpec = pSerializedInfo->dwKeySpec;
        } else
            pbExtra = NULL;

        if (0 < cParam) {
            DWORD off;
            PCRYPT_KEY_PROV_PARAM pParam;
            PSERIALIZED_KEY_PROV_PARAM pSerializedParam;

            off = pSerializedInfo->offrgProvParam;
            if (MAX_PROV_PARAM < cParam ||
                    off > cbSerialized ||
                    (off + cParam * sizeof(SERIALIZED_KEY_PROV_PARAM)) >
                            cbSerialized)
                goto InvalidData;

            lRemain -= cParam * sizeof(CRYPT_KEY_PROV_PARAM);
            if (0 <= lRemain) {
                pParam = (PCRYPT_KEY_PROV_PARAM) pbExtra;
                pInfo->rgProvParam = pParam;
                pbExtra += cParam * sizeof(CRYPT_KEY_PROV_PARAM);
            } else
                pParam = NULL;

            pSerializedParam =
                (PSERIALIZED_KEY_PROV_PARAM) (pbSerialized + off);
            for (; 0 < cParam; cParam--, pParam++, pSerializedParam++) {
                DWORD cbParamData = pSerializedParam->cbData;
                if (0 <= lRemain) {
                    pParam->dwParam = pSerializedParam->dwParam;
                    pParam->pbData = NULL;
                    pParam->cbData = cbParamData;
                    pParam->dwFlags = pSerializedParam->dwFlags;
                }

                if (0 < cbParamData) {
                    LONG lAlignExtra;

                    off = pSerializedParam->offbData;
                    if (MAX_PROV_PARAM_CBDATA < cbParamData ||
                        off > cbSerialized ||
                        (off + cbParamData) > cbSerialized)
                        goto InvalidData;

                    lAlignExtra = ENCODE_LEN_ALIGN(cbParamData);
                    lRemain -= lAlignExtra;
                    if (0 <= lRemain) {
                        pParam->pbData = pbExtra;
                        memcpy(pbExtra, pbSerialized + off, cbParamData);
                        pbExtra += lAlignExtra;
                    }
                }
            }

        }

        if (!DecodeKeyProvInfoString(
                pbSerialized,
                cbSerialized,
                pSerializedInfo->offwszContainerName,
                &pInfo->pwszContainerName,
                &pbExtra,
                &lRemain
                ))
            goto InvalidData;
        if (!DecodeKeyProvInfoString(
                pbSerialized,
                cbSerialized,
                pSerializedInfo->offwszProvName,
                &pInfo->pwszProvName,
                &pbExtra,
                &lRemain
                ))
            goto InvalidData;

        if (0 > lRemain && pInfo) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        } else
            fResult = TRUE;

        cbInfo = (DWORD) ((LONG) cbInfo - lRemain);

   } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto ExceptionError;
   }

CommonReturn:
    *pcbInfo = cbInfo;
    return fResult;

ErrorReturn:
    cbInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidData, ERROR_INVALID_DATA)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}


//+-------------------------------------------------------------------------
//  Creates a CTL entry whose attributes are the certificate context's
//  properties.
//
//  The SubjectIdentifier in the CTL entry is the SHA1 hash of the certificate.
//
//  The certificate properties are added as attributes. The property attribute 
//  OID is the decimal PROP_ID preceded by szOID_CERT_PROP_ID_PREFIX. Each
//  property value is copied as a single attribute value.
//
//  Any additional attributes to be included in the CTL entry can be passed
//  in via the cOptAttr and pOptAttr parameters.
//
//  CTL_ENTRY_FROM_PROP_CHAIN_FLAG can be set in dwFlags, to force the
//  inclusion of the chain building hash properties as attributes.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertCreateCTLEntryFromCertificateContextProperties(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD cOptAttr,
    IN OPTIONAL PCRYPT_ATTRIBUTE rgOptAttr,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT OPTIONAL PCTL_ENTRY pCtlEntry,
    IN OUT DWORD *pcbCtlEntry
    )
{
    BOOL fResult;
    DWORD cbCtlEntry;
    LONG lRemainExtra;
    BYTE *pbExtra;
    DWORD cbData;
    DWORD dwPropId;
    DWORD cProp;
    DWORD cAttr;
    DWORD cValue;
    DWORD cOptValue;
    DWORD iAttr;
    PCRYPT_ATTRIBUTE pAttr;
    PCRYPT_ATTR_BLOB pValue;

    DWORD rgdwChainHashPropId[] = {
        CERT_KEY_IDENTIFIER_PROP_ID,
//        CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID,
//        CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID,
        CERT_SUBJECT_NAME_MD5_HASH_PROP_ID,
    };
#define CHAIN_HASH_PROP_CNT     (sizeof(rgdwChainHashPropId) / \
                                    sizeof(rgdwChainHashPropId[0]))

    if (NULL == pCtlEntry) {
        cbCtlEntry = 0;
        lRemainExtra = 0;
    } else {
        cbCtlEntry = *pcbCtlEntry;
        lRemainExtra = (LONG) cbCtlEntry;
    }

    // Ensure the certificate has the SHA1 hash property
    if (!CertGetCertificateContextProperty(
            pCertContext,
            CERT_SHA1_HASH_PROP_ID,
            NULL,                       // pvData
            &cbData
            ) || SHA1_HASH_LEN != cbData)
        goto GetSha1HashPropError;

    if (dwFlags & CTL_ENTRY_FROM_PROP_CHAIN_FLAG) {
        DWORD i;

        // Ensure the certificate has all of the properties needed for
        // chain building
        for (i = 0; i < CHAIN_HASH_PROP_CNT; i++) {
            if (!CertGetCertificateContextProperty(
                    pCertContext,
                    rgdwChainHashPropId[i],
                    NULL,                       // pvData
                    &cbData
                    ))
                goto GetChainHashPropError;
        }
    }

    
    // Get the property count
    cProp = 0;
    dwPropId = 0;
    while (dwPropId = CertEnumCertificateContextProperties(
            pCertContext, dwPropId)) {
        // We won't copy the hCryptProv, KeySpec or SHA1 hash properties to
        // the attributes
        if (CERT_KEY_CONTEXT_PROP_ID == dwPropId ||
                CERT_SHA1_HASH_PROP_ID == dwPropId)
            continue;

        cProp++;
    }

    // Get the optional value count
    cOptValue = 0;
    for (iAttr = 0; iAttr < cOptAttr; iAttr++) {
        PCRYPT_ATTRIBUTE pOptAttr = &rgOptAttr[iAttr];

        cOptValue += pOptAttr->cValue;
    }

    // Calculate total attribute count. One attribute per property. Include
    // optional attributes passed in.
    cAttr = cOptAttr + cProp;

    // Calculate total value count. One value per property. Include optional
    // attribute values passed in.
    cValue = cOptValue + cProp;


    // Allocate memory for the CTL_ENTRY. array of attributes, all of the
    // attribute value blobs and the SubjectIdentifier hash.
    lRemainExtra -= sizeof(CTL_ENTRY) +
        cAttr * sizeof(CRYPT_ATTRIBUTE) +
        cValue * sizeof(CRYPT_ATTR_BLOB) +
        SHA1_HASH_LEN;

    if (0 <= lRemainExtra) {
        // Initialize the attribute, value and byte pointers
        pAttr = (PCRYPT_ATTRIBUTE) &pCtlEntry[1];
        pValue = (PCRYPT_ATTR_BLOB) &pAttr[cAttr];
        pbExtra = (BYTE *) &pValue[cValue];
        
        // Update the CTL_ENTRY fields
        pCtlEntry->SubjectIdentifier.cbData = SHA1_HASH_LEN;
        pCtlEntry->SubjectIdentifier.pbData = pbExtra;
        if (!CertGetCertificateContextProperty(
                pCertContext,
                CERT_SHA1_HASH_PROP_ID,
                pCtlEntry->SubjectIdentifier.pbData,
                &pCtlEntry->SubjectIdentifier.cbData
                ) || SHA1_HASH_LEN != pCtlEntry->SubjectIdentifier.cbData)
            goto GetSha1HashPropError;
        pbExtra += SHA1_HASH_LEN;

        pCtlEntry->cAttribute = cAttr;
        pCtlEntry->rgAttribute = pAttr;
    } else {
        pAttr = NULL;
        pValue = NULL;
        pbExtra = NULL;
    }

    // Copy over the optional attributes and attribute values
    for (iAttr = 0; iAttr < cOptAttr; iAttr++, pAttr++) {
        PCRYPT_ATTRIBUTE pOptAttr = &rgOptAttr[iAttr];
        DWORD cbOID = strlen(pOptAttr->pszObjId) + 1;
        DWORD iValue;

        lRemainExtra -= cbOID;
        if (0 <= lRemainExtra) {
            memcpy(pbExtra, pOptAttr->pszObjId, cbOID);
            pAttr->pszObjId = (LPSTR) pbExtra;
            pbExtra += cbOID;

            pAttr->cValue = pOptAttr->cValue;
            pAttr->rgValue = pValue;
        }

        for (iValue = 0; iValue < pOptAttr->cValue; iValue++, pValue++) {
            PCRYPT_ATTR_BLOB pOptValue = &pOptAttr->rgValue[iValue];

            assert(0 < cOptValue);
            if (0 == cOptValue)
                goto UnexpectedError;
            cOptValue--;
            
            lRemainExtra -= pOptValue->cbData;
            if (0 <= lRemainExtra) {
                pValue->cbData = pOptValue->cbData;
                pValue->pbData = pbExtra;
                if (0 < pValue->cbData)
                    memcpy(pValue->pbData, pOptValue->pbData, pValue->cbData);
                pbExtra += pValue->cbData;
            }
        }
    }

    assert(0 == cOptValue);
    if (0 != cOptValue)
        goto UnexpectedError;


    // Iterate through the properties and create an attribute and attribute
    // value for each
    dwPropId = 0;
    while (dwPropId = CertEnumCertificateContextProperties(
            pCertContext, dwPropId)) {
        CRYPT_DATA_BLOB OctetBlob;
        BYTE *pbEncoded = NULL;
        DWORD cbEncoded;
        char szPropId[33];
        DWORD cbPrefixOID;
        DWORD cbPropOID;
        DWORD cbOID;

        // We won't copy the hCryptProv, KeySpec or SHA1 hash properties to
        // the attributes
        if (CERT_KEY_CONTEXT_PROP_ID == dwPropId ||
                CERT_SHA1_HASH_PROP_ID == dwPropId)
            continue;

        assert(0 < cProp);
        if (0 == cProp)
            goto UnexpectedError;
        cProp--;

        OctetBlob.cbData = 0;
        OctetBlob.pbData = NULL;
        if (!CertGetCertificateContextProperty(
                pCertContext,
                dwPropId,
                NULL,                       // pvData
                &OctetBlob.cbData
                ))
            goto GetPropError;
        if (OctetBlob.cbData) {
            if (NULL == (OctetBlob.pbData =
                    (BYTE *) PkiNonzeroAlloc(OctetBlob.cbData)))
                 goto OutOfMemory;

            if (!CertGetCertificateContextProperty(
                    pCertContext,
                    dwPropId,
                    OctetBlob.pbData,
                    &OctetBlob.cbData
                    )) {
                PkiFree(OctetBlob.pbData);
                goto GetPropError;
            }

            if (CERT_KEY_PROV_INFO_PROP_ID == dwPropId) {
                // Need to serialize the KeyProvInfo data structure
                BYTE *pbEncodedKeyProvInfo;
                DWORD cbEncodedKeyProvInfo;

                fResult = AllocAndEncodeKeyProvInfo(
                    (PCRYPT_KEY_PROV_INFO) OctetBlob.pbData,
                    &pbEncodedKeyProvInfo,
                    &cbEncodedKeyProvInfo
                    );
                PkiFree(OctetBlob.pbData);
                if (!fResult)
                    goto SerializeKeyProvInfoError;

                OctetBlob.pbData = pbEncodedKeyProvInfo;
                OctetBlob.cbData = cbEncodedKeyProvInfo;
            }
        }

        // Encode the property as an octet string
        fResult = CryptEncodeObjectEx(
            pCertContext->dwCertEncodingType,
            X509_OCTET_STRING,
            &OctetBlob,
            CRYPT_ENCODE_ALLOC_FLAG,
            &PkiEncodePara,
            (void *) &pbEncoded,
            &cbEncoded
            );

        PkiFree(OctetBlob.pbData);
        if (!fResult)
            goto EncodeError;

        // Convert PropId to OID
        _ltoa(dwPropId, szPropId, 10);
        cbPropOID = strlen(szPropId) + 1;
        cbPrefixOID = strlen(szOID_CERT_PROP_ID_PREFIX);

        // Total length of attribute OID
        cbOID = cbPrefixOID + cbPropOID;

        lRemainExtra -= cbOID + cbEncoded;
        if (0 <= lRemainExtra) {
            // Update the attribute and value

            pAttr->pszObjId = (LPSTR) pbExtra;
            memcpy(pbExtra, szOID_CERT_PROP_ID_PREFIX, cbPrefixOID);
            memcpy(pbExtra + cbPrefixOID, szPropId, cbPropOID);
            pbExtra += cbOID;

            assert(0 != cbEncoded);

            pAttr->cValue = 1;
            pAttr->rgValue = pValue;
            pValue->cbData = cbEncoded;
            pValue->pbData = pbExtra;
            memcpy(pbExtra, pbEncoded, cbEncoded);
            pbExtra += cbEncoded;

            pAttr++;
            pValue++;
        }

        PkiFree(pbEncoded);
    }

    assert(0 == cProp);
    if (0 != cProp)
        goto UnexpectedError;

    if (0 <= lRemainExtra) {
        cbCtlEntry = cbCtlEntry - (DWORD) lRemainExtra;
    } else {
        cbCtlEntry = cbCtlEntry + (DWORD) -lRemainExtra;
        if (pCtlEntry) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
            goto CommonReturn;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbCtlEntry = cbCtlEntry;
    return fResult;
ErrorReturn:
    cbCtlEntry = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetSha1HashPropError)
TRACE_ERROR(GetChainHashPropError)
SET_ERROR(UnexpectedError, E_UNEXPECTED)
TRACE_ERROR(GetPropError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(SerializeKeyProvInfoError)
TRACE_ERROR(EncodeError)
}

//+-------------------------------------------------------------------------
//  Sets properties on the certificate context using the attributes in
//  the CTL entry.
//
//  The property attribute OID is the decimal PROP_ID preceded by
//  szOID_CERT_PROP_ID_PREFIX. Only attributes containing such an OID are
//  copied.
//
//  CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG may be set in dwFlags.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertSetCertificateContextPropertiesFromCTLEntry(
    IN PCCERT_CONTEXT pCertContext,
    IN PCTL_ENTRY pCtlEntry,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    BOOL fValidPropData;
    DWORD cAttr;
    PCRYPT_ATTRIBUTE pAttr;
    size_t cchPropPrefix;

    if (SHA1_HASH_LEN != pCtlEntry->SubjectIdentifier.cbData)
        goto InvalidCtlEntry;

    if (!CertSetCertificateContextProperty(
            pCertContext,
            CERT_SHA1_HASH_PROP_ID,
            dwFlags,
            &pCtlEntry->SubjectIdentifier
            ))
        goto SetSha1HashPropError;

    cchPropPrefix = strlen(szOID_CERT_PROP_ID_PREFIX);

    fValidPropData = TRUE;
    // Loop through the attributes. 
    for (cAttr = pCtlEntry->cAttribute,
            pAttr = pCtlEntry->rgAttribute; cAttr > 0; cAttr--, pAttr++) {
        DWORD dwPropId;
        PCRYPT_ATTR_BLOB pValue;

        CRYPT_DATA_BLOB PropBlob;
        PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
        void *pvData;

        // Skip any non-property attributes
        if (0 != strncmp(pAttr->pszObjId, szOID_CERT_PROP_ID_PREFIX,
                cchPropPrefix))
            continue;

        dwPropId = (DWORD) strtoul(pAttr->pszObjId + cchPropPrefix, NULL, 10);
        if (0 == dwPropId)
            continue;

        // Check that we have a single valued attribute encoded as an
        // OCTET STRING
        if (1 != pAttr->cValue) {
            fValidPropData = FALSE;
            continue;
        }
        pValue = pAttr->rgValue;
        if (2 > pValue->cbData ||
                ASN1UTIL_TAG_OCTETSTRING != pValue->pbData[0]) {
            fValidPropData = FALSE;
            continue;
        }

        // Extract the property bytes from the encoded OCTET STRING
        if (0 >= Asn1UtilExtractContent(
                pValue->pbData,
                pValue->cbData,
                &PropBlob.cbData,
                (const BYTE **) &PropBlob.pbData
                ) || CMSG_INDEFINITE_LENGTH == PropBlob.cbData) {
            fValidPropData = FALSE;
            continue;
        }

        if (CERT_KEY_PROV_INFO_PROP_ID == dwPropId) {
            BYTE *pbAlignedData = NULL;
            DWORD cbData;
            DWORD cbInfo;

            cbData = PropBlob.cbData;
            if (0 == cbData) {
                fValidPropData = FALSE;
                continue;
            }

            if (NULL == (pbAlignedData = (BYTE *) PkiNonzeroAlloc(cbData)))
                goto OutOfMemory;
            memcpy(pbAlignedData, PropBlob.pbData, cbData);

            if (!DecodeKeyProvInfo(
                    (PSERIALIZED_KEY_PROV_INFO) pbAlignedData,
                    cbData,
                    NULL,               // pInfo
                    &cbInfo
                    )) {
                PkiFree(pbAlignedData);
                fValidPropData = FALSE;
                continue;
            }

            if (NULL == (pKeyProvInfo =
                    (PCRYPT_KEY_PROV_INFO) PkiNonzeroAlloc(cbInfo))) {
                PkiFree(pbAlignedData);
                goto OutOfMemory;
            }

            if (!DecodeKeyProvInfo(
                    (PSERIALIZED_KEY_PROV_INFO) pbAlignedData,
                    cbData,
                    pKeyProvInfo,
                    &cbInfo
                    )) {
                PkiFree(pbAlignedData);
                PkiFree(pKeyProvInfo);
                fValidPropData = FALSE;
                continue;
            }

            PkiFree(pbAlignedData);
            pvData = (void *) pKeyProvInfo;
        } else
            pvData = (void *) &PropBlob;


        fResult = CertSetCertificateContextProperty(
                pCertContext,
                dwPropId,
                dwFlags,
                pvData
                );

        if (pKeyProvInfo)
            PkiFree(pKeyProvInfo);
        if (!fResult)
            goto SetPropError;
        
    }

    if (!fValidPropData)
        goto InvalidPropData;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidCtlEntry, E_INVALIDARG)
TRACE_ERROR(SetSha1HashPropError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(SetPropError)
SET_ERROR(InvalidPropData, ERROR_INVALID_DATA)
}

//+=========================================================================
//  KEYID_ELEMENT Functions
//==========================================================================

// pbKeyIdEncoded has already been allocated
STATIC PKEYID_ELEMENT CreateKeyIdElement(
    IN BYTE *pbKeyIdEncoded,
    IN DWORD cbKeyIdEncoded
    )
{
    PKEYID_ELEMENT pEle = NULL;

    // Allocate and initialize the prop element structure
    pEle = (PKEYID_ELEMENT) PkiZeroAlloc(sizeof(KEYID_ELEMENT));
    if (pEle == NULL) return NULL;
    pEle->KeyIdentifier.pbData = pbKeyIdEncoded;
    pEle->KeyIdentifier.cbData = cbKeyIdEncoded;

    return pEle;
}

STATIC void FreeKeyIdElement(IN PKEYID_ELEMENT pEle)
{
    PPROP_ELEMENT pPropEle;

    if (NULL == pEle)
        return;

    PkiFree(pEle->KeyIdentifier.pbData);

    // Free the Key Identifier's property elements
    while (pPropEle = pEle->pPropHead) {
        RemovePropElement(&pEle->pPropHead, pPropEle);
        FreePropElement(pPropEle);
    }
    PkiFree(pEle);
}


//+-------------------------------------------------------------------------
//  Open Message Store Provider
//
//  Get Certs and CRLs from the message. pvPara contains the HCRYPTMSG
//  to read.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenMsgStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    PCERT_STORE pStore = (PCERT_STORE) hCertStore;
    HCRYPTMSG hCryptMsg = (HCRYPTMSG) pvPara;

    BOOL fResult;
    BYTE *pbEncoded = NULL;
    DWORD cCert;
    DWORD cCrl;
    DWORD cbData;
    DWORD dwIndex;

    PCONTEXT_ELEMENT pCertEle;
    PCONTEXT_ELEMENT pCrlEle;

    if (dwFlags & CERT_STORE_UNSAFE_PHYSICAL_FLAG) {
        SetLastError((DWORD) E_INVALIDARG);
        goto ErrorReturn;
    }

    if (0 == GET_CERT_ENCODING_TYPE(dwEncodingType))
        dwEncodingType |= X509_ASN_ENCODING;

    // Get count of certificates and CRLs in the message
    cCert = 0;
    cbData = sizeof(cCert);
    fResult = CryptMsgGetParam(
        hCryptMsg,
        CMSG_CERT_COUNT_PARAM,
        0,                      // dwIndex
        &cCert,
        &cbData
        );
    if (!fResult) goto ErrorReturn;

    cCrl = 0;
    cbData = sizeof(cCrl);
    fResult = CryptMsgGetParam(
        hCryptMsg,
        CMSG_CRL_COUNT_PARAM,
        0,                      // dwIndex
        &cCrl,
        &cbData
        );
    if (!fResult) goto ErrorReturn;

    for (dwIndex = 0; dwIndex < cCert; dwIndex++) {
        if (NULL == (pbEncoded = (BYTE *) AllocAndGetMsgParam(
                hCryptMsg,
                CMSG_CERT_PARAM,
                dwIndex,
                &cbData))) goto ErrorReturn;

        pCertEle = CreateCertElement(
            pStore,
            dwEncodingType,
            pbEncoded,
            cbData,
            NULL                    // pShareEle
            );
        if (pCertEle == NULL)
            goto ErrorReturn;
        else {
            pbEncoded = NULL;
            AddContextElement(pCertEle);
        }
    }

    for (dwIndex = 0; dwIndex < cCrl; dwIndex++) {
        if (NULL == (pbEncoded = (BYTE *) AllocAndGetMsgParam(
                hCryptMsg,
                CMSG_CRL_PARAM,
                dwIndex,
                &cbData))) goto ErrorReturn;

        pCrlEle = CreateCrlElement(
            pStore,
            dwEncodingType,
            pbEncoded,
            cbData,
            NULL                    // pShareEle
            );
        if (pCrlEle == NULL)
            goto ErrorReturn;
        else {
            pbEncoded = NULL;
            AddContextElement(pCrlEle);
        }
    }

    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_NO_PERSIST_FLAG;
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    PkiFree(pbEncoded);
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Open PKCS #7 Signed Message Store Provider
//
//  Get Certs and CRLs from the message. pvPara points to a CRYPT_DATA_BLOB
//  containing the signed message.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenPKCS7StoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    PCRYPT_DATA_BLOB pMsg = (PCRYPT_DATA_BLOB) pvPara;
    HCRYPTMSG hMsg = NULL;
    DWORD dwMsgType;

    if (dwFlags & CERT_STORE_UNSAFE_PHYSICAL_FLAG)
        goto UnsafeOpenPKCS7Error;

    if (0 == GET_CERT_ENCODING_TYPE(dwEncodingType))
        dwEncodingType |= X509_ASN_ENCODING;
    if (0 == GET_CMSG_ENCODING_TYPE(dwEncodingType))
        dwEncodingType |= PKCS_7_ASN_ENCODING;

    if (Asn1UtilIsPKCS7WithoutContentType(pMsg->pbData, pMsg->cbData))
        dwMsgType = CMSG_SIGNED;
    else
        dwMsgType = 0;
    if (NULL == (hMsg = CryptMsgOpenToDecode(
            dwEncodingType,
            0,                          // dwFlags
            dwMsgType,
            0,                          // hCryptProv,
            NULL,                       // pRecipientInfo
            NULL                        // pStreamInfo
            ))) goto MsgOpenToDecodeError;
    if (!CryptMsgUpdate(
            hMsg,
            pMsg->pbData,
            pMsg->cbData,
            TRUE                    // fFinal
            )) goto MsgUpdateError;

    fResult = OpenMsgStoreProv(
            lpszStoreProvider,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            (const void *) hMsg,
            hCertStore,
            pStoreProvInfo
            );
    // Set in above call
    //  pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_NO_PERSIST_FLAG;


CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(UnsafeOpenPKCS7Error, E_INVALIDARG)
TRACE_ERROR(MsgOpenToDecodeError)
TRACE_ERROR(MsgUpdateError)
}

STATIC BOOL LoadSerializedStore(
    IN HANDLE h,
    IN PFNREAD pfnRead,
    IN PFNSKIP pfnSkip,
    IN DWORD cbReadSize,
    IN PCERT_STORE pStore
    )
{

    FILE_HDR FileHdr;
    DWORD   csStatus;

    if (!pfnRead(
            h,
            &FileHdr,
            sizeof(FileHdr)))
        return FALSE;

    if (FileHdr.dwVersion != CERT_FILE_VERSION_0 ||
        FileHdr.dwMagic != CERT_MAGIC) {
        SetLastError((DWORD) CRYPT_E_FILE_ERROR);
        return(FALSE);
    }

    while (CSContinue == (csStatus = LoadStoreElement(
            h,
            pfnRead,
            pfnSkip,
            cbReadSize,
            pStore,
            CERT_STORE_ADD_ALWAYS,
            CERT_STORE_ALL_CONTEXT_FLAG,
            NULL,                           // pdwContextType
            NULL)))                         // ppvContext
        ;
    if(csStatus == CSError)
        return(FALSE);

    return(TRUE);
}

//+-------------------------------------------------------------------------
//  Add the serialized store to the store.
//
//  Called from logstor.cpp for serialized registry stores
//--------------------------------------------------------------------------
BOOL WINAPI I_CertAddSerializedStore(
        IN HCERTSTORE hCertStore,
        IN BYTE *pbStore,
        IN DWORD cbStore
        )
{
    MEMINFO MemInfo;

    MemInfo.pByte = pbStore;
    MemInfo.cb = cbStore;
    MemInfo.cbSeek = 0;

    return LoadSerializedStore(
        (HANDLE) &MemInfo,
        ReadFromMemory,
        SkipInMemory,
        cbStore,
        (PCERT_STORE) hCertStore
        );
}


//+-------------------------------------------------------------------------
//  Open Serialized Store Provider
//
//  pvPara points to a CRYPT_DATA_BLOB containing an in memory serialized
//  Store.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenSerializedStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    PCRYPT_DATA_BLOB pData = (PCRYPT_DATA_BLOB) pvPara;

    if (dwFlags & CERT_STORE_UNSAFE_PHYSICAL_FLAG) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_NO_PERSIST_FLAG;

    assert(pData);
    return I_CertAddSerializedStore(
        hCertStore,
        pData->pbData,
        pData->cbData
        );
}

//+=========================================================================
//  File Store Provider Functions
//==========================================================================

#define OPEN_FILE_FLAGS_MASK        (CERT_STORE_CREATE_NEW_FLAG | \
                                        CERT_STORE_OPEN_EXISTING_FLAG | \
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG | \
                                        CERT_STORE_SHARE_CONTEXT_FLAG | \
                                        CERT_STORE_SHARE_STORE_FLAG | \
                                        CERT_STORE_BACKUP_RESTORE_FLAG | \
                                        CERT_STORE_READONLY_FLAG | \
                                        CERT_STORE_MANIFOLD_FLAG | \
                                        CERT_STORE_UPDATE_KEYID_FLAG | \
                                        CERT_STORE_ENUM_ARCHIVED_FLAG | \
                                        CERT_STORE_NO_CRYPT_RELEASE_FLAG | \
                                        CERT_STORE_SET_LOCALIZED_NAME_FLAG | \
                                        CERT_FILE_STORE_COMMIT_ENABLE_FLAG)


//+-------------------------------------------------------------------------
//  File Store Provider handle information. Only applicable when the store
//  was opened with CERT_FILE_STORE_COMMIT_ENABLE_FLAG set in dwFlags.
//--------------------------------------------------------------------------
typedef struct _FILE_STORE {
    HCERTSTORE          hCertStore;         // not duplicated
    CRITICAL_SECTION    CriticalSection;
    HANDLE              hFile;
    DWORD               dwLoFilePointer;
    LONG                lHiFilePointer;
    DWORD               dwEncodingType;
    DWORD               dwSaveAs;
    BOOL                fTouched;      // set for write, delete or set property
} FILE_STORE, *PFILE_STORE;

//+-------------------------------------------------------------------------
//  Lock and unlock file functions
//--------------------------------------------------------------------------
static inline void LockFileStore(IN PFILE_STORE pFileStore)
{
    EnterCriticalSection(&pFileStore->CriticalSection);
}
static inline void UnlockFileStore(IN PFILE_STORE pFileStore)
{
    LeaveCriticalSection(&pFileStore->CriticalSection);
}

STATIC BOOL CommitFile(
    IN PFILE_STORE pFileStore,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    BOOL fTouched;

    assert(pFileStore);
    LockFileStore(pFileStore);

    if (dwFlags & CERT_STORE_CTRL_COMMIT_FORCE_FLAG)
        fTouched = TRUE;
    else if (dwFlags & CERT_STORE_CTRL_COMMIT_CLEAR_FLAG)
        fTouched = FALSE;
    else
        fTouched = pFileStore->fTouched;

    if (fTouched) {
        HANDLE hFile = pFileStore->hFile;
        DWORD dwLoFilePointer;
        LONG lHiFilePointer = pFileStore->lHiFilePointer;

        // Start the file overwrite at the same location as we started
        // the store read from the file.
        assert(hFile);
        dwLoFilePointer = SetFilePointer(
            hFile,
            (LONG) pFileStore->dwLoFilePointer,
            &lHiFilePointer,
            FILE_BEGIN
            );
        if (0xFFFFFFFF == dwLoFilePointer && NO_ERROR != GetLastError())
            goto SetFilePointerError;

        if (!CertSaveStore(
                pFileStore->hCertStore,
                pFileStore->dwEncodingType,
                pFileStore->dwSaveAs,
                CERT_STORE_SAVE_TO_FILE,
                (void *) hFile,
                0))                     // dwFlags
            goto SaveStoreError;

        if (!SetEndOfFile(hFile))
            goto SetEndOfFileError;
    }
    pFileStore->fTouched = FALSE;
    fResult = TRUE;

CommonReturn:
    UnlockFileStore(pFileStore);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(SetFilePointerError)
TRACE_ERROR(SaveStoreError)
TRACE_ERROR(SetEndOfFileError)
}

//+-------------------------------------------------------------------------
//  File Store Provider Functions for stores opened with
//  CERT_FILE_STORE_COMMIT_ENABLE_FLAG set in dwFlags.
//
//  Note, since the CRL and CTL callbacks have the same signature as the
//  certificate callbacks and since we don't need to access the context
//  information, we can also use the certificate callbacks for CRLs and
//  CTLs.
//--------------------------------------------------------------------------
STATIC void WINAPI FileStoreProvClose(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags
        )
{
    PFILE_STORE pFileStore = (PFILE_STORE) hStoreProv;

    if (pFileStore) {
        if (pFileStore->fTouched)
            CommitFile(
                pFileStore,
                0               // dwFlags
                );
        if (pFileStore->hFile)
            CloseHandle(pFileStore->hFile);
        DeleteCriticalSection(&pFileStore->CriticalSection);
        PkiFree(pFileStore);
    }
}

STATIC BOOL WINAPI FileStoreProvWriteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    PFILE_STORE pFileStore = (PFILE_STORE) hStoreProv;
    assert(pFileStore);
    pFileStore->fTouched = TRUE;
    return TRUE;
}

STATIC BOOL WINAPI FileStoreProvDeleteCert(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwFlags
        )
{
    PFILE_STORE pFileStore = (PFILE_STORE) hStoreProv;
    assert(pFileStore);
    pFileStore->fTouched = TRUE;
    return TRUE;
}

STATIC BOOL WINAPI FileStoreProvSetCertProperty(
        IN HCERTSTOREPROV hStoreProv,
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD dwPropId,
        IN DWORD dwFlags,
        IN const void *pvData
        )
{
    PFILE_STORE pFileStore = (PFILE_STORE) hStoreProv;
    assert(pFileStore);
    pFileStore->fTouched = TRUE;
    return TRUE;
}


STATIC BOOL WINAPI FileStoreProvControl(
        IN HCERTSTOREPROV hStoreProv,
        IN DWORD dwFlags,
        IN DWORD dwCtrlType,
        IN void const *pvCtrlPara
        )
{
    BOOL fResult;
    PFILE_STORE pFileStore = (PFILE_STORE) hStoreProv;

    switch (dwCtrlType) {
        case CERT_STORE_CTRL_COMMIT:
            fResult = CommitFile(pFileStore, dwFlags);
            break;
        default:
            goto NotSupported;
    }

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NotSupported, ERROR_CALL_NOT_IMPLEMENTED)
}

static void * const rgpvFileStoreProvFunc[] = {
    // CERT_STORE_PROV_CLOSE_FUNC              0
    FileStoreProvClose,
    // CERT_STORE_PROV_READ_CERT_FUNC          1
    NULL,
    // CERT_STORE_PROV_WRITE_CERT_FUNC         2
    FileStoreProvWriteCert,
    // CERT_STORE_PROV_DELETE_CERT_FUNC        3
    FileStoreProvDeleteCert,
    // CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC  4
    FileStoreProvSetCertProperty,
    // CERT_STORE_PROV_READ_CRL_FUNC           5
    NULL,
    // CERT_STORE_PROV_WRITE_CRL_FUNC          6
    FileStoreProvWriteCert,
    // CERT_STORE_PROV_DELETE_CRL_FUNC         7
    FileStoreProvDeleteCert,
    // CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC   8
    FileStoreProvSetCertProperty,
    // CERT_STORE_PROV_READ_CTL_FUNC           9
    NULL,
    // CERT_STORE_PROV_WRITE_CTL_FUNC          10
    FileStoreProvWriteCert,
    // CERT_STORE_PROV_DELETE_CTL_FUNC         11
    FileStoreProvDeleteCert,
    // CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC   12
    FileStoreProvSetCertProperty,
    // CERT_STORE_PROV_CONTROL_FUNC            13
    FileStoreProvControl
};
#define FILE_STORE_PROV_FUNC_COUNT (sizeof(rgpvFileStoreProvFunc) / \
                                    sizeof(rgpvFileStoreProvFunc[0]))


STATIC BOOL OpenFileForCommit(
    IN HANDLE hFile,
    IN DWORD dwLoFilePointer,
    IN LONG lHiFilePointer,
    IN HCERTSTORE hCertStore,
    IN DWORD dwEncodingType,
    IN DWORD dwSaveAs,
    IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
    )
{
    BOOL fResult;

    PFILE_STORE pFileStore;

    if (NULL == (pFileStore = (PFILE_STORE) PkiZeroAlloc(sizeof(FILE_STORE))))
        return FALSE;
    if (!Pki_InitializeCriticalSection(&pFileStore->CriticalSection)) {
        PkiFree(pFileStore);
        return FALSE;
    }

    // Duplicate the file HANDLE
    if (!DuplicateHandle(
            GetCurrentProcess(),
            hFile,
            GetCurrentProcess(),
            &pFileStore->hFile,
            GENERIC_READ | GENERIC_WRITE,   // dwDesiredAccess
            FALSE,                          // bInheritHandle
            0                               // dwOptions
            ) || NULL == pFileStore->hFile)
        goto DuplicateFileError;

    pFileStore->hCertStore = hCertStore;

    pFileStore->dwLoFilePointer = dwLoFilePointer;
    pFileStore->lHiFilePointer = lHiFilePointer;
    pFileStore->dwEncodingType = dwEncodingType;
    pFileStore->dwSaveAs = dwSaveAs;

    pStoreProvInfo->cStoreProvFunc = FILE_STORE_PROV_FUNC_COUNT;
    pStoreProvInfo->rgpvStoreProvFunc = (void **) rgpvFileStoreProvFunc;
    pStoreProvInfo->hStoreProv = (HCERTSTOREPROV) pFileStore;
    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    PkiFree(pFileStore);
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(DuplicateFileError)
}


//+-------------------------------------------------------------------------
//  Open File Store Provider
//
//  Get Certs and CRLs from the opened file. pvPara contains the opened
//  HANDLE of the file to read.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//
//	Opening an empty file is tolerated.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenFileStoreProv(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    HANDLE hFile = (HANDLE) pvPara;
    DWORD dwLoFilePointer = 0;
    LONG lHiFilePointer = 0;
    DWORD cbReadSize;

    if (dwFlags & ~OPEN_FILE_FLAGS_MASK)
        goto InvalidArg;
    if (dwFlags & CERT_FILE_STORE_COMMIT_ENABLE_FLAG) {
        if (dwFlags & CERT_STORE_READONLY_FLAG)
            goto InvalidArg;
        // Get current file location. This is where we will start the
        // commits.
        lHiFilePointer = 0;
        dwLoFilePointer = SetFilePointer(
            hFile,
            0,                  // lDistanceToMove
            &lHiFilePointer,
            FILE_CURRENT
            );
        if (0xFFFFFFFF == dwLoFilePointer && NO_ERROR != GetLastError())
            goto SetFilePointerError;
    }

    cbReadSize = GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == cbReadSize) goto FileError;
    fResult = LoadSerializedStore(
        hFile,
        ReadFromFile,
        SkipInFile,
        cbReadSize,
        (PCERT_STORE) hCertStore
        );

    if (!fResult) {
        if (0 == GetFileSize(hFile, NULL))
            // Empty file
            fResult = TRUE;
    }

    if (fResult && (dwFlags & CERT_FILE_STORE_COMMIT_ENABLE_FLAG))
        fResult = OpenFileForCommit(
            hFile,
            dwLoFilePointer,
            lHiFilePointer,
            hCertStore,
            dwEncodingType,
            CERT_STORE_SAVE_AS_STORE,
            pStoreProvInfo
            );
    else
        pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_NO_PERSIST_FLAG;

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(SetFilePointerError)
TRACE_ERROR(FileError)
}

//+-------------------------------------------------------------------------
//  Open Filename Store Provider (Unicode version)
//
//  Attempt to open a file containing a Store, a PKCS #7 signed
//  message or a single encoded certificate.
//
//  pvPara contains a LPCWSTR of the Filename.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//
//	Opening an empty file is tolerated.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenFilenameStoreProvW(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    LPWSTR pwszFile = (LPWSTR) pvPara;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    CRYPT_DATA_BLOB FileData;
    memset(&FileData, 0, sizeof(FileData));
    DWORD cbBytesRead;
    DWORD dwSaveAs = 0;
    HCERTSTORE hSpecialCertStore = NULL;

    assert(pwszFile);

    dwFlags &= ~CERT_STORE_UNSAFE_PHYSICAL_FLAG;
    if (dwFlags & ~OPEN_FILE_FLAGS_MASK)
        goto InvalidArg;

    if (dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG)
        ILS_EnableBackupRestorePrivileges();

    if (0 == GET_CERT_ENCODING_TYPE(dwEncodingType))
        dwEncodingType |= X509_ASN_ENCODING;
    if (0 == GET_CMSG_ENCODING_TYPE(dwEncodingType))
        dwEncodingType |= PKCS_7_ASN_ENCODING;

    if (dwFlags & CERT_FILE_STORE_COMMIT_ENABLE_FLAG) {
        DWORD dwCreate;

        if (dwFlags & CERT_STORE_READONLY_FLAG)
            goto InvalidArg;

        if (dwFlags & CERT_STORE_CREATE_NEW_FLAG)
            dwCreate = CREATE_NEW;
        else if (dwFlags & CERT_STORE_OPEN_EXISTING_FLAG)
            dwCreate = OPEN_EXISTING;
        else
            dwCreate = OPEN_ALWAYS;

        if (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
                  pwszFile,
                  GENERIC_READ | GENERIC_WRITE,
                  FILE_SHARE_READ,
                  NULL,                   // lpsa
                  dwCreate,
                  FILE_ATTRIBUTE_NORMAL |
                    ((dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) ?
                        FILE_FLAG_BACKUP_SEMANTICS : 0),  
                  NULL                    // hTemplateFile
                  )))
            goto CreateFileError;

        // Default to saving as a serialized store
        dwSaveAs = CERT_STORE_SAVE_AS_STORE;

        if (0 == GetFileSize(hFile, NULL)) {
            // Use file extension to determine dwSaveAs
            LPWSTR pwszExt;
            pwszExt = pwszFile + wcslen(pwszFile);
            while (pwszExt-- > pwszFile) {
                if (L'.' == *pwszExt) {
                    pwszExt++;
                    if (0 == _wcsicmp(pwszExt, L"p7c") ||
                            0 == _wcsicmp(pwszExt, L"spc"))
                        dwSaveAs = CERT_STORE_SAVE_AS_PKCS7;
                    break;
                }
            }
            goto CommitReturn;
        }
    } else {
        WIN32_FILE_ATTRIBUTE_DATA FileAttr;

        if (!GetFileAttributesExW(
                pwszFile,
                GetFileExInfoStandard,
                &FileAttr
                ))
            goto GetFileAttributesError;

        if (INVALID_HANDLE_VALUE == (hFile = CreateFileU(
                  pwszFile,
                  GENERIC_READ,
                  FILE_SHARE_READ,
                  NULL,                   // lpsa
                  OPEN_EXISTING,
                  FILE_ATTRIBUTE_NORMAL |
                    ((dwFlags & CERT_STORE_BACKUP_RESTORE_FLAG) ?
                        FILE_FLAG_BACKUP_SEMANTICS : 0),  
                  NULL                    // hTemplateFile
                  )))
            goto CreateFileError;
    }

    if (OpenFileStoreProv(
            lpszStoreProvider,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            (const void *) hFile,
            hCertStore,
            pStoreProvInfo)) {
        // For commit, we have already called OpenFileForCommit
        fResult = TRUE;
        goto OpenReturn;
    }

    // Read the entire file. Will attempt to process as either a
    // PKCS #7 or as a single cert.
    //
    // Will first try as binary. If that fails will try as base64 encoded.
    if (0 != SetFilePointer(hFile, 0, NULL, FILE_BEGIN))
        goto FileError;
    FileData.cbData = GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == FileData.cbData) goto FileError;
    if (0 == FileData.cbData)
        // Empty file
        goto CommitReturn;
    if (NULL == (FileData.pbData = (BYTE *) PkiNonzeroAlloc(FileData.cbData)))
        goto OutOfMemory;
    if (!ReadFile(
            hFile,
            FileData.pbData,
            FileData.cbData,
            &cbBytesRead,
            NULL            // lpOverlapped
            )) goto FileError;

    if (OpenPKCS7StoreProv(
            lpszStoreProvider,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            (const void *) &FileData,
            hCertStore,
            pStoreProvInfo)) {
        dwSaveAs = CERT_STORE_SAVE_AS_PKCS7;
        goto CommitReturn;
    }

    // Try to process as a single encoded certificate
    if (CertAddEncodedCertificateToStore(
            hCertStore,
            dwEncodingType,
            FileData.pbData,
            FileData.cbData,
            CERT_STORE_ADD_USE_EXISTING,
            NULL)) {
        if (dwFlags & CERT_FILE_STORE_COMMIT_ENABLE_FLAG)
            goto CanNotCommitX509CertFileError;
        else
            goto CommitReturn;
    }

    // Try to process as an encoded PKCS7, X509 or CERT_PAIR in any
    // format
    if (CryptQueryObject(
            CERT_QUERY_OBJECT_BLOB,
            &FileData,
            CERT_QUERY_CONTENT_FLAG_CERT |
                CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
                CERT_QUERY_CONTENT_FLAG_CERT_PAIR,
            CERT_QUERY_FORMAT_FLAG_ALL,
            0,                                  // dwFlags
            NULL,                               // pdwMsgAndCertEncodingType
            NULL,                               // pdwContentType
            NULL,                               // pdwFormatType
            &hSpecialCertStore,
            NULL,                               // phMsg
            NULL                                // ppvContext
            )) {
        fResult = I_CertUpdateStore(hCertStore, hSpecialCertStore, 0, NULL);
        CertCloseStore(hSpecialCertStore, 0);
        if (!fResult)
            goto UpdateStoreError;
        if (dwFlags & CERT_FILE_STORE_COMMIT_ENABLE_FLAG)
            goto CanNotCommitSpecialFileError;
        else
            goto CommitReturn;
    }

    goto NoStoreOrPKCS7OrCertFileError;

CommitReturn:
    if (dwFlags & CERT_FILE_STORE_COMMIT_ENABLE_FLAG)
        fResult = OpenFileForCommit(
            hFile,
            0,                          // dwLoFilePointer
            0,                          // lHiFilePointer
            hCertStore,
            dwEncodingType,
            dwSaveAs,
            pStoreProvInfo
            );
    else {
        pStoreProvInfo->dwStoreProvFlags |= CERT_STORE_PROV_NO_PERSIST_FLAG;
        fResult = TRUE;
    }
OpenReturn:
    if (dwFlags & CERT_STORE_SET_LOCALIZED_NAME_FLAG) {
        CRYPT_DATA_BLOB Property;
        Property.pbData = (BYTE *) pwszFile;
        Property.cbData = (wcslen(pwszFile) + 1) * sizeof(WCHAR);
        CertSetStoreProperty(
            hCertStore,
            CERT_STORE_LOCALIZED_NAME_PROP_ID,
            0,                                  // dwFlags
            (const void *) &Property
            );
    }

CommonReturn:
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);
    if (FileData.pbData)
        PkiFree(FileData.pbData);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(GetFileAttributesError)
TRACE_ERROR(CreateFileError)
TRACE_ERROR(FileError)
TRACE_ERROR(OutOfMemory)
SET_ERROR(CanNotCommitX509CertFileError, ERROR_ACCESS_DENIED)
SET_ERROR(CanNotCommitSpecialFileError, ERROR_ACCESS_DENIED)
SET_ERROR(NoStoreOrPKCS7OrCertFileError, CRYPT_E_FILE_ERROR)
TRACE_ERROR(UpdateStoreError)
}

//+-------------------------------------------------------------------------
//  Open Filename Store Provider (ASCII version)
//
//  Attempt to open a file containing a Store, a PKCS #7 signed
//  message or a single encoded certificate.
//
//  pvPara contains a LPCWSTR of the Filename.
//
//  Note for an error return, the caller will free any certs or CRLs
//  successfully added to the store.
//
//	Opening an empty file is tolerated.
//--------------------------------------------------------------------------
STATIC BOOL WINAPI OpenFilenameStoreProvA(
        IN LPCSTR lpszStoreProvider,
        IN DWORD dwEncodingType,
        IN HCRYPTPROV hCryptProv,
        IN DWORD dwFlags,
        IN const void *pvPara,
        IN HCERTSTORE hCertStore,
        IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
        )
{
    BOOL fResult;
    LPWSTR pwszFilename;
    assert(pvPara);
    if (NULL == (pwszFilename = MkWStr((LPSTR) pvPara)))
        fResult = FALSE;
    else {
        fResult = OpenFilenameStoreProvW(
            lpszStoreProvider,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            (const void *) pwszFilename,
            hCertStore,
            pStoreProvInfo
            );
        FreeWStr(pwszFilename);
    }
    return fResult;
}

//+=========================================================================
//  CryptAcquireCertificatePrivateKey Support Functions
//==========================================================================

// Upon entry/exit, the Cache Store is locked.
//
// OUTs are only updated for success.
STATIC BOOL GetCacheKeyContext(
    IN PCONTEXT_ELEMENT pCacheEle,
    OUT HCRYPTPROV *phCryptProv,
    OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    BOOL fResult = FALSE;
    PPROP_ELEMENT pPropEle;
    if (pPropEle = FindPropElement(pCacheEle, CERT_KEY_CONTEXT_PROP_ID)) {
        PCERT_KEY_CONTEXT pKeyContext =
            (PCERT_KEY_CONTEXT) pPropEle->pbData;
        assert(pKeyContext);
        assert(pPropEle->cbData >= sizeof(CERT_KEY_CONTEXT));
        if (pKeyContext->hCryptProv) {
            *phCryptProv = pKeyContext->hCryptProv;
            if (pdwKeySpec)
                *pdwKeySpec = pKeyContext->dwKeySpec;
            fResult = TRUE;
        }
    }
    return fResult;
}


STATIC PCRYPT_KEY_PROV_INFO GetKeyIdentifierKeyProvInfo(
    IN PCONTEXT_ELEMENT pCacheEle
    )
{
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    DWORD cbKeyProvInfo;
    BYTE rgbKeyId[MAX_HASH_LEN];
    DWORD cbKeyId;
    CRYPT_HASH_BLOB KeyIdentifier;

    cbKeyId = sizeof(rgbKeyId);
    if(!GetProperty(
            pCacheEle,
            CERT_KEY_IDENTIFIER_PROP_ID,
            rgbKeyId,
            &cbKeyId
            ))
        return NULL;

    KeyIdentifier.pbData = rgbKeyId;
    KeyIdentifier.cbData = cbKeyId;

    if (CryptGetKeyIdentifierProperty(
            &KeyIdentifier,
            CERT_KEY_PROV_INFO_PROP_ID,
            CRYPT_KEYID_ALLOC_FLAG,
            NULL,                           // pwszComputerName
            NULL,                           // pvReserved
            (void *) &pKeyProvInfo,
            &cbKeyProvInfo
            ))
        return pKeyProvInfo;

    // Try again, searching LocalMachine
    if (CryptGetKeyIdentifierProperty(
            &KeyIdentifier,
            CERT_KEY_PROV_INFO_PROP_ID,
            CRYPT_KEYID_ALLOC_FLAG | CRYPT_KEYID_MACHINE_FLAG,
            NULL,                           // pwszComputerName
            NULL,                           // pvReserved
            (void *) &pKeyProvInfo,
            &cbKeyProvInfo
            ))
        return pKeyProvInfo;
    else
        return NULL;
}

STATIC BOOL AcquireKeyContext(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwFlags,
    IN PCRYPT_KEY_PROV_INFO pKeyProvInfo,
    IN OUT PCERT_KEY_CONTEXT pKeyContext,
    IN OUT BOOL *pfBadPubKey
    )
{
    BOOL fResult;
    DWORD dwAcquireFlags;
    DWORD dwIdx;

    dwAcquireFlags = pKeyProvInfo->dwFlags & ~CERT_SET_KEY_CONTEXT_PROP_ID;
    if (dwFlags & CRYPT_ACQUIRE_SILENT_FLAG)
        dwAcquireFlags |= CRYPT_SILENT;
    pKeyContext->dwKeySpec = pKeyProvInfo->dwKeySpec;

    if (PROV_RSA_FULL == pKeyProvInfo->dwProvType &&
            (NULL == pKeyProvInfo->pwszProvName ||
                L'\0' == *pKeyProvInfo->pwszProvName ||
                0 == _wcsicmp(pKeyProvInfo->pwszProvName, MS_DEF_PROV_W)))
        fResult = CryptAcquireContextU(
            &pKeyContext->hCryptProv,
            pKeyProvInfo->pwszContainerName,
            MS_ENHANCED_PROV_W,
            PROV_RSA_FULL,
            dwAcquireFlags
            );
    else if (PROV_DSS_DH == pKeyProvInfo->dwProvType &&
            (NULL == pKeyProvInfo->pwszProvName ||
                L'\0' == *pKeyProvInfo->pwszProvName ||
                0 == _wcsicmp(pKeyProvInfo->pwszProvName,
                    MS_DEF_DSS_DH_PROV_W)))
        fResult = CryptAcquireContextU(
            &pKeyContext->hCryptProv,
            pKeyProvInfo->pwszContainerName,
            MS_ENH_DSS_DH_PROV_W,
            PROV_DSS_DH,
            dwAcquireFlags
            );
    else
        fResult = FALSE;
    if (!fResult) {
        if (!CryptAcquireContextU(
                &pKeyContext->hCryptProv,
                pKeyProvInfo->pwszContainerName,
                pKeyProvInfo->pwszProvName,
                pKeyProvInfo->dwProvType,
                dwAcquireFlags
                )) {
            pKeyContext->hCryptProv = 0;
            goto AcquireContextError;
        }
    }

    for (dwIdx = 0; dwIdx < pKeyProvInfo->cProvParam; dwIdx++) {
        PCRYPT_KEY_PROV_PARAM pKeyProvParam = &pKeyProvInfo->rgProvParam[dwIdx];
        if (!CryptSetProvParam(
                pKeyContext->hCryptProv,
                pKeyProvParam->dwParam,
                pKeyProvParam->pbData,
                pKeyProvParam->dwFlags
                ))
            goto SetProvParamError;
    }


    if (dwFlags & CRYPT_ACQUIRE_COMPARE_KEY_FLAG) {
        if (!I_CertCompareCertAndProviderPublicKey(
                pCert,
                pKeyContext->hCryptProv,
                pKeyContext->dwKeySpec
                )) {
            *pfBadPubKey = TRUE;
            goto BadPublicKey;
        }
    }

    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    if (pKeyContext->hCryptProv) {
        DWORD dwErr = GetLastError();
        CryptReleaseContext(pKeyContext->hCryptProv, 0);
        SetLastError(dwErr);
        pKeyContext->hCryptProv = 0;
    }
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(AcquireContextError)
TRACE_ERROR(SetProvParamError)
SET_ERROR(BadPublicKey, NTE_BAD_PUBLIC_KEY)
}

//+-------------------------------------------------------------------------
//  Acquire a HCRYPTPROV handle and dwKeySpec for the specified certificate
//  context. Uses the certificate's CERT_KEY_PROV_INFO_PROP_ID property.
//  The returned HCRYPTPROV handle may optionally be cached using the
//  certificate's CERT_KEY_CONTEXT_PROP_ID property.
//
//  If CRYPT_ACQUIRE_CACHE_FLAG is set, then, if an already acquired and
//  cached HCRYPTPROV exists for the certificate, its returned. Otherwise,
//  a HCRYPTPROV is acquired and then cached via the certificate's
//  CERT_KEY_CONTEXT_PROP_ID.
//
//  The CRYPT_ACQUIRE_USE_PROV_INFO_FLAG can be set to use the dwFlags field of
//  the certificate's CERT_KEY_PROV_INFO_PROP_ID property's CRYPT_KEY_PROV_INFO
//  data structure to determine if the returned HCRYPTPROV should be cached.
//  HCRYPTPROV caching is enabled if the CERT_SET_KEY_CONTEXT_PROP_ID flag was
//  set.
//
//  If CRYPT_ACQUIRE_COMPARE_KEY_FLAG is set, then,
//  the public key in the certificate is compared with the public
//  key returned by the cryptographic provider. If the keys don't match, the
//  acquire fails and LastError is set to NTE_BAD_PUBLIC_KEY. Note, if
//  a cached HCRYPTPROV is returned, the comparison isn't done. We assume the
//  comparison was done on the initial acquire.
//
//  The CRYPT_ACQUIRE_SILENT_FLAG can be set to suppress any UI by the CSP.
//  See CryptAcquireContext's CRYPT_SILENT flag for more details.
//
//  *pfCallerFreeProv is returned set to FALSE for:
//    - Acquire or public key comparison fails.
//    - CRYPT_ACQUIRE_CACHE_FLAG is set.
//    - CRYPT_ACQUIRE_USE_PROV_INFO_FLAG is set AND
//      CERT_SET_KEY_CONTEXT_PROP_ID flag is set in the dwFlags field of the
//      certificate's CERT_KEY_PROV_INFO_PROP_ID property's
//      CRYPT_KEY_PROV_INFO data structure.
//  When *pfCallerFreeProv is FALSE, the caller must not release. The
//  returned HCRYPTPROV will be released on the last free of the certificate
//  context.
//
//  Otherwise, *pfCallerFreeProv is TRUE and the returned HCRYPTPROV must
//  be released by the caller by calling CryptReleaseContext.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptAcquireCertificatePrivateKey(
    IN PCCERT_CONTEXT pCert,
    IN DWORD dwFlags,
    IN void *pvReserved,
    OUT HCRYPTPROV *phCryptProv,
    OUT OPTIONAL DWORD *pdwKeySpec,
    OUT OPTIONAL BOOL *pfCallerFreeProv
    )
{
    BOOL fResult;
    BOOL fCallerFreeProv;
    PCONTEXT_ELEMENT pCacheEle;
    PCERT_STORE pCacheStore;

    CERT_KEY_CONTEXT KeyContext;
    memset(&KeyContext, 0, sizeof(KeyContext));
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    DWORD cbData;
    BOOL fKeyIdentifier = FALSE;
    BOOL fBadPubKey = FALSE;

    if (NULL == (pCacheEle = GetCacheElement(ToContextElement(pCert))))
        goto InvalidCert;
    pCacheStore = pCacheEle->pStore;

    if (dwFlags &
            (CRYPT_ACQUIRE_CACHE_FLAG | CRYPT_ACQUIRE_USE_PROV_INFO_FLAG)) {
        // Attempt to use existing CERT_KEY_CONTEXT_PROP_ID property

        LockStore(pCacheStore);
        if (GetCacheKeyContext(
                pCacheEle,
                phCryptProv,
                pdwKeySpec
                )) {
            if (pfCallerFreeProv)
                *pfCallerFreeProv = FALSE;
            UnlockStore(pCacheStore);
            return TRUE;
        }
        UnlockStore(pCacheStore);
    }

    if (!AllocAndGetProperty(
            pCacheEle,
            CERT_KEY_PROV_INFO_PROP_ID,
            (void **) &pKeyProvInfo,
            &cbData)) {
        fKeyIdentifier = TRUE;
        if (NULL == (pKeyProvInfo = GetKeyIdentifierKeyProvInfo(pCacheEle)))
            goto NoKeyProperty;
    }

    if (!AcquireKeyContext(
            pCert,
            dwFlags,
            pKeyProvInfo,
            &KeyContext,
            &fBadPubKey
            )) {
        DWORD dwLastErr;

        if (fKeyIdentifier)
            goto AcquireKeyContextError;

        dwLastErr = GetLastError();
        if (ERROR_CANCELLED == dwLastErr ||
                SCARD_W_CANCELLED_BY_USER == dwLastErr ||
                HRESULT_FROM_WIN32(ERROR_CANCELLED) == dwLastErr)
            goto AcquireKeyContextError;

        PkiFree(pKeyProvInfo);
        fKeyIdentifier = TRUE;
        if (NULL == (pKeyProvInfo = GetKeyIdentifierKeyProvInfo(pCacheEle)))
            goto NoKeyProperty;

        if (!AcquireKeyContext(
                pCert,
                dwFlags,
                pKeyProvInfo,
                &KeyContext,
                &fBadPubKey
                ))
            goto AcquireKeyContextError;
    }


    fResult = TRUE;
    if ((dwFlags & CRYPT_ACQUIRE_CACHE_FLAG)
                        ||
        ((dwFlags & CRYPT_ACQUIRE_USE_PROV_INFO_FLAG) &&
            (pKeyProvInfo->dwFlags & CERT_SET_KEY_CONTEXT_PROP_ID))) {
        // Cache the context.

        HCRYPTPROV hCryptProv;
        DWORD dwKeySpec;

        LockStore(pCacheStore);
        // First check that another thread hasn't already cached the context.
        if (GetCacheKeyContext(
                pCacheEle,
                &hCryptProv,
                &dwKeySpec
                )) {
            CryptReleaseContext(KeyContext.hCryptProv, 0);
            KeyContext.hCryptProv = hCryptProv;
            KeyContext.dwKeySpec = dwKeySpec;
        } else {
            KeyContext.cbSize = sizeof(KeyContext);
            fResult = SetProperty(
                pCacheEle,
                CERT_KEY_CONTEXT_PROP_ID,
                0,                              // dwFlags
                (void *) &KeyContext,
                TRUE                            // fInhibitProvSet
                );
        }
        UnlockStore(pCacheStore);
        if (!fResult) goto SetKeyContextPropertyError;
        fCallerFreeProv = FALSE;
    } else
        fCallerFreeProv = TRUE;

CommonReturn:
    if (pKeyProvInfo) {
        if (fKeyIdentifier)
            PkiDefaultCryptFree(pKeyProvInfo);
        else
            PkiFree(pKeyProvInfo);
    }

    *phCryptProv = KeyContext.hCryptProv;
    if (pdwKeySpec)
        *pdwKeySpec = KeyContext.dwKeySpec;
    if (pfCallerFreeProv)
        *pfCallerFreeProv = fCallerFreeProv;
    return fResult;

ErrorReturn:
    if (fBadPubKey)
        SetLastError((DWORD) NTE_BAD_PUBLIC_KEY);
    if (KeyContext.hCryptProv) {
        DWORD dwErr = GetLastError();
        CryptReleaseContext(KeyContext.hCryptProv, 0);
        SetLastError(dwErr);
        KeyContext.hCryptProv = 0;
    }
    fResult = FALSE;
    fCallerFreeProv = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidCert, E_INVALIDARG)
SET_ERROR(NoKeyProperty, CRYPT_E_NO_KEY_PROPERTY)
TRACE_ERROR(AcquireKeyContextError)
TRACE_ERROR(SetKeyContextPropertyError)
}

//+=========================================================================
//  I_CertSyncStore and I_CertSyncStoreEx Support Functions
//==========================================================================

// Returns FALSE if unable to do the find. For instance, OutOfMemory error.
STATIC BOOL FindElementInOtherStore(
    IN PCERT_STORE pOtherStore,
    IN DWORD dwContextType,
    IN PCONTEXT_ELEMENT pEle,
    OUT PCONTEXT_ELEMENT *ppOtherEle
    )
{
    PCONTEXT_ELEMENT pOtherEle;
    BYTE rgbHash[SHA1_HASH_LEN];
    DWORD cbHash;

    *ppOtherEle = NULL;

    cbHash = SHA1_HASH_LEN;
    if (!GetProperty(
            pEle,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash
            ) || SHA1_HASH_LEN != cbHash)
        return FALSE;

    assert(STORE_TYPE_CACHE == pOtherStore->dwStoreType);

    pOtherEle = NULL;
    // Enable fForceEnumArchived
    while (pOtherEle = FindElementInCacheStore(pOtherStore, dwContextType,
            &FindAnyInfo, pOtherEle, TRUE)) {
        BYTE rgbOtherHash[SHA1_HASH_LEN];
        DWORD cbOtherHash;

        cbOtherHash = SHA1_HASH_LEN;
        if (!GetProperty(
                pOtherEle,
                CERT_SHA1_HASH_PROP_ID,
                rgbOtherHash,
                &cbOtherHash
                ) || SHA1_HASH_LEN != cbOtherHash)
            return FALSE;
        if (0 == memcmp(rgbOtherHash, rgbHash, SHA1_HASH_LEN)) {
            *ppOtherEle = pOtherEle;
            return TRUE;
        }
    }

    return TRUE;
}

STATIC void AppendElementToDeleteList(
    IN PCONTEXT_ELEMENT pEle,
    IN OUT DWORD *pcDeleteList,
    IN OUT PCONTEXT_ELEMENT **pppDeleteList
    )
{
    DWORD cDeleteList = *pcDeleteList;
    PCONTEXT_ELEMENT *ppDeleteList = *pppDeleteList;

    if (ppDeleteList = (PCONTEXT_ELEMENT *) PkiRealloc(ppDeleteList,
            (cDeleteList + 1) * sizeof(PCONTEXT_ELEMENT))) {
        AddRefContextElement(pEle);
        ppDeleteList[cDeleteList] = pEle;
        *pcDeleteList = cDeleteList + 1;
        *pppDeleteList = ppDeleteList;
    }
}

//+-------------------------------------------------------------------------
//  Synchronize the original store with the new store.
//
//  Assumptions: Both are cache stores. The new store is temporary
//  and local to the caller. The new store's contexts can be deleted or
//  moved to the original store.
//
//  Setting ICERT_SYNC_STORE_INHIBIT_SYNC_PROPERTY_IN_FLAG in dwInFlags
//  inhibits the syncing of properties.
//
//  ICERT_SYNC_STORE_CHANGED_OUT_FLAG is returned and set in *pdwOutFlags
//  if any contexts were added or deleted from the original store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertSyncStoreEx(
    IN OUT HCERTSTORE hOriginalStore,
    IN OUT HCERTSTORE hNewStore,
    IN DWORD dwInFlags,
    OUT OPTIONAL DWORD *pdwOutFlags,
    IN OUT OPTIONAL void *pvReserved
    )
{
    PCERT_STORE pOrigStore = (PCERT_STORE) hOriginalStore;
    PCERT_STORE pNewStore = (PCERT_STORE) hNewStore;
    DWORD dwOutFlags = 0;

    DWORD cDeleteList = 0;
    PCONTEXT_ELEMENT *ppDeleteList = NULL;
    DWORD i;

    assert(STORE_TYPE_CACHE == pOrigStore->dwStoreType &&
        STORE_TYPE_CACHE == pNewStore->dwStoreType);

    if (STORE_TYPE_CACHE != pOrigStore->dwStoreType ||
            STORE_TYPE_CACHE != pNewStore->dwStoreType) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    if (pOrigStore->dwFlags & CERT_STORE_MANIFOLD_FLAG)
        ArchiveManifoldCertificatesInStore(pNewStore);

    // Loop through the original store's elements. If the context exists
    // in the new store, copy the new store's properties and delete from
    // the new store. Otherwise, put the original store's context on a
    // deferred delete list.
    for (i = 0; i < CONTEXT_COUNT; i++) {
        PCONTEXT_ELEMENT pOrigEle = NULL;
        // Enable fForceEnumArchived
        while (pOrigEle = FindElementInCacheStore(pOrigStore, i, &FindAnyInfo,
                pOrigEle, TRUE)) {
            PCONTEXT_ELEMENT pNewEle;
            if (FindElementInOtherStore(pNewStore, i, pOrigEle, &pNewEle)) {
                if (pNewEle) {
                    if (0 == (dwInFlags &
                            ICERT_SYNC_STORE_INHIBIT_SYNC_PROPERTY_IN_FLAG))
                        CopyProperties(
                            pNewEle,
                            pOrigEle,
                            COPY_PROPERTY_INHIBIT_PROV_SET_FLAG |
                                COPY_PROPERTY_SYNC_FLAG
                            );
                    DeleteContextElement(pNewEle);
                } else {
                    dwOutFlags |= ICERT_SYNC_STORE_CHANGED_OUT_FLAG;
                    AppendElementToDeleteList(pOrigEle, &cDeleteList,
                        &ppDeleteList);
                }
            }
            //
            // else
            //  Find failed due to OutOfMemory
        }
    }

    LockStore(pOrigStore);

    // Move any remaining contexts in the new store to the original store.
    // Note, append at the end of list and not at the beginning. Another
    // thread might have been enumerating the store. Its better to find
    // 2 copies of a renewed context instead of none.
    for (i = 0; i < CONTEXT_COUNT; i++) {
        PCONTEXT_ELEMENT pNewEle;

        if (pNewEle = pNewStore->rgpContextListHead[i]) {
            PCONTEXT_ELEMENT pOrigEle;

            dwOutFlags |= ICERT_SYNC_STORE_CHANGED_OUT_FLAG;

            if (pOrigEle = pOrigStore->rgpContextListHead[i]) {
                // Append at end of original store
                while (pOrigEle->pNext)
                    pOrigEle = pOrigEle->pNext;
                pOrigEle->pNext = pNewEle;
                pNewEle->pPrev = pOrigEle;
            } else {
                // New entries in original store
                pOrigStore->rgpContextListHead[i] = pNewEle;
                pNewEle->pPrev = NULL;
            }

            for ( ; pNewEle; pNewEle = pNewEle->pNext) {
                // Update the elements obtained from the new store to
                // point to the original store
                pNewEle->pStore = pOrigStore;
                pNewEle->pProvStore = pOrigStore;
                SetStoreHandle(pNewEle);
            }

            // No contexts remain in new store
            pNewStore->rgpContextListHead[i] = NULL;
        }
    }

    UnlockStore(pOrigStore);

    // Delete any contexts in the deferred delete list from the original store
    while (cDeleteList--)
        DeleteContextElement(ppDeleteList[cDeleteList]);
    PkiFree(ppDeleteList);

    if (pdwOutFlags)
        *pdwOutFlags = dwOutFlags;
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Synchronize the original store with the new store.
//
//  Assumptions: Both are cache stores. The new store is temporary
//  and local to the caller. The new store's contexts can be deleted or
//  moved to the original store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertSyncStore(
    IN OUT HCERTSTORE hOriginalStore,
    IN OUT HCERTSTORE hNewStore
    )
{
    return I_CertSyncStoreEx(
        hOriginalStore,
        hNewStore,
        0,                      // dwInFlags
        NULL,                   // pdwOutFlags
        NULL                    // pvReserved
        );
}

//+-------------------------------------------------------------------------
//  Update the original store with contexts from the new store.
//
//  Assumptions: Both are cache stores. The new store is temporary
//  and local to the caller. The new store's contexts can be deleted or
//  moved to the original store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertUpdateStore(
    IN OUT HCERTSTORE hOriginalStore,
    IN OUT HCERTSTORE hNewStore,
    IN DWORD dwReserved,
    IN OUT void *pvReserved
    )
{
    PCERT_STORE pOrigStore = (PCERT_STORE) hOriginalStore;
    PCERT_STORE pNewStore = (PCERT_STORE) hNewStore;
    DWORD i;

    assert(STORE_TYPE_CACHE == pOrigStore->dwStoreType &&
        STORE_TYPE_CACHE == pNewStore->dwStoreType);

    if (STORE_TYPE_CACHE != pOrigStore->dwStoreType ||
            STORE_TYPE_CACHE != pNewStore->dwStoreType) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    LockStore(pOrigStore);

    // Move contexts in the new store to the original store.
    for (i = 0; i < CONTEXT_COUNT; i++) {
        PCONTEXT_ELEMENT pNewEle;

        if (pNewEle = pNewStore->rgpContextListHead[i]) {
            PCONTEXT_ELEMENT pNewTailEle = NULL;
            PCONTEXT_ELEMENT pOrigEle;
            PCONTEXT_ELEMENT pEle;

            for (pEle = pNewEle ; pEle; pEle = pEle->pNext) {
                // Update the elements obtained from the new store to
                // point to the original store
                pEle->pStore = pOrigStore;
                pEle->pProvStore = pOrigStore;
                SetStoreHandle(pEle);

                // Remember the last element in the linked list
                pNewTailEle = pEle;
            }

            assert(pNewTailEle);
            assert(NULL == pNewEle->pPrev);
            assert(NULL == pNewTailEle->pNext);

            // Insert new store's linked list of contexts at the
            // beginning of the original store
            if (pOrigEle = pOrigStore->rgpContextListHead[i]) {
                assert(NULL == pOrigEle->pPrev);
                pOrigEle->pPrev = pNewTailEle;
                pNewTailEle->pNext = pOrigEle;
            }
            pOrigStore->rgpContextListHead[i] = pNewEle;

            // No contexts remain in new store
            pNewStore->rgpContextListHead[i] = NULL;
        }
    }

    UnlockStore(pOrigStore);

    return TRUE;
}



//+=========================================================================
//  SortedCTL APIs.
//==========================================================================

static const BYTE rgbSeqTag[] = {ASN1UTIL_TAG_SEQ, 0};
static const BYTE rgbSetTag[] = {ASN1UTIL_TAG_SET, 0};
static const BYTE rgbOIDTag[] = {ASN1UTIL_TAG_OID, 0};
static const BYTE rgbIntegerTag[] = {ASN1UTIL_TAG_INTEGER, 0};
static const BYTE rgbBooleanTag[] = {ASN1UTIL_TAG_BOOLEAN, 0};
static const BYTE rgbOctetStringTag[] = {ASN1UTIL_TAG_OCTETSTRING, 0};
static const BYTE rgbConstructedContext0Tag[] =
    {ASN1UTIL_TAG_CONSTRUCTED_CONTEXT_0, 0};
static const BYTE rgbChoiceOfTimeTag[] =
    {ASN1UTIL_TAG_UTC_TIME, ASN1UTIL_TAG_GENERALIZED_TIME, 0};

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractCtlPara[] = {
    // 0 - CertificateTrustList ::= SEQUENCE {
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - version                 CTLVersion DEFAULT v1,
    ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbIntegerTag,
    //   2 - subjectUsage            SubjectUsage,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //   3 - listIdentifier          ListIdentifier OPTIONAL,
    ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbOctetStringTag,
    //   4 - sequenceNumber          HUGEINTEGER OPTIONAL,
    ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbIntegerTag,
    //   5 - ctlThisUpdate           ChoiceOfTime,
    ASN1UTIL_STEP_OVER_VALUE_OP, rgbChoiceOfTimeTag,
    //   6 - ctlNextUpdate           ChoiceOfTime OPTIONAL,
    ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbChoiceOfTimeTag,
    //   7 - subjectAlgorithm        AlgorithmIdentifier,
    ASN1UTIL_RETURN_VALUE_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //   8 - trustedSubjects         TrustedSubjects OPTIONAL,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbSeqTag,
    //   9 - ctlExtensions           [0] EXPLICIT Extensions OPTIONAL
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbConstructedContext0Tag,
};
#define CTL_SEQ_VALUE_INDEX         0
#define CTL_SUBJECT_ALG_VALUE_INDEX 7
#define CTL_SUBJECTS_VALUE_INDEX    8
#define CTL_EXTENSIONS_VALUE_INDEX  9
#define CTL_VALUE_COUNT             \
    (sizeof(rgExtractCtlPara) / sizeof(rgExtractCtlPara[0]))

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractExtPara[] = {
    // 0 - Extension ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - extnId              OBJECT IDENTIFIER,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOIDTag,
    //   2 - critical            BOOLEAN DEFAULT FALSE,
    ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbBooleanTag,
    //   3 - extnValue           OCTETSTRING
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOctetStringTag,
};
#define EXT_OID_VALUE_INDEX         1
#define EXT_OCTETS_VALUE_INDEX      3
#define EXT_VALUE_COUNT             \
    (sizeof(rgExtractExtPara) / sizeof(rgExtractExtPara[0]))

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractTrustedSubjectPara[] = {
    // 0 - TrustedSubject ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - subjectIdentifier       SubjectIdentifier,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOctetStringTag,
    //   2 - subjectAttributes	    Attributes OPTIONAL
    ASN1UTIL_RETURN_VALUE_BLOB_FLAG |
        ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbSetTag,
};
#define TRUSTED_SUBJECT_IDENTIFIER_VALUE_INDEX      1
#define TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX      2
#define TRUSTED_SUBJECT_VALUE_COUNT                 \
    (sizeof(rgExtractTrustedSubjectPara) / \
        sizeof(rgExtractTrustedSubjectPara[0]))

// same as above, however, return content blob for subjectAttributes instead
// of its value blob
static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractTrustedSubjectPara2[] = {
    // 0 - TrustedSubject ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - subjectIdentifier       SubjectIdentifier,
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOctetStringTag,
    //   2 - subjectAttributes	    Attributes OPTIONAL
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_OPTIONAL_STEP_OVER_VALUE_OP, rgbSetTag,
};

static const ASN1UTIL_EXTRACT_VALUE_PARA rgExtractAttributePara[] = {
    // 0 - Attribute ::= SEQUENCE {
    ASN1UTIL_STEP_INTO_VALUE_OP, rgbSeqTag,
    //   1 - type  
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbOIDTag,
    //   2 - values     AttributeSetValue
    ASN1UTIL_RETURN_CONTENT_BLOB_FLAG |
        ASN1UTIL_STEP_OVER_VALUE_OP, rgbSetTag,
};
#define ATTRIBUTE_OID_VALUE_INDEX                   1
#define ATTRIBUTE_VALUES_VALUE_INDEX                2
#define ATTRIBUTE_VALUE_COUNT                       \
    (sizeof(rgExtractAttributePara) / sizeof(rgExtractAttributePara[0]))



static const DWORD rgdwPrime[] = {
            // Bits - cHashBucket
        1,  //   0  - 0x00001 (1)
        2,  //   1  - 0x00002 (2)
        3,  //   2  - 0x00004 (4)
        7,  //   3  - 0x00008 (8)
       13,  //   4  - 0x00010 (16)
       31,  //   5  - 0x00020 (32)
       61,  //   6  - 0x00040 (64)
      127,  //   7  - 0x00080 (128)
      251,  //   8  - 0x00100 (256)
      509,  //   9  - 0x00200 (512)
     1021,  //  10  - 0x00400 (1024)
     2039,  //  11  - 0x00800 (2048)
     4093,  //  12  - 0x01000 (4096)
     8191,  //  13  - 0x02000 (8192)
    16381,  //  14  - 0x04000 (16384)
    32749,  //  15  - 0x08000 (32768)
    65521,  //  16  - 0x10000 (65536)
};

#define MIN_HASH_BUCKET_BITS    6
#define MIN_HASH_BUCKET_COUNT   (1 << MIN_HASH_BUCKET_BITS)
#define MAX_HASH_BUCKET_BITS    16
#define MAX_HASH_BUCKET_COUNT   (1 << MAX_HASH_BUCKET_BITS)

#define DEFAULT_BYTES_PER_CTL_ENTRY     100
#define DEFAULT_CTL_ENTRY_COUNT         256

STATIC DWORD GetHashBucketCount(
    IN DWORD cCtlEntry
    )
{
    DWORD cBits;

    if (MAX_HASH_BUCKET_COUNT <= cCtlEntry)
        cBits = MAX_HASH_BUCKET_BITS;
    else {
        DWORD cHashBucket = MIN_HASH_BUCKET_COUNT;

        cBits = MIN_HASH_BUCKET_BITS;
        while (cCtlEntry > cHashBucket) {
            cHashBucket = cHashBucket << 1;
            cBits++;
        }
        assert(cBits <= MAX_HASH_BUCKET_BITS);
    }
    return rgdwPrime[cBits];
}

STATIC DWORD GetHashBucketIndex(
    IN DWORD cHashBucket,
    IN BOOL fHashedIdentifier,
    IN const CRYPT_DATA_BLOB *pIdentifier
    )
{
    DWORD dwIndex;
    const BYTE *pb = pIdentifier->pbData;
    DWORD cb = pIdentifier->cbData;


    if (fHashedIdentifier) {
        if (4 <= cb)
            memcpy(&dwIndex, pb, 4);
        else
            dwIndex = 0;
    } else {
        dwIndex = 0;
        while (cb--) {
            if (dwIndex & 0x80000000)
                dwIndex = (dwIndex << 1) | 1;
            else
                dwIndex = dwIndex << 1;
            dwIndex += *pb++;
        }
    }
    if (0 == cHashBucket)
        return 0;
    else
        return dwIndex % cHashBucket;
}

// #define szOID_CTL                       "1.3.6.1.4.1.311.10.1"
static const BYTE rgbOIDCtl[] =
    {0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x0A, 0x01};
static const CRYPT_DER_BLOB EncodedOIDCtl = {
    sizeof(rgbOIDCtl), (BYTE *) rgbOIDCtl
};

// #define szOID_SORTED_CTL                "1.3.6.1.4.1.311.10.1.1"
static const BYTE rgbOIDSortedCtlExt[] =
    {0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x0A, 0x01, 0x01};
static const CRYPT_DER_BLOB EncodedOIDSortedCtlExt = {
    sizeof(rgbOIDSortedCtlExt), (BYTE *) rgbOIDSortedCtlExt
};


// The encoded OID only includes the content octets. Excludes the tag and
// length octets.
STATIC BOOL CompareEncodedOID(
    IN const CRYPT_DER_BLOB *pEncodedOID1,
    IN const CRYPT_DER_BLOB *pEncodedOID2
    )
{
    if (pEncodedOID1->cbData == pEncodedOID2->cbData &&
            0 == memcmp(pEncodedOID1->pbData, pEncodedOID2->pbData,
                    pEncodedOID1->cbData))
        return TRUE;
    else
        return FALSE;
}


STATIC BOOL ExtractSortedCtlExtValue(
    IN const CRYPT_DER_BLOB rgCtlValueBlob[CTL_VALUE_COUNT],
    OUT const BYTE **ppbSortedCtlExtValue,
    OUT DWORD *pcbSortedCtlExtValue,
    OUT const BYTE **ppbRemainExt,
    OUT DWORD *pcbRemainExt
    )
{
    BOOL fResult;
    const BYTE *pbEncodedExtensions;
    DWORD cbEncodedExtensions;
    const BYTE *pbEncodedSortedCtlExt;
    DWORD cbEncodedSortedCtlExt;
    DWORD cValue;
    CRYPT_DER_BLOB rgValueBlob[EXT_VALUE_COUNT];
    LONG lSkipped;

    // Following points to the outer Extensions sequence
    pbEncodedExtensions = rgCtlValueBlob[CTL_EXTENSIONS_VALUE_INDEX].pbData;
    cbEncodedExtensions = rgCtlValueBlob[CTL_EXTENSIONS_VALUE_INDEX].cbData;
    if (0 == cbEncodedExtensions)
        goto NoExtensions;

    // Step into the Extension sequence and get pointer to the first extension.
    // The returned cbEncodedSortedCtlExt includes all of the
    // extensions in the sequence.
    if (0 >= (lSkipped = Asn1UtilExtractContent(
            pbEncodedExtensions,
            cbEncodedExtensions,
            &cbEncodedSortedCtlExt,
            &pbEncodedSortedCtlExt
            )) || CMSG_INDEFINITE_LENGTH == cbEncodedSortedCtlExt ||
                (DWORD) lSkipped + cbEncodedSortedCtlExt !=
                    cbEncodedExtensions)
        goto InvalidExtensions;

    // Decode the first extension
    cValue = EXT_VALUE_COUNT;
    if (0 >= (lSkipped = Asn1UtilExtractValues(
            pbEncodedSortedCtlExt,
            cbEncodedSortedCtlExt,
            ASN1UTIL_DEFINITE_LENGTH_FLAG,
            &cValue,
            rgExtractExtPara,
            rgValueBlob
            )))
        goto ExtractValuesError;

    // Check that the first extension is the SortedCtl extension
    if (!CompareEncodedOID(
            &rgValueBlob[EXT_OID_VALUE_INDEX],
            &EncodedOIDSortedCtlExt
            ))
        goto NoSortedCtlExtension;

    *ppbSortedCtlExtValue = rgValueBlob[EXT_OCTETS_VALUE_INDEX].pbData;
    *pcbSortedCtlExtValue = rgValueBlob[EXT_OCTETS_VALUE_INDEX].cbData;

    *ppbRemainExt = pbEncodedSortedCtlExt + lSkipped;
    *pcbRemainExt = cbEncodedSortedCtlExt - lSkipped;
    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    *ppbSortedCtlExtValue = NULL;
    *pcbSortedCtlExtValue = 0;
    *ppbRemainExt = NULL;
    *pcbRemainExt = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NoExtensions, ERROR_INVALID_DATA)
SET_ERROR(InvalidExtensions, ERROR_INVALID_DATA)
TRACE_ERROR(ExtractValuesError)
SET_ERROR(NoSortedCtlExtension, ERROR_INVALID_DATA)
}


BOOL
WINAPI
SortedCtlInfoEncodeEx(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN PCTL_INFO pOrigCtlInfo,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
    OUT OPTIONAL void *pvEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    PCTL_INFO pSortedCtlInfo = NULL;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    DWORD cCtlEntry;
    PCTL_ENTRY pSortedCtlEntry = NULL;
    DWORD cHashBucket = 0;
    PHASH_BUCKET_ENTRY *ppHashBucketHead = NULL;
    PHASH_BUCKET_ENTRY pHashBucketEntry = NULL;

    DWORD cSortedExtension;
    PCERT_EXTENSION pSortedExtension = NULL;
    BYTE *pbSortedCtlExtValue = NULL;
    DWORD cbSortedCtlExtValue = 0;


    if (0 == (dwFlags & CRYPT_ENCODE_ALLOC_FLAG))
        goto InvalidArg;

    // Make a copy of the CtlInfo. We're going to re-order the CTL entries
    // and insert a szOID_SORTED_CTL extension.
    if (NULL == (pSortedCtlInfo = (PCTL_INFO) PkiNonzeroAlloc(
            sizeof(CTL_INFO))))
        goto OutOfMemory;
    memcpy(pSortedCtlInfo, pOrigCtlInfo, sizeof(CTL_INFO));
    cCtlEntry = pSortedCtlInfo->cCTLEntry;
    if (0 < cCtlEntry) {
        DWORD i;
        DWORD j;
        PCTL_ENTRY pCtlEntry;
        DWORD cOrigExtension;
        PCERT_EXTENSION pOrigExtension;

        BOOL fHashedIdentifier =
            dwFlags & CRYPT_SORTED_CTL_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG;
        DWORD dwSortedCtlExtFlags = fHashedIdentifier ?
            SORTED_CTL_EXT_HASHED_SUBJECT_IDENTIFIER_FLAG : 0;
        DWORD dwMaxCollision = 0;

        cHashBucket = GetHashBucketCount(cCtlEntry);
        if (NULL == (ppHashBucketHead = (PHASH_BUCKET_ENTRY *) PkiZeroAlloc(
                sizeof(PHASH_BUCKET_ENTRY) * cHashBucket)))
            goto OutOfMemory;

        if (NULL == (pHashBucketEntry = (PHASH_BUCKET_ENTRY) PkiNonzeroAlloc(
                sizeof(HASH_BUCKET_ENTRY) * cCtlEntry)))
            goto OutOfMemory;

        // Iterate through the CTL entries and add to the appropriate
        // hash bucket.
        pCtlEntry = pSortedCtlInfo->rgCTLEntry;
        for (i = 0; i < cCtlEntry; i++) {
            DWORD HashBucketIndex;

            HashBucketIndex = GetHashBucketIndex(
                cHashBucket,
                fHashedIdentifier,
                &pCtlEntry[i].SubjectIdentifier
                );
            pHashBucketEntry[i].dwEntryIndex = i;
            pHashBucketEntry[i].pNext = ppHashBucketHead[HashBucketIndex];
            ppHashBucketHead[HashBucketIndex] = &pHashBucketEntry[i];
        }

        // Sort the entries according to the HashBucket order
        if (NULL == (pSortedCtlEntry = (PCTL_ENTRY) PkiNonzeroAlloc(
                sizeof(CTL_ENTRY) * cCtlEntry)))
            goto OutOfMemory;

        j = 0;
        for (i = 0; i < cHashBucket; i++) {
            DWORD dwCollision = 0;
            PHASH_BUCKET_ENTRY p;

            for (p = ppHashBucketHead[i]; p; p = p->pNext) {
                pSortedCtlEntry[j++] = pCtlEntry[p->dwEntryIndex];
                dwCollision++;
            }
            if (dwCollision > dwMaxCollision)
                dwMaxCollision = dwCollision;
        }
#if DBG
        DbgPrintf(DBG_SS_CRYPT32,
            "SortedCtlInfoEncodeEx:: cHashBucket: %d MaxCollision: %d Flags:: 0x%x\n",
            cHashBucket, dwMaxCollision, dwSortedCtlExtFlags);
#endif
        assert(j == cCtlEntry);
        pSortedCtlInfo->rgCTLEntry = pSortedCtlEntry;

        // Insert a SortedCtl extension
        cOrigExtension = pSortedCtlInfo->cExtension;
        pOrigExtension = pSortedCtlInfo->rgExtension;
        // Check if the first extension is the SortedCtl extension
        if (cOrigExtension && 0 == strcmp(pOrigExtension[0].pszObjId,
                szOID_SORTED_CTL)) {
            cOrigExtension--;
            pOrigExtension++;
        }

        cSortedExtension = cOrigExtension + 1;
        if (NULL == (pSortedExtension = (PCERT_EXTENSION) PkiNonzeroAlloc(
                sizeof(CERT_EXTENSION) * cSortedExtension)))
            goto OutOfMemory;

        if (cOrigExtension)
            memcpy(&pSortedExtension[1], pOrigExtension,
                sizeof(CERT_EXTENSION) * cOrigExtension);

        cbSortedCtlExtValue = SORTED_CTL_EXT_HASH_BUCKET_OFFSET +
            sizeof(DWORD) * (cHashBucket + 1);
        if (NULL == (pbSortedCtlExtValue = (BYTE *) PkiNonzeroAlloc(
                cbSortedCtlExtValue)))
            goto OutOfMemory;

        memcpy(pbSortedCtlExtValue + SORTED_CTL_EXT_FLAGS_OFFSET,
            &dwSortedCtlExtFlags, sizeof(DWORD));
        memcpy(pbSortedCtlExtValue + SORTED_CTL_EXT_COUNT_OFFSET,
            &cHashBucket, sizeof(DWORD));
        memcpy(pbSortedCtlExtValue + SORTED_CTL_EXT_MAX_COLLISION_OFFSET,
            &dwMaxCollision, sizeof(DWORD));

        pSortedExtension[0].pszObjId = szOID_SORTED_CTL;
        pSortedExtension[0].fCritical = FALSE;
        pSortedExtension[0].Value.pbData = pbSortedCtlExtValue;
        pSortedExtension[0].Value.cbData = cbSortedCtlExtValue;

        pSortedCtlInfo->cExtension = cSortedExtension;
        pSortedCtlInfo->rgExtension = pSortedExtension;
    }

    if (!CryptEncodeObjectEx(
            dwCertEncodingType,
            PKCS_CTL,
            pSortedCtlInfo,
            dwFlags,
            pEncodePara,
            (void *) &pbEncoded,
            &cbEncoded
            ))
        goto CtlInfoEncodeError;

    if (0 < cCtlEntry) {
        // Update the SortedCtl extension's array of hash bucket offsets

        // First, extract values for the encoded sequence of subjects
        // and extensions.

        DWORD i;
        DWORD cCtlValue;
        CRYPT_DER_BLOB rgCtlValueBlob[CTL_VALUE_COUNT];
        const BYTE *pbEncodedSubject;
        DWORD cbEncodedSubject;
        const BYTE *pbEncodedSortedCtlExtValue;
        DWORD cbEncodedSortedCtlExtValue;
        const BYTE *pbRemainExt;
        DWORD cbRemainExt;
        BYTE *pbEncodedHashBucketOffset;
        DWORD dwEncodedHashBucketOffset;

        cCtlValue = CTL_VALUE_COUNT;
        if (0 >= Asn1UtilExtractValues(
                pbEncoded,
                cbEncoded,
                ASN1UTIL_DEFINITE_LENGTH_FLAG,
                &cCtlValue,
                rgExtractCtlPara,
                rgCtlValueBlob
                ))
            goto ExtractCtlValuesError;

        pbEncodedSubject = rgCtlValueBlob[CTL_SUBJECTS_VALUE_INDEX].pbData;
        cbEncodedSubject = rgCtlValueBlob[CTL_SUBJECTS_VALUE_INDEX].cbData;
        assert(pbEncodedSubject > pbEncoded);
        assert(cbEncodedSubject);

        assert(rgCtlValueBlob[CTL_EXTENSIONS_VALUE_INDEX].pbData);
        if (!ExtractSortedCtlExtValue(
                rgCtlValueBlob,
                &pbEncodedSortedCtlExtValue,
                &cbEncodedSortedCtlExtValue,
                &pbRemainExt,
                &cbRemainExt
                ))
            goto ExtractSortedCtlExtValueError;
        assert(cbEncodedSortedCtlExtValue == cbSortedCtlExtValue);
        pbEncodedHashBucketOffset = (BYTE *) pbEncodedSortedCtlExtValue +
            SORTED_CTL_EXT_HASH_BUCKET_OFFSET;

        for (i = 0; i < cHashBucket; i++) {
            PHASH_BUCKET_ENTRY p;

            dwEncodedHashBucketOffset = (DWORD)(pbEncodedSubject - pbEncoded);
            memcpy(pbEncodedHashBucketOffset, &dwEncodedHashBucketOffset,
                sizeof(DWORD));
            pbEncodedHashBucketOffset += sizeof(DWORD);

            // Advance through the encoded subjects for the current
            // hash bucket index
            for (p = ppHashBucketHead[i]; p; p = p->pNext) {
                LONG lTagLength;
                DWORD cbContent;
                const BYTE *pbContent;
                DWORD cbSubject;

                lTagLength = Asn1UtilExtractContent(
                    pbEncodedSubject,
                    cbEncodedSubject,
                    &cbContent,
                    &pbContent
                    );
                assert(lTagLength > 0 && CMSG_INDEFINITE_LENGTH != cbContent);
                cbSubject = cbContent + lTagLength;
                assert(cbEncodedSubject >= cbSubject);
                pbEncodedSubject += cbSubject;
                cbEncodedSubject -= cbSubject;
            }
        }

        assert(0 == cbEncodedSubject);
        assert(pbEncodedSubject ==
            rgCtlValueBlob[CTL_SUBJECTS_VALUE_INDEX].pbData +
            rgCtlValueBlob[CTL_SUBJECTS_VALUE_INDEX].cbData);
        assert(pbEncodedHashBucketOffset + sizeof(DWORD) ==
            pbEncodedSortedCtlExtValue + cbEncodedSortedCtlExtValue);
        dwEncodedHashBucketOffset = (DWORD)(pbEncodedSubject - pbEncoded);
        memcpy(pbEncodedHashBucketOffset, &dwEncodedHashBucketOffset,
            sizeof(DWORD));
    }

    *((BYTE **) pvEncoded) = pbEncoded;
    *pcbEncoded = cbEncoded;
    fResult = TRUE;

CommonReturn:
    PkiFree(pSortedCtlInfo);
    PkiFree(pSortedCtlEntry);
    PkiFree(ppHashBucketHead);
    PkiFree(pHashBucketEntry);
    PkiFree(pSortedExtension);
    PkiFree(pbSortedCtlExtValue);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        if (pbEncoded) {
            PFN_CRYPT_FREE pfnFree = PkiGetEncodeFreeFunction(pEncodePara);
            pfnFree(pbEncoded);
        }
        *((BYTE **) pvEncoded) = NULL;
    }
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CtlInfoEncodeError)
TRACE_ERROR(ExtractCtlValuesError)
TRACE_ERROR(ExtractSortedCtlExtValueError)
}

STATIC BOOL CreateSortedCtlHashBuckets(
    IN OUT PSORTED_CTL_FIND_INFO pSortedCtlFindInfo
    )
{
    BOOL fResult;
    DWORD cHashBucket;
    DWORD *pdwHashBucketHead = NULL;
    PHASH_BUCKET_ENTRY pHashBucketEntry = NULL;
    DWORD cAllocEntry = 0;
    DWORD cEntry = 0;

    const BYTE *pbEncoded;
    DWORD cbEncoded;

#if DBG
    DWORD dwMaxCollision = 0;
#endif

    DWORD dwExceptionCode;

  // Handle MappedFile Exceptions
  __try {

    pbEncoded = pSortedCtlFindInfo->pbEncodedSubjects;
    cbEncoded = pSortedCtlFindInfo->cbEncodedSubjects;

    cHashBucket = GetHashBucketCount(cbEncoded / DEFAULT_BYTES_PER_CTL_ENTRY);
    if (NULL == (pdwHashBucketHead = (DWORD *) PkiZeroAlloc(
            sizeof(DWORD) * cHashBucket)))
        goto OutOfMemory;


    // Loop through the encoded trusted subjects. For each subject, create
    // hash bucket entry, calculate hash bucket index and insert.
    while (cbEncoded) {
        DWORD cValue;
        LONG lAllValues;
        DWORD HashBucketIndex;
        CRYPT_DER_BLOB rgValueBlob[TRUSTED_SUBJECT_VALUE_COUNT];

        cValue = TRUSTED_SUBJECT_VALUE_COUNT;
        if (0 >= (lAllValues = Asn1UtilExtractValues(
                pbEncoded,
                cbEncoded,
                ASN1UTIL_DEFINITE_LENGTH_FLAG,
                &cValue,
                rgExtractTrustedSubjectPara,
                rgValueBlob
                )))
            goto ExtractValuesError;

        if (cEntry == cAllocEntry) {
            PHASH_BUCKET_ENTRY pNewHashBucketEntry;

            cAllocEntry += DEFAULT_CTL_ENTRY_COUNT;
            if (NULL == (pNewHashBucketEntry = (PHASH_BUCKET_ENTRY) PkiRealloc(
                    pHashBucketEntry, sizeof(HASH_BUCKET_ENTRY) * cAllocEntry)))
                goto OutOfMemory;
            pHashBucketEntry = pNewHashBucketEntry;
        }

        if (0 == cEntry)
            // Entry[0] is used to indicate no entries for the indexed
            // HashBucket
            cEntry++;

        HashBucketIndex = GetHashBucketIndex(
            cHashBucket,
            FALSE,                  // fHashedIdentifier,
            &rgValueBlob[TRUSTED_SUBJECT_IDENTIFIER_VALUE_INDEX]
            );

#if DBG
        {
            DWORD dwEntryIndex = pdwHashBucketHead[HashBucketIndex];
            DWORD dwCollision = 1;
            while (dwEntryIndex) {
                dwCollision++;
                dwEntryIndex = pHashBucketEntry[dwEntryIndex].iNext;
            }
            if (dwCollision > dwMaxCollision)
                dwMaxCollision = dwCollision;
        }
#endif

        pHashBucketEntry[cEntry].iNext = pdwHashBucketHead[HashBucketIndex];
        pHashBucketEntry[cEntry].pbEntry = pbEncoded;
        pdwHashBucketHead[HashBucketIndex] = cEntry;
        cEntry++;

        cbEncoded -= lAllValues;
        pbEncoded += lAllValues;
    }

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

#if DBG
    DbgPrintf(DBG_SS_CRYPT32,
        "CreateSortedCtlHashBuckets:: cEntry: %d cHashBucket: %d MaxCollision: %d\n",
        cEntry, cHashBucket, dwMaxCollision);
#endif

    pSortedCtlFindInfo->cHashBucket = cHashBucket;
    pSortedCtlFindInfo->pdwHashBucketHead = pdwHashBucketHead;
    pSortedCtlFindInfo->pHashBucketEntry = pHashBucketEntry;

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    PkiFree(pdwHashBucketHead);
    PkiFree(pHashBucketEntry);
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ExtractValuesError)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}


STATIC BOOL FastDecodeCtlSubjects(
    IN const BYTE *pbEncodedSubjects,
    IN DWORD cbEncodedSubjects,
    OUT DWORD *pcCTLEntry,
    OUT PCTL_ENTRY *ppCTLEntry
    )
{
    BOOL fResult;

    PCTL_ENTRY pAllocEntry = NULL;
    DWORD cAllocEntry;
    DWORD cbAllocEntry;

    DWORD cEntry = 0;
    PCTL_ENTRY pEntry;
    DWORD cbEntryEncoded;
    const BYTE *pbEntryEncoded;

    DWORD cAttr = 0;
    PCRYPT_ATTRIBUTE pAttr;

    DWORD cAttrValue = 0;
    PCRYPT_ATTR_BLOB pAttrValue;

    DWORD cValue;
    LONG lAllValues;

    DWORD dwExceptionCode;

  // Handle MappedFile Exceptions
  __try {

    // First: Loop through the encoded trusted subjects. Get total count of
    // Entries, Attributes and Values.
    cbEntryEncoded = cbEncodedSubjects;
    pbEntryEncoded = pbEncodedSubjects;
    while (cbEntryEncoded) {
        CRYPT_DER_BLOB rgEntryValueBlob[TRUSTED_SUBJECT_VALUE_COUNT];
        DWORD cbAttrEncoded;
        const BYTE *pbAttrEncoded;

        cValue = TRUSTED_SUBJECT_VALUE_COUNT;
        if (0 >= (lAllValues = Asn1UtilExtractValues(
                pbEntryEncoded,
                cbEntryEncoded,
                ASN1UTIL_DEFINITE_LENGTH_FLAG,
                &cValue,
                rgExtractTrustedSubjectPara2,
                rgEntryValueBlob
                )))
            goto ExtractEntryError;
        cEntry++;
        cbEntryEncoded -= lAllValues;
        pbEntryEncoded += lAllValues;

        cbAttrEncoded =
            rgEntryValueBlob[TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX].cbData;
        pbAttrEncoded =
            rgEntryValueBlob[TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX].pbData;
        while (cbAttrEncoded) {
            CRYPT_DER_BLOB rgAttrValueBlob[ATTRIBUTE_VALUE_COUNT];
            DWORD cbAttrValueEncoded;
            const BYTE *pbAttrValueEncoded;

            cValue = ATTRIBUTE_VALUE_COUNT;
            if (0 >= (lAllValues = Asn1UtilExtractValues(
                    pbAttrEncoded,
                    cbAttrEncoded,
                    ASN1UTIL_DEFINITE_LENGTH_FLAG,
                    &cValue,
                    rgExtractAttributePara,
                    rgAttrValueBlob
                    )))
                goto ExtractAttrError;
            cAttr++;
            cbAttrEncoded -= lAllValues;
            pbAttrEncoded += lAllValues;

            cbAttrValueEncoded =
                rgAttrValueBlob[ATTRIBUTE_VALUES_VALUE_INDEX].cbData;
            pbAttrValueEncoded =
                rgAttrValueBlob[ATTRIBUTE_VALUES_VALUE_INDEX].pbData;
            while (cbAttrValueEncoded) {
                LONG lTagLength;
                DWORD cbAttrValue;
                const BYTE *pbContent;

                lTagLength = Asn1UtilExtractContent(
                    pbAttrValueEncoded,
                    cbAttrValueEncoded,
                    &cbAttrValue,
                    &pbContent
                    );
                if (0 >= lTagLength ||
                        CMSG_INDEFINITE_LENGTH == cbAttrValue)
                    goto ExtractValueError;
                cbAttrValue += (DWORD) lTagLength;
                if (cbAttrValue > cbAttrValueEncoded)
                    goto ExtractValueError;
                cAttrValue++;
                cbAttrValueEncoded -= cbAttrValue;
                pbAttrValueEncoded += cbAttrValue;
            }
        }
    }

    cAllocEntry = cEntry;
    if (0 == cEntry)
        goto SuccessReturn;

    cbAllocEntry = cEntry * sizeof(CTL_ENTRY) +
        cAttr * sizeof(CRYPT_ATTRIBUTE) +
        cAttrValue * sizeof(CRYPT_ATTR_BLOB);

    if (NULL == (pAllocEntry = (PCTL_ENTRY) PkiZeroAlloc(cbAllocEntry)))
        goto OutOfMemory;

    pEntry = pAllocEntry;
    pAttr = (PCRYPT_ATTRIBUTE) (pEntry + cEntry);
    pAttrValue = (PCRYPT_ATTR_BLOB) (pAttr + cAttr);

    // Second: Loop through the encoded trusted subjects. Update the
    // allocated Entries, Attributes and Values data structures
    cbEntryEncoded = cbEncodedSubjects;
    pbEntryEncoded = pbEncodedSubjects;
    while (cbEntryEncoded) {
        CRYPT_DER_BLOB rgEntryValueBlob[TRUSTED_SUBJECT_VALUE_COUNT];
        DWORD cbAttrEncoded;
        const BYTE *pbAttrEncoded;

        cValue = TRUSTED_SUBJECT_VALUE_COUNT;
        if (0 >= (lAllValues = Asn1UtilExtractValues(
                pbEntryEncoded,
                cbEntryEncoded,
                ASN1UTIL_DEFINITE_LENGTH_FLAG,
                &cValue,
                rgExtractTrustedSubjectPara2,
                rgEntryValueBlob
                )))
            goto ExtractEntryError;
        cbEntryEncoded -= lAllValues;
        pbEntryEncoded += lAllValues;

        assert(0 != cEntry);
        if (0 == cEntry--)
            goto InvalidCountError;
        pEntry->SubjectIdentifier =
            rgEntryValueBlob[TRUSTED_SUBJECT_IDENTIFIER_VALUE_INDEX];

        cbAttrEncoded =
            rgEntryValueBlob[TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX].cbData;
        pbAttrEncoded =
            rgEntryValueBlob[TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX].pbData;
        while (cbAttrEncoded) {
            CRYPT_DER_BLOB rgAttrValueBlob[ATTRIBUTE_VALUE_COUNT];
            DWORD cbAttrValueEncoded;
            const BYTE *pbAttrValueEncoded;

            ASN1encodedOID_t EncodedOid;
            BYTE *pbExtra;
            LONG lRemainExtra;

            cValue = ATTRIBUTE_VALUE_COUNT;
            if (0 >= (lAllValues = Asn1UtilExtractValues(
                    pbAttrEncoded,
                    cbAttrEncoded,
                    ASN1UTIL_DEFINITE_LENGTH_FLAG,
                    &cValue,
                    rgExtractAttributePara,
                    rgAttrValueBlob
                    )))
                goto ExtractAttrError;
            cbAttrEncoded -= lAllValues;
            pbAttrEncoded += lAllValues;

            assert(0 != cAttr);
            if (0 == cAttr--)
                goto InvalidCountError;

            if (0 == pEntry->cAttribute) {
                pEntry->cAttribute = 1;
                pEntry->rgAttribute = pAttr;
            } else
                pEntry->cAttribute++;

            EncodedOid.length = (ASN1uint16_t)
                rgAttrValueBlob[ATTRIBUTE_OID_VALUE_INDEX].cbData;
            EncodedOid.value =
                rgAttrValueBlob[ATTRIBUTE_OID_VALUE_INDEX].pbData;

            pbExtra = NULL;
            lRemainExtra = 0;
            I_CryptGetEncodedOID(
                &EncodedOid,
                CRYPT_DECODE_SHARE_OID_STRING_FLAG,
                &pAttr->pszObjId,
                &pbExtra,
                &lRemainExtra
                );

            cbAttrValueEncoded =
                rgAttrValueBlob[ATTRIBUTE_VALUES_VALUE_INDEX].cbData;
            pbAttrValueEncoded =
                rgAttrValueBlob[ATTRIBUTE_VALUES_VALUE_INDEX].pbData;
            while (cbAttrValueEncoded) {
                LONG lTagLength;
                DWORD cbAttrValue;
                const BYTE *pbContent;

                lTagLength = Asn1UtilExtractContent(
                    pbAttrValueEncoded,
                    cbAttrValueEncoded,
                    &cbAttrValue,
                    &pbContent
                    );
                if (0 >= lTagLength ||
                        CMSG_INDEFINITE_LENGTH == cbAttrValue)
                    goto ExtractValueError;
                cbAttrValue += (DWORD) lTagLength;
                if (cbAttrValue > cbAttrValueEncoded)
                    goto ExtractValueError;

                assert(0 != cAttrValue);
                if (0 == cAttrValue--)
                    goto InvalidCountError;

                if (0 == pAttr->cValue) {
                    pAttr->cValue = 1;
                    pAttr->rgValue = pAttrValue;
                } else
                    pAttr->cValue++;

                pAttrValue->cbData = cbAttrValue;
                pAttrValue->pbData = (BYTE *) pbAttrValueEncoded;
                pAttrValue++;

                cbAttrValueEncoded -= cbAttrValue;
                pbAttrValueEncoded += cbAttrValue;
            }

            pAttr++;
        }

        pEntry++;
    }

    assert(0 == cEntry && 0 == cAttr && 0 == cAttrValue);

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }
        

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    *pcCTLEntry = cAllocEntry;
    *ppCTLEntry = pAllocEntry;
    return fResult;

ErrorReturn:
    PkiFree(pAllocEntry);
    pAllocEntry = NULL;
    cAllocEntry = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(ExtractEntryError, ERROR_INVALID_DATA)
SET_ERROR(ExtractAttrError, ERROR_INVALID_DATA)
SET_ERROR(ExtractValueError, ERROR_INVALID_DATA)
SET_ERROR(InvalidCountError, ERROR_INVALID_DATA)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}

// pbCtlEncoded has already been allocated
STATIC PCONTEXT_ELEMENT FastCreateCtlElement(
    IN PCERT_STORE pStore,
    IN DWORD dwMsgAndCertEncodingType,
    IN const BYTE *pbCtlEncoded,
    IN DWORD cbCtlEncoded,
    IN OPTIONAL PSHARE_ELEMENT pShareEle,
    IN DWORD dwFlags
    )
{
    DWORD dwEncodingType;
    const BYTE *pbContent;                     // not allocated
    DWORD cbContent;
    PCTL_INFO pInfo = NULL;
    PCONTEXT_ELEMENT pEle = NULL;
    PCTL_CONTEXT pCtl;
    PCTL_CONTEXT_SUFFIX pCtlSuffix;             // not allocated
    PSORTED_CTL_FIND_INFO pSortedCtlFindInfo;   // not allocated

    const BYTE *pbCtlEncodedHdr;                // not allocated
    DWORD cbCtlEncodedHdr;
    BYTE *pbCtlReencodedHdr = NULL;
    DWORD cbCtlReencodedHdr;
    DWORD cCtlValue;
    CRYPT_DER_BLOB rgCtlValueBlob[CTL_VALUE_COUNT];
    const BYTE *pbEncodedSubjects;              // not allocated
    DWORD cbEncodedSubjects;
    const BYTE *pbSortedCtlExtValue;            // not allocated
    DWORD cbSortedCtlExtValue;
    const BYTE *pbRemainExt;                    // not allocated
    DWORD cbRemainExt;

    PCERT_EXTENSIONS pExtInfo = NULL;
    BYTE *pbAllocReencodedExt = NULL;
    BYTE *pbReencodedExt = NULL;                // not allocated
    DWORD cbReencodedExt;

    HCRYPTMSG hMsg = NULL;
    PCTL_ENTRY pCTLEntry = NULL;
    DWORD cCTLEntry;

    DWORD dwExceptionCode;

  // Handle MappedFile Exceptions
  __try {

    if (0 == (dwMsgAndCertEncodingType = GetCtlEncodingType(
             dwMsgAndCertEncodingType)))
        goto InvalidArg;

    // The message encoding type takes precedence
    dwEncodingType = (dwMsgAndCertEncodingType >> 16) & CERT_ENCODING_TYPE_MASK;


    // Advance to the encoded CTL_INFO
    if (0 >= Asn1UtilExtractPKCS7SignedDataContent(
            pbCtlEncoded,
            cbCtlEncoded,
            &EncodedOIDCtl,
            &cbContent,
            &pbContent
            ))
        goto ExtractSignedDataContentError;
    if (CMSG_INDEFINITE_LENGTH == cbContent)
        goto UnsupportedIndefiniteLength;

    // Get pointers to the encoded CTL_INFO values
    cCtlValue = CTL_VALUE_COUNT;
    if (0 >= Asn1UtilExtractValues(
            pbContent,
            cbContent,
            ASN1UTIL_DEFINITE_LENGTH_FLAG,
            &cCtlValue,
            rgExtractCtlPara,
            rgCtlValueBlob
            ))
        goto ExtractCtlValuesError;

    pbEncodedSubjects = rgCtlValueBlob[CTL_SUBJECTS_VALUE_INDEX].pbData;
    cbEncodedSubjects = rgCtlValueBlob[CTL_SUBJECTS_VALUE_INDEX].cbData;

    // Initialize pointer to and length of the Extensions sequence
    pbReencodedExt = rgCtlValueBlob[CTL_EXTENSIONS_VALUE_INDEX].pbData;
    cbReencodedExt = rgCtlValueBlob[CTL_EXTENSIONS_VALUE_INDEX].cbData;

    // Get pointer to the first value in the CTL sequence. Get length
    // through the subjectAlgorithm value. Don't include the TrustedSubjects
    // or Extensions.

    pbCtlEncodedHdr = rgCtlValueBlob[CTL_SEQ_VALUE_INDEX].pbData;
    cbCtlEncodedHdr = (DWORD)(rgCtlValueBlob[CTL_SUBJECT_ALG_VALUE_INDEX].pbData +
        rgCtlValueBlob[CTL_SUBJECT_ALG_VALUE_INDEX].cbData -
        pbCtlEncodedHdr);

    // Re-encode the CTL excluding the TrustedSubjects and Extensions.
    // Re-encode the CTL sequence to have an indefinite length and terminated
    // with a NULL tag and length.
    cbCtlReencodedHdr = cbCtlEncodedHdr + 2 + 2;
    if (NULL == (pbCtlReencodedHdr = (BYTE *) PkiNonzeroAlloc(
            cbCtlReencodedHdr)))
        goto OutOfMemory;
    pbCtlReencodedHdr[0] = ASN1UTIL_TAG_SEQ;
    pbCtlReencodedHdr[1] = ASN1UTIL_LENGTH_INDEFINITE;
    memcpy(pbCtlReencodedHdr + 2, pbCtlEncodedHdr, cbCtlEncodedHdr);
    pbCtlReencodedHdr[cbCtlEncodedHdr + 2] = ASN1UTIL_TAG_NULL;
    pbCtlReencodedHdr[cbCtlEncodedHdr + 3] = ASN1UTIL_LENGTH_NULL;

    // Decode CTL_INFO excluding the TrustedSubjects and Extensions
    if (NULL == (pInfo = (PCTL_INFO) AllocAndDecodeObject(
                dwEncodingType,
                PKCS_CTL,
                pbCtlReencodedHdr,
                cbCtlReencodedHdr,
                0                       // dwFlags
                ))) goto DecodeCtlError;

    // Allocate and initialize the CTL element structure
    if (NULL == (pEle = (PCONTEXT_ELEMENT) PkiZeroAlloc(
            sizeof(CONTEXT_ELEMENT) +
            sizeof(CTL_CONTEXT) + sizeof(CTL_CONTEXT_SUFFIX) +
            sizeof(SORTED_CTL_FIND_INFO))))
        goto OutOfMemory;

    pEle->dwElementType = ELEMENT_TYPE_CACHE;
    pEle->dwContextType = CERT_STORE_CTL_CONTEXT - 1;
    pEle->lRefCnt = 1;
    pEle->pEle = pEle;
    pEle->pStore = pStore;
    pEle->pProvStore = pStore;
    pEle->pShareEle = pShareEle;

    pCtl = (PCTL_CONTEXT) ToCtlContext(pEle);
    pCtl->dwMsgAndCertEncodingType =
        dwMsgAndCertEncodingType;
    pCtl->pbCtlEncoded = (BYTE *) pbCtlEncoded;
    pCtl->cbCtlEncoded = cbCtlEncoded;
    pCtl->pCtlInfo = pInfo;
    pCtl->hCertStore = (HCERTSTORE) pStore;
    // pCtl->hCryptMsg = NULL;
    pCtl->pbCtlContent = (BYTE *) pbContent;
    pCtl->cbCtlContent = cbContent;

    pCtlSuffix = ToCtlContextSuffix(pEle);
    // pCtlSuffix->ppSortedEntry = NULL;
    pCtlSuffix->fFastCreate = TRUE;

    if (0 == (dwFlags & CERT_CREATE_CONTEXT_SORTED_FLAG)) {
        if (0 == (dwFlags & CERT_CREATE_CONTEXT_NO_ENTRY_FLAG)) {
            if (!FastDecodeCtlSubjects(
                    pbEncodedSubjects,
                    cbEncodedSubjects,
                    &cCTLEntry,
                    &pCTLEntry
                    ))
                goto FastDecodeCtlSubjectsError;
            pInfo->cCTLEntry = cCTLEntry;
            pInfo->rgCTLEntry = pCTLEntry;
            pCtlSuffix->pCTLEntry = pCTLEntry;
        }

        if (0 == (dwFlags & CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG)) {
            BOOL fResult;
            DWORD dwLastErr = 0;
            HCRYPTPROV hProv = 0;
            DWORD dwProvFlags = 0;

            // Attempt to get the store's crypt provider. Serialize crypto
            // operations.
            hProv = GetCryptProv(pStore, &dwProvFlags);

            hMsg = CryptMsgOpenToDecode(
                    dwMsgAndCertEncodingType,
                    0,                          // dwFlags
                    0,                          // dwMsgType
                    hProv,
                    NULL,                       // pRecipientInfo
                    NULL                        // pStreamInfo
                    );
            if (hMsg && CryptMsgUpdate(
                    hMsg,
                    pbCtlEncoded,
                    cbCtlEncoded,
                    TRUE                    // fFinal
                    ))
                fResult = TRUE;
            else {
                fResult = FALSE;
                dwLastErr = GetLastError();
            }

            // For the store's crypt provider, release reference count. Leave
            // crypto operations critical section.
            ReleaseCryptProv(pStore, dwProvFlags);

            if (!fResult) {
                SetLastError(dwLastErr);
                goto MsgError;
            }

            pCtl->hCryptMsg = hMsg;
        }
    } else {
        pSortedCtlFindInfo = (PSORTED_CTL_FIND_INFO) ((BYTE *) pCtlSuffix +
            sizeof(CTL_CONTEXT_SUFFIX));
        pCtlSuffix->pSortedCtlFindInfo = pSortedCtlFindInfo;

        pSortedCtlFindInfo->pbEncodedSubjects = pbEncodedSubjects;
        pSortedCtlFindInfo->cbEncodedSubjects = cbEncodedSubjects;

        // Check if the CTL had the SORTED_CTL extension. If it does, update
        // the find info to point to the extension's hash bucket entry
        // offsets.
        if (ExtractSortedCtlExtValue(
                rgCtlValueBlob,
                &pbSortedCtlExtValue,
                &cbSortedCtlExtValue,
                &pbRemainExt,
                &cbRemainExt
                )) {
            DWORD dwCtlExtFlags;

            if (SORTED_CTL_EXT_HASH_BUCKET_OFFSET > cbSortedCtlExtValue)
                goto InvalidSortedCtlExtension;

            memcpy(&dwCtlExtFlags,
                pbSortedCtlExtValue + SORTED_CTL_EXT_FLAGS_OFFSET,
                sizeof(DWORD));
            pSortedCtlFindInfo->fHashedIdentifier =
                dwCtlExtFlags & SORTED_CTL_EXT_HASHED_SUBJECT_IDENTIFIER_FLAG;

            memcpy(&pSortedCtlFindInfo->cHashBucket,
                pbSortedCtlExtValue + SORTED_CTL_EXT_COUNT_OFFSET,
                sizeof(DWORD));
            pSortedCtlFindInfo->pbEncodedHashBucket =
                pbSortedCtlExtValue + SORTED_CTL_EXT_HASH_BUCKET_OFFSET;

            if (MAX_HASH_BUCKET_COUNT < pSortedCtlFindInfo->cHashBucket ||
                SORTED_CTL_EXT_HASH_BUCKET_OFFSET +
                    (pSortedCtlFindInfo->cHashBucket + 1) * sizeof(DWORD) >
                        cbSortedCtlExtValue)
                goto InvalidSortedCtlExtension;

            if (0 == cbRemainExt)
                cbReencodedExt = 0;
            else {
                // Reencode the remaining extensions.
                // Re-encode the Extensions sequence to have an indefinite
                // length and terminated with a NULL tag and length.
                cbReencodedExt = cbRemainExt + 2 + 2;
                if (NULL == (pbAllocReencodedExt =
                        (BYTE *) PkiNonzeroAlloc(cbReencodedExt)))
                    goto OutOfMemory;
                pbReencodedExt = pbAllocReencodedExt;
                pbReencodedExt[0] = ASN1UTIL_TAG_SEQ;
                pbReencodedExt[1] = ASN1UTIL_LENGTH_INDEFINITE;
                memcpy(pbReencodedExt + 2, pbRemainExt, cbRemainExt);
                pbReencodedExt[cbRemainExt + 2] = ASN1UTIL_TAG_NULL;
                pbReencodedExt[cbRemainExt + 3] = ASN1UTIL_LENGTH_NULL;
            }
        } else if (cbEncodedSubjects) {
            if (!CreateSortedCtlHashBuckets(pSortedCtlFindInfo))
                goto CreateSortedCtlHashBucketsError;
        }
    }

    if (cbReencodedExt) {
        if (NULL == (pExtInfo = (PCERT_EXTENSIONS) AllocAndDecodeObject(
                dwEncodingType,
                X509_EXTENSIONS,
                pbReencodedExt,
                cbReencodedExt,
                0                       // dwFlags
                ))) goto DecodeExtError;
        pInfo->cExtension = pExtInfo->cExtension;
        pInfo->rgExtension = pExtInfo->rgExtension;
        pCtlSuffix->pExtInfo = pExtInfo;
    }

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

    if (NULL == pShareEle) {
        CertPerfIncrementCtlElementCurrentCount();
        CertPerfIncrementCtlElementTotalCount();
    }

CommonReturn:
    PkiFree(pbCtlReencodedHdr);
    PkiFree(pbAllocReencodedExt);
    return pEle;
ErrorReturn:
    if (hMsg)
        CryptMsgClose(hMsg);
    PkiFree(pInfo);
    PkiFree(pExtInfo);
    PkiFree(pCTLEntry);

    if (pEle) {
        PkiFree(pEle);
        pEle = NULL;
    }
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(ExtractSignedDataContentError)
SET_ERROR(UnsupportedIndefiniteLength, ERROR_INVALID_DATA)
TRACE_ERROR(ExtractCtlValuesError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DecodeCtlError)
TRACE_ERROR(DecodeExtError)
SET_ERROR(InvalidSortedCtlExtension, ERROR_INVALID_DATA)
TRACE_ERROR(CreateSortedCtlHashBucketsError)
TRACE_ERROR(FastDecodeCtlSubjectsError)
TRACE_ERROR(MsgError)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}

//+-------------------------------------------------------------------------
//  Creates the specified context from the encoded bytes. The created
//  context isn't put in a store.
//
//  dwContextType values:
//      CERT_STORE_CERTIFICATE_CONTEXT
//      CERT_STORE_CRL_CONTEXT
//      CERT_STORE_CTL_CONTEXT
//
//  If CERT_CREATE_CONTEXT_NOCOPY_FLAG is set, the created context points
//  directly to the pbEncoded instead of an allocated copy. See flag
//  definition for more details.
//
//  If CERT_CREATE_CONTEXT_SORTED_FLAG is set, the context is created
//  with sorted entries. This flag may only be set for CERT_STORE_CTL_CONTEXT.
//  Setting this flag implicitly sets CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG and
//  CERT_CREATE_CONTEXT_NO_ENTRY_FLAG. See flag definition for
//  more details.
//
//  If CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG is set, the context is created
//  without creating a HCRYPTMSG handle for the context. This flag may only be
//  set for CERT_STORE_CTL_CONTEXT.  See flag definition for more details.
//
//  If CERT_CREATE_CONTEXT_NO_ENTRY_FLAG is set, the context is created
//  without decoding the entries. This flag may only be set for
//  CERT_STORE_CTL_CONTEXT.  See flag definition for more details.
//
//  If unable to decode and create the context, NULL is returned.
//  Otherwise, a pointer to a read only CERT_CONTEXT, CRL_CONTEXT or
//  CTL_CONTEXT is returned. The context must be freed by the appropriate
//  free context API. The context can be duplicated by calling the
//  appropriate duplicate context API.
//--------------------------------------------------------------------------
const void *
WINAPI
CertCreateContext(
    IN DWORD dwContextType,
    IN DWORD dwEncodingType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    IN OPTIONAL PCERT_CREATE_CONTEXT_PARA pCreatePara
    )
{
    BYTE *pbAllocEncoded = NULL;
    PCONTEXT_ELEMENT pEle = NULL;
    PCONTEXT_NOCOPY_INFO pNoCopyInfo = NULL;
    PCONTEXT_ELEMENT pStoreEle;                 // not allocated

    DWORD dwExceptionCode;

  // Handle MappedFile Exceptions
  __try {

    dwContextType--;
    if (CONTEXT_COUNT <= dwContextType)
        goto InvalidContextType;

    if (dwFlags & CERT_CREATE_CONTEXT_NOCOPY_FLAG) {
        if (NULL == (pNoCopyInfo = (PCONTEXT_NOCOPY_INFO) PkiZeroAlloc(
                sizeof(CONTEXT_NOCOPY_INFO))))
            goto OutOfMemory;
        if (pCreatePara && pCreatePara->cbSize >=
                offsetof(CERT_CREATE_CONTEXT_PARA, pfnFree) +
                    sizeof(pCreatePara->pfnFree)) {
            pNoCopyInfo->pfnFree = pCreatePara->pfnFree;
            if (pCreatePara->cbSize >=
                    offsetof(CERT_CREATE_CONTEXT_PARA, pvFree) +
                        sizeof(pCreatePara->pvFree) &&
                    pCreatePara->pvFree)
                pNoCopyInfo->pvFree = pCreatePara->pvFree;
            else
                pNoCopyInfo->pvFree = (void *) pbEncoded;
        }
    } else {
        if (NULL == (pbAllocEncoded = (BYTE *) PkiNonzeroAlloc(cbEncoded)))
            goto OutOfMemory;

        memcpy(pbAllocEncoded, pbEncoded, cbEncoded);
        pbEncoded = pbAllocEncoded;
    }

    if (CERT_STORE_CTL_CONTEXT - 1 == dwContextType)
        pEle = FastCreateCtlElement(
                &NullCertStore,
                dwEncodingType,
                pbEncoded,
                cbEncoded,
                NULL,                   // pShareEle
                dwFlags
                );
    else
        pEle = rgpfnCreateElement[dwContextType](
            &NullCertStore,
            dwEncodingType,
            (BYTE *) pbEncoded,
            cbEncoded,
            NULL                    // pShareEle
            );
    if (NULL == pEle)
        goto CreateElementError;

    pEle->pNoCopyInfo = pNoCopyInfo;

    if (!AddElementToStore(
            &NullCertStore,
            pEle,
            CERT_STORE_ADD_ALWAYS,
            &pStoreEle
            ))
        goto AddElementError;

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

CommonReturn:
    // Any To*Context would work
    return ToCertContext(pStoreEle);

ErrorReturn:
    if (pEle)
        FreeContextElement(pEle);
    else if (pNoCopyInfo) {
        if (pNoCopyInfo->pfnFree)
            pNoCopyInfo->pfnFree(pNoCopyInfo->pvFree);
        PkiFree(pNoCopyInfo);
    } else
        PkiFree(pbAllocEncoded);
    pStoreEle = NULL;
    goto CommonReturn;

SET_ERROR(InvalidContextType, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreateElementError)
TRACE_ERROR(AddElementError)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}


STATIC BOOL IsTrustedSubject(
    IN PCRYPT_DATA_BLOB pSubjectIdentifier,
    IN OUT const BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded,
    OUT BOOL *pfTrusted,
    OUT OPTIONAL PCRYPT_DATA_BLOB pEncodedAttributes
    )
{
    const BYTE *pbEncoded = *ppbEncoded;
    DWORD cbEncoded = *pcbEncoded;
    DWORD cValue;
    LONG lAllValues;
    CRYPT_DER_BLOB rgValueBlob[TRUSTED_SUBJECT_VALUE_COUNT];

    cValue = TRUSTED_SUBJECT_VALUE_COUNT;
    if (0 >= (lAllValues = Asn1UtilExtractValues(
            pbEncoded,
            cbEncoded,
            ASN1UTIL_DEFINITE_LENGTH_FLAG,
            &cValue,
            rgExtractTrustedSubjectPara,
            rgValueBlob
            ))) {
        *pfTrusted = FALSE;
        return FALSE;
    }
    if (pSubjectIdentifier->cbData ==
            rgValueBlob[TRUSTED_SUBJECT_IDENTIFIER_VALUE_INDEX].cbData
                        &&
            0 == memcmp(pSubjectIdentifier->pbData,
                rgValueBlob[
                    TRUSTED_SUBJECT_IDENTIFIER_VALUE_INDEX].pbData,
                pSubjectIdentifier->cbData)) {
        *pfTrusted = TRUE;
        if (pEncodedAttributes)
            *pEncodedAttributes =
                rgValueBlob[TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX];
    } else {
        cbEncoded -= lAllValues;
        *pcbEncoded = cbEncoded;
        pbEncoded += lAllValues;
        *ppbEncoded = pbEncoded;
        *pfTrusted = FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Returns TRUE if the SubjectIdentifier exists in the CTL. Optionally
//  returns a pointer to and byte count of the Subject's encoded attributes.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertFindSubjectInSortedCTL(
    IN PCRYPT_DATA_BLOB pSubjectIdentifier,
    IN PCCTL_CONTEXT pCtlContext,
    IN DWORD dwFlags,
    IN void *pvReserved,
    OUT OPTIONAL PCRYPT_DER_BLOB pEncodedAttributes
    )
{
    PCONTEXT_ELEMENT pCacheEle;                     // not allocated
    PSORTED_CTL_FIND_INFO pSortedCtlFindInfo;       // not allocated
    DWORD HashBucketIndex;
    BOOL fTrusted;

    if (NULL == (pCacheEle = GetCacheElement(ToContextElement(pCtlContext))))
        goto NoCacheElementError;

    if (NULL == (pSortedCtlFindInfo =
            ToCtlContextSuffix(pCacheEle)->pSortedCtlFindInfo))
        goto NotSortedCtlContext;

    HashBucketIndex = GetHashBucketIndex(
        pSortedCtlFindInfo->cHashBucket,
        pSortedCtlFindInfo->fHashedIdentifier,
        pSubjectIdentifier
        );

    if (pSortedCtlFindInfo->pbEncodedHashBucket) {
        DWORD dwEntryOffset[2];
        DWORD cbEncoded;
        const BYTE *pbEncoded;

        memcpy(dwEntryOffset, pSortedCtlFindInfo->pbEncodedHashBucket +
            sizeof(DWORD) * HashBucketIndex, sizeof(DWORD) * 2);

        if (dwEntryOffset[1] < dwEntryOffset[0] ||
                dwEntryOffset[1] > pCtlContext->cbCtlContent)
            goto InvalidSortedCtlExtension;

        // Iterate through the encoded TrustedSubjects until a match
        // or reached a TrustedSubject in the next HashBucket.
        cbEncoded = dwEntryOffset[1] - dwEntryOffset[0];
        pbEncoded = pCtlContext->pbCtlContent + dwEntryOffset[0];

        while (cbEncoded) {
            if (!IsTrustedSubject(
                    pSubjectIdentifier,
                    &pbEncoded,
                    &cbEncoded,
                    &fTrusted,
                    pEncodedAttributes))
                goto IsTrustedSubjectError;
            if (fTrusted)
                goto CommonReturn;
        }
    } else if (pSortedCtlFindInfo->pdwHashBucketHead) {
        DWORD dwEntryIndex;

        dwEntryIndex = pSortedCtlFindInfo->pdwHashBucketHead[HashBucketIndex];
        while (dwEntryIndex) {
            PHASH_BUCKET_ENTRY pHashBucketEntry;
            DWORD cbEncoded;
            const BYTE *pbEncoded;

            pHashBucketEntry =
                &pSortedCtlFindInfo->pHashBucketEntry[dwEntryIndex];
            pbEncoded = pHashBucketEntry->pbEntry;
            assert(pbEncoded >= pSortedCtlFindInfo->pbEncodedSubjects &&
                pbEncoded < pSortedCtlFindInfo->pbEncodedSubjects +
                    pSortedCtlFindInfo->cbEncodedSubjects);
            cbEncoded = (DWORD)(pSortedCtlFindInfo->cbEncodedSubjects -
                (pbEncoded - pSortedCtlFindInfo->pbEncodedSubjects));
            assert(cbEncoded);

            if (!IsTrustedSubject(
                    pSubjectIdentifier,
                    &pbEncoded,
                    &cbEncoded,
                    &fTrusted,
                    pEncodedAttributes))
                goto IsTrustedSubjectError;
            if (fTrusted)
                goto CommonReturn;

            dwEntryIndex = pHashBucketEntry->iNext;
        }
    }

    goto NotFoundError;

CommonReturn:
    return fTrusted;

NotFoundError:
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);
ErrorReturn:
    fTrusted = FALSE;
    goto CommonReturn;

TRACE_ERROR(NoCacheElementError)
SET_ERROR(NotSortedCtlContext, E_INVALIDARG)
SET_ERROR(InvalidSortedCtlExtension, ERROR_INVALID_DATA)
TRACE_ERROR(IsTrustedSubjectError)
}


//+-------------------------------------------------------------------------
//  Enumerates through the sequence of TrustedSubjects in a CTL context
//  created with CERT_CREATE_CONTEXT_SORTED_FLAG set.
//
//  To start the enumeration, *ppvNextSubject must be NULL. Upon return,
//  *ppvNextSubject is updated to point to the next TrustedSubject in
//  the encoded sequence.
//
//  Returns FALSE for no more subjects or invalid arguments.
//
//  Note, the returned DER_BLOBs point directly into the encoded
//  bytes (not allocated, and must not be freed).
//--------------------------------------------------------------------------
BOOL
WINAPI
CertEnumSubjectInSortedCTL(
    IN PCCTL_CONTEXT pCtlContext,
    IN OUT void **ppvNextSubject,
    OUT OPTIONAL PCRYPT_DER_BLOB pSubjectIdentifier,
    OUT OPTIONAL PCRYPT_DER_BLOB pEncodedAttributes
    )
{
    BOOL fResult;
    PCONTEXT_ELEMENT pCacheEle;                 // not allocated
    PSORTED_CTL_FIND_INFO pSortedCtlFindInfo;   // not allocated
    const BYTE *pbEncodedSubjects;
    const BYTE *pbEncoded;
    DWORD cbEncoded;
    DWORD cValue;
    LONG lAllValues;
    CRYPT_DER_BLOB rgValueBlob[TRUSTED_SUBJECT_VALUE_COUNT];

    if (NULL == (pCacheEle = GetCacheElement(ToContextElement(pCtlContext))))
        goto NoCacheElementError;

    if (NULL == (pSortedCtlFindInfo =
            ToCtlContextSuffix(pCacheEle)->pSortedCtlFindInfo))
        goto NotSortedCtlContext;

    cbEncoded = pSortedCtlFindInfo->cbEncodedSubjects;
    if (0 == cbEncoded)
        goto NotFoundError;

    pbEncodedSubjects = pSortedCtlFindInfo->pbEncodedSubjects;
    pbEncoded = *((const BYTE **) ppvNextSubject);
    if (NULL == pbEncoded)
        pbEncoded = pbEncodedSubjects;
    else if (pbEncoded < pbEncodedSubjects ||
            pbEncoded >= pbEncodedSubjects + cbEncoded)
        goto NotFoundError;
    else
        cbEncoded -= (DWORD)(pbEncoded - pbEncodedSubjects);

    cValue = TRUSTED_SUBJECT_VALUE_COUNT;
    if (0 >= (lAllValues = Asn1UtilExtractValues(
            pbEncoded,
            cbEncoded,
            ASN1UTIL_DEFINITE_LENGTH_FLAG,
            &cValue,
            rgExtractTrustedSubjectPara,
            rgValueBlob
            )))
        goto ExtractValuesError;

    if (pSubjectIdentifier)
        *pSubjectIdentifier =
            rgValueBlob[TRUSTED_SUBJECT_IDENTIFIER_VALUE_INDEX];
    if (pEncodedAttributes)
        *pEncodedAttributes =
            rgValueBlob[TRUSTED_SUBJECT_ATTRIBUTES_VALUE_INDEX];

    pbEncoded += lAllValues;
    *((const BYTE **) ppvNextSubject) = pbEncoded;
    fResult = TRUE;
CommonReturn:
    return fResult;

NotFoundError:
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);
ErrorReturn:
    *ppvNextSubject = NULL;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(NoCacheElementError)
SET_ERROR(NotSortedCtlContext, E_INVALIDARG)
TRACE_ERROR(ExtractValuesError)
}

//+=========================================================================
// Key Identifier Property Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Decode the Key Identifier and its properties.
//--------------------------------------------------------------------------
STATIC PKEYID_ELEMENT DecodeKeyIdElement(
    IN const BYTE *pbElement,
    IN DWORD cbElement
    )
{
    PKEYID_ELEMENT pEle = NULL;
    DWORD csStatus;
    MEMINFO MemInfo;

    MemInfo.pByte = (BYTE *) pbElement;
    MemInfo.cb = cbElement;
    MemInfo.cbSeek = 0;

    csStatus = LoadStoreElement(
        (HANDLE) &MemInfo,
        ReadFromMemory,
        SkipInMemory,
        cbElement,
        NULL,                       // pStore
        0,                          // dwAddDisposition
        0,                          // dwContextTypeFlags
        NULL,                       // pdwContextType
        (const void **) &pEle,
        TRUE                        // fKeyIdAllowed
        );

    if (NULL == pEle && CSError != csStatus)
        SetLastError((DWORD) CRYPT_E_FILE_ERROR);

    return pEle;
}

STATIC BOOL SerializeKeyIdElement(
    IN HANDLE h,
    IN PFNWRITE pfn,
    IN PKEYID_ELEMENT pEle
    )
{
    BOOL fResult;
    PPROP_ELEMENT pPropEle;

    for (pPropEle = pEle->pPropHead; pPropEle; pPropEle = pPropEle->pNext) {
        if (pPropEle->dwPropId != CERT_KEY_CONTEXT_PROP_ID) {
            if (!WriteStoreElement(
                    h,
                    pfn,
                    0,                      // dwEncodingType
                    pPropEle->dwPropId,
                    pPropEle->pbData,
                    pPropEle->cbData
                    ))
                goto WriteElementError;
        }
    }

    if (!WriteStoreElement(
            h,
            pfn,
            0,              // dwEncodingType
            FILE_ELEMENT_KEYID_TYPE,
            pEle->KeyIdentifier.pbData,
            pEle->KeyIdentifier.cbData
            ))
        goto WriteElementError;
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(WriteElementError);
}

//+-------------------------------------------------------------------------
//  Encode the Key Identifier and its properties.
//--------------------------------------------------------------------------
STATIC BOOL EncodeKeyIdElement(
    IN PKEYID_ELEMENT pEle,
    OUT BYTE **ppbElement,
    OUT DWORD *pcbElement
    )
{
    BOOL fResult;
    MEMINFO MemInfo;
    BYTE *pbElement = NULL;
    DWORD cbElement = 0;

    memset(&MemInfo, 0, sizeof(MemInfo));
    if (!SerializeKeyIdElement(
            (HANDLE) &MemInfo,
            WriteToMemory,
            pEle
            ))
        goto SerializeKeyIdElementError;

    cbElement = MemInfo.cbSeek;
    if (NULL == (pbElement = (BYTE *) PkiNonzeroAlloc(cbElement)))
        goto OutOfMemory;

    MemInfo.pByte = pbElement;
    MemInfo.cb = cbElement;
    MemInfo.cbSeek = 0;

    if (!SerializeKeyIdElement(
            (HANDLE) &MemInfo,
            WriteToMemory,
            pEle
            ))
        goto SerializeKeyIdElementError;

    fResult = TRUE;
CommonReturn:
    *ppbElement = pbElement;
    *pcbElement = cbElement;
    return fResult;
ErrorReturn:
    PkiFree(pbElement);
    pbElement = NULL;
    cbElement = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(SerializeKeyIdElementError)
TRACE_ERROR(OutOfMemory)
}


//+-------------------------------------------------------------------------
//  Get the property for the specified Key Identifier.
//
//  The Key Identifier is the SHA1 hash of the encoded CERT_PUBLIC_KEY_INFO.
//  The Key Identifier for a certificate can be obtained by getting the
//  certificate's CERT_KEY_IDENTIFIER_PROP_ID. The
//  CryptCreateKeyIdentifierFromCSP API can be called to create the Key
//  Identifier from a CSP Public Key Blob.
//
//  A Key Identifier can have the same properties as a certificate context.
//  CERT_KEY_PROV_INFO_PROP_ID is the property of most interest.
//  For CERT_KEY_PROV_INFO_PROP_ID, pvData points to a CRYPT_KEY_PROV_INFO
//  structure. Elements pointed to by fields in the pvData structure follow the
//  structure. Therefore, *pcbData will exceed the size of the structure.
//
//  If CRYPT_KEYID_ALLOC_FLAG is set, then, *pvData is updated with a
//  pointer to allocated memory. LocalFree() must be called to free the
//  allocated memory.
//
//  By default, searches the CurrentUser's list of Key Identifiers.
//  CRYPT_KEYID_MACHINE_FLAG can be set to search the LocalMachine's list
//  of Key Identifiers. When CRYPT_KEYID_MACHINE_FLAG is set, pwszComputerName
//  can also be set to specify the name of a remote computer to be searched
//  instead of the local machine.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptGetKeyIdentifierProperty(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN OPTIONAL void *pvReserved,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    BYTE *pbElement = NULL;
    DWORD cbElement = 0;

    PKEYID_ELEMENT pKeyIdEle = NULL;

    if (!ILS_ReadKeyIdElement(
            pKeyIdentifier,
            dwFlags & CRYPT_KEYID_MACHINE_FLAG ? TRUE : FALSE,
            pwszComputerName,
            &pbElement,
            &cbElement
            ))
        goto ReadKeyIdElementError;

    if (NULL == (pKeyIdEle = DecodeKeyIdElement(
            pbElement,
            cbElement
            )))
        goto DecodeKeyIdElementError;

    fResult = GetCallerProperty(
        pKeyIdEle->pPropHead,
        dwPropId,
        dwFlags & CRYPT_KEYID_ALLOC_FLAG ? TRUE : FALSE,
        pvData,
        pcbData
        );

CommonReturn:
    FreeKeyIdElement(pKeyIdEle);
    PkiFree(pbElement);
    return fResult;
ErrorReturn:
    if (dwFlags & CRYPT_KEYID_ALLOC_FLAG)
        *((void **) pvData) = NULL;
    *pcbData = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ReadKeyIdElementError)
TRACE_ERROR(DecodeKeyIdElementError)
}


//+-------------------------------------------------------------------------
//  Set the property for the specified Key Identifier.
//
//  For CERT_KEY_PROV_INFO_PROP_ID pvData points to the
//  CRYPT_KEY_PROV_INFO data structure. For all other properties, pvData
//  points to a CRYPT_DATA_BLOB.
//
//  Setting pvData == NULL, deletes the property.
//
//  Set CRYPT_KEYID_MACHINE_FLAG to set the property for a LocalMachine
//  Key Identifier. Set pwszComputerName, to select a remote computer.
//
//  If CRYPT_KEYID_DELETE_FLAG is set, the Key Identifier and all its
//  properties is deleted.
//
//  If CRYPT_KEYID_SET_NEW_FLAG is set, the set fails if the property already
//  exists. For an existing property, FALSE is returned with LastError set to
//  CRYPT_E_EXISTS.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSetKeyIdentifierProperty(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN OPTIONAL void *pvReserved,
    IN const void *pvData
    )
{
    BOOL fResult;
    BYTE *pbElement = NULL;
    DWORD cbElement = 0;
    PKEYID_ELEMENT pKeyIdEle = NULL;

    if (dwFlags & CRYPT_KEYID_DELETE_FLAG) {
        return ILS_DeleteKeyIdElement(
            pKeyIdentifier,
            dwFlags & CRYPT_KEYID_MACHINE_FLAG ? TRUE : FALSE,
            pwszComputerName
            );
    }

    if (!ILS_ReadKeyIdElement(
            pKeyIdentifier,
            dwFlags & CRYPT_KEYID_MACHINE_FLAG ? TRUE : FALSE,
            pwszComputerName,
            &pbElement,
            &cbElement
            )) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            goto ReadKeyIdElementError;
    }

    if (NULL == pbElement) {
        BYTE *pbKeyIdEncoded;
        if (NULL == (pbKeyIdEncoded = (BYTE *) PkiNonzeroAlloc(
                pKeyIdentifier->cbData)))
            goto OutOfMemory;
        if (NULL == (pKeyIdEle = CreateKeyIdElement(
                pbKeyIdEncoded,
                pKeyIdentifier->cbData
                )))
            goto OutOfMemory;
    } else {
        if (NULL == (pKeyIdEle = DecodeKeyIdElement(
                pbElement,
                cbElement
                )))
            goto DecodeKeyIdElementError;
        }

        if (dwFlags & CRYPT_KEYID_SET_NEW_FLAG) {
            if (FindPropElement(pKeyIdEle->pPropHead, dwPropId))
                goto KeyIdExists;
    }

    if (!SetCallerProperty(
            &pKeyIdEle->pPropHead,
            dwPropId,
            dwFlags,
            pvData
            ))
        goto SetCallerPropertyError;

    PkiFree(pbElement);
    pbElement = NULL;

    if (!EncodeKeyIdElement(
            pKeyIdEle,
            &pbElement,
            &cbElement
            ))
        goto EncodeKeyIdElementError;

    if (!ILS_WriteKeyIdElement(
            pKeyIdentifier,
            dwFlags & CRYPT_KEYID_MACHINE_FLAG ? TRUE : FALSE,
            pwszComputerName,
            pbElement,
            cbElement
            ))
        goto WriteKeyIdElementError;

    fResult = TRUE;

CommonReturn:
    FreeKeyIdElement(pKeyIdEle);
    PkiFree(pbElement);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(ReadKeyIdElementError)
TRACE_ERROR(OutOfMemory)
SET_ERROR(KeyIdExists, CRYPT_E_EXISTS)
TRACE_ERROR(DecodeKeyIdElementError)
TRACE_ERROR(SetCallerPropertyError)
TRACE_ERROR(EncodeKeyIdElementError)
TRACE_ERROR(WriteKeyIdElementError)
}

typedef struct _KEYID_ELEMENT_CALLBACK_ARG {
    DWORD                       dwPropId;
    DWORD                       dwFlags;
    void                        *pvArg;
    PFN_CRYPT_ENUM_KEYID_PROP   pfnEnum;
} KEYID_ELEMENT_CALLBACK_ARG, *PKEYID_ELEMENT_CALLBACK_ARG;

STATIC BOOL KeyIdElementCallback(
    IN const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN const BYTE *pbElement,
    IN DWORD cbElement,
    IN void *pvArg
    )
{
    BOOL fResult = TRUE;
    PKEYID_ELEMENT_CALLBACK_ARG pKeyIdArg =
        (PKEYID_ELEMENT_CALLBACK_ARG) pvArg;

    PKEYID_ELEMENT pKeyIdEle = NULL;
    PPROP_ELEMENT pPropEle;

    DWORD iProp;
    DWORD cProp = 0;
    DWORD *pdwPropId = NULL;
    void **ppvData = NULL;
    DWORD *pcbData = NULL;

    if (NULL == (pKeyIdEle = DecodeKeyIdElement(
            pbElement,
            cbElement
            )))
        goto DecodeKeyIdElementError;

    // Get number of properties
    cProp = 0;
    pPropEle = pKeyIdEle->pPropHead;
    for ( ; pPropEle; pPropEle = pPropEle->pNext) {
        if (pKeyIdArg->dwPropId) {
            if (pKeyIdArg->dwPropId == pPropEle->dwPropId) {
                cProp = 1;
                break;
            }
        } else
            cProp++;
    }

    if (0 == cProp) {
        if (0 == pKeyIdArg->dwPropId)
            fResult = pKeyIdArg->pfnEnum(
                pKeyIdentifier,
                0,                      // dwFlags
                NULL,                   // pvReserved
                pKeyIdArg->pvArg,
                0,                      // cProp
                NULL,                   // rgdwPropId
                NULL,                   // rgpvData
                NULL                    // rgcbData
                );
    } else {
        pdwPropId = (DWORD *) PkiZeroAlloc(cProp * sizeof(DWORD));
        ppvData = (void **) PkiZeroAlloc(cProp * sizeof(void *));
        pcbData = (DWORD *) PkiZeroAlloc(cProp * sizeof(DWORD));

        if (NULL == pdwPropId || NULL == ppvData || NULL == pcbData)
            goto OutOfMemory;

        iProp = 0;
        pPropEle = pKeyIdEle->pPropHead;
        for ( ; pPropEle; pPropEle = pPropEle->pNext) {
            if (pKeyIdArg->dwPropId &&
                    pKeyIdArg->dwPropId != pPropEle->dwPropId)
                continue;

            if (GetCallerProperty(
                    pPropEle,
                    pPropEle->dwPropId,
                    TRUE,                   // fAlloc
                    (void *) &ppvData[iProp],
                    &pcbData[iProp]
                    )) {
                pdwPropId[iProp] = pPropEle->dwPropId;
                iProp++;
                if (iProp == cProp)
                    break;
            }
        }

        if (0 == iProp)
            goto CommonReturn;

        fResult = pKeyIdArg->pfnEnum(
            pKeyIdentifier,
            0,                      // dwFlags
            NULL,                   // pvReserved
            pKeyIdArg->pvArg,
            iProp,
            pdwPropId,
            ppvData,
            pcbData
            );
    }


CommonReturn:
    FreeKeyIdElement(pKeyIdEle);
    if (ppvData) {
        while (cProp--)
            PkiDefaultCryptFree(ppvData[cProp]);
        PkiFree(ppvData);
    }
    PkiFree(pdwPropId);
    PkiFree(pcbData);
    return fResult;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(DecodeKeyIdElementError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Enumerate the Key Identifiers.
//
//  If pKeyIdentifier is NULL, enumerates all Key Identifers. Otherwise,
//  calls the callback for the specified KeyIdentifier. If dwPropId is
//  0, calls the callback with all the properties. Otherwise, only calls
//  the callback with the specified property (cProp = 1).
//  Furthermore, when dwPropId is specified, skips KeyIdentifiers not
//  having the property.
//
//  Set CRYPT_KEYID_MACHINE_FLAG to enumerate the LocalMachine
//  Key Identifiers. Set pwszComputerName, to enumerate Key Identifiers on
//  a remote computer.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptEnumKeyIdentifierProperties(
    IN OPTIONAL const CRYPT_HASH_BLOB *pKeyIdentifier,
    IN DWORD dwPropId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszComputerName,
    IN OPTIONAL void *pvReserved,
    IN OPTIONAL void *pvArg,
    IN PFN_CRYPT_ENUM_KEYID_PROP pfnEnum
    )
{
    BOOL fResult;

    KEYID_ELEMENT_CALLBACK_ARG KeyIdArg =
        { dwPropId, dwFlags, pvArg, pfnEnum };

    if (pKeyIdentifier) {
        BYTE *pbElement = NULL;
        DWORD cbElement;

        fResult = ILS_ReadKeyIdElement(
                pKeyIdentifier,
                dwFlags & CRYPT_KEYID_MACHINE_FLAG ? TRUE : FALSE,
                pwszComputerName,
                &pbElement,
                &cbElement
                );
        if (fResult)
            fResult = KeyIdElementCallback(
                pKeyIdentifier,
                pbElement,
                cbElement,
                (void *) &KeyIdArg
                );
        PkiFree(pbElement);
    } else
        fResult = ILS_OpenAllKeyIdElements(
            dwFlags & CRYPT_KEYID_MACHINE_FLAG ? TRUE : FALSE,
            pwszComputerName,
            (void *) &KeyIdArg,
            KeyIdElementCallback
            );

    return fResult;
}

//+-------------------------------------------------------------------------
//  For either the CERT_KEY_IDENTIFIER_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID
//  set the Crypt KeyIdentifier CERT_KEY_PROV_INFO_PROP_ID property if the
//  other property already exists.
//
//  If dwPropId == 0, does an implicit GetProperty(KEY_PROV_INFO)
//--------------------------------------------------------------------------
STATIC void SetCryptKeyIdentifierKeyProvInfoProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,              // may be 0
    IN const void *pvData
    )
{
    PCRYPT_HASH_BLOB pKeyIdentifier = NULL;
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    DWORD cbKeyProvInfo;
    void *pvOtherData = NULL;
    DWORD cbOtherData;
    CRYPT_HASH_BLOB OtherKeyIdentifier;

    if ((CERT_STORE_CERTIFICATE_CONTEXT - 1) != pEle->dwContextType)
        return;
    if (0 == dwPropId) {
        if (AllocAndGetProperty(
                pEle,
                CERT_KEY_PROV_INFO_PROP_ID,
                (void **) &pKeyProvInfo,
                &cbKeyProvInfo
                ) && cbKeyProvInfo) {
            SetCryptKeyIdentifierKeyProvInfoProperty(
                pEle,
                CERT_KEY_PROV_INFO_PROP_ID,
                pKeyProvInfo
                );
            PkiFree(pKeyProvInfo);
        }
        return;
    } else if (NULL == pvData)
        return;

    switch (dwPropId) {
        case CERT_KEY_IDENTIFIER_PROP_ID:
            AllocAndGetProperty(
                pEle,
                CERT_KEY_PROV_INFO_PROP_ID,
                &pvOtherData,
                &cbOtherData
                );
            if (pvOtherData) {
                pKeyIdentifier = (PCRYPT_HASH_BLOB) pvData;
                pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) pvOtherData;
            }
            break;
        case CERT_KEY_PROV_INFO_PROP_ID:
            AllocAndGetProperty(
                pEle,
                CERT_KEY_IDENTIFIER_PROP_ID,
                &pvOtherData,
                &cbOtherData
                );
            if (pvOtherData) {
                pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) pvData;
                OtherKeyIdentifier.cbData = cbOtherData;
                OtherKeyIdentifier.pbData = (BYTE *)pvOtherData;
                pKeyIdentifier = &OtherKeyIdentifier;
            }
            break;
        default:
            return;
    }

    if (pvOtherData) {
        DWORD dwFlags = CRYPT_KEYID_SET_NEW_FLAG;
        if (pKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET)
            dwFlags |= CRYPT_KEYID_MACHINE_FLAG;
        CryptSetKeyIdentifierProperty(
            pKeyIdentifier,
            CERT_KEY_PROV_INFO_PROP_ID,
            dwFlags,
            NULL,               // pwszComputerName
            NULL,               // pvReserved
            (const void *) pKeyProvInfo
            );
        PkiFree(pvOtherData);
    }

}

//+-------------------------------------------------------------------------
//  Get the Key Identifier property for the specified element.
//
//  Only supported for certificates.
//--------------------------------------------------------------------------
STATIC BOOL GetKeyIdProperty(
    IN PCONTEXT_ELEMENT pEle,
    IN DWORD dwPropId,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    PCCERT_CONTEXT pCert;
    PCERT_INFO pCertInfo;
    PCERT_EXTENSION pExt;
    CRYPT_HASH_BLOB KeyIdentifier = { 0, NULL };
    BYTE rgbHash[MAX_HASH_LEN];

    if ((CERT_STORE_CERTIFICATE_CONTEXT - 1) != pEle->dwContextType)
        goto InvalidPropId;

    pCert = ToCertContext(pEle);
    pCertInfo = pCert->pCertInfo;

    if (pExt = CertFindExtension(
            szOID_SUBJECT_KEY_IDENTIFIER,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            )) {
        // Skip by the octet tag, length bytes
        Asn1UtilExtractContent(
            pExt->Value.pbData,
            pExt->Value.cbData,
            &KeyIdentifier.cbData,
            (const BYTE **) &KeyIdentifier.pbData
            );
    }

    if (0 == KeyIdentifier.cbData) {
        const BYTE *pbPublicKeyInfo;
        DWORD cbPublicKeyInfo;
        if (!Asn1UtilExtractCertificatePublicKeyInfo(
                pCert->pbCertEncoded,
                pCert->cbCertEncoded,
                &cbPublicKeyInfo,
                &pbPublicKeyInfo
                ))
            goto ExtractPublicKeyInfoError;

        KeyIdentifier.cbData = sizeof(rgbHash);
        KeyIdentifier.pbData = rgbHash;
        if (!CryptHashCertificate(
                0,                      // hCryptProv
                CALG_SHA1,
                0,                      // dwFlags
                pbPublicKeyInfo,
                cbPublicKeyInfo,
                rgbHash,
                &KeyIdentifier.cbData
                ))
            goto HashPublicKeyInfoError;
    }

    if (!SetProperty(
            pEle,
            dwPropId,
            CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG,
            &KeyIdentifier
            ))
        goto SetKeyIdPropertyError;

    fResult = GetProperty(
            pEle,
            dwPropId,
            pvData,
            pcbData
            );
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    *pcbData = 0;
    goto CommonReturn;

SET_ERROR(InvalidPropId, E_INVALIDARG)
TRACE_ERROR(ExtractPublicKeyInfoError)
TRACE_ERROR(HashPublicKeyInfoError)
TRACE_ERROR(SetKeyIdPropertyError)
}

#ifdef CMS_PKCS7
//+-------------------------------------------------------------------------
//  If the verify signature fails with CRYPT_E_MISSING_PUBKEY_PARA,
//  build a certificate chain. Retry. Hopefully, the issuer's
//  CERT_PUBKEY_ALG_PARA_PROP_ID property gets set while building the chain.
//--------------------------------------------------------------------------
STATIC BOOL VerifyCertificateSignatureWithChainPubKeyParaInheritance(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwCertEncodingType,
    IN DWORD        dwSubjectType,
    IN void         *pvSubject,
    IN PCCERT_CONTEXT pIssuer
    )
{
    if (CryptVerifyCertificateSignatureEx(
            hCryptProv,
            dwCertEncodingType,
            dwSubjectType,
            pvSubject,
            CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT,
            (void *) pIssuer,
            0,                                  // dwFlags
            NULL                                // pvReserved
            ))
        return TRUE;
    else if (CRYPT_E_MISSING_PUBKEY_PARA != GetLastError())
        return FALSE;
    else {
        PCCERT_CHAIN_CONTEXT pChainContext;
        CERT_CHAIN_PARA ChainPara;

        // Build a chain. Hopefully, the issuer inherit's its public key
        // parameters from up the chain

        memset(&ChainPara, 0, sizeof(ChainPara));
        ChainPara.cbSize = sizeof(ChainPara);
        if (CertGetCertificateChain(
                NULL,                   // hChainEngine
                pIssuer,
                NULL,                   // pTime
                pIssuer->hCertStore,
                &ChainPara,
                CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL,
                NULL,                   // pvReserved
                &pChainContext
                ))
            CertFreeCertificateChain(pChainContext);

        // Try again. Hopefully the above chain building updated the issuer's
        // context property with the missing public key parameters
        return CryptVerifyCertificateSignatureEx(
                hCryptProv,
                dwCertEncodingType,
                dwSubjectType,
                pvSubject,
                CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT,
                (void *) pIssuer,
                0,                                  // dwFlags
                NULL                                // pvReserved
                );
    }
}
#endif  // CMS_PKCS7
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\oidinfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       oidinfo.cpp
//
//  Contents:   Cryptographic Object ID (OID) Info Functions
//
//  Functions:  I_CryptOIDInfoDllMain
//              CryptFindOIDInfo
//              CryptRegisterOIDInfo
//              CryptUnregisterOIDInfo
//              CryptEnumOIDInfo
//              CryptFindLocalizedName
//
//  Comments:
//
//  History:    24-May-97    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include "wintrust.h"   // wintrust.h is needed for SPC_ oids
#include "chain.h"      // chain.h is needed for ChainRetrieveObjectByUrlW()
                        // and ChainIsConnected()
#include "certca.h"     // certca.h is needed for CAOIDGetLdapURL()

// Initialized in I_CryptOIDInfoDllMain at ProcessAttach
static HMODULE hOIDInfoInst;

#define MAX_RESOURCE_OID_NAME_LENGTH    256
static LPCWSTR pwszNullName = L"";

#define LEN_ALIGN(Len)  ((Len + 7) & ~7)

#define CONST_OID_GROUP_PREFIX_CHAR    '!'
#define OID_INFO_ENCODING_TYPE          0
#define OID_INFO_NAME_VALUE_NAME        L"Name"
#define OID_INFO_ALGID_VALUE_NAME       L"Algid"
#define OID_INFO_EXTRA_INFO_VALUE_NAME  L"ExtraInfo"
#define OID_INFO_FLAGS_VALUE_NAME       L"Flags"



//+=========================================================================
//  OID Information Tables (by GROUP_ID)
//==========================================================================

#define OID_INFO_LEN sizeof(CRYPT_OID_INFO)

//+-------------------------------------------------------------------------
//  Hash Algorithm Table
//--------------------------------------------------------------------------
#define HASH_ALG_ENTRY(pszOID, pwszName, Algid) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_HASH_ALG_OID_GROUP_ID, Algid, 0, NULL

static CCRYPT_OID_INFO HashAlgTable[] = {
    HASH_ALG_ENTRY(szOID_OIWSEC_sha1, L"sha1", CALG_SHA1),
    HASH_ALG_ENTRY(szOID_OIWSEC_sha1, L"sha", CALG_SHA1),
    HASH_ALG_ENTRY(szOID_OIWSEC_sha, L"sha", CALG_SHA),
    HASH_ALG_ENTRY(szOID_RSA_MD5, L"md5", CALG_MD5),
    HASH_ALG_ENTRY(szOID_RSA_MD4, L"md4", CALG_MD4),
    HASH_ALG_ENTRY(szOID_RSA_MD2, L"md2", CALG_MD2)
};
#define HASH_ALG_CNT (sizeof(HashAlgTable) / sizeof(HashAlgTable[0]))


//+-------------------------------------------------------------------------
//  Encryption Algorithm Table
//--------------------------------------------------------------------------
#define ENCRYPT_ALG_ENTRY(pszOID, pwszName, Algid) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_ENCRYPT_ALG_OID_GROUP_ID, \
    Algid, 0, NULL

static CCRYPT_OID_INFO EncryptAlgTable[] = {
    ENCRYPT_ALG_ENTRY(szOID_OIWSEC_desCBC, L"des", CALG_DES),
    ENCRYPT_ALG_ENTRY(szOID_RSA_DES_EDE3_CBC, L"3des", CALG_3DES),
    ENCRYPT_ALG_ENTRY(szOID_RSA_RC2CBC, L"rc2", CALG_RC2),
    ENCRYPT_ALG_ENTRY(szOID_RSA_RC4, L"rc4", CALG_RC4),
#ifdef CMS_PKCS7
    ENCRYPT_ALG_ENTRY(szOID_RSA_SMIMEalgCMS3DESwrap, L"CMS3DESwrap", CALG_3DES),
    ENCRYPT_ALG_ENTRY(szOID_RSA_SMIMEalgCMSRC2wrap, L"CMSRC2wrap", CALG_RC2),
#endif  // CMS_PKCS7
};
#define ENCRYPT_ALG_CNT (sizeof(EncryptAlgTable) / sizeof(EncryptAlgTable[0]))


//+-------------------------------------------------------------------------
//  Public Key Algorithm Table
//--------------------------------------------------------------------------
static const DWORD dwMosaicFlags = CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG |
                                        CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG;

static const DWORD dwNoNullParaFlag = CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG;

#define PUBKEY_ALG_ENTRY(pszOID, pwszName, Algid) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_PUBKEY_ALG_OID_GROUP_ID, \
    Algid, 0, NULL

#define PUBKEY_EXTRA_ALG_ENTRY(pszOID, pwszName, Algid, dwFlags) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_PUBKEY_ALG_OID_GROUP_ID, \
    Algid, sizeof(dwFlags), (BYTE *) &dwFlags

#define DSA_PUBKEY_ALG_ENTRY(pszOID, pwszName) \
    PUBKEY_EXTRA_ALG_ENTRY(pszOID, pwszName, CALG_DSS_SIGN, dwNoNullParaFlag)

#define DH_PUBKEY_ALG_ENTRY(pszOID, pwszName) \
    PUBKEY_EXTRA_ALG_ENTRY(pszOID, pwszName, CALG_DH_SF, dwNoNullParaFlag)

#ifdef CMS_PKCS7
#define ESDH_PUBKEY_ALG_ENTRY(pszOID, pwszName) \
    PUBKEY_EXTRA_ALG_ENTRY(pszOID, pwszName, CALG_DH_EPHEM, dwNoNullParaFlag)
#endif  // CMS_PKCS7

static CCRYPT_OID_INFO PubKeyAlgTable[] = {
    PUBKEY_ALG_ENTRY(szOID_RSA_RSA, L"RSA", CALG_RSA_KEYX),
    DSA_PUBKEY_ALG_ENTRY(szOID_X957_DSA, L"DSA"),
    DH_PUBKEY_ALG_ENTRY(szOID_ANSI_X942_DH, L"DH"),
    PUBKEY_ALG_ENTRY(szOID_RSA_RSA, L"RSA_KEYX", CALG_RSA_KEYX),
    PUBKEY_ALG_ENTRY(szOID_RSA_RSA, L"RSA", CALG_RSA_SIGN),
    PUBKEY_ALG_ENTRY(szOID_RSA_RSA, L"RSA_SIGN", CALG_RSA_SIGN),
    DSA_PUBKEY_ALG_ENTRY(szOID_OIWSEC_dsa, L"DSA"),
    DSA_PUBKEY_ALG_ENTRY(szOID_OIWSEC_dsa, L"DSS"),
    DSA_PUBKEY_ALG_ENTRY(szOID_OIWSEC_dsa, L"DSA_SIGN"),
    DH_PUBKEY_ALG_ENTRY(szOID_RSA_DH, L"DH"),
    PUBKEY_ALG_ENTRY(szOID_OIWSEC_rsaXchg, L"RSA_KEYX", CALG_RSA_KEYX),
    PUBKEY_EXTRA_ALG_ENTRY(szOID_INFOSEC_mosaicKMandUpdSig,
        L"mosaicKMandUpdSig", CALG_DSS_SIGN, dwMosaicFlags),
#ifdef CMS_PKCS7
    ESDH_PUBKEY_ALG_ENTRY(szOID_RSA_SMIMEalgESDH, L"ESDH"),
#endif  // CMS_PKCS7
    PUBKEY_ALG_ENTRY(szOID_PKIX_NO_SIGNATURE, L"NO_SIGN", CALG_NO_SIGN),
};
#define PUBKEY_ALG_CNT (sizeof(PubKeyAlgTable) / sizeof(PubKeyAlgTable[0]))


//+-------------------------------------------------------------------------
//  Signature Algorithm Table
//--------------------------------------------------------------------------
static const ALG_ID aiRsaPubKey = CALG_RSA_SIGN;
static const DWORD rgdwMosaicSign[] = {
    CALG_DSS_SIGN,
    CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG |
        CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG
};
static const DWORD rgdwDssSign[] = {
    CALG_DSS_SIGN,
    CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG
};

#define SIGN_ALG_ENTRY(pszOID, pwszName, aiHash, aiPubKey) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_SIGN_ALG_OID_GROUP_ID, aiHash, \
    sizeof(aiPubKey), (BYTE *) &aiPubKey
#define RSA_SIGN_ALG_ENTRY(pszOID, pwszName, aiHash) \
    SIGN_ALG_ENTRY(pszOID, pwszName, aiHash, aiRsaPubKey)

#define SIGN_EXTRA_ALG_ENTRY(pszOID, pwszName, aiHash, rgdwExtra) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_SIGN_ALG_OID_GROUP_ID, aiHash, \
    sizeof(rgdwExtra), (BYTE *) rgdwExtra

#define DSS_SIGN_ALG_ENTRY(pszOID, pwszName) \
    SIGN_EXTRA_ALG_ENTRY(pszOID, pwszName, CALG_SHA1, rgdwDssSign)

static CCRYPT_OID_INFO SignAlgTable[] = {
    RSA_SIGN_ALG_ENTRY(szOID_RSA_SHA1RSA, L"sha1RSA", CALG_SHA1),
    RSA_SIGN_ALG_ENTRY(szOID_RSA_MD5RSA, L"md5RSA", CALG_MD5),
    DSS_SIGN_ALG_ENTRY(szOID_X957_SHA1DSA, L"sha1DSA"),
    RSA_SIGN_ALG_ENTRY(szOID_OIWSEC_sha1RSASign, L"sha1RSA", CALG_SHA1),
    RSA_SIGN_ALG_ENTRY(szOID_OIWSEC_sha1RSASign, L"shaRSA", CALG_SHA1),
    RSA_SIGN_ALG_ENTRY(szOID_OIWSEC_shaRSA, L"shaRSA", CALG_SHA),
    RSA_SIGN_ALG_ENTRY(szOID_OIWSEC_md5RSA, L"md5RSA", CALG_MD5),
    RSA_SIGN_ALG_ENTRY(szOID_RSA_MD2RSA, L"md2RSA", CALG_MD2),
    RSA_SIGN_ALG_ENTRY(szOID_RSA_MD4RSA, L"md4RSA", CALG_MD4),
    RSA_SIGN_ALG_ENTRY(szOID_OIWSEC_md4RSA, L"md4RSA", CALG_MD4),
    RSA_SIGN_ALG_ENTRY(szOID_OIWSEC_md4RSA2, L"md4RSA", CALG_MD4),
    RSA_SIGN_ALG_ENTRY(szOID_OIWDIR_md2RSA, L"md2RSA", CALG_MD2),
    DSS_SIGN_ALG_ENTRY(szOID_OIWSEC_shaDSA, L"sha1DSA"),
    DSS_SIGN_ALG_ENTRY(szOID_OIWSEC_shaDSA, L"shaDSA"),
    DSS_SIGN_ALG_ENTRY(szOID_OIWSEC_dsaSHA1,L"dsaSHA1"),
    SIGN_EXTRA_ALG_ENTRY(szOID_INFOSEC_mosaicUpdatedSig, L"mosaicUpdatedSig",
        CALG_SHA, rgdwMosaicSign),
};
#define SIGN_ALG_CNT (sizeof(SignAlgTable) / sizeof(SignAlgTable[0]))


//+-------------------------------------------------------------------------
//  RDN Attribute Table
//--------------------------------------------------------------------------

// PLEASE UPDATE the following define in certstr.cpp if you add a new entry
// with a longer pwszName
// #define MAX_X500_KEY_LEN    64

// Ordered lists of acceptable RDN attribute value types. 0 terminates.
static const DWORD rgdwPrintableValueType[] = { CERT_RDN_PRINTABLE_STRING, 0 };
static const DWORD rgdwIA5ValueType[] = { CERT_RDN_IA5_STRING, 0 };
static const DWORD rgdwNumericValueType[] = { CERT_RDN_NUMERIC_STRING, 0 };
static const DWORD rgdwIA5orUTF8ValueType[] = { CERT_RDN_IA5_STRING,
                                                CERT_RDN_UTF8_STRING, 0 };

#define RDN_ATTR_ENTRY(pszOID, pwszName, rgdwValueType) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_RDN_ATTR_OID_GROUP_ID, 0, \
    sizeof(rgdwValueType), (BYTE *) rgdwValueType
#define DEFAULT_RDN_ATTR_ENTRY(pszOID, pwszName) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_RDN_ATTR_OID_GROUP_ID, 0, 0, NULL

static CCRYPT_OID_INFO RDNAttrTable[] = {
    // Ordered with most commonly used key names at the beginning

    // Labeling attribute types:
    DEFAULT_RDN_ATTR_ENTRY(szOID_COMMON_NAME, L"CN"),
    // Geographic attribute types:
    DEFAULT_RDN_ATTR_ENTRY(szOID_LOCALITY_NAME, L"L"),
    // Organizational attribute types:
    DEFAULT_RDN_ATTR_ENTRY(szOID_ORGANIZATION_NAME, L"O"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_ORGANIZATIONAL_UNIT_NAME, L"OU"),

    // Verisign sticks the following in their cert names. Netscape uses the
    // "E" instead of the "Email". Will let "E" take precedence
    RDN_ATTR_ENTRY(szOID_RSA_emailAddr, L"E", rgdwIA5ValueType),
    RDN_ATTR_ENTRY(szOID_RSA_emailAddr, L"Email", rgdwIA5ValueType),

    // The following aren't used in Verisign's certs

    // Geographic attribute types:
    RDN_ATTR_ENTRY(szOID_COUNTRY_NAME, L"C", rgdwPrintableValueType),
    DEFAULT_RDN_ATTR_ENTRY(szOID_STATE_OR_PROVINCE_NAME, L"S"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_STATE_OR_PROVINCE_NAME, L"ST"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_STREET_ADDRESS, L"STREET"),

    // Organizational attribute types:
    DEFAULT_RDN_ATTR_ENTRY(szOID_TITLE, L"T"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_TITLE, L"Title"),

    DEFAULT_RDN_ATTR_ENTRY(szOID_GIVEN_NAME, L"G"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_GIVEN_NAME, L"GN"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_GIVEN_NAME, L"GivenName"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_INITIALS, L"I"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_INITIALS, L"Initials"),

    // Labeling attribute types:
    DEFAULT_RDN_ATTR_ENTRY(szOID_SUR_NAME, L"SN"),
//    RDN_ATTR_ENTRY(szOID_DEVICE_SERIAL_NUMBER, L"", rgdwPrintableValueType),

    // Pilot user attribute types:
    RDN_ATTR_ENTRY(szOID_DOMAIN_COMPONENT, L"DC", rgdwIA5orUTF8ValueType),

    // Explanatory attribute types:
    DEFAULT_RDN_ATTR_ENTRY(szOID_DESCRIPTION, L"Description"),
//  szOID_SEARCH_GUIDE                  "2.5.4.14"
//    DEFAULT_RDN_ATTR_ENTRY(szOID_BUSINESS_CATEGORY, L""),

    // Postal addressing attribute types:
//  szOID_POSTAL_ADDRESS                "2.5.4.16"
    DEFAULT_RDN_ATTR_ENTRY(szOID_POSTAL_CODE, L"PostalCode"),
    DEFAULT_RDN_ATTR_ENTRY(szOID_POST_OFFICE_BOX, L"POBox"),
//    DEFAULT_RDN_ATTR_ENTRY(szOID_PHYSICAL_DELIVERY_OFFICE_NAME, L""),

    // Telecommunications addressing attribute types:
    RDN_ATTR_ENTRY(szOID_TELEPHONE_NUMBER, L"Phone", rgdwPrintableValueType),
//  szOID_TELEX_NUMBER                  "2.5.4.21"
//  szOID_TELETEXT_TERMINAL_IDENTIFIER  "2.5.4.22"
//  szOID_FACSIMILE_TELEPHONE_NUMBER    "2.5.4.23"

//  Following is used as a test case for a Numeric value
    RDN_ATTR_ENTRY(szOID_X21_ADDRESS, L"X21Address", rgdwNumericValueType),
//    RDN_ATTR_ENTRY(szOID_INTERNATIONAL_ISDN_NUMBER, L"", rgdwNumericValueType),
//  szOID_REGISTERED_ADDRESS            "2.5.4.26"
//    RDN_ATTR_ENTRY(szOID_DESTINATION_INDICATOR, L"", rgdwPrintableValueType)

    // Preference attribute types:
//  szOID_PREFERRED_DELIVERY_METHOD     "2.5.4.28"

    // OSI application attribute types:
//  szOID_PRESENTATION_ADDRESS          "2.5.4.29"
//  szOID_SUPPORTED_APPLICATION_CONTEXT "2.5.4.30"

    // Relational application attribute types:
//  szOID_MEMBER                        "2.5.4.31"
//  szOID_OWNER                         "2.5.4.32"
//  szOID_ROLE_OCCUPANT                 "2.5.4.33"
//  szOID_SEE_ALSO                      "2.5.4.34"

    // Security attribute types:
//  szOID_USER_PASSWORD                 "2.5.4.35"
//  szOID_USER_CERTIFICATE              "2.5.4.36"
//  szOID_CA_CERTIFICATE                "2.5.4.37"
//  szOID_AUTHORITY_REVOCATION_LIST     "2.5.4.38"
//  szOID_CERTIFICATE_REVOCATION_LIST   "2.5.4.39"
//  szOID_CROSS_CERTIFICATE_PAIR        "2.5.4.40"

    // Undocumented attribute types???
//#define szOID_???                         "2.5.4.41"

    DEFAULT_RDN_ATTR_ENTRY(szOID_DN_QUALIFIER, L"dnQualifier"),
};
#define RDN_ATTR_CNT (sizeof(RDNAttrTable) / sizeof(RDNAttrTable[0]))

//+-------------------------------------------------------------------------
//  Extension or Attribute Table (Localized via resource strings)
//--------------------------------------------------------------------------
#define EXT_ATTR_ENTRY(pszOID, ResourceIdORpwszName) \
    OID_INFO_LEN, pszOID, (LPCWSTR) ResourceIdORpwszName, \
        CRYPT_EXT_OR_ATTR_OID_GROUP_ID, 0, 0, NULL

static CRYPT_OID_INFO ExtAttrTable[] = {
    EXT_ATTR_ENTRY(szOID_AUTHORITY_KEY_IDENTIFIER2,
        IDS_EXT_AUTHORITY_KEY_IDENTIFIER),
    EXT_ATTR_ENTRY(szOID_AUTHORITY_KEY_IDENTIFIER,
        IDS_EXT_AUTHORITY_KEY_IDENTIFIER),
    EXT_ATTR_ENTRY(szOID_KEY_ATTRIBUTES,
        IDS_EXT_KEY_ATTRIBUTES),
    EXT_ATTR_ENTRY(szOID_KEY_USAGE_RESTRICTION,
        IDS_EXT_KEY_USAGE_RESTRICTION),
    EXT_ATTR_ENTRY(szOID_SUBJECT_ALT_NAME2,
        IDS_EXT_SUBJECT_ALT_NAME),
    EXT_ATTR_ENTRY(szOID_SUBJECT_ALT_NAME,
        IDS_EXT_SUBJECT_ALT_NAME),
    EXT_ATTR_ENTRY(szOID_ISSUER_ALT_NAME2,
        IDS_EXT_ISSUER_ALT_NAME),
    EXT_ATTR_ENTRY(szOID_ISSUER_ALT_NAME,
        IDS_EXT_ISSUER_ALT_NAME),
    EXT_ATTR_ENTRY(szOID_BASIC_CONSTRAINTS2,
        IDS_EXT_BASIC_CONSTRAINTS),
    EXT_ATTR_ENTRY(szOID_BASIC_CONSTRAINTS,
        IDS_EXT_BASIC_CONSTRAINTS),
    EXT_ATTR_ENTRY(szOID_KEY_USAGE,
        IDS_EXT_KEY_USAGE),
    EXT_ATTR_ENTRY(szOID_CERT_POLICIES,
        IDS_EXT_CERT_POLICIES),
    EXT_ATTR_ENTRY(szOID_SUBJECT_KEY_IDENTIFIER,
        IDS_EXT_SUBJECT_KEY_IDENTIFIER),
    EXT_ATTR_ENTRY(szOID_CRL_REASON_CODE,
        IDS_EXT_CRL_REASON_CODE),
    EXT_ATTR_ENTRY(szOID_CRL_DIST_POINTS,
        IDS_EXT_CRL_DIST_POINTS),
    EXT_ATTR_ENTRY(szOID_ENHANCED_KEY_USAGE,
        IDS_EXT_ENHANCED_KEY_USAGE),
    EXT_ATTR_ENTRY(szOID_AUTHORITY_INFO_ACCESS,
        IDS_EXT_AUTHORITY_INFO_ACCESS),
    EXT_ATTR_ENTRY(szOID_CERT_EXTENSIONS,
        IDS_EXT_CERT_EXTENSIONS),
    EXT_ATTR_ENTRY(szOID_RSA_certExtensions,
        IDS_EXT_CERT_EXTENSIONS),
    EXT_ATTR_ENTRY(szOID_NEXT_UPDATE_LOCATION,
        IDS_EXT_NEXT_UPDATE_LOCATION),
    EXT_ATTR_ENTRY(szOID_YESNO_TRUST_ATTR,
        IDS_EXT_YESNO_TRUST_ATTR),
    EXT_ATTR_ENTRY(szOID_RSA_emailAddr,
        IDS_EXT_RSA_emailAddr),
    EXT_ATTR_ENTRY(szOID_RSA_unstructName,
        IDS_EXT_RSA_unstructName),
    EXT_ATTR_ENTRY(szOID_RSA_contentType,
        IDS_EXT_RSA_contentType),
    EXT_ATTR_ENTRY(szOID_RSA_messageDigest,
        IDS_EXT_RSA_messageDigest),
    EXT_ATTR_ENTRY(szOID_RSA_signingTime,
        IDS_EXT_RSA_signingTime),
    EXT_ATTR_ENTRY(szOID_RSA_counterSign,
        IDS_EXT_RSA_counterSign),
    EXT_ATTR_ENTRY(szOID_RSA_challengePwd,
        IDS_EXT_RSA_challengePwd),
    EXT_ATTR_ENTRY(szOID_RSA_unstructAddr,
        IDS_EXT_RSA_unstructAddr),
    EXT_ATTR_ENTRY(szOID_RSA_extCertAttrs, L""),
    EXT_ATTR_ENTRY(szOID_RSA_SMIMECapabilities,
        IDS_EXT_RSA_SMIMECapabilities),
    EXT_ATTR_ENTRY(szOID_RSA_preferSignedData,
        IDS_EXT_RSA_preferSignedData),
    EXT_ATTR_ENTRY(szOID_PKIX_POLICY_QUALIFIER_CPS,
        IDS_EXT_PKIX_POLICY_QUALIFIER_CPS),
    EXT_ATTR_ENTRY(szOID_PKIX_POLICY_QUALIFIER_USERNOTICE,
        IDS_EXT_PKIX_POLICY_QUALIFIER_USERNOTICE),
    EXT_ATTR_ENTRY(szOID_PKIX_OCSP,
        IDS_EXT_PKIX_OCSP),
    EXT_ATTR_ENTRY(szOID_PKIX_CA_ISSUERS,
        IDS_EXT_PKIX_CA_ISSUERS),
    EXT_ATTR_ENTRY(szOID_ENROLL_CERTTYPE_EXTENSION,
        IDS_EXT_MS_CERTIFICATE_TEMPLATE),
    EXT_ATTR_ENTRY(szOID_ENROLL_CERTTYPE_EXTENSION,
        IDS_EXT_ENROLL_CERTTYPE),
    EXT_ATTR_ENTRY(szOID_CERT_MANIFOLD,
        IDS_EXT_CERT_MANIFOLD),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_CERT_TYPE,
        IDS_EXT_NETSCAPE_CERT_TYPE),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_BASE_URL,
        IDS_EXT_NETSCAPE_BASE_URL),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_REVOCATION_URL,
        IDS_EXT_NETSCAPE_REVOCATION_URL),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_CA_REVOCATION_URL,
        IDS_EXT_NETSCAPE_CA_REVOCATION_URL),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_CERT_RENEWAL_URL,
        IDS_EXT_NETSCAPE_CERT_RENEWAL_URL),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_CA_POLICY_URL,
        IDS_EXT_NETSCAPE_CA_POLICY_URL),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_SSL_SERVER_NAME,
        IDS_EXT_NETSCAPE_SSL_SERVER_NAME),
    EXT_ATTR_ENTRY(szOID_NETSCAPE_COMMENT,
        IDS_EXT_NETSCAPE_COMMENT),
    EXT_ATTR_ENTRY(SPC_SP_AGENCY_INFO_OBJID,
        IDS_EXT_SPC_SP_AGENCY_INFO_OBJID),
    EXT_ATTR_ENTRY(SPC_FINANCIAL_CRITERIA_OBJID,
        IDS_EXT_SPC_FINANCIAL_CRITERIA_OBJID),
    EXT_ATTR_ENTRY(SPC_MINIMAL_CRITERIA_OBJID,
        IDS_EXT_SPC_MINIMAL_CRITERIA_OBJID),
    EXT_ATTR_ENTRY(szOID_COUNTRY_NAME,
        IDS_EXT_COUNTRY_NAME),
    EXT_ATTR_ENTRY(szOID_ORGANIZATION_NAME,
        IDS_EXT_ORGANIZATION_NAME),
    EXT_ATTR_ENTRY(szOID_ORGANIZATIONAL_UNIT_NAME,
        IDS_EXT_ORGANIZATIONAL_UNIT_NAME),
    EXT_ATTR_ENTRY(szOID_COMMON_NAME,
        IDS_EXT_COMMON_NAME),
    EXT_ATTR_ENTRY(szOID_LOCALITY_NAME,
        IDS_EXT_LOCALITY_NAME),
    EXT_ATTR_ENTRY(szOID_STATE_OR_PROVINCE_NAME,
        IDS_EXT_STATE_OR_PROVINCE_NAME),
    EXT_ATTR_ENTRY(szOID_TITLE,
        IDS_EXT_TITLE),
    EXT_ATTR_ENTRY(szOID_GIVEN_NAME,
        IDS_EXT_GIVEN_NAME),
    EXT_ATTR_ENTRY(szOID_INITIALS,
        IDS_EXT_INITIALS),
    EXT_ATTR_ENTRY(szOID_SUR_NAME,
        IDS_EXT_SUR_NAME),
    EXT_ATTR_ENTRY(szOID_DOMAIN_COMPONENT,
        IDS_EXT_DOMAIN_COMPONENT),
    EXT_ATTR_ENTRY(szOID_STREET_ADDRESS,
        IDS_EXT_STREET_ADDRESS),
    EXT_ATTR_ENTRY(szOID_DEVICE_SERIAL_NUMBER,
        IDS_EXT_DEVICE_SERIAL_NUMBER),
    EXT_ATTR_ENTRY(szOID_CERTSRV_CA_VERSION,
        IDS_EXT_CA_VERSION),
    EXT_ATTR_ENTRY(szOID_CERTSRV_CROSSCA_VERSION,
        IDS_EXT_CROSSCA_VERSION),
    EXT_ATTR_ENTRY(szOID_SERIALIZED,
        IDS_EXT_SERIALIZED),
    EXT_ATTR_ENTRY(szOID_NT_PRINCIPAL_NAME,
        IDS_EXT_NT_PRINCIPAL_NAME),
    EXT_ATTR_ENTRY(szOID_PRODUCT_UPDATE,
        IDS_EXT_PRODUCT_UPDATE),
    EXT_ATTR_ENTRY(szOID_ENROLLMENT_NAME_VALUE_PAIR,
        IDS_EXT_ENROLLMENT_NAME_VALUE_PAIR),
    EXT_ATTR_ENTRY(szOID_OS_VERSION,
        IDS_EXT_OS_VERSION),
    EXT_ATTR_ENTRY(szOID_ENROLLMENT_CSP_PROVIDER,
        IDS_EXT_ENROLLMENT_CSP_PROVIDER),
    EXT_ATTR_ENTRY(szOID_CRL_NUMBER,
        IDS_EXT_CRL_NUMBER),
    EXT_ATTR_ENTRY(szOID_DELTA_CRL_INDICATOR,
        IDS_EXT_DELTA_CRL_INDICATOR),
    EXT_ATTR_ENTRY(szOID_ISSUING_DIST_POINT,
        IDS_EXT_ISSUING_DIST_POINT),
    EXT_ATTR_ENTRY(szOID_FRESHEST_CRL,
        IDS_EXT_FRESHEST_CRL),
    EXT_ATTR_ENTRY(szOID_NAME_CONSTRAINTS,
        IDS_EXT_NAME_CONSTRAINTS),
    EXT_ATTR_ENTRY(szOID_POLICY_MAPPINGS,
        IDS_EXT_POLICY_MAPPINGS),
    EXT_ATTR_ENTRY(szOID_LEGACY_POLICY_MAPPINGS,
        IDS_EXT_POLICY_MAPPINGS),
    EXT_ATTR_ENTRY(szOID_POLICY_CONSTRAINTS,
        IDS_EXT_POLICY_CONSTRAINTS),
    EXT_ATTR_ENTRY(szOID_CROSS_CERT_DIST_POINTS,
        IDS_EXT_CROSS_CERT_DIST_POINTS),
    EXT_ATTR_ENTRY(szOID_APPLICATION_CERT_POLICIES,
        IDS_EXT_APP_POLICIES),
    EXT_ATTR_ENTRY(szOID_APPLICATION_POLICY_MAPPINGS,
        IDS_EXT_APP_POLICY_MAPPINGS),
    EXT_ATTR_ENTRY(szOID_APPLICATION_POLICY_CONSTRAINTS,
        IDS_EXT_APP_POLICY_CONSTRAINTS),


    // DSIE: Post Win2K, 8/2/2000.
    EXT_ATTR_ENTRY(szOID_CT_PKI_DATA,
        IDS_EXT_CT_PKI_DATA),
    EXT_ATTR_ENTRY(szOID_CT_PKI_RESPONSE,
        IDS_EXT_CT_PKI_RESPONSE),
    EXT_ATTR_ENTRY(szOID_CMC,
        IDS_EXT_CMC),
    EXT_ATTR_ENTRY(szOID_CMC_STATUS_INFO,
        IDS_EXT_CMC_STATUS_INFO),
    EXT_ATTR_ENTRY(szOID_CMC_ADD_EXTENSIONS,
        IDS_EXT_CMC_ADD_EXTENSIONS),
    EXT_ATTR_ENTRY(szOID_CMC_ADD_ATTRIBUTES,
        IDS_EXT_CMC_ADD_ATTRIBUTES),
    EXT_ATTR_ENTRY(szOID_CMC_ADD_ATTRIBUTES,
        IDS_EXT_CMC_ADD_ATTRIBUTES),

    EXT_ATTR_ENTRY(szOID_PKCS_7_DATA,
        IDS_EXT_PKCS_7_DATA),
    EXT_ATTR_ENTRY(szOID_PKCS_7_SIGNED,
        IDS_EXT_PKCS_7_SIGNED),
    EXT_ATTR_ENTRY(szOID_PKCS_7_ENVELOPED,
        IDS_EXT_PKCS_7_ENVELOPED),
    EXT_ATTR_ENTRY(szOID_PKCS_7_SIGNEDANDENVELOPED,
        IDS_EXT_PKCS_7_SIGNEDANDENVELOPED),
    EXT_ATTR_ENTRY(szOID_PKCS_7_DIGESTED,
        IDS_EXT_PKCS_7_DIGESTED),
    EXT_ATTR_ENTRY(szOID_PKCS_7_ENCRYPTED,
        IDS_EXT_PKCS_7_ENCRYPTED),

    EXT_ATTR_ENTRY(szOID_CERTSRV_PREVIOUS_CERT_HASH,
        IDS_EXT_CERTSRV_PREVIOUS_CERT_HASH),
    EXT_ATTR_ENTRY(szOID_CRL_VIRTUAL_BASE,
        IDS_EXT_CRL_VIRTUAL_BASE),
    EXT_ATTR_ENTRY(szOID_CRL_NEXT_PUBLISH,
        IDS_EXT_CRL_NEXT_PUBLISH),
    EXT_ATTR_ENTRY(szOID_KP_CA_EXCHANGE,
        IDS_EXT_KP_CA_EXCHANGE),
    EXT_ATTR_ENTRY(szOID_KP_KEY_RECOVERY_AGENT,
        IDS_EXT_KP_KEY_RECOVERY_AGENT),
    EXT_ATTR_ENTRY(szOID_CERTIFICATE_TEMPLATE,
        IDS_EXT_CERTIFICATE_TEMPLATE),
    EXT_ATTR_ENTRY(szOID_ENTERPRISE_OID_ROOT,
        IDS_EXT_ENTERPRISE_OID_ROOT),
    EXT_ATTR_ENTRY(szOID_RDN_DUMMY_SIGNER,
        IDS_EXT_RDN_DUMMY_SIGNER),

    EXT_ATTR_ENTRY(szOID_ARCHIVED_KEY_ATTR,
        IDS_EXT_ARCHIVED_KEY_ATTR),
    EXT_ATTR_ENTRY(szOID_CRL_SELF_CDP,
        IDS_EXT_CRL_SELF_CDP),
    EXT_ATTR_ENTRY(szOID_REQUIRE_CERT_CHAIN_POLICY,
        IDS_EXT_REQUIRE_CERT_CHAIN_POLICY),

    EXT_ATTR_ENTRY(szOID_CMC_TRANSACTION_ID,
	IDS_EXT_CMC_TRANSACTION_ID),
    EXT_ATTR_ENTRY(szOID_CMC_SENDER_NONCE,
	IDS_EXT_CMC_SENDER_NONCE),
    EXT_ATTR_ENTRY(szOID_CMC_RECIPIENT_NONCE,
	IDS_EXT_CMC_RECIPIENT_NONCE),
    EXT_ATTR_ENTRY(szOID_CMC_REG_INFO,
	IDS_EXT_CMC_REG_INFO),
    EXT_ATTR_ENTRY(szOID_CMC_GET_CERT,
	IDS_EXT_CMC_GET_CERT),
    EXT_ATTR_ENTRY(szOID_CMC_GET_CRL,
	IDS_EXT_CMC_GET_CRL),
    EXT_ATTR_ENTRY(szOID_CMC_REVOKE_REQUEST,
	IDS_EXT_CMC_REVOKE_REQUEST),
    EXT_ATTR_ENTRY(szOID_CMC_QUERY_PENDING,
	IDS_EXT_CMC_QUERY_PENDING),
    EXT_ATTR_ENTRY(szOID_CTL,
	IDS_EXT_CTL),
    EXT_ATTR_ENTRY(szOID_ARCHIVED_KEY_CERT_HASH,
	IDS_EXT_ARCHIVED_KEY_CERT_HASH),
    EXT_ATTR_ENTRY(szOID_PRIVATEKEY_USAGE_PERIOD,
	IDS_EXT_PRIVATEKEY_USAGE_PERIOD),
    EXT_ATTR_ENTRY(szOID_REQUEST_CLIENT_INFO,
	IDS_EXT_REQUEST_CLIENT_INFO),
};


#define EXT_ATTR_CNT (sizeof(ExtAttrTable) / sizeof(ExtAttrTable[0]))

//+-------------------------------------------------------------------------
//  Enhanced Key Usage Table (Localized via resource strings)
//--------------------------------------------------------------------------
#define ENHKEY_ENTRY(pszOID, ResourceIdORpwszName) \
    OID_INFO_LEN, pszOID, (LPCWSTR) ResourceIdORpwszName, \
        CRYPT_ENHKEY_USAGE_OID_GROUP_ID, 0, 0, NULL

static CRYPT_OID_INFO EnhKeyTable[] = {
    ENHKEY_ENTRY(szOID_PKIX_KP_SERVER_AUTH,
        IDS_ENHKEY_PKIX_KP_SERVER_AUTH),
    ENHKEY_ENTRY(szOID_PKIX_KP_CLIENT_AUTH,
        IDS_ENHKEY_PKIX_KP_CLIENT_AUTH),
    ENHKEY_ENTRY(szOID_PKIX_KP_CODE_SIGNING,
        IDS_ENHKEY_PKIX_KP_CODE_SIGNING),
    ENHKEY_ENTRY(szOID_PKIX_KP_EMAIL_PROTECTION,
        IDS_ENHKEY_PKIX_KP_EMAIL_PROTECTION),
    ENHKEY_ENTRY(szOID_PKIX_KP_TIMESTAMP_SIGNING,
        IDS_ENHKEY_PKIX_KP_TIMESTAMP_SIGNING),
    ENHKEY_ENTRY(szOID_KP_CTL_USAGE_SIGNING,
        IDS_ENHKEY_KP_CTL_USAGE_SIGNING),
    ENHKEY_ENTRY(szOID_KP_TIME_STAMP_SIGNING,
        IDS_ENHKEY_KP_TIME_STAMP_SIGNING),
    ENHKEY_ENTRY(szOID_PKIX_KP_IPSEC_END_SYSTEM,
        IDS_ENHKEY_PKIX_KP_IPSEC_END_SYSTEM),
    ENHKEY_ENTRY(szOID_PKIX_KP_IPSEC_TUNNEL,
        IDS_ENHKEY_PKIX_KP_IPSEC_TUNNEL),
    ENHKEY_ENTRY(szOID_PKIX_KP_IPSEC_USER,
        IDS_ENHKEY_PKIX_KP_IPSEC_USER),
   // ENHKEY_ENTRY(szOID_SERVER_GATED_CRYPTO,
   //     IDS_ENHKEY_SERVER_GATED_CRYPTO),
   // ENHKEY_ENTRY(szOID_SGC_NETSCAPE,
   //     IDS_ENHKEY_SGC_NETSCAPE),
    ENHKEY_ENTRY(szOID_KP_EFS,
        IDS_ENHKEY_KP_EFS),
    ENHKEY_ENTRY(szOID_WHQL_CRYPTO,
        IDS_ENHKEY_KP_WHQL),
    ENHKEY_ENTRY(szOID_NT5_CRYPTO,
        IDS_ENHKEY_KP_NT5),
    ENHKEY_ENTRY(szOID_OEM_WHQL_CRYPTO,
        IDS_ENHKEY_KP_OEM_WHQL),
    ENHKEY_ENTRY(szOID_EMBEDDED_NT_CRYPTO,
        IDS_ENHKEY_KP_EMBEDDED_NT),
    ENHKEY_ENTRY(szOID_LICENSES,
	IDS_ENHKEY_LICENSES),
    ENHKEY_ENTRY(szOID_LICENSE_SERVER,
	IDS_ENHKEY_LICENSES_SERVER),
    ENHKEY_ENTRY(szOID_KP_SMARTCARD_LOGON,
	IDS_ENHKEY_SMARTCARD_LOGON),
    ENHKEY_ENTRY(szOID_DRM,
	IDS_ENHKEY_DRM),
    ENHKEY_ENTRY(szOID_KP_QUALIFIED_SUBORDINATION,
        IDS_ENHKEY_KP_QUALIFIED_SUBORDINATION),
    ENHKEY_ENTRY(szOID_KP_KEY_RECOVERY,
        IDS_ENHKEY_KP_KEY_RECOVERY),
    ENHKEY_ENTRY(szOID_KP_DOCUMENT_SIGNING,
        IDS_ENHKEY_KP_CODE_SIGNING),
    ENHKEY_ENTRY(szOID_IPSEC_KP_IKE_INTERMEDIATE,
        IDS_ENHKEY_KP_IPSEC_IKE_INTERMEDIATE),
    ENHKEY_ENTRY(szOID_EFS_RECOVERY,
        IDS_ENHKEY_EFS_RECOVERY),

    //DSIE: 8/2/2000, Post Win2K.
    ENHKEY_ENTRY(szOID_ROOT_LIST_SIGNER,
        IDS_ENHKEY_ROOT_LIST_SIGNER),
    ENHKEY_ENTRY(szOID_ANY_APPLICATION_POLICY,
        IDS_ENHKEY_ANY_POLICY),
    ENHKEY_ENTRY(szOID_DS_EMAIL_REPLICATION,
        IDS_ENHKEY_DS_EMAIL_REPLICATION),
    ENHKEY_ENTRY(szOID_ENROLLMENT_AGENT,
        IDS_ENHKEY_ENROLLMENT_AGENT),
    ENHKEY_ENTRY(szOID_KP_KEY_RECOVERY_AGENT,
        IDS_ENHKEY_KP_KEY_RECOVERY_AGENT),
    ENHKEY_ENTRY(szOID_KP_CA_EXCHANGE,
        IDS_ENHKEY_KP_CA_EXCHANGE),
    ENHKEY_ENTRY(szOID_KP_LIFETIME_SIGNING,
        IDS_ENHKEY_KP_LIFETIME_SIGNING),
};
#define ENHKEY_CNT (sizeof(EnhKeyTable) / sizeof(EnhKeyTable[0]))

//+-------------------------------------------------------------------------
//  Policy Table (Localized via resource strings)
//--------------------------------------------------------------------------
#define POLICY_ENTRY(pszOID, ResourceIdORpwszName) \
    OID_INFO_LEN, pszOID, (LPCWSTR) ResourceIdORpwszName, \
        CRYPT_POLICY_OID_GROUP_ID, 0, 0, NULL

static CRYPT_OID_INFO PolicyTable[] = {
    POLICY_ENTRY(szOID_ANY_CERT_POLICY,
        IDS_POLICY_ANY_POLICY),
};
#define POLICY_CNT (sizeof(PolicyTable) / sizeof(PolicyTable[0]))

#if 0

//+-------------------------------------------------------------------------
//  Template Table (Localized via resource strings)
//--------------------------------------------------------------------------
#define TEMPLATE_ENTRY(pszOID, ResourceIdORpwszName) \
    OID_INFO_LEN, pszOID, (LPCWSTR) ResourceIdORpwszName, \
        CRYPT_TEMPLATE_OID_GROUP_ID, 0, 0, NULL

static CRYPT_OID_INFO TemplateTable[] = {
};
#define TEMPLATE_CNT (sizeof(TemplateTable) / sizeof(TemplateTable[0]))

#endif


//+=========================================================================
//  OID Group Tables
//
//  fLocalize is set to TRUE, if the CRYPT_OID_INFO's pwszName may be
//  a Resource ID that is used to get the localized name via LoadStringU().
//
//  Assumption, Resource ID's <= 0xFFFF.
//==========================================================================
typedef struct _GROUP_ENTRY {
    DWORD               cInfo;
    PCCRYPT_OID_INFO    rgInfo;
    BOOL                fLocalize;
} GROUP_ENTRY, *PGROUP_ENTRY;
typedef const GROUP_ENTRY CGROUP_ENTRY, *PCGROUP_ENTRY;

static CGROUP_ENTRY GroupTable[CRYPT_LAST_OID_GROUP_ID + 1] = {
    0, NULL, FALSE,                             // 0
    HASH_ALG_CNT, HashAlgTable, FALSE,          // 1
    ENCRYPT_ALG_CNT, EncryptAlgTable, FALSE,    // 2
    PUBKEY_ALG_CNT, PubKeyAlgTable, FALSE,      // 3
    SIGN_ALG_CNT, SignAlgTable, FALSE,          // 4
    RDN_ATTR_CNT, RDNAttrTable, FALSE,          // 5
    EXT_ATTR_CNT, ExtAttrTable, TRUE,           // 6
    ENHKEY_CNT, EnhKeyTable, TRUE,              // 7
    POLICY_CNT, PolicyTable, TRUE,              // 8
#if 0
    TEMPLATE_CNT, TemplateTable, TRUE,          // 9
#else
    0, NULL, FALSE,                             // 9
#endif
};


//+-------------------------------------------------------------------------
//  The following groups are dynamically updated from the registry on
//  CryptFindOIDInfo's first call.
//--------------------------------------------------------------------------
static GROUP_ENTRY RegBeforeGroup;
static GROUP_ENTRY RegAfterGroup;

// Do the load once within a critical section
static BOOL fLoadedFromRegAndResources = FALSE;
static CRITICAL_SECTION LoadFromRegCriticalSection;


//+=========================================================================
//  DS Group Definitions and Data Structures
//==========================================================================

typedef struct _DS_GROUP_ENTRY {
    DWORD               cInfo;
    PCCRYPT_OID_INFO    *rgpInfo;
} DS_GROUP_ENTRY, *PDS_GROUP_ENTRY;
typedef const DS_GROUP_ENTRY CDS_GROUP_ENTRY, *PCDS_GROUP_ENTRY;

// The DS group is dynamically updated from the DS on the first call
// to CryptFindOIDInfo or CryptEnumOIDInfo for the ENHKEY, POLICY or
// TEMPLATE groups.
static DS_GROUP_ENTRY DsGroup;

// The above DsGroup is updated every DS_RETRIEVAL_DELTA_SECONDS. Since
// any returned PCCRYPT_OID_INFO can not be freed, the following group contains
// PCCRYPT_OID_INFO entries that may have been deleted from the above DS group.
static DS_GROUP_ENTRY DsDeletedGroup;

static CRITICAL_SECTION DsCriticalSection;

// For a successful DS retrieval, the following is updated with
// CurrentTime + DS_RETRIEVAL_DELTA_SECONDS.
static FILETIME DsNextUpdateTime;

#define DS_RETRIEVAL_DELTA_SECONDS  (60 * 60 * 8)
#define DS_LDAP_TIMEOUT             (10 * 1000)


static void FreeDsGroups();

static PCCRYPT_OID_INFO SearchDsGroup(
    IN DWORD dwKeyType,
    IN void *pvKey,
    IN DWORD dwGroupId
    );

static BOOL EnumDsGroup(
    IN DWORD dwGroupId,
    IN void *pvArg,
    IN PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo
    );


//+=========================================================================
//  Localized Name Definitions and Data Structures
//==========================================================================

//+-------------------------------------------------------------------------
//  Localized Name Information
//--------------------------------------------------------------------------
typedef struct _LOCALIZED_NAME_INFO {
    LPCWSTR         pwszCryptName;
    union {
        UINT            uIDLocalizedName;
        LPCWSTR         pwszLocalizedName;
    };
} LOCALIZED_NAME_INFO, *PLOCALIZED_NAME_INFO;


//+-------------------------------------------------------------------------
//  Predefined Localized Names Table (Localized via resource strings)
//--------------------------------------------------------------------------
static LOCALIZED_NAME_INFO PredefinedNameTable[] = {
    // System store names
    L"Root",        IDS_SYS_NAME_ROOT,
    L"My",          IDS_SYS_NAME_MY,
    L"Trust",       IDS_SYS_NAME_TRUST,
    L"CA",          IDS_SYS_NAME_CA,
    L"UserDS",      IDS_SYS_NAME_USERDS,
    L"SmartCard",   IDS_SYS_NAME_SMARTCARD,
    L"AddressBook", IDS_SYS_NAME_ADDRESSBOOK,
    L"TrustedPublisher", IDS_SYS_NAME_TRUST_PUB,
    L"Disallowed",  IDS_SYS_NAME_DISALLOWED,
    L"AuthRoot",    IDS_SYS_NAME_AUTH_ROOT,
    L"Request",     IDS_SYS_NAME_REQUEST,
    L"TrustedPeople", IDS_SYS_NAME_TRUST_PEOPLE,

    // Physical store names
    CERT_PHYSICAL_STORE_DEFAULT_NAME,           IDS_PHY_NAME_DEFAULT,
    CERT_PHYSICAL_STORE_GROUP_POLICY_NAME,      IDS_PHY_NAME_GROUP_POLICY,
    CERT_PHYSICAL_STORE_LOCAL_MACHINE_NAME,     IDS_PHY_NAME_LOCAL_MACHINE,
    CERT_PHYSICAL_STORE_DS_USER_CERTIFICATE_NAME, IDS_PHY_NAME_DS_USER_CERT,
    CERT_PHYSICAL_STORE_ENTERPRISE_NAME,        IDS_PHY_NAME_ENTERPRISE,
    CERT_PHYSICAL_STORE_AUTH_ROOT_NAME,         IDS_PHY_NAME_AUTH_ROOT,
};
#define PREDEFINED_NAME_CNT  (sizeof(PredefinedNameTable) / \
                                    sizeof(PredefinedNameTable[0]))

//+-------------------------------------------------------------------------
//  Localized Name Group Table
//--------------------------------------------------------------------------
typedef struct _LOCALIZED_GROUP_ENTRY {
    DWORD                   cInfo;
    PLOCALIZED_NAME_INFO    rgInfo;
} LOCALIZED_GROUP_ENTRY, *PLOCALIZED_GROUP_ENTRY;

#define REG_LOCALIZED_GROUP             0
#define PREDEFINED_LOCALIZED_GROUP      1
static LOCALIZED_GROUP_ENTRY LocalizedGroupTable[] = {
    // 0 - Loaded from registry
    0, NULL,
    // 1 - Predefined list of names
    PREDEFINED_NAME_CNT, PredefinedNameTable
};
#define LOCALIZED_GROUP_CNT  (sizeof(LocalizedGroupTable) / \
                                    sizeof(LocalizedGroupTable[0]))

// The localized names are loaded once. Uses the above
// LoadFromRegCriticalSection;
static BOOL fLoadedLocalizedNames = FALSE;


//+-------------------------------------------------------------------------
//  OIDInfo allocation and free functions
//--------------------------------------------------------------------------
static void *OIDInfoAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

static void *OIDInfoRealloc(
    IN void *pvOrg,
    IN size_t cb
    )
{
    void *pv;
    if (NULL == (pv = pvOrg ? realloc(pvOrg, cb) : malloc(cb)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

static void OIDInfoFree(
    IN void *pv
    )
{
    free(pv);
}

//+-------------------------------------------------------------------------
//  Functions called at ProcessDetach to free the groups updated from the
//  registry during CryptFindOIDInfo's first call.
//--------------------------------------------------------------------------
static void FreeGroup(
    PGROUP_ENTRY pGroup
    )
{
    DWORD cInfo = pGroup->cInfo;
    PCCRYPT_OID_INFO pInfo = pGroup->rgInfo;
    for ( ; cInfo > 0; cInfo--, pInfo++)
        OIDInfoFree((LPSTR)pInfo->pszOID);

    OIDInfoFree((PCRYPT_OID_INFO) pGroup->rgInfo);
}

static void FreeRegGroups()
{
    FreeGroup(&RegBeforeGroup);
    FreeGroup(&RegAfterGroup);
}

//+-------------------------------------------------------------------------
//  Free resource strings allocated in groups having localized pwszName's.
//--------------------------------------------------------------------------
static void FreeGroupResources()
{
    DWORD i;
    if (!fLoadedFromRegAndResources)
        // No resource strings allocated
        return;

    for (i = 1; i <= CRYPT_LAST_OID_GROUP_ID; i++) {
        if (GroupTable[i].fLocalize) {
            DWORD cInfo = GroupTable[i].cInfo;
            PCRYPT_OID_INFO pInfo = (PCRYPT_OID_INFO) GroupTable[i].rgInfo;

            for ( ; cInfo > 0; cInfo--, pInfo++) {
                // pwszName is set to pwszNullName if the allocation failed
                if (pwszNullName != pInfo->pwszName) {
                    OIDInfoFree((LPWSTR) pInfo->pwszName);
                    pInfo->pwszName = pwszNullName;
                }
            }
        }
    }
}

//+-------------------------------------------------------------------------
//  Free memory allocated for localized names
//--------------------------------------------------------------------------
static void FreeLocalizedNames()
{
    if (!fLoadedLocalizedNames)
        // No resource strings allocated
        return;

    for (DWORD i = 0; i < LOCALIZED_GROUP_CNT; i++) {
        DWORD cInfo = LocalizedGroupTable[i].cInfo;
        PLOCALIZED_NAME_INFO pInfo = LocalizedGroupTable[i].rgInfo;

        for ( ; cInfo > 0; cInfo--, pInfo++) {
            LPWSTR pwszLocalizedName = (LPWSTR) pInfo->pwszLocalizedName;
            if (pwszNullName != pwszLocalizedName)
                OIDInfoFree(pwszLocalizedName);
        }
    }

    OIDInfoFree(LocalizedGroupTable[REG_LOCALIZED_GROUP].rgInfo);
}

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptOIDInfoDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL fRet = TRUE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        hOIDInfoInst = hInst;
        fRet = Pki_InitializeCriticalSection(&LoadFromRegCriticalSection);
        if (fRet) {
            fRet = Pki_InitializeCriticalSection(&DsCriticalSection);
            if (!fRet)
                DeleteCriticalSection(&LoadFromRegCriticalSection);
        }
        break;

    case DLL_PROCESS_DETACH:
        FreeRegGroups();
        FreeGroupResources();
        FreeLocalizedNames();
        DeleteCriticalSection(&LoadFromRegCriticalSection);

        FreeDsGroups();
        DeleteCriticalSection(&DsCriticalSection);
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return fRet;
}


//+-------------------------------------------------------------------------
//  Allocated and format the string consisting of the OID and GROUP_ID:
//
//  For example: 1.2.3.4!6
//--------------------------------------------------------------------------
static LPSTR FormatOIDGroupString(
    IN PCCRYPT_OID_INFO pInfo
    )
{
    LPSTR pszOIDGroupString;
    DWORD cchOIDGroupString;
    char szGroupId[34];

    if (NULL == pInfo || pInfo->cbSize < sizeof(CRYPT_OID_INFO) ||
            (DWORD_PTR) pInfo->pszOID <= 0xFFFF) {
        SetLastError((DWORD) E_INVALIDARG);
        return NULL;
    }

    szGroupId[0] = CONST_OID_GROUP_PREFIX_CHAR;
    _ltoa((long) pInfo->dwGroupId, &szGroupId[1], 10);

    cchOIDGroupString = strlen(pInfo->pszOID) +
        strlen(szGroupId) +
        1;

    if (pszOIDGroupString = (LPSTR) OIDInfoAlloc(cchOIDGroupString)) {
        strcpy(pszOIDGroupString, pInfo->pszOID);
        strcat(pszOIDGroupString, szGroupId);
    }

    return pszOIDGroupString;
}

//+-------------------------------------------------------------------------
//  Wrapper function for calling CryptSetOIDFunctionValue using OID info's
//  encoding type and function name.
//--------------------------------------------------------------------------
static BOOL SetOIDInfoRegValue(
    IN LPCSTR pszOIDGroupString,
    IN LPCWSTR pwszValueName,
    IN DWORD dwValueType,
    IN const BYTE *pbValueData,
    IN DWORD cbValueData
    )
{
    return CryptSetOIDFunctionValue(
        OID_INFO_ENCODING_TYPE,
        CRYPT_OID_FIND_OID_INFO_FUNC,
        pszOIDGroupString,
        pwszValueName,
        dwValueType,
        pbValueData,
        cbValueData
        );
}

//+-------------------------------------------------------------------------
//  Register OID information.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptRegisterOIDInfo(
    IN PCCRYPT_OID_INFO pInfo,
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    LPSTR pszOIDGroupString = NULL;

    if (NULL == (pszOIDGroupString = FormatOIDGroupString(pInfo)))
        goto FormatOIDGroupStringError;

    if (pInfo->pwszName && L'\0' != *pInfo->pwszName) {
        if (!SetOIDInfoRegValue(
                pszOIDGroupString,
                OID_INFO_NAME_VALUE_NAME,
                REG_SZ,
                (const BYTE *) pInfo->pwszName,
                (wcslen(pInfo->pwszName) + 1) * sizeof(WCHAR)
                )) goto SetOIDInfoRegValueError;
    }
    if (0 != pInfo->Algid) {
        if (!SetOIDInfoRegValue(
                pszOIDGroupString,
                OID_INFO_ALGID_VALUE_NAME,
                REG_DWORD,
                (const BYTE *) &pInfo->Algid,
                sizeof(pInfo->Algid)
                )) goto SetOIDInfoRegValueError;
    }
    if (0 != pInfo->ExtraInfo.cbData) {
        if (!SetOIDInfoRegValue(
                pszOIDGroupString,
                OID_INFO_EXTRA_INFO_VALUE_NAME,
                REG_BINARY,
                pInfo->ExtraInfo.pbData,
                pInfo->ExtraInfo.cbData
                )) goto SetOIDInfoRegValueError;
    }

    if (0 != dwFlags) {
        if (!SetOIDInfoRegValue(
                pszOIDGroupString,
                OID_INFO_FLAGS_VALUE_NAME,
                REG_DWORD,
                (const BYTE *) &dwFlags,
                sizeof(dwFlags)
                )) goto SetOIDInfoRegValueError;
    }

    fResult = TRUE;
CommonReturn:
    OIDInfoFree(pszOIDGroupString);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(FormatOIDGroupStringError)
TRACE_ERROR(SetOIDInfoRegValueError)
}

//+-------------------------------------------------------------------------
//  Unregister OID information. Only the pszOID and dwGroupId fields are
//  used to identify the OID information to be unregistered.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptUnregisterOIDInfo(
    IN PCCRYPT_OID_INFO pInfo
    )
{
    BOOL fResult;
    LPSTR pszOIDGroupString = NULL;

    if (NULL == (pszOIDGroupString = FormatOIDGroupString(pInfo)))
        goto FormatOIDGroupStringError;
    if (!CryptUnregisterOIDFunction(
            OID_INFO_ENCODING_TYPE,
            CRYPT_OID_FIND_OID_INFO_FUNC,
            pszOIDGroupString
            ))
        goto UnregisterOIDFunctionError;
    fResult = TRUE;
CommonReturn:
    OIDInfoFree(pszOIDGroupString);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(FormatOIDGroupStringError)
TRACE_ERROR(UnregisterOIDFunctionError)
}

//+-------------------------------------------------------------------------
//  Called by CryptEnumOIDFunction to enumerate through all the
//  registered OID information.
//
//  Called within critical section
//--------------------------------------------------------------------------
static BOOL WINAPI EnumRegistryCallback(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN DWORD cValue,
    IN const DWORD rgdwValueType[],
    IN LPCWSTR const rgpwszValueName[],
    IN const BYTE * const rgpbValueData[],
    IN const DWORD rgcbValueData[],
    IN void *pvArg
    )
{
    DWORD cchOID;
    LPCWSTR pwszName = NULL;
    DWORD cchName = 0;
    LPCSTR pszGroupId;
    DWORD dwGroupId = 0;
    ALG_ID Algid = 0;
    CRYPT_DATA_BLOB ExtraInfo = {0, NULL};
    DWORD dwFlags = 0;
    DWORD cbExtra;
    BYTE *pbExtra;
    PGROUP_ENTRY pGroup;
    PCRYPT_OID_INFO pInfo;

    // The pszOID consists of OID!<dwGroupId>, for example, 1.2.3!1
    // Start at the end and search for the '!'
    cchOID = strlen(pszOID);
    pszGroupId = pszOID + cchOID;
    while (pszGroupId > pszOID && CONST_OID_GROUP_PREFIX_CHAR != *pszGroupId)
        pszGroupId--;

    if (CONST_OID_GROUP_PREFIX_CHAR == *pszGroupId) {
        cchOID = (DWORD)(pszGroupId - pszOID);
        dwGroupId = (DWORD) atol(pszGroupId + 1);
    } else
        // Name is missing "!". Skip It.
        return TRUE;

    while (cValue--) {
        LPCWSTR pwszValueName = rgpwszValueName[cValue];
        DWORD dwValueType = rgdwValueType[cValue];
        const BYTE *pbValueData = rgpbValueData[cValue];
        DWORD cbValueData = rgcbValueData[cValue];

        if (0 == _wcsicmp(pwszValueName, OID_INFO_NAME_VALUE_NAME)) {
            if (REG_SZ == dwValueType) {
                pwszName = (LPWSTR) pbValueData;
                cchName = wcslen(pwszName);
            }
        } else if (0 == _wcsicmp(pwszValueName, OID_INFO_ALGID_VALUE_NAME)) {
            if (REG_DWORD == dwValueType &&
                    cbValueData >= sizeof(Algid))
                memcpy(&Algid, pbValueData, sizeof(Algid));
        } else if (0 == _wcsicmp(pwszValueName,
                OID_INFO_EXTRA_INFO_VALUE_NAME)) {
            if (REG_BINARY == dwValueType) {
                ExtraInfo.cbData = cbValueData;
                ExtraInfo.pbData = (BYTE *) pbValueData;
            }
        } else if (0 == _wcsicmp(pwszValueName, OID_INFO_FLAGS_VALUE_NAME)) {
            if (REG_DWORD == dwValueType &&
                    cbValueData >= sizeof(dwFlags))
                memcpy(&dwFlags, pbValueData, sizeof(dwFlags));
        }
    }

    cbExtra = LEN_ALIGN(cchOID + 1) +
        LEN_ALIGN((cchName + 1) * sizeof(WCHAR)) +
        ExtraInfo.cbData;
    if (NULL == (pbExtra = (BYTE *) OIDInfoAlloc(cbExtra)))
        return FALSE;

    if (dwFlags & CRYPT_INSTALL_OID_INFO_BEFORE_FLAG)
        pGroup = &RegBeforeGroup;
    else
        pGroup = &RegAfterGroup;

    if (NULL == (pInfo = (PCRYPT_OID_INFO) OIDInfoRealloc(
            (PCRYPT_OID_INFO) pGroup->rgInfo,
            (pGroup->cInfo + 1) * sizeof(CRYPT_OID_INFO)))) {
        OIDInfoFree(pbExtra);
        return FALSE;
    }
    pGroup->rgInfo = pInfo;
    pInfo = &pInfo[pGroup->cInfo++];

    pInfo->cbSize = sizeof(CRYPT_OID_INFO);
    pInfo->pszOID = (LPCSTR) pbExtra;
    if (cchOID)
        memcpy(pbExtra, pszOID, cchOID);
    *( ((LPSTR) pbExtra) + cchOID) = '\0';
    pbExtra += LEN_ALIGN(cchOID + 1);

    pInfo->pwszName = (LPCWSTR) pbExtra;
    if (cchName)
        memcpy(pbExtra, pwszName, (cchName + 1) * sizeof(WCHAR));
    else
        *((LPWSTR) pbExtra) = L'\0';
    pbExtra += LEN_ALIGN((cchName + 1) * sizeof(WCHAR));

    pInfo->dwGroupId = dwGroupId;
    pInfo->Algid = Algid;
    pInfo->ExtraInfo.cbData = ExtraInfo.cbData;
    if (ExtraInfo.cbData > 0) {
        pInfo->ExtraInfo.pbData = pbExtra;
        memcpy(pbExtra, ExtraInfo.pbData, ExtraInfo.cbData);
    } else
        pInfo->ExtraInfo.pbData = NULL;

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Allocate and load the string for the specified resource.
//
//  If LoadString or allocation fails, returns predefined pointer to an
//  empty string.
//--------------------------------------------------------------------------
static LPWSTR AllocAndLoadOIDNameString(
    IN UINT uID
    )
{
    WCHAR wszResource[MAX_RESOURCE_OID_NAME_LENGTH + 1];
    int cchResource;
    int cbResource;
    LPWSTR pwszDst;

    cchResource = LoadStringU(hOIDInfoInst, uID, wszResource,
        MAX_RESOURCE_OID_NAME_LENGTH);
    assert(0 < cchResource);
    if (0 >= cchResource)
        return (LPWSTR) pwszNullName;

    cbResource = (cchResource + 1) * sizeof(WCHAR);
    pwszDst = (LPWSTR) OIDInfoAlloc(cbResource);
    assert(pwszDst);
    if (NULL == pwszDst)
        return (LPWSTR) pwszNullName;
    memcpy((BYTE *) pwszDst, (BYTE *) wszResource, cbResource);
    return pwszDst;
}

//+-------------------------------------------------------------------------
//  Allocate and copy the string.
//
//  If allocation fails, returns predefined pointer to an empty string.
//--------------------------------------------------------------------------
static LPWSTR AllocAndCopyOIDNameString(
    IN LPCWSTR pwszSrc
    )
{
    DWORD cbSrc;
    LPWSTR pwszDst;

    cbSrc = (wcslen(pwszSrc) + 1) * sizeof(WCHAR);
    pwszDst = (LPWSTR) OIDInfoAlloc(cbSrc);
    assert(pwszDst);
    if (NULL == pwszDst)
        return (LPWSTR) pwszNullName;
    memcpy((BYTE *) pwszDst, (BYTE *) pwszSrc, cbSrc);
    return pwszDst;
}

//+-------------------------------------------------------------------------
//  Does a LoadString for pwszName's initialized with resource IDs in groups
//  with fLocalize set.
//--------------------------------------------------------------------------
static void LoadGroupResources()
{
    DWORD i;
    for (i = 1; i <= CRYPT_LAST_OID_GROUP_ID; i++) {
        if (GroupTable[i].fLocalize) {
            DWORD cInfo = GroupTable[i].cInfo;
            PCRYPT_OID_INFO pInfo = (PCRYPT_OID_INFO) GroupTable[i].rgInfo;
            for ( ; cInfo > 0; cInfo--, pInfo++) {
                UINT_PTR uID;
                uID = (UINT_PTR) pInfo->pwszName;
                if (uID <= 0xFFFF)
                    pInfo->pwszName = AllocAndLoadOIDNameString((UINT)uID);
                else
                    // ProcessDetach expects all pwszName's to be allocated
                    pInfo->pwszName = AllocAndCopyOIDNameString(
                        pInfo->pwszName);
            }
        }
    }
}

//+-------------------------------------------------------------------------
//  Load OID Information from the registry. Updates the RegBeforeGroup and
//  RegAfterGroup.
//
//  Loads resource strings in groups enabling localization of pwszName's.
//--------------------------------------------------------------------------
static void LoadFromRegistryAndResources()
{
    if (fLoadedFromRegAndResources)
        return;

    EnterCriticalSection(&LoadFromRegCriticalSection);
    if (!fLoadedFromRegAndResources) {
        CryptEnumOIDFunction(
            OID_INFO_ENCODING_TYPE,
            CRYPT_OID_FIND_OID_INFO_FUNC,
            NULL,                           // pszOID
            0,                              // dwFlags
            NULL,                           // pvArg
            EnumRegistryCallback
            );
        LoadGroupResources();
        fLoadedFromRegAndResources = TRUE;
    }
    LeaveCriticalSection(&LoadFromRegCriticalSection);
}

//+-------------------------------------------------------------------------
//  Compare the OID info according to the specified key and group.
//--------------------------------------------------------------------------
static BOOL CompareOIDInfo(
    IN DWORD dwKeyType,
    IN void *pvKey,
    IN DWORD dwGroupId,
    IN PCCRYPT_OID_INFO pInfo
    )
{
    if (dwGroupId && dwGroupId != pInfo->dwGroupId)
        return FALSE;

    switch (dwKeyType) {
        case CRYPT_OID_INFO_OID_KEY:
            if (0 == _stricmp((LPSTR) pvKey, pInfo->pszOID))
                return TRUE;
            break;
        case CRYPT_OID_INFO_NAME_KEY:
            if (0 == _wcsicmp((LPWSTR) pvKey, pInfo->pwszName))
                return TRUE;
            break;
        case CRYPT_OID_INFO_ALGID_KEY:
            if (*((ALG_ID *) pvKey) == pInfo->Algid)
                return TRUE;
            break;
        case CRYPT_OID_INFO_SIGN_KEY:
            {
                ALG_ID *paiKey = (ALG_ID *) pvKey;
                ALG_ID aiPubKey;

                if (sizeof(ALG_ID) <= pInfo->ExtraInfo.cbData)
                    aiPubKey = *((ALG_ID *) pInfo->ExtraInfo.pbData);
                else
                    aiPubKey = 0;

                if (paiKey[0] == pInfo->Algid &&
                        paiKey[1] == aiPubKey)
                return TRUE;
            }
            break;
        default:
            SetLastError((DWORD) E_INVALIDARG);
            return FALSE;
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//  Search the group according to the specified dwKeyType.
//
//  Note, the groups updated from the registry, RegBeforeGroup and
//  RegAfterGroup, may contain any GROUP_ID.
//--------------------------------------------------------------------------
static PCCRYPT_OID_INFO SearchGroup(
    IN DWORD dwKeyType,
    IN void *pvKey,
    IN DWORD dwGroupId,
    IN PCGROUP_ENTRY pGroup
    )
{
    DWORD cInfo = pGroup->cInfo;
    PCCRYPT_OID_INFO pInfo = pGroup->rgInfo;
    for ( ; cInfo > 0; cInfo--, pInfo++) {
        if (CompareOIDInfo(
                dwKeyType,
                pvKey,
                dwGroupId,
                pInfo
                ))
            return pInfo;
    }

    return NULL;
}

//+-------------------------------------------------------------------------
//  Find OID information. Returns NULL if unable to find any information
//  for the specified key and group.
//--------------------------------------------------------------------------
PCCRYPT_OID_INFO
WINAPI
CryptFindOIDInfo(
    IN DWORD dwKeyType,
    IN void *pvKey,
    IN DWORD dwGroupId      // 0 => any group
    )
{
    PCCRYPT_OID_INFO pInfo;

    LoadFromRegistryAndResources();

    if (RegBeforeGroup.cInfo && NULL != (pInfo = SearchGroup(
            dwKeyType,
            pvKey,
            dwGroupId,
            &RegBeforeGroup
            ))) return pInfo;
    if (0 == dwGroupId) {
        DWORD i;
        for (i = 1; i <= CRYPT_LAST_OID_GROUP_ID; i++) {
            if (pInfo = SearchGroup(
                dwKeyType,
                pvKey,
                0,
                &GroupTable[i]
                )) return pInfo;
        }
    } else if (dwGroupId <= CRYPT_LAST_OID_GROUP_ID) {
        if (pInfo = SearchGroup(
                dwKeyType,
                pvKey,
                dwGroupId,
                &GroupTable[dwGroupId]
                )) return pInfo;
    }

    if (RegAfterGroup.cInfo && NULL != (pInfo = SearchGroup(
            dwKeyType,
            pvKey,
            dwGroupId,
            &RegAfterGroup
            ))) return pInfo;

    return SearchDsGroup(
            dwKeyType,
            pvKey,
            dwGroupId
            );
}


//+-------------------------------------------------------------------------
//  Enumerate the group.
//--------------------------------------------------------------------------
static BOOL EnumGroup(
    IN DWORD dwGroupId,
    IN PCGROUP_ENTRY pGroup,
    IN void *pvArg,
    IN PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo
    )
{
    DWORD cInfo = pGroup->cInfo;
    PCCRYPT_OID_INFO pInfo = pGroup->rgInfo;
    for ( ; cInfo > 0; cInfo--, pInfo++) {
        if (dwGroupId && dwGroupId != pInfo->dwGroupId)
            continue;

        if (!pfnEnumOIDInfo(pInfo, pvArg))
            return FALSE;
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Enumerate the OID information.
//
//  pfnEnumOIDInfo is called for each OID information entry.
//
//  Setting dwGroupId to 0 matches all groups. Otherwise, only enumerates
//  entries in the specified group.
//
//  dwFlags currently isn't used and must be set to 0.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptEnumOIDInfo(
    IN DWORD dwGroupId,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo
    )
{
    LoadFromRegistryAndResources();

    if (RegBeforeGroup.cInfo && !EnumGroup(
            dwGroupId,
            &RegBeforeGroup,
            pvArg,
            pfnEnumOIDInfo
            )) return FALSE;
    if (0 == dwGroupId) {
        DWORD i;
        for (i = 1; i <= CRYPT_LAST_OID_GROUP_ID; i++) {
            if (!EnumGroup(
                    0,                  // dwGroupId
                    &GroupTable[i],
                    pvArg,
                    pfnEnumOIDInfo
                    )) return FALSE;
        }
    } else if (dwGroupId <= CRYPT_LAST_OID_GROUP_ID) {
        if (!EnumGroup(
                dwGroupId,
                &GroupTable[dwGroupId],
                pvArg,
                pfnEnumOIDInfo
                )) return FALSE;
    }

    if (RegAfterGroup.cInfo && !EnumGroup(
            dwGroupId,
            &RegAfterGroup,
            pvArg,
            pfnEnumOIDInfo
            )) return FALSE;


    return EnumDsGroup(
            dwGroupId,
            pvArg,
            pfnEnumOIDInfo
            );
}



//+=========================================================================
//  Localized Name Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Called by CryptEnumOIDFunction to enumerate through all the
//  registered localized name values.
//
//  Called within critical section
//
//  Note at ProcessDetach, the Info entry pwszLocalizedName strings are freed.
//  Therefore, for each Info entry, do a single allocation for both the
//  pwszLocalizedName and pwszCryptName. The pwszCryptName immediately
//  follows the pwszLocalizedName.
//--------------------------------------------------------------------------
static BOOL WINAPI EnumRegLocalizedNamesCallback(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN DWORD cValue,
    IN const DWORD rgdwValueType[],
    IN LPCWSTR const rgpwszValueName[],
    IN const BYTE * const rgpbValueData[],
    IN const DWORD rgcbValueData[],
    IN void *pvArg
    )
{
    BOOL fResult;
    DWORD cInfo = LocalizedGroupTable[REG_LOCALIZED_GROUP].cInfo;
    PLOCALIZED_NAME_INFO pInfo =
        LocalizedGroupTable[REG_LOCALIZED_GROUP].rgInfo;

    assert(CRYPT_LOCALIZED_NAME_ENCODING_TYPE == dwEncodingType);
    assert(0 == _stricmp(CRYPT_OID_FIND_LOCALIZED_NAME_FUNC, pszFuncName));
    assert(0 == _stricmp(CRYPT_LOCALIZED_NAME_OID, pszOID));

    while (cValue--) {
        if (REG_SZ == rgdwValueType[cValue]) {
            LPCWSTR pwszLocalizedName = (LPCWSTR) rgpbValueData[cValue];
            DWORD cchLocalizedName;
            DWORD cbLocalizedName;
            LPCWSTR pwszCryptName = rgpwszValueName[cValue];
            DWORD cbCryptName;

            LPWSTR pwszBothNames;
            PLOCALIZED_NAME_INFO pNewInfo;

            // Check for empty name string
            cchLocalizedName = wcslen(pwszLocalizedName);
            if (0 == cchLocalizedName)
                continue;

            cbLocalizedName = (cchLocalizedName + 1) * sizeof(WCHAR);
            cbCryptName = (wcslen(pwszCryptName) + 1) * sizeof(WCHAR);

            if (NULL == (pwszBothNames = (LPWSTR) OIDInfoAlloc(
                    cbLocalizedName + cbCryptName)))
                goto OutOfMemory;

            if (NULL == (pNewInfo = (PLOCALIZED_NAME_INFO) OIDInfoRealloc(
                    pInfo, (cInfo + 1) * sizeof(LOCALIZED_NAME_INFO)))) {
                OIDInfoFree(pwszBothNames);
                goto OutOfMemory;
            }
            pInfo = pNewInfo;
            pInfo[cInfo].pwszLocalizedName = (LPCWSTR) pwszBothNames;
            memcpy(pwszBothNames, pwszLocalizedName, cbLocalizedName);
            pwszBothNames =
                (LPWSTR) ((BYTE *) pwszBothNames + cbLocalizedName);
            pInfo[cInfo].pwszCryptName = (LPCWSTR) pwszBothNames;
            memcpy(pwszBothNames, pwszCryptName, cbCryptName);
            cInfo++;
        }
    }
    fResult = TRUE;

CommonReturn:
    LocalizedGroupTable[REG_LOCALIZED_GROUP].cInfo = cInfo;
    LocalizedGroupTable[REG_LOCALIZED_GROUP].rgInfo = pInfo;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
}

static void LoadPredefinedNameResources()
{
    for (DWORD i = 0; i < PREDEFINED_NAME_CNT; i++) {
        LPWSTR pwszLocalizedName;

        // Note, the following always returns a non-NULL string pointer.
        pwszLocalizedName = AllocAndLoadOIDNameString(
            PredefinedNameTable[i].uIDLocalizedName);
        if (L'\0' == *pwszLocalizedName)
            pwszLocalizedName = NULL;
        PredefinedNameTable[i].pwszLocalizedName = (LPCWSTR) pwszLocalizedName;
    }
}

static void LoadLocalizedNamesFromRegAndResources()
{
    if (fLoadedLocalizedNames)
        return;

    EnterCriticalSection(&LoadFromRegCriticalSection);
    if (!fLoadedLocalizedNames) {
        CryptEnumOIDFunction(
            CRYPT_LOCALIZED_NAME_ENCODING_TYPE,
            CRYPT_OID_FIND_LOCALIZED_NAME_FUNC,
            CRYPT_LOCALIZED_NAME_OID,
            0,                              // dwFlags
            NULL,                           // pvArg
            EnumRegLocalizedNamesCallback
            );
        LoadPredefinedNameResources();
        fLoadedLocalizedNames = TRUE;
    }
    LeaveCriticalSection(&LoadFromRegCriticalSection);
}

//+-------------------------------------------------------------------------
//  Find the localized name for the specified name. For example, find the
//  localized name for the "Root" system store name. A case insensitive
//  string comparison is done.
//
//  Returns NULL if unable to find the the specified name.
//--------------------------------------------------------------------------
LPCWSTR
WINAPI
CryptFindLocalizedName(
    IN LPCWSTR pwszCryptName
    )
{
    if (NULL == pwszCryptName || L'\0' == *pwszCryptName)
        return NULL;

    LoadLocalizedNamesFromRegAndResources();

    for (DWORD i = 0; i < LOCALIZED_GROUP_CNT; i++) {
        DWORD cInfo = LocalizedGroupTable[i].cInfo;
        PLOCALIZED_NAME_INFO pInfo = LocalizedGroupTable[i].rgInfo;
        for ( ; cInfo > 0; cInfo--, pInfo++) {
            if (0 == _wcsicmp(pwszCryptName, pInfo->pwszCryptName))
                return pInfo->pwszLocalizedName;
        }
    }

    return NULL;
}


//+=========================================================================
//  DS Group Functions
//==========================================================================

// certcli.dll has the helper function for getting the LDAP URL to the
// OID info stored in the DS.

#define sz_CERTCLI_DLL              "certcli.dll"
#define sz_CAOIDGetLdapURL          "CAOIDGetLdapURL"
#define sz_CAOIDFreeLdapURL         "CAOIDFreeLdapURL"

typedef HRESULT (WINAPI *PFN_CA_OID_GET_LDAP_URL)(
    IN  DWORD   dwType,
    IN  DWORD   dwFlag,
    OUT LPWSTR  *ppwszURL
    );

typedef HRESULT (WINAPI *PFN_CA_OID_FREE_LDAP_URL)(
    IN LPCWSTR pwszURL
    );


#if 1
//+-------------------------------------------------------------------------
//  Gets the LDAP URL for and then uses to retrieve the OID info stored
//  in the DS.
//
//  Returns NULL if unable to do a successful LDAP retrieval.
//
//  If the OID object doesn't exist in the directory, returns FALSE with
//  LastError == ERROR_FILE_NOT_FOUND.
//
//  Assumption: not in DsCriticalSection
//--------------------------------------------------------------------------
static PCRYPT_BLOB_ARRAY RetrieveDsGroupByLdapUrl()
{
    PCRYPT_BLOB_ARRAY pcba = NULL;
    HRESULT hr;
    LPWSTR pwszUrl = NULL;
    HMODULE hDll = NULL;
    PFN_CA_OID_GET_LDAP_URL pfnCAOIDGetLdapURL = NULL;
    PFN_CA_OID_FREE_LDAP_URL pfnCAOIDFreeLdapURL = NULL;

    if (!ChainIsConnected())
        goto NotConnected;

    if (NULL == (hDll = LoadLibraryA(sz_CERTCLI_DLL)))
        goto LoadCertCliDllError;

    if (NULL == (pfnCAOIDGetLdapURL =
            (PFN_CA_OID_GET_LDAP_URL) GetProcAddress(hDll,
                sz_CAOIDGetLdapURL)))
        goto CAOIDGetLdapURLProcAddressError;

    if (NULL == (pfnCAOIDFreeLdapURL =
            (PFN_CA_OID_FREE_LDAP_URL) GetProcAddress(hDll,
                sz_CAOIDFreeLdapURL)))
        goto CAOIDFreeLdapURLProcAddressError;

    hr = pfnCAOIDGetLdapURL(
            CERT_OID_TYPE_ALL,
            0,                      // dwFlags
            &pwszUrl
            );
    if (S_OK != hr)
        goto CAOIDGetLdapURLError;

    if (!ChainRetrieveObjectByUrlW (
            pwszUrl,
            NULL,                   // pszObjectOid,
            CRYPT_RETRIEVE_MULTIPLE_OBJECTS     |
                CRYPT_WIRE_ONLY_RETRIEVAL       |
                CRYPT_DONT_CACHE_RESULT         |
                CRYPT_OFFLINE_CHECK_RETRIEVAL   |
                CRYPT_LDAP_SIGN_RETRIEVAL |
                CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE,
            DS_LDAP_TIMEOUT,
            (LPVOID*) &pcba,
            NULL,                   // hAsyncRetrieve,
            NULL,                   // pCredentials,
            NULL,                   // pvVerify,
            NULL                    // pAuxInfo
            )) {
        DWORD dwErr = GetLastError();
        if (ERROR_FILE_NOT_FOUND == dwErr || CRYPT_E_NOT_FOUND == dwErr)
            goto NoDsOIDObject;
        else
            goto RetrieveObjectByUrlError;
    }

    assert(pcba);

CommonReturn:
    if (hDll) {
        DWORD dwErr = GetLastError();

        if (pfnCAOIDFreeLdapURL && pwszUrl)
            pfnCAOIDFreeLdapURL(pwszUrl);
        
        FreeLibrary(hDll);
        SetLastError(dwErr);
    }
    return pcba;
ErrorReturn:
    assert(NULL == pcba);
    goto CommonReturn;

SET_ERROR(LoadCertCliDllError, ERROR_FILE_NOT_FOUND)
SET_ERROR(CAOIDGetLdapURLProcAddressError, ERROR_FILE_NOT_FOUND)
SET_ERROR(CAOIDFreeLdapURLProcAddressError, ERROR_FILE_NOT_FOUND)
SET_ERROR_VAR(CAOIDGetLdapURLError, hr)
SET_ERROR(NotConnected, ERROR_NOT_CONNECTED)
SET_ERROR(NoDsOIDObject, ERROR_FILE_NOT_FOUND)
TRACE_ERROR(RetrieveObjectByUrlError)
}

#else

// Hard coded URL and credentials for testing

static PCRYPT_BLOB_ARRAY RetrieveDsGroupByLdapUrl()
{
    PCRYPT_BLOB_ARRAY pcba = NULL;

    CRYPT_CREDENTIALS Credentials;
    CRYPT_PASSWORD_CREDENTIALSA PasswordCredentials;

// This gets overwritten by logic in cryptnet.dll
//    char szUsername[] = "domain\\username";
    char szUsername[] = "jettdom\\administrator";

    PasswordCredentials.cbSize = sizeof( PasswordCredentials );
    PasswordCredentials.pszUsername = szUsername;
//    PasswordCredentials.pszPassword = "password";
    PasswordCredentials.pszPassword = "";

    Credentials.cbSize = sizeof( Credentials );
    Credentials.pszCredentialsOid = CREDENTIAL_OID_PASSWORD_CREDENTIALS_A;
    Credentials.pvCredentials = (LPVOID)&PasswordCredentials;

    if (!ChainIsConnected())
        goto NotConnected;


    if (!ChainRetrieveObjectByUrlW (
            L"ldap://jettdomdc/CN=OID,CN=Public Key Services,CN=Services,CN=Configuration,DC=jettdom,DC=nttest,DC=microsoft,DC=com?msPKI-OIDLocalizedName,displayName,msPKI-Cert-Template-OID,flags?one",
            NULL,                   // pszObjectOid,
            CRYPT_RETRIEVE_MULTIPLE_OBJECTS     |
                CRYPT_WIRE_ONLY_RETRIEVAL       |
                CRYPT_DONT_CACHE_RESULT         |
                CRYPT_OFFLINE_CHECK_RETRIEVAL   |
                CRYPT_LDAP_SIGN_RETRIEVAL       |
                CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE,
            DS_LDAP_TIMEOUT,
            (LPVOID*) &pcba,
            NULL,                   // hAsyncRetrieve,
            &Credentials,
            NULL,                   // pvVerify,
            NULL                    // pAuxInfo
            )) {
        if (ERROR_FILE_NOT_FOUND == GetLastError())
            goto NoDsOIDObject;
        else
            goto RetrieveObjectByUrlError;
    }

    assert(pcba);

CommonReturn:
    return pcba;
ErrorReturn:
    assert(NULL == pcba);
    goto CommonReturn;

SET_ERROR(NotConnected, ERROR_NOT_CONNECTED)
TRACE_ERROR(NoDsOIDObject)
TRACE_ERROR(RetrieveObjectByUrlError)
}

#endif


//+-------------------------------------------------------------------------
//  Frees the DS groups
//
//  Assumption: only called at ProcessDetach
//--------------------------------------------------------------------------
static void FreeDsGroups()
{
    DWORD cInfo;
    PCCRYPT_OID_INFO *ppInfo;

    cInfo = DsGroup.cInfo;
    ppInfo = DsGroup.rgpInfo;
    for ( ; cInfo > 0; cInfo--, ppInfo++)
        OIDInfoFree((PCRYPT_OID_INFO) *ppInfo);
    OIDInfoFree(DsGroup.rgpInfo);

    cInfo = DsDeletedGroup.cInfo;
    ppInfo = DsDeletedGroup.rgpInfo;
    for ( ; cInfo > 0; cInfo--, ppInfo++)
        OIDInfoFree((PCRYPT_OID_INFO) *ppInfo);
    OIDInfoFree(DsDeletedGroup.rgpInfo);
}


//+-------------------------------------------------------------------------
//  Adds the OID info entries to the specified DS group
//
//  Assumption: already in DsCriticalSection
//--------------------------------------------------------------------------
static BOOL AddDsOIDInfo(
    IN PCCRYPT_OID_INFO *ppAddInfo,
    IN DWORD cAddInfo,
    IN OUT PDS_GROUP_ENTRY pGroup
    )
{
    PCCRYPT_OID_INFO *ppInfo;
    assert(cAddInfo && ppAddInfo && *ppAddInfo);

    if (NULL == (ppInfo = (PCCRYPT_OID_INFO *) OIDInfoRealloc(
            pGroup->rgpInfo,
            (pGroup->cInfo + cAddInfo) * sizeof(PCCRYPT_OID_INFO))))
        return FALSE;

    pGroup->rgpInfo = ppInfo;

    ppInfo = &ppInfo[pGroup->cInfo];
    pGroup->cInfo += cAddInfo;
    for ( ; 0 < cAddInfo; cAddInfo --, ppAddInfo++, ppInfo++)
        *ppInfo = *ppAddInfo;

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Moves the OID info entries from one DS group to another DS group
//
//  Assumption: already in DsCriticalSection
//--------------------------------------------------------------------------
static BOOL MoveDsOIDInfo(
    IN DWORD dwInfoIndex,
    IN DWORD cMoveInfo,
    IN OUT PDS_GROUP_ENTRY pSrcGroup,
    IN OUT PDS_GROUP_ENTRY pDstGroup
    )
{
    DWORD cInfo;
    PCCRYPT_OID_INFO *ppInfo;
    DWORD i, j;

    if (0 == cMoveInfo)
        return TRUE;

    assert(dwInfoIndex + cMoveInfo <= pSrcGroup->cInfo);

    if (!AddDsOIDInfo(
            &pSrcGroup->rgpInfo[dwInfoIndex],
            cMoveInfo,
            pDstGroup
            ))
        return FALSE;

    // Move all remaining infos down
    cInfo = pSrcGroup->cInfo;
    ppInfo = pSrcGroup->rgpInfo;
    for (i = dwInfoIndex, j = i + cMoveInfo; j < cInfo; i++, j++)
        ppInfo[i] = ppInfo[j];

    pSrcGroup->cInfo = cInfo - cMoveInfo;

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Creates the OID info by converting the LDAP DS attribute octets.
//
//  If any of the cb's == 0 or not a valid converted group type, returns TRUE
//  with *ppInfo = NULL
//--------------------------------------------------------------------------
static BOOL CreateDsOIDInfo(
    IN BYTE *pbOID,
    IN DWORD cbOID,
    IN BYTE *pbName,
    IN DWORD cbName,
    IN BYTE *pbGroupId,
    IN DWORD cbGroupId,
    OUT PCCRYPT_OID_INFO *ppInfo
    )
{
    BOOL fResult;
    PCRYPT_OID_INFO pInfo = NULL;
    char szType[2];
    DWORD dwType;
    DWORD dwGroupId;

    int cchName;
    LPWSTR pwszName;
    LPSTR pszOID;
    DWORD cbExtra;

    *ppInfo = NULL;

    if (0 == cbOID || 0 == cbName || 1 != cbGroupId)
        return TRUE;

    // Convert the Type bytes to the GroupId and see if a valid DS OID group
    szType[0] = (char) *pbGroupId;
    szType[1] = '\0';
    dwType = 0;
    dwType = (DWORD) atol(szType);

    switch (dwType) {
        case CERT_OID_TYPE_TEMPLATE:
            dwGroupId = CRYPT_TEMPLATE_OID_GROUP_ID;
            break;
        case CERT_OID_TYPE_ISSUER_POLICY:
            dwGroupId = CRYPT_POLICY_OID_GROUP_ID;
            break;
        case CERT_OID_TYPE_APPLICATION_POLICY:
            dwGroupId = CRYPT_ENHKEY_USAGE_OID_GROUP_ID;
            break;
        default:
            return TRUE;
    }

    // The name is a UTF8 encoded string

    cchName = UTF8ToWideChar(
        (LPSTR) pbName,
        cbName,
        NULL,           // lpWideCharStr
        0               // cchWideChar
        );

    if (1 > cchName)
        return TRUE;

    cbExtra = (cchName + 1) * sizeof(WCHAR) + (cbOID + 1);

    pInfo = (PCRYPT_OID_INFO) OIDInfoAlloc(sizeof(CRYPT_OID_INFO) + cbExtra);
    if (NULL == pInfo)
        goto OutOfMemory;
    memset(pInfo, 0, sizeof(CRYPT_OID_INFO));

    pInfo->cbSize = sizeof(CRYPT_OID_INFO);
    pInfo->dwGroupId = dwGroupId;

    pwszName = (LPWSTR) &pInfo[1];
    pInfo->pwszName = (LPCWSTR) pwszName;
    cchName = UTF8ToWideChar(
        (LPSTR) pbName,
        cbName,
        pwszName,
        cchName
        );

    if (1 > cchName)
        goto UTF8ToWideCharError;

    pwszName[cchName] = L'\0';

    pszOID = (LPSTR) (pwszName + (cchName + 1));
    pInfo->pszOID = (LPCSTR) pszOID;
    memcpy(pszOID, pbOID, cbOID);
    pszOID[cbOID] = '\0';


    *ppInfo = (PCCRYPT_OID_INFO) pInfo;
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
    
TRACE_ERROR(OutOfMemory)
SET_ERROR(UTF8ToWideCharError, ERROR_INVALID_DATA)
}

//+-------------------------------------------------------------------------
//  Creates the OID info entry corresponding to the LDAP DS attribute octets.
//
//  If the OID info entry already exists in the DsDeletedGroup, then, the
//  OID info entry is moved from DsDeletedGroup to DsGroup. Otherwise, the
//  created OID entry is added to the DsGroup.
//
//  Assumption: already in DsCriticalSection
//--------------------------------------------------------------------------
static BOOL CreateAndAddDsOIDInfo(
    IN BYTE *pbOID,
    IN DWORD cbOID,
    IN BYTE *pbName,
    IN DWORD cbName,
    IN BYTE *pbGroupId,
    IN DWORD cbGroupId
    )
{
    BOOL fResult;
    PCCRYPT_OID_INFO pInfo = NULL;

    DWORD cDeletedInfo;
    PCCRYPT_OID_INFO *ppDeletedInfo;
    DWORD i;

    fResult = CreateDsOIDInfo(
        pbOID,
        cbOID,
        pbName,
        cbName,
        pbGroupId,
        cbGroupId,
        &pInfo
        );

    if (NULL == pInfo)
        // Either the create failed or not a valid DS OID group
        return fResult;

    // See if we have an entry in the DS deleted group

    cDeletedInfo = DsDeletedGroup.cInfo;
    ppDeletedInfo = DsDeletedGroup.rgpInfo;
    for (i = 0; i < cDeletedInfo; i++) {
        PCCRYPT_OID_INFO pDeletedInfo = ppDeletedInfo[i];

        if (pInfo->dwGroupId == pDeletedInfo->dwGroupId &&
                0 == strcmp(pInfo->pszOID, pDeletedInfo->pszOID) &&
                0 == wcscmp(pInfo->pwszName, pDeletedInfo->pwszName))
            break;
    }

    if (i < cDeletedInfo) {
        if (!MoveDsOIDInfo(
                i,
                1,          // cInfo
                &DsDeletedGroup,
                &DsGroup
                ))
            goto MoveDsOIDInfoError;
        OIDInfoFree((PCRYPT_OID_INFO) pInfo);
    } else {
        if (!AddDsOIDInfo(&pInfo, 1, &DsGroup))
            goto AddDsOIDInfoError;
    }

    fResult = TRUE;

CommonReturn:
    return fResult;
    
ErrorReturn:
    OIDInfoFree((PCRYPT_OID_INFO) pInfo);
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(MoveDsOIDInfoError)
TRACE_ERROR(AddDsOIDInfoError)
}

//+-------------------------------------------------------------------------
//  Allocates and converts UNICODE string to ASCII.
//--------------------------------------------------------------------------
static LPSTR AllocAndWszToSz(
    IN LPCWSTR pwsz
    )
{
    int cchMultiByte;
    LPSTR psz = NULL;

    cchMultiByte = WideCharToMultiByte(
        CP_ACP,
        0,                      // dwFlags
        pwsz,
        -1,
        NULL,                   // psz,
        0,                      // cchMultiByte
        NULL,                   // lpDefaultChar
        NULL                    // lpfUsedDefaultChar
        );

    if (1 < cchMultiByte) {
        psz = (LPSTR) OIDInfoAlloc(cchMultiByte);

        if (NULL != psz) {
            cchMultiByte = WideCharToMultiByte(
                CP_ACP,
                0,                      // dwFlags
                pwsz,
                -1,
                psz,
                cchMultiByte,
                NULL,                   // lpDefaultChar
                NULL                    // lpfUsedDefaultChar
                );
            if (1 > cchMultiByte) {
                OIDInfoFree(psz);
                psz = NULL;
            } 
        }
    }

    return psz;
}


//+------------------------------------------------------------------------------
//  Helper functions to thunk APIs which don't exist on downlevels.  
//  oidinfo.obj is statically linked in with xenroll, which has to work on
//  all downlevels (win9x, NT4, W2K, XP).  Any functions which aren't supported
//  on these platforms need to be thunked here to avoid a dependency violation.
//-------------------------------------------------------------------------------

#define sz_KERNEL32_DLL                "kernel32.dll"
#define sz_GetSystemDefaultUILanguage  "GetSystemDefaultUILanguage"
#define sz_GetUserDefaultUILanguage    "GetUserDefaultUILanguage"

typedef LANGID (WINAPI *PFNGetSystemDefaultUILanguage) (
    void
    ); 

typedef LANGID (WINAPI *PFNGetUserDefaultUILanguage) (
    void
    ); 

//+------------------------------------------------------------------------------
//  Helper function to thunk GetSystemDefaultUILanguage().  If this API isn't 
//  present, falls back to GetSystemDefaultLangID(). 
//------------------------------------------------------------------------------
static LANGID WINAPI MyGetSystemDefaultUILanguage(void) 
{ 
    HMODULE                        hKernel32                      = NULL; 
    LANGID                         langidRetval; 
    PFNGetSystemDefaultUILanguage  pfnGetSystemDefaultUILanguage  = NULL; 

    hKernel32 = LoadLibraryA(sz_KERNEL32_DLL); 
    if (NULL != hKernel32) { 
	pfnGetSystemDefaultUILanguage = (PFNGetSystemDefaultUILanguage)GetProcAddress(hKernel32, sz_GetSystemDefaultUILanguage); 
    }

    if (NULL != pfnGetSystemDefaultUILanguage) { 
	langidRetval = pfnGetSystemDefaultUILanguage();
    } else { 
	langidRetval = GetSystemDefaultLangID(); 
    }

    if (NULL != hKernel32) { 
	FreeLibrary(hKernel32); 
    }

    return langidRetval; 
}

//+------------------------------------------------------------------------------
//  Helper function to thunk GetUserDefaultUILanguage().  If this API isn't 
//  present, falls back to GetUserDefaultLangID(). 
//------------------------------------------------------------------------------
static LANGID WINAPI MyGetUserDefaultUILanguage(void) 
{ 
    HMODULE                      hKernel32                    = NULL; 
    LANGID                       langidRetval; 
    PFNGetUserDefaultUILanguage  pfnGetUserDefaultUILanguage  = NULL; 

    hKernel32 = LoadLibraryA(sz_KERNEL32_DLL); 
    if (NULL != hKernel32) { 
	pfnGetUserDefaultUILanguage = (PFNGetUserDefaultUILanguage)GetProcAddress(hKernel32, sz_GetUserDefaultUILanguage); 
    }

    if (NULL != pfnGetUserDefaultUILanguage) { 
	langidRetval = pfnGetUserDefaultUILanguage();
    } else { 
	// Use GetSystemDefaultLangID for fallback, even in the user case.  
	// From weiwu: "GetUserDefaultLangID is mostly for standards and formats; 
	//     it shouldn't be used as the UI language fallback."
	langidRetval = GetSystemDefaultLangID(); 
    }

    if (NULL != hKernel32) { 
	FreeLibrary(hKernel32); 
    }

    return langidRetval; 
}


//+-------------------------------------------------------------------------
//  Loads the DS group by doing an LDAP URL retrieval and
//  converting the DS attribute octets into the OID info entries.
//
//  Do the load on the first call. Do subsequent reloads after
//  DS_RETRIEVAL_DELTA_SECONDS has elapsed since a successful load.
//
//  Assumption: not in DsCriticalSection
//--------------------------------------------------------------------------
static void LoadDsGroup()
{
    FILETIME CurrentTime;
    LONG lCmp;

    PCRYPT_BLOB_ARRAY pcba = NULL;
    LPSTR pszOIDAttr = NULL;
    LPSTR pszNameAttr = NULL;
    LPSTR pszLocalizedNameAttr = NULL;
    LPSTR pszGroupAttr = NULL;

    LANGID SystemDefaultLangID = 0;

    LPCSTR pszPrevIndex;    // not allocated
    BYTE *pbOID;
    DWORD cbOID;
    BYTE *pbName;
    DWORD cbName;
    BYTE *pbLocalizedName;
    DWORD cbLocalizedName;
    BYTE *pbGroupId;
    DWORD cbGroupId;
    DWORD i;

    GetSystemTimeAsFileTime(&CurrentTime);
    EnterCriticalSection(&DsCriticalSection);
    lCmp = CompareFileTime(&DsNextUpdateTime, &CurrentTime);
    LeaveCriticalSection(&DsCriticalSection);

    if (0 < lCmp)
        // Current time is before the next update time
        return;

    if (NULL == (pcba = RetrieveDsGroupByLdapUrl()) &&
            ERROR_FILE_NOT_FOUND != GetLastError())
        return;

    EnterCriticalSection(&DsCriticalSection);

    // Move all the Ds group entries to the deleted list. As we iterate
    // through the retrieved LDAP entries, most if not all of the entries
    // in the deleted group will be moved back.
    if (!MoveDsOIDInfo(
            0,              // dwInfoIndex
            DsGroup.cInfo,
            &DsGroup,
            &DsDeletedGroup
            ))
        goto MoveDsGroupOIDInfoError;

    if (NULL == pcba)
        goto NoOIDObjectReturn;

    pszOIDAttr = AllocAndWszToSz(OID_PROP_OID);
    pszNameAttr = AllocAndWszToSz(OID_PROP_DISPLAY_NAME);
    pszLocalizedNameAttr = AllocAndWszToSz(OID_PROP_LOCALIZED_NAME);
    pszGroupAttr = AllocAndWszToSz(OID_PROP_TYPE);
    if (NULL == pszOIDAttr || NULL == pszNameAttr ||
            NULL == pszLocalizedNameAttr|| NULL == pszGroupAttr)
        goto OutOfMemory;

    pszPrevIndex = "";
    pbOID = NULL;
    cbOID = 0;
    pbName = NULL;
    cbName = 0;
    pbLocalizedName = NULL;
    cbLocalizedName = 0;
    pbGroupId = NULL;
    cbGroupId = 0;
    for (i = 0; i < pcba->cBlob; i++ ) {
        PBYTE pb = pcba->rgBlob[i].pbData;
        DWORD cb = pcba->rgBlob[i].cbData;

        DWORD cbPrefix;
        LPCSTR pszIndex;
        LPCSTR pszAttr;

        pszIndex = (LPCSTR) pb;
        cbPrefix = strlen(pszIndex) + 1;
        pb += cbPrefix;
        cb -= cbPrefix;

        pszAttr = (LPCSTR) pb;
        cbPrefix = strlen(pszAttr) + 1;
        pb += cbPrefix;
        cb -= cbPrefix;

        if (0 != strcmp(pszIndex, pszPrevIndex)) {
            if (!CreateAndAddDsOIDInfo(
                    pbOID,
                    cbOID,
                    cbLocalizedName ? pbLocalizedName : pbName,
                    cbLocalizedName ? cbLocalizedName : cbName,
                    pbGroupId,
                    cbGroupId
                    ))
                goto CreateAndAddDsOIDInfoError;
            pszPrevIndex = pszIndex;
            pbOID = NULL;
            cbOID = 0;
            pbName = NULL;
            cbName = 0;
            pbLocalizedName = NULL;
            cbLocalizedName = 0;
            pbGroupId = NULL;
            cbGroupId = 0;
        }

        if (0 == _stricmp(pszAttr, pszOIDAttr)) {
            pbOID = pb;
            cbOID = cb;
        } else if (0 == _stricmp(pszAttr, pszNameAttr)) {
            pbName = pb;
            cbName = cb;
        } else if (0 == _stricmp(pszAttr, pszLocalizedNameAttr)) {
            // The LocalizedName consists of:
            //      "%d,%s", LangID, pszUTF8Name (Name isn't NULL terminated)
            if (0 == cbLocalizedName) {
                LPCSTR pszLangID;

                // Search for the ',' delimiter and convert to a \0
                pszLangID = (LPCSTR) pb;
                for ( ; 0 < cb; pb++, cb--) {
                    if (',' == *pb) {
                        *pb = 0;
                        pb++;
                        cb--;
                        break;
                    }
                }

                if (0 < cb) {
                    LANGID LangID = 0;

                    LangID = (LANGID) strtoul(pszLangID, NULL, 10);
                    if (0 != LangID) {
                        if (0 == SystemDefaultLangID) {
                            SystemDefaultLangID = MyGetUserDefaultUILanguage();
                            if (0 == SystemDefaultLangID)
                                SystemDefaultLangID =
                                    MyGetSystemDefaultUILanguage();
                        }
                        if (LangID == SystemDefaultLangID) {
                            cbLocalizedName = cb;
                            pbLocalizedName = pb;
                        }
                    }
                }
            }
        } else if (0 == _stricmp(pszAttr, pszGroupAttr)) {
            pbGroupId = pb;
            cbGroupId = cb;
        }
    }

    if (!CreateAndAddDsOIDInfo(
            pbOID,
            cbOID,
            cbLocalizedName ? pbLocalizedName : pbName,
            cbLocalizedName ? cbLocalizedName : cbName,
            pbGroupId,
            cbGroupId
            ))
        goto CreateAndAddDsOIDInfoError;


NoOIDObjectReturn:
    I_CryptIncrementFileTimeBySeconds(
        &CurrentTime,
        DS_RETRIEVAL_DELTA_SECONDS,
        &DsNextUpdateTime
        );

CommonReturn:
    LeaveCriticalSection(&DsCriticalSection);

    OIDInfoFree(pszOIDAttr);
    OIDInfoFree(pszNameAttr);
    OIDInfoFree(pszLocalizedNameAttr);
    OIDInfoFree(pszGroupAttr);
    if (pcba)
        CryptMemFree(pcba);
    return;

ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(MoveDsGroupOIDInfoError)
TRACE_ERROR(CreateAndAddDsOIDInfoError)
}

//+-------------------------------------------------------------------------
//  The DS only contains the ENHKEY, POLICY and TEMPLATE OID groups.
//--------------------------------------------------------------------------
static inline BOOL IsDsGroup(
    IN DWORD dwGroupId
    )
{
    if (0 == dwGroupId                                      ||
            CRYPT_ENHKEY_USAGE_OID_GROUP_ID == dwGroupId    ||
            CRYPT_POLICY_OID_GROUP_ID == dwGroupId          ||
            CRYPT_TEMPLATE_OID_GROUP_ID == dwGroupId
            )
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  The DS only contains OID and NAME strings
//--------------------------------------------------------------------------
static inline BOOL IsDsKeyType(
    IN DWORD dwKeyType
    )
{
    if (CRYPT_OID_INFO_OID_KEY == dwKeyType ||
            CRYPT_OID_INFO_NAME_KEY == dwKeyType
            )
        return TRUE;
    else
        return FALSE;
}

//+-------------------------------------------------------------------------
//  Search the DS group according to the specified dwKeyType.
//--------------------------------------------------------------------------
static PCCRYPT_OID_INFO SearchDsGroup(
    IN DWORD dwKeyType,
    IN void *pvKey,
    IN DWORD dwGroupId
    )
{
    DWORD cInfo;
    PCCRYPT_OID_INFO *ppInfo;
    PCCRYPT_OID_INFO pInfo = NULL;

    if (!IsDsGroup(dwGroupId) || !IsDsKeyType(dwKeyType))
        return NULL;

    LoadDsGroup();

    EnterCriticalSection(&DsCriticalSection);

    cInfo = DsGroup.cInfo;
    ppInfo = DsGroup.rgpInfo;
    for ( ; cInfo > 0; cInfo--, ppInfo++) {
        pInfo = *ppInfo;
        if (CompareOIDInfo(
                dwKeyType,
                pvKey,
                dwGroupId,
                pInfo
                ))
            break;
    }

    if (0 == cInfo)
        pInfo = NULL;

    LeaveCriticalSection(&DsCriticalSection);

    return pInfo;
}

//+-------------------------------------------------------------------------
//  Enumerate the DS group.
//--------------------------------------------------------------------------
static BOOL EnumDsGroup(
    IN DWORD dwGroupId,
    IN void *pvArg,
    IN PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo
    )
{
    BOOL fResult;
    DWORD cInfo;
    PCCRYPT_OID_INFO *ppInfo = NULL;
    DWORD i;

    if (!IsDsGroup(dwGroupId))
        return TRUE;

    LoadDsGroup();

    EnterCriticalSection(&DsCriticalSection);

    // Make a copy of DS group OID info pointers while within the
    // DS critical section

    cInfo = DsGroup.cInfo;
    if (0 != cInfo) {
        ppInfo = (PCCRYPT_OID_INFO *) OIDInfoAlloc(
            cInfo * sizeof(PCCRYPT_OID_INFO));

        if (ppInfo)
            memcpy(ppInfo, DsGroup.rgpInfo, cInfo * sizeof(PCCRYPT_OID_INFO));
        else
            cInfo = 0;
    }

    LeaveCriticalSection(&DsCriticalSection);


    for (i = 0; i < cInfo; i++) {
        PCCRYPT_OID_INFO pInfo = ppInfo[i];

        if (dwGroupId && dwGroupId != pInfo->dwGroupId)
            continue;

        if (!pfnEnumOIDInfo(pInfo, pvArg))
            goto EnumOIDInfoError;
    }

    fResult = TRUE;

CommonReturn:
    OIDInfoFree(ppInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(EnumOIDInfoError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\oidfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       oidfunc.cpp
//
//  Contents:   Cryptographic Object ID (OID) Functions
//
//  Functions:  I_CryptOIDFuncDllMain
//              CryptInitOIDFunctionSet
//              CryptInstallOIDFunctionAddress
//
//              CryptSetOIDFunctionValue
//              CryptGetOIDFunctionValue
//              CryptRegisterOIDFunction
//              CryptUnregisterOIDFunction
//              CryptRegisterDefaultOIDFunction
//              CryptUnregisterDefaultOIDFunction
//              CryptEnumOIDFunction
//
//              CryptGetOIDFunctionAddress
//              CryptGetDefaultOIDDllList
//              CryptGetDefaultOIDFunctionAddress
//              CryptFreeOIDFunctionAddress
//
//  Comments:
//              For the CryptGetOIDFunctionAddress we search the installed
//              const and str lists without
//              entering the critical section. The adds which are within
//              the critical section update the list pointers in the proper
//              order to allow list searching without locking.
//
//              However, registry loads are done with OIDFunc
//              locked.
//
//              HOLDING OID LOCK WHILE DOING A LoadLibrary() or FreeLibrary()
//              MAY LEAD TO DEADLOCK !!!
//
//
//  History:    07-Nov-96    philh   created
//              09-Aug-98    philh   changed to NOT hold OID lock when calling
//                                   LoadLibrary() or FreeLibrary().
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

#ifdef STATIC
#undef STATIC
#endif
#define STATIC


#define LEN_ALIGN(Len)  ((Len + 7) & ~7)

#define CONST_OID_STR_PREFIX_CHAR   '#'

//+-------------------------------------------------------------------------
//  OID Element Type Definitions
//--------------------------------------------------------------------------
#define CONST_OID_TYPE          1
#define STR_OID_TYPE            2
#define DLL_OID_TYPE            3

//+-------------------------------------------------------------------------
//  Dll and Procedure Element Definitions
//--------------------------------------------------------------------------
typedef struct _DLL_ELEMENT DLL_ELEMENT, *PDLL_ELEMENT;
typedef struct _DLL_PROC_ELEMENT DLL_PROC_ELEMENT, *PDLL_PROC_ELEMENT;

struct _DLL_ELEMENT {
    DWORD                   dwOIDType;
    PDLL_ELEMENT            pNext;
    LPWSTR                  pwszDll;    // expanded
    HMODULE                 hDll;
    DWORD                   dwRefCnt;
    BOOL                    fLoaded;
    PDLL_PROC_ELEMENT       pProcHead;
    LPFNCANUNLOADNOW        pfnDllCanUnloadNow;

    // The following are used to defer the freeing of Dlls until after waiting
    // at least one FREE_DLL_TIMEOUT.
    DWORD                   dwFreeCnt;  // 0, 1 or 2.
    PDLL_ELEMENT            pFreeNext;
    PDLL_ELEMENT            pFreePrev;
};

struct _DLL_PROC_ELEMENT {
    PDLL_PROC_ELEMENT       pNext;
    PDLL_ELEMENT            pDll;
    LPSTR                   pszName;
    void                    *pvAddr;    // NULL'ed when Dll is unloaded
};

// Linked list of all the Dlls. All proc elements are on one of the Dll
// element's proc list.
static PDLL_ELEMENT pDllHead;

// Linked list of Dlls waiting to be freed.
static PDLL_ELEMENT pFreeDllHead;

// Count of elements in the above list
static DWORD dwFreeDllCnt;

// When nonzero, a FreeDll callback has been registered.
static LONG lFreeDll;
static HANDLE hFreeDllRegWaitFor;
static HMODULE hFreeDllLibModule;

// Crypt32.dll hInst
static HMODULE hOidInfoInst;

// 15 seconds
#define FREE_DLL_TIMEOUT    15000

//+-------------------------------------------------------------------------
//  Installed OID Element Definitions
//--------------------------------------------------------------------------
typedef struct _CONST_OID_FUNC_ELEMENT
    CONST_OID_FUNC_ELEMENT, *PCONST_OID_FUNC_ELEMENT;
struct _CONST_OID_FUNC_ELEMENT {
    DWORD                   dwOIDType;
    DWORD                   dwEncodingType;
    PCONST_OID_FUNC_ELEMENT pNext;
    DWORD_PTR               dwLowOID;
    DWORD_PTR               dwHighOID;
    HMODULE                 hDll;
    void                    **rgpvFuncAddr;
};

typedef struct _STR_OID_FUNC_ELEMENT
    STR_OID_FUNC_ELEMENT, *PSTR_OID_FUNC_ELEMENT;
struct _STR_OID_FUNC_ELEMENT {
    DWORD                   dwOIDType;
    DWORD                   dwEncodingType;
    PSTR_OID_FUNC_ELEMENT   pNext;
    LPSTR                   pszOID;
    HMODULE                 hDll;
    void                    *pvFuncAddr;
};

//+-------------------------------------------------------------------------
//  Registry OID Element Definitions
//--------------------------------------------------------------------------
typedef struct _REG_OID_FUNC_ELEMENT
    REG_OID_FUNC_ELEMENT, *PREG_OID_FUNC_ELEMENT;
struct _REG_OID_FUNC_ELEMENT {
    DWORD                   dwEncodingType;
    PREG_OID_FUNC_ELEMENT   pNext;
    union {
        DWORD_PTR               dwOID;
        LPSTR                   pszOID;
    };
    PDLL_PROC_ELEMENT       pDllProc;
};

//+-------------------------------------------------------------------------
//  Default registry DLL list Element Definitions
//--------------------------------------------------------------------------
typedef struct _DEFAULT_REG_ELEMENT
    DEFAULT_REG_ELEMENT, *PDEFAULT_REG_ELEMENT;
struct _DEFAULT_REG_ELEMENT {
    DWORD                   dwEncodingType;
    PDEFAULT_REG_ELEMENT    pNext;

    LPWSTR                  pwszDllList;
    DWORD                   cchDllList;

    DWORD                   cDll;
    LPWSTR                  *rgpwszDll;
    PDLL_PROC_ELEMENT       *rgpDllProc;
};

//+-------------------------------------------------------------------------
//  Function Set Definition
//--------------------------------------------------------------------------
typedef struct _FUNC_SET FUNC_SET, *PFUNC_SET;
struct _FUNC_SET {
    PFUNC_SET               pNext;
    LPSTR                   pszFuncName;
    PCONST_OID_FUNC_ELEMENT pConstOIDFuncHead;
    PCONST_OID_FUNC_ELEMENT pConstOIDFuncTail;
    PSTR_OID_FUNC_ELEMENT   pStrOIDFuncHead;
    PSTR_OID_FUNC_ELEMENT   pStrOIDFuncTail;

    // Following are updated with OIDFunc locked
    BOOL                    fRegLoaded;
    PREG_OID_FUNC_ELEMENT   pRegBeforeOIDFuncHead;
    PREG_OID_FUNC_ELEMENT   pRegAfterOIDFuncHead;
    PDEFAULT_REG_ELEMENT    pDefaultRegHead;
};

// Linked list of all the function sets
static PFUNC_SET pFuncSetHead;

// Used to protect the adding of function sets and elements to function sets.
// Protects the pDllHead list and registry loads.
static CRITICAL_SECTION OIDFuncCriticalSection;

//+-------------------------------------------------------------------------
//  OIDFunc lock and unlock functions
//--------------------------------------------------------------------------
static inline void LockOIDFunc()
{
    EnterCriticalSection(&OIDFuncCriticalSection);
}
static inline void UnlockOIDFunc()
{
    LeaveCriticalSection(&OIDFuncCriticalSection);
}


//+-------------------------------------------------------------------------
//  First try to get the EncodingType from the lower 16 bits. If 0, get
//  from the upper 16 bits.
//--------------------------------------------------------------------------
static inline DWORD GetEncodingType(
    IN DWORD dwEncodingType
    )
{
    return (dwEncodingType & CERT_ENCODING_TYPE_MASK) ?
        (dwEncodingType & CERT_ENCODING_TYPE_MASK) :
        (dwEncodingType & CMSG_ENCODING_TYPE_MASK) >> 16;
}

//+-------------------------------------------------------------------------
//  Duplicate the Dll library's handle
//
//  Upon entry/exit OIDFunc must NOT be locked!!
//--------------------------------------------------------------------------
static HMODULE DuplicateLibrary(
    IN HMODULE hDll
    )
{
    if (hDll) {
        WCHAR wszModule[_MAX_PATH + 1];
        if (0 == GetModuleFileNameU(hDll, wszModule, _MAX_PATH))
            goto GetModuleFileNameError;
        wszModule[_MAX_PATH] = L'\0';
        if (NULL == (hDll = LoadLibraryExU(wszModule, NULL, 0)))
            goto LoadLibraryError;
    }

CommonReturn:
    return hDll;
ErrorReturn:
    hDll = NULL;
    goto CommonReturn;
TRACE_ERROR(GetModuleFileNameError)
TRACE_ERROR(LoadLibraryError)
}


//+-------------------------------------------------------------------------
//  Add one or more functions with a constant OID. The constant OIDs are
//  monotonically increasing.
//
//  Upon entry, pFuncSet hasn't been added to the searched pFuncSetHead list.
//
//  Upon entry/exit OIDFunc must NOT be locked!!
//--------------------------------------------------------------------------
STATIC BOOL AddConstOIDFunc(
    IN HMODULE hDll,
    IN DWORD dwEncodingType,
    IN OUT PFUNC_SET pFuncSet,
    IN DWORD cFuncEntry,
    IN const CRYPT_OID_FUNC_ENTRY rgFuncEntry[]
    )
{
    PCONST_OID_FUNC_ELEMENT pEle;
    DWORD cbEle;
    void **ppvFuncAddr;

    cbEle = sizeof(CONST_OID_FUNC_ELEMENT) + cFuncEntry * sizeof(void *);
    if (NULL == (pEle = (PCONST_OID_FUNC_ELEMENT) PkiZeroAlloc(cbEle)))
        return FALSE;

    pEle->dwOIDType = CONST_OID_TYPE;
    pEle->dwEncodingType = dwEncodingType;
    pEle->pNext = NULL;
    pEle->dwLowOID = (DWORD_PTR) rgFuncEntry[0].pszOID;
    pEle->dwHighOID = pEle->dwLowOID + cFuncEntry - 1;
    pEle->hDll = DuplicateLibrary(hDll);
    ppvFuncAddr =
        (void **) (((BYTE *) pEle) + sizeof(CONST_OID_FUNC_ELEMENT));
    pEle->rgpvFuncAddr = ppvFuncAddr;

    for (DWORD i = 0; i < cFuncEntry; i++, ppvFuncAddr++)
        *ppvFuncAddr = rgFuncEntry[i].pvFuncAddr;

    if (pFuncSet->pConstOIDFuncTail)
        pFuncSet->pConstOIDFuncTail->pNext = pEle;
    else
        pFuncSet->pConstOIDFuncHead = pEle;
    pFuncSet->pConstOIDFuncTail = pEle;
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Add single function with a string OID.
//
//  Upon entry, pFuncSet hasn't been added to the searched pFuncSetHead list.
//
//  Upon entry/exit OIDFunc must NOT be locked!!
//--------------------------------------------------------------------------
STATIC BOOL AddStrOIDFunc(
    IN HMODULE hDll,
    IN DWORD dwEncodingType,
    IN OUT PFUNC_SET pFuncSet,
    IN const CRYPT_OID_FUNC_ENTRY *pFuncEntry
    )
{
    PSTR_OID_FUNC_ELEMENT pEle;
    DWORD cbEle;
    DWORD cchOID;
    LPSTR psz;

    cchOID = strlen(pFuncEntry->pszOID) + 1;
    cbEle = sizeof(STR_OID_FUNC_ELEMENT) + cchOID;
    if (NULL == (pEle = (PSTR_OID_FUNC_ELEMENT) PkiZeroAlloc(cbEle)))
        return FALSE;

    pEle->dwOIDType = STR_OID_TYPE;
    pEle->dwEncodingType = dwEncodingType;
    pEle->pNext = NULL;
    psz = (LPSTR) (((BYTE *) pEle) + sizeof(STR_OID_FUNC_ELEMENT));
    pEle->pszOID = psz;
    memcpy(psz, pFuncEntry->pszOID, cchOID);
    pEle->hDll = DuplicateLibrary(hDll);
    pEle->pvFuncAddr = pFuncEntry->pvFuncAddr;

    if (pFuncSet->pStrOIDFuncTail)
        pFuncSet->pStrOIDFuncTail->pNext = pEle;
    else
        pFuncSet->pStrOIDFuncHead = pEle;
    pFuncSet->pStrOIDFuncTail = pEle;
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Free the constant or string function elements
//
//  Upon entry/exit OIDFunc must NOT be locked!!
//--------------------------------------------------------------------------
STATIC void FreeFuncSetConstAndStrElements(
    IN OUT PFUNC_SET pFuncSet
    )
{
    PCONST_OID_FUNC_ELEMENT pConstEle;
    PSTR_OID_FUNC_ELEMENT pStrEle;

    pConstEle = pFuncSet->pConstOIDFuncHead;
    while (pConstEle) {
        PCONST_OID_FUNC_ELEMENT pNextEle = pConstEle->pNext;
        if (pConstEle->hDll)
            FreeLibrary(pConstEle->hDll);
        PkiFree(pConstEle);
        pConstEle = pNextEle;
    }

    pStrEle = pFuncSet->pStrOIDFuncHead;
    while (pStrEle) {
        PSTR_OID_FUNC_ELEMENT pNextEle = pStrEle->pNext;
        if (pStrEle->hDll)
            FreeLibrary(pStrEle->hDll);
        PkiFree(pStrEle);
        pStrEle = pNextEle;
    }
}

//+-------------------------------------------------------------------------
//  Free the function set and its elements
//
//  Upon entry/exit OIDFunc must NOT be locked!!
//--------------------------------------------------------------------------
STATIC void FreeFuncSet(
    IN OUT PFUNC_SET pFuncSet
    )
{
    PREG_OID_FUNC_ELEMENT pRegEle;
    PDEFAULT_REG_ELEMENT  pDefaultReg;

    FreeFuncSetConstAndStrElements(pFuncSet);

    pRegEle = pFuncSet->pRegBeforeOIDFuncHead;
    while (pRegEle) {
        PREG_OID_FUNC_ELEMENT pNextEle = pRegEle->pNext;
        PkiFree(pRegEle);
        pRegEle = pNextEle;
    }

    pRegEle = pFuncSet->pRegAfterOIDFuncHead;
    while (pRegEle) {
        PREG_OID_FUNC_ELEMENT pNextEle = pRegEle->pNext;
        PkiFree(pRegEle);
        pRegEle = pNextEle;
    }

    pDefaultReg = pFuncSet->pDefaultRegHead;
    while (pDefaultReg) {
        PDEFAULT_REG_ELEMENT pNext = pDefaultReg->pNext;
        PkiFree(pDefaultReg);
        pDefaultReg = pNext;
    }

    PkiFree(pFuncSet);
}

//+-------------------------------------------------------------------------
//  Free the Dll and its proc elements
//
//  Upon entry/exit OIDFunc must NOT be locked!!
//--------------------------------------------------------------------------
STATIC void FreeDll(
    IN OUT PDLL_ELEMENT pDll
    )
{
    PDLL_PROC_ELEMENT pProcEle;

    pProcEle = pDll->pProcHead;
    while (pProcEle) {
        PDLL_PROC_ELEMENT pNextEle = pProcEle->pNext;
        PkiFree(pProcEle);
        pProcEle = pNextEle;
    }

    if (pDll->fLoaded) {
        assert(pDll->hDll);
        FreeLibrary(pDll->hDll);
    }

    PkiFree(pDll);
}


//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptOIDFuncDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL fRet = TRUE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        fRet = Pki_InitializeCriticalSection(&OIDFuncCriticalSection);
        hOidInfoInst = hInst;
        break;

    case DLL_PROCESS_DETACH:
        // Do interlock to guard against a potential race condition with
        // the RegWaitFor callback thread. We doing this without doing
        // a LockOIDFunc().
        if (InterlockedExchange(&lFreeDll, 0)) {
            assert(hFreeDllRegWaitFor);
            hFreeDllLibModule = NULL;
            ILS_UnregisterWait(hFreeDllRegWaitFor);
            hFreeDllRegWaitFor = NULL;
        }

        while (pFuncSetHead) {
            PFUNC_SET pFuncSet = pFuncSetHead;
            pFuncSetHead = pFuncSet->pNext;
            FreeFuncSet(pFuncSet);
        }

        while (pDllHead) {
            PDLL_ELEMENT pDll = pDllHead;
            pDllHead = pDll->pNext;
            FreeDll(pDll);
        }
        DeleteCriticalSection(&OIDFuncCriticalSection);
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return fRet;
}

//+-------------------------------------------------------------------------
//  Initialize and return handle to the OID function set identified by its
//  function name.
//
//  If the set already exists, a handle to the existing set is returned.
//--------------------------------------------------------------------------
HCRYPTOIDFUNCSET
WINAPI
CryptInitOIDFunctionSet(
    IN LPCSTR pszFuncName,
    IN DWORD dwFlags
    )
{
    PFUNC_SET pFuncSet;

    LockOIDFunc();

    // See if the set already exists
    for (pFuncSet = pFuncSetHead; pFuncSet; pFuncSet = pFuncSet->pNext) {
        if (0 == strcmp(pszFuncName, pFuncSet->pszFuncName))
            break;
    }
    if (NULL == pFuncSet) {
        // Allocate and initialize a new set
        DWORD cchFuncName = strlen(pszFuncName) + 1;
        if (pFuncSet = (PFUNC_SET) PkiZeroAlloc(
                sizeof(FUNC_SET) + cchFuncName)) {
            LPSTR psz = (LPSTR) (((BYTE *) pFuncSet) + sizeof(FUNC_SET));
            pFuncSet->pszFuncName = psz;
            memcpy(psz, pszFuncName, cchFuncName);

            pFuncSet->pNext = pFuncSetHead;
            pFuncSetHead = pFuncSet;
        }
    }

    UnlockOIDFunc();

    return (HCRYPTOIDFUNCSET) pFuncSet;
}

//+-------------------------------------------------------------------------
//  Install a set of callable OID function addresses.
//
//  By default the functions are installed at end of the list.
//  Set CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG to install at beginning of list.
//
//  hModule should be updated with the hModule passed to DllMain to prevent
//  the Dll containing the function addresses from being unloaded by
//  CryptGetOIDFuncAddress/CryptFreeOIDFunctionAddress. This would be the
//  case when the Dll has also regsvr32'ed OID functions via
//  CryptRegisterOIDFunction.
//
//  DEFAULT functions are installed by setting rgFuncEntry[].pszOID =
//  CRYPT_DEFAULT_OID.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptInstallOIDFunctionAddress(
    IN HMODULE hModule,         // hModule passed to DllMain
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN DWORD cFuncEntry,
    IN const CRYPT_OID_FUNC_ENTRY rgFuncEntry[],
    IN DWORD dwFlags
    )
{
    BOOL fResult;
    PFUNC_SET pFuncSet;
    FUNC_SET AddFuncSet;
    memset(&AddFuncSet, 0, sizeof(AddFuncSet));
    int ConstFirst = -1;
    int ConstLast = 0;
    DWORD_PTR dwOID;
    DWORD_PTR dwLastOID = 0;
    DWORD i;

    dwEncodingType = GetEncodingType(dwEncodingType);
    if (NULL == (pFuncSet = (PFUNC_SET) CryptInitOIDFunctionSet(
            pszFuncName, 0)))
        return FALSE;


    // Don't need to hold lock while updating local copy of AddFuncSet.

    for (i = 0; i < cFuncEntry; i++) {
        if (0xFFFF >= (dwOID = (DWORD_PTR) rgFuncEntry[i].pszOID)) {
            if (ConstFirst < 0)
                ConstFirst = i;
            else if (dwOID != dwLastOID + 1) {
                if (!AddConstOIDFunc(
                        hModule,
                        dwEncodingType,
                        &AddFuncSet,
                        ConstLast - ConstFirst + 1,
                        &rgFuncEntry[ConstFirst]
                        )) goto AddConstOIDFuncError;
                ConstFirst = i;
            }
            ConstLast = i;
            dwLastOID = dwOID;
        } else {
            if (ConstFirst >= 0) {
                if (!AddConstOIDFunc(
                        hModule,
                        dwEncodingType,
                        &AddFuncSet,
                        ConstLast - ConstFirst + 1,
                        &rgFuncEntry[ConstFirst]
                        )) goto AddConstOIDFuncError;
                ConstFirst = -1;
            }

            if (!AddStrOIDFunc(
                    hModule,
                    dwEncodingType,
                    &AddFuncSet,
                    &rgFuncEntry[i]
                    )) goto AddStrOIDFuncError;
        }
    }
    if (ConstFirst >= 0) {
        if (!AddConstOIDFunc(
                hModule,
                dwEncodingType,
                &AddFuncSet,
                ConstLast - ConstFirst + 1,
                &rgFuncEntry[ConstFirst]
                )) goto AddConstOIDFuncError;
    }

    // NOTE:::
    //
    //  Since the get function accesses the lists without entering the critical
    //  section, the following pointers must be updated in the correct
    //  order.  Note, Get doesn't access the tail.

    LockOIDFunc();

    if (AddFuncSet.pConstOIDFuncHead) {
        if (NULL == pFuncSet->pConstOIDFuncHead) {
            pFuncSet->pConstOIDFuncHead = AddFuncSet.pConstOIDFuncHead;
            pFuncSet->pConstOIDFuncTail = AddFuncSet.pConstOIDFuncTail;
        } else if (dwFlags & CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG) {
            AddFuncSet.pConstOIDFuncTail->pNext = pFuncSet->pConstOIDFuncHead;
            pFuncSet->pConstOIDFuncHead = AddFuncSet.pConstOIDFuncHead;
        } else {
            pFuncSet->pConstOIDFuncTail->pNext = AddFuncSet.pConstOIDFuncHead;
            pFuncSet->pConstOIDFuncTail = AddFuncSet.pConstOIDFuncTail;
        }
    }

    if (AddFuncSet.pStrOIDFuncHead) {
        if (NULL == pFuncSet->pStrOIDFuncHead) {
            pFuncSet->pStrOIDFuncHead = AddFuncSet.pStrOIDFuncHead;
            pFuncSet->pStrOIDFuncTail = AddFuncSet.pStrOIDFuncTail;
        } else if (dwFlags & CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG) {
            AddFuncSet.pStrOIDFuncTail->pNext = pFuncSet->pStrOIDFuncHead;
            pFuncSet->pStrOIDFuncHead = AddFuncSet.pStrOIDFuncHead;
        } else {
            pFuncSet->pStrOIDFuncTail->pNext = AddFuncSet.pStrOIDFuncHead;
            pFuncSet->pStrOIDFuncTail = AddFuncSet.pStrOIDFuncTail;
        }
    }

    UnlockOIDFunc();
    fResult = TRUE;

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    FreeFuncSetConstAndStrElements(&AddFuncSet);
    goto CommonReturn;
TRACE_ERROR(AddConstOIDFuncError)
TRACE_ERROR(AddStrOIDFuncError)
}

STATIC LPSTR EncodingTypeToRegName(
    IN DWORD dwEncodingType
    )
{
    LPSTR pszRegName;
    DWORD cchRegName;
    char szEncodingTypeValue[33];

    dwEncodingType = GetEncodingType(dwEncodingType);
    _ltoa(dwEncodingType, szEncodingTypeValue, 10);
    cchRegName = strlen(CRYPT_OID_REG_ENCODING_TYPE_PREFIX) +
        strlen(szEncodingTypeValue) +
        1;

    if (pszRegName = (LPSTR) PkiNonzeroAlloc(cchRegName)) {
        strcpy(pszRegName, CRYPT_OID_REG_ENCODING_TYPE_PREFIX);
        strcat(pszRegName, szEncodingTypeValue);
    }

    return pszRegName;
}

// Returns FALSE for an invalid EncodingType reg name
STATIC BOOL RegNameToEncodingType(
    IN LPCSTR pszRegEncodingType,
    OUT DWORD *pdwEncodingType
    )
{
    BOOL fResult = FALSE;
    DWORD dwEncodingType = 0;
    const DWORD cchPrefix = strlen(CRYPT_OID_REG_ENCODING_TYPE_PREFIX);
    if (pszRegEncodingType && (DWORD) strlen(pszRegEncodingType) >= cchPrefix &&
            2 == CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                pszRegEncodingType, cchPrefix,
                CRYPT_OID_REG_ENCODING_TYPE_PREFIX, cchPrefix)) {
        long lEncodingType;
        lEncodingType = atol(pszRegEncodingType + cchPrefix);
        if (lEncodingType >= 0 && lEncodingType <= 0xFFFF) {
            dwEncodingType = (DWORD) lEncodingType;
            fResult = TRUE;
        }
    }
    *pdwEncodingType = dwEncodingType;
    return fResult;
}

STATIC LPSTR FormatOIDFuncRegName(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID
    )
{

    LPSTR pszRegEncodingType;
    LPSTR pszRegName;
    DWORD cchRegName;
    char szOID[34];

    if (pszOID == NULL) {
        SetLastError((DWORD) E_INVALIDARG);
        return NULL;
    }

    if (NULL == (pszRegEncodingType = EncodingTypeToRegName(dwEncodingType)))
        return NULL;

    if ((DWORD_PTR) pszOID <= 0xFFFF) {
        szOID[0] = CONST_OID_STR_PREFIX_CHAR;
        _ltoa((long) ((DWORD_PTR)pszOID), szOID + 1, 10);
        pszOID = szOID;
    }

    cchRegName = strlen(CRYPT_OID_REGPATH "\\") +
        strlen(pszRegEncodingType) + 1 +
        strlen(pszFuncName) + 1 +
        strlen(pszOID) +
        1;

    if (pszRegName = (LPSTR) PkiNonzeroAlloc(cchRegName)) {
        strcpy(pszRegName, CRYPT_OID_REGPATH "\\");
        strcat(pszRegName, pszRegEncodingType);
        strcat(pszRegName, "\\");
        strcat(pszRegName, pszFuncName);
        strcat(pszRegName, "\\");
        strcat(pszRegName, pszOID);
    }

    PkiFree(pszRegEncodingType);
    return pszRegName;
}

//+-------------------------------------------------------------------------
//  Set the value for the specified encoding type, function name, OID and
//  value name.
//
//  See RegSetValueEx for the possible value types.
//
//  String types are UNICODE.
//
//  If pbValueData == NULL and cbValueData == 0, deletes the value.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSetOIDFunctionValue(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN LPCWSTR pwszValueName,
    IN DWORD dwValueType,
    IN const BYTE *pbValueData,
    IN DWORD cbValueData
    )
{
    BOOL fResult;
    LONG lStatus;
    LPSTR pszRegName = NULL;
    HKEY hKey = NULL;
    DWORD dwDisposition;

    if (NULL == (pszRegName = FormatOIDFuncRegName(
            dwEncodingType, pszFuncName, pszOID)))
        goto FormatRegNameError;

    if (ERROR_SUCCESS != (lStatus = RegCreateKeyExA(
            HKEY_LOCAL_MACHINE,
            pszRegName,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            KEY_WRITE,
            NULL,                   // lpSecurityAttributes
            &hKey,
            &dwDisposition)))
        goto RegCreateKeyError;

    if (NULL == pbValueData && 0 == cbValueData) {
        if (ERROR_SUCCESS != (lStatus = RegDeleteValueU(
                hKey,
                pwszValueName)))
            goto RegDeleteValueError;
    } else {
        if (ERROR_SUCCESS != (lStatus = RegSetValueExU(
                hKey,
                pwszValueName,
                0,          // dwReserved
                dwValueType,
                pbValueData,
                cbValueData)))
            goto RegSetValueError;
    }

    fResult = TRUE;
CommonReturn:
    if (pszRegName)
        PkiFree(pszRegName);
    if (hKey)
       RegCloseKey(hKey);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FormatRegNameError)
SET_ERROR_VAR(RegCreateKeyError, lStatus)
SET_ERROR_VAR(RegDeleteValueError, lStatus)
SET_ERROR_VAR(RegSetValueError, lStatus)
}


//+-------------------------------------------------------------------------
//  Get the value for the specified encoding type, function name, OID and
//  value name.
//
//  See RegEnumValue for the possible value types.
//
//  String types are UNICODE.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptGetOIDFunctionValue(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN LPCWSTR pwszValueName,
    OUT DWORD *pdwValueType,
    OUT BYTE *pbValueData,
    IN OUT DWORD *pcbValueData
    )
{
    BOOL fResult;
    LONG lStatus;
    LPSTR pszRegName = NULL;
    HKEY hKey = NULL;

    if (NULL == (pszRegName = FormatOIDFuncRegName(
            dwEncodingType, pszFuncName, pszOID)))
        goto FormatRegNameError;

    if (ERROR_SUCCESS != (lStatus = RegOpenKeyExA(
            HKEY_LOCAL_MACHINE,
            pszRegName,
            0,                  // dwReserved
            KEY_READ,
            &hKey))) {
        if (ERROR_FILE_NOT_FOUND == lStatus) {
            // Inhibit error tracing
            SetLastError((DWORD) lStatus);
            goto ErrorReturn;
        }
        goto RegOpenKeyError;
    }

    if (ERROR_SUCCESS != (lStatus = RegQueryValueExU(
            hKey,
            pwszValueName,
            NULL,       // lpdwReserved
            pdwValueType,
            pbValueData,
            pcbValueData))) goto RegQueryValueError;

    fResult = TRUE;
CommonReturn:
    if (pszRegName)
        PkiFree(pszRegName);
    if (hKey)
       RegCloseKey(hKey);
    return fResult;

ErrorReturn:
    *pdwValueType = 0;
    *pcbValueData = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FormatRegNameError)
SET_ERROR_VAR(RegOpenKeyError, lStatus)
SET_ERROR_VAR(RegQueryValueError, lStatus)
}


//+-------------------------------------------------------------------------
//  Register the Dll containing the function to be called for the specified
//  encoding type, function name and OID.
//
//  pwszDll may contain environment-variable strings
//  which are ExpandEnvironmentStrings()'ed before loading the Dll.
//
//  In addition to registering the DLL, you may override the
//  name of the function to be called. For example,
//      pszFuncName = "CryptDllEncodeObject",
//      pszOverrideFuncName = "MyEncodeXyz".
//  This allows a Dll to export multiple OID functions for the same
//  function name without needing to interpose its own OID dispatcher function.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptRegisterOIDFunction(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN OPTIONAL LPCWSTR pwszDll,
    IN OPTIONAL LPCSTR pszOverrideFuncName
    )
{
    BOOL fResult;
    LPWSTR pwszOverrideFuncName = NULL;

    if (pwszDll) {
        if (!CryptSetOIDFunctionValue(
                dwEncodingType,
                pszFuncName,
                pszOID,
                CRYPT_OID_REG_DLL_VALUE_NAME,
                REG_SZ,
                (BYTE *) pwszDll,
                (wcslen(pwszDll) + 1) * sizeof(WCHAR)))
            goto SetDllError;
    }

    if (pszOverrideFuncName) {
        if (NULL == (pwszOverrideFuncName = MkWStr(
                (LPSTR) pszOverrideFuncName)))
            goto MkWStrError;
        if (!CryptSetOIDFunctionValue(
                dwEncodingType,
                pszFuncName,
                pszOID,
                CRYPT_OID_REG_FUNC_NAME_VALUE_NAME,
                REG_SZ,
                (BYTE *) pwszOverrideFuncName,
                (wcslen(pwszOverrideFuncName) + 1) * sizeof(WCHAR)))
            goto SetFuncNameError;
    }

    fResult = TRUE;
CommonReturn:
    if (pwszOverrideFuncName)
        FreeWStr(pwszOverrideFuncName);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(SetDllError)
TRACE_ERROR(SetFuncNameError)
TRACE_ERROR(MkWStrError)
}

//+-------------------------------------------------------------------------
//  Unregister the Dll containing the function to be called for the specified
//  encoding type, function name and OID.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptUnregisterOIDFunction(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID
    )
{
    BOOL fResult;
    LONG lStatus;
    LPSTR pszRegName = NULL;
    LPSTR pszRegOID;
    HKEY hKey = NULL;

    if (NULL == (pszRegName = FormatOIDFuncRegName(
            dwEncodingType, pszFuncName, pszOID)))
        goto FormatRegNameError;

    // Separate off the OID component of the RegName. Its the
    // last component of the name.
    pszRegOID = pszRegName + strlen(pszRegName);
    while (*pszRegOID != '\\')
        pszRegOID--;
    *pszRegOID++ = '\0';

    if (ERROR_SUCCESS != (lStatus = RegOpenKeyExA(
            HKEY_LOCAL_MACHINE,
            pszRegName,
            0,                  // dwReserved
            KEY_WRITE,
            &hKey))) goto RegOpenKeyError;

    if (ERROR_SUCCESS != (lStatus = RegDeleteKeyA(
            hKey,
            pszRegOID)))
        goto RegDeleteKeyError;

    fResult = TRUE;
CommonReturn:
    if (pszRegName)
        PkiFree(pszRegName);
    if (hKey)
       RegCloseKey(hKey);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FormatRegNameError)
SET_ERROR_VAR(RegOpenKeyError, lStatus)
SET_ERROR_VAR(RegDeleteKeyError, lStatus)
}

STATIC BOOL GetDefaultDllList(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    OUT LPWSTR pwszList,
    IN OUT DWORD *pcchList
    )
{
    BOOL fResult;
    DWORD dwType;
    DWORD cchList;
    DWORD cbList;

    cchList = *pcchList;
    if (pwszList) {
        if (cchList < 3)
            goto InvalidArg;
        else
            // make room for two extra null terminators
            cchList -= 2;
    } else
        cchList = 0;

    cbList = cchList * sizeof(WCHAR);
    fResult = CryptGetOIDFunctionValue(
            dwEncodingType,
            pszFuncName,
            CRYPT_DEFAULT_OID,
            CRYPT_OID_REG_DLL_VALUE_NAME,
            &dwType,
            (BYTE *) pwszList,
            &cbList);
    cchList = cbList / sizeof(WCHAR);
    if (!fResult) {
        if (ERROR_FILE_NOT_FOUND != GetLastError()) {
            if (cchList)
                cchList += 2;
            goto GetOIDFunctionValueError;
        }
        cchList = 0;
    } else if (!(REG_MULTI_SZ == dwType ||
            REG_SZ == dwType || REG_EXPAND_SZ == dwType))
        goto BadDefaultListRegType;

    if (pwszList) {
        // Ensure the list has two null terminators
        pwszList[cchList++] = L'\0';
        pwszList[cchList++] = L'\0';
    } else {
        if (cchList == 0)
            cchList = 3;
        else
            cchList += 2;
    }
    fResult = TRUE;
CommonReturn:
    *pcchList = cchList;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetOIDFunctionValueError)
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(BadDefaultListRegType, E_INVALIDARG)
}

// Remove any entries following the first empty string.
STATIC DWORD AdjustDefaultListLength(
    IN LPCWSTR pwszList
    )
{
    LPCWSTR pwsz = pwszList;
    DWORD cch;
    while (cch = wcslen(pwsz))
        pwsz += cch + 1;

    return (DWORD)(pwsz - pwszList) + 1;
}

//+-------------------------------------------------------------------------
//  Register the Dll containing the default function to be called for the
//  specified encoding type and function name.
//
//  Unlike CryptRegisterOIDFunction, you can't override the function name
//  needing to be exported by the Dll.
//
//  The Dll is inserted before the entry specified by dwIndex.
//    dwIndex == 0, inserts at the beginning.
//    dwIndex == CRYPT_REGISTER_LAST_INDEX, appends at the end.
//
//  pwszDll may contain environment-variable strings
//  which are ExpandEnvironmentStrings()'ed before loading the Dll.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptRegisterDefaultOIDFunction(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN DWORD dwIndex,
    IN LPCWSTR pwszDll
    )
{
    BOOL fResult;
    LPWSTR pwszDllList;   // _alloca'ed
    DWORD cchDllList;
    DWORD cchDll;

    LPWSTR pwsz, pwszInsert, pwszSrc, pwszDest;
    DWORD cch, cchRemain;

    if (NULL == pwszDll || L'\0' == *pwszDll)
        goto InvalidArg;
    cchDll = wcslen(pwszDll) + 1;

    if (!GetDefaultDllList(
            dwEncodingType,
            pszFuncName,
            NULL,                   // pwszDllList
            &cchDllList)) goto GetDefaultDllListError;
    __try {
        pwszDllList = (LPWSTR) _alloca((cchDllList + cchDll) * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto OutOfMemory;
    }
    if (!GetDefaultDllList(
            dwEncodingType,
            pszFuncName,
            pwszDllList,
            &cchDllList)) goto GetDefaultDllListError;

    // Remove entries following the first empty entry
    assert(AdjustDefaultListLength(pwszDllList) <= cchDllList);
    cchDllList = AdjustDefaultListLength(pwszDllList);

    // Check if the Dll already exists in the list
    pwsz = pwszDllList;
    while (cch = wcslen(pwsz)) {
        if (0 == _wcsicmp(pwsz, pwszDll))
            goto DllExistsError;
        pwsz += cch + 1;
    }

    // Find the Null terminated DLL in the DllList to insert before.
    // We insert before the dwIndex.
    pwszInsert = pwszDllList;
    while (dwIndex-- && 0 != (cch = wcslen(pwszInsert)))
        pwszInsert += cch + 1;

    // Before inserting, we need to move all the remaining entries in the
    // existing DllList.
    //
    // Note, there must be at least the final zero terminator at
    // pwszDllList[cchDllList - 1].
    assert(pwszInsert < pwszDllList + cchDllList);
    if (pwszInsert >= pwszDllList + cchDllList)
        goto BadRegMultiSzError;
    cchRemain = (DWORD)((pwszDllList + cchDllList) - pwszInsert);
    assert(cchRemain);
    pwszSrc = pwszDllList + cchDllList - 1;
    pwszDest = pwszSrc + cchDll;
    while (cchRemain--)
        *pwszDest-- = *pwszSrc--;
    assert(pwszSrc + 1 == pwszInsert);

    // Insert the pwszDll
    memcpy(pwszInsert, pwszDll, cchDll * sizeof(WCHAR));

    if (!CryptSetOIDFunctionValue(
            dwEncodingType,
            pszFuncName,
            CRYPT_DEFAULT_OID,
            CRYPT_OID_REG_DLL_VALUE_NAME,
            REG_MULTI_SZ,
            (BYTE *) pwszDllList,
            (cchDllList + cchDll) * sizeof(WCHAR))) goto SetDllListError;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
SET_ERROR(DllExistsError, ERROR_FILE_EXISTS)
SET_ERROR(BadRegMultiSzError, E_INVALIDARG)
TRACE_ERROR(GetDefaultDllListError)
TRACE_ERROR(SetDllListError)
}

BOOL
WINAPI
CryptUnregisterDefaultOIDFunction(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCWSTR pwszDll
    )
{
    BOOL fResult;
    LPWSTR pwszDllList;   // _alloca'ed
    DWORD cchDllList;
    DWORD cchDll;

    LPWSTR pwszDelete, pwszMove;
    DWORD cchDelete, cchRemain;

    if (NULL == pwszDll || L'\0' == *pwszDll)
        goto InvalidArg;
    cchDll = wcslen(pwszDll) + 1;

    if (!GetDefaultDllList(
            dwEncodingType,
            pszFuncName,
            NULL,                   // pwszDllList
            &cchDllList)) goto GetDefaultDllListError;
    __try {
        pwszDllList = (LPWSTR) _alloca(cchDllList * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto OutOfMemory;
    }
    if (!GetDefaultDllList(
            dwEncodingType,
            pszFuncName,
            pwszDllList,
            &cchDllList)) goto GetDefaultDllListError;

    // Remove entries following the first empty entry
    assert(AdjustDefaultListLength(pwszDllList) <= cchDllList);
    cchDllList = AdjustDefaultListLength(pwszDllList);

    // Search the DllList for a match
    pwszDelete = pwszDllList;
    while (cchDelete = wcslen(pwszDelete)) {
        if (0 == _wcsicmp(pwszDll, pwszDelete))
            break;
        pwszDelete += cchDelete + 1;
    }

    if (0 == cchDelete) goto DllNotFound;
    cchDelete++;
    assert(cchDelete == cchDll);

    // Move all the Dll entries that follow.
    //
    // Note, there must be at least the final zero terminator at
    // pwszDllList[cchDllList - 1].
    pwszMove = pwszDelete + cchDelete;
    assert(pwszMove < pwszDllList + cchDllList);
    if (pwszMove >= pwszDllList + cchDllList)
        goto BadRegMultiSzError;
    cchRemain = (DWORD)((pwszDllList + cchDllList) - pwszMove);
    assert(cchRemain);
    while (cchRemain--)
        *pwszDelete++ = *pwszMove++;

    if (!CryptSetOIDFunctionValue(
            dwEncodingType,
            pszFuncName,
            CRYPT_DEFAULT_OID,
            CRYPT_OID_REG_DLL_VALUE_NAME,
            REG_MULTI_SZ,
            (BYTE *) pwszDllList,
            (cchDllList - cchDelete) * sizeof(WCHAR))) goto SetDllListError;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(DllNotFound, ERROR_FILE_NOT_FOUND)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
SET_ERROR(BadRegMultiSzError, E_INVALIDARG)
TRACE_ERROR(GetDefaultDllListError)
TRACE_ERROR(SetDllListError)
}

#define MAX_SUBKEY_LEN      128

STATIC HKEY GetNextRegSubKey(
    IN HKEY hKey,
    IN OUT DWORD *piSubKey,
    IN LPCSTR pszFuncNameMatch,
    OUT char szSubKeyName[MAX_SUBKEY_LEN]
    )
{
    HKEY hSubKey;

    if (pszFuncNameMatch && *pszFuncNameMatch) {
        if ((*piSubKey)++ > 0 || strlen(pszFuncNameMatch) >= MAX_SUBKEY_LEN)
            return NULL;
        strcpy(szSubKeyName, pszFuncNameMatch);
    } else {
        if (ERROR_SUCCESS != RegEnumKeyA(
                hKey,
                (*piSubKey)++,
                szSubKeyName,
                MAX_SUBKEY_LEN))
            return NULL;
    }

    if (ERROR_SUCCESS == RegOpenKeyExA(
            hKey,
            szSubKeyName,
            0,                  // dwReserved
            KEY_READ,
            &hSubKey))
        return hSubKey;
    else
        return NULL;
}

STATIC BOOL GetRegValues(
    IN HKEY hKey,
    OUT void **ppvAlloc,
    OUT DWORD *pcValue,
    OUT DWORD **ppdwValueType,
    OUT LPWSTR **pppwszValueName,
    OUT BYTE ***pppbValueData,
    OUT DWORD **ppcbValueData
    )
{
    BOOL fResult;
    LONG lStatus;

    void *pvAlloc = NULL;

    DWORD cValue;
    DWORD iValue;
    DWORD cchMaxName;
    DWORD cbMaxData;
    DWORD cbAlignData = 0;

    DWORD *pdwValueType;
    LPWSTR *ppwszValueName;
    BYTE **ppbValueData;
    DWORD *pcbValueData;

    LPWSTR pwszName;
    BYTE *pbData;

    if (ERROR_SUCCESS != (lStatus = RegQueryInfoKeyU(
            hKey,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            &cValue,
            &cchMaxName,
            &cbMaxData,
            NULL,
            NULL
            ))) goto RegQueryInfoKeyError;

    // Do a single allocation for all the arrays, value names and
    // value data. Update the array pointers.
    if (cValue > 0) {
        BYTE *pbAlloc;
        DWORD cbAlloc;

        // Include NULL terminator for the name and align the data length
        // Also, include two NULL terminators to be added for the data.
        // Ensures REG_MULTI_SZ is always NULL terminated.
        cchMaxName++;
        if (4 > cbMaxData)
            cbMaxData = 4;
        cbAlignData = LEN_ALIGN(cbMaxData + 2 * sizeof(WCHAR));

        cbAlloc = (sizeof(DWORD) + sizeof(LPWSTR) + sizeof(BYTE *) +
             sizeof(DWORD) + cchMaxName * sizeof(WCHAR) + cbAlignData) * cValue;
        if (NULL == (pvAlloc = PkiNonzeroAlloc(cbAlloc)))
            goto OutOfMemory;

        pbAlloc = (BYTE *) pvAlloc;

        ppwszValueName = (LPWSTR *) pbAlloc;
        pbAlloc += sizeof(LPWSTR) * cValue;
        ppbValueData = (BYTE **) pbAlloc;
        pbAlloc += sizeof(BYTE *) * cValue;
        pdwValueType = (DWORD *) pbAlloc;
        pbAlloc += sizeof(DWORD) * cValue;
        pcbValueData = (DWORD *) pbAlloc;
        pbAlloc += sizeof(DWORD) * cValue;

        pbData = pbAlloc;
        pbAlloc += cbAlignData * cValue;
        pwszName = (LPWSTR) pbAlloc;
        assert(((BYTE *) pvAlloc) + cbAlloc ==
            pbAlloc + (cchMaxName * sizeof(WCHAR)) * cValue);
    } else {
        ppwszValueName = NULL;
        ppbValueData = NULL;
        pdwValueType = NULL;
        pcbValueData = NULL;
        pbData = NULL;
        pwszName = NULL;
    }

    for (iValue = 0; iValue < cValue;
                iValue++, pwszName += cchMaxName, pbData += cbAlignData) {
        DWORD cchName = cchMaxName;
        DWORD cbData = cbMaxData;
        DWORD dwType;

        if (ERROR_SUCCESS != (lStatus = RegEnumValueU(
                hKey,
                iValue,
                pwszName,
                &cchName,
                NULL,       // pdwReserved
                &dwType,
                pbData,
                &cbData
                )))
            goto RegEnumValueError;

        // Ensure the data has two NULL terminators for REG_MULTI_SZ
        // Note cbAlignData >= cbMaxData + 2 * sizeof(WCHAR)
        memset(pbData + cbData, 0, 2 * sizeof(WCHAR));

        pdwValueType[iValue] = dwType;
        ppwszValueName[iValue] = pwszName;
        ppbValueData[iValue] = pbData;
        pcbValueData[iValue] = cbData;
    }

    fResult = TRUE;
CommonReturn:
    *ppvAlloc = pvAlloc;
    *pcValue = cValue;
    *ppdwValueType = pdwValueType;
    *pppwszValueName = ppwszValueName;
    *pppbValueData = ppbValueData;
    *ppcbValueData = pcbValueData;
    return fResult;

ErrorReturn:
    if (pvAlloc) {
        PkiFree(pvAlloc);
        pvAlloc = NULL;
    }

    cValue = 0;
    pdwValueType = NULL;
    ppwszValueName = NULL;
    ppbValueData = NULL;
    pcbValueData = NULL;

    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(RegQueryInfoKeyError, lStatus)
SET_ERROR_VAR(RegEnumValueError, lStatus)
}

//+-------------------------------------------------------------------------
//  Enumerate the OID functions identified by their encoding type,
//  function name and OID.
//
//  pfnEnumOIDFunc is called for each registry key matching the input
//  parameters. Setting dwEncodingType to CRYPT_MATCH_ANY_ENCODING_TYPE matches
//  any. Setting pszFuncName or pszOID to NULL matches any.
//
//  Set pszOID == CRYPT_DEFAULT_OID to restrict the enumeration to only the
//  DEFAULT functions
//
//  String types are UNICODE.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptEnumOIDFunction(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN DWORD dwFlags,
    IN void *pvArg,
    IN PFN_CRYPT_ENUM_OID_FUNC pfnEnumOIDFunc
    )
{
    HKEY hRegKey;
    LPSTR pszEncodingType = NULL;
    char szOID[34];

    if (CRYPT_MATCH_ANY_ENCODING_TYPE != dwEncodingType) {
        dwEncodingType = GetEncodingType(dwEncodingType);
        if (NULL == (pszEncodingType = EncodingTypeToRegName(dwEncodingType)))
            return FALSE;
    }

    if (pszOID && (DWORD_PTR) pszOID <= 0xFFFF) {
        szOID[0] = CONST_OID_STR_PREFIX_CHAR;
        _ltoa((DWORD) ((DWORD_PTR)pszOID), szOID + 1, 10);
        pszOID = szOID;
    }

    if (ERROR_SUCCESS == RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            CRYPT_OID_REGPATH,
            0,                  // dwReserved
            KEY_READ,
            &hRegKey)) {
        // Enumerate and optionally match encoding type
        HKEY hEncodingTypeKey;
        DWORD iEncodingType = 0;
        char szRegEncodingType[MAX_SUBKEY_LEN];
        while (hEncodingTypeKey = GetNextRegSubKey(hRegKey,
                &iEncodingType, pszEncodingType, szRegEncodingType)) {
            // Convert the EncodingType string and validate
            DWORD dwRegEncodingType;
            if (RegNameToEncodingType(szRegEncodingType, &dwRegEncodingType)) {
                // Enumerate and optionally match FuncName, for example,
                // ("CryptDllEncodeObject")
                HKEY hFuncName;
                DWORD iFuncName = 0;
                char szRegFuncName[MAX_SUBKEY_LEN];
                while (hFuncName = GetNextRegSubKey(hEncodingTypeKey,
                        &iFuncName, pszFuncName, szRegFuncName)) {
                    // Enumerate and optionally match OID string ("1.2.3.4")
                    HKEY hOID;
                    DWORD iOID = 0;
                    char szRegOID[MAX_SUBKEY_LEN];
                    while (hOID = GetNextRegSubKey(hFuncName, &iOID, pszOID,
                            szRegOID)) {
                        // Read and allocate  the registry values
                        void *pvAlloc;
                        DWORD cValue;
                        DWORD *pdwValueType;
                        LPWSTR *ppwszValueName;
                        BYTE **ppbValueData;
                        DWORD *pcbValueData;

                        if (GetRegValues(
                                hOID,
                                &pvAlloc,
                                &cValue,
                                &pdwValueType,
                                &ppwszValueName,
                                &ppbValueData,
                                &pcbValueData)) {
                            pfnEnumOIDFunc(
                                dwRegEncodingType,
                                szRegFuncName,
                                szRegOID,
                                cValue,
                                pdwValueType,
                                (LPCWSTR *) ppwszValueName,
                                (const BYTE **) ppbValueData,
                                pcbValueData,
                                pvArg);
                            if (pvAlloc)
                                PkiFree(pvAlloc);
                        }
                        RegCloseKey(hOID);
                    }
                    RegCloseKey(hFuncName);
                }
            }
            RegCloseKey(hEncodingTypeKey);
        }
        RegCloseKey(hRegKey);
    }

    if (pszEncodingType)
        PkiFree(pszEncodingType);
    return TRUE;
}


//+=========================================================================
//  Registry and Dll Load Functions
//==========================================================================

// Note, returned Dll element isn't AddRef'ed
STATIC PDLL_ELEMENT FindDll(
    IN LPCWSTR pwszDll      // not expanded
    )
{
    LPWSTR pwszExpandDll; // _alloca'ed
    WCHAR rgch[4];
    DWORD cchDll;
    PDLL_ELEMENT pDll;

    if (0 == (cchDll = ExpandEnvironmentStringsU(
            pwszDll,
            rgch,               // lpszDest, NON_NULL for win95
            sizeof(rgch)/sizeof(rgch[0]))))     // cchDest
        return NULL;
    __try {
        pwszExpandDll = (LPWSTR) _alloca(cchDll * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        return NULL;
    }
    if (0 == ExpandEnvironmentStringsU(
            pwszDll,
            pwszExpandDll,
            cchDll))
        return NULL;

    LockOIDFunc();

    // Check if we already have an entry
    for (pDll = pDllHead; pDll; pDll = pDll->pNext) {
        if (0 == _wcsicmp(pwszExpandDll, pDll->pwszDll))
            break;
    }

    if (NULL == pDll) {
        // Need to create a new DLL entry and add to our list
        if (pDll = (PDLL_ELEMENT) PkiZeroAlloc(
                sizeof(DLL_ELEMENT) + cchDll * sizeof(WCHAR))) {
            LPWSTR pwszEleDll;

            pDll->dwOIDType = DLL_OID_TYPE;
            pwszEleDll = (LPWSTR) ((BYTE *) pDll + sizeof(DLL_ELEMENT));
            memcpy(pwszEleDll, pwszExpandDll, cchDll * sizeof(WCHAR));
            pDll->pwszDll = pwszEleDll;
            pDll->pNext = pDllHead;
            pDllHead = pDll;
        }
    }

    UnlockOIDFunc();
    return pDll;
}

// Upon entry/exit OIDFunc is locked
STATIC PDLL_PROC_ELEMENT AddDllProc(
    IN LPCSTR pszFuncName,
    IN LPCWSTR pwszDll
    )
{
    PDLL_PROC_ELEMENT pProcEle = NULL;
    PDLL_ELEMENT pDll;
    DWORD cchFuncName;
    DWORD cbEle;
    LPSTR psz;

    cchFuncName = strlen(pszFuncName) + 1;
    cbEle = sizeof(DLL_PROC_ELEMENT) + cchFuncName;
    if (NULL == (pProcEle = (PDLL_PROC_ELEMENT) PkiZeroAlloc(cbEle)))
        goto OutOfMemory;

    if (NULL == (pDll = FindDll(pwszDll)))
        goto FindDllError;

    pProcEle->pNext = pDll->pProcHead;
    pDll->pProcHead = pProcEle;
    pProcEle->pDll = pDll;
    psz = (LPSTR) ((BYTE *) pProcEle + sizeof(DLL_PROC_ELEMENT));
    memcpy(psz, pszFuncName, cchFuncName);
    pProcEle->pszName = psz;
    pProcEle->pvAddr = NULL;

CommonReturn:
    return pProcEle;
ErrorReturn:
    PkiFree(pProcEle);
    pProcEle = NULL;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(FindDllError)
}


// Upon entry/exit OIDFunc is locked
STATIC void AddRegOIDFunc(
    IN DWORD dwEncodingType,
    IN OUT PFUNC_SET pFuncSet,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN LPCWSTR pwszDll,
    IN DWORD dwCryptFlags
    )
{
    PREG_OID_FUNC_ELEMENT pOIDEle = NULL;
    PDLL_PROC_ELEMENT pProcEle; // not allocated, doesn't need to be free'ed
    DWORD cchOID;
    DWORD cbEle;
    LPSTR psz;

    if (0xFFFF < (DWORD_PTR) pszOID)
        cchOID = strlen(pszOID) + 1;
    else
        cchOID = 0;
    cbEle = sizeof(REG_OID_FUNC_ELEMENT) + cchOID;
    if (NULL == (pOIDEle = (PREG_OID_FUNC_ELEMENT) PkiZeroAlloc(cbEle)))
        goto OutOfMemory;

    if (NULL == (pProcEle = AddDllProc(pszFuncName, pwszDll)))
        goto AddDllProcError;

    pOIDEle->dwEncodingType = dwEncodingType;

    if (dwCryptFlags & CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG) {
        pOIDEle->pNext = pFuncSet->pRegBeforeOIDFuncHead;
        pFuncSet->pRegBeforeOIDFuncHead = pOIDEle;
    } else {
        pOIDEle->pNext = pFuncSet->pRegAfterOIDFuncHead;
        pFuncSet->pRegAfterOIDFuncHead = pOIDEle;
    }
    if (cchOID) {
        psz = (LPSTR) ((BYTE *) pOIDEle + sizeof(REG_OID_FUNC_ELEMENT));
        memcpy(psz, pszOID, cchOID);
        pOIDEle->pszOID = psz;
    } else
        pOIDEle->dwOID = (DWORD_PTR) pszOID;
    pOIDEle->pDllProc = pProcEle;

CommonReturn:
    return;
ErrorReturn:
    PkiFree(pOIDEle);
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(AddDllProcError)
}


// Upon entry/exit OIDFunc is locked
STATIC void AddDefaultDllList(
    IN DWORD dwEncodingType,
    IN OUT PFUNC_SET pFuncSet,
    IN LPCWSTR pwszInDllList,
    IN DWORD cchInDllList
    )
{
    LPWSTR pwszDllList;         // _alloca'ed
    LPWSTR pwsz;
    DWORD cchDllList;
    DWORD cchDll;
    DWORD cDll;

    DWORD i;

    PDEFAULT_REG_ELEMENT pEle = NULL;
    DWORD cbEle;
    LPWSTR *ppwszEleDll;
    PDLL_PROC_ELEMENT *ppEleDllProc;
    LPWSTR pwszEleDllList;

    // Ensure cchDllList has 2 terminating NULL characters
    assert(cchInDllList && pwszInDllList);
    cchDllList = cchInDllList + 2;
    __try {
        pwszDllList = (LPWSTR) _alloca(cchDllList * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto OutOfMemory;
    }
    memcpy(pwszDllList, pwszInDllList, cchInDllList * sizeof(WCHAR));
    pwszDllList[cchInDllList] = L'\0';
    pwszDllList[cchInDllList + 1] = L'\0';


    // Get count of null terminated Dlls
    cDll = 0;
    for (pwsz = pwszDllList; 0 != (cchDll = wcslen(pwsz)); pwsz += cchDll + 1)
        cDll++;

    if (0 == cDll)
        goto NoDll;

    cbEle = sizeof(DEFAULT_REG_ELEMENT) +
        cDll * sizeof(LPWSTR) +
        cDll * sizeof(PDLL_PROC_ELEMENT) +
        cchDllList * sizeof(WCHAR)
        ;

    if (NULL == (pEle = (PDEFAULT_REG_ELEMENT) PkiZeroAlloc(cbEle)))
        goto OutOfMemory;
    ppwszEleDll = (LPWSTR *) ((BYTE *) pEle + sizeof(DEFAULT_REG_ELEMENT));
    ppEleDllProc = (PDLL_PROC_ELEMENT *) ((BYTE *) ppwszEleDll +
        cDll * sizeof(LPWSTR));
    pwszEleDllList = (LPWSTR) ((BYTE *) ppEleDllProc +
        cDll * sizeof(PDLL_PROC_ELEMENT));

    assert((BYTE *) pwszEleDllList + cchDllList * sizeof(WCHAR) ==
        (BYTE *) pEle + cbEle);

    pEle->dwEncodingType = dwEncodingType;
//  pEle->pNext =
    memcpy(pwszEleDllList, pwszDllList, cchDllList * sizeof(WCHAR));
    pEle->pwszDllList = pwszEleDllList;
    pEle->cchDllList = cchDllList;
    pEle->cDll = cDll;
    pEle->rgpwszDll = ppwszEleDll;
    pEle->rgpDllProc = ppEleDllProc;

    for (pwsz = pwszEleDllList, i  = 0;
                    0 != (cchDll = wcslen(pwsz)); pwsz += cchDll + 1, i++) {
        ppwszEleDll[i] = pwsz;
        if (NULL == (ppEleDllProc[i] = AddDllProc(
                pFuncSet->pszFuncName, pwsz)))
            goto AddDllProcError;
    }
    assert (i == cDll);

    pEle->pNext = pFuncSet->pDefaultRegHead;
    pFuncSet->pDefaultRegHead = pEle;

CommonReturn:
    return;

ErrorReturn:
    PkiFree(pEle);
    goto CommonReturn;

TRACE_ERROR(NoDll);
TRACE_ERROR(OutOfMemory);
TRACE_ERROR(AddDllProcError);
}


//+-------------------------------------------------------------------------
//  Called by CryptEnumOIDFunction to enumerate through all the
//  registered OID functions.
//
//  Called with OIDFunc locked
//--------------------------------------------------------------------------
STATIC BOOL WINAPI EnumRegFuncCallback(
    IN DWORD dwEncodingType,
    IN LPCSTR pszFuncName,
    IN LPCSTR pszOID,
    IN DWORD cValue,
    IN const DWORD rgdwValueType[],
    IN LPCWSTR const rgpwszValueName[],
    IN const BYTE * const rgpbValueData[],
    IN const DWORD rgcbValueData[],
    IN void *pvArg
    )
{
    PFUNC_SET pFuncSet = (PFUNC_SET) pvArg;

    BOOL fDefaultDllList = FALSE;
    LPCWSTR pwszDll = NULL;                 // not allocated
    DWORD cchDll = 0;
    LPCWSTR pwszOverrideFuncName = NULL;    // not allocated
    DWORD dwCryptFlags = 0;

    assert(pFuncSet);

    if (CONST_OID_STR_PREFIX_CHAR == *pszOID) {
        // Convert "#<number>" string to its corresponding constant OID value
        pszOID = (LPCSTR)(DWORD_PTR) atol(pszOID + 1);
        if (0xFFFF < (DWORD_PTR) pszOID)
            // Invalid OID. Skip it.
            goto InvalidOID;
    } else if (0 == _stricmp(CRYPT_DEFAULT_OID, pszOID))
        fDefaultDllList = TRUE;

    while (cValue--) {
        LPCWSTR pwszValueName = rgpwszValueName[cValue];
        DWORD dwValueType = rgdwValueType[cValue];
        const BYTE *pbValueData = rgpbValueData[cValue];
        DWORD cbValueData = rgcbValueData[cValue];

        if (0 == _wcsicmp(pwszValueName, CRYPT_OID_REG_DLL_VALUE_NAME)) {
            if (REG_SZ == dwValueType || REG_EXPAND_SZ == dwValueType ||
                    (fDefaultDllList && REG_MULTI_SZ == dwValueType)) {
                pwszDll = (LPCWSTR) pbValueData;
                cchDll = cbValueData / sizeof(WCHAR);
            } else
                // Invalid "Dll" value.
                goto InvalidDll;
        } else if (0 == _wcsicmp(pwszValueName,
                CRYPT_OID_REG_FUNC_NAME_VALUE_NAME)) {
            if (REG_SZ == dwValueType) {
                LPCWSTR pwszValue = (LPCWSTR) pbValueData;
                if (L'\0' != *pwszValue)
                    pwszOverrideFuncName = pwszValue;
            } else
                // Invalid "FuncName" value.
                goto InvalidFuncName;
        } else if (0 == _wcsicmp(pwszValueName,
                CRYPT_OID_REG_FLAGS_VALUE_NAME)) {
            if (REG_DWORD == dwValueType &&
                    cbValueData >= sizeof(dwCryptFlags))
                memcpy(&dwCryptFlags, pbValueData, sizeof(dwCryptFlags));
            // else
            //  Ignore invalid CryptFlags value type
        }
    }

    if (0 == cchDll || L'\0' == *pwszDll)
        goto NoDll;

    if (fDefaultDllList)
        AddDefaultDllList(
            dwEncodingType,
            pFuncSet,
            pwszDll,
            cchDll
            );
    else {
        BYTE rgb[_MAX_PATH];
        if (pwszOverrideFuncName) {
            if (!MkMBStr(rgb, _MAX_PATH, pwszOverrideFuncName,
                    (LPSTR *) &pszFuncName))
                goto MkMBStrError;
        }
        AddRegOIDFunc(
            dwEncodingType,
            pFuncSet,
            pszFuncName,
            pszOID,
            pwszDll,
            dwCryptFlags
            );
        if (pwszOverrideFuncName)
            FreeMBStr(rgb, (LPSTR) pszFuncName);
    }

CommonReturn:
    return TRUE;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(InvalidOID)
TRACE_ERROR(InvalidDll)
TRACE_ERROR(InvalidFuncName)
TRACE_ERROR(NoDll)
TRACE_ERROR(MkMBStrError)
}

STATIC void LoadRegFunc(
    IN OUT PFUNC_SET pFuncSet
    )
{
    LockOIDFunc();
    if (pFuncSet->fRegLoaded)
        goto CommonReturn;

    CryptEnumOIDFunction(
        CRYPT_MATCH_ANY_ENCODING_TYPE,
        pFuncSet->pszFuncName,
        NULL,                           // pszOID
        0,                              // dwFlags
        (void *) pFuncSet,              // pvArg
        EnumRegFuncCallback
        );
    pFuncSet->fRegLoaded = TRUE;

CommonReturn:
    UnlockOIDFunc();
    return;
}

// Upon entry/exit OIDFunc is locked
STATIC void RemoveFreeDll(
    IN PDLL_ELEMENT pDll
    )
{
    // Remove Dll from free list
    if (pDll->pFreeNext)
        pDll->pFreeNext->pFreePrev = pDll->pFreePrev;
    if (pDll->pFreePrev)
        pDll->pFreePrev->pFreeNext = pDll->pFreeNext;
    else if (pDll == pFreeDllHead)
        pFreeDllHead = pDll->pFreeNext;
    // else
    //  Not on any list

    pDll->pFreeNext = NULL;
    pDll->pFreePrev = NULL;

    assert(dwFreeDllCnt);
    if (dwFreeDllCnt)
        dwFreeDllCnt--;
}

// Upon entry/exit OIDFunc is locked
STATIC void AddRefDll(
    IN PDLL_ELEMENT pDll
    )
{
    pDll->dwRefCnt++;
    if (pDll->dwFreeCnt) {
        pDll->dwFreeCnt = 0;
        RemoveFreeDll(pDll);
    }
}

// Note, MUST NOT HOLD OID LOCK WHILE CALLING FreeLibrary()!!
//
// Therefore, will put the Dll's to be freed on a list while holding the
// OID LOCK. After releasing the OID LOCK, will iterate through the
// list and call FreeLibrary().
STATIC VOID NTAPI FreeDllWaitForCallback(
    PVOID Context,
    BOOLEAN fWaitOrTimedOut     // ???
    )
{
    PDLL_ELEMENT pFreeDll;
    HMODULE *phFreeLibrary = NULL;  // _alloca'ed
    DWORD cFreeLibrary = 0;

    LockOIDFunc();

    if (dwFreeDllCnt) {
        DWORD dwOrigFreeDllCnt = dwFreeDllCnt;
    __try {
        phFreeLibrary = (HMODULE *) _alloca(
            dwOrigFreeDllCnt * sizeof(HMODULE));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
            goto OutOfMemory;
    }

        pFreeDll = pFreeDllHead;
        assert(pFreeDll);
        while (pFreeDll) {
            PDLL_ELEMENT pDll = pFreeDll;
            pFreeDll = pFreeDll->pFreeNext;

            assert(pDll->dwFreeCnt);
            if (0 == --pDll->dwFreeCnt) {
                RemoveFreeDll(pDll);

                assert(pDll->fLoaded);
                if (!pDll->fLoaded)
                    continue;
                if (NULL == pDll->pfnDllCanUnloadNow ||
                        S_OK == pDll->pfnDllCanUnloadNow()) {
                    assert(cFreeLibrary < dwOrigFreeDllCnt);
                    if (cFreeLibrary < dwOrigFreeDllCnt) {
                        PDLL_PROC_ELEMENT pEle;

                        // Loop and NULL all proc addresses
                        for (pEle = pDll->pProcHead; pEle; pEle = pEle->pNext)
                            pEle->pvAddr = NULL;

                        pDll->pfnDllCanUnloadNow = NULL;
                        // Add to array to be freed after releasing lock!!
                        assert(pDll->hDll);
                        phFreeLibrary[cFreeLibrary++] = pDll->hDll;
                        pDll->hDll = NULL;
                        pDll->fLoaded = FALSE;
                    }
                }
            }
        }
    } else {
        assert(NULL == pFreeDllHead);
    }

    if (NULL == pFreeDllHead) {
        assert(0 == dwFreeDllCnt);
        // Do interlock to guard against a potential race condition at
        // PROCESS_DETACH. Note, PROCESS_DETACH doesn't do a LockOIDFunc().
        if (InterlockedExchange(&lFreeDll, 0)) {
            HANDLE hRegWaitFor;
            HMODULE hDllLibModule;

            hRegWaitFor = hFreeDllRegWaitFor;
            hFreeDllRegWaitFor = NULL;
            hDllLibModule = hFreeDllLibModule;
            hFreeDllLibModule = NULL;
            UnlockOIDFunc();

            while (cFreeLibrary--)
                FreeLibrary(phFreeLibrary[cFreeLibrary]);

            assert(hRegWaitFor);
            ILS_ExitWait(hRegWaitFor, hDllLibModule);
            assert(FALSE);
            return;
        }
    }

CommonReturn:
    UnlockOIDFunc();
    while (cFreeLibrary--)
        FreeLibrary(phFreeLibrary[cFreeLibrary]);
    return;

ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(OutOfMemory);
}

STATIC void ReleaseDll(
    IN PDLL_ELEMENT pDll
    )
{
    LockOIDFunc();
    assert(pDll->dwRefCnt);
    if (0 == --pDll->dwRefCnt) {
        assert(pDll->fLoaded);
        if (!pDll->fLoaded)
            goto CommonReturn;

        assert(0 == pDll->dwFreeCnt);
        if (pDll->dwFreeCnt)
            goto CommonReturn;

        if (0 == lFreeDll) {
            assert(NULL == hFreeDllRegWaitFor);
            assert(NULL == hFreeDllLibModule);

            // Inhibit crypt32.dll from being unloaded until this thread
            // exits.
            hFreeDllLibModule = DuplicateLibrary(hOidInfoInst);
            if (!ILS_RegisterWaitForSingleObject(
                    &hFreeDllRegWaitFor,
                    NULL,                   // hObject
                    FreeDllWaitForCallback,
                    NULL,                   // Context
                    FREE_DLL_TIMEOUT,
                    0                       // dwFlags
                    )) {
                hFreeDllRegWaitFor = NULL;
                if (hFreeDllLibModule) {
                    FreeLibrary(hFreeDllLibModule);
                    hFreeDllLibModule = NULL;
                }
                goto RegisterWaitForError;
            }

            lFreeDll = 1;
        }

        assert(NULL == pDll->pFreeNext);
        assert(NULL == pDll->pFreePrev);
        pDll->dwFreeCnt = 2;
        if (pFreeDllHead) {
            pFreeDllHead->pFreePrev = pDll;
            pDll->pFreeNext = pFreeDllHead;
        }
        pFreeDllHead = pDll;
        dwFreeDllCnt++;
    }

CommonReturn:
    UnlockOIDFunc();
    return;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(RegisterWaitForError)
}

// Upon entry/exit OIDFunc must NOT be locked!!
STATIC BOOL LoadDll(
    IN PDLL_ELEMENT pDll
    )
{
    BOOL fResult;
    HMODULE hDll = NULL;
    LPFNCANUNLOADNOW pfnDllCanUnloadNow = NULL;

    LockOIDFunc();
    if (pDll->fLoaded)
        AddRefDll(pDll);
    else {
        UnlockOIDFunc();
        // NO LoadLibrary() or GetProcAddress() while holding OID lock!!
        hDll = LoadLibraryExU(pDll->pwszDll, NULL, 0);
        if (hDll)
            pfnDllCanUnloadNow = (LPFNCANUNLOADNOW) GetProcAddress(
                hDll, "DllCanUnloadNow");
        LockOIDFunc();
        
        AddRefDll(pDll);
        if (!pDll->fLoaded) {
            assert(1 == pDll->dwRefCnt);
            assert(0 == pDll->dwFreeCnt);
            assert(pDll->pwszDll);
            assert(NULL == pDll->hDll);
            if (NULL == (pDll->hDll = hDll)) {
                pDll->dwRefCnt = 0;
                goto LoadLibraryError;
            }
            hDll = NULL;
            pDll->fLoaded = TRUE;

            assert(NULL == pDll->pfnDllCanUnloadNow);
            pDll->pfnDllCanUnloadNow = pfnDllCanUnloadNow;
        }
    }

    fResult = TRUE;
CommonReturn:
    UnlockOIDFunc();
    if (hDll) {
        // Dll was loaded by another thread.
        DWORD dwErr = GetLastError();
        FreeLibrary(hDll);
        SetLastError(dwErr);
    }
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(LoadLibraryError);
}


// Upon entry/exit OIDFunc must NOT be locked!!
STATIC BOOL GetDllProcAddr(
    IN PDLL_PROC_ELEMENT pEle,
    OUT void **ppvFuncAddr,
    OUT HCRYPTOIDFUNCADDR *phFuncAddr
    )
{
    BOOL fResult;
    void *pvAddr;
    PDLL_ELEMENT pDll;

    LockOIDFunc();

    pDll = pEle->pDll;
    assert(pDll);

    if (pvAddr = pEle->pvAddr)
        AddRefDll(pDll);
    else {
        UnlockOIDFunc();
        // NO LoadLibrary() or GetProcAddress() while holding OID lock!!
        fResult = LoadDll(pDll);
        if (fResult) {
            assert(pDll->hDll);
            pvAddr = GetProcAddress(pDll->hDll, pEle->pszName);
        }
        LockOIDFunc();
        if (!fResult)
            goto LoadDllError;

        if (pvAddr)
            pEle->pvAddr = pvAddr;
        else {
            ReleaseDll(pDll);
            goto GetProcAddressError;
        }
    }

    fResult = TRUE;

CommonReturn:
    *ppvFuncAddr = pvAddr;
    *phFuncAddr = (HCRYPTOIDFUNCADDR) pDll;
    UnlockOIDFunc();

    return fResult;
ErrorReturn:
    fResult = FALSE;
    pDll = NULL;
    pvAddr = NULL;
    goto CommonReturn;
TRACE_ERROR(LoadDllError)
TRACE_ERROR(GetProcAddressError)
}

// Upon entry/exit OIDFunc must NOT be locked!!
STATIC BOOL GetRegOIDFunctionAddress(
    IN PREG_OID_FUNC_ELEMENT pRegEle,
    IN DWORD dwEncodingType,
    IN LPCSTR pszOID,
    OUT void **ppvFuncAddr,
    OUT HCRYPTOIDFUNCADDR *phFuncAddr
    )
{
    for (; pRegEle; pRegEle = pRegEle->pNext) {
        if (dwEncodingType != pRegEle->dwEncodingType)
            continue;
        if (0xFFFF >= (DWORD_PTR) pszOID) {
            if (pszOID != pRegEle->pszOID)
                continue;
        } else {
            if (0xFFFF >= (DWORD_PTR) pRegEle->pszOID ||
                    0 != _stricmp(pszOID, pRegEle->pszOID))
                continue;
        }

        return GetDllProcAddr(
            pRegEle->pDllProc,
            ppvFuncAddr,
            phFuncAddr
            );
    }

    *ppvFuncAddr = NULL;
    *phFuncAddr = NULL;
    return FALSE;
}

// Upon entry/exit OIDFunc must NOT be locked!!
STATIC BOOL GetDefaultRegOIDFunctionAddress(
    IN PFUNC_SET pFuncSet,
    IN DWORD dwEncodingType,
    IN LPCWSTR pwszDll,
    OUT void **ppvFuncAddr,
    OUT HCRYPTOIDFUNCADDR *phFuncAddr
    )
{
    PDEFAULT_REG_ELEMENT pRegEle = pFuncSet->pDefaultRegHead;
    PDLL_ELEMENT pDll;

    for (; pRegEle; pRegEle = pRegEle->pNext) {
        if (dwEncodingType != pRegEle->dwEncodingType)
            continue;

        for (DWORD i = 0; i < pRegEle->cDll; i++) {
            if (0 == _wcsicmp(pwszDll, pRegEle->rgpwszDll[i]))
                return GetDllProcAddr(
                    pRegEle->rgpDllProc[i],
                    ppvFuncAddr,
                    phFuncAddr
                    );
        }
    }

    if (pDll = FindDll(pwszDll)) {
        if (LoadDll(pDll)) {
            if (*ppvFuncAddr = GetProcAddress(pDll->hDll,
                    pFuncSet->pszFuncName)) {
                *phFuncAddr = (HCRYPTOIDFUNCADDR) pDll;
                return TRUE;
            } else
                ReleaseDll(pDll);
        }
    }

    *ppvFuncAddr = NULL;
    *phFuncAddr = NULL;
    return FALSE;
}


//+-------------------------------------------------------------------------
//  Search the list of installed functions for an OID and EncodingType match.
//  If not found, search the registry.
//
//  For success, returns TRUE with *ppvFuncAddr updated with the function's
//  address and *phFuncAddr updated with the function address's handle.
//  The function's handle is AddRef'ed. CryptFreeOIDFunctionAddress needs to
//  be called to release it.
//
//  For a registry match, the Dll containing the function is loaded.
//
//  By default, both the registered and installed function lists are searched.
//  Set CRYPT_GET_INSTALLED_OID_FUNC_FLAG to only search the installed list
//  of functions. This flag would be set by a registered function to get
//  the address of a pre-installed function it was replacing. For example,
//  the registered function might handle a new special case and call the
//  pre-installed function to handle the remaining cases.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptGetOIDFunctionAddress(
    IN HCRYPTOIDFUNCSET hFuncSet,
    IN DWORD dwEncodingType,
    IN LPCSTR pszOID,
    IN DWORD dwFlags,
    OUT void **ppvFuncAddr,
    OUT HCRYPTOIDFUNCADDR *phFuncAddr
    )
{
    PFUNC_SET pFuncSet = (PFUNC_SET) hFuncSet;
    DWORD_PTR dwOID;

    dwEncodingType = GetEncodingType(dwEncodingType);

    if (0xFFFF < (DWORD_PTR) pszOID && CONST_OID_STR_PREFIX_CHAR == *pszOID) {
        // Convert "#<number>" string to its corresponding constant OID value
        pszOID = (LPCSTR)(DWORD_PTR) atol(pszOID + 1);
        if (0xFFFF < (DWORD_PTR) pszOID) {
            SetLastError((DWORD) E_INVALIDARG);
            *ppvFuncAddr = NULL;
            *phFuncAddr = NULL;
            return FALSE;
        }
    }

    if (!pFuncSet->fRegLoaded)
        LoadRegFunc(pFuncSet);

    if (0 == (dwFlags & CRYPT_GET_INSTALLED_OID_FUNC_FLAG) &&
            pFuncSet->pRegBeforeOIDFuncHead) {
        if (GetRegOIDFunctionAddress(
                pFuncSet->pRegBeforeOIDFuncHead,
                dwEncodingType,
                pszOID,
                ppvFuncAddr,
                phFuncAddr
                ))
            return TRUE;
    }

    if (0xFFFF >= (dwOID = (DWORD_PTR) pszOID)) {
        PCONST_OID_FUNC_ELEMENT pConstEle = pFuncSet->pConstOIDFuncHead;
        while (pConstEle) {
            if (dwEncodingType == pConstEle->dwEncodingType &&
                    dwOID >= pConstEle->dwLowOID &&
                    dwOID <= pConstEle->dwHighOID) {
                *ppvFuncAddr = pConstEle->rgpvFuncAddr[
                    dwOID - pConstEle->dwLowOID];
                *phFuncAddr = (HCRYPTOIDFUNCADDR) pConstEle;
                return TRUE;
            }
            pConstEle = pConstEle->pNext;
        }
    } else {
        PSTR_OID_FUNC_ELEMENT pStrEle = pFuncSet->pStrOIDFuncHead;
        while (pStrEle) {
            if (dwEncodingType == pStrEle->dwEncodingType &&
                    0 == _stricmp(pszOID, pStrEle->pszOID)) {
                *ppvFuncAddr = pStrEle->pvFuncAddr;
                *phFuncAddr = (HCRYPTOIDFUNCADDR) pStrEle;
                return TRUE;
            }
            pStrEle = pStrEle->pNext;
        }
    }

    if (0 == (dwFlags & CRYPT_GET_INSTALLED_OID_FUNC_FLAG) &&
            pFuncSet->pRegAfterOIDFuncHead) {
        if (GetRegOIDFunctionAddress(
                pFuncSet->pRegAfterOIDFuncHead,
                dwEncodingType,
                pszOID,
                ppvFuncAddr,
                phFuncAddr
                ))
            return TRUE;
    }

    SetLastError((DWORD) ERROR_FILE_NOT_FOUND);
    *ppvFuncAddr = NULL;
    *phFuncAddr = NULL;
    return FALSE;
}

//+-------------------------------------------------------------------------
//  Get the list of registered default Dll entries for the specified
//  function set and encoding type.
//
//  The returned list consists of none, one or more null terminated Dll file
//  names. The list is terminated with an empty (L"\0") Dll file name.
//  For example: L"first.dll" L"\0" L"second.dll" L"\0" L"\0"
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptGetDefaultOIDDllList(
    IN HCRYPTOIDFUNCSET hFuncSet,
    IN DWORD dwEncodingType,
    OUT LPWSTR pwszDllList,
    IN OUT DWORD *pcchDllList
    )
{
    BOOL fResult;
    PFUNC_SET pFuncSet = (PFUNC_SET) hFuncSet;
    PDEFAULT_REG_ELEMENT pRegEle;

    DWORD cchRegDllList = 2;
    LPWSTR pwszRegDllList = L"\0\0";

    if (!pFuncSet->fRegLoaded)
        LoadRegFunc(pFuncSet);

    dwEncodingType = GetEncodingType(dwEncodingType);

    pRegEle = pFuncSet->pDefaultRegHead;
    for (; pRegEle; pRegEle = pRegEle->pNext) {
        if (dwEncodingType == pRegEle->dwEncodingType) {
            cchRegDllList = pRegEle->cchDllList;
            assert(cchRegDllList >= 2);
            pwszRegDllList = pRegEle->pwszDllList;
            break;
        }
    }

    fResult = TRUE;
    if (pwszDllList) {
        if (cchRegDllList > *pcchDllList) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        } else
            memcpy(pwszDllList, pwszRegDllList, cchRegDllList * sizeof(WCHAR));
    }
    *pcchDllList = cchRegDllList;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Either: get the first or next installed DEFAULT function OR
//  load the Dll containing the DEFAULT function.
//
//  If pwszDll is NULL, search the list of installed DEFAULT functions.
//  *phFuncAddr must be set to NULL to get the first installed function.
//  Successive installed functions are returned by setting *phFuncAddr
//  to the hFuncAddr returned by the previous call.
//
//  If pwszDll is NULL, the input *phFuncAddr
//  is always CryptFreeOIDFunctionAddress'ed by this function, even for
//  an error.
//
//  If pwszDll isn't NULL, then, attempts to load the Dll and the DEFAULT
//  function. *phFuncAddr is ignored upon entry and isn't
//  CryptFreeOIDFunctionAddress'ed.
//
//  For success, returns TRUE with *ppvFuncAddr updated with the function's
//  address and *phFuncAddr updated with the function address's handle.
//  The function's handle is AddRef'ed. CryptFreeOIDFunctionAddress needs to
//  be called to release it or CryptGetDefaultOIDFunctionAddress can also
//  be called for a NULL pwszDll.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptGetDefaultOIDFunctionAddress(
    IN HCRYPTOIDFUNCSET hFuncSet,
    IN DWORD dwEncodingType,
    IN OPTIONAL LPCWSTR pwszDll,
    IN DWORD dwFlags,
    OUT void **ppvFuncAddr,
    IN OUT HCRYPTOIDFUNCADDR *phFuncAddr
    )
{
    PFUNC_SET pFuncSet = (PFUNC_SET) hFuncSet;

    if (!pFuncSet->fRegLoaded)
        LoadRegFunc(pFuncSet);

    dwEncodingType = GetEncodingType(dwEncodingType);

    if (NULL == pwszDll) {
        // Get from installed list
        PSTR_OID_FUNC_ELEMENT pStrEle = (PSTR_OID_FUNC_ELEMENT) *phFuncAddr;

        if (pStrEle && STR_OID_TYPE == pStrEle->dwOIDType)
            pStrEle = pStrEle->pNext;
        else
            pStrEle = pFuncSet->pStrOIDFuncHead;
        while (pStrEle) {
            if (dwEncodingType == pStrEle->dwEncodingType &&
                    0 == _stricmp(CRYPT_DEFAULT_OID, pStrEle->pszOID)) {
                *ppvFuncAddr = pStrEle->pvFuncAddr;
                *phFuncAddr = (HCRYPTOIDFUNCADDR) pStrEle;
                return TRUE;
            }
            pStrEle = pStrEle->pNext;
        }

        SetLastError(ERROR_FILE_NOT_FOUND);
        *ppvFuncAddr = NULL;
        *phFuncAddr = NULL;
        return FALSE;
    } else
        return GetDefaultRegOIDFunctionAddress(
            pFuncSet,
            dwEncodingType,
            pwszDll,
            ppvFuncAddr,
            phFuncAddr);
}

//+-------------------------------------------------------------------------
//  Releases the handle AddRef'ed and returned by CryptGetOIDFunctionAddress
//  or CryptGetDefaultOIDFunctionAddress.
//
//  If a Dll was loaded for the function its unloaded. However, before doing
//  the unload, the DllCanUnloadNow function exported by the loaded Dll is
//  called. It should return S_FALSE to inhibit the unload or S_TRUE to enable
//  the unload. If the Dll doesn't export DllCanUnloadNow, the Dll is unloaded.
//
//  DllCanUnloadNow has the following signature:
//      STDAPI  DllCanUnloadNow(void);
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptFreeOIDFunctionAddress(
    IN HCRYPTOIDFUNCADDR hFuncAddr,
    IN DWORD dwFlags
    )
{
    PDLL_ELEMENT pDll = (PDLL_ELEMENT) hFuncAddr;
    if (pDll && DLL_OID_TYPE == pDll->dwOIDType) {
        DWORD dwErr = GetLastError();
        ReleaseDll(pDll);
        SetLastError(dwErr);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\oidinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       oidinfo.h
//
//--------------------------------------------------------------------------

#define         IDS_EXT_AUTHORITY_KEY_IDENTIFIER    8000
#define         IDS_EXT_KEY_ATTRIBUTES              8001
#define         IDS_EXT_KEY_USAGE_RESTRICTION       8002
#define         IDS_EXT_SUBJECT_ALT_NAME            8003
#define         IDS_EXT_ISSUER_ALT_NAME             8004
#define         IDS_EXT_BASIC_CONSTRAINTS           8005
#define         IDS_EXT_KEY_USAGE                   8006
#define         IDS_EXT_CERT_POLICIES               8007
#define         IDS_EXT_SUBJECT_KEY_IDENTIFIER      8008
#define         IDS_EXT_CRL_REASON_CODE             8009
#define         IDS_EXT_CRL_DIST_POINTS             8010
#define         IDS_EXT_ENHANCED_KEY_USAGE          8011
#define         IDS_EXT_AUTHORITY_INFO_ACCESS       8012
#define         IDS_EXT_CERT_EXTENSIONS             8013
#define         IDS_EXT_NEXT_UPDATE_LOCATION        8014
#define         IDS_EXT_YESNO_TRUST_ATTR            8015
#define         IDS_EXT_RSA_emailAddr               8016
#define         IDS_EXT_RSA_unstructName            8017
#define         IDS_EXT_RSA_contentType             8018
#define         IDS_EXT_RSA_messageDigest           8019
#define         IDS_EXT_RSA_signingTime             8020
#define         IDS_EXT_RSA_counterSign             8021
#define         IDS_EXT_RSA_challengePwd            8022
#define         IDS_EXT_RSA_unstructAddr            8023
#define         IDS_EXT_RSA_SMIMECapabilities       8024
#define         IDS_EXT_RSA_preferSignedData        8025
#define         IDS_EXT_PKIX_POLICY_QUALIFIER_CPS   8026
#define         IDS_EXT_PKIX_POLICY_QUALIFIER_USERNOTICE    8027
#define         IDS_EXT_PKIX_OCSP                   8028
#define         IDS_EXT_PKIX_CA_ISSUERS             8029
#define         IDS_EXT_MS_CERTIFICATE_TEMPLATE     8030
// Following was changed to IDS_ENHKEY_ENROLLMENT_AGENT
// #define         IDS_EXT_ENROLLMENT_AGENT            8031
#define         IDS_EXT_ENROLL_CERTTYPE             8032
#define         IDS_EXT_CERT_MANIFOLD               8033
#define         IDS_EXT_NETSCAPE_CERT_TYPE          8034
#define         IDS_EXT_NETSCAPE_BASE_URL           8035
#define         IDS_EXT_NETSCAPE_REVOCATION_URL     8036
#define         IDS_EXT_NETSCAPE_CA_REVOCATION_URL  8037
#define         IDS_EXT_NETSCAPE_CERT_RENEWAL_URL   8038
#define         IDS_EXT_NETSCAPE_CA_POLICY_URL      8039
#define         IDS_EXT_NETSCAPE_SSL_SERVER_NAME    8040
#define         IDS_EXT_NETSCAPE_COMMENT            8041
#define         IDS_EXT_SPC_SP_AGENCY_INFO_OBJID    8042
#define         IDS_EXT_SPC_FINANCIAL_CRITERIA_OBJID        8043
#define         IDS_EXT_SPC_MINIMAL_CRITERIA_OBJID  8044
#define         IDS_EXT_COUNTRY_NAME                8045
#define         IDS_EXT_ORGANIZATION_NAME           8046
#define         IDS_EXT_ORGANIZATIONAL_UNIT_NAME    8047
#define         IDS_EXT_COMMON_NAME                 8048
#define         IDS_EXT_LOCALITY_NAME               8049
#define         IDS_EXT_STATE_OR_PROVINCE_NAME      8050
#define         IDS_EXT_TITLE                       8051
#define         IDS_EXT_GIVEN_NAME                  8052
#define         IDS_EXT_INITIALS                    8053
#define         IDS_EXT_SUR_NAME                    8054
#define         IDS_EXT_DOMAIN_COMPONENT            8055
#define         IDS_EXT_STREET_ADDRESS              8056
#define 	    IDS_EXT_DEVICE_SERIAL_NUMBER	    8057
#define 	    IDS_EXT_CA_VERSION		            8058
#define 	    IDS_EXT_SERIALIZED		            8059
#define 	    IDS_EXT_NT_PRINCIPAL_NAME	        8060
#define 	    IDS_EXT_PRODUCT_UPDATE		        8061
#define 	    IDS_EXT_ENROLLMENT_NAME_VALUE_PAIR  8062
#define 	    IDS_EXT_OS_VERSION                  8063
#define 	    IDS_EXT_ENROLLMENT_CSP_PROVIDER     8064
#define         IDS_EXT_CRL_NUMBER                  8065
#define         IDS_EXT_DELTA_CRL_INDICATOR         8066
#define         IDS_EXT_ISSUING_DIST_POINT          8067
#define         IDS_EXT_FRESHEST_CRL                8068
#define         IDS_EXT_NAME_CONSTRAINTS            8069
#define         IDS_EXT_POLICY_MAPPINGS             8070
#define         IDS_EXT_POLICY_CONSTRAINTS          8071
#define         IDS_EXT_CROSS_CERT_DIST_POINTS      8072
#define         IDS_EXT_APP_POLICIES                8073
#define         IDS_EXT_APP_POLICY_MAPPINGS         8074
#define         IDS_EXT_APP_POLICY_CONSTRAINTS      8075

// DSIE: Post Win2k, 8/2/2000.
#define         IDS_EXT_CT_PKI_DATA                 8076
#define         IDS_EXT_CT_PKI_RESPONSE             8077
#define         IDS_EXT_CMC                         8078
#define         IDS_EXT_CMC_STATUS_INFO             8079
#define         IDS_EXT_CMC_ADD_EXTENSIONS          8080
#define         IDS_EXT_CMC_ADD_ATTRIBUTES          8081
#define         IDS_EXT_PKCS_7_DATA                 8082
#define         IDS_EXT_PKCS_7_SIGNED               8083
#define         IDS_EXT_PKCS_7_ENVELOPED            8084
#define         IDS_EXT_PKCS_7_SIGNEDANDENVELOPED   8085
#define         IDS_EXT_PKCS_7_DIGESTED             8086
#define         IDS_EXT_PKCS_7_ENCRYPTED            8087
#define         IDS_EXT_CERTSRV_PREVIOUS_CERT_HASH  8088
#define         IDS_EXT_CRL_VIRTUAL_BASE            8089
#define         IDS_EXT_CRL_NEXT_PUBLISH            8090
#define         IDS_EXT_KP_CA_EXCHANGE              8091
#define         IDS_EXT_KP_KEY_RECOVERY_AGENT       8092
#define         IDS_EXT_CERTIFICATE_TEMPLATE        8093
#define         IDS_EXT_ENTERPRISE_OID_ROOT         8094
#define         IDS_EXT_RDN_DUMMY_SIGNER            8095
#define         IDS_EXT_ARCHIVED_KEY_ATTR           8096
#define         IDS_EXT_CRL_SELF_CDP                8097
#define         IDS_EXT_REQUIRE_CERT_CHAIN_POLICY   8098
#define         IDS_EXT_CMC_TRANSACTION_ID          8099
#define         IDS_EXT_CMC_SENDER_NONCE            8100
#define         IDS_EXT_CMC_RECIPIENT_NONCE         8101
#define         IDS_EXT_CMC_REG_INFO                8102
#define         IDS_EXT_CMC_GET_CERT                8103
#define         IDS_EXT_CMC_GET_CRL                 8104
#define         IDS_EXT_CMC_REVOKE_REQUEST          8105
#define         IDS_EXT_CMC_QUERY_PENDING           8106
#define         IDS_EXT_CTL                         8107
#define         IDS_EXT_ARCHIVED_KEY_CERT_HASH      8108
#define         IDS_EXT_PRIVATEKEY_USAGE_PERIOD     8109
#define         IDS_EXT_REQUEST_CLIENT_INFO         8110

#define         IDS_EXT_CROSSCA_VERSION             8111

#define         IDS_ENHKEY_PKIX_KP_SERVER_AUTH      8500
#define         IDS_ENHKEY_PKIX_KP_CLIENT_AUTH      8501
#define         IDS_ENHKEY_PKIX_KP_CODE_SIGNING     8502
#define         IDS_ENHKEY_PKIX_KP_EMAIL_PROTECTION 8503
#define         IDS_ENHKEY_PKIX_KP_TIMESTAMP_SIGNING 8504
#define         IDS_ENHKEY_KP_CTL_USAGE_SIGNING     8505
#define         IDS_ENHKEY_KP_TIME_STAMP_SIGNING    8506
#define         IDS_ENHKEY_PKIX_KP_IPSEC_END_SYSTEM 8507
#define         IDS_ENHKEY_PKIX_KP_IPSEC_TUNNEL     8508
#define         IDS_ENHKEY_PKIX_KP_IPSEC_USER       8509
#define         IDS_ENHKEY_SERVER_GATED_CRYPTO      8510
#define         IDS_ENHKEY_SGC_NETSCAPE             8511
#define         IDS_ENHKEY_KP_EFS                   8512
#define         IDS_ENHKEY_KP_WHQL                  8513
#define         IDS_ENHKEY_KP_NT5                   8514
#define         IDS_ENHKEY_KP_OEM_WHQL              8515
#define         IDS_ENHKEY_KP_EMBEDDED_NT           8516
#define 	    IDS_ENHKEY_LICENSES		            8517
#define 	    IDS_ENHKEY_LICENSES_SERVER	        8518
#define 	    IDS_ENHKEY_SMARTCARD_LOGON	        8519
#define 	    IDS_ENHKEY_DRM			            8520
#define         IDS_ENHKEY_KP_QUALIFIED_SUBORDINATION 8521
#define         IDS_ENHKEY_KP_KEY_RECOVERY          8522
#define         IDS_ENHKEY_KP_CODE_SIGNING          8523
#define         IDS_ENHKEY_KP_IPSEC_IKE_INTERMEDIATE 8524
#define 	    IDS_ENHKEY_EFS_RECOVERY			    8525

// DSIE: Post Win2k, 8/2/2000.
#define         IDS_ENHKEY_ROOT_LIST_SIGNER         8527
#define         IDS_ENHKEY_ANY_POLICY               8528
#define         IDS_ENHKEY_DS_EMAIL_REPLICATION     8529
#define         IDS_ENHKEY_ENROLLMENT_AGENT         8530
#define         IDS_ENHKEY_KP_KEY_RECOVERY_AGENT    8531
#define         IDS_ENHKEY_KP_CA_EXCHANGE           8532
#define 	    IDS_ENHKEY_KP_LIFETIME_SIGNING      8533

// DSIE: Post Win2K, 10/13/2000. Issuance Policy
#define         IDS_POLICY_ANY_POLICY               8600

#define         IDS_SYS_NAME_ROOT                   9000
#define         IDS_SYS_NAME_MY                     9001
#define         IDS_SYS_NAME_TRUST                  9002
#define         IDS_SYS_NAME_CA                     9003
#define         IDS_SYS_NAME_USERDS                 9004
#define         IDS_SYS_NAME_SMARTCARD              9005
#define         IDS_SYS_NAME_ADDRESSBOOK            9006
#define         IDS_SYS_NAME_TRUST_PUB              9007
#define         IDS_SYS_NAME_DISALLOWED             9008
#define         IDS_SYS_NAME_AUTH_ROOT              9009
#define         IDS_SYS_NAME_REQUEST                9010
#define         IDS_SYS_NAME_TRUST_PEOPLE           9011

#define         IDS_PHY_NAME_DEFAULT                9100
#define         IDS_PHY_NAME_GROUP_POLICY           9101
#define         IDS_PHY_NAME_LOCAL_MACHINE          9102
#define         IDS_PHY_NAME_DS_USER_CERT           9104
#define         IDS_PHY_NAME_ENTERPRISE             9105
#define         IDS_PHY_NAME_AUTH_ROOT              9106
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\protroot.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       protroot.cpp
//
//  Contents:   Protect Current User (CU) Root Store APIs
//
//  Functions:  I_ProtectedRootDllMain
//              I_CertProtectFunction
//              I_CertSrvProtectFunction
//              IPR_EnableSecurityPrivilege
//              IPR_IsCurrentUserRootsAllowed
//              IPR_IsAuthRootsAllowed
//              IPR_IsNTAuthRequiredDisabled
//              IPR_IsNotDefinedNameConstraintDisabled
//              IPR_IsAuthRootAutoUpdateDisabled
//              IPR_InitProtectedRootInfo
//              IPR_DeleteUnprotectedRootsFromStore
//              IPR_ProtectedRootMessageBox
//              IPR_LogCrypt32Event
//              IPR_LogCrypt32Error
//              IPR_LogCertInformation
//              IPR_AddCertInAuthRootAutoUpdateCtl
//
//  History:    23-Nov-97    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <chain.h>
#include <dbgdef.h>
#include <wininet.h>

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

// Used for "root" system store's message box
static HMODULE hRegStoreInst;

// # of bytes for a hash. Such as, SHA (20) or MD5 (16)
#define MAX_HASH_LEN                20

#define PROT_ROOT_SUBKEY_NAME       L"ProtectedRoots"
#define PROT_ROOT_CERT_VALUE_NAME   L"Certificates"
#define PROT_ROOT_MAX_CNT           1000000

#define SYSTEM_STORE_REGPATH        L"Software\\Microsoft\\SystemCertificates"
#define PROT_ROOT_REGPATH           \
                SYSTEM_STORE_REGPATH L"\\Root\\" PROT_ROOT_SUBKEY_NAME

//+-------------------------------------------------------------------------
//  Protected root information data structure and defines
//
//  The protected root information is stored in the "Certificates" value of
//  the "root" store's "ProtectedRoots" SubKey.
//--------------------------------------------------------------------------

// In V1, all hashes are SHA1 (length of 20 bytes) and are at the end of
// the info. cbInfo = dwRootOffset + cRoot * 20
typedef struct _PROT_ROOT_INFO {
    DWORD               cbSize;         // sizeof(PROT_ROOT_INFO)
    DWORD               dwVersion;
    FILETIME            LastUpdate;
    DWORD               cRoot;
    DWORD               dwRootOffset;
} PROT_ROOT_INFO, *PPROT_ROOT_INFO;

#define PROT_ROOT_V1            1

// SHA1 hash length
#define PROT_ROOT_HASH_LEN      20


//+-------------------------------------------------------------------------
//  Predefined SIDs allocated once by GetPredefinedSids. Freed at
//  ProcessDetach.
//--------------------------------------------------------------------------
static CRITICAL_SECTION ProtRootCriticalSection;
static BOOL fInitializedPredefinedSids = FALSE;
static PSID psidLocalSystem = NULL;
static PSID psidAdministrators = NULL;
static PSID psidEveryone = NULL;

//+-------------------------------------------------------------------------
//  SID definitions used to set security on the "ProtectedRoots" SubKey.
//--------------------------------------------------------------------------
// Only enable the following if you want to do special testing without
// going through the LocalSystem service.
// #define TESTING_NO_PROT_ROOT_RPC    1

#define PSID_PROT_OWNER             psidAdministrators
#ifdef TESTING_NO_PROT_ROOT_RPC
#define PSID_PROT_SYSTEM            psidAdministrators
#else
#define PSID_PROT_SYSTEM            psidLocalSystem
#endif
#define PSID_PROT_EVERYONE          psidEveryone

//+-------------------------------------------------------------------------
//  ACL definitions used to set security on the "ProtectedRoots" SubKey.
//--------------------------------------------------------------------------
#define PROT_SYSTEM_ACE_MASK        KEY_ALL_ACCESS
#define PROT_EVERYONE_ACE_MASK      KEY_READ
#define PROT_ACE_FLAGS              CONTAINER_INHERIT_ACE

#define PROT_ACE_COUNT              2
#define PROT_SYSTEM_ACE_INDEX       0
#define PROT_EVERYONE_ACE_INDEX     1


//+-------------------------------------------------------------------------
//  Critical Section to Serialize Access to Crypt32 Event Log Data Structures
//--------------------------------------------------------------------------
CRITICAL_SECTION Crypt32EventLogCriticalSection;

//+-------------------------------------------------------------------------
//  Allocate/free predefined SIDs
//--------------------------------------------------------------------------
static BOOL GetPredefinedSids()
{
    if (fInitializedPredefinedSids)
        return TRUE;

    BOOL fResult;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaWorldSidAuthority =
        SECURITY_WORLD_SID_AUTHORITY;

    EnterCriticalSection(&ProtRootCriticalSection);

    if (!fInitializedPredefinedSids) {
        if (!AllocateAndInitializeSid(
                &siaNtAuthority,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0, 0, 0, 0, 0, 0, 0,
                &psidLocalSystem
                )) 
            goto AllocateAndInitializeSidError;

        if (!AllocateAndInitializeSid(
                &siaNtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &psidAdministrators
                ))
            goto AllocateAndInitializeSidError;

        if (!AllocateAndInitializeSid(
                &siaWorldSidAuthority,
                1,
                SECURITY_WORLD_RID,
                0, 0, 0, 0, 0, 0, 0,
                &psidEveryone
                ))
            goto AllocateAndInitializeSidError;

        fInitializedPredefinedSids = TRUE;
    }
    fResult = TRUE;
CommonReturn:
    LeaveCriticalSection(&ProtRootCriticalSection);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(AllocateAndInitializeSidError)
}

static void FreePredefinedSids()
{
    if (fInitializedPredefinedSids) {
        FreeSid(psidLocalSystem);
        FreeSid(psidAdministrators);
        FreeSid(psidEveryone);
    }
}

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_ProtectedRootDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL fRet = TRUE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        // Used for "root" system store's message box
        hRegStoreInst = hInst;

        fRet = Pki_InitializeCriticalSection(&ProtRootCriticalSection);
        if (fRet) {
            fRet = Pki_InitializeCriticalSection(
                &Crypt32EventLogCriticalSection);
            if (!fRet)
                DeleteCriticalSection(&ProtRootCriticalSection);
        }

        I_DBLogAttach();

        break;

    case DLL_PROCESS_DETACH:
        I_DBLogDetach();

        FreePredefinedSids();
        DeleteCriticalSection(&ProtRootCriticalSection);
        DeleteCriticalSection(&Crypt32EventLogCriticalSection);
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    return fRet;
}

//+=========================================================================
//  Protected root registry flags support function
//==========================================================================

//+-------------------------------------------------------------------------
//  Get the ProtectedRoots Flags DWORD registry value stored in HKLM.
//--------------------------------------------------------------------------
STATIC DWORD GetProtectedRootFlags()
{
    HKEY hKey = NULL;
    LONG err;
    DWORD dwProtRootFlags = 0;

    if (ERROR_SUCCESS != (err = RegOpenKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_PROT_ROOT_FLAGS_REGPATH,
            0,                      // dwReserved
            KEY_READ,
            &hKey
            ))) goto RegOpenKeyError;
    if (!ILS_ReadDWORDValueFromRegistry(
            hKey,
            CERT_PROT_ROOT_FLAGS_VALUE_NAME,
            &dwProtRootFlags
            )) goto ReadValueError;

CommonReturn:
    ILS_CloseRegistryKey(hKey);
    return dwProtRootFlags;
ErrorReturn:
    dwProtRootFlags = 0;
    goto CommonReturn;

SET_ERROR_VAR(RegOpenKeyError, err)
TRACE_ERROR(ReadValueError)
}

//+=========================================================================
//  Protected root information support functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Open the SubKey containing the protected root information.
//--------------------------------------------------------------------------
STATIC HKEY OpenProtectedRootSubKey(
    IN HKEY hKeyCU,
    IN REGSAM samDesired
    )
{
    LONG err;
    HKEY hKeyProtRoot;

    if (ERROR_SUCCESS != (err = RegOpenKeyExU(
            hKeyCU,
            PROT_ROOT_REGPATH,
            0,                      // dwReserved
            samDesired,
            &hKeyProtRoot)))
        goto RegOpenKeyError;

CommonReturn:
    return hKeyProtRoot;
ErrorReturn:
    hKeyProtRoot = NULL;
    goto CommonReturn;

SET_ERROR_VAR(RegOpenKeyError, err)
}

//+-------------------------------------------------------------------------
//  Create the SubKey containing the protected root information.
//--------------------------------------------------------------------------
STATIC HKEY CreateProtectedRootSubKey(
    IN HKEY hKeyCU,
    IN REGSAM samDesired
    )
{
    LONG err;
    HKEY hKeyProtRoot;
    DWORD dwDisposition;

    if (ERROR_SUCCESS != (err = RegCreateKeyExU(
            hKeyCU,
            PROT_ROOT_REGPATH,
            0,                      // dwReserved
            NULL,                   // lpClass
            REG_OPTION_NON_VOLATILE,
            samDesired,
            NULL,                   // lpSecurityAttributes
            &hKeyProtRoot,
            &dwDisposition)))
        goto RegCreateKeyError;
CommonReturn:
    return hKeyProtRoot;
ErrorReturn:
    hKeyProtRoot = NULL;
    goto CommonReturn;

SET_ERROR_VAR(RegCreateKeyError, err)
}

//+-------------------------------------------------------------------------
//  Allocate, read from registry and verify the protected root info.
//
//  The root hashes are at the end of the info.
//--------------------------------------------------------------------------
STATIC PPROT_ROOT_INFO ReadProtectedRootInfo(
    IN HKEY hKeyProtRoot
    )
{
    PPROT_ROOT_INFO pInfo = NULL;
    DWORD cbInfo;
    DWORD cRoot;
    DWORD dwRootOffset;

    if (!ILS_ReadBINARYValueFromRegistry(
            hKeyProtRoot,
            PROT_ROOT_CERT_VALUE_NAME,
            (BYTE **) &pInfo,
            &cbInfo
            )) goto ReadCertificatesProtInfoValueError;

    if (sizeof(PROT_ROOT_INFO) > cbInfo ||
            sizeof(PROT_ROOT_INFO) > pInfo->cbSize ||
            pInfo->cbSize > cbInfo ||
            PROT_ROOT_V1 != pInfo->dwVersion
            ) goto InvalidProtectedRootInfo;

    // The root hashes must be at the end of the info
    cRoot = pInfo->cRoot;
    dwRootOffset = pInfo->dwRootOffset;
    if (dwRootOffset < pInfo->cbSize || dwRootOffset > cbInfo ||
            PROT_ROOT_MAX_CNT < cRoot ||
            cRoot * PROT_ROOT_HASH_LEN != cbInfo - dwRootOffset
            ) goto InvalidProtectedRootInfo;

CommonReturn:
    return pInfo;
ErrorReturn:
    PkiFree(pInfo);
    pInfo = NULL;
    goto CommonReturn;

TRACE_ERROR(ReadCertificatesProtInfoValueError)
SET_ERROR(InvalidProtectedRootInfo, ERROR_INVALID_DATA)
}

//+-------------------------------------------------------------------------
//  Write the protected root info to the registry.
//
//  The root hashes are at the end of the info. Updates the info's
//  LastUpdate time.
//--------------------------------------------------------------------------
STATIC BOOL WriteProtectedRootInfo(
    IN HKEY hKeyProtRoot,
    IN OUT PPROT_ROOT_INFO pInfo
    )
{
    BOOL fResult;
    LONG err;
    DWORD cbInfo;
    SYSTEMTIME SystemTime;
    FILETIME FileTime;

    cbInfo = pInfo->dwRootOffset + pInfo->cRoot * PROT_ROOT_HASH_LEN;

    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);
    pInfo->LastUpdate = FileTime;

    if (ERROR_SUCCESS != (err = RegSetValueExU(
            hKeyProtRoot,
            PROT_ROOT_CERT_VALUE_NAME,
            NULL,
            REG_BINARY,
            (BYTE *) pInfo,
            cbInfo
            ))) goto RegSetValueError;
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegSetValueError, err)
}


// In the debugger I saw 0x58
#define PROT_ROOT_SD_LEN      0x100

//+-------------------------------------------------------------------------
//  Allocate and get the security descriptor information for the specified
//  registry key.
//--------------------------------------------------------------------------
static PSECURITY_DESCRIPTOR AllocAndGetSecurityDescriptor(
    IN HKEY hKey,
    SECURITY_INFORMATION SecInf
    )
{
    LONG err;
    PSECURITY_DESCRIPTOR psd = NULL;
    DWORD cbsd;

    cbsd = PROT_ROOT_SD_LEN;
    if (NULL == (psd = (PSECURITY_DESCRIPTOR) PkiNonzeroAlloc(cbsd)))
        goto OutOfMemory;

    err = RegGetKeySecurity(
            hKey,
            SecInf,
            psd,
            &cbsd
            );
    if (ERROR_SUCCESS == err)
        goto CommonReturn;
    if (ERROR_INSUFFICIENT_BUFFER != err)
        goto RegGetKeySecurityError;

    if (0 == cbsd)
        goto NoSecurityDescriptor;

    PkiFree(psd);
    psd = NULL;
    if (NULL == (psd = (PSECURITY_DESCRIPTOR) PkiNonzeroAlloc(cbsd)))
        goto OutOfMemory;

    if (ERROR_SUCCESS != (err = RegGetKeySecurity(
            hKey,
            SecInf,
            psd,
            &cbsd
            ))) goto RegGetKeySecurityError;

CommonReturn:
    return psd;
ErrorReturn:
    PkiFree(psd);
    psd = NULL;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(RegGetKeySecurityError, err)
SET_ERROR(NoSecurityDescriptor, ERROR_INVALID_SECURITY_DESCR)
}

//+-------------------------------------------------------------------------
//  Opens the "ProtectedRoots" registry key and verifies its security owner,
//  group, DACLs and SACLs. Must match the security set by
//  SrvGetProtectedRootInfo().
//
//  If the "ProtectedRoots" SubKey has the proper security. Allocates, reads
//  and verifies the "Certificates" value to get the protected root info.
//--------------------------------------------------------------------------
STATIC BOOL GetProtectedRootInfo(
    IN HKEY hKeyCU,
    IN REGSAM samDesired,
    OUT OPTIONAL HKEY *phKeyProtRoot,
    OUT OPTIONAL PPROT_ROOT_INFO *ppInfo
    )
{
    BOOL fResult;
    HKEY hKeyProtRoot = NULL;
    PSECURITY_DESCRIPTOR psd = NULL;
    PPROT_ROOT_INFO pInfo = NULL;
    PSID psidOwner;                 // not allocated
    BOOL fOwnerDefaulted;
    BOOL fDaclPresent;
    PACL pAcl;                      // not allocated
    BOOL fDaclDefaulted;
    DWORD dwAceIndex;
    PACCESS_ALLOWED_ACE rgpAce[PROT_ACE_COUNT];

    if (NULL == (hKeyProtRoot = OpenProtectedRootSubKey(hKeyCU, samDesired)))
        goto OpenProtectedRootSubKeyError;
    if (NULL == (psd = AllocAndGetSecurityDescriptor(
            hKeyProtRoot,
            OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION
            ))) goto GetSecurityDescriptorError;

    if (!GetPredefinedSids())
        goto GetPredefinedSidsError;

    // Verify owner
    if (!GetSecurityDescriptorOwner(psd, &psidOwner, &fOwnerDefaulted))
        goto GetSecurityDescriptorOwnerError;
    if (NULL == psidOwner || !EqualSid(psidOwner, PSID_PROT_OWNER))
        goto InvalidProtectedRootOwner;

    // Verify DACL
    if (!GetSecurityDescriptorDacl(psd, &fDaclPresent, &pAcl,
            &fDaclDefaulted))
        goto GetSecurityDescriptorDaclError;
    if (!fDaclPresent || NULL == pAcl)
        goto MissingProtectedRootDaclError;
    if (PROT_ACE_COUNT != pAcl->AceCount)
        goto InvalidProtectedRootDacl;

    for (dwAceIndex = 0; dwAceIndex < PROT_ACE_COUNT; dwAceIndex++) {
        PACCESS_ALLOWED_ACE pAce;
        if (!GetAce(pAcl, dwAceIndex, (void **) &pAce))
            goto InvalidProtectedRootDacl;
        rgpAce[dwAceIndex] = pAce;

        if (ACCESS_ALLOWED_ACE_TYPE != pAce->Header.AceType ||
                PROT_ACE_FLAGS != pAce->Header.AceFlags)
            goto InvalidProtectedRootDacl;
    }

    if (PROT_SYSTEM_ACE_MASK != rgpAce[PROT_SYSTEM_ACE_INDEX]->Mask ||
            !EqualSid(PSID_PROT_SYSTEM,
                (PSID) &rgpAce[PROT_SYSTEM_ACE_INDEX]->SidStart) ||
            PROT_EVERYONE_ACE_MASK != rgpAce[PROT_EVERYONE_ACE_INDEX]->Mask ||
            !EqualSid(PSID_PROT_EVERYONE,
                (PSID) &rgpAce[PROT_EVERYONE_ACE_INDEX]->SidStart))
        goto InvalidProtectedRootDacl;

    // Get verified protected root info
    if (NULL == (pInfo = ReadProtectedRootInfo(hKeyProtRoot)))
        goto ReadProtectedRootInfoError;

    fResult = TRUE;
CommonReturn:
    PkiFree(psd);
    if (phKeyProtRoot)
        *phKeyProtRoot = hKeyProtRoot;
    else
        ILS_CloseRegistryKey(hKeyProtRoot);
    if (ppInfo)
        *ppInfo = pInfo;
    else
        PkiFree(pInfo);
    return fResult;
ErrorReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    hKeyProtRoot = NULL;
    PkiFree(pInfo);
    pInfo = NULL;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenProtectedRootSubKeyError)
TRACE_ERROR(GetSecurityDescriptorError)
TRACE_ERROR(GetPredefinedSidsError)
TRACE_ERROR(GetSecurityDescriptorOwnerError)
TRACE_ERROR(GetSecurityDescriptorDaclError)
SET_ERROR(InvalidProtectedRootOwner, ERROR_INVALID_OWNER)
SET_ERROR(MissingProtectedRootDaclError, ERROR_INVALID_ACL)
SET_ERROR(InvalidProtectedRootDacl, ERROR_INVALID_ACL)
TRACE_ERROR(ReadProtectedRootInfoError)
}


//+=========================================================================
//  Functions to find, add or delete a root hash from the protected root
//  info.
//==========================================================================
STATIC BOOL FindProtectedRoot(
    IN PPROT_ROOT_INFO pInfo,
    IN BYTE rgbFindRootHash[PROT_ROOT_HASH_LEN],
    OUT OPTIONAL DWORD *pdwRootIndex = NULL
    )
{
    BYTE *pbRoot = (BYTE *) pInfo + pInfo->dwRootOffset;
    DWORD cRoot = pInfo->cRoot;
    DWORD dwRootIndex = 0;
    BYTE bFirst = rgbFindRootHash[0];

    for ( ; dwRootIndex < cRoot; dwRootIndex++, pbRoot += PROT_ROOT_HASH_LEN) {
        if (bFirst == *pbRoot &&
                0 == memcmp(rgbFindRootHash, pbRoot, PROT_ROOT_HASH_LEN)) {
            if (pdwRootIndex)
                *pdwRootIndex = dwRootIndex;
            return TRUE;
        }
    }
    if (pdwRootIndex)
        *pdwRootIndex = 0;
    return FALSE;
}

// Root hash is appended to the end of the list
STATIC BOOL AddProtectedRoot(
    IN OUT PPROT_ROOT_INFO *ppInfo,
    IN BYTE rgbAddRootHash[PROT_ROOT_HASH_LEN]
    )
{
    PPROT_ROOT_INFO pInfo = *ppInfo;
    DWORD cRoot = pInfo->cRoot;
    DWORD dwRootOffset = pInfo->dwRootOffset;
    DWORD cbInfo;

    if (PROT_ROOT_MAX_CNT <= cRoot) {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    cbInfo = dwRootOffset + (cRoot + 1) * PROT_ROOT_HASH_LEN;

    if (NULL == (pInfo = (PPROT_ROOT_INFO) PkiRealloc(pInfo, cbInfo)))
        return FALSE;

    memcpy((BYTE *) pInfo + (dwRootOffset + cRoot * PROT_ROOT_HASH_LEN),
        rgbAddRootHash, PROT_ROOT_HASH_LEN);
    pInfo->cRoot = cRoot + 1;
    *ppInfo = pInfo;
    return TRUE;
}

STATIC void DeleteProtectedRoot(
    IN PPROT_ROOT_INFO pInfo,
    IN DWORD dwDeleteRootIndex
    )
{
    DWORD cRoot = pInfo->cRoot;
    BYTE *pbRoot = (BYTE *) pInfo + pInfo->dwRootOffset;

    assert(0 < cRoot);
    assert(dwDeleteRootIndex < cRoot);
    cRoot--;

    if (cRoot > dwDeleteRootIndex) {
        // Move following roots down
        BYTE *pbDst = pbRoot + dwDeleteRootIndex * PROT_ROOT_HASH_LEN;
        BYTE *pbSrc = pbDst + PROT_ROOT_HASH_LEN;
        DWORD cbMove = (cRoot - dwDeleteRootIndex) * PROT_ROOT_HASH_LEN;
        while (cbMove--)
            *pbDst++ = *pbSrc++;
    }
    // else
    //  last root in list

    pInfo->cRoot = cRoot;
}

//+=========================================================================
//  Certificate store support functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Opens the SystemRegistry "Root" store unprotected and relative to the
//  specifed base SubKey.
//--------------------------------------------------------------------------
STATIC HCERTSTORE OpenUnprotectedRootStore(
    IN HKEY hKeyCU,
    IN DWORD dwOpenFlags = 0
    )
{
    CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;

    RelocatePara.hKeyBase = hKeyCU;
    RelocatePara.pwszSystemStore = L"Root";
    return CertOpenStore(
        CERT_STORE_PROV_SYSTEM_REGISTRY_W,
        0,                                  // dwEncodingType
        NULL,                               // hCryptProv
        CERT_SYSTEM_STORE_RELOCATE_FLAG |
            CERT_SYSTEM_STORE_UNPROTECTED_FLAG |
            CERT_SYSTEM_STORE_CURRENT_USER |
            dwOpenFlags,
        (const void *) &RelocatePara
        );
}

//+-------------------------------------------------------------------------
//  Gets the certificate's SHA1 hash property. Rehashes the encoded
//  certificate. Returns TRUE if the property matches the regenerated hash.
//--------------------------------------------------------------------------
static BOOL GetVerifiedCertHashProperty(
    IN PCCERT_CONTEXT pCert,
    OUT BYTE rgbHash[PROT_ROOT_HASH_LEN]
    )
{
    BYTE rgbProp[PROT_ROOT_HASH_LEN];
    DWORD cbData;
    
    cbData = PROT_ROOT_HASH_LEN;
    if (!CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbProp,
            &cbData
            ) || PROT_ROOT_HASH_LEN != cbData)
        return FALSE;

    // Verify the property
    cbData = PROT_ROOT_HASH_LEN;
    if (!CryptHashCertificate(
            0,                  // hProv
            CALG_SHA1,
            0,                  //dwFlags
            pCert->pbCertEncoded,
            pCert->cbCertEncoded,
            rgbHash,
            &cbData
            ) || PROT_ROOT_HASH_LEN != cbData)
        return FALSE;
    return (0 == memcmp(rgbHash, rgbProp, PROT_ROOT_HASH_LEN));
}


//+=========================================================================
//  FormatMsgBox support functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Formats multi bytes into WCHAR hex. Includes a space after every 4 bytes.
//
//  Needs (cb * 2 + cb/4 + 1) characters in wsz
//--------------------------------------------------------------------------
static void FormatMsgBoxMultiBytes(DWORD cb, BYTE *pb, LPWSTR wsz)
{
    for (DWORD i = 0; i<cb; i++) {
        int b;
        if (i && 0 == (i & 3))
            *wsz++ = L' ';
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (WCHAR)( (b <= 9) ? b + L'0' : (b - 10) + L'A');
        b = *pb & 0x0F;
        *wsz++ = (WCHAR) ((b <= 9) ? b + L'0' : (b - 10) + L'A');
        pb++;
    }
    *wsz++ = 0;
}

//+-------------------------------------------------------------------------
//  Format and allocate a single message box item
//
//  The formatted item needs to be LocalFree'ed.
//--------------------------------------------------------------------------
static void FormatMsgBoxItem(
    OUT LPWSTR *ppwszMsg,
    OUT DWORD *pcchMsg,
    IN UINT nFormatID,
    ...
    )
{
    // get format string from resources
    WCHAR wszFormat[256];
    wszFormat[0] = '\0';
    LoadStringU(hRegStoreInst, nFormatID, wszFormat,
        sizeof(wszFormat)/sizeof(wszFormat[0]));

    // format message into requested buffer
    va_list argList;
    va_start(argList, nFormatID);
    *ppwszMsg = NULL;
    *pcchMsg = FormatMessageU(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        wszFormat,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPWSTR) ppwszMsg,
        0,                  // minimum size to allocate
        &argList);

    va_end(argList);
}


//+=========================================================================
//  Protected root functions called from the services process
//==========================================================================


//+-------------------------------------------------------------------------
//  Enable the specified security privilege for the current process.
//
//  Also, called from logstor.cpp to enable SE_BACKUP_NAME and
//  SE_RESTORE_NAME for CERT_STORE_BACKUP_RESTORE_FLAG.
//--------------------------------------------------------------------------
BOOL
IPR_EnableSecurityPrivilege(
    LPCSTR pszPrivilege
    )
{
    BOOL fResult;
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious;

    if (!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            ))
        goto OpenProcessTokenError;

    if (!LookupPrivilegeValueA(NULL, pszPrivilege, &luid))
        goto LookupPrivilegeValueError;

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    cbPrevious = sizeof(TOKEN_PRIVILEGES);
    memset(&tpPrevious, 0, sizeof(TOKEN_PRIVILEGES));
    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );
    if (ERROR_SUCCESS != GetLastError())
        goto AdjustTokenPrivilegesError;

    //
    // second pass.  enable privilege
    //
    if (0 == tpPrevious.PrivilegeCount)
        tpPrevious.Privileges[0].Attributes = 0;

    tpPrevious.PrivilegeCount       = 1;
    tpPrevious.Privileges[0].Luid   = luid;
    tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tpPrevious,
            cbPrevious,
            NULL,
            NULL
            );
    if (ERROR_SUCCESS != GetLastError())
        goto AdjustTokenPrivilegesError;

    fResult = TRUE;
CommonReturn:
    if (hToken)
        CloseHandle(hToken);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenProcessTokenError)
TRACE_ERROR(LookupPrivilegeValueError)
TRACE_ERROR(AdjustTokenPrivilegesError)
}

//+-------------------------------------------------------------------------
//  Take ownership of the "ProtectedRoots" SubKey
//--------------------------------------------------------------------------
STATIC BOOL SetProtectedRootOwner(
    IN HKEY hKeyCU,
    OUT BOOL *pfNew
    )
{
    BOOL fResult;
    LONG err;
    BOOL fNew = FALSE;
    HKEY hKeyProtRoot = NULL;
    SECURITY_DESCRIPTOR sd;

    if (!IPR_EnableSecurityPrivilege(SE_TAKE_OWNERSHIP_NAME))
        goto EnableTakeOwnershipPrivilegeError;

    if (hKeyProtRoot = OpenProtectedRootSubKey(hKeyCU, WRITE_OWNER))
        fNew = FALSE;
    else {
        if (ERROR_FILE_NOT_FOUND == GetLastError())
            hKeyProtRoot = CreateProtectedRootSubKey(hKeyCU, WRITE_OWNER);
        if (NULL == hKeyProtRoot)
            goto OpenProtectedRootSubKeyError;
        fNew = TRUE;
    }

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
        goto InitializeSecurityDescriptorError;

    if (!SetSecurityDescriptorOwner(&sd, PSID_PROT_OWNER, FALSE))
        goto SetSecurityDescriptorOwnerError;

    if (ERROR_SUCCESS != (err = RegSetKeySecurity(
            hKeyProtRoot,
            OWNER_SECURITY_INFORMATION,
            &sd
            )))
        goto RegSetKeySecurityError;

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    *pfNew = fNew;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(EnableTakeOwnershipPrivilegeError)
TRACE_ERROR(OpenProtectedRootSubKeyError)
TRACE_ERROR(InitializeSecurityDescriptorError)
TRACE_ERROR(SetSecurityDescriptorOwnerError)
SET_ERROR_VAR(RegSetKeySecurityError, err)
}

//+-------------------------------------------------------------------------
//  Allocate and get the specified token info.
//--------------------------------------------------------------------------
static void * AllocAndGetTokenInfo(
    IN HANDLE hToken,
    IN TOKEN_INFORMATION_CLASS tic
    )
{
    void *pvInfo = NULL;
    DWORD cbInfo = 0;
    DWORD cbInfo2;

    if (!GetTokenInformation(
            hToken,
            tic,
            pvInfo,
            0,              // cbInfo
            &cbInfo
            )) {
        if (ERROR_INSUFFICIENT_BUFFER != GetLastError())
            goto GetTokenInfoError;
    }
    if (0 == cbInfo)
        goto NoTokenInfoError;
    if (NULL == (pvInfo = PkiNonzeroAlloc(cbInfo)))
        goto OutOfMemory;

    cbInfo2 = cbInfo;
    if (!GetTokenInformation(
            hToken,
            tic,
            pvInfo,
            cbInfo,
            &cbInfo2
            ))
        goto GetTokenInfoError;

CommonReturn:
    return pvInfo;
ErrorReturn:
    PkiFree(pvInfo);
    pvInfo = NULL;
    goto CommonReturn;
TRACE_ERROR(GetTokenInfoError)
SET_ERROR(NoTokenInfoError, ERROR_NO_TOKEN)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Set the security group, DACLs and SACLs for the "ProtectedRoots" SubKey
//--------------------------------------------------------------------------
STATIC BOOL SetProtectedRootGroupDaclSacl(
    IN HKEY hKeyCU
    )
{
    BOOL fResult;
    LONG err;
    HKEY hKeyProtRoot = NULL;
    SECURITY_DESCRIPTOR sd;
    HANDLE hToken = NULL;
    void *pvTokenInfo = NULL;

    PACL pDacl = NULL;
    PACCESS_ALLOWED_ACE pAce;
    DWORD dwAclSize;
    DWORD i;

    if (!IPR_EnableSecurityPrivilege(SE_SECURITY_NAME))
        goto EnableSecurityNamePrivilegeError;

    if (NULL == (hKeyProtRoot = OpenProtectedRootSubKey(
            hKeyCU,
            WRITE_OWNER | WRITE_DAC | ACCESS_SYSTEM_SECURITY
            )))
        goto OpenProtectedRootSubKeyError;

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
        goto InitializeSecurityDescriptorError;

    // Set group SID using current process token's primary group SID
    if (!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY,
            &hToken
            ))
        goto OpenProcessTokenError;
    if (NULL == (pvTokenInfo = AllocAndGetTokenInfo(hToken, TokenPrimaryGroup)))
        goto GetTokenInfoError;
    else {
        PTOKEN_PRIMARY_GROUP pTokenPrimaryGroup =
            (PTOKEN_PRIMARY_GROUP) pvTokenInfo;
        PSID psidGroup = pTokenPrimaryGroup->PrimaryGroup;

        if (!SetSecurityDescriptorGroup(&sd, psidGroup, FALSE))
            goto SetSecurityDescriptorGroupError;
    }

    // Set DACL

    //
    // compute size of ACL
    //
    dwAclSize = sizeof(ACL) +
        PROT_ACE_COUNT * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(PSID_PROT_SYSTEM) +
        GetLengthSid(PSID_PROT_EVERYONE)
        ;

    //
    // allocate storage for Acl
    //
    if (NULL == (pDacl = (PACL) PkiNonzeroAlloc(dwAclSize)))
        goto OutOfMemory;

    if (!InitializeAcl(pDacl, dwAclSize, ACL_REVISION))
        goto InitializeAclError;

    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            PROT_SYSTEM_ACE_MASK,
            PSID_PROT_SYSTEM
            ))
        goto AddAceError;
    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            PROT_EVERYONE_ACE_MASK,
            PSID_PROT_EVERYONE
            ))
        goto AddAceError;

    //
    // make containers inherit.
    //
    for (i = 0; i < PROT_ACE_COUNT; i++) {
        if(!GetAce(pDacl, i, (void **) &pAce))
            goto GetAceError;
        pAce->Header.AceFlags = PROT_ACE_FLAGS;
    }

    if (!SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE))
        goto SetSecurityDescriptorDaclError;

    // Set SACL
    if (!SetSecurityDescriptorSacl(&sd, FALSE, NULL, FALSE))
        goto SetSecurityDescriptorSaclError;

    if (ERROR_SUCCESS != (err = RegSetKeySecurity(
            hKeyProtRoot,
            GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION |
                SACL_SECURITY_INFORMATION,
            &sd
            )))
        goto RegSetKeySecurityError;

    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    if (hToken)
        CloseHandle(hToken);
    PkiFree(pvTokenInfo);
    PkiFree(pDacl);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(EnableSecurityNamePrivilegeError)
TRACE_ERROR(OpenProtectedRootSubKeyError)
TRACE_ERROR(InitializeSecurityDescriptorError)
TRACE_ERROR(OpenProcessTokenError)
TRACE_ERROR(GetTokenInfoError)
TRACE_ERROR(SetSecurityDescriptorGroupError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(InitializeAclError)
TRACE_ERROR(AddAceError)
TRACE_ERROR(GetAceError)
TRACE_ERROR(SetSecurityDescriptorDaclError)
TRACE_ERROR(SetSecurityDescriptorSaclError)
SET_ERROR_VAR(RegSetKeySecurityError, err)
}

//+-------------------------------------------------------------------------
//  Create the initial protected root info.
//
//  If not inhibited, add all the roots in the unprotected CurrentUser
//  "Root" store.
//--------------------------------------------------------------------------
STATIC BOOL InitAndSetProtectedRootInfo(
    IN HKEY hKeyCU,
    IN BOOL fNew
    )
{
    BOOL fResult;
    HKEY hKeyProtRoot = NULL;
    HCERTSTORE hStore = NULL;
    PPROT_ROOT_INFO pInfo = NULL;

    if (NULL == (pInfo = (PPROT_ROOT_INFO) PkiNonzeroAlloc(
            sizeof(PROT_ROOT_INFO))))
        goto OutOfMemory;
    memset(pInfo, 0, sizeof(PROT_ROOT_INFO));
    pInfo->cbSize = sizeof(PROT_ROOT_INFO);
    pInfo->dwVersion = PROT_ROOT_V1;
    pInfo->dwRootOffset = sizeof(PROT_ROOT_INFO);

    if (fNew && 0 == (GetProtectedRootFlags() &
            CERT_PROT_ROOT_INHIBIT_ADD_AT_INIT_FLAG)) {
        if (hStore = OpenUnprotectedRootStore(hKeyCU,
                CERT_STORE_READONLY_FLAG)) {
            PCCERT_CONTEXT pCert = NULL;
            while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
                BYTE rgbHash[PROT_ROOT_HASH_LEN];
                if (GetVerifiedCertHashProperty(pCert, rgbHash)) {
                    if (!AddProtectedRoot(&pInfo, rgbHash))
                        goto AddProtectedRootError;
                }
            }
        }
    }

    if (NULL == (hKeyProtRoot = OpenProtectedRootSubKey(
            hKeyCU,
            KEY_ALL_ACCESS
            ))) goto OpenProtectedRootSubKeyError;

    if (!WriteProtectedRootInfo(hKeyProtRoot, pInfo))
        goto WritedProtectedRootInfoError;

    fResult = TRUE;
CommonReturn:
    PkiFree(pInfo);
    CertCloseStore(hStore, 0);
    ILS_CloseRegistryKey(hKeyProtRoot);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(AddProtectedRootError)
TRACE_ERROR(OpenProtectedRootSubKeyError)
TRACE_ERROR(WritedProtectedRootInfoError)
}

//+-------------------------------------------------------------------------
//  Open the "ProtectedRoots" SubKey and verify its security. Allocate,
//  read and verify the protected root information.
//
//  If the "ProtectedRoots" SubKey doesn't exist or is invalid, initialize.
//--------------------------------------------------------------------------
STATIC BOOL SrvGetProtectedRootInfo(
    IN HKEY hKeyCU,
    OUT OPTIONAL HKEY *phKeyProtRoot,
    OUT OPTIONAL PPROT_ROOT_INFO *ppProtRootInfo
    )
{
    BOOL fNew;
    if (GetProtectedRootInfo(
            hKeyCU,
            KEY_ALL_ACCESS,
            phKeyProtRoot,
            ppProtRootInfo
            ))
        return TRUE;

    if (!GetPredefinedSids())
        return FALSE;

    if (!SetProtectedRootOwner(hKeyCU, &fNew))
        return FALSE;
    if (!SetProtectedRootGroupDaclSacl(hKeyCU))
        return FALSE;
    if (!InitAndSetProtectedRootInfo(hKeyCU, fNew))
        return FALSE;

    return GetProtectedRootInfo(
        hKeyCU,
        KEY_ALL_ACCESS,
        phKeyProtRoot,
        ppProtRootInfo
        );
}

//+-------------------------------------------------------------------------
//  Initialize the protected list of CurrentUser roots
//--------------------------------------------------------------------------
STATIC BOOL SrvInitProtectedRoots(
    IN HKEY hKeyCU
    )
{
    return SrvGetProtectedRootInfo(
        hKeyCU,
        NULL,           // phKeyProtRoot
        NULL            // ppProtRootInfo
        );
}

//+-------------------------------------------------------------------------
//  Purge all CurrentUser roots from the protected list that also exist
//  in the LocalMachine SystemRegistry "Root" store. Also removes duplicated
//  certificates from the CurrentUser SystemRegistry "Root" store.
//--------------------------------------------------------------------------
STATIC BOOL SrvPurgeLocalMachineProtectedRoots(
    IN HKEY hKeyCU,
    IN LPCWSTR pwszRootStoreName
    )
{
    BOOL fResult;
    HKEY hKeyProtRoot = NULL;
    PPROT_ROOT_INFO pInfo = NULL;
    PCCERT_CONTEXT pCert = NULL;
    HCERTSTORE hCURootStore = NULL;
    HCERTSTORE hLMRootStore = NULL;
    BOOL fProtDeleted;
    BYTE rgbHash[PROT_ROOT_HASH_LEN];
    CRYPT_DATA_BLOB HashBlob;
    DWORD dwRootIndex;

    if (!SrvGetProtectedRootInfo(
            hKeyCU,
            &hKeyProtRoot,
            &pInfo
            )) goto GetProtectedRootInfoError;

    if (GetProtectedRootFlags() & CERT_PROT_ROOT_INHIBIT_PURGE_LM_FLAG)
        goto AccessDenied;

    if (NULL == (hCURootStore = OpenUnprotectedRootStore(hKeyCU)))
        goto OpenCURootStoreError;

    if (NULL == (hLMRootStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_REGISTRY_W,
            0,                                  // dwEncodingType
            NULL,                               // hCryptProv
            CERT_SYSTEM_STORE_LOCAL_MACHINE | CERT_STORE_READONLY_FLAG,
            (const void *) pwszRootStoreName
            )))
        goto OpenLMRootStoreError;

    HashBlob.pbData = rgbHash;
    HashBlob.cbData = PROT_ROOT_HASH_LEN;
    fProtDeleted = FALSE;
    pCert = NULL;
    while (pCert = CertEnumCertificatesInStore(hCURootStore, pCert)) {
        if (GetVerifiedCertHashProperty(pCert, rgbHash)) {
            PCCERT_CONTEXT pLMCert;

            if (pLMCert = CertFindCertificateInStore(
                    hLMRootStore,
                    0,                  // dwCertEncodingType
                    0,                  // dwFindFlags
                    CERT_FIND_SHA1_HASH,
                    (const void *) &HashBlob,
                    NULL                //pPrevCertContext
                    )) {
                // CurrentUser Root also exists in LocalMachine. Delete
                // it from the CurrentUser Root store.
                PCCERT_CONTEXT pDeleteCert =
                    CertDuplicateCertificateContext(pCert);

                CertFreeCertificateContext(pLMCert);
                if (!CertDeleteCertificateFromStore(pDeleteCert))
                    goto DeleteCertFromRootStoreError;

                if (FindProtectedRoot(pInfo, rgbHash, &dwRootIndex)) {
                    // The CurrentUser Root is in the protected list,
                    // delete it from there.
                    DeleteProtectedRoot(pInfo, dwRootIndex);
                    fProtDeleted = TRUE;
                }
            }
        }
    }

    // If a protected root exists in the LocalMachine, then, delete it
    // from  the protected list. This step is necessary, if the root
    // was removed from the CurrentUser unprotected store.
    dwRootIndex = pInfo->cRoot;
    HashBlob.pbData = (BYTE *) pInfo + pInfo->dwRootOffset +
        PROT_ROOT_HASH_LEN * dwRootIndex;
    while (dwRootIndex--) {
        PCCERT_CONTEXT pLMCert;

        HashBlob.pbData -= PROT_ROOT_HASH_LEN;
        if (pLMCert = CertFindCertificateInStore(
                hLMRootStore,
                0,                  // dwCertEncodingType
                0,                  // dwFindFlags
                CERT_FIND_SHA1_HASH,
                (const void *) &HashBlob,
                NULL                //pPrevCertContext
                )) {
            CertFreeCertificateContext(pLMCert);
            // Cert exists in the LocalMachine store, delete
            // from protected list.
            DeleteProtectedRoot(pInfo, dwRootIndex);
            fProtDeleted = TRUE;
        }
    }

    if (fProtDeleted) {
        if (!WriteProtectedRootInfo(hKeyProtRoot, pInfo))
            goto WriteProtectedRootInfoError;
    }
    
    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    PkiFree(pInfo);
    CertFreeCertificateContext(pCert);
    CertCloseStore(hCURootStore, 0);
    CertCloseStore(hLMRootStore, 0);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(OpenCURootStoreError)
TRACE_ERROR(OpenLMRootStoreError)
TRACE_ERROR(GetProtectedRootInfoError)
TRACE_ERROR(DeleteCertFromRootStoreError)
TRACE_ERROR(WriteProtectedRootInfoError)
}

//+-------------------------------------------------------------------------
//  Add the specified certificate to the CurrentUser SystemRegistry "Root"
//  store and the protected list of roots. The user is prompted before doing
//  the add.
//
//  Note, CertAddSerializedElementToStore() has __try/__except around
//  accessing pbSerializedCert.
//--------------------------------------------------------------------------
STATIC BOOL SrvAddProtectedRoot(
    IN handle_t hRpc,
    IN HKEY hKeyCU,
    IN BYTE *pbSerializedCert,
    IN DWORD cbSerializedCert
    )
{
    BOOL fResult;
    HKEY hKeyProtRoot = NULL;
    PPROT_ROOT_INFO pInfo = NULL;
    PCCERT_CONTEXT pCert = NULL;
    BYTE rgbCertHash[PROT_ROOT_HASH_LEN];
    HCERTSTORE hRootStore = NULL;
    BOOL fProtExists;

    if (!SrvGetProtectedRootInfo(
            hKeyCU,
            &hKeyProtRoot,
            &pInfo
            )) goto GetProtectedRootInfoError;

    if (!CertAddSerializedElementToStore(
            NULL,               // hCertStore, NULL => create context
            pbSerializedCert,
            cbSerializedCert,
            CERT_STORE_ADD_ALWAYS,
            0,                  // dwFlags
            CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
            NULL,               // pdwContextType
            (const void **) &pCert
            )) goto CreateCertContextError;

    if (!GetVerifiedCertHashProperty(pCert, rgbCertHash))
        goto VerifyHashPropertyError;

    fProtExists = FindProtectedRoot(pInfo, rgbCertHash);
    if (!fProtExists) {
        if (IDYES != IPR_ProtectedRootMessageBox(
                hRpc,
                pCert,
                IDS_ROOT_MSG_BOX_ADD_ACTION,
                MB_TOPMOST | MB_SERVICE_NOTIFICATION ))
            goto Cancelled;
    }

    if (NULL == (hRootStore = OpenUnprotectedRootStore(hKeyCU)))
        goto OpenRootStoreError;

    if (!CertAddSerializedElementToStore(
            hRootStore,
            pbSerializedCert,
            cbSerializedCert,
            CERT_STORE_ADD_REPLACE_EXISTING,
            0,                  // dwFlags
            CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
            NULL,               // pdwContextType
            NULL                // ppvContext
            )) goto AddCertToRootStoreError;

    if (!fProtExists) {
        if (!AddProtectedRoot(&pInfo, rgbCertHash))
            goto AddProtectedRootError;
        if (!WriteProtectedRootInfo(hKeyProtRoot, pInfo))
            goto WriteProtectedRootInfoError;
    }
    
    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    PkiFree(pInfo);
    CertFreeCertificateContext(pCert);
    CertCloseStore(hRootStore, 0);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(Cancelled, ERROR_CANCELLED)
TRACE_ERROR(CreateCertContextError)
TRACE_ERROR(VerifyHashPropertyError)
TRACE_ERROR(GetProtectedRootInfoError)
TRACE_ERROR(OpenRootStoreError)
TRACE_ERROR(AddCertToRootStoreError)
TRACE_ERROR(AddProtectedRootError)
TRACE_ERROR(WriteProtectedRootInfoError)
}


//+-------------------------------------------------------------------------
//  Delete the specified certificate from the CurrentUser SystemRegistry "Root"
//  store and the protected list of roots. The user is prompted before doing
//  the delete.
//
//  __try/__except around memory access to
//  rgbUntrustedRootHash[PROT_ROOT_HASH_LEN]
//--------------------------------------------------------------------------
STATIC BOOL SrvDeleteProtectedRoot(
    IN handle_t hRpc,
    IN HKEY hKeyCU,
    IN BYTE rgbUntrustedRootHash[PROT_ROOT_HASH_LEN]
    )
{
    BOOL fResult;
    HKEY hKeyProtRoot = NULL;
    PPROT_ROOT_INFO pInfo = NULL;
    PCCERT_CONTEXT pCert = NULL;
    HCERTSTORE hRootStore = NULL;
    BYTE rgbCertHash[PROT_ROOT_HASH_LEN];
    DWORD dwRootIndex;
    BOOL fProtExists;
    BYTE rgbRootHash[PROT_ROOT_HASH_LEN];
    CRYPT_DATA_BLOB RootHashBlob;
    DWORD dwExceptionCode;

    if (!SrvGetProtectedRootInfo(
            hKeyCU,
            &hKeyProtRoot,
            &pInfo
            )) goto GetProtectedRootInfoError;

    if (NULL == (hRootStore = OpenUnprotectedRootStore(hKeyCU)))
        goto OpenRootStoreError;

    __try {
        memcpy(rgbRootHash, rgbUntrustedRootHash, sizeof(rgbRootHash));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto ExceptionError;
    }

    RootHashBlob.pbData = rgbRootHash;
    RootHashBlob.cbData = PROT_ROOT_HASH_LEN;
    if (NULL == (pCert = CertFindCertificateInStore(
            hRootStore,
            0,                  // dwCertEncodingType
            0,                  // dwFindFlags
            CERT_FIND_SHA1_HASH,
            (const void *) &RootHashBlob,
            NULL                //pPrevCertContext
            ))) goto FindCertError;

    if (!GetVerifiedCertHashProperty(pCert, rgbCertHash))
        goto VerifyHashPropertyError;

    fProtExists = FindProtectedRoot(pInfo, rgbCertHash, &dwRootIndex);
    if (fProtExists) {
        if (IDYES != IPR_ProtectedRootMessageBox(
                hRpc,
                pCert,
                IDS_ROOT_MSG_BOX_DELETE_ACTION,
                MB_TOPMOST | MB_SERVICE_NOTIFICATION ))
            goto Cancelled;
    }

    fResult = CertDeleteCertificateFromStore(pCert);
    pCert = NULL;
    if (!fResult)
        goto DeleteCertFromRootStoreError;
    if (fProtExists) {
        DeleteProtectedRoot(pInfo, dwRootIndex);
        if (!WriteProtectedRootInfo(hKeyProtRoot, pInfo))
            goto WriteProtectedRootInfoError;
    }
    
    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    PkiFree(pInfo);
    CertFreeCertificateContext(pCert);
    CertCloseStore(hRootStore, 0);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(Cancelled, ERROR_CANCELLED)
TRACE_ERROR(OpenRootStoreError)
TRACE_ERROR(FindCertError)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
TRACE_ERROR(VerifyHashPropertyError)
TRACE_ERROR(GetProtectedRootInfoError)
TRACE_ERROR(DeleteCertFromRootStoreError)
TRACE_ERROR(WriteProtectedRootInfoError)
}

//+-------------------------------------------------------------------------
//  Delete all CurrentUser roots from the protected list that don't also
//  exist in the CurrentUser SystemRegistry "Root" store. The user is
//  prompted before doing the delete.
//--------------------------------------------------------------------------
STATIC BOOL SrvDeleteUnknownProtectedRoots(
    IN handle_t hRpc,
    IN HKEY hKeyCU
    )
{
    BOOL fResult;
    HKEY hKeyProtRoot = NULL;
    PPROT_ROOT_INFO pInfo = NULL;
    HCERTSTORE hRootStore = NULL;
    DWORD cOrigRoot;
    CRYPT_DATA_BLOB HashBlob;
    DWORD dwRootIndex;

    if (!SrvGetProtectedRootInfo(
            hKeyCU,
            &hKeyProtRoot,
            &pInfo
            )) goto GetProtectedRootInfoError;
    if (NULL == (hRootStore = OpenUnprotectedRootStore(hKeyCU)))
        goto OpenRootStoreError;

    cOrigRoot = pInfo->cRoot;

    HashBlob.pbData = (BYTE *) pInfo + pInfo->dwRootOffset +
        PROT_ROOT_HASH_LEN * cOrigRoot;
    HashBlob.cbData = PROT_ROOT_HASH_LEN;
    dwRootIndex = cOrigRoot;
    while (dwRootIndex--) {
        PCCERT_CONTEXT pCert;

        HashBlob.pbData -= PROT_ROOT_HASH_LEN;
        if (pCert = CertFindCertificateInStore(
                hRootStore,
                0,                  // dwCertEncodingType
                0,                  // dwFindFlags
                CERT_FIND_SHA1_HASH,
                (const void *) &HashBlob,
                NULL                //pPrevCertContext
                ))
            CertFreeCertificateContext(pCert);
        else
            // Cert doesn't exist in the unprotected store, delete
            // from protected list.
            DeleteProtectedRoot(pInfo, dwRootIndex);
    }

    if (cOrigRoot > pInfo->cRoot) {
        // At least one root was deleted above
        int id;
        LPWSTR pwszTitle;
        LPWSTR pwszText;
        DWORD cchText;
        RPC_STATUS RpcStatus = 0;

        FormatMsgBoxItem(&pwszTitle, &cchText, IDS_ROOT_MSG_BOX_TITLE);
        FormatMsgBoxItem(&pwszText, &cchText,
            IDS_ROOT_MSG_BOX_DELETE_UNKNOWN_PROT_ROOTS,
                cOrigRoot - pInfo->cRoot);

        // Do impersonation for TerminalServer clients
        if (hRpc)
            RpcStatus = RpcImpersonateClient(hRpc);
        id = MessageBoxU(
                NULL,       // hwndOwner
                pwszText,
                pwszTitle,
                MB_YESNO | MB_DEFBUTTON2 | MB_ICONWARNING |
                    MB_TOPMOST | MB_SERVICE_NOTIFICATION
                );
        if (hRpc && ERROR_SUCCESS == RpcStatus)
            RpcRevertToSelf();

        LocalFree((HLOCAL) pwszTitle);
        LocalFree((HLOCAL) pwszText);
        if (IDYES != id)
            goto AccessDenied;

        if (!WriteProtectedRootInfo(hKeyProtRoot, pInfo))
            goto WriteProtectedRootInfoError;
    }
    
    fResult = TRUE;
CommonReturn:
    ILS_CloseRegistryKey(hKeyProtRoot);
    PkiFree(pInfo);
    CertCloseStore(hRootStore, 0);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AccessDenied, E_ACCESSDENIED)
TRACE_ERROR(GetProtectedRootInfoError)
TRACE_ERROR(OpenRootStoreError)
TRACE_ERROR(WriteProtectedRootInfoError)
}

// Forward reference
STATIC BOOL SrvLogCrypt32Event(
    IN BYTE *pbIn,
    IN DWORD cbIn
    );

STATIC BOOL SrvAddCertInCtl(
    IN BYTE *pbIn,
    IN DWORD cbIn
    );

//+-------------------------------------------------------------------------
//  Called from the services process to process a protected certificate 
//  function.
//
//  Returns the error status, ie, not returned in LastError.
//--------------------------------------------------------------------------
DWORD
WINAPI
I_CertSrvProtectFunction(
    IN handle_t hRpc,
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN LPCWSTR pwszIn,
    IN BYTE *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut,
    IN PFN_CERT_PROT_MIDL_USER_ALLOC pfnAlloc,
    IN PFN_CERT_PROT_MIDL_USER_FREE pfnFree
    )
{
    DWORD dwErr;
    BOOL fResult;
    HKEY hKeyCU = NULL;
    LONG err;
#ifndef TESTING_NO_PROT_ROOT_RPC
    RPC_STATUS RpcStatus;
#endif

#ifdef TESTING_NO_PROT_ROOT_RPC
    // For testing, called from the client's process
    err = RegOpenHKCU(&hKeyCU);
    if (ERROR_SUCCESS != err)
        goto RegOpenHKCUError;
#else
    if (NULL == hRpc)
        goto InvalidArg;

    // Get the client's HKCU.
    if (ERROR_SUCCESS != (RpcStatus = RpcImpersonateClient(hRpc)))
        goto ImpersonateClientError;
    err = RegOpenHKCUEx(&hKeyCU, REG_HKCU_LOCAL_SYSTEM_ONLY_DEFAULT_FLAG);
    RpcRevertToSelf();
    if (ERROR_SUCCESS != err)
        goto RegOpenHKCUError;
#endif

    switch (dwFuncId) {
        case CERT_PROT_INIT_ROOTS_FUNC_ID:
            fResult = SrvInitProtectedRoots(hKeyCU);
            break;
        case CERT_PROT_PURGE_LM_ROOTS_FUNC_ID:
            fResult = SrvPurgeLocalMachineProtectedRoots(hKeyCU, L"Root");
            fResult &= SrvPurgeLocalMachineProtectedRoots(hKeyCU, L"AuthRoot");
            break;
        case CERT_PROT_ADD_ROOT_FUNC_ID:
            if (NULL == pbIn || 0 == cbIn)
                goto InvalidArg;
            fResult = SrvAddProtectedRoot(hRpc, hKeyCU, pbIn, cbIn);
            break;
        case CERT_PROT_DELETE_ROOT_FUNC_ID:
            if (NULL == pbIn || PROT_ROOT_HASH_LEN != cbIn)
                goto InvalidArg;
            fResult = SrvDeleteProtectedRoot(hRpc, hKeyCU, pbIn);
            break;
        case CERT_PROT_DELETE_UNKNOWN_ROOTS_FUNC_ID:
            fResult = SrvDeleteUnknownProtectedRoots(hRpc, hKeyCU);
            break;
        case CERT_PROT_ADD_ROOT_IN_CTL_FUNC_ID:
            if (NULL == pbIn || 0 == cbIn)
                goto InvalidArg;
            fResult = SrvAddCertInCtl(pbIn, cbIn);
            break;
        case CERT_PROT_LOG_EVENT_FUNC_ID:
            if (NULL == pbIn || 0 == cbIn)
                goto InvalidArg;
            fResult = SrvLogCrypt32Event(pbIn, cbIn);
            break;
        case CERT_PROT_ROOT_LIST_FUNC_ID:
            // Removed support for XAddRoot control
        default:
            goto InvalidArg;
    }

    if (!fResult)
        goto ErrorReturn;
    dwErr = ERROR_SUCCESS;
CommonReturn:
    if (hKeyCU)
        RegCloseHKCU(hKeyCU);
    return dwErr;
ErrorReturn:
    dwErr = GetLastError();
    if (0 == dwErr)
        dwErr = (DWORD) E_UNEXPECTED;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
#ifdef TESTING_NO_PROT_ROOT_RPC
#else
SET_ERROR_VAR(ImpersonateClientError, RpcStatus)
#endif
SET_ERROR_VAR(RegOpenHKCUError, err)
}

#ifdef TESTING_NO_PROT_ROOT_RPC
// For testing: the server stuff resides in the client process
BOOL
WINAPI
I_CertProtectFunction(
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszIn,
    IN OPTIONAL BYTE *pbIn,
    IN DWORD cbIn,
    OUT OPTIONAL BYTE **ppbOut,
    OUT OPTIONAL DWORD *pcbOut
    )
{
    DWORD dwErr;
    dwErr = I_CertSrvProtectFunction(
        NULL,           // hRpc
        dwFuncId,
        dwFlags,
        pwszIn,
        pbIn,
        cbIn,
        NULL,           // ppbOut
        NULL,           // pcbOut
        NULL,           // pfnAlloc
        NULL            // pfnFree
        );

    if (ERROR_SUCCESS == dwErr)
        return TRUE;
    else {
        SetLastError(dwErr);
        return FALSE;
    }
}
#else

BOOL
WINAPI
I_CertProtectFunction(
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszIn,
    IN OPTIONAL BYTE *pbIn,
    IN DWORD cbIn,
    OUT OPTIONAL BYTE **ppbOut,
    OUT OPTIONAL DWORD *pcbOut
    )
{
    return I_CertCltProtectFunction(
        dwFuncId,
        dwFlags,
        pwszIn,
        pbIn,
        cbIn,
        ppbOut,
        pcbOut
        );
}
#endif



//+=========================================================================
//  Protected root functions called from the client process in logstor.cpp
//  or in ..\chain\chain.cpp
//==========================================================================
    
//+-------------------------------------------------------------------------
//  Returns TRUE if the protected root flag wasn't set to disable the opening
//  of the CurrentUser's "root\.Default" physical store.
//--------------------------------------------------------------------------
BOOL
IPR_IsCurrentUserRootsAllowed()
{
    DWORD dwProtRootFlags;
    dwProtRootFlags = GetProtectedRootFlags();
    return 0 == (dwProtRootFlags & CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG);
}

//+-------------------------------------------------------------------------
//  Returns TRUE if the protected root flag wasn't set to disable the opening
//  of the LocalMachine's "root\.AuthRoot" physical store.
//--------------------------------------------------------------------------
BOOL
IPR_IsAuthRootsAllowed()
{
    DWORD dwProtRootFlags;
    dwProtRootFlags = GetProtectedRootFlags();
    return 0 == (dwProtRootFlags & CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG);
}

//+-------------------------------------------------------------------------
//  Returns TRUE if the protected root flag was set to disable the
//  requiring of the issuing CA certificate being in the "NTAuth"
//  Enterprise store.
//--------------------------------------------------------------------------
BOOL
IPR_IsNTAuthRequiredDisabled()
{
    DWORD dwProtRootFlags;
    dwProtRootFlags = GetProtectedRootFlags();
    return 0 != (dwProtRootFlags &
                    CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG);
}


//+-------------------------------------------------------------------------
//  Returns TRUE if the protected root flag was set to disable checking for
//  not defined name constraints.
//--------------------------------------------------------------------------
BOOL
IPR_IsNotDefinedNameConstraintDisabled()
{
    DWORD dwProtRootFlags;
    dwProtRootFlags = GetProtectedRootFlags();
    return 0 != (dwProtRootFlags &
                    CERT_PROT_ROOT_DISABLE_NOT_DEFINED_NAME_CONSTRAINT_FLAG);
}

//+---------------------------------------------------------------------------
//  Returns TRUE if Auto Update has been disabled
//----------------------------------------------------------------------------
BOOL
IPR_IsAuthRootAutoUpdateDisabled()
{
    HKEY hKey = NULL;
    DWORD dwInstallFlag = 0;

    if (!IPR_IsAuthRootsAllowed())
        return TRUE;

    if (ERROR_SUCCESS != RegOpenKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_OCM_SUBCOMPONENTS_LOCAL_MACHINE_REGPATH,
            0,                      // dwReserved
            KEY_READ,
            &hKey
            ))
        return TRUE;

    ILS_ReadDWORDValueFromRegistry(
        hKey,
        CERT_OCM_SUBCOMPONENTS_ROOT_AUTO_UPDATE_VALUE_NAME,
        &dwInstallFlag
        );
    ILS_CloseRegistryKey(hKey);

    return 0 == dwInstallFlag;
}


//+-------------------------------------------------------------------------
//  Gets the protected root information containing the list of protected
//  root stores.
//
//  If protected root store isn't supported, returns TRUE with
//  *ppProtRootInfo set to NULL.
//--------------------------------------------------------------------------
BOOL CltGetProtectedRootInfo(
    OUT PPROT_ROOT_INFO *ppInfo
    )
{
    BOOL fResult;
    LONG err;
    HKEY hKeyCU = NULL;

    *ppInfo = NULL;

#ifndef TESTING_NO_PROT_ROOT_RPC
    if (!FIsWinNT5())
        // No protected roots on Win9x or NT4.0
        return TRUE;
#endif

    if (ERROR_SUCCESS != (err = RegOpenHKCU(&hKeyCU)))
        goto RegOpenHKCUError;

    if (GetProtectedRootInfo(
            hKeyCU,
            KEY_READ,
            NULL,                   // phKeyProtRoot
            ppInfo
            )) goto SuccessReturn;

    if (!I_CertProtectFunction(
            CERT_PROT_INIT_ROOTS_FUNC_ID,
            0,                              // dwFlags
            NULL,                           // pwszIn
            NULL,                           // pbIn
            0,                              // cbIn
            NULL,                           // ppbOut
            NULL                            // pcbOut
            )) {
        DWORD dwErr = GetLastError();
        if (ERROR_CALL_NOT_IMPLEMENTED == dwErr || RPC_S_UNKNOWN_IF == dwErr)
            goto SuccessReturn;
        goto ProtFuncError;
    }

    if (!GetProtectedRootInfo(
            hKeyCU,
            KEY_READ,
            NULL,                   // phKeyProtRoot
            ppInfo
            ))
        goto GetProtectedRootInfoError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    if (hKeyCU)
        RegCloseHKCU(hKeyCU);
    return fResult;
ErrorReturn:
    *ppInfo = NULL;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(RegOpenHKCUError, err)
TRACE_ERROR(GetProtectedRootInfoError)
TRACE_ERROR(ProtFuncError)
}
    
//+-------------------------------------------------------------------------
//  Initializes the protected list of roots.
//--------------------------------------------------------------------------
void
IPR_InitProtectedRootInfo()
{
    HKEY hKeyCU;

#ifndef TESTING_NO_PROT_ROOT_RPC
    if (!FIsWinNT5())
        // No protected roots on Win9x or NT4.0
        return;
#endif

    if (ERROR_SUCCESS == RegOpenHKCU(&hKeyCU)) {
        HKEY hKeyProtRoot;

        if (hKeyProtRoot = OpenProtectedRootSubKey(hKeyCU, KEY_READ))
            // Protected root subkey exists
            ILS_CloseRegistryKey(hKeyProtRoot);
        else {
            I_CertProtectFunction(
                CERT_PROT_INIT_ROOTS_FUNC_ID,
                0,                              // dwFlags
                NULL,                           // pwszIn
                NULL,                           // pbIn
                0,                              // cbIn
                NULL,                           // ppbOut
                NULL                            // pcbOut
                );
        }

        RegCloseHKCU(hKeyCU);
    }
}

//+-------------------------------------------------------------------------
//  Delete certificates not in the protected store list.
//--------------------------------------------------------------------------
BOOL
IPR_DeleteUnprotectedRootsFromStore(
    IN HCERTSTORE hStore,
    OUT BOOL *pfProtected
    )
{
    PPROT_ROOT_INFO pInfo;
    PCCERT_CONTEXT pCert;

    if (!CltGetProtectedRootInfo(&pInfo)) {
        *pfProtected = FALSE;
        // Delete all certificates from the store's cache.
        while (pCert = CertEnumCertificatesInStore(hStore, NULL))
            CertDeleteCertificateFromStore(pCert);
        return FALSE;
    }

    if (NULL == pInfo)
        // Root store isn't protected.
        *pfProtected = FALSE;
    else {
        *pfProtected = TRUE;
        pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hStore, pCert)) {
            BYTE rgbHash[PROT_ROOT_HASH_LEN];
            if (!GetVerifiedCertHashProperty(pCert, rgbHash) ||
                    !FindProtectedRoot(pInfo, rgbHash)) {
                PCCERT_CONTEXT pDeleteCert =
                    CertDuplicateCertificateContext(pCert);
                CertDeleteCertificateFromStore(pDeleteCert);
            }
        }

        PkiFree(pInfo);
    }
    return TRUE;
}

// Includes the title
#define MAX_PROT_ROOT_BOX_ITEMS 10

typedef struct _PROT_ROOT_BOX_ITEM {
    LPWSTR      pwszItem;
    DWORD       cchItem;
} PROT_ROOT_BOX_ITEM;


// Returns count of items added
DWORD
I_FormatRootBoxItems(
    IN PCCERT_CONTEXT pCert,
    IN UINT wActionID,
    IN OUT PROT_ROOT_BOX_ITEM rgItem[MAX_PROT_ROOT_BOX_ITEMS]
    )
{
    DWORD cItem = 0;
    DWORD cchTmp;
    LPWSTR pwszTmp;

    // ACTION: 
    FormatMsgBoxItem(&rgItem[cItem].pwszItem, &rgItem[cItem].cchItem,
        wActionID);
    cItem++;

    // SUBJECT
    cchTmp = CertNameToStrW(
            pCert->dwCertEncodingType,
            &pCert->pCertInfo->Subject,
            CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
            NULL,                   // pwsz
            0);                     // cwsz
    pwszTmp = (LPWSTR) PkiNonzeroAlloc(cchTmp * sizeof(WCHAR));
    if (NULL != pwszTmp)
        CertNameToStrW(
            pCert->dwCertEncodingType,
            &pCert->pCertInfo->Subject,
            CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
            pwszTmp,
            cchTmp);
    FormatMsgBoxItem(&rgItem[cItem].pwszItem, &rgItem[cItem].cchItem,
        IDS_ROOT_MSG_BOX_SUBJECT, NULL != pwszTmp ? pwszTmp : L"");
    cItem++;
    PkiFree(pwszTmp);

    // ISSUER. May be self issued
    if (CertCompareCertificateName(
            pCert->dwCertEncodingType,
            &pCert->pCertInfo->Subject,
            &pCert->pCertInfo->Issuer
            ))
        // Self issued
        FormatMsgBoxItem(&rgItem[cItem].pwszItem, &rgItem[cItem].cchItem,
            IDS_ROOT_MSG_BOX_SELF_ISSUED);
    else {
        // Format certificate's issuer
        cchTmp = CertNameToStrW(
                pCert->dwCertEncodingType,
                &pCert->pCertInfo->Issuer,
                CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
                NULL,                   // pwsz
                0);                     // cwsz
        pwszTmp = (LPWSTR) PkiNonzeroAlloc(cchTmp * sizeof(WCHAR));
        if (NULL != pwszTmp)
            CertNameToStrW(
                pCert->dwCertEncodingType,
                &pCert->pCertInfo->Issuer,
                CERT_SIMPLE_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
                pwszTmp,
                cchTmp);
        FormatMsgBoxItem(&rgItem[cItem].pwszItem, &rgItem[cItem].cchItem,
            IDS_ROOT_MSG_BOX_ISSUER, NULL != pwszTmp ? pwszTmp : L"");

        PkiFree(pwszTmp);
    }
    cItem++;

    // TIME VALIDITY
    {
        FILETIME ftLocal;
        SYSTEMTIME stLocal;
        WCHAR wszNotBefore[128];
        WCHAR wszNotAfter[128];
        wszNotBefore[0] = '\0';
        wszNotAfter[0] = '\0';

        FileTimeToLocalFileTime(&pCert->pCertInfo->NotBefore, &ftLocal);
        FileTimeToSystemTime(&ftLocal, &stLocal);
        GetDateFormatU(LOCALE_USER_DEFAULT, DATE_LONGDATE, &stLocal,
            NULL, wszNotBefore, 128);
        FileTimeToLocalFileTime(&pCert->pCertInfo->NotAfter, &ftLocal);
        FileTimeToSystemTime(&ftLocal, &stLocal);
        GetDateFormatU(LOCALE_USER_DEFAULT, DATE_LONGDATE, &stLocal,
            NULL, wszNotAfter, 128);

        FormatMsgBoxItem(&rgItem[cItem].pwszItem,
            &rgItem[cItem].cchItem, IDS_ROOT_MSG_BOX_TIME_VALIDITY,
            wszNotBefore, wszNotAfter);
        cItem++;
    }

    // SERIAL NUMBER
    if (pCert->pCertInfo->SerialNumber.cbData) {
        DWORD cb = pCert->pCertInfo->SerialNumber.cbData;
        BYTE *pb;
        if (pb = PkiAsn1AllocAndReverseBytes(
                pCert->pCertInfo->SerialNumber.pbData, cb)) {
            LPWSTR pwsz;
            if (pwsz = (LPWSTR) PkiNonzeroAlloc(
                    (cb*2 + cb/4 + 1) * sizeof(WCHAR))) {
                FormatMsgBoxMultiBytes(cb, pb, pwsz);
                FormatMsgBoxItem(&rgItem[cItem].pwszItem,
                    &rgItem[cItem].cchItem, IDS_ROOT_MSG_BOX_SERIAL_NUMBER,
                    pwsz);
                cItem++;
                PkiFree(pwsz);
            }
            PkiAsn1Free(pb);
        }
    }

    // THUMBPRINTS: sha1 and md5
    {
        BYTE    rgbHash[MAX_HASH_LEN];
        DWORD   cbHash = MAX_HASH_LEN;
        WCHAR   wszTmp[MAX_HASH_LEN * 3 + 1];

        // get the sha1 thumbprint
        if (CertGetCertificateContextProperty(
                pCert,
                CERT_SHA1_HASH_PROP_ID,
                rgbHash,
                &cbHash)) {
            FormatMsgBoxMultiBytes(cbHash, rgbHash, wszTmp);
            FormatMsgBoxItem(&rgItem[cItem].pwszItem,
                &rgItem[cItem].cchItem, IDS_ROOT_MSG_BOX_SHA1_THUMBPRINT,
                wszTmp);
            cItem++;
        }

        // get the md5 thumbprint
        if (CertGetCertificateContextProperty(
                pCert,
                CERT_MD5_HASH_PROP_ID,
                rgbHash,
                &cbHash)) {
            FormatMsgBoxMultiBytes(cbHash, rgbHash, wszTmp);
            FormatMsgBoxItem(&rgItem[cItem].pwszItem,
                &rgItem[cItem].cchItem, IDS_ROOT_MSG_BOX_MD5_THUMBPRINT,
                wszTmp);
            cItem++;
        }
    }

    return cItem;
}


// Returns count of items added
DWORD
I_FormatAddRootBoxItems(
    IN PCCERT_CONTEXT pCert,
    IN OUT PROT_ROOT_BOX_ITEM rgItem[MAX_PROT_ROOT_BOX_ITEMS]
    )
{
    WCHAR wszIssuer[100];

    BYTE rgbHash[MAX_HASH_LEN];
    DWORD cbHash = MAX_HASH_LEN;
    WCHAR wszThumbprint[MAX_HASH_LEN * 3 + 1];

    // Issuer Name
    CertGetNameStringW(
        pCert,
        CERT_NAME_SIMPLE_DISPLAY_TYPE,
        0,                              // dwFlags
        NULL,                           // pvTypePara
        wszIssuer,
        sizeof(wszIssuer) / sizeof(wszIssuer[0])
        );

    // sha1 Thumbprint
    if (CertGetCertificateContextProperty(
            pCert,
            CERT_SHA1_HASH_PROP_ID,
            rgbHash,
            &cbHash))
        FormatMsgBoxMultiBytes(cbHash, rgbHash, wszThumbprint);
    else
        wcscpy(wszThumbprint, L"???");

    // Format the intro, body and end lines
    FormatMsgBoxItem(&rgItem[0].pwszItem, &rgItem[0].cchItem,
        IDS_ADD_ROOT_MSG_BOX_INTRO, wszIssuer);
    FormatMsgBoxItem(&rgItem[1].pwszItem, &rgItem[1].cchItem,
        IDS_ADD_ROOT_MSG_BOX_BODY_0, wszIssuer);
    FormatMsgBoxItem(&rgItem[2].pwszItem, &rgItem[2].cchItem,
        IDS_ADD_ROOT_MSG_BOX_BODY_1, wszThumbprint);
    FormatMsgBoxItem(&rgItem[3].pwszItem, &rgItem[3].cchItem,
        IDS_ADD_ROOT_MSG_BOX_END_0);
    FormatMsgBoxItem(&rgItem[4].pwszItem, &rgItem[4].cchItem,
        IDS_ADD_ROOT_MSG_BOX_END_1);

    return 5;
}


//+-------------------------------------------------------------------------
//  The add/delete root message box.
//
//  If protected roots aren't supported, called from the client process.
//  Otherwise, called from the services process.
//--------------------------------------------------------------------------
int
IPR_ProtectedRootMessageBox(
    IN handle_t hRpc,
    IN PCCERT_CONTEXT pCert,
    IN UINT wActionID,
    IN UINT uFlags
    )
{
    int id;

    PROT_ROOT_BOX_ITEM rgItem[MAX_PROT_ROOT_BOX_ITEMS];
    DWORD cItem;
    LPWSTR pwszText = NULL;
    DWORD cchText = 0;
    DWORD ItemIdx;

    if (wActionID == IDS_ROOT_MSG_BOX_ADD_ACTION)
        cItem = I_FormatAddRootBoxItems(
            pCert,
            rgItem
            );
    else
        cItem = I_FormatRootBoxItems(
            pCert,
            wActionID,
            rgItem
            );

    // Concatenate all the items into a single allocated string
    for (ItemIdx = 0; ItemIdx < cItem; ItemIdx++)
        cchText += rgItem[ItemIdx].cchItem;

    if (NULL != (pwszText = (LPWSTR) PkiNonzeroAlloc(
            (cchText + 1) * sizeof(WCHAR)))) {
        LPWSTR pwsz = pwszText;
        RPC_STATUS RpcStatus = 0;

        for (ItemIdx = 0; ItemIdx < cItem; ItemIdx++) {
            DWORD cch = rgItem[ItemIdx].cchItem;
            if (cch) {
                assert(rgItem[ItemIdx].pwszItem);
                memcpy(pwsz, rgItem[ItemIdx].pwszItem, cch * sizeof(WCHAR));
                pwsz += cch;
            }
        }
        assert (pwsz == pwszText + cchText);
        *pwsz = '\0';

        // TITLE
        FormatMsgBoxItem(&rgItem[cItem].pwszItem, &rgItem[cItem].cchItem,
            (IDS_ROOT_MSG_BOX_ADD_ACTION == wActionID) ?
                IDS_ADD_ROOT_MSG_BOX_TITLE : IDS_ROOT_MSG_BOX_TITLE);

        // Do impersonation for TerminalServer clients
        if (hRpc)
            RpcStatus = RpcImpersonateClient(hRpc);
        id = MessageBoxU(
                NULL,       // hwndOwner
                pwszText,
                rgItem[cItem].pwszItem,
                MB_TOPMOST | MB_YESNO | MB_DEFBUTTON2 | MB_ICONWARNING | uFlags
                );
        if (hRpc && ERROR_SUCCESS == RpcStatus)
            RpcRevertToSelf();

        cItem++;
        PkiFree(pwszText);
    } else
        id = IDNO;


    // Free up all the individually allocated items
    while (cItem--) {
        if (rgItem[cItem].pwszItem)
            LocalFree((HLOCAL) rgItem[cItem].pwszItem);
    }

    return id;
}

//+=========================================================================
//  crypt32 Event Logging Functions
//==========================================================================

#define MAX_CRYPT32_EVENT_LOG_STRINGS           5
#define MAX_CRYPT32_EVENT_LOG_COUNT             50

// 1 hour (in units of seconds)
#define CRYPT32_EVENT_LOG_THRESHOLD_PERIOD      (60*60)

// Count of logged events. Gets reset whenever the interval between
// logged events >= CRYPT32_EVENT_LOG_THRESHOLD_PERIOD. If
// MAX_CRYPT32_EVENT_LOG_COUNT is reached, suspend logging for
// CRYPT32_EVENT_LOG_THRESHOLD_PERIOD.
DWORD dwCrypt32EventLogCnt;

// Time of last logged event.
FILETIME ftLastCrypt32EventLog;

// advapi32.dll Event APIs. Not supported on Win9x.

typedef HANDLE (WINAPI *PFN_REGISTER_EVENT_SOURCE_W)(
    IN LPCWSTR lpUNCServerName,
    IN LPCWSTR lpSourceName
    );

typedef BOOL (WINAPI *PFN_DEREGISTER_EVENT_SOURCE)(
    IN OUT HANDLE hEventLog
    );

typedef BOOL (WINAPI *PFN_REPORT_EVENT_W)(
     IN HANDLE     hEventLog,
     IN WORD       wType,
     IN WORD       wCategory,
     IN DWORD      dwEventID,
     IN PSID       lpUserSid,
     IN WORD       wNumStrings,
     IN DWORD      dwDataSize,
     IN LPCWSTR   *lpStrings,
     IN LPVOID     lpRawData
    );

//+-------------------------------------------------------------------------
//  Logs crypt32 events. Ensures we don't log more than
//  MAX_CRYPT32_EVENT_LOG_COUNT events in any period of
//  CRYPT32_EVENT_LOG_THRESHOLD_PERIOD seconds.
//
//  Also, dynamically detects if event logging is supported by the version
//  of advapi32.dll on the machine.
//--------------------------------------------------------------------------
STATIC BOOL LogCrypt32Event(
    IN WORD wType,
    IN WORD wCategory,
    IN DWORD dwEventID,
    IN WORD wNumStrings,
    IN DWORD dwDataSize,
    IN LPCWSTR *rgpwszStrings,
    IN BYTE *pbData
    )
{
    BOOL fResult;
    FILETIME ftCurrent;
    FILETIME ftNext;
    LONG lThreshold;
    HMODULE hModule;            // No FreeLibary() for GetModuleHandle
    DWORD dwExceptionCode;
    DWORD dwLastErr = 0;

    PFN_REGISTER_EVENT_SOURCE_W pfnRegisterEventSourceW;
    PFN_REPORT_EVENT_W pfnReportEventW;
    PFN_DEREGISTER_EVENT_SOURCE pfnDeregisterEventSource;

    // Check if we have exceeded the crypt32 event log threshold for
    // this time period
    //
    // lThreshold:
    //  -1  - haven't reached it,
    //   0  - reached it this time
    //  +1  - previously reached, won't log this event

    lThreshold = -1;
    EnterCriticalSection(&Crypt32EventLogCriticalSection);

    I_CryptIncrementFileTimeBySeconds(&ftLastCrypt32EventLog,
        CRYPT32_EVENT_LOG_THRESHOLD_PERIOD, &ftNext);
    GetSystemTimeAsFileTime(&ftCurrent);

    if (0 <= CompareFileTime(&ftCurrent, &ftNext))
        dwCrypt32EventLogCnt = 0;
    else if (MAX_CRYPT32_EVENT_LOG_COUNT <= dwCrypt32EventLogCnt)
        lThreshold = 1;

    if (0 >= lThreshold) {
        ftLastCrypt32EventLog = ftCurrent;
        dwCrypt32EventLogCnt++;
        if (MAX_CRYPT32_EVENT_LOG_COUNT <= dwCrypt32EventLogCnt)
            lThreshold = 0;
    }

    LeaveCriticalSection(&Crypt32EventLogCriticalSection);

    if (0 < lThreshold)
        goto ExceededCrypt32EventLogThreshold;

    // Only supported on systems where the event APIs are exported from
    // advapi32.dll. Note, crypt32.dll has a static link dependency on
    // advapi32.dll.
    if (NULL == (hModule = GetModuleHandleA("advapi32.dll")))
        goto GetAdvapi32ModuleError;

    pfnRegisterEventSourceW = (PFN_REGISTER_EVENT_SOURCE_W)
        GetProcAddress(hModule, "RegisterEventSourceW");
    pfnReportEventW = (PFN_REPORT_EVENT_W)
        GetProcAddress(hModule, "ReportEventW");
    pfnDeregisterEventSource = (PFN_DEREGISTER_EVENT_SOURCE)
        GetProcAddress(hModule, "DeregisterEventSource");

    if (NULL == pfnRegisterEventSourceW ||
            NULL == pfnReportEventW ||
            NULL == pfnDeregisterEventSource)
        goto Advapi32EventAPINotSupported;

    fResult = TRUE;
    __try {
        HANDLE hEventLog;

        hEventLog = pfnRegisterEventSourceW(
            NULL,               // lpUNCServerName
            L"crypt32"
            );

        if (hEventLog) {
            if (!pfnReportEventW(
                    hEventLog,
                    wType,
                    wCategory,
                    dwEventID,
                    NULL,       // lpUserSid
                    wNumStrings,
                    dwDataSize,
                    rgpwszStrings,
                    pbData
                    )) {
                fResult = FALSE;
                dwLastErr = GetLastError();
            }

            I_DBLogCrypt32Event(
                wType,
                dwEventID,
                wNumStrings,
                rgpwszStrings
                );

            if (0 == lThreshold) {
                WCHAR wszCnt[34];
                WCHAR wszPeriod[34];
                LPCWSTR rgpwszThresholdStrings[2] = {wszCnt, wszPeriod};

                _ltow(MAX_CRYPT32_EVENT_LOG_COUNT, wszCnt, 10);
                _ltow(CRYPT32_EVENT_LOG_THRESHOLD_PERIOD / 60, wszPeriod, 10);

                if (!pfnReportEventW(
                        hEventLog,
                        EVENTLOG_WARNING_TYPE,
                        0,          // wCategory
                        MSG_CRYPT32_EVENT_LOG_THRESHOLD_WARNING,
                        NULL,       // lpUserSid
                        2,          // wNumStrings
                        0,          // dwDataSize
                        rgpwszThresholdStrings,
                        NULL        // pbData
                        )) {
                    fResult = FALSE;
                    dwLastErr = GetLastError();
                }

                I_DBLogCrypt32Event(
                    EVENTLOG_WARNING_TYPE,
                    MSG_CRYPT32_EVENT_LOG_THRESHOLD_WARNING,
                    2,          // wNumStrings
                    rgpwszThresholdStrings
                    );
            }

            pfnDeregisterEventSource(hEventLog);
        } else {
            fResult = FALSE;
            dwLastErr = GetLastError();
        }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto ExceptionError;
    }


    if (!fResult)
        goto ReportEventError;

CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(ExceededCrypt32EventLogThreshold, ERROR_CAN_NOT_COMPLETE)
TRACE_ERROR(GetAdvapi32ModuleError)
SET_ERROR(Advapi32EventAPINotSupported, ERROR_PROC_NOT_FOUND)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
SET_ERROR_VAR(ReportEventError, dwLastErr)
}

//+-------------------------------------------------------------------------
//  Unmarshals the event logging parameter block passed to the service
//  and call's the crypt32 event logging function with the unmarshalled
//  parameters.
//
//  __try/__except around memory access to pbIn.
//--------------------------------------------------------------------------
STATIC BOOL SrvLogCrypt32Event(
    IN BYTE *pbIn,
    IN DWORD cbIn
    )
{
    BOOL fResult;
    PCERT_PROT_EVENT_LOG_PARA pPara = NULL;
    BYTE *pbExtra;
    DWORD cbExtra;
    LPCWSTR rgpwszStrings[MAX_CRYPT32_EVENT_LOG_STRINGS];
    LPCWSTR pwszStrings;
    DWORD cchStrings;
    WORD i;
    BYTE *pbData;
    DWORD dwExceptionCode;


    if (sizeof(CERT_PROT_EVENT_LOG_PARA) > cbIn)
        goto InvalidArg;

    // Ensure the PARA is aligned.
    pPara = (PCERT_PROT_EVENT_LOG_PARA) PkiNonzeroAlloc(cbIn);
    if (NULL == pPara)
        goto OutOfMemory;

    __try {
        memcpy(pPara, pbIn, cbIn);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto ExceptionError;
    }

    pbExtra = (BYTE *) &pPara[1];
    cbExtra = cbIn - sizeof(CERT_PROT_EVENT_LOG_PARA);

    // If present, create an array of pointers to the NULL terminated
    // UNICODE strings that immediately follow the PARA structure.
    if (MAX_CRYPT32_EVENT_LOG_STRINGS < pPara->wNumStrings)
        goto InvalidArg;

    cchStrings = cbExtra / sizeof(WCHAR);   // Maximum #, will be less if we
                                            // also have binary data
    pwszStrings = (LPCWSTR) pbExtra;

    for (i = 0; i < pPara->wNumStrings; i++) {
        rgpwszStrings[i] = pwszStrings;

        for ( ; cchStrings > 0; cchStrings--, pwszStrings++) {
            if (L'\0' == *pwszStrings)
                // Have NULL terminated string
                break;
        }

        if (0 == cchStrings)
            // Reached end without a  NULL terminator
            goto InvalidData;

        // Advance past NULL terminator
        cchStrings--;
        pwszStrings++;
    }

    // The optional data immediately follows the above sequence of 
    // NULL terminated strings
    pbData = (BYTE *) pwszStrings;
    assert(cbExtra >= (DWORD) (pbData - pbExtra));
    if ((cbExtra - (pbData - pbExtra)) != pPara->dwDataSize)
        goto InvalidData;

    fResult = LogCrypt32Event(
        pPara->wType,
        pPara->wCategory,
        pPara->dwEventID,
        pPara->wNumStrings,
        pPara->dwDataSize,
        0 == pPara->wNumStrings ? NULL : rgpwszStrings,
        0 == pPara->dwDataSize  ? NULL : pbData
        );

CommonReturn:
    PkiFree(pPara);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidData, ERROR_INVALID_DATA)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
SET_ERROR(InvalidArg, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Marshals the event logging parameters and does an LRPC to the
//  crypt32 service to do the event logging.
//
//  Should only be called in the client.
//--------------------------------------------------------------------------
void
IPR_LogCrypt32Event(
    IN WORD wType,
    IN DWORD dwEventID,
    IN WORD wNumStrings,
    IN LPCWSTR *rgpwszStrings
    )
{
    DWORD rgcchStrings[MAX_CRYPT32_EVENT_LOG_STRINGS];
    LPWSTR pwszStrings;
    DWORD cchStrings;
    WORD i;

    PCERT_PROT_EVENT_LOG_PARA pPara = NULL;
    DWORD cbPara;

    // Get Strings character count
    if (MAX_CRYPT32_EVENT_LOG_STRINGS < wNumStrings)
        goto InvalidArg;

    cchStrings = 0;
    for (i = 0; i < wNumStrings; i++) {
        rgcchStrings[i] = wcslen(rgpwszStrings[i]) + 1;
        cchStrings += rgcchStrings[i];
    }

    // Create one serialized blob to be passed to the service. This will
    // consist of the event log para struct followed immediately by the
    // NULL terminated UNICODE strings

    cbPara = sizeof(CERT_PROT_EVENT_LOG_PARA) + cchStrings * sizeof(WCHAR);

    if (NULL == (pPara = (PCERT_PROT_EVENT_LOG_PARA) PkiZeroAlloc(cbPara)))
        goto OutOfMemory;

    pPara->wType = wType;
    // pPara->wCategory = 0;
    pPara->dwEventID = dwEventID;
    pPara->wNumStrings = wNumStrings;
    // pPara->wPad1 = 0;
    // pPara->dwDataSize = 0;

    pwszStrings = (LPWSTR) &pPara[1];
    for (i = 0; i < wNumStrings; i++) {
        memcpy(pwszStrings, rgpwszStrings[i], rgcchStrings[i] * sizeof(WCHAR));
        pwszStrings += rgcchStrings[i];
    }

    if (!I_CertProtectFunction(
            CERT_PROT_LOG_EVENT_FUNC_ID,
            0,                              // dwFlags
            NULL,                           // pwszIn
            (BYTE *) pPara,
            cbPara,
            NULL,                           // ppbOut
            NULL                            // pcbOut
            ))
        goto ProtFuncError;

CommonReturn:
    PkiFree(pPara);
    return;
ErrorReturn:
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(ProtFuncError)
}

//+-------------------------------------------------------------------------
//  Log a crypt32 error event
//
//  Should only be called in the client.
//--------------------------------------------------------------------------
void
IPR_LogCrypt32Error(
    IN DWORD dwEventID,
    IN LPCWSTR pwszString,      // %1
    IN DWORD dwErr              // %2
    )
{
    WCHAR wszErr[80];
    const DWORD cchErr = sizeof(wszErr) / sizeof(wszErr[0]);
    LPCWSTR rgpwszStrings[2];
    DWORD cchFormatErr;
    LPWSTR pwszFormatErr = NULL;

    cchFormatErr = FormatMessageU (
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        dwErr,
        MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPWSTR) &pwszFormatErr,
        0,
        NULL);

    if (0 == cchFormatErr &&
            INTERNET_ERROR_BASE <= dwErr && INTERNET_ERROR_LAST >= dwErr) {
        HMODULE hWininet;

        hWininet = LoadLibraryEx(
            "wininet.dll",
            NULL,               // reserved, must be NULL
            LOAD_LIBRARY_AS_DATAFILE
            );

        if (hWininet) {
            cchFormatErr = FormatMessageU (
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
                hWininet,
                dwErr,
                MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPWSTR) &pwszFormatErr,
                0,
                NULL);

            FreeLibrary(hWininet);
        }

    }

    if (0 != cchFormatErr)
        rgpwszStrings[1] = pwszFormatErr;
    else {
        int cch = 0;


        if (HTTP_STATUS_FIRST <= dwErr && HTTP_STATUS_LAST >= dwErr) {
            WCHAR wszFormat[64];
            wszFormat[0] = '\0';

            if (0 < LoadStringU(hRegStoreInst, IDS_HTTP_RESPONSE_STATUS,
                    wszFormat, sizeof(wszFormat) / sizeof(wszFormat[0]))) {
                cch = _snwprintf(wszErr, cchErr - 1, L"%d (%s)", dwErr,
                    wszFormat);
            }
        }

        if (0 >= cch)
            cch = _snwprintf(wszErr, cchErr - 1, L"%d (0x%x)", dwErr, dwErr);

        if (0 < cch) {
            wszErr[cchErr - 1] = L'\0';
            rgpwszStrings[1] = wszErr;
        } else
            rgpwszStrings[1] = L"???";
    }

    rgpwszStrings[0] = pwszString;


    IPR_LogCrypt32Event(
        EVENTLOG_ERROR_TYPE,
        dwEventID,
        2,                      // wNumStrings
        rgpwszStrings
        );

    if (pwszFormatErr)
        LocalFree(pwszFormatErr);
}


//+-------------------------------------------------------------------------
//  Formats the cert's subject or issuer name string and SHA1 thumbprint.
//--------------------------------------------------------------------------
STATIC BOOL FormatLogCertInformation(
    IN PCCERT_CONTEXT pCert,
    IN BOOL fFormatIssuerName,
    OUT WCHAR wszSha1Hash[SHA1_HASH_LEN * 2 + 1],
    OUT LPWSTR *ppwszName
    )
{
    BOOL fResult;
    DWORD cchName;
    LPWSTR pwszName = NULL;
    DWORD cbData;
    BYTE rgbSha1Hash[SHA1_HASH_LEN];

    PCERT_NAME_BLOB pNameBlob;

    if (fFormatIssuerName)
        pNameBlob = &pCert->pCertInfo->Issuer;
    else
        pNameBlob = &pCert->pCertInfo->Subject;

    cchName = CertNameToStrW(
        pCert->dwCertEncodingType,
        pNameBlob,
        CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
        NULL,                   // pwsz
        0                       // cwsz
        );

    if (NULL == (pwszName = (LPWSTR) PkiNonzeroAlloc(cchName * sizeof(WCHAR))))
        goto OutOfMemory;

    CertNameToStrW(
        pCert->dwCertEncodingType,
        pNameBlob,
        CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
        pwszName,
        cchName
        );

    cbData = SHA1_HASH_LEN;
    if (CertGetCertificateContextProperty(
              pCert,
              CERT_SHA1_HASH_PROP_ID,
              rgbSha1Hash,
              &cbData
              ) && SHA1_HASH_LEN == cbData)
        ILS_BytesToWStr(SHA1_HASH_LEN, rgbSha1Hash, wszSha1Hash);
    else
        wcscpy(wszSha1Hash, L"???");

    fResult = TRUE;
CommonReturn:
    *ppwszName = pwszName;
    return fResult;
ErrorReturn:
    if (pwszName) {
        PkiFree(pwszName);
        pwszName = NULL;
    }
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Get the cert's subject or issuer name string and SHA1 thumbprint. Logs the
//  specified crypt32 event.
//
//  This function is called from the client.
//--------------------------------------------------------------------------
void
IPR_LogCertInformation(
    IN DWORD dwEventID,
    IN PCCERT_CONTEXT pCert,
    IN BOOL fFormatIssuerName
    )
{
    LPWSTR pwszName = NULL;
    WCHAR wszSha1Hash[SHA1_HASH_LEN * 2 + 1];
    LPCWSTR rgpwszStrings[2];

    if (!FormatLogCertInformation(
            pCert,
            fFormatIssuerName,
            wszSha1Hash,
            &pwszName
            ))
        return;

    rgpwszStrings[0] = pwszName;
    rgpwszStrings[1] = wszSha1Hash;
    
    IPR_LogCrypt32Event(
        EVENTLOG_INFORMATION_TYPE,
        dwEventID,
        2,                          // wNumStrings
        rgpwszStrings
        );

    PkiFree(pwszName);
}

//+-------------------------------------------------------------------------
//  Get the cert's subject name string and SHA1 thumbprint. Log the
//  MSG_ROOT_AUTO_UPDATE_INFORMATIONAL crypt32 event.
//
//  This function is called from the service.
//--------------------------------------------------------------------------
STATIC void LogAddAuthRootEvent(
    IN PCCERT_CONTEXT pCert
    )
{
    LPWSTR pwszName = NULL;
    WCHAR wszSha1Hash[SHA1_HASH_LEN * 2 + 1];
    LPCWSTR rgpwszStrings[2];

    if (!FormatLogCertInformation(
            pCert,
            FALSE,                  // fFormatIssuerName
            wszSha1Hash,
            &pwszName
            ))
        return;


    rgpwszStrings[0] = pwszName;
    rgpwszStrings[1] = wszSha1Hash;
    
    LogCrypt32Event(
        EVENTLOG_INFORMATION_TYPE,
        0,                          // wCategory
        MSG_ROOT_AUTO_UPDATE_INFORMATIONAL,
        2,                          // wNumStrings
        0,                          // dwDataSize
        rgpwszStrings,
        NULL                        // pbData
        );

    PkiFree(pwszName);
}

//+=========================================================================
//  Install Cert into AuthRoot Auto Update CTL Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Function that can be called from either the client or service to
//  add the certificate to the specified store. 
//
//  First validates the CTL. The certificate must
//  have an entry in the CTL before it will be added. The CTL entry's
//  property attributes are set on the certificate context to be added.
//--------------------------------------------------------------------------
STATIC
BOOL
AddCertInCtlToStore(
    IN PCCERT_CONTEXT pCert,
    IN PCCTL_CONTEXT pCtl,
    IN OUT HCERTSTORE hStore
    )
{
    BOOL fResult;
    PCTL_ENTRY pCtlEntry;

    if (!IRL_VerifyAuthRootAutoUpdateCtl(pCtl))
        goto InvalidCtl;

    if (NULL == (pCtlEntry = CertFindSubjectInCTL(
            pCert->dwCertEncodingType,
            CTL_CERT_SUBJECT_TYPE,
            (void *) pCert,
            pCtl,
            0                           // dwFlags
            )))
        goto CertNotInCtl;

    // Check if a remove entry
    if (CertFindAttribute(
            szOID_REMOVE_CERTIFICATE,
            pCtlEntry->cAttribute,
            pCtlEntry->rgAttribute
            ))
        goto RemoveCertEntry;

    // Set Ctl Entry Attribute properties
    if (!CertSetCertificateContextPropertiesFromCTLEntry(
            pCert,
            pCtlEntry,
            CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG
            ))
        goto AddCtlEntryAttibutePropertiesError;

     if (!CertAddCertificateContextToStore(
            hStore,
            pCert,
            CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES,
            NULL                // ppStoreContext
            ))
        goto AddCertToStoreError;

    LogAddAuthRootEvent(pCert);

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(InvalidCtl)
SET_ERROR(CertNotInCtl, CRYPT_E_NOT_FOUND)
SET_ERROR(RemoveCertEntry, CRYPT_E_NOT_FOUND)
TRACE_ERROR(AddCtlEntryAttibutePropertiesError)
TRACE_ERROR(AddCertToStoreError)
}

//+-------------------------------------------------------------------------
//  Unmarshals the ASN.1 encoded X.509 certificate immediately followed by the
//  ASN.1 encoded CTL.
//
//  If the certificate has an entry in a valid CTL, its added to the
//  HKLM "AuthRoot" store.

//  __try/__except around memory access to pbIn.
//--------------------------------------------------------------------------
STATIC
BOOL
SrvAddCertInCtl(
    IN BYTE *pbIn,
    IN DWORD cbIn
    )
{
    BOOL fResult;
    DWORD cbCert;
    PCCERT_CONTEXT pCert = NULL;
    PCCTL_CONTEXT pCtl = NULL;
    HCERTSTORE hAuthRootStore = NULL;
    DWORD dwExceptionCode;

    if (IPR_IsAuthRootAutoUpdateDisabled())
        goto AuthRootAutoUpdateDisabledError;

    __try {
        // The input consists of the encoded certificate immediately followed
        // by the encoded CTL. Extract and create both components.

        cbCert = Asn1UtilAdjustEncodedLength(pbIn, cbIn);

        assert(cbCert <= cbIn);

        if (NULL == (pCert = CertCreateCertificateContext(
                X509_ASN_ENCODING,
                pbIn,
                cbCert
                )))
            goto CreateCertificateContextError;

        if (NULL == (pCtl = CertCreateCTLContext(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                pbIn + cbCert,
                cbIn - cbCert
                )))
            goto CreateCtlContextError;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto ExceptionError;
    }

    if (NULL == (hAuthRootStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_REGISTRY_W,
            0,                                  // dwEncodingType
            NULL,                               // hCryptProv
            CERT_SYSTEM_STORE_LOCAL_MACHINE,
            (const void *) L"AuthRoot"
            )))
        goto OpenAuthRootStoreError;

    fResult = AddCertInCtlToStore(
        pCert,
        pCtl,
        hAuthRootStore
        );

CommonReturn:
    if (pCert)
        CertFreeCertificateContext(pCert);
    if (pCtl)
        CertFreeCTLContext(pCtl);
    if (hAuthRootStore)
        CertCloseStore(hAuthRootStore, 0);

    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(AuthRootAutoUpdateDisabledError, E_INVALIDARG)
TRACE_ERROR(CreateCertificateContextError)
TRACE_ERROR(CreateCtlContextError)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
TRACE_ERROR(OpenAuthRootStoreError)
}


    
//+-------------------------------------------------------------------------
//  For Pre W2K OS's that don't have a crypt32 service, do the add in
//  client process.
//--------------------------------------------------------------------------
STATIC
BOOL
PreW2KAddCertInCtl(
    IN PCCERT_CONTEXT pCert,
    IN PCCTL_CONTEXT pCtl
    )
{
    BOOL fResult;
    HCERTSTORE hRootStore = NULL;

    // Try opening the HKLM AuthRoot store. If that fails, fall back to
    // adding to the HKCU Root (Unprotected) store
    if (NULL == (hRootStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_REGISTRY_W,
            0,                                  // dwEncodingType
            NULL,                               // hCryptProv
            CERT_SYSTEM_STORE_LOCAL_MACHINE,
            (const void *) L"AuthRoot"
            ))) {
        if (NULL == (hRootStore = CertOpenStore(
                CERT_STORE_PROV_SYSTEM_REGISTRY_W,
                0,                                  // dwEncodingType
                NULL,                               // hCryptProv
                CERT_SYSTEM_STORE_CURRENT_USER |
                    CERT_SYSTEM_STORE_UNPROTECTED_FLAG,
                (const void *) L"Root"
                )))
            goto OpenRootStoreError;
    }

    fResult = AddCertInCtlToStore(
        pCert,
        pCtl,
        hRootStore
        );

CommonReturn:
    if (hRootStore)
        CertCloseStore(hRootStore, 0);

    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenRootStoreError)
}


//+-------------------------------------------------------------------------
//  If the certificate has an entry in a valid CTL, its added to the
//  HKLM "AuthRoot" store.
//--------------------------------------------------------------------------
BOOL
IPR_AddCertInAuthRootAutoUpdateCtl(
    IN PCCERT_CONTEXT pCert,
    IN PCCTL_CONTEXT pCtl
    )
{
    BOOL fResult;
    DWORD cbIn;
    BYTE *pbIn = NULL;

    // Create one serialized blob to be passed to the service. This will
    // consist of the encoded certificate followed immediately by the
    // encoded CTL.

    cbIn = pCert->cbCertEncoded + pCtl->cbCtlEncoded;

    if (NULL == (pbIn = (BYTE *) PkiNonzeroAlloc(cbIn)))
        goto OutOfMemory;

    memcpy(pbIn, pCert->pbCertEncoded, pCert->cbCertEncoded);
    memcpy(pbIn + pCert->cbCertEncoded, pCtl->pbCtlEncoded,
        pCtl->cbCtlEncoded);

    if (!I_CertProtectFunction(
            CERT_PROT_ADD_ROOT_IN_CTL_FUNC_ID,
            0,                              // dwFlags
            NULL,                           // pwszIn
            pbIn,
            cbIn,
            NULL,                           // ppbOut
            NULL                            // pcbOut
            )) {
        DWORD dwErr = GetLastError();
        if (ERROR_CALL_NOT_IMPLEMENTED == dwErr || RPC_S_UNKNOWN_IF == dwErr) {
            if (!PreW2KAddCertInCtl(
                    pCert,
                    pCtl
                    ))
                goto PreW2KAddCertInCtlError;
        } else
            goto ProtFuncError;
    }

    fResult = TRUE;
CommonReturn:
    PkiFree(pbIn);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(PreW2KAddCertInCtlError)
TRACE_ERROR(ProtFuncError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\protroot.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       protroot.h
//
//  Contents:   Public functions in protroot.cpp
//
//  History:    15-Sep-00   philh   created
//--------------------------------------------------------------------------

#ifndef __PROTROOT_H__
#define __PROTROOT_H__

BOOL
IPR_EnableSecurityPrivilege(
    LPCSTR pszPrivilege
    );

BOOL
IPR_IsCurrentUserRootsAllowed();

BOOL
IPR_IsAuthRootsAllowed();

BOOL
IPR_IsNTAuthRequiredDisabled();

BOOL
IPR_IsNotDefinedNameConstraintDisabled();

BOOL
IPR_IsAuthRootAutoUpdateDisabled();

void
IPR_InitProtectedRootInfo();

BOOL
IPR_DeleteUnprotectedRootsFromStore(
    IN HCERTSTORE hStore,
    OUT BOOL *pfProtected
    );

int
IPR_ProtectedRootMessageBox(
    IN handle_t hRpc,
    IN PCCERT_CONTEXT pCert,
    IN UINT wActionID,
    IN UINT uFlags
    );

//+=========================================================================
//  crypt32 Event Logging Functions
//==========================================================================
void
IPR_LogCrypt32Event(
    IN WORD wType,
    IN DWORD dwEventID,
    IN WORD wNumStrings,
    IN LPCWSTR *rgpwszStrings
    );

void
IPR_LogCrypt32Error(
    IN DWORD dwEventID,
    IN LPCWSTR pwszString,      // %1
    IN DWORD dwErr              // %2
    );

void
IPR_LogCertInformation(
    IN DWORD dwEventID,
    IN PCCERT_CONTEXT pCert,
    IN BOOL fFormatIssuerName
    );

BOOL
IPR_AddCertInAuthRootAutoUpdateCtl(
    IN PCCERT_CONTEXT pCert,
    IN PCCTL_CONTEXT pCtl
    );
#endif  // __PROTROOT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\queryobj.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:	queryobj.cpp
//
//  Contents:   OID format functions
//
//  Functions:
//              CryptQueryObject
//
//  History:    15-05-97    xiaohs   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include "frmtfunc.h"
#include "align.h"

#define ASN_ASCII_HEX_PREFIX        "{ASN}"
#define ASN_ASCII_HEX_PREFIX_LEN    ((DWORD) strlen(ASN_ASCII_HEX_PREFIX))

#define NOTEPAD_UNICODE_SPECIAL_WCHAR   L'\xfeff'

//**************************************************************************
//
//     The following section is for CryptQueryObject
//**************************************************************************

//+-------------------------------------------------------------------------
//  CryptStringToBinaryA: Decode the BLOB
//
//--------------------------------------------------------------------------
BOOL    DecodeBlobA(CHAR    *pbByte,
                    DWORD   cbByte,
                    BYTE    **ppbData,
                    DWORD   *pcbData)
{
    DWORD   err=0;
    BOOL    fResult=FALSE;
    DWORD   dwFlag=0;

    *ppbData=NULL;
    *pcbData=0;

    __try {
    if(!CryptStringToBinaryA(pbByte,
                      cbByte,
                      CRYPT_STRING_BASE64_ANY,
                      NULL,
                      pcbData,
                      NULL,
                      &dwFlag))
    {
        err = GetLastError();
        goto DecodeErr;
    }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        err = GetExceptionCode();
        goto DecodeErr;
    }

    *ppbData=(BYTE *)malloc(*pcbData);

    if(NULL==*ppbData)
        goto OutOfMemoryErr;

    __try {
    if(!CryptStringToBinaryA(pbByte,
                      cbByte,
                      dwFlag,
                      *ppbData,
                      pcbData,
                      NULL,
                      NULL))
    {
        err = GetLastError();
        goto DecodeErr;
    }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        err = GetExceptionCode();
        goto DecodeErr;
    }

    fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

    if(*ppbData)
    {
        free(*ppbData);
        *ppbData=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR_VAR(DecodeErr, err);
SET_ERROR(OutOfMemoryErr, E_OUTOFMEMORY);

}

//+-------------------------------------------------------------------------
//  CryptStringToBinaryW: Decode the BLOB
//
//--------------------------------------------------------------------------
BOOL    DecodeBlobW(WCHAR    *pbByte,
                    DWORD   cbByte,
                    BYTE    **ppbData,
                    DWORD   *pcbData)
{
    DWORD   err=0;
    BOOL    fResult=FALSE;
    DWORD   dwFlag=0;

    *ppbData=NULL;
    *pcbData=0;

    __try {
    if(!CryptStringToBinaryW(pbByte,
                      cbByte,
                      CRYPT_STRING_BASE64_ANY,
                      NULL,
                      pcbData,
                      NULL,
                      &dwFlag))
    {
        err = GetLastError();
        goto DecodeErr;
    }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        err = GetExceptionCode();
        goto DecodeErr;
    }

    *ppbData=(BYTE *)malloc(*pcbData);

    if(NULL==*ppbData)
        goto OutOfMemoryErr;

    __try {
    if(!CryptStringToBinaryW(pbByte,
                      cbByte,
                      dwFlag,
                      *ppbData,
                      pcbData,
                      NULL,
                      NULL))
    {
        err = GetLastError();
        goto DecodeErr;
    }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        err = GetExceptionCode();
        goto DecodeErr;
    }


    fResult=TRUE;

CommonReturn:

	return fResult;

ErrorReturn:

    if(*ppbData)
    {
        free(*ppbData);
        *ppbData=NULL;
    }

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR_VAR(DecodeErr, err);
SET_ERROR(OutOfMemoryErr, E_OUTOFMEMORY);

}

//+-------------------------------------------------------------------------
//  Decode the BLOB encoded as ASCII HEX.
//
//  Note, pbByte has already been advanced past any leading prefix such as,
//  "{ASN}"
//--------------------------------------------------------------------------
BOOL
DecodeAsciiHex(
    const char  *pch,
    DWORD       cch,
    BYTE        **ppbData,
    DWORD       *pcbData
    )
{
    DWORD   err;
    BOOL    fResult;
    DWORD   cbData;
    BYTE    *pbData = NULL;

    pbData = (BYTE *) malloc(cch/2 + 1);
    if (NULL == pbData)
        goto OutOfMemory;

    __try {
        BYTE    bData;
        BYTE    *pb;
        BOOL    fUpperNibble;

        fUpperNibble = TRUE;
        for (pb = pbData; 0 < cch; cch--, pch++) {
            BYTE b;
            char ch;

            // Convert ascii hex characters 0..9, a..f, A..F
            // silently ignore all others
            ch = *pch;
            if (ch >= '0' && ch <= '9')
                b = (BYTE)( ch - '0' );
            else if (ch >= 'a' && ch <= 'f')
                b = (BYTE)( 10 + ch - 'a' );
            else if (ch >= 'A' && ch <= 'F')
                b = (BYTE)( 10 + ch - 'A' );
            else
                goto InvalidData;

            if (fUpperNibble) {
                bData = (BYTE)( b << 4 );
                fUpperNibble = FALSE;
            } else {
                bData = (BYTE)( bData | b );
                *pb++ = bData;
                fUpperNibble = TRUE;
            }
        }

        cbData = (DWORD) (pb - pbData);
        if (0 == cbData || !fUpperNibble)
            goto InvalidData;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        err = GetExceptionCode();
        goto ExceptionErr;
    }

    fResult = TRUE;

CommonReturn:
    *ppbData = pbData;
    *pcbData = cbData;
	return fResult;

ErrorReturn:
    if (pbData) {
        free(pbData);
        pbData = NULL;
    }
    cbData = 0;
	fResult = FALSE;
	goto CommonReturn;

SET_ERROR_VAR(ExceptionErr, err);
SET_ERROR(OutOfMemory, E_OUTOFMEMORY);
SET_ERROR(InvalidData, ERROR_INVALID_DATA);

}


//+-------------------------------------------------------------------------
//  Skip over the identifier and length octets in an ASN encoded blob.
//  Returns the number of bytes skipped.
//
//  For an invalid identifier or length octet returns 0.
//--------------------------------------------------------------------------
 DWORD SkipOverIdentifierAndLengthOctets(
    IN const BYTE *pbDER,
    IN DWORD cbDER
    )
{
#define TAG_MASK 0x1f
    DWORD   cb;
    DWORD   cbLength;
    const BYTE   *pb = pbDER;

    // Need minimum of 2 bytes
    if (cbDER < 2)
        return 0;

    // Skip over the identifier octet(s)
    if (TAG_MASK == (*pb++ & TAG_MASK)) {
        // high-tag-number form
        for (cb=2; *pb++ & 0x80; cb++) {
            if (cb >= cbDER)
                return 0;
        }
    } else
        // low-tag-number form
        cb = 1;

    // need at least one more byte for length
    if (cb >= cbDER)
        return 0;

    if (0x80 == *pb)
        // Indefinite
        cb++;
    else if ((cbLength = *pb) & 0x80) {
        cbLength &= ~0x80;         // low 7 bits have number of bytes
        cb += cbLength + 1;
        if (cb > cbDER)
            return 0;
    } else
        cb++;

    return cb;
}

//--------------------------------------------------------------------------
//
//	Skip over the tag and length
//----------------------------------------------------------------------------
BOOL SignNoContentWrap(IN const BYTE *pbDER, IN DWORD cbDER)
{
    DWORD cb;

    __try {
    cb = SkipOverIdentifierAndLengthOctets(pbDER, cbDER);
    if (cb > 0 && cb < cbDER && pbDER[cb] == 0x02)
        return TRUE;
    else
        return FALSE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(GetExceptionCode());
    }

    return FALSE;
}


//--------------------------------------------------------------------------------
//
//get the bytes from the file name
//
//---------------------------------------------------------------------------------
HRESULT RetrieveBLOBFromFile(LPWSTR	pwszFileName,DWORD *pcb,BYTE **ppb)
{


	HRESULT	hr=E_FAIL;
	HANDLE	hFile=NULL;
    HANDLE  hFileMapping=NULL;

    DWORD   cbData=0;
    BYTE    *pbData=0;

    WIN32_FILE_ATTRIBUTE_DATA FileAttr;

	if(!pcb || !ppb || !pwszFileName)
		return E_INVALIDARG;

	*ppb=NULL;
	*pcb=0;

    if (!GetFileAttributesExW(
            pwszFileName,
            GetFileExInfoStandard,
            &FileAttr
            ))
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

    cbData = FileAttr.nFileSizeLow;

    if ((FileAttr.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
            (0 != FileAttr.nFileSizeHigh) ||
            (0 == cbData))
    {
			hr=E_FAIL;
			goto CLEANUP;
    }

    if ((hFile = CreateFileU(pwszFileName,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,                   // lpsa
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL)) == INVALID_HANDLE_VALUE)
    {
            hFile = NULL;
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

    //create a file mapping object
    if(NULL == (hFileMapping=CreateFileMapping(
                hFile,
                NULL,
                PAGE_READONLY,
                0,
                0,
                NULL)))
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

    //create a view of the file
	if(NULL == (pbData=(BYTE *)MapViewOfFile(
		hFileMapping,
		FILE_MAP_READ,
		0,
		0,
		cbData)))
    {
            hr=HRESULT_FROM_WIN32(GetLastError());
            goto CLEANUP;
    }

	hr=S_OK;

	*pcb=cbData;
	*ppb=pbData;

CLEANUP:

	if(hFile)
		CloseHandle(hFile);

	if(hFileMapping)
		CloseHandle(hFileMapping);

	return hr;

}

//-------------------------------------------------------------------------
//
//   Check to see if the BLOB has an embeded PKCS7 using SIP functions
//
//-------------------------------------------------------------------------
BOOL    GetEmbeddedPKCS7(CERT_BLOB  *pCertBlob,
                         LPWSTR     pwszFileName,
                         BYTE       **ppbData,
                         DWORD      *pcbData,
                         DWORD      *pdwEncodingType)
{
    BOOL                fResult=FALSE;
    CHAR                szTempPath[MAX_PATH];
    CHAR                szTempFileName[MAX_PATH];
    LPSTR               szPreFix="Tmp";     //we should not localize this string
                                            //since it has to be in ANSCII characeter set
    DWORD               dwBytesWritten=0;
    GUID				gSubject;
    SIP_DISPATCH_INFO	SipDispatch;
    SIP_SUBJECTINFO		SubjectInfo;


    HANDLE              hFile=NULL;
    LPWSTR              pwszFileToUse=NULL;

    //init the output
    *ppbData=NULL;
    *pcbData=0;
    *pdwEncodingType=0;

    //create a temporary file since SIP functions only takes a file name
    if(NULL==pwszFileName)
    {
        if(0==GetTempPath(sizeof(szTempPath), szTempPath))
            goto GetTempPathErr;

        if(0==GetTempFileName(szTempPath, szPreFix, 0, szTempFileName))
            goto GetTempFileNameErr;

        if(INVALID_HANDLE_VALUE==(hFile=CreateFile(szTempFileName,
                        GENERIC_WRITE |GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        CREATE_NEW,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL)))
            goto CreateFileErr;

        //write the BLOB to the file
        if(!WriteFile(hFile,
                            pCertBlob->pbData,
                            pCertBlob->cbData,
                            &dwBytesWritten,
                            NULL))
            goto WriteFileErr;

        if(dwBytesWritten != pCertBlob->cbData)
            goto WriteBytesErr;

        //close the file handle
        if(!CloseHandle(hFile))
        {
            hFile=NULL;
            goto CloseHandleErr;
        }

        hFile=NULL;

        //get the unicode version of the file name
        pwszFileToUse=MkWStr(szTempFileName);

        if(NULL==pwszFileToUse)
           goto MkWStrErr;

    }
    else
        pwszFileToUse=pwszFileName;

    //call the sip functions
    //get the GUID
    if (!CryptSIPRetrieveSubjectGuid(
            pwszFileToUse,
            NULL,
            &gSubject))
        goto CryptNoMatchErr;

    //load the dispatch
    memset(&SipDispatch, 0, sizeof(SipDispatch));
    SipDispatch.cbSize = sizeof(SipDispatch);

    if (!CryptSIPLoad(
            &gSubject,
            0,
            &SipDispatch))
        goto CryptNoMatchErr;

    //fill out the subjectInfo
    memset(&SubjectInfo, 0, sizeof(SubjectInfo));
    SubjectInfo.cbSize = sizeof(SubjectInfo);
    SubjectInfo.pgSubjectType = (GUID*) &gSubject;
    SubjectInfo.hFile = INVALID_HANDLE_VALUE;
    SubjectInfo.pwsFileName = pwszFileToUse;
    SubjectInfo.dwEncodingType = *pdwEncodingType;

    //get the embedded PKCS7
    SipDispatch.pfGet(
            &SubjectInfo,
            pdwEncodingType,
            0,                          // dwIndex
            pcbData,
            NULL                        // pbSignedData
            );
    if (0 == (*pcbData))
        goto CryptNoMatchErr;

    if (NULL == (*ppbData=(BYTE *)malloc(*pcbData)))
        goto OutOfMemoryErr;

    if (!SipDispatch.pfGet(
            &SubjectInfo,
            pdwEncodingType,
            0,                          // dwIndex
            pcbData,
            *ppbData
            ))
        goto CryptNoMatchErr;


    fResult=TRUE;


CommonReturn:

    //close the file handle
    if(INVALID_HANDLE_VALUE!=hFile && NULL !=hFile)
        CloseHandle(hFile);

    //delete the file if it was created
    if(NULL==pwszFileName)
    {
        DeleteFileU(pwszFileToUse);

        FreeWStr(pwszFileToUse);
    }

	return fResult;

ErrorReturn:

	fResult=FALSE;

    if(*ppbData)
    {
        free(*ppbData);
        *ppbData=NULL;
    }

	goto CommonReturn;

TRACE_ERROR(GetTempPathErr);
TRACE_ERROR(GetTempFileNameErr);
TRACE_ERROR(CreateFileErr);
TRACE_ERROR(WriteFileErr);
SET_ERROR(WriteBytesErr, E_FAIL);
TRACE_ERROR(CloseHandleErr);
TRACE_ERROR(MkWStrErr);
SET_ERROR(CryptNoMatchErr, CRYPT_E_NO_MATCH);
SET_ERROR(OutOfMemoryErr, E_OUTOFMEMORY);
}

BOOL
AddCertPairToStore(
    IN HCERTSTORE hCertStore,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    BOOL fResult;
    PCERT_PAIR pInfo = NULL;
    DWORD cbInfo;
    PCCERT_CONTEXT pCertForward = NULL;

    // CryptDecodeObjectEX should be usable here, but since this object
    // is included with XEnroll and XEnroll must run with Auth2UPD Crypt32
    // we must stick with the old CryptDecodeObject 2 pass calls.
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_CERT_PAIR,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            NULL,                       // pInfo
            &cbInfo
            ))
        goto DecodeError;
    if (NULL == (pInfo = (PCERT_PAIR) malloc(cbInfo)))
        goto OutOfMemory;
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_CERT_PAIR,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            pInfo,
            &cbInfo
            ))
        goto DecodeError;

    if (pInfo->Forward.cbData) {
        if (!CertAddEncodedCertificateToStore(
                hCertStore,
                X509_ASN_ENCODING,
                pInfo->Forward.pbData,
                pInfo->Forward.cbData,
                CERT_STORE_ADD_ALWAYS,
                &pCertForward
                ))
            goto AddCertError;
    }

    if (pInfo->Reverse.cbData) {
        if (!CertAddEncodedCertificateToStore(
                hCertStore,
                X509_ASN_ENCODING,
                pInfo->Reverse.pbData,
                pInfo->Reverse.cbData,
                CERT_STORE_ADD_ALWAYS,
                NULL                            // ppCertContext
                ))
            goto AddCertError;
    }

    if (pCertForward)
        CertFreeCertificateContext(pCertForward);

    fResult = TRUE;

CommonReturn:
    if (pInfo)
        free(pInfo);
    return fResult;

DecodeError:
ErrorReturn:
    fResult = FALSE;
    if (pCertForward)
        CertDeleteCertificateFromStore(pCertForward);
    goto CommonReturn;

SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
TRACE_ERROR(AddCertError)
}


//-------------------------------------------------------------------------
//
//   The real implementation of CryptQueryObject
//
//-------------------------------------------------------------------------
BOOL   I_CryptQueryObject(CERT_BLOB      *pCertBlob,
                       LPWSTR           pwszFileName,
                       DWORD            dwContentTypeFlag,
                       DWORD            dwFormatTypeFlag,
                       DWORD            dwFlag,
                       DWORD            *pdwMsgAndCertEncodingType,
                       DWORD            *pdwContentType,
                       DWORD            *pdwFormatType,
                       HCERTSTORE       *phCertStore,
                       HCRYPTMSG        *phMsg,
                       const void       **ppvContext)
{
    BOOL                fResult=FALSE;
    DWORD               dwMsgEncodingType=PKCS_7_ASN_ENCODING;
    DWORD               dwEncodingType=X509_ASN_ENCODING;
    DWORD               dwPKCS7EncodingType=X509_ASN_ENCODING|PKCS_7_ASN_ENCODING;
    DWORD               dwContentType=0;
    DWORD               dwMsgType=0;
    DWORD               cbData=0;
    BOOL                fEmbedded=FALSE;
    CERT_BLOB           PKCS7Blob;

    BYTE                *pbPKCS7=NULL;
    DWORD               cbPKCS7=0;
    HCERTSTORE          hCertStore=NULL;
    HCRYPTMSG           hMsg=NULL;
    PCCERT_CONTEXT      pCertContext=NULL;
    PCCRL_CONTEXT       pCRLContext=NULL;
    PCCTL_CONTEXT       pCTLContext=NULL;
    PCERT_REQUEST_INFO  pReqInfo=NULL;

    //NULL the output
    if(pdwMsgAndCertEncodingType)
        *pdwMsgAndCertEncodingType=0;

    if(pdwContentType)
        *pdwContentType=0;

    if(pdwFormatType)
        *pdwFormatType=0;

    if(phCertStore)
        *phCertStore=NULL;

    if(phMsg)
        *phMsg=NULL;

    if(ppvContext)
        *ppvContext=NULL;

    //open a generic memory store
    hCertStore=CertOpenStore(CERT_STORE_PROV_MEMORY,
						 0,
						 NULL,
						 0,
						 NULL);

    if(NULL == hCertStore)
        goto CertOpenStoreErr;


    //single encoded cert
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_CERT)
    {
        if(CertAddEncodedCertificateToStore(hCertStore,
								dwEncodingType,
								pCertBlob->pbData,
								pCertBlob->cbData,
								CERT_STORE_ADD_ALWAYS,
								&pCertContext))
        {
            dwContentType=CERT_QUERY_CONTENT_CERT;
            goto Found;
        }
    }

    //an encoded CertificatePair (contains forward and/or reverse cross certs)
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_CERT_PAIR)
    {
        if(AddCertPairToStore(hCertStore,
								pCertBlob->pbData,
								pCertBlob->cbData
								))
        {
            dwContentType=CERT_QUERY_CONTENT_CERT_PAIR;
            goto Found;
        }
    }

     //single encoded CTL
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_CTL)
    {

        if(CertAddEncodedCTLToStore(hCertStore,
								dwEncodingType | dwMsgEncodingType,
								pCertBlob->pbData,
								pCertBlob->cbData,
								CERT_STORE_ADD_ALWAYS,
								&pCTLContext))
        {
            dwContentType=CERT_QUERY_CONTENT_CTL;
            dwEncodingType |= dwMsgEncodingType;
            goto Found;
        }
    }

    //single encoded CRL
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_CRL)
    {

        if(CertAddEncodedCRLToStore(hCertStore,
								dwEncodingType,
								pCertBlob->pbData,
								pCertBlob->cbData,
								CERT_STORE_ADD_ALWAYS,
								&pCRLContext))
        {
            dwContentType=CERT_QUERY_CONTENT_CRL;
            goto Found;
        }
    }

    //PFX
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_PFX)
    {
          if(PFXIsPFXBlob((CRYPT_DATA_BLOB*)pCertBlob))
          {
              dwContentType=CERT_QUERY_CONTENT_PFX;
    		//we need to close the temporary store
    		CertCloseStore(hCertStore, 0);
    		hCertStore=NULL;

              goto Found;
          }

    }



    //serialized CERT
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT)
    {

        if(CertAddSerializedElementToStore(hCertStore,
                                pCertBlob->pbData,
                                pCertBlob->cbData,
                                CERT_STORE_ADD_ALWAYS,
                                0,
                                CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
                                NULL,
                                (const void **)&pCertContext))
        {
            dwContentType=CERT_QUERY_CONTENT_SERIALIZED_CERT;
            dwEncodingType=pCertContext->dwCertEncodingType;
            goto Found;
        }

    }

    //serialized CTL
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL)
    {

        if(CertAddSerializedElementToStore(hCertStore,
                                pCertBlob->pbData,
                                pCertBlob->cbData,
                                CERT_STORE_ADD_ALWAYS,
                                0,
                                CERT_STORE_CTL_CONTEXT_FLAG,
                                NULL,
                                (const void **)&pCTLContext))
        {
            dwContentType=CERT_QUERY_CONTENT_SERIALIZED_CTL;
            dwEncodingType=pCTLContext->dwMsgAndCertEncodingType;
            goto Found;
        }

    }


    //serialized CRL
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL)
    {

        if(CertAddSerializedElementToStore(hCertStore,
                                pCertBlob->pbData,
                                pCertBlob->cbData,
                                CERT_STORE_ADD_ALWAYS,
                                0,
                                CERT_STORE_CRL_CONTEXT_FLAG,
                                NULL,
                                (const void **)&pCRLContext))
        {
            dwContentType=CERT_QUERY_CONTENT_SERIALIZED_CRL;
            dwEncodingType=pCRLContext->dwCertEncodingType;
            goto Found;
        }

    }

    //we need to close the temporary store
    CertCloseStore(hCertStore, 0);

    hCertStore=NULL;


    //serialized store
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE)
    {
        if(hCertStore=CertOpenStore(
                            CERT_STORE_PROV_SERIALIZED,
							dwEncodingType | dwMsgEncodingType,
							NULL,
							0,
							pCertBlob))
        {
            dwContentType=CERT_QUERY_CONTENT_SERIALIZED_STORE;
            dwEncodingType |= dwMsgEncodingType;
            goto Found;
        }
    }

    //PKCS7 signed message
    if((dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED) ||
       (dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED) )
    {

       //get the embedded signed pkcs7
       if((CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED & dwContentTypeFlag))
       {
            if(GetEmbeddedPKCS7(pCertBlob, pwszFileName, &pbPKCS7, &cbPKCS7, &dwPKCS7EncodingType))
                fEmbedded=TRUE;
            else
            {
                if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED)
                {
                    //there is no embedded PKCS7
                    dwPKCS7EncodingType=dwEncodingType | dwMsgEncodingType;

                    pbPKCS7=pCertBlob->pbData;
                    cbPKCS7=pCertBlob->cbData;
                }
                else
                    pbPKCS7=NULL;
            }
       }
       else
       {
            //there is no embedded PKCS7
            dwPKCS7EncodingType=dwEncodingType | dwMsgEncodingType;

            pbPKCS7=pCertBlob->pbData;
            cbPKCS7=pCertBlob->cbData;
        }

        //proceed if there is a pkcs7 to decode
        if(NULL != pbPKCS7)
        {
            //check if the header is missing
            if(SignNoContentWrap(pbPKCS7, cbPKCS7))
                dwMsgType=CMSG_SIGNED;

            if(NULL==(hMsg=CryptMsgOpenToDecode(dwPKCS7EncodingType,
                            0,
                            dwMsgType,
                            NULL,
                            NULL,
                            NULL)))
                goto CryptMsgOpenErr;

            //update the message
            if(CryptMsgUpdate(hMsg,
                        pbPKCS7,
                        cbPKCS7,
                        TRUE))
            {

                //get the message type
                cbData=sizeof(dwMsgType);

                if(!CryptMsgGetParam(hMsg,
                            CMSG_TYPE_PARAM,
                            0,
                            &dwMsgType,
                            &cbData))
                    goto CryptMsgGetParamErr;

                if(CMSG_SIGNED == dwMsgType)
                {
                    PKCS7Blob.cbData=cbPKCS7;
                    PKCS7Blob.pbData=pbPKCS7;

                    //open a certificate store
                    hCertStore=CertOpenStore(CERT_STORE_PROV_PKCS7,
							dwPKCS7EncodingType,
							NULL,
							0,
							&PKCS7Blob);

                    if(NULL==hCertStore)
                        goto CertOpenStoreErr;

                    //we succeeded in opening a signed PKCS7
                    dwEncodingType = dwPKCS7EncodingType;

                    if(TRUE==fEmbedded)
                        dwContentType=CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED;
                    else
                        dwContentType=CERT_QUERY_CONTENT_PKCS7_SIGNED;

                    goto Found;
                }
            }

            //close the message
            CryptMsgClose(hMsg);

            hMsg=NULL;

        }
    }


    //PKCS7 unsigned message, not embedded
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED)
    {
        //no need to check if the header is missing
        if(NULL==(hMsg=CryptMsgOpenToDecode(dwEncodingType | dwMsgEncodingType,
                            0,
                            0,
                            NULL,
                            NULL,
                            NULL)))
            goto CryptMsgOpenErr;

        //update the message
        if(CryptMsgUpdate(hMsg,
                        pCertBlob->pbData,
                        pCertBlob->cbData,
                        TRUE))
        {

            //get the message type
            cbData=sizeof(dwMsgType);

            if(!CryptMsgGetParam(hMsg,
                            CMSG_TYPE_PARAM,
                            0,
                            &dwMsgType,
                            &cbData))
                goto CryptMsgGetParamErr;

            if(CMSG_SIGNED != dwMsgType)
            {
                //we succeeded in opening a unsigned PKCS7
                dwContentType=CERT_QUERY_CONTENT_PKCS7_UNSIGNED;
                dwEncodingType =dwEncodingType | dwMsgEncodingType;

                goto Found;
            }
        }

        //close the message
        CryptMsgClose(hMsg);

        hMsg=NULL;
    }

    //PKCS10
    if(dwContentTypeFlag & CERT_QUERY_CONTENT_FLAG_PKCS10)
    {
        //try to decode the BLOB
        cbData = 0;
        if(CryptDecodeObject(dwEncodingType,
                            X509_CERT_REQUEST_TO_BE_SIGNED,
                            pCertBlob->pbData,
                            pCertBlob->cbData,
                            0,
                            NULL,
                            &cbData))
        {
            dwContentType=CERT_QUERY_CONTENT_PKCS10;

            // CryptDecodeObjectEX should be usable here, but since this object
            // is included with XEnroll and XEnroll must run with Auth2UPD Crypt32
            // we must stick with the old CryptDecodeObject 2 pass calls.
            if( (dwFlag & CRYPT_DECODE_ALLOC_FLAG) == CRYPT_DECODE_ALLOC_FLAG ) {

                // allocate the space, must use local alloc
                if( NULL == (pReqInfo = (PCERT_REQUEST_INFO) LocalAlloc(LPTR, cbData)) )
                    goto LocalAllocErr;

                // decode the request
                if( !CryptDecodeObject(dwEncodingType,
                            X509_CERT_REQUEST_TO_BE_SIGNED,
                            pCertBlob->pbData,
                            pCertBlob->cbData,
                            0,
                            pReqInfo,
                            &cbData))
                goto CryptDecodeObjectErr;

            }
            goto Found;

        }
    }


    //we give up
    goto NoMatchErr;

Found:

    //fill in the output if required; Free the resources
    if(pdwMsgAndCertEncodingType)
        *pdwMsgAndCertEncodingType=dwEncodingType;

    if(pdwContentType)
        *pdwContentType=dwContentType;

    if(phCertStore)
        *phCertStore=hCertStore;
    else
    {
        if(hCertStore)
            CertCloseStore(hCertStore, 0);
    }

    if(phMsg)
        *phMsg=hMsg;
    else
    {
        if(hMsg)
            CryptMsgClose(hMsg);
    }

    if(ppvContext)
    {
        //only one of pCertContext or pCRLContext or pCRLContext is set
        if(pCertContext)
            *ppvContext=pCertContext;
        else
        {
            if(pCRLContext)
                *ppvContext=pCRLContext;

            else if(pReqInfo)
                *ppvContext=pReqInfo;

            else
                *ppvContext=pCTLContext;
        }
    }
    else
    {
        if(pCertContext)
            CertFreeCertificateContext(pCertContext);

        if(pCRLContext)
            CertFreeCRLContext(pCRLContext);

        if(pCTLContext)
            CertFreeCTLContext(pCTLContext);

        if(pReqInfo)
            LocalFree(pReqInfo);
    }


    fResult=TRUE;


CommonReturn:

    if(pbPKCS7)
    {
        if(TRUE==fEmbedded)
            free(pbPKCS7);
    }

	return fResult;

ErrorReturn:

    //relaset the stores and reset the local parameters
    if(hCertStore)
        CertCloseStore(hCertStore, 0);

    if(hMsg)
        CryptMsgClose(hMsg);

    if(pCertContext)
        CertFreeCertificateContext(pCertContext);

    if(pCRLContext)
        CertFreeCRLContext(pCRLContext);

    if(pCTLContext)
        CertFreeCTLContext(pCTLContext);

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR(NoMatchErr,CRYPT_E_NO_MATCH);
SET_ERROR(LocalAllocErr, ERROR_OUTOFMEMORY);
TRACE_ERROR(CryptDecodeObjectErr);
TRACE_ERROR(CryptMsgOpenErr);
TRACE_ERROR(CryptMsgGetParamErr);
TRACE_ERROR(CertOpenStoreErr);
}

//-------------------------------------------------------------------------
//
//  CryptQueryObject takes a CERT_BLOB or a file name and returns the
//  information about the content in the blob or in the file.
//
//  Parameters:
//  INPUT   dwObjectType:
//                       Indicate the type of the object.  Should be one of the
//                       following:
//                          CERT_QUERY_OBJECT_FILE
//                          CERT_QUERY_OBJECT_BLOB
//
//  INPUT   pvObject:
//                        If dwObjectType == CERT_QUERY_OBJECT_FILE, it is a
//                        LPWSTR, that is, the pointer to a wchar file name
//                        if dwObjectType == CERT_QUERY_OBJECT_BLOB, it is a
//                        PCERT_BLOB, that is, a pointer to a CERT_BLOB
//
//  INPUT   dwExpectedContentTypeFlags:
//                        Indicate the expected contenet type.
//                        Can be one of the following:
//                              CERT_QUERY_CONTENT_FLAG_ALL  (the content can be any type)
//                              CERT_QUERY_CONTENT_FLAG_CERT
//                              CERT_QUERY_CONTENT_FLAG_CTL
//                              CERT_QUERY_CONTENT_FLAG_CRL
//                              CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE
//                              CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT
//                              CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL
//                              CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL
//                              CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED
//                              CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED
//                              CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED
//                              CERT_QUERY_CONTENT_FLAG_PKCS10
//                              CERT_QUERY_CONTENT_FLAG_PFX
//                              CERT_QUERY_CONTENT_FLAG_CERT_PAIR
//
//  INPUT   dwExpectedFormatTypeFlags:
//                        Indicate the expected format type.
//                        Can be one of the following:
//                              CERT_QUERY_FORMAT_FLAG_ALL (the content can be any format)
//                              CERT_QUERY_FORMAT_FLAG_BINARY
//                              CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED
//                              CERT_QUERY_FORMAT_FLAG_ASN_ASCII_HEX_ENCODED
//
//
//  INPUT   dwFlags
//                        Reserved flag.  Should always set to 0
//
//  OUTPUT  pdwMsgAndCertEncodingType
//                        Optional output.  If NULL != pdwMsgAndCertEncodingType,
//                        it contains the encoding type of the content as any
//                        combination of the following:
//                              X509_ASN_ENCODING
//                              PKCS_7_ASN_ENCODING
//
//  OUTPUT  pdwContentType
//                        Optional output.  If NULL!=pdwContentType, it contains
//                        the content type as one of the the following:
//                              CERT_QUERY_CONTENT_CERT
//                              CERT_QUERY_CONTENT_CTL
//                              CERT_QUERY_CONTENT_CRL
//                              CERT_QUERY_CONTENT_SERIALIZED_STORE
//                              CERT_QUERY_CONTENT_SERIALIZED_CERT
//                              CERT_QUERY_CONTENT_SERIALIZED_CTL
//                              CERT_QUERY_CONTENT_SERIALIZED_CRL
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED
//                              CERT_QUERY_CONTENT_PKCS7_UNSIGNED
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED
//                              CERT_QUERY_CONTENT_PKCS10
//                              CERT_QUERY_CONTENT_PFX
//                              CERT_QUERY_CONTENT_CERT_PAIR
//
//  OUTPUT  pdwFormatType
//                        Optional output.  If NULL !=pdwFormatType, it
//                        contains the format type of the content as one of the
//                        following:
//                              CERT_QUERY_FORMAT_BINARY
//                              CERT_QUERY_FORMAT_BASE64_ENCODED
//                              CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED
//
//
//  OUTPUT  phCertStore
//                        Optional output.  If NULL !=phStore,
//                        it contains a cert store that includes all of certificates,
//                        CRL, and CTL in the object if the object content type is
//                        one of the following:
//                              CERT_QUERY_CONTENT_CERT
//                              CERT_QUERY_CONTENT_CTL
//                              CERT_QUERY_CONTENT_CRL
//                              CERT_QUERY_CONTENT_SERIALIZED_STORE
//                              CERT_QUERY_CONTENT_SERIALIZED_CERT
//                              CERT_QUERY_CONTENT_SERIALIZED_CTL
//                              CERT_QUERY_CONTENT_SERIALIZED_CRL
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED
//                              CERT_QUERY_CONTENT_CERT_PAIR
//
//                       Caller should free *phCertStore via CertCloseStore.
//
//
//  OUTPUT  phMsg        Optional output.  If NULL != phMsg,
//                        it contains a handle to a opened message if
//                        the content type is one of the following:
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED
//                              CERT_QUERY_CONTENT_PKCS7_UNSIGNED
//                              CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED
//
//                       Caller should free *phMsg via CryptMsgClose.
//
//  OUTPUT pContext     Optional output.  If NULL != pContext,
//                      it contains either a PCCERT_CONTEXT or PCCRL_CONTEXT,
//                      or PCCTL_CONTEXT based on the content type.
//
//                      If the content type is CERT_QUERY_CONTENT_CERT or
//                      CERT_QUERY_CONTENT_SERIALIZED_CERT, it is a PCCERT_CONTEXT;
//                      Caller should free the pContext via CertFreeCertificateContext.
//
//                      If the content type is CERT_QUERY_CONTENT_CRL or
//                      CERT_QUERY_CONTENT_SERIALIZED_CRL, it is a PCCRL_CONTEXT;
//                      Caller should free the pContext via CertFreeCRLContext.
//
//                      If the content type is CERT_QUERY_CONTENT_CTL or
//                      CERT_QUERY_CONTENT_SERIALIZED_CTL, it is a PCCTL_CONTEXT;
//                      Caller should free the pContext via CertFreeCTLContext.
//
//  If the *pbObject is of type CERT_QUERY_CONTENT_PKCS10 or CERT_QUERY_CONTENT_PFX, CryptQueryObject
//  will not return anything in *phCertstore, *phMsg, or *ppvContext.
//--------------------------------------------------------------------------

BOOL
WINAPI
CryptQueryObject(DWORD            dwObjectType,
                       const void       *pvObject,
                       DWORD            dwExpectedContentTypeFlags,
                       DWORD            dwExpectedFormatTypeFlags,
                       DWORD            dwFlags,
                       DWORD            *pdwMsgAndCertEncodingType,
                       DWORD            *pdwContentType,
                       DWORD            *pdwFormatType,
                       HCERTSTORE       *phCertStore,
                       HCRYPTMSG        *phMsg,
                       const void       **ppvContext)
{
        BOOL        fResult=FALSE;
        DWORD       err;
        CERT_BLOB   CertBlob;
        DWORD       cbData=0;
        BYTE        *pbData=NULL;

        BYTE        *pbToDecode=NULL;
        DWORD       cbToDecode=0;

        DWORD       cbDecodedData=0;
        BYTE        *pbDecodedData=NULL;
        HRESULT     hr=S_OK;
        DWORD       dwFormatType=0;

    __try {

        //check input parameters
        if(NULL==pvObject)
            goto InvalidArgErr;

        //make sure we have a correct dwFormatTypeFlag
        if(0==(dwExpectedFormatTypeFlags & CERT_QUERY_FORMAT_FLAG_ALL))
            goto InvalidArgErr;

        //make sure we have a correct dwContentTypeFlag
        if(0==(dwExpectedContentTypeFlags & CERT_QUERY_CONTENT_FLAG_ALL))
            goto InvalidArgErr;

        //NULL out local variables
        memset(&CertBlob, 0, sizeof(CERT_BLOB));

        //get the BLOB
        if(CERT_QUERY_OBJECT_FILE == dwObjectType)
        {
              if(S_OK!=(hr=RetrieveBLOBFromFile((LPWSTR)pvObject, &cbData, &pbData)))
                    goto  RetrieveBLOBFromFileErr;

        }
        else
        {
            if(CERT_QUERY_OBJECT_BLOB == dwObjectType)
            {
                cbData=((PCERT_BLOB)pvObject)->cbData;
                pbData=((PCERT_BLOB)pvObject)->pbData;

            }
            else
                goto InvalidArgErr;
        }

       //make sure the input are valid
       if(0==cbData || NULL==pbData)
            goto InvalidArgErr;


        //assume the BLOBs are ANSCII
        CertBlob.cbData=cbData;
        CertBlob.pbData=pbData;


        //binary decoding
        if(dwExpectedFormatTypeFlags & CERT_QUERY_FORMAT_FLAG_BINARY)
        {

            if(I_CryptQueryObject(
                        &CertBlob,
                        (CERT_QUERY_OBJECT_FILE == dwObjectType) ? (LPWSTR)pvObject : NULL,
                        dwExpectedContentTypeFlags,
                        dwExpectedFormatTypeFlags,
                        dwFlags,
                        pdwMsgAndCertEncodingType,
                        pdwContentType,
                        pdwFormatType,
                        phCertStore,
                        phMsg,
                        ppvContext))
            {
                dwFormatType=CERT_QUERY_FORMAT_BINARY;
                goto Done;
            }
        }

        if(dwExpectedFormatTypeFlags &
                CERT_QUERY_FORMAT_FLAG_ASN_ASCII_HEX_ENCODED)
        {
            if (ASN_ASCII_HEX_PREFIX_LEN < cbData &&
                    0 == _strnicmp((char *) pbData, ASN_ASCII_HEX_PREFIX,
                            ASN_ASCII_HEX_PREFIX_LEN))
            {
                dwFormatType=CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED;

                if (!DecodeAsciiHex(
                        (char *) (pbData + ASN_ASCII_HEX_PREFIX_LEN),
                        cbData - ASN_ASCII_HEX_PREFIX_LEN,
                        &pbDecodedData,
                        &cbDecodedData
                        ))
                    goto InvalidAsciiHex;

                CertBlob.cbData=cbDecodedData;
                CertBlob.pbData=pbDecodedData;


                if(I_CryptQueryObject(
                        &CertBlob,
                        NULL,
                        dwExpectedContentTypeFlags,
                        dwExpectedFormatTypeFlags,
                        dwFlags,
                        pdwMsgAndCertEncodingType,
                        pdwContentType,
                        pdwFormatType,
                        phCertStore,
                        phMsg,
                        ppvContext))
                {
                    goto Done;
                } else {
                    goto I_CryptQueryObjectErr;
                }
            }
        }

        if(dwExpectedFormatTypeFlags & CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED)
        {
			pbToDecode = pbData;
			cbToDecode = cbData;

            if(!DecodeBlobA((CHAR *)pbToDecode, cbToDecode, &pbDecodedData, &cbDecodedData))
            {
                LPWSTR pwszUnicode = (LPWSTR) pbData;
                DWORD cchUnicode = cbData / sizeof(WCHAR);

                if(!POINTER_IS_ALIGNED(pwszUnicode, sizeof(WCHAR)) ||
                        !DecodeBlobW(pwszUnicode, cchUnicode, &pbDecodedData, &cbDecodedData))
                {
                    //now we are conviced the BLOB is not base64 encoded
                    goto NoMatchErr;
                }
            }

            //the BLOB has been properly decoded
            dwFormatType=CERT_QUERY_FORMAT_BASE64_ENCODED;

            //make sure the base64 decode routine worked
            if(0==cbDecodedData || NULL==pbDecodedData)
                goto BadEncodeErr;

            CertBlob.cbData=cbDecodedData;
            CertBlob.pbData=pbDecodedData;

            //try the base64 decoded BLOB
            if(!I_CryptQueryObject(
                        &CertBlob,
                        NULL,
                        dwExpectedContentTypeFlags,
                        dwExpectedFormatTypeFlags,
                        dwFlags,
                        pdwMsgAndCertEncodingType,
                        pdwContentType,
                        pdwFormatType,
                        phCertStore,
                        phMsg,
                        ppvContext))
                    goto I_CryptQueryObjectErr;
        }
        else
        {
            goto NoMatchErr;
        }

Done:
        //return the FormatType
        if(NULL != pdwFormatType)
            *pdwFormatType = dwFormatType;

        fResult=TRUE;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        err = GetExceptionCode();
        goto ExceptionErr;
    }

CommonReturn:

    //free memory
    if(CERT_QUERY_OBJECT_FILE == dwObjectType)
    {
        if(pbData)
            UnmapViewOfFile(pbData);
    }

    if(pbDecodedData)
        free(pbDecodedData);

	return fResult;

ErrorReturn:

	fResult=FALSE;
	goto CommonReturn;

SET_ERROR_VAR(RetrieveBLOBFromFileErr, hr);
SET_ERROR(InvalidArgErr,E_INVALIDARG);
TRACE_ERROR(I_CryptQueryObjectErr);
SET_ERROR(NoMatchErr, CRYPT_E_NO_MATCH);
SET_ERROR(BadEncodeErr, CRYPT_E_BAD_ENCODE);
TRACE_ERROR(InvalidAsciiHex);
SET_ERROR_VAR(ExceptionErr, err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\policy.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       policy.cpp
//
//  Contents:   Certificate Chain Policy APIs
//
//  Functions:  CertChainPolicyDllMain
//              CertVerifyCertificateChainPolicy
//              CertDllVerifyBaseCertificateChainPolicy
//              CertDllVerifyBasicConstraintsCertificateChainPolicy
//              CertDllVerifyAuthenticodeCertificateChainPolicy
//              CertDllVerifyAuthenticodeTimeStampCertificateChainPolicy
//              CertDllVerifySSLCertificateChainPolicy
//              CertDllVerifyNTAuthCertificateChainPolicy
//              CertDllVerifyMicrosoftRootCertificateChainPolicy
//
//  History:    16-Feb-98   philh   created
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>
#include "wintrust.h"
#include "softpub.h"

#include "wininet.h"
#ifndef SECURITY_FLAG_IGNORE_REVOCATION
#   define SECURITY_FLAG_IGNORE_REVOCATION          0x00000080
#   define SECURITY_FLAG_IGNORE_UNKNOWN_CA          0x00000100
#endif

#ifndef SECURITY_FLAG_IGNORE_WRONG_USAGE
#   define  SECURITY_FLAG_IGNORE_WRONG_USAGE        0x00000200
#endif


#define INVALID_NAME_ERROR_STATUS   ( \
    CERT_TRUST_INVALID_NAME_CONSTRAINTS             | \
    CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT    | \
    CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT      | \
    CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT    | \
    CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT           \
    )

#define INVALID_POLICY_ERROR_STATUS   ( \
    CERT_TRUST_INVALID_POLICY_CONSTRAINTS           | \
    CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY               \
    )

BOOL fWildcardsEnabledInSslServerCerts = TRUE;

//+-------------------------------------------------------------------------
//  Global cert policy critical section.
//--------------------------------------------------------------------------
static CRITICAL_SECTION CertPolicyCriticalSection;

//+-------------------------------------------------------------------------
//  Cached certificate store used for NTAuth certificate chain policy.
//--------------------------------------------------------------------------
static HCERTSTORE hNTAuthCertStore = NULL;

//
//  support for MS test roots!!!!
//
static BYTE rgbTestRoot[] = 
{
#include "mstest1.h"
};

static BYTE rgbTestRootCorrected[] = 
{
#include "mstest2.h"
};

static BYTE rgbTestRootBeta1[] = 
{
#include "mstestb1.h"
};

static CERT_PUBLIC_KEY_INFO rgTestRootPublicKeyInfo[] = 
{
    {szOID_RSA_RSA, 0, NULL, sizeof(rgbTestRoot), rgbTestRoot, 0},
    {szOID_RSA_RSA, 0, NULL,
        sizeof(rgbTestRootCorrected), rgbTestRootCorrected, 0},
    {szOID_RSA_RSA, 0, NULL, sizeof(rgbTestRootBeta1), rgbTestRootBeta1, 0}
};
#define NTESTROOTS (sizeof(rgTestRootPublicKeyInfo)/ \
                            sizeof(rgTestRootPublicKeyInfo[0]))

HCRYPTOIDFUNCSET hChainPolicyFuncSet;

typedef BOOL (WINAPI *PFN_CHAIN_POLICY_FUNC) (
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifyBaseCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifyAuthenticodeCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifyAuthenticodeTimeStampCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifySSLCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifyBasicConstraintsCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifyNTAuthCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

BOOL
WINAPI
CertDllVerifyMicrosoftRootCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    );

static const CRYPT_OID_FUNC_ENTRY ChainPolicyFuncTable[] = {
    CERT_CHAIN_POLICY_BASE, CertDllVerifyBaseCertificateChainPolicy,
    CERT_CHAIN_POLICY_AUTHENTICODE,
        CertDllVerifyAuthenticodeCertificateChainPolicy,
    CERT_CHAIN_POLICY_AUTHENTICODE_TS,
        CertDllVerifyAuthenticodeTimeStampCertificateChainPolicy,
    CERT_CHAIN_POLICY_SSL,
        CertDllVerifySSLCertificateChainPolicy,
    CERT_CHAIN_POLICY_BASIC_CONSTRAINTS,
        CertDllVerifyBasicConstraintsCertificateChainPolicy,
    CERT_CHAIN_POLICY_NT_AUTH,
        CertDllVerifyNTAuthCertificateChainPolicy,
    CERT_CHAIN_POLICY_MICROSOFT_ROOT,
        CertDllVerifyMicrosoftRootCertificateChainPolicy,
};

#define CHAIN_POLICY_FUNC_COUNT (sizeof(ChainPolicyFuncTable) / \
                                    sizeof(ChainPolicyFuncTable[0]))


BOOL
WINAPI
CertChainPolicyDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        if (NULL == (hChainPolicyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_VERIFY_CERTIFICATE_CHAIN_POLICY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                0,                          // dwEncodingType
                CRYPT_OID_VERIFY_CERTIFICATE_CHAIN_POLICY_FUNC,
                CHAIN_POLICY_FUNC_COUNT,
                ChainPolicyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;

        if (!Pki_InitializeCriticalSection(&CertPolicyCriticalSection))
            goto InitCritSectionError;
        break;

    case DLL_PROCESS_DETACH:
        DeleteCriticalSection(&CertPolicyCriticalSection);
        if (hNTAuthCertStore)
            CertCloseStore(hNTAuthCertStore, 0);
        break;

    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(InitCritSectionError)
TRACE_ERROR(CryptInitOIDFunctionSetError)
TRACE_ERROR(CryptInstallOIDFunctionAddressError)
}


//+-------------------------------------------------------------------------
//  Lock and unlock global cert policy functions
//--------------------------------------------------------------------------
static inline void CertPolicyLock()
{
    EnterCriticalSection(&CertPolicyCriticalSection);
}
static inline void CertPolicyUnlock()
{
    LeaveCriticalSection(&CertPolicyCriticalSection);
}


//+-------------------------------------------------------------------------
//  Verify that the certificate chain satisfies the specified policy
//  requirements. If we were able to verify the chain policy, TRUE is returned
//  and the dwError field of the pPolicyStatus is updated. A dwError of 0
//  (ERROR_SUCCESS, S_OK) indicates the chain satisfies the specified policy.
//
//  If dwError applies to the entire chain context, both lChainIndex and
//  lElementIndex are set to -1. If dwError applies to a simple chain,
//  lElementIndex is set to -1 and lChainIndex is set to the index of the
//  first offending chain having the error. If dwError applies to a
//  certificate element, lChainIndex and lElementIndex are updated to 
//  index the first offending certificate having the error, where, the
//  the certificate element is at:
//      pChainContext->rgpChain[lChainIndex]->rgpElement[lElementIndex].
//
//  The dwFlags in pPolicyPara can be set to change the default policy checking
//  behaviour. In addition, policy specific parameters can be passed in
//  the pvExtraPolicyPara field of pPolicyPara.
//
//  In addition to returning dwError, in pPolicyStatus, policy OID specific
//  extra status may be returned via pvExtraPolicyStatus.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertVerifyCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr = NULL;

    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);
    pPolicyStatus->dwError = 0;
    pPolicyStatus->lChainIndex = -1;
    pPolicyStatus->lElementIndex = -1;

    if (!CryptGetOIDFunctionAddress(
            hChainPolicyFuncSet,
            0,                      // dwEncodingType,
            pszPolicyOID,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr))
        goto GetOIDFuncAddrError;

    fResult = ((PFN_CHAIN_POLICY_FUNC) pvFuncAddr)(
        pszPolicyOID,
        pChainContext,
        pPolicyPara,
        pPolicyStatus
        );
    CryptFreeOIDFunctionAddress(hFuncAddr, 0);
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOIDFuncAddrError)
}


static inline PCERT_CHAIN_ELEMENT GetRootChainElement(
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    DWORD dwRootChainIndex = pChainContext->cChain - 1;
    DWORD dwRootElementIndex =
        pChainContext->rgpChain[dwRootChainIndex]->cElement - 1;

    return pChainContext->rgpChain[dwRootChainIndex]->
                                        rgpElement[dwRootElementIndex];
}

void GetElementIndexOfFirstError(
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN DWORD dwErrorStatusMask,
    OUT LONG *plChainIndex,
    OUT LONG *plElementIndex
    )
{
    DWORD i;
    for (i = 0; i < pChainContext->cChain; i++) {
        DWORD j;
        PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];

        for (j = 0; j < pChain->cElement; j++) {
            PCERT_CHAIN_ELEMENT pEle = pChain->rgpElement[j];

            if (pEle->TrustStatus.dwErrorStatus & dwErrorStatusMask) {
                *plChainIndex = (LONG) i;
                *plElementIndex = (LONG) j;
                return;
            }
        }
    }

    *plChainIndex = -1;
    *plElementIndex = -1;
}

void GetChainIndexOfFirstError(
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN DWORD dwErrorStatusMask,
    OUT LONG *plChainIndex
    )
{
    DWORD i;
    for (i = 0; i < pChainContext->cChain; i++) {
        PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];

        if (pChain->TrustStatus.dwErrorStatus & dwErrorStatusMask) {
            *plChainIndex = (LONG) i;
            return;
        }
    }

    *plChainIndex = -1;
}


//+=========================================================================
//  CertDllVerifyBaseCertificateChainPolicy Functions
//==========================================================================

BOOL
WINAPI
CertDllVerifyBaseCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    DWORD dwError;
    DWORD dwFlags;
    DWORD dwContextError;
    LONG lChainIndex = -1;
    LONG lElementIndex = -1;
    DWORD dwErrorStatusMask;

    dwContextError = pChainContext->TrustStatus.dwErrorStatus;


    if (0 == dwContextError) {
        // Valid chain
        dwError = 0;
        goto CommonReturn;
    }

    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, dwFlags) <
            pPolicyPara->cbSize)
        dwFlags = pPolicyPara->dwFlags;
    else
        dwFlags = 0;

    if (dwContextError &
            (CERT_TRUST_IS_NOT_SIGNATURE_VALID |
                CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID)) {
        dwError = (DWORD) TRUST_E_CERT_SIGNATURE;
        dwErrorStatusMask =
            CERT_TRUST_IS_NOT_SIGNATURE_VALID |
                CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID;
        if (dwErrorStatusMask & CERT_TRUST_IS_NOT_SIGNATURE_VALID)
            goto GetElementIndexReturn;
        else
            goto GetChainIndexReturn;
    } 

    if (dwContextError & CERT_TRUST_IS_UNTRUSTED_ROOT) {
        dwErrorStatusMask = CERT_TRUST_IS_UNTRUSTED_ROOT;
        if (dwFlags & CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG) {
            ;
        } else if (0 == (dwFlags & CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG)) {
            dwError = (DWORD) CERT_E_UNTRUSTEDROOT;
            goto GetElementIndexReturn;
        } else {
            // Check if one of the "test" roots
            DWORD i;
            BOOL fTestRoot;
            PCERT_CHAIN_ELEMENT pRootElement;
            PCCERT_CONTEXT pRootCert;

            pRootElement = GetRootChainElement(pChainContext);
            assert(pRootElement->TrustStatus.dwInfoStatus &
                CERT_TRUST_IS_SELF_SIGNED);
            pRootCert = pRootElement->pCertContext;

            fTestRoot = FALSE;
            for (i = 0; i < NTESTROOTS; i++) {
                if (CertComparePublicKeyInfo(
                        pRootCert->dwCertEncodingType,
                        &pRootCert->pCertInfo->SubjectPublicKeyInfo,
                        &rgTestRootPublicKeyInfo[i])) {
                    fTestRoot = TRUE;
                    break;
                }
            }
            if (fTestRoot) {
                if (0 == (dwFlags & CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG)) {
                    dwError = (DWORD) CERT_E_UNTRUSTEDTESTROOT;
                    goto GetElementIndexReturn;
                }
            } else {
                dwError = (DWORD) CERT_E_UNTRUSTEDROOT;
                goto GetElementIndexReturn;
            }
        }
    }

    if (dwContextError & CERT_TRUST_IS_PARTIAL_CHAIN) {
        if (0 == (dwFlags & CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG)) {
            dwError = (DWORD) CERT_E_CHAINING;
            dwErrorStatusMask = CERT_TRUST_IS_PARTIAL_CHAIN;
            goto GetChainIndexReturn;
        }
    }

    if (dwContextError & CERT_TRUST_IS_REVOKED) {
        dwError = (DWORD) CRYPT_E_REVOKED;
        dwErrorStatusMask = CERT_TRUST_IS_REVOKED;
        goto GetElementIndexReturn;
    }

    if (dwContextError & (CERT_TRUST_IS_NOT_VALID_FOR_USAGE |
            CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE)) {
        if (0 == (dwFlags & CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG)) {
            dwError = (DWORD) CERT_E_WRONG_USAGE;
            dwErrorStatusMask = CERT_TRUST_IS_NOT_VALID_FOR_USAGE |
                CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE;
            if (dwContextError & CERT_TRUST_IS_NOT_VALID_FOR_USAGE)
                goto GetElementIndexReturn;
            else
                goto GetChainIndexReturn;
        }
    }

    if (dwContextError & CERT_TRUST_IS_NOT_TIME_VALID) {
        if (0 == (dwFlags & CERT_CHAIN_POLICY_IGNORE_NOT_TIME_VALID_FLAG)) {
            dwError = (DWORD) CERT_E_EXPIRED;
            dwErrorStatusMask = CERT_TRUST_IS_NOT_TIME_VALID;
            goto GetElementIndexReturn;
        }
    }

    if (dwContextError & CERT_TRUST_CTL_IS_NOT_TIME_VALID) {
        if (0 == (dwFlags & CERT_CHAIN_POLICY_IGNORE_CTL_NOT_TIME_VALID_FLAG)) {
            dwErrorStatusMask = CERT_TRUST_CTL_IS_NOT_TIME_VALID;
            dwError = (DWORD) CERT_E_EXPIRED;
            goto GetChainIndexReturn;
        }
    }

    if (dwContextError & INVALID_NAME_ERROR_STATUS) {
        if (0 == (dwFlags & CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG)) {
            dwError = (DWORD) CERT_E_INVALID_NAME;
            dwErrorStatusMask = INVALID_NAME_ERROR_STATUS;
            goto GetElementIndexReturn;
        }
    }

    if (dwContextError & INVALID_POLICY_ERROR_STATUS) {
        if (0 == (dwFlags & CERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG)) {
            dwError = (DWORD) CERT_E_INVALID_POLICY;
            dwErrorStatusMask = INVALID_POLICY_ERROR_STATUS;
            goto GetElementIndexReturn;
        }
    }

    if (dwContextError & CERT_TRUST_INVALID_BASIC_CONSTRAINTS) {
        if (0 == (dwFlags &
                    CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG)) {
            dwError = (DWORD) TRUST_E_BASIC_CONSTRAINTS;
            dwErrorStatusMask = CERT_TRUST_INVALID_BASIC_CONSTRAINTS;
            goto GetElementIndexReturn;
        }
    }

    if (dwContextError & CERT_TRUST_IS_NOT_TIME_NESTED) {
        if (0 == (dwFlags & CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG)) {
            dwErrorStatusMask = CERT_TRUST_IS_NOT_TIME_NESTED;
            dwError = (DWORD) CERT_E_VALIDITYPERIODNESTING;
            goto GetElementIndexReturn;
        }
    }

    dwError = 0;

    // Note, OFFLINE takes precedence over NO_CHECK

    if (dwContextError & CERT_TRUST_REVOCATION_STATUS_UNKNOWN) {
        if ((dwFlags & CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS) !=
                CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS) {
            DWORD i;
            for (i = 0; i < pChainContext->cChain; i++) {
                DWORD j;
                PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];

                for (j = 0; j < pChain->cElement; j++) {
                    PCERT_CHAIN_ELEMENT pEle = pChain->rgpElement[j];
                    DWORD dwEleError = pEle->TrustStatus.dwErrorStatus;
                    DWORD dwEleInfo = pEle->TrustStatus.dwInfoStatus;
                    DWORD dwRevokeError;
                    BOOL fEnableRevokeError;

                    if (0 == (dwEleError &
                            CERT_TRUST_REVOCATION_STATUS_UNKNOWN))
                        continue;

                    assert(pEle->pRevocationInfo);
                    dwRevokeError = pEle->pRevocationInfo->dwRevocationResult;
                    if (CRYPT_E_NO_REVOCATION_CHECK != dwRevokeError)
                        dwRevokeError = (DWORD) CRYPT_E_REVOCATION_OFFLINE;
                    fEnableRevokeError = FALSE;

                    if (dwEleInfo & CERT_TRUST_IS_SELF_SIGNED) {
                        // Chain Root
                        if (0 == (dwFlags &
                                CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG)) {
                            fEnableRevokeError = TRUE;
                        }
                    } else if (0 == i && 0 == j) {
                        // End certificate
                        if (0 == (dwFlags &
                                CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG)) {
                            fEnableRevokeError = TRUE;
                        }
                    } else if (0 == j) {
                        // CTL signer certificate
                        if (0 ==
                                (dwFlags & CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG)) {
                            fEnableRevokeError = TRUE;
                        }
                    } else  {
                        // CA certificate
                        if (0 ==
                                (dwFlags & CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG)) {
                            fEnableRevokeError = TRUE;
                        }
                    }

                    if (fEnableRevokeError) {
                        if (0 == dwError ||
                                CRYPT_E_REVOCATION_OFFLINE == dwRevokeError) {
                            dwError = dwRevokeError;
                            lChainIndex = (LONG) i;
                            lElementIndex = (LONG) j;

                            if (CRYPT_E_REVOCATION_OFFLINE == dwError)
                                goto CommonReturn;
                        }
                    }
                }
            }
        }
    }


CommonReturn:
    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);

    pPolicyStatus->dwError = dwError;
    pPolicyStatus->lChainIndex = lChainIndex;
    pPolicyStatus->lElementIndex = lElementIndex;
    return TRUE;

GetElementIndexReturn:
    GetElementIndexOfFirstError(pChainContext, dwErrorStatusMask,
        &lChainIndex, &lElementIndex);
    goto CommonReturn;

GetChainIndexReturn:
    GetChainIndexOfFirstError(pChainContext, dwErrorStatusMask,
        &lChainIndex);
    goto CommonReturn;
}

//+=========================================================================
//  CertDllVerifyBasicConstraintsCertificateChainPolicy Functions
//==========================================================================

// If dwFlags is 0, allow either CA or END_ENTITY for dwEleIndex == 0
BOOL CheckChainElementBasicConstraints(
    IN PCERT_CHAIN_ELEMENT pEle,
    IN DWORD dwEleIndex,
    IN DWORD dwFlags
    )
{
    BOOL fResult;

    PCERT_INFO pCertInfo = pEle->pCertContext->pCertInfo;
    PCERT_EXTENSION pExt;
    PCERT_BASIC_CONSTRAINTS_INFO pInfo = NULL;
    PCERT_BASIC_CONSTRAINTS2_INFO pInfo2 = NULL;
    DWORD cbInfo;

    BOOL fCA;
    BOOL fEndEntity;

    if (pEle->TrustStatus.dwErrorStatus &
            CERT_TRUST_INVALID_BASIC_CONSTRAINTS)
        goto ChainBasicContraintsError;

    if (0 == dwFlags || 0 != dwEleIndex || 0 == pCertInfo->cExtension) 
        goto SuccessReturn;
    // else
    //  Only need to do additional checking to see if the end cert is
    //  a CA or END_ENTITY.

    if (pExt = CertFindExtension(
            szOID_BASIC_CONSTRAINTS2,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            )) {
        if (!CryptDecodeObjectEx(
                pEle->pCertContext->dwCertEncodingType,
                X509_BASIC_CONSTRAINTS2, 
                pExt->Value.pbData,
                pExt->Value.cbData,
                CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                    CRYPT_DECODE_SHARE_OID_STRING_FLAG,
                &PkiDecodePara,
                (void *) &pInfo2,
                &cbInfo
                )) {
            if (pExt->fCritical) 
                goto DecodeError;
            else
                goto SuccessReturn;
        }
        fCA = pInfo2->fCA;
        fEndEntity = !fCA;
    } else if (pExt = CertFindExtension(
            szOID_BASIC_CONSTRAINTS,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            )) {
        if (!CryptDecodeObjectEx(
                pEle->pCertContext->dwCertEncodingType,
                X509_BASIC_CONSTRAINTS, 
                pExt->Value.pbData,
                pExt->Value.cbData,
                CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                    CRYPT_DECODE_SHARE_OID_STRING_FLAG,
                &PkiDecodePara,
                (void *) &pInfo,
                &cbInfo
                )) {
            if (pExt->fCritical) 
                goto DecodeError;
            else
                goto SuccessReturn;
        }
        if (pExt->fCritical && pInfo->cSubtreesConstraint)
            goto SubtreesError;

        if (pInfo->SubjectType.cbData > 0) {
            BYTE bRole = pInfo->SubjectType.pbData[0];
            fCA = (0 != (bRole & CERT_CA_SUBJECT_FLAG));
            fEndEntity = (0 != (bRole & CERT_END_ENTITY_SUBJECT_FLAG));
        } else {
            fCA = FALSE;
            fEndEntity = FALSE;
        }
    } else
        goto SuccessReturn;


    if (dwFlags & BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG) {
        if (!fEndEntity)
            goto NotAnEndEntity;
    }
    if (dwFlags & BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_CA_FLAG) {
        if (!fCA)
            goto NotACA;
    }
    
SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(pInfo);
    PkiFree(pInfo2);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
 
TRACE_ERROR(ChainBasicContraintsError)
TRACE_ERROR(NotACA)
TRACE_ERROR(NotAnEndEntity)
TRACE_ERROR(SubtreesError)
TRACE_ERROR(DecodeError)
}

BOOL
WINAPI
CertDllVerifyBasicConstraintsCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    DWORD dwFlags;

    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, dwFlags) <
            pPolicyPara->cbSize) {
        dwFlags = pPolicyPara->dwFlags;
        dwFlags &= (BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_CA_FLAG |
            BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG);
        if (dwFlags == (BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_CA_FLAG |
                BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG))
            dwFlags = 0;    // 0 => allow CA or END_ENTITY
    } else
        dwFlags = 0;

    DWORD i;
    for (i = 0; i < pChainContext->cChain; i++) {
        DWORD j;
        PCERT_SIMPLE_CHAIN pChain = pChainContext->rgpChain[i];

        for (j = 0; j < pChain->cElement; j++) {
            if (!CheckChainElementBasicConstraints(pChain->rgpElement[j], j,
                    dwFlags)) {
                assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS,
                    lElementIndex) < pPolicyStatus->cbSize);
                pPolicyStatus->dwError = (DWORD) TRUST_E_BASIC_CONSTRAINTS;
                pPolicyStatus->lChainIndex = (LONG) i;
                pPolicyStatus->lElementIndex = (LONG) j;
                return TRUE;
            }
        }
        // Allow CTL to be signed by either a CA or END_ENTITY
        dwFlags = 0;
    }

    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);
    pPolicyStatus->dwError = 0;
    pPolicyStatus->lChainIndex = -1;
    pPolicyStatus->lElementIndex = -1;
    return TRUE;
}

//+=========================================================================
//  CertDllVerifyAuthenticodeCertificateChainPolicy Functions
//
//  On July 1, 2000 philh removed all of the individual/commercial
//  stuff. It hasn't been used for years!.
//==========================================================================

// Returns TRUE if the signer cert has the Code Signing EKU or if the signer
// cert has the legacy Key Usage extension with either the individual or
// commercial usage.
//
// For backwards compatibility, allow a signer cert without any EKU's
BOOL CheckAuthenticodeChainPurpose(
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    BOOL fResult;
    PCERT_CHAIN_ELEMENT pEle;
    PCCERT_CONTEXT pCert;
    PCERT_INFO pCertInfo;
    PCERT_EXTENSION pExt;
    PCERT_KEY_USAGE_RESTRICTION_INFO pInfo = NULL;
    DWORD cbInfo;

    pEle = pChainContext->rgpChain[0]->rgpElement[0];
    if (NULL == pEle->pApplicationUsage) {
        // No usages. Good for any usage.
        // Do we want to allow this?? Yes, for backward compatibility
        goto SuccessReturn;
    } else {
        DWORD cUsage;
        LPSTR *ppszUsage;

        cUsage = pEle->pApplicationUsage->cUsageIdentifier;
        ppszUsage = pEle->pApplicationUsage->rgpszUsageIdentifier;
        for ( ; cUsage > 0; cUsage--, ppszUsage++) {
            if (0 == strcmp(*ppszUsage, szOID_PKIX_KP_CODE_SIGNING))
                goto SuccessReturn;
        }
    }

    pCert = pEle->pCertContext;
    pCertInfo = pCert->pCertInfo;

    if (0 == pCertInfo->cExtension)
        goto NoSignerCertExtensions;
    
    if (NULL == (pExt = CertFindExtension(
            szOID_KEY_USAGE_RESTRICTION,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            )))
        goto NoSignerKeyUsageExtension;

    if (!CryptDecodeObjectEx(
            pCert->dwCertEncodingType,
            X509_KEY_USAGE_RESTRICTION,
            pExt->Value.pbData,
            pExt->Value.cbData,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                CRYPT_DECODE_SHARE_OID_STRING_FLAG,
            &PkiDecodePara,
            (void *) &pInfo,
            &cbInfo
            ))
        goto DecodeError;

    if (pInfo->cCertPolicyId) {
        DWORD cPolicyId;
        PCERT_POLICY_ID pPolicyId;

        cPolicyId = pInfo->cCertPolicyId;
        pPolicyId = pInfo->rgCertPolicyId;
        for ( ; cPolicyId > 0; cPolicyId--, pPolicyId++) {
            DWORD cElementId = pPolicyId->cCertPolicyElementId;
            LPSTR *ppszElementId = pPolicyId->rgpszCertPolicyElementId;

            for ( ; cElementId > 0; cElementId--, ppszElementId++) 
            {
                if (0 == strcmp(*ppszElementId,
                        SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID))
                    goto SuccessReturn;
                else if (0 == strcmp(*ppszElementId,
                        SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID))
                    goto SuccessReturn;
            }
        }
    }

    goto NoSignerLegacyPurpose;
    
SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(pInfo);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
 
TRACE_ERROR(NoSignerCertExtensions)
TRACE_ERROR(NoSignerKeyUsageExtension)
TRACE_ERROR(DecodeError);
TRACE_ERROR(NoSignerLegacyPurpose)
}

void MapAuthenticodeRegPolicySettingsToBaseChainPolicyFlags(
    IN DWORD dwRegPolicySettings,
    IN OUT DWORD *pdwFlags
    )
{
    DWORD dwFlags;

    if (0 == dwRegPolicySettings)
        return;

    dwFlags = *pdwFlags;
    if (dwRegPolicySettings & WTPF_TRUSTTEST)
        dwFlags |= CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG;
    if (dwRegPolicySettings & WTPF_TESTCANBEVALID)
        dwFlags |= CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG;
    if (dwRegPolicySettings & WTPF_IGNOREEXPIRATION)
        dwFlags |= CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS;

    if (dwRegPolicySettings & WTPF_IGNOREREVOKATION)
        dwFlags |= CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS;
    else if (dwRegPolicySettings & (WTPF_OFFLINEOK_COM | WTPF_OFFLINEOK_IND))
        dwFlags |= CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG;

    *pdwFlags = dwFlags;
}


void GetAuthenticodePara(
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    OUT DWORD *pdwRegPolicySettings,
    OUT PCMSG_SIGNER_INFO *ppSignerInfo
    )
{
    *ppSignerInfo = NULL;
    *pdwRegPolicySettings = 0;
    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, pvExtraPolicyPara) <
            pPolicyPara->cbSize && pPolicyPara->pvExtraPolicyPara) {
        PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA pAuthPara =
            (PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA)
                pPolicyPara->pvExtraPolicyPara;

        if (offsetof(AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA,
                dwRegPolicySettings) < pAuthPara->cbSize)
            *pdwRegPolicySettings = pAuthPara->dwRegPolicySettings;
        if (offsetof(AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA,
                pSignerInfo) < pAuthPara->cbSize)
            *ppSignerInfo = pAuthPara->pSignerInfo;
    }
}

// Map the CRYPT_E_ revocation errors to the corresponding CERT_E_
// revocation errors
static DWORD MapToAuthenticodeError(
    IN DWORD dwError
    )
{
    switch (dwError) {
        case CRYPT_E_REVOKED:
            return (DWORD) CERT_E_REVOKED;
            break;
        case CRYPT_E_NO_REVOCATION_DLL:
        case CRYPT_E_NO_REVOCATION_CHECK:
        case CRYPT_E_REVOCATION_OFFLINE:
        case CRYPT_E_NOT_IN_REVOCATION_DATABASE:
            return (DWORD) CERT_E_REVOCATION_FAILURE;
            break;
    }
    return dwError;
}

BOOL
WINAPI
CertDllVerifyAuthenticodeCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    DWORD dwError;
    DWORD dwFlags;
    DWORD dwRegPolicySettings;
    PCMSG_SIGNER_INFO pSignerInfo;
    LONG lChainIndex = -1;
    LONG lElementIndex = -1;


    CERT_CHAIN_POLICY_PARA BasePolicyPara;
    memset(&BasePolicyPara, 0, sizeof(BasePolicyPara));
    BasePolicyPara.cbSize = sizeof(BasePolicyPara);

    CERT_CHAIN_POLICY_STATUS BasePolicyStatus;
    memset(&BasePolicyStatus, 0, sizeof(BasePolicyStatus));
    BasePolicyStatus.cbSize = sizeof(BasePolicyStatus);

    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, dwFlags) <
            pPolicyPara->cbSize)
        dwFlags = pPolicyPara->dwFlags;
    else
        dwFlags = 0;
    GetAuthenticodePara(pPolicyPara, &dwRegPolicySettings, &pSignerInfo);

    MapAuthenticodeRegPolicySettingsToBaseChainPolicyFlags(
        dwRegPolicySettings, &dwFlags);

    // Do the basic chain policy verification. Authenticode overrides
    // the defaults for the following:
    dwFlags |=
        CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG |
        CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG;

    BasePolicyPara.dwFlags = dwFlags;
    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_BASE,
            pChainContext,
            &BasePolicyPara,
            &BasePolicyStatus
            ))
        return FALSE;
    if (dwError = BasePolicyStatus.dwError) {
        dwError = MapToAuthenticodeError(dwError);
        lChainIndex = BasePolicyStatus.lChainIndex;
        lElementIndex = BasePolicyStatus.lElementIndex;

        if (CERT_E_REVOCATION_FAILURE != dwError)
            goto CommonReturn;
        // else
        //  for REVOCATION_FAILURE let
        //  PURPOSE and BASIC_CONSTRAINTS errors take precedence
    }

    if (pSignerInfo) {
        // Check that either the chain has the code signing EKU or
        // the signer cert has the legacy Key Usage extension containing
        // the commerical or individual policy.
        if (!CheckAuthenticodeChainPurpose(pChainContext)) {
            dwError = (DWORD) CERT_E_PURPOSE;
            lChainIndex = 0;
            lElementIndex = 0;
            goto CommonReturn;
        }
    }
        
    if (pSignerInfo)
        BasePolicyPara.dwFlags =
            BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG;
    else
        BasePolicyPara.dwFlags = 0;
    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_BASIC_CONSTRAINTS,
            pChainContext,
            &BasePolicyPara,
            &BasePolicyStatus
            ))
        return FALSE;
    if (BasePolicyStatus.dwError) {
        dwError = BasePolicyStatus.dwError;
        lChainIndex = BasePolicyStatus.lChainIndex;
        lElementIndex = BasePolicyStatus.lElementIndex;
        goto CommonReturn;
    }

CommonReturn:
    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);
    pPolicyStatus->dwError = dwError;
    pPolicyStatus->lChainIndex = lChainIndex;
    pPolicyStatus->lElementIndex = lElementIndex;

    if (offsetof(CERT_CHAIN_POLICY_STATUS, pvExtraPolicyStatus) <
            pPolicyStatus->cbSize &&
                pPolicyStatus->pvExtraPolicyStatus) {
        // Since the signer statement's Commercial/Individual flag is no
        // longer used, default to individual
        PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS pAuthStatus =
            (PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS)
                pPolicyStatus->pvExtraPolicyStatus;
        if (offsetof(AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS,
                fCommercial) < pAuthStatus->cbSize)
            pAuthStatus->fCommercial = FALSE;
    }
    return TRUE;
}

//+=========================================================================
//  CertDllVerifyAuthenticodeTimeStampCertificateChainPolicy Functions
//==========================================================================

void MapAuthenticodeTimeStampRegPolicySettingsToBaseChainPolicyFlags(
    IN DWORD dwRegPolicySettings,
    IN OUT DWORD *pdwFlags
    )
{
    DWORD dwFlags;

    if (0 == dwRegPolicySettings)
        return;

    dwFlags = *pdwFlags;
    if (dwRegPolicySettings & WTPF_TRUSTTEST)
        dwFlags |= CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG;
    if (dwRegPolicySettings & WTPF_TESTCANBEVALID)
        dwFlags |= CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG;
    if (dwRegPolicySettings & WTPF_IGNOREEXPIRATION)
        dwFlags |= CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS;

    if (dwRegPolicySettings & WTPF_IGNOREREVOCATIONONTS)
        dwFlags |= CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS;
    else if (dwRegPolicySettings & (WTPF_OFFLINEOK_COM | WTPF_OFFLINEOK_IND))
        dwFlags |= CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG;

    *pdwFlags = dwFlags;
}


void GetAuthenticodeTimeStampPara(
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    OUT DWORD *pdwRegPolicySettings
    )
{
    *pdwRegPolicySettings = 0;
    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, pvExtraPolicyPara) <
            pPolicyPara->cbSize && pPolicyPara->pvExtraPolicyPara) {
        PAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA pAuthPara =
            (PAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA)
                pPolicyPara->pvExtraPolicyPara;

        if (offsetof(AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA,
                dwRegPolicySettings) < pAuthPara->cbSize)
            *pdwRegPolicySettings = pAuthPara->dwRegPolicySettings;
    }
}


BOOL
WINAPI
CertDllVerifyAuthenticodeTimeStampCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    DWORD dwError;
    DWORD dwFlags;
    DWORD dwRegPolicySettings;
    LONG lChainIndex = -1;
    LONG lElementIndex = -1;

    CERT_CHAIN_POLICY_PARA BasePolicyPara;
    memset(&BasePolicyPara, 0, sizeof(BasePolicyPara));
    BasePolicyPara.cbSize = sizeof(BasePolicyPara);

    CERT_CHAIN_POLICY_STATUS BasePolicyStatus;
    memset(&BasePolicyStatus, 0, sizeof(BasePolicyStatus));
    BasePolicyStatus.cbSize = sizeof(BasePolicyStatus);

    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, dwFlags) <
            pPolicyPara->cbSize)
        dwFlags = pPolicyPara->dwFlags;
    else
        dwFlags = 0;
    GetAuthenticodeTimeStampPara(
        pPolicyPara, &dwRegPolicySettings);

    MapAuthenticodeTimeStampRegPolicySettingsToBaseChainPolicyFlags(
        dwRegPolicySettings, &dwFlags);

    // Do the basic chain policy verification. Authenticode overrides
    // the defaults for the following:
    dwFlags |=
        CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG |
        CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG;

    BasePolicyPara.dwFlags = dwFlags;
    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_BASE,
            pChainContext,
            &BasePolicyPara,
            &BasePolicyStatus
            ))
        return FALSE;
    if (dwError = BasePolicyStatus.dwError) {
        dwError = MapToAuthenticodeError(dwError);
        lChainIndex = BasePolicyStatus.lChainIndex;
        lElementIndex = BasePolicyStatus.lElementIndex;
        goto CommonReturn;
    }

CommonReturn:
    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);
    pPolicyStatus->dwError = dwError;
    pPolicyStatus->lChainIndex = lChainIndex;
    pPolicyStatus->lElementIndex = lElementIndex;
    return TRUE;
}

//+=========================================================================
//  CertDllVerifySSLCertificateChainPolicy Functions
//==========================================================================

// www.foobar.com == www.foobar.com
// Www.Foobar.com == www.fooBar.cOm
// www.foobar.com == *.foobar.com
// www.foobar.com == w*.foobar.com
// www.foobar.com == ww*.foobar.com
// www.foobar.com != *ww.foobar.com
// abcdef.foobar.com != ab*ef.foobar.com
// abcdef.foobar.com != abc*ef.foobar.com
// abcdef.foobar.com != abc*def.foobar.com
// www.foobar.com != www.f*bar.com
// www.foobar.com != www.*bar.com
// www.foobar.com != www.foo*.com
// www.foobar.com != www.*.com
// foobar.com != *.com
// www.foobar.abc.com != *.abc.com
// foobar.com != *.*
// foobar != *
// abc.def.foobar.com != a*.d*.foobar.com
// abc.foobar.com.au != *.*.com.au
// abc.foobar.com.au != www.*.com.au

BOOL CompareSSLDNStoCommonName(LPCWSTR pDNS, LPCWSTR pCN)
{
    BOOL fUseWildCardRules = FALSE;

    if (NULL == pDNS || L'\0' == *pDNS ||
            NULL == pCN || L'\0' == *pCN)
        return FALSE;

    if(fWildcardsEnabledInSslServerCerts)
    {
        if(wcschr(pCN, L'*') != NULL)
        {
            fUseWildCardRules = TRUE;
        }
    }

    if(fUseWildCardRules)
    {
        DWORD    nCountPeriods  = 1;
        BOOL     fExactMatch    = TRUE;
        BOOL     fComp;
        LPCWSTR  pWild;

        pWild = wcschr(pCN, L'*');
        if(pWild)
        {
            // Fail if CN contains more than one '*'.
            if(wcschr(pWild + 1, L'*'))
            {
                return FALSE;
            }

            // Fail if the wildcard isn't in the first name component.
            if(pWild > wcschr(pCN, L'.'))
            {
                return FALSE;
            }
        }

        while(TRUE)
        {
            fComp = (CSTR_EQUAL == CompareStringU(
                                            LOCALE_USER_DEFAULT,
                                            NORM_IGNORECASE,
                                            pDNS,
                                            1,             // cchCount1
                                            pCN,
                                            1));           // cchCount2

            if ((!fComp && *pCN != L'*') || !(*pDNS) || !(*pCN))
            {
                break;
            }

            if (!fComp)
            {
                fExactMatch = FALSE;
            }

            if (*pCN == L'*')
            {
                nCountPeriods = 0;

                if (*pDNS == L'.')
                {
                    pCN++;
                }
                else
                {
                    pDNS++;
                }
            }
            else
            {
                if (*pDNS == L'.')
                {
                    nCountPeriods++;
                }

                pDNS++;
                pCN++;
            }
        }

        return((*pDNS == 0) && (*pCN == 0) && ((nCountPeriods >= 2) || fExactMatch));
    }
    else
    {
        if (CSTR_EQUAL == CompareStringU(
                LOCALE_USER_DEFAULT,
                NORM_IGNORECASE,
                pDNS,
                -1,             // cchCount1
                pCN,
                -1              // cchCount2
                ))
            return TRUE;
        else
            return FALSE;
    }
}

BOOL IsSSLServerNameInNameInfo(
    IN DWORD dwCertEncodingType,
    IN PCERT_NAME_BLOB pNameInfoBlob,
    IN LPCWSTR pwszServerName
    )
{
    BOOL fResult;
    PCERT_NAME_INFO pInfo = NULL;
    DWORD cbInfo;
    DWORD cRDN;
    PCERT_RDN pRDN;
    
    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            X509_UNICODE_NAME,
            pNameInfoBlob->pbData,
            pNameInfoBlob->cbData,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                CRYPT_DECODE_SHARE_OID_STRING_FLAG,
            &PkiDecodePara,
            (void *) &pInfo,
            &cbInfo
            ))
        goto DecodeError;

    cRDN = pInfo->cRDN;
    pRDN = pInfo->rgRDN;
    for ( ; cRDN > 0; cRDN--, pRDN++) {
        DWORD cAttr = pRDN->cRDNAttr;
        PCERT_RDN_ATTR pAttr = pRDN->rgRDNAttr;
        for ( ; cAttr > 0; cAttr--, pAttr++) {
            if (!IS_CERT_RDN_CHAR_STRING(pAttr->dwValueType))
                continue;
            if (0 == strcmp(pAttr->pszObjId, szOID_COMMON_NAME)) {
                if (CompareSSLDNStoCommonName(pwszServerName,
                        (LPCWSTR) pAttr->Value.pbData))
                    goto SuccessReturn;
            }
        }
    }

    goto ErrorReturn;
SuccessReturn:
    fResult = TRUE;
CommonReturn:
    PkiFree(pInfo);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DecodeError)
}

//
//  Returns:
//      1 - found a matching DNS_NAME choice
//      0 - AltName has DNS_NAME choices, no match
//     -1 - AltName doesn't have DNS_NAME choices
//
int IsSSLServerNameInAltName(
    IN DWORD dwCertEncodingType,
    IN PCRYPT_DER_BLOB pAltNameBlob,
    IN LPCWSTR pwszServerName
    )
{
    int iResult = -1;           // default to no DNS_NAME choices
    PCERT_ALT_NAME_INFO pInfo = NULL;
    DWORD cbInfo;
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;
    
    if (!CryptDecodeObjectEx(
            dwCertEncodingType,
            X509_ALTERNATE_NAME,
            pAltNameBlob->pbData,
            pAltNameBlob->cbData,
            CRYPT_DECODE_NOCOPY_FLAG | CRYPT_DECODE_ALLOC_FLAG |
                CRYPT_DECODE_SHARE_OID_STRING_FLAG,
            &PkiDecodePara,
            (void *) &pInfo,
            &cbInfo
            ))
        goto DecodeError;

    cEntry = pInfo->cAltEntry;
    pEntry = pInfo->rgAltEntry;
    for ( ; cEntry > 0; cEntry--, pEntry++) {
        if (CERT_ALT_NAME_DNS_NAME == pEntry->dwAltNameChoice) {
            if (CompareSSLDNStoCommonName(pwszServerName,
                    pEntry->pwszDNSName))
                goto SuccessReturn;
            else
                iResult = 0;
        }
    }

    goto ErrorReturn;

SuccessReturn:
    iResult = 1;
CommonReturn:
    PkiFree(pInfo);
    return iResult;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(DecodeError)
}

BOOL IsSSLServerName(
    IN PCCERT_CONTEXT pCertContext,
    IN LPCWSTR pwszServerName
    )
{
    PCERT_INFO pCertInfo = pCertContext->pCertInfo;
    DWORD dwCertEncodingType = pCertContext->dwCertEncodingType;
    PCERT_EXTENSION pExt;

    pExt = CertFindExtension(
        szOID_SUBJECT_ALT_NAME2,
        pCertInfo->cExtension,
        pCertInfo->rgExtension
        );

    if (NULL == pExt) {
        pExt = CertFindExtension(
            szOID_SUBJECT_ALT_NAME,
            pCertInfo->cExtension,
            pCertInfo->rgExtension
            );
    }

    if (pExt) {
        int iResult;
        iResult = IsSSLServerNameInAltName(dwCertEncodingType,
            &pExt->Value, pwszServerName);

        if (0 < iResult)
            return TRUE;
        else if (0 == iResult)
            return FALSE;
        // else
        //  AltName didn't have any DNS_NAME choices
    }

    return IsSSLServerNameInNameInfo(dwCertEncodingType,
                &pCertInfo->Subject, pwszServerName);
}


BOOL
WINAPI
CertDllVerifySSLCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    DWORD dwError;
    DWORD dwFlags;
    DWORD fdwChecks;
    LONG lChainIndex = -1;
    LONG lElementIndex = -1;

    SSL_EXTRA_CERT_CHAIN_POLICY_PARA NullSSLExtraPara;
    PSSL_EXTRA_CERT_CHAIN_POLICY_PARA pSSLExtraPara;    // not allocated

    CERT_CHAIN_POLICY_PARA BasePolicyPara;
    memset(&BasePolicyPara, 0, sizeof(BasePolicyPara));
    BasePolicyPara.cbSize = sizeof(BasePolicyPara);

    CERT_CHAIN_POLICY_STATUS BasePolicyStatus;
    memset(&BasePolicyStatus, 0, sizeof(BasePolicyStatus));
    BasePolicyStatus.cbSize = sizeof(BasePolicyStatus);


    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, dwFlags) <
            pPolicyPara->cbSize)
        dwFlags = pPolicyPara->dwFlags;
    else
        dwFlags = 0;

    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, pvExtraPolicyPara) <
            pPolicyPara->cbSize && pPolicyPara->pvExtraPolicyPara) {
        pSSLExtraPara =
            (PSSL_EXTRA_CERT_CHAIN_POLICY_PARA) pPolicyPara->pvExtraPolicyPara;
        if (offsetof(SSL_EXTRA_CERT_CHAIN_POLICY_PARA, pwszServerName) >=
                pSSLExtraPara->cbSize) {
            SetLastError((DWORD) ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    } else {
        pSSLExtraPara = &NullSSLExtraPara;
        memset(&NullSSLExtraPara, 0, sizeof(NullSSLExtraPara));
        NullSSLExtraPara.cbSize = sizeof(NullSSLExtraPara);
        NullSSLExtraPara.dwAuthType = AUTHTYPE_SERVER;
    }
        
    fdwChecks = pSSLExtraPara->fdwChecks;
    if (fdwChecks) {
        if (fdwChecks & SECURITY_FLAG_IGNORE_UNKNOWN_CA)
            // 11-Nov-98 per Sanjay Shenoy removed
            // CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG;
            dwFlags |= CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG;

        if (fdwChecks & SECURITY_FLAG_IGNORE_WRONG_USAGE)
            dwFlags |= CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG;
        if (fdwChecks & SECURITY_FLAG_IGNORE_CERT_DATE_INVALID)
            dwFlags |= CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS;
        if (fdwChecks & SECURITY_FLAG_IGNORE_CERT_CN_INVALID)
            dwFlags |= CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG;
    }

    // Do the basic chain policy verification. SSL overrides
    // the defaults for the following:
    dwFlags |=
        CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG |
        CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG;

    BasePolicyPara.dwFlags = dwFlags;
    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_BASE,
            pChainContext,
            &BasePolicyPara,
            &BasePolicyStatus
            ))
        return FALSE;
    if (dwError = BasePolicyStatus.dwError) {
        // Map to errors understood by wininet
        switch (dwError) {
            case CERT_E_CHAINING:
                dwError = (DWORD) CERT_E_UNTRUSTEDROOT;
                break;
            case CERT_E_INVALID_NAME:
                dwError = (DWORD) CERT_E_CN_NO_MATCH;
                break;
            case CERT_E_INVALID_POLICY:
                dwError = (DWORD) CERT_E_PURPOSE;
                break;
            case TRUST_E_BASIC_CONSTRAINTS:
                dwError = (DWORD) CERT_E_ROLE;
                break;
            default:
                break;
        }

        lChainIndex = BasePolicyStatus.lChainIndex;
        lElementIndex = BasePolicyStatus.lElementIndex;
        if (CRYPT_E_NO_REVOCATION_CHECK != dwError &&
                CRYPT_E_REVOCATION_OFFLINE != dwError)
            goto CommonReturn;
        // else
        //  for NO_REVOCATION or REVOCATION_OFFLINE let
        //  ServerName errors take precedence
    }
        

    // Note, this policy can also be used for LDAP ServerName strings. These
    // strings can have the following syntax:
    //   svc-class/host/service-name[@domain]
    //
    // Will parse the ServerName as follows:
    //   take everything after the last forward slash and before the "@"
    //   (if any).

    if (pSSLExtraPara->pwszServerName) {
        DWORD cbServerName;
        LPWSTR pwszAllocServerName = NULL;
        LPWSTR pwszServerName = NULL;
        LPWSTR pwsz;
        WCHAR wc;

        cbServerName = (wcslen(pSSLExtraPara->pwszServerName) + 1) *
            sizeof(WCHAR);

        pwszAllocServerName = (LPWSTR) PkiNonzeroAlloc(cbServerName);
        if (NULL == pwszAllocServerName) {
            dwError = (DWORD) E_OUTOFMEMORY;
            goto EndCertError;
        }
        pwszServerName = pwszAllocServerName;

        memcpy(pwszServerName, pSSLExtraPara->pwszServerName, cbServerName);

        for (pwsz = pwszServerName; wc = *pwsz; pwsz++) {
            if (L'/' == wc)
                pwszServerName = pwsz + 1;
            else if (L'@' == wc) {
                *pwsz = L'\0';
                break;
            }
        }

        if (0 == (fdwChecks & SECURITY_FLAG_IGNORE_CERT_CN_INVALID)) {
            if (!IsSSLServerName(
                    pChainContext->rgpChain[0]->rgpElement[0]->pCertContext,
                    pwszServerName
                    )) {
                PkiFree(pwszAllocServerName);
                dwError = (DWORD) CERT_E_CN_NO_MATCH;
                goto EndCertError;
            }
        }

        PkiFree(pwszAllocServerName);
    }

CommonReturn:
    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);
    pPolicyStatus->dwError = dwError;
    pPolicyStatus->lChainIndex = lChainIndex;
    pPolicyStatus->lElementIndex = lElementIndex;

    return TRUE;

EndCertError:
    lChainIndex = 0;
    lElementIndex = 0;
    goto CommonReturn;
}


//+=========================================================================
//  CertDllVerifyNTAuthCertificateChainPolicy Functions
//==========================================================================

// Open and cache the store containing CAs trusted for NT Authentication.
// Also, enable auto resync for the cached store.
HCERTSTORE OpenNTAuthStore()
{
    HCERTSTORE hStore;

    hStore = hNTAuthCertStore;
    if (NULL == hStore) {
        // Serialize opening of the cached store
        CertPolicyLock();

        hStore = hNTAuthCertStore;
        if (NULL == hStore) {
            hStore = CertOpenStore(
                CERT_STORE_PROV_SYSTEM_REGISTRY_W, 
                0,                  // dwEncodingType
                0,                  // hCryptProv
                CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE |
                    CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                L"NTAuth"
                );
            if (hStore) {
                CertControlStore(
                    hStore,
                    0,                  // dwFlags
                    CERT_STORE_CTRL_AUTO_RESYNC,
                    NULL                // pvCtrlPara
                    );
                hNTAuthCertStore = hStore;
            }
        }

        CertPolicyUnlock();
    }

    return hStore;
}

BOOL
WINAPI
CertDllVerifyNTAuthCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    BOOL fResult;
    DWORD dwError;
    LONG lChainIndex = 0;
    LONG lElementIndex = 0;
    PCERT_SIMPLE_CHAIN pChain;

    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);

    if (!CertDllVerifyBaseCertificateChainPolicy(
            pszPolicyOID,
            pChainContext,
            pPolicyPara,
            pPolicyStatus
            ))
        return FALSE;
    if (dwError = pPolicyStatus->dwError) {
        if (CRYPT_E_NO_REVOCATION_CHECK != dwError &&
                CRYPT_E_REVOCATION_OFFLINE != dwError)
            return TRUE;
        // else
        //  for NO_REVOCATION or REVOCATION_OFFLINE let
        //  following errors take precedence

        // Remember revocation indices
        lChainIndex = pPolicyStatus->lChainIndex;
        lElementIndex = pPolicyStatus->lElementIndex;
    }

    fResult = CertDllVerifyBasicConstraintsCertificateChainPolicy(
        pszPolicyOID,
        pChainContext,
        pPolicyPara,
        pPolicyStatus
        );
    if (!fResult || 0 != pPolicyStatus->dwError)
        return fResult;

    // Check if we have a CA certificate that issued the end entity
    // certificate. Its Element[1] in the first simple chain.
    pChain = pChainContext->rgpChain[0];
    if (2 > pChain->cElement)
        goto MissingCACert;

    if (IPR_IsNTAuthRequiredDisabled() &&
            (pChain->TrustStatus.dwInfoStatus &
                CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS)) {
        // If its not required that the issuing CA be in the NTAuth store
        // and there are valid name constraints for all name spaces including
        // UPN, then, we can skip the test for being in the NTAuth store.
        ;
    } else {
        PCCERT_CONTEXT pFindCert;           // freed if found
        HCERTSTORE hStore;                  // cached, don't close
        BYTE rgbCertHash[SHA1_HASH_LEN];
        CRYPT_HASH_BLOB CertHash;

        // Open the store where the CA certificate must exist to be trusted.
        // Note, this store is cached with auto resync enabled.
        if (NULL == (hStore = OpenNTAuthStore()))
            goto OpenNTAuthStoreError;

        // Try to find the CA certificate in the store
        CertHash.cbData = sizeof(rgbCertHash);
        CertHash.pbData = rgbCertHash;
        if (!CertGetCertificateContextProperty(
                pChain->rgpElement[1]->pCertContext,
                CERT_SHA1_HASH_PROP_ID,
                CertHash.pbData,
                &CertHash.cbData
                ))
            goto GetHashPropertyError;
        if (NULL == (pFindCert = CertFindCertificateInStore(
                hStore,
                0,                      // dwCertEncodingType
                0,                      // dwFindFlags
                CERT_FIND_SHA1_HASH,
                &CertHash,
                NULL                    // pPrevCertContext
                )))
            goto UntrustedNTAuthCert;
        CertFreeCertificateContext(pFindCert);
    }

    if (dwError) {
        // For NO_REVOCATION or REVOCATION_OFFLINE update indices
        pPolicyStatus->lChainIndex = lChainIndex;
        pPolicyStatus->lElementIndex = lElementIndex;
    }
CommonReturn:
    pPolicyStatus->dwError = dwError;
    return TRUE;

ErrorReturn:
    pPolicyStatus->lChainIndex = 0;
    pPolicyStatus->lElementIndex = 1;
MissingCACert:
    dwError = (DWORD) CERT_E_UNTRUSTEDCA;
    goto CommonReturn;
TRACE_ERROR(OpenNTAuthStoreError)
TRACE_ERROR(GetHashPropertyError)
TRACE_ERROR(UntrustedNTAuthCert)
}

//+-------------------------------------------------------------------------
//  SHA1 Key Identifier of the Microsoft roots
//--------------------------------------------------------------------------
const BYTE MicrosoftRootList[][SHA1_HASH_LEN] = {
    // The following is the sha1 key identifier for the Microsoft root
    {
        0x4A, 0x5C, 0x75, 0x22, 0xAA, 0x46, 0xBF, 0xA4, 0x08, 0x9D,
        0x39, 0x97, 0x4E, 0xBD, 0xB4, 0xA3, 0x60, 0xF7, 0xA0, 0x1D
    },

    // The following is the sha1 key identifier for the Microsoft root
    // generated in 2001 with a key length of 4096 bits
    {
        0x0E, 0xAC, 0x82, 0x60, 0x40, 0x56, 0x27, 0x97, 0xE5, 0x25,
        0x13, 0xFC, 0x2A, 0xE1, 0x0A, 0x53, 0x95, 0x59, 0xE4, 0xA4
    },
};

#define MICROSOFT_ROOT_LIST_CNT  (sizeof(MicrosoftRootList) / \
                                        sizeof(MicrosoftRootList[0]))

//+-------------------------------------------------------------------------
//  SHA1 Key Identifier of the Microsoft test roots
//--------------------------------------------------------------------------
const BYTE MicrosoftTestRootList[][SHA1_HASH_LEN] = {
    // The following is the sha1 key for the Microsoft Test Root:
    //      CN=Microsoft Test Root Authority
    //      OU=Microsoft Corporation
    //      OU=Copyright (c) 1999 Microsoft Corp.
    //
    //  NotBefore:: Sat Jan 09 23:00:00 1999
    //  NotAfter::  Wed Dec 30 23:00:00 2020
    {
        0x22, 0xCD, 0x37, 0xF1, 0xB1, 0x47, 0x50, 0xAE, 0x53, 0x7C,
        0x8C, 0x6A, 0x03, 0x67, 0x47, 0xE2, 0xB7, 0x1E, 0x17, 0xB7
    },
};

#define MICROSOFT_TEST_ROOT_LIST_CNT  (sizeof(MicrosoftTestRootList) / \
                                        sizeof(MicrosoftTestRootList[0]))


BOOL
WINAPI
CertDllVerifyMicrosoftRootCertificateChainPolicy(
    IN LPCSTR pszPolicyOID,
    IN PCCERT_CHAIN_CONTEXT pChainContext,
    IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
    IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus
    )
{
    DWORD dwError;
    LONG lElementIndex;
    PCERT_SIMPLE_CHAIN pChain;
    DWORD cChainElement;
    PCCERT_CONTEXT pCert;   // not refCount'ed
    BYTE rgbKeyId[SHA1_HASH_LEN];
    DWORD cbKeyId;
    DWORD i;
    DWORD dwFlags;

    assert(pPolicyStatus && offsetof(CERT_CHAIN_POLICY_STATUS, lElementIndex) <
            pPolicyStatus->cbSize);

    pChain = pChainContext->rgpChain[0];
    cChainElement = pChain->cElement;

    // Check that the top level certificate contains the public
    // key for the Microsoft root.
    pCert = pChain->rgpElement[cChainElement - 1]->pCertContext;

    cbKeyId = SHA1_HASH_LEN;
    if (!CryptHashPublicKeyInfo(
            NULL,               // hCryptProv
            CALG_SHA1,
            0,                  // dwFlags
            X509_ASN_ENCODING,
            &pCert->pCertInfo->SubjectPublicKeyInfo,
            rgbKeyId,
            &cbKeyId) || SHA1_HASH_LEN != cbKeyId)
        goto HashPublicKeyInfoError;

    for (i = 0; i < MICROSOFT_ROOT_LIST_CNT; i++) {
        if (0 == memcmp(MicrosoftRootList[i], rgbKeyId, SHA1_HASH_LEN))
            goto SuccessReturn;
    }

    if (pPolicyPara && offsetof(CERT_CHAIN_POLICY_PARA, dwFlags) <
            pPolicyPara->cbSize)
        dwFlags = pPolicyPara->dwFlags;
    else
        dwFlags = 0;

    if (dwFlags & MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG) {
        for (i = 0; i < MICROSOFT_TEST_ROOT_LIST_CNT; i++) {
            if (0 == memcmp(MicrosoftTestRootList[i], rgbKeyId, SHA1_HASH_LEN))
                goto SuccessReturn;
        }
    }

    goto InvalidMicrosoftRoot;

SuccessReturn:
    dwError = 0;
    lElementIndex = 0;
CommonReturn:
    pPolicyStatus->dwError = dwError;
    pPolicyStatus->lChainIndex = 0;
    pPolicyStatus->lElementIndex = lElementIndex;
    return TRUE;

ErrorReturn:
    dwError = (DWORD) CERT_E_UNTRUSTEDROOT;
    lElementIndex = cChainElement - 1;
    goto CommonReturn;
TRACE_ERROR(HashPublicKeyInfoError)
TRACE_ERROR(InvalidMicrosoftRoot)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\rootlist.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       rootlist.cpp
//
//  Contents:   Signed List of Trusted Roots Helper Functions
//
//
//  Functions:  IRL_VerifyAuthRootAutoUpdateCtl
//
//  History:    01-Aug-99   philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

//+-------------------------------------------------------------------------
// If the certificate has an EKU extension, returns an allocated and
// decoded EKU. Otherwise, returns NULL.
//
// PkiFree() must be called to free the returned EKU.
//--------------------------------------------------------------------------
STATIC
PCERT_ENHKEY_USAGE
WINAPI
GetAndAllocCertEKUExt(
    IN PCCERT_CONTEXT pCert
    )
{
    PCERT_ENHKEY_USAGE pUsage = NULL;
    DWORD cbUsage;

    cbUsage = 0;
    if (!CertGetEnhancedKeyUsage(
            pCert,
            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
            NULL,                                   // pUsage
            &cbUsage) || 0 == cbUsage)
        goto GetEnhancedKeyUsageError;
    if (NULL == (pUsage = (PCERT_ENHKEY_USAGE) PkiNonzeroAlloc(cbUsage)))
        goto OutOfMemory;
    if (!CertGetEnhancedKeyUsage(
            pCert,
            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
            pUsage,
            &cbUsage))
        goto GetEnhancedKeyUsageError;

CommonReturn:
    return pUsage;
ErrorReturn:
    if (pUsage) {
        PkiFree(pUsage);
        pUsage = NULL;
    }
    goto CommonReturn;

SET_ERROR(GetEnhancedKeyUsageError, CERT_E_WRONG_USAGE)
TRACE_ERROR(OutOfMemory)
}


//+-------------------------------------------------------------------------
//  The signature of the CTL is verified. The signer of the CTL is verified
//  up to a trusted root containing the predefined Microsoft public key.
//
//  The signer and intermediate certificates must have the
//  szOID_ROOT_LIST_SIGNER enhanced key usage extension.
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
VerifyAuthRootAutoUpdateCtlSigner(
    IN HCRYPTMSG hCryptMsg
    )
{
    BOOL fResult;
    DWORD dwLastError = 0;
    HCERTSTORE hMsgStore = NULL;
    PCCERT_CONTEXT pSignerCert = NULL;
    LPSTR pszUsageOID;
    CERT_CHAIN_PARA ChainPara;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    PCERT_SIMPLE_CHAIN pChain;
    DWORD cChainElement;
    CERT_CHAIN_POLICY_PARA BasePolicyPara;
    CERT_CHAIN_POLICY_STATUS BasePolicyStatus;
    CERT_CHAIN_POLICY_PARA MicrosoftRootPolicyPara;
    CERT_CHAIN_POLICY_STATUS MicrosoftRootPolicyStatus;
    PCERT_ENHKEY_USAGE pUsage = NULL;
    DWORD i;

    if (NULL == (hMsgStore = CertOpenStore(
            CERT_STORE_PROV_MSG,
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            0,                      // hCryptProv
            0,                      // dwFlags
            hCryptMsg               // pvPara
            )))
        goto OpenMsgStoreError;

    if (!CryptMsgGetAndVerifySigner(
            hCryptMsg,
            0,                      // cSignerStore
            NULL,                   // rghSignerStore
            0,                      // dwFlags
            &pSignerCert,
            NULL                    // pdwSignerIndex
            ))
        goto CryptMsgGetAndVerifySignerError;

    pszUsageOID = szOID_ROOT_LIST_SIGNER;
    memset(&ChainPara, 0, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);
    ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    ChainPara.RequestedUsage.Usage.cUsageIdentifier = 1;
    ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = &pszUsageOID;

    if (!CertGetCertificateChain(
            NULL,                       // hChainEngine
            pSignerCert,
            NULL,                       // pTime
            hMsgStore,
            &ChainPara,
            CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE,
            NULL,                       // pvReserved
            &pChainContext
            ))
        goto GetChainError;

    // Do the basic chain policy verification
    memset(&BasePolicyPara, 0, sizeof(BasePolicyPara));
    BasePolicyPara.cbSize = sizeof(BasePolicyPara);

    // We explicitly check for the Microsoft Root below. It doesn't need
    // to be in the root store.
    BasePolicyPara.dwFlags = 
        CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG |
        CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG;

    memset(&BasePolicyStatus, 0, sizeof(BasePolicyStatus));
    BasePolicyStatus.cbSize = sizeof(BasePolicyStatus);

    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_BASE,
            pChainContext,
            &BasePolicyPara,
            &BasePolicyStatus
            ))
        goto VerifyChainBasePolicyError;
    if (0 != BasePolicyStatus.dwError)
        goto ChainBasePolicyError;

    // Check that we have more than just the signer cert.
    pChain = pChainContext->rgpChain[0];
    cChainElement = pChain->cElement;
    if (2 > cChainElement)
        goto MissingSignerChainCertsError;

    // Check that the top level certificate contains the public
    // key for the Microsoft root.
    memset(&MicrosoftRootPolicyPara, 0, sizeof(MicrosoftRootPolicyPara));
    MicrosoftRootPolicyPara.cbSize = sizeof(MicrosoftRootPolicyPara);
    memset(&MicrosoftRootPolicyStatus, 0, sizeof(MicrosoftRootPolicyStatus));
    MicrosoftRootPolicyStatus.cbSize = sizeof(MicrosoftRootPolicyStatus);

    if (!CertVerifyCertificateChainPolicy(
            CERT_CHAIN_POLICY_MICROSOFT_ROOT,
            pChainContext,
            &MicrosoftRootPolicyPara,
            &MicrosoftRootPolicyStatus
            ))
        goto VerifyChainMicrosoftRootPolicyError;
    if (0 != MicrosoftRootPolicyStatus.dwError)
        goto ChainMicrosoftRootPolicyError;


    // Check that the signer and intermediate certs have the RootListSigner
    // Usage extension
    for (i = 0; i < cChainElement - 1; i++) {
        PCCERT_CONTEXT pCert;   // not refCount'ed
        DWORD j;

        pCert = pChain->rgpElement[i]->pCertContext;

        pUsage = GetAndAllocCertEKUExt(pCert);
        if (NULL == pUsage)
            goto GetAndAllocCertEKUExtError;

        for (j = 0; j < pUsage->cUsageIdentifier; j++) {
            if (0 == strcmp(szOID_ROOT_LIST_SIGNER,
                    pUsage->rgpszUsageIdentifier[j]))
                break;
        }

        if (j == pUsage->cUsageIdentifier)
            goto MissingRootListSignerUsageError;

        PkiFree(pUsage);
        pUsage = NULL;
    }

    fResult = TRUE;
CommonReturn:
    if (pChainContext)
        CertFreeCertificateChain(pChainContext);
    if (pUsage)
        PkiFree(pUsage);

    if (pSignerCert)
        CertFreeCertificateContext(pSignerCert);

    if (hMsgStore)
        CertCloseStore(hMsgStore, 0);

    SetLastError(dwLastError);
    return fResult;
ErrorReturn:
    dwLastError = GetLastError();
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenMsgStoreError)
TRACE_ERROR(CryptMsgGetAndVerifySignerError)
TRACE_ERROR(GetChainError)
TRACE_ERROR(VerifyChainBasePolicyError)
SET_ERROR_VAR(ChainBasePolicyError, BasePolicyStatus.dwError)
TRACE_ERROR(VerifyChainMicrosoftRootPolicyError)
SET_ERROR_VAR(ChainMicrosoftRootPolicyError, MicrosoftRootPolicyStatus.dwError)
SET_ERROR(MissingSignerChainCertsError, CERT_E_CHAINING)
TRACE_ERROR(GetAndAllocCertEKUExtError)
SET_ERROR(MissingRootListSignerUsageError, CERT_E_WRONG_USAGE)
}

//+-------------------------------------------------------------------------
// Returns TRUE if all the CTL fields are valid. Checks for the following:
//  - The SubjectUsage is szOID_ROOT_LIST_SIGNER
//  - If NextUpdate isn't NULL, that the CTL is still time valid
//  - Only allow roots identified by their sha1 hash
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
VerifyAuthRootAutoUpdateCtlFields(
    IN PCTL_INFO pCtlInfo
    )
{
    BOOL fResult;

    // Must have the szOID_ROOT_LIST_SIGNER usage
    if (1 != pCtlInfo->SubjectUsage.cUsageIdentifier ||
            0 != strcmp(szOID_ROOT_LIST_SIGNER,
                    pCtlInfo->SubjectUsage.rgpszUsageIdentifier[0]))
        goto InvalidSubjectUsageError;


    // If NextUpdate is present, verify that the CTL hasn't expired.
    if (pCtlInfo->NextUpdate.dwLowDateTime ||
                pCtlInfo->NextUpdate.dwHighDateTime) {
        SYSTEMTIME SystemTime;
        FILETIME FileTime;

        GetSystemTime(&SystemTime);
        SystemTimeToFileTime(&SystemTime, &FileTime);

        if (CompareFileTime(&FileTime, &pCtlInfo->NextUpdate) > 0)
            goto ExpiredCtlError;
    }

    // Only allow roots identified by their sha1 hash
    if (0 != strcmp(szOID_OIWSEC_sha1,
            pCtlInfo->SubjectAlgorithm.pszObjId))
        goto InvalidSubjectAlgorithm;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidSubjectUsageError, ERROR_INVALID_DATA)
SET_ERROR(ExpiredCtlError, CERT_E_EXPIRED)
SET_ERROR(InvalidSubjectAlgorithm, ERROR_INVALID_DATA)
}

//+-------------------------------------------------------------------------
// Returns TRUE if the CTL doesn't have any critical extensions.
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
VerifyAuthRootAutoUpdateCtlExtensions(
    IN PCTL_INFO pCtlInfo
    )
{
    BOOL fResult;
    PCERT_EXTENSION pExt;
    DWORD cExt;

    // Verify the extensions
    for (cExt = pCtlInfo->cExtension,
         pExt = pCtlInfo->rgExtension; 0 < cExt; cExt--, pExt++)
    {
        if (pExt->fCritical) {
            goto CriticalExtensionError;
        }
    }

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(CriticalExtensionError, ERROR_INVALID_DATA)
}



//+-------------------------------------------------------------------------
//  Verifies that the CTL contains a valid list of AuthRoots used for
//  Auto Update.
//
//  The signature of the CTL is verified. The signer of the CTL is verified
//  up to a trusted root containing the predefined Microsoft public key.
//  The signer and intermediate certificates must have the
//  szOID_ROOT_LIST_SIGNER enhanced key usage extension.
//
//  The CTL fields are validated as follows:
//   - The SubjectUsage is szOID_ROOT_LIST_SIGNER
//   - If NextUpdate isn't NULL, that the CTL is still time valid
//   - Only allow roots identified by their sha1 hash
//
//  If the CTL contains any critical extensions, then, the
//  CTL verification fails.
//--------------------------------------------------------------------------
BOOL
WINAPI
IRL_VerifyAuthRootAutoUpdateCtl(
    IN PCCTL_CONTEXT pCtl
    )
{
    BOOL fResult;
    PCTL_INFO pCtlInfo;                 // not allocated

    if (!VerifyAuthRootAutoUpdateCtlSigner(pCtl->hCryptMsg))
        goto VerifyCtlSignerError;

    pCtlInfo = pCtl->pCtlInfo;

    if (!VerifyAuthRootAutoUpdateCtlFields(pCtlInfo))
        goto VerifyCtlFieldsError;
    if (!VerifyAuthRootAutoUpdateCtlExtensions(pCtlInfo))
        goto VerifyCtlExtensionsError;

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(VerifyCtlSignerError)
TRACE_ERROR(VerifyCtlFieldsError)
TRACE_ERROR(VerifyCtlExtensionsError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\revfunc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       revfunc.cpp
//
//  Contents:   Certificate Revocation Dispatch Functions
//
//  Functions:  I_CertRevFuncDllMain
//              CertVerifyRevocation
//
//  History:    12-Dec-96    philh   created
//              11-Mar-97    philh   changed signature of CertVerifyRevocation
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

static HCRYPTOIDFUNCSET hRevFuncSet;

typedef BOOL (WINAPI *PFN_CERT_DLL_VERIFY_REVOCATION)(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwFlags,
    IN OPTIONAL PCERT_REVOCATION_PARA pRevPara,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    );

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertRevFuncDllMain(
        HMODULE hModule,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        if (NULL == (hRevFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_VERIFY_REVOCATION_FUNC,
                0)))                                // dwFlags
            goto CryptInitOIDFunctionSetError;
        break;

    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInitOIDFunctionSetError)
}

static inline void ZeroRevStatus(OUT PCERT_REVOCATION_STATUS pRevStatus)
{
    DWORD cbSize = pRevStatus->cbSize;
    
    memset(pRevStatus, 0, cbSize);
    pRevStatus->cbSize = cbSize;
}

// Remember the first "interesting" error. *pdwError is initialized to
// CRYPT_E_NO_REVOCATION_DLL.
static void UpdateNoRevocationCheckStatus(
    IN PCERT_REVOCATION_STATUS pRevStatus,
    IN OUT DWORD *pdwError,
    IN OUT DWORD *pdwReason,
    IN OUT BOOL *pfHasFreshnessTime,
    IN OUT DWORD *pdwFreshnessTime
    )
{
    if (pRevStatus->dwError &&
            (*pdwError == (DWORD) CRYPT_E_NO_REVOCATION_DLL ||
                *pdwError == (DWORD) CRYPT_E_NO_REVOCATION_CHECK)) {
        *pdwError = pRevStatus->dwError;
        *pdwReason = pRevStatus->dwReason;

        if (pRevStatus->cbSize >= STRUCT_CBSIZE(CERT_REVOCATION_STATUS,
                dwFreshnessTime)) {
            *pfHasFreshnessTime = pRevStatus->fHasFreshnessTime;
            *pdwFreshnessTime = pRevStatus->dwFreshnessTime;
        }
    }
}

static BOOL VerifyDefaultRevocation(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwFlags,
    IN FILETIME *pftEndUrlRetrieval,
    IN OPTIONAL PCERT_REVOCATION_PARA pRevPara,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    )
{
    BOOL fResult;
    DWORD dwError = (DWORD) CRYPT_E_NO_REVOCATION_DLL;
    DWORD dwReason = 0;
    BOOL fHasFreshnessTime = FALSE;
    DWORD dwFreshnessTime = 0;
    LPWSTR pwszDllList;       // _alloca'ed
    DWORD cchDllList;
    DWORD cchDll;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    // Iterate through the installed default functions.
    // Setting pwszDll to NULL searches the installed list. Setting
    // hFuncAddr to NULL starts the search at the beginning.
    hFuncAddr = NULL;
    while (CryptGetDefaultOIDFunctionAddress(
                hRevFuncSet,
                dwEncodingType,
                NULL,               // pwszDll
                0,                  // dwFlags
                &pvFuncAddr,
                &hFuncAddr)) {
        ZeroRevStatus(pRevStatus);

        if (dwFlags & CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG) {
            pRevPara->dwUrlRetrievalTimeout =
                I_CryptRemainingMilliseconds(pftEndUrlRetrieval);
            if (0 == pRevPara->dwUrlRetrievalTimeout)
                pRevPara->dwUrlRetrievalTimeout = 1;
        }

        fResult = ((PFN_CERT_DLL_VERIFY_REVOCATION) pvFuncAddr)(
                dwEncodingType,
                dwRevType,
                cContext,
                rgpvContext,
                dwFlags,
                pRevPara,
                pRevStatus);
        if (fResult || CRYPT_E_REVOKED == pRevStatus->dwError ||
                0 < pRevStatus->dwIndex) {
            // All contexts successfully checked, one of the contexts
            // was revoked or successfully able to check at least one
            // of the contexts.
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);
            goto CommonReturn;
        } else
            // Unable to check revocation for this installed
            // function. However, remember any "interesting"
            // errors such as, offline.
            UpdateNoRevocationCheckStatus(pRevStatus, &dwError, &dwReason,
                &fHasFreshnessTime, &dwFreshnessTime);
    }

    if (!CryptGetDefaultOIDDllList(
            hRevFuncSet,
            dwEncodingType,
            NULL,               // pszDllList
            &cchDllList)) goto GetDllListError;
    __try {
        pwszDllList = (LPWSTR) _alloca(cchDllList * sizeof(WCHAR));
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        goto OutOfMemory;
    }
    if (!CryptGetDefaultOIDDllList(
            hRevFuncSet,
            dwEncodingType,
            pwszDllList,
            &cchDllList)) goto GetDllListError;

    for (; 0 != (cchDll = wcslen(pwszDllList)); pwszDllList += cchDll + 1) {
        if (CryptGetDefaultOIDFunctionAddress(
                hRevFuncSet,
                dwEncodingType,
                pwszDllList,
                0,              // dwFlags
                &pvFuncAddr,
                &hFuncAddr)) {
            ZeroRevStatus(pRevStatus);

            if (dwFlags & CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG) {
                pRevPara->dwUrlRetrievalTimeout =
                    I_CryptRemainingMilliseconds(pftEndUrlRetrieval);
                if (0 == pRevPara->dwUrlRetrievalTimeout)
                    pRevPara->dwUrlRetrievalTimeout = 1;
            }

            fResult = ((PFN_CERT_DLL_VERIFY_REVOCATION) pvFuncAddr)(
                    dwEncodingType,
                    dwRevType,
                    cContext,
                    rgpvContext,
                    dwFlags,
                    pRevPara,
                    pRevStatus);
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);
            if (fResult || CRYPT_E_REVOKED == pRevStatus->dwError ||
                    0 < pRevStatus->dwIndex)
                // All contexts successfully checked, one of the contexts
                // was revoked or successfully able to check at least one
                // of the contexts.
                goto CommonReturn;
            else
                // Unable to check revocation for this registered
                // function. However, remember any "interesting"
                // errors such as, offline.
                UpdateNoRevocationCheckStatus(pRevStatus, &dwError, &dwReason,
                    &fHasFreshnessTime, &dwFreshnessTime);
        }
    }

    goto ErrorReturn;

CommonReturn:
    return fResult;
ErrorReturn:
    pRevStatus->dwIndex = 0;
    pRevStatus->dwError = dwError;
    pRevStatus->dwReason = dwReason;

    if (pRevStatus->cbSize >= STRUCT_CBSIZE(CERT_REVOCATION_STATUS,
            dwFreshnessTime)) {
        pRevStatus->fHasFreshnessTime = fHasFreshnessTime;
        pRevStatus->dwFreshnessTime = dwFreshnessTime;
    }

    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetDllListError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Verifies the array of contexts for revocation. The dwRevType parameter
//  indicates the type of the context data structure passed in rgpvContext.
//  Currently only the revocation of certificates is defined.
//
//  If the CERT_VERIFY_REV_CHAIN_FLAG flag is set, then, CertVerifyRevocation
//  is verifying a chain of certs where, rgpvContext[i + 1] is the issuer
//  of rgpvContext[i]. Otherwise, CertVerifyRevocation makes no assumptions
//  about the order of the contexts.
//
//  To assist in finding the issuer, the pRevPara may optionally be set. See
//  the CERT_REVOCATION_PARA data structure for details.
//
//  The contexts must contain enough information to allow the
//  installable or registered revocation DLLs to find the revocation server. For
//  certificates, this information would normally be conveyed in an
//  extension such as the IETF's AuthorityInfoAccess extension.
//
//  CertVerifyRevocation returns TRUE if all of the contexts were successfully
//  checked and none were revoked. Otherwise, returns FALSE and updates the
//  returned pRevStatus data structure as follows:
//    dwIndex
//      Index of the first context that was revoked or unable to
//      be checked for revocation
//    dwError
//      Error status. LastError is also set to this error status.
//      dwError can be set to one of the following error codes defined
//      in winerror.h:
//        ERROR_SUCCESS - good context
//        CRYPT_E_REVOKED - context was revoked. dwReason contains the
//           reason for revocation
//        CRYPT_E_REVOCATION_OFFLINE - unable to connect to the
//           revocation server
//        CRYPT_E_NOT_IN_REVOCATION_DATABASE - the context to be checked
//           was not found in the revocation server's database.
//        CRYPT_E_NO_REVOCATION_CHECK - the called revocation function
//           wasn't able to do a revocation check on the context
//        CRYPT_E_NO_REVOCATION_DLL - no installed or registered Dll was
//           found to verify revocation
//    dwReason
//      The dwReason is currently only set for CRYPT_E_REVOKED and contains
//      the reason why the context was revoked. May be one of the following
//      CRL reasons defined by the CRL Reason Code extension ("2.5.29.21")
//          CRL_REASON_UNSPECIFIED              0
//          CRL_REASON_KEY_COMPROMISE           1
//          CRL_REASON_CA_COMPROMISE            2
//          CRL_REASON_AFFILIATION_CHANGED      3
//          CRL_REASON_SUPERSEDED               4
//          CRL_REASON_CESSATION_OF_OPERATION   5
//          CRL_REASON_CERTIFICATE_HOLD         6
//
//  For each entry in rgpvContext, CertVerifyRevocation iterates
//  through the CRYPT_OID_VERIFY_REVOCATION_FUNC
//  function set's list of installed DEFAULT functions.
//  CryptGetDefaultOIDFunctionAddress is called with pwszDll = NULL. If no
//  installed functions are found capable of doing the revocation verification,
//  CryptVerifyRevocation iterates through CRYPT_OID_VERIFY_REVOCATION_FUNC's
//  list of registered DEFAULT Dlls. CryptGetDefaultOIDDllList is called to
//  get the list. CryptGetDefaultOIDFunctionAddress is called to load the Dll.
//
//  The called functions have the same signature as CertVerifyRevocation. A
//  called function returns TRUE if it was able to successfully check all of
//  the contexts and none were revoked. Otherwise, the called function returns
//  FALSE and updates pRevStatus. dwIndex is set to the index of
//  the first context that was found to be revoked or unable to be checked.
//  dwError and LastError are updated. For CRYPT_E_REVOKED, dwReason
//  is updated. Upon input to the called function, dwIndex, dwError and
//  dwReason have been zero'ed. cbSize has been checked to be >=
//  sizeof(CERT_REVOCATION_STATUS).
//  
//  If the called function returns FALSE, and dwError isn't set to
//  CRYPT_E_REVOKED, then, CertVerifyRevocation either continues on to the
//  next DLL in the list for a returned dwIndex of 0 or for a returned
//  dwIndex > 0, restarts the process of finding a verify function by
//  advancing the start of the context array to the returned dwIndex and
//  decrementing the count of remaining contexts.
//--------------------------------------------------------------------------
BOOL
WINAPI
CertVerifyRevocation(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwFlags,
    IN OPTIONAL PCERT_REVOCATION_PARA pRevPara,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    )
{
    BOOL fResult = FALSE;
    DWORD dwIndex;

    // Following are only used for CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG
    CERT_REVOCATION_PARA RevPara;
    FILETIME ftEndUrlRetrieval;

    assert(pRevStatus->cbSize >= STRUCT_CBSIZE(CERT_REVOCATION_STATUS,
            dwReason));
    if (pRevStatus->cbSize < STRUCT_CBSIZE(CERT_REVOCATION_STATUS,
            dwReason))
        goto InvalidArg;

    if (dwFlags & CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG) {
        // RevPara.dwUrlRetrievalTimeout will be updated with the remaining
        // timeout

        memset(&RevPara, 0, sizeof(RevPara));
        if (pRevPara != NULL)
            memcpy(&RevPara, pRevPara, min(pRevPara->cbSize, sizeof(RevPara)));
        RevPara.cbSize = sizeof(RevPara);
        if (0 == RevPara.dwUrlRetrievalTimeout)
            dwFlags &= ~CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG;
        else {
            FILETIME ftCurrent;

            GetSystemTimeAsFileTime(&ftCurrent);
            I_CryptIncrementFileTimeByMilliseconds(
                &ftCurrent, RevPara.dwUrlRetrievalTimeout, &ftEndUrlRetrieval);

            pRevPara = &RevPara;
        }
    }

    dwIndex = 0;
    while (dwIndex < cContext) {
        fResult = VerifyDefaultRevocation(
                dwEncodingType,
                dwRevType,
                cContext - dwIndex,
                &rgpvContext[dwIndex],
                dwFlags,
                &ftEndUrlRetrieval,
                pRevPara,
                pRevStatus
                );
        if (fResult)
            // All contexts successfully checked.
            break;
        else if (CRYPT_E_REVOKED == pRevStatus->dwError ||
                0 == pRevStatus->dwIndex) {
            // One of the contexts was revoked or unable to check the
            // dwIndex context.
            pRevStatus->dwIndex += dwIndex;
            SetLastError(pRevStatus->dwError);
            break;
        } else
            // Advance past the checked contexts
            dwIndex += pRevStatus->dwIndex;
    }

    if (dwIndex >= cContext) {
        // Able to check all the contexts
        fResult = TRUE;
        pRevStatus->dwIndex = 0;
        pRevStatus->dwError = 0;
        pRevStatus->dwReason = 0;
    }

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\rootlist.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       rootlist.h
//
//  Contents:   Signed List of Trusted Roots Helper Functions
//
//  History:    01-Aug-99   philh   created
//--------------------------------------------------------------------------

#ifndef __ROOTLIST_H__
#define __ROOTLIST_H__

//+-------------------------------------------------------------------------
//  Verifies that the CTL contains a valid list of AuthRoots used for
//  Auto Update.
//
//  The signature of the CTL is verified. The signer of the CTL is verified
//  up to a trusted root containing the predefined Microsoft public key.
//  The signer and intermediate certificates must have the
//  szOID_ROOT_LIST_SIGNER enhanced key usage extension.
//
//  The CTL fields are validated as follows:
//   - The SubjectUsage is szOID_ROOT_LIST_SIGNER
//   - If NextUpdate isn't NULL, that the CTL is still time valid
//   - Only allow roots identified by their sha1 hash
//
//  If the CTL contains any critical extensions, then, the
//  CTL verification fails.
//--------------------------------------------------------------------------
BOOL
WINAPI
IRL_VerifyAuthRootAutoUpdateCtl(
    IN PCCTL_CONTEXT pCtl
    );

#endif  // __ROOTLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------


#define         IDS_ROOT_MSG_BOX_TITLE                      6100
#define         IDS_ROOT_MSG_BOX_SUBJECT                    6110
#define         IDS_ROOT_MSG_BOX_ISSUER                     6120
#define         IDS_ROOT_MSG_BOX_SELF_ISSUED                6121
#define         IDS_ROOT_MSG_BOX_SERIAL_NUMBER              6130
#define         IDS_ROOT_MSG_BOX_SHA1_THUMBPRINT            6140
#define         IDS_ROOT_MSG_BOX_MD5_THUMBPRINT             6150
#define         IDS_ROOT_MSG_BOX_TIME_VALIDITY              6160
#define         IDS_ROOT_MSG_BOX_ADD_ACTION                 6170
#define         IDS_ROOT_MSG_BOX_DELETE_ACTION              6180
#define         IDS_ROOT_MSG_BOX_DELETE_UNKNOWN_PROT_ROOTS  6190

#define         IDS_INSTALLCA                               6200
#define         IDS_TOO_MANY_CA_CERTS                       6210

#define         IDS_ADD_ROOT_MSG_BOX_TITLE                  6250
#define         IDS_ADD_ROOT_MSG_BOX_INTRO                  6251
#define         IDS_ADD_ROOT_MSG_BOX_BODY_0                 6255
#define         IDS_ADD_ROOT_MSG_BOX_BODY_1                 6256
#define         IDS_ADD_ROOT_MSG_BOX_END_0                  6260
#define         IDS_ADD_ROOT_MSG_BOX_END_1                  6261

// Following resources are used to format chain extended error information
#define         IDS_INVALID_ISSUER_NAME_CONSTRAINT_EXT      6500
#define         IDS_INVALID_SUBJECT_NAME_CONSTRAINT_INFO    6501
#define         IDS_NOT_SUPPORTED_ENTRY_NAME_CONSTRAINT     6502
#define         IDS_NOT_SUPPORTED_PERMITTED_NAME_CONSTRAINT 6503
#define         IDS_NOT_SUPPORTED_EXCLUDED_NAME_CONSTRAINT  6504
#define         IDS_NOT_PERMITTED_ENTRY_NAME_CONSTRAINT     6505
#define         IDS_EXCLUDED_ENTRY_NAME_CONSTRAINT          6506
#define         IDS_NOT_DEFINED_ENTRY_NAME_CONSTRAINT       6507


#define         IDS_BASIC_CONS2_PATH                    7002
#define         IDS_BASIC_CONS2_NONE                    7003
#define         IDS_NONE                                7004
#define         IDS_SUB_EE                              7005
#define         IDS_SUB_CA                              7006
#define         IDS_UNSPECIFIED                         7007
#define         IDS_KEY_COMPROMISE                      7008
#define         IDS_CA_COMPROMISE                       7009
#define         IDS_AFFILIATION_CHANGED                 7010
#define         IDS_SUPERSEDED                          7011
#define         IDS_CESSATION_OF_OPERATION              7012
#define         IDS_CERTIFICATE_HOLD                    7013
#define         IDS_UNKNOWN_VALUE                       7014
#define         IDS_REMOVE_FROM_CRL                     7015
#define         IDS_SUBTREE_CONSTRAINT                  7016
#define         IDS_NO_INFO                             7017
#define         IDS_OTHER_NAME                          7018
#define         IDS_RFC822_NAME                         7019
#define         IDS_DNS_NAME                            7020
#define         IDS_X400_ADDRESS                        7021
#define         IDS_DIRECTORY_NAME                      7022
#define         IDS_EDI_PARTY_NAME                      7023
#define         IDS_URL                                 7024
#define         IDS_IP_ADDRESS                          7025
#define         IDS_REGISTERED_ID                       7026
#define         IDS_ALT_NAME_ENTRY_UNKNOWN              7027
#define         IDS_ALT_NAME_ENTRY                      7030
#define         IDS_YES                                 7031
#define         IDS_NO                                  7032
#define         IDS_AVAILABLE                           7033
#define         IDS_NOT_AVAILABLE                       7034
#define         IDS_SPC_FINANCIAL_NOT_AVAIL             7035
#define         IDS_MIME_CAPABILITY                     7036
#define         IDS_SPC_FINANCIAL_AVAIL                 7037
#define         IDS_AUTH_KEY_ID                         7038
#define         IDS_AUTH_CERT_NUMBER                    7039
#define         IDS_AUTH_CERT_ISSUER                    7040
#define         IDS_DIG_SIG                             7041
#define         IDS_KEY_ENCIPHERMENT                    7042
#define         IDS_DATA_ENCIPHERMENT                   7043
#define         IDS_KEY_AGREEMENT                       7044
#define         IDS_CERT_SIGN                           7045
#define         IDS_OFFLINE_CRL_SIGN                    7046
#define         IDS_CRL_SIGN                            7047
#define         IDS_DECIPHER_ONLY                       7048
#define         IDS_NON_REPUDIATION                     7049
#define         IDS_ENCIPHER_ONLY                       7050
#define         IDS_MIME_CAPABILITY_NO_PARAM            7052
#define         IDS_ENHANCED_KEY_USAGE                  7053
#define         IDS_NO_ALT_NAME                         7054
#define         IDS_UNKNOWN_ACCESS_METHOD               7055
#define         IDS_AUTHORITY_ACCESS_INFO               7056
#define         IDS_CRL_REASON                          7057
#define         IDS_UNKNOWN_KEY_USAGE                   7058
#define         IDS_BIT_BLOB                            7059
#define         IDS_SUNDAY                              7060
#define         IDS_MONDAY                              IDS_SUNDAY+1  
#define         IDS_TUESDAY                             IDS_MONDAY+1  
#define         IDS_WED                                 IDS_TUESDAY+1 
#define         IDS_THUR                                IDS_WED+1     
#define         IDS_FRI                                 IDS_THUR+1    
#define         IDS_SAT                                 IDS_FRI+1     
#define         IDS_JAN                                 7070
#define         IDS_FEB                                 IDS_JAN+1   
#define         IDS_MAR                                 IDS_FEB+1   
#define         IDS_APR                                 IDS_MAR+1   
#define         IDS_MAY                                 IDS_APR+1   
#define         IDS_JUNE                                IDS_MAY+1   
#define         IDS_JULY                                IDS_JUNE+1  
#define         IDS_AUG                                 IDS_JULY+1  
#define         IDS_SEP                                 IDS_AUG+1   
#define         IDS_OCT                                 IDS_SEP+1   
#define         IDS_NOV                                 IDS_OCT+1   
#define         IDS_DEC                                 IDS_NOV+1
#define         IDS_AM                                  7083
#define         IDS_PM                                  7084 
#define         IDS_FILE_TIME                           7085
#define         IDS_FILE_TIME_DWORD                     7086
#define         IDS_KEY_ATTR_ID                         7087
#define         IDS_KEY_ATTR_USAGE                      7088
#define         IDS_KEY_ATTR_AFTER                      7089
#define         IDS_KEY_ATTR_BEFORE                     7090
#define         IDS_KEY_RES_USAGE                       7091
#define         IDS_KEY_RES_ID                          7092
#define         IDS_CRL_DIST_FULL_NAME                  7093
#define         IDS_CRL_DIST_ISSUER_RDN                 7094
#define         IDS_DWORD                               7095
#define         IDS_UNKNOWN_CRL_REASON                  7096
#define         IDS_CRL_DIST_NAME                       7097
#define         IDS_CRL_DIST_REASON                     7098
#define         IDS_CRL_DIST_ENTRY                      7099
#define         IDS_CRL_DIST_ISSUER                     7100
#define         IDS_POLICY_QUALIFIER                    7101
#define         IDS_POLICY_QUALIFIER_NO_BLOB            7102
#define         IDS_POLICY_QUALIFIER_INFO               7103
#define         IDS_CERT_POLICY_NO_QUA                  7104
#define         IDS_CERT_POLICY                         7105
#define         IDS_SPC_URL_LINK                        7107
#define         IDS_SPC_MONIKER_LINK                    7108
#define         IDS_SPC_FILE_LINK                       7109
#define         IDS_SPC_LINK_UNKNOWN                    7110
#define         IDS_IMAGE_LINK                          7111
#define         IDS_IMAGE_BITMAP                        7112
#define         IDS_IMAGE_METAFILE                      7113
#define         IDS_IMAGE_ENHANCED_METAFILE             7114
#define         IDS_IMAGE_GIFFILE                       7115
#define         IDS_AGENCY_POLICY_INFO                  7116
#define         IDS_AGENCY_POLICY_DSPLY                 7117
#define         IDS_AGENCY_LOGO_LINK                    7118
#define         IDS_SPC_OBJECT_NO_BLOB                  7119
#define         IDS_AGENCY_LOGO_IMAGE                   7120
#define         IDS_BASIC_CONS2_PATH_MULTI              7121
#define         IDS_BASIC_CONS2_NONE_MULTI              7122
#define         IDS_SUBTREE_CONSTRAINT_MULTI            7123
#define         IDS_SPC_FINANCIAL_AVAIL_MULTI           7124
#define         IDS_SPC_FINANCIAL_NOT_AVAIL_MULTI       7125
#define         IDS_MIME_CAPABILITY_MULTI               7126
#define         IDS_MIME_CAPABILITY_NO_PARAM_MULTI      7127
#define         IDS_AUTHORITY_ACCESS_INFO_MULTI         7128
#define         IDS_AUTHORITY_ACCESS_NO_METHOD_MULTI    7129
#define         IDS_KEY_ATTR_ID_MULTI                   7130
#define         IDS_KEY_ATTR_USAGE_MULTI                7131
#define         IDS_KEY_ATTR_BEFORE_MULTI               7132
#define         IDS_KEY_ATTR_AFTER_MULTI                7133
#define         IDS_KEY_RES_ID_MULTI                    7134
#define         IDS_KEY_RES_USAGE_MULTI                 7135
#define         IDS_CRL_DIST_FULL_NAME_MULTI            7136
#define         IDS_CRL_DIST_NAME_MULTI                 7137
#define         IDS_CRL_DIST_REASON_MULTI               7138
#define         IDS_CRL_DIST_ISSUER_MULTI               7139
#define         IDS_CRL_DIST_ENTRY_MULTI                7140
#define         IDS_POLICY_QUALIFIER_MULTI              7141
#define         IDS_POLICY_QUALIFIER_INFO_MULTI         7142
#define         IDS_CERT_POLICY_MULTI                   7143
#define         IDS_CERT_POLICY_NO_QUA_MULTI            7144
#define         IDS_SPC_MONIKER_LINK_MULTI              7145
#define         IDS_IMAGE_LINK_MULTI                    7146
#define         IDS_IMAGE_BITMAP_MULTI                  7147
#define         IDS_IMAGE_METAFILE_MULTI                7148
#define         IDS_IMAGE_ENHANCED_METAFILE_MULTI       7149
#define         IDS_IMAGE_GIFFILE_MULTI                 7150
#define         IDS_AGENCY_POLICY_INFO_MULTI            7151
#define         IDS_AGENCY_POLICY_DSPLY_MULTI           7152
#define         IDS_AGENCY_LOGO_IMAGE_MULTI             7153
#define         IDS_AGENCY_LOGO_LINK_MULTI              7154
#define         IDS_AUTH_CERT_ISSUER_MULTI              7155
#define         IDS_AUTHORITY_ACCESS_NO_METHOD          7156
#define         IDS_SPC_OBJECT_DATA                     7157
#define         IDS_SPC_OBJECT_CLASS                    7158
#define         IDS_ONE_TAB                             7159
#define         IDS_TWO_TABS                            7160
#define         IDS_THREE_TABS                          7161
#define         IDS_FOUR_TABS                           7162
#define         IDS_FRMT_SPACE                          7170
#define         IDS_FRMT_A                              7171
#define         IDS_FRMT_ZERO                           7172
#define         IDS_FRMT_HEX                            7173
#define         IDS_DIRECTORY_NAME_MULTI                7174
#define         IDS_UNICODE_STRING                      7175
#define         IDS_UNICODE_STRING_MULTI                7176
#define         IDS_CA_VERSION                          7177
#define         IDS_CA_VERSION_MULTI                    7178
#define         IDS_NETSCAPE_SSL_CLIENT_AUTH            7179
#define         IDS_NETSCAPE_SSL_SERVER_AUTH            7180
#define         IDS_NETSCAPE_SMIME                      7181
#define         IDS_NETSCAPE_SIGN                       7182
#define         IDS_NETSCAPE_SSL_CA                     7183
#define         IDS_NETSCAPE_SMIME_CA                   7184
#define         IDS_NETSCAPE_SIGN_CA                    7185
#define         IDS_UNKNOWN_CERT_TYPE                   7186
#define         IDS_OTHER_NAME_MULTI                    7187
#define         IDS_OTHER_NAME_OIDNAME                  7188
#define         IDS_OTHER_NAME_OID                      7189
#define         IDS_NAME_VALUE                          7190
#define         IDS_NAME_VALUE_MULTI                    7191
#define         IDS_POLICY_QUALIFIER_ELEMENT            7192
#define         IDS_USER_NOTICE_TEXT                    7193                        
#define         IDS_USER_NOTICE_REF_ORG                 7194        
#define         IDS_USER_NOTICE_REF                     7195
#define         IDS_USER_NOTICE_REF_NUMBER              7196
#define         IDS_POLICY_QUALIFIER_NO_BLOB_MULTI      7197
// Post Win2K
#define         IDS_INTEGER                             7198
#define         IDS_STRING                              7199
#define         IDS_GENERIC_OBJECT_ID                   7200
#define         IDS_CRL_NUMBER                          7201
#define         IDS_DELTA_CRL_INDICATOR                 7202
#define         IDS_CRL_VIRTUAL_BASE                    7203
#define         IDS_ONLY_CONTAINS_USER_CERTS            7204
#define         IDS_ONLY_CONTAINS_CA_CERTS              7205
#define         IDS_INDIRECT_CRL                        7206
#define         IDS_ONLY_SOME_CRL_DIST_NAME             7207
#define         IDS_ONLY_SOME_CRL_DIST_NAME_MULTI       7208
#define         IDS_FRESHEST_CRL                        7209
#define         IDS_FRESHEST_CRL_MULTI                  7210
#define         IDS_CRL_SELF_CDP                        7211
#define         IDS_CRL_SELF_CDP_MULTI                  7212
#define         IDS_NAME_CONSTRAINTS_PERMITTED          7213
#define         IDS_NAME_CONSTRAINTS_EXCLUDED           7214
#define         IDS_NAME_CONSTRAINTS_PERMITTED_NONE     7215
#define         IDS_NAME_CONSTRAINTS_EXCLUDED_NONE      7216
#define         IDS_NAME_CONSTRAINTS_SUBTREE            7217
#define         IDS_NAME_CONSTRAINTS_SUBTREE_NO_MAX     7218

#define         IDS_APPLICATION_CERT_POLICY             7219 
#define         IDS_APPLICATION_CERT_POLICY_MULTI       7220 
#define         IDS_APPLICATION_CERT_POLICY_NO_QUA      7221 
#define         IDS_APPLICATION_CERT_POLICY_NO_QUA_MULTI 7222 
#define         IDS_ISSUER_DOMAIN_POLICY                7223
#define         IDS_SUBJECT_DOMAIN_POLICY               7224
#define         IDS_REQUIRED_EXPLICIT_POLICY_SKIP_CERTS 7225
#define         IDS_INHIBIT_POLICY_MAPPING_SKIP_CERTS   7226
#define         IDS_CERTIFICATE_TEMPLATE_MAJOR_VERSION  7227
#define         IDS_CERTIFICATE_TEMPLATE_MINOR_VERSION  7228

#define         IDS_IPADDRESS_V4_4                      7229
#define         IDS_IPADDRESS_V4_8                      7230
#define         IDS_IPADDRESS_V6_16                     7231
#define         IDS_IPADDRESS_V6_32                     7232

#define         IDS_XCERT_DELTA_SYNC_TIME               7233
#define         IDS_XCERT_DIST_POINT                    7234

#define         IDS_HTTP_RESPONSE_STATUS                7235

// CSP resources in range 7500 ... 7600
// THESE RESOURCES ARE LOADED BY THE MS CSPs SO THE
// DEFINE VALUES MAY NOT CHANGE UNLESS THEY ARE
// CHANGED IN THE CSPs
#define         IDS_CSP_RSA_SIG_DESCR                   7501
#define         IDS_CSP_RSA_EXCH_DESCR                  7502
#define         IDS_CSP_IMPORT_SIMPLE                   7503
#define         IDS_CSP_SIGNING_E                       7504
#define         IDS_CSP_CREATE_RSA_SIG                  7505
#define         IDS_CSP_CREATE_RSA_EXCH                 7506
#define         IDS_CSP_DSS_SIG_DESCR                   7507
#define         IDS_CSP_DSS_EXCH_DESCR                  7508
#define         IDS_CSP_CREATE_DSS_SIG                  7509
#define         IDS_CSP_CREATE_DH_EXCH                  7510
#define         IDS_CSP_IMPORT_E_PUB                    7511
#define         IDS_CSP_MIGR                            7512
#define         IDS_CSP_DELETE_SIG                      7513
#define         IDS_CSP_DELETE_KEYX                     7514
#define         IDS_CSP_DELETE_SIG_MIGR                 7515
#define         IDS_CSP_DELETE_KEYX_MIGR                7516
#define         IDS_CSP_SIGNING_S                       7517
#define         IDS_CSP_EXPORT_E_PRIV                   7518
#define         IDS_CSP_EXPORT_S_PRIV                   7519
#define         IDS_CSP_IMPORT_E_PRIV                   7520
#define         IDS_CSP_IMPORT_S_PRIV                   7521
#define         IDS_CSP_AUDIT_CAPI_KEY                  7522

#include "oidinfo.h"
// Note IDS_EXT_*                          in range 8000 .. 8499
// Note IDS_ENHKEY_*                       in range 8500 .. 8999
// Note IDS_SYS_NAME_                      in range 9000 .. 9099
// Note IDS_PHY_NAME_                      in range 9100 .. 9199
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\scrdcert.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       scrdcert.cpp
//
//  Contents:   Smart Card Certificate API
//
//  History:    11-24-1997    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>
//+---------------------------------------------------------------------------
//
//  Function:   I_CryptRegisterSmartCardStore
//
//  Synopsis:   register smart card store
//
//----------------------------------------------------------------------------
BOOL WINAPI
I_CryptRegisterSmartCardStore (
       IN LPCWSTR pwszCardName,
       IN OPTIONAL LPCWSTR pwszProvider,
       IN OPTIONAL DWORD dwProviderType,
       IN OPTIONAL LPCWSTR pwszContainer,
       IN DWORD dwFlags
       )
{
    BOOL                     fResult;
    DWORD                    cw;
    CHAR                     szProviderType[MAX_PROVIDER_TYPE_STRLEN];
    WCHAR                    wszProviderType[MAX_PROVIDER_TYPE_STRLEN];
    LPWSTR                   pwszOpenFilter;
    DWORD                    dwRegisterFlags = 0;
    CERT_SYSTEM_STORE_INFO   cssi;
    CERT_PHYSICAL_STORE_INFO cpsi;
    
    cw = wcslen( pwszCardName ) + 1;
    
    if ( pwszProvider == NULL )
    {
        pwszProvider = MS_BASE_PROVIDER;
    }
    
    cw += wcslen( pwszProvider ) + 1;
    cw += MAX_PROVIDER_TYPE_STRLEN + 1;
    
    if ( pwszContainer == NULL )
    {
        pwszContainer = pwszCardName;
    }
    
    cw += wcslen( pwszContainer ) + 1;
    
    pwszOpenFilter = new WCHAR [cw];
    if ( pwszOpenFilter == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }
    
    _ultoa( dwProviderType, szProviderType, 10 );
    
    MultiByteToWideChar(
         CP_ACP,
         0,
         szProviderType,
         MAX_PROVIDER_TYPE_STRLEN,
         wszProviderType,
         MAX_PROVIDER_TYPE_STRLEN
         );
    
    wcscpy( pwszOpenFilter, pwszCardName );
    wcscat( pwszOpenFilter, L"\\" );
    wcscat( pwszOpenFilter, pwszProvider );
    wcscat( pwszOpenFilter, L"\\" );
    wcscat( pwszOpenFilter, wszProviderType );
    wcscat( pwszOpenFilter, L"\\" );
    wcscat( pwszOpenFilter, pwszContainer );
    
    memset( &cssi, 0, sizeof( cssi ) );
    cssi.cbSize = sizeof( cssi );
           
    // What about the localized name property?                      
    CertRegisterSystemStore(
        SMART_CARD_SYSTEM_STORE,
        CERT_SYSTEM_STORE_CURRENT_USER,
        &cssi,
        NULL
        );
    
    memset( &cpsi, 0, sizeof( cpsi ) );
    cpsi.cbSize = sizeof( cpsi );
    cpsi.pszOpenStoreProvider = sz_CERT_STORE_PROV_SMART_CARD;
    cpsi.OpenParameters.cbData = cw * sizeof( WCHAR );
    cpsi.OpenParameters.pbData = (LPBYTE)pwszOpenFilter;
    cpsi.dwFlags = CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG;
    cpsi.dwFlags |= CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG;
    
    if ( !( dwFlags & SMART_CARD_STORE_REPLACE_EXISTING ) )
    {
        dwRegisterFlags |= CERT_STORE_CREATE_NEW_FLAG;
    }
          
    fResult = CertRegisterPhysicalStore(
                  SMART_CARD_SYSTEM_STORE,
                  dwRegisterFlags | CERT_SYSTEM_STORE_CURRENT_USER,
                  pwszCardName,
                  &cpsi,
                  NULL
                  );
                  
    delete pwszOpenFilter;
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptUnregisterSmartCardStore
//
//  Synopsis:   unregister a smart card store
//
//----------------------------------------------------------------------------
BOOL WINAPI
I_CryptUnregisterSmartCardStore (
       IN LPCWSTR pwszCardName
       )
{
    return( CertUnregisterPhysicalStore(
                SMART_CARD_SYSTEM_STORE,
                CERT_SYSTEM_STORE_CURRENT_USER,
                pwszCardName
                ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptFindSmartCardCertInStore
//
//  Synopsis:   find a smart card certificate matching the given criteria
//
//----------------------------------------------------------------------------
PCCERT_CONTEXT WINAPI
I_CryptFindSmartCardCertInStore (
       IN HCERTSTORE hStore,
       IN PCCERT_CONTEXT pPrevCert,
       IN OPTIONAL PSMART_CARD_CERT_FIND_DATA pFindData,
       IN OUT OPTIONAL PCRYPT_DATA_BLOB* ppSmartCardData
       )
{
    BOOL             fResult;
    BOOL             fFound = FALSE;
    PCCERT_CONTEXT   pCertContext = pPrevCert;
    DWORD            cb;
    PCRYPT_DATA_BLOB pSmartCardData = NULL;
    DWORD            dwPropId = CERT_SMART_CARD_DATA_PROP_ID;
    
    assert( hStore != NULL );
    
    while ( fFound == FALSE )
    {
        pCertContext = CertFindCertificateInStore(
                           hStore,
                           X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                           0,
                           CERT_FIND_PROPERTY,
                           (const void *)&dwPropId,
                           pCertContext
                           );
                           
        if ( ( ppSmartCardData != NULL ) && ( *ppSmartCardData != NULL ) )
        {
            LocalFree( (HLOCAL)*ppSmartCardData );
            *ppSmartCardData = NULL;
        }
                                                       
        if ( pCertContext != NULL )
        {
            if ( pFindData != NULL )
            {
                PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
                
                fResult = CertGetCertificateContextProperty(
                              pCertContext,
                              CERT_KEY_PROV_INFO_PROP_ID,
                              NULL,
                              &cb
                              );
                              
                if ( fResult == TRUE )
                {
                    pKeyProvInfo = (PCRYPT_KEY_PROV_INFO)new BYTE [cb];
                    if ( pKeyProvInfo != NULL )
                    {
                        fResult = CertGetCertificateContextProperty(
                                      pCertContext,
                                      CERT_KEY_PROV_INFO_PROP_ID,
                                      pKeyProvInfo,
                                      &cb  
                                      );
                    }
                    else
                    {
                        fResult = FALSE;
                    }
                }
                
                if ( fResult == TRUE )
                {
                    fFound = TRUE;
                    
                    if ( ( pFindData->pwszProvider != NULL ) &&
                         ( _wcsicmp( 
                               pKeyProvInfo->pwszProvName, 
                               pFindData->pwszProvider
                               ) != 0 ) )
                    {
                        fFound = FALSE;
                    }
                    
                    if ( ( pFindData->dwProviderType != 0 ) &&
                         ( pKeyProvInfo->dwProvType != 
                           pFindData->dwProviderType ) )
                    {
                        fFound = FALSE;
                    }
                    
                    if ( ( pFindData->pwszContainer != NULL ) &&
                         ( _wcsicmp( 
                               pKeyProvInfo->pwszContainerName, 
                               pFindData->pwszContainer
                               ) != 0 ) )
                    {
                        fFound = FALSE;
                    }
                    
                    if ( ( pFindData->dwKeySpec != 0 ) &&
                         ( pKeyProvInfo->dwKeySpec != 
                           pFindData->dwKeySpec ) )
                    {
                        fFound = FALSE;
                    }
                }
                
                delete (LPBYTE)pKeyProvInfo;
            }
            else
            {
                fFound = TRUE;
            }
        }
        else
        {
            fFound = TRUE;
        }
    }
    
    assert( fFound == TRUE );
    
    if ( ( ppSmartCardData != NULL ) && ( pCertContext != NULL ) )
    {
        fResult = CertGetCertificateContextProperty(
                      pCertContext,
                      CERT_SMART_CARD_DATA_PROP_ID,
                      NULL,
                      &cb
                      );
                      
        if ( fResult == TRUE )
        {
            pSmartCardData = (PCRYPT_DATA_BLOB)LocalAlloc( 
                                                    GPTR, 
                                                    cb + sizeof( CRYPT_DATA_BLOB )
                                                    );
                                          
            if ( pSmartCardData != NULL )
            {
                pSmartCardData->cbData = cb;
                pSmartCardData->pbData = (LPBYTE)pSmartCardData + sizeof( CRYPT_DATA_BLOB );
                
                fResult = CertGetCertificateContextProperty(
                              pCertContext,
                              CERT_SMART_CARD_DATA_PROP_ID,
                              pSmartCardData->pbData,
                              &cb
                              );
            }
            else
            {
                fResult = FALSE;
            }
        }
        
        if ( fResult == TRUE )
        {
            *ppSmartCardData = pSmartCardData;
        }
        else
        {
            if ( pSmartCardData != NULL )
            {
                LocalFree( (HLOCAL)pSmartCardData );
            }
            
            CertFreeCertificateContext( pCertContext );
            pCertContext = NULL;
        }
    }
    
    return( pCertContext );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptAddSmartCardCertToStore
//
//  Synopsis:   add a smart card certificate to the specified store
//
//----------------------------------------------------------------------------
BOOL WINAPI
I_CryptAddSmartCardCertToStore (
       IN HCERTSTORE hStore,
       IN PCRYPT_DATA_BLOB pEncodedCert,
       IN OPTIONAL LPWSTR pwszCertFriendlyName,
       IN PCRYPT_DATA_BLOB pSmartCardData,
       IN PCRYPT_KEY_PROV_INFO pKeyProvInfo
       )
{
    BOOL            fResult = TRUE;
    PCCERT_CONTEXT  pCertContext;
    CRYPT_DATA_BLOB DataBlob;
    
    pCertContext = CertCreateCertificateContext(
                       X509_ASN_ENCODING,
                       pEncodedCert->pbData,
                       pEncodedCert->cbData
                       );
                  
    if ( pCertContext == NULL )
    {
        return( FALSE );
    }
    
    if ( pwszCertFriendlyName != NULL )
    {
        DataBlob.cbData = ( wcslen( pwszCertFriendlyName ) + 1 ) * sizeof( WCHAR );
        DataBlob.pbData = (LPBYTE)pwszCertFriendlyName;
        
        fResult = CertSetCertificateContextProperty(
                      pCertContext,
                      CERT_FRIENDLY_NAME_PROP_ID,
                      0,
                      (const void *)&DataBlob
                      );
    }
    
    if ( fResult == TRUE )
    {
        fResult = CertSetCertificateContextProperty(
                      pCertContext,
                      CERT_SMART_CARD_DATA_PROP_ID,
                      0,
                      (const void *)pSmartCardData
                      );
    }
    
    if ( fResult == TRUE )
    {
        fResult = CertSetCertificateContextProperty(
                      pCertContext,
                      CERT_KEY_PROV_INFO_PROP_ID,
                      0,
                      (const void *)pKeyProvInfo
                      );
    }
    
    if ( fResult == TRUE )
    {
        fResult = CertAddCertificateContextToStore(
                      hStore,
                      pCertContext,
                      CERT_STORE_ADD_REPLACE_EXISTING,
                      NULL
                      );
    }
                  
    CertFreeCertificateContext( pCertContext );
    
    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\sca.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       sca.cpp
//
//  Contents:   Simplified Cryptographic APIs (SCA)
//
//              This implementation layers upon the CryptMsg and CertStore
//              APIs.
//
//  Functions:
//              CryptSignMessage
//              CryptVerifyMessageSignature
//              CryptVerifyDetachedMessageSignature
//              CryptGetMessageSignerCount
//              CryptGetMessageCertificates
//              CryptDecodeMessage
//              CryptEncryptMessage
//              CryptDecryptMessage
//              CryptSignAndEncryptMessage
//              CryptDecryptAndVerifyMessageSignature
//              CryptHashMessage
//              CryptVerifyMessageHash
//              CryptVerifyDetachedMessageHash
//              CryptSignMessageWithKey
//              CryptVerifyMessageSignatureWithKey
//
//  History:    14-Feb-96   philh   created
//              21-Feb-96   phil    redid to reflect changes made to sca.h
//              19-Jan-97   philh   removed SET stuff
//              
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

// #define ENABLE_SCA_STREAM_TEST              1
#define SCA_STREAM_ENABLE_FLAG              0x80000000
#define SCA_INDEFINITE_STREAM_FLAG          0x40000000

static const CRYPT_OBJID_TABLE MsgTypeObjIdTable[] = {
    CMSG_DATA,                  szOID_RSA_data              ,
    CMSG_SIGNED,                szOID_RSA_signedData        ,
    CMSG_ENVELOPED,             szOID_RSA_envelopedData     ,
    CMSG_SIGNED_AND_ENVELOPED,  szOID_RSA_signEnvData       ,
    CMSG_HASHED,                szOID_RSA_digestedData      ,
    CMSG_ENCRYPTED,             szOID_RSA_encryptedData
};
#define MSG_TYPE_OBJID_CNT (sizeof(MsgTypeObjIdTable)/sizeof(MsgTypeObjIdTable[0]))


//+-------------------------------------------------------------------------
//  Convert the MsgType to the ASN.1 Object Identifier string
//
//  Returns NULL if there isn't an ObjId corresponding to the MsgType.
//--------------------------------------------------------------------------
static LPCSTR MsgTypeToOID(
    IN DWORD dwMsgType
    )
{

    int i;
    for (i = 0; i < MSG_TYPE_OBJID_CNT; i++)
        if (MsgTypeObjIdTable[i].dwAlgId == dwMsgType)
            return MsgTypeObjIdTable[i].pszObjId;
    return NULL;
}

//+-------------------------------------------------------------------------
//  Convert the ASN.1 Object Identifier string to the MsgType
//
//  Returns 0 if there isn't a MsgType corresponding to the ObjId.
//--------------------------------------------------------------------------
static DWORD OIDToMsgType(
    IN LPCSTR pszObjId
    )
{
    int i;
    for (i = 0; i < MSG_TYPE_OBJID_CNT; i++)
        if (_stricmp(pszObjId, MsgTypeObjIdTable[i].pszObjId) == 0)
            return MsgTypeObjIdTable[i].dwAlgId;
    return 0;
}

//+-------------------------------------------------------------------------
//  SCA allocation and free routines
//--------------------------------------------------------------------------
static void *SCAAlloc(
    IN size_t cbBytes
    );
static void SCAFree(
    IN void *pv
    );

//+-------------------------------------------------------------------------
//  Null implementation of the get signer certificate
//--------------------------------------------------------------------------
static PCCERT_CONTEXT WINAPI NullGetSignerCertificate(
    IN void *pvGetArg,
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pSignerId,
    IN HCERTSTORE hMsgCertStore
    );

//+-------------------------------------------------------------------------
//  Functions for initializing message encode information
//--------------------------------------------------------------------------
static PCMSG_SIGNER_ENCODE_INFO InitSignerEncodeInfo(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara
    );
static void FreeSignerEncodeInfo(
    IN PCMSG_SIGNER_ENCODE_INFO pSigner
    );
static BOOL InitSignedCertAndCrl(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    OUT PCERT_BLOB *ppCertEncoded,
    OUT PCRL_BLOB *ppCrlEncoded
    );
static void FreeSignedCertAndCrl(
    IN PCERT_BLOB pCertEncoded,
    IN PCRL_BLOB pCrlEncoded
    );

static BOOL InitSignedMsgEncodeInfo(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    OUT PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    );
static void FreeSignedMsgEncodeInfo(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    IN PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    );


#ifdef CMS_PKCS7
// Returned array of CMSG_RECIPIENT_ENCODE_INFOs needs to be SCAFree'd
static PCMSG_RECIPIENT_ENCODE_INFO InitCmsRecipientEncodeInfo(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN DWORD dwFlags
    );
#else
// Returned array of PCERT_INFOs needs to be SCAFree'd
static PCERT_INFO *InitRecipientEncodeInfo(
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[]
    );
#endif  // CMS_PKCS7

static BOOL InitEnvelopedMsgEncodeInfo(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    OUT PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    );
static void FreeEnvelopedMsgEncodeInfo(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    );

//+-------------------------------------------------------------------------
//  Encodes the message.
//--------------------------------------------------------------------------
static BOOL EncodeMsg(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo,
    IN DWORD cToBeEncoded,
    IN const BYTE *rgpbToBeEncoded[],
    IN DWORD rgcbToBeEncoded[],
    IN BOOL fBareContent,
    IN DWORD dwInnerContentType,
    OUT BYTE *pbEncodedBlob,
    IN OUT DWORD *pcbEncodedBlob
    );

//+-------------------------------------------------------------------------
//  Decodes the message types:
//      CMSG_SIGNED
//      CMSG_ENVELOPED
//      CMSG_SIGNED_AND_ENVELOPED
//      CMSG_HASHED
//--------------------------------------------------------------------------
static BOOL DecodeMsg(
    IN DWORD dwMsgTypeFlags,
    IN OPTIONAL PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN OPTIONAL PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD cToBeEncoded,
    IN OPTIONAL const BYTE *rgpbToBeEncoded[],
    IN OPTIONAL DWORD rgcbToBeEncoded[],
    IN DWORD dwPrevInnerContentType,
    OUT OPTIONAL DWORD *pdwMsgType,
    OUT OPTIONAL DWORD *pdwInnerContentType,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    );

#ifdef ENABLE_SCA_STREAM_TEST
//+-------------------------------------------------------------------------
//  Encodes the message using streaming.
//--------------------------------------------------------------------------
static BOOL StreamEncodeMsg(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo,
    IN DWORD cToBeEncoded,
    IN const BYTE *rgpbToBeEncoded[],
    IN DWORD rgcbToBeEncoded[],
    IN BOOL fBareContent,
    IN DWORD dwInnerContentType,
    OUT BYTE *pbEncodedBlob,
    IN OUT DWORD *pcbEncodedBlob
    );

//+-------------------------------------------------------------------------
//  Decodes the message types:
//      CMSG_SIGNED
//      CMSG_ENVELOPED
//      CMSG_SIGNED_AND_ENVELOPED
//      CMSG_HASHED
//
//  Uses streaming.
//--------------------------------------------------------------------------
static BOOL StreamDecodeMsg(
    IN DWORD dwMsgTypeFlags,
    IN OPTIONAL PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN OPTIONAL PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD cToBeEncoded,
    IN OPTIONAL const BYTE *rgpbToBeEncoded[],
    IN OPTIONAL DWORD rgcbToBeEncoded[],
    IN DWORD dwPrevInnerContentType,
    OUT OPTIONAL DWORD *pdwMsgType,
    OUT OPTIONAL DWORD *pdwInnerContentType,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    );
#endif

//+-------------------------------------------------------------------------
//  Decodes the HASHED message type
//--------------------------------------------------------------------------
static BOOL DecodeHashMsg(
    IN PCRYPT_HASH_MESSAGE_PARA pHashPara,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD cToBeHashed,
    IN OPTIONAL const BYTE *rgpbToBeHashed[],
    IN OPTIONAL DWORD rgcbToBeHashed[],
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL BYTE *pbComputedHash,
    IN OUT OPTIONAL DWORD *pcbComputedHash
    );

//+-------------------------------------------------------------------------
//  Get certificate for and verify the message's signer.
//--------------------------------------------------------------------------
static BOOL GetSignerCertAndVerify(
    IN PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN HCRYPTMSG hMsg,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    );
//+-------------------------------------------------------------------------
// Get a certificate with a key provider property for one of the message's
// recipients and use to decrypt the message.
//--------------------------------------------------------------------------
static BOOL GetXchgCertAndDecrypt(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN HCRYPTMSG hMsg,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert
    );
//+-------------------------------------------------------------------------
// Allocate and get message parameter
//--------------------------------------------------------------------------
static void * AllocAndMsgGetParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex
    );

//+-------------------------------------------------------------------------
//  Sign the message.
//
//  If fDetachedSignature is TRUE, the "to be signed" content isn't included
//  in the encoded signed blob.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSignMessage(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    IN BOOL fDetachedSignature,
    IN DWORD cToBeSigned,
    IN const BYTE *rgpbToBeSigned[],
    IN DWORD rgcbToBeSigned[],
    OUT BYTE *pbSignedBlob,
    IN OUT DWORD *pcbSignedBlob
    )
{
    BOOL fResult;
    CMSG_SIGNED_ENCODE_INFO SignedMsgEncodeInfo;

    fResult = InitSignedMsgEncodeInfo(
        pSignPara,
        &SignedMsgEncodeInfo
        );
    if (fResult) {
        BOOL fBareContent;
        DWORD dwInnerContentType;
        DWORD dwFlags = 0;

        if (fDetachedSignature)
            dwFlags |= CMSG_DETACHED_FLAG;

        if (pSignPara->cbSize >= STRUCT_CBSIZE(CRYPT_SIGN_MESSAGE_PARA,
                dwInnerContentType)) {
            fBareContent =
                pSignPara->dwFlags & CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG;
            dwInnerContentType =
                pSignPara->dwInnerContentType;
#ifdef CMS_PKCS7
            if (pSignPara->dwFlags &
                    CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG)
                dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
#endif  // CMS_PKCS7
        } else {
            fBareContent = FALSE;
            dwInnerContentType = 0;
        }
#ifdef ENABLE_SCA_STREAM_TEST
        if (pSignPara->cbSize >= STRUCT_CBSIZE(CRYPT_SIGN_MESSAGE_PARA,
                    dwFlags) &&
                (pSignPara->dwFlags & SCA_STREAM_ENABLE_FLAG)) {
            dwFlags |= pSignPara->dwFlags & SCA_INDEFINITE_STREAM_FLAG;

            fResult = StreamEncodeMsg(
                pSignPara->dwMsgEncodingType,
                dwFlags,
                CMSG_SIGNED,
                &SignedMsgEncodeInfo,
                cToBeSigned,
                rgpbToBeSigned,
                rgcbToBeSigned,
                fBareContent,
                dwInnerContentType,
                pbSignedBlob,
                pcbSignedBlob
                );
        } else
#endif
        fResult = EncodeMsg(
            pSignPara->dwMsgEncodingType,
            dwFlags,
            CMSG_SIGNED,
            &SignedMsgEncodeInfo,
            cToBeSigned,
            rgpbToBeSigned,
            rgcbToBeSigned,
            fBareContent,
            dwInnerContentType,
            pbSignedBlob,
            pcbSignedBlob
            );
        FreeSignedMsgEncodeInfo(pSignPara, &SignedMsgEncodeInfo);
    } else
        *pcbSignedBlob = 0;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Verify a signed message.
//
//  For *pcbDecoded == 0 on input, the signer isn't verified.
//
//  A message might have more than one signer. Set dwSignerIndex to iterate
//  through all the signers. dwSignerIndex == 0 selects the first signer.
//
//  pVerifyPara's pfnGetSignerCertificate is called to get the signer's
//  certificate.
//
//  For a verified signer and message, *ppSignerCert is updated
//  with the CertContext of the signer. It must be freed by calling
//  CertFreeCertificateContext. Otherwise, *ppSignerCert is set to NULL.
//  For *pbcbDecoded == 0 on input, *ppSignerCert is always set to
//  NULL.
//
//  ppSignerCert can be NULL, indicating the caller isn't interested
//  in getting the CertContext of the signer.
//
//  pcbDecoded can be NULL, indicating the caller isn't interested in getting
//  the decoded content. Furthermore, if the message doesn't contain any
//  content or signers, then, pcbDecoded must be set to NULL, to allow the
//  pVerifyPara->pfnGetSignerCertificate to be called. Normally, this would be
//  the case when the signed message contains only certficates and CRLs.
//  If pcbDecoded is NULL and the message doesn't have the indicated signer,
//  pfnGetSignerCertificate is called with pSignerId set to NULL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyMessageSignature(
    IN PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbSignedBlob,
    IN DWORD cbSignedBlob,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
#ifdef ENABLE_SCA_STREAM_TEST
    if (pVerifyPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG)
        return StreamDecodeMsg(
            CMSG_SIGNED_FLAG,
            NULL,               // pDecryptPara
            pVerifyPara,
            dwSignerIndex,
            pbSignedBlob,
            cbSignedBlob,
            0,                  // cToBeEncoded
            NULL,               // rgpbToBeEncoded
            NULL,               // rgcbToBeEncoded
            0,                  // dwPrevInnerContentType
            NULL,               // pdwMsgType
            NULL,               // pdwInnerContentType
            pbDecoded,
            pcbDecoded,
            NULL,               // ppXchgCert
            ppSignerCert
            );
    else
#endif
    return DecodeMsg(
        CMSG_SIGNED_FLAG,
        NULL,               // pDecryptPara
        pVerifyPara,
        dwSignerIndex,
        pbSignedBlob,
        cbSignedBlob,
        0,                  // cToBeEncoded
        NULL,               // rgpbToBeEncoded
        NULL,               // rgcbToBeEncoded
        0,                  // dwPrevInnerContentType
        NULL,               // pdwMsgType
        NULL,               // pdwInnerContentType
        pbDecoded,
        pcbDecoded,
        NULL,               // ppXchgCert
        ppSignerCert
        );
}

//+-------------------------------------------------------------------------
//  Verify a signed message containing detached signature(s).
//  The "to be signed" content is passed in separately. No
//  decoded output. Otherwise, identical to CryptVerifyMessageSignature.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyDetachedMessageSignature(
    IN PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbDetachedSignBlob,
    IN DWORD cbDetachedSignBlob,
    IN DWORD cToBeSigned,
    IN const BYTE *rgpbToBeSigned[],
    IN DWORD rgcbToBeSigned[],
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
#ifdef ENABLE_SCA_STREAM_TEST
    if (pVerifyPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG)
        return StreamDecodeMsg(
            CMSG_SIGNED_FLAG,
            NULL,               // pDecryptPara
            pVerifyPara,
            dwSignerIndex,
            pbDetachedSignBlob,
            cbDetachedSignBlob,
            cToBeSigned,
            rgpbToBeSigned,
            rgcbToBeSigned,
            0,                  // dwPrevInnerContentType
            NULL,               // pdwMsgType
            NULL,               // pdwInnerContentType
            NULL,               // pbDecoded
            NULL,               // pcbDecoded
            NULL,               // ppXchgCert
            ppSignerCert
            );
    else
#endif
    return DecodeMsg(
        CMSG_SIGNED_FLAG,
        NULL,               // pDecryptPara
        pVerifyPara,
        dwSignerIndex,
        pbDetachedSignBlob,
        cbDetachedSignBlob,
        cToBeSigned,
        rgpbToBeSigned,
        rgcbToBeSigned,
        0,                  // dwPrevInnerContentType
        NULL,               // pdwMsgType
        NULL,               // pdwInnerContentType
        NULL,               // pbDecoded
        NULL,               // pcbDecoded
        NULL,               // ppXchgCert
        ppSignerCert
        );
}

//+-------------------------------------------------------------------------
//  Returns the count of signers in the signed message. For no signers, returns
//  0. For an error returns -1 with LastError updated accordingly.
//--------------------------------------------------------------------------
LONG
WINAPI
CryptGetMessageSignerCount(
    IN DWORD dwMsgEncodingType,
    IN const BYTE *pbSignedBlob,
    IN DWORD cbSignedBlob
    )
{
    HCRYPTMSG hMsg = NULL;
    LONG lSignerCount;
    DWORD cbData;

    if (NULL == (hMsg = CryptMsgOpenToDecode(
            dwMsgEncodingType,
            0,                          // dwFlags
            0,                          // dwMsgType
            0,                          // hCryptProv,
            NULL,                       // pRecipientInfo
            NULL                        // pStreamInfo
            ))) goto ErrorReturn;
    if (!CryptMsgUpdate(
            hMsg,
            pbSignedBlob,
            cbSignedBlob,
            TRUE                    // fFinal
            )) goto ErrorReturn;

    lSignerCount = 0;
    cbData = sizeof(lSignerCount);
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_SIGNER_COUNT_PARAM,
            0,                      // dwIndex
            &lSignerCount,
            &cbData
            )) goto ErrorReturn;

    goto CommonReturn;

ErrorReturn:
    lSignerCount = -1;
CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);
    return lSignerCount;
}

//+-------------------------------------------------------------------------
//  Returns the cert store containing the message's certs and CRLs.
//  For an error, returns NULL with LastError updated.
//--------------------------------------------------------------------------
HCERTSTORE
WINAPI
CryptGetMessageCertificates(
    IN DWORD dwMsgAndCertEncodingType,
    IN HCRYPTPROV hCryptProv,           // passed to CertOpenStore
    IN DWORD dwFlags,                   // passed to CertOpenStore
    IN const BYTE *pbSignedBlob,
    IN DWORD cbSignedBlob
    )
{
    CRYPT_DATA_BLOB SignedBlob;
    SignedBlob.pbData = (BYTE *) pbSignedBlob;
    SignedBlob.cbData = cbSignedBlob;

    return CertOpenStore(
        CERT_STORE_PROV_PKCS7,
        dwMsgAndCertEncodingType,
        hCryptProv,
        dwFlags,
        (const void *) &SignedBlob
        );
}

//+-------------------------------------------------------------------------
//  Encrypts the message for the recipient(s).
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptEncryptMessage(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN const BYTE *pbToBeEncrypted,
    IN DWORD cbToBeEncrypted,
    OUT BYTE *pbEncryptedBlob,
    IN OUT DWORD *pcbEncryptedBlob
    )
{
    BOOL fResult;
    CMSG_ENVELOPED_ENCODE_INFO EnvelopedMsgEncodeInfo;

    fResult = InitEnvelopedMsgEncodeInfo(
        pEncryptPara,
        cRecipientCert,
        rgpRecipientCert,
        &EnvelopedMsgEncodeInfo
        );
    if (fResult) {
        BOOL fBareContent;
        DWORD dwInnerContentType;
        DWORD dwFlags = 0;

        if (pEncryptPara->cbSize >= sizeof(CRYPT_ENCRYPT_MESSAGE_PARA)) {
            fBareContent =
                pEncryptPara->dwFlags & CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG;
            dwInnerContentType =
                pEncryptPara->dwInnerContentType;
#ifdef CMS_PKCS7
            if (pEncryptPara->dwFlags &
                    CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG)
                dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
#endif  // CMS_PKCS7
        } else {
            fBareContent = FALSE;
            dwInnerContentType = 0;
        }

#ifdef ENABLE_SCA_STREAM_TEST
        if (pEncryptPara->cbSize >= STRUCT_CBSIZE(CRYPT_ENCRYPT_MESSAGE_PARA,
                    dwFlags) &&
                (pEncryptPara->dwFlags & SCA_STREAM_ENABLE_FLAG)) {
            dwFlags |= pEncryptPara->dwFlags & SCA_INDEFINITE_STREAM_FLAG;

            fResult = StreamEncodeMsg(
                pEncryptPara->dwMsgEncodingType,
                dwFlags,
                CMSG_ENVELOPED,
                &EnvelopedMsgEncodeInfo,
                1,                              // cToBeEncrypted
                &pbToBeEncrypted,
                &cbToBeEncrypted,
                fBareContent,
                dwInnerContentType,
                pbEncryptedBlob,
                pcbEncryptedBlob
                );
        } else
#endif
        fResult = EncodeMsg(
            pEncryptPara->dwMsgEncodingType,
            dwFlags,
            CMSG_ENVELOPED,
            &EnvelopedMsgEncodeInfo,
            1,                              // cToBeEncrypted
            &pbToBeEncrypted,
            &cbToBeEncrypted,
            fBareContent,
            dwInnerContentType,
            pbEncryptedBlob,
            pcbEncryptedBlob
            );
        FreeEnvelopedMsgEncodeInfo(pEncryptPara, &EnvelopedMsgEncodeInfo);
    } else
        *pcbEncryptedBlob = 0;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decrypts the message.
//
//  For *pcbDecrypted == 0 on input, the message isn't decrypted.
//
//  For a successfully decrypted message, *ppXchgCert is updated
//  with the CertContext used to decrypt. It must be freed by calling
//  CertFreeCertificateContext. Otherwise, *ppXchgCert is set to NULL.
//  For *pbcbDecrypted == 0 on input, *ppXchgCert is always set to
//  NULL.
//
//  ppXchgCert can be NULL, indicating the caller isn't interested
//  in getting the CertContext used to decrypt.
//
//  pcbDecrypted can be NULL, indicating the caller isn't interested in
//  getting the decrypted content. However, when pcbDecrypted is NULL,
//  the message is still decrypted.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptDecryptMessage(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN const BYTE *pbEncryptedBlob,
    IN DWORD cbEncryptedBlob,
    OUT OPTIONAL BYTE *pbDecrypted,
    IN OUT OPTIONAL DWORD *pcbDecrypted,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert
    )
{
#ifdef ENABLE_SCA_STREAM_TEST
    if (pDecryptPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG)
        return StreamDecodeMsg(
            CMSG_ENVELOPED_FLAG,
            pDecryptPara,
            NULL,               // pVerifyPara
            0,                  // dwSignerIndex
            pbEncryptedBlob,
            cbEncryptedBlob,
            0,                  // cToBeEncoded
            NULL,               // rgpbToBeEncoded
            NULL,               // rgcbToBeEncoded
            0,                  // dwPrevInnerContentType
            NULL,               // pdwMsgType
            NULL,               // pdwInnerContentType
            pbDecrypted,
            pcbDecrypted,
            ppXchgCert,
            NULL                // ppSignerCert
            );
    else

#endif
    return DecodeMsg(
        CMSG_ENVELOPED_FLAG,
        pDecryptPara,
        NULL,               // pVerifyPara
        0,                  // dwSignerIndex
        pbEncryptedBlob,
        cbEncryptedBlob,
        0,                  // cToBeEncoded
        NULL,               // rgpbToBeEncoded
        NULL,               // rgcbToBeEncoded
        0,                  // dwPrevInnerContentType
        NULL,               // pdwMsgType
        NULL,               // pdwInnerContentType
        pbDecrypted,
        pcbDecrypted,
        ppXchgCert,
        NULL                // ppSignerCert
        );
}

//+-------------------------------------------------------------------------
//  Sign the message and encrypt for the recipient(s)
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSignAndEncryptMessage(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN const BYTE *pbToBeSignedAndEncrypted,
    IN DWORD cbToBeSignedAndEncrypted,
    OUT BYTE *pbSignedAndEncryptedBlob,
    IN OUT DWORD *pcbSignedAndEncryptedBlob
    )
{
#if 1
    BOOL fResult;
    DWORD cbSigned;
    DWORD cbSignedDelta = 0;
    BYTE *pbSigned = NULL;

    if (pbSignedAndEncryptedBlob == NULL)
        *pcbSignedAndEncryptedBlob = 0;

    cbSigned = 0;
    CryptSignMessage(
            pSignPara,
            FALSE,          // fDetachedSignature
            1,              // cToBeSigned
            &pbToBeSignedAndEncrypted,
            &cbToBeSignedAndEncrypted,
            NULL,           // pbSignedBlob
            &cbSigned
            );
    if (cbSigned == 0) goto ErrorReturn;
    if (*pcbSignedAndEncryptedBlob) {
        DWORD cbSignedMax;
        pbSigned = (BYTE *) SCAAlloc(cbSigned);
        if (pbSigned == NULL) goto ErrorReturn;
        cbSignedMax = cbSigned;
        if (!CryptSignMessage(
                pSignPara,
                FALSE,          // fDetachedSignature
                1,              // cToBeSigned
                &pbToBeSignedAndEncrypted,
                &cbToBeSignedAndEncrypted,
                pbSigned,
                &cbSigned
                )) goto ErrorReturn;

        if (cbSignedMax > cbSigned)
            // For DSS, the signature length varies since it consists of
            // a sequence of unsigned integers.
            cbSignedDelta = cbSignedMax - cbSigned;
    }

    fResult = CryptEncryptMessage(
            pEncryptPara,
            cRecipientCert,
            rgpRecipientCert,
            pbSigned,
            cbSigned,
            pbSignedAndEncryptedBlob,
            pcbSignedAndEncryptedBlob
            );
    if (!fResult && 0 != *pcbSignedAndEncryptedBlob)
        // Adjust if necessary for DSS signature length
        *pcbSignedAndEncryptedBlob += cbSignedDelta;
    goto CommonReturn;

ErrorReturn:
    *pcbSignedAndEncryptedBlob = 0;
    fResult = FALSE;
CommonReturn:
    if (pbSigned)
        SCAFree(pbSigned);
    return fResult;

#else
    BOOL fResult;
    CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO SignedAndEnvelopedMsgEncodeInfo;

    SignedAndEnvelopedMsgEncodeInfo.cbSize =
        sizeof(CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO);
    fResult = InitSignedMsgEncodeInfo(
        pSignPara,
        &SignedAndEnvelopedMsgEncodeInfo.SignedInfo
        );
    if (fResult) {
        fResult = InitEnvelopedMsgEncodeInfo(
            pEncryptPara,
            cRecipientCert,
            rgpRecipientCert,
            &SignedAndEnvelopedMsgEncodeInfo.EnvelopedInfo
            );
        if (fResult) {
            fResult = EncodeMsg(
                pSignPara->dwMsgEncodingType,
                CMSG_SIGNED_AND_ENVELOPED,
                &SignedAndEnvelopedMsgEncodeInfo,
                pbToBeSignedAndEncrypted,
                cbToBeSignedAndEncrypted,
                FALSE,                      // fBareContent
                0,                          // dwInnerContentType
                pbSignedAndEncryptedBlob,
                pcbSignedAndEncryptedBlob
                );
            FreeEnvelopedMsgEncodeInfo(pEncryptPara,
                &SignedAndEnvelopedMsgEncodeInfo.EnvelopedInfo);
        }
        FreeSignedMsgEncodeInfo(pSignPara,
            &SignedAndEnvelopedMsgEncodeInfo.SignedInfo);
    }
    return fResult;
#endif
}

//+-------------------------------------------------------------------------
//  Decrypts the message and verifies the signer.
//
//  For *pcbDecrypted == 0 on input, the message isn't decrypted and the
//  signer isn't verified.
//
//  A message might have more than one signer. Set dwSignerIndex to iterate
//  through all the signers. dwSignerIndex == 0 selects the first signer.
//
//  The hVerify's GetSignerCertificate is called to verify the signer's
//  certificate.
//
//  For a successfully decrypted and verified message, *ppXchgCert and
//  *ppSignerCert are updated. They must be freed by calling
//  CertFreeCertificateContext. Otherwise, they are set to NULL.
//  For *pbcbDecrypted == 0 on input, both are always set to NULL.
//
//  ppXchgCert and/or ppSignerCert can be NULL, indicating the
//  caller isn't interested in getting the CertContext.
//
//  pcbDecrypted can be NULL, indicating the caller isn't interested in
//  getting the decrypted content. However, when pcbDecrypted is NULL,
//  the message is still decrypted and verified.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptDecryptAndVerifyMessageSignature(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbEncryptedBlob,
    IN DWORD cbEncryptedBlob,
    OUT OPTIONAL BYTE *pbDecrypted,
    IN OUT OPTIONAL DWORD *pcbDecrypted,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
#if 1
    BOOL fResult;
    DWORD cbSignedBlob;
    BYTE *pbSignedBlob = NULL;
    DWORD dwEnvelopeInnerContentType;

    if (ppXchgCert)
        *ppXchgCert = NULL;
    if (ppSignerCert)
        *ppSignerCert = NULL;

#ifdef ENABLE_SCA_STREAM_TEST
    if (pDecryptPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG) {
        cbSignedBlob = 0;
        StreamDecodeMsg(
                CMSG_ENVELOPED_FLAG,
                pDecryptPara,
                NULL,               // pVerifyPara
                0,                  // dwSignerIndex
                pbEncryptedBlob,
                cbEncryptedBlob,
                0,                  // cToBeEncoded
                NULL,               // rgpbToBeEncoded
                NULL,               // rgcbToBeEncoded
                0,                  // dwPrevInnerContentType
                NULL,               // pdwMsgType
                NULL,               // pdwInnerContentType
                NULL,               // pbDecrypted
                &cbSignedBlob,
                NULL,               // ppXchgCert
                NULL                // ppSignerCert
                );
        if (cbSignedBlob == 0) goto ErrorReturn;
        pbSignedBlob = (BYTE *) SCAAlloc(cbSignedBlob);
        if (pbSignedBlob == NULL) goto ErrorReturn;
        if (!StreamDecodeMsg(
                CMSG_ENVELOPED_FLAG,
                pDecryptPara,
                NULL,               // pVerifyPara
                0,                  // dwSignerIndex
                pbEncryptedBlob,
                cbEncryptedBlob,
                0,                  // cToBeEncoded
                NULL,               // rgpbToBeEncoded
                NULL,               // rgcbToBeEncoded
                0,                  // dwPrevInnerContentType
                NULL,               // pdwMsgType
                &dwEnvelopeInnerContentType,
                pbSignedBlob,
                &cbSignedBlob,
                ppXchgCert,
                NULL                // ppSignerCert
                )) goto ErrorReturn;
    } else {

#endif

    cbSignedBlob = 0;
    DecodeMsg(
            CMSG_ENVELOPED_FLAG,
            pDecryptPara,
            NULL,               // pVerifyPara
            0,                  // dwSignerIndex
            pbEncryptedBlob,
            cbEncryptedBlob,
            0,                  // cToBeEncoded
            NULL,               // rgpbToBeEncoded
            NULL,               // rgcbToBeEncoded
            0,                  // dwPrevInnerContentType
            NULL,               // pdwMsgType
            NULL,               // pdwInnerContentType
            NULL,               // pbDecrypted
            &cbSignedBlob,
            NULL,               // ppXchgCert
            NULL                // ppSignerCert
            );
    if (cbSignedBlob == 0) goto ErrorReturn;
    pbSignedBlob = (BYTE *) SCAAlloc(cbSignedBlob);
    if (pbSignedBlob == NULL) goto ErrorReturn;
    if (!DecodeMsg(
            CMSG_ENVELOPED_FLAG,
            pDecryptPara,
            NULL,               // pVerifyPara
            0,                  // dwSignerIndex
            pbEncryptedBlob,
            cbEncryptedBlob,
            0,                  // cToBeEncoded
            NULL,               // rgpbToBeEncoded
            NULL,               // rgcbToBeEncoded
            0,                  // dwPrevInnerContentType
            NULL,               // pdwMsgType
            &dwEnvelopeInnerContentType,
            pbSignedBlob,
            &cbSignedBlob,
            ppXchgCert,
            NULL                // ppSignerCert
            )) goto ErrorReturn;

#ifdef ENABLE_SCA_STREAM_TEST
    }
#endif

#ifdef ENABLE_SCA_STREAM_TEST
    if (pVerifyPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG)
        fResult = StreamDecodeMsg(
                CMSG_SIGNED_FLAG,
                NULL,               // pDecryptPara
                pVerifyPara,
                dwSignerIndex,
                pbSignedBlob,
                cbSignedBlob,
                0,                  // cToBeEncoded
                NULL,               // rgpbToBeEncoded
                NULL,               // rgcbToBeEncoded
                dwEnvelopeInnerContentType,
                NULL,               // pdwMsgType
                NULL,               // pdwInnerContentType
                pbDecrypted,
                pcbDecrypted,
                NULL,               // ppXchgCert
                ppSignerCert
                );
    else
#endif
    fResult = DecodeMsg(
            CMSG_SIGNED_FLAG,
            NULL,               // pDecryptPara
            pVerifyPara,
            dwSignerIndex,
            pbSignedBlob,
            cbSignedBlob,
            0,                  // cToBeEncoded
            NULL,               // rgpbToBeEncoded
            NULL,               // rgcbToBeEncoded
            dwEnvelopeInnerContentType,
            NULL,               // pdwMsgType
            NULL,               // pdwInnerContentType
            pbDecrypted,
            pcbDecrypted,
            NULL,               // ppXchgCert
            ppSignerCert
            );
    if (!fResult) goto VerifyError;
    goto CommonReturn;

ErrorReturn:
    if (pcbDecrypted)
        *pcbDecrypted = 0;
VerifyError:
    if (ppXchgCert && *ppXchgCert) {
        CertFreeCertificateContext(*ppXchgCert);
        *ppXchgCert = NULL;
    }
    if (ppSignerCert && *ppSignerCert) {
        CertFreeCertificateContext(*ppSignerCert);
        *ppSignerCert = NULL;
    }
    fResult = FALSE;
CommonReturn:
    if (pbSignedBlob)
        SCAFree(pbSignedBlob);
    return fResult;

#else
    // This needs to be updated if we switch back to this option
    return DecodeMsg(
        CMSG_SIGNED_AND_ENVELOPED_FLAG,
        pDecryptPara,
        pVerifyPara,
        dwSignerIndex,
        pbEncryptedBlob,
        cbEncryptedBlob,
        0,                  // dwPrevInnerContentType
        NULL,               // pdwMsgType
        NULL,               // pdwInnerContentType
        pbDecrypted,
        pcbDecrypted,
        ppXchgCert,
        ppSignerCert
        );
#endif
}


//+-------------------------------------------------------------------------
//  Get the hash length for the specified algorithm identifier.
//
//  Returns 0 for an unknown identifier.
//--------------------------------------------------------------------------
static DWORD GetComputedHashLength(PCRYPT_ALGORITHM_IDENTIFIER pAlgId)
{
    DWORD cbHash;
    DWORD dwAlgId;

    dwAlgId = CertOIDToAlgId(pAlgId->pszObjId);
    switch (dwAlgId) {
        case CALG_SHA:
            cbHash = 20;
            break;
        case CALG_MD2:
        case CALG_MD4:
        case CALG_MD5:
            cbHash = 16;
            break;
        default:
            cbHash = 0;
    }
    return cbHash;
}


//+-------------------------------------------------------------------------
//  Hash the message.
//
//  If fDetachedHash is TRUE, only the ComputedHash is encoded in the
//  pbHashedBlob. Otherwise, both the ToBeHashed and ComputedHash
//  are encoded.
//
//  pcbHashedBlob or pcbComputedHash can be NULL, indicating the caller
//  isn't interested in getting the output.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptHashMessage(
    IN PCRYPT_HASH_MESSAGE_PARA pHashPara,
    IN BOOL fDetachedHash,
    IN DWORD cToBeHashed,
    IN const BYTE *rgpbToBeHashed[],
    IN DWORD rgcbToBeHashed[],
    OUT OPTIONAL BYTE *pbHashedBlob,
    IN OUT OPTIONAL DWORD *pcbHashedBlob,
    OUT OPTIONAL BYTE *pbComputedHash,
    IN OUT OPTIONAL DWORD *pcbComputedHash
    )
{
    BOOL fResult;
    DWORD dwFlags = fDetachedHash ? CMSG_DETACHED_FLAG : 0;
    HCRYPTMSG hMsg = NULL;
    CMSG_HASHED_ENCODE_INFO HashedMsgEncodeInfo;
    DWORD cbHashedBlob;
    DWORD cbComputedHash;

    // Get input lengths and default return lengths to 0
    cbHashedBlob = 0;
    if (pcbHashedBlob) {
        if (pbHashedBlob)
            cbHashedBlob = *pcbHashedBlob;
        *pcbHashedBlob = 0;
    }
    cbComputedHash = 0;
    if (pcbComputedHash) {
        if (pbComputedHash)
            cbComputedHash = *pcbComputedHash;
        *pcbComputedHash = 0;
    }

    assert(pHashPara->cbSize == sizeof(CRYPT_HASH_MESSAGE_PARA));
    if (pHashPara->cbSize != sizeof(CRYPT_HASH_MESSAGE_PARA))
        goto InvalidArg;

    HashedMsgEncodeInfo.cbSize = sizeof(CMSG_HASHED_ENCODE_INFO);
    HashedMsgEncodeInfo.hCryptProv = pHashPara->hCryptProv;
    HashedMsgEncodeInfo.HashAlgorithm = pHashPara->HashAlgorithm;
    HashedMsgEncodeInfo.pvHashAuxInfo = pHashPara->pvHashAuxInfo;

    fResult = TRUE;
    if (0 == cbHashedBlob && 0 == cbComputedHash &&
            (NULL == pcbComputedHash ||
                0 != (*pcbComputedHash = GetComputedHashLength(
                    &pHashPara->HashAlgorithm)))) {
        // Length only

        if (pcbHashedBlob) {
            DWORD c;
            DWORD cbTotal = 0;
            DWORD *pcb;
            for (c = cToBeHashed, pcb = rgcbToBeHashed; c > 0; c--, pcb++)
                cbTotal += *pcb;

            if (0 == (*pcbHashedBlob = CryptMsgCalculateEncodedLength(
                    pHashPara->dwMsgEncodingType,
                    dwFlags,
                    CMSG_HASHED,
                    &HashedMsgEncodeInfo,
                    NULL,                   // pszInnerContentObjID
                    cbTotal
                    ))) goto CalculateEncodedLengthError;
            if (pbHashedBlob) goto LengthError;
        }

        if (pcbComputedHash && pbComputedHash)
            goto LengthError;

    } else {
        if (NULL == (hMsg = CryptMsgOpenToEncode(
                pHashPara->dwMsgEncodingType,
                dwFlags,
                CMSG_HASHED,
                &HashedMsgEncodeInfo,
                NULL,                   // pszInnerContentObjID
                NULL                    // pStreamInfo
                ))) goto OpenToEncodeError;

        if (0 == cToBeHashed) {
            if (!CryptMsgUpdate(
                    hMsg,
                    NULL,           // pbData
                    0,              // cbData
                    TRUE            // fFinal
                    )) goto UpdateError;
        } else {
            DWORD c;
            DWORD *pcb;
            const BYTE **ppb;
            for (c = cToBeHashed,
                 pcb = rgcbToBeHashed,
                 ppb = rgpbToBeHashed; c > 0; c--, pcb++, ppb++) {
                if (!CryptMsgUpdate(
                        hMsg,
                        *ppb,
                        *pcb,
                        c == 1                    // fFinal
                        )) goto UpdateError;
            }
        }

        if (pcbHashedBlob) {
            fResult = CryptMsgGetParam(
                hMsg,
                CMSG_CONTENT_PARAM,
                0,                      // dwIndex
                pbHashedBlob,
                &cbHashedBlob
                );
            *pcbHashedBlob = cbHashedBlob;
        }
        if (pcbComputedHash) {
            DWORD dwErr = 0;
            BOOL fResult2;
            if (!fResult)
                dwErr = GetLastError();
            fResult2 = CryptMsgGetParam(
                hMsg,
                CMSG_COMPUTED_HASH_PARAM,
                0,                      // dwIndex
                pbComputedHash,
                &cbComputedHash
                );
            *pcbComputedHash = cbComputedHash;
            if (!fResult2)
                fResult = FALSE;
            else if (!fResult)
                SetLastError(dwErr);
        }
        if (!fResult)
            goto ErrorReturn;     // NO_TRACE
    }

CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(LengthError, ERROR_MORE_DATA)
TRACE_ERROR(CalculateEncodedLengthError)
TRACE_ERROR(OpenToEncodeError)
TRACE_ERROR(UpdateError)
}

//+-------------------------------------------------------------------------
//  Verify a hashed message.
//
//  pcbToBeHashed or pcbComputedHash can be NULL,
//  indicating the caller isn't interested in getting the output.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyMessageHash(
    IN PCRYPT_HASH_MESSAGE_PARA pHashPara,
    IN BYTE *pbHashedBlob,
    IN DWORD cbHashedBlob,
    OUT OPTIONAL BYTE *pbToBeHashed,
    IN OUT OPTIONAL DWORD *pcbToBeHashed,
    OUT OPTIONAL BYTE *pbComputedHash,
    IN OUT OPTIONAL DWORD *pcbComputedHash
    )
{
    return DecodeHashMsg(
        pHashPara,
        pbHashedBlob,
        cbHashedBlob,
        NULL,               // cToBeHashed
        NULL,               // rgpbToBeHashed
        NULL,               // rgcbToBeHashed
        pbToBeHashed,
        pcbToBeHashed,
        pbComputedHash,
        pcbComputedHash
        );
}

//+-------------------------------------------------------------------------
//  Verify a hashed message containing a detached hash.
//  The "to be hashed" content is passed in separately. No
//  decoded output. Otherwise, identical to CryptVerifyMessageHash.
//
//  pcbComputedHash can be NULL, indicating the caller isn't interested
//  in getting the output.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyDetachedMessageHash(
    IN PCRYPT_HASH_MESSAGE_PARA pHashPara,
    IN BYTE *pbDetachedHashBlob,
    IN DWORD cbDetachedHashBlob,
    IN DWORD cToBeHashed,
    IN const BYTE *rgpbToBeHashed[],
    IN DWORD rgcbToBeHashed[],
    OUT OPTIONAL BYTE *pbComputedHash,
    IN OUT OPTIONAL DWORD *pcbComputedHash
    )
{
    return DecodeHashMsg(
        pHashPara,
        pbDetachedHashBlob,
        cbDetachedHashBlob,
        cToBeHashed,
        rgpbToBeHashed,
        rgcbToBeHashed,
        NULL,               // pbDecoded
        NULL,               // pcbDecoded
        pbComputedHash,
        pcbComputedHash
        );
}

//+-------------------------------------------------------------------------
//  Decodes a cryptographic message which may be one of the following types:
//    CMSG_DATA
//    CMSG_SIGNED
//    CMSG_ENVELOPED
//    CMSG_SIGNED_AND_ENVELOPED
//    CMSG_HASHED
//
//  dwMsgTypeFlags specifies the set of allowable messages. For example, to
//  decode either SIGNED or ENVELOPED messages, set dwMsgTypeFlags to:
//      CMSG_SIGNED_FLAG | CMSG_ENVELOPED_FLAG.
//
//  dwProvInnerContentType is only applicable when processing nested
//  crytographic messages. When processing an outer crytographic message
//  it must be set to 0. When decoding a nested cryptographic message
//  its the dwInnerContentType returned by a previous CryptDecodeMessage
//  of the outer message. The InnerContentType can be any of the CMSG types,
//  for example, CMSG_DATA, CMSG_SIGNED, ...
//
//  The optional *pdwMsgType is updated with the type of message.
//
//  The optional *pdwInnerContentType is updated with the type of the inner
//  message. Unless there is cryptographic message nesting, CMSG_DATA
//  is returned.
//
//  For CMSG_DATA: returns decoded content.
//  For CMSG_SIGNED: same as CryptVerifyMessageSignature.
//  For CMSG_ENVELOPED: same as CryptDecryptMessage.
//  For CMSG_SIGNED_AND_ENVELOPED: same as CryptDecryptMessage plus
//      CryptVerifyMessageSignature.
//  For CMSG_HASHED: verifies the hash and returns decoded content.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptDecodeMessage(
    IN DWORD dwMsgTypeFlags,
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD dwPrevInnerContentType,
    OUT OPTIONAL DWORD *pdwMsgType,
    OUT OPTIONAL DWORD *pdwInnerContentType,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
#ifdef ENABLE_SCA_STREAM_TEST
    if ((pVerifyPara &&
            (pVerifyPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG))
                    ||
        (pDecryptPara &&
            (pDecryptPara->dwMsgAndCertEncodingType & SCA_STREAM_ENABLE_FLAG)))
        return StreamDecodeMsg(
            dwMsgTypeFlags,
            pDecryptPara,
            pVerifyPara,
            dwSignerIndex,
            pbEncodedBlob,
            cbEncodedBlob,
            0,                  // cToBeEncoded
            NULL,               // rgpbToBeEncoded
            NULL,               // rgcbToBeEncoded
            dwPrevInnerContentType,
            pdwMsgType,
            pdwInnerContentType,
            pbDecoded,
            pcbDecoded,
            ppXchgCert,
            ppSignerCert
            );
    else
#endif
    return DecodeMsg(
        dwMsgTypeFlags,
        pDecryptPara,
        pVerifyPara,
        dwSignerIndex,
        pbEncodedBlob,
        cbEncodedBlob,
        0,                  // cToBeEncoded
        NULL,               // rgpbToBeEncoded
        NULL,               // rgcbToBeEncoded
        dwPrevInnerContentType,
        pdwMsgType,
        pdwInnerContentType,
        pbDecoded,
        pcbDecoded,
        ppXchgCert,
        ppSignerCert
        );
}


//+-------------------------------------------------------------------------
//  Sign the message using the provider's private key specified in the
//  parameters. A dummy SignerId is created and stored in the message.
//
//  Normally used until a certificate has been created for the key.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptSignMessageWithKey(
    IN PCRYPT_KEY_SIGN_MESSAGE_PARA pSignPara,
    IN const BYTE *pbToBeSigned,
    IN DWORD cbToBeSigned,
    OUT BYTE *pbSignedBlob,
    IN OUT DWORD *pcbSignedBlob
    )
{
    BOOL fResult;
    CMSG_SIGNED_ENCODE_INFO SignedMsgEncodeInfo;
    CMSG_SIGNER_ENCODE_INFO SignerEncodeInfo;
    CERT_INFO CertInfo;
    DWORD dwSerialNumber = 0x12345678;

#define NO_CERT_COMMON_NAME     "NO CERT SIGNATURE"
    CERT_RDN rgRDN[1];
    CERT_RDN_ATTR rgAttr[1];
    CERT_NAME_INFO NameInfo;
    BYTE *pbNameEncoded = NULL;
    DWORD cbNameEncoded;

    assert(pSignPara->cbSize >= offsetof(CRYPT_KEY_SIGN_MESSAGE_PARA,
        pvHashAuxInfo) + sizeof(pSignPara->pvHashAuxInfo));
    if (pSignPara->cbSize < offsetof(CRYPT_KEY_SIGN_MESSAGE_PARA,
            pvHashAuxInfo) + sizeof(pSignPara->pvHashAuxInfo))
        goto InvalidArg;

    // Create a dummy issuer name
    NameInfo.cRDN = 1;
    NameInfo.rgRDN = rgRDN;
    rgRDN[0].cRDNAttr = 1;
    rgRDN[0].rgRDNAttr = rgAttr;
    rgAttr[0].pszObjId = szOID_COMMON_NAME;
    rgAttr[0].dwValueType = CERT_RDN_PRINTABLE_STRING;
    rgAttr[0].Value.pbData = (BYTE *) NO_CERT_COMMON_NAME;
    rgAttr[0].Value.cbData = strlen(NO_CERT_COMMON_NAME);

    cbNameEncoded = 0;
    CryptEncodeObject(
        pSignPara->dwMsgAndCertEncodingType,
        X509_NAME,
        &NameInfo,
        NULL,                           // pbEncoded
        &cbNameEncoded
        );
    if (cbNameEncoded == 0) goto ErrorReturn;
    pbNameEncoded = (BYTE *) SCAAlloc(cbNameEncoded);
    if (pbNameEncoded == NULL) goto ErrorReturn;
    if (!CryptEncodeObject(
            pSignPara->dwMsgAndCertEncodingType,
            X509_NAME,
            &NameInfo,
            pbNameEncoded,
            &cbNameEncoded
            )) goto ErrorReturn;

    // CertInfo needs to only be initialized with issuer, serial number
    // and public key algorithm
    memset(&CertInfo, 0, sizeof(CertInfo));
    CertInfo.Issuer.pbData = pbNameEncoded;
    CertInfo.Issuer.cbData = cbNameEncoded;
    CertInfo.SerialNumber.pbData = (BYTE *) &dwSerialNumber;
    CertInfo.SerialNumber.cbData = sizeof(dwSerialNumber);

    if (pSignPara->cbSize >= offsetof(CRYPT_KEY_SIGN_MESSAGE_PARA,
                PubKeyAlgorithm) + sizeof(pSignPara->PubKeyAlgorithm) &&
            pSignPara->PubKeyAlgorithm.pszObjId &&
            '\0' != *pSignPara->PubKeyAlgorithm.pszObjId)
        CertInfo.SubjectPublicKeyInfo.Algorithm = pSignPara->PubKeyAlgorithm;
    else
        CertInfo.SubjectPublicKeyInfo.Algorithm.pszObjId =
            CERT_DEFAULT_OID_PUBLIC_KEY_SIGN;

    memset(&SignerEncodeInfo, 0, sizeof(SignerEncodeInfo));
    SignerEncodeInfo.cbSize = sizeof(SignerEncodeInfo);
    SignerEncodeInfo.pCertInfo = &CertInfo;
    SignerEncodeInfo.hCryptProv = pSignPara->hCryptProv;
    SignerEncodeInfo.dwKeySpec = pSignPara->dwKeySpec;
    SignerEncodeInfo.HashAlgorithm = pSignPara->HashAlgorithm;
    SignerEncodeInfo.pvHashAuxInfo = pSignPara->pvHashAuxInfo;

    memset(&SignedMsgEncodeInfo, 0, sizeof(SignedMsgEncodeInfo));
    SignedMsgEncodeInfo.cbSize = sizeof(SignedMsgEncodeInfo);
    SignedMsgEncodeInfo.cSigners = 1;
    SignedMsgEncodeInfo.rgSigners = &SignerEncodeInfo;

    fResult = EncodeMsg(
        pSignPara->dwMsgAndCertEncodingType,
        0,                              // dwFlags
        CMSG_SIGNED,
        &SignedMsgEncodeInfo,
        1,                              // cToBeSigned
        &pbToBeSigned,
        &cbToBeSigned,
        FALSE,                          // fBareContent
        0,                              // dwInnerContentType
        pbSignedBlob,
        pcbSignedBlob
        );
    goto CommonReturn;

InvalidArg:
    SetLastError((DWORD) E_INVALIDARG);
ErrorReturn:
    fResult = FALSE;
    *pcbSignedBlob = 0;
CommonReturn:
    if (pbNameEncoded)
        SCAFree(pbNameEncoded);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Verify a signed message using the specified public key info.
//
//  Normally called by a CA until it has created a certificate for the
//  key.
//
//  pPublicKeyInfo contains the public key to use to verify the signed
//  message. If NULL, the signature isn't verified (for instance, the decoded
//  content may contain the PublicKeyInfo).
//
//  pcbDecoded can be NULL, indicating the caller isn't interested
//  in getting the decoded content.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptVerifyMessageSignatureWithKey(
    IN PCRYPT_KEY_VERIFY_MESSAGE_PARA pVerifyPara,
    IN OPTIONAL PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
    IN const BYTE *pbSignedBlob,
    IN DWORD cbSignedBlob,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded
    )
{
    BOOL fResult = TRUE;
    HCRYPTMSG hMsg = NULL;
    PCERT_INFO pCertInfo = NULL;
    DWORD cbData;
    DWORD dwMsgType;
    DWORD dwFlags;

    assert(pVerifyPara->cbSize == sizeof(CRYPT_KEY_VERIFY_MESSAGE_PARA));
    if (pVerifyPara->cbSize != sizeof(CRYPT_KEY_VERIFY_MESSAGE_PARA))
        goto InvalidArg;

    if (pbDecoded == NULL && pcbDecoded)
        *pcbDecoded = 0;

    if (pcbDecoded && *pcbDecoded == 0 && pPublicKeyInfo == NULL)
        dwFlags = CMSG_LENGTH_ONLY_FLAG;
    else
        dwFlags = 0;

    hMsg = CryptMsgOpenToDecode(
        pVerifyPara->dwMsgEncodingType,
        dwFlags,
        0,                          // dwMsgType
        pVerifyPara->hCryptProv,
        NULL,                       // pRecipientInfo
        NULL                        // pStreamInfo
        );
    if (hMsg == NULL) goto ErrorReturn;

    fResult = CryptMsgUpdate(
        hMsg,
        pbSignedBlob,
        cbSignedBlob,
        TRUE                    // fFinal
        );
    if (!fResult) goto ErrorReturn;

    cbData = sizeof(dwMsgType);
    dwMsgType = 0;
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_TYPE_PARAM,
        0,                  // dwIndex
        &dwMsgType,
        &cbData
        );
    if (!fResult) goto ErrorReturn;
    if (dwMsgType != CMSG_SIGNED)
    {
        SetLastError((DWORD) CRYPT_E_UNEXPECTED_MSG_TYPE);
        goto ErrorReturn;
    }

    if (pPublicKeyInfo) {
        // Allocate and get the CERT_INFO containing the SignerId 
        // (Issuer and SerialNumber)
        pCertInfo = (PCERT_INFO) AllocAndMsgGetParam(
            hMsg,
            CMSG_SIGNER_CERT_INFO_PARAM,
            0                           // dwSignerIndex
            );
        if (pCertInfo == NULL) goto ErrorReturn;

        pCertInfo->SubjectPublicKeyInfo = *pPublicKeyInfo;

        fResult = CryptMsgControl(
            hMsg,
            0,                  // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pCertInfo
            );
        if (!fResult)  goto ErrorReturn;
    }

    if (pcbDecoded) {
        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbDecoded,
            pcbDecoded
            );
    }
    goto CommonReturn;

InvalidArg:
    SetLastError((DWORD) E_INVALIDARG);
ErrorReturn:
    if (pcbDecoded)
        *pcbDecoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pCertInfo)
        SCAFree(pCertInfo);
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;
}

//+-------------------------------------------------------------------------
//  SCA allocation and free routines
//--------------------------------------------------------------------------
static void *SCAAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}
static void SCAFree(
    IN void *pv
    )
{
    if (pv)
        free(pv);
}

//+-------------------------------------------------------------------------
//  Null implementation of the callback get and verify signer certificate
//--------------------------------------------------------------------------
static PCCERT_CONTEXT WINAPI NullGetSignerCertificate(
    IN void *pvGetArg,
    IN DWORD dwCertEncodingType,
    IN PCERT_INFO pSignerId,    // Only the Issuer and SerialNumber
                                // fields are used
    IN HCERTSTORE hMsgCertStore
    )
{
    return CertGetSubjectCertificateFromStore(hMsgCertStore, dwCertEncodingType,
        pSignerId);
}


//+-------------------------------------------------------------------------
//  Functions for initializing message encode information
//--------------------------------------------------------------------------

static PCMSG_SIGNER_ENCODE_INFO InitSignerEncodeInfo(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara
    )
{
    BOOL fResult;
    PCMSG_SIGNER_ENCODE_INFO pSigner = NULL;
    BOOL *pfDidCryptAcquire;
    DWORD cbSigner;
#ifdef CMS_PKCS7
    BYTE *pbHash;                   // not allocated
#endif  // CMS_PKCS7
    DWORD dwAcquireFlags;

    if (pSignPara->pSigningCert == NULL)
        return NULL;

    // The flag indicating we did a CryptAcquireContext
    // follows the CMSG_SIGNER_ENCODE_INFO. If set, the HCRYPTPROV will need to be
    // released when SignerEncodeInfo is freed.
    cbSigner = sizeof(CMSG_SIGNER_ENCODE_INFO) + sizeof(BOOL);
#ifdef CMS_PKCS7
    if (pSignPara->dwFlags & CRYPT_MESSAGE_KEYID_SIGNER_FLAG)
        cbSigner += MAX_HASH_LEN;
#endif  // CMS_PKCS7
    pSigner = (PCMSG_SIGNER_ENCODE_INFO) SCAAlloc(cbSigner);
    if (pSigner == NULL) goto ErrorReturn;
    memset(pSigner, 0, cbSigner);
    pSigner->cbSize = sizeof(CMSG_SIGNER_ENCODE_INFO);

    pfDidCryptAcquire =
        (BOOL *) (((BYTE *) pSigner) + sizeof(CMSG_SIGNER_ENCODE_INFO));

    pSigner->pCertInfo = pSignPara->pSigningCert->pCertInfo;
    pSigner->HashAlgorithm = pSignPara->HashAlgorithm;
    pSigner->pvHashAuxInfo = pSignPara->pvHashAuxInfo;

    dwAcquireFlags = CRYPT_ACQUIRE_USE_PROV_INFO_FLAG;
    if (pSignPara->dwFlags & CRYPT_MESSAGE_SILENT_KEYSET_FLAG)
        dwAcquireFlags |= CRYPT_ACQUIRE_SILENT_FLAG;
    fResult = CryptAcquireCertificatePrivateKey(
        pSignPara->pSigningCert,
        dwAcquireFlags,
        NULL,                               // pvReserved
        &pSigner->hCryptProv,
        &pSigner->dwKeySpec,
        pfDidCryptAcquire
        );
    if (!fResult) goto ErrorReturn;

    if (pSignPara->cbSize >= STRUCT_CBSIZE(CRYPT_SIGN_MESSAGE_PARA,
            rgUnauthAttr)) {
    	pSigner->cAuthAttr      = pSignPara->cAuthAttr;
    	pSigner->rgAuthAttr 	= pSignPara->rgAuthAttr;
    	pSigner->cUnauthAttr 	= pSignPara->cUnauthAttr;
    	pSigner->rgUnauthAttr 	= pSignPara->rgUnauthAttr;
    }

#ifdef CMS_PKCS7
    if (pSignPara->dwFlags & CRYPT_MESSAGE_KEYID_SIGNER_FLAG) {
        pbHash = (BYTE *) pfDidCryptAcquire + sizeof(*pfDidCryptAcquire);

        pSigner->SignerId.dwIdChoice = CERT_ID_KEY_IDENTIFIER;
        pSigner->SignerId.KeyId.pbData = pbHash;
        pSigner->SignerId.KeyId.cbData = MAX_HASH_LEN;

        if (!CertGetCertificateContextProperty(
                pSignPara->pSigningCert,
                CERT_KEY_IDENTIFIER_PROP_ID,
                pbHash,
                &pSigner->SignerId.KeyId.cbData
                ))
            goto ErrorReturn;
    }

    if (pSignPara->cbSize >= STRUCT_CBSIZE(CRYPT_SIGN_MESSAGE_PARA,
            pvHashEncryptionAuxInfo)) {
    	pSigner->HashEncryptionAlgorithm = pSignPara->HashEncryptionAlgorithm;
    	pSigner->pvHashEncryptionAuxInfo = pSignPara->pvHashEncryptionAuxInfo;
    }
#endif  // CMS_PKCS7
    
    goto CommonReturn;

ErrorReturn:
    if (pSigner) {
        FreeSignerEncodeInfo(pSigner);
        pSigner = NULL;
    }

CommonReturn:
    return pSigner;
}

static void FreeSignerEncodeInfo(
    IN PCMSG_SIGNER_ENCODE_INFO pSigner
    )
{
    BOOL *pfDidCryptAcquire;

    if (pSigner == NULL)
        return;

    // The flag indicating we did a CryptAcquireContext
    // follows the CMSG_SIGNER_ENCODE_INFO.
    pfDidCryptAcquire =
        (BOOL *) (((BYTE *) pSigner) + sizeof(CMSG_SIGNER_ENCODE_INFO));
    if (*pfDidCryptAcquire) {
        DWORD dwErr = GetLastError();
        CryptReleaseContext(pSigner->hCryptProv, 0);
        SetLastError(dwErr);
    }
    
    SCAFree(pSigner);
}

static BOOL InitSignedCertAndCrl(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    OUT PCERT_BLOB *ppCertEncoded,
    OUT PCRL_BLOB *ppCrlEncoded
    )
{
    PCERT_BLOB pCertEncoded = NULL;
    PCRL_BLOB pCrlEncoded = NULL;
    DWORD cMsgCert = pSignPara->cMsgCert;
    DWORD cMsgCrl = pSignPara->cMsgCrl;

    BOOL fResult;
    DWORD dwIdx;

    if (cMsgCert) {
        pCertEncoded = (PCERT_BLOB) SCAAlloc(sizeof(CERT_BLOB) * cMsgCert);
        if (pCertEncoded == NULL) goto ErrorReturn;
        for (dwIdx = 0; dwIdx < cMsgCert; dwIdx++) {
            pCertEncoded[dwIdx].pbData = pSignPara->rgpMsgCert[dwIdx]->pbCertEncoded;
            pCertEncoded[dwIdx].cbData = pSignPara->rgpMsgCert[dwIdx]->cbCertEncoded;
        }
    }

    if (cMsgCrl) {
        pCrlEncoded = (PCRL_BLOB) SCAAlloc(sizeof(CRL_BLOB) * cMsgCrl);
        if (pCrlEncoded == NULL) goto ErrorReturn;
        for (dwIdx = 0; dwIdx < cMsgCrl; dwIdx++) {
            pCrlEncoded[dwIdx].pbData = pSignPara->rgpMsgCrl[dwIdx]->pbCrlEncoded;
            pCrlEncoded[dwIdx].cbData = pSignPara->rgpMsgCrl[dwIdx]->cbCrlEncoded;
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    FreeSignedCertAndCrl(pCertEncoded, pCrlEncoded);
    pCertEncoded = NULL;
    pCrlEncoded = NULL;
    fResult = FALSE;
CommonReturn:
    *ppCertEncoded = pCertEncoded;
    *ppCrlEncoded = pCrlEncoded;
    return fResult;
}

static void FreeSignedCertAndCrl(
    IN PCERT_BLOB pCertEncoded,
    IN PCRL_BLOB pCrlEncoded
    )
{
    if (pCertEncoded)
        SCAFree(pCertEncoded);
    if (pCrlEncoded)
        SCAFree(pCrlEncoded);
}

static BOOL InitSignedMsgEncodeInfo(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    OUT PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    )
{
    BOOL fResult = FALSE;

    assert(pSignPara->cbSize >=
        STRUCT_CBSIZE(CRYPT_SIGN_MESSAGE_PARA, rgpMsgCrl));

    if (pSignPara->cbSize < STRUCT_CBSIZE(CRYPT_SIGN_MESSAGE_PARA, rgpMsgCrl))
        SetLastError((DWORD) E_INVALIDARG);
    else {
        memset(pSignedMsgEncodeInfo, 0, sizeof(CMSG_SIGNED_ENCODE_INFO));
        pSignedMsgEncodeInfo->cbSize = sizeof(CMSG_SIGNED_ENCODE_INFO);
        pSignedMsgEncodeInfo->cSigners = 
            (pSignPara->pSigningCert != NULL) ? 1 : 0;
        pSignedMsgEncodeInfo->rgSigners = InitSignerEncodeInfo(pSignPara);
        if (pSignedMsgEncodeInfo->rgSigners ||
            pSignedMsgEncodeInfo->cSigners == 0) {
            pSignedMsgEncodeInfo->cCertEncoded = pSignPara->cMsgCert;
            pSignedMsgEncodeInfo->cCrlEncoded = pSignPara->cMsgCrl;
    
            fResult = InitSignedCertAndCrl(
                pSignPara,
                &pSignedMsgEncodeInfo->rgCertEncoded,
                &pSignedMsgEncodeInfo->rgCrlEncoded
                );
            if(!fResult)
                FreeSignerEncodeInfo(pSignedMsgEncodeInfo->rgSigners);
        }
    }

    if (!fResult)
        memset(pSignedMsgEncodeInfo, 0, sizeof(CMSG_SIGNED_ENCODE_INFO));
    return fResult;
}

static void FreeSignedMsgEncodeInfo(
    IN PCRYPT_SIGN_MESSAGE_PARA pSignPara,
    IN PCMSG_SIGNED_ENCODE_INFO pSignedMsgEncodeInfo
    )
{
    FreeSignerEncodeInfo(pSignedMsgEncodeInfo->rgSigners);
    FreeSignedCertAndCrl(
        pSignedMsgEncodeInfo->rgCertEncoded,
        pSignedMsgEncodeInfo->rgCrlEncoded
        );
}

#ifdef CMS_PKCS7
// Returned array of CMSG_RECIPIENT_ENCODE_INFOs needs to be SCAFree'd
//
// KeyAgree recipients use RC2 or 3DES wrap according
// to the EncryptPara's ContentEncryptionAlgorithm
static PCMSG_RECIPIENT_ENCODE_INFO InitCmsRecipientEncodeInfo(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN DWORD dwFlags
    )
{
    PCMSG_RECIPIENT_ENCODE_INFO pCmsRecipientEncodeInfo = NULL;
    DWORD cbCmsRecipientEncodeInfo;
    PCMSG_RECIPIENT_ENCODE_INFO pEncodeInfo;                // not allocated
    PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTrans;        // not allocated
    PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgree;        // not allocated
    PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO *ppEncryptedKey; // not allocated
    PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO pEncryptedKey; // not allocated
    PCCERT_CONTEXT *ppRecipientCert;                        // not allocated
    BYTE *pbHash = NULL;                                    // not allocated

    assert(cRecipientCert);

    cbCmsRecipientEncodeInfo = 
            sizeof(CMSG_RECIPIENT_ENCODE_INFO) * cRecipientCert +
            sizeof(CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO) * cRecipientCert +
            sizeof(CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO) * cRecipientCert +
            sizeof(CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO *) * cRecipientCert +
            sizeof(CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO) * cRecipientCert;
    if (dwFlags & CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG)
        cbCmsRecipientEncodeInfo += MAX_HASH_LEN * cRecipientCert;

    pCmsRecipientEncodeInfo =
        (PCMSG_RECIPIENT_ENCODE_INFO) SCAAlloc(cbCmsRecipientEncodeInfo);
    if (NULL == pCmsRecipientEncodeInfo)
        goto OutOfMemory;
    memset(pCmsRecipientEncodeInfo, 0, cbCmsRecipientEncodeInfo);

    pEncodeInfo = pCmsRecipientEncodeInfo;
    pKeyTrans = (PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO)
        &pEncodeInfo[cRecipientCert];
    pKeyAgree = (PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO)
        &pKeyTrans[cRecipientCert];
    ppEncryptedKey = (PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO *)
        &pKeyAgree[cRecipientCert];
    pEncryptedKey = (PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO)
        &ppEncryptedKey[cRecipientCert];
    if (dwFlags & CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG)
        pbHash = (BYTE *) &pEncryptedKey[cRecipientCert];

    ppRecipientCert = rgpRecipientCert;
    for ( ; 0 < cRecipientCert; cRecipientCert--,
                                    pEncodeInfo++,
                                    pKeyTrans++,
                                    pKeyAgree++,
                                    ppEncryptedKey++,
                                    pEncryptedKey++,
                                    ppRecipientCert++) {
        PCERT_INFO pCertInfo = (*ppRecipientCert)->pCertInfo;
        PCERT_PUBLIC_KEY_INFO pPublicKeyInfo =
            &pCertInfo->SubjectPublicKeyInfo;

        PCCRYPT_OID_INFO pOIDInfo;
        PCERT_ID pRecipientId;
        ALG_ID aiPubKey;

        if (pOIDInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_OID_KEY,
                pPublicKeyInfo->Algorithm.pszObjId,
                CRYPT_PUBKEY_ALG_OID_GROUP_ID))
            aiPubKey = pOIDInfo->Algid;
        else
            aiPubKey = 0;

        if (aiPubKey == CALG_DH_SF || aiPubKey == CALG_DH_EPHEM) {
            pEncodeInfo->dwRecipientChoice = CMSG_KEY_AGREE_RECIPIENT;
            pEncodeInfo->pKeyAgree = pKeyAgree;
            ALG_ID aiSymKey;

            pKeyAgree->cbSize = sizeof(*pKeyAgree);
            pKeyAgree->KeyEncryptionAlgorithm.pszObjId =
                szOID_RSA_SMIMEalgESDH;
            // pKeyAgree->pvKeyEncryptionAuxInfo =

            if (pOIDInfo = CryptFindOIDInfo(
                    CRYPT_OID_INFO_OID_KEY,
                    pEncryptPara->ContentEncryptionAlgorithm.pszObjId,
                    CRYPT_ENCRYPT_ALG_OID_GROUP_ID))
                aiSymKey = pOIDInfo->Algid;
            else
                aiSymKey = 0;

            if (CALG_3DES == aiSymKey)
                pKeyAgree->KeyWrapAlgorithm.pszObjId =
                    szOID_RSA_SMIMEalgCMS3DESwrap;
            else {
                pKeyAgree->KeyWrapAlgorithm.pszObjId =
                    szOID_RSA_SMIMEalgCMSRC2wrap;
                if (CALG_RC2 == aiSymKey)
                    pKeyAgree->pvKeyWrapAuxInfo =
                        pEncryptPara->pvEncryptionAuxInfo;
            }

            // pKeyAgree->hCryptProv =
            pKeyAgree->dwKeyChoice = CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE;
            pKeyAgree->pEphemeralAlgorithm = &pPublicKeyInfo->Algorithm;
            // pKeyAgree->UserKeyingMaterial = 
            pKeyAgree->cRecipientEncryptedKeys = 1;
            pKeyAgree->rgpRecipientEncryptedKeys = ppEncryptedKey;
            *ppEncryptedKey = pEncryptedKey;

            pEncryptedKey->cbSize = sizeof(*pEncryptedKey);
            pEncryptedKey->RecipientPublicKey = pPublicKeyInfo->PublicKey;
            pRecipientId = &pEncryptedKey->RecipientId;
            // pEncryptedKey->Date =
            // pEncryptedKey->pOtherAttr =
        } else {
            pEncodeInfo->dwRecipientChoice = CMSG_KEY_TRANS_RECIPIENT;
            pEncodeInfo->pKeyTrans = pKeyTrans;

            pKeyTrans->cbSize = sizeof(*pKeyTrans);
            pKeyTrans->KeyEncryptionAlgorithm = pPublicKeyInfo->Algorithm;
            // pKeyTrans->pvKeyEncryptionAuxInfo =
            // pKeyTrans->hCryptProv =
            pKeyTrans->RecipientPublicKey = pPublicKeyInfo->PublicKey;
            pRecipientId = &pKeyTrans->RecipientId;
        }

        if (dwFlags & CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG) {
            pRecipientId->dwIdChoice = CERT_ID_KEY_IDENTIFIER;
            pRecipientId->KeyId.pbData = pbHash;
            pRecipientId->KeyId.cbData = MAX_HASH_LEN;

            if (!CertGetCertificateContextProperty(
                    *ppRecipientCert,
                    CERT_KEY_IDENTIFIER_PROP_ID,
                    pbHash,
                    &pRecipientId->KeyId.cbData
                    ))
                goto GetKeyIdPropError;
            pbHash += MAX_HASH_LEN;
        } else {
            pRecipientId->dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
            pRecipientId->IssuerSerialNumber.Issuer =
                pCertInfo->Issuer;
            pRecipientId->IssuerSerialNumber.SerialNumber =
                pCertInfo->SerialNumber;
        }
    }

CommonReturn:
    return pCmsRecipientEncodeInfo;

ErrorReturn:
    SCAFree(pCmsRecipientEncodeInfo);
    pCmsRecipientEncodeInfo = NULL;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetKeyIdPropError)
}

#else

// Returned array of PCERT_INFOs needs to be SCAFree'd
static PCERT_INFO *InitRecipientEncodeInfo(
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[]
    )
{
    DWORD dwIdx;
    PCERT_INFO *ppRecipientEncodeInfo;

    if (cRecipientCert == 0) {
        SetLastError((DWORD) E_INVALIDARG);
        return NULL;
    }

    ppRecipientEncodeInfo = (PCERT_INFO *)
        SCAAlloc(sizeof(PCERT_INFO) * cRecipientCert);
    if (ppRecipientEncodeInfo != NULL) {
        for (dwIdx = 0; dwIdx < cRecipientCert; dwIdx++)
            ppRecipientEncodeInfo[dwIdx] = rgpRecipientCert[dwIdx]->pCertInfo;
    }

    return ppRecipientEncodeInfo;
}

#endif  // CMS_PKCS7

static BOOL InitEnvelopedMsgEncodeInfo(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    OUT PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    )
{
    BOOL fResult = FALSE;

#ifdef CMS_PKCS7
    PCMSG_RECIPIENT_ENCODE_INFO pCmsRecipientEncodeInfo = NULL;
#else
    PCERT_INFO *ppRecipientEncodeInfo;
#endif  // CMS_PKCS7

    assert(pEncryptPara->cbSize == sizeof(CRYPT_ENCRYPT_MESSAGE_PARA) ||
        pEncryptPara->cbSize == offsetof(CRYPT_ENCRYPT_MESSAGE_PARA, dwFlags));
    if (pEncryptPara->cbSize < offsetof(CRYPT_ENCRYPT_MESSAGE_PARA, dwFlags))
        SetLastError((DWORD) E_INVALIDARG);
    else {
#ifdef CMS_PKCS7
        if (0 == cRecipientCert || (pCmsRecipientEncodeInfo =
                InitCmsRecipientEncodeInfo(
                    pEncryptPara,
                    cRecipientCert,
                    rgpRecipientCert,
                    pEncryptPara->cbSize >= sizeof(CRYPT_ENCRYPT_MESSAGE_PARA) ?
                        pEncryptPara->dwFlags : 0
                    ))) {
#else
        ppRecipientEncodeInfo = InitRecipientEncodeInfo(
            cRecipientCert,
            rgpRecipientCert
            );
    
        if (ppRecipientEncodeInfo) {
#endif  // CMS_PKCS7
            memset(pEnvelopedMsgEncodeInfo, 0,
                sizeof(CMSG_ENVELOPED_ENCODE_INFO));
            pEnvelopedMsgEncodeInfo->cbSize =
                sizeof(CMSG_ENVELOPED_ENCODE_INFO);
            pEnvelopedMsgEncodeInfo->hCryptProv = pEncryptPara->hCryptProv;
            pEnvelopedMsgEncodeInfo->ContentEncryptionAlgorithm =
                pEncryptPara->ContentEncryptionAlgorithm;
            pEnvelopedMsgEncodeInfo->pvEncryptionAuxInfo =
                pEncryptPara->pvEncryptionAuxInfo;
            pEnvelopedMsgEncodeInfo->cRecipients = cRecipientCert;
#ifdef CMS_PKCS7
            pEnvelopedMsgEncodeInfo->rgCmsRecipients = pCmsRecipientEncodeInfo;
#else
            pEnvelopedMsgEncodeInfo->rgpRecipients = ppRecipientEncodeInfo;
#endif  // CMS_PKCS7
            fResult = TRUE;
        } else
            fResult = FALSE;
    }
    if (!fResult) 
        memset(pEnvelopedMsgEncodeInfo, 0, sizeof(CMSG_ENVELOPED_ENCODE_INFO));
    return fResult;
}

static void FreeEnvelopedMsgEncodeInfo(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedMsgEncodeInfo
    )
{
#ifdef CMS_PKCS7
    if (pEnvelopedMsgEncodeInfo->rgCmsRecipients)
        SCAFree(pEnvelopedMsgEncodeInfo->rgCmsRecipients);
#else
    if (pEnvelopedMsgEncodeInfo->rgpRecipients)
        SCAFree(pEnvelopedMsgEncodeInfo->rgpRecipients);
#endif  // CMS_PKCS7
}

//+-------------------------------------------------------------------------
//  Encode the message.
//--------------------------------------------------------------------------
static BOOL EncodeMsg(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo,
    IN DWORD cToBeEncoded,
    IN const BYTE *rgpbToBeEncoded[],
    IN DWORD rgcbToBeEncoded[],
    IN BOOL fBareContent,
    IN DWORD dwInnerContentType,
    OUT BYTE *pbEncodedBlob,
    IN OUT DWORD *pcbEncodedBlob
    )
{
    BOOL fResult;
    HCRYPTMSG hMsg = NULL;
    DWORD cbEncodedBlob;
    LPCSTR pszInnerContentOID;

    // Get input length and default return length to 0
    if (pbEncodedBlob == NULL)
        cbEncodedBlob = 0;
    else
        cbEncodedBlob = *pcbEncodedBlob;
    *pcbEncodedBlob = 0;

    if (dwInnerContentType)
        pszInnerContentOID = MsgTypeToOID(dwInnerContentType);
    else
        pszInnerContentOID = NULL;

    if (0 == cbEncodedBlob) {
        DWORD c;
        DWORD cbTotal = 0;
        DWORD *pcb;
        for (c = cToBeEncoded, pcb = rgcbToBeEncoded; c > 0; c--, pcb++)
            cbTotal += *pcb;

        if (fBareContent)
            dwFlags |= CMSG_BARE_CONTENT_FLAG;

        if (0 == (*pcbEncodedBlob = CryptMsgCalculateEncodedLength(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            pvMsgEncodeInfo,
            (LPSTR) pszInnerContentOID,
            cbTotal
            ))) goto CalculateEncodedLengthError;
        if (pbEncodedBlob) goto LengthError;
    } else {
        if (NULL == (hMsg = CryptMsgOpenToEncode(
                dwMsgEncodingType,
                dwFlags,
                dwMsgType,
                pvMsgEncodeInfo,
                (LPSTR) pszInnerContentOID,
                NULL                    // pStreamInfo
                ))) goto OpenToEncodeError;


        if (0 == cToBeEncoded) {
            if (!CryptMsgUpdate(
                    hMsg,
                    NULL,           // pbData
                    0,              // cbData
                    TRUE            // fFinal
                    )) goto UpdateError;
        } else {
            DWORD c;
            DWORD *pcb;
            const BYTE **ppb;
            for (c = cToBeEncoded,
                 pcb = rgcbToBeEncoded,
                 ppb = rgpbToBeEncoded; c > 0; c--, pcb++, ppb++) {
                if (!CryptMsgUpdate(
                        hMsg,
                        *ppb,
                        *pcb,
                        c == 1                    // fFinal
                        )) goto UpdateError;
            }
        }

        fResult = CryptMsgGetParam(
            hMsg,
            fBareContent ? CMSG_BARE_CONTENT_PARAM : CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbEncodedBlob,
            &cbEncodedBlob
            );
        *pcbEncodedBlob = cbEncodedBlob;
        if (!fResult) goto ErrorReturn;     // NO_TRACE
    }
    fResult = TRUE;

CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(LengthError, ERROR_MORE_DATA)
TRACE_ERROR(CalculateEncodedLengthError)
TRACE_ERROR(OpenToEncodeError)
TRACE_ERROR(UpdateError)
}

//+-------------------------------------------------------------------------
//  Decodes the message types:
//      CMSG_SIGNED
//      CMSG_ENVELOPED
//      CMSG_SIGNED_AND_ENVELOPED
//      CMSG_HASHED
//
//  For detached signature (cToBeEncoded != 0), then, pcbDecoded == NULL.
//--------------------------------------------------------------------------
static BOOL DecodeMsg(
    IN DWORD dwMsgTypeFlags,
    IN OPTIONAL PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN OPTIONAL PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD cToBeEncoded,
    IN OPTIONAL const BYTE *rgpbToBeEncoded[],
    IN OPTIONAL DWORD rgcbToBeEncoded[],
    IN DWORD dwPrevInnerContentType,
    OUT OPTIONAL DWORD *pdwMsgType,
    OUT OPTIONAL DWORD *pdwInnerContentType,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
    BOOL fResult;
    HCRYPTMSG hMsg = NULL;
    DWORD cbData;
    DWORD dwMsgType;
    DWORD dwFlags;
    HCRYPTPROV hCryptProv;
    DWORD dwMsgEncodingType;
    DWORD cbDecoded;

    // Get input length and default return length to 0
    cbDecoded = 0;
    if (pcbDecoded) {
        if (pbDecoded)
            cbDecoded = *pcbDecoded;
        *pcbDecoded = 0;
    }

    // Default optional return values to 0
    if (pdwMsgType)
        *pdwMsgType = 0;
    if (pdwInnerContentType)
        *pdwInnerContentType = 0;
    if (ppXchgCert)
        *ppXchgCert = NULL;
    if (ppSignerCert)
        *ppSignerCert = NULL;

    if (pDecryptPara) {
        assert(pDecryptPara->cbSize >=
            STRUCT_CBSIZE(CRYPT_DECRYPT_MESSAGE_PARA, rghCertStore));
        if (pDecryptPara->cbSize < 
                STRUCT_CBSIZE(CRYPT_DECRYPT_MESSAGE_PARA, rghCertStore))
            goto InvalidArg;
    }

    if (pVerifyPara) {
        assert(pVerifyPara->cbSize == sizeof(CRYPT_VERIFY_MESSAGE_PARA));
        if (pVerifyPara->cbSize != sizeof(CRYPT_VERIFY_MESSAGE_PARA))
            goto InvalidArg;
        hCryptProv = pVerifyPara->hCryptProv;
        dwMsgEncodingType = pVerifyPara->dwMsgAndCertEncodingType;
    } else {
        hCryptProv = 0;
        if (NULL == pDecryptPara) goto InvalidArg;
        dwMsgEncodingType = pDecryptPara->dwMsgAndCertEncodingType;
    }

    if (cToBeEncoded)
        dwFlags = CMSG_DETACHED_FLAG;
    else if (pcbDecoded && 0 == cbDecoded &&
            NULL == ppXchgCert && NULL == ppSignerCert)
        dwFlags = CMSG_LENGTH_ONLY_FLAG;
    else
        dwFlags = 0;

    if (dwPrevInnerContentType) {
        dwMsgType = dwPrevInnerContentType;
        if (CMSG_DATA == dwMsgType)
            dwMsgType = 0;
    } else
        dwMsgType = 0;
    if (NULL == (hMsg = CryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            hCryptProv,
            NULL,                       // pRecipientInfo
            NULL                        // pStreamInfo
            ))) goto OpenToDecodeError;

    if (!CryptMsgUpdate(
            hMsg,
            pbEncodedBlob,
            cbEncodedBlob,
            TRUE                    // fFinal
            )) goto UpdateError;

    if (cToBeEncoded) {
        // Detached signature
        DWORD c;
        DWORD *pcb;
        const BYTE **ppb;
        for (c = cToBeEncoded,
             pcb = rgcbToBeEncoded,
             ppb = rgpbToBeEncoded; c > 0; c--, pcb++, ppb++) {
            if (!CryptMsgUpdate(
                    hMsg,
                    *ppb,
                    *pcb,
                    c == 1                    // fFinal
                    )) goto UpdateError;
        }
    }

    cbData = sizeof(dwMsgType);
    dwMsgType = 0;
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_TYPE_PARAM,
            0,                  // dwIndex
            &dwMsgType,
            &cbData
            )) goto GetTypeError;
    if (pdwMsgType)
        *pdwMsgType = dwMsgType;
    if (0 == ((1 << dwMsgType) & dwMsgTypeFlags))
        goto UnexpectedMsgTypeError;

    if (pdwInnerContentType) {
        char szInnerContentType[128];
        cbData = sizeof(szInnerContentType);
        if (!CryptMsgGetParam(
                hMsg,
                CMSG_INNER_CONTENT_TYPE_PARAM,
                0,                  // dwIndex
                szInnerContentType,
                &cbData
                )) goto GetInnerContentTypeError;
        *pdwInnerContentType = OIDToMsgType(szInnerContentType);
    }

    if (0 == (dwFlags & CMSG_LENGTH_ONLY_FLAG)) {
        if (dwMsgType == CMSG_ENVELOPED ||
                dwMsgType == CMSG_SIGNED_AND_ENVELOPED) {
            if (pDecryptPara == NULL) goto InvalidArg;
            if (!GetXchgCertAndDecrypt(
                    pDecryptPara,
                    hMsg,
                    ppXchgCert
                    )) goto GetXchgCertAndDecryptError;
        }

        if (dwMsgType == CMSG_SIGNED ||
                dwMsgType == CMSG_SIGNED_AND_ENVELOPED) {
            if (pVerifyPara == NULL) goto InvalidArg;
            if (!GetSignerCertAndVerify(
                    pVerifyPara,
                    dwSignerIndex,
                    hMsg,
                    ppSignerCert
                    )) goto GetSignerCertAndVerifyError;
        }
    }


    if (pcbDecoded) {
        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbDecoded,
            &cbDecoded
            );
        *pcbDecoded = cbDecoded;
        if (!fResult) goto ErrorReturn;     // NO_TRACE
    }

    fResult = TRUE;

CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;

ErrorReturn:
    if (ppXchgCert && *ppXchgCert) {
        CertFreeCertificateContext(*ppXchgCert);
        *ppXchgCert = NULL;
    }
    if (ppSignerCert && *ppSignerCert) {
        CertFreeCertificateContext(*ppSignerCert);
        *ppSignerCert = NULL;
    }

    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OpenToDecodeError)
TRACE_ERROR(UpdateError)
TRACE_ERROR(GetTypeError)
TRACE_ERROR(GetInnerContentTypeError)
SET_ERROR(UnexpectedMsgTypeError, CRYPT_E_UNEXPECTED_MSG_TYPE)
TRACE_ERROR(GetXchgCertAndDecryptError)
TRACE_ERROR(GetSignerCertAndVerifyError)
}

#ifdef ENABLE_SCA_STREAM_TEST

typedef struct _STREAM_OUTPUT_INFO {
    BYTE    *pbData;
    DWORD   cbData;
    DWORD   cFinal;
} STREAM_OUTPUT_INFO, *PSTREAM_OUTPUT_INFO;

static void *SCARealloc(
    IN void *pvOrg,
    IN size_t cbBytes
    )
{
    void *pv;
    if (NULL == (pv = pvOrg ? realloc(pvOrg, cbBytes) : malloc(cbBytes)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

static BOOL WINAPI StreamOutputCallback(
        IN const void *pvArg,
        IN BYTE *pbData,
        IN DWORD cbData,
        IN BOOL fFinal
        )
{
    BOOL fResult = TRUE;
    PSTREAM_OUTPUT_INFO pInfo = (PSTREAM_OUTPUT_INFO) pvArg;
    if (fFinal)
        pInfo->cFinal++;

    if (cbData) {
        BYTE *pb;

        if (NULL == (pb = (BYTE *) SCARealloc(pInfo->pbData,
                pInfo->cbData + cbData)))
            fResult = FALSE;
        else {
            memcpy(pb + pInfo->cbData, pbData, cbData);
            pInfo->pbData = pb;
            pInfo->cbData += cbData;
        }
    }
    return fResult;
}


//+-------------------------------------------------------------------------
//  Encodes the message using streaming.
//--------------------------------------------------------------------------
static BOOL StreamEncodeMsg(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void *pvMsgEncodeInfo,
    IN DWORD cToBeEncoded,
    IN const BYTE *rgpbToBeEncoded[],
    IN DWORD rgcbToBeEncoded[],
    IN BOOL fBareContent,
    IN DWORD dwInnerContentType,
    OUT BYTE *pbEncodedBlob,
    IN OUT DWORD *pcbEncodedBlob
    )
{
    BOOL fResult;
    HCRYPTMSG hMsg = NULL;
    DWORD cbEncodedBlob;
    LPCSTR pszInnerContentOID;

    STREAM_OUTPUT_INFO OutputInfo;
    memset(&OutputInfo, 0, sizeof(OutputInfo));

    CMSG_STREAM_INFO StreamInfo;
    memset(&StreamInfo, 0, sizeof(StreamInfo));

    StreamInfo.pfnStreamOutput = StreamOutputCallback;
    StreamInfo.pvArg = (void *) &OutputInfo;
    if (dwFlags & SCA_INDEFINITE_STREAM_FLAG)
        StreamInfo.cbContent = CMSG_INDEFINITE_LENGTH;
    else {
        DWORD c;
        DWORD cbTotal = 0;
        DWORD *pcb;
        for (c = cToBeEncoded, pcb = rgcbToBeEncoded; c > 0; c--, pcb++)
            cbTotal += *pcb;

        StreamInfo.cbContent = cbTotal;
    }
    dwFlags &= ~(SCA_STREAM_ENABLE_FLAG | SCA_INDEFINITE_STREAM_FLAG);

    // Get input length and default return length to 0
    if (pbEncodedBlob == NULL)
        cbEncodedBlob = 0;
    else
        cbEncodedBlob = *pcbEncodedBlob;
    *pcbEncodedBlob = 0;

    if (dwInnerContentType)
        pszInnerContentOID = MsgTypeToOID(dwInnerContentType);
    else
        pszInnerContentOID = NULL;

    {
        if (fBareContent)
            dwFlags |= CMSG_BARE_CONTENT_FLAG;
        if (NULL == (hMsg = CryptMsgOpenToEncode(
                dwMsgEncodingType,
                dwFlags,
                dwMsgType,
                pvMsgEncodeInfo,
                (LPSTR) pszInnerContentOID,
                &StreamInfo
                ))) goto OpenToEncodeError;

        if (0 == cToBeEncoded) {
            if (!CryptMsgUpdate(
                    hMsg,
                    NULL,           // pbData
                    0,              // cbData
                    TRUE            // fFinal
                    )) goto UpdateError;
        } else {
            DWORD c;
            DWORD *pcb;
            const BYTE **ppb;
            for (c = cToBeEncoded,
                 pcb = rgcbToBeEncoded,
                 ppb = rgpbToBeEncoded; c > 0; c--, pcb++, ppb++) {
                BYTE *pbAlloc = NULL;
                const BYTE *pb = *ppb;

                if (NULL == pb) {
                    pbAlloc = (BYTE *) SCAAlloc(*pcb);
                    pb = pbAlloc;
                }
                
                fResult = CryptMsgUpdate(
                        hMsg,
                        pb,
                        *pcb,
                        c == 1                    // fFinal
                        );
                if (pbAlloc)
                    SCAFree(pbAlloc);
                if (!fResult)
                    goto UpdateError;
            }
        }

        if (1 != OutputInfo.cFinal)
            goto BadStreamFinalCountError;

        *pcbEncodedBlob = OutputInfo.cbData;
        if (pbEncodedBlob) {
            if (cbEncodedBlob < OutputInfo.cbData) {
                SetLastError((DWORD) ERROR_MORE_DATA);
                goto ErrorReturn;       // no trace
            }

            if (OutputInfo.cbData > 0)
                memcpy(pbEncodedBlob, OutputInfo.pbData, OutputInfo.cbData);
        }
    }
    fResult = TRUE;

CommonReturn:
    SCAFree(OutputInfo.pbData);
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OpenToEncodeError)
TRACE_ERROR(UpdateError)
SET_ERROR(BadStreamFinalCountError, E_UNEXPECTED)
}

//+-------------------------------------------------------------------------
//  Decodes the message types:
//      CMSG_SIGNED
//      CMSG_ENVELOPED
//      CMSG_SIGNED_AND_ENVELOPED
//      CMSG_HASHED
//
//  Uses streaming.
//--------------------------------------------------------------------------
static BOOL StreamDecodeMsg(
    IN DWORD dwMsgTypeFlags,
    IN OPTIONAL PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN OPTIONAL PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD cToBeEncoded,
    IN OPTIONAL const BYTE *rgpbToBeEncoded[],
    IN OPTIONAL DWORD rgcbToBeEncoded[],
    IN DWORD dwPrevInnerContentType,
    OUT OPTIONAL DWORD *pdwMsgType,
    OUT OPTIONAL DWORD *pdwInnerContentType,
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
    BOOL fResult;
    HCRYPTMSG hMsg = NULL;
    DWORD cbData;
    DWORD dwMsgType;
    DWORD dwFlags;
    HCRYPTPROV hCryptProv;
    DWORD dwMsgEncodingType;
    DWORD cbDecoded;

    STREAM_OUTPUT_INFO OutputInfo;
    memset(&OutputInfo, 0, sizeof(OutputInfo));
    CMSG_STREAM_INFO StreamInfo;
    memset(&StreamInfo, 0, sizeof(StreamInfo));

    StreamInfo.pfnStreamOutput = StreamOutputCallback;
    StreamInfo.pvArg = (void *) &OutputInfo;
    StreamInfo.cbContent = CMSG_INDEFINITE_LENGTH;

    // Get input length and default return length to 0
    cbDecoded = 0;
    if (pcbDecoded) {
        if (pbDecoded)
            cbDecoded = *pcbDecoded;
        *pcbDecoded = 0;
    }

    // Default optional return values to 0
    if (pdwMsgType)
        *pdwMsgType = 0;
    if (pdwInnerContentType)
        *pdwInnerContentType = 0;
    if (ppXchgCert)
        *ppXchgCert = NULL;
    if (ppSignerCert)
        *ppSignerCert = NULL;

    if (pDecryptPara) {
        assert(pDecryptPara->cbSize >=
            STRUCT_CBSIZE(CRYPT_DECRYPT_MESSAGE_PARA, rghCertStore));
        if (pDecryptPara->cbSize < 
                STRUCT_CBSIZE(CRYPT_DECRYPT_MESSAGE_PARA, rghCertStore))
            goto InvalidArg;
    }

    if (pVerifyPara) {
        assert(pVerifyPara->cbSize == sizeof(CRYPT_VERIFY_MESSAGE_PARA));
        if (pVerifyPara->cbSize != sizeof(CRYPT_VERIFY_MESSAGE_PARA))
            goto InvalidArg;
        hCryptProv = pVerifyPara->hCryptProv;
        dwMsgEncodingType = pVerifyPara->dwMsgAndCertEncodingType;
    } else {
        hCryptProv = 0;
        if (NULL == pDecryptPara) goto InvalidArg;
        dwMsgEncodingType = pDecryptPara->dwMsgAndCertEncodingType;
    }

    dwMsgEncodingType &= ~SCA_STREAM_ENABLE_FLAG;

    if (cToBeEncoded)
        dwFlags = CMSG_DETACHED_FLAG;
    else
        dwFlags = 0;

    if (dwPrevInnerContentType) {
        dwMsgType = dwPrevInnerContentType;
        if (CMSG_DATA == dwMsgType)
            dwMsgType = 0;
    } else
        dwMsgType = 0;
    if (NULL == (hMsg = CryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            hCryptProv,
            NULL,                       // pRecipientInfo
            &StreamInfo
            ))) goto OpenToDecodeError;

    {
#if 1
        DWORD cbDelta = cbEncodedBlob / 10;
#else
        DWORD cbDelta = 1;
#endif
        DWORD cbRemain = cbEncodedBlob;
        const BYTE *pb = pbEncodedBlob;

        do {
            DWORD cb;

            if (cbRemain > cbDelta)
                cb = cbDelta;
            else
                cb = cbRemain;

            if (!CryptMsgUpdate(
                    hMsg,
                    pb,
                    cb,
                    cbRemain == cb     // fFinal
                    )) goto UpdateError;
            pb += cb;
            cbRemain -= cb;
        } while (0 != cbRemain);
    }

    if (cToBeEncoded) {
        // Detached signature
        DWORD c;
        DWORD *pcb;
        const BYTE **ppb;
        for (c = cToBeEncoded,
             pcb = rgcbToBeEncoded,
             ppb = rgpbToBeEncoded; c > 0; c--, pcb++, ppb++) {
            if (!CryptMsgUpdate(
                    hMsg,
                    *ppb,
                    *pcb,
                    c == 1                    // fFinal
                    )) goto UpdateError;
        }
    }

    cbData = sizeof(dwMsgType);
    dwMsgType = 0;
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_TYPE_PARAM,
            0,                  // dwIndex
            &dwMsgType,
            &cbData
            )) goto GetTypeError;
    if (pdwMsgType)
        *pdwMsgType = dwMsgType;
    if (0 == ((1 << dwMsgType) & dwMsgTypeFlags))
        goto UnexpectedMsgTypeError;

    if (pdwInnerContentType) {
        char szInnerContentType[128];
        cbData = sizeof(szInnerContentType);
        if (!CryptMsgGetParam(
                hMsg,
                CMSG_INNER_CONTENT_TYPE_PARAM,
                0,                  // dwIndex
                szInnerContentType,
                &cbData
                )) goto GetInnerContentTypeError;
        *pdwInnerContentType = OIDToMsgType(szInnerContentType);
    }

    if (pcbDecoded && 0 == cbDecoded &&
            NULL == ppXchgCert && NULL == ppSignerCert &&
            dwMsgType != CMSG_ENVELOPED)
        ; // Length only
    else {
        if (dwMsgType == CMSG_ENVELOPED ||
                dwMsgType == CMSG_SIGNED_AND_ENVELOPED) {
            if (pDecryptPara == NULL) goto InvalidArg;
            if (!GetXchgCertAndDecrypt(
                    pDecryptPara,
                    hMsg,
                    ppXchgCert
                    )) goto GetXchgCertAndDecryptError;
        }

        if (dwMsgType == CMSG_SIGNED ||
                dwMsgType == CMSG_SIGNED_AND_ENVELOPED) {
            if (pVerifyPara == NULL) goto InvalidArg;
            if (!GetSignerCertAndVerify(
                    pVerifyPara,
                    dwSignerIndex,
                    hMsg,
                    ppSignerCert
                    )) goto GetSignerCertAndVerifyError;
        }
    }

    if (1 != OutputInfo.cFinal)
        goto BadStreamFinalCountError;

    if (pcbDecoded) {
        *pcbDecoded = OutputInfo.cbData;
        if (pbDecoded) {
            if (cbDecoded < OutputInfo.cbData) {
                SetLastError((DWORD) ERROR_MORE_DATA);
                goto ErrorReturn;       // no trace
            }

            if (OutputInfo.cbData > 0)
                memcpy(pbDecoded, OutputInfo.pbData, OutputInfo.cbData);
        }
    }

    fResult = TRUE;

CommonReturn:
    SCAFree(OutputInfo.pbData);
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;

ErrorReturn:
    if (ppXchgCert && *ppXchgCert) {
        CertFreeCertificateContext(*ppXchgCert);
        *ppXchgCert = NULL;
    }
    if (ppSignerCert && *ppSignerCert) {
        CertFreeCertificateContext(*ppSignerCert);
        *ppSignerCert = NULL;
    }

    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OpenToDecodeError)
TRACE_ERROR(UpdateError)
TRACE_ERROR(GetTypeError)
TRACE_ERROR(GetInnerContentTypeError)
SET_ERROR(UnexpectedMsgTypeError, CRYPT_E_UNEXPECTED_MSG_TYPE)
TRACE_ERROR(GetXchgCertAndDecryptError)
TRACE_ERROR(GetSignerCertAndVerifyError)
SET_ERROR(BadStreamFinalCountError, E_UNEXPECTED)
}

#endif      // ENABLE_SCA_STREAM_TEST


//+-------------------------------------------------------------------------
//  Decodes the HASHED message type
//
//  For detached hash (cToBeHashed != 0), then, pcbDecoded == NULL.
//--------------------------------------------------------------------------
static BOOL DecodeHashMsg(
    IN PCRYPT_HASH_MESSAGE_PARA pHashPara,
    IN const BYTE *pbEncodedBlob,
    IN DWORD cbEncodedBlob,
    IN DWORD cToBeHashed,
    IN OPTIONAL const BYTE *rgpbToBeHashed[],
    IN OPTIONAL DWORD rgcbToBeHashed[],
    OUT OPTIONAL BYTE *pbDecoded,
    IN OUT OPTIONAL DWORD *pcbDecoded,
    OUT OPTIONAL BYTE *pbComputedHash,
    IN OUT OPTIONAL DWORD *pcbComputedHash
    )
{
    BOOL fResult;
    HCRYPTMSG hMsg = NULL;
    DWORD cbData;
    DWORD dwMsgType;
    DWORD dwFlags;
    HCRYPTPROV hCryptProv;
    DWORD dwMsgEncodingType;
    DWORD cbDecoded;
    DWORD cbComputedHash;

    // Get input lengths and default return lengths to 0
    cbDecoded = 0;
    if (pcbDecoded) {
        if (pbDecoded)
            cbDecoded = *pcbDecoded;
        *pcbDecoded = 0;
    }
    cbComputedHash = 0;
    if (pcbComputedHash) {
        if (pbComputedHash)
            cbComputedHash = *pcbComputedHash;
        *pcbComputedHash = 0;
    }

    assert(pHashPara->cbSize == sizeof(CRYPT_HASH_MESSAGE_PARA));
    if (pHashPara->cbSize != sizeof(CRYPT_HASH_MESSAGE_PARA))
        goto InvalidArg;

    hCryptProv = pHashPara->hCryptProv;
    dwMsgEncodingType = pHashPara->dwMsgEncodingType;

    if (cToBeHashed)
        dwFlags = CMSG_DETACHED_FLAG;
    else if (0 == cbDecoded && NULL == pcbComputedHash)
        dwFlags = CMSG_LENGTH_ONLY_FLAG;
    else
        dwFlags = 0;

    if (NULL == (hMsg = CryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags,
            0,                          // dwMsgType
            hCryptProv,
            NULL,                       // pRecipientInfo
            NULL                        // pStreamInfo
            ))) goto OpenToDecodeError;

    if (!CryptMsgUpdate(
            hMsg,
            pbEncodedBlob,
            cbEncodedBlob,
            TRUE                    // fFinal
            )) goto UpdateError;

    if (cToBeHashed) {
        // Detached signature or hash
        DWORD c = 0;
        DWORD *pcb;
        const BYTE **ppb;
        for (c = cToBeHashed,
             pcb = rgcbToBeHashed,
             ppb = rgpbToBeHashed; c > 0; c--, pcb++, ppb++) {
            if (!CryptMsgUpdate(
                    hMsg,
                    *ppb,
                    *pcb,
                    c == 1                    // fFinal
                    )) goto UpdateError;
        }
    }

    cbData = sizeof(dwMsgType);
    dwMsgType = 0;
    if (!CryptMsgGetParam(
            hMsg,
            CMSG_TYPE_PARAM,
            0,                  // dwIndex
            &dwMsgType,
            &cbData
            )) goto GetTypeError;
    if (dwMsgType != CMSG_HASHED)
        goto UnexpectedMsgTypeError;

    if (0 == (dwFlags & CMSG_LENGTH_ONLY_FLAG)) {
        if (!CryptMsgControl(
                hMsg,
                0,                      // dwFlags
                CMSG_CTRL_VERIFY_HASH,
                NULL                    // pvCtrlPara
                )) goto ControlError;
    }

    fResult = TRUE;
    if (pcbDecoded) {
        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbDecoded,
            &cbDecoded
            );
        *pcbDecoded = cbDecoded;
    }
    if (pcbComputedHash) {
        DWORD dwErr = 0;
        BOOL fResult2;
        if (!fResult)
            dwErr = GetLastError();
        fResult2 = CryptMsgGetParam(
            hMsg,
            CMSG_COMPUTED_HASH_PARAM,
            0,                      // dwIndex
            pbComputedHash,
            &cbComputedHash
            );
        *pcbComputedHash = cbComputedHash;
        if (!fResult2)
            fResult = FALSE;
        else if (!fResult)
            SetLastError(dwErr);
    }
    if (!fResult)
        goto ErrorReturn;     // NO_TRACE

CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);    // for success, preserves LastError
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(OpenToDecodeError)
TRACE_ERROR(UpdateError)
TRACE_ERROR(GetTypeError)
SET_ERROR(UnexpectedMsgTypeError, CRYPT_E_UNEXPECTED_MSG_TYPE)
TRACE_ERROR(ControlError)
}

//+-------------------------------------------------------------------------
//  Get certificate for and verify the message's signer.
//--------------------------------------------------------------------------
static BOOL GetSignerCertAndVerify(
    IN PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
    IN DWORD dwSignerIndex,
    IN HCRYPTMSG hMsg,
    OUT OPTIONAL PCCERT_CONTEXT *ppSignerCert
    )
{
    BOOL fResult;
    BOOL fNoSigner = FALSE;
    PCERT_INFO pSignerId = NULL;
    PCCERT_CONTEXT pSignerCert = NULL;
    HCERTSTORE hMsgCertStore = NULL;
    DWORD dwLastError = 0;


    {
        // First, get count of signers in the message and verify the
        // dwSignerIndex
        DWORD cSigner = 0;
        DWORD cbData = sizeof(cSigner);
        if (!CryptMsgGetParam(
                hMsg,
                CMSG_SIGNER_COUNT_PARAM,
                0,                      // dwIndex
                &cSigner,
                &cbData
                )) goto ErrorReturn;
        if (cSigner <= dwSignerIndex) fNoSigner = TRUE;
    }

    if (!fNoSigner) {
        // Allocate and get the CERT_INFO containing the SignerId 
        // (Issuer and SerialNumber)
        if (NULL == (pSignerId = (PCERT_INFO) AllocAndMsgGetParam(
                hMsg,
                CMSG_SIGNER_CERT_INFO_PARAM,
                dwSignerIndex
                ))) goto ErrorReturn;
    }

    // Open a cert store initialized with certs and CRLs from the message
    hMsgCertStore = CertOpenStore(
        CERT_STORE_PROV_MSG,
#ifdef ENABLE_SCA_STREAM_TEST
        pVerifyPara->dwMsgAndCertEncodingType &= ~SCA_STREAM_ENABLE_FLAG,
#else
        pVerifyPara->dwMsgAndCertEncodingType,
#endif
        pVerifyPara->hCryptProv,
        CERT_STORE_NO_CRYPT_RELEASE_FLAG,
        hMsg                        // pvPara
        );
    if (hMsgCertStore == NULL) goto ErrorReturn;

    if (pVerifyPara->pfnGetSignerCertificate)
        pSignerCert = pVerifyPara->pfnGetSignerCertificate(
            pVerifyPara->pvGetArg,
#ifdef ENABLE_SCA_STREAM_TEST
            pVerifyPara->dwMsgAndCertEncodingType &= ~SCA_STREAM_ENABLE_FLAG,
#else
            pVerifyPara->dwMsgAndCertEncodingType,
#endif
            pSignerId,
            hMsgCertStore
            );
    else
        pSignerCert = NullGetSignerCertificate(
            NULL,
#ifdef ENABLE_SCA_STREAM_TEST
            pVerifyPara->dwMsgAndCertEncodingType &= ~SCA_STREAM_ENABLE_FLAG,
#else
            pVerifyPara->dwMsgAndCertEncodingType,
#endif
            pSignerId,
            hMsgCertStore
            );
    if (fNoSigner) goto NoSigner;
    if (pSignerCert == NULL) goto ErrorReturn;

#ifdef CMS_PKCS7
    {
        CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA CtrlPara;

        memset(&CtrlPara, 0, sizeof(CtrlPara));
        CtrlPara.cbSize = sizeof(CtrlPara);
        // CtrlPara.hCryptProv =
        CtrlPara.dwSignerIndex = dwSignerIndex;
        CtrlPara.dwSignerType = CMSG_VERIFY_SIGNER_CERT;
        CtrlPara.pvSigner = (void *) pSignerCert;
        if (!CryptMsgControl(
                hMsg,
                0,                  // dwFlags
                CMSG_CTRL_VERIFY_SIGNATURE_EX,
                &CtrlPara
                )) {
            if (CRYPT_E_MISSING_PUBKEY_PARA != GetLastError())
                goto ErrorReturn;
            else {
                PCCERT_CHAIN_CONTEXT pChainContext;
                CERT_CHAIN_PARA ChainPara;

                // Build a chain. Hopefully, the signer inherit's its public key
                // parameters from up the chain

                memset(&ChainPara, 0, sizeof(ChainPara));
                ChainPara.cbSize = sizeof(ChainPara);
                if (CertGetCertificateChain(
                        NULL,                   // hChainEngine
                        pSignerCert,
                        NULL,                   // pTime
                        hMsgCertStore,
                        &ChainPara,
                        CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL,
                        NULL,                   // pvReserved
                        &pChainContext
                        ))
                    CertFreeCertificateChain(pChainContext);

                // Try again. Hopefully the above chain building updated the
                // signer's context property with the missing public key
                // parameters
                if (!CryptMsgControl(
                        hMsg,
                        0,                  // dwFlags
                        CMSG_CTRL_VERIFY_SIGNATURE_EX,
                        &CtrlPara)) goto ErrorReturn;
            }
        }
    }
#else
    if (!CryptMsgControl(
            hMsg,
            0,                  // dwFlags
            CMSG_CTRL_VERIFY_SIGNATURE,
            pSignerCert->pCertInfo
            )) goto ErrorReturn;
#endif  // CMS_PKCS7

    if (ppSignerCert)
        *ppSignerCert = pSignerCert;
    else
        CertFreeCertificateContext(pSignerCert);

    fResult = TRUE;
    goto CommonReturn;

NoSigner:
    SetLastError((DWORD) CRYPT_E_NO_SIGNER);
ErrorReturn:
    if (pSignerCert)
        CertFreeCertificateContext(pSignerCert);
    if (ppSignerCert)
        *ppSignerCert = NULL;
    fResult = FALSE;
    dwLastError = GetLastError();
CommonReturn:
    if (pSignerId)
        SCAFree(pSignerId);
    if (hMsgCertStore)
        CertCloseStore(hMsgCertStore, 0);
    if (dwLastError)
        SetLastError(dwLastError);
    return fResult;
}

#ifdef CMS_PKCS7

static BOOL GetXchgCertAndDecrypt(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN HCRYPTMSG hMsg,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert
    )
{
    BOOL fResult;
    PCMSG_CMS_RECIPIENT_INFO pRecipientInfo = NULL;
    PCCERT_CONTEXT pXchgCert = NULL;
    DWORD cRecipient;
    DWORD cbData;
    DWORD dwRecipientIdx;

    // Get # of CMS recipients in the message.
    cbData = sizeof(cRecipient);
    cRecipient = 0;
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_CMS_RECIPIENT_COUNT_PARAM,
        0,                      // dwIndex
        &cRecipient,
        &cbData
        );
    if (!fResult) goto ErrorReturn;
    if (cRecipient == 0) {
        SetLastError((DWORD) CRYPT_E_RECIPIENT_NOT_FOUND);
        goto ErrorReturn;
    }

    // Loop through the recipients in the message until we find a
    // recipient cert in one of the stores with either the
    // CERT_KEY_CONTEXT_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID.
    for (dwRecipientIdx = 0; dwRecipientIdx < cRecipient; dwRecipientIdx++) {
        DWORD dwRecipientChoice;
        PCMSG_KEY_TRANS_RECIPIENT_INFO pKeyTrans = NULL;
        PCMSG_KEY_AGREE_RECIPIENT_INFO pKeyAgree = NULL;
        DWORD cRecipientEncryptedKeys;
        PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO *ppRecipientEncryptedKey = NULL;
        DWORD dwRecipientEncryptedKeyIndex;

        pRecipientInfo = (PCMSG_CMS_RECIPIENT_INFO) AllocAndMsgGetParam(
            hMsg,
            CMSG_CMS_RECIPIENT_INFO_PARAM,
            dwRecipientIdx
            );
        if (pRecipientInfo == NULL) goto ErrorReturn;

        dwRecipientChoice = pRecipientInfo->dwRecipientChoice;
        switch (dwRecipientChoice) {
            case CMSG_KEY_TRANS_RECIPIENT:
                pKeyTrans = pRecipientInfo->pKeyTrans;
                cRecipientEncryptedKeys = 1;
                break;
            case CMSG_KEY_AGREE_RECIPIENT:
                pKeyAgree = pRecipientInfo->pKeyAgree;
                if (CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY !=
                        pKeyAgree->dwOriginatorChoice) {
                    SCAFree(pRecipientInfo);
                    pRecipientInfo = NULL;
                    continue;
                }
                cRecipientEncryptedKeys = pKeyAgree->cRecipientEncryptedKeys;
                ppRecipientEncryptedKey = pKeyAgree->rgpRecipientEncryptedKeys;
                break;
            default:
                SCAFree(pRecipientInfo);
                pRecipientInfo = NULL;
                continue;
        }

        for (dwRecipientEncryptedKeyIndex = 0;
                dwRecipientEncryptedKeyIndex < cRecipientEncryptedKeys;
                    dwRecipientEncryptedKeyIndex++) {
            PCERT_ID pRecipientId;
            DWORD dwStoreIdx;

            if (CMSG_KEY_TRANS_RECIPIENT == dwRecipientChoice)
                pRecipientId = &pKeyTrans->RecipientId;
            else {
                pRecipientId =
                    &ppRecipientEncryptedKey[
                        dwRecipientEncryptedKeyIndex]->RecipientId;
            }

            for (dwStoreIdx = 0;
                    dwStoreIdx < pDecryptPara->cCertStore; dwStoreIdx++) {
                pXchgCert = CertFindCertificateInStore(
                    pDecryptPara->rghCertStore[dwStoreIdx],
                    pDecryptPara->dwMsgAndCertEncodingType,
                    0,                                      // dwFindFlags
                    CERT_FIND_CERT_ID,
                    pRecipientId,
                    NULL                                    // pPrevCertContext
                    );

                if (pXchgCert) {
                    HCRYPTPROV hCryptProv;
                    DWORD dwKeySpec;
                    BOOL fDidCryptAcquire;
                    DWORD dwAcquireFlags;

                    dwAcquireFlags = CRYPT_ACQUIRE_USE_PROV_INFO_FLAG;
                    if (pDecryptPara->cbSize >=
                            STRUCT_CBSIZE(CRYPT_DECRYPT_MESSAGE_PARA, dwFlags)
                                        &&
                            (pDecryptPara->dwFlags &
                                CRYPT_MESSAGE_SILENT_KEYSET_FLAG))
                        dwAcquireFlags |= CRYPT_ACQUIRE_SILENT_FLAG;

                    fResult = CryptAcquireCertificatePrivateKey(
                        pXchgCert,
                        dwAcquireFlags,
                        NULL,                               // pvReserved
                        &hCryptProv,
                        &dwKeySpec,
                        &fDidCryptAcquire
                        );
                    if (fResult) {
                        if (CMSG_KEY_TRANS_RECIPIENT == dwRecipientChoice) {
                            CMSG_CTRL_KEY_TRANS_DECRYPT_PARA Para;

                            memset(&Para, 0, sizeof(Para));
                            Para.cbSize = sizeof(Para);
                            Para.hCryptProv = hCryptProv;
                            Para.dwKeySpec = dwKeySpec;
                            Para.pKeyTrans = pKeyTrans;
                            Para.dwRecipientIndex = dwRecipientIdx;
                            fResult = CryptMsgControl(
                                hMsg,
                                0,                  // dwFlags
                                CMSG_CTRL_KEY_TRANS_DECRYPT,
                                &Para
                                );
                        } else {
                            CMSG_CTRL_KEY_AGREE_DECRYPT_PARA Para;

                            memset(&Para, 0, sizeof(Para));
                            Para.cbSize = sizeof(Para);
                            Para.hCryptProv = hCryptProv;
                            Para.dwKeySpec = dwKeySpec;
                            Para.pKeyAgree = pKeyAgree;
                            Para.dwRecipientIndex = dwRecipientIdx;
                            Para.dwRecipientEncryptedKeyIndex =
                                dwRecipientEncryptedKeyIndex;
                            Para.OriginatorPublicKey =
                                pKeyAgree->OriginatorPublicKeyInfo.PublicKey;
                            fResult = CryptMsgControl(
                                hMsg,
                                0,                  // dwFlags
                                CMSG_CTRL_KEY_AGREE_DECRYPT,
                                &Para
                                );
                        }

                        if (fDidCryptAcquire) {
                            DWORD dwErr = GetLastError();
                            CryptReleaseContext(hCryptProv, 0);
                            SetLastError(dwErr);
                        }
                        if (fResult) {
                            if (ppXchgCert)
                                *ppXchgCert = pXchgCert;
                            else
                                CertFreeCertificateContext(pXchgCert);
                            goto CommonReturn;
                        } else
                            goto ErrorReturn;
                    }
                    CertFreeCertificateContext(pXchgCert);
                    pXchgCert = NULL;
                }
            }
        }
        SCAFree(pRecipientInfo);
        pRecipientInfo = NULL;
    }
    SetLastError((DWORD) CRYPT_E_NO_DECRYPT_CERT);

ErrorReturn:
    if (pXchgCert)
        CertFreeCertificateContext(pXchgCert);
    if (ppXchgCert)
        *ppXchgCert = NULL;
    fResult = FALSE;

CommonReturn:
    if (pRecipientInfo)
        SCAFree(pRecipientInfo);

    return fResult;
}

#else

//+-------------------------------------------------------------------------
// Get a certificate with a key provider property for one of the message's
// recipients and use to decrypt the message.
//--------------------------------------------------------------------------
static BOOL GetXchgCertAndDecrypt(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN HCRYPTMSG hMsg,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert
    )
{
    BOOL fResult;
    PCERT_INFO pRecipientId = NULL;
    PCCERT_CONTEXT pXchgCert = NULL;
    DWORD cRecipient;
    DWORD cbData;
    DWORD dwRecipientIdx;
    DWORD dwStoreIdx;

    // Get # of recipients in the message.
    cbData = sizeof(cRecipient);
    cRecipient = 0;
    fResult = CryptMsgGetParam(
        hMsg,
        CMSG_RECIPIENT_COUNT_PARAM,
        0,                      // dwIndex
        &cRecipient,
        &cbData
        );
    if (!fResult) goto ErrorReturn;
    if (cRecipient == 0) {
        SetLastError((DWORD) CRYPT_E_RECIPIENT_NOT_FOUND);
        goto ErrorReturn;
    }

    // Loop through the recipients in the message until we find a
    // recipient cert in one of the stores with either the
    // CERT_KEY_CONTEXT_PROP_ID or CERT_KEY_PROV_INFO_PROP_ID.
    for (dwRecipientIdx = 0; dwRecipientIdx < cRecipient; dwRecipientIdx++) {
        // Allocate and get the CERT_INFO containing the RecipientId 
        // (Issuer and SerialNumber)
        pRecipientId = (PCERT_INFO) AllocAndMsgGetParam(
            hMsg,
            CMSG_RECIPIENT_INFO_PARAM,
            dwRecipientIdx
            );
        if (pRecipientId == NULL) goto ErrorReturn;
        for (dwStoreIdx = 0;
                dwStoreIdx < pDecryptPara->cCertStore; dwStoreIdx++) {
            pXchgCert = CertGetSubjectCertificateFromStore(
                pDecryptPara->rghCertStore[dwStoreIdx],
                pDecryptPara->dwMsgAndCertEncodingType,
                pRecipientId
                );
            if (pXchgCert) {
                CMSG_CTRL_DECRYPT_PARA Para;
                BOOL fDidCryptAcquire;
                Para.cbSize = sizeof(CMSG_CTRL_DECRYPT_PARA);
                fResult = CryptAcquireCertificatePrivateKey(
                    pXchgCert,
                    CRYPT_ACQUIRE_USE_PROV_INFO_FLAG,
                    NULL,                               // pvReserved
                    &Para.hCryptProv,
                    &Para.dwKeySpec,
                    &fDidCryptAcquire
                    );
                if (fResult) {
                    Para.dwRecipientIndex = dwRecipientIdx;
                    fResult = CryptMsgControl(
                        hMsg,
                        0,                  // dwFlags
                        CMSG_CTRL_DECRYPT,
                        &Para
                        );
                    if (fDidCryptAcquire) {
                        DWORD dwErr = GetLastError();
                        CryptReleaseContext(Para.hCryptProv, 0);
                        SetLastError(dwErr);
                    }
                    if (fResult) {
                        if (ppXchgCert)
                            *ppXchgCert = pXchgCert;
                        else
                            CertFreeCertificateContext(pXchgCert);
                        goto CommonReturn;
                    } else
                        goto ErrorReturn;
                }
                CertFreeCertificateContext(pXchgCert);
                pXchgCert = NULL;
            }
        }
        SCAFree(pRecipientId);
        pRecipientId = NULL;
    }
    SetLastError((DWORD) CRYPT_E_NO_DECRYPT_CERT);

ErrorReturn:
    if (pXchgCert)
        CertFreeCertificateContext(pXchgCert);
    if (ppXchgCert)
        *ppXchgCert = NULL;
    fResult = FALSE;

CommonReturn:
    if (pRecipientId)
        SCAFree(pRecipientId);

    return fResult;
}

#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
// Allocate and get the CMSG_SIGNER_CERT_INFO_PARAM or CMSG_RECIPIENT_INFO_PARAM
// from the message
//--------------------------------------------------------------------------
static void * AllocAndMsgGetParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex
    )
{
    BOOL fResult;
    void *pvData;
    DWORD cbData;

    // First get the length of the CertId's CERT_INFO
    cbData = 0;
    CryptMsgGetParam(
        hMsg,
        dwParamType,
        dwIndex,
        NULL,                   // pvData
        &cbData
        );
    if (cbData == 0) return NULL;
    pvData = SCAAlloc(cbData);
    if (pvData == NULL) return NULL;

    fResult = CryptMsgGetParam(
        hMsg,
        dwParamType,
        dwIndex,
        pvData,
        &cbData
        );
    if (fResult)
        return pvData;
    else {
        SCAFree(pvData);
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\scstore.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       scstore.cpp
//
//  Contents:   Smart Card Store Provider implementation
//
//  History:    03-Dec-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>
//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::CSmartCardStore, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CSmartCardStore::CSmartCardStore ()
                : m_dwOpenFlags( 0 ),
                  m_pwszCardName( NULL ),
                  m_pwszProvider( NULL ),
                  m_dwProviderType( 0 ),
                  m_pwszContainer( NULL ),
                  m_hCacheStore( NULL )
{
    Pki_InitializeCriticalSection( &m_StoreLock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::~CSmartCardStore, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CSmartCardStore::~CSmartCardStore ()
{
    DeleteCriticalSection( &m_StoreLock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::OpenStore, public
//
//  Synopsis:   open store
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::OpenStore (
                     LPCSTR pszStoreProv,
                     DWORD dwMsgAndCertEncodingType,
                     HCRYPTPROV hCryptProv,
                     DWORD dwFlags,
                     const void* pvPara,
                     HCERTSTORE hCertStore,
                     PCERT_STORE_PROV_INFO pStoreProvInfo
                     )
{
    BOOL fResult;
    
    assert( m_dwOpenFlags == 0 );
    assert( m_pwszCardName == NULL );
    assert( m_pwszProvider == NULL );
    assert( m_pwszContainer == NULL );
    assert( m_hCacheStore == NULL );
    
    if ( ( pvPara == NULL ) ||
         ( dwFlags & (CERT_STORE_DELETE_FLAG |
                        CERT_STORE_UNSAFE_PHYSICAL_FLAG) ) )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }
    
    if ( SCStoreParseOpenFilter(
                (LPWSTR)pvPara,
                &m_pwszCardName,
                &m_pwszProvider,
                &m_dwProviderType,
                &m_pwszContainer
                ) == FALSE )
    {
        return( FALSE );
    }
    
    m_dwOpenFlags = dwFlags;
    m_hCacheStore = hCertStore;                                  
                                      
    fResult = FillCacheStore( FALSE );  
    
    if ( fResult == TRUE )
    {
        pStoreProvInfo->cStoreProvFunc = SMART_CARD_PROV_FUNC_COUNT;
        pStoreProvInfo->rgpvStoreProvFunc = (void **)rgpvSmartCardProvFunc;
        pStoreProvInfo->hStoreProv = (HCERTSTOREPROV)this;
    }
    else
    {
        CloseStore( 0 );
    }
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::CloseStore, public
//
//  Synopsis:   close store
//
//----------------------------------------------------------------------------
VOID
CSmartCardStore::CloseStore (DWORD dwFlags)
{
    EnterCriticalSection( &m_StoreLock );
    
    delete m_pwszCardName;
    m_pwszCardName = NULL;
    
    delete m_pwszProvider;
    m_pwszProvider = NULL;
    
    delete m_pwszContainer;
    m_pwszContainer = NULL;
    
    LeaveCriticalSection( &m_StoreLock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::DeleteCert, public
//
//  Synopsis:   delete cert
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::DeleteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags)
{
    return( ModifyCertOnCard( pCertContext, TRUE ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::SetCertProperty, public
//
//  Synopsis:   set certificate property
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::SetCertProperty (
                    PCCERT_CONTEXT pCertContext,
                    DWORD dwPropId,
                    DWORD dwFlags,
                    const void* pvPara
                    )
{
    // NOTENOTE: Properties are NOT persisted
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::WriteCert, public
//
//  Synopsis:   write certificate
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::WriteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags)
{
    return( ModifyCertOnCard( pCertContext, FALSE ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::StoreControl, public
//
//  Synopsis:   store control
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::StoreControl (
                      DWORD dwFlags, 
                      DWORD dwCtrlType, 
                      LPVOID pvCtrlPara
                      )
{
    switch ( dwCtrlType )
    {
    case CERT_STORE_CTRL_RESYNC:
         return( Resync() );
    }
    
    SetLastError( (DWORD) ERROR_NOT_SUPPORTED );                    
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::Resync, public
//
//  Synopsis:   resync store
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::Resync ()
{
    BOOL fResult;
    
    EnterCriticalSection( &m_StoreLock );
    
    fResult = FillCacheStore( TRUE );
    
    LeaveCriticalSection( &m_StoreLock );
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::FillCacheStore, public
//
//  Synopsis:   fill the cache store
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::FillCacheStore (BOOL fClearCache)
{
    BOOL                      fResult = TRUE;
    PCCERT_CONTEXT            pCertContext;
    PCCRL_CONTEXT             pCrlContext;
    PCCTL_CONTEXT             pCtlContext;
    DWORD                     dwFlags = 0;
    SMART_CARD_CERT_FIND_DATA sccfind;
    HCERTSTORE                hMyStore;
    
    if ( fClearCache == TRUE )
    {
        while ( pCertContext = CertEnumCertificatesInStore( m_hCacheStore, NULL ) )
        {
            CertDeleteCertificateFromStore( pCertContext );
        }
        
        while ( pCrlContext = CertGetCRLFromStore( m_hCacheStore, NULL, NULL, &dwFlags ) )
        {
            CertDeleteCRLFromStore( pCrlContext );
        }
            
        while ( pCtlContext = CertEnumCTLsInStore( m_hCacheStore, NULL ) )
        {
            CertDeleteCTLFromStore( pCtlContext );
        }
    }                 
    
    hMyStore = CertOpenSystemStoreW( NULL, L"MY" );
    if ( hMyStore == NULL )
    {
        return( FALSE );
    }
    
    sccfind.cbSize = sizeof( sccfind );
    sccfind.pwszProvider = m_pwszProvider;
    sccfind.dwProviderType = m_dwProviderType;
    sccfind.pwszContainer = m_pwszContainer;
    sccfind.dwKeySpec = 0;
    
    pCertContext = NULL;                       
    while ( ( fResult == TRUE ) && 
            ( ( pCertContext = I_CryptFindSmartCardCertInStore(
                                    hMyStore,
                                    pCertContext,
                                    &sccfind,
                                    NULL
                                    ) ) != NULL ) ) 
    {
        fResult = CertAddCertificateContextToStore(
                      m_hCacheStore,
                      pCertContext,
                      CERT_STORE_ADD_ALWAYS,
                      NULL
                      );
    }
    
    CertCloseStore( hMyStore, 0 );
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSmartCardStore::ModifyCertOnCard, public
//
//  Synopsis:   modify the cert corresponding to the public key in the given
//              cert context
//
//----------------------------------------------------------------------------
BOOL
CSmartCardStore::ModifyCertOnCard (PCCERT_CONTEXT pCertContext, BOOL fDelete)
{
    BOOL       fResult;
    HCRYPTPROV hContainer = NULL;
    HCRYPTKEY  hKeyPair = 0;
    
    fResult = CryptAcquireContextU(
                   &hContainer,
                   m_pwszContainer,
                   m_pwszProvider,
                   m_dwProviderType,
                   0
                   );
                   
    if ( fResult == TRUE )
    {
        fResult = SCStoreAcquireHandleForCertKeyPair( 
                         hContainer,
                         pCertContext,
                         &hKeyPair
                         );
    }
    
    if ( fResult == TRUE )
    {
        fResult = SCStoreWriteCertToCard(
                         ( fDelete == FALSE ) ? pCertContext : NULL,
                         hKeyPair
                         );
                         
        CryptDestroyKey( hKeyPair );                 
    }
    
    if ( hContainer != NULL )
    {
        CryptReleaseContext( hContainer, 0 );
    }
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardProvOpenStore
//
//  Synopsis:   provider open store entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI SmartCardProvOpenStore (
                 IN LPCSTR pszStoreProv,
                 IN DWORD dwMsgAndCertEncodingType,
                 IN HCRYPTPROV hCryptProv,
                 IN DWORD dwFlags,
                 IN const void* pvPara,
                 IN HCERTSTORE hCertStore,
                 IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
                 )
{
    BOOL             fResult;
    CSmartCardStore* pSCStore;

    pSCStore = new CSmartCardStore;
    if ( pSCStore == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    fResult = pSCStore->OpenStore(
                            pszStoreProv,
                            dwMsgAndCertEncodingType,
                            hCryptProv,
                            dwFlags,
                            pvPara,
                            hCertStore,
                            pStoreProvInfo
                            );

    if ( fResult == FALSE )
    {
        delete pSCStore;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardProvCloseStore
//
//  Synopsis:   provider close store entry point
//
//----------------------------------------------------------------------------
void WINAPI SmartCardProvCloseStore (
                 IN HCERTSTOREPROV hStoreProv,
                 IN DWORD dwFlags
                 )
{
    ( (CSmartCardStore *)hStoreProv )->CloseStore( dwFlags );
    delete (CSmartCardStore *)hStoreProv;
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardProvDeleteCert
//
//  Synopsis:   provider delete cert entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI SmartCardProvDeleteCert (
                 IN HCERTSTOREPROV hStoreProv,
                 IN PCCERT_CONTEXT pCertContext,
                 IN DWORD dwFlags
                 )
{
    return( ( (CSmartCardStore *)hStoreProv )->DeleteCert( 
                                                     pCertContext, 
                                                     dwFlags 
                                                     ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardProvSetCertProperty
//
//  Synopsis:   provider set cert property entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI SmartCardProvSetCertProperty (
                 IN HCERTSTOREPROV hStoreProv,
                 IN PCCERT_CONTEXT pCertContext,
                 IN DWORD dwPropId,
                 IN DWORD dwFlags,
                 IN const void* pvData
                 )
{
    return( ( (CSmartCardStore *)hStoreProv )->SetCertProperty(
                                                  pCertContext,
                                                  dwPropId,
                                                  dwFlags,
                                                  pvData
                                                  ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardProvWriteCert
//
//  Synopsis:   provider write cert entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI SmartCardProvWriteCert (
                 IN HCERTSTOREPROV hStoreProv,
                 IN PCCERT_CONTEXT pCertContext,
                 IN DWORD dwFlags
                 )
{
    return( ( (CSmartCardStore *)hStoreProv )->WriteCert( 
                                                    pCertContext, 
                                                    dwFlags 
                                                    ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SmartCardProvStoreControl
//
//  Synopsis:   provider store control entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI SmartCardProvStoreControl (
                 IN HCERTSTOREPROV hStoreProv,
                 IN DWORD dwFlags,
                 IN DWORD dwCtrlType,
                 IN LPVOID pvCtrlPara
                 )
{
    return( ( (CSmartCardStore *)hStoreProv )->StoreControl( 
                                                    dwFlags, 
                                                    dwCtrlType, 
                                                    pvCtrlPara 
                                                    ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SCStoreParseOpenFilter
//
//  Synopsis:   parse open filter
//
//----------------------------------------------------------------------------
BOOL WINAPI
SCStoreParseOpenFilter (
       IN LPWSTR pwszOpenFilter,
       OUT LPWSTR* ppwszCardName,
       OUT LPWSTR* ppwszProvider,
       OUT DWORD* pdwProviderType,
       OUT LPWSTR* ppwszContainer
       )
{
    LPWSTR pwsz;
    DWORD  cw = wcslen( pwszOpenFilter ) + 1;
    DWORD  cParse = 1;
    DWORD  cCount;
    DWORD  aParse[PARSE_ELEM];
    LPWSTR pwszCardName;
    LPWSTR pwszProvider;
    LPSTR  pszProviderType;
    DWORD  dwProviderType;
    LPWSTR pwszContainer;
    
    pwsz = new WCHAR [ cw ];                                   
    if ( pwsz == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }
    
    wcscpy( pwsz, pwszOpenFilter );
    memset( aParse, 0, sizeof( aParse ) );
    
    for ( cCount = 0; ( cCount < cw ) && ( cParse < PARSE_ELEM ); cCount++ )
    {
        if ( pwsz[cCount] == L'\\' )
        {
            aParse[cParse++] = cCount + 1;
            pwsz[cCount] = L'\0';
        }
    }
    
    if ( cParse < PARSE_ELEM - 1 )
    {
        delete pwsz;
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }
    
    pwszCardName = new WCHAR [wcslen( &pwsz[aParse[0]] ) + 1];
    pwszProvider = new WCHAR [wcslen( &pwsz[aParse[1]] ) + 1];
    cw = wcslen( &pwsz[aParse[2]] ) + 1;
    pszProviderType = new CHAR [cw];
    pwszContainer = new WCHAR [wcslen( &pwsz[aParse[3]] ) + 1];
    
    if ( ( pwszCardName == NULL ) || ( pwszProvider == NULL ) ||
         ( pszProviderType == NULL ) || ( pwszContainer == NULL ) )
    {
        delete pwszCardName;
        delete pwszProvider;
        delete pszProviderType;
        delete pwszContainer;
        delete pwsz;
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }
    
    wcscpy( pwszCardName, &pwsz[aParse[0]] );
    wcscpy( pwszProvider, &pwsz[aParse[1]] );
    
    WideCharToMultiByte(
        CP_ACP,
        0,
        &pwsz[aParse[2]],
        cw,
        pszProviderType,
        cw,
        NULL,
        NULL
        );
    
    dwProviderType = atol( pszProviderType );
    wcscpy( pwszContainer, &pwsz[aParse[3]] );
    
    *ppwszCardName = pwszCardName;
    *ppwszProvider = pwszProvider;
    *pdwProviderType = dwProviderType;
    *ppwszContainer = pwszContainer;               
                   
    delete pszProviderType;
    delete pwsz;
    
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   SCStoreAcquireHandleForCertKeyPair
//
//  Synopsis:   get the provider handle corresponding to the key pair
//              identified by the public key given in the cert context
//
//----------------------------------------------------------------------------
BOOL WINAPI
SCStoreAcquireHandleForCertKeyPair (
       IN HCRYPTPROV hContainer,
       IN PCCERT_CONTEXT pCertContext,
       OUT HCRYPTKEY* phKeyPair
       )
{
    BOOL  fResult;
    DWORD dwKeySpec = AT_SIGNATURE;
    
    fResult = I_CertCompareCertAndProviderPublicKey(
                    pCertContext,
                    hContainer,
                    dwKeySpec
                    );
                    
    if ( fResult == FALSE )
    {
        dwKeySpec = AT_KEYEXCHANGE;
        
        fResult = I_CertCompareCertAndProviderPublicKey(
                        pCertContext,
                        hContainer,
                        dwKeySpec
                        );
    }
    
    if ( fResult == TRUE )
    {
        fResult = CryptGetUserKey( hContainer, dwKeySpec, phKeyPair );
    }
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SCStoreWriteCertToCard
//
//  Synopsis:   write the cert to the card
//
//----------------------------------------------------------------------------
BOOL WINAPI
SCStoreWriteCertToCard (
       IN OPTIONAL PCCERT_CONTEXT pCertContext,
       IN HCRYPTKEY hKeyPair
       )
{
    LPBYTE pbEncoded = NULL;
    
    if ( pCertContext != NULL )
    {
        pbEncoded = pCertContext->pbCertEncoded;
    }
    
    return( CryptSetKeyParam( hKeyPair, KP_CERTIFICATE, pbEncoded, 0 ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\syscert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       syscert.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"

HCERTSTORE WINAPI CertOpenSystemStoreA(HCRYPTPROV  hProv,
                                                const char * szSubsystemProtocol) {

    DWORD dwFlags = CERT_STORE_NO_CRYPT_RELEASE_FLAG;
    if (0 == _stricmp(szSubsystemProtocol, "SPC"))
        dwFlags |= CERT_SYSTEM_STORE_LOCAL_MACHINE;
    else
        dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
    return CertOpenStore(
        CERT_STORE_PROV_SYSTEM_A,
        0,                          // dwEncodingType
        hProv,
        dwFlags,
        (const void *) szSubsystemProtocol
        );
}

HCERTSTORE WINAPI CertOpenSystemStoreW(HCRYPTPROV  hProv, 
                                                const WCHAR * wcsSubsystemProtocol) {

    DWORD dwFlags = CERT_STORE_NO_CRYPT_RELEASE_FLAG;
    if (0 == _wcsicmp(wcsSubsystemProtocol, L"SPC"))
        dwFlags |= CERT_SYSTEM_STORE_LOCAL_MACHINE;
    else
        dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER;
    return CertOpenStore(
        CERT_STORE_PROV_SYSTEM_W,
        0,                          // dwEncodingType
        hProv,
        dwFlags,
        (const void *) wcsSubsystemProtocol
        );
}

BOOL WINAPI CertAddEncodedCertificateToSystemStoreA(
    const char *    szCertStoreName,
    const BYTE *    pbCertEncoded,
    DWORD           cbCertEncoded
    )
{

    HCERTSTORE      hStore = NULL;
    BOOL            fOk;

    fOk =
          (hStore = CertOpenSystemStoreA(NULL, szCertStoreName)) != NULL                                 &&
          CertAddEncodedCertificateToStore(hStore, X509_ASN_ENCODING,
                pbCertEncoded, cbCertEncoded, CERT_STORE_ADD_USE_EXISTING,
                NULL);

    if(hStore != NULL)
        CertCloseStore(hStore, 0);

    return(fOk);
}

BOOL WINAPI CertAddEncodedCertificateToSystemStoreW(
    const WCHAR *   wcsCertStoreName,
    const BYTE *    pbCertEncoded,
    DWORD           cbCertEncoded
    )
{

    HCERTSTORE      hStore = NULL;
    BOOL            fOk;

    fOk =
          (hStore = CertOpenSystemStoreW(NULL, wcsCertStoreName)) != NULL                                &&
          CertAddEncodedCertificateToStore(hStore, X509_ASN_ENCODING,
            pbCertEncoded, cbCertEncoded, CERT_STORE_ADD_USE_EXISTING, NULL);

    if(hStore != NULL)
        CertCloseStore(hStore, 0);

    return(fOk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\selfsign.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       selfsign.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

PCCERT_CONTEXT
WINAPI
CertCreateSelfSignCertificate(
    IN          HCRYPTPROV                  hProv,          
    IN          PCERT_NAME_BLOB             pSubjectIssuerBlob,
    IN          DWORD                       dwFlags,
    OPTIONAL    PCRYPT_KEY_PROV_INFO        pKeyProvInfo,
    OPTIONAL    PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    OPTIONAL    PSYSTEMTIME                 pStartTime,
    OPTIONAL    PSYSTEMTIME                 pEndTime,
    OPTIONAL    PCERT_EXTENSIONS            pExtensions
    ) {

    PCCERT_CONTEXT              pCertContext    = NULL;
    DWORD                       errBefore       = GetLastError();
    DWORD                       err             = ERROR_SUCCESS;
    DWORD                       cbPubKeyInfo    = 0;
    PCERT_PUBLIC_KEY_INFO       pPubKeyInfo     = NULL;
    BYTE *                      pbCert          = NULL;
    DWORD                       cbCert          = 0;
    LPSTR                       sz              = NULL;
    DWORD                       cb              = 0;
    BYTE *                      pbToBeSigned    = NULL;
    BYTE *                      pbSignature     = NULL;

    CERT_INFO                   certInfo;
    GUID                        serialNbr;
    CRYPT_KEY_PROV_INFO         keyProvInfo;
    CERT_SIGNED_CONTENT_INFO    sigInfo;
    
    CRYPT_ALGORITHM_IDENTIFIER  algID;

    LPWSTR                      wsz             = NULL;
    BOOL                        fFreehProv      = FALSE;
    HCRYPTKEY                   hKey            = NULL;
    UUID                        guidContainerName;
    RPC_STATUS                  RpcStatus;

    memset(&certInfo, 0, sizeof(CERT_INFO));
    memset(&serialNbr, 0, sizeof(serialNbr));
    memset(&keyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));
    memset(&sigInfo, 0, sizeof(CERT_SIGNED_CONTENT_INFO));

    // do key spec now because we need it
    if(pKeyProvInfo == NULL) 
        keyProvInfo.dwKeySpec = AT_SIGNATURE;
    else 
        keyProvInfo.dwKeySpec = pKeyProvInfo->dwKeySpec;

    // see if we have an hProv, if not, create one
    if(hProv == NULL) {

        fFreehProv = TRUE;

        // if not prov info, make one up, signing RSA cert, default provider
        if(pKeyProvInfo == NULL) {

            RpcStatus = UuidCreate(&guidContainerName);
            if (!(RPC_S_OK == RpcStatus ||
                    RPC_S_UUID_LOCAL_ONLY == RpcStatus)) {
                // Use stack randomness
                ;
            }

            // note: unlike UUidToString, always must LocalFree() returned memory
            UuidToStringU(&guidContainerName, &wsz);
        
    	    if( !CryptAcquireContextU(
    	        &hProv,
                 wsz,
                 NULL,
                 PROV_RSA_FULL,
                 CRYPT_NEWKEYSET) ) {
                 hProv = NULL;
                goto ErrorCryptAcquireContext;                
            }
        }
        else {

            // first use the existing keyset
    	    if( !CryptAcquireContextU(
    	        &hProv,
                 pKeyProvInfo->pwszContainerName,
                 pKeyProvInfo->pwszProvName,
                 pKeyProvInfo->dwProvType,
                 pKeyProvInfo->dwFlags) )  {

                // otherwise generate a keyset
        	    if( !CryptAcquireContextU(
        	        &hProv,
                     pKeyProvInfo->pwszContainerName,
                     pKeyProvInfo->pwszProvName,
                     pKeyProvInfo->dwProvType,
                     pKeyProvInfo->dwFlags | CRYPT_NEWKEYSET) )  {
                    hProv = NULL;
                    goto ErrorCryptAcquireContext; 
                }
            }
        }

        // we have the keyset, now make sure we have the key gen'ed
        if( !CryptGetUserKey(   hProv,
                                keyProvInfo.dwKeySpec,
                                &hKey) ) {

            // doesn't exist so gen it                        
            assert(hKey == NULL);
            if(!CryptGenKey(    hProv, 
                                keyProvInfo.dwKeySpec, 
                                0,
                                &hKey) ) {
                goto ErrorCryptGenKey;
            }
        }
    }

    // get the exportable public key bits
    if( !CryptExportPublicKeyInfo( hProv,
                            keyProvInfo.dwKeySpec, 
                            X509_ASN_ENCODING,
                            NULL, 
                            &cbPubKeyInfo)                              ||
        (pPubKeyInfo =
            (PCERT_PUBLIC_KEY_INFO) PkiNonzeroAlloc(cbPubKeyInfo)) == NULL      ||
        !CryptExportPublicKeyInfo( hProv,
                            keyProvInfo.dwKeySpec, 
                            X509_ASN_ENCODING,
                            pPubKeyInfo,
                            &cbPubKeyInfo) )
        goto ErrorCryptExportPublicKeyInfo;

    // default if we don't have an algid
    if(pSignatureAlgorithm == NULL) {
        memset(&algID, 0, sizeof(algID));
        algID.pszObjId = szOID_OIWSEC_sha1RSASign;
        pSignatureAlgorithm = &algID;
    }

    // make a temp cert, only care about key info
    // and serial number for uniqueness
    RpcStatus = UuidCreate(&serialNbr);
    if (!(RPC_S_OK == RpcStatus || RPC_S_UUID_LOCAL_ONLY == RpcStatus)) {
        // Use stack randomness.
        ;
    }
    certInfo.dwVersion              = CERT_V3;
    certInfo.SubjectPublicKeyInfo   = *pPubKeyInfo;
    certInfo.SerialNumber.cbData    = sizeof(serialNbr);
    certInfo.SerialNumber.pbData    = (BYTE *) &serialNbr;
    certInfo.SignatureAlgorithm     = *pSignatureAlgorithm;
    certInfo.Issuer                 = *pSubjectIssuerBlob;
    certInfo.Subject                = *pSubjectIssuerBlob;

    // only put in extensions if we have them
    if( pExtensions != NULL) {
        certInfo.cExtension             = pExtensions->cExtension;
        certInfo.rgExtension            = pExtensions->rgExtension;
    }

    //default if we don't have times
    if(pStartTime == NULL)
	GetSystemTimeAsFileTime(&certInfo.NotBefore);
    else if(!SystemTimeToFileTime(pStartTime, &certInfo.NotBefore))
	goto ErrorSystemTimeToFileTime;

    if(pEndTime == NULL)
	*(((DWORDLONG UNALIGNED *) &certInfo.NotAfter)) =
	    *(((DWORDLONG UNALIGNED *) &certInfo.NotBefore)) +
	    0x11F03C3613000i64;
    else if(!SystemTimeToFileTime(pEndTime, &certInfo.NotAfter))
	goto ErrorSystemTimeToFileTime;
    
    // encode the cert
    if( !CryptEncodeObject(
            CRYPT_ASN_ENCODING, X509_CERT_TO_BE_SIGNED,
            &certInfo,
            NULL,           // pbEncoded
            &sigInfo.ToBeSigned.cbData
            )                                               ||
        (pbToBeSigned = (BYTE *) 
            PkiNonzeroAlloc(sigInfo.ToBeSigned.cbData)) == NULL     ||
        !CryptEncodeObject(
            CRYPT_ASN_ENCODING, X509_CERT_TO_BE_SIGNED,
            &certInfo,
            pbToBeSigned,
            &sigInfo.ToBeSigned.cbData
            ) ) 
        goto ErrorEncodeTempCertToBeSigned;
    sigInfo.ToBeSigned.pbData = pbToBeSigned;

    // sign the certificate
    sigInfo.SignatureAlgorithm = certInfo.SignatureAlgorithm;

    // this is to work around an OSS bug of not accepting zero length bit strings
    // this is only needed if we don't actually sign the code.
    sigInfo.Signature.pbData = (BYTE *) &sigInfo;
    sigInfo.Signature.cbData = 1;
    
    if( (CERT_CREATE_SELFSIGN_NO_SIGN & dwFlags) == 0 ) {
        if( !CryptSignCertificate(
                hProv,
                keyProvInfo.dwKeySpec,
                CRYPT_ASN_ENCODING,
                sigInfo.ToBeSigned.pbData,
                sigInfo.ToBeSigned.cbData,
                &sigInfo.SignatureAlgorithm,
                NULL,
                NULL,
                &sigInfo.Signature.cbData)      ||
        (pbSignature = (BYTE *) 
            PkiNonzeroAlloc(sigInfo.Signature.cbData)) == NULL     ||
        !CryptSignCertificate(
                hProv,
                keyProvInfo.dwKeySpec,
                CRYPT_ASN_ENCODING,
                sigInfo.ToBeSigned.pbData,
                sigInfo.ToBeSigned.cbData,
                &sigInfo.SignatureAlgorithm,
                NULL,
                pbSignature,
                &sigInfo.Signature.cbData)  )
            goto ErrorCryptSignCertificate;
        sigInfo.Signature.pbData = pbSignature;
    }
    
    // encode the final cert.
    if( !CryptEncodeObject(
            CRYPT_ASN_ENCODING,
            X509_CERT,
            &sigInfo,
            NULL,
            &cbCert
            )                               ||
        (pbCert = (BYTE *)               
            PkiNonzeroAlloc(cbCert)) == NULL     ||
        !CryptEncodeObject(
            CRYPT_ASN_ENCODING,
            X509_CERT,
            &sigInfo,
            pbCert, 
            &cbCert ) ) 
        goto ErrorEncodeTempCert;            

     // get a cert context from the encoding
    if( (pCertContext = CertCreateCertificateContext(
        CRYPT_ASN_ENCODING,
        pbCert,
        cbCert)) == NULL ) 
        goto ErrorCreateTempCertContext;

    if( (CERT_CREATE_SELFSIGN_NO_KEY_INFO & dwFlags) == 0 ) {
    
        // get the key prov info
        if(pKeyProvInfo == NULL)   {
        
            // get a key prov info from the hProv
            if( !CryptGetProvParam( hProv,
                                PP_NAME,
                                NULL,
                                &cb,
                                0)                  ||
                (sz = (char *) PkiNonzeroAlloc(cb)) == NULL ||
                !CryptGetProvParam( hProv,
                                PP_NAME,
                                (BYTE *) sz,
                                &cb,
                                0) )
                goto ErrorGetProvName;
            keyProvInfo.pwszProvName = MkWStr(sz);
            PkiFree(sz);
            sz = NULL;

            cb = 0; 
            if( !CryptGetProvParam( hProv,
                                PP_CONTAINER,
                                NULL,
                                &cb,
                                0)                  ||
                (sz = (char *) PkiNonzeroAlloc(cb)) == NULL ||
                !CryptGetProvParam( hProv,
                                PP_CONTAINER,
                                (BYTE *) sz,
                                &cb,
                                0) )
                goto ErrorGetContainerName;
            keyProvInfo.pwszContainerName = MkWStr(sz);

            cb = sizeof(keyProvInfo.dwProvType);
            if( !CryptGetProvParam( hProv,
                                PP_PROVTYPE,
                                (BYTE *) &keyProvInfo.dwProvType,
                                &cb,
                                0) )
                goto ErrorGetProvType;
            
            pKeyProvInfo = &keyProvInfo;
        }

        // put the key property on the certificate
        if( !CertSetCertificateContextProperty(
                pCertContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                0,
                pKeyProvInfo) )
            goto ErrorSetTempCertPropError;
    }
        
CommonReturn:

    if(hKey != NULL)
        CryptDestroyKey(hKey);
        
    if(fFreehProv && hProv != NULL)
        CryptReleaseContext(hProv, 0);
        
    if(keyProvInfo.pwszProvName != NULL)
        FreeWStr(keyProvInfo.pwszProvName);

    if(keyProvInfo.pwszContainerName != NULL)
        FreeWStr(keyProvInfo.pwszContainerName);

    if(wsz != NULL)
        LocalFree(wsz);

    PkiFree(pPubKeyInfo);
    PkiFree(pbToBeSigned);
    PkiFree(pbSignature);
    PkiFree(pbCert);
    PkiFree(sz);

    // don't know if we have an error or not
    // but I do know the errBefore is set properly
    SetLastError(errBefore);

    return(pCertContext);

ErrorReturn:

    if(GetLastError() == ERROR_SUCCESS) 
        SetLastError((DWORD) E_UNEXPECTED);
    err = GetLastError();

    // We have an error, make sure we set it.
    errBefore = GetLastError();

    if(pCertContext != NULL)
        CertFreeCertificateContext(pCertContext);
    pCertContext = NULL;     

    goto CommonReturn;

TRACE_ERROR(ErrorCryptGenKey);
TRACE_ERROR(ErrorCryptAcquireContext);
TRACE_ERROR(ErrorCryptExportPublicKeyInfo);
TRACE_ERROR(ErrorEncodeTempCertToBeSigned);
TRACE_ERROR(ErrorEncodeTempCert);
TRACE_ERROR(ErrorCreateTempCertContext);
TRACE_ERROR(ErrorGetProvName);
TRACE_ERROR(ErrorGetContainerName);
TRACE_ERROR(ErrorGetProvType);
TRACE_ERROR(ErrorSetTempCertPropError);
TRACE_ERROR(ErrorCryptSignCertificate);
TRACE_ERROR(ErrorSystemTimeToFileTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\scstore.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       scstore.h
//
//  Contents:   Smart Card Store Provider
//
//  History:    11-25-1997    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__SCSTORE_H__)
#define __SCSTORE_H__

//
// Store provider open store function name
//

#define SMART_CARD_OPEN_STORE_PROV_FUNC "SmartCardProvOpenStore"

//
// CSmartCardStore.  This class implements all callbacks for the Smart Card
// Store provider.  A pointer to an instance of this class is used as the 
// hStoreProv parameter for the callback functions implemented
//

class CSmartCardStore
{
public:

    //
    // Construction
    //

    CSmartCardStore ();
    ~CSmartCardStore ();

    //
    // Store functions
    //

    BOOL OpenStore (
             LPCSTR pszStoreProv,
             DWORD dwMsgAndCertEncodingType,
             HCRYPTPROV hCryptProv,
             DWORD dwFlags,
             const void* pvPara,
             HCERTSTORE hCertStore,
             PCERT_STORE_PROV_INFO pStoreProvInfo
             );

    VOID CloseStore (DWORD dwFlags);

    BOOL DeleteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags);

    BOOL SetCertProperty (
            PCCERT_CONTEXT pCertContext,
            DWORD dwPropId,
            DWORD dwFlags,
            const void* pvPara
            );

    BOOL WriteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags);

    BOOL StoreControl (DWORD dwFlags, DWORD dwCtrlType, LPVOID pvCtrlPara);
    
    BOOL Resync ();

private:

    //
    // Object lock
    //
    
    CRITICAL_SECTION m_StoreLock;          
    
    //
    // Open Store flags
    //

    DWORD            m_dwOpenFlags;
    
    //
    // Open filter parameters
    //
    
    LPWSTR           m_pwszCardName;
    LPWSTR           m_pwszProvider;
    DWORD            m_dwProviderType;
    LPWSTR           m_pwszContainer;
    
    //
    // Cache Store
    //
    
    HCERTSTORE       m_hCacheStore;
    
    //
    // Private methods
    //

    BOOL FillCacheStore (BOOL fClearCache);    
    
    BOOL ModifyCertOnCard (PCCERT_CONTEXT pCertContext, BOOL fDelete);
};

//
// Smart Card Store Provider functions
//

BOOL WINAPI SmartCardProvOpenStore (
                 IN LPCSTR pszStoreProv,
                 IN DWORD dwMsgAndCertEncodingType,
                 IN HCRYPTPROV hCryptProv,
                 IN DWORD dwFlags,
                 IN const void* pvPara,
                 IN HCERTSTORE hCertStore,
                 IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
                 );

void WINAPI SmartCardProvCloseStore (
                 IN HCERTSTOREPROV hStoreProv,
                 IN DWORD dwFlags
                 );

BOOL WINAPI SmartCardProvDeleteCert (
                 IN HCERTSTOREPROV hStoreProv,
                 IN PCCERT_CONTEXT pCertContext,
                 IN DWORD dwFlags
                 );

BOOL WINAPI SmartCardProvSetCertProperty (
                 IN HCERTSTOREPROV hStoreProv,
                 IN PCCERT_CONTEXT pCertContext,
                 IN DWORD dwPropId,
                 IN DWORD dwFlags,
                 IN const void* pvData
                 );

BOOL WINAPI SmartCardProvWriteCert (
                 IN HCERTSTOREPROV hStoreProv,
                 IN PCCERT_CONTEXT pCertContext,
                 IN DWORD dwFlags
                 );

BOOL WINAPI SmartCardProvStoreControl (
                 IN HCERTSTOREPROV hStoreProv,
                 IN DWORD dwFlags,
                 IN DWORD dwCtrlType,
                 IN LPVOID pvCtrlPara
                 );

//
// Smart Card Store Provider Function table
//

static void* const rgpvSmartCardProvFunc[] = {

    // CERT_STORE_PROV_CLOSE_FUNC              0
    SmartCardProvCloseStore,
    // CERT_STORE_PROV_READ_CERT_FUNC          1
    NULL,
    // CERT_STORE_PROV_WRITE_CERT_FUNC         2
    SmartCardProvWriteCert,
    // CERT_STORE_PROV_DELETE_CERT_FUNC        3
    SmartCardProvDeleteCert,
    // CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC  4
    SmartCardProvSetCertProperty,
    // CERT_STORE_PROV_READ_CRL_FUNC           5
    NULL,
    // CERT_STORE_PROV_WRITE_CRL_FUNC          6
    NULL,
    // CERT_STORE_PROV_DELETE_CRL_FUNC         7
    NULL,
    // CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC   8
    NULL,
    // CERT_STORE_PROV_READ_CTL_FUNC           9
    NULL,
    // CERT_STORE_PROV_WRITE_CTL_FUNC          10
    NULL,
    // CERT_STORE_PROV_DELETE_CTL_FUNC         11
    NULL,
    // CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC   12
    NULL,
    // CERT_STORE_PROV_CONTROL_FUNC            13
    SmartCardProvStoreControl
};

#define SMART_CARD_PROV_FUNC_COUNT (sizeof(rgpvSmartCardProvFunc) / \
                                    sizeof(rgpvSmartCardProvFunc[0]))
       
//
// Smart Card Store Helper Functions
//

BOOL WINAPI
SCStoreParseOpenFilter (
       IN LPWSTR pwszOpenFilter,
       OUT LPWSTR* ppwszCardName,
       OUT LPWSTR* ppwszProvider,
       OUT DWORD* pdwProviderType,
       OUT LPWSTR* ppwszContainer
       );
          
BOOL WINAPI
SCStoreAcquireHandleForCertKeyPair (
       IN HCRYPTPROV hContainer,
       IN PCCERT_CONTEXT pCertContext,
       OUT HCRYPTKEY* phKeyPair
       );
       
BOOL WINAPI
SCStoreWriteCertToCard (
       IN OPTIONAL PCCERT_CONTEXT pCertContext,
       IN HCRYPTKEY hKeyPair
       );       
       
//
// Open filter parsing definitions
//       

#define PARSE_ELEM 4
       
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\wincert.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wincert.cpp
//
//  Contents:   Certificate, Certificate Revocation List (CRL),
//              Certificate Request and Certificate Name
//              Encode/Decode APIs
//
//              ASN.1 implementation uses the ASN1 compiler.
//
//  Functions:  CryptEncodeObject
//              CryptDecodeObject
//              CryptEncodeObjectEx
//              CryptDecodeObjectEx
//
//  History:    29-Feb-96       philh   created
//              20-Jan-98       philh   added "Ex" version
//
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>

#ifndef OSS_CRYPT_ASN1
#define ASN1_SUPPORTS_UTF8_TAG       1
#endif  // OSS_CRYPT_ASN1

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

static const BYTE NullDer[2] = {0x05, 0x00};
static const CRYPT_OBJID_BLOB NullDerBlob = {2, (BYTE *)&NullDer[0]};

HCRYPTASN1MODULE hX509Asn1Module;

HCRYPTOIDFUNCSET hX509EncodeFuncSet;
HCRYPTOIDFUNCSET hX509DecodeFuncSet;
HCRYPTOIDFUNCSET hX509EncodeExFuncSet;
HCRYPTOIDFUNCSET hX509DecodeExFuncSet;


//+-------------------------------------------------------------------------
//  Function:  GetEncoder/GetDecoder
//
//  Synopsis:  Initialize thread local storage for the asn libs
//
//  Returns:   pointer to an initialized Asn1 encoder/decoder data
//             structures
//--------------------------------------------------------------------------
static inline ASN1encoding_t GetEncoder(void)
{
    return I_CryptGetAsn1Encoder(hX509Asn1Module);
}
static inline ASN1decoding_t GetDecoder(void)
{
    return I_CryptGetAsn1Decoder(hX509Asn1Module);
}

typedef BOOL (WINAPI *PFN_ENCODE_FUNC) (
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const void *pvStructInfo,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

typedef BOOL (WINAPI *PFN_DECODE_FUNC) (
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

typedef BOOL (WINAPI *PFN_ENCODE_EX_FUNC) (
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const void *pvStructInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

typedef BOOL (WINAPI *PFN_DECODE_EX_FUNC) (
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  ASN1 X509 v3 ASN.1 Encode / Decode functions
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CSPProviderEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_CSP_PROVIDER pCSPProvider,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

BOOL WINAPI Asn1CSPProviderDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
        
BOOL WINAPI Asn1NameValueEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ENROLLMENT_NAME_VALUE_PAIR pNameValue,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
        
BOOL WINAPI Asn1NameValueDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509CertInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CertInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509CrlInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CrlInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509CertRequestInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_REQUEST_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CertRequestInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509KeygenRequestInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEYGEN_REQUEST_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509KeygenRequestInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509SignedContentEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_SIGNED_CONTENT_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509SignedContentDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509NameInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509NameInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509NameValueEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_VALUE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509NameValueDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  ASN1 ASN.1 X509 Certificate Extensions Encode / Decode functions
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ExtensionsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_EXTENSIONS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509ExtensionsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );


//+-------------------------------------------------------------------------
//  ASN1 ASN.1 Public Key Info Encode / Decode functions
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509PublicKeyInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_PUBLIC_KEY_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509PublicKeyInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  ASN1 ASN.1 PKCS#1 RSAPublicKey Encode / Decode functions
//--------------------------------------------------------------------------
BOOL WINAPI Asn1RSAPublicKeyStrucEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PUBLICKEYSTRUC *pPubKeyStruc,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1RSAPublicKeyStrucDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  ASN1 X509 v3 Extension ASN.1 Encode / Decode functions
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityKeyIdEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_KEY_ID_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509AuthorityKeyIdDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509AuthorityKeyId2EncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_KEY_ID2_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509AuthorityKeyId2DecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509KeyAttributesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEY_ATTRIBUTES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509KeyAttributesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509AltNameEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_ALT_NAME_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509AltNameDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509KeyUsageRestrictionEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEY_USAGE_RESTRICTION_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509KeyUsageRestrictionDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509BasicConstraintsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_BASIC_CONSTRAINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509BasicConstraintsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509BasicConstraints2EncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_BASIC_CONSTRAINTS2_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509BasicConstraints2DecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509BitsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509BitsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509BitsWithoutTrailingZeroesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CertPoliciesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICIES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CertPoliciesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509CertPoliciesQualifier1DecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );


BOOL WINAPI Asn1X509PKIXUserNoticeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICY_QUALIFIER_USER_NOTICE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

BOOL WINAPI Asn1X509PKIXUserNoticeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509AuthorityInfoAccessEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_INFO_ACCESS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509AuthorityInfoAccessDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509CrlDistPointsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_DIST_POINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CrlDistPointsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509IntegerEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN int *pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509IntegerDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509MultiByteIntegerEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_INTEGER_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509MultiByteIntegerDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509EnumeratedEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN int *pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509EnumeratedDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509OctetStringEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_DATA_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509OctetStringDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509ChoiceOfTimeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN LPFILETIME pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509ChoiceOfTimeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509AttributeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ATTRIBUTE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509AttributeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509ContentInfoSequenceOfAnyEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509ContentInfoSequenceOfAnyDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509ContentInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_CONTENT_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509ContentInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509SequenceOfAnyEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_SEQUENCE_OF_ANY pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509SequenceOfAnyDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509MultiByteUINTEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_UINT_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509MultiByteUINTDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509DSSParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_DSS_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509DSSParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509DSSSignatureEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BYTE rgbSignature[CERT_DSS_SIGNATURE_LEN],
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509DSSSignatureDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509DHParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_DH_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509DHParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X942DhParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_X942_DH_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X942DhParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X942OtherInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_X942_OTHER_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X942OtherInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1RC2CBCParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_RC2_CBC_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1RC2CBCParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1SMIMECapabilitiesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_SMIME_CAPABILITIES pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1SMIMECapabilitiesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1UtcTimeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN FILETIME * pFileTime,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1UtcTimeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1TimeStampRequestInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_TIME_STAMP_REQUEST_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

BOOL WINAPI Asn1TimeStampRequestInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509AttributesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ATTRIBUTES pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509AttributesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  ASN1 X509 Certificate Trust List (CTL) ASN.1 Encode / Decode functions
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CtlUsageEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_USAGE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CtlUsageDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );
BOOL WINAPI Asn1X509CtlInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CtlInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509CertPairEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_PAIR pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CertPairDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509NameConstraintsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_CONSTRAINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509NameConstraintsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509CrlIssuingDistPointEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_ISSUING_DIST_POINT pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CrlIssuingDistPointDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509PolicyMappingsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICY_MAPPINGS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509PolicyMappingsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509PolicyConstraintsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICY_CONSTRAINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509PolicyConstraintsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1X509CrossCertDistPointsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCROSS_CERT_DIST_POINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CrossCertDistPointsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+=========================================================================
//  Certificate Management Messages over CMS (CMC) Encode/Decode Functions
//==========================================================================
BOOL WINAPI Asn1CmcDataEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_DATA_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcDataDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1CmcResponseEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_RESPONSE_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcResponseDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1CmcStatusEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_STATUS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcStatusDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1CmcAddExtensionsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_ADD_EXTENSIONS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcAddExtensionsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

BOOL WINAPI Asn1CmcAddAttributesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_ADD_ATTRIBUTES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1CmcAddAttributesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+=========================================================================
//  Certificate Template Encode/Decode Functions
//==========================================================================

BOOL WINAPI Asn1X509CertTemplateEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_TEMPLATE_EXT pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL WINAPI Asn1X509CertTemplateDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

#ifndef OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Encode / Decode the "UNICODE" Name Info
//
//  from certstr.cpp
//--------------------------------------------------------------------------
extern BOOL WINAPI UnicodeNameInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
extern BOOL WINAPI UnicodeNameInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Encode / Decode the "UNICODE" Name Value
//
//  from certstr.cpp
//--------------------------------------------------------------------------
extern BOOL WINAPI UnicodeNameValueEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_VALUE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );
extern BOOL WINAPI UnicodeNameValueDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Encode sorted ctl info
//
//  from newstor.cpp
//--------------------------------------------------------------------------
extern BOOL WINAPI SortedCtlInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_INFO pCtlInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

#endif  // OSS_CRYPT_ASN1

#ifdef OSS_CRYPT_ASN1
#define ASN1_OID_OFFSET         10000 +
#define ASN1_OID_PREFIX         "OssCryptAsn1."
#else
#define ASN1_OID_OFFSET
#define ASN1_OID_PREFIX
#endif  // OSS_CRYPT_ASN1

#ifdef DEBUG_CRYPT_ASN1_MASTER
#define OSS_OID_OFFSET         10000
#define OSS_OID_PREFIX         "OssCryptAsn1."
#endif  // DEBUG_CRYPT_ASN1_MASTER

static const CRYPT_OID_FUNC_ENTRY X509EncodeExFuncTable[] = {
    ASN1_OID_OFFSET X509_CERT, Asn1X509SignedContentEncodeEx,
    ASN1_OID_OFFSET X509_CERT_TO_BE_SIGNED, Asn1X509CertInfoEncodeEx,
    ASN1_OID_OFFSET X509_CERT_CRL_TO_BE_SIGNED, Asn1X509CrlInfoEncodeEx,
    ASN1_OID_OFFSET X509_CERT_REQUEST_TO_BE_SIGNED, Asn1X509CertRequestInfoEncodeEx,
    ASN1_OID_OFFSET X509_EXTENSIONS, Asn1X509ExtensionsEncodeEx,
    ASN1_OID_OFFSET X509_NAME_VALUE, Asn1X509NameValueEncodeEx,
    ASN1_OID_OFFSET X509_NAME, Asn1X509NameInfoEncodeEx,
    ASN1_OID_OFFSET X509_PUBLIC_KEY_INFO, Asn1X509PublicKeyInfoEncodeEx,
    ASN1_OID_OFFSET X509_AUTHORITY_KEY_ID, Asn1X509AuthorityKeyIdEncodeEx,
    ASN1_OID_OFFSET X509_KEY_ATTRIBUTES, Asn1X509KeyAttributesEncodeEx,
    ASN1_OID_OFFSET X509_KEY_USAGE_RESTRICTION, Asn1X509KeyUsageRestrictionEncodeEx,
    ASN1_OID_OFFSET X509_ALTERNATE_NAME, Asn1X509AltNameEncodeEx,
    ASN1_OID_OFFSET X509_BASIC_CONSTRAINTS, Asn1X509BasicConstraintsEncodeEx,
    ASN1_OID_OFFSET X509_KEY_USAGE, Asn1X509BitsWithoutTrailingZeroesEncodeEx,
    ASN1_OID_OFFSET X509_BASIC_CONSTRAINTS2, Asn1X509BasicConstraints2EncodeEx,
    ASN1_OID_OFFSET X509_CERT_POLICIES, Asn1X509CertPoliciesEncodeEx,
    ASN1_OID_OFFSET PKCS_UTC_TIME, Asn1UtcTimeEncodeEx,
    ASN1_OID_OFFSET PKCS_TIME_REQUEST, Asn1TimeStampRequestInfoEncodeEx,
    ASN1_OID_OFFSET RSA_CSP_PUBLICKEYBLOB, Asn1RSAPublicKeyStrucEncodeEx,
#ifndef OSS_CRYPT_ASN1
    ASN1_OID_OFFSET X509_UNICODE_NAME, UnicodeNameInfoEncodeEx,
#endif  // OSS_CRYPT_ASN1

    ASN1_OID_OFFSET X509_KEYGEN_REQUEST_TO_BE_SIGNED, Asn1X509KeygenRequestInfoEncodeEx,
    ASN1_OID_OFFSET PKCS_ATTRIBUTE, Asn1X509AttributeEncodeEx,
    ASN1_OID_OFFSET PKCS_CONTENT_INFO_SEQUENCE_OF_ANY, Asn1X509ContentInfoSequenceOfAnyEncodeEx,
#ifndef OSS_CRYPT_ASN1
    ASN1_OID_OFFSET X509_UNICODE_NAME_VALUE, UnicodeNameValueEncodeEx,
#endif  // OSS_CRYPT_ASN1
    ASN1_OID_OFFSET X509_OCTET_STRING, Asn1X509OctetStringEncodeEx,
    ASN1_OID_OFFSET X509_BITS, Asn1X509BitsEncodeEx,
    ASN1_OID_OFFSET X509_INTEGER, Asn1X509IntegerEncodeEx,
    ASN1_OID_OFFSET X509_MULTI_BYTE_INTEGER, Asn1X509MultiByteIntegerEncodeEx,
    ASN1_OID_OFFSET X509_ENUMERATED, Asn1X509EnumeratedEncodeEx,
    ASN1_OID_OFFSET X509_CHOICE_OF_TIME, Asn1X509ChoiceOfTimeEncodeEx,
    ASN1_OID_OFFSET X509_AUTHORITY_KEY_ID2, Asn1X509AuthorityKeyId2EncodeEx, 
    ASN1_OID_OFFSET X509_AUTHORITY_INFO_ACCESS, Asn1X509AuthorityInfoAccessEncodeEx,
    ASN1_OID_OFFSET PKCS_CONTENT_INFO, Asn1X509ContentInfoEncodeEx,
    ASN1_OID_OFFSET X509_SEQUENCE_OF_ANY, Asn1X509SequenceOfAnyEncodeEx,
    ASN1_OID_OFFSET X509_CRL_DIST_POINTS, Asn1X509CrlDistPointsEncodeEx,

    ASN1_OID_OFFSET X509_ENHANCED_KEY_USAGE, Asn1X509CtlUsageEncodeEx,
    ASN1_OID_OFFSET PKCS_CTL, Asn1X509CtlInfoEncodeEx,

    ASN1_OID_OFFSET X509_MULTI_BYTE_UINT, Asn1X509MultiByteUINTEncodeEx,
    ASN1_OID_OFFSET X509_DSS_PARAMETERS, Asn1X509DSSParametersEncodeEx,
    ASN1_OID_OFFSET X509_DSS_SIGNATURE, Asn1X509DSSSignatureEncodeEx,
    ASN1_OID_OFFSET PKCS_RC2_CBC_PARAMETERS, Asn1RC2CBCParametersEncodeEx,
    ASN1_OID_OFFSET PKCS_SMIME_CAPABILITIES, Asn1SMIMECapabilitiesEncodeEx,

    ASN1_OID_PREFIX X509_PKIX_POLICY_QUALIFIER_USERNOTICE, Asn1X509PKIXUserNoticeEncodeEx,
    ASN1_OID_OFFSET X509_DH_PARAMETERS, Asn1X509DHParametersEncodeEx,
    ASN1_OID_OFFSET PKCS_ATTRIBUTES, Asn1X509AttributesEncodeEx,
#ifndef OSS_CRYPT_ASN1
    ASN1_OID_OFFSET PKCS_SORTED_CTL, SortedCtlInfoEncodeEx,
#endif  // OSS_CRYPT_ASN1

    ASN1_OID_OFFSET X942_DH_PARAMETERS, Asn1X942DhParametersEncodeEx,
    ASN1_OID_OFFSET X509_BITS_WITHOUT_TRAILING_ZEROES, Asn1X509BitsWithoutTrailingZeroesEncodeEx,

    ASN1_OID_OFFSET X942_OTHER_INFO, Asn1X942OtherInfoEncodeEx,
    ASN1_OID_OFFSET X509_CERT_PAIR, Asn1X509CertPairEncodeEx,
    ASN1_OID_OFFSET X509_ISSUING_DIST_POINT, Asn1X509CrlIssuingDistPointEncodeEx,
    ASN1_OID_OFFSET X509_NAME_CONSTRAINTS, Asn1X509NameConstraintsEncodeEx,
    ASN1_OID_OFFSET X509_POLICY_MAPPINGS, Asn1X509PolicyMappingsEncodeEx,
    ASN1_OID_OFFSET X509_POLICY_CONSTRAINTS, Asn1X509PolicyConstraintsEncodeEx,
    ASN1_OID_OFFSET X509_CROSS_CERT_DIST_POINTS, Asn1X509CrossCertDistPointsEncodeEx,

    ASN1_OID_OFFSET CMC_DATA, Asn1CmcDataEncodeEx,
    ASN1_OID_OFFSET CMC_RESPONSE, Asn1CmcResponseEncodeEx,
    ASN1_OID_OFFSET CMC_STATUS, Asn1CmcStatusEncodeEx,
    ASN1_OID_OFFSET CMC_ADD_EXTENSIONS, Asn1CmcAddExtensionsEncodeEx,
    ASN1_OID_OFFSET CMC_ADD_ATTRIBUTES, Asn1CmcAddAttributesEncodeEx,
    ASN1_OID_OFFSET X509_CERTIFICATE_TEMPLATE, Asn1X509CertTemplateEncodeEx,

    ASN1_OID_PREFIX szOID_AUTHORITY_KEY_IDENTIFIER, Asn1X509AuthorityKeyIdEncodeEx,
    ASN1_OID_PREFIX szOID_KEY_ATTRIBUTES, Asn1X509KeyAttributesEncodeEx,
    ASN1_OID_PREFIX szOID_KEY_USAGE_RESTRICTION, Asn1X509KeyUsageRestrictionEncodeEx,
    ASN1_OID_PREFIX szOID_SUBJECT_ALT_NAME, Asn1X509AltNameEncodeEx,
    ASN1_OID_PREFIX szOID_ISSUER_ALT_NAME, Asn1X509AltNameEncodeEx,
    ASN1_OID_PREFIX szOID_BASIC_CONSTRAINTS, Asn1X509BasicConstraintsEncodeEx,
    ASN1_OID_PREFIX szOID_KEY_USAGE, Asn1X509BitsWithoutTrailingZeroesEncodeEx,
    ASN1_OID_PREFIX szOID_BASIC_CONSTRAINTS2, Asn1X509BasicConstraints2EncodeEx,
    ASN1_OID_PREFIX szOID_CERT_POLICIES, Asn1X509CertPoliciesEncodeEx,

    ASN1_OID_PREFIX szOID_PKIX_POLICY_QUALIFIER_USERNOTICE, Asn1X509PKIXUserNoticeEncodeEx,

    ASN1_OID_PREFIX szOID_AUTHORITY_KEY_IDENTIFIER2, Asn1X509AuthorityKeyId2EncodeEx, 
    ASN1_OID_PREFIX szOID_SUBJECT_KEY_IDENTIFIER, Asn1X509OctetStringEncodeEx,
    ASN1_OID_PREFIX szOID_SUBJECT_ALT_NAME2, Asn1X509AltNameEncodeEx,
    ASN1_OID_PREFIX szOID_ISSUER_ALT_NAME2, Asn1X509AltNameEncodeEx,
    ASN1_OID_PREFIX szOID_CRL_REASON_CODE, Asn1X509EnumeratedEncodeEx,
    ASN1_OID_PREFIX szOID_AUTHORITY_INFO_ACCESS, Asn1X509AuthorityInfoAccessEncodeEx,
    ASN1_OID_PREFIX szOID_CRL_DIST_POINTS, Asn1X509CrlDistPointsEncodeEx,

    ASN1_OID_PREFIX szOID_CERT_EXTENSIONS, Asn1X509ExtensionsEncodeEx,
    ASN1_OID_PREFIX szOID_RSA_certExtensions, Asn1X509ExtensionsEncodeEx,
    ASN1_OID_PREFIX szOID_NEXT_UPDATE_LOCATION, Asn1X509AltNameEncodeEx,

    ASN1_OID_PREFIX szOID_ENHANCED_KEY_USAGE, Asn1X509CtlUsageEncodeEx,
    ASN1_OID_PREFIX szOID_CTL, Asn1X509CtlInfoEncodeEx,

    ASN1_OID_PREFIX szOID_RSA_RC2CBC, Asn1RC2CBCParametersEncodeEx,
    ASN1_OID_PREFIX szOID_RSA_SMIMECapabilities, Asn1SMIMECapabilitiesEncodeEx,
    ASN1_OID_PREFIX szOID_RSA_signingTime, Asn1UtcTimeEncodeEx,

    ASN1_OID_PREFIX szOID_ENROLLMENT_NAME_VALUE_PAIR, Asn1NameValueEncodeEx,
	szOID_ENROLLMENT_CSP_PROVIDER, Asn1CSPProviderEncodeEx,

    ASN1_OID_OFFSET szOID_CRL_NUMBER, Asn1X509IntegerEncodeEx,
    ASN1_OID_OFFSET szOID_DELTA_CRL_INDICATOR, Asn1X509IntegerEncodeEx,
    ASN1_OID_OFFSET szOID_ISSUING_DIST_POINT, Asn1X509CrlIssuingDistPointEncodeEx,
    ASN1_OID_PREFIX szOID_FRESHEST_CRL, Asn1X509CrlDistPointsEncodeEx,
    ASN1_OID_OFFSET szOID_NAME_CONSTRAINTS, Asn1X509NameConstraintsEncodeEx,
    ASN1_OID_OFFSET szOID_POLICY_MAPPINGS, Asn1X509PolicyMappingsEncodeEx,
    ASN1_OID_OFFSET szOID_LEGACY_POLICY_MAPPINGS, Asn1X509PolicyMappingsEncodeEx,
    ASN1_OID_OFFSET szOID_POLICY_CONSTRAINTS, Asn1X509PolicyConstraintsEncodeEx,
    ASN1_OID_OFFSET szOID_CROSS_CERT_DIST_POINTS, Asn1X509CrossCertDistPointsEncodeEx,
    ASN1_OID_OFFSET szOID_CERTIFICATE_TEMPLATE, Asn1X509CertTemplateEncodeEx,

};

#define X509_ENCODE_EX_FUNC_COUNT (sizeof(X509EncodeExFuncTable) / \
                                    sizeof(X509EncodeExFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY X509DecodeExFuncTable[] = {
    ASN1_OID_OFFSET X509_CERT, Asn1X509SignedContentDecodeEx,
    ASN1_OID_OFFSET X509_CERT_TO_BE_SIGNED, Asn1X509CertInfoDecodeEx,
    ASN1_OID_OFFSET X509_CERT_CRL_TO_BE_SIGNED, Asn1X509CrlInfoDecodeEx,
    ASN1_OID_OFFSET X509_CERT_REQUEST_TO_BE_SIGNED, Asn1X509CertRequestInfoDecodeEx,
    ASN1_OID_OFFSET X509_EXTENSIONS, Asn1X509ExtensionsDecodeEx,
    ASN1_OID_OFFSET X509_NAME_VALUE, Asn1X509NameValueDecodeEx,
    ASN1_OID_OFFSET X509_NAME, Asn1X509NameInfoDecodeEx,
    ASN1_OID_OFFSET X509_PUBLIC_KEY_INFO, Asn1X509PublicKeyInfoDecodeEx,
    ASN1_OID_OFFSET X509_AUTHORITY_KEY_ID, Asn1X509AuthorityKeyIdDecodeEx,
    ASN1_OID_OFFSET X509_KEY_ATTRIBUTES, Asn1X509KeyAttributesDecodeEx,
    ASN1_OID_OFFSET X509_KEY_USAGE_RESTRICTION, Asn1X509KeyUsageRestrictionDecodeEx,
    ASN1_OID_OFFSET X509_ALTERNATE_NAME, Asn1X509AltNameDecodeEx,
    ASN1_OID_OFFSET X509_BASIC_CONSTRAINTS, Asn1X509BasicConstraintsDecodeEx,
    ASN1_OID_OFFSET X509_KEY_USAGE, Asn1X509BitsDecodeEx,
    ASN1_OID_OFFSET X509_BASIC_CONSTRAINTS2, Asn1X509BasicConstraints2DecodeEx,
    ASN1_OID_OFFSET X509_CERT_POLICIES, Asn1X509CertPoliciesDecodeEx,
    ASN1_OID_OFFSET PKCS_UTC_TIME, Asn1UtcTimeDecodeEx,
    ASN1_OID_OFFSET PKCS_TIME_REQUEST, Asn1TimeStampRequestInfoDecodeEx,
    ASN1_OID_OFFSET RSA_CSP_PUBLICKEYBLOB, Asn1RSAPublicKeyStrucDecodeEx,
#ifndef OSS_CRYPT_ASN1
    ASN1_OID_OFFSET X509_UNICODE_NAME, UnicodeNameInfoDecodeEx,
#endif  // OSS_CRYPT_ASN1

    ASN1_OID_OFFSET X509_KEYGEN_REQUEST_TO_BE_SIGNED, Asn1X509KeygenRequestInfoDecodeEx,
    ASN1_OID_OFFSET PKCS_ATTRIBUTE, Asn1X509AttributeDecodeEx,
    ASN1_OID_OFFSET PKCS_CONTENT_INFO_SEQUENCE_OF_ANY, Asn1X509ContentInfoSequenceOfAnyDecodeEx,
#ifndef OSS_CRYPT_ASN1
    ASN1_OID_OFFSET X509_UNICODE_NAME_VALUE, UnicodeNameValueDecodeEx,
#endif  // OSS_CRYPT_ASN1
    ASN1_OID_OFFSET X509_OCTET_STRING, Asn1X509OctetStringDecodeEx,
    ASN1_OID_OFFSET X509_BITS, Asn1X509BitsDecodeEx,
    ASN1_OID_OFFSET X509_INTEGER, Asn1X509IntegerDecodeEx,
    ASN1_OID_OFFSET X509_MULTI_BYTE_INTEGER, Asn1X509MultiByteIntegerDecodeEx,
    ASN1_OID_OFFSET X509_ENUMERATED, Asn1X509EnumeratedDecodeEx,
    ASN1_OID_OFFSET X509_CHOICE_OF_TIME, Asn1X509ChoiceOfTimeDecodeEx,
    ASN1_OID_OFFSET X509_AUTHORITY_KEY_ID2, Asn1X509AuthorityKeyId2DecodeEx, 
    ASN1_OID_OFFSET X509_AUTHORITY_INFO_ACCESS, Asn1X509AuthorityInfoAccessDecodeEx,
    ASN1_OID_OFFSET PKCS_CONTENT_INFO, Asn1X509ContentInfoDecodeEx,
    ASN1_OID_OFFSET X509_SEQUENCE_OF_ANY, Asn1X509SequenceOfAnyDecodeEx,
    ASN1_OID_OFFSET X509_CRL_DIST_POINTS, Asn1X509CrlDistPointsDecodeEx,

    ASN1_OID_OFFSET X509_ENHANCED_KEY_USAGE, Asn1X509CtlUsageDecodeEx,
    ASN1_OID_OFFSET PKCS_CTL, Asn1X509CtlInfoDecodeEx,

    ASN1_OID_OFFSET X509_MULTI_BYTE_UINT, Asn1X509MultiByteUINTDecodeEx,
    ASN1_OID_OFFSET X509_DSS_PARAMETERS, Asn1X509DSSParametersDecodeEx,
    ASN1_OID_OFFSET X509_DSS_SIGNATURE, Asn1X509DSSSignatureDecodeEx,
    ASN1_OID_OFFSET PKCS_RC2_CBC_PARAMETERS, Asn1RC2CBCParametersDecodeEx,
    ASN1_OID_OFFSET PKCS_SMIME_CAPABILITIES, Asn1SMIMECapabilitiesDecodeEx,

    ASN1_OID_PREFIX X509_PKIX_POLICY_QUALIFIER_USERNOTICE, Asn1X509PKIXUserNoticeDecodeEx,
    ASN1_OID_OFFSET X509_DH_PARAMETERS, Asn1X509DHParametersDecodeEx,
    ASN1_OID_OFFSET PKCS_ATTRIBUTES, Asn1X509AttributesDecodeEx,
#ifndef OSS_CRYPT_ASN1
    ASN1_OID_OFFSET PKCS_SORTED_CTL, Asn1X509CtlInfoDecodeEx,
#endif  // OSS_CRYPT_ASN1

    ASN1_OID_OFFSET X942_DH_PARAMETERS, Asn1X942DhParametersDecodeEx,
    ASN1_OID_OFFSET X509_BITS_WITHOUT_TRAILING_ZEROES, Asn1X509BitsDecodeEx,

    ASN1_OID_OFFSET X942_OTHER_INFO, Asn1X942OtherInfoDecodeEx,
    ASN1_OID_OFFSET X509_CERT_PAIR, Asn1X509CertPairDecodeEx,
    ASN1_OID_OFFSET X509_ISSUING_DIST_POINT, Asn1X509CrlIssuingDistPointDecodeEx,
    ASN1_OID_OFFSET X509_NAME_CONSTRAINTS, Asn1X509NameConstraintsDecodeEx,
    ASN1_OID_OFFSET X509_POLICY_MAPPINGS, Asn1X509PolicyMappingsDecodeEx,
    ASN1_OID_OFFSET X509_POLICY_CONSTRAINTS, Asn1X509PolicyConstraintsDecodeEx,
    ASN1_OID_OFFSET X509_CROSS_CERT_DIST_POINTS, Asn1X509CrossCertDistPointsDecodeEx,

    ASN1_OID_OFFSET CMC_DATA, Asn1CmcDataDecodeEx,
    ASN1_OID_OFFSET CMC_RESPONSE, Asn1CmcResponseDecodeEx,
    ASN1_OID_OFFSET CMC_STATUS, Asn1CmcStatusDecodeEx,
    ASN1_OID_OFFSET CMC_ADD_EXTENSIONS, Asn1CmcAddExtensionsDecodeEx,
    ASN1_OID_OFFSET CMC_ADD_ATTRIBUTES, Asn1CmcAddAttributesDecodeEx,
    ASN1_OID_OFFSET X509_CERTIFICATE_TEMPLATE, Asn1X509CertTemplateDecodeEx,

    ASN1_OID_PREFIX szOID_AUTHORITY_KEY_IDENTIFIER, Asn1X509AuthorityKeyIdDecodeEx,
    ASN1_OID_PREFIX szOID_KEY_ATTRIBUTES, Asn1X509KeyAttributesDecodeEx,
    ASN1_OID_PREFIX szOID_KEY_USAGE_RESTRICTION, Asn1X509KeyUsageRestrictionDecodeEx,
    ASN1_OID_PREFIX szOID_SUBJECT_ALT_NAME, Asn1X509AltNameDecodeEx,
    ASN1_OID_PREFIX szOID_ISSUER_ALT_NAME, Asn1X509AltNameDecodeEx,
    ASN1_OID_PREFIX szOID_BASIC_CONSTRAINTS, Asn1X509BasicConstraintsDecodeEx,
    ASN1_OID_PREFIX szOID_KEY_USAGE, Asn1X509BitsDecodeEx,
    ASN1_OID_PREFIX szOID_BASIC_CONSTRAINTS2, Asn1X509BasicConstraints2DecodeEx,
    ASN1_OID_PREFIX szOID_CERT_POLICIES, Asn1X509CertPoliciesDecodeEx,
    ASN1_OID_PREFIX szOID_CERT_POLICIES_95, Asn1X509CertPoliciesDecodeEx,
    ASN1_OID_PREFIX szOID_CERT_POLICIES_95_QUALIFIER1, Asn1X509CertPoliciesQualifier1DecodeEx,

    ASN1_OID_PREFIX szOID_PKIX_POLICY_QUALIFIER_USERNOTICE, Asn1X509PKIXUserNoticeDecodeEx,

    ASN1_OID_PREFIX szOID_AUTHORITY_KEY_IDENTIFIER2, Asn1X509AuthorityKeyId2DecodeEx, 
    ASN1_OID_PREFIX szOID_SUBJECT_KEY_IDENTIFIER, Asn1X509OctetStringDecodeEx,
    ASN1_OID_PREFIX szOID_SUBJECT_ALT_NAME2, Asn1X509AltNameDecodeEx,
    ASN1_OID_PREFIX szOID_ISSUER_ALT_NAME2, Asn1X509AltNameDecodeEx,
    ASN1_OID_PREFIX szOID_CRL_REASON_CODE, Asn1X509EnumeratedDecodeEx,
    ASN1_OID_PREFIX szOID_AUTHORITY_INFO_ACCESS, Asn1X509AuthorityInfoAccessDecodeEx,
    ASN1_OID_PREFIX szOID_CRL_DIST_POINTS, Asn1X509CrlDistPointsDecodeEx,

    ASN1_OID_PREFIX szOID_CERT_EXTENSIONS, Asn1X509ExtensionsDecodeEx,
    ASN1_OID_PREFIX szOID_RSA_certExtensions, Asn1X509ExtensionsDecodeEx,
    ASN1_OID_PREFIX szOID_NEXT_UPDATE_LOCATION, Asn1X509AltNameDecodeEx,

    ASN1_OID_PREFIX szOID_ENHANCED_KEY_USAGE, Asn1X509CtlUsageDecodeEx,
    ASN1_OID_PREFIX szOID_CTL, Asn1X509CtlInfoDecodeEx,

    ASN1_OID_PREFIX szOID_RSA_RC2CBC, Asn1RC2CBCParametersDecodeEx,
    ASN1_OID_PREFIX szOID_RSA_SMIMECapabilities, Asn1SMIMECapabilitiesDecodeEx,
    ASN1_OID_PREFIX szOID_RSA_signingTime, Asn1UtcTimeDecodeEx,

    ASN1_OID_PREFIX szOID_ENROLLMENT_NAME_VALUE_PAIR, Asn1NameValueDecodeEx,
    ASN1_OID_PREFIX szOID_ENROLLMENT_CSP_PROVIDER, Asn1CSPProviderDecodeEx,

    ASN1_OID_OFFSET szOID_CRL_NUMBER, Asn1X509IntegerDecodeEx,
    ASN1_OID_OFFSET szOID_DELTA_CRL_INDICATOR, Asn1X509IntegerDecodeEx,
    ASN1_OID_OFFSET szOID_ISSUING_DIST_POINT, Asn1X509CrlIssuingDistPointDecodeEx,
    ASN1_OID_PREFIX szOID_FRESHEST_CRL, Asn1X509CrlDistPointsDecodeEx,
    ASN1_OID_OFFSET szOID_NAME_CONSTRAINTS, Asn1X509NameConstraintsDecodeEx,
    ASN1_OID_OFFSET szOID_POLICY_MAPPINGS, Asn1X509PolicyMappingsDecodeEx,
    ASN1_OID_OFFSET szOID_LEGACY_POLICY_MAPPINGS, Asn1X509PolicyMappingsDecodeEx,
    ASN1_OID_OFFSET szOID_POLICY_CONSTRAINTS, Asn1X509PolicyConstraintsDecodeEx,
    ASN1_OID_OFFSET szOID_CROSS_CERT_DIST_POINTS, Asn1X509CrossCertDistPointsDecodeEx,
    ASN1_OID_OFFSET szOID_CERTIFICATE_TEMPLATE, Asn1X509CertTemplateDecodeEx,
};

#define X509_DECODE_EX_FUNC_COUNT (sizeof(X509DecodeExFuncTable) / \
                                    sizeof(X509DecodeExFuncTable[0]))

#ifdef DEBUG_CRYPT_ASN1_MASTER
static HMODULE hOssCryptDll = NULL;
#endif  // DEBUG_CRYPT_ASN1_MASTER

BOOL
WINAPI
CertASNDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;

    if (!I_CryptOIDConvDllMain(hInst, ulReason, lpReserved))
        return FALSE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        if (NULL == (hX509EncodeFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hX509DecodeFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_DECODE_OBJECT_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (NULL == (hX509EncodeExFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_ENCODE_OBJECT_EX_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hX509DecodeExFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_DECODE_OBJECT_EX_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_EX_FUNC,
                X509_ENCODE_EX_FUNC_COUNT,
                X509EncodeExFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_EX_FUNC,
                X509_DECODE_EX_FUNC_COUNT,
                X509DecodeExFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;

#ifdef OSS_CRYPT_ASN1
        if (0 == (hX509Asn1Module = I_CryptInstallAsn1Module(ossx509, 0, NULL)))
            goto CryptInstallAsn1ModuleError;
#else
        X509_Module_Startup();
        if (0 == (hX509Asn1Module = I_CryptInstallAsn1Module(
                X509_Module, 0, NULL))) {
            X509_Module_Cleanup();
            goto CryptInstallAsn1ModuleError;
        }
#endif  // OSS_CRYPT_ASN1
        break;

    case DLL_PROCESS_DETACH:
#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (hOssCryptDll) {
            FreeLibrary(hOssCryptDll);
            hOssCryptDll = NULL;
        }
#endif  // DEBUG_CRYPT_ASN1_MASTER

        I_CryptUninstallAsn1Module(hX509Asn1Module);
#ifndef OSS_CRYPT_ASN1
        X509_Module_Cleanup();
#endif  // OSS_CRYPT_ASN1
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    I_CryptOIDConvDllMain(hInst, DLL_PROCESS_DETACH, NULL);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInstallAsn1ModuleError)
TRACE_ERROR(CryptInitOIDFunctionSetError)
TRACE_ERROR(CryptInstallOIDFunctionAddressError)
}

#ifdef DEBUG_CRYPT_ASN1_MASTER

#define DEBUG_OSS_CRYPT_ASN1_ENCODE_FLAG        0x1
#define DEBUG_OSS_CRYPT_ASN1_DECODE_FLAG        0x2
#define DEBUG_OSS_CRYPT_ASN1_COMPARE_FLAG       0x4

static BOOL fGotDebugCryptAsn1Flags = FALSE;
static int iDebugCryptAsn1Flags = 0;

int
WINAPI
GetDebugCryptAsn1Flags()
{

    if (!fGotDebugCryptAsn1Flags) {
        char    *pszEnvVar;
        char    *p;
        int     iFlags;

        if (pszEnvVar = getenv("DEBUG_CRYPT_ASN1_FLAGS"))
            iFlags = strtol(pszEnvVar, &p, 16);
        else
            iFlags = DEBUG_OSS_CRYPT_ASN1_COMPARE_FLAG;

        if (iFlags) {
            if (NULL == (hOssCryptDll = LoadLibraryA("osscrypt.dll"))) {
                iFlags = 0;
                if (pszEnvVar)
                    MessageBoxA(
                        NULL,           // hwndOwner
                        "LoadLibrary(osscrypt.dll) failed",
                        "CheckCryptEncodeDecodeAsn1",
                        MB_TOPMOST | MB_OK | MB_ICONWARNING |
                            MB_SERVICE_NOTIFICATION
                        );
            }
        }

        iDebugCryptAsn1Flags = iFlags;
        fGotDebugCryptAsn1Flags = TRUE;
    }
    return iDebugCryptAsn1Flags;
}

//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------
static BOOL WriteDERToFile(
    LPCSTR  pszFileName,
    PBYTE   pbDER,
    DWORD   cbDER
    )
{
    BOOL fResult;

    // Write the Encoded Blob to the file
    HANDLE hFile;
    hFile = CreateFile(pszFileName,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        fResult = FALSE;
    } else {
        DWORD dwBytesWritten;
        fResult = WriteFile(
                hFile,
                pbDER,
                cbDER,
                &dwBytesWritten,
                NULL            // lpOverlapped
                );
        CloseHandle(hFile);
    }
    return fResult;
}

#endif  // DEBUG_CRYPT_ASN1_MASTER

//+-------------------------------------------------------------------------
// Encode the specified data structure according to the certificate
// encoding type.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptEncodeObjectEx(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
    OUT void *pvEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr = NULL;

#ifdef DEBUG_CRYPT_ASN1_MASTER
    int iOssAsn1Flags;
    LPSTR lpszOssAsn1StructType = NULL;
    char szOssOID[128];
    HCRYPTOIDFUNCADDR hOssAsn1FuncAddr = NULL;
    void *pvOssAsn1FuncAddr = NULL;

    iOssAsn1Flags = GetDebugCryptAsn1Flags() &
        (DEBUG_OSS_CRYPT_ASN1_ENCODE_FLAG |
            DEBUG_OSS_CRYPT_ASN1_COMPARE_FLAG);
    if (iOssAsn1Flags) {
        if (0xFFFF < (DWORD_PTR) lpszStructType) {
            if ((DWORD) strlen(lpszStructType) <
                (sizeof(szOssOID) - strlen(OSS_OID_PREFIX) - 1)) {
                strcpy(szOssOID, OSS_OID_PREFIX);
                strcat(szOssOID, lpszStructType);
                lpszOssAsn1StructType = szOssOID;
            }
        } else
            lpszOssAsn1StructType = (LPSTR) lpszStructType +
                OSS_OID_OFFSET;

        if (lpszOssAsn1StructType) {
            if (!CryptGetOIDFunctionAddress(
                    hX509EncodeExFuncSet,
                    dwCertEncodingType,
                    lpszOssAsn1StructType,
                    0,                      // dwFlags
                    &pvOssAsn1FuncAddr,
                    &hOssAsn1FuncAddr
                    ))
                pvOssAsn1FuncAddr = NULL;
        }
    }

    if (pvOssAsn1FuncAddr &&
            0 == (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_COMPARE_FLAG)) {
        fResult = ((PFN_ENCODE_EX_FUNC) pvOssAsn1FuncAddr)(
            dwCertEncodingType,
            lpszStructType,
            pvStructInfo,
            dwFlags,
            pEncodePara,
            pvEncoded,
            pcbEncoded
            );
    } else
#endif  // DEBUG_CRYPT_ASN1_MASTER

    if (CryptGetOIDFunctionAddress(
            hX509EncodeExFuncSet,
            dwCertEncodingType,
            lpszStructType,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
      __try {
        fResult = ((PFN_ENCODE_EX_FUNC) pvFuncAddr)(
            dwCertEncodingType,
            lpszStructType,
            pvStructInfo,
            dwFlags,
            pEncodePara,
            pvEncoded,
            pcbEncoded
            );
      } __except(EXCEPTION_EXECUTE_HANDLER) {
        fResult = FALSE;
        *pcbEncoded = 0;
        SetLastError(GetExceptionCode());
      }

#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (pvOssAsn1FuncAddr && fResult && pvEncoded) {
            BYTE *pbEncoded;
            BOOL fOssAsn1Result;
            BYTE *pbOssAsn1 = NULL;
            DWORD cbOssAsn1;

            
            if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
                pbEncoded = *((BYTE **)pvEncoded);
            else
                pbEncoded = (BYTE *) pvEncoded;

            fOssAsn1Result = ((PFN_ENCODE_EX_FUNC) pvOssAsn1FuncAddr)(
                dwCertEncodingType,
                lpszStructType,
                pvStructInfo,
                dwFlags | CRYPT_ENCODE_ALLOC_FLAG,
                &PkiEncodePara,
                (void *) &pbOssAsn1,
                &cbOssAsn1
                );

            if (!fOssAsn1Result) {
                int id;

                id = MessageBoxA(
                    NULL,           // hwndOwner
                    "OssCryptAsn1 encode failed. Select Cancel to stop future OssCryptAsn1 encodes",
                    "CheckCryptEncodeDecodeAsn1",
                    MB_TOPMOST | MB_OKCANCEL | MB_ICONQUESTION |
                        MB_SERVICE_NOTIFICATION
                    );
                if (IDCANCEL == id)
                    iDebugCryptAsn1Flags = 0;
            } else if (*pcbEncoded != cbOssAsn1 ||
                    0 != memcmp(pbEncoded, pbOssAsn1, cbOssAsn1)) {
                int id;

                WriteDERToFile("msasn1.der", pbEncoded, *pcbEncoded);
                WriteDERToFile("ossasn1.der", pbOssAsn1, cbOssAsn1);
                
                id = MessageBoxA(
                    NULL,           // hwndOwner
                    "OssCryptAsn1 encode compare failed. Check ossasn1.der and msasn1.der. Select Cancel to stop future OssCryptAsn1 encodes",
                    "CheckCryptEncodeDecodeAsn1",
                    MB_TOPMOST | MB_OKCANCEL | MB_ICONQUESTION |
                        MB_SERVICE_NOTIFICATION
                    );
                if (IDCANCEL == id)
                    iDebugCryptAsn1Flags = 0;
            }

            if (pbOssAsn1)
                PkiFree(pbOssAsn1);
        }
#endif  // DEBUG_CRYPT_ASN1_MASTER
    } else {
        BYTE *pbEncoded;

#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (lpszOssAsn1StructType) {
            if (hOssAsn1FuncAddr)
                CryptFreeOIDFunctionAddress(hOssAsn1FuncAddr, 0);

            if (!CryptGetOIDFunctionAddress(
                    hX509EncodeFuncSet,
                    dwCertEncodingType,
                    lpszOssAsn1StructType,
                    0,                      // dwFlags
                    &pvOssAsn1FuncAddr,
                    &hOssAsn1FuncAddr
                    ))
                pvOssAsn1FuncAddr = NULL;
        }
#endif  // DEBUG_CRYPT_ASN1_MASTER

        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        if (dwFlags & ~CRYPT_ENCODE_ALLOC_FLAG)
            goto InvalidFlags;

#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (pvOssAsn1FuncAddr &&
                0 == (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_COMPARE_FLAG)) {
            pvFuncAddr = pvOssAsn1FuncAddr;
            pvOssAsn1FuncAddr = NULL;
            hFuncAddr = hOssAsn1FuncAddr;
            hOssAsn1FuncAddr = NULL;
        } else
#endif  // DEBUG_CRYPT_ASN1_MASTER
        if (!CryptGetOIDFunctionAddress(
                hX509EncodeFuncSet,
                dwCertEncodingType,
                lpszStructType,
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            goto NoEncodeFunction;
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
            PFN_CRYPT_ALLOC pfnAlloc;

            *pcbEncoded = 0;
          __try {
            fResult = ((PFN_ENCODE_FUNC) pvFuncAddr)(
                dwCertEncodingType,
                lpszStructType,
                pvStructInfo,
                NULL,
                pcbEncoded
                );
          } __except(EXCEPTION_EXECUTE_HANDLER) {
            fResult = FALSE;
            *pcbEncoded = 0;
            SetLastError(GetExceptionCode());
          }
            if (!fResult || 0 == *pcbEncoded)
                goto CommonReturn;

            pfnAlloc = PkiGetEncodeAllocFunction(pEncodePara);
            if (NULL == (pbEncoded = (BYTE *) pfnAlloc(*pcbEncoded)))
                goto OutOfMemory;
        } else
            pbEncoded = (BYTE *) pvEncoded;

      __try {
        fResult = ((PFN_ENCODE_FUNC) pvFuncAddr)(
                dwCertEncodingType,
                lpszStructType,
                pvStructInfo,
                pbEncoded,
                pcbEncoded
                );
      } __except(EXCEPTION_EXECUTE_HANDLER) {
        fResult = FALSE;
        *pcbEncoded = 0;
        SetLastError(GetExceptionCode());
      }

#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (pvOssAsn1FuncAddr && fResult && pbEncoded) {
            BOOL fOssAsn1Result;
            BYTE *pbOssAsn1 = NULL;
            DWORD cbOssAsn1;

            cbOssAsn1 = *pcbEncoded;
            pbOssAsn1 = (BYTE *) PkiNonzeroAlloc(cbOssAsn1);
            if (NULL == pbOssAsn1)
                fOssAsn1Result = FALSE;
            else
                fOssAsn1Result = ((PFN_ENCODE_FUNC) pvOssAsn1FuncAddr)(
                    dwCertEncodingType,
                    lpszStructType,
                    pvStructInfo,
                    pbOssAsn1,
                    &cbOssAsn1
                    );

            if (!fOssAsn1Result) {
                int id;

                id = MessageBoxA(
                    NULL,           // hwndOwner
                    "OssCryptAsn1 encode failed. Select Cancel to stop future OssCryptAsn1 encodes",
                    "CheckCryptEncodeDecodeAsn1",
                    MB_TOPMOST | MB_OKCANCEL | MB_ICONQUESTION |
                        MB_SERVICE_NOTIFICATION
                    );
                if (IDCANCEL == id)
                    iDebugCryptAsn1Flags = 0;
            } else if (*pcbEncoded != cbOssAsn1 ||
                    0 != memcmp(pbEncoded, pbOssAsn1, cbOssAsn1)) {
                int id;

                WriteDERToFile("msasn1.der", pbEncoded, *pcbEncoded);
                WriteDERToFile("ossasn1.der", pbOssAsn1, cbOssAsn1);
                
                id = MessageBoxA(
                    NULL,           // hwndOwner
                    "OssCryptAsn1 encode compare failed. Check ossasn1.der and msasn1.der. Select Cancel to stop future OssCryptAsn1 encodes",
                    "CheckCryptEncodeDecodeAsn1",
                    MB_TOPMOST | MB_OKCANCEL | MB_ICONQUESTION |
                        MB_SERVICE_NOTIFICATION
                    );
                if (IDCANCEL == id)
                    iDebugCryptAsn1Flags = 0;
            }

            PkiFree(pbOssAsn1);
        }
#endif  // DEBUG_CRYPT_ASN1_MASTER

        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
            if (fResult)
                *((BYTE **) pvEncoded) = pbEncoded;
            else {
                PFN_CRYPT_FREE pfnFree;
                pfnFree = PkiGetEncodeFreeFunction(pEncodePara);
                pfnFree(pbEncoded);
            }
        }
    }

CommonReturn:
    if (hFuncAddr)
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
#ifdef DEBUG_CRYPT_ASN1_MASTER
    if (hOssAsn1FuncAddr)
        CryptFreeOIDFunctionAddress(hOssAsn1FuncAddr, 0);
#endif  // DEBUG_CRYPT_ASN1_MASTER

    return fResult;
ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidFlags, E_INVALIDARG)
TRACE_ERROR(NoEncodeFunction)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
}

BOOL
WINAPI
CryptEncodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    return CryptEncodeObjectEx(
        dwCertEncodingType,
        lpszStructType,
        pvStructInfo,
        0,                          // dwFlags
        NULL,                       // pEncodePara
        pbEncoded,
        pcbEncoded
        );
}


//+-------------------------------------------------------------------------
// Decode the specified data structure according to the certificate
// encoding type.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptDecodeObjectEx(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT DWORD *pcbStructInfo
    )
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr = NULL;

#ifdef DEBUG_CRYPT_ASN1_MASTER
    int iOssAsn1Flags;
    LPSTR lpszOssAsn1StructType = NULL;
    char szOssOID[128];
    HCRYPTOIDFUNCADDR hOssAsn1FuncAddr = NULL;
    void *pvOssAsn1FuncAddr = NULL;

    iOssAsn1Flags = GetDebugCryptAsn1Flags() &
        DEBUG_OSS_CRYPT_ASN1_DECODE_FLAG;
    if (iOssAsn1Flags) {
        if (0xFFFF < (DWORD_PTR) lpszStructType) {
            if ((DWORD) strlen(lpszStructType) <
                (sizeof(szOssOID) - strlen(OSS_OID_PREFIX) - 1)) {
                strcpy(szOssOID, OSS_OID_PREFIX);
                strcat(szOssOID, lpszStructType);
                lpszOssAsn1StructType = szOssOID;
            }
        } else
            lpszOssAsn1StructType = (LPSTR) lpszStructType + OSS_OID_OFFSET;

        if (lpszOssAsn1StructType) {
            if (!CryptGetOIDFunctionAddress(
                    hX509DecodeExFuncSet,
                    dwCertEncodingType,
                    lpszOssAsn1StructType,
                    0,                      // dwFlags
                    &pvOssAsn1FuncAddr,
                    &hOssAsn1FuncAddr
                    ))
                pvOssAsn1FuncAddr = NULL;
        }
    }

    if (pvOssAsn1FuncAddr) {
        fResult = ((PFN_DECODE_EX_FUNC) pvOssAsn1FuncAddr)(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            dwFlags,
            pDecodePara,
            pvStructInfo,
            pcbStructInfo
            );
    } else
#endif  // DEBUG_CRYPT_ASN1_MASTER
    if (CryptGetOIDFunctionAddress(
            hX509DecodeExFuncSet,
            dwCertEncodingType,
            lpszStructType,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
      __try {
        fResult = ((PFN_DECODE_EX_FUNC) pvFuncAddr)(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            dwFlags,
            pDecodePara,
            pvStructInfo,
            pcbStructInfo
            );
      } __except(EXCEPTION_EXECUTE_HANDLER) {
        fResult = FALSE;
        *pcbStructInfo = 0;
        SetLastError(GetExceptionCode());
      }
    } else {
        void *pv;

#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (lpszOssAsn1StructType) {
            if (!CryptGetOIDFunctionAddress(
                    hX509DecodeFuncSet,
                    dwCertEncodingType,
                    lpszOssAsn1StructType,
                    0,                      // dwFlags
                    &pvOssAsn1FuncAddr,
                    &hOssAsn1FuncAddr
                    ))
                pvOssAsn1FuncAddr = NULL;
        }
#endif  // DEBUG_CRYPT_ASN1_MASTER

        if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
            *((void **) pvStructInfo) = NULL;

#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (pvOssAsn1FuncAddr) {
            pvFuncAddr = pvOssAsn1FuncAddr;
            pvOssAsn1FuncAddr = NULL;
            hFuncAddr = hOssAsn1FuncAddr;
            hOssAsn1FuncAddr = NULL;
        } else
#endif  // DEBUG_CRYPT_ASN1_MASTER

        if (!CryptGetOIDFunctionAddress(
                hX509DecodeFuncSet,
                dwCertEncodingType,
                lpszStructType,
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr))
            goto NoDecodeFunction;
        if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
            PFN_CRYPT_ALLOC pfnAlloc;

            *pcbStructInfo = 0;
          __try {
            fResult = ((PFN_DECODE_FUNC) pvFuncAddr)(
                dwCertEncodingType,
                lpszStructType,
                pbEncoded,
                cbEncoded,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                NULL,
                pcbStructInfo
                );
          } __except(EXCEPTION_EXECUTE_HANDLER) {
            fResult = FALSE;
            *pcbStructInfo = 0;
            SetLastError(GetExceptionCode());
          }
            if (!fResult || 0 == *pcbStructInfo)
                goto CommonReturn;

            pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);
            if (NULL == (pv = pfnAlloc(*pcbStructInfo)))
                goto OutOfMemory;
        } else
            pv = pvStructInfo;

      __try {
        fResult = ((PFN_DECODE_FUNC) pvFuncAddr)(
                dwCertEncodingType,
                lpszStructType,
                pbEncoded,
                cbEncoded,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                pv,
                pcbStructInfo
                );
      } __except(EXCEPTION_EXECUTE_HANDLER) {
        fResult = FALSE;
        *pcbStructInfo = 0;
        SetLastError(GetExceptionCode());
      }
        if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
            if (fResult)
                *((void **) pvStructInfo) = pv;
            else {
                PFN_CRYPT_FREE pfnFree;
                pfnFree = PkiGetDecodeFreeFunction(pDecodePara);
                pfnFree(pv);
            }
        }
    }

CommonReturn:
    if (hFuncAddr)
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
#ifdef DEBUG_CRYPT_ASN1_MASTER
    if (hOssAsn1FuncAddr)
        CryptFreeOIDFunctionAddress(hOssAsn1FuncAddr, 0);
#endif  // DEBUG_CRYPT_ASN1_MASTER
    return fResult;
ErrorReturn:
    *pcbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(NoDecodeFunction)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
}


BOOL
WINAPI
CryptDecodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT DWORD *pcbStructInfo
    )
{
    return CryptDecodeObjectEx(
        dwCertEncodingType,
        lpszStructType,
        pbEncoded,
        cbEncoded,
        dwFlags,
        NULL,                   // pDecodePara
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//
//  Called by the Asn1X509*Encode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoEncodeEx(
        IN int pdunum,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfoEx(
        GetEncoder(),
        pdunum,
        pvAsn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded);
}

//+-------------------------------------------------------------------------
//  Decode into an allocated, ASN1 formatted info structure
//
//  Called by the Asn1X509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoDecodeAndAlloc(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        )
{
    return PkiAsn1DecodeAndAllocInfo(
        GetDecoder(),
        pdunum,
        pbEncoded,
        cbEncoded,
        ppvAsn1Info);
}

//+-------------------------------------------------------------------------
//  Free an allocated, ASN1 formatted info structure
//
//  Called by the Asn1X509*Decode() functions.
//--------------------------------------------------------------------------
static void Asn1InfoFree(
        IN int pdunum,
        IN void *pAsn1Info
        )
{
    if (pAsn1Info) {
        DWORD dwErr = GetLastError();

        // TlsGetValue globbers LastError
        PkiAsn1FreeInfo(GetDecoder(), pdunum, pAsn1Info);

        SetLastError(dwErr);
    }
}

//+-------------------------------------------------------------------------
//  Decode into an ASN1 formatted info structure. Call the callback
//  function to convert into the 'C' data structure. If
//  CRYPT_DECODE_ALLOC_FLAG is set, call the callback twice. First,
//  to get the length of the 'C' data structure. Then after allocating,
//  call again to update the 'C' data structure.
//
//  Called by the Asn1X509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoDecodeAndAllocEx(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return PkiAsn1DecodeAndAllocInfoEx(
        GetDecoder(),
        pdunum,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  ASN1 X509 v3 ASN.1 Set / Get functions
//
//  Called by the ASN1 X509 encode/decode functions.
//
//  Assumption: all types are UNBOUNDED.
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//  Set/Get Encoded Object Identifier string
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
#define Asn1X509SetEncodedObjId(pszObjId, pAsn1) \
            I_CryptSetEncodedOID(pszObjId, (OssEncodedOID *) (pAsn1))

#define Asn1X509GetEncodedObjId(pAsn1, dwFlags, \
                ppszObjId, ppbExtra, plRemainExtra) \
            I_CryptGetEncodedOID((OssEncodedOID *) (pAsn1), dwFlags, \
                ppszObjId, ppbExtra, plRemainExtra)

#else

#define Asn1X509SetEncodedObjId(pszObjId, pAsn1) \
            I_CryptSetEncodedOID(pszObjId, pAsn1)

#define Asn1X509GetEncodedObjId(pAsn1, dwFlags, \
                ppszObjId, ppbExtra, plRemainExtra) \
            I_CryptGetEncodedOID(pAsn1, dwFlags, \
                ppszObjId, ppbExtra, plRemainExtra)

#endif  // OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Set/Get CRYPT_DATA_BLOB (Octet String)
//--------------------------------------------------------------------------
inline void Asn1X509SetOctetString(
        IN PCRYPT_DATA_BLOB pInfo,
        OUT OCTETSTRING *pAsn1
        )
{
    pAsn1->value = pInfo->pbData;
    pAsn1->length = pInfo->cbData;
}
inline void Asn1X509GetOctetString(
        IN OCTETSTRING *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetOctetString(pAsn1->length, pAsn1->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CRYPT_INTEGER_BLOB
//--------------------------------------------------------------------------
inline BOOL Asn1X509SetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT HUGEINTEGER *pAsn1
        )
{
    return PkiAsn1SetHugeInteger(pInfo, &pAsn1->length, &pAsn1->value);
}
inline void Asn1X509FreeHugeInteger(
        IN HUGEINTEGER *pAsn1
        )
{
    PkiAsn1FreeHugeInteger(pAsn1->value);
    pAsn1->value = NULL;
    pAsn1->length = 0;
}
inline void Asn1X509GetHugeInteger(
        IN HUGEINTEGER *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetHugeInteger(pAsn1->length, pAsn1->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CRYPT_UINT_BLOB
//--------------------------------------------------------------------------
inline BOOL Asn1X509SetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT HUGEINTEGER *pAsn1
        )
{
    return PkiAsn1SetHugeUINT(pInfo, &pAsn1->length, &pAsn1->value);
}

#define Asn1X509FreeHugeUINT     Asn1X509FreeHugeInteger

inline void Asn1X509GetHugeUINT(
        IN HUGEINTEGER *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetHugeUINT(pAsn1->length, pAsn1->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get CRYPT_BIT_BLOB
//--------------------------------------------------------------------------
inline void Asn1X509SetBit(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT BITSTRING *pAsn1
        )
{
    PkiAsn1SetBitString(pInfo, &pAsn1->length, &pAsn1->value);
}
inline void Asn1X509GetBit(
        IN BITSTRING *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetBitString(pAsn1->length, pAsn1->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}

inline void Asn1X509SetBitWithoutTrailingZeroes(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT BITSTRING *pAsn1
        )
{
    PkiAsn1SetBitStringWithoutTrailingZeroes(
        pInfo, &pAsn1->length, &pAsn1->value);
}


//+-------------------------------------------------------------------------
//  Set/Get LPSTR (IA5 String)
//--------------------------------------------------------------------------
inline void Asn1X509SetIA5(
        IN LPSTR psz,
        OUT IA5STRING *pAsn1
        )
{
    pAsn1->value = psz;
    pAsn1->length = strlen(psz);
}
inline void Asn1X509GetIA5(
        IN IA5STRING *pAsn1,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetIA5String(pAsn1->length, pAsn1->value, dwFlags,
        ppsz, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL Asn1X509SetUnicodeConvertedToIA5(
        IN LPWSTR pwsz,
        OUT IA5STRING *pAsn1,
        IN DWORD dwIndex,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    fResult = PkiAsn1SetUnicodeConvertedToIA5String(pwsz,
        &pAsn1->length, &pAsn1->value);
    if (!fResult && (DWORD) CRYPT_E_INVALID_IA5_STRING == GetLastError())
        *pdwErrLocation = (dwIndex << 16) | pAsn1->length;
    else
        *pdwErrLocation = 0;
    return fResult;
}
inline void Asn1X509FreeUnicodeConvertedToIA5(IN IA5STRING *pAsn1)
{
    PkiAsn1FreeUnicodeConvertedToIA5String(pAsn1->value);
    pAsn1->value = NULL;
}
inline void Asn1X509GetIA5ConvertedToUnicode(
        IN IA5STRING *pAsn1,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetIA5StringConvertedToUnicode(pAsn1->length, pAsn1->value, dwFlags,
        ppwsz, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get LPWSTR (BMP String)
//--------------------------------------------------------------------------
inline void Asn1X509SetBMP(
        IN LPWSTR pwsz,
        OUT BMPSTRING *pAsn1
        )
{
    pAsn1->value = pwsz;
    pAsn1->length = wcslen(pwsz);
}
inline void Asn1X509GetBMP(
        IN BMPSTRING *pAsn1,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetBMPString(pAsn1->length, pAsn1->value, dwFlags,
        ppwsz, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
inline void Asn1X509SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT NOCOPYANY *pAsn1
        )
{
    PkiAsn1SetAny(pInfo, pAsn1);
}
inline void Asn1X509GetAny(
        IN NOCOPYANY *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetAny(pAsn1, dwFlags, pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get CRYPT_ALGORITHM_IDENTIFIER
//--------------------------------------------------------------------------
BOOL Asn1X509SetAlgorithm(
        IN PCRYPT_ALGORITHM_IDENTIFIER pInfo,
        OUT AlgorithmIdentifier *pAsn1,
        IN DWORD dwGroupId = 0
        )
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    if (pInfo->pszObjId) {
        if (!Asn1X509SetEncodedObjId(pInfo->pszObjId, &pAsn1->algorithm))
            return FALSE;

        if (pInfo->Parameters.cbData) {
            Asn1X509SetAny(&pInfo->Parameters, &pAsn1->parameters);
            pAsn1->bit_mask |= parameters_present;
        } else {
            if (dwGroupId) {
                // For public key or signature algorithms, check if
                // NO NULL parameters.

                PCCRYPT_OID_INFO pOIDInfo;
                DWORD dwFlags = 0;

                switch (dwGroupId) {
                    case CRYPT_PUBKEY_ALG_OID_GROUP_ID:
                        if (pOIDInfo = CryptFindOIDInfo(
                                CRYPT_OID_INFO_OID_KEY,
                                pInfo->pszObjId,
                                CRYPT_PUBKEY_ALG_OID_GROUP_ID)) {
                            if (1 <= pOIDInfo->ExtraInfo.cbData /
                                    sizeof(DWORD)) {
                                DWORD *pdwExtra = (DWORD *)
                                    pOIDInfo->ExtraInfo.pbData;
                                dwFlags = pdwExtra[0];
                            }
                        }
                        break;
                    case CRYPT_SIGN_ALG_OID_GROUP_ID:
                        if (pOIDInfo = CryptFindOIDInfo(
                                CRYPT_OID_INFO_OID_KEY,
                                pInfo->pszObjId,
                                CRYPT_SIGN_ALG_OID_GROUP_ID)) {
                            if (2 <= pOIDInfo->ExtraInfo.cbData /
                                    sizeof(DWORD)) {
                                DWORD *pdwExtra = (DWORD *)
                                    pOIDInfo->ExtraInfo.pbData;
                                dwFlags = pdwExtra[1];
                            }
                        }
                        break;
                    default:
                        break;
                }

                if (dwFlags & CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG)
                    return TRUE;
            }

            // Per PKCS #1: default to the ASN.1 type NULL.
            Asn1X509SetAny((PCRYPT_OBJID_BLOB) &NullDerBlob, &pAsn1->parameters);
            pAsn1->bit_mask |= parameters_present;
        }
    }
    return TRUE;
}

void Asn1X509GetAlgorithm(
        IN AlgorithmIdentifier *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_ALGORITHM_IDENTIFIER pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    if (*plRemainExtra >= 0)
        memset(pInfo, 0, sizeof(*pInfo));
    Asn1X509GetEncodedObjId(&pAsn1->algorithm, dwFlags, &pInfo->pszObjId,
            ppbExtra, plRemainExtra);
    if (pAsn1->bit_mask & parameters_present)
        Asn1X509GetAny(&pAsn1->parameters, dwFlags, &pInfo->Parameters,
            ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get CERT_PUBLIC_KEY_INFO
//--------------------------------------------------------------------------
BOOL Asn1X509SetPublicKeyInfo(
        IN PCERT_PUBLIC_KEY_INFO pInfo,
        OUT SubjectPublicKeyInfo *pAsn1
        )
{
    if (!Asn1X509SetAlgorithm(&pInfo->Algorithm, &pAsn1->algorithm,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID))
        return FALSE;
    Asn1X509SetBit(&pInfo->PublicKey, &pAsn1->subjectPublicKey);
    return TRUE;
}

void Asn1X509GetPublicKeyInfo(
        IN SubjectPublicKeyInfo *pAsn1,
        IN DWORD dwFlags,
        OUT PCERT_PUBLIC_KEY_INFO pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    Asn1X509GetAlgorithm(&pAsn1->algorithm, dwFlags, &pInfo->Algorithm,
        ppbExtra, plRemainExtra);
    Asn1X509GetBit(&pAsn1->subjectPublicKey, dwFlags, &pInfo->PublicKey,
        ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Extensions
//--------------------------------------------------------------------------
BOOL Asn1X509SetExtensions(
        IN DWORD cExtension,
        IN PCERT_EXTENSION pExtension,
        OUT Extensions *pAsn1
        )
{
    Extension *pAsn1Ext;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cExtension == 0)
        return TRUE;

    pAsn1Ext = (Extension *) PkiZeroAlloc(cExtension * sizeof(Extension));
    if (pAsn1Ext == NULL)
        return FALSE;
    pAsn1->value = pAsn1Ext;
    pAsn1->count = cExtension;

    for ( ; cExtension > 0; cExtension--, pExtension++, pAsn1Ext++) {
        if (!Asn1X509SetEncodedObjId(pExtension->pszObjId, &pAsn1Ext->extnId))
            return FALSE;
        if (pExtension->fCritical) {
            pAsn1Ext->critical = TRUE;
            pAsn1Ext->bit_mask |= critical_present;
        }
        Asn1X509SetOctetString(&pExtension->Value, &pAsn1Ext->extnValue);
    }
    return TRUE;
}

void Asn1X509FreeExtensions(
        IN Extensions *pAsn1)
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1X509GetExtensions(
        IN Extensions *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcExtension,
        OUT PCERT_EXTENSION *ppExtension,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cExt;
    Extension *pAsn1Ext;
    PCERT_EXTENSION pGetExt;

    cExt = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cExt * sizeof(CERT_EXTENSION));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcExtension = cExt;
        pGetExt = (PCERT_EXTENSION) pbExtra;
        *ppExtension = pGetExt;
        pbExtra += lAlignExtra;
    } else
        pGetExt = NULL;

    pAsn1Ext = pAsn1->value;
    for ( ; cExt > 0; cExt--, pAsn1Ext++, pGetExt++) {
        Asn1X509GetEncodedObjId(&pAsn1Ext->extnId, dwFlags, &pGetExt->pszObjId,
                &pbExtra, &lRemainExtra);
        if (lRemainExtra >= 0) {
            pGetExt->fCritical = FALSE;
            if (pAsn1Ext->bit_mask & critical_present)
                pGetExt->fCritical = (BOOLEAN) pAsn1Ext->critical;
        }

        Asn1X509GetOctetString(&pAsn1Ext->extnValue, dwFlags, &pGetExt->Value,
                &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CRL Entries
//--------------------------------------------------------------------------
BOOL Asn1X509SetCrlEntries(
        IN DWORD cEntry,
        IN PCRL_ENTRY pEntry,
        OUT RevokedCertificates *pAsn1
        )
{
    CRLEntry *pAsn1Entry;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cEntry == 0)
        return TRUE;

    pAsn1Entry = (CRLEntry *) PkiZeroAlloc(cEntry * sizeof(CRLEntry));
    if (pAsn1Entry == NULL)
        return FALSE;
    pAsn1->value = pAsn1Entry;
    pAsn1->count = cEntry;

    for ( ; cEntry > 0; cEntry--, pEntry++, pAsn1Entry++) {
        if (!Asn1X509SetHugeInteger(&pEntry->SerialNumber,
                &pAsn1Entry->userCertificate))
            return FALSE;
        if (!PkiAsn1ToChoiceOfTime(&pEntry->RevocationDate,
                &pAsn1Entry->revocationDate.choice,
                &pAsn1Entry->revocationDate.u.generalTime,
                &pAsn1Entry->revocationDate.u.utcTime
                )) {
            SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
            return FALSE;
        }
        if (pEntry->cExtension) {
            if (!Asn1X509SetExtensions(pEntry->cExtension, pEntry->rgExtension,
                    &pAsn1Entry->crlEntryExtensions))
                return FALSE;
            pAsn1Entry->bit_mask |= crlEntryExtensions_present;
        }
    }
    return TRUE;
}

void Asn1X509FreeCrlEntries(
        IN RevokedCertificates *pAsn1)
{
    if (pAsn1->value) {
        CRLEntry *pAsn1Entry = pAsn1->value;
        DWORD cEntry = pAsn1->count;
        for ( ; cEntry > 0; cEntry--, pAsn1Entry++) {
            Asn1X509FreeHugeInteger(&pAsn1Entry->userCertificate);
            Asn1X509FreeExtensions(&pAsn1Entry->crlEntryExtensions);
        }
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

BOOL Asn1X509GetCrlEntries(
        IN RevokedCertificates *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcEntry,
        OUT PCRL_ENTRY *ppEntry,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cEntry;
    CRLEntry *pAsn1Entry;
    PCRL_ENTRY pGetEntry;

    cEntry = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cEntry * sizeof(CRL_ENTRY));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcEntry = cEntry;
        pGetEntry = (PCRL_ENTRY) pbExtra;
        *ppEntry = pGetEntry;
        pbExtra += lAlignExtra;
    } else
        pGetEntry = NULL;

    pAsn1Entry = pAsn1->value;
    for ( ; cEntry > 0; cEntry--, pAsn1Entry++, pGetEntry++) {
        Asn1X509GetHugeInteger(&pAsn1Entry->userCertificate, dwFlags,
            &pGetEntry->SerialNumber, &pbExtra, &lRemainExtra);

        // RevocationDate
        if (lRemainExtra >= 0) {
            if (!PkiAsn1FromChoiceOfTime(pAsn1Entry->revocationDate.choice,
                    &pAsn1Entry->revocationDate.u.generalTime,
                    &pAsn1Entry->revocationDate.u.utcTime,
                    &pGetEntry->RevocationDate)) {
                SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
                return FALSE;
            }
        }

        // Extensions
        if (pAsn1Entry->bit_mask & crlEntryExtensions_present)
            Asn1X509GetExtensions(&pAsn1Entry->crlEntryExtensions, dwFlags,
                &pGetEntry->cExtension, &pGetEntry->rgExtension,
                &pbExtra, &lRemainExtra);
        else if (lRemainExtra >= 0) {
            pGetEntry->cExtension = 0;
            pGetEntry->rgExtension = NULL;
        }
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
    return TRUE;
}

#ifndef ASN1_SUPPORTS_UTF8_TAG

void inline Asn1X509ReverseCopy(
    OUT BYTE *pbOut,
    IN BYTE *pbInOrg,
    IN DWORD cbIn
    )
{
    BYTE *pbIn = pbInOrg + cbIn - 1;

    while (cbIn-- > 0)
        *pbOut++ = *pbIn--;
}

#define MAX_LENGTH_OCTETS   5

//+-------------------------------------------------------------------------
//  Copy out the encoding of the length octets for a specified content length.
//
//  Returns the number of length octets
//--------------------------------------------------------------------------
DWORD Asn1X509GetLengthOctets(
    IN DWORD cbContent,
    OUT BYTE rgbLength[MAX_LENGTH_OCTETS]
    )
{
    DWORD cbLength;

    if (cbContent < 0x80) {
        rgbLength[0] = (BYTE) cbContent;
        cbLength = 0;
    } else {
        if (cbContent > 0xffffff)
            cbLength = 4;
        else if (cbContent > 0xffff)
            cbLength = 3;
        else if (cbContent > 0xff)
            cbLength = 2;
        else
            cbLength = 1;
        rgbLength[0] = (BYTE) cbLength | 0x80;
        Asn1X509ReverseCopy(rgbLength + 1, (BYTE *) &cbContent, cbLength);
    }
    return cbLength + 1;
}

// Prefix includes:
//  - 1 byte for number of unused bytes in the prefix
//  - 1 byte for the tag
//  - up to 5 bytes for the length octets
#define MAX_ENCODED_UTF8_PREFIX     (1 + 1 + MAX_LENGTH_OCTETS)
#define UTF8_ASN_TAG                0x0C

//+-------------------------------------------------------------------------
//  Allocate and Encode UTF8
//
//  The returned pbEncoded points to an ASN.1 encoded UTF8 string.
//  pbEncoded points to the UTF8_ASN_TAG, followed by the length octets and
//  then the UTF8 bytes.
//
//  *(pbEncoded -1) contains the number of unused bytes preceding the encoded
//  UTF8, ie, pbAllocEncoded = pbEncoded - *(pbEncoded -1).
//--------------------------------------------------------------------------
BOOL Asn1X509AllocAndEncodeUTF8(
        IN PCERT_RDN_VALUE_BLOB pValue,
        OUT BYTE **ppbEncoded,
        OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbAllocEncoded = NULL;
    BYTE *pbEncoded;
    DWORD cbEncoded;
    BYTE rgbLength[MAX_LENGTH_OCTETS];
    DWORD cbLength;
    DWORD cbUnusedPrefix;
    int cchUnicode;
    int cchUTF8;

    cchUnicode = pValue->cbData / sizeof(WCHAR);

    // In the largest buffer case there are 3 bytes per Unicode character.
    // The encoded UTF8 is preceded with a prefix consisting of a byte
    // indicating the number of unused bytes in the prefix, a byte for the
    // UTF8 tag and up to 5 bytes for the length octets.
    if (NULL == (pbAllocEncoded = (BYTE *) PkiNonzeroAlloc(
            MAX_ENCODED_UTF8_PREFIX + cchUnicode * 3)))
        goto OutOfMemory;

    if (0 == cchUnicode)
        cchUTF8 = 0;
    else {
        if (0 >= (cchUTF8 = WideCharToUTF8(
                (LPCWSTR) pValue->pbData,
                cchUnicode,
                (LPSTR) (pbAllocEncoded + MAX_ENCODED_UTF8_PREFIX),
                cchUnicode * 3
                )))
            goto WideCharToUTF8Error;
    }

    cbLength = Asn1X509GetLengthOctets(cchUTF8, rgbLength);
    assert(MAX_ENCODED_UTF8_PREFIX > (1 + cbLength));
    cbUnusedPrefix = MAX_ENCODED_UTF8_PREFIX - (1 + cbLength);
    pbEncoded = pbAllocEncoded + cbUnusedPrefix;
    cbEncoded = 1 + cbLength + cchUTF8;
    *(pbEncoded - 1) = (BYTE) cbUnusedPrefix;
    *(pbEncoded) = UTF8_ASN_TAG;
    memcpy(pbEncoded + 1, rgbLength, cbLength);

    fResult = TRUE;
CommonReturn:
    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    PkiFree(pbAllocEncoded);
    pbEncoded = NULL;
    cbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(WideCharToUTF8Error)
}

//+-------------------------------------------------------------------------
//  Free previously encoded UTF8
//
//  *(pbEncoded -1) contains the number of unused bytes preceding the encoded
//  UTF8, ie, pbAllocEncoded = pbEncoded - *(pbEncoded -1).
//--------------------------------------------------------------------------
void Asn1X509FreeEncodedUTF8(
        IN BYTE *pbEncoded
        )
{
    if (pbEncoded) {
        BYTE *pbAllocEncoded;

        assert(MAX_ENCODED_UTF8_PREFIX > *(pbEncoded -1));

        pbAllocEncoded = pbEncoded - *(pbEncoded - 1);
        PkiFree(pbAllocEncoded);
    }
}

//+-------------------------------------------------------------------------
//  Get UTF8
//--------------------------------------------------------------------------
BOOL Asn1X509GetUTF8(
        IN NOCOPYANY *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pdwValueType,
        OUT PCERT_RDN_VALUE_BLOB pValue,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    const BYTE *pbEncoded = (const BYTE *) pAsn1->encoded;
    DWORD cbEncoded = pAsn1->length;
    const BYTE *pbContent;
    DWORD cbContent;
    int cchUnicode;
    LPWSTR pwszUnicode = NULL;
    LONG lAlignExtra;
    LONG lData;


    if (0 == cbEncoded || UTF8_ASN_TAG != *pbEncoded)
        goto InvalidUTF8Tag;

    if (0 >= Asn1UtilExtractContent(
            pbEncoded,
            cbEncoded,
            &cbContent,
            &pbContent
            ))
        goto InvalidUTF8Header;

    if (0 == cbContent)
        cchUnicode = 0;
    else {
        if (pbContent + cbContent > pbEncoded + cbEncoded)
            goto InvalidUTF8Header;

        // In the largest buffer case there is one Unicode character per
        // UTF8 character
        if (NULL == (pwszUnicode = (LPWSTR) PkiNonzeroAlloc(
                cbContent * sizeof(WCHAR))))
            goto OutOfMemory;

        if (0 >= (cchUnicode = UTF8ToWideChar(
                (LPCSTR) pbContent,
                cbContent,              // cchUTF8
                pwszUnicode,
                cbContent               // cchUnicode
                )))
            goto UTF8ToWideCharError;
    }

    // Add + sizeof(WCHAR) for added 0 bytes. Want to ensure that the WCHAR
    // string is always null terminated
    lData = cchUnicode * sizeof(WCHAR);
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        *pdwValueType = CERT_RDN_UTF8_STRING;
        pValue->pbData = *ppbExtra;
        pValue->cbData = (DWORD) lData;
        if (lData > 0)
            memcpy(pValue->pbData, pwszUnicode, lData);
        memset(pValue->pbData + lData, 0, sizeof(WCHAR));
        *ppbExtra += lAlignExtra;
    }

    fResult = TRUE;
CommonReturn:
    PkiFree(pwszUnicode);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidUTF8Tag, CRYPT_E_BAD_ENCODE)
SET_ERROR(InvalidUTF8Header, CRYPT_E_BAD_ENCODE)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(UTF8ToWideCharError)
}

#endif  // not defined ASN1_SUPPORTS_UTF8_TAG


//+-------------------------------------------------------------------------
//  Set/Get AnyString
//--------------------------------------------------------------------------
void Asn1X509SetAnyString(
        IN DWORD dwValueType,
        IN PCERT_RDN_VALUE_BLOB pValue,
        OUT AnyString *pAsn1
        )
{
    pAsn1->u.octetString.value = pValue->pbData;
    pAsn1->u.octetString.length = pValue->cbData;
    switch (dwValueType) {
        case CERT_RDN_OCTET_STRING:
            pAsn1->choice = octetString_chosen;
            break;
        case CERT_RDN_NUMERIC_STRING:
            pAsn1->choice = numericString_chosen;
            break;
        case CERT_RDN_PRINTABLE_STRING:
            pAsn1->choice = printableString_chosen;
            break;
        case CERT_RDN_TELETEX_STRING:
            pAsn1->choice = teletexString_chosen;
            break;
        case CERT_RDN_VIDEOTEX_STRING:
            pAsn1->choice = videotexString_chosen;
            break;
        case CERT_RDN_IA5_STRING:
            pAsn1->choice = ia5String_chosen;
            break;
        case CERT_RDN_GRAPHIC_STRING:
            pAsn1->choice = graphicString_chosen;
            break;
        case CERT_RDN_VISIBLE_STRING:
            pAsn1->choice = visibleString_chosen;
            break;
        case CERT_RDN_GENERAL_STRING:
            pAsn1->choice = generalString_chosen;
            break;
        case CERT_RDN_UNIVERSAL_STRING:
            pAsn1->choice = universalString_chosen;
            pAsn1->u.octetString.length = pValue->cbData / 4;
            break;
        case CERT_RDN_BMP_STRING:
            pAsn1->choice = bmpString_chosen;
            pAsn1->u.octetString.length = pValue->cbData / 2;
            break;
#ifdef ASN1_SUPPORTS_UTF8_TAG
        case CERT_RDN_UTF8_STRING:
            pAsn1->choice = utf8String_chosen;
            pAsn1->u.octetString.length = pValue->cbData / 2;
            break;
#endif // ASN1_SUPPORTS_UTF8_TAG
        default:
            assert(dwValueType >= CERT_RDN_OCTET_STRING &&
                dwValueType <= CERT_RDN_UTF8_STRING);
            pAsn1->choice = 0;
    }
}

void Asn1X509GetAnyString(
        IN AnyString *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pdwValueType,
        OUT PCERT_RDN_VALUE_BLOB pValue,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;

    DWORD dwValueType;
    BYTE *pbData;
    LONG lData;

    pbData = pAsn1->u.octetString.value;
    lData = pAsn1->u.octetString.length;
    switch (pAsn1->choice) {
        case octetString_chosen:
            dwValueType = CERT_RDN_OCTET_STRING;
            break;
        case numericString_chosen:
            dwValueType = CERT_RDN_NUMERIC_STRING;
            break;
        case printableString_chosen:
            dwValueType = CERT_RDN_PRINTABLE_STRING;
            break;
        case teletexString_chosen:
            dwValueType = CERT_RDN_TELETEX_STRING;
            break;
        case videotexString_chosen:
            dwValueType = CERT_RDN_VIDEOTEX_STRING;
            break;
        case ia5String_chosen:
            dwValueType = CERT_RDN_IA5_STRING;
            break;
        case graphicString_chosen:
            dwValueType = CERT_RDN_GRAPHIC_STRING;
            break;
        case visibleString_chosen:
            dwValueType = CERT_RDN_VISIBLE_STRING;
            break;
        case generalString_chosen:
            dwValueType = CERT_RDN_GENERAL_STRING;
            break;
        case universalString_chosen:
            dwValueType = CERT_RDN_UNIVERSAL_STRING;
            lData = pAsn1->u.universalString.length * 4;
            break;
        case bmpString_chosen:
            dwValueType = CERT_RDN_BMP_STRING;
            lData = pAsn1->u.bmpString.length * 2;
            break;
#ifdef ASN1_SUPPORTS_UTF8_TAG
        case utf8String_chosen:
            dwValueType = CERT_RDN_UTF8_STRING;
            lData = pAsn1->u.utf8String.length * 2;
            break;
#endif // ASN1_SUPPORTS_UTF8_TAG
        default:
            assert(pAsn1->choice >= 1 && pAsn1->choice <= bmpString_chosen);
            dwValueType = 0;
    }

    // Add + sizeof(WCHAR) for added 0 bytes. Want to ensure that a char
    // or WCHAR string is always null terminated
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        *pdwValueType = dwValueType;
        pValue->pbData = *ppbExtra;
        pValue->cbData = (DWORD) lData;
        if (lData > 0)
            memcpy(pValue->pbData, pbData, lData);
        memset(pValue->pbData + lData, 0, sizeof(WCHAR));
        *ppbExtra += lAlignExtra;
    }
}


//+-------------------------------------------------------------------------
//  Allocate and Encode AnyString
//--------------------------------------------------------------------------
BOOL Asn1X509AllocAndEncodeAnyString(
        IN DWORD dwValueType,
        IN PCERT_RDN_VALUE_BLOB pValue,
        OUT BYTE **ppbEncoded,
        OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    AnyString Asn1String;
    ASN1error_e Asn1Err;
    ASN1encoding_t pEnc = GetEncoder();

    Asn1X509SetAnyString(dwValueType, pValue, &Asn1String);

    *ppbEncoded = NULL;
    *pcbEncoded = 0;
    PkiAsn1SetEncodingRule(pEnc, ASN1_BER_RULE_DER);
    if (ASN1_SUCCESS != (Asn1Err = PkiAsn1Encode(
                pEnc,
                &Asn1String,
                AnyString_PDU,
                ppbEncoded,
                pcbEncoded
                )))
        goto Asn1EncodeError;

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1EncodeError, PkiAsn1ErrToHr(Asn1Err))
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_RDN attribute value
//--------------------------------------------------------------------------
BOOL Asn1X509SetRDNAttributeValue(
        IN DWORD dwValueType,
        IN PCERT_RDN_VALUE_BLOB pValue,
        OUT NOCOPYANY *pAsn1
        )
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    if (dwValueType == CERT_RDN_ANY_TYPE) {
        SetLastError((DWORD) E_INVALIDARG);
        return FALSE;
    }

    // Determine if value is an encoded representation or is a known string
    // type. Encode accordingly.
    if (dwValueType == CERT_RDN_ENCODED_BLOB) {
        Asn1X509SetAny(pValue, pAsn1);
#ifndef ASN1_SUPPORTS_UTF8_TAG
    } else if (dwValueType == CERT_RDN_UTF8_STRING) {
        CRYPT_OBJID_BLOB ObjIdBlob;

        if (!Asn1X509AllocAndEncodeUTF8(
                pValue,
                &ObjIdBlob.pbData,
                &ObjIdBlob.cbData))
            return FALSE;
        Asn1X509SetAny(&ObjIdBlob, pAsn1);
#endif  // not defined ASN1_SUPPORTS_UTF8_TAG
    } else {
        CRYPT_OBJID_BLOB ObjIdBlob;

        if (!Asn1X509AllocAndEncodeAnyString(
                dwValueType,
                pValue,
                &ObjIdBlob.pbData,
                &ObjIdBlob.cbData))
            return FALSE;
        Asn1X509SetAny(&ObjIdBlob, pAsn1);
    }
    return TRUE;
}

void Asn1X509FreeRDNAttributeValue(
        IN DWORD dwValueType,
        IN OUT NOCOPYANY *pAsn1
        )
{
#ifndef ASN1_SUPPORTS_UTF8_TAG
    if (dwValueType == CERT_RDN_UTF8_STRING) {
        Asn1X509FreeEncodedUTF8((BYTE *) pAsn1->encoded);
        pAsn1->encoded = NULL;
        pAsn1->length = 0;
    } else
#endif  // not defined ASN1_SUPPORTS_UTF8_TAG
    if (dwValueType != CERT_RDN_ENCODED_BLOB) {
        if (pAsn1->encoded) {
            DWORD dwErr = GetLastError();

            // TlsGetValue globbers LastError
            PkiAsn1FreeEncoded(GetEncoder(), pAsn1->encoded);
            pAsn1->encoded = NULL;

            SetLastError(dwErr);
        }
        pAsn1->length = 0;
    }
}

BOOL Asn1X509GetRDNAttributeValue(
        IN NOCOPYANY *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pdwValueType,
        OUT PCERT_RDN_VALUE_BLOB pValue,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    ASN1decoding_t pDec = GetDecoder();
    AnyString *pAsn1String = NULL;

#ifndef ASN1_SUPPORTS_UTF8_TAG
    if (0 < pAsn1->length && UTF8_ASN_TAG == *((BYTE *) pAsn1->encoded))
        return Asn1X509GetUTF8(
            pAsn1,
            dwFlags,
            pdwValueType,
            pValue,
            ppbExtra,
            plRemainExtra
            );
#endif  // not defined ASN1_SUPPORTS_UTF8_TAG


#ifdef OSS_CRYPT_ASN1
    unsigned long ulPrevDecodingFlags;


    // Since its acceptable for the following decode to fail, don't output
    // decode errors.
    ulPrevDecodingFlags = ossGetDecodingFlags((POssGlobal) pDec);
    if (ulPrevDecodingFlags & DEBUG_ERRORS)
        ossSetDecodingFlags((POssGlobal) pDec,
            ulPrevDecodingFlags & ~DEBUG_ERRORS);
    ossSetEncodingRules((POssGlobal) pDec, OSS_BER);
#endif  // OSS_CRYPT_ASN1

    // Check if the value is a string type
    if (ASN1_SUCCESS == PkiAsn1Decode(
            pDec,
            (void **) &pAsn1String,
            AnyString_PDU,
            (BYTE *) pAsn1->encoded,
            pAsn1->length
            )) {
        Asn1X509GetAnyString(pAsn1String, dwFlags, pdwValueType, pValue,
            ppbExtra, plRemainExtra);
    } else {
        // Encoded representation
        if (*plRemainExtra >= 0)
            *pdwValueType = CERT_RDN_ENCODED_BLOB;

        Asn1X509GetAny(pAsn1, dwFlags, pValue, ppbExtra, plRemainExtra);
    }

#ifdef OSS_CRYPT_ASN1
    // Restore previous flags
    if (ulPrevDecodingFlags & DEBUG_ERRORS)
        ossSetDecodingFlags((POssGlobal) pDec, ulPrevDecodingFlags);
#endif  // OSS_CRYPT_ASN1

    PkiAsn1FreeDecoded(
        pDec,
        pAsn1String,
        AnyString_PDU
        );

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_RDN attribute
//--------------------------------------------------------------------------
BOOL Asn1X509SetRDNAttribute(
        IN PCERT_RDN_ATTR pInfo,
        OUT AttributeTypeValue *pAsn1
        )
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    if (pInfo->pszObjId) {
        if (!Asn1X509SetEncodedObjId(pInfo->pszObjId, &pAsn1->type))
            return FALSE;
    }

    return Asn1X509SetRDNAttributeValue(
            pInfo->dwValueType,
            &pInfo->Value,
            &pAsn1->value
            );
}

void Asn1X509FreeRDNAttribute(
        IN PCERT_RDN_ATTR pInfo,
        IN OUT AttributeTypeValue *pAsn1
        )
{
    Asn1X509FreeRDNAttributeValue(
        pInfo->dwValueType,
        &pAsn1->value
        );
}

BOOL Asn1X509GetRDNAttribute(
        IN AttributeTypeValue *pAsn1,
        IN DWORD dwFlags,
        OUT PCERT_RDN_ATTR pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Get ObjectIdentifier
    Asn1X509GetEncodedObjId(&pAsn1->type, dwFlags, &pInfo->pszObjId,
            ppbExtra, plRemainExtra);

    // Get value
    return Asn1X509GetRDNAttributeValue(&pAsn1->value, dwFlags,
        &pInfo->dwValueType, &pInfo->Value, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get SeqOfAny
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SetSeqOfAny(
        IN DWORD cValue,
        IN PCRYPT_DER_BLOB pValue,
#ifdef OSS_CRYPT_ASN1
        OUT unsigned int *pAsn1Count,
#else
        OUT ASN1uint32_t *pAsn1Count,
#endif  // OSS_CRYPT_ASN1
        OUT NOCOPYANY **ppAsn1Value
        )
{
    
    *pAsn1Count = 0;
    *ppAsn1Value = NULL;
    if (cValue > 0) {
        NOCOPYANY *pAsn1Value;

        pAsn1Value = (NOCOPYANY *) PkiZeroAlloc(cValue * sizeof(NOCOPYANY));
        if (pAsn1Value == NULL)
            return FALSE;
        *pAsn1Count = cValue;
        *ppAsn1Value = pAsn1Value;
        for ( ; cValue > 0; cValue--, pValue++, pAsn1Value++)
            Asn1X509SetAny(pValue, pAsn1Value);
    }
    return TRUE;
}

void Asn1X509FreeSeqOfAny(
        IN NOCOPYANY *pAsn1Value
        )
{
    if (pAsn1Value)
        PkiFree(pAsn1Value);
}

void Asn1X509GetSeqOfAny(
        IN unsigned int Asn1Count,
        IN NOCOPYANY *pAsn1Value,
        IN DWORD dwFlags,
        OUT DWORD *pcValue,
        OUT PCRYPT_DER_BLOB *ppValue,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;
    PCRYPT_ATTR_BLOB pValue;

    lAlignExtra = INFO_LEN_ALIGN(Asn1Count * sizeof(CRYPT_DER_BLOB));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        *pcValue = Asn1Count;
        pValue = (PCRYPT_DER_BLOB) *ppbExtra;
        *ppValue = pValue;
        *ppbExtra += lAlignExtra;
    } else
        pValue = NULL;

    for (; Asn1Count > 0; Asn1Count--, pAsn1Value++, pValue++)
        Asn1X509GetAny(pAsn1Value, dwFlags, pValue, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Set/Free/Get CRYPT_ATTRIBUTE
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SetAttribute(
        IN PCRYPT_ATTRIBUTE pInfo,
        OUT Attribute *pAsn1
        )
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    if (!Asn1X509SetEncodedObjId(pInfo->pszObjId, &pAsn1->type))
        return FALSE;

    return Asn1X509SetSeqOfAny(
            pInfo->cValue,
            pInfo->rgValue,
            &pAsn1->values.count,
            &pAsn1->values.value);
}

void Asn1X509FreeAttribute(
        IN OUT Attribute *pAsn1
        )
{
    Asn1X509FreeSeqOfAny(pAsn1->values.value);
}

void Asn1X509GetAttribute(
        IN Attribute *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_ATTRIBUTE pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    Asn1X509GetEncodedObjId(&pAsn1->type, dwFlags,
        &pInfo->pszObjId, ppbExtra, plRemainExtra);
    Asn1X509GetSeqOfAny(pAsn1->values.count, pAsn1->values.value, dwFlags,
        &pInfo->cValue, &pInfo->rgValue, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Attributes
//--------------------------------------------------------------------------
BOOL Asn1X509SetAttributes(
        IN DWORD cAttribute,
        IN PCRYPT_ATTRIBUTE pAttribute,
        OUT Attributes *pAsn1
        )
{
    Attribute *pAsn1Attr;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cAttribute == 0)
        return TRUE;

    pAsn1Attr = (Attribute *) PkiZeroAlloc(cAttribute * sizeof(Attribute));
    if (pAsn1Attr == NULL)
        return FALSE;
    pAsn1->value = pAsn1Attr;
    pAsn1->count = cAttribute;

    for ( ; cAttribute > 0; cAttribute--, pAttribute++, pAsn1Attr++) {
        if (!Asn1X509SetAttribute(pAttribute, pAsn1Attr))
            return FALSE;
    }
    return TRUE;
}

void Asn1X509FreeAttributes(
        IN Attributes *pAsn1
        )
{
    if (pAsn1->value) {
        DWORD cAttr = pAsn1->count;
        Attribute *pAsn1Attr = pAsn1->value;

        for ( ; cAttr > 0; cAttr--, pAsn1Attr++)
            Asn1X509FreeAttribute(pAsn1Attr);

        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1X509GetAttributes(
        IN Attributes *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcAttribute,
        OUT PCRYPT_ATTRIBUTE *ppAttribute,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cAttr;
    Attribute *pAsn1Attr;
    PCRYPT_ATTRIBUTE pGetAttr;

    cAttr = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cAttr * sizeof(CRYPT_ATTRIBUTE));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcAttribute = cAttr;
        pGetAttr = (PCRYPT_ATTRIBUTE) pbExtra;
        *ppAttribute = pGetAttr;
        pbExtra += lAlignExtra;
    } else
        pGetAttr = NULL;

    pAsn1Attr = pAsn1->value;
    for ( ; cAttr > 0; cAttr--, pAsn1Attr++, pGetAttr++) {
        Asn1X509GetAttribute(pAsn1Attr, dwFlags, pGetAttr,
                &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_ALT_NAME_ENTRY
//--------------------------------------------------------------------------
BOOL Asn1X509SetAltNameEntry(
        IN PCERT_ALT_NAME_ENTRY pInfo,
        OUT GeneralName *pAsn1,
        IN DWORD dwEntryIndex,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;

    // Assumption: ASN1 choice == dwAltNameChoice
    // Asn1X509GetAltNameEntry has asserts to verify
    pAsn1->choice = (unsigned short) pInfo->dwAltNameChoice;

    *pdwErrLocation = 0;

    switch (pInfo->dwAltNameChoice) {
    case CERT_ALT_NAME_OTHER_NAME:
        if (!Asn1X509SetEncodedObjId(pInfo->pOtherName->pszObjId,
                &pAsn1->u.otherName.type))
            goto ErrorReturn;
        Asn1X509SetAny(&pInfo->pOtherName->Value, &pAsn1->u.otherName.value);
        break;
    case CERT_ALT_NAME_DIRECTORY_NAME:
        Asn1X509SetAny(&pInfo->DirectoryName, &pAsn1->u.directoryName);
        break;
    case CERT_ALT_NAME_RFC822_NAME:
    case CERT_ALT_NAME_DNS_NAME:
    case CERT_ALT_NAME_URL:
        if (!Asn1X509SetUnicodeConvertedToIA5(pInfo->pwszRfc822Name,
                &pAsn1->u.rfc822Name, dwEntryIndex, pdwErrLocation))
            goto ErrorReturn;
        break;
    case CERT_ALT_NAME_IP_ADDRESS:
        Asn1X509SetOctetString(&pInfo->IPAddress, &pAsn1->u.iPAddress);
        break;
    case CERT_ALT_NAME_REGISTERED_ID:
        if (!Asn1X509SetEncodedObjId(pInfo->pszRegisteredID, &pAsn1->u.registeredID))
            goto ErrorReturn;
        break;
    case CERT_ALT_NAME_X400_ADDRESS:
    case CERT_ALT_NAME_EDI_PARTY_NAME:
    default:
        SetLastError((DWORD) E_INVALIDARG);
        goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

void Asn1X509FreeAltNameEntry(
        IN GeneralName *pAsn1
        )
{
    switch (pAsn1->choice) {
    case CERT_ALT_NAME_RFC822_NAME:
    case CERT_ALT_NAME_DNS_NAME:
    case CERT_ALT_NAME_URL:
        Asn1X509FreeUnicodeConvertedToIA5(&pAsn1->u.rfc822Name);
        break;
    default:
        break;
    }
}

BOOL Asn1X509GetAltNameEntry(
        IN GeneralName *pAsn1,
        IN DWORD dwFlags,
        OUT PCERT_ALT_NAME_ENTRY pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    DWORD dwAltNameChoice;

    assert(otherName_chosen == CERT_ALT_NAME_OTHER_NAME);
    assert(rfc822Name_chosen == CERT_ALT_NAME_RFC822_NAME);
    assert(dNSName_chosen == CERT_ALT_NAME_DNS_NAME);
    assert(x400Address_chosen == CERT_ALT_NAME_X400_ADDRESS);
    assert(directoryName_chosen == CERT_ALT_NAME_DIRECTORY_NAME);
    assert(ediPartyName_chosen == CERT_ALT_NAME_EDI_PARTY_NAME);
    assert(uniformResourceLocator_chosen == CERT_ALT_NAME_URL);
    assert(iPAddress_chosen == CERT_ALT_NAME_IP_ADDRESS);
    assert(registeredID_chosen == CERT_ALT_NAME_REGISTERED_ID);


    dwAltNameChoice = pAsn1->choice;
    if (*plRemainExtra >= 0)
        pInfo->dwAltNameChoice = dwAltNameChoice;
    switch (dwAltNameChoice) {
    case CERT_ALT_NAME_OTHER_NAME:
        {
            LONG lAlignExtra;
            PCERT_OTHER_NAME pOtherName;

            lAlignExtra = INFO_LEN_ALIGN(sizeof(CERT_OTHER_NAME));
            *plRemainExtra -= lAlignExtra;
            if (*plRemainExtra >= 0) {
                pOtherName = (PCERT_OTHER_NAME) *ppbExtra;
                pInfo->pOtherName = pOtherName;
                *ppbExtra += lAlignExtra;
            } else
                pOtherName = NULL;

            Asn1X509GetEncodedObjId(&pAsn1->u.otherName.type, dwFlags,
                &pOtherName->pszObjId, ppbExtra, plRemainExtra);
            Asn1X509GetAny(&pAsn1->u.otherName.value, dwFlags,
                &pOtherName->Value, ppbExtra, plRemainExtra);
        }
        break;
    case CERT_ALT_NAME_DIRECTORY_NAME:
        Asn1X509GetAny(&pAsn1->u.directoryName, dwFlags,
            &pInfo->DirectoryName, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_RFC822_NAME:
    case CERT_ALT_NAME_DNS_NAME:
    case CERT_ALT_NAME_URL:
        Asn1X509GetIA5ConvertedToUnicode(&pAsn1->u.rfc822Name, dwFlags,
            &pInfo->pwszRfc822Name, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_IP_ADDRESS:
        Asn1X509GetOctetString(&pAsn1->u.iPAddress, dwFlags,
            &pInfo->IPAddress, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_REGISTERED_ID:
        Asn1X509GetEncodedObjId(&pAsn1->u.registeredID, dwFlags,
            &pInfo->pszRegisteredID, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_X400_ADDRESS:
    case CERT_ALT_NAME_EDI_PARTY_NAME:
        break;
    default:
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_ALT_NAME_INFO
//--------------------------------------------------------------------------
BOOL Asn1X509SetAltNames(
        IN PCERT_ALT_NAME_INFO pInfo,
        OUT AltNames *pAsn1,
        IN DWORD dwIndex,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    DWORD i;
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;
    GeneralName *pAsn1Entry = NULL;

    *pdwErrLocation = 0;

    cEntry = pInfo->cAltEntry;
    pEntry = pInfo->rgAltEntry;
    pAsn1->count = cEntry;
    pAsn1->value = NULL;
    if (cEntry > 0) {
        pAsn1Entry =
            (GeneralName *) PkiZeroAlloc(cEntry * sizeof(GeneralName));
        if (pAsn1Entry == NULL)
            goto ErrorReturn;
        pAsn1->value = pAsn1Entry;
    }

    // Array of AltName entries
    for (i = 0; i < cEntry; i++, pEntry++, pAsn1Entry++) {
        if (!Asn1X509SetAltNameEntry(pEntry, pAsn1Entry,
                (dwIndex << 8) | i, pdwErrLocation))
            goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

void Asn1X509FreeAltNames(
        OUT AltNames *pAsn1
        )
{
    if (pAsn1->value) {
        DWORD cEntry = pAsn1->count;
        GeneralName *pAsn1Entry = pAsn1->value;
        for ( ; cEntry > 0; cEntry--, pAsn1Entry++)
            Asn1X509FreeAltNameEntry(pAsn1Entry);
        PkiFree(pAsn1->value);
    }
}

BOOL Asn1X509GetAltNames(
        IN AltNames *pAsn1,
        IN DWORD dwFlags,
        OUT PCERT_ALT_NAME_INFO pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;
    GeneralName *pAsn1Entry;

    cEntry = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cEntry * sizeof(CERT_ALT_NAME_ENTRY));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        pInfo->cAltEntry = cEntry;
        pEntry = (PCERT_ALT_NAME_ENTRY) *ppbExtra;
        pInfo->rgAltEntry = pEntry;
        *ppbExtra += lAlignExtra;
    } else
        pEntry = NULL;

    // Array of AltName entries
    pAsn1Entry = pAsn1->value;
    for (; cEntry > 0; cEntry--, pEntry++, pAsn1Entry++) {
        if (!Asn1X509GetAltNameEntry(pAsn1Entry, dwFlags,
                    pEntry, ppbExtra, plRemainExtra))
                return FALSE;
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_ACCESS_DESCRIPTION
//--------------------------------------------------------------------------
BOOL Asn1X509SetAccessDescriptions(
        IN DWORD cAccDescr,
        IN PCERT_ACCESS_DESCRIPTION pAccDescr,
        OUT AccessDescription *pAsn1,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    DWORD i;

    *pdwErrLocation = 0;
    for (i = 0; i < cAccDescr; i++, pAccDescr++, pAsn1++) {
        if (!Asn1X509SetEncodedObjId(pAccDescr->pszAccessMethod, &pAsn1->accessMethod))
            goto ErrorReturn;
        if (!Asn1X509SetAltNameEntry(&pAccDescr->AccessLocation,
                &pAsn1->accessLocation,
                i,
                pdwErrLocation))
            goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

void Asn1X509FreeAccessDescriptions(
        IN DWORD cAccDescr,
        IN OUT AccessDescription *pAsn1
        )
{
    for ( ; cAccDescr > 0; cAccDescr--, pAsn1++)
        Asn1X509FreeAltNameEntry(&pAsn1->accessLocation);
}

BOOL Asn1X509GetAccessDescriptions(
        IN DWORD cAccDescr,
        IN AccessDescription *pAsn1,
        IN DWORD dwFlags,
        IN PCERT_ACCESS_DESCRIPTION pAccDescr,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Array of AccessDescription entries
    for (; cAccDescr > 0; cAccDescr--, pAccDescr++, pAsn1++) {
        Asn1X509GetEncodedObjId(&pAsn1->accessMethod, dwFlags,
                &pAccDescr->pszAccessMethod, ppbExtra, plRemainExtra);
        if (!Asn1X509GetAltNameEntry(&pAsn1->accessLocation, dwFlags,
                &pAccDescr->AccessLocation, ppbExtra, plRemainExtra))
            return FALSE;
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Encode the Cert Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CertificateToBeSigned Cert;

    memset(&Cert, 0, sizeof(Cert));
    if (pInfo->dwVersion != 0) {
#ifdef OSS_CRYPT_ASN1
        Cert.CertificateToBeSigned_version = pInfo->dwVersion;
#else
        Cert.version = pInfo->dwVersion;
#endif  // OSS_CRYPT_ASN1
        Cert.bit_mask |= CertificateToBeSigned_version_present;
    }

    if (!Asn1X509SetHugeInteger(&pInfo->SerialNumber, &Cert.serialNumber))
        goto ErrorReturn;
    if (!Asn1X509SetAlgorithm(&pInfo->SignatureAlgorithm, &Cert.signature,
            CRYPT_SIGN_ALG_OID_GROUP_ID))
        goto ErrorReturn;
    Asn1X509SetAny(&pInfo->Issuer, &Cert.issuer);
    if (!PkiAsn1ToChoiceOfTime(&pInfo->NotBefore, 
            &Cert.validity.notBefore.choice,
            &Cert.validity.notBefore.u.generalTime,
            &Cert.validity.notBefore.u.utcTime
            ))
        goto EncodeError;
    if (!PkiAsn1ToChoiceOfTime(&pInfo->NotAfter, 
            &Cert.validity.notAfter.choice,
            &Cert.validity.notAfter.u.generalTime,
            &Cert.validity.notAfter.u.utcTime
            ))
        goto EncodeError;
    Asn1X509SetAny(&pInfo->Subject, &Cert.subject);
    if (!Asn1X509SetPublicKeyInfo(&pInfo->SubjectPublicKeyInfo,
            &Cert.subjectPublicKeyInfo))
        goto ErrorReturn;

    if (pInfo->IssuerUniqueId.cbData) {
        Asn1X509SetBit(&pInfo->IssuerUniqueId, &Cert.issuerUniqueIdentifier);
        Cert.bit_mask |= issuerUniqueIdentifier_present;
    }
    if (pInfo->SubjectUniqueId.cbData) {
        Asn1X509SetBit(&pInfo->SubjectUniqueId, &Cert.subjectUniqueIdentifier);
        Cert.bit_mask |= subjectUniqueIdentifier_present;
    }
    if (pInfo->cExtension) {
        if (!Asn1X509SetExtensions(pInfo->cExtension, pInfo->rgExtension,
                &Cert.extensions))
            goto ErrorReturn;
        Cert.bit_mask |= extensions_present;
    }

    fResult = Asn1InfoEncodeEx(
        CertificateToBeSigned_PDU,
        &Cert,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

EncodeError:
    SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeHugeInteger(&Cert.serialNumber);
    Asn1X509FreeExtensions(&Cert.extensions);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the Cert Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CertificateToBeSigned *pCert = (CertificateToBeSigned *) pvAsn1Info;
    PCERT_INFO pInfo = (PCERT_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_INFO));

        // Update fields not needing extra memory after the CERT_INFO
        if (pCert->bit_mask & CertificateToBeSigned_version_present)
#ifdef OSS_CRYPT_ASN1
            pInfo->dwVersion = pCert->CertificateToBeSigned_version;
#else
            pInfo->dwVersion = pCert->version;
#endif  // OSS_CRYPT_ASN1
        if (!PkiAsn1FromChoiceOfTime(pCert->validity.notBefore.choice,
                &pCert->validity.notBefore.u.generalTime,
                &pCert->validity.notBefore.u.utcTime,
                &pInfo->NotBefore))
            goto DecodeError;
        if (!PkiAsn1FromChoiceOfTime(pCert->validity.notAfter.choice,
                &pCert->validity.notAfter.u.generalTime,
                &pCert->validity.notAfter.u.utcTime,
                &pInfo->NotAfter))
            goto DecodeError;
        pbExtra = (BYTE *) pInfo + sizeof(CERT_INFO);
    }

    Asn1X509GetHugeInteger(&pCert->serialNumber, dwFlags,
            &pInfo->SerialNumber, &pbExtra, &lRemainExtra);
    Asn1X509GetAlgorithm(&pCert->signature, dwFlags,
            &pInfo->SignatureAlgorithm, &pbExtra, &lRemainExtra);
    Asn1X509GetAny(&pCert->issuer, dwFlags,
            &pInfo->Issuer, &pbExtra, &lRemainExtra);
    Asn1X509GetAny(&pCert->subject, dwFlags,
            &pInfo->Subject, &pbExtra, &lRemainExtra);
    Asn1X509GetPublicKeyInfo(&pCert->subjectPublicKeyInfo, dwFlags,
            &pInfo->SubjectPublicKeyInfo, &pbExtra, &lRemainExtra);

    if (pCert->bit_mask & issuerUniqueIdentifier_present)
        Asn1X509GetBit(&pCert->issuerUniqueIdentifier, dwFlags,
            &pInfo->IssuerUniqueId, &pbExtra, &lRemainExtra);
    if (pCert->bit_mask & subjectUniqueIdentifier_present)
        Asn1X509GetBit(&pCert->subjectUniqueIdentifier, dwFlags,
            &pInfo->SubjectUniqueId, &pbExtra, &lRemainExtra);
    if (pCert->bit_mask & extensions_present)
        Asn1X509GetExtensions(&pCert->extensions, dwFlags,
            &pInfo->cExtension, &pInfo->rgExtension, &pbExtra, &lRemainExtra);

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1X509CertInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    const BYTE *pbToBeSigned;
    DWORD cbToBeSigned;

    if ((dwFlags & CRYPT_DECODE_TO_BE_SIGNED_FLAG) ||
            !Asn1UtilExtractCertificateToBeSignedContent(
                pbEncoded,
                cbEncoded,
                &cbToBeSigned,
                &pbToBeSigned
                )) {
        pbToBeSigned = pbEncoded;
        cbToBeSigned = cbEncoded;
    }

    return Asn1InfoDecodeAndAllocEx(
        CertificateToBeSigned_PDU,
        pbToBeSigned,
        cbToBeSigned,
        dwFlags,
        pDecodePara,
        Asn1X509CertInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode the CRL Info (ASN1 X509 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrlInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CertificateRevocationListToBeSigned Crl;

    memset(&Crl, 0, sizeof(Crl));

    if (pInfo->dwVersion != 0) {
#ifdef OSS_CRYPT_ASN1
        Crl.CertificateRevocationListToBeSigned_version = pInfo->dwVersion;
#else
        Crl.version = pInfo->dwVersion;
#endif  // OSS_CRYPT_ASN1
        Crl.bit_mask |= CertificateRevocationListToBeSigned_version_present;
    }
    if (!Asn1X509SetAlgorithm(&pInfo->SignatureAlgorithm, &Crl.signature,
            CRYPT_SIGN_ALG_OID_GROUP_ID))
        goto ErrorReturn;
    Asn1X509SetAny(&pInfo->Issuer, &Crl.issuer);
    if (!PkiAsn1ToChoiceOfTime(&pInfo->ThisUpdate, 
            &Crl.thisUpdate.choice,
            &Crl.thisUpdate.u.generalTime,
            &Crl.thisUpdate.u.utcTime
            ))
        goto EncodeError;
    if (pInfo->NextUpdate.dwLowDateTime || pInfo->NextUpdate.dwHighDateTime) {
        Crl.bit_mask |= nextUpdate_present;
        if (!PkiAsn1ToChoiceOfTime(&pInfo->NextUpdate, 
                &Crl.nextUpdate.choice,
                &Crl.nextUpdate.u.generalTime,
                &Crl.nextUpdate.u.utcTime
                ))
            goto EncodeError;
    }
    if (pInfo->cCRLEntry) {
        if (!Asn1X509SetCrlEntries(pInfo->cCRLEntry, pInfo->rgCRLEntry,
                &Crl.revokedCertificates))
            goto ErrorReturn;
        Crl.bit_mask |= revokedCertificates_present;
    }
    if (pInfo->cExtension) {
        if (!Asn1X509SetExtensions(pInfo->cExtension, pInfo->rgExtension,
                &Crl.crlExtensions))
            goto ErrorReturn;
        Crl.bit_mask |= crlExtensions_present;
    }

    fResult = Asn1InfoEncodeEx(
        CertificateRevocationListToBeSigned_PDU,
        &Crl,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

EncodeError:
    SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeCrlEntries(&Crl.revokedCertificates);
    Asn1X509FreeExtensions(&Crl.crlExtensions);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the CRL Info (ASN1 X509 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrlInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CertificateRevocationListToBeSigned *pCrl = 
        (CertificateRevocationListToBeSigned *) pvAsn1Info;
    PCRL_INFO pInfo = (PCRL_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRL_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CRL_INFO));

        // Update fields not needing extra memory after the CRL_INFO
        if (pCrl->bit_mask &
                CertificateRevocationListToBeSigned_version_present)
#ifdef OSS_CRYPT_ASN1
            pInfo->dwVersion =
                pCrl->CertificateRevocationListToBeSigned_version;
#else
            pInfo->dwVersion = pCrl->version;
#endif  // OSS_CRYPT_ASN1
        if (!PkiAsn1FromChoiceOfTime(pCrl->thisUpdate.choice,
                &pCrl->thisUpdate.u.generalTime,
                &pCrl->thisUpdate.u.utcTime,
                &pInfo->ThisUpdate))
            goto DecodeError;
        if (pCrl->bit_mask & nextUpdate_present) {
            if (!PkiAsn1FromChoiceOfTime(pCrl->nextUpdate.choice,
                    &pCrl->nextUpdate.u.generalTime,
                    &pCrl->nextUpdate.u.utcTime,
                    &pInfo->NextUpdate))
                goto DecodeError;
        }

        pbExtra = (BYTE *) pInfo + sizeof(CRL_INFO);
    }

    Asn1X509GetAlgorithm(&pCrl->signature, dwFlags,
            &pInfo->SignatureAlgorithm, &pbExtra, &lRemainExtra);
    Asn1X509GetAny(&pCrl->issuer, dwFlags,
            &pInfo->Issuer, &pbExtra, &lRemainExtra);
    if (pCrl->bit_mask & revokedCertificates_present)
        Asn1X509GetCrlEntries(&pCrl->revokedCertificates, dwFlags,
            &pInfo->cCRLEntry, &pInfo->rgCRLEntry, &pbExtra, &lRemainExtra);
    if (pCrl->bit_mask & crlExtensions_present)
        Asn1X509GetExtensions(&pCrl->crlExtensions, dwFlags,
            &pInfo->cExtension, &pInfo->rgExtension, &pbExtra, &lRemainExtra);

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1X509CrlInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    const BYTE *pbToBeSigned;
    DWORD cbToBeSigned;

    if ((dwFlags & CRYPT_DECODE_TO_BE_SIGNED_FLAG) ||
            !Asn1UtilExtractCertificateToBeSignedContent(
                pbEncoded,
                cbEncoded,
                &cbToBeSigned,
                &pbToBeSigned
                )) {
        pbToBeSigned = pbEncoded;
        cbToBeSigned = cbEncoded;
    }

    return Asn1InfoDecodeAndAllocEx(
        CertificateRevocationListToBeSigned_PDU,
        pbToBeSigned,
        cbToBeSigned,
        dwFlags,
        pDecodePara,
        Asn1X509CrlInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode the Cert Request Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertRequestInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_REQUEST_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CertificationRequestInfo CertReq;

    memset(&CertReq, 0, sizeof(CertReq));
    CertReq.version = pInfo->dwVersion;

    Asn1X509SetAny(&pInfo->Subject, &CertReq.subject);
    if (!Asn1X509SetPublicKeyInfo(&pInfo->SubjectPublicKeyInfo,
            &CertReq.subjectPublicKeyInfo))
        goto ErrorReturn;

    if (!Asn1X509SetAttributes(pInfo->cAttribute, pInfo->rgAttribute,
            &CertReq.attributes))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        CertificationRequestInfo_PDU,
        &CertReq,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeAttributes(&CertReq.attributes);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the Cert Request Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertRequestInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    CertificationRequestInfoDecode *pCertReq = 
        (CertificationRequestInfoDecode *) pvAsn1Info;
    PCERT_REQUEST_INFO pInfo = (PCERT_REQUEST_INFO) pvStructInfo;
    BYTE *pbExtra;
    LONG lRemainExtra = *plRemainExtra;

    lRemainExtra -= sizeof(CERT_REQUEST_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_REQUEST_INFO));

        // Update fields not needing extra memory after the CERT_INFO
        pInfo->dwVersion = pCertReq->version;
        pbExtra = (BYTE *) pInfo + sizeof(CERT_REQUEST_INFO);
    }

    Asn1X509GetAny(&pCertReq->subject, dwFlags,
            &pInfo->Subject, &pbExtra, &lRemainExtra);
    Asn1X509GetPublicKeyInfo(&pCertReq->subjectPublicKeyInfo, dwFlags,
            &pInfo->SubjectPublicKeyInfo,
            &pbExtra, &lRemainExtra);

    if (pCertReq->bit_mask & attributes_present) {
        Asn1X509GetAttributes(&pCertReq->attributes, dwFlags,
            &pInfo->cAttribute, &pInfo->rgAttribute, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509CertRequestInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    const BYTE *pbToBeSigned;
    DWORD cbToBeSigned;

    if ((dwFlags & CRYPT_DECODE_TO_BE_SIGNED_FLAG) ||
            !Asn1UtilExtractCertificateToBeSignedContent(
                pbEncoded,
                cbEncoded,
                &cbToBeSigned,
                &pbToBeSigned
                )) {
        pbToBeSigned = pbEncoded;
        cbToBeSigned = cbEncoded;
    }

    return Asn1InfoDecodeAndAllocEx(
        CertificationRequestInfoDecode_PDU,
        pbToBeSigned,
        cbToBeSigned,
        dwFlags,
        pDecodePara,
        Asn1X509CertRequestInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode the Keygen Request Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509KeygenRequestInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEYGEN_REQUEST_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    KeygenRequestInfo KeygenReq;
    DWORD dwErrLocation;

    memset(&KeygenReq, 0, sizeof(KeygenReq));

    if (!Asn1X509SetPublicKeyInfo(&pInfo->SubjectPublicKeyInfo,
            &KeygenReq.subjectPublicKeyInfo))
        goto ErrorReturn;
    if (!Asn1X509SetUnicodeConvertedToIA5(pInfo->pwszChallengeString,
            &KeygenReq.challenge, 0, &dwErrLocation)) {
        *pcbEncoded = dwErrLocation;
        goto InvalidIA5;
    }

    fResult = Asn1InfoEncodeEx(
        KeygenRequestInfo_PDU,
        &KeygenReq,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
InvalidIA5:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeUnicodeConvertedToIA5(&KeygenReq.challenge);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the Keygen Request Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509KeygenRequestInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    KeygenRequestInfo *pKeygenReq = (KeygenRequestInfo *) pvAsn1Info;
    PCERT_KEYGEN_REQUEST_INFO pInfo = (PCERT_KEYGEN_REQUEST_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_KEYGEN_REQUEST_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_KEYGEN_REQUEST_INFO));

        pbExtra = (BYTE *) pInfo + sizeof(CERT_KEYGEN_REQUEST_INFO);
    }

    Asn1X509GetPublicKeyInfo(&pKeygenReq->subjectPublicKeyInfo, dwFlags,
        &pInfo->SubjectPublicKeyInfo, &pbExtra, &lRemainExtra);
    Asn1X509GetIA5ConvertedToUnicode(&pKeygenReq->challenge, dwFlags,
            &pInfo->pwszChallengeString, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509KeygenRequestInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    const BYTE *pbToBeSigned;
    DWORD cbToBeSigned;

    if ((dwFlags & CRYPT_DECODE_TO_BE_SIGNED_FLAG) ||
            !Asn1UtilExtractCertificateToBeSignedContent(
                pbEncoded,
                cbEncoded,
                &cbToBeSigned,
                &pbToBeSigned
                )) {
        pbToBeSigned = pbEncoded;
        cbToBeSigned = cbEncoded;
    }

    return Asn1InfoDecodeAndAllocEx(
        KeygenRequestInfo_PDU,
        pbToBeSigned,
        cbToBeSigned,
        dwFlags,
        pDecodePara,
        Asn1X509KeygenRequestInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode the Signed Content (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SignedContentEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_SIGNED_CONTENT_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    SignedContent Asn1SignedContent;
    CRYPT_BIT_BLOB SignatureBlob;
    BYTE *pbAllocSignature = NULL;

    memset(&Asn1SignedContent, 0, sizeof(Asn1SignedContent));
    Asn1X509SetAny(&pInfo->ToBeSigned, &Asn1SignedContent.toBeSigned);
    if (!Asn1X509SetAlgorithm(&pInfo->SignatureAlgorithm,
            &Asn1SignedContent.algorithm, CRYPT_SIGN_ALG_OID_GROUP_ID))
        goto ErrorReturn;

    if (dwFlags & CRYPT_ENCODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG) {
        SignatureBlob.pbData = pInfo->Signature.pbData;
    } else {
        if (NULL == (pbAllocSignature = PkiAsn1AllocAndReverseBytes(
                pInfo->Signature.pbData, pInfo->Signature.cbData)))
            goto ErrorReturn;
        SignatureBlob.pbData = pbAllocSignature;
    }
    SignatureBlob.cbData = pInfo->Signature.cbData;
    SignatureBlob.cUnusedBits = 0;
    Asn1X509SetBit(&SignatureBlob, &Asn1SignedContent.signature);

    fResult = Asn1InfoEncodeEx(
        SignedContent_PDU,
        &Asn1SignedContent,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbAllocSignature)
        PkiAsn1Free(pbAllocSignature);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the Signed Content (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SignedContentDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    SignedContent *pSignedContent = (SignedContent *) pvAsn1Info;
    PCERT_SIGNED_CONTENT_INFO pInfo = (PCERT_SIGNED_CONTENT_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_SIGNED_CONTENT_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_SIGNED_CONTENT_INFO);

    Asn1X509GetAny(&pSignedContent->toBeSigned, dwFlags,
        &pInfo->ToBeSigned, &pbExtra, &lRemainExtra);
    Asn1X509GetAlgorithm(&pSignedContent->algorithm, dwFlags,
        &pInfo->SignatureAlgorithm, &pbExtra, &lRemainExtra);
    // Since bits will be reversed, always need to make a copy (dwFlags = 0)
    Asn1X509GetBit(&pSignedContent->signature, 0,
        &pInfo->Signature, &pbExtra, &lRemainExtra);
    if (lRemainExtra >= 0) {
        if (0 == (dwFlags & CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG))
            PkiAsn1ReverseBytes(pInfo->Signature.pbData,
                pInfo->Signature.cbData);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509SignedContentDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
            SignedContent_PDU,
            pbEncoded,
            cbEncoded,
            dwFlags,
            pDecodePara,
            Asn1X509SignedContentDecodeExCallback,
            pvStructInfo,
            pcbStructInfo
            );
}

//+-------------------------------------------------------------------------
//  Encode the Name Info (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509NameInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD cRDN, cAttr;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;
    Name Asn1Name;
    RelativeDistinguishedName *pAsn1RDN = NULL;
    AttributeTypeValue *pAsn1Attr = NULL;

    cRDN = pInfo->cRDN;
    pRDN = pInfo->rgRDN;
    Asn1Name.count = cRDN;
    Asn1Name.value = NULL;
    if (cRDN > 0) {
        pAsn1RDN =
            (RelativeDistinguishedName *) PkiZeroAlloc(
                cRDN * sizeof(RelativeDistinguishedName));
        if (pAsn1RDN == NULL)
            goto ErrorReturn;
        Asn1Name.value = pAsn1RDN;
    }

    // Array of RDNs
    for ( ; cRDN > 0; cRDN--, pRDN++, pAsn1RDN++) {
        cAttr = pRDN->cRDNAttr;
        pAttr = pRDN->rgRDNAttr;
        pAsn1RDN->count = cAttr;

        if (cAttr > 0) {
            pAsn1Attr =
                (AttributeTypeValue *) PkiZeroAlloc(cAttr *
                    sizeof(AttributeTypeValue));
            if (pAsn1Attr == NULL)
                goto ErrorReturn;
            pAsn1RDN->value = pAsn1Attr;
        }

        // Array of attribute/values
        for ( ; cAttr > 0; cAttr--, pAttr++, pAsn1Attr++) {
            // We're now ready to encode the attribute/value stuff
            if (!Asn1X509SetRDNAttribute(pAttr, pAsn1Attr))
                goto ErrorReturn;
        }
    }

    fResult = Asn1InfoEncodeEx(
        Name_PDU,
        &Asn1Name,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (Asn1Name.value) {
        cRDN = Asn1Name.count;
        pRDN = pInfo->rgRDN;
        pAsn1RDN = Asn1Name.value;
        for ( ; cRDN > 0; cRDN--, pRDN++, pAsn1RDN++) {
            if (pAsn1RDN->value) {
                cAttr = pAsn1RDN->count;
                pAttr = pRDN->rgRDNAttr;
                pAsn1Attr = pAsn1RDN->value;
                for ( ; cAttr > 0; cAttr--, pAttr++, pAsn1Attr++)
                    Asn1X509FreeRDNAttribute(pAttr, pAsn1Attr);
                PkiFree(pAsn1RDN->value);
            }
        }
        PkiFree(Asn1Name.value);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the Name Info (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509NameInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    Name *pAsn1Name =  (Name *) pvAsn1Info;
    PCERT_NAME_INFO pInfo = (PCERT_NAME_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;

    DWORD cRDN, cAttr;
    PCERT_RDN pRDN;
    PCERT_RDN_ATTR pAttr;
    RelativeDistinguishedName *pAsn1RDN;
    AttributeTypeValue *pAsn1Attr;

    lRemainExtra -= sizeof(CERT_NAME_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_NAME_INFO);

    cRDN = pAsn1Name->count;
    pAsn1RDN = pAsn1Name->value;
    lAlignExtra = INFO_LEN_ALIGN(cRDN * sizeof(CERT_RDN));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pInfo->cRDN = cRDN;
        pRDN = (PCERT_RDN) pbExtra;
        pInfo->rgRDN = pRDN;
        pbExtra += lAlignExtra;
    } else
        pRDN = NULL;

    // Array of RDNs
    for (; cRDN > 0; cRDN--, pRDN++, pAsn1RDN++) {
        cAttr = pAsn1RDN->count;
        pAsn1Attr = pAsn1RDN->value;
        lAlignExtra = INFO_LEN_ALIGN(cAttr * sizeof(CERT_RDN_ATTR));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pRDN->cRDNAttr = cAttr;
            pAttr = (PCERT_RDN_ATTR) pbExtra;
            pRDN->rgRDNAttr = pAttr;
            pbExtra += lAlignExtra;
        } else
            pAttr = NULL;

        // Array of attribute/values
        for (; cAttr > 0; cAttr--, pAttr++, pAsn1Attr++)
            // We're now ready to decode the attribute/value stuff
            if (!Asn1X509GetRDNAttribute(pAsn1Attr, dwFlags,
                    pAttr, &pbExtra, &lRemainExtra))
                return FALSE;
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}


BOOL WINAPI Asn1X509NameInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        Name_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509NameInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Encode a single Name Value (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509NameValueEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_VALUE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD dwValueType;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;

    dwValueType = pInfo->dwValueType;
    switch (dwValueType) {
    case CERT_RDN_ANY_TYPE:
        SetLastError((DWORD) E_INVALIDARG);
        *pcbEncoded = 0;
        fResult = FALSE;
        break;
#ifndef ASN1_SUPPORTS_UTF8_TAG
    case CERT_RDN_UTF8_STRING:
        {
            CERT_NAME_VALUE EncodedBlobInfo;

            fResult = Asn1X509AllocAndEncodeUTF8(
                &pInfo->Value,
                &EncodedBlobInfo.Value.pbData,
                &EncodedBlobInfo.Value.cbData
                );
            if (fResult) {
                EncodedBlobInfo.dwValueType = CERT_RDN_ENCODED_BLOB;
                fResult = Asn1X509NameValueEncodeEx(
                    dwCertEncodingType,
                    lpszStructType,
                    &EncodedBlobInfo,
                    dwFlags,
                    pEncodePara,
                    pvEncoded,
                    pcbEncoded
                    );
                Asn1X509FreeEncodedUTF8(EncodedBlobInfo.Value.pbData);
            } else
                *pcbEncoded = 0;
        }
        break;
#endif  // not defined ASN1_SUPPORTS_UTF8_TAG
    case CERT_RDN_ENCODED_BLOB:
        {
            DWORD cbEncoded = pInfo->Value.cbData;

            fResult = TRUE;
            if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
                if (cbEncoded) {
                    BYTE *pb;
                    PFN_CRYPT_ALLOC pfnAlloc =
                        PkiGetEncodeAllocFunction(pEncodePara);
                    if (NULL == (pb = (BYTE *) pfnAlloc(cbEncoded))) {
                        fResult = FALSE;
                        cbEncoded = 0;
                    } else {
                        memcpy(pb, pInfo->Value.pbData, cbEncoded);
                        *((BYTE **) pvEncoded) = pb;
                    }
                }
            } else {
                if (NULL == pvEncoded)
                    *pcbEncoded = 0;
                if (*pcbEncoded < cbEncoded) {
                    if (pvEncoded) {
                        SetLastError((DWORD) ERROR_MORE_DATA);
                        fResult = FALSE;
                    }
                } else if (cbEncoded)
                    memcpy((BYTE *) pvEncoded, pInfo->Value.pbData, cbEncoded);
            }
            *pcbEncoded = cbEncoded;
        }
        break;
    default:
        {
            AnyString Asn1AnyString;

            Asn1X509SetAnyString(dwValueType, &pInfo->Value, &Asn1AnyString);
            fResult = Asn1InfoEncodeEx(
                AnyString_PDU,
                &Asn1AnyString,
                dwFlags,
                pEncodePara,
                pvEncoded,
                pcbEncoded
                );
        }
        break;
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode a single Name Value (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509NameValueDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    PCERT_NAME_VALUE pInfo = (PCERT_NAME_VALUE) pvStructInfo;
    NOCOPYANY Asn1Value;
    BYTE *pbExtra;
    LONG lRemainExtra;


    if (pInfo == NULL || (dwFlags & CRYPT_DECODE_ALLOC_FLAG))
        *pcbStructInfo = 0;

    memset(&Asn1Value, 0, sizeof(Asn1Value));
    Asn1Value.encoded = (void *)pbEncoded;
    Asn1Value.length = cbEncoded;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbStructInfo - sizeof(CERT_NAME_VALUE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_NAME_VALUE);

    if (!Asn1X509GetRDNAttributeValue(&Asn1Value, dwFlags,
            &pInfo->dwValueType, &pInfo->Value, &pbExtra, &lRemainExtra))
        goto GetRDNAttributeValueError;

    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
        PCERT_NAME_VALUE pAllocInfo;
        PFN_CRYPT_ALLOC pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);

        assert(0 > lRemainExtra);
        lRemainExtra = -lRemainExtra;

        pAllocInfo = (PCERT_NAME_VALUE) pfnAlloc(lRemainExtra);
        *((PCERT_NAME_VALUE *) pvStructInfo) = pAllocInfo;
        if (NULL == pAllocInfo)
            goto OutOfMemory;
        *pcbStructInfo = lRemainExtra;

        pbExtra = (BYTE *) pAllocInfo + sizeof(CERT_NAME_VALUE);
        lRemainExtra -= sizeof(CERT_NAME_VALUE);
        if (!Asn1X509GetRDNAttributeValue(&Asn1Value, dwFlags,
                &pAllocInfo->dwValueType, &pAllocInfo->Value,
                &pbExtra, &lRemainExtra))
            goto GetRDNAttributeValueError;
        assert(lRemainExtra >= 0);
    }

    if (lRemainExtra >= 0)
        *pcbStructInfo = *pcbStructInfo - (DWORD) lRemainExtra;
    else {
        *pcbStructInfo = *pcbStructInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    *pcbStructInfo = 0;
    goto CommonReturn;
TRACE_ERROR(GetRDNAttributeValueError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Encode X509 certificate extensions (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ExtensionsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_EXTENSIONS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    Extensions Asn1Ext;

    if (!Asn1X509SetExtensions(pInfo->cExtension, pInfo->rgExtension, &Asn1Ext))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        Extensions_PDU,
        &Asn1Ext,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeExtensions(&Asn1Ext);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode X509 certificate extensions (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ExtensionsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    Extensions *pAsn1Ext = (Extensions *) pvAsn1Info;
    PCERT_EXTENSIONS pInfo = (PCERT_EXTENSIONS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_EXTENSIONS);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_EXTENSIONS);

    Asn1X509GetExtensions(pAsn1Ext, dwFlags,
        &pInfo->cExtension, &pInfo->rgExtension, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

#define T61_ASN_TAG             0x14

BOOL WINAPI Asn1X509ExtensionsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{

    if (0 < cbEncoded && T61_ASN_TAG == *pbEncoded) {
        // Entrust wraps X509 Extensions within a T61 string
        DWORD cbContent;
        const BYTE *pbContent;

        // Skip past the outer T61 tag and length octets
        if (0 < Asn1UtilExtractContent(
                pbEncoded,
                cbEncoded,
                &cbContent,
                &pbContent
                )) {
            cbEncoded = cbContent;
            pbEncoded = pbContent;
        }
    }

    return Asn1InfoDecodeAndAllocEx(
        Extensions_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509ExtensionsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Public Key Info Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509PublicKeyInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_PUBLIC_KEY_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    SubjectPublicKeyInfo PublicKey;

    if (!Asn1X509SetPublicKeyInfo(pInfo, &PublicKey))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        SubjectPublicKeyInfo_PDU,
        &PublicKey,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}


//+-------------------------------------------------------------------------
//  Public Key Info Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509PublicKeyInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    SubjectPublicKeyInfo *pPublicKey = (SubjectPublicKeyInfo *) pvAsn1Info;
    PCERT_PUBLIC_KEY_INFO pInfo = (PCERT_PUBLIC_KEY_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_PUBLIC_KEY_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_PUBLIC_KEY_INFO);

    Asn1X509GetPublicKeyInfo(pPublicKey, dwFlags,
        pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509PublicKeyInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        SubjectPublicKeyInfo_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509PublicKeyInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


#ifndef RSA1
#define RSA1 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'1'<<24))
#endif

//+-------------------------------------------------------------------------
//  RSA Public Key Structure Encode (ASN1 X509)
//
//  Converts from the CAPI public key representation to a PKCS #1 RSAPublicKey
//
//  BYTE reversal::
//   - this only needs to be done for little endian processors
//--------------------------------------------------------------------------
BOOL WINAPI Asn1RSAPublicKeyStrucEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PUBLICKEYSTRUC *pPubKeyStruc,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    BYTE *pbKeyBlob;
    RSAPUBKEY *pRsaPubKey;
    const BYTE *pbModulus;
    DWORD cbModulus;
    BYTE *pbAllocModulus = NULL;
    RSAPublicKey Asn1PubKey;

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - RSAPUBKEY
    //  - rgbModulus[]
    pbKeyBlob = (BYTE *) pPubKeyStruc;
    pRsaPubKey = (RSAPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    pbModulus = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY);
    cbModulus = pRsaPubKey->bitlen / 8;

    assert(cbModulus > 0);
    assert(pPubKeyStruc->bType == PUBLICKEYBLOB);
    assert(pPubKeyStruc->bVersion == CUR_BLOB_VERSION);
    assert(pPubKeyStruc->aiKeyAlg == CALG_RSA_SIGN ||
           pPubKeyStruc->aiKeyAlg == CALG_RSA_KEYX);
    assert(pRsaPubKey->magic == RSA1);
    assert(pRsaPubKey->bitlen % 8 == 0);

    if (pPubKeyStruc->bType != PUBLICKEYBLOB)
        goto InvalidArg;

    // PKCS #1 ASN.1 encode
    //
    // ASN1 isn't reversing HUGE_INTEGERs. Also, after doing the
    // reversal insert a leading 0 byte to force it to always be treated
    // as an unsigned integer
    if (NULL == (pbAllocModulus = (BYTE *) PkiNonzeroAlloc(cbModulus + 1)))
        goto ErrorReturn;
    *pbAllocModulus = 0;
    memcpy(pbAllocModulus + 1, pbModulus, cbModulus);
    PkiAsn1ReverseBytes(pbAllocModulus + 1, cbModulus);
    pbModulus = pbAllocModulus;
    cbModulus++;

    Asn1PubKey.publicExponent = pRsaPubKey->pubexp;
    Asn1PubKey.modulus.length = cbModulus;
    Asn1PubKey.modulus.value = (BYTE *) pbModulus;

    fResult = Asn1InfoEncodeEx(
        RSAPublicKey_PDU,
        &Asn1PubKey,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

InvalidArg:
    SetLastError((DWORD) E_INVALIDARG);
ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pbAllocModulus)
        PkiFree(pbAllocModulus);
    return fResult;
}


//+-------------------------------------------------------------------------
//  RSA Public Key Structure Decode (ASN1 X509)
//
//  Converts from a PKCS #1 RSAPublicKey to a CAPI public key representation
//
//  BYTE reversal::
//   - this only needs to be done for little endian processors
//--------------------------------------------------------------------------
BOOL WINAPI Asn1RSAPublicKeyStrucDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    RSAPublicKey *pAsn1PubKey = (RSAPublicKey *) pvAsn1Info;
    PUBLICKEYSTRUC *pPubKeyStruc = (PUBLICKEYSTRUC *) pvStructInfo;
    BYTE *pbAsn1Modulus;
    DWORD cbModulus;

    // Now convert the ASN1 RSA public key into CAPI's representation which
    // consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - RSAPUBKEY
    //  - rgbModulus[]
    cbModulus = pAsn1PubKey->modulus.length;
    pbAsn1Modulus = pAsn1PubKey->modulus.value;
    // Strip off a leading 0 byte. Its there in the decoded ASN
    // integer for an unsigned integer with the leading bit set.
    if (cbModulus > 1 && *pbAsn1Modulus == 0) {
        pbAsn1Modulus++;
        cbModulus--;
    }
    *plRemainExtra -= sizeof(PUBLICKEYSTRUC) + sizeof(RSAPUBKEY) + cbModulus;
    if (0 <= *plRemainExtra) {
        BYTE *pbKeyBlob = (BYTE *) pPubKeyStruc;
        RSAPUBKEY *pRsaPubKey =
            (RSAPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
        BYTE *pbModulus = pbKeyBlob + sizeof(PUBLICKEYSTRUC) +
            sizeof(RSAPUBKEY);

        pPubKeyStruc->bType = PUBLICKEYBLOB;
        pPubKeyStruc->bVersion = CUR_BLOB_VERSION;
        pPubKeyStruc->reserved = 0;
        // Note: KEYX can also be used for doing a signature
        pPubKeyStruc->aiKeyAlg = CALG_RSA_KEYX;
        pRsaPubKey->magic = RSA1;
        pRsaPubKey->bitlen = cbModulus * 8;
        pRsaPubKey->pubexp = pAsn1PubKey->publicExponent;
        if (cbModulus > 0) {
            memcpy(pbModulus, pbAsn1Modulus, cbModulus);
            // ASN1 isn't reversing HUGEINTEGERs
            PkiAsn1ReverseBytes(pbModulus, cbModulus);
        }
    }
    return TRUE;
}

BOOL WINAPI Asn1RSAPublicKeyStrucDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        RSAPublicKey_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1RSAPublicKeyStrucDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Authority Key Id Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityKeyIdEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_KEY_ID_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;

    AuthorityKeyId Asn1AuthorityKeyId;
    memset(&Asn1AuthorityKeyId, 0, sizeof(Asn1AuthorityKeyId));

    if (pInfo->KeyId.cbData) {
        Asn1X509SetOctetString(&pInfo->KeyId,
#ifdef OSS_CRYPT_ASN1
            &Asn1AuthorityKeyId.AuthorityKeyId_keyIdentifier);
#else
            &Asn1AuthorityKeyId.keyIdentifier);
#endif  // OSS_CRYPT_ASN1
        Asn1AuthorityKeyId.bit_mask |= AuthorityKeyId_keyIdentifier_present;
    }
    if (pInfo->CertIssuer.cbData) {
        Asn1X509SetAny(&pInfo->CertIssuer, &Asn1AuthorityKeyId.certIssuer);
        Asn1AuthorityKeyId.bit_mask |= certIssuer_present;
    }
    if (pInfo->CertSerialNumber.cbData) {
        if (!Asn1X509SetHugeInteger(&pInfo->CertSerialNumber,
                &Asn1AuthorityKeyId.certSerialNumber))
            goto ErrorReturn;
        Asn1AuthorityKeyId.bit_mask |= certSerialNumber_present;
    }

    fResult = Asn1InfoEncodeEx(
        AuthorityKeyId_PDU,
        &Asn1AuthorityKeyId,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeHugeInteger(&Asn1AuthorityKeyId.certSerialNumber);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Authority Key Id Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityKeyIdDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    AuthorityKeyId *pAuthorityKeyId = (AuthorityKeyId *) pvAsn1Info;
    PCERT_AUTHORITY_KEY_ID_INFO pInfo =
        (PCERT_AUTHORITY_KEY_ID_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_AUTHORITY_KEY_ID_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_AUTHORITY_KEY_ID_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_AUTHORITY_KEY_ID_INFO);
    }

    if (pAuthorityKeyId->bit_mask & AuthorityKeyId_keyIdentifier_present)
#ifdef OSS_CRYPT_ASN1
        Asn1X509GetOctetString(&pAuthorityKeyId->AuthorityKeyId_keyIdentifier,
#else
        Asn1X509GetOctetString(&pAuthorityKeyId->keyIdentifier,
#endif  // OSS_CRYPT_ASN1
            dwFlags, &pInfo->KeyId, &pbExtra, &lRemainExtra);
    if (pAuthorityKeyId->bit_mask & certIssuer_present)
        Asn1X509GetAny(&pAuthorityKeyId->certIssuer, dwFlags,
            &pInfo->CertIssuer, &pbExtra, &lRemainExtra);
    if (pAuthorityKeyId->bit_mask & certSerialNumber_present)
        Asn1X509GetHugeInteger(&pAuthorityKeyId->certSerialNumber, dwFlags,
            &pInfo->CertSerialNumber, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509AuthorityKeyIdDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        AuthorityKeyId_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509AuthorityKeyIdDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Authority Key Id2 Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityKeyId2EncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_KEY_ID2_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD dwErrLocation;

    AuthorityKeyId2 Asn1AuthorityKeyId2;
    memset(&Asn1AuthorityKeyId2, 0, sizeof(Asn1AuthorityKeyId2));

    if (pInfo->KeyId.cbData) {
        Asn1X509SetOctetString(&pInfo->KeyId,
#ifdef OSS_CRYPT_ASN1
            &Asn1AuthorityKeyId2.AuthorityKeyId2_keyIdentifier);
#else
            &Asn1AuthorityKeyId2.keyIdentifier);
#endif  // OSS_CRYPT_ASN1
        Asn1AuthorityKeyId2.bit_mask |= AuthorityKeyId2_keyIdentifier_present;
    }
    if (pInfo->AuthorityCertIssuer.cAltEntry) {
        if (!Asn1X509SetAltNames(&pInfo->AuthorityCertIssuer,
                &Asn1AuthorityKeyId2.authorityCertIssuer, 0, &dwErrLocation)) {
            *pcbEncoded = dwErrLocation;
            goto AltNamesError;
        }
        Asn1AuthorityKeyId2.bit_mask |= authorityCertIssuer_present;
    }
    if (pInfo->AuthorityCertSerialNumber.cbData) {
        if (!Asn1X509SetHugeInteger(&pInfo->AuthorityCertSerialNumber,
                &Asn1AuthorityKeyId2.authorityCertSerialNumber))
            goto ErrorReturn;
        Asn1AuthorityKeyId2.bit_mask |= authorityCertSerialNumber_present;
    }

    fResult = Asn1InfoEncodeEx(
        AuthorityKeyId2_PDU,
        &Asn1AuthorityKeyId2,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
AltNamesError:
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeAltNames(&Asn1AuthorityKeyId2.authorityCertIssuer);
    Asn1X509FreeHugeInteger(&Asn1AuthorityKeyId2.authorityCertSerialNumber);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Authority Key Id2 Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityKeyId2DecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    AuthorityKeyId2 *pAuthorityKeyId2 = (AuthorityKeyId2 *) pvAsn1Info;
    PCERT_AUTHORITY_KEY_ID2_INFO pInfo =
        (PCERT_AUTHORITY_KEY_ID2_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_AUTHORITY_KEY_ID2_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_AUTHORITY_KEY_ID2_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_AUTHORITY_KEY_ID2_INFO);
    }

    if (pAuthorityKeyId2->bit_mask & AuthorityKeyId2_keyIdentifier_present)
#ifdef OSS_CRYPT_ASN1
        Asn1X509GetOctetString(&pAuthorityKeyId2->AuthorityKeyId2_keyIdentifier,
#else
        Asn1X509GetOctetString(&pAuthorityKeyId2->keyIdentifier,
#endif  // OSS_CRYPT_ASN1
            dwFlags, &pInfo->KeyId, &pbExtra, &lRemainExtra);
    if (pAuthorityKeyId2->bit_mask & authorityCertIssuer_present) {
        if (!Asn1X509GetAltNames(&pAuthorityKeyId2->authorityCertIssuer, dwFlags,
                &pInfo->AuthorityCertIssuer, &pbExtra, &lRemainExtra))
            goto ErrorReturn;
    }
    if (pAuthorityKeyId2->bit_mask & authorityCertSerialNumber_present)
        Asn1X509GetHugeInteger(&pAuthorityKeyId2->authorityCertSerialNumber, dwFlags,
            &pInfo->AuthorityCertSerialNumber, &pbExtra, &lRemainExtra);

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL WINAPI Asn1X509AuthorityKeyId2DecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        AuthorityKeyId2_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509AuthorityKeyId2DecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Key Attributes Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509KeyAttributesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEY_ATTRIBUTES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    KeyAttributes Asn1KeyAttributes;
    memset(&Asn1KeyAttributes, 0, sizeof(Asn1KeyAttributes));

    if (pInfo->KeyId.cbData) {
        Asn1X509SetOctetString(&pInfo->KeyId,
#ifdef OSS_CRYPT_ASN1
            &Asn1KeyAttributes.KeyAttributes_keyIdentifier);
#else
            &Asn1KeyAttributes.keyIdentifier);
#endif  // OSS_CRYPT_ASN1
        Asn1KeyAttributes.bit_mask |= KeyAttributes_keyIdentifier_present;
    }
    if (pInfo->IntendedKeyUsage.cbData) {
        Asn1X509SetBitWithoutTrailingZeroes(&pInfo->IntendedKeyUsage,
            &Asn1KeyAttributes.intendedKeyUsage);
        Asn1KeyAttributes.bit_mask |= intendedKeyUsage_present;
    }
    if (pInfo->pPrivateKeyUsagePeriod) {
        if (!PkiAsn1ToGeneralizedTime(
                &pInfo->pPrivateKeyUsagePeriod->NotBefore,
                &Asn1KeyAttributes.privateKeyUsagePeriod.notBefore))
            goto EncodeError;
        if (!PkiAsn1ToGeneralizedTime(
                &pInfo->pPrivateKeyUsagePeriod->NotAfter,
                &Asn1KeyAttributes.privateKeyUsagePeriod.notAfter))
            goto EncodeError;
        Asn1KeyAttributes.privateKeyUsagePeriod.bit_mask |=
            notBefore_present | notAfter_present;
        Asn1KeyAttributes.bit_mask |= privateKeyUsagePeriod_present;
    }

    fResult = Asn1InfoEncodeEx(
        KeyAttributes_PDU,
        &Asn1KeyAttributes,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

EncodeError:
    SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

//+-------------------------------------------------------------------------
//  Key Attributes Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509KeyAttributesDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    KeyAttributes *pKeyAttributes = (KeyAttributes *) pvAsn1Info;
    PCERT_KEY_ATTRIBUTES_INFO pInfo = (PCERT_KEY_ATTRIBUTES_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_KEY_ATTRIBUTES_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_KEY_ATTRIBUTES_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_KEY_ATTRIBUTES_INFO);
    }

    if (pKeyAttributes->bit_mask & KeyAttributes_keyIdentifier_present)
#ifdef OSS_CRYPT_ASN1
        Asn1X509GetOctetString(&pKeyAttributes->KeyAttributes_keyIdentifier,
#else
        Asn1X509GetOctetString(&pKeyAttributes->keyIdentifier,
#endif  // OSS_CRYPT_ASN1
            dwFlags, &pInfo->KeyId, &pbExtra, &lRemainExtra);
    if (pKeyAttributes->bit_mask & intendedKeyUsage_present)
        Asn1X509GetBit(&pKeyAttributes->intendedKeyUsage, dwFlags,
            &pInfo->IntendedKeyUsage, &pbExtra, &lRemainExtra);

    if (pKeyAttributes->bit_mask & privateKeyUsagePeriod_present) {
        LONG lAlignExtra;
        PrivateKeyValidity *pAsn1KeyUsage =
            &pKeyAttributes->privateKeyUsagePeriod;

        lAlignExtra = INFO_LEN_ALIGN(sizeof(CERT_PRIVATE_KEY_VALIDITY));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            PCERT_PRIVATE_KEY_VALIDITY pKeyUsage =
                (PCERT_PRIVATE_KEY_VALIDITY) pbExtra;

            // Default all optional fields to zero
            memset(pKeyUsage, 0, sizeof(CERT_PRIVATE_KEY_VALIDITY));
            if (pAsn1KeyUsage->bit_mask & notBefore_present) {
                if (!PkiAsn1FromGeneralizedTime(&pAsn1KeyUsage->notBefore,
                        &pKeyUsage->NotBefore))
                    goto DecodeError;
            }
            if (pAsn1KeyUsage->bit_mask & notAfter_present) {
                if (!PkiAsn1FromGeneralizedTime(&pAsn1KeyUsage->notAfter,
                        &pKeyUsage->NotAfter))
                    goto DecodeError;
            }
            pInfo->pPrivateKeyUsagePeriod = pKeyUsage;
            pbExtra += lAlignExtra;
        }
    }

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1X509KeyAttributesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        KeyAttributes_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509KeyAttributesDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  AltName Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AltNameEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_ALT_NAME_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    AltNames AltNames;
    DWORD dwErrLocation;

    if (!Asn1X509SetAltNames(pInfo, &AltNames, 0, &dwErrLocation)) {
        *pcbEncoded = dwErrLocation;
        fResult = FALSE;
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        goto CommonReturn;
    }

    fResult = Asn1InfoEncodeEx(
        AltNames_PDU,
        &AltNames,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    Asn1X509FreeAltNames(&AltNames);
    return fResult;
}


//+-------------------------------------------------------------------------
//  AltName Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AltNameDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    AltNames *pAltNames = (AltNames *) pvAsn1Info;
    PCERT_ALT_NAME_INFO pInfo = (PCERT_ALT_NAME_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_ALT_NAME_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_ALT_NAME_INFO);

    if (!Asn1X509GetAltNames(pAltNames, dwFlags,
            pInfo, &pbExtra, &lRemainExtra))
        goto ErrorReturn;

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL WINAPI Asn1X509AltNameDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        AltNames_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509AltNameDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}



//+-------------------------------------------------------------------------
//  Key Usage Restriction Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509KeyUsageRestrictionEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_KEY_USAGE_RESTRICTION_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD cPolicyId;

    KeyUsageRestriction Asn1KeyUsageRestriction;
    memset(&Asn1KeyUsageRestriction, 0, sizeof(Asn1KeyUsageRestriction));

    cPolicyId = pInfo->cCertPolicyId;
    if (cPolicyId) {
        PCERT_POLICY_ID pPolicyId = pInfo->rgCertPolicyId;
        CertPolicyId *pAsn1PolicyId =
            (CertPolicyId *) PkiZeroAlloc(cPolicyId * sizeof(CertPolicyId));
        if (pAsn1PolicyId == NULL) goto ErrorReturn;
        Asn1KeyUsageRestriction.certPolicySet.count = cPolicyId;
        Asn1KeyUsageRestriction.certPolicySet.value = pAsn1PolicyId;

        for ( ; cPolicyId > 0; cPolicyId--, pPolicyId++, pAsn1PolicyId++) {
            DWORD cElement = pPolicyId->cCertPolicyElementId;
            if (cElement > 0) {
                LPSTR *ppszElement = pPolicyId->rgpszCertPolicyElementId;
                EncodedObjectID *pAsn1Element =
                    (EncodedObjectID *) PkiZeroAlloc(cElement * sizeof(EncodedObjectID));
                if (pAsn1Element == NULL) goto ErrorReturn;
                pAsn1PolicyId->count = cElement;
                pAsn1PolicyId->value = pAsn1Element;
                for ( ; cElement > 0; cElement--, ppszElement++, pAsn1Element++)
                    if (!Asn1X509SetEncodedObjId(*ppszElement, pAsn1Element))
                        goto ErrorReturn;
            }
        }
        Asn1KeyUsageRestriction.bit_mask |= certPolicySet_present;
    }

    if (pInfo->RestrictedKeyUsage.cbData) {
        Asn1X509SetBitWithoutTrailingZeroes(&pInfo->RestrictedKeyUsage,
            &Asn1KeyUsageRestriction.restrictedKeyUsage);
        Asn1KeyUsageRestriction.bit_mask |= restrictedKeyUsage_present;
    }

    fResult = Asn1InfoEncodeEx(
        KeyUsageRestriction_PDU,
        &Asn1KeyUsageRestriction,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (Asn1KeyUsageRestriction.certPolicySet.value) {
        cPolicyId = Asn1KeyUsageRestriction.certPolicySet.count;
        CertPolicyId *pAsn1PolicyId = Asn1KeyUsageRestriction.certPolicySet.value;
        for ( ; cPolicyId > 0; cPolicyId--, pAsn1PolicyId++)
            if (pAsn1PolicyId->value)
                PkiFree(pAsn1PolicyId->value);
        PkiFree(Asn1KeyUsageRestriction.certPolicySet.value);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Key Usage Restriction Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509KeyUsageRestrictionDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    KeyUsageRestriction *pKeyUsageRestriction =
        (KeyUsageRestriction *) pvAsn1Info;
    PCERT_KEY_USAGE_RESTRICTION_INFO pInfo =
        (PCERT_KEY_USAGE_RESTRICTION_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_KEY_USAGE_RESTRICTION_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_KEY_USAGE_RESTRICTION_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_KEY_USAGE_RESTRICTION_INFO);
    }

    if (pKeyUsageRestriction->bit_mask & certPolicySet_present) {
        LONG lAlignExtra;
        DWORD cPolicyId;
        PCERT_POLICY_ID pPolicyId;
        CertPolicyId *pAsn1PolicyId;

        cPolicyId = pKeyUsageRestriction->certPolicySet.count;
        lAlignExtra = INFO_LEN_ALIGN(cPolicyId * sizeof(CERT_POLICY_ID));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pInfo->cCertPolicyId = cPolicyId;
            pPolicyId = (PCERT_POLICY_ID) pbExtra;
            pInfo->rgCertPolicyId = pPolicyId;
            pbExtra += lAlignExtra;
        } else
            pPolicyId = NULL;

        pAsn1PolicyId = pKeyUsageRestriction->certPolicySet.value;
        for ( ; cPolicyId > 0; cPolicyId--, pPolicyId++, pAsn1PolicyId++) {
            DWORD cElement;
            LPSTR *ppszElement;
            EncodedObjectID *pAsn1Element;

            cElement = pAsn1PolicyId->count;
            lAlignExtra = INFO_LEN_ALIGN(cElement * sizeof(LPSTR *));
            lRemainExtra -= lAlignExtra;
            if (lRemainExtra >= 0) {
                pPolicyId->cCertPolicyElementId = cElement;
                ppszElement = (LPSTR *) pbExtra;
                pPolicyId->rgpszCertPolicyElementId = ppszElement;
                pbExtra += lAlignExtra;
            } else
                ppszElement = NULL;

            pAsn1Element = pAsn1PolicyId->value;
            for ( ; cElement > 0; cElement--, ppszElement++, pAsn1Element++)
                Asn1X509GetEncodedObjId(pAsn1Element, dwFlags,
                    ppszElement, &pbExtra, &lRemainExtra);
        }
    }

    if (pKeyUsageRestriction->bit_mask & restrictedKeyUsage_present)
        Asn1X509GetBit(&pKeyUsageRestriction->restrictedKeyUsage, dwFlags,
            &pInfo->RestrictedKeyUsage, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509KeyUsageRestrictionDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        KeyUsageRestriction_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509KeyUsageRestrictionDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Basic Constraints Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BasicConstraintsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_BASIC_CONSTRAINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD cSubtrees;

    BasicConstraints Asn1BasicConstraints;
    memset(&Asn1BasicConstraints, 0, sizeof(Asn1BasicConstraints));

    Asn1X509SetBitWithoutTrailingZeroes(&pInfo->SubjectType,
        &Asn1BasicConstraints.subjectType);
    if (pInfo->fPathLenConstraint) {
#ifdef OSS_CRYPT_ASN1
        Asn1BasicConstraints.BasicConstraints_pathLenConstraint =
#else
        Asn1BasicConstraints.pathLenConstraint =
#endif  // OSS_CRYPT_ASN1
            pInfo->dwPathLenConstraint;
        Asn1BasicConstraints.bit_mask |=
            BasicConstraints_pathLenConstraint_present;
    }
    cSubtrees = pInfo->cSubtreesConstraint;
    if (cSubtrees) {
        PCERT_NAME_BLOB pSubtrees = pInfo->rgSubtreesConstraint;
        NOCOPYANY *pAsn1Subtrees =
            (NOCOPYANY *) PkiZeroAlloc(
                cSubtrees * sizeof(NOCOPYANY));
        if (pAsn1Subtrees == NULL) goto ErrorReturn;
        Asn1BasicConstraints.subtreesConstraint.count = cSubtrees;
        Asn1BasicConstraints.subtreesConstraint.value = pAsn1Subtrees;

        for ( ; cSubtrees > 0; cSubtrees--, pSubtrees++, pAsn1Subtrees++)
            Asn1X509SetAny(pSubtrees, pAsn1Subtrees);
        Asn1BasicConstraints.bit_mask |= subtreesConstraint_present;
    }

    fResult = Asn1InfoEncodeEx(
        BasicConstraints_PDU,
        &Asn1BasicConstraints,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (Asn1BasicConstraints.subtreesConstraint.value)
        PkiFree(Asn1BasicConstraints.subtreesConstraint.value);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Basic Constraints Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BasicConstraintsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BasicConstraints *pBasicConstraints = (BasicConstraints *) pvAsn1Info;
    PCERT_BASIC_CONSTRAINTS_INFO pInfo =
        (PCERT_BASIC_CONSTRAINTS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_BASIC_CONSTRAINTS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_BASIC_CONSTRAINTS_INFO));

        // Update fields not needing extra memory after the
        // CERT_BASIC_CONSTRAINTS_INFO
        if (pBasicConstraints->bit_mask &
                BasicConstraints_pathLenConstraint_present) {
            pInfo->fPathLenConstraint = TRUE;
            pInfo->dwPathLenConstraint =
#ifdef OSS_CRYPT_ASN1
                pBasicConstraints->BasicConstraints_pathLenConstraint;
#else
                pBasicConstraints->pathLenConstraint;
#endif  // OSS_CRYPT_ASN1
        }

        pbExtra = (BYTE *) pInfo + sizeof(CERT_BASIC_CONSTRAINTS_INFO);
    }

    Asn1X509GetBit(&pBasicConstraints->subjectType, dwFlags,
        &pInfo->SubjectType, &pbExtra, &lRemainExtra);

    if (pBasicConstraints->bit_mask & subtreesConstraint_present) {
        LONG lAlignExtra;
        DWORD cSubtrees;
        PCERT_NAME_BLOB pSubtrees;
        NOCOPYANY *pAsn1Subtrees;

        cSubtrees = pBasicConstraints->subtreesConstraint.count;
        lAlignExtra = INFO_LEN_ALIGN(cSubtrees * sizeof(CERT_NAME_BLOB));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pInfo->cSubtreesConstraint = cSubtrees;
            pSubtrees = (PCERT_NAME_BLOB) pbExtra;
            pInfo->rgSubtreesConstraint = pSubtrees;
            pbExtra += lAlignExtra;
        } else
            pSubtrees = NULL;

        pAsn1Subtrees = pBasicConstraints->subtreesConstraint.value;
        for ( ; cSubtrees > 0; cSubtrees--, pSubtrees++, pAsn1Subtrees++)
            Asn1X509GetAny(pAsn1Subtrees, dwFlags,
                pSubtrees, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509BasicConstraintsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        BasicConstraints_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509BasicConstraintsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Basic Constraints #2 Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BasicConstraints2EncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_BASIC_CONSTRAINTS2_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BasicConstraints2 Asn1Info;
    memset(&Asn1Info, 0, sizeof(Asn1Info));

    if (pInfo->fCA) {
        Asn1Info.cA = TRUE;
        Asn1Info.bit_mask |= cA_present;
    }
    if (pInfo->fPathLenConstraint) {
#ifdef OSS_CRYPT_ASN1
        Asn1Info.BasicConstraints2_pathLenConstraint =
#else
        Asn1Info.pathLenConstraint =
#endif  // OSS_CRYPT_ASN1
            pInfo->dwPathLenConstraint;
        Asn1Info.bit_mask |= BasicConstraints2_pathLenConstraint_present;
    }

    return Asn1InfoEncodeEx(
        BasicConstraints2_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Basic Constraints #2 Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BasicConstraints2DecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BasicConstraints2 *pAsn1Info = (BasicConstraints2 *) pvAsn1Info;
    PCERT_BASIC_CONSTRAINTS2_INFO pInfo =
        (PCERT_BASIC_CONSTRAINTS2_INFO) pvStructInfo;

    *plRemainExtra -= sizeof(CERT_BASIC_CONSTRAINTS2_INFO);
    if (*plRemainExtra >= 0) {
        memset(pInfo, 0, sizeof(CERT_BASIC_CONSTRAINTS2_INFO));

        if (pAsn1Info->bit_mask & cA_present)
            pInfo->fCA = (BOOLEAN) pAsn1Info->cA;

        if (pAsn1Info->bit_mask &
                BasicConstraints2_pathLenConstraint_present) {
            pInfo->fPathLenConstraint = TRUE;
            pInfo->dwPathLenConstraint =
#ifdef OSS_CRYPT_ASN1
                pAsn1Info->BasicConstraints2_pathLenConstraint;
#else
                pAsn1Info->pathLenConstraint;
#endif  // OSS_CRYPT_ASN1
        }
    }
    return TRUE;
}

BOOL WINAPI Asn1X509BasicConstraints2DecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        BasicConstraints2_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509BasicConstraints2DecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Bits Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BitsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BITSTRING Asn1Info;

    Asn1X509SetBit(pInfo, &Asn1Info);
    return Asn1InfoEncodeEx(
        Bits_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Bits Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BitsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BITSTRING *pAsn1Info = (BITSTRING *) pvAsn1Info;
    PCRYPT_BIT_BLOB pInfo = (PCRYPT_BIT_BLOB) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_BIT_BLOB);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_BIT_BLOB);

    Asn1X509GetBit(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509BitsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        Bits_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509BitsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Bits Without Trailing Zeroes Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509BitsWithoutTrailingZeroesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BITSTRING Asn1Info;

    Asn1X509SetBitWithoutTrailingZeroes(pInfo, &Asn1Info);
    return Asn1InfoEncodeEx(
        Bits_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}


//+-------------------------------------------------------------------------
//  Certificate Policies Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertPoliciesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICIES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD cPolicyInfo;

    CertificatePolicies Asn1Info;
    memset(&Asn1Info, 0, sizeof(Asn1Info));

    cPolicyInfo = pInfo->cPolicyInfo;
    if (cPolicyInfo) {
        PCERT_POLICY_INFO pPolicyInfo = pInfo->rgPolicyInfo;
        PolicyInformation *pAsn1PolicyInfo =
            (PolicyInformation *) PkiZeroAlloc(
                cPolicyInfo * sizeof(PolicyInformation));
        if (pAsn1PolicyInfo == NULL) goto ErrorReturn;
        Asn1Info.count = cPolicyInfo;
        Asn1Info.value = pAsn1PolicyInfo;

        for ( ; cPolicyInfo > 0;
                            cPolicyInfo--, pPolicyInfo++, pAsn1PolicyInfo++) {
            DWORD cQualifier = pPolicyInfo->cPolicyQualifier;
            if (!Asn1X509SetEncodedObjId(pPolicyInfo->pszPolicyIdentifier,
                    &pAsn1PolicyInfo->policyIdentifier))
                    goto ErrorReturn;
            if (cQualifier > 0) {
                PCERT_POLICY_QUALIFIER_INFO pQualifier =
                    pPolicyInfo->rgPolicyQualifier;
                PolicyQualifierInfo *pAsn1Qualifier =
                    (PolicyQualifierInfo *) PkiZeroAlloc(
                        cQualifier * sizeof(PolicyQualifierInfo));
                if (pAsn1Qualifier == NULL) goto ErrorReturn;
                pAsn1PolicyInfo->policyQualifiers.count = cQualifier;
                pAsn1PolicyInfo->policyQualifiers.value = pAsn1Qualifier;
                pAsn1PolicyInfo->bit_mask |= policyQualifiers_present;

                for ( ; cQualifier > 0;
                            cQualifier--, pQualifier++, pAsn1Qualifier++) {
                    if (!Asn1X509SetEncodedObjId(pQualifier->pszPolicyQualifierId,
                            &pAsn1Qualifier->policyQualifierId))
                        goto ErrorReturn;

                    if (pQualifier->Qualifier.cbData) {
                        Asn1X509SetAny(&pQualifier->Qualifier,
                            &pAsn1Qualifier->qualifier);
                        pAsn1Qualifier->bit_mask |= qualifier_present;
                    }
                }
            }
        }
    }

    fResult = Asn1InfoEncodeEx(
        CertificatePolicies_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (Asn1Info.value) {
        cPolicyInfo = Asn1Info.count;
        PolicyInformation *pAsn1PolicyInfo = Asn1Info.value;
        for ( ; cPolicyInfo > 0; cPolicyInfo--, pAsn1PolicyInfo++)
            if (pAsn1PolicyInfo->policyQualifiers.value)
                PkiFree(pAsn1PolicyInfo->policyQualifiers.value);
        PkiFree(Asn1Info.value);
    }
    return fResult;
}


//+-------------------------------------------------------------------------
//  Certificate Policies Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertPoliciesDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    CertificatePolicies *pAsn1Info = (CertificatePolicies *) pvAsn1Info;
    PCERT_POLICIES_INFO pInfo = (PCERT_POLICIES_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    DWORD cPolicyInfo;

    lRemainExtra -= sizeof(CERT_POLICIES_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CERT_POLICIES_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_POLICIES_INFO);
    }

    cPolicyInfo = pAsn1Info->count;
    if (cPolicyInfo) {
        LONG lAlignExtra;
        PCERT_POLICY_INFO pPolicyInfo;
        PolicyInformation *pAsn1PolicyInfo;

        lAlignExtra = INFO_LEN_ALIGN(cPolicyInfo * sizeof(CERT_POLICY_INFO));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pInfo->cPolicyInfo = cPolicyInfo;
            pPolicyInfo = (PCERT_POLICY_INFO) pbExtra;
            pInfo->rgPolicyInfo = pPolicyInfo;
            memset(pPolicyInfo, 0, cPolicyInfo * sizeof(CERT_POLICY_INFO));
            pbExtra += lAlignExtra;
        } else
            pPolicyInfo = NULL;

        pAsn1PolicyInfo = pAsn1Info->value;
        for ( ; cPolicyInfo > 0;
                            cPolicyInfo--, pPolicyInfo++, pAsn1PolicyInfo++) {
            DWORD cQualifier;

            // check to see if there is a policy identifier
            if (pAsn1PolicyInfo->policyIdentifier.length != 0) {
                Asn1X509GetEncodedObjId(&pAsn1PolicyInfo->policyIdentifier, dwFlags,
                &pPolicyInfo->pszPolicyIdentifier, &pbExtra, &lRemainExtra);
            }
            else {
                lAlignExtra = INFO_LEN_ALIGN(strlen("")+1);
                lRemainExtra -= lAlignExtra;
                if (lRemainExtra >= 0) {
                    pPolicyInfo->pszPolicyIdentifier = (LPSTR) pbExtra;
                    strcpy(pPolicyInfo->pszPolicyIdentifier, "");
                    pbExtra += lAlignExtra;
                }
            }
            
            cQualifier = pAsn1PolicyInfo->bit_mask & policyQualifiers_present ?
                pAsn1PolicyInfo->policyQualifiers.count : 0;
            if (cQualifier > 0) {
                PCERT_POLICY_QUALIFIER_INFO pQualifier;
                PolicyQualifierInfo *pAsn1Qualifier;

                lAlignExtra = INFO_LEN_ALIGN(cQualifier *
                    sizeof(CERT_POLICY_QUALIFIER_INFO));
                lRemainExtra -= lAlignExtra;
                if (lRemainExtra >= 0) {
                    pPolicyInfo->cPolicyQualifier = cQualifier;
                    pQualifier = (PCERT_POLICY_QUALIFIER_INFO) pbExtra;
                    pPolicyInfo->rgPolicyQualifier = pQualifier;
                    memset(pQualifier, 0,
                        cQualifier * sizeof(CERT_POLICY_QUALIFIER_INFO));
                    pbExtra += lAlignExtra;
                } else
                    pQualifier = NULL;

                pAsn1Qualifier = pAsn1PolicyInfo->policyQualifiers.value;
                for ( ; cQualifier > 0;
                            cQualifier--, pQualifier++, pAsn1Qualifier++) {
                    Asn1X509GetEncodedObjId(&pAsn1Qualifier->policyQualifierId, dwFlags,
                        &pQualifier->pszPolicyQualifierId,
                        &pbExtra, &lRemainExtra);
                    if (pAsn1Qualifier->bit_mask & qualifier_present)
                        Asn1X509GetAny(&pAsn1Qualifier->qualifier, dwFlags,
                            &pQualifier->Qualifier, &pbExtra, &lRemainExtra);
                }
            }
        }
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509CertPoliciesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    CertificatePolicies *pAsn1Info = NULL;
    CertificatePolicies95 *pAsn1Info95 = NULL;
    PolicyInformation *pPolicyInformation = NULL;
    CertificatePolicies certificatePolicies;
    DWORD i;

    if (!Asn1InfoDecodeAndAlloc(
            CertificatePolicies_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pAsn1Info))
    {
        // try to decode it as the old style
        if (!Asn1InfoDecodeAndAlloc(
                CertificatePolicies95_PDU,
                pbEncoded,
                cbEncoded,
                (void **) &pAsn1Info95))
             goto ErrorReturn;

        // that decode worked, so alloc some memory, fix up some pointers
        // and role through the rest of the routine per usual
        certificatePolicies.count = pAsn1Info95->count;
        if (NULL == (pPolicyInformation = 
                    (PolicyInformation *) PkiNonzeroAlloc(pAsn1Info95->count * sizeof(PolicyInformation))))
            goto ErrorReturn;

        certificatePolicies.value = pPolicyInformation;
        
        for (i=0; i<pAsn1Info95->count; i++)
        {
            pPolicyInformation[i].bit_mask = policyQualifiers_present;
            pPolicyInformation[i].policyIdentifier.length = 0;
            pPolicyInformation[i].policyIdentifier.value = NULL;
            pPolicyInformation[i].policyQualifiers.count = pAsn1Info95->value[i].count;
            pPolicyInformation[i].policyQualifiers.value = pAsn1Info95->value[i].value;
        }
            
        pAsn1Info = &certificatePolicies;
    }

    fResult = PkiAsn1AllocStructInfoEx(
        pAsn1Info,
        dwFlags,
        pDecodePara,
        Asn1X509CertPoliciesDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
CommonReturn:
    if (pAsn1Info95)
    {
        if (pPolicyInformation)
            PkiFree(pPolicyInformation);
        Asn1InfoFree(CertificatePolicies95_PDU, pAsn1Info95);
    }
    else
    {
        Asn1InfoFree(CertificatePolicies_PDU, pAsn1Info);
    }
    
    return fResult;

ErrorReturn:
    *pcbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Policy Information 95 - Qualifier 1 decode
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertPoliciesQualifier1DecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    VerisignQualifier1 *pAsn1Info = (VerisignQualifier1 *) pvAsn1Info; 
    PCERT_POLICY95_QUALIFIER1 pInfo =
        (PCERT_POLICY95_QUALIFIER1) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;
    DWORD i;
    
    lRemainExtra -= sizeof(CERT_POLICY95_QUALIFIER1);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CERT_POLICY95_QUALIFIER1));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_POLICY95_QUALIFIER1);
    }

    if (
#ifndef OSS_CRYPT_ASN1
            0 != (pAsn1Info->bit_mask & practicesReference_present) &&
#endif  // OSS_CRYPT_ASN1
            pAsn1Info->practicesReference != NULL)
    {
        lAlignExtra = INFO_LEN_ALIGN((strlen(pAsn1Info->practicesReference)+1) * 2);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pInfo->pszPracticesReference = (LPWSTR) pbExtra;
            MultiByteToWideChar(CP_ACP, 
                                0, 
                                pAsn1Info->practicesReference, 
                                -1, 
                                pInfo->pszPracticesReference,
                                lAlignExtra / 2);   // character count
            pbExtra += lAlignExtra;
        }
    }
    else if (lRemainExtra >= 0)
    {
        pInfo->pszPracticesReference = NULL;
    }
    
    if (pAsn1Info->bit_mask & noticeId_present)
    {
        Asn1X509GetEncodedObjId(&pAsn1Info->noticeId, dwFlags,
                        &pInfo->pszNoticeIdentifier,
                        &pbExtra, &lRemainExtra);  
    }
    else if (lRemainExtra >= 0)
    {
        pInfo->pszNoticeIdentifier = NULL;
    }

    if (pAsn1Info->bit_mask & nsiNoticeId_present)
    {
        Asn1X509GetEncodedObjId(&pAsn1Info->nsiNoticeId, dwFlags,
                        &pInfo->pszNSINoticeIdentifier,
                        &pbExtra, &lRemainExtra);  
    }
    else if (lRemainExtra >= 0)
    {
        pInfo->pszNSINoticeIdentifier = NULL;
    }

    if (pAsn1Info->bit_mask & cpsURLs_present)
    {
        lAlignExtra = INFO_LEN_ALIGN(pAsn1Info->cpsURLs.count * sizeof(CPS_URLS));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) { 
            pInfo->rgCPSURLs = (CPS_URLS *) pbExtra;
            memset(pInfo->rgCPSURLs, 0, lAlignExtra);
            pInfo->cCPSURLs = pAsn1Info->cpsURLs.count;   
            pbExtra += lAlignExtra;
        }
        
        for (i=0; i<pAsn1Info->cpsURLs.count; i++)
        {
            lAlignExtra = INFO_LEN_ALIGN((strlen(pAsn1Info->cpsURLs.value[i].url)+1) * 2);
            lRemainExtra -= lAlignExtra;
            if (lRemainExtra >= 0)
            {
                pInfo->rgCPSURLs[i].pszURL = (LPWSTR) pbExtra;
                MultiByteToWideChar(CP_ACP, 
                                    0, 
                                    pAsn1Info->cpsURLs.value[i].url, 
                                    -1, 
                                    pInfo->rgCPSURLs[i].pszURL,
                                    lAlignExtra / 2);   // character count
                pbExtra += lAlignExtra;
            }

            if (pAsn1Info->cpsURLs.value[i].bit_mask & digestAlgorithmId_present)
            {
                lAlignExtra = INFO_LEN_ALIGN(sizeof(CRYPT_ALGORITHM_IDENTIFIER));
                lRemainExtra -= lAlignExtra;
                if (lRemainExtra >= 0)
                {
                    pInfo->rgCPSURLs[i].pAlgorithm = (CRYPT_ALGORITHM_IDENTIFIER *) pbExtra;
                    memset(pInfo->rgCPSURLs[i].pAlgorithm, 0, lAlignExtra);
                    pbExtra += lAlignExtra;
                }

                Asn1X509GetAlgorithm(
                        &(pAsn1Info->cpsURLs.value[i].digestAlgorithmId),
                        dwFlags,
                        pInfo->rgCPSURLs[i].pAlgorithm,
                        &pbExtra,
                        &lRemainExtra);
            }
            else if (lRemainExtra >= 0)
            {
                pInfo->rgCPSURLs[i].pAlgorithm = NULL;
            }

            if (pAsn1Info->cpsURLs.value[i].bit_mask & digest_present)
            {
                lAlignExtra = INFO_LEN_ALIGN(sizeof(CRYPT_DATA_BLOB));
                lRemainExtra -= lAlignExtra;
                if (lRemainExtra >= 0)
                {
                    pInfo->rgCPSURLs[i].pDigest = (CRYPT_DATA_BLOB *) pbExtra;
                    memset(pInfo->rgCPSURLs[i].pDigest, 0, lAlignExtra);
                    pbExtra += lAlignExtra;
                }   

                Asn1X509GetOctetString(
                        &(pAsn1Info->cpsURLs.value[i].digest),
                        dwFlags,
                        pInfo->rgCPSURLs[i].pDigest,
                        &pbExtra,
                        &lRemainExtra);
            }
            else if (lRemainExtra >= 0)
            {
                pInfo->rgCPSURLs[i].pDigest = NULL;
            }
        }   
    }
    else if (lRemainExtra >= 0)
    {
        pInfo->rgCPSURLs = NULL;
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509CertPoliciesQualifier1DecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        VerisignQualifier1_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CertPoliciesQualifier1DecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Authority Information Access Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityInfoAccessEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_AUTHORITY_INFO_ACCESS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    AuthorityInfoAccess Asn1Info;
    DWORD cAccDescr;
    AccessDescription *pAsn1AccDescr;
    DWORD dwErrLocation;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;

    memset(&Asn1Info, 0, sizeof(Asn1Info));

    cAccDescr = pInfo->cAccDescr;
    if (cAccDescr > 0) {
        pAsn1AccDescr =
            (AccessDescription *) PkiZeroAlloc(cAccDescr *
                sizeof(AccessDescription));
        if (pAsn1AccDescr == NULL)
            goto ErrorReturn;
        Asn1Info.count = cAccDescr;
        Asn1Info.value = pAsn1AccDescr;

        if (!Asn1X509SetAccessDescriptions(
                cAccDescr,
                pInfo->rgAccDescr,
                pAsn1AccDescr,
                &dwErrLocation))
            goto AccessDescriptionsError;

    } else
        pAsn1AccDescr = NULL;

    fResult = Asn1InfoEncodeEx(
        AuthorityInfoAccess_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

AccessDescriptionsError:
    *pcbEncoded = dwErrLocation;
    fResult = FALSE;
    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (pAsn1AccDescr) {
        Asn1X509FreeAccessDescriptions(cAccDescr, pAsn1AccDescr);
        PkiFree(pAsn1AccDescr);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Authority Information Access Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AuthorityInfoAccessDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    AuthorityInfoAccess *pAsn1 = (AuthorityInfoAccess *) pvAsn1Info;
    PCERT_AUTHORITY_INFO_ACCESS pInfo =
        (PCERT_AUTHORITY_INFO_ACCESS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;
    DWORD cAccDescr;
    PCERT_ACCESS_DESCRIPTION pAccDescr;

    cAccDescr = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cAccDescr * sizeof(CERT_ACCESS_DESCRIPTION));

    lRemainExtra -= sizeof(CERT_AUTHORITY_INFO_ACCESS) + lAlignExtra;
    if (lRemainExtra < 0) {
        pbExtra = NULL;
        pAccDescr = NULL;
    } else {
        pbExtra = (BYTE *) pInfo + sizeof(CERT_AUTHORITY_INFO_ACCESS);
        pAccDescr = (PCERT_ACCESS_DESCRIPTION) pbExtra;
        pInfo->cAccDescr = cAccDescr;
        pInfo->rgAccDescr = pAccDescr;
        pbExtra += lAlignExtra;
    }

    if (!Asn1X509GetAccessDescriptions(
            cAccDescr,
            pAsn1->value,
            dwFlags,
            pAccDescr,
            &pbExtra,
            &lRemainExtra
            )) goto ErrorReturn;

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}


BOOL WINAPI Asn1X509AuthorityInfoAccessDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        AuthorityInfoAccess_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509AuthorityInfoAccessDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  CRL Distribution Points Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrlDistPointsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_DIST_POINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CRLDistributionPoints Asn1Info;
    DistributionPoint *pAsn1DistPoint;
    PCRL_DIST_POINT pDistPoint;
    DWORD cDistPoint;
    DWORD i;
    DWORD dwErrLocation;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (0 == (cDistPoint = pInfo->cDistPoint))
        goto InvalidArg;

    if (NULL == (pAsn1DistPoint = (DistributionPoint *) PkiZeroAlloc(
            cDistPoint * sizeof(DistributionPoint))))
        goto ErrorReturn;
    Asn1Info.count = cDistPoint;
    Asn1Info.value = pAsn1DistPoint;

    pDistPoint = pInfo->rgDistPoint;
    for (i = 0; i < cDistPoint; i++, pDistPoint++, pAsn1DistPoint++) {
        PCRL_DIST_POINT_NAME pDistPointName =
            &pDistPoint->DistPointName;
        if (CRL_DIST_POINT_NO_NAME !=
                pDistPointName->dwDistPointNameChoice) {
            DistributionPointName *pAsn1DistPointName =
                &pAsn1DistPoint->distributionPoint;

            pAsn1DistPoint->bit_mask |= distributionPoint_present;
            pAsn1DistPointName->choice = (unsigned short)
                pDistPointName->dwDistPointNameChoice;
            
            assert(fullName_chosen == CRL_DIST_POINT_FULL_NAME);
            assert(nameRelativeToCRLIssuer_chosen ==
                CRL_DIST_POINT_ISSUER_RDN_NAME);

            switch (pDistPointName->dwDistPointNameChoice) {
                case CRL_DIST_POINT_FULL_NAME:
                    if (!Asn1X509SetAltNames(
                            &pDistPointName->FullName,
                            &pAsn1DistPointName->u.fullName, i, &dwErrLocation))
                        goto AltNamesError;
                    break;
                case CRL_DIST_POINT_ISSUER_RDN_NAME:
                default:
                    goto InvalidArg;
            }
        }

        if (pDistPoint->ReasonFlags.cbData) {
            pAsn1DistPoint->bit_mask |= reasons_present;
            Asn1X509SetBitWithoutTrailingZeroes(&pDistPoint->ReasonFlags,
                &pAsn1DistPoint->reasons);
        }

        if (pDistPoint->CRLIssuer.cAltEntry) {
            pAsn1DistPoint->bit_mask |= cRLIssuer_present;
            if (!Asn1X509SetAltNames(
                    &pDistPoint->CRLIssuer,
                    &pAsn1DistPoint->cRLIssuer,
                    (CRL_DIST_POINT_ERR_CRL_ISSUER_BIT >> 24) | i,
                    &dwErrLocation))
                goto AltNamesError;
        }
    }

    fResult = Asn1InfoEncodeEx(
        CRLDistributionPoints_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;


AltNamesError:
    *pcbEncoded = dwErrLocation;
    fResult = FALSE;
    goto CommonReturn;

InvalidArg:
    SetLastError((DWORD) E_INVALIDARG);
ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    pAsn1DistPoint = Asn1Info.value;
    if (pAsn1DistPoint) {
        cDistPoint = Asn1Info.count;
        pDistPoint = pInfo->rgDistPoint;
        for ( ; cDistPoint > 0; cDistPoint--, pDistPoint++, pAsn1DistPoint++) {
            DistributionPointName *pAsn1DistPointName =
                &pAsn1DistPoint->distributionPoint;

            switch (pAsn1DistPointName->choice) {
                case CRL_DIST_POINT_FULL_NAME:
                    Asn1X509FreeAltNames(&pAsn1DistPointName->u.fullName);
                    break;
                case CRL_DIST_POINT_ISSUER_RDN_NAME:
                default:
                    break;
            }

            Asn1X509FreeAltNames(&pAsn1DistPoint->cRLIssuer);
        }
        PkiFree(Asn1Info.value);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  CRL Distribution Points Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrlDistPointsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CRLDistributionPoints *pAsn1 = (CRLDistributionPoints *) pvAsn1Info;
    PCRL_DIST_POINTS_INFO pInfo = (PCRL_DIST_POINTS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;

    lRemainExtra -= sizeof(CRL_DIST_POINTS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CRL_DIST_POINTS_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CRL_DIST_POINTS_INFO);
    }

    if (pAsn1->count) {
        DWORD cDistPoint = pAsn1->count;
        DistributionPoint *pAsn1DistPoint = pAsn1->value;
        PCRL_DIST_POINT pDistPoint;

        lAlignExtra = INFO_LEN_ALIGN(cDistPoint * sizeof(CRL_DIST_POINT));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pDistPoint = (PCRL_DIST_POINT) pbExtra;
            memset(pDistPoint, 0, cDistPoint * sizeof(CRL_DIST_POINT));
            pInfo->cDistPoint = cDistPoint;
            pInfo->rgDistPoint = pDistPoint;
            pbExtra += lAlignExtra;
        } else
            pDistPoint = NULL;

        for ( ; cDistPoint > 0; cDistPoint--, pAsn1DistPoint++, pDistPoint++) {
            if (pAsn1DistPoint->bit_mask & distributionPoint_present) {
                DistributionPointName *pAsn1DistPointName =
                    &pAsn1DistPoint->distributionPoint;
                DWORD dwDistPointNameChoice = pAsn1DistPointName->choice;
                PCRL_DIST_POINT_NAME pDistPointName;

                if (lRemainExtra >= 0) {
                    pDistPointName = &pDistPoint->DistPointName;
                    pDistPointName->dwDistPointNameChoice =
                        dwDistPointNameChoice;
                } else
                    pDistPointName = NULL;

                assert(fullName_chosen == CRL_DIST_POINT_FULL_NAME);
                assert(nameRelativeToCRLIssuer_chosen ==
                    CRL_DIST_POINT_ISSUER_RDN_NAME);

                switch (dwDistPointNameChoice) {
                    case CRL_DIST_POINT_FULL_NAME:
                        if (!Asn1X509GetAltNames(&pAsn1DistPointName->u.fullName,
                                dwFlags, &pDistPointName->FullName,
                                &pbExtra, &lRemainExtra))
                            goto ErrorReturn;
                        break;
                    case CRL_DIST_POINT_ISSUER_RDN_NAME:
                        break;
                    default:
                        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
                        goto ErrorReturn;
                }
            }

            if (pAsn1DistPoint->bit_mask & reasons_present)
                Asn1X509GetBit(&pAsn1DistPoint->reasons, dwFlags,
                    &pDistPoint->ReasonFlags, &pbExtra, &lRemainExtra);

            if (pAsn1DistPoint->bit_mask & cRLIssuer_present) {
                if (!Asn1X509GetAltNames(&pAsn1DistPoint->cRLIssuer, dwFlags,
                        &pDistPoint->CRLIssuer, &pbExtra, &lRemainExtra))
                    goto ErrorReturn;
            }
        }
    }

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL WINAPI Asn1X509CrlDistPointsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CRLDistributionPoints_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CrlDistPointsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Integer Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509IntegerEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN int *pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    int Asn1Info = *pInfo;

    return Asn1InfoEncodeEx(
        IntegerType_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Integer Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509IntegerDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    int *pAsn1Info = (int *) pvAsn1Info;
    int *pInfo = (int *) pvStructInfo;

    *plRemainExtra -= sizeof(int);
    if (*plRemainExtra >= 0)
        *pInfo = *pAsn1Info;
    return TRUE;
}

BOOL WINAPI Asn1X509IntegerDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        IntegerType_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509IntegerDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  MultiByte Integer Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509MultiByteIntegerEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_INTEGER_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    HUGEINTEGER Asn1Info;


    if (!Asn1X509SetHugeInteger(pInfo, &Asn1Info)) {
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
        return FALSE;
    }
    fResult = Asn1InfoEncodeEx(
        HugeIntegerType_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    Asn1X509FreeHugeInteger(&Asn1Info);
    return fResult;
}

//+-------------------------------------------------------------------------
//  MultiByte Integer Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509MultiByteIntegerDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    HUGEINTEGER *pAsn1Info = (HUGEINTEGER *) pvAsn1Info;
    PCRYPT_INTEGER_BLOB pInfo = (PCRYPT_INTEGER_BLOB) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_INTEGER_BLOB);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_INTEGER_BLOB);

    Asn1X509GetHugeInteger(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509MultiByteIntegerDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        HugeIntegerType_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509MultiByteIntegerDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  MultiByte UINT Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509MultiByteUINTEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_UINT_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    HUGEINTEGER Asn1Info;

    if (!Asn1X509SetHugeUINT(pInfo, &Asn1Info)) {
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
        return FALSE;
    }
    fResult = Asn1InfoEncodeEx(
        HugeIntegerType_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    Asn1X509FreeHugeUINT(&Asn1Info);
    return fResult;
}

//+-------------------------------------------------------------------------
//  MultiByte UINT Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509MultiByteUINTDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    HUGEINTEGER *pAsn1Info = (HUGEINTEGER *) pvAsn1Info;
    PCRYPT_UINT_BLOB pInfo = (PCRYPT_UINT_BLOB) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_UINT_BLOB);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_UINT_BLOB);

    Asn1X509GetHugeUINT(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509MultiByteUINTDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        HugeIntegerType_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509MultiByteUINTDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  DSS Parameters Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DSSParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_DSS_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DSSParameters Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1X509SetHugeUINT(&pInfo->p, &Asn1Info.p))
        goto ErrorReturn;
    if (!Asn1X509SetHugeUINT(&pInfo->q, &Asn1Info.q))
        goto ErrorReturn;
    if (!Asn1X509SetHugeUINT(&pInfo->g, &Asn1Info.g))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        DSSParameters_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeHugeUINT(&Asn1Info.p);
    Asn1X509FreeHugeUINT(&Asn1Info.q);
    Asn1X509FreeHugeUINT(&Asn1Info.g);
    return fResult;
}

//+-------------------------------------------------------------------------
//  DSS Parameters Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DSSParametersDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    DSSParameters *pAsn1Info = (DSSParameters *) pvAsn1Info;
    PCERT_DSS_PARAMETERS pInfo = (PCERT_DSS_PARAMETERS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_DSS_PARAMETERS);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_DSS_PARAMETERS);

    Asn1X509GetHugeUINT(&pAsn1Info->p, dwFlags,
        &pInfo->p, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->q, dwFlags,
        &pInfo->q, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->g, dwFlags,
        &pInfo->g, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509DSSParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        DSSParameters_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509DSSParametersDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  DSS Signature Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DSSSignatureEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BYTE rgbSignature[CERT_DSS_SIGNATURE_LEN],
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BYTE rgbR[1 + CERT_DSS_R_LEN];
    BYTE rgbS[1 + CERT_DSS_S_LEN];
    DSSSignature Asn1Signature;
    DWORD i;

    // Treat the r and s components of the DSS signature as being unsigned.
    // Also need to swap before doing the encode.
    rgbR[0] = 0;
    for (i = 0; i < CERT_DSS_R_LEN; i++)
        rgbR[(1 + CERT_DSS_R_LEN - 1) - i] = rgbSignature[i];
    Asn1Signature.r.length = sizeof(rgbR);
    Asn1Signature.r.value = rgbR;

    rgbS[0] = 0;
    for (i = 0; i < CERT_DSS_S_LEN; i++)
        rgbS[(1 + CERT_DSS_S_LEN - 1) - i] =
            rgbSignature[CERT_DSS_R_LEN + i];
    Asn1Signature.s.length = sizeof(rgbS);
    Asn1Signature.s.value = rgbS;

    return Asn1InfoEncodeEx(
        DSSSignature_PDU,
        &Asn1Signature,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  DSS Signature Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DSSSignatureDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    DSSSignature *pAsn1Signature = (DSSSignature *) pvAsn1Info;
//  BYTE rgbSignature[CERT_DSS_SIGNATURE_LEN],
    BYTE *rgbSignature = (BYTE *) pvStructInfo;
    DWORD cb;
    BYTE *pb;
    DWORD i;

    *plRemainExtra -= CERT_DSS_SIGNATURE_LEN;
    if (*plRemainExtra >= 0) {
        memset(rgbSignature, 0, CERT_DSS_SIGNATURE_LEN);

        // Strip off a leading 0 byte. Byte reverse while copying
        cb = pAsn1Signature->r.length;
        pb = pAsn1Signature->r.value;
        if (cb > 1 && *pb == 0) {
            pb++;
            cb--;
        }
        if (0 == cb || cb > CERT_DSS_R_LEN)
            goto DecodeError;
        for (i = 0; i < cb; i++)
            rgbSignature[i] = pb[cb - 1 - i];

        // Strip off a leading 0 byte. Byte reverse while copying
        cb = pAsn1Signature->s.length;
        pb = pAsn1Signature->s.value;
        if (cb > 1 && *pb == 0) {
            pb++;
            cb--;
        }
        if (0 == cb || cb > CERT_DSS_S_LEN)
            goto DecodeError;
        for (i = 0; i < cb; i++)
            rgbSignature[CERT_DSS_R_LEN + i] = pb[cb - 1 - i];
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1X509DSSSignatureDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        DSSSignature_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509DSSSignatureDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  DH Parameters Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DHParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_DH_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DHParameters Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1X509SetHugeUINT(&pInfo->p, &Asn1Info.p))
        goto ErrorReturn;
    if (!Asn1X509SetHugeUINT(&pInfo->g, &Asn1Info.g))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        DHParameters_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeHugeUINT(&Asn1Info.p);
    Asn1X509FreeHugeUINT(&Asn1Info.g);
    return fResult;
}

//+-------------------------------------------------------------------------
//  DH Parameters Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DHParametersDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    DHParameters *pAsn1Info = (DHParameters *) pvAsn1Info;
    PCERT_DH_PARAMETERS pInfo = (PCERT_DH_PARAMETERS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_DH_PARAMETERS);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_DH_PARAMETERS);

    Asn1X509GetHugeUINT(&pAsn1Info->p, dwFlags,
        &pInfo->p, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->g, dwFlags,
        &pInfo->g, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

//+-------------------------------------------------------------------------
//  DH Parameters Decode (ASN1) New Style X942
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509DHParametersX942DecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    X942DhParameters *pAsn1Info = (X942DhParameters *) pvAsn1Info;
    PCERT_DH_PARAMETERS pInfo = (PCERT_DH_PARAMETERS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_DH_PARAMETERS);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CERT_DH_PARAMETERS);

    Asn1X509GetHugeUINT(&pAsn1Info->p, dwFlags,
        &pInfo->p, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->g, dwFlags,
        &pInfo->g, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509DHParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    DWORD cbStructInfo;

    cbStructInfo = *pcbStructInfo;
    fResult = Asn1InfoDecodeAndAllocEx(
        DHParameters_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509DHParametersDecodeExCallback,
        pvStructInfo,
        &cbStructInfo
        );

    if (!fResult && 0 == cbStructInfo) {
        // Try to decode as new style X942 parameters

        DWORD dwErr = GetLastError();

        cbStructInfo = *pcbStructInfo;
        fResult = Asn1InfoDecodeAndAllocEx(
            X942DhParameters_PDU,
            pbEncoded,
            cbEncoded,
            dwFlags,
            pDecodePara,
            Asn1X509DHParametersX942DecodeExCallback,
            pvStructInfo,
            &cbStructInfo
            );
        if (!fResult && 0 == cbStructInfo)
            SetLastError(dwErr);
    }

    *pcbStructInfo = cbStructInfo;
    return fResult;
}

//+-------------------------------------------------------------------------
//  X942 DH Parameters Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X942DhParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_X942_DH_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    X942DhParameters Asn1Info;

    if (0 == pInfo->q.cbData) {
        CERT_DH_PARAMETERS Pkcs3Info;

        Pkcs3Info.p = pInfo->p;
        Pkcs3Info.g = pInfo->g;
        return Asn1X509DHParametersEncodeEx(
            dwCertEncodingType,
            lpszStructType,
            &Pkcs3Info,
            dwFlags,
            pEncodePara,
            pvEncoded,
            pcbEncoded
            );
    }

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1X509SetHugeUINT(&pInfo->p, &Asn1Info.p))
        goto ErrorReturn;
    if (!Asn1X509SetHugeUINT(&pInfo->g, &Asn1Info.g))
        goto ErrorReturn;
    if (!Asn1X509SetHugeUINT(&pInfo->q, &Asn1Info.q))
        goto ErrorReturn;

    if (pInfo->j.cbData) {
        if (!Asn1X509SetHugeUINT(&pInfo->j, &Asn1Info.j))
            goto ErrorReturn;
        Asn1Info.bit_mask |= j_present;
    }

    if (pInfo->pValidationParams) {
        PCERT_X942_DH_VALIDATION_PARAMS pValidationParams =
            pInfo->pValidationParams;

        Asn1X509SetBit(&pValidationParams->seed,
            &Asn1Info.validationParams.seed);
        Asn1Info.validationParams.pgenCounter = pValidationParams->pgenCounter;
        Asn1Info.bit_mask |= validationParams_present;
    }

    fResult = Asn1InfoEncodeEx(
        X942DhParameters_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeHugeUINT(&Asn1Info.p);
    Asn1X509FreeHugeUINT(&Asn1Info.g);
    Asn1X509FreeHugeUINT(&Asn1Info.q);
    Asn1X509FreeHugeUINT(&Asn1Info.j);
    return fResult;
}

//+-------------------------------------------------------------------------
//  X942 DH Parameters Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X942DhParametersDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    X942DhParameters *pAsn1Info = (X942DhParameters *) pvAsn1Info;
    PCERT_X942_DH_PARAMETERS pInfo = (PCERT_X942_DH_PARAMETERS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_X942_DH_PARAMETERS);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_X942_DH_PARAMETERS));

        pbExtra = (BYTE *) pInfo + sizeof(CERT_X942_DH_PARAMETERS);
    }

    Asn1X509GetHugeUINT(&pAsn1Info->p, dwFlags,
        &pInfo->p, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->g, dwFlags,
        &pInfo->g, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->q, dwFlags,
        &pInfo->q, &pbExtra, &lRemainExtra);

    if (pAsn1Info->bit_mask & j_present)
        Asn1X509GetHugeUINT(&pAsn1Info->j, dwFlags,
            &pInfo->j, &pbExtra, &lRemainExtra);

    if (pAsn1Info->bit_mask & validationParams_present) {
        PCERT_X942_DH_VALIDATION_PARAMS pValidationParams;

        lRemainExtra -= sizeof(CERT_X942_DH_VALIDATION_PARAMS);

        if (lRemainExtra < 0) {
            pValidationParams = NULL;
        } else {
            pValidationParams = (PCERT_X942_DH_VALIDATION_PARAMS) pbExtra;
            pInfo->pValidationParams = pValidationParams;
            pbExtra += sizeof(CERT_X942_DH_VALIDATION_PARAMS);
            pValidationParams->pgenCounter =
                pAsn1Info->validationParams.pgenCounter;
        }

        Asn1X509GetBit(&pAsn1Info->validationParams.seed, dwFlags,
            &pValidationParams->seed, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

//+-------------------------------------------------------------------------
//  X942 DH Parameters Decode (ASN1) Old Style Pkcs #3
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X942DhParametersPkcs3DecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    DHParameters *pAsn1Info = (DHParameters *) pvAsn1Info;
    PCERT_X942_DH_PARAMETERS pInfo = (PCERT_X942_DH_PARAMETERS) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_X942_DH_PARAMETERS);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_X942_DH_PARAMETERS));

        pbExtra = (BYTE *) pInfo + sizeof(CERT_X942_DH_PARAMETERS);
    }
    Asn1X509GetHugeUINT(&pAsn1Info->p, dwFlags,
        &pInfo->p, &pbExtra, &lRemainExtra);
    Asn1X509GetHugeUINT(&pAsn1Info->g, dwFlags,
        &pInfo->g, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X942DhParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    DWORD cbStructInfo;

    cbStructInfo = *pcbStructInfo;
    fResult = Asn1InfoDecodeAndAllocEx(
        X942DhParameters_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X942DhParametersDecodeExCallback,
        pvStructInfo,
        &cbStructInfo
        );

    if (!fResult && 0 == cbStructInfo) {
        // Try to decode as old style PKCS #3 parameters

        DWORD dwErr = GetLastError();

        cbStructInfo = *pcbStructInfo;
        fResult = Asn1InfoDecodeAndAllocEx(
            DHParameters_PDU,
            pbEncoded,
            cbEncoded,
            dwFlags,
            pDecodePara,
            Asn1X942DhParametersPkcs3DecodeExCallback,
            pvStructInfo,
            &cbStructInfo
            );
        if (!fResult && 0 == cbStructInfo)
            SetLastError(dwErr);
    }

    *pcbStructInfo = cbStructInfo;
    return fResult;
}


//+-------------------------------------------------------------------------
//  X942_OTHER_INFO Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X942OtherInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_X942_OTHER_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    X942DhOtherInfo Asn1Info;
    BYTE rgbAsn1Counter[CRYPT_X942_COUNTER_BYTE_LENGTH];
    BYTE rgbAsn1KeyLength[CRYPT_X942_KEY_LENGTH_BYTE_LENGTH];

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1X509SetEncodedObjId(pInfo->pszContentEncryptionObjId,
            &Asn1Info.keyInfo.algorithm))
        goto ErrorReturn;

    memcpy(rgbAsn1Counter, pInfo->rgbCounter, CRYPT_X942_COUNTER_BYTE_LENGTH);
    PkiAsn1ReverseBytes(rgbAsn1Counter, CRYPT_X942_COUNTER_BYTE_LENGTH);
    Asn1Info.keyInfo.counter.length = CRYPT_X942_COUNTER_BYTE_LENGTH;
    Asn1Info.keyInfo.counter.value = rgbAsn1Counter;

    memcpy(rgbAsn1KeyLength, pInfo->rgbKeyLength,
        CRYPT_X942_KEY_LENGTH_BYTE_LENGTH);
    PkiAsn1ReverseBytes(rgbAsn1KeyLength, CRYPT_X942_KEY_LENGTH_BYTE_LENGTH);
    Asn1Info.keyLength.length = CRYPT_X942_KEY_LENGTH_BYTE_LENGTH;
    Asn1Info.keyLength.value = rgbAsn1KeyLength;

    if (pInfo->PubInfo.cbData) {
        Asn1X509SetOctetString(&pInfo->PubInfo, &Asn1Info.pubInfo);
        Asn1Info.bit_mask |= pubInfo_present;
    }

    fResult = Asn1InfoEncodeEx(
        X942DhOtherInfo_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

//+-------------------------------------------------------------------------
//  X942_OTHER_INFO Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X942OtherInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    X942DhOtherInfo *pAsn1Info = (X942DhOtherInfo *) pvAsn1Info;
    PCRYPT_X942_OTHER_INFO pInfo = (PCRYPT_X942_OTHER_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    if (CRYPT_X942_COUNTER_BYTE_LENGTH != pAsn1Info->keyInfo.counter.length ||
            CRYPT_X942_KEY_LENGTH_BYTE_LENGTH !=
                pAsn1Info->keyLength.length) {
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }

    lRemainExtra -= sizeof(CRYPT_X942_OTHER_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CRYPT_X942_OTHER_INFO));

        memcpy(pInfo->rgbCounter, pAsn1Info->keyInfo.counter.value,
            CRYPT_X942_COUNTER_BYTE_LENGTH);
        PkiAsn1ReverseBytes(pInfo->rgbCounter, CRYPT_X942_COUNTER_BYTE_LENGTH);

        memcpy(pInfo->rgbKeyLength, pAsn1Info->keyLength.value,
            CRYPT_X942_KEY_LENGTH_BYTE_LENGTH);
        PkiAsn1ReverseBytes(pInfo->rgbKeyLength,
            CRYPT_X942_KEY_LENGTH_BYTE_LENGTH);

        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_X942_OTHER_INFO);
    }

    Asn1X509GetEncodedObjId(&pAsn1Info->keyInfo.algorithm, dwFlags,
            &pInfo->pszContentEncryptionObjId,
            &pbExtra, &lRemainExtra);

    if (pAsn1Info->bit_mask & pubInfo_present) {
        Asn1X509GetOctetString(&pAsn1Info->pubInfo, dwFlags,
            &pInfo->PubInfo, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X942OtherInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        X942DhOtherInfo_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X942OtherInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  RC2 CBC Parameters Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1RC2CBCParametersEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_RC2_CBC_PARAMETERS pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    RC2CBCParameters Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    Asn1Info.version = pInfo->dwVersion;
    if (pInfo->fIV) {
        Asn1Info.bit_mask |= iv_present;
        Asn1Info.iv.length = sizeof(pInfo->rgbIV);
        Asn1Info.iv.value = pInfo->rgbIV;
    }

    return Asn1InfoEncodeEx(
        RC2CBCParameters_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  RC2 CBC Parameters Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1RC2CBCParametersDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    RC2CBCParameters *pAsn1Info = (RC2CBCParameters *) pvAsn1Info;
    PCRYPT_RC2_CBC_PARAMETERS pInfo = (PCRYPT_RC2_CBC_PARAMETERS) pvStructInfo;

    *plRemainExtra -= sizeof(CRYPT_RC2_CBC_PARAMETERS);
    if (*plRemainExtra >= 0) {
        memset(pInfo, 0, sizeof(CRYPT_RC2_CBC_PARAMETERS));
        pInfo->dwVersion = pAsn1Info->version;
        if (pAsn1Info->bit_mask & iv_present) {
            pInfo->fIV = TRUE;
            if (pAsn1Info->iv.length != sizeof(pInfo->rgbIV))
                goto DecodeError;
            memcpy(pInfo->rgbIV, pAsn1Info->iv.value, sizeof(pInfo->rgbIV));
        }
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1RC2CBCParametersDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        RC2CBCParameters_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1RC2CBCParametersDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  SMIME Capabilities Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1SMIMECapabilitiesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_SMIME_CAPABILITIES pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    SMIMECapabilities Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (0 != pInfo->cCapability) {
        DWORD cCap = pInfo->cCapability;
        PCRYPT_SMIME_CAPABILITY pCap = pInfo->rgCapability;
        SMIMECapability *pAsn1Cap;
        
        if (NULL == (pAsn1Cap = (SMIMECapability *) PkiZeroAlloc(
                cCap * sizeof(SMIMECapability))))
            goto ErrorReturn;

        Asn1Info.count = cCap;
        Asn1Info.value = pAsn1Cap;
        for ( ; cCap > 0; cCap--, pCap++, pAsn1Cap++) {
            if (!Asn1X509SetEncodedObjId(pCap->pszObjId, &pAsn1Cap->capabilityID))
                goto ErrorReturn;
            if (pCap->Parameters.cbData) {
                pAsn1Cap->bit_mask |= smimeParameters_present;
                Asn1X509SetAny(&pCap->Parameters,
                    &pAsn1Cap->smimeParameters);
            }
        }
    }

    fResult = Asn1InfoEncodeEx(
        SMIMECapabilities_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    PkiFree(Asn1Info.value);
    return fResult;
}

//+-------------------------------------------------------------------------
//  SMIME Capabilities Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1SMIMECapabilitiesDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    SMIMECapabilities *pAsn1Info = (SMIMECapabilities *) pvAsn1Info;
    PCRYPT_SMIME_CAPABILITIES pInfo = (PCRYPT_SMIME_CAPABILITIES) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;
    DWORD cCap;
    SMIMECapability *pAsn1Cap;
    PCRYPT_SMIME_CAPABILITY pCap;

    cCap = pAsn1Info->count;
    lAlignExtra = cCap * sizeof(CRYPT_SMIME_CAPABILITY);

    lRemainExtra -= sizeof(CRYPT_SMIME_CAPABILITIES) + lAlignExtra;
    if (lRemainExtra < 0) {
        pbExtra = NULL;
        pCap = NULL;
    } else {
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_SMIME_CAPABILITIES);
        pCap = (PCRYPT_SMIME_CAPABILITY) pbExtra;
        pInfo->cCapability = cCap;
        pInfo->rgCapability = pCap;
        if (lAlignExtra) {
            memset(pbExtra, 0, lAlignExtra);
            pbExtra += lAlignExtra;
        }
    }

    pAsn1Cap = pAsn1Info->value;
    for ( ; cCap > 0; cCap--, pAsn1Cap++, pCap++) {
        Asn1X509GetEncodedObjId(&pAsn1Cap->capabilityID, dwFlags, &pCap->pszObjId,
            &pbExtra, &lRemainExtra);
        if (pAsn1Cap->bit_mask & smimeParameters_present)
            Asn1X509GetAny(&pAsn1Cap->smimeParameters, dwFlags,
                &pCap->Parameters, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1SMIMECapabilitiesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        SMIMECapabilities_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1SMIMECapabilitiesDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Enumerated Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509EnumeratedEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN int *pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    EnumeratedType Asn1Info = (EnumeratedType) *pInfo;

    return Asn1InfoEncodeEx(
        EnumeratedType_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Enumerated Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509EnumeratedDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    EnumeratedType *pAsn1Info = (EnumeratedType *) pvAsn1Info;
    int *pInfo = (int *) pvStructInfo;

    *plRemainExtra -= sizeof(int);
    if (*plRemainExtra >= 0)
        *pInfo = *pAsn1Info;
    return TRUE;
}

BOOL WINAPI Asn1X509EnumeratedDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        EnumeratedType_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509EnumeratedDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Octet String Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509OctetStringEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_DATA_BLOB pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    OCTETSTRING Asn1Info;

    Asn1X509SetOctetString(pInfo, &Asn1Info);
    return Asn1InfoEncodeEx(
        OctetStringType_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
// Octet String Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509OctetStringDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    OCTETSTRING *pAsn1Info = (OCTETSTRING *) pvAsn1Info;
    PCRYPT_DATA_BLOB pInfo = (PCRYPT_DATA_BLOB) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_DATA_BLOB);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_DATA_BLOB);

    Asn1X509GetOctetString(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509OctetStringDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        OctetStringType_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509OctetStringDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  ChoiceOfTime Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ChoiceOfTimeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN LPFILETIME pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    ChoiceOfTime Asn1Info;

    if (!PkiAsn1ToChoiceOfTime(pInfo,
            &Asn1Info.choice,
            &Asn1Info.u.generalTime ,
            &Asn1Info.u.utcTime
            )) {
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
        return FALSE;
    }
    return Asn1InfoEncodeEx(
        ChoiceOfTime_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  ChoiceOfTime Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ChoiceOfTimeDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    ChoiceOfTime *pAsn1Info = (ChoiceOfTime *) pvAsn1Info;
    LPFILETIME pInfo = (LPFILETIME) pvStructInfo;

    *plRemainExtra -= sizeof(FILETIME);
    if (*plRemainExtra >= 0) {
        if (!PkiAsn1FromChoiceOfTime(pAsn1Info->choice,
                &pAsn1Info->u.generalTime,
                &pAsn1Info->u.utcTime,
                pInfo))
            goto DecodeError;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1X509ChoiceOfTimeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        ChoiceOfTime_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509ChoiceOfTimeDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Attribute Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AttributeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ATTRIBUTE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    Attribute Asn1Info;


    if (!Asn1X509SetAttribute(pInfo, &Asn1Info)) {
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
        return FALSE;
    }
    fResult = Asn1InfoEncodeEx(
        Attribute_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    Asn1X509FreeAttribute(&Asn1Info);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Attribute Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AttributeDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    Attribute *pAsn1Info = (Attribute *) pvAsn1Info;
    PCRYPT_ATTRIBUTE pInfo = (PCRYPT_ATTRIBUTE) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_ATTRIBUTE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_ATTRIBUTE);

    Asn1X509GetAttribute(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509AttributeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        Attribute_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509AttributeDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  ContentInfo Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ContentInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_CONTENT_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    ContentInfo Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1X509SetEncodedObjId(pInfo->pszObjId, &Asn1Info.contentType)) {
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
        return FALSE;
    }

    if (pInfo->Content.cbData) {
        Asn1Info.bit_mask |= content_present;
        Asn1X509SetAny(&pInfo->Content, &Asn1Info.content);
    }

    return Asn1InfoEncodeEx(
        ContentInfo_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  ContentInfo Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ContentInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    ContentInfo *pAsn1Info = (ContentInfo *) pvAsn1Info;
    PCRYPT_CONTENT_INFO pInfo = (PCRYPT_CONTENT_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_CONTENT_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CRYPT_CONTENT_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_CONTENT_INFO);
    }

    Asn1X509GetEncodedObjId(&pAsn1Info->contentType, dwFlags,
        &pInfo->pszObjId, &pbExtra, &lRemainExtra);
    if (pAsn1Info->bit_mask & content_present)
        Asn1X509GetAny(&pAsn1Info->content, dwFlags,
            &pInfo->Content, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509ContentInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        ContentInfo_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509ContentInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  ContentInfoSequenceOfAny Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ContentInfoSequenceOfAnyEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    ContentInfoSeqOfAny Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1X509SetEncodedObjId(pInfo->pszObjId, &Asn1Info.contentType))
        goto ErrorReturn;

    if (pInfo->cValue) {
        Asn1Info.bit_mask |= contentSeqOfAny_present;
        if (!Asn1X509SetSeqOfAny(
                pInfo->cValue,
                pInfo->rgValue,
                &Asn1Info.contentSeqOfAny.count,
                &Asn1Info.contentSeqOfAny.value))
            goto ErrorReturn;
    }

    fResult = Asn1InfoEncodeEx(
        ContentInfoSeqOfAny_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeSeqOfAny(Asn1Info.contentSeqOfAny.value);
    return fResult;
}

//+-------------------------------------------------------------------------
//  ContentInfoSequenceOfAny Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509ContentInfoSequenceOfAnyDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    ContentInfoSeqOfAny *pAsn1Info = (ContentInfoSeqOfAny *) pvAsn1Info;
    PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY pInfo =
        (PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY));
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY);
    }

    Asn1X509GetEncodedObjId(&pAsn1Info->contentType, dwFlags,
        &pInfo->pszObjId, &pbExtra, &lRemainExtra);
    if (pAsn1Info->bit_mask & contentSeqOfAny_present)
        Asn1X509GetSeqOfAny(pAsn1Info->contentSeqOfAny.count,
            pAsn1Info->contentSeqOfAny.value, dwFlags,
            &pInfo->cValue, &pInfo->rgValue, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509ContentInfoSequenceOfAnyDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        ContentInfoSeqOfAny_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509ContentInfoSequenceOfAnyDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  SequenceOfAny Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SequenceOfAnyEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_SEQUENCE_OF_ANY pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    SeqOfAny Asn1Info;

    if (!Asn1X509SetSeqOfAny(
            pInfo->cValue,
            pInfo->rgValue,
            &Asn1Info.count,
            &Asn1Info.value))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        SeqOfAny_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeSeqOfAny(Asn1Info.value);
    return fResult;
}

//+-------------------------------------------------------------------------
//  SequenceOfAny Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509SequenceOfAnyDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    SeqOfAny *pAsn1Info = (SeqOfAny *) pvAsn1Info;
    PCRYPT_SEQUENCE_OF_ANY pInfo = (PCRYPT_SEQUENCE_OF_ANY) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_SEQUENCE_OF_ANY);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_SEQUENCE_OF_ANY);
    }

    Asn1X509GetSeqOfAny(pAsn1Info->count, pAsn1Info->value, dwFlags,
            &pInfo->cValue, &pInfo->rgValue, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509SequenceOfAnyDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        SeqOfAny_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509SequenceOfAnyDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  UTC TIME Encode/Decode
//--------------------------------------------------------------------------
BOOL WINAPI Asn1UtcTimeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN FILETIME * pFileTime,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        ) {

    assert(pcbEncoded != NULL);

    BOOL fResult;
    UtcTime utcTime;

    memset(&utcTime, 0, sizeof(UtcTime));

    if( !PkiAsn1ToUTCTime(pFileTime, &utcTime) )
            goto PkiAsn1ToUTCTimeError;

    fResult = Asn1InfoEncodeEx(
                UtcTime_PDU,
                &utcTime,
                dwFlags,
                pEncodePara,
                pvEncoded,
                pcbEncoded
                );

CommonReturn:
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(PkiAsn1ToUTCTimeError, CRYPT_E_BAD_ENCODE);
}


BOOL WINAPI Asn1UtcTimeDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    UtcTime *putcTime = (UtcTime *) pvAsn1Info;
    LPFILETIME pInfo = (LPFILETIME) pvStructInfo;

    *plRemainExtra -= sizeof(FILETIME);
    if (*plRemainExtra >= 0) {
        if(!PkiAsn1FromUTCTime(putcTime, pInfo))
            goto DecodeError;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1UtcTimeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        UtcTime_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1UtcTimeDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

BOOL WINAPI Asn1TimeStampRequestInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_TIME_STAMP_REQUEST_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD   pdu;

    union {
        TimeStampRequest tsr;
        TimeStampRequestOTS tsrocs;
        } timeStampReq;

    memset(&timeStampReq, 0, sizeof(TimeStampRequest));

    if( !Asn1X509SetEncodedObjId(pInfo->pszTimeStampAlgorithm, &timeStampReq.tsr.timeStampAlgorithm) ||
        !Asn1X509SetEncodedObjId(pInfo->pszContentType, &timeStampReq.tsr.content.contentType) )
	goto Asn1X509SetEncodedObjIdError;

    // only write content if it is present
    if(pInfo->Content.cbData != 0)
        timeStampReq.tsr.content.bit_mask |= content_present;

    if(!strcmp(pInfo->pszContentType, szOID_RSA_data)) {
        Asn1X509SetOctetString(&pInfo->Content, &timeStampReq.tsrocs.contentOTS.contentOTS);
        pdu = TimeStampRequestOTS_PDU;
        }
    else {
        Asn1X509SetAny(&pInfo->Content, &timeStampReq.tsr.content.content);
        pdu = TimeStampRequest_PDU;
        }

    if (pInfo->cAttribute > 0) {
        if (!Asn1X509SetAttributes(pInfo->cAttribute, pInfo->rgAttribute,
                &timeStampReq.tsr.attributesTS))
            goto ErrorReturn;
        timeStampReq.tsr.bit_mask |= attributesTS_present;
    }

    fResult = Asn1InfoEncodeEx(
        pdu,
        &timeStampReq,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

CommonReturn:
    Asn1X509FreeAttributes(&timeStampReq.tsr.attributesTS);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(Asn1X509SetEncodedObjIdError);
}


//+-------------------------------------------------------------------------
//  Decode the Time Stamp Request Info (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1TimeStampRequestInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    TimeStampRequest *pTimeStampReq = (TimeStampRequest *) pvAsn1Info;
    PCRYPT_TIME_STAMP_REQUEST_INFO pInfo =
        (PCRYPT_TIME_STAMP_REQUEST_INFO) pvStructInfo;

    OctetStringType *pOctetStringType = NULL;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRYPT_TIME_STAMP_REQUEST_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CRYPT_TIME_STAMP_REQUEST_INFO));

        // Update fields not needing extra memory after the CERT_INFO
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_TIME_STAMP_REQUEST_INFO);
    }

    Asn1X509GetEncodedObjId(   &pTimeStampReq->timeStampAlgorithm,
                        dwFlags,
                       &pInfo->pszTimeStampAlgorithm,
                       &pbExtra,
                       &lRemainExtra
                   );
    Asn1X509GetEncodedObjId(   &pTimeStampReq->content.contentType,
                        dwFlags,
                       &pInfo->pszContentType,
                       &pbExtra,
                       &lRemainExtra
                   );

    if(pTimeStampReq->content.bit_mask == content_present) {
    
        // OctetStrings will be smaller, so when doing byte counting go to
        // ANY which will requre more room for decode...
        if(pInfo && !strcmp(pInfo->pszContentType, szOID_RSA_data)) {

            if (!Asn1InfoDecodeAndAlloc(
                        OctetStringType_PDU,
                        (const unsigned char *) pTimeStampReq->content.content.encoded,
                        pTimeStampReq->content.content.length,
                        (void **) &pOctetStringType))
                    goto Asn1InfoDecodeAndAllocError;

            Asn1X509GetOctetString(pOctetStringType, dwFlags,
                &pInfo->Content, &pbExtra, &lRemainExtra);
        }
        else
            Asn1X509GetAny(&pTimeStampReq->content.content, dwFlags,
                &pInfo->Content, &pbExtra, &lRemainExtra);
    }

    if (pTimeStampReq->bit_mask & attributesTS_present) {
        Asn1X509GetAttributes(&pTimeStampReq->attributesTS, dwFlags,
            &pInfo->cAttribute, &pInfo->rgAttribute, &pbExtra, &lRemainExtra);
    }

    fResult = TRUE;

CommonReturn:
    Asn1InfoFree(OctetStringType_PDU, pOctetStringType);
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(Asn1InfoDecodeAndAllocError);
}

BOOL WINAPI Asn1TimeStampRequestInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        TimeStampRequest_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1TimeStampRequestInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Set/Free/Get CTL Usage object identifiers
//--------------------------------------------------------------------------
BOOL Asn1X509SetCtlUsage(
        IN PCTL_USAGE pUsage,
        OUT EnhancedKeyUsage *pAsn1
        )
{
    DWORD cId;
    LPSTR *ppszId;
    UsageIdentifier *pAsn1Id;

    pAsn1->count = 0;
    pAsn1->value = NULL;
    cId = pUsage->cUsageIdentifier;
    if (0 == cId)
        return TRUE;

    pAsn1Id = (UsageIdentifier *) PkiNonzeroAlloc(cId * sizeof(UsageIdentifier));
    if (pAsn1Id == NULL)
        return FALSE;

    pAsn1->count = cId;
    pAsn1->value = pAsn1Id;
    ppszId = pUsage->rgpszUsageIdentifier;
    for ( ; cId > 0; cId--, ppszId++, pAsn1Id++) {
        if (!Asn1X509SetEncodedObjId(*ppszId, pAsn1Id))
            return FALSE;
    }

    return TRUE;
}

void Asn1X509FreeCtlUsage(
        IN EnhancedKeyUsage *pAsn1)
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
}

void Asn1X509GetCtlUsage(
        IN EnhancedKeyUsage *pAsn1,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pUsage,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cId;
    UsageIdentifier *pAsn1Id;
    LPSTR *ppszId;

    cId = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cId * sizeof(LPSTR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pUsage->cUsageIdentifier = cId;
        ppszId = (LPSTR *) pbExtra;
        pUsage->rgpszUsageIdentifier = ppszId;
        pbExtra += lAlignExtra;
    } else
        ppszId = NULL;

    pAsn1Id = pAsn1->value;
    for ( ; cId > 0; cId--, pAsn1Id++, ppszId++)
        Asn1X509GetEncodedObjId(pAsn1Id, dwFlags, ppszId, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  CTL Usage (Enhanced Key Usage) Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CtlUsageEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_USAGE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    EnhancedKeyUsage Asn1Info;

    if (!Asn1X509SetCtlUsage(pInfo, &Asn1Info)) {
        if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
            *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
        fResult = FALSE;
    } else
        fResult = Asn1InfoEncodeEx(
            EnhancedKeyUsage_PDU,
            &Asn1Info,
            dwFlags,
            pEncodePara,
            pvEncoded,
            pcbEncoded
            );
    Asn1X509FreeCtlUsage(&Asn1Info);
    return fResult;
}

//+-------------------------------------------------------------------------
//  CTL Usage (Enhanced Key Usage) Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CtlUsageDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    EnhancedKeyUsage *pAsn1Info = (EnhancedKeyUsage *) pvAsn1Info;
    PCTL_USAGE pInfo = (PCTL_USAGE) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CTL_USAGE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CTL_USAGE);

    Asn1X509GetCtlUsage(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509CtlUsageDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        EnhancedKeyUsage_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CtlUsageDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CTL Entries
//--------------------------------------------------------------------------
BOOL Asn1X509SetCtlEntries(
        IN DWORD cEntry,
        IN PCTL_ENTRY pEntry,
        OUT TrustedSubjects *pAsn1
        )
{
    TrustedSubject *pAsn1Entry;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cEntry == 0)
        return TRUE;

    pAsn1Entry = (TrustedSubject *) PkiZeroAlloc(
        cEntry * sizeof(TrustedSubject));
    if (pAsn1Entry == NULL)
        return FALSE;
    pAsn1->value = pAsn1Entry;
    pAsn1->count = cEntry;

    for ( ; cEntry > 0; cEntry--, pEntry++, pAsn1Entry++) {
        Asn1X509SetOctetString(&pEntry->SubjectIdentifier,
            &pAsn1Entry->subjectIdentifier);
        if (pEntry->cAttribute > 0) {
            pAsn1Entry->bit_mask |= subjectAttributes_present;

            if (!Asn1X509SetAttributes(pEntry->cAttribute, pEntry->rgAttribute,
                    &pAsn1Entry->subjectAttributes))
                return FALSE;
        }
    }
    return TRUE;
}

void Asn1X509FreeCtlEntries(
        IN TrustedSubjects *pAsn1)
{
    if (pAsn1->value) {
        DWORD cEntry = pAsn1->count;
        TrustedSubject *pAsn1Entry = pAsn1->value;
        for ( ; cEntry > 0; cEntry--, pAsn1Entry++)
            Asn1X509FreeAttributes(&pAsn1Entry->subjectAttributes);
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1X509GetCtlEntries(
        IN TrustedSubjects *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcEntry,
        OUT PCTL_ENTRY *ppEntry,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cEntry;
    TrustedSubject *pAsn1Entry;
    PCTL_ENTRY pEntry;

    cEntry = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cEntry * sizeof(CTL_ENTRY));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcEntry = cEntry;
        pEntry = (PCTL_ENTRY) pbExtra;
        memset(pEntry, 0, cEntry * sizeof(CTL_ENTRY));
        *ppEntry = pEntry;
        pbExtra += lAlignExtra;
    } else
        pEntry = NULL;

    pAsn1Entry = pAsn1->value;
    for ( ; cEntry > 0; cEntry--, pAsn1Entry++, pEntry++) {
        // SubjectIdentifier
        Asn1X509GetOctetString(&pAsn1Entry->subjectIdentifier, dwFlags,
                &pEntry->SubjectIdentifier, &pbExtra, &lRemainExtra);

        // Attributes
        if (pAsn1Entry->bit_mask & subjectAttributes_present) {
            Asn1X509GetAttributes(&pAsn1Entry->subjectAttributes, dwFlags,
                &pEntry->cAttribute, &pEntry->rgAttribute,
                &pbExtra, &lRemainExtra);
        }
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Encode the CTL Info (ASN1 X509 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CtlInfoEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCTL_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CertificateTrustList Ctl;

    memset(&Ctl, 0, sizeof(Ctl));

    if (pInfo->dwVersion != 0) {
#ifdef OSS_CRYPT_ASN1
        Ctl.CertificateTrustList_version = pInfo->dwVersion;
#else
        Ctl.version = pInfo->dwVersion;
#endif  // OSS_CRYPT_ASN1
        Ctl.bit_mask |= CertificateTrustList_version_present;
    }
    if (!Asn1X509SetCtlUsage(&pInfo->SubjectUsage, &Ctl.subjectUsage))
        goto ErrorReturn;
    if (pInfo->ListIdentifier.cbData) {
        Asn1X509SetOctetString(&pInfo->ListIdentifier, &Ctl.listIdentifier);
        Ctl.bit_mask |= listIdentifier_present;
    }
    if (pInfo->SequenceNumber.cbData) {
        if (!Asn1X509SetHugeInteger(&pInfo->SequenceNumber,
                &Ctl.sequenceNumber))
            goto ErrorReturn;
        Ctl.bit_mask |= sequenceNumber_present;
    }
    if (!PkiAsn1ToChoiceOfTime(&pInfo->ThisUpdate, 
            &Ctl.ctlThisUpdate.choice,
            &Ctl.ctlThisUpdate.u.generalTime,
            &Ctl.ctlThisUpdate.u.utcTime
            ))
        goto EncodeError;
    if (pInfo->NextUpdate.dwLowDateTime || pInfo->NextUpdate.dwHighDateTime) {
        Ctl.bit_mask |= ctlNextUpdate_present;
        if (!PkiAsn1ToChoiceOfTime(&pInfo->NextUpdate, 
                &Ctl.ctlNextUpdate.choice,
                &Ctl.ctlNextUpdate.u.generalTime,
                &Ctl.ctlNextUpdate.u.utcTime
                ))
            goto EncodeError;
    }
    if (!Asn1X509SetAlgorithm(&pInfo->SubjectAlgorithm, &Ctl.subjectAlgorithm))
        goto ErrorReturn;
    if (pInfo->cCTLEntry) {
        if (!Asn1X509SetCtlEntries(pInfo->cCTLEntry, pInfo->rgCTLEntry,
                &Ctl.trustedSubjects))
            goto ErrorReturn;
        Ctl.bit_mask |= trustedSubjects_present;
    }
    if (pInfo->cExtension) {
        if (!Asn1X509SetExtensions(pInfo->cExtension, pInfo->rgExtension,
                &Ctl.ctlExtensions))
            goto ErrorReturn;
        Ctl.bit_mask |= ctlExtensions_present;
    }

    fResult = Asn1InfoEncodeEx(
        CertificateTrustList_PDU,
        &Ctl,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

EncodeError:
    SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeCtlUsage(&Ctl.subjectUsage);
    Asn1X509FreeHugeInteger(&Ctl.sequenceNumber);
    Asn1X509FreeCtlEntries(&Ctl.trustedSubjects);
    Asn1X509FreeExtensions(&Ctl.ctlExtensions);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode the CTL Info (ASN1 X509 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CtlInfoDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CertificateTrustList *pCtl = (CertificateTrustList *) pvAsn1Info;
    PCTL_INFO pInfo = (PCTL_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CTL_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CTL_INFO));

        // Update fields not needing extra memory after the CTL_INFO
        if (pCtl->bit_mask &
                CertificateTrustList_version_present)
#ifdef OSS_CRYPT_ASN1
            pInfo->dwVersion =
                pCtl->CertificateTrustList_version;
#else
            pInfo->dwVersion = pCtl->version;
#endif  // OSS_CRYPT_ASN1
        if (!PkiAsn1FromChoiceOfTime(pCtl->ctlThisUpdate.choice,
                &pCtl->ctlThisUpdate.u.generalTime,
                &pCtl->ctlThisUpdate.u.utcTime,
                &pInfo->ThisUpdate))
            goto DecodeError;
        if (pCtl->bit_mask & ctlNextUpdate_present) {
            if (!PkiAsn1FromChoiceOfTime(pCtl->ctlNextUpdate.choice,
                    &pCtl->ctlNextUpdate.u.generalTime,
                    &pCtl->ctlNextUpdate.u.utcTime,
                    &pInfo->NextUpdate))
                goto DecodeError;
        }

        pbExtra = (BYTE *) pInfo + sizeof(CTL_INFO);
    }

    Asn1X509GetCtlUsage(&pCtl->subjectUsage, dwFlags,
            &pInfo->SubjectUsage, &pbExtra, &lRemainExtra);
    if (pCtl->bit_mask & listIdentifier_present)
        // Always copy to force alignment
        Asn1X509GetOctetString(&pCtl->listIdentifier,
                dwFlags & ~CRYPT_DECODE_NOCOPY_FLAG,
                &pInfo->ListIdentifier, &pbExtra, &lRemainExtra);
    if (pCtl->bit_mask & sequenceNumber_present)
        Asn1X509GetHugeInteger(&pCtl->sequenceNumber, dwFlags,
                &pInfo->SequenceNumber, &pbExtra, &lRemainExtra);
    Asn1X509GetAlgorithm(&pCtl->subjectAlgorithm, dwFlags,
            &pInfo->SubjectAlgorithm, &pbExtra, &lRemainExtra);
    if (pCtl->bit_mask & trustedSubjects_present)
        Asn1X509GetCtlEntries(&pCtl->trustedSubjects, dwFlags,
            &pInfo->cCTLEntry, &pInfo->rgCTLEntry, &pbExtra, &lRemainExtra);
    if (pCtl->bit_mask & ctlExtensions_present)
        Asn1X509GetExtensions(&pCtl->ctlExtensions, dwFlags,
            &pInfo->cExtension, &pInfo->rgExtension, &pbExtra, &lRemainExtra);

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(DecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1X509CtlInfoDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CertificateTrustList_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CtlInfoDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


BOOL WINAPI Asn1X509PKIXUserNoticeEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICY_QUALIFIER_USER_NOTICE pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    UserNotice Asn1Info;

    memset (&Asn1Info, 0, sizeof(Asn1Info));

    if (pInfo->pNoticeReference != NULL)
    {
        Asn1Info.bit_mask |= noticeRef_present;
        Asn1Info.noticeRef.organization = pInfo->pNoticeReference->pszOrganization;
        Asn1Info.noticeRef.noticeNumbers.count = pInfo->pNoticeReference->cNoticeNumbers;
#ifdef OSS_CRYPT_ASN1
        Asn1Info.noticeRef.noticeNumbers.value = pInfo->pNoticeReference->rgNoticeNumbers;
#else
        Asn1Info.noticeRef.noticeNumbers.value = (ASN1int32_t *) pInfo->pNoticeReference->rgNoticeNumbers;
#endif  // OSS_CRYPT_ASN1
    }

    if (pInfo->pszDisplayText)
    {
        Asn1Info.bit_mask |= explicitText_present;
        Asn1Info.explicitText.choice = theBMPString_chosen;
        Asn1Info.explicitText.u.theBMPString.length = wcslen(pInfo->pszDisplayText);
        Asn1Info.explicitText.u.theBMPString.value = (unsigned short *) pInfo->pszDisplayText;
    }
    
    fResult = Asn1InfoEncodeEx(
            UserNotice_PDU,
            &Asn1Info,
            dwFlags,
            pEncodePara,
            pvEncoded,
            pcbEncoded
            );
    
    return fResult;
}

BOOL WINAPI Asn1X509PKIXUserNoticeDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    UserNotice *pAsn1UserNotice = (UserNotice *) pvAsn1Info;
    PCERT_POLICY_QUALIFIER_USER_NOTICE pInfo =
        (PCERT_POLICY_QUALIFIER_USER_NOTICE) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_POLICY_QUALIFIER_USER_NOTICE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CERT_POLICY_QUALIFIER_USER_NOTICE));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_POLICY_QUALIFIER_USER_NOTICE);
    }

    // check to see if there is a notice reference
    if (pAsn1UserNotice->bit_mask & noticeRef_present)
    {
        lRemainExtra -= sizeof(CERT_POLICY_QUALIFIER_NOTICE_REFERENCE);
        if (lRemainExtra >= 0)
        {
            pInfo->pNoticeReference = (PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE) pbExtra;
            memset(pInfo->pNoticeReference, 0, sizeof(CERT_POLICY_QUALIFIER_NOTICE_REFERENCE));
            pbExtra += sizeof(CERT_POLICY_QUALIFIER_NOTICE_REFERENCE);
        }

        lRemainExtra -= INFO_LEN_ALIGN(strlen(pAsn1UserNotice->noticeRef.organization)+1);
        if (lRemainExtra >= 0)
        {
            pInfo->pNoticeReference->pszOrganization = (LPSTR) pbExtra;
            strcpy(pInfo->pNoticeReference->pszOrganization, pAsn1UserNotice->noticeRef.organization);
            pbExtra += INFO_LEN_ALIGN(strlen(pAsn1UserNotice->noticeRef.organization)+1);
        }

        lRemainExtra -= pAsn1UserNotice->noticeRef.noticeNumbers.count * sizeof(int);
        if (lRemainExtra >= 0)
        {   
            pInfo->pNoticeReference->cNoticeNumbers = pAsn1UserNotice->noticeRef.noticeNumbers.count;
            pInfo->pNoticeReference->rgNoticeNumbers = (int *) pbExtra;
            memcpy(
                pInfo->pNoticeReference->rgNoticeNumbers, 
                pAsn1UserNotice->noticeRef.noticeNumbers.value, 
                pAsn1UserNotice->noticeRef.noticeNumbers.count * sizeof(int));
            pbExtra += pAsn1UserNotice->noticeRef.noticeNumbers.count * sizeof(int);
        }
    }
    else if (lRemainExtra >= 0)
    {
        pInfo->pNoticeReference = NULL;
    }

    // check to see if there is a notice reference
    if (pAsn1UserNotice->bit_mask & explicitText_present)
    {
        // check whether it is a visible or bmp string
        if (pAsn1UserNotice->explicitText.choice & theVisibleString_chosen)
        {
            lRemainExtra -= (strlen(pAsn1UserNotice->explicitText.u.theVisibleString)+1) * sizeof(WCHAR);
            if (lRemainExtra >= 0)
            {
                pInfo->pszDisplayText = (LPWSTR) pbExtra;
                MultiByteToWideChar(
                    CP_ACP, 
                    0, 
                    pAsn1UserNotice->explicitText.u.theVisibleString,
                    -1,
                    pInfo->pszDisplayText,
                    (strlen(pAsn1UserNotice->explicitText.u.theVisibleString)+1));
                pbExtra += (strlen(pAsn1UserNotice->explicitText.u.theVisibleString)+1) * sizeof(WCHAR);
            }
        }
        else if (pAsn1UserNotice->explicitText.choice & theBMPString_chosen)
        {
            lRemainExtra -= (pAsn1UserNotice->explicitText.u.theBMPString.length + 1) * sizeof(WCHAR);
            if (lRemainExtra >= 0)
            {
                pInfo->pszDisplayText = (LPWSTR) pbExtra;
                memcpy(
                    (void *)pInfo->pszDisplayText, 
                    pAsn1UserNotice->explicitText.u.theBMPString.value,
                    pAsn1UserNotice->explicitText.u.theBMPString.length * sizeof(WCHAR));
                pInfo->pszDisplayText[pAsn1UserNotice->explicitText.u.theBMPString.length] = 0;
                pbExtra += (pAsn1UserNotice->explicitText.u.theBMPString.length + 1) * sizeof(WCHAR);
            }
        }
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509PKIXUserNoticeDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        UserNotice_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509PKIXUserNoticeDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  Encode Attributes (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AttributesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ATTRIBUTES pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    Attributes Asn1Info;

    if (!Asn1X509SetAttributes(pInfo->cAttr, pInfo->rgAttr,
            &Asn1Info))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        Attributes_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    Asn1X509FreeAttributes(&Asn1Info);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode Attributes (ASN1 X509 v3 ASN.1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509AttributesDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    Attributes *pAsn1Info = (Attributes *) pvAsn1Info;
    PCRYPT_ATTRIBUTES pInfo = (PCRYPT_ATTRIBUTES) pvStructInfo;
    BYTE *pbExtra;
    LONG lRemainExtra = *plRemainExtra;

    lRemainExtra -= sizeof(CRYPT_ATTRIBUTES);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_ATTRIBUTES);
    }

    Asn1X509GetAttributes(pAsn1Info, dwFlags,
            &pInfo->cAttr, &pInfo->rgAttr, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509AttributesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        Attributes_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509AttributesDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Decode Enrollment Name Value Pair Authenticated Attributes in RA PKCS7s
//--------------------------------------------------------------------------

BOOL WINAPI Asn1NameValueDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    EnrollmentNameValuePair *pAsn1Info = (EnrollmentNameValuePair *) pvAsn1Info;
    PCRYPT_ENROLLMENT_NAME_VALUE_PAIR pNameValuePair = (PCRYPT_ENROLLMENT_NAME_VALUE_PAIR) pvStructInfo;
    BYTE *pbExtra;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;

    lRemainExtra -= sizeof(CRYPT_ENROLLMENT_NAME_VALUE_PAIR);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        pbExtra = (BYTE *) pNameValuePair + sizeof(CRYPT_ENROLLMENT_NAME_VALUE_PAIR);
    }

    lAlignExtra = INFO_LEN_ALIGN(sizeof(CRYPT_ENROLLMENT_NAME_VALUE_PAIR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pbExtra += lAlignExtra;
    }

    PkiAsn1GetBMPString(
        pAsn1Info->name.length,
        pAsn1Info->name.value,
        0,
        &pNameValuePair->pwszName,
        &pbExtra,
        &lRemainExtra
        );
        
    PkiAsn1GetBMPString(
        pAsn1Info->value.length,
        pAsn1Info->value.value,
        0,
        &pNameValuePair->pwszValue,
        &pbExtra,
        &lRemainExtra
        );

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1NameValueDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        EnrollmentNameValuePair_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1NameValueDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode Name Value Pair Authenticated Attributes in RA PKCS7s
//--------------------------------------------------------------------------
BOOL WINAPI Asn1NameValueEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ENROLLMENT_NAME_VALUE_PAIR pNameValue,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    EnrollmentNameValuePair NameValue;

    NameValue.name.length = wcslen(pNameValue->pwszName);
    NameValue.name.value  = pNameValue->pwszName;
    
    NameValue.value.length = wcslen(pNameValue->pwszValue);
    NameValue.value.value  = pNameValue->pwszValue;
    
    fResult = Asn1InfoEncodeEx(
        EnrollmentNameValuePair_PDU,
        &NameValue,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
        
    if (!fResult && (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)) {
        *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode CSP Provider Attribute
//--------------------------------------------------------------------------

BOOL WINAPI Asn1CSPProviderDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    CSPProvider *pAsn1Info = (CSPProvider *) pvAsn1Info;
    PCRYPT_CSP_PROVIDER pCSPProvider = (PCRYPT_CSP_PROVIDER) pvStructInfo;
    BYTE *pbExtra;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;

    lRemainExtra -= sizeof(CRYPT_CSP_PROVIDER);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        pbExtra = (BYTE *) pCSPProvider + sizeof(CRYPT_CSP_PROVIDER);
    }

    lAlignExtra = INFO_LEN_ALIGN(sizeof(CRYPT_CSP_PROVIDER));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pbExtra += lAlignExtra;
    }

    pCSPProvider->dwKeySpec = (DWORD) pAsn1Info->keySpec;
    
    PkiAsn1GetBMPString(
        pAsn1Info->cspName.length,
        pAsn1Info->cspName.value,
        0,
        &pCSPProvider->pwszProviderName,
        &pbExtra,
        &lRemainExtra
        );

    Asn1X509GetBit(
            &pAsn1Info->signature,
            dwFlags,
            &pCSPProvider->Signature,
            &pbExtra,
            &lRemainExtra
            );
            
    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1CSPProviderDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CSPProvider_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CSPProviderDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Encode CSP Provider Attribute
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CSPProviderEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_CSP_PROVIDER pCSPProvider,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CSPProvider CspProvider;

    CspProvider.keySpec = (int) pCSPProvider->dwKeySpec;
    CspProvider.cspName.length = wcslen(pCSPProvider->pwszProviderName);
    CspProvider.cspName.value  = pCSPProvider->pwszProviderName;
    
     Asn1X509SetBit(
        &pCSPProvider->Signature,
        &CspProvider.signature
        );

    fResult = Asn1InfoEncodeEx(
        CSPProvider_PDU,
        &CspProvider,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    if (!fResult && (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)) {
        *((void **) pvEncoded) = NULL;
        *pcbEncoded = 0;
    }

    return fResult;
}


//+-------------------------------------------------------------------------
//  Certificate Pair Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertPairEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_PAIR pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    CertificatePair Asn1CertificatePair;
    memset(&Asn1CertificatePair, 0, sizeof(Asn1CertificatePair));

    if (pInfo->Forward.cbData) {
        Asn1X509SetAny(&pInfo->Forward, &Asn1CertificatePair.forward);
        Asn1CertificatePair.bit_mask |= forward_present;
    }

    if (pInfo->Reverse.cbData) {
        Asn1X509SetAny(&pInfo->Reverse, &Asn1CertificatePair.reverse);
        Asn1CertificatePair.bit_mask |= reverse_present;
    }

    return Asn1InfoEncodeEx(
        CertificatePair_PDU,
        &Asn1CertificatePair,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Certificate Pair Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CertPairDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    CertificatePair *pCertificatePair = (CertificatePair *) pvAsn1Info;
    PCERT_PAIR pInfo =
        (PCERT_PAIR) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_PAIR);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CERT_PAIR));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_PAIR);
    }

    if (pCertificatePair->bit_mask & forward_present)
        Asn1X509GetAny(&pCertificatePair->forward, dwFlags,
            &pInfo->Forward, &pbExtra, &lRemainExtra);
    if (pCertificatePair->bit_mask & reverse_present)
        Asn1X509GetAny(&pCertificatePair->reverse, dwFlags,
            &pInfo->Reverse, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509CertPairDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CertificatePair_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CertPairDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Set/Free/Get NameConstraints Subtree
//--------------------------------------------------------------------------
BOOL Asn1X509SetNameConstraintsSubtree(
        IN DWORD cSubtree,
        IN PCERT_GENERAL_SUBTREE pSubtree,
        IN OUT GeneralSubtrees *pAsn1,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    DWORD i;
    GeneralSubtree *pAsn1Subtree;

    *pdwErrLocation = 0;

    assert(0 != cSubtree);
    if (NULL == (pAsn1Subtree = (GeneralSubtree *) PkiZeroAlloc(
            cSubtree * sizeof(GeneralSubtree))))
        goto ErrorReturn;

    pAsn1->count = cSubtree;
    pAsn1->value = pAsn1Subtree;

    for (i = 0; i < cSubtree; i++, pSubtree++, pAsn1Subtree++) {
        if (!Asn1X509SetAltNameEntry(&pSubtree->Base,
                &pAsn1Subtree->base,
                i,
                pdwErrLocation))
            goto ErrorReturn;
        if (0 < pSubtree->dwMinimum) {
            pAsn1Subtree->minimum = pSubtree->dwMinimum;
            pAsn1Subtree->bit_mask |= minimum_present;
        }

        if (pSubtree->fMaximum) {
            pAsn1Subtree->maximum = pSubtree->dwMaximum;
            pAsn1Subtree->bit_mask |= maximum_present;
        }
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

void Asn1X509FreeNameConstraintsSubtree(
        IN OUT GeneralSubtrees *pAsn1
        )
{
    DWORD cSubtree = pAsn1->count;
    GeneralSubtree *pAsn1Subtree = pAsn1->value;

    for ( ; cSubtree > 0; cSubtree--, pAsn1Subtree++)
        Asn1X509FreeAltNameEntry(&pAsn1Subtree->base);

    PkiFree(pAsn1->value);
}

BOOL Asn1X509GetNameConstraintsSubtree(
        IN GeneralSubtrees *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcSubtree,
        IN OUT PCERT_GENERAL_SUBTREE *ppSubtree,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    BYTE *pbExtra = *ppbExtra;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;

    DWORD cSubtree;
    GeneralSubtree *pAsn1Subtree;
    PCERT_GENERAL_SUBTREE pSubtree;

    cSubtree = pAsn1->count;
    if (0 == cSubtree)
        goto SuccessReturn;

    pAsn1Subtree = pAsn1->value;

    lAlignExtra = INFO_LEN_ALIGN(cSubtree * sizeof(CERT_GENERAL_SUBTREE));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra < 0) {
        pSubtree = NULL;
    } else {
        pSubtree = (PCERT_GENERAL_SUBTREE) pbExtra;
        memset(pSubtree, 0, lAlignExtra);
        *pcSubtree = cSubtree;
        *ppSubtree = pSubtree;
        pbExtra += lAlignExtra;
    }

    // Subtree Array entries
    for (; cSubtree > 0; cSubtree--, pSubtree++, pAsn1Subtree++) {
        if (!Asn1X509GetAltNameEntry(&pAsn1Subtree->base, dwFlags,
                &pSubtree->Base, &pbExtra, &lRemainExtra))
            goto ErrorReturn;
        if (lRemainExtra >= 0) {
            if (pAsn1Subtree->bit_mask & minimum_present) 
                pSubtree->dwMinimum = pAsn1Subtree->minimum;
            if (pAsn1Subtree->bit_mask & maximum_present) {
                pSubtree->fMaximum = TRUE;
                pSubtree->dwMaximum = pAsn1Subtree->maximum;
            }
        }
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    *ppbExtra = pbExtra;
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Name Constraints Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509NameConstraintsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_NAME_CONSTRAINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    NameConstraints Asn1Info;
    DWORD cSubtree;
    DWORD dwErrLocation;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;

    memset(&Asn1Info, 0, sizeof(Asn1Info));

    cSubtree = pInfo->cPermittedSubtree;
    if (0 < cSubtree) {
        if (!Asn1X509SetNameConstraintsSubtree(
                cSubtree,
                pInfo->rgPermittedSubtree,
                &Asn1Info.permittedSubtrees,
                &dwErrLocation))
            goto SubtreeError;
        Asn1Info.bit_mask |= permittedSubtrees_present;
    }

    cSubtree = pInfo->cExcludedSubtree;
    if (0 < cSubtree) {
        if (!Asn1X509SetNameConstraintsSubtree(
                cSubtree,
                pInfo->rgExcludedSubtree,
                &Asn1Info.excludedSubtrees,
                &dwErrLocation)) {
            if (0 != dwErrLocation)
                dwErrLocation |= CERT_EXCLUDED_SUBTREE_BIT;
            goto SubtreeError;
        }
        Asn1Info.bit_mask |= excludedSubtrees_present;
    }

    fResult = Asn1InfoEncodeEx(
        NameConstraints_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    Asn1X509FreeNameConstraintsSubtree(&Asn1Info.permittedSubtrees);
    Asn1X509FreeNameConstraintsSubtree(&Asn1Info.excludedSubtrees);
    return fResult;

SubtreeError:
    *pcbEncoded = dwErrLocation;
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Name Constraints Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509NameConstraintsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    NameConstraints *pAsn1 = (NameConstraints *) pvAsn1Info;
    PCERT_NAME_CONSTRAINTS_INFO pInfo =
        (PCERT_NAME_CONSTRAINTS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_NAME_CONSTRAINTS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CERT_NAME_CONSTRAINTS_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_NAME_CONSTRAINTS_INFO);
    }

    if (pAsn1->bit_mask & permittedSubtrees_present) {
        if (!Asn1X509GetNameConstraintsSubtree(
                &pAsn1->permittedSubtrees,
                dwFlags,
                &pInfo->cPermittedSubtree,
                &pInfo->rgPermittedSubtree,
                &pbExtra,
                &lRemainExtra
                )) goto ErrorReturn;
    }

    if (pAsn1->bit_mask & excludedSubtrees_present) {
        if (!Asn1X509GetNameConstraintsSubtree(
                &pAsn1->excludedSubtrees,
                dwFlags,
                &pInfo->cExcludedSubtree,
                &pInfo->rgExcludedSubtree,
                &pbExtra,
                &lRemainExtra
                )) goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}



BOOL WINAPI Asn1X509NameConstraintsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        NameConstraints_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509NameConstraintsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  CRL Issuing Distribution Point Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrlIssuingDistPointEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRL_ISSUING_DIST_POINT pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    IssuingDistributionPoint Asn1Info;
    DistributionPointName *pAsn1DistPointName;
    PCRL_DIST_POINT_NAME pDistPointName;
    DWORD dwErrLocation;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;

    memset(&Asn1Info, 0, sizeof(Asn1Info));

    pDistPointName = &pInfo->DistPointName;
    if (CRL_DIST_POINT_NO_NAME !=
            pDistPointName->dwDistPointNameChoice) {
        pAsn1DistPointName = &Asn1Info.issuingDistributionPoint;

        Asn1Info.bit_mask |= issuingDistributionPoint_present;
        pAsn1DistPointName->choice = (unsigned short)
            pDistPointName->dwDistPointNameChoice;
        
        assert(fullName_chosen == CRL_DIST_POINT_FULL_NAME);
        assert(nameRelativeToCRLIssuer_chosen ==
            CRL_DIST_POINT_ISSUER_RDN_NAME);

        switch (pDistPointName->dwDistPointNameChoice) {
            case CRL_DIST_POINT_FULL_NAME:
                if (!Asn1X509SetAltNames(
                        &pDistPointName->FullName,
                        &pAsn1DistPointName->u.fullName, 0, &dwErrLocation))
                    goto AltNamesError;
                break;
            case CRL_DIST_POINT_ISSUER_RDN_NAME:
            default:
                goto InvalidArg;
        }
    }

    if (pInfo->fOnlyContainsUserCerts) {
        Asn1Info.bit_mask |= onlyContainsUserCerts_present;
        Asn1Info.onlyContainsUserCerts = TRUE;
    }
    if (pInfo->fOnlyContainsCACerts) {
        Asn1Info.bit_mask |= onlyContainsCACerts_present;
        Asn1Info.onlyContainsCACerts = TRUE;
    }
    if (pInfo->fIndirectCRL) {
        Asn1Info.bit_mask |= indirectCRL_present;
        Asn1Info.indirectCRL = TRUE;
    }

    if (pInfo->OnlySomeReasonFlags.cbData) {
        Asn1Info.bit_mask |= onlySomeReasons_present;
        Asn1X509SetBitWithoutTrailingZeroes(&pInfo->OnlySomeReasonFlags,
            &Asn1Info.onlySomeReasons);
    }

    fResult = Asn1InfoEncodeEx(
        IssuingDistributionPoint_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    pAsn1DistPointName = &Asn1Info.issuingDistributionPoint;
    switch (pAsn1DistPointName->choice) {
        case CRL_DIST_POINT_FULL_NAME:
            Asn1X509FreeAltNames(&pAsn1DistPointName->u.fullName);
            break;
        case CRL_DIST_POINT_ISSUER_RDN_NAME:
        default:
            break;
    }
    return fResult;

AltNamesError:
    *pcbEncoded = dwErrLocation;
    goto ErrorReturn;

InvalidArg:
    SetLastError((DWORD) E_INVALIDARG);
    *pcbEncoded = 0;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  CRL Issuing Distribution Point Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrlIssuingDistPointDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    IssuingDistributionPoint *pAsn1 = (IssuingDistributionPoint *) pvAsn1Info;
    PCRL_ISSUING_DIST_POINT pInfo = (PCRL_ISSUING_DIST_POINT) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CRL_ISSUING_DIST_POINT);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CRL_ISSUING_DIST_POINT));
        pbExtra = (BYTE *) pInfo + sizeof(CRL_ISSUING_DIST_POINT);

        if (pAsn1->bit_mask & onlyContainsUserCerts_present)
            pInfo->fOnlyContainsUserCerts =
                (BOOL) pAsn1->onlyContainsUserCerts;
        if (pAsn1->bit_mask & onlyContainsCACerts_present)
            pInfo->fOnlyContainsCACerts = (BOOL) pAsn1->onlyContainsCACerts;
        if (pAsn1->bit_mask & indirectCRL_present)
            pInfo->fIndirectCRL = (BOOL) pAsn1->indirectCRL;
    }

    if (pAsn1->bit_mask & issuingDistributionPoint_present) {
        DistributionPointName *pAsn1DistPointName =
            &pAsn1->issuingDistributionPoint;
        DWORD dwDistPointNameChoice = pAsn1DistPointName->choice;
        PCRL_DIST_POINT_NAME pDistPointName;

        if (lRemainExtra >= 0) {
            pDistPointName = &pInfo->DistPointName;
            pDistPointName->dwDistPointNameChoice =
                dwDistPointNameChoice;
        } else
            pDistPointName = NULL;

        assert(fullName_chosen == CRL_DIST_POINT_FULL_NAME);
        assert(nameRelativeToCRLIssuer_chosen ==
            CRL_DIST_POINT_ISSUER_RDN_NAME);

        switch (dwDistPointNameChoice) {
            case CRL_DIST_POINT_FULL_NAME:
                if (!Asn1X509GetAltNames(&pAsn1DistPointName->u.fullName,
                        dwFlags, &pDistPointName->FullName,
                        &pbExtra, &lRemainExtra))
                    goto ErrorReturn;
                break;
            case CRL_DIST_POINT_ISSUER_RDN_NAME:
                break;
            default:
                SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
                goto ErrorReturn;
        }
    }

    if (pAsn1->bit_mask & onlySomeReasons_present)
        Asn1X509GetBit(&pAsn1->onlySomeReasons, dwFlags,
                &pInfo->OnlySomeReasonFlags, &pbExtra, &lRemainExtra);

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL WINAPI Asn1X509CrlIssuingDistPointDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        IssuingDistributionPoint_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CrlIssuingDistPointDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Policy Mappings Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509PolicyMappingsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICY_MAPPINGS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    PolicyMappings Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (0 != pInfo->cPolicyMapping) {
        DWORD cMap = pInfo->cPolicyMapping;
        PCERT_POLICY_MAPPING pMap = pInfo->rgPolicyMapping;
        PolicyMapping *pAsn1Map;
        
        if (NULL == (pAsn1Map = (PolicyMapping *) PkiZeroAlloc(
                cMap * sizeof(PolicyMapping))))
            goto ErrorReturn;

        Asn1Info.count = cMap;
        Asn1Info.value = pAsn1Map;
        for ( ; cMap > 0; cMap--, pMap++, pAsn1Map++) {
            if (!Asn1X509SetEncodedObjId(pMap->pszIssuerDomainPolicy,
                    &pAsn1Map->issuerDomainPolicy))
                goto ErrorReturn;
            if (!Asn1X509SetEncodedObjId(pMap->pszSubjectDomainPolicy,
                    &pAsn1Map->subjectDomainPolicy))
                goto ErrorReturn;
        }
    }

    fResult = Asn1InfoEncodeEx(
        PolicyMappings_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    PkiFree(Asn1Info.value);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Policy Mappings Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509PolicyMappingsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    PolicyMappings *pAsn1Info = (PolicyMappings *) pvAsn1Info;
    PCERT_POLICY_MAPPINGS_INFO pInfo =
        (PCERT_POLICY_MAPPINGS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;
    DWORD cMap;
    PolicyMapping *pAsn1Map;
    PCERT_POLICY_MAPPING pMap;

    cMap = pAsn1Info->count;
    lAlignExtra = cMap * sizeof(CERT_POLICY_MAPPING);

    lRemainExtra -= sizeof(CERT_POLICY_MAPPINGS_INFO) + lAlignExtra;
    if (lRemainExtra < 0) {
        pbExtra = NULL;
        pMap = NULL;
    } else {
        pbExtra = (BYTE *) pInfo + sizeof(CERT_POLICY_MAPPINGS_INFO);
        pMap = (PCERT_POLICY_MAPPING) pbExtra;
        pInfo->cPolicyMapping = cMap;
        pInfo->rgPolicyMapping = pMap;
        if (lAlignExtra) {
            memset(pbExtra, 0, lAlignExtra);
            pbExtra += lAlignExtra;
        }
    }

    pAsn1Map = pAsn1Info->value;
    for ( ; cMap > 0; cMap--, pAsn1Map++, pMap++) {
        Asn1X509GetEncodedObjId(&pAsn1Map->issuerDomainPolicy, dwFlags,
            &pMap->pszIssuerDomainPolicy, &pbExtra, &lRemainExtra);
        Asn1X509GetEncodedObjId(&pAsn1Map->subjectDomainPolicy, dwFlags,
            &pMap->pszSubjectDomainPolicy, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509PolicyMappingsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        PolicyMappings_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509PolicyMappingsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Policy Constraints Extension Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509PolicyConstraintsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_POLICY_CONSTRAINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    PolicyConstraints Asn1Info;
    memset(&Asn1Info, 0, sizeof(Asn1Info));

    if (pInfo->fRequireExplicitPolicy) {
        Asn1Info.requireExplicitPolicy =
            pInfo->dwRequireExplicitPolicySkipCerts;
        Asn1Info.bit_mask |= requireExplicitPolicy_present;
    }

    if (pInfo->fInhibitPolicyMapping) {
        Asn1Info.inhibitPolicyMapping =
            pInfo->dwInhibitPolicyMappingSkipCerts;
        Asn1Info.bit_mask |= inhibitPolicyMapping_present;
    }

    return Asn1InfoEncodeEx(
        PolicyConstraints_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Policy Constraints  Extension Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509PolicyConstraintsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    PolicyConstraints *pAsn1Info = (PolicyConstraints *) pvAsn1Info;
    PCERT_POLICY_CONSTRAINTS_INFO pInfo =
        (PCERT_POLICY_CONSTRAINTS_INFO) pvStructInfo;

    *plRemainExtra -= sizeof(CERT_POLICY_CONSTRAINTS_INFO);
    if (*plRemainExtra >= 0) {
        memset(pInfo, 0, sizeof(CERT_POLICY_CONSTRAINTS_INFO));

        if (pAsn1Info->bit_mask & requireExplicitPolicy_present) {
            pInfo->fRequireExplicitPolicy = TRUE;
            pInfo->dwRequireExplicitPolicySkipCerts =
                pAsn1Info->requireExplicitPolicy;
        }

        if (pAsn1Info->bit_mask & inhibitPolicyMapping_present) {
            pInfo->fInhibitPolicyMapping = TRUE;
            pInfo->dwInhibitPolicyMappingSkipCerts =
                pAsn1Info->inhibitPolicyMapping;
        }
    }
    return TRUE;
}

BOOL WINAPI Asn1X509PolicyConstraintsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        PolicyConstraints_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509PolicyConstraintsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Cross Cert Distribution Points Encode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrossCertDistPointsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCROSS_CERT_DIST_POINTS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CrossCertDistPoints Asn1Info;
    GeneralNames *pAsn1DistPoint;
    PCERT_ALT_NAME_INFO pDistPoint;
    DWORD cDistPoint;
    DWORD i;
    DWORD dwErrLocation;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (pInfo->dwSyncDeltaTime) {
        Asn1Info.syncDeltaTime = pInfo->dwSyncDeltaTime;
        Asn1Info.bit_mask |= syncDeltaTime_present;
    }

    cDistPoint = pInfo->cDistPoint;
    if (0 < cDistPoint) {
        if (NULL == (pAsn1DistPoint = (GeneralNames *) PkiZeroAlloc(
                cDistPoint * sizeof(GeneralNames))))
            goto ErrorReturn;
        Asn1Info.crossCertDistPointNames.count = cDistPoint;
        Asn1Info.crossCertDistPointNames.value = pAsn1DistPoint;

        pDistPoint = pInfo->rgDistPoint;
        for (i = 0; i < cDistPoint; i++, pDistPoint++, pAsn1DistPoint++) {
            if (!Asn1X509SetAltNames(
                    pDistPoint,
                    pAsn1DistPoint,
                    i,
                    &dwErrLocation))
                goto AltNamesError;
        }
    }

    fResult = Asn1InfoEncodeEx(
        CrossCertDistPoints_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    pAsn1DistPoint = Asn1Info.crossCertDistPointNames.value;
    if (pAsn1DistPoint) {
        cDistPoint = Asn1Info.crossCertDistPointNames.count;
        for ( ; cDistPoint > 0; cDistPoint--, pAsn1DistPoint++) {
            Asn1X509FreeAltNames(pAsn1DistPoint);
        }
        PkiFree(Asn1Info.crossCertDistPointNames.value);
    }
    return fResult;

AltNamesError:
    *pcbEncoded = dwErrLocation;
    fResult = FALSE;
    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Cross Cert Distribution Points Decode (ASN1 X509)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1X509CrossCertDistPointsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CrossCertDistPoints *pAsn1 = (CrossCertDistPoints *) pvAsn1Info;
    PCROSS_CERT_DIST_POINTS_INFO pInfo =
        (PCROSS_CERT_DIST_POINTS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;
    LONG lAlignExtra;

    lRemainExtra -= sizeof(CROSS_CERT_DIST_POINTS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CROSS_CERT_DIST_POINTS_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CROSS_CERT_DIST_POINTS_INFO);

        if (pAsn1->bit_mask & syncDeltaTime_present)
            pInfo->dwSyncDeltaTime = pAsn1->syncDeltaTime;
    }

    if (pAsn1->crossCertDistPointNames.count) {
        DWORD cDistPoint = pAsn1->crossCertDistPointNames.count;
        GeneralNames *pAsn1DistPoint = pAsn1->crossCertDistPointNames.value;
        PCERT_ALT_NAME_INFO pDistPoint;

        lAlignExtra = INFO_LEN_ALIGN(cDistPoint * sizeof(CERT_ALT_NAME_INFO));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pDistPoint = (PCERT_ALT_NAME_INFO) pbExtra;
            memset(pDistPoint, 0, cDistPoint * sizeof(CERT_ALT_NAME_INFO));
            pInfo->cDistPoint = cDistPoint;
            pInfo->rgDistPoint = pDistPoint;
            pbExtra += lAlignExtra;
        } else
            pDistPoint = NULL;

        for ( ; cDistPoint > 0; cDistPoint--, pAsn1DistPoint++, pDistPoint++) {
            if (!Asn1X509GetAltNames(pAsn1DistPoint, dwFlags, pDistPoint,
                    &pbExtra, &lRemainExtra))
                goto ErrorReturn;
        }
    }

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL WINAPI Asn1X509CrossCertDistPointsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CrossCertDistPoints_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CrossCertDistPointsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+=========================================================================
//  Certificate Management Messages over CMS (CMC) Encode/Decode Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Set/Free/Get CMC Tagged Attributes
//--------------------------------------------------------------------------
BOOL Asn1CmcSetTaggedAttributes(
        IN DWORD cTaggedAttr,
        IN PCMC_TAGGED_ATTRIBUTE pTaggedAttr,
        OUT ControlSequence *pAsn1
        )
{
    TaggedAttribute *pAsn1Attr;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cTaggedAttr == 0)
        return TRUE;

    pAsn1Attr = (TaggedAttribute *) PkiZeroAlloc(
        cTaggedAttr * sizeof(TaggedAttribute));
    if (pAsn1Attr == NULL)
        return FALSE;
    pAsn1->value = pAsn1Attr;
    pAsn1->count = cTaggedAttr;

    for ( ; cTaggedAttr > 0; cTaggedAttr--, pTaggedAttr++, pAsn1Attr++) {
        pAsn1Attr->bodyPartID = pTaggedAttr->dwBodyPartID;
        if (!Asn1X509SetEncodedObjId(pTaggedAttr->Attribute.pszObjId,
                &pAsn1Attr->type))
            return FALSE;

        if (!Asn1X509SetSeqOfAny(
                pTaggedAttr->Attribute.cValue,
                pTaggedAttr->Attribute.rgValue,
                &pAsn1Attr->values.count,
                &pAsn1Attr->values.value))
            return FALSE;
    }
    return TRUE;
}

void Asn1CmcFreeTaggedAttributes(
        IN OUT ControlSequence *pAsn1
        )
{
    if (pAsn1->value) {
        TaggedAttribute *pAsn1Attr = pAsn1->value;
        DWORD cTaggedAttr = pAsn1->count;

        for ( ; cTaggedAttr > 0; cTaggedAttr--, pAsn1Attr++) {
            Asn1X509FreeSeqOfAny(pAsn1Attr->values.value);
        }
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1CmcGetTaggedAttributes(
        IN ControlSequence *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcTaggedAttr,
        OUT PCMC_TAGGED_ATTRIBUTE *ppTaggedAttr,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cTaggedAttr;
    TaggedAttribute *pAsn1Attr;
    PCMC_TAGGED_ATTRIBUTE pTaggedAttr;

    cTaggedAttr = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cTaggedAttr * sizeof(CMC_TAGGED_ATTRIBUTE));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcTaggedAttr = cTaggedAttr;
        pTaggedAttr = (PCMC_TAGGED_ATTRIBUTE) pbExtra;
        *ppTaggedAttr = pTaggedAttr;
        pbExtra += lAlignExtra;
    } else
        pTaggedAttr = NULL;

    pAsn1Attr = pAsn1->value;
    for ( ; cTaggedAttr > 0; cTaggedAttr--, pAsn1Attr++, pTaggedAttr++) {
        if (lRemainExtra >= 0) {
            pTaggedAttr->dwBodyPartID = pAsn1Attr->bodyPartID;
        }
        Asn1X509GetEncodedObjId(&pAsn1Attr->type, dwFlags,
            &pTaggedAttr->Attribute.pszObjId, &pbExtra, &lRemainExtra);
        Asn1X509GetSeqOfAny(
            pAsn1Attr->values.count, pAsn1Attr->values.value, dwFlags,
            &pTaggedAttr->Attribute.cValue, &pTaggedAttr->Attribute.rgValue,
            &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CMC Tagged Requests
//--------------------------------------------------------------------------
BOOL Asn1CmcSetTaggedRequests(
        IN DWORD cTaggedReq,
        IN PCMC_TAGGED_REQUEST pTaggedReq,
        OUT ReqSequence *pAsn1
        )
{
    TaggedRequest *pAsn1Req;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cTaggedReq == 0)
        return TRUE;

    pAsn1Req = (TaggedRequest *) PkiZeroAlloc(
        cTaggedReq * sizeof(TaggedRequest));
    if (pAsn1Req == NULL)
        return FALSE;
    pAsn1->value = pAsn1Req;
    pAsn1->count = cTaggedReq;

    for ( ; cTaggedReq > 0; cTaggedReq--, pTaggedReq++, pAsn1Req++) {
        PCMC_TAGGED_CERT_REQUEST pTaggedCertReq;
        TaggedCertificationRequest *ptcr;

        if (CMC_TAGGED_CERT_REQUEST_CHOICE !=
                pTaggedReq->dwTaggedRequestChoice) {
            SetLastError((DWORD) E_INVALIDARG);
            return FALSE;
        }
        
        pAsn1Req->choice = tcr_chosen;
        ptcr = &pAsn1Req->u.tcr;
        pTaggedCertReq = pTaggedReq->pTaggedCertRequest;

        ptcr->bodyPartID = pTaggedCertReq->dwBodyPartID;
        Asn1X509SetAny(&pTaggedCertReq->SignedCertRequest,
            &ptcr->certificationRequest);
    }
    return TRUE;
}

void Asn1CmcFreeTaggedRequests(
        IN OUT ReqSequence *pAsn1
        )
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

BOOL Asn1CmcGetTaggedRequests(
        IN ReqSequence *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcTaggedReq,
        OUT PCMC_TAGGED_REQUEST *ppTaggedReq,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cTaggedReq;
    TaggedRequest *pAsn1Req;
    PCMC_TAGGED_REQUEST pTaggedReq;

    cTaggedReq = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cTaggedReq * sizeof(CMC_TAGGED_REQUEST));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcTaggedReq = cTaggedReq;
        pTaggedReq = (PCMC_TAGGED_REQUEST) pbExtra;
        *ppTaggedReq = pTaggedReq;
        pbExtra += lAlignExtra;
    } else
        pTaggedReq = NULL;

    pAsn1Req = pAsn1->value;
    for ( ; cTaggedReq > 0; cTaggedReq--, pAsn1Req++, pTaggedReq++) {
        PCMC_TAGGED_CERT_REQUEST pTaggedCertReq;
        TaggedCertificationRequest *ptcr;

        if (tcr_chosen != pAsn1Req->choice) {
            SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
            goto ErrorReturn;
        }

        ptcr = &pAsn1Req->u.tcr;

        lAlignExtra = INFO_LEN_ALIGN(sizeof(CMC_TAGGED_CERT_REQUEST));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pTaggedReq->dwTaggedRequestChoice =
                CMC_TAGGED_CERT_REQUEST_CHOICE;

            pTaggedCertReq = (PCMC_TAGGED_CERT_REQUEST) pbExtra;
            pbExtra += lAlignExtra;

            pTaggedReq->pTaggedCertRequest = pTaggedCertReq;
            pTaggedCertReq->dwBodyPartID = ptcr->bodyPartID;
        } else
            pTaggedCertReq = NULL;

        Asn1X509GetAny(&ptcr->certificationRequest, dwFlags,
            &pTaggedCertReq->SignedCertRequest, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CMC Tagged ContentInfo
//--------------------------------------------------------------------------
BOOL Asn1CmcSetTaggedContentInfos(
        IN DWORD cTaggedCI,
        IN PCMC_TAGGED_CONTENT_INFO pTaggedCI,
        OUT CmsSequence *pAsn1
        )
{
    TaggedContentInfo *pAsn1CI;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cTaggedCI == 0)
        return TRUE;

    pAsn1CI = (TaggedContentInfo *) PkiZeroAlloc(
        cTaggedCI * sizeof(TaggedContentInfo));
    if (pAsn1CI == NULL)
        return FALSE;
    pAsn1->value = pAsn1CI;
    pAsn1->count = cTaggedCI;

    for ( ; cTaggedCI > 0; cTaggedCI--, pTaggedCI++, pAsn1CI++) {
        pAsn1CI->bodyPartID = pTaggedCI->dwBodyPartID;
        Asn1X509SetAny(&pTaggedCI->EncodedContentInfo, &pAsn1CI->contentInfo);
    }

    return TRUE;
}

void Asn1CmcFreeTaggedContentInfos(
        IN OUT CmsSequence *pAsn1
        )
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1CmcGetTaggedContentInfos(
        IN CmsSequence *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcTaggedCI,
        OUT PCMC_TAGGED_CONTENT_INFO *ppTaggedCI,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cTaggedCI;
    TaggedContentInfo *pAsn1CI;
    PCMC_TAGGED_CONTENT_INFO pTaggedCI;

    cTaggedCI = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cTaggedCI * sizeof(CMC_TAGGED_CONTENT_INFO));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcTaggedCI = cTaggedCI;
        pTaggedCI = (PCMC_TAGGED_CONTENT_INFO) pbExtra;
        *ppTaggedCI = pTaggedCI;
        pbExtra += lAlignExtra;
    } else
        pTaggedCI = NULL;

    pAsn1CI = pAsn1->value;
    for ( ; cTaggedCI > 0; cTaggedCI--, pAsn1CI++, pTaggedCI++) {
        if (lRemainExtra >= 0) {
            pTaggedCI->dwBodyPartID = pAsn1CI->bodyPartID;
        }

        Asn1X509GetAny(&pAsn1CI->contentInfo, dwFlags,
            &pTaggedCI->EncodedContentInfo, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get CMC Tagged OtherMsg
//--------------------------------------------------------------------------
BOOL Asn1CmcSetTaggedOtherMsgs(
        IN DWORD cTaggedOM,
        IN PCMC_TAGGED_OTHER_MSG pTaggedOM,
        OUT OtherMsgSequence *pAsn1
        )
{
    TaggedOtherMsg *pAsn1OM;

    pAsn1->value = NULL;
    pAsn1->count = 0;
    if (cTaggedOM == 0)
        return TRUE;

    pAsn1OM = (TaggedOtherMsg *) PkiZeroAlloc(
        cTaggedOM * sizeof(TaggedOtherMsg));
    if (pAsn1OM == NULL)
        return FALSE;
    pAsn1->value = pAsn1OM;
    pAsn1->count = cTaggedOM;

    for ( ; cTaggedOM > 0; cTaggedOM--, pTaggedOM++, pAsn1OM++) {
        pAsn1OM->bodyPartID = pTaggedOM->dwBodyPartID;

        if (!Asn1X509SetEncodedObjId(pTaggedOM->pszObjId,
                &pAsn1OM->otherMsgType))
            return FALSE;

        Asn1X509SetAny(&pTaggedOM->Value, &pAsn1OM->otherMsgValue);
    }

    return TRUE;
}

void Asn1CmcFreeTaggedOtherMsgs(
        IN OUT OtherMsgSequence *pAsn1
        )
{
    if (pAsn1->value) {
        PkiFree(pAsn1->value);
        pAsn1->value = NULL;
    }
    pAsn1->count = 0;
}

void Asn1CmcGetTaggedOtherMsgs(
        IN OtherMsgSequence *pAsn1,
        IN DWORD dwFlags,
        OUT DWORD *pcTaggedOM,
        OUT PCMC_TAGGED_OTHER_MSG *ppTaggedOM,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cTaggedOM;
    TaggedOtherMsg *pAsn1OM;
    PCMC_TAGGED_OTHER_MSG pTaggedOM;

    cTaggedOM = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cTaggedOM * sizeof(CMC_TAGGED_OTHER_MSG));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        *pcTaggedOM = cTaggedOM;
        pTaggedOM = (PCMC_TAGGED_OTHER_MSG) pbExtra;
        *ppTaggedOM = pTaggedOM;
        pbExtra += lAlignExtra;
    } else
        pTaggedOM = NULL;

    pAsn1OM = pAsn1->value;
    for ( ; cTaggedOM > 0; cTaggedOM--, pAsn1OM++, pTaggedOM++) {
        if (lRemainExtra >= 0) {
            pTaggedOM->dwBodyPartID = pAsn1OM->bodyPartID;
        }

        Asn1X509GetEncodedObjId(&pAsn1OM->otherMsgType, dwFlags,
            &pTaggedOM->pszObjId, &pbExtra, &lRemainExtra);

        Asn1X509GetAny(&pAsn1OM->otherMsgValue, dwFlags,
            &pTaggedOM->Value, &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  CMC Data Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcDataEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_DATA_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcData Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1CmcSetTaggedAttributes(pInfo->cTaggedAttribute,
            pInfo->rgTaggedAttribute, &Asn1Info.controlSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedRequests(pInfo->cTaggedRequest,
            pInfo->rgTaggedRequest, &Asn1Info.reqSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedContentInfos(pInfo->cTaggedContentInfo,
            pInfo->rgTaggedContentInfo, &Asn1Info.cmsSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedOtherMsgs(pInfo->cTaggedOtherMsg,
            pInfo->rgTaggedOtherMsg, &Asn1Info.otherMsgSequence))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        CmcData_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    Asn1CmcFreeTaggedAttributes(&Asn1Info.controlSequence);
    Asn1CmcFreeTaggedRequests(&Asn1Info.reqSequence);
    Asn1CmcFreeTaggedContentInfos(&Asn1Info.cmsSequence);
    Asn1CmcFreeTaggedOtherMsgs(&Asn1Info.otherMsgSequence);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  CMC Data Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcDataDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcData *pAsn1 = (CmcData *) pvAsn1Info;
    PCMC_DATA_INFO pInfo = (PCMC_DATA_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_DATA_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_DATA_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_DATA_INFO);
    }

    Asn1CmcGetTaggedAttributes(&pAsn1->controlSequence,
        dwFlags,
        &pInfo->cTaggedAttribute,
        &pInfo->rgTaggedAttribute,
        &pbExtra,
        &lRemainExtra
        );

    if (!Asn1CmcGetTaggedRequests(&pAsn1->reqSequence,
            dwFlags,
            &pInfo->cTaggedRequest,
            &pInfo->rgTaggedRequest,
            &pbExtra,
            &lRemainExtra
            ))
        goto ErrorReturn;

    Asn1CmcGetTaggedContentInfos(&pAsn1->cmsSequence,
        dwFlags,
        &pInfo->cTaggedContentInfo,
        &pInfo->rgTaggedContentInfo,
        &pbExtra,
        &lRemainExtra
        );

    Asn1CmcGetTaggedOtherMsgs(&pAsn1->otherMsgSequence,
        dwFlags,
        &pInfo->cTaggedOtherMsg,
        &pInfo->rgTaggedOtherMsg,
        &pbExtra,
        &lRemainExtra
        );

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

BOOL WINAPI Asn1CmcDataDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcData_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcDataDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  CMC Response Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcResponseEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_RESPONSE_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcResponseBody Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1CmcSetTaggedAttributes(pInfo->cTaggedAttribute,
            pInfo->rgTaggedAttribute, &Asn1Info.controlSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedContentInfos(pInfo->cTaggedContentInfo,
            pInfo->rgTaggedContentInfo, &Asn1Info.cmsSequence))
        goto ErrorReturn;
    if (!Asn1CmcSetTaggedOtherMsgs(pInfo->cTaggedOtherMsg,
            pInfo->rgTaggedOtherMsg, &Asn1Info.otherMsgSequence))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        CmcResponseBody_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
CommonReturn:
    Asn1CmcFreeTaggedAttributes(&Asn1Info.controlSequence);
    Asn1CmcFreeTaggedContentInfos(&Asn1Info.cmsSequence);
    Asn1CmcFreeTaggedOtherMsgs(&Asn1Info.otherMsgSequence);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  CMC Response Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcResponseDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcResponseBody *pAsn1 = (CmcResponseBody *) pvAsn1Info;
    PCMC_RESPONSE_INFO pInfo = (PCMC_RESPONSE_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_RESPONSE_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_RESPONSE_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_RESPONSE_INFO);
    }

    Asn1CmcGetTaggedAttributes(&pAsn1->controlSequence,
        dwFlags,
        &pInfo->cTaggedAttribute,
        &pInfo->rgTaggedAttribute,
        &pbExtra,
        &lRemainExtra
        );

    Asn1CmcGetTaggedContentInfos(&pAsn1->cmsSequence,
        dwFlags,
        &pInfo->cTaggedContentInfo,
        &pInfo->rgTaggedContentInfo,
        &pbExtra,
        &lRemainExtra
        );

    Asn1CmcGetTaggedOtherMsgs(&pAsn1->otherMsgSequence,
        dwFlags,
        &pInfo->cTaggedOtherMsg,
        &pInfo->rgTaggedOtherMsg,
        &pbExtra,
        &lRemainExtra
        );

    fResult = TRUE;
    *plRemainExtra = lRemainExtra;
    return fResult;
}

BOOL WINAPI Asn1CmcResponseDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcResponseBody_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcResponseDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  CMC Status Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcStatusEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_STATUS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcStatusInfo Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    Asn1Info.cmcStatus = pInfo->dwStatus;
    if (pInfo->cBodyList) {
        Asn1Info.bodyList.count = pInfo->cBodyList;
        Asn1Info.bodyList.value = pInfo->rgdwBodyList;
    }

    if (pInfo->pwszStatusString && L'\0' != *pInfo->pwszStatusString) {
        Asn1Info.bit_mask |= statusString_present;
        Asn1Info.statusString.length = wcslen(pInfo->pwszStatusString);
        Asn1Info.statusString.value = pInfo->pwszStatusString;
    }

    if (CMC_OTHER_INFO_NO_CHOICE != pInfo->dwOtherInfoChoice) {
        Asn1Info.bit_mask |= otherInfo_present;

        switch (pInfo->dwOtherInfoChoice) {
            case CMC_OTHER_INFO_FAIL_CHOICE:
                Asn1Info.otherInfo.choice = failInfo_chosen;
                Asn1Info.otherInfo.u.failInfo = pInfo->dwFailInfo;
                break;
            case CMC_OTHER_INFO_PEND_CHOICE:
                Asn1Info.otherInfo.choice = pendInfo_chosen;
                Asn1X509SetOctetString(&pInfo->pPendInfo->PendToken,
                    &Asn1Info.otherInfo.u.pendInfo.pendToken);
                if (!PkiAsn1ToGeneralizedTime(
                        &pInfo->pPendInfo->PendTime,
                        &Asn1Info.otherInfo.u.pendInfo.pendTime))
                    goto GeneralizedTimeError;
                break;
            default:
                goto InvalidOtherInfoChoiceError;
        }
    }


    fResult = Asn1InfoEncodeEx(
        CmcStatusInfo_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidOtherInfoChoiceError, E_INVALIDARG)
SET_ERROR(GeneralizedTimeError, CRYPT_E_BAD_ENCODE)
}

//+-------------------------------------------------------------------------
//  CMC Status Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcStatusDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcStatusInfo *pAsn1 = (CmcStatusInfo *) pvAsn1Info;
    PCMC_STATUS_INFO pInfo = (PCMC_STATUS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_STATUS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_STATUS_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_STATUS_INFO);

        pInfo->dwStatus = pAsn1->cmcStatus;
    }

    if (pAsn1->bodyList.count > 0) {
        ASN1uint32_t count = pAsn1->bodyList.count;
        
        lAlignExtra = INFO_LEN_ALIGN(count * sizeof(DWORD));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            BodyPartID *value;
            DWORD *pdwBodyList;

            value = pAsn1->bodyList.value;
            pdwBodyList = (DWORD *) pbExtra;
            pbExtra += lAlignExtra;

            pInfo->cBodyList = count;
            pInfo->rgdwBodyList = pdwBodyList;

            for ( ; count > 0; count--, value++, pdwBodyList++)
                *pdwBodyList = *value;
        }
    }


    if (pAsn1->bit_mask & statusString_present) {
        ASN1uint32_t length = pAsn1->statusString.length;

        lAlignExtra = INFO_LEN_ALIGN((length + 1) * sizeof(WCHAR));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            memcpy(pbExtra, pAsn1->statusString.value, length * sizeof(WCHAR));
            memset(pbExtra + (length * sizeof(WCHAR)), 0, sizeof(WCHAR));

            pInfo->pwszStatusString = (LPWSTR) pbExtra;
            pbExtra += lAlignExtra;
        }
    }

    if (pAsn1->bit_mask & otherInfo_present) {
        switch (pAsn1->otherInfo.choice) {
            case failInfo_chosen:
                if (lRemainExtra >= 0) {
                    pInfo->dwOtherInfoChoice = CMC_OTHER_INFO_FAIL_CHOICE;
                    pInfo->dwFailInfo = pAsn1->otherInfo.u.failInfo;
                }
                break;
            case pendInfo_chosen:
                {
                    PCMC_PEND_INFO pPendInfo;

                    lAlignExtra = INFO_LEN_ALIGN(sizeof(CMC_PEND_INFO));
                    lRemainExtra -= lAlignExtra;
                    if (lRemainExtra >= 0) {
                        pInfo->dwOtherInfoChoice = CMC_OTHER_INFO_PEND_CHOICE;
                        pPendInfo = (PCMC_PEND_INFO) pbExtra;
                        pInfo->pPendInfo = pPendInfo;
                        pbExtra += lAlignExtra;

                        if (!PkiAsn1FromGeneralizedTime(
                                &pAsn1->otherInfo.u.pendInfo.pendTime,
                                &pPendInfo->PendTime))
                            goto GeneralizedTimeDecodeError;
                    } else
                        pPendInfo = NULL;

                    Asn1X509GetOctetString(
                        &pAsn1->otherInfo.u.pendInfo.pendToken, dwFlags,
                        &pPendInfo->PendToken, &pbExtra, &lRemainExtra);
                }
                break;
            default:
                goto InvalidOtherInfoChoiceError;
        }
    }

    fResult = TRUE;
CommonReturn:
    *plRemainExtra = lRemainExtra;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidOtherInfoChoiceError, CRYPT_E_BAD_ENCODE)
SET_ERROR(GeneralizedTimeDecodeError, CRYPT_E_BAD_ENCODE)
}

BOOL WINAPI Asn1CmcStatusDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcStatusInfo_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcStatusDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}


//+-------------------------------------------------------------------------
//  CMC Add Extensions Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcAddExtensionsEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_ADD_EXTENSIONS_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcAddExtensions Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    Asn1Info.pkiDataReference = pInfo->dwCmcDataReference;
    if (pInfo->cCertReference) {
        Asn1Info.certReferences.count = pInfo->cCertReference;
        Asn1Info.certReferences.value = pInfo->rgdwCertReference;
    }

    if (!Asn1X509SetExtensions(pInfo->cExtension, pInfo->rgExtension,
            &Asn1Info.extensions))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        CmcAddExtensions_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    Asn1X509FreeExtensions(&Asn1Info.extensions);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  CMC Add Extensions Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcAddExtensionsDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcAddExtensions *pAsn1 = (CmcAddExtensions *) pvAsn1Info;
    PCMC_ADD_EXTENSIONS_INFO pInfo = (PCMC_ADD_EXTENSIONS_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_ADD_EXTENSIONS_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_ADD_EXTENSIONS_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_ADD_EXTENSIONS_INFO);

        pInfo->dwCmcDataReference = pAsn1->pkiDataReference;
    }

    if (pAsn1->certReferences.count > 0) {
        ASN1uint32_t count = pAsn1->certReferences.count;
        
        lAlignExtra = INFO_LEN_ALIGN(count * sizeof(DWORD));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            BodyPartID *value;
            DWORD *pdwCertReference;

            value = pAsn1->certReferences.value;
            pdwCertReference = (DWORD *) pbExtra;
            pbExtra += lAlignExtra;

            pInfo->cCertReference = count;
            pInfo->rgdwCertReference = pdwCertReference;

            for ( ; count > 0; count--, value++, pdwCertReference++)
                *pdwCertReference = *value;
        }
    }

    Asn1X509GetExtensions(&pAsn1->extensions, dwFlags,
        &pInfo->cExtension, &pInfo->rgExtension, &pbExtra, &lRemainExtra);

    fResult = TRUE;
    *plRemainExtra = lRemainExtra;
    return fResult;
}

BOOL WINAPI Asn1CmcAddExtensionsDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcAddExtensions_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcAddExtensionsDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  CMC Add Attributes Encode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcAddAttributesEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCMC_ADD_ATTRIBUTES_INFO pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CmcAddAttributes Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    Asn1Info.pkiDataReference = pInfo->dwCmcDataReference;
    if (pInfo->cCertReference) {
        Asn1Info.certReferences.count = pInfo->cCertReference;
        Asn1Info.certReferences.value = pInfo->rgdwCertReference;
    }

    if (!Asn1X509SetAttributes(pInfo->cAttribute, pInfo->rgAttribute,
            &Asn1Info.attributes))
        goto ErrorReturn;

    fResult = Asn1InfoEncodeEx(
        CmcAddAttributes_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

CommonReturn:
    Asn1X509FreeAttributes(&Asn1Info.attributes);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  CMC Add Attributes Decode (ASN1)
//--------------------------------------------------------------------------
BOOL WINAPI Asn1CmcAddAttributesDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    BOOL fResult;
    CmcAddAttributes *pAsn1 = (CmcAddAttributes *) pvAsn1Info;
    PCMC_ADD_ATTRIBUTES_INFO pInfo = (PCMC_ADD_ATTRIBUTES_INFO) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    LONG lAlignExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CMC_ADD_ATTRIBUTES_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CMC_ADD_ATTRIBUTES_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CMC_ADD_ATTRIBUTES_INFO);

        pInfo->dwCmcDataReference = pAsn1->pkiDataReference;
    }

    if (pAsn1->certReferences.count > 0) {
        ASN1uint32_t count = pAsn1->certReferences.count;
        
        lAlignExtra = INFO_LEN_ALIGN(count * sizeof(DWORD));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            BodyPartID *value;
            DWORD *pdwCertReference;

            value = pAsn1->certReferences.value;
            pdwCertReference = (DWORD *) pbExtra;
            pbExtra += lAlignExtra;

            pInfo->cCertReference = count;
            pInfo->rgdwCertReference = pdwCertReference;

            for ( ; count > 0; count--, value++, pdwCertReference++)
                *pdwCertReference = *value;
        }
    }

    Asn1X509GetAttributes(&pAsn1->attributes, dwFlags,
        &pInfo->cAttribute, &pInfo->rgAttribute, &pbExtra, &lRemainExtra);

    fResult = TRUE;
    *plRemainExtra = lRemainExtra;
    return fResult;
}

BOOL WINAPI Asn1CmcAddAttributesDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CmcAddAttributes_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1CmcAddAttributesDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+=========================================================================
//  Certificate Template Encode/Decode Functions
//==========================================================================

BOOL WINAPI Asn1X509CertTemplateEncodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCERT_TEMPLATE_EXT pInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    CertificateTemplate Asn1Info;

    memset(&Asn1Info, 0, sizeof(Asn1Info));
    if (!Asn1X509SetEncodedObjId(pInfo->pszObjId, &Asn1Info.templateID))
        goto ErrorReturn;

    Asn1Info.templateMajorVersion = pInfo->dwMajorVersion;
    if (pInfo->fMinorVersion) {
        Asn1Info.bit_mask |= templateMinorVersion_present;
        Asn1Info.templateMinorVersion = pInfo->dwMinorVersion;
    }

    fResult = Asn1InfoEncodeEx(
        CertificateTemplate_PDU,
        &Asn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );

    goto CommonReturn;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG)
        *((void **) pvEncoded) = NULL;
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

BOOL WINAPI Asn1X509CertTemplateDecodeExCallback(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT LONG *plRemainExtra
        )
{
    CertificateTemplate *pAsn1Info = (CertificateTemplate *) pvAsn1Info;
    PCERT_TEMPLATE_EXT pInfo =
        (PCERT_TEMPLATE_EXT) pvStructInfo;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra;

    lRemainExtra -= sizeof(CERT_TEMPLATE_EXT);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CERT_TEMPLATE_EXT));
        pbExtra = (BYTE *) pInfo + sizeof(CERT_TEMPLATE_EXT);

        pInfo->dwMajorVersion = pAsn1Info->templateMajorVersion;
        if (pAsn1Info->bit_mask & templateMinorVersion_present) {
            pInfo->fMinorVersion = TRUE;
            pInfo->dwMinorVersion = pAsn1Info->templateMinorVersion;
        }
    }

    Asn1X509GetEncodedObjId(&pAsn1Info->templateID, dwFlags,
        &pInfo->pszObjId, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

BOOL WINAPI Asn1X509CertTemplateDecodeEx(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return Asn1InfoDecodeAndAllocEx(
        CertificateTemplate_PDU,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        Asn1X509CertTemplateDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\x509.h ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for X509 v3 certificates */

#ifndef _X509_Module_H_
#define _X509_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1int32_t NoticeReference_noticeNumbers_Seq;

typedef ASN1intx_t HUGEINTEGER;

typedef ASN1bitstring_t BITSTRING;

typedef ASN1octetstring_t OCTETSTRING;

typedef ASN1open_t NOCOPYANY;

typedef ASN1charstring_t NUMERICSTRING;

typedef ASN1charstring_t PRINTABLESTRING;

typedef ASN1charstring_t TELETEXSTRING;

typedef ASN1charstring_t T61STRING;

typedef ASN1charstring_t VIDEOTEXSTRING;

typedef ASN1charstring_t IA5STRING;

typedef ASN1charstring_t GRAPHICSTRING;

typedef ASN1charstring_t VISIBLESTRING;

typedef ASN1charstring_t ISO646STRING;

typedef ASN1charstring_t GENERALSTRING;

typedef ASN1char32string_t UNIVERSALSTRING;

typedef ASN1char16string_t BMPSTRING;

typedef ASN1wstring_t UTF8STRING;

typedef ASN1encodedOID_t EncodedObjectID;
#define EncodedObjectID_PDU 0
#define SIZE_X509_Module_PDU_0 sizeof(EncodedObjectID)

typedef BITSTRING Bits;
#define Bits_PDU 1
#define SIZE_X509_Module_PDU_1 sizeof(Bits)

typedef ASN1int32_t CertificateVersion;
#define CertificateVersion_v1 0
#define CertificateVersion_v2 1
#define CertificateVersion_v3 2

typedef HUGEINTEGER CertificateSerialNumber;

typedef BITSTRING UniqueIdentifier;

typedef ASN1int32_t CRLVersion;
#define CRLVersion_v1 0
#define CRLVersion_v2 1

typedef ASN1int32_t CertificationRequestInfoVersion;

typedef OCTETSTRING KeyIdentifier;

typedef BITSTRING KeyUsage;

typedef EncodedObjectID CertPolicyElementId;

typedef BITSTRING SubjectType;

typedef BITSTRING ReasonFlags;

typedef ASN1int32_t IntegerType;
#define IntegerType_PDU 2
#define SIZE_X509_Module_PDU_2 sizeof(IntegerType)

typedef HUGEINTEGER HugeIntegerType;
#define HugeIntegerType_PDU 3
#define SIZE_X509_Module_PDU_3 sizeof(HugeIntegerType)

typedef OCTETSTRING OctetStringType;
#define OctetStringType_PDU 4
#define SIZE_X509_Module_PDU_4 sizeof(OctetStringType)

typedef enum EnumeratedType {
    dummyEnumerated0 = 0,
} EnumeratedType;
#define EnumeratedType_PDU 5
#define SIZE_X509_Module_PDU_5 sizeof(EnumeratedType)

typedef ASN1utctime_t UtcTime;
#define UtcTime_PDU 6
#define SIZE_X509_Module_PDU_6 sizeof(UtcTime)

typedef EncodedObjectID ContentType;

typedef EncodedObjectID UsageIdentifier;

typedef ASN1int32_t CTLVersion;
#define CTLVersion_v1 0

typedef OCTETSTRING ListIdentifier;

typedef OCTETSTRING SubjectIdentifier;

typedef ASN1uint32_t BaseDistance;

typedef ASN1uint32_t SkipCerts;

typedef ASN1uint32_t BodyPartID;

typedef ASN1uint32_t TemplateVersion;

typedef struct NoticeReference_noticeNumbers {
    ASN1uint32_t count;
    NoticeReference_noticeNumbers_Seq *value;
} NoticeReference_noticeNumbers;

typedef struct AnyString {
    ASN1choice_t choice;
    union {
#	define octetString_chosen 1
	OCTETSTRING octetString;
#	define utf8String_chosen 2
	UTF8STRING utf8String;
#	define numericString_chosen 3
	NUMERICSTRING numericString;
#	define printableString_chosen 4
	PRINTABLESTRING printableString;
#	define teletexString_chosen 5
	TELETEXSTRING teletexString;
#	define videotexString_chosen 6
	VIDEOTEXSTRING videotexString;
#	define ia5String_chosen 7
	IA5STRING ia5String;
#	define graphicString_chosen 8
	GRAPHICSTRING graphicString;
#	define visibleString_chosen 9
	VISIBLESTRING visibleString;
#	define generalString_chosen 10
	GENERALSTRING generalString;
#	define universalString_chosen 11
	UNIVERSALSTRING universalString;
#	define bmpString_chosen 12
	BMPSTRING bmpString;
    } u;
} AnyString;
#define AnyString_PDU 7
#define SIZE_X509_Module_PDU_7 sizeof(AnyString)

typedef struct AlgorithmIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID algorithm;
#   define parameters_present 0x80
    NOCOPYANY parameters;
} AlgorithmIdentifier;

typedef struct Name {
    ASN1uint32_t count;
    struct RelativeDistinguishedName *value;
} Name;
#define Name_PDU 8
#define SIZE_X509_Module_PDU_8 sizeof(Name)

typedef struct RelativeDistinguishedName {
    ASN1uint32_t count;
    struct AttributeTypeValue *value;
} RelativeDistinguishedName;

typedef struct AttributeTypeValue {
    EncodedObjectID type;
    NOCOPYANY value;
} AttributeTypeValue;

typedef struct AttributeSetValue {
    ASN1uint32_t count;
    NOCOPYANY *value;
} AttributeSetValue;

typedef struct Attributes {
    ASN1uint32_t count;
    struct Attribute *value;
} Attributes;
#define Attributes_PDU 9
#define SIZE_X509_Module_PDU_9 sizeof(Attributes)

typedef struct RSAPublicKey {
    HUGEINTEGER modulus;
    ASN1uint32_t publicExponent;
} RSAPublicKey;
#define RSAPublicKey_PDU 10
#define SIZE_X509_Module_PDU_10 sizeof(RSAPublicKey)

typedef struct DSSParameters {
    HUGEINTEGER p;
    HUGEINTEGER q;
    HUGEINTEGER g;
} DSSParameters;
#define DSSParameters_PDU 11
#define SIZE_X509_Module_PDU_11 sizeof(DSSParameters)

typedef struct DSSSignature {
    HUGEINTEGER r;
    HUGEINTEGER s;
} DSSSignature;
#define DSSSignature_PDU 12
#define SIZE_X509_Module_PDU_12 sizeof(DSSSignature)

typedef struct DHParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    HUGEINTEGER p;
    HUGEINTEGER g;
#   define privateValueLength_present 0x80
    HUGEINTEGER privateValueLength;
} DHParameters;
#define DHParameters_PDU 13
#define SIZE_X509_Module_PDU_13 sizeof(DHParameters)

typedef struct X942DhValidationParams {
    BITSTRING seed;
    ASN1uint32_t pgenCounter;
} X942DhValidationParams;

typedef struct X942DhKeySpecificInfo {
    EncodedObjectID algorithm;
    OCTETSTRING counter;
} X942DhKeySpecificInfo;

typedef struct RC2CBCParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
#   define iv_present 0x80
    OCTETSTRING iv;
} RC2CBCParameters;
#define RC2CBCParameters_PDU 14
#define SIZE_X509_Module_PDU_14 sizeof(RC2CBCParameters)

typedef struct SMIMECapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID capabilityID;
#   define smimeParameters_present 0x80
    NOCOPYANY smimeParameters;
} SMIMECapability;

typedef struct SMIMECapabilities {
    ASN1uint32_t count;
    struct SMIMECapability *value;
} SMIMECapabilities;
#define SMIMECapabilities_PDU 15
#define SIZE_X509_Module_PDU_15 sizeof(SMIMECapabilities)

typedef struct SubjectPublicKeyInfo {
    AlgorithmIdentifier algorithm;
    BITSTRING subjectPublicKey;
} SubjectPublicKeyInfo;
#define SubjectPublicKeyInfo_PDU 16
#define SIZE_X509_Module_PDU_16 sizeof(SubjectPublicKeyInfo)

typedef struct ChoiceOfTime {
    ASN1choice_t choice;
    union {
#	define utcTime_chosen 1
	ASN1utctime_t utcTime;
#	define generalTime_chosen 2
	ASN1generalizedtime_t generalTime;
    } u;
} ChoiceOfTime;
#define ChoiceOfTime_PDU 17
#define SIZE_X509_Module_PDU_17 sizeof(ChoiceOfTime)

typedef struct Validity {
    ChoiceOfTime notBefore;
    ChoiceOfTime notAfter;
} Validity;

typedef struct Extensions {
    ASN1uint32_t count;
    struct Extension *value;
} Extensions;
#define Extensions_PDU 18
#define SIZE_X509_Module_PDU_18 sizeof(Extensions)

typedef struct Extension {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID extnId;
#   define critical_present 0x80
    ASN1bool_t critical;
    OCTETSTRING extnValue;
} Extension;

typedef struct SignedContent {
    NOCOPYANY toBeSigned;
    AlgorithmIdentifier algorithm;
    BITSTRING signature;
} SignedContent;
#define SignedContent_PDU 19
#define SIZE_X509_Module_PDU_19 sizeof(SignedContent)

typedef struct RevokedCertificates {
    ASN1uint32_t count;
    struct CRLEntry *value;
} RevokedCertificates;

typedef struct CRLEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CertificateSerialNumber userCertificate;
    ChoiceOfTime revocationDate;
#   define crlEntryExtensions_present 0x80
    Extensions crlEntryExtensions;
} CRLEntry;

typedef struct CertificationRequestInfo {
    CertificationRequestInfoVersion version;
    NOCOPYANY subject;
    SubjectPublicKeyInfo subjectPublicKeyInfo;
    Attributes attributes;
} CertificationRequestInfo;
#define CertificationRequestInfo_PDU 20
#define SIZE_X509_Module_PDU_20 sizeof(CertificationRequestInfo)

typedef struct CertificationRequestInfoDecode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CertificationRequestInfoVersion version;
    NOCOPYANY subject;
    SubjectPublicKeyInfo subjectPublicKeyInfo;
#   define attributes_present 0x80
    Attributes attributes;
} CertificationRequestInfoDecode;
#define CertificationRequestInfoDecode_PDU 21
#define SIZE_X509_Module_PDU_21 sizeof(CertificationRequestInfoDecode)

typedef struct KeygenRequestInfo {
    SubjectPublicKeyInfo subjectPublicKeyInfo;
    IA5STRING challenge;
} KeygenRequestInfo;
#define KeygenRequestInfo_PDU 22
#define SIZE_X509_Module_PDU_22 sizeof(KeygenRequestInfo)

typedef struct AuthorityKeyId {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define AuthorityKeyId_keyIdentifier_present 0x80
    KeyIdentifier keyIdentifier;
#   define certIssuer_present 0x40
    NOCOPYANY certIssuer;
#   define certSerialNumber_present 0x20
    CertificateSerialNumber certSerialNumber;
} AuthorityKeyId;
#define AuthorityKeyId_PDU 23
#define SIZE_X509_Module_PDU_23 sizeof(AuthorityKeyId)

typedef struct PrivateKeyValidity {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define notBefore_present 0x80
    ASN1generalizedtime_t notBefore;
#   define notAfter_present 0x40
    ASN1generalizedtime_t notAfter;
} PrivateKeyValidity;

typedef struct CertPolicySet {
    ASN1uint32_t count;
    struct CertPolicyId *value;
} CertPolicySet;

typedef struct CertPolicyId {
    ASN1uint32_t count;
    CertPolicyElementId *value;
} CertPolicyId;

typedef struct AltNames {
    ASN1uint32_t count;
    struct GeneralName *value;
} AltNames;
#define AltNames_PDU 24
#define SIZE_X509_Module_PDU_24 sizeof(AltNames)

typedef AltNames GeneralNames;

typedef struct OtherName {
    EncodedObjectID type;
    NOCOPYANY value;
} OtherName;

typedef struct EDIPartyName {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define nameAssigner_present 0x80
    NOCOPYANY nameAssigner;
    NOCOPYANY partyName;
} EDIPartyName;
#define EDIPartyName_PDU 25
#define SIZE_X509_Module_PDU_25 sizeof(EDIPartyName)

typedef struct SubtreesConstraint {
    ASN1uint32_t count;
    NOCOPYANY *value;
} SubtreesConstraint;

typedef struct BasicConstraints2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define cA_present 0x80
    ASN1bool_t cA;
#   define BasicConstraints2_pathLenConstraint_present 0x40
    ASN1int32_t pathLenConstraint;
} BasicConstraints2;
#define BasicConstraints2_PDU 26
#define SIZE_X509_Module_PDU_26 sizeof(BasicConstraints2)

typedef struct CertificatePolicies {
    ASN1uint32_t count;
    struct PolicyInformation *value;
} CertificatePolicies;
#define CertificatePolicies_PDU 27
#define SIZE_X509_Module_PDU_27 sizeof(CertificatePolicies)

typedef struct PolicyQualifiers {
    ASN1uint32_t count;
    struct PolicyQualifierInfo *value;
} PolicyQualifiers;

typedef struct PolicyQualifierInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID policyQualifierId;
#   define qualifier_present 0x80
    NOCOPYANY qualifier;
} PolicyQualifierInfo;

typedef struct NoticeReference {
    ASN1ztcharstring_t organization;
    NoticeReference_noticeNumbers noticeNumbers;
} NoticeReference;

typedef struct DisplayText {
    ASN1choice_t choice;
    union {
#	define theVisibleString_chosen 1
	ASN1ztcharstring_t theVisibleString;
#	define theBMPString_chosen 2
	ASN1char16string_t theBMPString;
    } u;
} DisplayText;

typedef struct CertificatePolicies95 {
    ASN1uint32_t count;
    struct PolicyQualifiers *value;
} CertificatePolicies95;
#define CertificatePolicies95_PDU 28
#define SIZE_X509_Module_PDU_28 sizeof(CertificatePolicies95)

typedef struct CpsURLs {
    ASN1uint32_t count;
    struct CpsURLs_Seq *value;
} CpsURLs;

typedef struct AuthorityKeyId2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define AuthorityKeyId2_keyIdentifier_present 0x80
    KeyIdentifier keyIdentifier;
#   define authorityCertIssuer_present 0x40
    GeneralNames authorityCertIssuer;
#   define authorityCertSerialNumber_present 0x20
    CertificateSerialNumber authorityCertSerialNumber;
} AuthorityKeyId2;
#define AuthorityKeyId2_PDU 29
#define SIZE_X509_Module_PDU_29 sizeof(AuthorityKeyId2)

typedef struct AuthorityInfoAccess {
    ASN1uint32_t count;
    struct AccessDescription *value;
} AuthorityInfoAccess;
#define AuthorityInfoAccess_PDU 30
#define SIZE_X509_Module_PDU_30 sizeof(AuthorityInfoAccess)

typedef struct CRLDistributionPoints {
    ASN1uint32_t count;
    struct DistributionPoint *value;
} CRLDistributionPoints;
#define CRLDistributionPoints_PDU 31
#define SIZE_X509_Module_PDU_31 sizeof(CRLDistributionPoints)

typedef struct DistributionPointName {
    ASN1choice_t choice;
    union {
#	define fullName_chosen 1
	GeneralNames fullName;
#	define nameRelativeToCRLIssuer_chosen 2
	RelativeDistinguishedName nameRelativeToCRLIssuer;
    } u;
} DistributionPointName;

typedef struct ContentInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
#   define content_present 0x80
    NOCOPYANY content;
} ContentInfo;
#define ContentInfo_PDU 32
#define SIZE_X509_Module_PDU_32 sizeof(ContentInfo)

typedef struct SeqOfAny {
    ASN1uint32_t count;
    NOCOPYANY *value;
} SeqOfAny;
#define SeqOfAny_PDU 33
#define SIZE_X509_Module_PDU_33 sizeof(SeqOfAny)

typedef struct TimeStampRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID timeStampAlgorithm;
#   define attributesTS_present 0x80
    Attributes attributesTS;
    ContentInfo content;
} TimeStampRequest;
#define TimeStampRequest_PDU 34
#define SIZE_X509_Module_PDU_34 sizeof(TimeStampRequest)

typedef struct ContentInfoOTS {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentTypeOTS;
#   define contentOTS_present 0x80
    OCTETSTRING contentOTS;
} ContentInfoOTS;
#define ContentInfoOTS_PDU 35
#define SIZE_X509_Module_PDU_35 sizeof(ContentInfoOTS)

typedef struct TimeStampRequestOTS {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID timeStampAlgorithmOTS;
#   define attributesOTS_present 0x80
    Attributes attributesOTS;
    ContentInfoOTS contentOTS;
} TimeStampRequestOTS;
#define TimeStampRequestOTS_PDU 36
#define SIZE_X509_Module_PDU_36 sizeof(TimeStampRequestOTS)

typedef struct EnhancedKeyUsage {
    ASN1uint32_t count;
    UsageIdentifier *value;
} EnhancedKeyUsage;
#define EnhancedKeyUsage_PDU 37
#define SIZE_X509_Module_PDU_37 sizeof(EnhancedKeyUsage)

typedef EnhancedKeyUsage SubjectUsage;

typedef struct TrustedSubjects {
    ASN1uint32_t count;
    struct TrustedSubject *value;
} TrustedSubjects;

typedef struct TrustedSubject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SubjectIdentifier subjectIdentifier;
#   define subjectAttributes_present 0x80
    Attributes subjectAttributes;
} TrustedSubject;

typedef struct EnrollmentNameValuePair {
    BMPSTRING name;
    BMPSTRING value;
} EnrollmentNameValuePair;
#define EnrollmentNameValuePair_PDU 38
#define SIZE_X509_Module_PDU_38 sizeof(EnrollmentNameValuePair)

typedef struct CSPProvider {
    ASN1int32_t keySpec;
    BMPSTRING cspName;
    BITSTRING signature;
} CSPProvider;
#define CSPProvider_PDU 39
#define SIZE_X509_Module_PDU_39 sizeof(CSPProvider)

typedef struct CertificatePair {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define forward_present 0x80
    NOCOPYANY forward;
#   define reverse_present 0x40
    NOCOPYANY reverse;
} CertificatePair;
#define CertificatePair_PDU 40
#define SIZE_X509_Module_PDU_40 sizeof(CertificatePair)

typedef struct GeneralSubtrees {
    ASN1uint32_t count;
    struct GeneralSubtree *value;
} GeneralSubtrees;

typedef struct IssuingDistributionPoint {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define issuingDistributionPoint_present 0x80
    DistributionPointName issuingDistributionPoint;
#   define onlyContainsUserCerts_present 0x40
    ASN1bool_t onlyContainsUserCerts;
#   define onlyContainsCACerts_present 0x20
    ASN1bool_t onlyContainsCACerts;
#   define onlySomeReasons_present 0x10
    ReasonFlags onlySomeReasons;
#   define indirectCRL_present 0x8
    ASN1bool_t indirectCRL;
} IssuingDistributionPoint;
#define IssuingDistributionPoint_PDU 41
#define SIZE_X509_Module_PDU_41 sizeof(IssuingDistributionPoint)

typedef struct CrossCertDistPointNames {
    ASN1uint32_t count;
    GeneralNames *value;
} CrossCertDistPointNames;

typedef struct PolicyMappings {
    ASN1uint32_t count;
    struct PolicyMapping *value;
} PolicyMappings;
#define PolicyMappings_PDU 42
#define SIZE_X509_Module_PDU_42 sizeof(PolicyMappings)

typedef struct PolicyMapping {
    EncodedObjectID issuerDomainPolicy;
    EncodedObjectID subjectDomainPolicy;
} PolicyMapping;

typedef struct PolicyConstraints {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define requireExplicitPolicy_present 0x80
    SkipCerts requireExplicitPolicy;
#   define inhibitPolicyMapping_present 0x40
    SkipCerts inhibitPolicyMapping;
} PolicyConstraints;
#define PolicyConstraints_PDU 43
#define SIZE_X509_Module_PDU_43 sizeof(PolicyConstraints)

typedef struct ControlSequence {
    ASN1uint32_t count;
    struct TaggedAttribute *value;
} ControlSequence;

typedef struct ReqSequence {
    ASN1uint32_t count;
    struct TaggedRequest *value;
} ReqSequence;

typedef struct CmsSequence {
    ASN1uint32_t count;
    struct TaggedContentInfo *value;
} CmsSequence;

typedef struct OtherMsgSequence {
    ASN1uint32_t count;
    struct TaggedOtherMsg *value;
} OtherMsgSequence;

typedef struct BodyPartIDSequence {
    ASN1uint32_t count;
    BodyPartID *value;
} BodyPartIDSequence;

typedef struct TaggedAttribute {
    BodyPartID bodyPartID;
    EncodedObjectID type;
    AttributeSetValue values;
} TaggedAttribute;

typedef struct TaggedCertificationRequest {
    BodyPartID bodyPartID;
    NOCOPYANY certificationRequest;
} TaggedCertificationRequest;

typedef struct TaggedContentInfo {
    BodyPartID bodyPartID;
    NOCOPYANY contentInfo;
} TaggedContentInfo;

typedef struct TaggedOtherMsg {
    BodyPartID bodyPartID;
    EncodedObjectID otherMsgType;
    NOCOPYANY otherMsgValue;
} TaggedOtherMsg;

typedef struct PendInfo {
    OCTETSTRING pendToken;
    ASN1generalizedtime_t pendTime;
} PendInfo;

typedef struct CmcAddExtensions {
    BodyPartID pkiDataReference;
    BodyPartIDSequence certReferences;
    Extensions extensions;
} CmcAddExtensions;
#define CmcAddExtensions_PDU 44
#define SIZE_X509_Module_PDU_44 sizeof(CmcAddExtensions)

typedef struct CmcAddAttributes {
    BodyPartID pkiDataReference;
    BodyPartIDSequence certReferences;
    Attributes attributes;
} CmcAddAttributes;
#define CmcAddAttributes_PDU 45
#define SIZE_X509_Module_PDU_45 sizeof(CmcAddAttributes)

typedef struct CertificateTemplate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID templateID;
    TemplateVersion templateMajorVersion;
#   define templateMinorVersion_present 0x80
    TemplateVersion templateMinorVersion;
} CertificateTemplate;
#define CertificateTemplate_PDU 46
#define SIZE_X509_Module_PDU_46 sizeof(CertificateTemplate)

typedef struct CmcStatusInfo_otherInfo {
    ASN1choice_t choice;
    union {
#	define failInfo_chosen 1
	ASN1uint32_t failInfo;
#	define pendInfo_chosen 2
	PendInfo pendInfo;
    } u;
} CmcStatusInfo_otherInfo;

typedef struct CpsURLs_Seq {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1ztcharstring_t url;
#   define digestAlgorithmId_present 0x80
    AlgorithmIdentifier digestAlgorithmId;
#   define digest_present 0x40
    OCTETSTRING digest;
} CpsURLs_Seq;

typedef struct Attribute {
    EncodedObjectID type;
    AttributeSetValue values;
} Attribute;
#define Attribute_PDU 47
#define SIZE_X509_Module_PDU_47 sizeof(Attribute)

typedef struct X942DhParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    HUGEINTEGER p;
    HUGEINTEGER g;
    HUGEINTEGER q;
#   define j_present 0x80
    HUGEINTEGER j;
#   define validationParams_present 0x40
    X942DhValidationParams validationParams;
} X942DhParameters;
#define X942DhParameters_PDU 48
#define SIZE_X509_Module_PDU_48 sizeof(X942DhParameters)

typedef struct X942DhOtherInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    X942DhKeySpecificInfo keyInfo;
#   define pubInfo_present 0x80
    OCTETSTRING pubInfo;
    OCTETSTRING keyLength;
} X942DhOtherInfo;
#define X942DhOtherInfo_PDU 49
#define SIZE_X509_Module_PDU_49 sizeof(X942DhOtherInfo)

typedef struct CertificateToBeSigned {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define CertificateToBeSigned_version_present 0x80
    CertificateVersion version;
    CertificateSerialNumber serialNumber;
    AlgorithmIdentifier signature;
    NOCOPYANY issuer;
    Validity validity;
    NOCOPYANY subject;
    SubjectPublicKeyInfo subjectPublicKeyInfo;
#   define issuerUniqueIdentifier_present 0x40
    UniqueIdentifier issuerUniqueIdentifier;
#   define subjectUniqueIdentifier_present 0x20
    UniqueIdentifier subjectUniqueIdentifier;
#   define extensions_present 0x10
    Extensions extensions;
} CertificateToBeSigned;
#define CertificateToBeSigned_PDU 50
#define SIZE_X509_Module_PDU_50 sizeof(CertificateToBeSigned)

typedef struct CertificateRevocationListToBeSigned {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define CertificateRevocationListToBeSigned_version_present 0x80
    CRLVersion version;
    AlgorithmIdentifier signature;
    NOCOPYANY issuer;
    ChoiceOfTime thisUpdate;
#   define nextUpdate_present 0x40
    ChoiceOfTime nextUpdate;
#   define revokedCertificates_present 0x20
    RevokedCertificates revokedCertificates;
#   define crlExtensions_present 0x10
    Extensions crlExtensions;
} CertificateRevocationListToBeSigned;
#define CertificateRevocationListToBeSigned_PDU 51
#define SIZE_X509_Module_PDU_51 sizeof(CertificateRevocationListToBeSigned)

typedef struct KeyAttributes {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define KeyAttributes_keyIdentifier_present 0x80
    KeyIdentifier keyIdentifier;
#   define intendedKeyUsage_present 0x40
    KeyUsage intendedKeyUsage;
#   define privateKeyUsagePeriod_present 0x20
    PrivateKeyValidity privateKeyUsagePeriod;
} KeyAttributes;
#define KeyAttributes_PDU 52
#define SIZE_X509_Module_PDU_52 sizeof(KeyAttributes)

typedef struct KeyUsageRestriction {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define certPolicySet_present 0x80
    CertPolicySet certPolicySet;
#   define restrictedKeyUsage_present 0x40
    KeyUsage restrictedKeyUsage;
} KeyUsageRestriction;
#define KeyUsageRestriction_PDU 53
#define SIZE_X509_Module_PDU_53 sizeof(KeyUsageRestriction)

typedef struct GeneralName {
    ASN1choice_t choice;
    union {
#	define otherName_chosen 1
	OtherName otherName;
#	define rfc822Name_chosen 2
	IA5STRING rfc822Name;
#	define dNSName_chosen 3
	IA5STRING dNSName;
#	define x400Address_chosen 4
	SeqOfAny x400Address;
#	define directoryName_chosen 5
	NOCOPYANY directoryName;
#	define ediPartyName_chosen 6
	SeqOfAny ediPartyName;
#	define uniformResourceLocator_chosen 7
	IA5STRING uniformResourceLocator;
#	define iPAddress_chosen 8
	OCTETSTRING iPAddress;
#	define registeredID_chosen 9
	EncodedObjectID registeredID;
    } u;
} GeneralName;

typedef struct BasicConstraints {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SubjectType subjectType;
#   define BasicConstraints_pathLenConstraint_present 0x80
    ASN1int32_t pathLenConstraint;
#   define subtreesConstraint_present 0x40
    SubtreesConstraint subtreesConstraint;
} BasicConstraints;
#define BasicConstraints_PDU 54
#define SIZE_X509_Module_PDU_54 sizeof(BasicConstraints)

typedef struct PolicyInformation {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EncodedObjectID policyIdentifier;
#   define policyQualifiers_present 0x80
    PolicyQualifiers policyQualifiers;
} PolicyInformation;

typedef struct UserNotice {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define noticeRef_present 0x80
    NoticeReference noticeRef;
#   define explicitText_present 0x40
    DisplayText explicitText;
} UserNotice;
#define UserNotice_PDU 55
#define SIZE_X509_Module_PDU_55 sizeof(UserNotice)

typedef struct VerisignQualifier1 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define practicesReference_present 0x80
    ASN1ztcharstring_t practicesReference;
#   define noticeId_present 0x40
    EncodedObjectID noticeId;
#   define nsiNoticeId_present 0x20
    EncodedObjectID nsiNoticeId;
#   define cpsURLs_present 0x10
    CpsURLs cpsURLs;
} VerisignQualifier1;
#define VerisignQualifier1_PDU 56
#define SIZE_X509_Module_PDU_56 sizeof(VerisignQualifier1)

typedef struct AccessDescription {
    EncodedObjectID accessMethod;
    GeneralName accessLocation;
} AccessDescription;

typedef struct DistributionPoint {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define distributionPoint_present 0x80
    DistributionPointName distributionPoint;
#   define reasons_present 0x40
    ReasonFlags reasons;
#   define cRLIssuer_present 0x20
    GeneralNames cRLIssuer;
} DistributionPoint;

typedef struct ContentInfoSeqOfAny {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
#   define contentSeqOfAny_present 0x80
    SeqOfAny contentSeqOfAny;
} ContentInfoSeqOfAny;
#define ContentInfoSeqOfAny_PDU 57
#define SIZE_X509_Module_PDU_57 sizeof(ContentInfoSeqOfAny)

typedef struct CertificateTrustList {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define CertificateTrustList_version_present 0x80
    CTLVersion version;
    SubjectUsage subjectUsage;
#   define listIdentifier_present 0x40
    ListIdentifier listIdentifier;
#   define sequenceNumber_present 0x20
    HUGEINTEGER sequenceNumber;
    ChoiceOfTime ctlThisUpdate;
#   define ctlNextUpdate_present 0x10
    ChoiceOfTime ctlNextUpdate;
    AlgorithmIdentifier subjectAlgorithm;
#   define trustedSubjects_present 0x8
    TrustedSubjects trustedSubjects;
#   define ctlExtensions_present 0x4
    Extensions ctlExtensions;
} CertificateTrustList;
#define CertificateTrustList_PDU 58
#define SIZE_X509_Module_PDU_58 sizeof(CertificateTrustList)

typedef struct NameConstraints {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define permittedSubtrees_present 0x80
    GeneralSubtrees permittedSubtrees;
#   define excludedSubtrees_present 0x40
    GeneralSubtrees excludedSubtrees;
} NameConstraints;
#define NameConstraints_PDU 59
#define SIZE_X509_Module_PDU_59 sizeof(NameConstraints)

typedef struct GeneralSubtree {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    GeneralName base;
#   define minimum_present 0x80
    BaseDistance minimum;
#   define maximum_present 0x40
    BaseDistance maximum;
} GeneralSubtree;

typedef struct CrossCertDistPoints {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define syncDeltaTime_present 0x80
    ASN1uint32_t syncDeltaTime;
    CrossCertDistPointNames crossCertDistPointNames;
} CrossCertDistPoints;
#define CrossCertDistPoints_PDU 60
#define SIZE_X509_Module_PDU_60 sizeof(CrossCertDistPoints)

typedef struct CmcData {
    ControlSequence controlSequence;
    ReqSequence reqSequence;
    CmsSequence cmsSequence;
    OtherMsgSequence otherMsgSequence;
} CmcData;
#define CmcData_PDU 61
#define SIZE_X509_Module_PDU_61 sizeof(CmcData)

typedef struct CmcResponseBody {
    ControlSequence controlSequence;
    CmsSequence cmsSequence;
    OtherMsgSequence otherMsgSequence;
} CmcResponseBody;
#define CmcResponseBody_PDU 62
#define SIZE_X509_Module_PDU_62 sizeof(CmcResponseBody)

typedef struct TaggedRequest {
    ASN1choice_t choice;
    union {
#	define tcr_chosen 1
	TaggedCertificationRequest tcr;
    } u;
} TaggedRequest;

typedef struct CmcStatusInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint32_t cmcStatus;
    BodyPartIDSequence bodyList;
#   define statusString_present 0x80
    UTF8STRING statusString;
#   define otherInfo_present 0x40
    CmcStatusInfo_otherInfo otherInfo;
} CmcStatusInfo;
#define CmcStatusInfo_PDU 63
#define SIZE_X509_Module_PDU_63 sizeof(CmcStatusInfo)

extern ASN1bool_t IssuingDistributionPoint_indirectCRL_default;
extern ASN1bool_t IssuingDistributionPoint_onlyContainsCACerts_default;
extern ASN1bool_t IssuingDistributionPoint_onlyContainsUserCerts_default;
extern BaseDistance GeneralSubtree_minimum_default;
extern CTLVersion CertificateTrustList_version_default;
extern ASN1bool_t BasicConstraints2_cA_default;
extern ASN1bool_t Extension_critical_default;
extern CertificateVersion CertificateToBeSigned_version_default;

extern ASN1module_t X509_Module;
extern void ASN1CALL X509_Module_Startup(void);
extern void ASN1CALL X509_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _X509_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\chain\api.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       api.cpp
//
//  Contents:   Certificate Chaining Infrastructure
//
//  History:    28-Jan-98    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>

//
// Globals
//

HMODULE                g_hCryptnet = NULL;
CRITICAL_SECTION       g_CryptnetLock;
CDefaultChainEngineMgr DefaultChainEngineMgr;

CRITICAL_SECTION       g_RoamingLogoffNotificationLock;
BOOL                   g_fRoamingLogoffNotificationInitialized = FALSE;


HMODULE                g_hChainInst;

VOID WINAPI
CreateRoamingLogoffNotificationEvent();
VOID WINAPI
InitializeRoamingLogoffNotification();
VOID WINAPI
UninitializeRoamingLogoffNotification();

//+---------------------------------------------------------------------------
//
//  Function:   ChainDllMain
//
//  Synopsis:   Chaining infrastructure initialization
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainDllMain (
     IN HMODULE hModule,
     IN ULONG ulReason,
     IN LPVOID pvReserved
     )
{
    BOOL fResult = TRUE;

    switch ( ulReason )
    {
    case DLL_PROCESS_ATTACH:

        g_hChainInst = hModule;

        fResult = Pki_InitializeCriticalSection( &g_CryptnetLock );
        if (fResult)
        {
            fResult = Pki_InitializeCriticalSection(
                &g_RoamingLogoffNotificationLock );

            if (fResult)
            {
                fResult = DefaultChainEngineMgr.Initialize();
                if (fResult)
                {
                    CreateRoamingLogoffNotificationEvent();
                }
                else
                {
                    DeleteCriticalSection( &g_RoamingLogoffNotificationLock );
                }
            }

            if (!fResult)
            {
                DeleteCriticalSection( &g_CryptnetLock );
            }
        }

        break;
    case DLL_PROCESS_DETACH:

        UninitializeRoamingLogoffNotification();

        DefaultChainEngineMgr.Uninitialize();

        if ( g_hCryptnet != NULL )
        {
            FreeLibrary( g_hCryptnet );
        }

        DeleteCriticalSection( &g_CryptnetLock );
        DeleteCriticalSection( &g_RoamingLogoffNotificationLock );
        break;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   InternalCertCreateCertificateChainEngine
//
//  Synopsis:   create a chain engine handle
//
//----------------------------------------------------------------------------
BOOL WINAPI
InternalCertCreateCertificateChainEngine (
    IN PCERT_CHAIN_ENGINE_CONFIG pConfig,
    IN BOOL fDefaultEngine,
    OUT HCERTCHAINENGINE* phChainEngine
    )
{
    BOOL                     fResult = TRUE;
    PCCERTCHAINENGINE        pChainEngine = NULL;
    CERT_CHAIN_ENGINE_CONFIG Config;

    if ( pConfig->cbSize != sizeof( CERT_CHAIN_ENGINE_CONFIG ) )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    Config = *pConfig;

    if ( Config.MaximumCachedCertificates == 0 )
    {
        Config.MaximumCachedCertificates = DEFAULT_MAX_INDEX_ENTRIES;
    }

    pChainEngine = new CCertChainEngine( &Config, fDefaultEngine, fResult );
    if ( pChainEngine == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        *phChainEngine = (HCERTCHAINENGINE)pChainEngine;
    }
    else
    {
        delete pChainEngine;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertCreateCertificateChainEngine
//
//  Synopsis:   create a certificate chain engine
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertCreateCertificateChainEngine (
    IN PCERT_CHAIN_ENGINE_CONFIG pConfig,
    OUT HCERTCHAINENGINE* phChainEngine
    )
{
    return( InternalCertCreateCertificateChainEngine(
                    pConfig,
                    FALSE,
                    phChainEngine
                    ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertFreeCertificateChainEngine
//
//  Synopsis:   free the chain engine handle
//
//----------------------------------------------------------------------------
VOID WINAPI
CertFreeCertificateChainEngine (
    IN HCERTCHAINENGINE hChainEngine
    )
{
    if ( ( hChainEngine == HCCE_CURRENT_USER ) ||
         ( hChainEngine == HCCE_LOCAL_MACHINE ) )
    {
        DefaultChainEngineMgr.FlushDefaultEngine( hChainEngine );
        return;
    }

    ( (PCCERTCHAINENGINE)hChainEngine )->Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   CertResyncCertificateChainEngine
//
//  Synopsis:   resync the chain engine
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertResyncCertificateChainEngine (
    IN HCERTCHAINENGINE hChainEngine
    )
{
    BOOL                fResult;
    PCCERTCHAINENGINE   pChainEngine = (PCCERTCHAINENGINE)hChainEngine;
    PCCHAINCALLCONTEXT  pCallContext = NULL;

    if ( ( hChainEngine == HCCE_LOCAL_MACHINE ) ||
         ( hChainEngine == HCCE_CURRENT_USER ) )
    {
        if ( DefaultChainEngineMgr.GetDefaultEngine(
                                      hChainEngine,
                                      (HCERTCHAINENGINE *)&pChainEngine
                                      ) == FALSE )
        {
            return( FALSE );
        }
    }
    else
    {
        pChainEngine->AddRef();
    }

    fResult = CallContextCreateCallObject(
            pChainEngine,
            NULL,                   // pRequestedTime
            NULL,                   // pChainPara
            CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL,
            &pCallContext
            );

    if (fResult)
    {

        pChainEngine->LockEngine();

        fResult = pChainEngine->Resync( pCallContext, TRUE );

        CertPerfIncrementChainRequestedEngineResyncCount();

        pChainEngine->UnlockEngine();

        CallContextFreeCallObject(pCallContext);
    }

    pChainEngine->Release();

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertGetCertificateChain
//
//  Synopsis:   get the certificate chain for the given end certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertGetCertificateChain (
    IN OPTIONAL HCERTCHAINENGINE hChainEngine,
    IN PCCERT_CONTEXT pCertContext,
    IN OPTIONAL LPFILETIME pTime,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN OPTIONAL PCERT_CHAIN_PARA pChainPara,
    IN DWORD dwFlags,
    IN LPVOID pvReserved,
    OUT PCCERT_CHAIN_CONTEXT* ppChainContext
    )
{
    BOOL              fResult;
    PCCERTCHAINENGINE pChainEngine = (PCCERTCHAINENGINE)hChainEngine;

    InitializeRoamingLogoffNotification();

    if ( ( pChainPara == NULL ) || ( pvReserved != NULL ) )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    if ( ( hChainEngine == HCCE_LOCAL_MACHINE ) ||
         ( hChainEngine == HCCE_CURRENT_USER ) )
    {
        if ( DefaultChainEngineMgr.GetDefaultEngine(
                                      hChainEngine,
                                      (HCERTCHAINENGINE *)&pChainEngine
                                      ) == FALSE )
        {
            return( FALSE );
        }
    }
    else
    {
        pChainEngine->AddRef();
    }

    fResult = pChainEngine->GetChainContext(
                               pCertContext,
                               pTime,
                               hAdditionalStore,
                               pChainPara,
                               dwFlags,
                               pvReserved,
                               ppChainContext
                               );

    pChainEngine->Release();

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertFreeCertificateChain
//
//  Synopsis:   free a certificate chain context
//
//----------------------------------------------------------------------------
VOID WINAPI
CertFreeCertificateChain (
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    ChainReleaseInternalChainContext(
         (PINTERNAL_CERT_CHAIN_CONTEXT)pChainContext
         );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertDuplicateCertificateChain
//
//  Synopsis:   duplicate (add a reference to) a certificate chain
//
//----------------------------------------------------------------------------
PCCERT_CHAIN_CONTEXT WINAPI
CertDuplicateCertificateChain (
    IN PCCERT_CHAIN_CONTEXT pChainContext
    )
{
    ChainAddRefInternalChainContext(
         (PINTERNAL_CERT_CHAIN_CONTEXT)pChainContext
         );

    return( pChainContext );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetCryptnetModule
//
//  Synopsis:   get the cryptnet.dll module handle
//
//----------------------------------------------------------------------------
HMODULE WINAPI
ChainGetCryptnetModule ()
{
    HMODULE hModule;

    EnterCriticalSection( &g_CryptnetLock );

    if ( g_hCryptnet == NULL )
    {
        g_hCryptnet = LoadLibraryA( "cryptnet.dll" );
    }

    hModule = g_hCryptnet;

    LeaveCriticalSection( &g_CryptnetLock );

    return( hModule );
}



//+===========================================================================
//  RegisterWaitForSingleObject and UnregisterWaitEx are only supported
//  in kernel32.dll on NT5.
//
//  Internal functions to do dynamic calls
//-===========================================================================

typedef BOOL (WINAPI *PFN_REGISTER_WAIT_FOR_SINGLE_OBJECT)(
    PHANDLE hNewWaitObject,
    HANDLE hObject,
    WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    );

typedef BOOL (WINAPI *PFN_UNREGISTER_WAIT_EX)(
    HANDLE WaitHandle,
    HANDLE CompletionEvent      // INVALID_HANDLE_VALUE => create event
                                // to wait for
    );

#define sz_KERNEL32_DLL                 "kernel32.dll"
#define sz_RegisterWaitForSingleObject  "RegisterWaitForSingleObject"
#define sz_UnregisterWaitEx             "UnregisterWaitEx"

BOOL
WINAPI
InternalRegisterWaitForSingleObject(
    PHANDLE hNewWaitObject,
    HANDLE hObject,
    WAITORTIMERCALLBACK Callback,
    PVOID Context,
    ULONG dwMilliseconds,
    ULONG dwFlags
    )
{
    BOOL fResult;
    HMODULE hKernel32Dll = NULL;
    PFN_REGISTER_WAIT_FOR_SINGLE_OBJECT pfnRegisterWaitForSingleObject;

    if (NULL == (hKernel32Dll = LoadLibraryA(sz_KERNEL32_DLL)))
        goto LoadKernel32DllError;

    if (NULL == (pfnRegisterWaitForSingleObject =
            (PFN_REGISTER_WAIT_FOR_SINGLE_OBJECT) GetProcAddress(
                hKernel32Dll, sz_RegisterWaitForSingleObject)))
        goto GetRegisterWaitForSingleObjectProcAddressError;

    fResult = pfnRegisterWaitForSingleObject(
        hNewWaitObject,
        hObject,
        Callback,
        Context,
        dwMilliseconds,
        dwFlags
        );

CommonReturn:
    if (hKernel32Dll) {
        DWORD dwErr = GetLastError();
        FreeLibrary(hKernel32Dll);
        SetLastError(dwErr);
    }
    return fResult;
ErrorReturn:
    *hNewWaitObject = NULL;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(LoadKernel32DllError)
TRACE_ERROR(GetRegisterWaitForSingleObjectProcAddressError)
}

BOOL
WINAPI
InternalUnregisterWaitEx(
    HANDLE WaitHandle,
    HANDLE CompletionEvent      // INVALID_HANDLE_VALUE => create event
                                // to wait for
    )
{
    BOOL fResult;
    HMODULE hKernel32Dll = NULL;
    PFN_UNREGISTER_WAIT_EX pfnUnregisterWaitEx;

    if (NULL == (hKernel32Dll = LoadLibraryA(sz_KERNEL32_DLL)))
        goto LoadKernel32DllError;
    if (NULL == (pfnUnregisterWaitEx =
            (PFN_UNREGISTER_WAIT_EX) GetProcAddress(
                hKernel32Dll, sz_UnregisterWaitEx)))
        goto GetUnregisterWaitExProcAddressError;

    fResult = pfnUnregisterWaitEx(
        WaitHandle,
        CompletionEvent
        );

CommonReturn:
    if (hKernel32Dll) {
        DWORD dwErr = GetLastError();
        FreeLibrary(hKernel32Dll);
        SetLastError(dwErr);
    }
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(LoadKernel32DllError)
TRACE_ERROR(GetUnregisterWaitExProcAddressError)
}

//+===========================================================================
//  We only get logoff notification in winlogon.exe.
//
//  The work around is to have the winlogon ChainWlxLogoffEvent pulse a
//  named event. All processes where crypt32.dll is loaded will be doing
//  a RegisterWaitForObject for this event.
//
//  Note, there is a very small window where we might not be waiting at the
//  time the event is pulsed.
//-===========================================================================

#define CRYPT32_LOGOFF_EVENT    "Global\\crypt32LogoffEvent"

HANDLE g_hLogoffEvent;
HANDLE g_hLogoffRegWaitFor;

typedef BOOL (WINAPI *PFN_WLX_LOGOFF)(
    PWLX_NOTIFICATION_INFO pNotificationInfo
    );

VOID NTAPI LogoffWaitForCallback(
    PVOID Context,
    BOOLEAN fWaitOrTimedOut        // ???
    )
{
    HMODULE hModule;

    CertFreeCertificateChainEngine( HCCE_CURRENT_USER );

    // Only call if cryptnet has been loaded
    if (NULL != GetModuleHandleA("cryptnet.dll")) {
        hModule = ChainGetCryptnetModule();
        if (hModule) {
            PFN_WLX_LOGOFF pfn;

            pfn = (PFN_WLX_LOGOFF) GetProcAddress(hModule,
                "CryptnetWlxLogoffEvent");
            if (pfn)
                pfn(NULL);
        }
    }
}

// Note, the event must not be created while impersonating. That's why it
// is created at ProcessAttach.
VOID WINAPI
CreateRoamingLogoffNotificationEvent()
{
    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;

    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siaWorldSidAuthority =
        SECURITY_WORLD_SID_AUTHORITY;

    PSID psidLocalSystem = NULL;
    PSID psidEveryone = NULL;
    PACL pDacl = NULL;
    DWORD dwAclSize;

    if (!FIsWinNT5())
        return;

    // Allow Everyone to have SYNCHRONIZE access to the logoff event.
    // Only allow LocalSystem to have ALL access
    if (!AllocateAndInitializeSid(
            &siaNtAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidLocalSystem
            )) 
        goto AllocateAndInitializeSidError;

    if (!AllocateAndInitializeSid(
            &siaWorldSidAuthority,
            1,
            SECURITY_WORLD_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidEveryone
            ))
        goto AllocateAndInitializeSidError;
    //
    // compute size of ACL
    //
    dwAclSize = sizeof(ACL) +
        2 * ( sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) ) +
        GetLengthSid(psidLocalSystem) +
        GetLengthSid(psidEveryone)
        ;

    //
    // allocate storage for Acl
    //
    if (NULL == (pDacl = (PACL) PkiNonzeroAlloc(dwAclSize)))
        goto OutOfMemory;

    if (!InitializeAcl(pDacl, dwAclSize, ACL_REVISION))
        goto InitializeAclError;

    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            EVENT_ALL_ACCESS,
            psidLocalSystem
            ))
        goto AddAceError;
    if (!AddAccessAllowedAce(
            pDacl,
            ACL_REVISION,
            SYNCHRONIZE,
            psidEveryone
            ))
        goto AddAceError;

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
        goto InitializeSecurityDescriptorError;
    if (!SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE))
        goto SetSecurityDescriptorDaclError;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;

    g_hLogoffEvent = CreateEventA(
        &sa,
        TRUE,           // fManualReset, must be TRUE to pulse all waitors
        FALSE,          // fInitialState
        CRYPT32_LOGOFF_EVENT
        );
    if (NULL == g_hLogoffEvent) {
        // Try to open with only SYNCHRONIZE access
        g_hLogoffEvent = OpenEventA(
            SYNCHRONIZE,
            FALSE,          // fInherit
            CRYPT32_LOGOFF_EVENT
            );
        if (NULL == g_hLogoffEvent)
            goto CreateEventError;
    }

CommonReturn:
    if (psidLocalSystem)
        FreeSid(psidLocalSystem);
    if (psidEveryone)
        FreeSid(psidEveryone);
    PkiFree(pDacl);

    return;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(AllocateAndInitializeSidError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(InitializeAclError)
TRACE_ERROR(AddAceError)
TRACE_ERROR(InitializeSecurityDescriptorError)
TRACE_ERROR(SetSecurityDescriptorDaclError)
TRACE_ERROR(CreateEventError)
}

VOID WINAPI
InitializeRoamingLogoffNotification()
{
    if (!FIsWinNT5())
        return;
    if (g_fRoamingLogoffNotificationInitialized)
        return;

    EnterCriticalSection(&g_RoamingLogoffNotificationLock);

    if (g_fRoamingLogoffNotificationInitialized)
        goto CommonReturn;
    if (NULL == g_hLogoffEvent)
        goto NoLogoffEvent;

    // No need to do roaming logoff notification for TS processes
    if (0 != GetSystemMetrics(SM_REMOTESESSION))
        goto CommonReturn;

    // Note, this can't be called at ProcessAttach
    if (!InternalRegisterWaitForSingleObject(
            &g_hLogoffRegWaitFor,
            g_hLogoffEvent,
            LogoffWaitForCallback,
            NULL,                   // Context
            INFINITE,               // no timeout
            WT_EXECUTEINWAITTHREAD
            ))
        goto RegisterWaitForError;

CommonReturn:
    g_fRoamingLogoffNotificationInitialized = TRUE;
    LeaveCriticalSection(&g_RoamingLogoffNotificationLock);
    return;
ErrorReturn:
    goto CommonReturn;
SET_ERROR(NoLogoffEvent, E_UNEXPECTED)
TRACE_ERROR(RegisterWaitForError)
}

VOID WINAPI
UninitializeRoamingLogoffNotification()
{
    if (g_hLogoffRegWaitFor) {
        InternalUnregisterWaitEx(g_hLogoffRegWaitFor, INVALID_HANDLE_VALUE);
        g_hLogoffRegWaitFor = NULL;
    }

    if (g_hLogoffEvent) {
        CloseHandle(g_hLogoffEvent);
        g_hLogoffEvent = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainWlxLogoffEvent
//
//  Synopsis:   logoff event processing
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainWlxLogoffEvent (PWLX_NOTIFICATION_INFO pNotificationInfo)
{
    if (g_hLogoffRegWaitFor) {
        InternalUnregisterWaitEx(g_hLogoffRegWaitFor, INVALID_HANDLE_VALUE);
        g_hLogoffRegWaitFor = NULL;
    }

    CertFreeCertificateChainEngine( HCCE_CURRENT_USER );

    if (g_hLogoffEvent) {
        // Trigger all non-winlogon processes to do logoff processing
        PulseEvent(g_hLogoffEvent);
    }
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\chain\callctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       callctx.cpp
//
//  Contents:   Certificate Chaining Infrastructure Call Context
//
//  History:    02-Mar-98    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CChainCallContext::CChainCallContext, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CChainCallContext::CChainCallContext (
                         IN PCCERTCHAINENGINE pChainEngine,
                         IN OPTIONAL LPFILETIME pRequestedTime,
                         IN OPTIONAL PCERT_CHAIN_PARA pChainPara,
                         IN DWORD dwFlags,
                         OUT BOOL& rfResult
                         )
{
    LRU_CACHE_CONFIG Config;

    m_hObjectCreationCache = NULL;
    m_pChainEngine = pChainEngine;
    GetSystemTimeAsFileTime(&m_CurrentTime);
    if (pRequestedTime)
        m_RequestedTime = *pRequestedTime;
    else
        m_RequestedTime = m_CurrentTime;
    m_dwCallFlags = dwFlags;
    m_dwStatus = 0;
    m_dwTouchEngineCount = 0;
    // m_RevEndTime =       // Initialized by RevocationUrlRetrievalTimeout()

    m_dwAIAUrlRetrievalCount = 0;
    // m_AIAEndTime =       // Initialized by AIAUrlRetrievalTimeout()

    memset(&m_ChainPara, 0, sizeof(m_ChainPara));
    if (NULL != pChainPara)
        memcpy(&m_ChainPara, pChainPara, min(pChainPara->cbSize,
            sizeof(m_ChainPara)));
    m_ChainPara.cbSize = sizeof(m_ChainPara);

    if (0 == m_ChainPara.dwUrlRetrievalTimeout) {
        m_ChainPara.dwUrlRetrievalTimeout =
            pChainEngine->UrlRetrievalTimeout();
        m_fDefaultUrlRetrievalTimeout = 
            pChainEngine->HasDefaultUrlRetrievalTimeout();
    } else
        m_fDefaultUrlRetrievalTimeout = FALSE;


    memset( &Config, 0, sizeof( Config ) );

    Config.dwFlags = LRU_CACHE_NO_SERIALIZE | LRU_CACHE_NO_COPY_IDENTIFIER;
    Config.pfnHash = CertObjectCacheHashMd5Identifier;
    Config.pfnOnRemoval = CallContextOnCreationCacheObjectRemoval;
    Config.cBuckets = DEFAULT_CREATION_CACHE_BUCKETS;

    rfResult = I_CryptCreateLruCache( &Config, &m_hObjectCreationCache );
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainCallContext::~CChainCallContext, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CChainCallContext::~CChainCallContext ()
{
    if ( m_hObjectCreationCache != NULL )
    {
        I_CryptFreeLruCache( m_hObjectCreationCache, 0, NULL );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainCallContext::AddPathObjectToCreationCache, public
//
//  Synopsis:   add a path object to the creation cache
//
//----------------------------------------------------------------------------
BOOL
CChainCallContext::AddPathObjectToCreationCache (
                      IN PCCHAINPATHOBJECT pPathObject
                      )
{
    BOOL            fResult;
    CRYPT_DATA_BLOB DataBlob;
    HLRUENTRY       hEntry;

    DataBlob.cbData = CHAINHASHLEN;
    DataBlob.pbData = pPathObject->CertObject()->CertHash();

    fResult = I_CryptCreateLruEntry(
                     m_hObjectCreationCache,
                     &DataBlob,
                     pPathObject,
                     &hEntry
                     );

    if ( fResult == TRUE )
    {
        I_CryptInsertLruEntry( hEntry, pPathObject );
        I_CryptReleaseLruEntry( hEntry );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainCallContext::FindPathObjectInCreationCache, public
//
//  Synopsis:   find a path object in the creation cache
//
//----------------------------------------------------------------------------
PCCHAINPATHOBJECT
CChainCallContext::FindPathObjectInCreationCache (
                       IN BYTE rgbCertHash[ CHAINHASHLEN ]
                       )
{
    HLRUENTRY       hFound;
    PCCHAINPATHOBJECT    pFound = NULL;
    CRYPT_DATA_BLOB DataBlob;

    DataBlob.cbData = CHAINHASHLEN;
    DataBlob.pbData = rgbCertHash;

    hFound = I_CryptFindLruEntry( m_hObjectCreationCache, &DataBlob );
    if ( hFound != NULL )
    {
        pFound = (PCCHAINPATHOBJECT)I_CryptGetLruEntryData( hFound );

        I_CryptReleaseLruEntry( hFound );
    }

    return( pFound );
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainCallContext::RemovePathObjectFromCreationCache, public
//
//  Synopsis:   remove the specified path object from the creation cache
//
//----------------------------------------------------------------------------
VOID
CChainCallContext::RemovePathObjectFromCreationCache (
    IN PCCHAINPATHOBJECT pPathObject
    )
{
    HLRUENTRY hEntry;
    CRYPT_DATA_BLOB DataBlob;

    DataBlob.cbData = CHAINHASHLEN;
    DataBlob.pbData = pPathObject->CertObject()->CertHash();

    hEntry = I_CryptFindLruEntry( m_hObjectCreationCache, &DataBlob );
    while (NULL != hEntry) {
        PCCHAINPATHOBJECT pFound;

        pFound = (PCCHAINPATHOBJECT) I_CryptGetLruEntryData( hEntry );
        if (pFound == pPathObject) {
            I_CryptReleaseLruEntry( hEntry );
            I_CryptRemoveLruEntry( hEntry, 0, this );
            break;
        }

        hEntry = I_CryptEnumMatchingLruEntries(hEntry);
    }
}


DWORD CChainCallContext::RevocationUrlRetrievalTimeout()
{
    DWORD dwRevTimeout;

    if (m_dwCallFlags & CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT)
    {
        if (m_dwStatus & CHAINCALLCONTEXT_REV_END_TIME_FLAG)
        {
            dwRevTimeout = I_CryptRemainingMilliseconds(&m_RevEndTime);
            if (0 == dwRevTimeout)
                dwRevTimeout = 1;
        }
        else
        {
            FILETIME ftCurrent;

            if (m_fDefaultUrlRetrievalTimeout)
                dwRevTimeout = DEFAULT_REV_ACCUMULATIVE_URL_RETRIEVAL_TIMEOUT;
            else
                dwRevTimeout = m_ChainPara.dwUrlRetrievalTimeout;

            GetSystemTimeAsFileTime(&ftCurrent);
            I_CryptIncrementFileTimeByMilliseconds(&ftCurrent,
                dwRevTimeout, &m_RevEndTime);
            m_dwStatus |= CHAINCALLCONTEXT_REV_END_TIME_FLAG;
        }
    }
    else
    {
        dwRevTimeout = m_ChainPara.dwUrlRetrievalTimeout;
    }

    return dwRevTimeout;
}

DWORD CChainCallContext::AIAUrlRetrievalTimeout()
{
    DWORD dwAIATimeout;

    if (m_dwStatus & CHAINCALLCONTEXT_AIA_END_TIME_FLAG)
    {
        dwAIATimeout = I_CryptRemainingMilliseconds(&m_AIAEndTime) / 2;
        if (0 == dwAIATimeout)
            dwAIATimeout = 1;
    }
    else
    {
        FILETIME ftCurrent;

        dwAIATimeout = m_ChainPara.dwUrlRetrievalTimeout;

        GetSystemTimeAsFileTime(&ftCurrent);
        I_CryptIncrementFileTimeByMilliseconds(&ftCurrent,
            dwAIATimeout * 2, &m_AIAEndTime);
        m_dwStatus |= CHAINCALLCONTEXT_AIA_END_TIME_FLAG;
    }

    return dwAIATimeout;
}


BOOL
CChainCallContext::IsOnline ()
{
    if ( !(m_dwStatus & CHAINCALLCONTEXT_CHECKED_ONLINE_FLAG) )
    {
        if (!(m_pChainEngine->Flags() & CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL) &&
                !(m_dwCallFlags & CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL))
        {
            if ( ChainIsConnected() )
            {
                m_dwStatus |= CHAINCALLCONTEXT_ONLINE_FLAG;
            }
        }
        m_dwStatus |= CHAINCALLCONTEXT_CHECKED_ONLINE_FLAG;
    }

    if (m_dwStatus & CHAINCALLCONTEXT_ONLINE_FLAG)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL
CChainCallContext::IsTouchedEngine ()
{
    if (m_dwTouchEngineCount == m_pChainEngine->TouchEngineCount())
        return FALSE;
    else
        return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CallContextCreateCallObject
//
//  Synopsis:   create a chain call context object
//
//----------------------------------------------------------------------------
BOOL WINAPI
CallContextCreateCallObject (
    IN PCCERTCHAINENGINE pChainEngine,
    IN OPTIONAL LPFILETIME pRequestedTime,
    IN OPTIONAL PCERT_CHAIN_PARA pChainPara,
    IN DWORD dwFlags,
    OUT PCCHAINCALLCONTEXT* ppCallContext
    )
{
    BOOL               fResult = FALSE;
    PCCHAINCALLCONTEXT pCallContext;

    pCallContext = new CChainCallContext(
            pChainEngine,
            pRequestedTime,
            pChainPara,
            dwFlags,
            fResult
            );
    if ( pCallContext == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    if ( fResult == TRUE )
    {
        *ppCallContext = pCallContext;
    }
    else
    {
        CallContextFreeCallObject( pCallContext );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CallContextFreeCallObject
//
//  Synopsis:   free the chain call context object
//
//----------------------------------------------------------------------------
VOID WINAPI
CallContextFreeCallObject (
    IN PCCHAINCALLCONTEXT pCallContext
    )
{
    delete pCallContext;
}

//+---------------------------------------------------------------------------
//
//  Function:   CallContextOnCreationCacheObjectRemoval
//
//  Synopsis:   removal notification callback
//
//----------------------------------------------------------------------------
VOID WINAPI
CallContextOnCreationCacheObjectRemoval (
    IN LPVOID pv,
    IN LPVOID pvRemovalContext
    )
{
    delete (PCCHAINPATHOBJECT) pv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\certstor\x509.c ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for X509 v3 certificates */

#pragma warning(push,3)

#include <windows.h>
#include "x509.h"

#pragma warning (pop)

// unreferenced inline function has been removed
#pragma warning (disable: 4514)

// unreferenced formal parameter
#pragma warning (disable: 4100)

// assignment within conditional expression
#pragma warning (disable: 4706)

ASN1module_t X509_Module = NULL;

static int ASN1CALL ASN1Enc_EncodedObjectID(ASN1encoding_t enc, ASN1uint32_t tag, EncodedObjectID *val);
static int ASN1CALL ASN1Enc_Bits(ASN1encoding_t enc, ASN1uint32_t tag, Bits *val);
static int ASN1CALL ASN1Enc_IntegerType(ASN1encoding_t enc, ASN1uint32_t tag, IntegerType *val);
static int ASN1CALL ASN1Enc_HugeIntegerType(ASN1encoding_t enc, ASN1uint32_t tag, HugeIntegerType *val);
static int ASN1CALL ASN1Enc_OctetStringType(ASN1encoding_t enc, ASN1uint32_t tag, OctetStringType *val);
static int ASN1CALL ASN1Enc_EnumeratedType(ASN1encoding_t enc, ASN1uint32_t tag, EnumeratedType *val);
static int ASN1CALL ASN1Enc_UtcTime(ASN1encoding_t enc, ASN1uint32_t tag, UtcTime *val);
static int ASN1CALL ASN1Enc_NoticeReference_noticeNumbers(ASN1encoding_t enc, ASN1uint32_t tag, NoticeReference_noticeNumbers *val);
static int ASN1CALL ASN1Enc_AnyString(ASN1encoding_t enc, ASN1uint32_t tag, AnyString *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_Name(ASN1encoding_t enc, ASN1uint32_t tag, Name *val);
static int ASN1CALL ASN1Enc_RelativeDistinguishedName(ASN1encoding_t enc, ASN1uint32_t tag, RelativeDistinguishedName *val);
static int ASN1CALL ASN1Enc_AttributeTypeValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeTypeValue *val);
static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Enc_RSAPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPublicKey *val);
static int ASN1CALL ASN1Enc_DSSParameters(ASN1encoding_t enc, ASN1uint32_t tag, DSSParameters *val);
static int ASN1CALL ASN1Enc_DSSSignature(ASN1encoding_t enc, ASN1uint32_t tag, DSSSignature *val);
static int ASN1CALL ASN1Enc_DHParameters(ASN1encoding_t enc, ASN1uint32_t tag, DHParameters *val);
static int ASN1CALL ASN1Enc_X942DhValidationParams(ASN1encoding_t enc, ASN1uint32_t tag, X942DhValidationParams *val);
static int ASN1CALL ASN1Enc_X942DhKeySpecificInfo(ASN1encoding_t enc, ASN1uint32_t tag, X942DhKeySpecificInfo *val);
static int ASN1CALL ASN1Enc_RC2CBCParameters(ASN1encoding_t enc, ASN1uint32_t tag, RC2CBCParameters *val);
static int ASN1CALL ASN1Enc_SMIMECapability(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapability *val);
static int ASN1CALL ASN1Enc_SMIMECapabilities(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapabilities *val);
static int ASN1CALL ASN1Enc_SubjectPublicKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, SubjectPublicKeyInfo *val);
static int ASN1CALL ASN1Enc_ChoiceOfTime(ASN1encoding_t enc, ASN1uint32_t tag, ChoiceOfTime *val);
static int ASN1CALL ASN1Enc_Validity(ASN1encoding_t enc, ASN1uint32_t tag, Validity *val);
static int ASN1CALL ASN1Enc_Extensions(ASN1encoding_t enc, ASN1uint32_t tag, Extensions *val);
static int ASN1CALL ASN1Enc_Extension(ASN1encoding_t enc, ASN1uint32_t tag, Extension *val);
static int ASN1CALL ASN1Enc_SignedContent(ASN1encoding_t enc, ASN1uint32_t tag, SignedContent *val);
static int ASN1CALL ASN1Enc_RevokedCertificates(ASN1encoding_t enc, ASN1uint32_t tag, RevokedCertificates *val);
static int ASN1CALL ASN1Enc_CRLEntry(ASN1encoding_t enc, ASN1uint32_t tag, CRLEntry *val);
static int ASN1CALL ASN1Enc_CertificationRequestInfo(ASN1encoding_t enc, ASN1uint32_t tag, CertificationRequestInfo *val);
static int ASN1CALL ASN1Enc_CertificationRequestInfoDecode(ASN1encoding_t enc, ASN1uint32_t tag, CertificationRequestInfoDecode *val);
static int ASN1CALL ASN1Enc_KeygenRequestInfo(ASN1encoding_t enc, ASN1uint32_t tag, KeygenRequestInfo *val);
static int ASN1CALL ASN1Enc_AuthorityKeyId(ASN1encoding_t enc, ASN1uint32_t tag, AuthorityKeyId *val);
static int ASN1CALL ASN1Enc_PrivateKeyValidity(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyValidity *val);
static int ASN1CALL ASN1Enc_CertPolicySet(ASN1encoding_t enc, ASN1uint32_t tag, CertPolicySet *val);
static int ASN1CALL ASN1Enc_CertPolicyId(ASN1encoding_t enc, ASN1uint32_t tag, CertPolicyId *val);
static int ASN1CALL ASN1Enc_AltNames(ASN1encoding_t enc, ASN1uint32_t tag, AltNames *val);
static int ASN1CALL ASN1Enc_GeneralNames(ASN1encoding_t enc, ASN1uint32_t tag, GeneralNames *val);
static int ASN1CALL ASN1Enc_OtherName(ASN1encoding_t enc, ASN1uint32_t tag, OtherName *val);
static int ASN1CALL ASN1Enc_EDIPartyName(ASN1encoding_t enc, ASN1uint32_t tag, EDIPartyName *val);
static int ASN1CALL ASN1Enc_SubtreesConstraint(ASN1encoding_t enc, ASN1uint32_t tag, SubtreesConstraint *val);
static int ASN1CALL ASN1Enc_BasicConstraints2(ASN1encoding_t enc, ASN1uint32_t tag, BasicConstraints2 *val);
static int ASN1CALL ASN1Enc_CertificatePolicies(ASN1encoding_t enc, ASN1uint32_t tag, CertificatePolicies *val);
static int ASN1CALL ASN1Enc_PolicyQualifiers(ASN1encoding_t enc, ASN1uint32_t tag, PolicyQualifiers *val);
static int ASN1CALL ASN1Enc_PolicyQualifierInfo(ASN1encoding_t enc, ASN1uint32_t tag, PolicyQualifierInfo *val);
static int ASN1CALL ASN1Enc_NoticeReference(ASN1encoding_t enc, ASN1uint32_t tag, NoticeReference *val);
static int ASN1CALL ASN1Enc_DisplayText(ASN1encoding_t enc, ASN1uint32_t tag, DisplayText *val);
static int ASN1CALL ASN1Enc_CertificatePolicies95(ASN1encoding_t enc, ASN1uint32_t tag, CertificatePolicies95 *val);
static int ASN1CALL ASN1Enc_CpsURLs(ASN1encoding_t enc, ASN1uint32_t tag, CpsURLs *val);
static int ASN1CALL ASN1Enc_AuthorityKeyId2(ASN1encoding_t enc, ASN1uint32_t tag, AuthorityKeyId2 *val);
static int ASN1CALL ASN1Enc_AuthorityInfoAccess(ASN1encoding_t enc, ASN1uint32_t tag, AuthorityInfoAccess *val);
static int ASN1CALL ASN1Enc_CRLDistributionPoints(ASN1encoding_t enc, ASN1uint32_t tag, CRLDistributionPoints *val);
static int ASN1CALL ASN1Enc_DistributionPointName(ASN1encoding_t enc, ASN1uint32_t tag, DistributionPointName *val);
static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Enc_SeqOfAny(ASN1encoding_t enc, ASN1uint32_t tag, SeqOfAny *val);
static int ASN1CALL ASN1Enc_TimeStampRequest(ASN1encoding_t enc, ASN1uint32_t tag, TimeStampRequest *val);
static int ASN1CALL ASN1Enc_ContentInfoOTS(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfoOTS *val);
static int ASN1CALL ASN1Enc_TimeStampRequestOTS(ASN1encoding_t enc, ASN1uint32_t tag, TimeStampRequestOTS *val);
static int ASN1CALL ASN1Enc_EnhancedKeyUsage(ASN1encoding_t enc, ASN1uint32_t tag, EnhancedKeyUsage *val);
static int ASN1CALL ASN1Enc_SubjectUsage(ASN1encoding_t enc, ASN1uint32_t tag, SubjectUsage *val);
static int ASN1CALL ASN1Enc_TrustedSubjects(ASN1encoding_t enc, ASN1uint32_t tag, TrustedSubjects *val);
static int ASN1CALL ASN1Enc_TrustedSubject(ASN1encoding_t enc, ASN1uint32_t tag, TrustedSubject *val);
static int ASN1CALL ASN1Enc_EnrollmentNameValuePair(ASN1encoding_t enc, ASN1uint32_t tag, EnrollmentNameValuePair *val);
static int ASN1CALL ASN1Enc_CSPProvider(ASN1encoding_t enc, ASN1uint32_t tag, CSPProvider *val);
static int ASN1CALL ASN1Enc_CertificatePair(ASN1encoding_t enc, ASN1uint32_t tag, CertificatePair *val);
static int ASN1CALL ASN1Enc_GeneralSubtrees(ASN1encoding_t enc, ASN1uint32_t tag, GeneralSubtrees *val);
static int ASN1CALL ASN1Enc_IssuingDistributionPoint(ASN1encoding_t enc, ASN1uint32_t tag, IssuingDistributionPoint *val);
static int ASN1CALL ASN1Enc_CrossCertDistPointNames(ASN1encoding_t enc, ASN1uint32_t tag, CrossCertDistPointNames *val);
static int ASN1CALL ASN1Enc_PolicyMappings(ASN1encoding_t enc, ASN1uint32_t tag, PolicyMappings *val);
static int ASN1CALL ASN1Enc_PolicyMapping(ASN1encoding_t enc, ASN1uint32_t tag, PolicyMapping *val);
static int ASN1CALL ASN1Enc_PolicyConstraints(ASN1encoding_t enc, ASN1uint32_t tag, PolicyConstraints *val);
static int ASN1CALL ASN1Enc_ControlSequence(ASN1encoding_t enc, ASN1uint32_t tag, ControlSequence *val);
static int ASN1CALL ASN1Enc_ReqSequence(ASN1encoding_t enc, ASN1uint32_t tag, ReqSequence *val);
static int ASN1CALL ASN1Enc_CmsSequence(ASN1encoding_t enc, ASN1uint32_t tag, CmsSequence *val);
static int ASN1CALL ASN1Enc_OtherMsgSequence(ASN1encoding_t enc, ASN1uint32_t tag, OtherMsgSequence *val);
static int ASN1CALL ASN1Enc_BodyPartIDSequence(ASN1encoding_t enc, ASN1uint32_t tag, BodyPartIDSequence *val);
static int ASN1CALL ASN1Enc_TaggedAttribute(ASN1encoding_t enc, ASN1uint32_t tag, TaggedAttribute *val);
static int ASN1CALL ASN1Enc_TaggedCertificationRequest(ASN1encoding_t enc, ASN1uint32_t tag, TaggedCertificationRequest *val);
static int ASN1CALL ASN1Enc_TaggedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, TaggedContentInfo *val);
static int ASN1CALL ASN1Enc_TaggedOtherMsg(ASN1encoding_t enc, ASN1uint32_t tag, TaggedOtherMsg *val);
static int ASN1CALL ASN1Enc_PendInfo(ASN1encoding_t enc, ASN1uint32_t tag, PendInfo *val);
static int ASN1CALL ASN1Enc_CmcAddExtensions(ASN1encoding_t enc, ASN1uint32_t tag, CmcAddExtensions *val);
static int ASN1CALL ASN1Enc_CmcAddAttributes(ASN1encoding_t enc, ASN1uint32_t tag, CmcAddAttributes *val);
static int ASN1CALL ASN1Enc_CertificateTemplate(ASN1encoding_t enc, ASN1uint32_t tag, CertificateTemplate *val);
static int ASN1CALL ASN1Enc_CmcStatusInfo_otherInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmcStatusInfo_otherInfo *val);
static int ASN1CALL ASN1Enc_CpsURLs_Seq(ASN1encoding_t enc, ASN1uint32_t tag, CpsURLs_Seq *val);
static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Enc_X942DhParameters(ASN1encoding_t enc, ASN1uint32_t tag, X942DhParameters *val);
static int ASN1CALL ASN1Enc_X942DhOtherInfo(ASN1encoding_t enc, ASN1uint32_t tag, X942DhOtherInfo *val);
static int ASN1CALL ASN1Enc_CertificateToBeSigned(ASN1encoding_t enc, ASN1uint32_t tag, CertificateToBeSigned *val);
static int ASN1CALL ASN1Enc_CertificateRevocationListToBeSigned(ASN1encoding_t enc, ASN1uint32_t tag, CertificateRevocationListToBeSigned *val);
static int ASN1CALL ASN1Enc_KeyAttributes(ASN1encoding_t enc, ASN1uint32_t tag, KeyAttributes *val);
static int ASN1CALL ASN1Enc_KeyUsageRestriction(ASN1encoding_t enc, ASN1uint32_t tag, KeyUsageRestriction *val);
static int ASN1CALL ASN1Enc_GeneralName(ASN1encoding_t enc, ASN1uint32_t tag, GeneralName *val);
static int ASN1CALL ASN1Enc_BasicConstraints(ASN1encoding_t enc, ASN1uint32_t tag, BasicConstraints *val);
static int ASN1CALL ASN1Enc_PolicyInformation(ASN1encoding_t enc, ASN1uint32_t tag, PolicyInformation *val);
static int ASN1CALL ASN1Enc_UserNotice(ASN1encoding_t enc, ASN1uint32_t tag, UserNotice *val);
static int ASN1CALL ASN1Enc_VerisignQualifier1(ASN1encoding_t enc, ASN1uint32_t tag, VerisignQualifier1 *val);
static int ASN1CALL ASN1Enc_AccessDescription(ASN1encoding_t enc, ASN1uint32_t tag, AccessDescription *val);
static int ASN1CALL ASN1Enc_DistributionPoint(ASN1encoding_t enc, ASN1uint32_t tag, DistributionPoint *val);
static int ASN1CALL ASN1Enc_ContentInfoSeqOfAny(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfoSeqOfAny *val);
static int ASN1CALL ASN1Enc_CertificateTrustList(ASN1encoding_t enc, ASN1uint32_t tag, CertificateTrustList *val);
static int ASN1CALL ASN1Enc_NameConstraints(ASN1encoding_t enc, ASN1uint32_t tag, NameConstraints *val);
static int ASN1CALL ASN1Enc_GeneralSubtree(ASN1encoding_t enc, ASN1uint32_t tag, GeneralSubtree *val);
static int ASN1CALL ASN1Enc_CrossCertDistPoints(ASN1encoding_t enc, ASN1uint32_t tag, CrossCertDistPoints *val);
static int ASN1CALL ASN1Enc_CmcData(ASN1encoding_t enc, ASN1uint32_t tag, CmcData *val);
static int ASN1CALL ASN1Enc_CmcResponseBody(ASN1encoding_t enc, ASN1uint32_t tag, CmcResponseBody *val);
static int ASN1CALL ASN1Enc_TaggedRequest(ASN1encoding_t enc, ASN1uint32_t tag, TaggedRequest *val);
static int ASN1CALL ASN1Enc_CmcStatusInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmcStatusInfo *val);
static int ASN1CALL ASN1Dec_EncodedObjectID(ASN1decoding_t dec, ASN1uint32_t tag, EncodedObjectID *val);
static int ASN1CALL ASN1Dec_Bits(ASN1decoding_t dec, ASN1uint32_t tag, Bits *val);
static int ASN1CALL ASN1Dec_IntegerType(ASN1decoding_t dec, ASN1uint32_t tag, IntegerType *val);
static int ASN1CALL ASN1Dec_HugeIntegerType(ASN1decoding_t dec, ASN1uint32_t tag, HugeIntegerType *val);
static int ASN1CALL ASN1Dec_OctetStringType(ASN1decoding_t dec, ASN1uint32_t tag, OctetStringType *val);
static int ASN1CALL ASN1Dec_EnumeratedType(ASN1decoding_t dec, ASN1uint32_t tag, EnumeratedType *val);
static int ASN1CALL ASN1Dec_UtcTime(ASN1decoding_t dec, ASN1uint32_t tag, UtcTime *val);
static int ASN1CALL ASN1Dec_NoticeReference_noticeNumbers(ASN1decoding_t dec, ASN1uint32_t tag, NoticeReference_noticeNumbers *val);
static int ASN1CALL ASN1Dec_AnyString(ASN1decoding_t dec, ASN1uint32_t tag, AnyString *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_Name(ASN1decoding_t dec, ASN1uint32_t tag, Name *val);
static int ASN1CALL ASN1Dec_RelativeDistinguishedName(ASN1decoding_t dec, ASN1uint32_t tag, RelativeDistinguishedName *val);
static int ASN1CALL ASN1Dec_AttributeTypeValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeTypeValue *val);
static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Dec_RSAPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPublicKey *val);
static int ASN1CALL ASN1Dec_DSSParameters(ASN1decoding_t dec, ASN1uint32_t tag, DSSParameters *val);
static int ASN1CALL ASN1Dec_DSSSignature(ASN1decoding_t dec, ASN1uint32_t tag, DSSSignature *val);
static int ASN1CALL ASN1Dec_DHParameters(ASN1decoding_t dec, ASN1uint32_t tag, DHParameters *val);
static int ASN1CALL ASN1Dec_X942DhValidationParams(ASN1decoding_t dec, ASN1uint32_t tag, X942DhValidationParams *val);
static int ASN1CALL ASN1Dec_X942DhKeySpecificInfo(ASN1decoding_t dec, ASN1uint32_t tag, X942DhKeySpecificInfo *val);
static int ASN1CALL ASN1Dec_RC2CBCParameters(ASN1decoding_t dec, ASN1uint32_t tag, RC2CBCParameters *val);
static int ASN1CALL ASN1Dec_SMIMECapability(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapability *val);
static int ASN1CALL ASN1Dec_SMIMECapabilities(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapabilities *val);
static int ASN1CALL ASN1Dec_SubjectPublicKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, SubjectPublicKeyInfo *val);
static int ASN1CALL ASN1Dec_ChoiceOfTime(ASN1decoding_t dec, ASN1uint32_t tag, ChoiceOfTime *val);
static int ASN1CALL ASN1Dec_Validity(ASN1decoding_t dec, ASN1uint32_t tag, Validity *val);
static int ASN1CALL ASN1Dec_Extensions(ASN1decoding_t dec, ASN1uint32_t tag, Extensions *val);
static int ASN1CALL ASN1Dec_Extension(ASN1decoding_t dec, ASN1uint32_t tag, Extension *val);
static int ASN1CALL ASN1Dec_SignedContent(ASN1decoding_t dec, ASN1uint32_t tag, SignedContent *val);
static int ASN1CALL ASN1Dec_RevokedCertificates(ASN1decoding_t dec, ASN1uint32_t tag, RevokedCertificates *val);
static int ASN1CALL ASN1Dec_CRLEntry(ASN1decoding_t dec, ASN1uint32_t tag, CRLEntry *val);
static int ASN1CALL ASN1Dec_CertificationRequestInfo(ASN1decoding_t dec, ASN1uint32_t tag, CertificationRequestInfo *val);
static int ASN1CALL ASN1Dec_CertificationRequestInfoDecode(ASN1decoding_t dec, ASN1uint32_t tag, CertificationRequestInfoDecode *val);
static int ASN1CALL ASN1Dec_KeygenRequestInfo(ASN1decoding_t dec, ASN1uint32_t tag, KeygenRequestInfo *val);
static int ASN1CALL ASN1Dec_AuthorityKeyId(ASN1decoding_t dec, ASN1uint32_t tag, AuthorityKeyId *val);
static int ASN1CALL ASN1Dec_PrivateKeyValidity(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyValidity *val);
static int ASN1CALL ASN1Dec_CertPolicySet(ASN1decoding_t dec, ASN1uint32_t tag, CertPolicySet *val);
static int ASN1CALL ASN1Dec_CertPolicyId(ASN1decoding_t dec, ASN1uint32_t tag, CertPolicyId *val);
static int ASN1CALL ASN1Dec_AltNames(ASN1decoding_t dec, ASN1uint32_t tag, AltNames *val);
static int ASN1CALL ASN1Dec_GeneralNames(ASN1decoding_t dec, ASN1uint32_t tag, GeneralNames *val);
static int ASN1CALL ASN1Dec_OtherName(ASN1decoding_t dec, ASN1uint32_t tag, OtherName *val);
static int ASN1CALL ASN1Dec_EDIPartyName(ASN1decoding_t dec, ASN1uint32_t tag, EDIPartyName *val);
static int ASN1CALL ASN1Dec_SubtreesConstraint(ASN1decoding_t dec, ASN1uint32_t tag, SubtreesConstraint *val);
static int ASN1CALL ASN1Dec_BasicConstraints2(ASN1decoding_t dec, ASN1uint32_t tag, BasicConstraints2 *val);
static int ASN1CALL ASN1Dec_CertificatePolicies(ASN1decoding_t dec, ASN1uint32_t tag, CertificatePolicies *val);
static int ASN1CALL ASN1Dec_PolicyQualifiers(ASN1decoding_t dec, ASN1uint32_t tag, PolicyQualifiers *val);
static int ASN1CALL ASN1Dec_PolicyQualifierInfo(ASN1decoding_t dec, ASN1uint32_t tag, PolicyQualifierInfo *val);
static int ASN1CALL ASN1Dec_NoticeReference(ASN1decoding_t dec, ASN1uint32_t tag, NoticeReference *val);
static int ASN1CALL ASN1Dec_DisplayText(ASN1decoding_t dec, ASN1uint32_t tag, DisplayText *val);
static int ASN1CALL ASN1Dec_CertificatePolicies95(ASN1decoding_t dec, ASN1uint32_t tag, CertificatePolicies95 *val);
static int ASN1CALL ASN1Dec_CpsURLs(ASN1decoding_t dec, ASN1uint32_t tag, CpsURLs *val);
static int ASN1CALL ASN1Dec_AuthorityKeyId2(ASN1decoding_t dec, ASN1uint32_t tag, AuthorityKeyId2 *val);
static int ASN1CALL ASN1Dec_AuthorityInfoAccess(ASN1decoding_t dec, ASN1uint32_t tag, AuthorityInfoAccess *val);
static int ASN1CALL ASN1Dec_CRLDistributionPoints(ASN1decoding_t dec, ASN1uint32_t tag, CRLDistributionPoints *val);
static int ASN1CALL ASN1Dec_DistributionPointName(ASN1decoding_t dec, ASN1uint32_t tag, DistributionPointName *val);
static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Dec_SeqOfAny(ASN1decoding_t dec, ASN1uint32_t tag, SeqOfAny *val);
static int ASN1CALL ASN1Dec_TimeStampRequest(ASN1decoding_t dec, ASN1uint32_t tag, TimeStampRequest *val);
static int ASN1CALL ASN1Dec_ContentInfoOTS(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfoOTS *val);
static int ASN1CALL ASN1Dec_TimeStampRequestOTS(ASN1decoding_t dec, ASN1uint32_t tag, TimeStampRequestOTS *val);
static int ASN1CALL ASN1Dec_EnhancedKeyUsage(ASN1decoding_t dec, ASN1uint32_t tag, EnhancedKeyUsage *val);
static int ASN1CALL ASN1Dec_SubjectUsage(ASN1decoding_t dec, ASN1uint32_t tag, SubjectUsage *val);
static int ASN1CALL ASN1Dec_TrustedSubjects(ASN1decoding_t dec, ASN1uint32_t tag, TrustedSubjects *val);
static int ASN1CALL ASN1Dec_TrustedSubject(ASN1decoding_t dec, ASN1uint32_t tag, TrustedSubject *val);
static int ASN1CALL ASN1Dec_EnrollmentNameValuePair(ASN1decoding_t dec, ASN1uint32_t tag, EnrollmentNameValuePair *val);
static int ASN1CALL ASN1Dec_CSPProvider(ASN1decoding_t dec, ASN1uint32_t tag, CSPProvider *val);
static int ASN1CALL ASN1Dec_CertificatePair(ASN1decoding_t dec, ASN1uint32_t tag, CertificatePair *val);
static int ASN1CALL ASN1Dec_GeneralSubtrees(ASN1decoding_t dec, ASN1uint32_t tag, GeneralSubtrees *val);
static int ASN1CALL ASN1Dec_IssuingDistributionPoint(ASN1decoding_t dec, ASN1uint32_t tag, IssuingDistributionPoint *val);
static int ASN1CALL ASN1Dec_CrossCertDistPointNames(ASN1decoding_t dec, ASN1uint32_t tag, CrossCertDistPointNames *val);
static int ASN1CALL ASN1Dec_PolicyMappings(ASN1decoding_t dec, ASN1uint32_t tag, PolicyMappings *val);
static int ASN1CALL ASN1Dec_PolicyMapping(ASN1decoding_t dec, ASN1uint32_t tag, PolicyMapping *val);
static int ASN1CALL ASN1Dec_PolicyConstraints(ASN1decoding_t dec, ASN1uint32_t tag, PolicyConstraints *val);
static int ASN1CALL ASN1Dec_ControlSequence(ASN1decoding_t dec, ASN1uint32_t tag, ControlSequence *val);
static int ASN1CALL ASN1Dec_ReqSequence(ASN1decoding_t dec, ASN1uint32_t tag, ReqSequence *val);
static int ASN1CALL ASN1Dec_CmsSequence(ASN1decoding_t dec, ASN1uint32_t tag, CmsSequence *val);
static int ASN1CALL ASN1Dec_OtherMsgSequence(ASN1decoding_t dec, ASN1uint32_t tag, OtherMsgSequence *val);
static int ASN1CALL ASN1Dec_BodyPartIDSequence(ASN1decoding_t dec, ASN1uint32_t tag, BodyPartIDSequence *val);
static int ASN1CALL ASN1Dec_TaggedAttribute(ASN1decoding_t dec, ASN1uint32_t tag, TaggedAttribute *val);
static int ASN1CALL ASN1Dec_TaggedCertificationRequest(ASN1decoding_t dec, ASN1uint32_t tag, TaggedCertificationRequest *val);
static int ASN1CALL ASN1Dec_TaggedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, TaggedContentInfo *val);
static int ASN1CALL ASN1Dec_TaggedOtherMsg(ASN1decoding_t dec, ASN1uint32_t tag, TaggedOtherMsg *val);
static int ASN1CALL ASN1Dec_PendInfo(ASN1decoding_t dec, ASN1uint32_t tag, PendInfo *val);
static int ASN1CALL ASN1Dec_CmcAddExtensions(ASN1decoding_t dec, ASN1uint32_t tag, CmcAddExtensions *val);
static int ASN1CALL ASN1Dec_CmcAddAttributes(ASN1decoding_t dec, ASN1uint32_t tag, CmcAddAttributes *val);
static int ASN1CALL ASN1Dec_CertificateTemplate(ASN1decoding_t dec, ASN1uint32_t tag, CertificateTemplate *val);
static int ASN1CALL ASN1Dec_CmcStatusInfo_otherInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmcStatusInfo_otherInfo *val);
static int ASN1CALL ASN1Dec_CpsURLs_Seq(ASN1decoding_t dec, ASN1uint32_t tag, CpsURLs_Seq *val);
static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Dec_X942DhParameters(ASN1decoding_t dec, ASN1uint32_t tag, X942DhParameters *val);
static int ASN1CALL ASN1Dec_X942DhOtherInfo(ASN1decoding_t dec, ASN1uint32_t tag, X942DhOtherInfo *val);
static int ASN1CALL ASN1Dec_CertificateToBeSigned(ASN1decoding_t dec, ASN1uint32_t tag, CertificateToBeSigned *val);
static int ASN1CALL ASN1Dec_CertificateRevocationListToBeSigned(ASN1decoding_t dec, ASN1uint32_t tag, CertificateRevocationListToBeSigned *val);
static int ASN1CALL ASN1Dec_KeyAttributes(ASN1decoding_t dec, ASN1uint32_t tag, KeyAttributes *val);
static int ASN1CALL ASN1Dec_KeyUsageRestriction(ASN1decoding_t dec, ASN1uint32_t tag, KeyUsageRestriction *val);
static int ASN1CALL ASN1Dec_GeneralName(ASN1decoding_t dec, ASN1uint32_t tag, GeneralName *val);
static int ASN1CALL ASN1Dec_BasicConstraints(ASN1decoding_t dec, ASN1uint32_t tag, BasicConstraints *val);
static int ASN1CALL ASN1Dec_PolicyInformation(ASN1decoding_t dec, ASN1uint32_t tag, PolicyInformation *val);
static int ASN1CALL ASN1Dec_UserNotice(ASN1decoding_t dec, ASN1uint32_t tag, UserNotice *val);
static int ASN1CALL ASN1Dec_VerisignQualifier1(ASN1decoding_t dec, ASN1uint32_t tag, VerisignQualifier1 *val);
static int ASN1CALL ASN1Dec_AccessDescription(ASN1decoding_t dec, ASN1uint32_t tag, AccessDescription *val);
static int ASN1CALL ASN1Dec_DistributionPoint(ASN1decoding_t dec, ASN1uint32_t tag, DistributionPoint *val);
static int ASN1CALL ASN1Dec_ContentInfoSeqOfAny(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfoSeqOfAny *val);
static int ASN1CALL ASN1Dec_CertificateTrustList(ASN1decoding_t dec, ASN1uint32_t tag, CertificateTrustList *val);
static int ASN1CALL ASN1Dec_NameConstraints(ASN1decoding_t dec, ASN1uint32_t tag, NameConstraints *val);
static int ASN1CALL ASN1Dec_GeneralSubtree(ASN1decoding_t dec, ASN1uint32_t tag, GeneralSubtree *val);
static int ASN1CALL ASN1Dec_CrossCertDistPoints(ASN1decoding_t dec, ASN1uint32_t tag, CrossCertDistPoints *val);
static int ASN1CALL ASN1Dec_CmcData(ASN1decoding_t dec, ASN1uint32_t tag, CmcData *val);
static int ASN1CALL ASN1Dec_CmcResponseBody(ASN1decoding_t dec, ASN1uint32_t tag, CmcResponseBody *val);
static int ASN1CALL ASN1Dec_TaggedRequest(ASN1decoding_t dec, ASN1uint32_t tag, TaggedRequest *val);
static int ASN1CALL ASN1Dec_CmcStatusInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmcStatusInfo *val);
static void ASN1CALL ASN1Free_EncodedObjectID(EncodedObjectID *val);
static void ASN1CALL ASN1Free_Bits(Bits *val);
static void ASN1CALL ASN1Free_HugeIntegerType(HugeIntegerType *val);
static void ASN1CALL ASN1Free_OctetStringType(OctetStringType *val);
static void ASN1CALL ASN1Free_UtcTime(UtcTime *val);
static void ASN1CALL ASN1Free_NoticeReference_noticeNumbers(NoticeReference_noticeNumbers *val);
static void ASN1CALL ASN1Free_AnyString(AnyString *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_Name(Name *val);
static void ASN1CALL ASN1Free_RelativeDistinguishedName(RelativeDistinguishedName *val);
static void ASN1CALL ASN1Free_AttributeTypeValue(AttributeTypeValue *val);
static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val);
static void ASN1CALL ASN1Free_Attributes(Attributes *val);
static void ASN1CALL ASN1Free_RSAPublicKey(RSAPublicKey *val);
static void ASN1CALL ASN1Free_DSSParameters(DSSParameters *val);
static void ASN1CALL ASN1Free_DSSSignature(DSSSignature *val);
static void ASN1CALL ASN1Free_DHParameters(DHParameters *val);
static void ASN1CALL ASN1Free_X942DhValidationParams(X942DhValidationParams *val);
static void ASN1CALL ASN1Free_X942DhKeySpecificInfo(X942DhKeySpecificInfo *val);
static void ASN1CALL ASN1Free_RC2CBCParameters(RC2CBCParameters *val);
static void ASN1CALL ASN1Free_SMIMECapability(SMIMECapability *val);
static void ASN1CALL ASN1Free_SMIMECapabilities(SMIMECapabilities *val);
static void ASN1CALL ASN1Free_SubjectPublicKeyInfo(SubjectPublicKeyInfo *val);
static void ASN1CALL ASN1Free_ChoiceOfTime(ChoiceOfTime *val);
static void ASN1CALL ASN1Free_Validity(Validity *val);
static void ASN1CALL ASN1Free_Extensions(Extensions *val);
static void ASN1CALL ASN1Free_Extension(Extension *val);
static void ASN1CALL ASN1Free_SignedContent(SignedContent *val);
static void ASN1CALL ASN1Free_RevokedCertificates(RevokedCertificates *val);
static void ASN1CALL ASN1Free_CRLEntry(CRLEntry *val);
static void ASN1CALL ASN1Free_CertificationRequestInfo(CertificationRequestInfo *val);
static void ASN1CALL ASN1Free_CertificationRequestInfoDecode(CertificationRequestInfoDecode *val);
static void ASN1CALL ASN1Free_KeygenRequestInfo(KeygenRequestInfo *val);
static void ASN1CALL ASN1Free_AuthorityKeyId(AuthorityKeyId *val);
static void ASN1CALL ASN1Free_PrivateKeyValidity(PrivateKeyValidity *val);
static void ASN1CALL ASN1Free_CertPolicySet(CertPolicySet *val);
static void ASN1CALL ASN1Free_CertPolicyId(CertPolicyId *val);
static void ASN1CALL ASN1Free_AltNames(AltNames *val);
static void ASN1CALL ASN1Free_GeneralNames(GeneralNames *val);
static void ASN1CALL ASN1Free_OtherName(OtherName *val);
static void ASN1CALL ASN1Free_EDIPartyName(EDIPartyName *val);
static void ASN1CALL ASN1Free_SubtreesConstraint(SubtreesConstraint *val);
static void ASN1CALL ASN1Free_CertificatePolicies(CertificatePolicies *val);
static void ASN1CALL ASN1Free_PolicyQualifiers(PolicyQualifiers *val);
static void ASN1CALL ASN1Free_PolicyQualifierInfo(PolicyQualifierInfo *val);
static void ASN1CALL ASN1Free_NoticeReference(NoticeReference *val);
static void ASN1CALL ASN1Free_DisplayText(DisplayText *val);
static void ASN1CALL ASN1Free_CertificatePolicies95(CertificatePolicies95 *val);
static void ASN1CALL ASN1Free_CpsURLs(CpsURLs *val);
static void ASN1CALL ASN1Free_AuthorityKeyId2(AuthorityKeyId2 *val);
static void ASN1CALL ASN1Free_AuthorityInfoAccess(AuthorityInfoAccess *val);
static void ASN1CALL ASN1Free_CRLDistributionPoints(CRLDistributionPoints *val);
static void ASN1CALL ASN1Free_DistributionPointName(DistributionPointName *val);
static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val);
static void ASN1CALL ASN1Free_SeqOfAny(SeqOfAny *val);
static void ASN1CALL ASN1Free_TimeStampRequest(TimeStampRequest *val);
static void ASN1CALL ASN1Free_ContentInfoOTS(ContentInfoOTS *val);
static void ASN1CALL ASN1Free_TimeStampRequestOTS(TimeStampRequestOTS *val);
static void ASN1CALL ASN1Free_EnhancedKeyUsage(EnhancedKeyUsage *val);
static void ASN1CALL ASN1Free_SubjectUsage(SubjectUsage *val);
static void ASN1CALL ASN1Free_TrustedSubjects(TrustedSubjects *val);
static void ASN1CALL ASN1Free_TrustedSubject(TrustedSubject *val);
static void ASN1CALL ASN1Free_EnrollmentNameValuePair(EnrollmentNameValuePair *val);
static void ASN1CALL ASN1Free_CSPProvider(CSPProvider *val);
static void ASN1CALL ASN1Free_CertificatePair(CertificatePair *val);
static void ASN1CALL ASN1Free_GeneralSubtrees(GeneralSubtrees *val);
static void ASN1CALL ASN1Free_IssuingDistributionPoint(IssuingDistributionPoint *val);
static void ASN1CALL ASN1Free_CrossCertDistPointNames(CrossCertDistPointNames *val);
static void ASN1CALL ASN1Free_PolicyMappings(PolicyMappings *val);
static void ASN1CALL ASN1Free_PolicyMapping(PolicyMapping *val);
static void ASN1CALL ASN1Free_ControlSequence(ControlSequence *val);
static void ASN1CALL ASN1Free_ReqSequence(ReqSequence *val);
static void ASN1CALL ASN1Free_CmsSequence(CmsSequence *val);
static void ASN1CALL ASN1Free_OtherMsgSequence(OtherMsgSequence *val);
static void ASN1CALL ASN1Free_BodyPartIDSequence(BodyPartIDSequence *val);
static void ASN1CALL ASN1Free_TaggedAttribute(TaggedAttribute *val);
static void ASN1CALL ASN1Free_TaggedCertificationRequest(TaggedCertificationRequest *val);
static void ASN1CALL ASN1Free_TaggedContentInfo(TaggedContentInfo *val);
static void ASN1CALL ASN1Free_TaggedOtherMsg(TaggedOtherMsg *val);
static void ASN1CALL ASN1Free_PendInfo(PendInfo *val);
static void ASN1CALL ASN1Free_CmcAddExtensions(CmcAddExtensions *val);
static void ASN1CALL ASN1Free_CmcAddAttributes(CmcAddAttributes *val);
static void ASN1CALL ASN1Free_CertificateTemplate(CertificateTemplate *val);
static void ASN1CALL ASN1Free_CmcStatusInfo_otherInfo(CmcStatusInfo_otherInfo *val);
static void ASN1CALL ASN1Free_CpsURLs_Seq(CpsURLs_Seq *val);
static void ASN1CALL ASN1Free_Attribute(Attribute *val);
static void ASN1CALL ASN1Free_X942DhParameters(X942DhParameters *val);
static void ASN1CALL ASN1Free_X942DhOtherInfo(X942DhOtherInfo *val);
static void ASN1CALL ASN1Free_CertificateToBeSigned(CertificateToBeSigned *val);
static void ASN1CALL ASN1Free_CertificateRevocationListToBeSigned(CertificateRevocationListToBeSigned *val);
static void ASN1CALL ASN1Free_KeyAttributes(KeyAttributes *val);
static void ASN1CALL ASN1Free_KeyUsageRestriction(KeyUsageRestriction *val);
static void ASN1CALL ASN1Free_GeneralName(GeneralName *val);
static void ASN1CALL ASN1Free_BasicConstraints(BasicConstraints *val);
static void ASN1CALL ASN1Free_PolicyInformation(PolicyInformation *val);
static void ASN1CALL ASN1Free_UserNotice(UserNotice *val);
static void ASN1CALL ASN1Free_VerisignQualifier1(VerisignQualifier1 *val);
static void ASN1CALL ASN1Free_AccessDescription(AccessDescription *val);
static void ASN1CALL ASN1Free_DistributionPoint(DistributionPoint *val);
static void ASN1CALL ASN1Free_ContentInfoSeqOfAny(ContentInfoSeqOfAny *val);
static void ASN1CALL ASN1Free_CertificateTrustList(CertificateTrustList *val);
static void ASN1CALL ASN1Free_NameConstraints(NameConstraints *val);
static void ASN1CALL ASN1Free_GeneralSubtree(GeneralSubtree *val);
static void ASN1CALL ASN1Free_CrossCertDistPoints(CrossCertDistPoints *val);
static void ASN1CALL ASN1Free_CmcData(CmcData *val);
static void ASN1CALL ASN1Free_CmcResponseBody(CmcResponseBody *val);
static void ASN1CALL ASN1Free_TaggedRequest(TaggedRequest *val);
static void ASN1CALL ASN1Free_CmcStatusInfo(CmcStatusInfo *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[64] = {
    (ASN1EncFun_t) ASN1Enc_EncodedObjectID,
    (ASN1EncFun_t) ASN1Enc_Bits,
    (ASN1EncFun_t) ASN1Enc_IntegerType,
    (ASN1EncFun_t) ASN1Enc_HugeIntegerType,
    (ASN1EncFun_t) ASN1Enc_OctetStringType,
    (ASN1EncFun_t) ASN1Enc_EnumeratedType,
    (ASN1EncFun_t) ASN1Enc_UtcTime,
    (ASN1EncFun_t) ASN1Enc_AnyString,
    (ASN1EncFun_t) ASN1Enc_Name,
    (ASN1EncFun_t) ASN1Enc_Attributes,
    (ASN1EncFun_t) ASN1Enc_RSAPublicKey,
    (ASN1EncFun_t) ASN1Enc_DSSParameters,
    (ASN1EncFun_t) ASN1Enc_DSSSignature,
    (ASN1EncFun_t) ASN1Enc_DHParameters,
    (ASN1EncFun_t) ASN1Enc_RC2CBCParameters,
    (ASN1EncFun_t) ASN1Enc_SMIMECapabilities,
    (ASN1EncFun_t) ASN1Enc_SubjectPublicKeyInfo,
    (ASN1EncFun_t) ASN1Enc_ChoiceOfTime,
    (ASN1EncFun_t) ASN1Enc_Extensions,
    (ASN1EncFun_t) ASN1Enc_SignedContent,
    (ASN1EncFun_t) ASN1Enc_CertificationRequestInfo,
    (ASN1EncFun_t) ASN1Enc_CertificationRequestInfoDecode,
    (ASN1EncFun_t) ASN1Enc_KeygenRequestInfo,
    (ASN1EncFun_t) ASN1Enc_AuthorityKeyId,
    (ASN1EncFun_t) ASN1Enc_AltNames,
    (ASN1EncFun_t) ASN1Enc_EDIPartyName,
    (ASN1EncFun_t) ASN1Enc_BasicConstraints2,
    (ASN1EncFun_t) ASN1Enc_CertificatePolicies,
    (ASN1EncFun_t) ASN1Enc_CertificatePolicies95,
    (ASN1EncFun_t) ASN1Enc_AuthorityKeyId2,
    (ASN1EncFun_t) ASN1Enc_AuthorityInfoAccess,
    (ASN1EncFun_t) ASN1Enc_CRLDistributionPoints,
    (ASN1EncFun_t) ASN1Enc_ContentInfo,
    (ASN1EncFun_t) ASN1Enc_SeqOfAny,
    (ASN1EncFun_t) ASN1Enc_TimeStampRequest,
    (ASN1EncFun_t) ASN1Enc_ContentInfoOTS,
    (ASN1EncFun_t) ASN1Enc_TimeStampRequestOTS,
    (ASN1EncFun_t) ASN1Enc_EnhancedKeyUsage,
    (ASN1EncFun_t) ASN1Enc_EnrollmentNameValuePair,
    (ASN1EncFun_t) ASN1Enc_CSPProvider,
    (ASN1EncFun_t) ASN1Enc_CertificatePair,
    (ASN1EncFun_t) ASN1Enc_IssuingDistributionPoint,
    (ASN1EncFun_t) ASN1Enc_PolicyMappings,
    (ASN1EncFun_t) ASN1Enc_PolicyConstraints,
    (ASN1EncFun_t) ASN1Enc_CmcAddExtensions,
    (ASN1EncFun_t) ASN1Enc_CmcAddAttributes,
    (ASN1EncFun_t) ASN1Enc_CertificateTemplate,
    (ASN1EncFun_t) ASN1Enc_Attribute,
    (ASN1EncFun_t) ASN1Enc_X942DhParameters,
    (ASN1EncFun_t) ASN1Enc_X942DhOtherInfo,
    (ASN1EncFun_t) ASN1Enc_CertificateToBeSigned,
    (ASN1EncFun_t) ASN1Enc_CertificateRevocationListToBeSigned,
    (ASN1EncFun_t) ASN1Enc_KeyAttributes,
    (ASN1EncFun_t) ASN1Enc_KeyUsageRestriction,
    (ASN1EncFun_t) ASN1Enc_BasicConstraints,
    (ASN1EncFun_t) ASN1Enc_UserNotice,
    (ASN1EncFun_t) ASN1Enc_VerisignQualifier1,
    (ASN1EncFun_t) ASN1Enc_ContentInfoSeqOfAny,
    (ASN1EncFun_t) ASN1Enc_CertificateTrustList,
    (ASN1EncFun_t) ASN1Enc_NameConstraints,
    (ASN1EncFun_t) ASN1Enc_CrossCertDistPoints,
    (ASN1EncFun_t) ASN1Enc_CmcData,
    (ASN1EncFun_t) ASN1Enc_CmcResponseBody,
    (ASN1EncFun_t) ASN1Enc_CmcStatusInfo,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[64] = {
    (ASN1DecFun_t) ASN1Dec_EncodedObjectID,
    (ASN1DecFun_t) ASN1Dec_Bits,
    (ASN1DecFun_t) ASN1Dec_IntegerType,
    (ASN1DecFun_t) ASN1Dec_HugeIntegerType,
    (ASN1DecFun_t) ASN1Dec_OctetStringType,
    (ASN1DecFun_t) ASN1Dec_EnumeratedType,
    (ASN1DecFun_t) ASN1Dec_UtcTime,
    (ASN1DecFun_t) ASN1Dec_AnyString,
    (ASN1DecFun_t) ASN1Dec_Name,
    (ASN1DecFun_t) ASN1Dec_Attributes,
    (ASN1DecFun_t) ASN1Dec_RSAPublicKey,
    (ASN1DecFun_t) ASN1Dec_DSSParameters,
    (ASN1DecFun_t) ASN1Dec_DSSSignature,
    (ASN1DecFun_t) ASN1Dec_DHParameters,
    (ASN1DecFun_t) ASN1Dec_RC2CBCParameters,
    (ASN1DecFun_t) ASN1Dec_SMIMECapabilities,
    (ASN1DecFun_t) ASN1Dec_SubjectPublicKeyInfo,
    (ASN1DecFun_t) ASN1Dec_ChoiceOfTime,
    (ASN1DecFun_t) ASN1Dec_Extensions,
    (ASN1DecFun_t) ASN1Dec_SignedContent,
    (ASN1DecFun_t) ASN1Dec_CertificationRequestInfo,
    (ASN1DecFun_t) ASN1Dec_CertificationRequestInfoDecode,
    (ASN1DecFun_t) ASN1Dec_KeygenRequestInfo,
    (ASN1DecFun_t) ASN1Dec_AuthorityKeyId,
    (ASN1DecFun_t) ASN1Dec_AltNames,
    (ASN1DecFun_t) ASN1Dec_EDIPartyName,
    (ASN1DecFun_t) ASN1Dec_BasicConstraints2,
    (ASN1DecFun_t) ASN1Dec_CertificatePolicies,
    (ASN1DecFun_t) ASN1Dec_CertificatePolicies95,
    (ASN1DecFun_t) ASN1Dec_AuthorityKeyId2,
    (ASN1DecFun_t) ASN1Dec_AuthorityInfoAccess,
    (ASN1DecFun_t) ASN1Dec_CRLDistributionPoints,
    (ASN1DecFun_t) ASN1Dec_ContentInfo,
    (ASN1DecFun_t) ASN1Dec_SeqOfAny,
    (ASN1DecFun_t) ASN1Dec_TimeStampRequest,
    (ASN1DecFun_t) ASN1Dec_ContentInfoOTS,
    (ASN1DecFun_t) ASN1Dec_TimeStampRequestOTS,
    (ASN1DecFun_t) ASN1Dec_EnhancedKeyUsage,
    (ASN1DecFun_t) ASN1Dec_EnrollmentNameValuePair,
    (ASN1DecFun_t) ASN1Dec_CSPProvider,
    (ASN1DecFun_t) ASN1Dec_CertificatePair,
    (ASN1DecFun_t) ASN1Dec_IssuingDistributionPoint,
    (ASN1DecFun_t) ASN1Dec_PolicyMappings,
    (ASN1DecFun_t) ASN1Dec_PolicyConstraints,
    (ASN1DecFun_t) ASN1Dec_CmcAddExtensions,
    (ASN1DecFun_t) ASN1Dec_CmcAddAttributes,
    (ASN1DecFun_t) ASN1Dec_CertificateTemplate,
    (ASN1DecFun_t) ASN1Dec_Attribute,
    (ASN1DecFun_t) ASN1Dec_X942DhParameters,
    (ASN1DecFun_t) ASN1Dec_X942DhOtherInfo,
    (ASN1DecFun_t) ASN1Dec_CertificateToBeSigned,
    (ASN1DecFun_t) ASN1Dec_CertificateRevocationListToBeSigned,
    (ASN1DecFun_t) ASN1Dec_KeyAttributes,
    (ASN1DecFun_t) ASN1Dec_KeyUsageRestriction,
    (ASN1DecFun_t) ASN1Dec_BasicConstraints,
    (ASN1DecFun_t) ASN1Dec_UserNotice,
    (ASN1DecFun_t) ASN1Dec_VerisignQualifier1,
    (ASN1DecFun_t) ASN1Dec_ContentInfoSeqOfAny,
    (ASN1DecFun_t) ASN1Dec_CertificateTrustList,
    (ASN1DecFun_t) ASN1Dec_NameConstraints,
    (ASN1DecFun_t) ASN1Dec_CrossCertDistPoints,
    (ASN1DecFun_t) ASN1Dec_CmcData,
    (ASN1DecFun_t) ASN1Dec_CmcResponseBody,
    (ASN1DecFun_t) ASN1Dec_CmcStatusInfo,
};
static const ASN1FreeFun_t freefntab[64] = {
    (ASN1FreeFun_t) ASN1Free_EncodedObjectID,
    (ASN1FreeFun_t) ASN1Free_Bits,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_HugeIntegerType,
    (ASN1FreeFun_t) ASN1Free_OctetStringType,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_UtcTime,
    (ASN1FreeFun_t) ASN1Free_AnyString,
    (ASN1FreeFun_t) ASN1Free_Name,
    (ASN1FreeFun_t) ASN1Free_Attributes,
    (ASN1FreeFun_t) ASN1Free_RSAPublicKey,
    (ASN1FreeFun_t) ASN1Free_DSSParameters,
    (ASN1FreeFun_t) ASN1Free_DSSSignature,
    (ASN1FreeFun_t) ASN1Free_DHParameters,
    (ASN1FreeFun_t) ASN1Free_RC2CBCParameters,
    (ASN1FreeFun_t) ASN1Free_SMIMECapabilities,
    (ASN1FreeFun_t) ASN1Free_SubjectPublicKeyInfo,
    (ASN1FreeFun_t) ASN1Free_ChoiceOfTime,
    (ASN1FreeFun_t) ASN1Free_Extensions,
    (ASN1FreeFun_t) ASN1Free_SignedContent,
    (ASN1FreeFun_t) ASN1Free_CertificationRequestInfo,
    (ASN1FreeFun_t) ASN1Free_CertificationRequestInfoDecode,
    (ASN1FreeFun_t) ASN1Free_KeygenRequestInfo,
    (ASN1FreeFun_t) ASN1Free_AuthorityKeyId,
    (ASN1FreeFun_t) ASN1Free_AltNames,
    (ASN1FreeFun_t) ASN1Free_EDIPartyName,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_CertificatePolicies,
    (ASN1FreeFun_t) ASN1Free_CertificatePolicies95,
    (ASN1FreeFun_t) ASN1Free_AuthorityKeyId2,
    (ASN1FreeFun_t) ASN1Free_AuthorityInfoAccess,
    (ASN1FreeFun_t) ASN1Free_CRLDistributionPoints,
    (ASN1FreeFun_t) ASN1Free_ContentInfo,
    (ASN1FreeFun_t) ASN1Free_SeqOfAny,
    (ASN1FreeFun_t) ASN1Free_TimeStampRequest,
    (ASN1FreeFun_t) ASN1Free_ContentInfoOTS,
    (ASN1FreeFun_t) ASN1Free_TimeStampRequestOTS,
    (ASN1FreeFun_t) ASN1Free_EnhancedKeyUsage,
    (ASN1FreeFun_t) ASN1Free_EnrollmentNameValuePair,
    (ASN1FreeFun_t) ASN1Free_CSPProvider,
    (ASN1FreeFun_t) ASN1Free_CertificatePair,
    (ASN1FreeFun_t) ASN1Free_IssuingDistributionPoint,
    (ASN1FreeFun_t) ASN1Free_PolicyMappings,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_CmcAddExtensions,
    (ASN1FreeFun_t) ASN1Free_CmcAddAttributes,
    (ASN1FreeFun_t) ASN1Free_CertificateTemplate,
    (ASN1FreeFun_t) ASN1Free_Attribute,
    (ASN1FreeFun_t) ASN1Free_X942DhParameters,
    (ASN1FreeFun_t) ASN1Free_X942DhOtherInfo,
    (ASN1FreeFun_t) ASN1Free_CertificateToBeSigned,
    (ASN1FreeFun_t) ASN1Free_CertificateRevocationListToBeSigned,
    (ASN1FreeFun_t) ASN1Free_KeyAttributes,
    (ASN1FreeFun_t) ASN1Free_KeyUsageRestriction,
    (ASN1FreeFun_t) ASN1Free_BasicConstraints,
    (ASN1FreeFun_t) ASN1Free_UserNotice,
    (ASN1FreeFun_t) ASN1Free_VerisignQualifier1,
    (ASN1FreeFun_t) ASN1Free_ContentInfoSeqOfAny,
    (ASN1FreeFun_t) ASN1Free_CertificateTrustList,
    (ASN1FreeFun_t) ASN1Free_NameConstraints,
    (ASN1FreeFun_t) ASN1Free_CrossCertDistPoints,
    (ASN1FreeFun_t) ASN1Free_CmcData,
    (ASN1FreeFun_t) ASN1Free_CmcResponseBody,
    (ASN1FreeFun_t) ASN1Free_CmcStatusInfo,
};
static const ULONG sizetab[64] = {
    SIZE_X509_Module_PDU_0,
    SIZE_X509_Module_PDU_1,
    SIZE_X509_Module_PDU_2,
    SIZE_X509_Module_PDU_3,
    SIZE_X509_Module_PDU_4,
    SIZE_X509_Module_PDU_5,
    SIZE_X509_Module_PDU_6,
    SIZE_X509_Module_PDU_7,
    SIZE_X509_Module_PDU_8,
    SIZE_X509_Module_PDU_9,
    SIZE_X509_Module_PDU_10,
    SIZE_X509_Module_PDU_11,
    SIZE_X509_Module_PDU_12,
    SIZE_X509_Module_PDU_13,
    SIZE_X509_Module_PDU_14,
    SIZE_X509_Module_PDU_15,
    SIZE_X509_Module_PDU_16,
    SIZE_X509_Module_PDU_17,
    SIZE_X509_Module_PDU_18,
    SIZE_X509_Module_PDU_19,
    SIZE_X509_Module_PDU_20,
    SIZE_X509_Module_PDU_21,
    SIZE_X509_Module_PDU_22,
    SIZE_X509_Module_PDU_23,
    SIZE_X509_Module_PDU_24,
    SIZE_X509_Module_PDU_25,
    SIZE_X509_Module_PDU_26,
    SIZE_X509_Module_PDU_27,
    SIZE_X509_Module_PDU_28,
    SIZE_X509_Module_PDU_29,
    SIZE_X509_Module_PDU_30,
    SIZE_X509_Module_PDU_31,
    SIZE_X509_Module_PDU_32,
    SIZE_X509_Module_PDU_33,
    SIZE_X509_Module_PDU_34,
    SIZE_X509_Module_PDU_35,
    SIZE_X509_Module_PDU_36,
    SIZE_X509_Module_PDU_37,
    SIZE_X509_Module_PDU_38,
    SIZE_X509_Module_PDU_39,
    SIZE_X509_Module_PDU_40,
    SIZE_X509_Module_PDU_41,
    SIZE_X509_Module_PDU_42,
    SIZE_X509_Module_PDU_43,
    SIZE_X509_Module_PDU_44,
    SIZE_X509_Module_PDU_45,
    SIZE_X509_Module_PDU_46,
    SIZE_X509_Module_PDU_47,
    SIZE_X509_Module_PDU_48,
    SIZE_X509_Module_PDU_49,
    SIZE_X509_Module_PDU_50,
    SIZE_X509_Module_PDU_51,
    SIZE_X509_Module_PDU_52,
    SIZE_X509_Module_PDU_53,
    SIZE_X509_Module_PDU_54,
    SIZE_X509_Module_PDU_55,
    SIZE_X509_Module_PDU_56,
    SIZE_X509_Module_PDU_57,
    SIZE_X509_Module_PDU_58,
    SIZE_X509_Module_PDU_59,
    SIZE_X509_Module_PDU_60,
    SIZE_X509_Module_PDU_61,
    SIZE_X509_Module_PDU_62,
    SIZE_X509_Module_PDU_63,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */
ASN1bool_t IssuingDistributionPoint_indirectCRL_default = 0;
ASN1bool_t IssuingDistributionPoint_onlyContainsCACerts_default = 0;
ASN1bool_t IssuingDistributionPoint_onlyContainsUserCerts_default = 0;
BaseDistance GeneralSubtree_minimum_default = 0;
CTLVersion CertificateTrustList_version_default = 0;
ASN1bool_t BasicConstraints2_cA_default = 0;
ASN1bool_t Extension_critical_default = 0;
CertificateVersion CertificateToBeSigned_version_default = 0;

void ASN1CALL X509_Module_Startup(void)
{
    X509_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 64, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x39303578);
}

void ASN1CALL X509_Module_Cleanup(void)
{
    ASN1_CloseModule(X509_Module);
    X509_Module = NULL;
}

static int ASN1CALL ASN1Enc_EncodedObjectID(ASN1encoding_t enc, ASN1uint32_t tag, EncodedObjectID *val)
{
    if (!ASN1BEREncEoid(enc, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncodedObjectID(ASN1decoding_t dec, ASN1uint32_t tag, EncodedObjectID *val)
{
    if (!ASN1BERDecEoid(dec, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncodedObjectID(EncodedObjectID *val)
{
    if (val) {
	ASN1BEREoid_free(val);
    }
}

static int ASN1CALL ASN1Enc_Bits(ASN1encoding_t enc, ASN1uint32_t tag, Bits *val)
{
    if (!ASN1DEREncBitString(enc, tag ? tag : 0x3, (val)->length, (val)->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Bits(ASN1decoding_t dec, ASN1uint32_t tag, Bits *val)
{
    if (!ASN1BERDecBitString2(dec, tag ? tag : 0x3, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Bits(Bits *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_IntegerType(ASN1encoding_t enc, ASN1uint32_t tag, IntegerType *val)
{
    if (!ASN1BEREncS32(enc, tag ? tag : 0x2, *val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IntegerType(ASN1decoding_t dec, ASN1uint32_t tag, IntegerType *val)
{
    if (!ASN1BERDecS32Val(dec, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_HugeIntegerType(ASN1encoding_t enc, ASN1uint32_t tag, HugeIntegerType *val)
{
    if (!ASN1BEREncSX(enc, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_HugeIntegerType(ASN1decoding_t dec, ASN1uint32_t tag, HugeIntegerType *val)
{
    if (!ASN1BERDecSXVal(dec, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_HugeIntegerType(HugeIntegerType *val)
{
    if (val) {
	ASN1intx_free(val);
    }
}

static int ASN1CALL ASN1Enc_OctetStringType(ASN1encoding_t enc, ASN1uint32_t tag, OctetStringType *val)
{
    if (!ASN1DEREncOctetString(enc, tag ? tag : 0x4, (val)->length, (val)->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OctetStringType(ASN1decoding_t dec, ASN1uint32_t tag, OctetStringType *val)
{
    if (!ASN1BERDecOctetString2(dec, tag ? tag : 0x4, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OctetStringType(OctetStringType *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_EnumeratedType(ASN1encoding_t enc, ASN1uint32_t tag, EnumeratedType *val)
{
    if (!ASN1BEREncU32(enc, tag ? tag : 0xa, *val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnumeratedType(ASN1decoding_t dec, ASN1uint32_t tag, EnumeratedType *val)
{
    if (!ASN1BERDecU32Val(dec, tag ? tag : 0xa, (ASN1uint32_t *) val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UtcTime(ASN1encoding_t enc, ASN1uint32_t tag, UtcTime *val)
{
    if (!ASN1DEREncUTCTime(enc, tag ? tag : 0x17, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UtcTime(ASN1decoding_t dec, ASN1uint32_t tag, UtcTime *val)
{
    if (!ASN1BERDecUTCTime(dec, tag ? tag : 0x17, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UtcTime(UtcTime *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_NoticeReference_noticeNumbers(ASN1encoding_t enc, ASN1uint32_t tag, NoticeReference_noticeNumbers *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncS32(enc, 0x2, ((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NoticeReference_noticeNumbers(ASN1decoding_t dec, ASN1uint32_t tag, NoticeReference_noticeNumbers *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (NoticeReference_noticeNumbers_Seq *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecS32Val(dd, 0x2, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NoticeReference_noticeNumbers(NoticeReference_noticeNumbers *val)
{
    if (val) {
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AnyString(ASN1encoding_t enc, ASN1uint32_t tag, AnyString *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->u.octetString).length, ((val)->u.octetString).value))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncUTF8String(enc, 0xc, ((val)->u.utf8String).length, ((val)->u.utf8String).value))
	    return 0;
	break;
    case 3:
	if (!ASN1DEREncCharString(enc, 0x12, ((val)->u.numericString).length, ((val)->u.numericString).value))
	    return 0;
	break;
    case 4:
	if (!ASN1DEREncCharString(enc, 0x13, ((val)->u.printableString).length, ((val)->u.printableString).value))
	    return 0;
	break;
    case 5:
	if (!ASN1DEREncMultibyteString(enc, 0x14, &(val)->u.teletexString))
	    return 0;
	break;
    case 6:
	if (!ASN1DEREncMultibyteString(enc, 0x15, &(val)->u.videotexString))
	    return 0;
	break;
    case 7:
	if (!ASN1DEREncCharString(enc, 0x16, ((val)->u.ia5String).length, ((val)->u.ia5String).value))
	    return 0;
	break;
    case 8:
	if (!ASN1DEREncCharString(enc, 0x19, ((val)->u.graphicString).length, ((val)->u.graphicString).value))
	    return 0;
	break;
    case 9:
	if (!ASN1DEREncCharString(enc, 0x1a, ((val)->u.visibleString).length, ((val)->u.visibleString).value))
	    return 0;
	break;
    case 10:
	if (!ASN1DEREncCharString(enc, 0x1b, ((val)->u.generalString).length, ((val)->u.generalString).value))
	    return 0;
	break;
    case 11:
	if (!ASN1DEREncChar32String(enc, 0x1c, ((val)->u.universalString).length, ((val)->u.universalString).value))
	    return 0;
	break;
    case 12:
	if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->u.bmpString).length, ((val)->u.bmpString).value))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AnyString(ASN1decoding_t dec, ASN1uint32_t tag, AnyString *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x4:
	(val)->choice = 1;
	if (!ASN1BERDecOctetString2(dec, 0x4, &(val)->u.octetString))
	    return 0;
	break;
    case 0xc:
	(val)->choice = 2;
	if (!ASN1BERDecUTF8String(dec, 0xc, &(val)->u.utf8String))
	    return 0;
	break;
    case 0x12:
	(val)->choice = 3;
	if (!ASN1BERDecCharString(dec, 0x12, &(val)->u.numericString))
	    return 0;
	break;
    case 0x13:
	(val)->choice = 4;
	if (!ASN1BERDecCharString(dec, 0x13, &(val)->u.printableString))
	    return 0;
	break;
    case 0x14:
	(val)->choice = 5;
	if (!ASN1BERDecMultibyteString(dec, 0x14, &(val)->u.teletexString))
	    return 0;
	break;
    case 0x15:
	(val)->choice = 6;
	if (!ASN1BERDecMultibyteString(dec, 0x15, &(val)->u.videotexString))
	    return 0;
	break;
    case 0x16:
	(val)->choice = 7;
	if (!ASN1BERDecCharString(dec, 0x16, &(val)->u.ia5String))
	    return 0;
	break;
    case 0x19:
	(val)->choice = 8;
	if (!ASN1BERDecCharString(dec, 0x19, &(val)->u.graphicString))
	    return 0;
	break;
    case 0x1a:
	(val)->choice = 9;
	if (!ASN1BERDecCharString(dec, 0x1a, &(val)->u.visibleString))
	    return 0;
	break;
    case 0x1b:
	(val)->choice = 10;
	if (!ASN1BERDecCharString(dec, 0x1b, &(val)->u.generalString))
	    return 0;
	break;
    case 0x1c:
	(val)->choice = 11;
	if (!ASN1BERDecChar32String(dec, 0x1c, &(val)->u.universalString))
	    return 0;
	break;
    case 0x1e:
	(val)->choice = 12;
	if (!ASN1BERDecChar16String(dec, 0x1e, &(val)->u.bmpString))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AnyString(AnyString *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	case 2:
	    ASN1utf8string_free(&(val)->u.utf8String);
	    break;
	case 3:
	    ASN1charstring_free(&(val)->u.numericString);
	    break;
	case 4:
	    ASN1charstring_free(&(val)->u.printableString);
	    break;
	case 5:
	    ASN1charstring_free(&(val)->u.teletexString);
	    break;
	case 6:
	    ASN1charstring_free(&(val)->u.videotexString);
	    break;
	case 7:
	    ASN1charstring_free(&(val)->u.ia5String);
	    break;
	case 8:
	    ASN1charstring_free(&(val)->u.graphicString);
	    break;
	case 9:
	    ASN1charstring_free(&(val)->u.visibleString);
	    break;
	case 10:
	    ASN1charstring_free(&(val)->u.generalString);
	    break;
	case 11:
	    ASN1char32string_free(&(val)->u.universalString);
	    break;
	case 12:
	    ASN1char16string_free(&(val)->u.bmpString);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->algorithm);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_Name(ASN1encoding_t enc, ASN1uint32_t tag, Name *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_RelativeDistinguishedName(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Name(ASN1decoding_t dec, ASN1uint32_t tag, Name *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (RelativeDistinguishedName *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_RelativeDistinguishedName(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Name(Name *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_RelativeDistinguishedName(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_RelativeDistinguishedName(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_RelativeDistinguishedName(ASN1encoding_t enc, ASN1uint32_t tag, RelativeDistinguishedName *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_AttributeTypeValue(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RelativeDistinguishedName(ASN1decoding_t dec, ASN1uint32_t tag, RelativeDistinguishedName *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (AttributeTypeValue *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_AttributeTypeValue(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RelativeDistinguishedName(RelativeDistinguishedName *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_AttributeTypeValue(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_AttributeTypeValue(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AttributeTypeValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeTypeValue *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->type))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeTypeValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeTypeValue *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->type))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeTypeValue(AttributeTypeValue *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (NOCOPYANY *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_Attribute(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (Attribute *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_Attribute(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attributes(Attributes *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_Attribute(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_Attribute(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_RSAPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPublicKey *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->publicExponent))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RSAPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPublicKey *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->publicExponent))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RSAPublicKey(RSAPublicKey *val)
{
    if (val) {
	ASN1intx_free(&(val)->modulus);
    }
}

static int ASN1CALL ASN1Enc_DSSParameters(ASN1encoding_t enc, ASN1uint32_t tag, DSSParameters *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->p))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->q))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->g))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DSSParameters(ASN1decoding_t dec, ASN1uint32_t tag, DSSParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->p))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->q))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->g))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DSSParameters(DSSParameters *val)
{
    if (val) {
	ASN1intx_free(&(val)->p);
	ASN1intx_free(&(val)->q);
	ASN1intx_free(&(val)->g);
    }
}

static int ASN1CALL ASN1Enc_DSSSignature(ASN1encoding_t enc, ASN1uint32_t tag, DSSSignature *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->r))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->s))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DSSSignature(ASN1decoding_t dec, ASN1uint32_t tag, DSSSignature *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->r))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->s))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DSSSignature(DSSSignature *val)
{
    if (val) {
	ASN1intx_free(&(val)->r);
	ASN1intx_free(&(val)->s);
    }
}

static int ASN1CALL ASN1Enc_DHParameters(ASN1encoding_t enc, ASN1uint32_t tag, DHParameters *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->p))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->g))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncSX(enc, 0x2, &(val)->privateValueLength))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DHParameters(ASN1decoding_t dec, ASN1uint32_t tag, DHParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->p))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->g))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecSXVal(dd, 0x2, &(val)->privateValueLength))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DHParameters(DHParameters *val)
{
    if (val) {
	ASN1intx_free(&(val)->p);
	ASN1intx_free(&(val)->g);
	if ((val)->o[0] & 0x80) {
	    ASN1intx_free(&(val)->privateValueLength);
	}
    }
}

static int ASN1CALL ASN1Enc_X942DhValidationParams(ASN1encoding_t enc, ASN1uint32_t tag, X942DhValidationParams *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->seed).length, ((val)->seed).value))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->pgenCounter))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_X942DhValidationParams(ASN1decoding_t dec, ASN1uint32_t tag, X942DhValidationParams *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecBitString2(dd, 0x3, &(val)->seed))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->pgenCounter))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_X942DhValidationParams(X942DhValidationParams *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_X942DhKeySpecificInfo(ASN1encoding_t enc, ASN1uint32_t tag, X942DhKeySpecificInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->algorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->counter).length, ((val)->counter).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_X942DhKeySpecificInfo(ASN1decoding_t dec, ASN1uint32_t tag, X942DhKeySpecificInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->algorithm))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->counter))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_X942DhKeySpecificInfo(X942DhKeySpecificInfo *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->algorithm);
    }
}

static int ASN1CALL ASN1Enc_RC2CBCParameters(ASN1encoding_t enc, ASN1uint32_t tag, RC2CBCParameters *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->iv).length, ((val)->iv).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RC2CBCParameters(ASN1decoding_t dec, ASN1uint32_t tag, RC2CBCParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x4) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->iv))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RC2CBCParameters(RC2CBCParameters *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_SMIMECapability(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapability *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->capabilityID))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->smimeParameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SMIMECapability(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->capabilityID))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->smimeParameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SMIMECapability(SMIMECapability *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->capabilityID);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_SMIMECapabilities(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapabilities *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_SMIMECapability(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SMIMECapabilities(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapabilities *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (SMIMECapability *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_SMIMECapability(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SMIMECapabilities(SMIMECapabilities *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_SMIMECapability(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_SMIMECapability(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SubjectPublicKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, SubjectPublicKeyInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->algorithm))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subjectPublicKey).length, ((val)->subjectPublicKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SubjectPublicKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, SubjectPublicKeyInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BERDecBitString2(dd, 0x3, &(val)->subjectPublicKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SubjectPublicKeyInfo(SubjectPublicKeyInfo *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->algorithm);
    }
}

static int ASN1CALL ASN1Enc_ChoiceOfTime(ASN1encoding_t enc, ASN1uint32_t tag, ChoiceOfTime *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncUTCTime(enc, 0x17, &(val)->u.utcTime))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->u.generalTime))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ChoiceOfTime(ASN1decoding_t dec, ASN1uint32_t tag, ChoiceOfTime *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x17:
	(val)->choice = 1;
	if (!ASN1BERDecUTCTime(dec, 0x17, &(val)->u.utcTime))
	    return 0;
	break;
    case 0x18:
	(val)->choice = 2;
	if (!ASN1BERDecGeneralizedTime(dec, 0x18, &(val)->u.generalTime))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ChoiceOfTime(ChoiceOfTime *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    break;
	case 2:
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_Validity(ASN1encoding_t enc, ASN1uint32_t tag, Validity *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->notBefore))
	return 0;
    if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->notAfter))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Validity(ASN1decoding_t dec, ASN1uint32_t tag, Validity *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->notBefore))
	return 0;
    if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->notAfter))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Validity(Validity *val)
{
    if (val) {
	ASN1Free_ChoiceOfTime(&(val)->notBefore);
	ASN1Free_ChoiceOfTime(&(val)->notAfter);
    }
}

static int ASN1CALL ASN1Enc_Extensions(ASN1encoding_t enc, ASN1uint32_t tag, Extensions *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_Extension(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Extensions(ASN1decoding_t dec, ASN1uint32_t tag, Extensions *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (Extension *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_Extension(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Extensions(Extensions *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_Extension(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_Extension(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Extension(ASN1encoding_t enc, ASN1uint32_t tag, Extension *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if (!(val)->critical)
	o[0] &= ~0x80;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->extnId))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1BEREncBool(enc, 0x1, (val)->critical))
	    return 0;
    }
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->extnValue).length, ((val)->extnValue).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Extension(ASN1decoding_t dec, ASN1uint32_t tag, Extension *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->extnId))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x1) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecBool(dd, 0x1, &(val)->critical))
	    return 0;
    }
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->extnValue))
	return 0;
    if (!((val)->o[0] & 0x80))
	(val)->critical = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Extension(Extension *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->extnId);
    }
}

static int ASN1CALL ASN1Enc_SignedContent(ASN1encoding_t enc, ASN1uint32_t tag, SignedContent *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->toBeSigned))
	return 0;
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->algorithm))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->signature).length, ((val)->signature).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignedContent(ASN1decoding_t dec, ASN1uint32_t tag, SignedContent *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->toBeSigned))
	return 0;
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BERDecBitString2(dd, 0x3, &(val)->signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignedContent(SignedContent *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->algorithm);
    }
}

static int ASN1CALL ASN1Enc_RevokedCertificates(ASN1encoding_t enc, ASN1uint32_t tag, RevokedCertificates *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_CRLEntry(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RevokedCertificates(ASN1decoding_t dec, ASN1uint32_t tag, RevokedCertificates *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (CRLEntry *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_CRLEntry(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RevokedCertificates(RevokedCertificates *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_CRLEntry(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_CRLEntry(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CRLEntry(ASN1encoding_t enc, ASN1uint32_t tag, CRLEntry *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->userCertificate))
	return 0;
    if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->revocationDate))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Extensions(enc, 0, &(val)->crlEntryExtensions))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CRLEntry(ASN1decoding_t dec, ASN1uint32_t tag, CRLEntry *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->userCertificate))
	return 0;
    if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->revocationDate))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Extensions(dd, 0, &(val)->crlEntryExtensions))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CRLEntry(CRLEntry *val)
{
    if (val) {
	ASN1intx_free(&(val)->userCertificate);
	ASN1Free_ChoiceOfTime(&(val)->revocationDate);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Extensions(&(val)->crlEntryExtensions);
	}
    }
}

static int ASN1CALL ASN1Enc_CertificationRequestInfo(ASN1encoding_t enc, ASN1uint32_t tag, CertificationRequestInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->subject))
	return 0;
    if (!ASN1Enc_SubjectPublicKeyInfo(enc, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    if (!ASN1Enc_Attributes(enc, 0x80000000, &(val)->attributes))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificationRequestInfo(ASN1decoding_t dec, ASN1uint32_t tag, CertificationRequestInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->subject))
	return 0;
    if (!ASN1Dec_SubjectPublicKeyInfo(dd, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    if (!ASN1Dec_Attributes(dd, 0x80000000, &(val)->attributes))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificationRequestInfo(CertificationRequestInfo *val)
{
    if (val) {
	ASN1Free_SubjectPublicKeyInfo(&(val)->subjectPublicKeyInfo);
	ASN1Free_Attributes(&(val)->attributes);
    }
}

static int ASN1CALL ASN1Enc_CertificationRequestInfoDecode(ASN1encoding_t enc, ASN1uint32_t tag, CertificationRequestInfoDecode *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->subject))
	return 0;
    if (!ASN1Enc_SubjectPublicKeyInfo(enc, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0x80000000, &(val)->attributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificationRequestInfoDecode(ASN1decoding_t dec, ASN1uint32_t tag, CertificationRequestInfoDecode *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->subject))
	return 0;
    if (!ASN1Dec_SubjectPublicKeyInfo(dd, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0x80000000, &(val)->attributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificationRequestInfoDecode(CertificationRequestInfoDecode *val)
{
    if (val) {
	ASN1Free_SubjectPublicKeyInfo(&(val)->subjectPublicKeyInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->attributes);
	}
    }
}

static int ASN1CALL ASN1Enc_KeygenRequestInfo(ASN1encoding_t enc, ASN1uint32_t tag, KeygenRequestInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_SubjectPublicKeyInfo(enc, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x16, ((val)->challenge).length, ((val)->challenge).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeygenRequestInfo(ASN1decoding_t dec, ASN1uint32_t tag, KeygenRequestInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_SubjectPublicKeyInfo(dd, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x16, &(val)->challenge))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeygenRequestInfo(KeygenRequestInfo *val)
{
    if (val) {
	ASN1Free_SubjectPublicKeyInfo(&(val)->subjectPublicKeyInfo);
	ASN1charstring_free(&(val)->challenge);
    }
}

static int ASN1CALL ASN1Enc_AuthorityKeyId(ASN1encoding_t enc, ASN1uint32_t tag, AuthorityKeyId *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->keyIdentifier).length, ((val)->keyIdentifier).value))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->certIssuer))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncSX(enc, 0x80000002, &(val)->certSerialNumber))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AuthorityKeyId(ASN1decoding_t dec, ASN1uint32_t tag, AuthorityKeyId *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOctetString2(dd, 0x80000000, &(val)->keyIdentifier))
	    return 0;
    }
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000001) {
	    (val)->o[0] |= 0x40;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType2(dd0, &(val)->certIssuer))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecSXVal(dd, 0x80000002, &(val)->certSerialNumber))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AuthorityKeyId(AuthorityKeyId *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1intx_free(&(val)->certSerialNumber);
	}
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyValidity(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyValidity *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncGeneralizedTime(enc, 0x80000000, &(val)->notBefore))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncGeneralizedTime(enc, 0x80000001, &(val)->notAfter))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyValidity(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyValidity *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecGeneralizedTime(dd, 0x80000000, &(val)->notBefore))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecGeneralizedTime(dd, 0x80000001, &(val)->notAfter))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyValidity(PrivateKeyValidity *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_CertPolicySet(ASN1encoding_t enc, ASN1uint32_t tag, CertPolicySet *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_CertPolicyId(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertPolicySet(ASN1decoding_t dec, ASN1uint32_t tag, CertPolicySet *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (CertPolicyId *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_CertPolicyId(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertPolicySet(CertPolicySet *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_CertPolicyId(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_CertPolicyId(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CertPolicyId(ASN1encoding_t enc, ASN1uint32_t tag, CertPolicyId *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncEoid(enc, 0x6, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertPolicyId(ASN1decoding_t dec, ASN1uint32_t tag, CertPolicyId *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (CertPolicyElementId *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecEoid(dd, 0x6, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertPolicyId(CertPolicyId *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1BEREoid_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1BEREoid_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AltNames(ASN1encoding_t enc, ASN1uint32_t tag, AltNames *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_GeneralName(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AltNames(ASN1decoding_t dec, ASN1uint32_t tag, AltNames *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (GeneralName *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_GeneralName(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AltNames(AltNames *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_GeneralName(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_GeneralName(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_GeneralNames(ASN1encoding_t enc, ASN1uint32_t tag, GeneralNames *val)
{
    if (!ASN1Enc_AltNames(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GeneralNames(ASN1decoding_t dec, ASN1uint32_t tag, GeneralNames *val)
{
    if (!ASN1Dec_AltNames(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GeneralNames(GeneralNames *val)
{
    if (val) {
	ASN1Free_AltNames(val);
    }
}

static int ASN1CALL ASN1Enc_OtherName(ASN1encoding_t enc, ASN1uint32_t tag, OtherName *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->type))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OtherName(ASN1decoding_t dec, ASN1uint32_t tag, OtherName *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->type))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType2(dd0, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OtherName(OtherName *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_EDIPartyName(ASN1encoding_t enc, ASN1uint32_t tag, EDIPartyName *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->nameAssigner))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->partyName))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EDIPartyName(ASN1decoding_t dec, ASN1uint32_t tag, EDIPartyName *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000000) {
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType2(dd0, &(val)->nameAssigner))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType2(dd0, &(val)->partyName))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EDIPartyName(EDIPartyName *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_SubtreesConstraint(ASN1encoding_t enc, ASN1uint32_t tag, SubtreesConstraint *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncOpenType(enc, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SubtreesConstraint(ASN1decoding_t dec, ASN1uint32_t tag, SubtreesConstraint *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (NOCOPYANY *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SubtreesConstraint(SubtreesConstraint *val)
{
  