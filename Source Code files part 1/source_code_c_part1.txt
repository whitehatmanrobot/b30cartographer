
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\inkbd.h ===
/*
	CW: Character Oriented Windows
	
	inkbd.h: Installable keyboard driver CW info
*/

/***BEGIN_PUBLIC***/
/* Key state masks for keyboard messages (in HIWORD(lParam)) */
#define	KK_EXTENDED		0x8000	/* from extended keypad usually */
/* shifts */
#define	KK_CAPLOCK		0x4000
#define	KK_NUMLOCK		0x2000
#define	KK_SCRLOCK		0x1000
#define	KK_ALT			0x0800
#define	KK_CONTROL		0x0400
#define	KK_SHIFT		0x0200

/* for WM_CHAR */
#define	KK_VK			0x01ff	/* mask to get untranslated VK_ */

/* for WM_KEYUP / WM_KEYDOWN */
#define	KK_SC			0x00ff	/* mask to get scan code */

#ifdef KANJI
#define KJ_SC			0xff00
#define KJ_KANA 		0x0080
#define KJ_OTHER		0x0040
#define KJ_KK			0x00b0
#define KJ_COUNT		0x003f
#endif

/***END_PUBLIC***/

/*****************************************************************************/
/* keyboard information structure (passed to driver) */

typedef VOID		(FAR PASCAL *LPFN_KBD_MSG)(BYTE, WORD, WORD, BOOL);
typedef BOOL		(FAR PASCAL *LPFN_KBD_TEST)(void);
typedef BOOL		(FAR PASCAL *LPFN_KBD_FALTD)(void);
typedef VOID		(FAR PASCAL *LPFN_KBD_UPD)(BOOL, BOOL, BOOL);
typedef VOID		(FAR PASCAL *LPFN_KBD_ABORT)(void);


typedef struct _inkb	/* keyboard info */
	{
	/* call back functions */
	LPFN_KBD_MSG	lpfnKeyboardMessage;
	LPFN_KBD_TEST	lpfnFTestKeyboardEmpty;
	LPFN_KBD_ABORT	lpfnSpecialAbort;

	/* public flags */
	BOOL	fAbort;			/* maps to global flag */
	BOOL	fPollKeyboard;		/* maps to global flag */
	BYTE	fKeyIsUp;		/* maps to global flag */
	BYTE	fKeyWasUp;		/* maps to global flag */
	WORD	wRateKeyRepeat;		/* maps to global flag */

	/* private CW flags */
	WORD	fNormalKeyboard;	/* => no TSR resident */
	BYTE	fNonAltKeyHit;		/* => non alt key hit */

	WORD	fDisableExtended;	/* => don't do extended bios calls */
	} INKB;

extern INKB	inkb;

/*****************************************************************************/
/* CW private info */

typedef VOID		(FAR PASCAL *LPFN_KBD_ENABLE)(INKB *, BOOL, BOOL);
typedef VOID		(FAR PASCAL *LPFN_KBD_POLL)(void);
typedef VOID		(FAR PASCAL *LPFN_KBD_FLUSH)(char *);
typedef WORD		(FAR PASCAL *LPFN_KBD_MKGET)(void);
typedef VOID		(FAR PASCAL *LPFN_KBD_SETKK)(WORD);
typedef char		(FAR PASCAL *LPFN_KBD_CHALT)(char);

typedef struct _inkj	/* keyboard jump table */
	{
	LPFN_KBD_ENABLE	pfnEnableKeyboardKbd;
	LPFN_KBD_POLL	pfnPollKeyboardKbd;
	LPFN_KBD_FLUSH	pfnFlushKeyRgchKbd;
	LPFN_KBD_MKGET	pfnMkGetShiftStatesKbd;
	LPFN_KBD_SETKK	pfnSetShiftKkKbd;
	LPFN_KBD_CHALT	pfnChAlternateKeytopKbd;	/* KANJI only */
	} INKJ;

/* indtKeyboard service */
#define	cpfnKbdMin	6

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\kmem.h ===
/*
	COW : Character Oriented Windows

	kmem.h : Kernel Memory module header + misc Kernel stuff
*/

/***BEGIN_PUBLIC***/

extern BYTE PASCAL	fShellPresent;		/* DOS 3 : SHELL.EXE hook */

HANDLE		FARPUBLIC GlobalAlloc(WORD, DWORD);		/*OPTIONAL*/
HANDLE		FARPUBLIC GlobalFree(HANDLE);			/*OPTIONAL*/
LPSTR		FARPUBLIC GlobalLock(HANDLE);			/*OPTIONAL*/
HANDLE		FARPUBLIC GlobalReAlloc(HANDLE, DWORD, WORD);	/*OPTIONAL*/
BOOL		FARPUBLIC GlobalUnlock(HANDLE);			/*OPTIONAL*/
DWORD		FARPUBLIC GlobalCompact(DWORD);			/*OPTIONAL*/

DWORD		FARPUBLIC RerrExec(char *, char *, char *, BOOL, BOOL);/*OPTIONAL*/
VOID		FARPUBLIC BindSegment(PFN, BOOL);		/*OPTIONAL*/
VOID		FARPUBLIC AccessSwapFile(BOOL);			/*OPTIONAL*/

/* RerrExec return values */
#define	rerrOk		0
#define	rerrBadFile	2
#define	rerrBadPath	3
#define	rerrNoMemory	8
#define	rerrBadFormat	11
#define	rerrBadRead	30
#define	rerrBadVersion	90
#define	rerrBadMemReq	91

/***END_PUBLIC***/



#ifdef COW

DWORD		FARPUBLIC GlobalHandle(HANDLE);

/* dereference global data object handle -- limited lifetime */
#define	LpvGlobalDeref(h)	((VOID FAR *) MAKELONG(0, HIWORD(GlobalHandle(h))))

#define GMEM_MOVEABLE	    0x0002
#define GMEM_ZEROINIT	    0x0040
#define LHND		(LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR		(LMEM_FIXED    | LMEM_ZEROINIT)
#define NONZEROLHND	(LMEM_MOVEABLE)
#define NONZEROLPTR	(LMEM_FIXED)

#endif /*COW*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\stamp2.asm ===
DB	13, 10, '$', 0
szVerCowMax:

_data	ends						 
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\gmemory5.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	gmemory5.asm : Global memory for DOS 5

	TITLE	GMEMORY - Windows interface to DOS memory management DOS 5

	.xlist
	include	kernel.inc
	.list


externFP  <DosAllocSeg, DosReallocSeg, DosFreeSeg>


sBegin	KERNEL
    assumes CS,KERNEL
    assumes DS,DATA


cProc	GlobalAlloc,<PUBLIC,FAR,ATOMIC>
    parmW   flags
    parmD   lcb
    localW  sd			;* segment descriptor - returned as handle
cBegin	GlobalAlloc

;*	* Assume size < 64 K
	mov	dx,word ptr (lcb+2)	;* HI_cb
	or	dx,dx
	jnz	alloc_fail		;* too big
	mov	ax,word ptr (lcb)	;* LO_cb
	lea	bx,sd
	cCall	DosAllocSeg,<ax, ss, bx, 0>	;* don't share
	or	ax,ax
	mov	ax,sd
	jz	alloc_ok
alloc_fail:
	xor	ax,ax			;* return NULL handle
alloc_ok:	;* ax = hgmem (actually a sd (segment descriptor))

cEnd	GlobalAlloc



cProc	GlobalReAlloc,<PUBLIC,FAR,ATOMIC>
    parmW   hgmem
    parmD   lcb
    parmW   flags
cBegin	GlobalReAlloc

;*	* Assume size < 64 K
	mov	dx,word ptr (lcb+2)	;* HI_cb
	or	dx,dx
	jnz	realloc_fail		;* too big
	mov	ax,word ptr (lcb)	;* LO_cb
	cCall	DosReallocSeg,<ax, hgmem>
	or	ax,ax
	mov	ax,hgmem		;* return old handle
	jz	realloc_ok
realloc_fail:
	xor	ax,ax			;* return NULL handle
realloc_ok:	;* ax = hgmem (actually a sd (segment descriptor))

cEnd	GlobalReAlloc



cProc	GlobalFree,<PUBLIC,FAR,ATOMIC>
    parmW   hgmem
cBegin	GlobalFree
	cCall	DosFreeSeg,<hgmem>
;*	* return VOID (Lock state not used).
cEnd	GlobalFree



cProc	GlobalLock,<PUBLIC,FAR,ATOMIC>
   parmW   hgmem
cBegin	GlobalLock
	mov	dx,hgmem
	xor	ax,ax		;* dx:ax => block
cEnd	GlobalLock



cProc	GlobalUnlock,<PUBLIC,FAR,ATOMIC>
   parmW   hgmem
cBegin	GlobalUnlock
;*	* Do nothing
cEnd	GlobalUnlock


cProc	GlobalHandle,<PUBLIC,FAR,ATOMIC>
   parmW   hgmem
cBegin	GlobalHandle

	mov	ax,hgmem			;* return handle/address
	mov	dx,ax				;* in both parts

cEnd	GlobalHandle


cProc	GetCodeHandle,<PUBLIC,FAR,ATOMIC>
   parmW   ps
   parmW   ib
cBegin	GetCodeHandle

	mov	ax,ps				;* return handle/address

cEnd	GetCodeHandle


cProc	ThrowStack,<PUBLIC,FAR,ATOMIC>
   parmW   bpNew
cBegin	ThrowStack
cEnd	ThrowStack


sEnd	KERNEL

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\gacheck.c ===
/*
	COW : Character Oriented Windows

	gacheck.c : global heap check procedure (DEBUG ONLY)
*/

#define COW
#include <cow.h>

#include <kmem.h>
#include <cwdebug.h>

#ifdef DEBUG	/* entire file for debug only */
#include "gadebug.h"

extern LPGLOBALINFO FAR PASCAL LpGlobalHeap(void);   /* where global heap is */

/* Two interfaces to global heap checking */
DWORD NEAR PASCAL CheckGlobalHeap(void);


BOOL FAR PASCAL
FCheckGlobalHeap(lpckh)
/*
  -- clean interface to check global heap
  -- note : DS unimportant
*/
CKH FAR *lpckh;
	{
	WORD cblk;
	LPGLOBALINFO lpGlobalHeap;
	WORD psArena;

	if (!(lpGlobalHeap = LpGlobalHeap()) ||
	    CheckGlobalHeap() != 0L)
		return FALSE;

	if (!lpckh)
		return TRUE;	/* no statistics required */

	/* Initialize structure */
	lpckh->cblkTotal = lpckh->cblkCode = lpckh->cblkData = lpckh->cblkFree = 0;
	lpckh->cbTotal = lpckh->cbCode = lpckh->cbData = lpckh->cbFree = 0L;

	cblk = lpGlobalHeap->hi_count;
	psArena = lpGlobalHeap->hi_first;
	while (cblk--)
		{
		LPGLOBALARENA pa = lpGlobalArena(psArena);
		DWORD cb = (DWORD) pa->ga_size;
		cb += cb;
		cb += cb;
		cb += cb;
		cb += cb;		/* sleazy way to get *16 with no
						LIBH routine */
		/* accumulate info */

		lpckh->cblkTotal++;
		lpckh->cbTotal += cb;
		if (!pa->ga_owner)
			{
			/* no owner => free */
			lpckh->cblkFree++;
			lpckh->cbFree += cb;
			}
		else if (pa->ga_owner < 256)
			{
			/* code segment */
			lpckh->cblkCode++;
			lpckh->cbCode += cb;
			}
		else if (pa->ga_owner != (WORD) -1)
			{
			/* data */
			lpckh->cblkData++;
			lpckh->cbData += cb;
			}
		/* else : special system object */
		psArena = pa->ga_next;
		}
	return TRUE;	/* Heap ok */
	}



STATIC DWORD NEAR PASCAL
CheckGlobalHeap()
/*
  -- check global heap : NOTE DS may be pointing to trash !!!!
*/
	{
	WORD cnt, maxcnt, nrefhandles, nhandles;
	WORD nfreehandles, nusedhandles, ndishandles;
	WORD p, pbadsig, pprev;
	LPGLOBALINFO lpGlobalHeap;
	LPGLOBALARENA pa;
	LPHANDLEENTRY ph;
	LPHANDLETABLE pt;
	WORD result = 0;

	if (!(lpGlobalHeap = LpGlobalHeap()))
		return 0;

/*
	if (!lpGlobalHeap->hi_check)
		return 0;
*/
	cnt = lpGlobalHeap->hi_count;
	pprev = (WORD) -1;
	pbadsig = 0;
	p = lpGlobalHeap->hi_first;
	while (cnt--)
		{
		pa = lpGlobalArena( p );

		/* check to see if within heap bounds */
		if (p < lpGlobalHeap->hi_first || p > lpGlobalHeap->hi_last)
			{
			if (!pbadsig)
				pbadsig = pprev;
				break;
			}

		/* check next link */
		if (pa->ga_next > p)
			{
			if (!pbadsig)
				{
                                if ((pa->ga_sig != GA_SIGNATURE)
                                    && (pa->ga_sig != GA_HOLESIG))
					pbadsig = pprev;
				else if ((pa->ga_size || pprev != (WORD) -1) &&
				    pa->ga_next != (p + pa->ga_size + 1))
					pbadsig = p;
				}

			pprev = p;
			p = pa->ga_next;
			}
		else
			{
			pprev = p;
			p = pa->ga_next;
			pa = lpGlobalArena( p );
			if (!pbadsig && pa->ga_sig != GA_ENDSIG)
				pbadsig = pprev;
			break;
			}
		}

	if (pbadsig || cnt || p != lpGlobalHeap->hi_last)
		result |= 1;	      /* Forward links invalid */

	cnt = lpGlobalHeap->hi_count;
	pprev = (WORD) -1;
	p = lpGlobalHeap->hi_last;
	while (cnt--)
		{
		if (p < lpGlobalHeap->hi_first || p > lpGlobalHeap->hi_last)
			{
			if (!pbadsig)
				pbadsig = pprev;
			break;
			}
		pa = lpGlobalArena( p );
		pprev = p;
		p = pa->ga_prev;
		if (p >= pprev)
			break;
		}

	if (pbadsig || cnt || p != lpGlobalHeap->hi_first)
		result |= 2;	    /* Backward links invalid */

	if (result || pbadsig)
		goto checkdone;     /* Bail out if invalid heap links */

	cnt = lpGlobalHeap->hi_count;
	p = lpGlobalHeap->hi_first;
	nrefhandles = 0;
	while (cnt--)
		{
		pa = lpGlobalArena( p );
		if (pa->ga_owner)
			if (pa->ga_handle)
				{
				ph = lpHandleEntry( pa->ga_handle );
				if ( ((LPFREEHANDLEENTRY)ph)->he_free == HE_FREEHANDLE ) {
					result |= 4;	/* Block points to free handle */
					if (!pbadsig) pbadsig = p;
					}
				else
				if ((WORD)pa->ga_handle == (WORD)0xFFFF ||
				    ph->he_address != p+1)
					{
					result |= 8;	/* Block points to handle but not vice versa */
					if (!pbadsig)
						pbadsig = p;
					}
				else
					nrefhandles++;
				}

		p = pa->ga_next;
		}

	nhandles = 0;
	ndishandles = 0;
	nusedhandles = 0;
	nfreehandles = 0;
	p = (WORD)lpGlobalHeap->hi_htable;
	maxcnt = nrefhandles;	/* Limit the search */
	while (maxcnt-- && p)
		{
		pt = lpHandleTable( p );
		ph = &pt->ht_entry[ 0 ];
		cnt = pt->ht_count;
		nhandles += cnt;
		while (cnt--)
			{
			if ( ((LPFREEHANDLEENTRY)ph)->he_free == HE_FREEHANDLE )
				nfreehandles++;
			else
			if (ph->he_flags & HE_DISCARDED)
				ndishandles++;
			else
				nusedhandles++;

			ph++;
			}

		p = (WORD)ph->he_address;
		}

	if (nrefhandles != nusedhandles)
		result |= 16;	/* allocated handles dont match used handles */

	if (nhandles != (nfreehandles + nusedhandles + ndishandles))
		result |= 32;	/* total number of handles dont add up */

	cnt = nfreehandles;
	p = (WORD)lpGlobalHeap->hi_hfree;
	while (cnt--)
		{
		ph = lpHandleEntry( p );
		p = (WORD)ph->he_address;
		}

	if (p)
		result |= 64;	/* total number of free handles dont add up */

checkdone:
	return (((DWORD)pbadsig << 16) | (DWORD)result);
	}

#endif /* DEBUG (entire file) */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\vkey.h ===
/*
	vkey.h : COW virtual keys
	NOTE : same as Windows except VK values are > 255
*/

/***BEGIN_PUBLIC***/	
#ifndef NOVIRTUALKEYCODES	
#define	VK_MIN		0x100

#define	VK_LBUTTON	0x101
#define	VK_RBUTTON	0x102
#define	VK_CANCEL	0x103
#define	VK_MBUTTON	0x104	/* NOT contiguous with L & RBUTTON */
#define	VK_BACK		0x108
#define	VK_TAB		0x109
#define	VK_CLEAR	0x10C
#define	VK_RETURN	0x10D
#define	VK_SHIFT	0x110
#define	VK_CONTROL	0x111
#define	VK_ALT		0x112
#define	VK_PAUSE	0x113
#define	VK_CAPLOCK	0x114

/* special VK_s for Kanji and Kana-Kanji conversion */
#define	VK_KANA		0x115
#define	VK_ROMAJI	0x116
#define	VK_ZENKAKU	0x117
#define	VK_HIRAGANA	0x118
#define	VK_KANJI	0x119
/* note: hole for 1A and 1B */
#define	VK_CONVERT	0x11C
#define	VK_NONCONVERT	0x11D
#define	VK_ACCEPT	0x11E
#define	VK_MODECHANGE	0x11F

#define	VK_ESCAPE	0x11B
#define	VK_SPACE	0x120

#define	VK_PRIOR	0x121
#define	VK_NEXT		0x122
#define	VK_END		0x123
#define	VK_HOME		0x124
#define	VK_LEFT		0x125
#define	VK_UP		0x126
#define	VK_RIGHT	0x127
#define	VK_DOWN		0x128

#define	VK_0		0x130
/* 1..8 */
#define	VK_9		0x139
#define	VK_A		0x141
/* B..Y */
#define	VK_Z		0x15A

#define	VK_SELECT	0x129
#define	VK_PRINT	0x12A
#define	VK_EXECUTE	0x12B
#define	VK_INSERT	0x12D
#define	VK_DELETE	0x12E
#define	VK_HELP		0x12F

#define	VK_NUMPAD0	0x160
#define	VK_NUMPAD1	0x161
#define	VK_NUMPAD2	0x162
#define	VK_NUMPAD3	0x163
#define	VK_NUMPAD4	0x164
#define	VK_NUMPAD5	0x165
#define	VK_NUMPAD6	0x166
#define	VK_NUMPAD7	0x167
#define	VK_NUMPAD8	0x168
#define	VK_NUMPAD9	0x169
#define	VK_MULTIPLY	0x16A
#define	VK_ADD		0x16B
#define	VK_SEPARATOR	0x16C
#define	VK_SUBTRACT	0x16D
#define	VK_DECIMAL	0x16E
#define	VK_DIVIDE	0x16F

#define	VK_F1		0x170
#define	VK_F2		0x171
#define	VK_F3		0x172
#define	VK_F4		0x173
#define	VK_F5		0x174
#define	VK_F6		0x175
#define	VK_F7		0x176
#define	VK_F8		0x177
#define	VK_F9		0x178
#define	VK_F10		0x179
#define	VK_F11		0x17A
#define	VK_F12		0x17B
#define	VK_F13		0x17C
#define	VK_F14		0x17D
#define	VK_F15		0x17E
#define	VK_F16		0x17F

#define VK_OAX		0x180

#define	VK_NUMLOCK	0x190
#define	VK_SCRLOCK	0x191

/* alternative names */
#define	VK_MENU		VK_ALT
#define	VK_CAPITAL	VK_CAPLOCK
#define	VK_OEM_NUMBER	VK_NUMLOCK
#define	VK_OEM_SCROLL	VK_SCRLOCK
#define	VK_SEPARATER	VK_SEPARATOR

#endif /*!NOVIRTUALKEYCODES*/	
/***END_PUBLIC***/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\umedit.h ===
/*    	COW : Character Oriented Windows

	umedit.h: Definitions for user multi-line Edit
	NOTE: these are defined by the old TWIN interface and are subject
		to change
	REVIEW: find out exactly what of this must be public
*/

/***BEGIN_PUBLIC***/

#ifndef NOMULTIEDIT

/*** ld - line buffer */
typedef struct ld
	{
	WORD	flags;
	WORD	cb;	/* count of bytes in buffer */
	WORD	cbMax;	/* max buffer length */
	char *	prgch;	/* pointer to buffer */
	} LD; 

/*** ip - insert point */
typedef struct ip
	{	/* insert point */
	short	ob;	/* offset to current column position */
	short	oln;	/* offset to current line position */
	} IP;

/*** pd - program descripter */
typedef struct pd
	{
	WORD	olntop;	/* offset within progrm display at top of screen */
	short	obleft;	/* offset within list buffer of left most character */
	WORD	oln;	/* current ld line offset within program */
	} PD;

/*** ef - Edit Field ***/
typedef struct ef
	{
	WORD	hBuffer;
	PD	pdCur;
	IP	ipCur;
	IP	ipAnchor;
	LD	*pldCur;
	PWND	pwndScrollV;
	PWND	pwndScrollH;
	WORD	attrCur;
	BYTE	Style;
	BYTE	fSelection;
	} EF;

#define hBufferUndefined	0xffff	/* hBuffer is not defined */

typedef struct LineAttr
	{
	WORD	attr;
	WORD	cb;
	} LineAttr;

extern BOOL PASCAL fPasteOk;
extern BOOL PASCAL fInsertMode;
extern LD PASCAL ldEMScratch;

extern WORD PASCAL emFlags;
#define EMF_IN_EDITMGR 0x01

/* styles */
#define ES_MULTILINE	0x0001
#define ES_NOREDRAW	0x0002
#define ES_NOSELECT	0x0004

/* control messages: */
#define EM_SELCHARS	(WM_USER+0)
#define EM_REPLACESEL	(WM_USER+1)
#define EM_GETWORD	(WM_USER+2)
#define EM_GETLINESEL	(WM_USER+3)
#define WM_UNDO 	(WM_USER+4)
#define WM_CLEAR	(WM_USER+5)
#define WM_SETTEXT	(WM_USER+6)
#define WM_GETTEXT	(WM_USER+7)
#define WM_SEARCHFIND	(WM_USER+8)
#define WM_SEARCHCHANGE (WM_USER+9)
#define WM_SETBOOKMARK	(WM_USER+10)
#define WM_GOTOBOOKMARK (WM_USER+11)
#define	WM_SEARCHNEXT	(WM_USER+13)
#define	WM_MATCHBRACE	(WM_USER+14)

/* ldCur.flags values */
#define LD_fDirty			0x0001


/* for Basic Text Manager Only */
ISA		FARPUBLIC SetInverseIsa(ISA);		/* OPTIONAL */

#endif /*!NOMULTIEDIT*/

/***END_PUBLIC***/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\sdmver.h ===
/*
	COW : Character Oriented Windows

	sdmver.h : sdm version control
*/

/***BEGIN_PUBLIC***/

#define	SDM_COW		1
/* #define SDM_ST */
/* #define SDM_LOCK */

/***END_PUBLIC***/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\itl.h ===
/*
	COW : Character Oriented Windows

	itl.h	: Internationalization header
*/

#ifdef LANGUAGE_ENGLISH

#define	szOk		"OK"
#define cchOk		(2+4)
/* chAccelOk no accelerator */

#define	szYes		"Yes"
#define cchYes		(3+2)
#define	chAccelYes	'Y'

#define	szNo		"No"
#define cchNo		(2+4)
#define	chAccelNo	'N'

#define szCancel	"Cancel"
#define cchCancel	6
/* chAccelCancel no accelerator */

#define	szRetry		"Retry"
#define	cchRetry	5
#define	chAccelRetry	'R'

#define	szAbort		"Abort"
#define cchAbort	5
#define	chAccelAbort	'A'

#ifdef HELP_BUTTON
#define szHelp		"Help"
#define cchHelp 	(4+2)
#define chAccelHelp	'H'
#endif

#endif /*LANGUAGE_ENGLISH*/



#ifdef LANGUAGE_FRENCH

#define szOk		"OK"
#define cchOk		(2+4)
/* chAccelOk no accelerator */

#define szYes		"Oui"
#define cchYes		(3+2)
#define chAccelYes	'O'

#define szNo		"Non"
#define cchNo		(3+3)
#define chAccelNo	'N'

#define szCancel	"Annuler"
#define cchCancel	7
/* chAccelCancel no accelerator */

#define szRetry 	"R\202essayer"
#define cchRetry	9
#define chAccelRetry	'R'

#define szAbort 	"Annuler"
#define cchAbort	7
#define chAccelAbort	'A'

#endif /*LANGUAGE_FRENCH*/



#ifdef LANGUAGE_JAPANESE

#define	szOk		"\212\155\224\106"		/* kakunin */
#define cchOk		(4+2)
/* chAccelOk no accelerator */

#define	szYes		"Y/\202\315\202\242"		/* hai */
#define cchYes		(6+2)
#define	chAccelYes	'Y'

#define	szNo		"N/\202\242\202\242\202\246"	/* iie */
#define cchNo		(8+0)
#define	chAccelNo	'N'

#define szCancel	"\216\346\217\301"		/* torikeshi */
#define cchCancel	(4+2)
/* chAccelCancel no accelerator */

#define	szRetry		"R/\215\304\216\300\215\163"	/* saijikkou */
#define	cchRetry	(8+0)
#define	chAccelRetry	'R'

#define	szAbort		"A/\222\206\216\176"		/* cyuushi */
#define cchAbort	(6+2)
#define	chAccelAbort	'A'

#ifdef HELP_BUTTON
#define szHelp		"H/\203\167\203\213\203\166"	/* herupu */
#define cchHelp 	(8+0)
#define chAccelHelp	'H'
#endif

#endif /*LANGUAGE_JAPANESE*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\handle.inc ===
;*
;*	COW : Character Oriented Windows
;*
;*	handle.inc : include file for handles

; Data structure that describes an allocation arena.  Both the local
; and global allocators use this structure at the beginning of their
; information structures.
;
HeapInfo    STRUC
hi_check    DW	?	; arena check word (non-zero enables heap checking)
hi_freeze   DW	?	; arena frozen word (non-zero prevents compaction)
hi_count    DW	?	; #entries in arena
hi_first    DW	?	; first arena entry (sentinel, always busy)
hi_last     DW	?	; last arena entry (sentinel, always busy)
hi_ncompact DB	?	; #compactions done so far (max of 3)
hi_dislevel DB	?	; current discard level
hi_distotal DW	?	; total amount discarded so far
hi_htable   DW	?	; head of handle table list
hi_hfree    DW	?	; head of free handle table list
hi_hdelta   DW	?	; #handles to allocate each time
hi_hexpand  DW	?	; address of near procedure to expand handles for
			; this arena
HeapInfo    ENDS

; Handle table entry.
;
HandleEntry STRUC
he_address  DW	?		    ; actual address of object
he_flags    DB	?		    ; flags and priority level
he_count    DB	?		    ; lock count
HandleEntry ENDS
he_link     EQU he_address	    ; Free handle table entries chained
				    ; through this word
he_owner    EQU he_address	    ; Discarded objects contain owner field
				    ; here so we know when to free handle
				    ; table entries of discarded objects.

HE_SWAPPED	EQU 080h	    ; Bit to mark objects that have been
				    ; handled by the swap module
HE_DISCARDED	EQU 040h	    ; Bit to mark objects that have been
				    ; discarded.

HE_BIT1 	EQU 020h	    ; Available bit
HE_BIT0 	EQU 010h	    ; Available bit
HE_DISCARDABLE	EQU 00Fh	    ; Discard level of this object
HE_USERFLAGS	EQU 03Fh	    ; Mask for user setable flags

HE_FREEHANDLE	EQU 0FFFFh	    ; Use -1 to mark free handle table entries

HE_ALIGN    = 4-1
HE_MASK     = NOT HE_ALIGN

; Handles are allocated in blocks of N, where N is the hi_hdelta field
; in the local heap information structure.  The last word of each block
; of handles is used to thread the blocks together, allowing all handles
; to be enumerated.  The first word of every block is the number of
; handle table entries in the block.  Not only does it save us code
; in henum, but it also has the convenient property of placing all
; handle entries on 2 byte boundaries (i.e. 2, 6, 10, 14), since the
; LA_MOVEABLE bit is 02h.  Thus the address of the he_address field of
; a handle table entry is also the address of the handle table entry
; itself.
;
HandleTable STRUC
ht_count    DW	?		    ; # handletable entries in this block
ht_entry    DB SIZE HandleEntry DUP (?)
HandleTable ENDS
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\kkeyboar.h ===
/*
	CW : Character Windows

	kkeyboar.h : keyboard exported interface
*/

#include <inkbd.h>				/* installable driver */

/***BEGIN_PUBLIC***/
extern BOOL PASCAL fAbort;			/* normal Abort */
extern BOOL PASCAL fPollKeyboard;		/* Poll the keyboard ? */
extern BYTE PASCAL fKeyIsUp, fKeyWasUp;		/* Key transitions */
extern WORD PASCAL wRateKeyRepeat;		/* repeat rate */
VOID		FARPUBLIC EnableKeyboard(BOOL);
VOID		FARPUBLIC PollKeyboard(void);
VOID		FARPUBLIC SetShiftKk(WORD);
VOID		FARPUBLIC DisableExtendedKeyboard(void);
/***END_PUBLIC***/


/*****************************************************************************/

#ifdef COW
/* COW PRIVATE */

INKJ	inkj;					/* jump vectors */

extern BYTE PASCAL fNonAltKey;			/* set on every non-alt key */
extern WORD PASCAL fNormalKeyboard;		/* FALSE => TSR keyboard input */
extern BYTE PASCAL fAbortSpecial;		/* special abort case */

WORD	FAR PASCAL	MkGetShiftStates(void);
#define	FAltDown()	(MkGetShiftStates() & MK_MENU)


#ifdef KANJI
char	FAR PASCAL	ChAlternateKeytop(char);
#endif /*KANJI*/

#endif /*COW*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\gmemory3.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	gmemory3.asm : Global memory for DOS 3
;*	* NOTE : the old size of the block is stored in the last 2 bytes
;*	*  of the MSDOS arena !!

	TITLE	GMEMORY - Windows interface to DOS memory management DOS 3

	.xlist
	include	kernel.inc
	.list

sBegin	KERNEL
    assumes CS,KERNEL
    assumes DS,DATA


;********** CparaOfCb **********
;*	entry : DX:BX = long count of bytes
;*	* round up to number of paragraphs
;*	exit : BX = # of paragraphs

cProc	CparaOfCb,<NEAR, ATOMIC>
cBegin	CparaOfCb
	add	bx,0fh			;* round up
	adc	dx,0
	mov	cx,4
shift_loop:
	shr	dx,1
	rcr	bx,1
	loop	shift_loop
cEnd	CparaOfCb



cProc	GlobalAlloc,<PUBLIC,FAR,ATOMIC>
    parmW   flags
    parmD   lcb
cBegin	GlobalAlloc
	mov	bx,word ptr (lcb)
	mov	dx,word ptr (lcb+2)	;* DX:AX = lcb
	cCall	CparaOfCb
	mov	ah,48h			;* alloc block
	push	bx
	int	21h
	pop	bx
	jc	alloc_error
	dec	ax
	mov	es,ax			;* point to arena
	inc	ax
	mov	es:[14],bx		;* save size
alloc_end:	;* ax = hgmem

cEnd	GlobalAlloc

alloc_error:
	xor	ax,ax			;* return NULL handle
	jmp	alloc_end


cProc	GlobalReAlloc,<PUBLIC,FAR,ATOMIC>
    parmW   hgmem
    parmD   lcb
    parmW   flags
cBegin	GlobalReAlloc

	mov	bx,word ptr (lcb)
	mov	dx,word ptr (lcb+2)	;* DX:AX = lcb
	cCall	CparaOfCb
	mov	es,hgmem		;* block to grow/shrink
	mov	ah,4ah			;* change size of block
	push	bx
	int	21h
	pop	bx
	mov	ax,hgmem
	jnc	realloc_ok

;*	* failed : attempt to allocate new block
	mov	ah,48h
	push	bx
	int	21h
	pop	bx
	jc	realloc_error		;* sorry - no room

;*	* copy from old to new
	push	si
	push	di
	push	ds
	mov	es,ax
	xor	di,di			;* es:di => destination

	mov	dx,hgmem		;* old source
	dec	dx
	mov	ds,dx			;* point to arena
	mov	cx,ds:[14]		;* old size in paragraphs
	inc	dx
	mov	ds,dx			;* point to old data

	xor	si,si			;* ds:si => old data

	shl	cx,1
	shl	cx,1
	shl	cx,1			 ;* cx = cw

	rep movsw			;* move to new location

	pop	ds
	pop	di
	pop	si

	push	ax			;* new hgmem
	mov	es,hgmem
	mov	ah,49h
	int	21h			;* free old block
	pop	ax			;* new hgmem

realloc_ok:	;* ax = hgmem
	dec	ax
	mov	es,ax			;* point to arena
	mov	es:[14],bx		;* save new size
	inc	ax
realloc_end:

cEnd	GlobalReAlloc

realloc_error:
	xor	ax,ax			;* return NULL handle
	jmp	realloc_end



cProc	GlobalFree,<PUBLIC,FAR,ATOMIC>
    parmW   hgmem
cBegin	GlobalFree
	mov	es,hgmem
	mov	ah,49h
	int	21h		;* free block
cEnd	GlobalFree



cProc	GlobalLock,<PUBLIC,FAR,ATOMIC>
   parmW   hgmem
cBegin	GlobalLock
	mov	dx,hgmem
	xor	ax,ax
cEnd	GlobalLock



cProc	GlobalUnlock,<PUBLIC,FAR,ATOMIC>
   parmW   hgmem
cBegin	GlobalUnlock
;*	* Do nothing
cEnd	GlobalUnlock


cProc	GlobalHandle,<PUBLIC,FAR,ATOMIC>
   parmW   hgmem
cBegin	GlobalHandle

	mov	ax,hgmem			;* return handle/address
	mov	dx,ax				;* in both parts

cEnd	GlobalHandle



sEnd	KERNEL

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\stamp.asm ===
;*	* CW : Header for stamp
;*	* Contains version #

_data	segment byte public 'data'			 
dgroup	GROUP _data					 
assume	cs:dgroup					 
public	sdVerCow,szVerCow,szVerCowMax

sdVerCow:
szVerCow:

	DB	'CW Version 2.22'
	DB	13, 10

;********************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\debug5.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	debug5.asm : debug support for OS/2


	include	kernel.inc

IFDEF	DEBUG	;* entire file!!

externFP	<VioWrtTty>


sBegin	KERNEL
    assumes CS,KERNEL
    assumes DS,nothing


cProc	CwOutSz,<FAR,PUBLIC>,<DI>
    parmW	sz
cBegin	CwOutSz

	PUBLIC	_cwoutsz
_cwoutsz:
	cld
	push	ss
	pop	es
	mov	di,sz
	xor	ax,ax
	mov	cx,0ffffh
	repne	scasb
	neg	cx
	sub	cx,2
	cCall	VioWrtTty,<es, sz, cx, 0>

cEnd	CwOutSz


sEnd	KERNEL

ENDIF	;DEBUG	;* entire file!!

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\uwindow.h ===
/*
	COW: Character Oriented Windows
	
	uwindow.h: Publics for USER Window
*/

/***BEGIN_PUBLIC***/

VOID		FARPUBLIC AddChild(PWND, PWND);
VOID		FARPUBLIC RemoveChild(PWND);
VOID		FARPUBLIC EnableWindow(PWND, BOOL);
VOID		FARPUBLIC GetClientRrc(PWND, RRC *);
VOID		FARPUBLIC SetWindowStyle(PWND, WORD);
VOID		FARPUBLIC SetWindowSize(PWND, BYTE, BYTE);
VOID		FARPUBLIC DrawWindow(PWND);
VOID		FARPUBLIC DrawBorder(PWND, BOX *, WORD, char *);
VOID		FARPUBLIC TextOut(PWND, RX, RY, char *, short, WORD);
VOID		FARPUBLIC CharOut(PWND, RX, RY, ACHAR, WORD);
VOID		FARPUBLIC FillRrc(PWND, PRRC, ACHAR, WORD);
VOID		FARPUBLIC BltRrc(PWND, RX, RY, BYTE, BYTE, RX, RY);
VOID		FARPUBLIC DrawBox(PWND, PRRC, BOX *, WORD);
VOID		FARPUBLIC SaveRrc(PWND, PRRC, BYTE FAR *);
VOID		FARPUBLIC RestoreRrc(PWND, PRRC, BYTE FAR *);
VOID		FARPUBLIC EnableCursor(PWND, BOOL);
VOID		FARPUBLIC MoveCursor(PWND, RX, RY);
VOID		FARPUBLIC MoveWindow(PWND, AX, AY);
BOOL		FARPUBLIC IntersectRect(PRRC, PRRC, PRRC);
VOID		FARPUBLIC UnionRect(PRRC, PRRC, PRRC);
BOOL		FARPUBLIC IsRectEmpty(PRRC);
VOID		FARPUBLIC SetRect(PRRC, RX, RY, RX, RY);
BOOL		FARPUBLIC PtInRect(PRRC, RX, RY);
WORD		FARPUBLIC CwSizeRrc(PRRC);
VOID		FARPUBLIC ShadowArc(PARC);
/*	* for overlap windows */
VOID		FARPUBLIC AddChildHead(PWND, PWND);		/*OPTIONAL*/
VOID		FARPUBLIC AddChildTail(PWND, PWND);		/*OPTIONAL*/
VOID		FARPUBLIC RethinkDisplay(void);			/*OPTIONAL*/
BOOL		FARPUBLIC FWindowToTop(PWND);            	/*OPTIONAL*/
VOID		FARPUBLIC RedrawDamagedRegions(void);		/*OPTIONAL*/
BOOL		FARPUBLIC FMoveSizeWithKeyboard(PWND, BOOL);	/*OPTIONAL*/
BOOL		FARPUBLIC FIsTopWindow(PWND);			/*OPTIONAL*/
PWND		FARPUBLIC PwndGetTopWindow(PWND);		/*OPTIONAL*/
VOID		FARPUBLIC DrawOverlapShadow(PWND);		/*OPTIONAL*/
/*	Listbox routines */
DWORD		FARPUBLIC ListBoxWndProc(PWND, WORD, WORD, DWORD);
VOID		FARPUBLIC InitListBox(PWND, PWFN);		/*OPTIONAL*/
VOID		FARPUBLIC InitListBoxOriented(PWND, PWFN, WORD *, WORD *);/*OPTIONAL*/
VOID		FARPUBLIC GetListBoxOrientation(PWND, WORD *, WORD *);/*OPTIONAL*/
#define FMoveOverlapWithKeyboard(pwnd) FMoveSizeWithKeyboard(pwnd,TRUE);
#define FSizeOverlapWithKeyboard(pwnd) FMoveSizeWithKeyboard(pwnd,FALSE);

#ifndef NORECT
#define CopyRect(prrcDest, prrcSrc) {*(prrcDest) = *(prrcSrc) }
#define SetRectEmpty(prrc) {*((long *) prrc) = 0; }
#endif /*!NORECT*/

#ifndef NOWNDMACROS

#define wndGeneric(id, style, fEnabled, ax, ay, dax, day, pfnWndProc, pwndParent, pwndSibling, pwndChild) { \
	id, style, 0, fEnabled, \
	{ax, ay, ax+dax, ay+day}, \
	{((style) & WS_BORDER) ? ax+1 : ax, \
	 ((style) & WS_BORDER) ? ay+1 : ay, \
	 ((style) & (WS_BORDER | WS_VSCROLL)) ? ax+dax-1 : ax+dax, \
	 ((style) & (WS_BORDER | WS_HSCROLL)) ? ay+day-1 : ay+day}, \
	(PLFN) pfnWndProc, pwndParent, pwndSibling, pwndChild, 0, 0,

#define wndGenericCursor(id, style, fEnabled, ax, ay, dax, day, pfnWndProc, pwndParent, pwndSibling, pwndChild, axCurs, ayCurs) { \
	id, style, TRUE, fEnabled, \
	{ax, ay, ax+dax, ay+day}, \
	{((style) & WS_BORDER) ? ax+1 : ax, \
	 ((style) & WS_BORDER) ? ay+1 : ay, \
	 ((style) & (WS_BORDER | WS_VSCROLL)) ? ax+dax-1 : ax+dax, \
	 ((style) & (WS_BORDER | WS_HSCROLL)) ? ay+day-1 : ay+day}, \
	(PLFN) pfnWndProc, pwndParent, pwndSibling, pwndChild, axCurs, ayCurs,
		
#define endWndGeneric }

#define wndListBox(id,fBorder,fSorted,fEnabled,ax,ay,dax,day,pfnWndProc,pwndParent,pwndSibling,pwndChild,color,isaHilite,ctickRep) { \
	id, (WS_CHILD | WS_LISTBOX | WS_VSCROLL | \
             (fSorted ? LBS_SORT : 0) | (fBorder ? WS_BORDER : 0)), \
	TRUE, fEnabled, {ax, ay, ax+dax, ay+day},                   \
	{ (fBorder ? ax+1 : ax),                                    \
	  (fBorder ? ay+1 : ay),                                    \
	  ((TRUE)  ? ax+dax-1 : ax+dax),                      \
	  (fBorder ? ay+day-1 : ay+day)     }, \
	(PLFN) pfnWndProc, pwndParent, pwndSibling,      \
	pwndChild, \
        (fBorder ? ax+2 : ax+1), 1 \
 	,{0,0,0,0,0,0,0,0,0,1,0,0,color,isaHilite,ctickRep,0} }

#define	SetWindowProc(pwnd, pfn) {(pwnd)->pfnWndProc = pfn;}
#define	GetWindowWord(pwnd, iw) ((pwnd)->rgwExtra[(iw)])
#define	SetWindowWord(pwnd, iw, w) {(pwnd)->rgwExtra[(iw)] = (w);}
#define	PwndParent(pwnd) ((pwnd)->pwndParent)
#define	PwndChild(pwnd) ((pwnd)->pwndChild)
#define	PwndSibling(pwnd) ((pwnd)->pwndSibling)

#endif /*NOWNDMACROS*/

#ifndef NODRAW
/* Window Drawing support */
#define	AxOfRx(pwnd,rx) ((pwnd)->arcClipping.axLeft+(rx))
#define	AyOfRy(pwnd,ry) ((pwnd)->arcClipping.ayTop+(ry))
#define	RxOfAx(pwnd,ax) ((ax)-(pwnd)->arcClipping.axLeft)
#define	RyOfAy(pwnd,ay) ((ay)-(pwnd)->arcClipping.ayTop)
#define CbSizeRrc(prrc) (CwSizeRrc(prrc) << 1)
#endif /*!NODRAW*/

#ifndef NOWINSTYLES
/* Window styles */
#define	WS_TILED		0x0000
#define	WS_CHILD		0x0000	/* note : no distinction */

#define	WS_BORDER		0x0100
#define	WS_VSCROLL		0x0200
#define	WS_HSCROLL		0x0400
#define WS_SUBSTYLE		0x003f

#define WS_OVERLAP		0x0040
#define WS_CLIPOUT		0x0080

#define WS_TYPE 		0x3800	/* type mask */
#define WS_EDIT			0x0800
#define WS_LISTBOX		0x1000
#define WS_BUTTON		0x1800
#define WS_STATIC		0x2000
#define WS_DIALOG		0x2800
#define WS_SCROLL		0x3000
#define WS_STATIC_NOACCEL	0x3800

#define LBS_SORT		0x0001
#endif /*!NOWINSTYLES*/

/* codes for listbox item indices */
#define	iszMin	((WORD)	0)
#define	iszNil	((WORD)	-1)		/* invalid isz */

/***END_PUBLIC***/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\ukanji.h ===
/*
	CW : Character Oriented Windows

	ukanji.h : KANJI (DBCS) specific definitions
*/

/***BEGIN_PUBLIC***/

BOOL		FARPUBLIC FIsDbcsChar(ACHAR);		/* OPTIONAL */
WORD		FARPUBLIC CchLenDbcs(char *);		/* OPTIONAL */
char *		FARPUBLIC PchNextDbcs(char *);		/* OPTIONAL */
char *		FARPUBLIC PchPrevDbcs(char *, char *);	/* OPTIONAL */

/***END_PUBLIC***/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\rlb.inc ===
;*
;*	rlb.inc : Compact relocation format
;*

;*	* Magic values for RLB signature
magicWin2	EQU	334EH		;* N3

;*	* Compact Relocations
RLC 	STRUC
rliRlc		DW	?		;* reloc info (see below)
offSrcRlc	DW	?		;* start thread address
RLC 	ENDS

;*	* if fImportRli == 0
RLI	RECORD	fImportRli:1, fAddRli:1, rtRli:2, ithunkRli:12
;*	* LOBYTE(rli) == segTarg for rtFixed
;*	* if fImportRli == 1
RLI2	RECORD	fImportRli2:1, fNameRli:1, rtRli2:2, imodRli:3, entnoRli:9
;*	* imodRli is 0 based

rtFixed		EQU	0		;* Base to fixed segment
					;*   (may be additive)
rtOffset	EQU	1		;* offset of thunk
rtBase		EQU	2		;* base of thunk
rtPtr		EQU	3		;* ptr to thunk


;*	* Relocation Block Info
RLT	RECORD	f2Rlt:1, f1Rlt:1, prelocRlt:14

RLS 	STRUC
rltRls		DW	?		;* see RLT record above
csumRls		DW	?		;* check sum
RLS 	ENDS

RLB	STRUC
magicRlb	DW	?		;* magic value (magicNe)
segSpecialRlb	DW	?		;* first segment
segFirstRlb	DW	?		;* first segment
rgrlsRlb	DB	?		;* Array of RLSs
				;* zero'th element is segSpecial
				;* 1'st element is segFirst
				;* (all remaining sequential from segFirst).
RLB	ENDS


IFDEF DUAL
;*******************************************************************************
;*
;*	DUAL mode extras
;*

;*	NOTE:	This must match the RLE struct in \ut\munge\rlb.h!!
RLB_ENT	STRUC
re_segLast	DB	?	;* last segment handled by this rlb
re_iexe		DB	?	;* swap file index
re_cbRlb	DW	?	;* Rlb size
re_lfaRlb	DD	?	;* lfa relative to beginning of main swap file
re_dlfaBias	DD	?	;* dlfa for this exe
RLB_ENT	ENDS

LO_re_lfaRlb	EQU	[word ptr re_lfaRlb]
HI_re_lfaRlb	EQU	[word ptr re_lfaRlb + 2]

LO_re_dlfaBias	EQU	[word ptr re_dlfaBias]
HI_re_dlfaBias	EQU	[word ptr re_dlfaBias + 2]

;*
;*******************************************************************************
ENDIF ;DUAL
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\kernel.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	kernel : kernel init for stand alone kernel
;REVIEW:	this file is massively out of date !!

	include kernel.inc


IFDEF DEBUG
neLomOffset	=	OFFSET neLom
	PUBLIC	neLomOffset	;* address for Pcode Debugger
ENDIF ;DEBUG


sBegin	BSS
    assumes DS,DGROUP

externB	iexeCur			;* set to 255 when closing EXE file

globalW	psLom,0			;* ps of LOM data initialized by loader

globalW hGlobalHeap,0	    ; Handle to master object
globalW pGlobalHeap,0	    ; Current physical address

;;;;;globalB	rgbKernelBuff,<cbKernelBuff DUP (?)>	;* General buffer

sEnd	BSS


sBegin	DATA
    assumes DS,DGROUP

externW     <pStackTop, pStackMin, pStackBot>

sEnd	DATA



;*	* Far entry provided by application
externFPublic <_main>

;*	* Global free
externFP    <GlobalFree>

externFP    <FInitSysTimer>			;* from ktimer.asm
externFP    <EndSysTimer>			;* from ktimer.asm

sBegin	INIT
    assumes CS,INIT
    assumes DS,DGROUP
    assumes SS,DGROUP

externNP    <InitThunk>				;* from ldthunk.asm

;********** BeginKernel **********
;*	entry : es = psLom
;*		ax = handle of LOADER
;*		si = start of DDS local heap
;*		di = end of DDS local heap
;*		sp = Bottom of stack
;*	* Called by loader to start up the kernel
;*	exit : NEVER EXITED ! (see ExitKernel()).
cProc	BeginKernel,<FAR,PUBLIC,ATOMIC>
cBegin	BeginKernel

	push	ax				;* save hmemLoader

	mov	psLom,es			;* save all important psLom
;*	* Copy very important variables from LOM into DS
	mov	ax,es:[pGlobalHeapLom]
	mov	pGlobalHeap,ax
	mov	ax,es:[hGlobalHeapLom]
	mov	hGlobalHeap,ax

;*	* Initialize DDS for stack limits
	mov	ax,sp
	mov	pStackBot,ax
	mov	pStackMin,ax
	sub	ax,es:[neLom.ne_stack]		;* less stack size
	mov	pStackTop,ax

;*	* Initialize entry table for Thunk control
	cCall	InitThunk

;*	* Initialize the system timer
	cCall	FInitSysTimer

;*	* Free the loader
	cCall	GlobalFree			;* handle already on the stack
IFDEF DEBUG
	or	ax,ax
	jz	ok_free_loader
	cCall	CowAssertFailed
	DB	"freeing loader$"
ok_free_loader:
ENDIF ;DEBUG

;*	* call the Application's main entry point
	xor	ax,ax			;* no parameters
	cCall	_main,<ax,ax>

cEnd	BeginKernel

;*******************************************************

sEnd	INIT

;*****************************************************************************

sBegin	EXIT
    assumes CS,EXIT
    assumes SS,DATA
    assumes DS,DATA



;********** ExitKernel alias **********

	PUBLIC _exit
_exit:
;*	* fall through to ExitKernel

;********** ExitKernel / exit (ex) **********
;*	entry : ex = exit code
;*	* Exit from COW system (unhook everything)
;*	exit : never return to caller - return to system

cProc	ExitKernel,<FAR,PUBLIC,ATOMIC>
   parmB ex
cBegin	ExitKernel

;*	* unhook system timers
	cCall	EndSysTimer
;*	* close the swap file (to be nice)
	mov	ax,-1
	xchg	iexeCur,al			;* set iexeCur = 255, get old
	cmp	al,ah
	je	no_file_open			;* iexeCur == 255
	mov	es,psLom
	mov	bx,es:[fdExeLom]
	AssertNE bx,-1
	mov	ah,3eh
	int	21h				;* close file
	mov	iexeCur,255			;* no file open
no_file_open:

;*	* exit to DOS
	mov	al,ex
	mov	ah,4ch				;* terminate a process
	int	21h
;*	*NOTREACHED*

cEnd	ExitKernel

sEnd	EXIT

;*****************************************************************************

sBegin	KERNEL
    assumes CS,KERNEL

;*	* stub for prompting for swap disk (never called)
cProc	PromptSwapDisk, <NEAR, PUBLIC, ATOMIC>
cBegin
	mov	ax,999				;* never called !!
	cCall	ExitKernel,<ax>
cEnd

sEnd	KERNEL


;*****************************************************************************

	END	BeginKernel
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\kinput.h ===
/*
	COW : Character Oriented Windows

	kinput.h : Kernel Input module header
*/

#include <inmou.h>			/* mouse driver */

/***BEGIN_PUBLIC***/

extern BYTE	PASCAL	fMousePresent;		/* valid after init */

VOID		FARPUBLIC LeaveCow(BOOL);			/*OPTIONAL*/
				/* temporary leave COW */
/* Swapped Cow init/exit */
#ifdef CC
VOID		FAR CDECL exit(int);				/*OPTIONAL*/
#endif

VOID		FARPUBLIC GetProgDir(char *);			/*OPTIONAL*/

/* Non-swapped Cow init/end */
BOOL		FARPUBLIC FInitCow(void);			/*OPTIONAL*/
VOID		FARPUBLIC EndCow(WORD);				/*OPTIONAL*/

/***END_PUBLIC***/


#ifdef COW

#ifdef DOS5
VOID		FARPRIVATE KickTimer(DWORD);
#define	ctickIdle	((DWORD) -1L)			/* idle timer */
#else
#define	KickTimer(ctick)				/* nothing here */
#endif

#endif /*COW*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\gmem.asm ===
;*
;*	CW : Character Windows
;*
;*	
	TITLE	GMEM - Register interface to global memory allocator

	.xlist
	include	kernel.inc
	include	galloc.inc
	.list


sBegin	KERNEL
    assumes CS,KERNEL
    assumes DS,NOTHING			;* usually points to MOB
    assumes SS,DATA

;*	* low level procs
externNP    <halloc,hfree,hdref>	    ; HANDLE.ASM
externNP    <gsplice,gjoin,gzero>	    ; GALLOC.ASM
externNP    <gsearch,gmarkfree,gcheckfree>  ; GALLOC.ASM
externNP    <gmovebusy,gcompact>	    ; GCOMPACT.ASM
externNP    <gnotify>			    ; GINTERF.ASM
IFDEF	REALLOC_FIXED
externNP    <gfixedCompact>		    ; GFIXCOMP.ASM
ENDIF	; REALLOC_FIXED

	PUBLIC	galign, gdref, ghandle, galloc, grealloc
	PUBLIC	gfree, glock, gunlock

SUBRS	PROC	NEAR

; GALIGN - procedure to align the size request for a global item to
; the next high valid paragraph boundary.
;
;   Input:	BX = #paras
;		Carry flag set if #paras overflowed.
;
;   Output:	DX = #paras aligned to next higher multiple of 4
;
galign: jc	align1		    ; Overflow occur?
	lea	dx,[bx+GA_ALIGN]    ; No, add alignment amount
	and	dl,GA_MASK	    ; ...modulo alignment boundary
	cmp	dx,bx		    ; Test for overflow
	jb	align1		    ; Yes, continue
	ret
align1: mov	dx,GA_MASK	    ; Return largest possible size
	ret


; GDREF - procedure to dereference a global handle.
;
;   Inputs:	DX = handle
;
;   Outputs:	ES:DI = address of arena header
;		AX = address of client data
;		CH = lock count or zero for fixed objects
;		SI = handle table entry address or zero for fixed objects
;		Z flag set if NULL handle or AX = 0
;

gdref:
	xor	cx,cx			; Zero lock count
	mov	ax,dx			; Return handle if fixed object
	test	al,GA_FIXED		; Is it moveable?
	jz	dref3			; Yes, go dereference handle
	xor	si,si			; Set SI to zero for fixed objects
dref1:
	or	ax,ax			; No, were we passed NULL?
	jz	dref2			; Yes, then all done
	mov	bx,ax			; No, return ES:DI pointing
	dec	bx
	mov	es,bx			; ...to arena header
	cmp	ES:[di].ga_sig,GA_SIGNATURE ; Return error if, invalid sig.
	jne	dref4
	cmp	ES:[di].ga_handle,si	    ; Handle mismatch
	jne	dref4
	cmp	ES:[di].ga_owner,di	    ; or free block
	je	dref4
dref2:					; Otherwise return with Z flag clear
	ret
dref3:
	mov	si,dx
	call	hdref	    ; Get true address in AX and lock count in CH
	jnz	dref1	    ; Compute arena header if valid true address
	mov	bx,[si].he_address	; Return owner of discarded object
dref4:					; in BX
	xor	ax,ax
	ret

;
; GHANDLE - procedure return the handle for a global segment.
;
;   Inputs:	AX = handle or segment address parameter
;		DS:DI = master object segment address
;
;   Outputs:	AX = handle or zero if invalid segment address
;		Z flag set if DX is zero.  O.W. Z flag reset and
;		BX = pointer to handle table entry
;		CX = lock count and flags for moveable object
;		DX = segment address or zero if discarded or invalid handle
;		ES:DI = arena header of block
;
;   Destroys:	ES,BX
;

ghandle:
	mov	bx,ax			; Compute address of arena header
	test	bl,GA_FIXED		; Fixed?
	jnz	gh0			; Yes, have segment address then
	or	bx,bx			; Null handle?
	jz	gh1			; Yes, return null
	test	bl,2			; Valid moveable handle?
	jz	gh1			; No, return null
	mov	bx,ds:[di].hi_htable	; Get base of handle table
	cmp	ax,bx			; Handle pointer before it?
	jbe	gh1			; Yes, return null
	mov	cx,ds:[bx].ht_count	; Get size of handle table
	shl	cx,1
	shl	cx,1
	add	bx,cx
	cmp	ax,bx			; Handle pointer after it?
	jae	gh1			; Yes, return null
	mov	bx,ax
	mov	cx,word ptr [bx].he_flags
	inc	cx			; Free handle?
	jz	gh1			; Yes, return null
	dec	cx
	test	cl,HE_DISCARDED 	; No, discarded?
	jnz	gh3			; Yes, then no segment address
	mov	ax,ds:[bx].he_address	; No, convert handle to
	mov	bx,ax			; segment address
gh0:
	dec	bx
	cmp	ds:[di].hi_first,bx	; Error if points outside arena
	jae	gh1
	cmp	ds:[di].hi_last,bx
	jbe	gh1
	mov	es,bx
	cmp	ES:[di].ga_sig,GA_SIGNATURE
	jne	gh1			; Error if invalid signature byte
	cmp	ES:[di].ga_owner,di
	je	gh1			; Error if free segment
	mov	bx,ES:[di].ga_handle	; Get back pointer to handle
	or	bx,bx
	jz	ghx			; Return seg parameter if not moveable
	cmp	DS:[bx].he_address,ax	; Does handle point to segment?
	jne	gh1			; No, return error
gh0a:
	mov	cx,word ptr [bx].he_flags
	errnz	<2-he_flags>
	errnz	<3-he_count>
	mov	dx,ax			; Return segment address in DX
	or	dx,dx			; Clear Z flag
	mov	ax,bx			; Yes, return handle
	ret				; Return
gh1:	xor	ax,ax
ghx:	xor	cx,cx
	mov	dx,ax
	ret
gh3:
	xor	ax,ax
	test	cl,HE_SWAPPED		; Discarded, is it swapped?
	jz	gh0a			; No, return NULL

	jmp	short gh1		;* all done


; GALLOC - procedure to allocate global memory.
;
;   Inputs:	AX = allocation flags
;		BX = #paragraphs
;		CX = owner field
;		DS:DI = address of global heap info
;
;   Outputs:	AX = handle to object or zero
;		BX = size of largest free block if AX = 0
;		CX = AX
;

galloc:
	or	bx,bx			; Allocating zero size?
	jnz	ga1			; No, continue
	xchg	ax,cx			; AX = owner, CX = flags
	test	cl,GA_MOVEABLE		; Yes, moveable?
	jz	gaerr			; No, return error (AX = 0)
	push	cx			; save flags
	call	halloc			; and allocate handle for owner
	pop	dx			; restore flags
	jcxz	gaerr			; Error return
	or	dh,HE_DISCARDED 	; and mark as discarded
	mov	[bx].he_flags,dh	; Set handle flags
	jmp	short gax
gaerr1:
	dec	dx			; Free block if no available
	mov	es,dx			; handles.
	call	gmarkfree
gaerr:
	xor	dx,dx			; DX = 0 means NOT out of memory
	xor	ax,ax			; Return AX = 0 to indicate error
	jmp	short gax
ga1:
	call	gsearch 		; Search for block big enough
	jz	gax			; Done, if couldn't get enough
	test	dl,GA_MOVEABLE		; Is this a moveable object?
	jz	gax			; No, all done
	call	halloc			; Yes, allocate handle for object in AX
	jcxz	gaerr1			; No handles, free memory
	mov	si,[bx].he_address	; Store back link to handle in header
	dec	si
	mov	es,si
	mov	ES:[di].ga_handle,bx	; Mark as moveable block
	mov	[bx].he_flags,dh	; Save discard level in handle
gax:
	mov	cx,ax
	ret


; GREALLOC - procedure to reallocate global memory object
;
;   Inputs:	AX = allocation flags
;		BX = #paragraphs for new size
;		CX = new owner field value
;		DX = existing handle
;		DS:DI = address of global heap info
;
;   Outputs:	AX = handle to object or zero
;		DX = size of largest free block if AX = 0
;		CX = AX
;

grealloc:
	push	bp
	mov	bp,sp
	push	ax
rflags	EQU	word ptr [bp-2]
	push	dx
h	EQU	word ptr [bp-4]
	push	cx
owner	EQU	word ptr [bp-6]
	push	bx
rsize	EQU	word ptr [bp-8]
	call	gdref
	mov	bx,rsize
	jz	racreate	    ; Do nothing with zero, free or discarded  handles
	or	bx,bx		    ; Are we reallocing to zero length?
	jnz	raokay1  	    ; No, continue
	jcxz	radiscard	    ; No, is handle locked?
rafail:
	xor	ax,ax		    ; Yes, return failure
	xor	dx,dx
	jmp	raexit

radiscard:			    ; No, then try to discard the object
	; Here to discard object, when reallocating to zero size.  This
	; feature is only enabled if the caller passes the moveable flag
	test	byte ptr rflags,GA_MOVEABLE ; Did they want to discard?
	jz	rafail		    ; No, then return failure.
	mov	al,GN_DISCARD	    ; AL = discard message code
	xor	cx,cx		    ; CX = discard level of 0 (means realloc)
	mov	bx,h		    ; BX = handle
	push	es
	mov	dx,es:[di].ga_owner	;* set owner for notify
	call	gnotify			;* notify that we are discarding
					;* note : no return value
	pop	es
	push	ES:[di].ga_owner    ; Save owner field
	push	ax
	call	gmarkfree	    ; Free client data
	pop	cx
	jz	rafixed 	    ; Return NULL if freed a fixed block
	mov	[si].he_address,cx  ; No, remember owner in handle table entry
	or	[si].he_flags,HE_DISCARDED  ; ...and mark discarded
	jmp	short rasame1	    ; Return original handle, except
				    ; GlobalLock will now return null.
rafixed:
	pop	ax
	xor	ax,ax
	jmp	raexit

rasame1:
        jmp     short rasame
raokay1:
        jmp     short raokay
rafail0:
	jmp	rafail

racreate:
	test	cl,HE_DISCARDED     ; Is this a discarded handle?
	jz	rafail0 	    ; No, return error
	or	bx,bx		    ; Are we reallocing to zero length?
	jz	rasame		    ; Yes, return handle as is.
	mov	ax,GA_MOVEABLE	    ; Reallocating a moveable object
	or	ax,rflags	    ; ...plus any flags from the caller
	mov	cl,[si].he_flags    ; ...plus saved segment type bits
	and	cl,GA_SEGTYPE
	or	al,cl
	or	ah,cl
	test	al,GA_DISCCODE	    ; Discardable code segment?
	jz	ranotcode
	or	al,GA_ALLOCHIGH     ; Yes, allocate high
ranotcode:
	mov	[di].gi_cmpflags,al ; Save flags for gcompact
	mov	cx,[si].he_owner    ; Use previous owner
	push	si		    ; save handle
	call	gsearch 	    ; Find block big enough
	pop	si		    ; restore existing handle
	jz	racreate1
	xor	[si].he_flags,HE_DISCARDED  ; and mark as not discarded
	mov	[si].he_address,ax  ; Set new client data address
	mov	ch,[si].he_flags    ; Get handle flags
	xchg	ax,si		    ; Return original handle
				    ; Set back link to handle in new block
	dec	si
	mov	es,si
	mov	ES:[di].ga_handle,ax
	and	ch,GA_SEGTYPE
	mov	ES:[di].ga_flags,ch ; Copy segment type flags to ga_flags
racreate0:
	jmp	raexit
racreate1:
	jmp	rafailmem1
raokay:
	mov	si,bx
	add	bx,ax		    ; Compute address of new next header
	call	galign		    ; assuming there is room.
; Here if not trying to realloc this block to zero
; ES:0 = arena header of current block
; AX:0 = client address of current block
; CH = lock count of current block
; DX:0 = new next block, based on new requested size
; SI = new requested size of block
	mov	bx,ES:[di].ga_next  ; Get address of current next header
	cmp	dx,bx		    ; Are we growing or shrinking?
	ja	ragrow		    ; We are growing
rashrink:			    ; We are shrinking
; Here to shrink a block
; ES:0 = arena header of current block
; BX:0 = arena header of next block
; DX:0 = new next block, based on new requested size
	mov	si,dx		    ; SI = new next block
	inc	dx		    ; Test for small shrinkage
	inc	dx
	errnz	<GA_ALIGN-1>

	cmp	dx,bx		    ; Is there enough room from for free block?
	jae	raoverflow	    ; No, then no change to make
				    ; Yes, ES:DI = current block, SI=new block
	call	gsplice 	    ; splice new block into the arena
	mov	es,si		    ; ES:DI = new free block
	call	gmarkfree	    ; Mark it as free
rasame:
	mov	ax,h		    ; Return the same handle
rax:	jmp	raexit		    ; All done

raoverflow:
	test	byte ptr rflags,GA_ZEROINIT ; Zero file extension?
	jz	rasame	            ; No, continue
	mov	cx,bx		    ; Next heap header
	dec	cx		    ; Last paragraph for us
	mov	bx,si		    ; Where the new block would have started
	call	gzero		    ; zero fill extension
	jmp	short rasame

; Here to try to grow the current block
; AX:0 = client address of current block
; CH = lock count of current block
; ES:0 = arena header of current block
; BX:0 = arena header of next block
; DX:0 = new next block, based on new requested size
; SI = new requested size of block
ragrow:
	mov	al,1		    ;* first time through
ragrowagain:	;* al == 0 => don't retry
	push	es		    ; Save current block address
	mov	es,bx		    ; ES = next block address
	cmp	ES:[di].ga_owner,di ; Is next block free?
	jne	ragrow1		    ; No, can't fit it in
	sub	dx,bx		    ; Yes, compute how much of it we need
	push	si		    ; See if free block is big enough
	push	ax		    ;* save flag
	call	gcheckfree
	pop	ax
	pop	si
	jb	ragrow2		    ; No, can't fit it in
	add	dx,bx		    ; Yes, restore new next block address
	pop	cx		    ; Discard saved value (gjoin returns it)
	mov	cx,es		    ; Yes, save free block address in CX
	call	gjoin		    ; and attach to end of current block
	test	byte ptr rflags,GA_ZEROINIT ; Zero fill extension?
	jz	ranz		    ; No, continue
	mov	bx,cx		    ; Yes, BX = first paragraph to fill
	mov	cx,dx		    ; compute last paragraph to fill
	dec	cx		    ; into CX
	call	gzero		    ; zero fill extension
ranz:
	mov	bx,ES:[di].ga_next  ; Pick up new next block address
	jmp	rashrink	    ; Now shrink block to correct size

ragrow2:
	add	dx,bx		    ;* restore dx
; Here to try to move the current block (or grow fixed block in place)
; BX:0 = arena header of next block
; CH = lock count of current block
; DX:0 = new next block, based on new requested size
; (on stack) ES:0 = arena header of current block
; SI = new requested size of block
ragrow1:
	pop	es		    ; Recover current block address
	push	bx
	push	dx		    ;* save flags in case we must retry
	mov	dx,rflags	    ; get the passed in flags
	AssertReset dl,GA_DISCCODE  ;* you can not grow fixed code !
	mov	bx,GA_MOVEABLE	    ; Determine if okay to move this guy
	jcxz	ramove1 	    ; Continue if this handle not locked
	test	dx,bx		    ; Locked.  Did they say move anyway?
	jnz	ramove1 	    ; Yes, go do it
;*	* Can't move (i.e. fixed or locked)
	jmp	short ragrowfixed   ;* force grow in place
ramove1:
	or	dx,bx		    ; make sure moveable bit set
	test	h,GA_FIXED	    ; Is this a moveable handle?
	jz	ramove2 	    ; Yes, okay to move
	xor	dx,bx		    ; No, clear moveable flag in arg to gsearch
	test	rflags,bx	    ; Did they say it's okay to move?
	jnz	ramove2 	    ; Yes, proceed
ragrowfixed:
	or	al,al
	jz	rafailmem	    ;* try maximum of twice
	push	ax
	push	si
	push	es
IFDEF	REALLOC_FIXED
	mov	dx,si		    ;**** over size request M00BUG
	cCall	gfixedCompact
ELSE	; REALLOC_FIXED
	xor	dx,dx		    ; No, get size of largest free block
	call	gcompact	    ; AX = size of largest free block
ENDIF	; REALLOC_FIXED
	pop	es
	pop	si
	pop	ax
	xor	al,al		    ;* last chance
;*	* block can not be moved, but gcompact may have freed sufficient
;*	* space.
	pop	dx
	pop	bx		    ;* restore everything to look like ragrow
	jmp	ragrowagain

rafailmem:
	mov	bx,h
	test	bl,GA_FIXED
	jnz	rafail2
	mov	bx,[bx].he_address
rafail2:			    ; BX = client data address
	dec	bx
	mov	es,bx		    ; ES = arena header address
	mov	ax,es:[di].ga_size  ; AX = size of current block
	mov	es,es:[di].ga_next  ; Check following block
	cmp	es:[di].ga_owner,di ; Is it free?
	jne	rafailmem0	    ; No, continue
	add	ax,es:[di].ga_size  ; Yes, then include it as well
	inc	ax
rafailmem0:
	cmp	ax,dx		    ; Chose the larger of the two
	jbe	rafailmem1
	mov	dx,ax
rafailmem1:
	xor	ax,ax
	jmp	rax

ramove2:
	pop	ax
	pop	ax		    ;* ignore 2 saved values from ragrow1
	mov	ax,dx		    ; AX = allocation flags
	mov	bx,si		    ; BX = size of new block
	mov	cx,si		    ; CX = owner (use size for now)
	call	gsearch 	    ; Find block big enough
	jz	racantmove	    ; Cant find one, grow in place now?
	mov	si,h
	mov	cx,ax
	test	si,GA_FIXED
	jnz	ramove3
	mov	cx,si
	mov	si,[si].he_address  ; SI = old client data address
ramove3:
	dec	ax
	mov	es,ax		    ; ES = destination arena
	dec	si		    ; SI = source arena
	call	gmovebusy	    ; Call common code to move busy block
	mov	ax,cx		    ; Return new handle
raexit:
	mov	cx,ax
	mov	sp,bp
	pop	bp
	ret


racantmove:
	mov	bx,h
	test	bl,GA_FIXED
	jnz	racmove1
	mov	bx,[bx].he_address
racmove1:			    ; BX = client data address
	mov	ax,bx
	dec	bx
	mov	es,bx		    ; ES = arena header address

	mov	bx,rsize
	add	bx,ax		    ; Compute address of new next header
	call	galign		    ; assuming there is room.

	mov	bx,ES:[di].ga_next  ; Get address of current next header
	mov	es,bx		    ; ES = next block address
	cmp	ES:[di].ga_owner,di ; Is next block free?
	jne	racmove3	    ; No, try to move the current block
	sub	dx,bx		    ; Yes, compute how much of it we need
	call	gcheckfree	    ; See if free block is big enough
	jb	racmove3	    ; No, try to move the current block
	add	dx,bx		    ; Yes, restore new next block address
	mov	cx,es		    ; Yes, save free block address in CX
	call	gjoin		    ; and attach to end of current block
	test	byte ptr rflags,GA_ZEROINIT ; Zero fill extension?
	jz	racmove2	    ; No, continue
	mov	bx,cx		    ; Yes, BX = first paragraph to fill
	mov	cx,dx		    ; compute last paragraph to fill
	dec	cx		    ; into CX
	call	gzero		    ; zero fill extension
racmove2:
	mov	bx,ES:[di].ga_next  ; Pick up new next block address
	jmp	rashrink	    ; Now shrink block to correct size

racmove3:
	xor	dx,dx		    ; No, get size of largest free block
	call	gcompact
	mov	dx,ax		    ; DX = size of largest free block
	jmp	rafailmem


; GFREE - procedure to free a global object
;
;   Inputs:	DX = global memory object handle
;		CX = owner field value to match or zero if dont care
;		DS:DI = address of global heap info
;
;   Outputs:	AX = zero it successful or handle if not
;		CX = AX
;

gfree:
	push	cx
	call	gdref
	pop	dx
	jz	gf2		    ; Free handle if object discarded
	or	dx,dx
	jnz	gf3
gf1:
	call	gmarkfree	    ; No, free the object
gf2:
	call	hfree		    ; Free handle
gfx:
	mov	cx,ax
	ret
gf3:
	cmp	ES:[di].ga_owner,dx
	je	gf1
	mov	ax,-1
	jmp	short gfx


; GLOCK - procedure to increment the lock count of an object
;
;   Inputs:	BX = handle to global object
;		CX = handle table flags and lock count for moveable objects
;		DX = segment address of object
;		DS:DI = address of master object
;
;   Outputs:	Updated lock count in handle table entry and CX
;		Z flag set if count overflowed.
;

glock:
	inc	ch		    ; Increment lock count
	jz	gl2		    ; All done if overflow
	mov	[bx].he_count,ch    ; Update lock count
gl2:
	ret


; GUNLOCK - procedure to deccrement the lock count of an object
;
;   Inputs:	BX = handle to global object
;		CX = handle table flags and lock count for moveable objects
;		DX = segment address of object
;		DS:DI = address of master object
;
;   Outputs:	CX = 0 if handle already unlocked. non-zero o.w.
;		Updated lock count in handle table entry and CX
;		Z flag set if count underflowed.
;

gunlock:
	dec	ch		    ; Decrement usage count
	cmp	ch,0FFh-1	    ; ff -> fe, 0 -> ff
	jae	gul1		    ; Return if pinned, or was already zero
	dec	[bx].he_count	    ; Non-zero update lock count
	jnz	gul2		    ; All done if still non-zero
	test	cl,GA_DISCARDABLE   ; Is this a discardable handle?
	jz	gul1		    ; No, all done
gul1:
	xor	cx,cx
gul2:
	ret			    ; Non-zero lock count. Return true


SUBRS	ENDP

sEnd	KERNEL

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\cwos2.asm ===
;*
;*	CW : Character Windows
;*
;*	cwos2.asm : jump table data for OS/2 (copied to inosDrv)

	include kernel.inc
	include indrv.inc

;*****************************************************************************

IFNDEF DUAL ;!DUAL
	Assert					;* DUAL only
ENDIF ;!DUAL

;*****************************************************************************


externFP	<CWBeginIO,CWEndIO>


;*****************************************************************************

createSeg   CWOS2,CWOS2,BYTE,PUBLIC,CODE

sBegin	CWOS2
	assumes CS,CWOS2
	assumes DS,CWOS2

	PUBLIC	inosDrvOS2
inosDrv: ;* this label is not exported but referenced by _inos.asm
inosDrvOS2:
	include	_inos.asm

sEnd	CWOS2


;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\uutil.h ===
/*
	COW : Character Oriented Windows

	uutil.h : Definitions for User Windows
		Cmerge definitions from util.asm + sdmasm.asm
*/

#include <insyd.h>				/* installable driver */

/***BEGIN_PUBLIC***/

extern BYTE PASCAL	fSingleFloppy;	/* TRUE => 1 floppy system */
extern BYTE PASCAL	fInt24Error;	/* Set if INT 24 error detected */

/* Sound Facilities */
#define	Beep()		DoSound(0)
#define	Click()		DoSound(1)

BOOL		FARPUBLIC FValidDrive(char);
/***END_PUBLIC***/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\uisa.h ===
/*
	COW : Character Oriented Windows

	uisa.h : Master table of isa's
*/

/***BEGIN_PUBLIC***/
#ifndef NOCOLOR

/*	* General colors */
#define	isaBackground		0

#define	isaHilite		1		/* hilite / inversion */
#define	isaGreyed		2		/* not currently used */
#define	isaEnabled		3
#define	isaDisabled		4
#define	isaAlert		5

/*	* Dialog elements :	*/
#define	isaDialogBox		6	/* the actual dialog box */
#define isaStatic		isaDialogBox	/* static text */
#define isaButton		isaDialogBox	/* radio/check buttons */
#define isaPushButton		7		/* push buttons */
#define isaButtonDown		8		/* pushed button */
#define isaListBox		9		/* listbox background */
#define isaEdit			isaDialogBox

/*	* Scroll Bars :		*/
#define isaScrollbar		10
#define isaElevator		11

/*	* Menus :		*/
#define isaMenuBox		12		/* box around pull downs */
#define	isaMenu			13		/* non-selected MENU */
#define isaMenuSelected		14		/* selected menu item */
#define	isaMenuHilite		15		/* hilited character */
/* hilited character under selection */
#define	isaMenuHiliteSel	16		/* for menu titles */
#define	isaItemHiliteSel	17		/* for menu items */

#define	isaDialogAccel		18		/* dialog accelerators */

/*	* Shadows :		*/
#define	isaShadow		19

/* User Colors :		*/
#define	isaUserMin		20
#define	isaUserMax		(isaUserMin+16)
#define isaMax			isaUserMax

#endif /*!NOCOLOR*/
/***END_PUBLIC***/


#ifdef COW


/*	* Message boxes :	*/
#define	isaMessageBox		isaAlert

/*	* Buttons :		*/
#define isaButtonDisabled	isaDisabled

/*	* Edit Items :		*/
#define isaHiliteEdit		isaHilite

/*	* Listboxes :		*/
#define isaListBoxSelection 	isaHilite

/*	* Menus :		*/
#define isaEnabledMenuItem	isaEnabled	/* enabled item */
#define isaDisabledMenuItem	isaDisabled	/* disabled item */
#define isaSelectedMenuItem	isaHilite	/* selected item */


#endif /*COW*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\private.c ===
/*
	CW : Character Windows

	private.c : Includes headers for making .inc files
	NOTE: does not include all headers, just those needed for assembler
*/

#include "cow.h"		/* NOTE: cow.inc not generated !! */
#include "uevent.h"
#include "uisa.h"
#include "uscroll.h"
#include "uscreen.h"
#include "vkey.h"
#include "uedit.h"
#include "indrv.h"
#include "inscr.h"
#include "inkbd.h"
#include "insyd.h"
#include "inmou.h"
#include "kmem.h"

/* Graphics */
#include "ingxd.h"
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\insyd.h ===
/*
	CW: Character Windows
	
	insyd.h: SYD (System Feature) Driver specifics
*/

/*****************************************************************************/
/***BEGIN_PUBLIC***/

/* System Specifics */
VOID		FARPUBLIC DoSound(WORD);
DWORD		FARPUBLIC ClockTicks(void);

/***END_PUBLIC***/

/*****************************************************************************/
/* indtSystem : loaded representation */

/*
  -- the INYJ structure contains far pointers to routines in an installable
	driver
*/

/* Prototypes for functions */
typedef	VOID	(FAR PASCAL *LPFN_SY_SOUND)(WORD);
typedef	DWORD	(FAR PASCAL *LPFN_SY_TIME)(VOID);


typedef	struct _inyj
	{
	LPFN_SY_SOUND	lpfnDoSoundSyd;
	LPFN_SY_TIME	lpfnLGetTimeSyd;
	} INYJ; /* Installable sYstem Jump table */

#define	cpfnSydMin	2

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\int24.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	int24.asm : DOS Hard error control

	title	int24.asm : DOS Hard error control

	include kernel.inc
	include	vkey.inc

IFDEF DEBPUB
ifndef INT24_ALTERNATE
	PUBLIC	HandlerInt24
endif
ENDIF ;DEBPUB

;----------------------------------------------------------------------------

sBegin	BSS

    assumes DS,DGROUP

globalB	fSingleFloppy,0		; If one floppy, set to True
globalB	drivePhantom,0		;                set to 2 (drive code for B)
globalW	chDrivePhantom,0	;                set to "b:" 

globalB fInt24Error,0

globalB	fGrabInt05,0		; Re-route if requested.

labelD	pfnHdlrInt05		; old vector
globalW	OFF_pfnHdlrInt05,0
globalW	SEG_pfnHdlrInt05,0

staticB	bCtrlBrkOld,0		; control break state

ifndef INT24_ALTERNATE
labelD	pfnHdlrInt24		; old vector
staticW	OFF_pfnHdlrInt24,0
staticW	SEG_pfnHdlrInt24,0
endif

sEnd	BSS

;----------------------------------------------------------------------------

;externFP	DoSound
externFP	KeyboardMessage

;----------------------------------------------------------------------------

sBegin	INIT

;----------------------------------------------------------------------------
;
;  Hook int24 vector, figure out system specs
;
;	entry : n/a
;	exit : n/a

    assumes CS,INIT
    assumes DS,DGROUP
    assumes SS,DGROUP
    assumes ES,NOTHING

cProc	InitInt24Etc,<FAR,PUBLIC,ATOMIC>
cBegin	InitInt24Etc

ifndef	INT24_ALTERNATE

	mov	ax,3524h			; Get Interrupt Vector 24h
	int	21H
	mov	OFF_pfnHdlrInt24,bx
	mov	SEG_pfnHdlrInt24,es

	push	ds
	mov	ax,SEG kernelBase		;* both in KERNEL segment
	mov	ds,ax
    assumes ds,NOTHING
	mov	dx,kernelOffset HandlerInt24
	mov	ax,2524h			; Set Interrupt Vector 24h
	int	21H
	pop	ds
    assumes ds,DATA

endif	; !INT24_ALTERNATE

;---------------------------------------
;
; Figure out interrupt 05 (^PrtSc) stuff.

	mov	ax,3505h			; Get Interrupt Vector 05h
	int	21h
	mov	SEG_pfnHdlrInt05,es
	mov	OFF_pfnHdlrInt05,bx

	cmp	fGrabInt05,0			; Only reroute if requested.
	je	@F

	push	ds
	mov	ax,SEG kernelBase
	mov	ds,ax
    assumes ds,NOTHING
	mov	dx,kernelOffset HandlerInt05Key
	mov	ax,2505h			; Set Interrupt Vector 05h
	int	21h
	pop	ds
    assumes ds,DATA

@@:

;---------------------------------------
;
; Figure out floppy info.

	mov	fSingleFloppy,0
	mov	drivePhantom,-1		; Guess that neither A nor B are
	mov	chDrivePhantom,-1	;   phantom drives.

	int	11h			; Get BIOS equipment list
	test	al,11000000B
	jnz	lots_o_floppy

	dec	fSingleFloppy

; On a single floppy system, the byte at 0040:0104 is 00 if the floppy is
; currently acting as A:, and 01 if the floppy is currently acting as B:.
;
; This is using a totally undocumented DOS data location; it's the sleaziest
; CW operation that I know of.  For safety's sake (ha!), we check the 
; obscure case of 1, and assume B: is the phantom for !1.
;
; If this breaks in a future version of DOS, I would suggest adding a DOS
; check, and not just punting this stuff altogether.

	xor	ax,ax
	mov	es,ax
    assumes es,NOTHING

	mov	bl,1			; Guess it's currently acting as B:,
	mov	ax,":a"			;   so that A: is the phantom drive.
	cmp	es:[0504h],bl
	jz	@F
	inc	ax			; Guessed wrong: B: is the phantom
	inc	bx			;   drive.
@@:
	mov	chDrivePhantom,ax	; "a:" if A is phantom, "b:" if B is.
	mov	drivePhantom,bl		;   1  if A is phantom,   2  if B is.

; We should do something to reselect to avoid phantom drives (???)

lots_o_floppy:

;---------------------------------------
;
; Get state of control-break, save it and turn off

	mov	ax,3300h			;* request current state
	int	21h
	mov	bCtrlBrkOld,dl			;* save old state
	xor	dl,dl				;* state off !!!
	mov	ax,3301h			;* set state
	int	21h

cEnd	InitInt24Etc


sEnd	INIT

;----------------------------------------------------------------------------

sBegin	EXIT

    assumes CS,EXIT
    assumes SS,DATA
    assumes DS,DATA
    assumes ES,NOTHING


;********** EndInt24 **********
;*	entry : n/a
;*	* Unhook the timer interrupt
;*	exit : n/a

cProc	EndInt24,<NEAR,PUBLIC,ATOMIC>
cBegin	EndInt24

ifndef	INT24_ALTERNATE

	push	ds
	lds	dx,pfnHdlrInt24
    assumes ds,NOTHING
	mov	ax,2524H			; Set Interrupt Vector 24h
	int	21H
	pop	ds
    assumes ds,DATA

endif	; !INT24_ALTERNATE

	push	ds
	lds	dx,pfnHdlrInt05
    assumes ds,NOTHING
	mov	ax,2505H			; Set Interrupt Vector 05h
	int	21H
	pop	ds
    assumes ds,DATA

	mov	dl,bCtrlBrkOld			; restore old ctrl-break 
	mov	ax,3301h			;   state
	int	21h

cEnd	EndInt24

sEnd	EXIT

;----------------------------------------------------------------------------

sBegin	KERNEL

    assumes CS,KERNEL
    assumes SS,NOTHING
    assumes DS,NOTHING	; interrupt handler may be called from anywhere
    assumes ES,NOTHING

ifndef	INT24_ALTERNATE

;---------------------------------------
;
; Interrupt 24 (DOS Hard Error) handler
;

cProc	HandlerInt24,<FAR,ATOMIC>
cBegin	nogen	; HandlerInt24

    assumes DS,NOTHING
	push	ds
	mov	ax,SEG dataBase
	mov	ds,ax
    assumes ds,DATA
	mov	al,3			;* return error
	mov	fInt24Error,al
	pop	ds
    assumes DS,NOTHING
	iret

cEnd	nogen	; HandlerInt24
endif

;---------------------------------------
;
; Interrupt 05 (^PrtSc) handler to generate a keystroke (for CBT)
;

cProc	HandlerInt05Key,<FAR,ATOMIC>
cBegin	nogen	; HandlerInt05Key

    assumes DS,NOTHING

	mov	ax,VK_PRINT
	xor	cx,cx
	cCall	KeyboardMessage,<ax,ax,cx,cx>

	iret

cEnd	nogen	; HandlerInt05Key

;---------------------------------------
;
; Interrupt 05 (^PrtSc) handler to disable the functionality
;

cProc	HandlerInt05Dead,<FAR,PUBLIC,ATOMIC>
cBegin	nogen	; HandlerInt05Dead

    assumes DS,NOTHING

	xor	ax,ax
;	cCall	DoSound,<ax>
	iret

cEnd	nogen	; HandlerInt05Dead

sEnd	KERNEL

;----------------------------------------------------------------------------

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\cover.asm ===
;*	* CW : Cover.asm : Code Coverage kludge module

_data	segment byte public 'data'			 
dgroup	GROUP _data					 
assume	cs:dgroup					 
assume	ds:dgroup					 

	public	crefCow
crefCow	DW	0

_data	ends


core	segment byte public 'code'
assume	cs:core

	public	GetCodeHandle
GetCodeHandle:
	public	GetCodeInfo
GetCodeInfo:
	int	3

core	ends

;********************************

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\kanji.inc ===
;*
;*	CW : Character Oriented Windows
;*
;*	kanji.inc : Kanji / DBCS support

;*	* first range: 81->9F
chDbcMin1	=	081H
chDbcMac1	=	09FH+1
;*	* second range: E0->FC
chDbcMin2	=	0E0H
chDbcMac2	=	0FCH+1


;********** JmpNotDbc **********
;*	entry: al = first character
;*	* jump to label if not first byte of D.B. character
;*	* Trashes nothing except flags

JmpNotDbc MACRO label
	LOCAL	is_dbc
	cmp	al,chDbcMin1
	jb	label
	cmp	al,chDbcMac1
	jb	is_dbc
	cmp	al,chDbcMin2
	jb	label
	cmp	al,chDbcMac2
	jae	label
is_dbc:
ENDM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\glock.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	glock.asm : Global memory allocator - Locking procedures

	.xlist
	include	kernel.inc
	include	galloc.inc
	.list


sBegin	KERNEL
    assumes CS,KERNEL
    assumes DS,NOTHING			;* DS usually points to MOB
    assumes SS,DATA			;* get variables from here


;*	* low level subroutines
externNP    <glock,gunlock>		; GMEM.ASM
externNP    <xhandle>			; GWINTERF.ASM


; The remainder of this file implements the exported interface to the
; global memory manager.
;   HANDLE	far PASCAL LockSegment( WORD );
;   HANDLE	far PASCAL UnlockSegment( WORD );
;   char far *	far PASCAL GlobalLock( HANDLE );
;   BOOL	far PASCAL GlobalUnlock( HANDLE );

cPublic	LockSegment
;   parmW   seg
cBegin	nogen
	call	xhandle 	    ; Get handle
	jz	xhandlex	    ; Ignore invalid or discarded objects
	call	glock
	jmp	short xhandlex
cEnd	nogen ;LockSegment


cPublic	UnlockSegment
;   parmW   seg
cBegin	nogen
	call	xhandle 	    ; Get handle
	jz	xhandlex	    ; Ignore invalid or discarded objects
	call	gunlock
	jmp	short xhandlex
cEnd	nogen ;UnlockSegment


cPublic	GlobalLock
;   parmW   h
cBegin	nogen
lock0:
	call	xhandle 	    ; Call ghandle with handle in DX
	jz	lock1		    ; Ignore invalid or discarded objects
IFDEF DEBUG
	cmp	ch,0FFh 	    ; Debugging check for count overflow
	jne	lock_ok
	cCall	CowAssertFailed
	DB	"GlobalLock: Object usage count overflow$"
lock_ok:
ENDIF ;DEBUG
	call	glock		    ; Increment lock count
lock1:
	xor	ax,ax
	mov	cx,dx
xhandlex:
        dec     ds:[di].gi_lrulock
        pop     di
        pop     ds
        ret     2

cEnd	nogen ;GlobalLock


cPublic	GlobalUnlock
;   parmW   h
cBegin	nogen
	call	xhandle 	    ; Call ghandle with handle in DX
	jz	xhandlex	    ; Ignore invalid or discarded objects
IFDEF DEBUG
	cmp	ch,00h		    ; Debugging check for count underflow
	jne	unlock_ok
	cCall	CowAssertFailed
	DB	"Global Unlock underflow$"
unlock_ok:
ENDIF ;DEBUG
	call	gunlock
	mov	ax,cx
	jmp	xhandlex

cEnd	nogen ;GlobalUnlock


sEnd	KERNEL

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\cbfree.asm ===
;
;	COW : Character Oriented Windows
;
;	cbfree.asm : return current size of available pool or sb's.

	include	kernel.inc
	include galloc.inc

;----------------------------------------------------------------------------

sBegin	DATA

externW     <pGlobalHeap>

sEnd	DATA

;----------------------------------------------------------------------------

sBegin	KERNEL

    assumes CS,KERNEL
    assumes DS,DGROUP
    assumes ES,NOTHING
    assumes SS,DGROUP

cProc	CbFreeMem, <FAR, PUBLIC, ATOMIC>, <ds,di>
cBegin	CbFreeMem

	xor	ax,ax				; Starting size = 0000.
	mov	ds,pGlobalHeap
	xor	di,di
	mov	dx,ds:[di].hi_last		; Calculate location of
	sub	dx,ds:[di].gi_reserve		;   the fence.

	mov	ds,ds:[di].hi_first		; get to first in the list.

DoNext:
	mov	cx,ds:[di].ga_next		; Does the next block spill
	cmp	cx,dx				;   over the fence?
	jae	HitFence			; Bail if it does.

	mov	bx,ds:[di].ga_owner		; If he's Free or Code
	or	bh,bh				;   then add
	jnz	@F				;   on his size.
	add	ax,ds:[di].ga_size
@@:	mov	ds,cx				; Go on to the Next block.
	jmp	short DoNext
	
HitFence:
	mov	bx,ds:[di].ga_owner		; If the last is Free/Code
	or	bh,bh				;   then add on from start of
	jnz	@F				;   block to start of fence

	add	ax,dx				; size := size +
	mov	bx,ds				;   (
	sub	ax,bx

	mov	bx,ds				; size : = size +
	sub	dx,bx				;    (fence - start of block)
	add	ax,dx

@@:

cEnd	CbFreeMem

sEnd	KERNEL
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\usdmtmpl.h ===
/*
	COW : Character Oriented Windows

	usdmtmpl.h : Template include for SDM

	Normally only compiled with the CS compiler

	* * * * WARNING * * * *
	!! application code should not depend on the contents of this file !!
*/

/***BEGIN_PUBLIC***/

/* -- defined Dialog Item */
typedef struct _sdmtm
	{
	BITS	tmtBase:6;	/* item type */
	BITS	tmsBase:4;	/* sub-type */
	BIT	f1:1;		/* general purpose # 1 */
	BIT	f2:1;		/* general purpose # 2 */
	BIT	f3:1;		/* general purpose # 3 */
	BIT	fDisable:1;	/* if originally disabled */
	BIT	fProc:1;	/* if call dialog proc */
	BIT	fDismiss:1; 	/* if dismiss dialog */

#ifdef CC
	WORD	bpString;	/* based pointer or wParam */
#else
#ifdef SDM_ST
	char	st[];		/* based pointer or wParam */
#else
	char	sz[];		/* based pointer or wParam */
#endif
#endif /*!CC*/

	LONG	l;		/* compact rectangle or PFN */
#ifdef SDM_LONG_COORD
	LONG	l2;
#endif
	} SDMTM;


#ifdef SDM_COW
/* Compact Rectangle */
typedef struct _crc
	{
	BYTE	x, y, dx, dy;		/* order critical */
	} CRC;		/* Compact Rectangle */
#endif

/* Dialog Proc Type */
typedef BOOL	(FARPUBLIC *PFFN_DLG)(WORD, TMC, WORD, WORD, WORD);


/* dialog header */
typedef struct _dlg
	{
#ifdef SDM_COW
	CRC	crcDlg;			/* Compact Rectangle */
#else
	WRC wrcDlg;
	long lStyle;			/* dialog style */
#endif /*!SDM_COW*/

/* title string : based pointer */
#ifdef CC
	WORD bpTitle;			/* based pointer to title */
#else
#ifdef SDM_ST
	char stTitle[];
#else
	char szTitle[];		/* dialog title */
#endif
#endif /*!CC*/

	WORD	hid;			/* dialog help id */

	PFFN_DLG pfnDlg; 		/* dialog function */
	TMC	tmcSelInit;		/* initial selection */
#ifndef CC
	SDMTM	rgtm[];			/* variable length for CS */
#else
#ifdef SDM_ENGINE
	SDMTM	rgtm[1];		/* array starts here */
#endif
#endif /*CC*/
	} DLG;	/* Dialog Template */

/*****************************************************************************/

/* instances of tmtBase  (basic tm types) */
#define	tmtNull			0
#define	tmtEnd			0
#define	tmtStaticText		1
#define	tmtFormattedText	2
#define	tmtTrackingText		3
#define	tmtGroupBox		4

#define	tmtPushButton		5
#define	tmtCheckBox		6
#define	tmtRadioButton		7
#define	tmtToggleBox		8
#define	tmtToggleButton		9
#define	tmtEdit			10
#define	tmtListBox		11
#define	tmtStandardButton	12

#define	tmtDummyText		13		/* dummy static text */
#define	tmtGeneralPicture	14		/* with Render Proc */

#define	tmtNormalMax		15

#define	tmtUserMin		16
/* App / future  extensions (32 types) */
#define	tmtUserMax		48

#define	tmtSpecialMin		48
/* Special Records */
#define	tmtConditional		48

/* Extension Records (still Special) */
#define	tmtExtensionMin		61

#define	tmtExtension1		61
#define	tmtExtension2		62
#define	tmtExtension3		63

#define	tmtSpecialMax		64

#define	tmtMax			64		/* 6 bits */


/***END_PUBLIC***/

/******************************************************************/
/* Information that is tightly bound to the contents of this file */
/******************************************************************/

#ifdef COW

/* The standard TM has many parallel structures which are tightly
	bound to the SDMTM structure !!! */


/* macro to decide if tmt is real or an extension */
#define	FNormalTmt(tmt)		((tmt) < tmtNormalMax)
#define	FExtensionTmt(tmt)	((tmt) >= tmtExtensionMin)
#define	FSpecialTmt(tmt)	((tmt) >= tmtSpecialMin)

/***** ***** ***** NORMAL TMs ***** ***** *****/

#define	bpStringFromCab		((WORD) 1)

/***** special use of general flags *****/
/* when fDismiss is set */
#define	fCabDismiss		f1		/* if Dismiss with CAB */

/* for RadioButtons / ToggleButtons */
#define	fFirstButton		f1		/* if first radio button */

/* for Listboxes */
#define	fComboListBox		f1		/* if Combo */
#define	fDirListBox		f2		/* if Directory */
#define	fSortedListBox		f3		/* if sorted */

/* for PushButtons */
#define fDefaultPushButton	f2		/* if default */

/* for StandardButtons */
#define	fStandardCancel		f3		/* if Cancel else Ok */

/* for Edit Items (Secret Edit Text right now) */
#define	fCharValidated		f1

/* for Static Text, Edit Item (not ipl) */
#define	fNotLeftJustify		f2		/* CENTER or RIGHT */
#define	fNotRightJustify	f3		/* CENTER */

/***** ***** ***** CONDITIONAL TMs ***** ***** *****/

#define	PtmoOfTm(ptm)		((TMO *) (ptm))
#define	FUseSubDialog(ptm, sab)	((sab) & (1 << PtmoOfTm(ptm)->jSab))

typedef struct _tmo
	{
	BITS	tmtBase:6;	/* tmtConditional */
	BITS	jSab:4;		/* bit index to SAB */
	BITS	filler:6;

	WORD	ctmNormal;	/* # of normal TMs to skip */
	WORD	ddxDialog;	/* extra width */
	WORD	ddyDialog;	/* extra height */
	} TMO; /* cOnditional TM */


/***** ***** ***** EXTENSION 1 ***** ***** *****/
/* if extension 1 exists it MUST come right after a normal TM */

#define Ptm1OfTm(ptm)		((TM1 *) (ptm))
#define Ptm1OfTif(ptif)		Ptm1OfTm((ptif)->ptm+1)
/* is there an extension 1 record ?? */
#define	FExtension1(ptif)	(Ptm1OfTif(ptif)->tmtBase == tmtExtension1)
/* assert that item has proc (listbox proc, parse proc, ...) */
#define	AssertExtension1(ptif)	Assert(FExtension1(ptif))

/* Control Procedure */
typedef WORD	(FARPUBLIC *PWFN_CTL)(WORD, char *, WORD, TMC, WORD, WORD);

typedef struct _tm1
	{
	BITS	tmtBase:6;	/* tmtExtension1 */
	BITS	reserved:4;	/* will be item size */
	BITS	filler:6;

	WORD	tmcImport;	/* imported TMC or tmcNull */
	PWFN_CTL pfnCtl;		/* Control Proc */
	} TM1;	/* TM extension #1 */


#endif /*COW*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\uevent.h ===
/*
	COW : Character Oriented Windows

	uevent.h : Definitions for User Windows
*/

/***BEGIN_PUBLIC***/

#ifndef NOMSG
/* Message structure */
typedef struct _msg
	{
	PWND	pwnd;
	WORD	message;
	WORD	wParam;
	DWORD	lParam;
	DWORD	time;
	} MSG;
typedef MSG *PMSG;
#ifndef DOS5
extern BOOL PASCAL fMessage;
#ifdef DUAL
extern DWORD PASCAL semaMessage;	/* message semaphore */
#define	hsemaMessage	((DWORD) (DWORD FAR *) &semaMessage)
#endif /*DUAL*/
#else
extern DWORD PASCAL semaMessage;	/* message semaphore */
#define	hsemaMessage	((DWORD) (DWORD FAR *) &semaMessage)
#endif
#endif /*!NOMSG*/


#ifndef NOWINMESSAGES
/* Window Messages */
#define	WM_NULL			0x0000
#define	WM_CREATE		0x0001
#define	WM_WANTFOCUS		0x0005
#define	WM_MAKEACTIVE		0x0006
#define	WM_SETFOCUS		0x0007
#define	WM_KILLFOCUS		0x0008
#define	WM_PAINT		0x000f
#define	WM_QUIT			0x0012

#define	WM_KEYFIRST		0x0100
#define WM_KEYLAST		0x0102

#define	WM_KEYDOWN		0x0100
#define	WM_KEYUP		0x0101
#define	WM_CHAR			0x0102

#define	WM_CUT			0x0103
#define	WM_PASTE		0x0104
#define	WM_COPY			0x0105
#define	WM_INSERT		0x0106

#define	WM_MENUIDLE		0x0110		/* Menu Idle */
#define	WM_COMMAND		0x0111
#define	WM_MENUSELECT		0x0112		/* selecting a menu item */
#define	WM_MENUSTART		0x0113		/* starting a menu action */
#define	WM_HSCROLL		0x0114
#define	WM_VSCROLL		0x0115
#define	WM_INITMENUPOPUP	0x0116
#define	WM_ALARM		0x0117

#define	WM_MOUSEFIRST		0x0200
#define	WM_LMOUSELAST		0x0203	/* last of Left mouse actions */
#define	WM_MOUSELAST		0x0206

#define	WM_MOUSEMOVE		0x0200	/* mouse related constants */
#define	WM_LBUTTONDOWN		0x0201
#define	WM_LBUTTONUP		0x0202
#define	WM_LBUTTONDBLCLK	0x0203
#define	WM_RBUTTONDOWN		0x0204
#define	WM_RBUTTONUP		0x0205
#define	WM_RBUTTONDBLCLK	0x0206

/* Edit Wnd Proc Messages */
#define EM_SETSEL		0x0300
#define EM_GETSEL		0x0301

/* Overlap Wnd Proc Messages */
#define WM_ACTIVATE	0x0320
#define WM_ZOOM		0x0321
#define WM_CLOSE	0x0322
#define WM_MOVE		0x0323
#define WM_SIZE		0x0324


/*WM-DIALOG is actually private (and LB_SETWIDTH)*/
#define WM_DIALOG		0x0380
/* Listbox Proc Messages */
#define WM_LISTBOX_COMMAND	WM_DIALOG
#define LB_RESETCONTENT		0x0340
#define LB_ADDSTRING		0x0341
#define LB_DELETESTRING		0x0342
#define LB_SETCURSEL		0x0343
#define LB_GETCURSEL		0x0344
#ifdef LISTBOX_HORIZ
#define LB_SETWIDTH		0x0345
#endif /*LISTBOX_HORIZ*/
#define LB_GETTEXT		0x0346
#define LB_GETCOUNT		0x0347
#define LB_REPLACESTRING	0x0348
#define LB_INSERTSTRING		0x0349

/* private window messages start here */
#define	WM_USER			0x0400
#endif

/* Window's aliases for KK_ states */
#define	KK_MENU			KK_ALT
#define	KK_CAPITAL		KK_CAPLOCK

/* HELP */
#define	VK_HELP_KEY		VK_F1

/* listbox notification codes */
#define LBN_SELCHANGE		0
#define LBN_DBLCLK		1
#define LBN_SELECT_DONE		2


/* List Box Selection Codes */
#define lbrCause		0xf
#define lbrNone			0
#define lbrMouse		1
#define lbrScroll		2
#define lbrKeys			3
#define lbrSpace		4
#define lbrOther		5
#define flbrReselect		0x10


/* help types/contexts */
#define	hemMenu			1
#define	hemMenuItem		2
#define	hemMbox			3
#define	hemDialog		4
#define	hemUserMin		0x10		/* For Application contexts */

/* help id's for message boxes */
#ifndef NOMB
#define	hidMboxOk		MB_OK
#define	hidMboxYesNoCancel	MB_YESNOCANCEL
#define	hidMboxRetryCancel	MB_RETRYCANCEL
#define	hidMboxOkCancel		MB_OKCANCEL
#define	hidMboxAbort		MB_ABORT
#define hidMboxYesNo		MB_YESNO
#define hidMboxRetry		MB_RETRY
#endif /*!NOMB*/

VOID		FARPUBLIC SetAlarm(PWND, WORD);
VOID		FARPUBLIC KillAlarm(void);
VOID		FARPUBLIC UngetMessage(PMSG);
BOOL		FARPUBLIC PeekMessage(PMSG);
PWND		FARPUBLIC GetFocus(void);
PWND		FARPUBLIC SetFocus(PWND);
VOID		FARPUBLIC FlushAbort(void);
PWND		FARPUBLIC SetCapture(PWND);
VOID 		FARPUBLIC ReleaseCapture(void);
DWORD		FARPUBLIC DispatchMessage(PMSG);
BOOL		FARPUBLIC PostMessage(PWND, WORD, WORD, DWORD);
DWORD		FARPUBLIC SendMessage(PWND, WORD, WORD, DWORD);
WORD		FARPUBLIC SetDoubleClickTime(WORD);		/*OPTIONAL*/
VOID		FARPUBLIC SynthesizeShiftKeys(WORD, WORD);	/*OPTIONAL*/

/***END_PUBLIC***/

#ifdef COW

/* window if alarm set (used by timer) */
extern PWND pwndAlarm;

#ifdef KANJI
VOID		FAR PASCAL KeyboardMessage(BYTE, BYTE, WORD, WORD, BOOL);
#else
VOID		FAR PASCAL KeyboardMessage(BYTE, WORD, WORD, BOOL);
#endif
VOID		FAR PASCAL SpecialTsrAbort(void);
BOOL		FAR PASCAL FTestKeyboardEmpty(void);
VOID		FAR PASCAL FlushKeyEvents(VOID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\cow.h ===
/*
	CW : Character Windows

	cow.h : System Wide definitions
*/

/***BEGIN_PUBLIC***/

#ifdef NOALL
#define NOMINMAX
#define NOWND
#define NOWINSTYLES
#define NOCOLOR
#define NORECT
#define NOMSG
#define NOWINMESSAGES
#define NOKEYSTATE
#define NOMENUS
#define NOMEMMGR
#define NODRAW
#define NOSCROLL
#define NOSUBSTYLES
#define NOVIRTUALKEYCODES
#define NOMB
#define NOWNDMACROS
#endif /*NOALL*/


#ifndef CC
/* -- Pcode Specific Definitions -- */
#ifndef EXPORT
#define	EXPORT	export
#endif
#ifndef NATIVE
#define	NATIVE	native
#endif
#else
/* -- Cmerge Compiler -- */
#ifndef CDECL
#define CDECL cdecl
#endif
#endif /*CC*/


#ifndef PASCAL
#define	PASCAL pascal
#endif

#define	FALSE	0
#define	TRUE	1
#define	NULL	0

#define	FAR	far
#define	LONG	long
#define	VOID	void
#ifdef CC
#define	NEAR	near
#else
#define NEAR
#endif

#define FARPUBLIC	FAR PASCAL		/* all interfaces FAR */

typedef unsigned char	BYTE;
typedef unsigned short	WORD;
typedef unsigned long	DWORD;
typedef int		BOOL;
typedef int	(FARPUBLIC *PFN)();		/* General Procedure */
typedef BOOL	(FARPUBLIC *PFFN)();		/* BOOL Procedure */
typedef VOID	(FARPUBLIC *PVFN)();		/* Void Procedure */
typedef WORD	(FARPUBLIC *PWFN)();		/* Word Procedure */
typedef DWORD	(FARPUBLIC *PLFN)();		/* DWORD Procedure */
typedef VOID	(FARPUBLIC *LPFN)();		/* explicit FAR procedure */
typedef WORD		HANDLE;
typedef unsigned	BIT;
typedef unsigned	BITS;

/* special type for WndProc pointers */
typedef DWORD	(FARPUBLIC *PLFN_WNDPROC)(struct _wnd *, WORD, WORD, DWORD);

/* BYTE/WORD types */
#ifndef CC	/* Pcode => WORD */
typedef WORD		AX;
typedef WORD		AY;
typedef WORD		RX;
typedef WORD		RY;
typedef WORD		ISA;
#else
typedef BYTE		AX;
typedef BYTE		AY;
typedef BYTE		RX;
typedef BYTE		RY;
typedef BYTE		ISA;
#endif /*CC*/

typedef char FAR	*LPSTR;
typedef int  FAR	*LPINT;

#ifndef NOMINMAX
#define	max(a,b)	((a) > (b) ? (a) : (b))
#define	min(a,b)	((a) < (b) ? (a) : (b))
#endif

#define	MAKELONG(l, h)	((long)(((unsigned)(l)) | ((unsigned long)((unsigned)(h))) << 16))
#define MAKEWORD(l, h)	((WORD)(((BYTE)(l)) | ((WORD)((BYTE)(h))) << 8))
#define	LOWORD(l)	((WORD)(l))
#define	HIWORD(l)	((WORD)(((DWORD)(l) >> 16) & 0xffff))
#define	LOBYTE(w)	((BYTE) ((w) & 0xff))
#define	HIBYTE(w)	((BYTE)(((WORD)(w) >> 8) & 0xff))

/* DCHAR = Double Byte Character */
typedef	WORD		DCHAR;
/* CHAR = unsigned char */
typedef unsigned char	CHAR;

/* ACHAR = either a DCHAR or a CHAR */
#ifdef KANJI
typedef	DCHAR		ACHAR;
extern BOOL PASCAL fKanaAccel;	/* set by application to choose accelerators */
#else
typedef	CHAR		ACHAR;
#endif

/*****************************************************************************/

#ifndef NORECT
typedef struct _rrc
	{
	BYTE	rxLeft;
	BYTE	ryTop;
	BYTE	rxRight;
	BYTE	ryBottom;
	} RRC;
typedef RRC *PRRC;
typedef struct _arc
	{
	BYTE	axLeft;
	BYTE	ayTop;
	BYTE	axRight;
	BYTE	ayBottom;
	} ARC;
typedef ARC *PARC;
typedef struct _box
	{
	char	chTopLeftCorner;
	char	chTopRightCorner;
	char	chBottomLeftCorner;
	char	chBottomRightCorner;
	char	chTopSide;
	char	chBottomSide;
	char	chLeftSide;
	char	chRightSide;
	} BOX;
extern BOX PASCAL boxSingle, PASCAL boxDouble;
extern BOX PASCAL boxActiveWindowOut;
extern BOX PASCAL boxInactiveWindowOut;
extern BOX PASCAL boxActiveWindowIn;
extern BOX PASCAL boxInactiveWindowIn;
extern BYTE PASCAL axMac;
extern BYTE PASCAL ayMac;
/* all CW applications should work with screens up to 254x254 */
#define axMax 254
#define ayMax 254

#endif /*!NORECT*/

#ifndef NOWND

#ifndef cwExtraWnd
#ifdef CC
/* -- for CC compiler : fixed length */
#define cwExtraWnd 1 
#else
/* -- for CS compiler : variable length */
#define cwExtraWnd
#endif
#endif

typedef struct _wnd
	{
	WORD	id;
	BITS	style:14;
	BITS	fCursorOn:1;
	BITS	fEnabled:1;
	ARC	arcWindow;
	ARC	arcClipping;
	PLFN_WNDPROC pfnWndProc;			/* Medium Model */
	struct _wnd *pwndParent;
	struct _wnd *pwndSibling;
	struct _wnd *pwndChild;
	BYTE	axCursor;
	BYTE	ayCursor;
	WORD	rgwExtra[cwExtraWnd];
	} WND;

typedef WND *PWND;
#endif /*!NOWND*/

/***END_PUBLIC***/

#ifdef COW

#define	DEBPUB			 1	/* always debugging publics */
#include <version.h>

#define PUBLIC		/* global export */
#define PRIVATE		/* local export within module */
#define	BLOCK		/* Nested Block */


#ifdef CC
#ifndef COW_TINY_SWAPPED
#define FARPRIVATE	NEAR PASCAL		/* small model internal */
#else
#define FARPRIVATE	FAR PASCAL
#endif
#else
#define	FARPRIVATE	PASCAL
#endif

typedef int (FARPRIVATE *PFN_PRIVATE)();	/* General Private Procedure */

#ifndef DEBPUB
#define STATIC static	/* static */
#else
#define STATIC		/* make visible for debugging */
#endif

#define REGISTER register			/* for old code */
#define REG register				/* use this */
#define	Unreferenced(x)		((void)x)	/* for unreferenced formals */

#ifdef DEBUG
PRIVATE VOID FAR CowAssertFailedLine(char *, int);
PRIVATE VOID FAR CowAssertFailedSz(char *);
#define Assert(exp)	{ \
	if (!(exp)) CowAssertFailedLine(__FILE__, __LINE__); \
		}
#define AssertSz(exp, sz)	{ \
	if (!(exp)) CowAssertFailedSz(sz); \
		}
#define	Debug(statement)	statement
	
#else
#define Assert(exp)
#define AssertSz(exp, sz)
#define	Debug(statement)
#endif /* !DEBUG */

#ifdef PROFILE
extern int FAR StartNMeas(void);	/* really VOID */
extern VOID FAR StopNMeas(void);
extern DWORD FAR LTrickCall(void);
extern VOID FAR TrickReturn(DWORD);

extern int PASCAL crefCow;

/* note : StartPublic may should be placed after first { of procedure */
#define	StartPublic() int wProfile = crefCow++ ? 0 : StartNMeas()

/* note : StopPublic should be placed before the end and before any returns */
#define	StopPublic() {if (--crefCow == 0) StopNMeas(); }
#define	ReturnPublic(expr, type) {\
	type xRet = expr; StopPublic(); return(xRet); }

/* note : ReturnLeave is like ReturnPublic, but leave COW to evaluate "expr" */
#define	ReturnLeave(expr, type) {\
	type xRet;		/* variable for expression result */\
	int crefT = crefCow;	/* save reference count */	\
	DWORD lTrick = LTrickCall();	/* trick CALL */	\
	StartNMeas();						\
	crefCow = 0;		/* leaving COW for a while */	\
	xRet = expr;		/* evaluate function */		\
	crefCow = crefT;	/* restore state */		\
	TrickReturn(lTrick);	/* trick return */		\
	StopNMeas();						\
	return(xRet); }

#else
#define	StartPublic()	extern int fooBar	/* trick to put at start */
/*? ?? ?? ? ? does it increase frames in optimized code ???? */
#define	StopPublic()
#define	ReturnPublic(expr, type) return(expr)
#define	ReturnLeave(expr, type) return(expr)
#endif


/*	* Things supplied by the application */
BYTE *		FARPUBLIC PbAllocWork(WORD);
VOID		FARPUBLIC FreeWork(BYTE *);
VOID		FARPUBLIC OutOfMemory(void);
VOID		FARPUBLIC Help(WORD, WORD, VOID *, WORD);
VOID		FARPUBLIC UpdateShiftKk(WORD, WORD);
#ifdef KANJI
VOID		FARPUBLIC UpdateShiftKj(WORD, WORD);
#endif
VOID		FARPUBLIC PrepareSwapDisk(void);

/* for far screen saves (only if SCREEN_FAR_SAVE) */
BYTE FAR *	FARPUBLIC LpbAllocWorkFar(WORD);
VOID		FARPUBLIC FreeWorkFar(BYTE FAR *);

#ifdef DEBUG
BOOL		FARPUBLIC FTrapMouseRbutton(void);
#endif

#endif /*COW*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\cwdebug.h ===
/*
	CW : Character Windows

	cwdebug.h : debugging support
		NOTE : only valid for swap based system
*/

typedef	struct
	{
	WORD	cblkTotal;
	WORD	cblkCode;
	WORD	cblkData;
	WORD	cblkFree;
	DWORD	cbTotal;
	DWORD	cbCode;
	DWORD	cbData;
	DWORD	cbFree;
	} CKH;	/* Heap checking structure */

/* Debugging routines */
VOID FAR CDECL dprintf(char *, ...);		/* debug printf */
VOID FARPUBLIC PrDebugRgch(char far *, int);
BOOL FARPUBLIC FCheckGlobalHeap(CKH FAR *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\pdb.inc ===
;
; MSDOS 2.xx Process Data Block
;
;   Contains all DOS specific data.
;

FilPerProc	EQU	20

; Process Data located in the Program Segment Prefix, just before the
; code and data for the loaded program.
;
PDB		STRUC
PDB_Exit_Call	DW  ?
PDB_block_len	DW  ?
		DB  ?
PDB_CPM_Call	DB  5 DUP (?)
PDB_Exit	DD  ?
PDB_Ctrl_C	DD  ?
PDB_Fatal_Abort DD  ?
PDB_Parent_PID	DW  ?
PDB_JFN_Table	DB  FilPerProc DUP (?)
PDB_environ	DW  ?
PDB_User_stack	DD  ?
PDB_JFN_Length	DW  ?		    ; DOS 3.x only
PDB_JFN_Pointer DD  ?		    ; DOS 3.x only
PDB_Next_PDB	DD  ?		    ; DOS 3.x only
PDB_PAD1	DB  06h DUP (?)
PDB_Chain	DW  ?		    ; Windows only
PDB_Partition	DW  ?		    ; Windows only
PDB_NextPDB	DW  ?		    ; Windows only
PDB_GlobalHeap	DD  ?		    ; Windows only
PDB_Entry_stack DD  ?		    ; Windows only
PDB_Call_system DB  5h DUP (?)
PDB_PAD2	DB  7h DUP (?)
PDB_5C_FCB	DB  10h DUP (?)
PDB_6C_FCB	DB  14h DUP (?)
PDB_DEF_DTA	DB  80h DUP (?)
PDB		ENDS
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\cmacros.inc ===
comment $
cmacros - assembly macros for interfacing to HHLs
(C)Copyright Microsoft Corp. 1984, 1985, 1986
$
if1
ASMpass=1
outif MACRO name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
%out ! onmsg
endif
else
ifnb <offmsg>
%out ! offmsg
endif
endif
endm
??error macro msg
E r r o r ----- msg
endm
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
%out cMacros Version 2.09 - 10/10/86
%out Copyright (C) Microsoft Corp. 1984, 1985, 1986. All rights reserved.
outif memS,0,<Small Model>
outif memM,0,<Medium Model>
outif memL,0,<Large Model>
outif memC,0,<Compact Model>
outif memH,0,<Huge Model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS= 1
outif memS,0,<Small Model>
else
??error <Must have only 1 memory model selected>
endif
endif
sizeC= memM + memL + memH
sizeD= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows Support>
outif ?PLM,1,<PLM calling convention>
ifndef ?NODATA
?NODATA1=0
else
?NODATA1=1
%out ! NODATA module
endif
ifndef ?CHKSTK
?CHKSTK1=0
else
?CHKSTK1=1
ifdef ?CHKSTKPROC
%out ! Private stack checking enabled
else
%out ! Stack checking enabled
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
?286=1
%out ! DOS5 module
endif
ifdef ?PROFILE
%out ! Native Profiling Enabled
endif
outif ?286,0,<286 mode code only>
else
ASMpass=2
endif
if ?286
.286p
endif
.XCREF
.XCREF ?N,?AX,?AH,?AL,?BX,?BH
.XCREF ?BL,?CX,?CH,?CL,?DX,?DH
.XCREF ?DL,?SI,?DI,?ES,?DS,?BP
.XCREF ?SP,?SS,?CS
.XCREF ?RSL,?CPD,?argl,?argc,?BA
.XCREF ?ACB,???,?PO
.XCREF ?PAS,?PC
.XCREF Uconcat,mPush,mPop
.XCREF ?RI,?pp,?pp1,?al1
.XCREF ?aD,?AP,?Atal,?dd,?dd1
.XCREF ?pg,?pg1,?aloc,?cs1,?cs2
.XCREF ?DF,?TF,?FF,?PLM,?WIN,?IA,?PU,?ADJ
.XCREF ?UF,?RP,?286,?ND,?NODATA1,?CHKSTK1,?DOS5
.XCREF ?WFP
?RSL = 0
?CPD = 0
?ArgL = 0
?ArgC = 0
?BA = 0
?ACB = 0
??? = 0
?PO = 0
?PAS = 0
?PC = 0
?IA = 0
?PU = 0
?ADJ = 0
?RP = 0
?UF = 0
?ND = 0
?WFP = 0
?FF = 0
?N = 0000000000000000B
?AX = 0000000000000011B
?AH = 0000000000000001B
?AL = 0000000000000010B
?BX = 0000000000001100B
?BH = 0000000000000100B
?BL = 0000000000001000B
?CX = 0000000000110000B
?CH = 0000000000010000B
?CL = 0000000000100000B
?DX = 0000000011000000B
?DH = 0000000001000000B
?DL = 0000000010000000B
?SI = 0000000100000000B
?DI = 0000001000000000B
?ES = 0000010000000000B
?DS = 0000100000000000B
?BP = 0001000000000000B
?SP = 0010000000000000B
?SS = 0100000000000000B
?CS = 1000000000000000B
.CREF
uconcat macro a,b,c,d,e,f
a&b c&d e&f
endm
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if r AND ?&&x
push x
endif
endm
endm
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if r AND ?&&x
pop x
endif
endm
endm
save macro r
?RSL=0
?RI ?RSL,<r>
endm
?RI macro n,r
irp x,<r>
ifdef ?&&x
n=n OR ?&&x
endif
endm
endm
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<DWORD>,0,4
?pp <Off_&&x>,<WORD>,2,2
?pp <Seg_&&x>,<WORD>,2,2
endm
else
irp x,<n>
?pp <Seg_&&x>,<WORD>,2,2
?pp <Off_&&x>,<WORD>,2,2
?pp <&&x>,<DWORD>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<QWORD>,8,8
endm
parmT macro n
?pp <n>,<TBYTE>,10,10
endm
if sizeC
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sizeD
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?CPD
.xcref
irp x,<n>
.xcref ?T&&x
?T&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?PO+?adj)
?PO=?PO+l
else
?PO=?PO+l
?pp1 x,<t>,%?PO,%?adj
endif
endm
.cref
else
??error <Parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b
ife ?PLM
n equ t ptr [bp+b]
else
n equ t ptr [bp+a+?PO-o]
endif
endm
ifndef ?NOPARMR
.XCREF
.XCREF ?pr
.CREF
parmR macro n,r,r2
?pr n,r,r2,%?RP,%(?IA+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR SEG_&n,r
parmR OFF_&n,r2
n equ dword ptr [bp-o-2]
.xcref ?T&n
?T&n=4
else
.xcref ?RP&i
?RP&i=0
ifdef ?&r
?RP&i=?&r
endif
if ??? OR (?CPD EQ 0) OR (?RP&i EQ 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ word ptr [bp-o]
?T&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x EQ ?&r
n equ byte ptr [bp-o]
?T&n=1
exitm
endif
endm
?IA=?IA+2
?RP=?RP+1
endif
.cref
endm
endif
localB macro n
?aLoc <n>,<BYTE ptr>,1,1,0
endm
localW macro n
?aLoc <n>,<WORD PTR>,2,2,1
endm
localD macro n
irp x,<n>
?aLoc <Seg_&&x>,<WORD PTR>,2,2,1
?aLoc <Off_&&x>,<WORD PTR>,2,2,1
?aLoc <&&x>,<DWORD PTR>,0,4,1
endm
endm
localQ macro n
?aLoc <n>,<QWORD PTR>,8,8,1
endm
localT macro n
?aLoc <n>,<TBYTE PTR>,10,10,1
endm
if sizeC
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sizeD
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aLoc <n>,,%(a),0,1
endm
?aLoc macro n,t,l,s,a
if ?CPD
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) AND 0FFFEH)
endif
?aL1 x,<t>,%(???+?IA)
.xcref ?T&&x
?T&&x=s
endm
.cref
else
??error <Locals "&n" declared outside procedure def>
endif
endm
?aL1 macro n,t,o
n equ t [bp-o]
endm
ifndef ?NOGLOBAL
globalB macro n,i,s
?aD <n>,1
?dd n,1,<BYTE>,<DB>,<i>,<s>
endm
globalW macro n,i,s
?aD <n>,2
?dd n,1,<WORD>,<DW>,<i>,<s>
endm
globalD macro n,i,s
?aD <n>,4
?dd n,1,<DWORD>,<DD>,<i>,<s>
endm
globalQ macro n,i,s
?aD <n>,8
?dd n,1,<QWORD>,<DQ>,<i>,<s>
endm
globalT macro n,i,s
?aD <n>,10
?dd n,1,<TBYTE>,<DT>,<i>,<s>
endm
if sizeC
globalCP macro n,i,s
globalD n,<i>,<s>
endm
else
globalCP macro n,i,s
globalW n,<i>,<s>
endm
endif
if sizeD
globalDP macro n,i,s
globalD n,<i>,<s>
endm
else
globalDP macro n,i,s
globalW n,<i>,<s>
endm
endif
endif
ifndef ?NOSTATIC
staticB macro n,i,s
?aD <n>,1
?dd n,0,<BYTE>,<DB>,<i>,<s>
endm
staticW macro n,i,s
?aD <n>,2
?dd n,0,<WORD>,<DW>,<i>,<s>
endm
staticD macro n,i,s
?aD <n>,4
?dd n,0,<DWORD>,<DD>,<i>,<s>
endm
staticQ macro n,i,s
?aD <n>,8
?dd n,0,<QWORD>,<DQ>,<i>,<s>
endm
staticT macro n,i,s
?aD <n>,10
?dd n,0,<TBYTE>,<DT>,<i>,<s>
endm
if sizeC
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sizeD
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s
ife ?PLM
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
PUBLIC n
endif
ifb <s>
n d i
else
ifb <i>
n d s DUP (?)
else
n d s DUP (i)
endif
endif
endm
ifndef ?NOEXTERN
.XCREF
.XCREF ?ex1
.CREF
externB macro n
?ex1 <n>,1,<BYTE>
endm
externW macro n
?ex1 <n>,2,<WORD>
endm
externD macro n
?ex1 <n>,4,<DWORD>
endm
externQ macro n
?ex1 <n>,8,<QWORD>
endm
externT macro n
?ex1 <n>,10,<TBYTE>
endm
externNP macro n
?ex1 <n>,2,<NEAR>
endm
externFP macro n
?ex1 <n>,4,<FAR>
endm
if sizeC
externP macro n
?ex1 <n>,4,<FAR>
endm
else
externP macro n
?ex1 <n>,2,<NEAR>
endm
endif
if sizeC
externCP macro n
?ex1 <n>,4,<DWORD>
endm
else
externCP macro n
?ex1 <n>,2,<WORD>
endm
endif
if sizeD
externDP macro n
?ex1 <n>,4,<DWORD>
endm
else
externDP macro n
?ex1 <n>,2,<WORD>
endm
endif
?ex1 macro n,s,d
irp x,<n>
.xcref
.xcref ?T&&x
.cref
?T&&x=s
ife ?PLM
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
endm
endm
endif
ifndef ?NOLABEL
.XCREF
?lblpu = 0
.XCREF ?lb1,?lblpu
.CREF
labelB macro n
?lb1 <n>,1,<BYTE>
endm
labelW macro n
?lb1 <n>,2,<WORD>
endm
labelD macro n
?lb1 <n>,4,<DWORD>
endm
labelQ macro n
?lb1 <n>,8,<QWORD>
endm
labelT macro n
?lb1 <n>,10,<TBYTE>
endm
labelNP macro n
?lb1 <n>,2,<NEAR>
endm
labelFP macro n
?lb1 <n>,4,<FAR>
endm
if sizeC
labelP macro n
?lb1 <n>,4,<FAR>
endm
else
labelP macro n
?lb1 <n>,2,<NEAR>
endm
endif
if sizeC
labelCP macro n
?lb1 <n>,4,<DWORD>
endm
else
labelCP macro n
?lb1 <n>,2,<WORD>
endm
endif
if sizeD
labelDP macro n
?lb1 <n>,4,<DWORD>
endm
else
labelDP macro n
?lb1 <n>,2,<WORD>
endm
endif
?lb1 macro n,s,d
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?T&&x
.cref
?T&&x=s
ife ?PLM
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
defB macro n
?aD <n>,1
endm
defW macro n
?aD <n>,2
endm
defD macro n
?aD <n>,4
endm
defQ macro n
?aD <n>,8
endm
defT macro n
?aD <n>,10
endm
if sizeC
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sizeD
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?aD macro n,s
irp x,<n>
.xcref
.xcref ?T&&x
.cref
?T&&x=s
endm
endm
ifndef ?NOPTR
regPtr macro n,S,O
farPtr n,S,O
endm
farptr macro n,S,O
.xcref
.xcref ?T&n
.cref
n &macro
push S
push O
&endm
?T&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?Atal <x>,%?argc
endm
endm
?Atal macro n,i
.xcref
.xcref ?ALI&i
.cref
?ALI&i &macro
?AP n
&endm
endm
?AP macro n
?argl=?argl+2
ifdef ?T&n
ife ?T&n-1
push word ptr (n)
exitm
endif
ife ?T&n-2
push n
exitm
endif
ife ?T&n-4
push word ptr (n)+2
push word ptr (n)
?argl=?argl+2
exitm
endif
ife ?T&n-8
push word ptr (n)+6
push word ptr (n)+4
push word ptr (n)+2
push word ptr (n)
?argl=?argl+6
exitm
endif
if ?T&n AND 80h
n
?argl=?argl+2
exitm
endif
ife ?T&n
push word ptr (n)
exitm
endif
endif
push n
endm
ccall macro n,a,sleaze
ifnb <a>
Arg <a>
endif
mpush %?RSL
?argl=0
ife ?PLM
?ACB=?argc
else
?ACB=1
endif
rept ?argc
uconcat <?ALI>,%?ACB
uconcat <purge>,,<?ALI>,%?ACB
ife ?PLM
?ACB=?ACB-1
else
?ACB=?ACB+1
endif
endm
ife ?PLM
ifb <sleaze>
call _&n
else
call n
endif
if ?argl
add sp,?argl
endif
else
call n
endif
mpop %?RSL
?RSL=0
?argc= 0
?argl= 0
endm
cProc macro n,c,a
if ?CPD
?UTPE
endif
?CPD=1
???=0
?argc=0
?BA=0
?PO=0
?PU=0
?IA=0
?adj=4
?RP=0
?UF=0
?FF=0
?PAS=0
ifnb <a>
?RI ?PAS,<a>
endif
?PC=sizeC
?ND=?NODATA1
?WFP=?WIN
irp x,<c>
ifidn <x>,<FAR>
?PC=1
endif
ifidn <x>,<NEAR>
?PC=0
endif
ifidn <x>,<PUBLIC>
?PU=1
endif
ifidn <x>,<SMALL>
?UF=1
endif
ifidn <x>,<DATA>
?ND=0
endif
ifidn <x>,<NODATA>
?ND=1
endif
ifidn <x>,<ATOMIC>
?WFP=0
endif
ifidn <x>,<FORCEFRAME>
?FF=1
endif
endm
if ?PC
if ?WFP
ife ?ND
?IA=2
?PAS = ?PAS AND (NOT ?ds)
endif
endif
?adj=?adj+2
else
?WFP=0
endif
?PAS = ?PAS AND (NOT (?sp+?cs+?ss))
if ?UF+?WFP+?FF
?PAS = ?PAS AND (NOT (?bp))
endif
if ?UF
?PAS = ?PAS AND (NOT (?si+?di))
endif
ife ?PLM
?pg <_&n>,%?PU,%?PC,%?PAS,%?WFP,<n>
else
?pg <n>,%?PU,%?PC,%?PAS,%?WFP,<n>
endif
endm
?pg macro n,p,c,a,w,nu
.xcref
if ?UF
if ?RP
??error <parmR encountered in &n - user frame ignored>
?UF=0
endif
if ?ND
??error <NODATA encountered in &n - user frame ignored>
?UF=0
endif
endif
cBegin &macro g
.xcref
?pg1 <n>,c,a,%?PO,w,%?UF,%?ND,%?RP
?CPD=0
?argc=0
?BA=1
???=(???+1) AND 0FFFEH
if p
PUBLIC n
endif
ife ?PLM
ife c
nu label near
else
nu label far
endif
endif
ife c
n proc NEAR
else
n proc FAR
endif
ifidn <g>,<nogen>
if ???+?PO+a+?RP
%out <cBegin - possible invalid use of nogen>
endif
else
if ?UF
?MF c,%???,%?PO
mPush a
else
if w
ife ?ND
mov ax,ds
nop
endif
ife ?DOS5
inc bp
endif
push bp
mov bp,sp
ife ?ND
push ds
mov ds,ax
endif
else
if ?FF+???+?PO+?RP
if (?286 ne 0) AND (??? ne 0)
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
if ?RP
?UF=0
rept ?RP
uconcat mpush,,?RP,%?UF
?UF=?UF+1
endm
endif
if ???
if ?CHKSTK1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
mov ax,???
ife ?PLM
call _chkstk
else
call chkstk
endif
endif
else
if (?286 eq 0) OR w
sub sp,???
endif
endif
endif
if ???+?PO+?RP
mPush %(a AND (NOT ?bp))
else
mPush a
endif
endif
ifdef ?PROFILE
if c
call StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
?UTPE &macro
??error <Unterminated Procedure Definition: "&n">
&endm
endm
?pg1 macro n,c,a,o,w,f,d,r
.xcref
cEnd &macro g
.xcref
?BA=0
ifidn <g>,<nogen>
if o+a+r
%out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
if ???+?PO+?RP
mPop %(a AND (NOT ?bp))
else
mPop a
endif
if f
db 0C3h
else
if w
if d
if (?TF eq 0) OR (???+?RP)
if ?286
leave
else
mov sp,bp
pop bp
endif
else
pop bp
endif
else
if (?TF eq 0) OR (???+?RP)
lea sp,-2[bp]
endif
pop ds
pop bp
endif
ife ?DOS5
dec bp
endif
else
if ?FF+???+?PO+?RP
if (?TF eq 0) OR (???+?RP)
ife ?286
mov sp,bp
pop bp
else
leave
endif
else
pop bp
endif
endif
endif
ife ?PLM
ret
else
ret o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addSeg grp,n
else
ln&OFFSET equ OFFSET n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addSeg macro grp,seg
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
grp&_add &macro s
grp&_in <seg>,s
&endm
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defGrp macro grp,ln
addSeg grp
ifnb <ln>
?cs3 <ln>,<grp>
ln&OFFSET equ OFFSET grp:
ln&BASE equ grp
endif
endm
?cs1 macro ln,n
ln&_sBegin &macro
?MF &&macro c,l,p
if c
extrn n&_FARFRAME:near
call n&_FARFRAME
else
extrn n&_NEARFRAME:near
call n&_NEARFRAME
endif
db l shr 1
db p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
sEnd &macro
n ends
purge ?MF
&endm
endm
?cs3 macro ln,n
ln&_assumes &macro s
assume s:&n
&endm
endm
sBegin macro ln
ln&_sBegin
endm
ife ?DF
createSeg _TEXT,code,word,public,CODE
ife ?NODATA1
createSeg _DATA,data,word,public,DATA,DGROUP
defGrp DGROUP,DATA
endif
if ?CHKSTK1
ifndef ?CHKSTKPROC
externP <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *ERRNZ* x1 = x2
endm
errn$ macro l,x
errnz <OFFSET $ - OFFSET l x>
ENDM
ifdef ?PROFILE
externFP <StartNMeas, StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\inos.asm ===
;*
;*	CW : Character Windows
;*
;*	inos.asm : the INOS data structure

	include kernel.inc
	include indrv.inc

;*****************************************************************************

;*****************************************************************************

sBegin	DATA
    assumes CS,DGROUP
    assumes DS,DGROUP


	PUBLIC	inosDrv
inosDrv:
IFDEF DUAL
	DB	cbInosMin DUP (?)		;* inos fixed at runtime
ELSE ;!DUAL
IFDEF DOS5
	include	_inos.asm
ENDIF ;DOS5
ENDIF ;!DUAL

sEnd	DATA

;*****************************************************************************

sBegin	DRV
    assumes CS,DRV
    assumes DS,DRV

;*	* pointer in code space to driver OS/2 jump routines
IFDEF DOS5
globalW pinos, <dataOffset inosDrv>
ELSE
globalW pinos, 0
ENDIF

sEnd	DRV

;*****************************************************************************
;* IOPL hack

IFDEF DOS5
createSeg   IOPL_TEXT,IOPL_TEXT,BYTE,PUBLIC,CODE	;* IOPL segment

sBegin	IOPL_TEXT
    assumes CS,IOPL_TEXT

;********** CwBeginIO **********
;*	entry: called from driver with CPL = 3
;*	exit:  return to driver with CPL = 2 (so it can do IO)
;*	* NOTE: the following is kludgey
;*	* NOTE: between CwBeginIO and CwEndIO the stack is different

cProc	CwBeginIO, <PUBLIC, FAR>
cBegin	nogen ;CwBeginIO -- called through call gate from PL3

	push	bp			;* save BP
;*	* At this point the PL2 stack looks like
;*	SP =>	old BP
;*		IP (caller)
;*		CS (caller) -- PL3
;*		SP (caller)
;*		SS (caller) -- PL3
	mov	bp,sp			;* point to PL2 stack
	and	word ptr ss:[bp+4],NOT 1;* turn return address into PL2
	pop	bp			;* restore BP
	retf				;* return (remain at PL2)

cEnd	nogen ;CwBeginIO -- exit at PL2


;********** CwEndIO **********
;*	entry: in PL2, stack is still set up from original call gate
;*	exit:  return to driver with CPL = 3
;*	* CwBeginIO and CwEndIO must be matched
;*	* NOTE: the following is kludgey
;*	* NOTE: between CwEndIO and CwEndIO the stack is different

cProc	CwEndIO, <PUBLIC, FAR>
cBegin	nogen ;CwEndIO -- enter from PL2 (not call gate)

	push	bp			;* save BP
;*	* At this point the PL2 stack looks like
;*	SP =>	old BP
;*		IP (caller)
;*		CS (caller) -- PL3
;*		SP (caller)
;*		SS (caller) -- PL3
	mov	bp,sp			;* point to PL2 stack
	or	word ptr ss:[bp+4],1	;* turn return address into PL3
	pop	bp			;* restore BP
	retf				;* return (return to PL3)

cEnd	nogen ;CwEndIO -- return through gate to PL3

sEnd	IOPL_TEXT

ENDIF ;DOS5

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\gfixcomp.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	gfixcomp.asm : global fixed compaction
;*	* NOTE :

	TITLE	GFIXCOMP - Global Memory compacted for fixed blocks

.xlist
include	kernel.inc
include	galloc.inc
.list

IFDEF	REALLOC_FIXED
;*****************************************************************************

sBegin	DATA

externW	<psLom>
externW	<pGlobalHeap>

;* Put back as locals latter

globalW	cpTotalFree,(?)
globalW	cpCodeInData,(?)
globalW	cpFixedToEOM,(?)
globalW	cpUsedFixedToEOM,(?)
globalW	cpFreeUnder,(?)
globalW	psFixed,(?)
globalW	psEOM,(?)

sEnd	DATA

;*****************************************************************************


sBegin	KERNEL
	assumes	CS,KERNEL
	assumes	DS,nothing
	assumes	SS,DGROUP

externNP	gsplice				;* galloc.asm
externNP	gjoin				;* galloc.asm
externNP	gnotify				;* gwinterf.asm
externNP	gdiscard			;* gcompact.asm
externNP	gcompact			;* gcompact.asm


;***	gCopyUp(psDest, psSrc) - This routine is used to copy between heap
;*		entries.  It has the advantage that:
;*		1) It does not copy the handles and
;*		2) It does not change ANY registers
;*
cProc	gCopyUp,<NEAR,PUBLIC>,<bx,cx,es,ds,di,si>
parmW	psDest				;* Destination
parmW	psSource			;* Source
parmW	cpSource			;* Size of source
cBegin	
	mov	bx,cpSource		;* Get size of data
					;*	(does not include handle)
	mov	cx,psSource		;* Move over handle
	inc	cx
	add	cx,bx
	mov	ds,cx
	mov	cx,psDest		;* Move over handle
	inc	cx
	add	cx,bx
	mov	es,cx
	STD
	
CM10:
	mov	cx,0fffh		;* - 64Kb (in paras)
	cmp	bx,cx			;* > 64Kb to copy?
	ja	CM20			;* Yes - Do 64K now
	mov	cx,bx			;* No - do this many paras
CM20:
	sub	bx,cx			;* Update count of paras left

	mov	di,es			;* Change base to copy from
	sub	di,cx			;*   --
	mov	es,di
	mov	di,ds
	sub	di,cx
	mov	ds,di

	shl	cx,1			;* Convert from paras to words
	shl	cx,1			;*
	shl	cx,1
;	xor	di,di			;* Zero this out
;	xor	si,si			;* Zero this out
	mov	di,cx
	dec	di			;* move into previous paragraph
	shl	di,1			;* Convert to bytes
	mov	si,di

	repz	movsw			;* Do the copy
	or	bx,bx			;* Done coping?
	jz	CM99			;* Yes - exit
	jmp	short CM10
CM99:
	cld				;* Save us from ourselfs
cEnd


;***	
;*
;*

cProc	CopyHandle,<NEAR,PUBLIC>
cBegin	
	mov	ax,ds:[di].ga_owner	;* Copy Owner
	mov	es:[di].ga_owner,ax	;*
	
	mov	ah,ds:[di].ga_flags	;* Copy Flags
	mov	es:[di].ga_flags,ah	;*
	
	mov	ax,ds:[di].ga_handle	;* Copy Handle
	mov	es:[di].ga_handle,ax	;*

	xor	ax,ax			;* And Free the old block
	mov	ds:[di].ga_owner,ax	;*	Mark as free
	mov	ds:[di].ga_handle,ax	;*	Zero the handle
cEnd	


;*
;*	Assumptions:
;*	1.  Currently assumes that the free segment and	the data segment
;*		are adjacent.
;*	2.  Free segment is above data segment
;*	3.  Doing a compress up
;*	
;*
;*	Inputs:
;*		psFree = free segment to place in
;*		psData = segment to move
;*
;*	Outputs
;*		es = new address of segment
;*		ax = new address of free segment
;*

cProc	gfixedSlide,<NEAR,PUBLIC>
parmW	psFree
parmW	psData
cBegin
	push	ds
	mov	ds,ax
	mov	bx,es:[di].ga_size
	cmp	bx,ds:[di].ga_size
	ja	gfs50
	je	gfs90

;*
;*  	Size of free heap entry is greater than size of Data heap entry
;*
	mov	ax,ds:[di].ga_next	;* Compute address where data
	sub	ax,es:[di].ga_size	;*  heap entry will start after
	dec	ax			;*  the copy is finished
	pop	ds			;* Set up for the splice routine
	mov	si,ax
	mov	es,[psFree]
	call	gsplice

	;*  psData = old
	;*  si = new
gfs10:
	mov	es,psData
	mov	al,GN_MOVE
	mov	bx,es:[di].ga_handle
	mov	dx,es:[di].ga_owner
	mov	cx,si
	inc	cx
	mov	ds,[pGlobalHeap]
	call	gnotify

	mov	es,psData
	mov	bx,es:[di].ga_size
	cCall	gCopyUp,<si,es,bx>
	push	ds
	mov	ax,es			;* Copy some flags around
	mov	ds,ax
	mov	es,si
	cCall	copyHandle
	pop	ds
	
	jmp	gfs99

	;*
	;*	This means same number of paragraphs in both
	;*	source and destination
	;*
gfs90:
	mov	si,psFree
	pop	ds
	jmp	short gfs10

	;*
	;*	Fewer paragraphs in free segment than in data segment
	;*
;*****
gfs50:
	mov	cx,ds:[di].ga_next		;* Address of end of free
	sub	cx,bx				;* Less size of data segment
	dec	cx				;* and one more is
	mov	psFree,cx			;* start of new data segment
	mov	ax,ds				;* setup for gjoin
	mov	es,ax				;* es:di = psFree
	pop	ds				;* ds:di = psGlobalHeap
	push	bx				;* Save size of Data 
	call	gjoin
	
	inc	cx
	mov	bx,es:[di].ga_handle
	mov	dx,es:[di].ga_owner
	mov	ds,[pGlobalHeap]
	mov	al,GN_MOVE
	call	gnotify
	
	pop	bx
	cCall	gCopyUp,<psFree,psData,bx>
	
	mov	es,psData
	mov	si,psFree
	call	gsplice
	
	push	ds
	mov	es,psFree
	mov	ds,psData
	cCall	copyHandle
	pop	ds
	
gfs99:
cEnd


;*
;*  This subroutine is used to do a compact suitable for doing a
;*	realloc on a fixed data segment.  This routine will push
;*	the moveable blocks following the fixed segment up in memory
;*	to make room for it to grow.
;*
;*  This routine is not optimal in either performance or sucess rate.
;*	For instance it does not deal with the possiblity of placing
;*	moveable data segments above the fixed block into free space
;*	below it.  (This could however be done ineffiecently by doing
;*	a normal compact first.)
;*
;*  Inputs:	DX = New size for entry
;*		DS:DI = address of global heap information
;*		ES:DI = header of fixed block to be expanded
;*
;*  Outputs:	AX = size of largest contiguous free block
;*		ES:DI = arena header of largest contiguous free block
;*		DX = minimum # contiguous bytes needed
;*
;*  Destroys:	
;*

cProc	gfixedCompact,<NEAR,PUBLIC>,<si>
cBegin
	mov	psFixed,es		;* Save Segment of Fixed block
	mov	ax,ds:[di].hi_last	;* Last entry in the heap
	sub	ax,ds:[di].gi_reserve	;* Subtract the fence size
	mov	psEOM,ax
	sub	dx,es:[di].ga_size	;* Subtract number of bytes already there

;*	Do an estimate to see if the compact could succeed
;*	-	Compute
;*		-	Total Amount of free space in the system
;*		-	Amount of code in data area
;*		-	Amount of space between this fixed block
;*			and the next fixed block, the code fence,
;*			locked block, or the end of user memory
;*		-	Free space below this fixed block
	xor	ax,ax	
	mov	cpTotalFree,ax		;* Zero out the counters
	mov	cpCodeInData,ax
	mov	cpFixedToEOM,ax
	mov	cpUsedFixedToEOM,ax
	mov	cpFreeUnder,ax

	mov	ax,ds:[di].hi_first	;* Start with first entry
lab10:
	mov	es,ax			;* Point to the entry
	mov	bx,es:[di].ga_size	;* Get the size of the block
	inc	bx			;* Include the header in size
	
	;*
	;*	if (block is free) {
	;*		cpTotalFree += block size;
	;*		if (psBlock < psFixed)
	;*			cpFreeUnder += block size
	;*		else if (psBlock < psEOM)
	;*			cpFixedToEOM += block size
	;*	} else {
	;*		if (psBlock <= psFixed)
	;*		       continue;
	;*		if (psBlock is Locked)
	;*		       break;
	;*		if (psBlock < psEOM) {
	;*			cpFixedToEOM += block size
	;*			if (block is code)
	;*				cpCodeInData += block size
	;*		}
	;*	}
	;*
	cmp	di,es:[di].ga_owner	;* Is is free?
	jne	lab20
	add	cpTotalFree,bx		;* Yes -- add to total free
	
	cmp	ax,psFixed		;* Is it below the fixed entry?
	jae	lab15			;* No - move on
	add	cpFreeUnder,bx		;* Yes -- add to total free below fixed
	jmp	short lab80		;*	 Move to next entry

lab15:	
	je	lab80			;* Is the fixed entry -- skip to next
	cmp	ax,psEOM		;* Above the fence?
	jae	lab80			;* Yes - move to next entry
	add	cpFixedToEOM,bx		;* No -- add size below fence to total
	add	bx,ax			;* Find end of segment
	sub	bx,psEOM		;* Below the fence?
	jbe	lab80			;* yes -- Goto next entry
	sub	cpFixedToEOM,bx		;* No -- subtract overflow from total
	jmp	short lab80		;* Move to next entry

lab20:
	cmp	ax,psFixed		;* Is is below or equal to the fixed entry?
	jbe	lab80			;* Yes -- move to next entry
	
	mov	si,es:[di].ga_handle	;* Get the blocks handle
	cmp	ds:[si].he_count,0	;* Is the block locked?
	jnz	l90			;* Yes -- exit the loop

	cmp	ax,psEOM		;* Is it above the fence?
	jae	lab80			;* Yes -- move to next entry
	
	push	ax			;* Get only overflow size
	add	ax,bx			;* Total size
	sub	ax,psEOM		;* Where are we relative to psEOM
	jbe	@F			;* End point is below psEOM -- bx = all
	sub	bx,ax			;* Subtract overflow
@@:
	pop	ax			;* Restore register
	add	cpFixedToEOM,bx		;* Add to amount between fixed and EOM
	add	cpUsedFixedToEOM,bx	;* Add to used amount between fixed and EOM

	test	es:[di].ga_flags,GA_DISCCODE ;* Is this a code segment?
	jz	lab80			;* No - move to next entry
	add	cpCodeInData,bx		;* Yes - add in
	sub	cpUsedFixedToEOM,bx	;* Add to used amount between fixed and EOM

lab80:
	mov	ax,es			;* Move to next entry
	cmp	ax,es:[di].ga_next	;* Last Entry? (next == cur)
	je	l90

	mov	ax,es:[di].ga_next	;* search forward along the link
	jmp	lab10
l90:

;-	No - return failure
;	-	If (amount of space < space needed) -- fail
	mov	ax,cpFixedToEOM
	sub	ax,cpUsedFixedToEOM
	cmp	dx,ax
	jbe	la10
	jmp	gfcExit

;*
;*	-	If ((Total Free space + Code in Data) < space needed) -- fail
;*
la10:
	mov	ax,cpTotalFree
	add	ax,cpCodeInData
	cmp	ax,dx
	jae	la20
	jmp	gfcExit

;*	Compute parameters for compaction
;*	Do the compaction
;*
;*	-	discard code as needed
;*		#paras = (Requested - (Total Free - Free Space below))
la20:
	push	dx			;* Save request size
	sub	dx,cpTotalFree		;* Compute amount of code to discard
	add	dx,cpFreeUnder		;*
	or	dx,dx			;* Do we need any?
	jle	la25			;* no --
	call	gdiscard

la25:	
	pop	dx			;* Restore Request size

;*
;*	-	Walk from this until sufficent free space has been covered
;*		Starting at fixed block
;*		free space = 0
;*		while (not to end of region) {
;*		    if (Block is free) {
;*		       add block size to free space
;*		       if (free space > space requested)
;*		          break;
;*		    } else {
;*			if (block is fixed) fail
;*			if (past fence) fail
;*		    go to next block
;*		}

	mov	es,psFixed		;* Starting at block to grow
	xor	cx,cx			;* Initially no free space found
	jmp	short la50		;* Move to next block

la30:	;*** Start of loop

	cmp	di,es:[di].ga_owner	;* Is the block free?
	jne	la40			;* No - jmp
					;* Yes (block was free)
	mov	bx,es:[di].ga_size	;* Get the size of the block
	inc	bx			;* Add one for handle
	add	cx,bx			;* Total free found to-date
	cmp	cx,dx			;* enough yet?
	jae	la60			;* Yes -- exit
	jmp	short la50		;* No  -- go to next block

la40:					;* was not a free block

la50:					;* Move to next block
	cmp	ax,es:[di].ga_next	;* Last entry in heap?
	je	la55			;* Yes -- exit

	mov	ax,es:[di].ga_next	;* Move to next entry
	mov	es,ax			;* Set up segment register
	jmp	la30			;* Go to start of loop

	;***	End of Loop

	;*	If we get here then we did not find enough area
	;*	We should therefore do an immediate fail
la55:
	jmp	gfcExit

	;*	Sufficent space has been found to do the shift up
	;*
la60:
;*
;*		assert current block is free
;*
	AssertEq di,es:[di].ga_owner
;*
;*		if (free space < space requested) fail
;*
	cmp	cx,dx
	jae	la70
	jmp	gfcExit
la70:
;*
;*	-	Compute end point
;*		if (free space == space requested) {
;*		    end point = current block
;*		} else {
;*		    delta = free space - space requested
;*		    split current block by removing last delta paras
;*		    current block = first of split pair
;*		}
	public	phase2
phase2:
	je	la80
	sub	cx,dx			;* extra free = Total Free - Space needed
	and	cx,NOT 1		;* make it even
					;* cx is now the number of excess
					;* paragraphs.
	jz	la80			;* if cx == 0 then start moving data
	mov	ax,es:[di].ga_next	;* Start of next heap entry
	sub	ax,cx			;* Less size of excess -- start of
					;* new block
	push	si			;* Set-up for subroutine call
	mov	si,ax
	call	gsplice			;* Create a new block
	pop	si
la80:
	mov	ax,es:[di].ga_prev	;* Move to previous heap entry
;		
;	-	walk down until fixed is found pushing each non-free segment
;		up and combining free segments
;		
;		move to previous block
;		while (block is not fixed) {
;		   if (block is free) {
;		      combine block and next block into a single
;			block
;		   } else {
;		      slide this block to end of next block
;		   }
;		   move to previous block
;		}
b10:
	mov	es,ax
	cmp	di,es:[di].ga_owner	;* Is this block free?
	jnz	b50			;* No - go to else clause
	
	push	es			;* save es
	mov	ax,es:[di].ga_next	;* Where is the next block
	mov	es,ax			;*
	cmp	di,es:[di].ga_owner	;* Is it free?
	pop	es			;* restore
	jnz	b90			;* No - move to next block in list
	
	mov	es,ax			;* Set-up for the join
	call	gjoin			;* Join together the free blocks
	jmp	b90			;* Move to the next block in the list

b50:					;* Not a free block
	mov	ax,es:[di].ga_next	;* Slide up in memory
	cCall	gfixedSlide,<ax,es>	;*
b90:
	mov	ax,es			;*
	AssertNe ax,es:[di].ga_prev	;* FIRST IN LOOP!!!!

	mov	ax,es:[di].ga_prev	;* Next forward
	cmp	ax,[psFixed]
	je	b99
	jmp	short b10

b99:
;		
;		assert next block is free
;		test size of next block >= requested
;		true - succeed
;		false - fail
;
gfcExit:
cEnd	gfixedCompact

sEnd	CODE

ENDIF	; REALLOC_FIXED
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\assertsw.c ===
/*
	COW : Character Oriented Windows

	assertsw.c : AssertFailed() procedures for swapped environment
*/

#define COW
#include <cow.h>

#include <kmem.h>
#include <kinput.h>
#include <uwindow.h>
#include <umenu.h>			/* Menu structure */
#include <uscreen.h>
#include <cwdebug.h>			/* debugging support */

#ifdef DEBUG	/* entire file for debug only */


VOID FAR cdecl	AssertPrintf(char *, ...);


PRIVATE VOID FAR
CowAssertFailedLine(szFile, ln)
/*
  -- print assert failed message
*/
char *szFile;
int ln;
	{
	AssertPrintf("Assertion failed: file %s, line %d\n", szFile, ln);
	AssertBreak();
	}



PRIVATE VOID FAR
CowAssertFailedSz(sz)
/*
  -- print assert failed message
*/
char *sz;
	{
	AssertPrintf("Assertion failed: %s\n", sz);
	AssertBreak();
	}

#endif /* DEBUG (entire file) */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\usdm.h ===
/*
	COW : Character Oriented Windows

	usdm.h : Definitions for SDM
*/


/***BEGIN_PUBLIC***/

typedef WORD TMC;		/* iTeM Codes */
typedef WORD DLM;		/* Dialog Messages */
typedef WORD TMM;		/* Control proc Messages */

/* standard item codes (tmc) */
#define	tmcNull		((TMC) 0)
#define	tmcOK		((TMC) 1)
#define	tmcOk		tmcOK
#define	tmcCancel	((TMC) 2)
#define	tmcSysMin	((TMC) 0x10)
#ifdef HELP_BUTTON
#define tmcHelp 	((TMC) tmcSysMin-1)
#endif
#define	tmcSysMax	((TMC) 0x100)
#define	tmcGrouped	0x8000		/* OR'd to specify whole group
					  as opposed to first button */
#define	tmcUserMin	tmcSysMax
#define	tmcUserMax	tmcGrouped



/* special ninch (No Input, No CHange) values */
#define	wNinch		(-32767)	/* ints */
#define	uNinch		(0xffff)	/* unsigned */
#define	iszNinchList	uNinch		/* listboxes */
#define	uNinchList	uNinch		/* other name */
#define	uNinchRadio	uNinch		/* radio groups */
#define	uNinchCheck	2		/* check boxes */
#define	wNinchCheck	uNinchCheck	/* old name */

/* special parse error values */
#define	wError		(-32766)	/* ints */
#define	uError		(0xfffe)	/* unsigneds */


/* command argument block header */
typedef struct _cabh
	{
	WORD	cwData;			/* total size of CAB less CABH */
	WORD	cagHandle;		/* # of handles */
	} CABH;

typedef void **HCAB;		/* CAB is just a concept, no real type */
typedef	void *PCAB;		/* pointer to CAB */

typedef	struct _dlg *PDLG;	/* Dialog pointer */

/* minimum CAB size : header + SAB */
#define	cwCabMin	((sizeof(CABH) + sizeof(WORD)) / sizeof(WORD))

/* Dialog Messages */
#define	dlmInit 	0	/* do custom initialization */
#define	dlmClick	1	/* item clicked */
#define	dlmChange	2	/* edit control may have changed */
#define	dlmKey		3	/* any untrapped key */
#define	dlmDblClk	4	/* double click in listbox/radio */

#define	dlmSetFocus	5	/* set focus */
#define	dlmKillFocus	6	/* lose focus */

#define	dlmTerm 	7	/* termination for one of many reasons */
#define	dlmIdle		8	/* idle for dialogs */

#define	dlmUnclick	9	/* item unclicked */

#define	dlmUserMin	16	/* for user extensions */


/* ListboxProc (pfnTm) messages */
#define	tmmCount	0	/* return number of items in listbox */
#define	tmmText 	1	/* return text associated with n'th item in listbox */
#define	tmmEditText	2	/* like msgText for Combo listboxes */

#define	cszUnknown	((WORD) -1)	/* return to tmmCount if unknown */

/* ParseProc (pfnTm) messages */
#define	tmmFormat	0	/* format data */
#define	tmmParse	1	/* parse data */
#define	tmmCwVal	2	/* return size of data in words */

/* RenderProc (pfnTm) messages */
#define	tmmPaint	0	/* paint yourself */


#define	tmmUserMin	16	/* for user extensions */


/* default no help */
#define	hidDlgNull	0	/* for no help */


/* macro to get void pointer to general CAB arg */
#define	PvParseArg(hObj, bArg) ((VOID *) (*((WORD *)(hObj)) + (bArg)))


/* Iag macro
   returns iag corresponding to field fld in application structure str
*/
#define Iag(str, fld)	((WORD)((int)&(((str *)0)->fld) / sizeof(int) - cwCabMin))


/* Globally Exported Function Definitions */
#ifdef CC

TMC		FARPUBLIC TmcDoDlg(VOID *, HCAB);
HCAB		FARPUBLIC HcabAlloc(WORD);
VOID		FARPUBLIC FreeCab(HCAB);
VOID		FARPUBLIC FreeCabData(HCAB);
VOID		FARPUBLIC SzToCab(HCAB, char *, WORD);
char *		FARPUBLIC SzFromCab(HCAB, char *, WORD, WORD);
VOID		FARPUBLIC PszToCab(HCAB, char **, WORD);	/*OPTIONAL*/

VOID		FARPUBLIC EnableTmc(TMC, BOOL);
BOOL		FARPUBLIC FEnabledTmc(TMC);
VOID		FARPUBLIC SetTmcVal(TMC, WORD);
WORD		FARPUBLIC GetTmcVal(TMC);
VOID		FARPUBLIC SetTmcSel(TMC, WORD, WORD);
VOID		FARPUBLIC GetTmcText(TMC, char *, WORD);
VOID		FARPUBLIC SetTmcText(TMC, char *);
VOID		FARPUBLIC SetFocusTmc(TMC);
VOID		FARPUBLIC RedisplayListBox(TMC);
VOID		FARPUBLIC RedisplayListBoxOriented(TMC, WORD *, WORD *); /*OPTIONAL*/
VOID		FARPUBLIC GetTmcListBoxOrientation(TMC, WORD *, WORD *); /*OPTIONAL*/
VOID		FARPUBLIC RedisplayTmc(TMC);
VOID		FARPUBLIC SetDefaultTmc(TMC);
WORD		FARPUBLIC ParseInt(WORD, char *, HANDLE, TMC, WORD, WORD); /*OPTIONAL*/
VOID		FARPUBLIC SetTmcListWidth(TMC, WORD);		/*OPTIONAL*/
VOID		FARPUBLIC SetTmcEditWidth(TMC, WORD);		/*OPTIONAL*/

VOID		FARPUBLIC InitCab(HCAB, WORD);
VOID		FARPUBLIC ReinitCab(HCAB, WORD);

PWND		FARPUBLIC PwndOfListbox(TMC);
#define	TmcListBoxResetcontent(tmc)	\
	SendMessage(PwndOfListbox(tmc), LB_RESETCONTENT, 0, 0L)
#define	TmcListBoxAddstring(tmc,sz,fRedraw)	\
	SendMessage(PwndOfListbox(tmc), LB_ADDSTRING, (WORD) sz, MAKELONG(fRedraw,0))
#define	TmcListBoxInsertstring(tmc,sz,isz,fRedraw)	\
	SendMessage(PwndOfListbox(tmc), LB_INSERTSTRING,(WORD)sz, MAKELONG(fRedraw,isz))
#define	TmcListBoxDeletestring(tmc,isz,fRedraw)	\
	SendMessage(PwndOfListbox(tmc), LB_DELETESTRING, 0, MAKELONG(fRedraw,isz))
#define	TmcListBoxReplacestring(tmc,sz,isz)	\
	SendMessage(PwndOfListbox(tmc), LB_REPLACESTRING, (WORD) sz, MAKELONG(0,isz))
#define TmcListBoxRepaint(tmc)	\
	SendMessage(PwndOfListbox(tmc), WM_PAINT, 0, 0L)
#define TmcGetClientRrc(tmc,prrc)	\
	GetClientRrc(PwndOfListbox(tmc), prrc)

#endif /*CC*/

/***END_PUBLIC***/

/* locking not allowed */
PCAB		FARPUBLIC PcabLockCab(HCAB);
VOID		FARPUBLIC UnlockCab(HCAB);
/* should not be needed : take out later ??? */
VOID		FARPUBLIC StToCab(HCAB, char *, WORD);
VOID		FARPUBLIC RgbToCab(HCAB, BYTE *, WORD, WORD);
char *		FARPUBLIC StFromCab(HCAB, char *, WORD, WORD);
BYTE *		FARPUBLIC RgbFromCab(HCAB, BYTE *, WORD, WORD);

#ifdef COW

/******************************************************************/
/* Information that is tightly bound to the contents of this file */
/******************************************************************/


/* CABX : primative CAB type */

typedef struct _cabx
	{
	CABH	cabh;			/* header */
	WORD	sab;			/* sub dialog word - always present */
	HANDLE	rgh[1];			/* where handles start */
	} CABX; /* NOTE : never use sizeof(CABX) */

#define	cbCabOverhead	(sizeof(CABX) - sizeof(HANDLE))

typedef CABX	*PCABX;
typedef CABX	**HCABX;

/* macro to get temporary pointer to CABX from a HCAB */
#define PcabxOfCab(hcab)	((CABX *)(*(hcab)))
/* macro to get handle (usually a psz) */
#define PpvFromCab(hcab, iag) ((VOID **)(PcabxOfCab(hcab)->rgh[iag]))

#endif /*COW*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\uedit.h ===
/*    	COW : Character Oriented Windows

	uedit.h: Definitions for user Edit
*/

/***BEGIN_PUBLIC***/

#ifndef NOWNDMACROS

#define wndEdit(id, fBorder, fEnabled, ax, ay, dax, day, pwndParent, pwndSibbling, szBuf, cchMax, chFill, isa, isaSel) {\
	id, WS_CHILD | WS_EDIT | (fBorder ? WS_BORDER : 0), \
	0, fEnabled, {ax, ay, ax+dax, ay+day}, \
	{((fBorder) ? ax+1 : ax), (fBorder ? ay+1 : ay), \
	 ((fBorder) ? ax+dax-1 : ax+dax), (fBorder ? ay+day-1 : ay+day)}, \
	(PLFN) InternalEditWndProc, pwndParent, pwndSibbling, NULL, 0, 0, \
	{0, (WORD) szBuf, cchMax, isa, isaSel, chFill, 0, 0, 0, 0, TRUE, 0, \
	 (WORD) szBuf}}
/* InternalEditWndProc must be forward defined for CS compiler */
DWORD 		FARPUBLIC InternalEditWndProc(PWND, WORD, WORD, DWORD);

#endif /* !NOWNDMACROS */

/* for selection (SetTmcSel) */
#define	ichSelectEnd	(0x7fff)		/* select to end */


VOID		FARPUBLIC SetEditText(PWND, char *, BOOL);
VOID		FARPUBLIC SetEditWidth(PWND, WORD);	/* OPTIONAL */
WORD		FARPUBLIC GetEditText(PWND, char *, WORD);
DWORD		FARPUBLIC EditWndProc(PWND, WORD, WORD, DWORD);
VOID		FARPUBLIC DefaultEditMgrInit(VOID);	/* OPTIONAL */

#define EN_CHANGE			1
#define EN_CURSORMOVED			2

/***END_PUBLIC***/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\graphic.h ===
/*
	CW: Character Oriented Windows
	
	graphic.h: Graphics Interface Layer
*/

#include <ingxd.h>				/* installable driver */

/***BEGIN_PUBLIC***/

extern BOOL PASCAL fPrinting;

/*****************************************************************************/
/* Graphic Drawing Procedures */

BOOL	FARPUBLIC FLoadGsd(char *);
BOOL	FARPUBLIC FLoadGpd(char *);
VOID	FARPUBLIC SetPrinting(BOOL);

BOOL	FARPUBLIC FInitGraphics(VOID *, VOID FAR *);
VOID	FARPUBLIC TermGraphics(void);
VOID	FARPUBLIC Move(WORD, WORD);
VOID	FARPUBLIC Draw(WORD, WORD);
VOID	FARPUBLIC SetAreaPat(WORD);
VOID	FARPUBLIC SetLinePat(WORD);
VOID	FARPUBLIC SetLineWeight(WORD);
VOID	FARPUBLIC SetColor(WORD, WORD);
VOID	FARPUBLIC Text(char far *, WORD, WORD, WORD, int);
VOID	FARPUBLIC Rectangle(struct _rect far *);
VOID	FARPUBLIC Arc(struct _rect far *, int, int);
VOID	FARPUBLIC Polygon(struct _polygon far *);
VOID	FARPUBLIC BitBlt(struct _rect far *, BYTE far *, WORD, BOOL);

/***END_PUBLIC***/

/*****************************************************************************/
/* COW private info */

extern INDJ	indjGsd;		/* jump vectors for screen driver */
extern INDJ	indjGpd;		/* jump vectors for printer driver */

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\os2.h ===
/*
	os2.h : OS/2 calls (from DOSCALLS.H)
	NOTE : these procedures are mixed case and use machine independent
		parameters (i.e. WORD, DWORD).
*/

#define	OS2CALL	extern WORD FAR PASCAL

/* Semaphores */
OS2CALL		DosSemClear(DWORD);
OS2CALL		DosSemRequest(DWORD, long);
OS2CALL		DosSemSet(DWORD);
OS2CALL		DosSemSetWait(DWORD, long);
OS2CALL		DosSemWait(DWORD, long);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\itl.inc ===
;*
;*	COW : Character Oriented Windows
;*
;*	itl.inc	: Internationalization header (for assembler)
;*	(LOADER stuff only)


IFDEF LANGUAGE_ENGLISH

szErrNotOnPath	EQU	"program is not on search path"
szErrEnviron	EQU	"invalid environment"
szErrMemory	EQU	"insufficient memory"
szErrProgram	EQU	"invalid program file"

ENDIF ;LANGUAGE_ENGLISH
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\handle.h ===
/*
	COW : Character Oriented Windows

	handle.h : Handle information
*/

#define HE_SWAPPED      0x80
#define HE_DISCARDED    0x40
#define HE_SHAREALL     0x20
#define HE_SHARE        0x10
#define HE_DISCARDABLE  0x0F

#define HE_FREEHANDLE   0xFFFF

typedef struct
    {
    WORD    he_address;
    BYTE    he_flags;
    BYTE    he_count;
    } HANDLEENTRY;
typedef HANDLEENTRY *PHANDLEENTRY;
typedef HANDLEENTRY FAR *LPHANDLEENTRY;

typedef struct
    {
    WORD	ht_count;
    HANDLEENTRY ht_entry[ 1 ];
    } HANDLETABLE;
typedef HANDLETABLE *PHANDLETABLE;
typedef HANDLETABLE FAR *LPHANDLETABLE;

typedef struct
    {
    WORD    he_link;
    WORD    he_free;
    } FREEHANDLEENTRY;
typedef FREEHANDLEENTRY *PFREEHANDLEENTRY;
typedef FREEHANDLEENTRY FAR *LPFREEHANDLEENTRY;
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\cowextra.h ===
/*
	COW : Character Oriented Windows

	cowextras.h : Extra routines in COW
	(do not rely on these routines : unofficially exported / supported)
*/

DWORD		FARPUBLIC SendMessageToSibbling(PWND, WORD, WORD, DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\gcompact.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	gcompact.asm : global compaction
;*	* NOTE :assumes stack never moves !

	TITLE	GCOMPACT - Global memory compactor

	.xlist
	include kernel.inc
	include galloc.inc
	.list


;*****************************************************************************

sBegin	DATA

externW     <psLom>

;*************************** compact kludge ***********************
globalB     fCompactLowerHeap,0


sEnd	DATA

;*****************************************************************************


sBegin	KERNEL
    assumes CS,KERNEL
    assumes DS,NOTHING			;* DS == pGlobalHeap
    assumes SS,DATA

; These are all the external subroutines needed by this source file.
;
externNP    <genter>			; GINTERF.ASM
externNP    <gjoin,gmarkfree,gcheckfree>; GALLOC.ASM
externNP    <gnotify>			; GINTERF.ASM

; These are all of the internal subroutines defined in this source file.
;
	PUBLIC	gcompact		;* compact global heap
	PUBLIC	gmovebusy

IFDEF DEBPUB
	PUBLIC	gmove, gmoveable, gslidecommon
	PUBLIC	gcmpheap, gslide, gbestfit, gdiscard
ENDIF

SUBRS	PROC	NEAR


; Subroutine to move a moveable block into the top part of a free block
; The low order bit of the source and destination may be either set or
; reset.  If set, then this routine does NOT move the arena header paragraph.
; If the bit is reset, then the arena header is moved.	Only the low order
; bit of SI is examined, and the low order bit of ES is assumed to the same.
;
;   Inputs:	ES:0  = address of destination block
;		SI:0  = address of source block
;

gmove:
	push	es
	push	si
	push	di
	push	ax
	push	bx
	push	cx
	push	dx

	mov	dx,si			; DX = 0 if moving arena header too
	and	dx,1			; and 1 if not.

	push	es			; Save destination
	mov	cx,es			; CX = client data address of dest.
	or	cl,1

	mov	ax,si			; ES:DI = arena header of source
	xor	ax,dx			;
	mov	es,ax

	xor	dl,1			; DX = #paragraphs to move
	add	dx,ES:[di].ga_size
	push	dx			; Save #paragraphs

	mov	ax,GN_MOVE
	mov	bx,ES:[di].ga_handle	; BX = handle of source
	or	bx,bx
	jnz	gm1
	mov	bx,es
	inc	bx
gm1:
	push	es
	mov	dx,es:[di].ga_owner	;* set up owner for gnotify
	call	gnotify 		; Call global notify procedure
	pop	cx
	inc	cx
	pop	dx			; DX = #paragraphs to move
	pop	di			; DI = destination

	; Save DS value AFTER call to gnotify, as it might be the one
	; we are moving and thus changed by the global heap notify proc.
	push	ds

	mov	ax,dx			; AX:0 = end of source
	add	ax,si
	mov	bx,dx			; BX:0 = end of destination
	add	bx,di

	cmp	si,di			; Moving up towards high memory?
	jb	move0a			; Yes, all set
	mov	ax,si			; No, start at beginning of source
	mov	bx,di			; ... and destination
move0a:

; AX:0 = end of source
; BX:0 = end of destination
; DX   = #paragraphs left to move
;
move1:
	mov	cx,1000h	    ; Can only move 64k at a time
	cmp	dx,cx		    ; More than that left?
	jae	move2		    ; Yes, just move 64k bytes
	mov	cx,dx		    ; No, move what is left then
	jcxz	move3		    ; All done if nothing left to move
move2:
	sub	dx,cx		    ; DX = #paragraphs left after this xfer
	mov	si,cx
	shl	cx,1		    ; CX = #words to move
	shl	cx,1
	shl	cx,1

	cmp	ax,bx		    ; Moving up towards high memory?
	jb	move2a		    ; Yes, handle separately

	cld
	mov	ds,ax		    ; DS:SI = first word in source block
	mov	es,bx		    ; ES:DI = first word in dest. block
	add	ax,si		    ; AX:0 = end of source block this xfer
	add	bx,si		    ; BX:0 = end of dest. block this xfer
	xor	si,si
	jmp	short move2b
move2a:
	std
	sub	ax,si		    ; AX:0 = beginning of source block this xfer
	sub	bx,si		    ; BX:0 = beginning of dest. block this xfer
	mov	si,cx
	dec	si
	shl	si,1
	mov	ds,ax		    ; DS:SI = last word in source block
	mov	es,bx		    ; ES:DI = last word in dest. block
move2b:
	mov	di,si
	rep	movsw		    ; move this section
	jmp	move1		    ; Back for more
move3:
	pop	ds		    ; Restore DS (it might be different)
	pop	dx		    ; Restore registers
	pop	cx
	pop	bx
	pop	ax
	pop	di
	pop	si
	pop	es
	cld		    ; Protect people like MarkCl from themselves
	ret

; Subroutine to compact the global heap
;
;   Inputs:	DX = minimum #contiguous bytes needed
;		DS:DI = address of global heap information
;
;   Outputs:	AX = size of largest contiguous free block
;		ES:DI = arena header of largest contiguous free block
;		DX = minimum #contiguous bytes needed
;
;   Destroys:	CX
;

gcompact:
	push	si

gcompactl:
	push	dx		    ; Save requested size
	cmp	fCompactLowerHeap,0 ; See if only compacting lower heap
	jz	gcompactn	    ; no normal compact
	mov	es,[di].hi_first    ; Yes, compact lower heap
	mov	bx,ga_next
	jmp	short gcompact1a    ; Now see any special flags

gcompactn:
	cmp	[di].gi_reserve,di  ; Is there a reserve swap area?
	je	gcompact1	    ; No, then dont compact lower heap
	mov	es,[di].hi_first    ; Yes, compact lower heap
	mov	bx,ga_next
	push	dx
	call	gcmpheap
	pop	dx
gcompact1:
	mov	es,[di].hi_last     ; Compact upper heap
	mov	bx,ga_prev
gcompact1a:
	call	gcmpheap
	pop	dx		    ; Get requested size
	mov	es,ax		    ; ES points to largest free block
	or	ax,ax		    ; Did we find a free block?
	jz	gcompact2	    ; No, try discarding
	call	gcheckfree	    ; Yes, see if block big enough
	jae	gcompactx	    ; Yes, all done
gcompact2:			    ; Discarding allowed?
	test	byte ptr [di].gi_cmpflags,GA_NODISCARD+GA_NOCOMPACT
	jnz	gcompactx	    ; No, return
	call	gdiscard	    ; No, try discarding
	jnz	gcompactl	    ; Compact again if something discarded
gcompactx:
	pop	si		    ; Restore SI
	ret

gcmpheap:
	mov	cx,[di].hi_count
	xor	ax,ax		    ; Nothing found yet
	push	ax		    ; Save largest free block so far
gchloop:
	cmp	es:[di].ga_owner,di
	je	gchfreefnd
gchnext:
	mov	es,es:[bx]
	loop	gchloop
	pop	ax		    ; Return largest free block in AX
	ret

gchfreefnd:					; Compaction allowed?
	test	byte ptr [di].gi_cmpflags,GA_NOCOMPACT
	jnz	gchmaxfree			; No, just compute max free.
;*	* if compacting upper heap, the free block must be just before another
;*	*  code block (or the end of the heap)
	push	es
	cmp	bl,ga_prev		;* upper heap ??
	jne	no_hack 		;* lower heap normal
	test	byte ptr ds:[di].gi_cmpflags,GA_DISCCODE
	jz	no_hack 		;* hack is only for discardable code
	cmp	dx,es:[di].ga_size
	ja	no_hack 		;* to small to fit anyway
	mov	es,es:[di].ga_next	;* next block (CODE or END)
	test	es:[di].ga_flags,GA_DISCCODE
	jnz	hack			;* it is code, we can use it
	mov	ax,es
	cmp	ax,ds:[di].hi_last
	je	hack
;*	* we are looking for code in the upper heap but the only free block
;*	*  that is available is not connected to the upper heap, hence we
;*	*  can't use it.
	pop	es
	pop	ax
	xor	ax,ax			;* fail, try to discard to get
					;*  legitimate space out of the code
					;*  swap area.
	ret

hack:
	pop	es
	pop	ax
	mov	ax,es			;* use this block only
	ret

no_hack:
	pop	es			;* restore es from hack check
	call	gslide
	jnz	gchfreefnd
	call	gbestfit
	jnz	gchfreefnd
gchmaxfree:
	cmp	bl,ga_prev	    ; Compacting upper heap?
	jne	gchnext 	    ; No, then dont compute largest free block
	pop	si		    ; Recover largest free block so far
	mov	ax,es		    ; AX = current free block
	cmp	si,ax		    ; Same as current?
	je	gchmf2		    ; Yes, no change then
	cmp	ES:[di].ga_owner,di ; No, is current free?
	jne	gchmf2		    ; No, ignore it then
	or	si,si		    ; Yes, First time?
	jz	gchmf1		    ; Yes, special case
	cmp	ds:[di].gi_reserve,di	; Is there a code reserve area?
	je	gchmf0			; No, continue
	test	byte ptr ds:[di].gi_cmpflags,GA_DISCCODE ; Yes, use only first free
	jnz	gchmf2		    ; block if allocating discardable code
gchmf0:
	push	es
	mov	es,si
	mov	ax,ES:[di].ga_size  ; No, get size of largest free block
	pop	es		    ; Compare with size of this free block
	cmp	ES:[di].ga_size,ax  ; Is it bigger?
	jb	gchmf2		    ; No, do nothing
gchmf1: mov	si,es		    ; Yes, remember biggest free block
gchmf2: push	si		    ; Save largest free block so far
	jmp	gchnext 	    ; Go process next block


; Subroutine to test if an object is moveable
;
;   Inputs:	ES:DI = arena header of object
;		DS:DI = address of global heap information
;		BX = ga_next or ga_prev
;
;   Outputs:	Z flag clear if object moveable
;		Z flag set if object not moveable
;
;   Destroys:	SI
;

gmoveable:
	mov	si,es:[di].ga_handle
	or	si,si				; If no handle then fixed
	jz	gmfixed
	cmp	[si].he_count,bh		; If locked then fixed
	jne	gmfixed
;**** compact kludge ****
	cmp	fCompactLowerHeap,bh		; see if in special mode
	jnz	gmokay				; Yes allow anything to move
	test	es:[di].ga_flags,GA_DISCCODE	; If discardable code
	jz	gmnotcode
	cmp	bl,ga_next			; Discardable code can only
	ret					; move up in memory
gmnotcode:
	cmp	[di].gi_reserve,di		; If no reserved code area?
	je	gmokay				; Then anything can move up
	cmp	bl,ga_prev			; Otherwise can only move down
	ret					; in memory
gmfixed:
	xor	si,si				; Return zero if fixed
gmokay:
	or	si,si				; Return with Z flag set if
	ret					; not moveable


; Subroutine to see if next/previous block can slide into the
; passed free block.
;
;   Inputs:	ES:DI = free block
;		DS:DI = address of global heap information
;		CX = #arena entries left to examine
;		BX = ga_next or ga_prev
;
;   Outputs:	Z flag clear if block found and moved into passed free
;		block and ES:DI point to new free block
;
;		Z flag set if no block found and ES:DI points to
;		original free block
;
;   Destroys:	AX,DX,SI
;

gslide:
	push	es
	mov	es,es:[bx]
	mov	ax,es
	mov	dx,es:[di].ga_size
	call	gmoveable
	pop	es
	jnz	gslidecommon
	ret
gslidecommon:			    ; Enter here from gbestfit
				    ; moving non-contiguous blocks
	mov	si,ax		    ; Source is busy block
	inc	dx		    ; DX = busy.ga_size + 1
	cmp	bl,ga_next
	je	gslidedown

; Here to slide moveable block up to high end of free block.
;
; Free and busy block adjacent
;     0000:0	|	    |		    |		|
;		|-----------|	     a ->   |-----------|
;		|   busy    |		    |	free  ? |
;		|-----------|		    |		|
;		|   free    |	     b ->   |-----------|
;		|	    |		    | ? busy  ? |
;		|-----------|	     c ->   |-----------|
;     FFFF:0	|	    |		    | ? 	|
;
;
;	a = busy
;	b = free.ga_next - busy.ga_size - 1
;	c = free.ga_next
;	destination = b
;
; Free and busy block NOT adjacent
;     0000:0	|	    |		    |		|
;		|-----------|		    |-----------|
;		|   busy    |		    |	free	|
;		|-----------|		    |-----------|
;		|	    |		    |		|
;		|-----------|	     a ->   |-----------|
;		|   free    |		    |	free  ? |
;		|	    |	     b ->   |-----------|
;		|	    |		    | ? busy  ? |
;		|-----------|	     c ->   |-----------|
;     FFFF:0	|	    |		    | ? 	|
;
;
;	a = free
;	b = free.ga_next - busy.ga_size - 1
;	c = free.ga_next
;	destination = b
;
gslideup:
	mov	ax,es:[di].ga_next
	push	ax			; Save c
	sub	ax,dx
	push	ax			; Save b
	cmp	es:[bx],si		; Are blocks adjacent?
	je	gslideup1
	push	es			; No, a = free
	jmp	short gslideup2
gslideup1:
	push	si			; Yes, a = busy
gslideup2:
	mov	es,ax			; Destination is b
	xor	ax,ax			; a.ga_prev will remain valid
	jmp	short gslidemove

; Here to slide moveable block down to low end of free block.
;
; Free and busy block adjacent
;     0000:0	|	    |		    |		|
;		|-----------|	     a ->   |-----------|
;		|   free    |		    | ? busy  ? |
;		|	    |	     b ->   |-----------|
;		|-----------|		    | ? free  ? |
;		|   busy    |		    |		|
;		|-----------|	     c ->   |-----------|
;     FFFF:0	|	    |		    | ? 	|
;
;	a = free
;	b = free + busy.ga_size + 1
;	c = busy.ga_next
;	destination = free
;
; Free and busy block NOT adjacent
;     0000:0	|	    |		    |		|
;		|-----------|	     a ->   |-----------|
;		|   free    |		    | ? busy  ? |
;		|	    |	     b ->   |-----------|
;		|	    |		    | ? free  ? |
;		|-----------|	     c ->   |-----------|
;		|	    |		    | ? 	|
;		|-----------|		    |-----------|
;		|   busy    |		    |	free	|
;		|-----------|		    |-----------|
;     FFFF:0	|	    |		    |		|
;
;
;	a = free
;	b = free + busy.ga_size + 1
;	c = free.ga_next
;	destination = free
;

gslidedown:
	cmp	es:[bx],si		; Are blocks adjacent?
	je	gslidedn1
	push	es:[di].ga_next 	; No, c = free.ga_next
	jmp	short gslidedn2
gslidedn1:
	add	ax,dx			; Yes, c = busy.ga_next
	push	ax
gslidedn2:
	mov	ax,es
	add	ax,dx
	push	ax			; Save b
	push	es			; Save a
	mov	ax,es:[di].ga_prev	; a.ga_prev must be restored after move
gslidemove:
	call	gmove
	mov	si,es			; Save new busy block location
	pop	es			; ES = a
	or	ax,ax			; Does a.prev need to be restored?
	jz	gslide1 		; No, continue
	mov	es:[di].ga_prev,ax	; Yes, do it
gslide1:
	pop	ax
	mov	es:[di].ga_next,ax	; a.ga_next = b
	mov	dx,es
	mov	es,ax
	mov	es:[di].ga_prev,dx	; b.ga_prev = a
	pop	ax
	mov	es:[di].ga_next,ax	; b.ga_next = c
	mov	dx,es
	mov	es,ax
	mov	es:[di].ga_prev,dx	; c.ga_prev = b
	mov	es,si			; ES = new busy block
	mov	si,es:[di].ga_handle	; SI = handle
	or	si,si
	jz	gslide2
	mov	ax,es
	inc	ax
	mov	ds:[si].he_address,ax	; Update client address
gslide2:
	mov	es,es:[bx]		; Move to new free block
	mov	ax,es:[di].ga_next	; Set size and signature
	mov	si,es			; byte fields of new free block
	sub	ax,si
	dec	ax
	mov	es:[di].ga_size,ax
	mov	es:[di].ga_sig,GA_SIGNATURE
	mov	es:[di].ga_flags,0
	mov	es:[di].ga_handle,di
	call	gmarkfree		; Coelesce new free block
	or	ax,ax
	ret


; Subroutine to search for the largest moveable block that
; will fit in the passed free block.
;
;   Inputs:	ES:DI = free block
;		DS:DI = address of global heap information
;		CX = #arena entries left to examine
;		BX = ga_next or ga_prev
;
;   Outputs:	Z flag set if block found and moved into passed free
;		block with no extra room.
;		ES:DI = busy block before/after new busy block.
;
;		Z flag clear if ES:DI points to a free block, either the
;		original one or what is left over after moving a block
;		into it.
;
;   Destroys:	DX,SI
;

gbestfit:
	push	es
	push	cx
	xor	si,si		    ; Have not found anything yet
	mov	dx,ES:[di].ga_size  ; Compute max size to look for
gbfloop:
	cmp	ES:[di].ga_owner,di ; Is this block busy?
	je	gbfnext 	    ; No, continue
	push	si
	call	gmoveable	    ; Yes, is it moveable
	pop	si
	jz	gbfnext 	    ; No, continue
	cmp	ES:[di].ga_size,dx  ; Yes, is block bigger than max size?
	ja	gbfnext 	    ; Yes, continue
	or	si,si		    ; First block we have found?
	jz	gbf1st		    ; Yes, special case
	push	es
	mov	es,si
	mov	ax,ES:[di].ga_size  ; No, get size of largest block so far
	pop	es		    ; Compare with this block
	cmp	ES:[di].ga_size,ax  ; Is it bigger than the largest so far?
	jbe	gbfnext 	    ; No, continue
gbf1st:
	mov	si,es		    ; Yes, remember biggest block
	mov	ax,ES:[di].ga_size  ; ...and size
gbfnext:
	mov	es,ES:[bx]	    ; Skip past this block
	loop	gbfloop
	pop	cx		    ; All done looking
	pop	es
	or	si,si		    ; Did we find a block?
	jz	gbestfit1	    ; No, return with Z flag
	call	gmovebusy	    ; Yes, move it into free block
gbestfit1:
	ret

; Subroutine to move a busy block to a free block of the same size,
; preserving the appropriate arena header fields, freeing the old
; busy block and updating the handle table entry to point to the
; new location of the block
;
;   Inputs:	SI = old busy block location
;		ES:DI = new busy block location
;		DS:DI = address of global heap information
;
;   Outputs:	ES:DI = points to new busy block arena header
;
;   Destroys:	AX,SI
;

gmovebusy:
	push	cx
	push	dx
	mov	ax,es
	mov	cx,es:[di].ga_size  ; CX = size of destination
	cmp	es:[di].ga_owner,di ; Is destination busy?
	mov	es,si
	mov	dx,es:[di].ga_size  ; DX = size of source
	jne	gmbexactfit	    ; Yes, then dont create extra block
	cmp	cx,dx		    ; No, are source and destination same size?
	je	gmbexactfit	    ; Yes, then dont create extra block

	mov	es,ax		    ; ES = destination
	mov	ax,si		    ; AX = source
	push	si		    ; Save busy block address
	call	gslidecommon	    ; Call common code to do the move
	inc	[di].hi_count	    ; Just created a new arena entry
	mov	ax,es		    ; Save new free block address
	pop	es		    ; Get old busy block address
	call	gmarkfree	    ; Mark as free and coalesce
	mov	es,ax		    ; Restore new free block address
	or	ax,ax		    ; Return with Z flag clear.
	jmp	gmbexit

gmbexactfit:
	inc	si			; SI = old client data address
	mov	cl,ES:[di].ga_flags
	push	ES:[di].ga_owner
	mov	es,ax
	pop	ES:[di].ga_owner	; Copy client words to new header
	mov	ES:[di].ga_flags,cl
	inc	ax
	mov	es,ax			; ES = new client data address
	call	gmove			; Move the client data
	dec	si
	mov	es,si			; ES:DI = old arena header
	call	gmarkfree		; Free old block
	dec	ax
	mov	es,ax			; ES:DI = new arena header
	inc	ax
	or	si,si
	jz	gmb1
	mov	[si].he_address,ax	; Set new client data address
	mov	ES:[di].ga_handle,si	; Set back link to handle in new block
	xor	si,si			; Set Z flag
gmb1:
gmbexit:
	pop	dx
	pop	cx
	ret

; Subroutine to walk segment list, discarding objects until the #paras
; discarded, plus the biggest free block is greater than the #paras
; we are looking for.
;
;   Inputs:	ES:DI = largest free block
;		AX = size of largest free block
;		DX = minimum #paras needed
;		DS:DI = address of global heap information
;
;   Outputs:	Z flag clear if one or more objects discarded.
;
;		Z flag set if no objects discarded.
;
;   Destroys:	BX,CX,SI
;

gdiscard:
	push	es
	push	ax
	push	dx

	mov	[di].hi_ncompact,0	; Clear compaction flag
	sub	dx,ax			; How much to discard before
	mov	[di].hi_distotal,dx	; compacting again.
	mov	es,ds:[di].hi_last
	mov	cx,es			; Assume no discard fence
	cmp	ds:[di].gi_reserve,di	; True if no reserve area
	je	gdstart
	test	byte ptr ds:[di].gi_cmpflags,GA_DISCCODE    ; or code request
	jnz	gdstart
gdloop0:
	mov	es,es:[di].ga_prev
	cmp	es:[di].ga_owner,di
	je	gdfence
	test	es:[di].ga_flags,GA_DISCCODE
	jnz	gdloop0
gdfence:
	sub	cx,ds:[di].gi_reserve	; Compute beginning of reserve area
	cmp	cx,es:[di].ga_next	; Does all disc. code lie within it?
	jbe	gdstart 		; Yes, set discard fence
	mov	cx,ds:[di].hi_last	; No, then no discard fence
gdstart:
	mov	ds:[di].gi_disfence,cx	; Set the discard fence
gdloop:
	call	ggetlru 		;* get least recently used code handle
	jz	gdexit			; No, more see if we discarded anything
					;* ignore items below swap fence

IFDEF DEBUG
	cmp	[si].he_count,0 	; Is this handle locked?
	je	gd_not_locked
	cCall	CowAssertFailed 	;* we do not support code locking
gd_not_locked:
ENDIF ;DEBUG
	mov	bx,[si].he_address
	dec	bx
	mov	es,bx			;* es:0 => arena
	mov	bx,si			; BX = handle
	mov	al,GN_DISCARD		; AX = GN_DISCARD
	mov	dx,es:[di].ga_owner	;* set up owner for gnotify
	push	dx			;* save owner
	push	[si].he_address 	;* save original address
	call	gnotify

	pop	ax			;* original address
	dec	ax
	mov	es,ax			; ES:DI = address of block to free
	mov	dx,es:[di].ga_size	; Save size !!!
	call	gmarkfree		; Free the block associated with this handle
					;* DX not trashed !!
	pop	[si].he_address 	; Remember owner in handle table entry
	or	[si].he_flags,HE_DISCARDED  ; ...and mark discarded
	mov	[di].hi_ncompact,1	; Remember we discarded something
	sub	[di].hi_distotal,dx	; Have we discarded enough yet?
	ja	gdloop			; No, look at next handle
gdexit:
	cmp	[di].hi_ncompact,0	; Return with Z flag set or clear
	pop	dx
	pop	ax
	pop	es
	ret


;********** ggetlru **********
;*	entry : DI = 0
;*	* scan LRU table, return handle to code segment to discard
;*	* Note : this is a simple scan to find the maximum segref
;*	*  (later on make more efficient depending on code requirements needed).
;*	* NOTE : ignores items that are above swap fence
;*		(swap fence (gi_disfence) should not be set for GA_DISCCODE
;*		   allocations).
;*	exit : Z => no more left
;*		else SI = handle

ggetlru:
	push	bp
	mov	bp,ds:[di].gi_disfence		;* swap fence limit

	mov	es,psLom
	mov	cx,es:[neLom.ne_cseg]
	dec	cx				;* count of code segments
	mov	si,es:[neLom.ne_psegrefbytes]
	mov	di,es:[neLom.ne_segtab] 	;* point to segtab
;*	* note : DI != 0
	xor	dx,dx				;* null return (handle)
	xor	ah,ah				;* see if you can beat or match 0

gget_loop:
	lods	byte ptr es:[si]		;* al = segref
	cmp	al,ah
	jl	gget_next			;* too small
;*	* test to see if below swap fence
	mov	bx,es:[di].ns_handle		;* get handle
	cmp	[bx].he_address,bp		;* above swap fence ?
	jae	gget_next			;* above => don't discard.
;*	* the new maximum (so far)
	mov	dx,bx				;* new handle
	mov	ah,al				;* new maximum segref
gget_next:
	add	di,SIZE NEW_SEG1
	loop	gget_loop
;*	* dx = handle of discardable segment with largest seg-ref (lru)
	mov	si,dx
	xor	di,di				;* restore DI
	or	si,si				;* z=> none found
	pop	bp
	ret

SUBRS	ENDP


;*****************************************************************************


sEnd	KERNEL

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\assertns.c ===
/*
	COW : Character Oriented Windows

	assertns.c : AssertFailed() procedures for DOS 3/5 non-swapped
*/

#define COW
#include <cow.h>

#include <kinput.h>	/* for EndCow() */

#define LINT_ARGS
#include <stdio.h>
#include <process.h>	/* for exit() */


#ifdef DEBUG	/* entire file for debug only */

#define	exAssert	99


PUBLIC VOID FAR PASCAL CowAssertFailed(void);	/* called from assembler */


PRIVATE VOID FAR PASCAL
CowAssertFailedLine(szFile, ln)
/*
  -- print assert failed message
*/
char *szFile;
int ln;
	{
	printf("COW Assertion failed: %s(%d)\n", szFile, ln);
	EndCow(FALSE);
	exit(exAssert);
	}



PRIVATE VOID FAR PASCAL
CowAssertFailedSz(sz)
/*
  -- print assert failed message
*/
char *sz;
	{
	printf("COW Assertion failed: %s\n", sz);
	EndCow(FALSE);
	exit(exAssert);
	}


PRIVATE VOID FAR PASCAL		/* always far */
CowAssertFailed()
/*
  -- low level assert failed
*/
	{
	printf("COW Assertion failed (assembler)\n");
	EndCow(FALSE);
	exit(exAssert);
	}


#endif /* DEBUG (entire file) */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\uscroll.h ===
/*
	COW : Character Oriented Windows

	uscroll.h: Definitions for User Scroll
*/

/***BEGIN_PUBLIC***/

#ifndef NOSUBSTYLES
/* Scroll bar constants */
#define	SBS_HORZ			0
#define	SBS_VERT			1
#endif /*!NOSTYLES*/


#ifndef NOSCROLL

/* Scroll Commands */
#define	SB_LINEUP		0
#define	SB_LINEDOWN		1
#define	SB_PAGEUP		2
#define	SB_PAGEDOWN		3
#define	SB_THUMBPOSITION	4
#define	SB_THUMBTRACK		5
#define	SB_TOP			6
#define	SB_BOTTOM		7
#define SB_ENDSCROLL		8
/* define SB_UPCLICK 15 (private message) */
#endif /*!NOSCROLL*/


#ifndef NOWNDMACROS

DWORD		FARPUBLIC ScrollBarWndProc(PWND, WORD, WORD, DWORD);

#ifdef CC
#ifndef cwExtraWnd
#define cwExtraWnd 5
#endif /*no extra size*/
#endif /*CC*/
#define wndScrollBar(id, fVert, fEnabled, ax, ay, dax, day, pwndParent, pwndSibbling, ctickRep) { \
	id, WS_CHILD | WS_SCROLL | (fVert ? SBS_VERT : SBS_HORZ), \
	0, fEnabled, {ax, ay, ax+dax, ay+day}, {ax, ay, ax+dax, ay+day}, \
	(PLFN) ScrollBarWndProc, pwndParent, pwndSibbling, NULL, 0, 0, \
	{ctickRep, 0, 0, 1, 1}}

#endif /* !NOWNDMACROS */

short		FARPUBLIC SetScrollPos(PWND, short, BOOL);
short		FARPUBLIC GetScrollPos(PWND);
VOID		FARPUBLIC SetScrollRange(PWND, short, short, BOOL);

/***END_PUBLIC***/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\udialog.h ===
/*    	COW : Character Oriented Windows

	udialog.h: Definitions for user Dialog 
*/

/***BEGIN_PUBLIC***/

WORD		FARPUBLIC MessageBox(char *, char *, char *, WORD);
VOID		FARPUBLIC SetDialogCaption(HANDLE, char *);
VOID		FARPUBLIC HiliteDialogAccel(void);

/* Message Box Definitions */

#ifndef NOMB
#define	IDDEFAULT		1
#define	IDCANCEL		2
#define	IDNO			3
#define	IDOK			IDDEFAULT
#define	IDYES			IDDEFAULT
#define	IDRETRY			IDDEFAULT
#define	IDABORT			IDDEFAULT
#ifdef	HELP_BUTTON
#define IDHELP			4
#endif	// HELP_BUTTON
#define	MB_OK			1
#define	MB_YESNOCANCEL		2
#define	MB_RETRYCANCEL		3
#define	MB_OKCANCEL		4
#define	MB_ABORT		5
#define MB_YESNO		6
#define MB_RETRY		7
#define	MB_TYPE			0x0f		/* message type */
#define MB_BEEP			0x10
#define MB_CAPTION		0x20		/* 1st param is caption */
#ifdef	HELP_BUTTON
#define MB_NOHELP		0x8000
#endif	// HELP_BUTTON
#endif /*!NOMB*/

/* for Special MessageBox */
extern BYTE FAR * PASCAL lpbWorkTemp;	/* App should never use directly */

#define	InitSpecialMessageBox(lpbBuff)	\
	{				\
	Assert(lpbWorkTemp == NULL);	\
	lpbWorkTemp = (lpbBuff);	\
	}

#define	EndSpecialMessageBox()		\
	{				\
	Assert(lpbWorkTemp != NULL);	\
	lpbWorkTemp = NULL;		\
	}


/***END_PUBLIC***/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\ingxd.h ===
/*
	CW: Character Windows
	
	ingxd.h: Graphic Drawing (GSD and GPD)
	NOTE: probably missing some GPD related stuff

	for Pcode use (unnamed unions/structs) define NOGD_????
*/

/***BEGIN_PUBLIC***/

/* Primative Graphic Types */

#ifndef NOGD_GPT
typedef struct _gpoint
	{
	int	x;
	int	y;
	} GPT; /* GPOINT / Graphic Point */
#endif /*!NOGD_GPT*/

#ifndef NOGD_RECT
typedef struct _rect
	{
	int	xLeft;
	int	yTop;
	int	xRight;
	int	yBottom;
	} RECT;
#endif /*!NOGD_RECT*/

#ifndef NOGD_POLYGON
typedef struct _polygon
	{
	WORD	cbPolygon;
	RECT	rectBound;
	GPT	rggpt[1];
	} POLYGON;
#endif /*!NOGD_POLYGON*/

#define	cpenMax		41	/* maximum number of pens */
#define	icoMax		41	/* maximum ico number */

/* Device descriptor */
typedef struct _ingd
	{
	WORD	fingd;		/* flags -- see below			*/
	WORD	reserved2;	/* for future use			*/
	WORD	fingpSupported;	/* procedures supported -- see below	*/
	WORD	dimH;		/* horizontal size in twips		*/
	WORD	dimV;		/* vertical size in twips		*/
	WORD	dxScreen;	/* number of horizontal pixels		*/
	WORD	dyScreen;	/* number of vertical pixels		*/
	WORD	dimPenH;	/* horizontal pen size in twips		*/
	WORD	dimPenV;	/* vertical pen size in twips		*/
	BYTE	cpen;		/* number of pens available		*/
	BYTE	icoAvailMac;	/* number of colors available		*/
	BYTE	icoPrefMac;	/* number of preferred colors		*/
	BYTE	ipaLineMac;	/* number of line styles		*/
	BYTE	ipaAreaMac;	/* number of area fill patterns		*/
	BYTE	ccopln;		/* number of color planes or ribbons	*/

	WORD	rgcoAvail[cpenMax];
	WORD	rgcoPref[cpenMax];
	BYTE	rgpaLine[5];
	BYTE	rgpaArea[16];
	char	szName[40];
	} INGD;


/* FINGD : Flags for the options supported in INGD */
#define	fingdRstrVctr	0x0004	/* Raster : MUST BE SET */
#define	fingdRasterFonts 0x0040	/* can use raster fonts			*/
#define	fingdMultiColor	0x0100	/* device has infinite colors		*/
#define	fingdVirtualPen	0x0200	/* do not prompt for pen changes	*/
#define	fingdFilm	0x0400	/* film device				*/
#define	fingdVarPenSize	0x1000	/* device can vary the pen size		*/
#define	fingdNotAvailable 0x8000/* device does not support this DEV	*/

/* FINGP: GSD procedures supported */
#define	fingpSetAreaPat	0x0001	/* set the current area pattern		*/
#define	fingpSetLinePat	0x0002	/* set the current line pattern		*/
#define	fingpSetLineWeight 0x0004 /* set the current line weight	*/
#define	fingpSetColor	0x0008	/* set the current color		*/
#define	fingpText	0x0010	/* draw a text string			*/
#define	fingpRectangle	0x0020	/* draw or fill a rectangle		*/
#define	fingpArc	0x0040	/* draw or fill an arc			*/
#define	fingpPolygon	0x0080	/* draw or fill a polygon		*/
#define	fingpBitBlt	0x0100	/* copy a bitmap			*/

/***END_PUBLIC***/

/*****************************************************************************/
/* CW private info */

/*****************************************************************************/
/* GPD jump vectors */

typedef BOOL		(FAR PASCAL *LPFN_GD_INIT)(VOID *, VOID FAR *);
typedef VOID		(FAR PASCAL *LPFN_GD_TERM)(void);
typedef VOID		(FAR PASCAL *LPFN_GD_XY)(WORD, WORD);
typedef VOID		(FAR PASCAL *LPFN_GD_INDEX)(WORD);
typedef VOID		(FAR PASCAL *LPFN_GD_COLOR)(WORD, WORD);
typedef VOID		(FAR PASCAL *LPFN_GD_TEXT)(char far *, WORD, WORD, WORD, int);
typedef VOID		(FAR PASCAL *LPFN_GD_RECT)(struct _rect far *);
typedef VOID		(FAR PASCAL *LPFN_GD_ARC)(struct _rect far *, int, int);
typedef VOID		(FAR PASCAL *LPFN_GD_POLY)(struct _polygon far *);
typedef VOID		(FAR PASCAL *LPFN_GD_BITBLT)(struct _rect far *, BYTE far *, WORD, BOOL);

typedef struct _indj /* drawing jump vectors */
	{
	LPFN_GD_INIT	pfnFInitGraphics;
	LPFN_GD_TERM	pfnTermGraphics;
	LPFN_GD_XY	pfnMove;
	LPFN_GD_XY	pfnDraw;
	LPFN_GD_INDEX	pfnSetAreaPat;
	LPFN_GD_INDEX	pfnSetLinePat;
	LPFN_GD_INDEX	pfnSetLineWeight;
	LPFN_GD_COLOR	pfnSetColor;
	LPFN_GD_TEXT	pfnText;
	LPFN_GD_RECT	pfnRectangle;
	LPFN_GD_ARC	pfnArc;
	LPFN_GD_POLY	pfnPolygon;
	LPFN_GD_BITBLT	pfnBitBlt;
	} INDJ;

/* indtGraphicScreen/indtGraphicPrinter service */
#define	cpfnGxdMin	13
#define	cpfnGsdMin	cpfnGxdMin
#define	cpfnGpdMin	cpfnGxdMin

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\lom.inc ===
;*
;*	loinfo.inc : low memory info (for loader & kernel)
;*
;*	SAR : 86-6-11

;*	* Note : this information is initialized by the loader
;*		and is passed to the kernel


	include newexe.inc		;* new exe header
	include pdb.inc 		;* DOS 2.x PDB

cchBootPathMax	EQU	80		;* (really 2 + 64 + 8 + 1 + 3 + 1)

LOM	STRUC
;* PDB
 pdbLom 	DB	SIZE PDB DUP (?)	;* (Prog descriptor block)
;* boot file path : properly formed : chDrive:....
 szBootPathLom	DB	cchBootPathMax DUP (?)
;* Miscellaneous variables
 fdExeLom	DW	?	;* file handle of Open .EXE file
 ;* Warning : cbNeLom & lfaNeLom MUST be contiguous
 cbNeLom	DW	?	;* # of bytes in new exe file
 lfaNeLom	DD	?	;* long file offset to New portion
 hGlobalHeapLom DW	?	;* handle to global heap
 pGlobalHeapLom DW	?	;* ps of start of global heap
 psDgroupLom	DW	?	;* ps of DGROUP
 psUseMax	DW	?	;* maximum ps that can be used
 offRlbLom	DW	?	;* offset in psLom of RLB information
				;* (far kernel work buffer)
;* Near jumps to far procedures
 opcReloadLom	DB	?	;* JMPF
 offReloadLom	DW	?
 psReloadLom	DW	?
 opcRelruLom	DB	?	;* JMPF
 offRelruLom	DW	?
 psRelruLom	DW	?
 opcRetThunkLom	DB	?	;* JMPF
 offRetThunkLom	DW	?
 psRetThunkLom	DW	?
 fillerLom	DB	?	;* WORD align

;* Exe name for DOS 3 rename protection
 szExeLom	DB	14 dup (?)		;* name only (12+\0+align)

IFDEF DUAL
 pbRleCurLom	DW	?	;* RLB_ENT currently in kernel buffer
ENDIF ;DUAL

;*	* New EXE
 neLom		DB	SIZE NEW_EXE DUP (?)	;* new exe header
;*	* extra information follows here ....
LOM	ENDS

cbLom		EQU	SIZE LOM		;* # of bytes in LOM
cpsLom		EQU	(SIZE LOM + 15) / 16	;* # of paras in LOM

lomOffset	EQU	<>			;* offset of struct

;*	* aliases for PDB
cchCmdLine	EQU	pdbLom.PDB_DEF_DTA
szCmdLine	EQU	pdbLom.PDB_DEF_DTA+1

;* * format of memory :
;*	LOM
;*	swap file names
;*	seg tab
;*	ent tab
;*	FIXED CODE SEGMENTS
;*	* DGROUP
;*	* [preloaded moveable code segments]
;*	* .. free global heap
;*	[LOADER]
;*	* end of heap
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\inscreen.h ===
/*
	CW: Character Oriented Windows
	
	inscreen.h: Installable screen driver CW info
*/

#include <indrv.h>				/* installable driver */
#include <inscr.h>				/* installable driver */

/***BEGIN_PUBLIC***/

extern INST PASCAL instCur;
extern INCH PASCAL inch;		/* near buffer for characters */
extern BOOL PASCAL fFontAvailable;	/* extra "ffont" drawing available ? */

/* name aliases for the actual characters */
#define	chTopSide1		(inch._chTopSide1)
#define	chBottomSide1		(inch._chBottomSide1)
#define	chLeftSide1		(inch._chLeftSide1)
#define	chRightSide1		(inch._chRightSide1)
#define	chTopLeftCorner1	(inch._chTopLeftCorner1)
#define	chTopRightCorner1	(inch._chTopRightCorner1)
#define	chBottomLeftCorner1	(inch._chBottomLeftCorner1)
#define	chBottomRightCorner1	(inch._chBottomRightCorner1)
#define chMiddleLeft1		(inch._chMiddleLeft1)
#define chMiddleRight1		(inch._chMiddleRight1)
#define	chTopSide2		(inch._chTopSide2)
#define	chBottomSide2		(inch._chBottomSide2)
#define	chTopLeftCorner2	(inch._chTopLeftCorner2)
#define	chTopRightCorner2	(inch._chTopRightCorner2)
#define	chBottomLeftCorner2	(inch._chBottomLeftCorner2)
#define	chBottomRightCorner2	(inch._chBottomRightCorner2)
#define	chUpArrow		(inch._chUpArrow)
#define	chDownArrow		(inch._chDownArrow)
#define	chRightArrow		(inch._chRightArrow)
#define	chLeftArrow		(inch._chLeftArrow)
#define	chBullet		(inch._chBullet)
#define	chMiddleDot		(inch._chMiddleDot)
#define	chScrollbar		(inch._chScrollbar)
#define	chElevator		(inch._chElevator)
#define	chShadowInit		(inch._chShadowInit)

/* for overlapping windows */
#define	chClose			(inch._chClose)
#define	chZoomIn		(inch._chZoomIn)
#define	chZoomOut		(inch._chZoomOut)
#define	chUpDownArrow		(inch._chUpDownArrow)
#define	chLeftRightArrow	(inch._chLeftRightArrow)

/*****************************************************************************/
/* Screen Procedures */

typedef WORD FAR *	(FAR PASCAL *LPFN_DRV_ALLOC)(WORD, WORD);
typedef VOID		(FAR PASCAL *LPFN_DRV_FREE)(WORD FAR *);

WORD	FARPUBLIC ImodeGuessCurrent(void);			/*OPTIONAL*/
BOOL	FARPUBLIC FQueryInst(INST *, WORD);			/*OPTIONAL*/
BOOL	FARPUBLIC FAllocInstBuffers(INST *, LPFN_DRV_ALLOC, BOOL); /*OPTIONAL*/
VOID	FARPUBLIC FreeInstBuffers(INST *, LPFN_DRV_FREE);	/*OPTIONAL*/

BOOL	FARPUBLIC FAllocOverlapTable(INST *, LPFN_DRV_ALLOC);	/*OPTIONAL*/
VOID	FARPUBLIC FreeOverlapTable(LPFN_DRV_FREE);		/*OPTIONAL*/

BOOL	FARPUBLIC FInitScreen(INST *);				/*OPTIONAL*/
VOID	FARPUBLIC EndScreen(BOOL);				/*OPTIONAL*/

BOOL	FARPUBLIC FGetColorPalette(WORD, WORD *, WORD *);	/*OPTIONAL*/
VOID	FARPUBLIC SetColorPalette(WORD, WORD, WORD *);		/*OPTIONAL*/

VOID	FARPUBLIC MoveHwCursCsd(AX, AY, WORD);			/*OPTIONAL*/

BOOL	FARPUBLIC FQueryInft(INFT *, WORD);			/*OPTIONAL*/

WORD	FARPUBLIC CbSizeVids(void);				/*OPTIONAL*/
BOOL	FARPUBLIC FSaveVids(VIDS *, INST *);			/*OPTIONAL*/
BOOL	FARPUBLIC FRestoreVids(VIDS *);				/*OPTIONAL*/
VOID	FARPUBLIC SaveVidData(VIDS *, WORD FAR *);		/*OPTIONAL*/
VOID	FARPUBLIC RestoreVidData(VIDS *, WORD FAR *);		/*OPTIONAL*/
VOID	FARPUBLIC EnableVidsMonitor(BOOL);			/*OPTIONAL*/

VOID	FARPUBLIC GetCharMap(INFT *, BYTE, BYTE *);

/***END_PUBLIC***/

/*****************************************************************************/
/* COW private info */

extern INSJ insj;			/* jump vectors for screen driver */

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\galloc.inc ===
;*
;*	COW : Character Oriented Windows
;*
;*	galloc.inc : global memory allocation.

	include handle.inc

; Global arena objects are kept in a doubly linked list.
; No LRU is maintained (Code segment LRU maintained in segrefbyte table).
;
GlobalArena STRUC
ga_sig	    DB	?	    ; DOS 2.x 3.x signature byte
ga_owner    DW	?	    ; DOS 2.x 3.x owner field (current task)
				;* 0 => free
				;* 1 .. 254 = code segment # (Code blocks)
				;* -1 => special objects (SENTINEL / MOB)
				;* ownerDgroup = DATA GROUP
				;* ownerData = all other USER global data blocks
ga_size     DW	?	    ; DOS 2.x 3.x size, in paragraphs, not incl. header
ga_flags    DB	?	    ; 1 byte available for flags
ga_prev     DW	?	    ; previous arena entry (first points to self)
ga_next     DW	?	    ; next arena entry (last points to self)
ga_handle   DW	?	    ; back link to handle table entry
ga_newpara  DW  ?           ; Paragraph allocated (GA_HOLE only)
ga_reserved DW	?	    ;* RESERVED
				;* ga_lruprev & ga_lrunext not used
GlobalArena ENDS

GA_SIGNATURE	= 04Dh		;* Mark Zbikowski was here !
GA_ENDSIG	= 05Ah
GA_HOLE         = 04Ah          ;* A hole from TSR?

ownerDgroup	EQU	"DG"		;* DGroup
ownerData	EQU	"GD"		;* Global Data

; Global arena objects are aligned on 2 para. boundaries, leaving the
; low order bit always zero.
;
GA_ALIGN    = 2-1
GA_MASK     = NOT GA_ALIGN
GA_FIXED    = 1
Assert	<GA_FIXED EQ GA_ALIGN>

; Flags passed to GlobalAlloc (zero is the default case)
;
GA_ALLOCHIGH	EQU 01h 	; Flag to indicate allocate high
GA_MOVEABLE	EQU 02h
GA_DGROUP	EQU 04h
GA_DISCCODE	EQU 08h
GA_SEGTYPE	EQU 0Ch 	; Above 2 bits stored in he_flags field
GA_NOCOMPACT	EQU 10h
GA_NODISCARD	EQU 20h
GA_ZEROINIT	EQU 40h
; These flags for use by KERNEL only (caller's CS must match)
GA_INTFLAGS	= GA_ALLOCHIGH+GA_SEGTYPE

; High byte of flags remembered in handle table (he_flags field)
;
GA_DISCARDABLE	EQU 01h 	; Boolean flag for global object, not a level.
; User setable handle table flags

; Data structure that describes the global arena.  Allocated at the end
; of the local heap information structure.
;
GlobalInfo  STRUC
	    DB	SIZE HeapInfo DUP (?)
gi_disfence DW	?	; Fence for discardable code.
gi_lrulock  DW	?	; Lock out access to LRU chain from interrupt level
gi_reserve  DW	?	; #paragraphs to reserve for discardable code
			; Zero means not enabled
GlobalInfo  ENDS
gi_cmpflags = hi_dislevel   ; Flags to control gcompact

; Notify procedure message codes
;
GN_MOVE     = 1 	; Object moved - arg1 = handle arg2 = old location
GN_DISCARD  = 2 	; Object discard? - arg1 = handle, arg2 = discard flags
			; Returns new discard flags in AX


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\galloc.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	galloc.asm : global memory allocation

	TITLE	GALLOC - Global memory allocator

	.xlist
	include kernel.inc
	include galloc.inc
	include pbi.inc
	.list


;*****************************************************************************


sBegin	BSS
    assumes DS,DGROUP

staticW plblFailSearch,0		;* label to jump to if compact fails

sEnd	BSS

sBegin	DATA

externW <psLom>

sEnd	DATA


;*****************************************************************************


sBegin	KERNEL
    assumes CS,KERNEL
    assumes DS,NOTHING		;* DS points to MOB usually
    assumes SS,DGROUP

externNP	<gcompact,gmovebusy>		;* gcompact.asm
externNP	<galign>			;* ginterf.asm
externNP	<UnbindAll>			;* ldtunk.asm

	PUBLIC	gsplice, gjoin, gzero, gsearch, gmarkfree, gfindfree, gcheckfree
	PUBLIC	DoSearchAddMemory

SUBRS	PROC	NEAR

; Subroutine to splice in a new block into the arena after an existing block
;
;   Inputs:	ES:DI = address of existing block
;		SI = address of new block to add to arena after existing block
;		DS:DI = address of global arena information structure
;
;   Outputs:	Updated size field for old and new block
;		Updated hi_count field in global arena information structure
;
;   Destroys:	CX
;

gsplice:
	inc	[di].hi_count		; Adding new arena entry
	push	si			; save new
	push	es			; save old
	mov	cx,si			; save old.next
	xchg	ES:[di].ga_next,cx	; and old.next = new
	mov	es,cx
	mov	ES:[di].ga_prev,si	; [old old.next].prev = new
	mov	es,si
	mov	ES:[di].ga_next,cx	; new.next = old old.next
	sub	si,cx			; new.size = new.next - new - 1
	neg	si
	dec	si
	mov	ES:[di].ga_size,si
	pop	cx			; new.prev = old
	mov	ES:[di].ga_prev,cx
	mov	ES:[di].ga_owner,di	; Zero owner & handle fields
	mov	ES:[di].ga_handle,di
	mov	ES:[di].ga_sig,GA_SIGNATURE
	mov	es,cx			; ES = old
	sub	cx,ES:[di].ga_next	; old.size = old.next - old - 1
	neg	cx
	dec	cx
	mov	ES:[di].ga_size,cx
	pop	si			; Restore new
	ret


; Subroutine to join two blocks together, by removing one
;
;   Inputs:	ES:DI = address of block to remove
;		DS:DI = address of global arena information structure
;
;   Outputs:	ES:DI = address of block that pointed to the one removed, with
;			update size field and next pointer.
;		Updated hi_count field in global arena information structure
;
;   Destroys:	SI
;

gjoin:
	dec	[di].hi_count
	mov	si,ES:[di].ga_prev	; who points to this block
	mov	es,ES:[di].ga_next	; Get address of block after
	mov	ES:[di].ga_prev,si	; one we are removing.
	push	es			; Change it's back link
	mov	es,si
	pop	ES:[di].ga_next 	; and change the forward link
	sub	si,ES:[di].ga_next	; Recompute size of block
	neg	si
	dec	si
	mov	ES:[di].ga_size,si
	ret


; Subroutine to fill a block with zeros
;
;   Inputs:	BX = address of first paragraph to zero
;		CX = address of last paragraph to zero
;
;   Outputs:	BX = 0
;
;   Destroys:	CX
;

gzero:
	push	ax
	push	di
	push	es

	mov	es,bx		    ; ES = destination
	sub	bx,cx		    ; BX = #para
	neg	bx
	inc	bx
zero1:
	mov	cx,1000h
	cmp	bx,cx
	jae	zero2
	mov	cx,bx
	jcxz	zero3
zero2:
	sub	bx,cx
	shl	cx,1
	shl	cx,1
	shl	cx,1
	xor	ax,ax
	xor	di,di
	cld
	rep	stosw		; Zero it out

	mov	ax,es		; Move to next 64k block
	add	ah,10h
	mov	es,ax

	jmp	zero1
zero3:
	pop	es
	pop	di
	pop	ax
	ret


;*	* special trap routines for search failure
;*	* We will first try to compact. Then we will try to allocate some
;*	* Additonal memory.  If This fails we will then try to trash som
;*	* bound segments(for code).  Finally we fail.
;*	*
;* if we failed we will then try to allocate memory to add onto our
;*	* We will get the largest free memory.	If > predefined minimum
;*	* to add, then we will try to add this new segment into our
;*	* memory list. Note: we will continue trying to allocate memory
;*	* Until we do not get a big enough chunk.

DoSearchFail:		;* if search fails second time, give up
	pop	ax
	pop	cx
	pop	bx
	xor	ax,ax			;* failure
	ret

DoSearchUnBind:
;*	* if after compacting we still don't have enough
;*	*   if compacting for a data request => give up (DoSearchFail)
;*	*   if compacting for code => unbind any segments and try again
	pop	ax
	push	ax			;* ax = flags
	test	al,GA_ALLOCHIGH 	; Allocating from high memory?
	jz	DoSearchFail		;* give up for data
;*	* still trying code (un-bind any bound segments)
	cCall	UnbindAll
	mov	plblFailSearch,kernelOffset DoSearchFail
	jmp	do_compact




DoSearchAddMemory:
IFDEF	WINDOWS_OLD_APP
	jmp	DoSearchUnbind		;* We can't handle this case 
ELSE	; !WINDOWS_OLD_APP

	mov	bx,0ffffh		; Try to allocate 1 meg?
	mov	ah,48h
	int	21h
	cmp	bx,100h 		; Add minimum of 4k
	jc	DoSearchUnbind		; Not enough try 3rd pass

	mov	ah,48h			; Now lets allocate it
	int	21h			;
	jc	DoSearchUnbind		; Allocate now failed?

;;;;; for now we will only handle ones added to end of list.
	; see if we insert new chunk at begining, ending, or in middle
	cmp	ax,[di].hi_first	; see if before current first block
	jc	DoSearchAddMemory	 ; New lowest block
	cmp	ax,[di].hi_last 	; see if after highest
	jc	DoSearchAddMemory	; Tsr went away?
	; New highest point - most probable case.  We ran something that
	; was a TSR.  Now lets merge this memory in.  We need to create a
	; new End sentinal.  As the last ax=start, bx=lenth in paragraphs

	push	ax			;* Save original paragraph number
	test	ax,GA_ALIGN		;* see if aligned right
	jz	ok_align		;* yes
	mov	cx,ax			;* save orignal size
	add	ax,GA_ALIGN
	and	ax,GA_MASK		;* new starting position
	push	ax
	sub	ax,cx			;* see the difference
	sub	bx,ax			;* now update count of bytes
	pop	ax			;* restore new starting position
ok_align:
	mov	cx,ss:psLom		;* Need to make sure in range
	mov	es,cx			;* Use segment register.
	mov	cx,ax			; Save start postion.
	add	ax,bx			;* ax = new end
;*	* check to make sure we are within the useable limits
	cmp	ax,es:[psUseMax]
	jb	still_in_range		;* ok request
	mov	ax,es:[psUseMax]
Still_in_range:
	sub	ax,GA_ALIGN		;* Lets get right position
	and	al,LOW(GA_MASK) 	;* make even
	mov	bx,ax			;* compute new free area added
	sub	bx,cx			;*
	dec	bx			;*

;*	now	lets create a header for new free memory segment
	mov	es,cx			;* setup segment.
	mov	es:[di].ga_sig,GA_SIGNATURE ;* data segment
	mov	es:[di].ga_owner,0	;* Free memory
	mov	es:[di].ga_size,bx	;* How much free area added
	mov	es:[di].ga_flags,0
	mov	es:[di].ga_handle,di	;* no handle
	mov	es:[di].ga_next,ax	;* link to new sentinal
	mov	bx,[di].hi_last 	;* Get old high mark.
	mov	es:[di].ga_prev,bx	;* Link to old sentinal

;*	* create new sentinal
	mov	es,ax			;* setup new sentinal segment
	mov	es:[di].ga_sig,GA_ENDSIG
	mov	es:[di].ga_owner,-1	;* sentinal
	mov	es:[di].ga_size,GA_ALIGN
	mov	es:[di].ga_flags,0
	mov	es:[di].ga_handle,di	;* no handle
	mov	es:[di].ga_next,es	;* link to self
	mov	es:[di].ga_prev,cx

;*	* update Old sentinal to be	;* fixed block that cant move
	xchg	ax,[di].hi_last 	;* Setup pointer to new last object
	mov	es,ax			;* now we need to modify header
	mov	es:[di].ga_sig,GA_HOLE	;* setup as a hole.
	mov	es:[di].ga_next,cx	;* Setup next pointer to new memory object
	sub	cx,ax			;* Setup size of hole.
	dec	cx			;*
	mov	es:[di].ga_size,cx	;* size of hole
	pop	es:[di].ga_newpara	   ;* put allocation seg paragraph number


;*	* now add 2 to the number of items in the list
	add	[di].hi_count,2 	;* add new free list, and endsig

	jmp	short do_compact	; now compact using new memory
ENDIF	; WINDOWS_OLD_APP


;**********************************************************
DoSearchCompact:	;* if search fails first time, compact and try again
	mov	plblFailSearch,kernelOffset DoSearchAddMemory
do_compact:
	push	bx
	call	gcompact		; End of arena.  Try compacting.
	pop	bx
;*	* now retry
	pop	ax
	pop	cx
	pop	bx
	jmp	short gsearch_again


; Subroutine to search for a free global object.  Called from within
; the global memory manager's critical section.
;
;   Inputs:	AX = allocations flags
;		BX = #paras
;		CX = owner field value
;		DS:DI = address of global arena information structure
;
;   Outputs:	AX = data address of block allocated or NULL
;		DX = allocation flags or size of largest free block if
;		     AX = 0
;		Z flag set if AX = zero
;
;   Destroys:	BX,CX,SI,ES
;

gsearch:
	mov	plblFailSearch,kernelOffset DoSearchCompact
gsearch_again:
	push	bx			;* save cpara
	push	cx			; Save owner
	push	ax			; Save flags
	add	bx,1			; Room for header (set flags for galign)
	call	galign			; Get requested size in DX
	mov	cx,[di].hi_count	; ES:DI is our arena pointer
	mov	es,[di].hi_first	; Assume fixed, start with first entry
	mov	bx,ga_next		; and search forwards along next links
	test	al,GA_ALLOCHIGH 	; Allocating from high memory?
	jz	gs1			; No, continue
	mov	es,[di].hi_last 	; Yes, start with last entry
	mov	bl,ga_prev		; and search backwards along prev links
gs1:	mov	es,es:[bx]		; Skip first or last block
aloop:
	cmp	ES:[di].ga_owner,di	; Is block free?
	je	afree			; Yes, see if it is big enough
	mov	si,ES:[di].ga_handle	; See if moveable
	cmp	bl,ga_next		; No, moving forward?
	jne	aloop1			; No, see if we should stop looking
	or	si,si
	jz	anext
	cmp	[si].he_count,bh
	jne	anext			; No, keep looking
	pop	ax
	push	ax
	test	al,GA_MOVEABLE		; Yes, is this a fixed request?
	jnz	anext			; No, keep looking
	mov	ax,es:[di].ga_size	; Yes, is this moveable block
	inc	ax			; big enough for the fixed space
	cmp	ax,dx			; needed?
	jb	anext			; No, keep looking
	push	dx
	mov	dx,ax			; Yes, try to find a place for the
	call	gfindfree		; moveable block
	pop	dx
	or	ax,ax			; Did we find a place?
	jz	anext			; No, keep looking
	push	es:[di].ga_prev 	; Where to pick up enumeration from
	mov	si,es			; SI = moveable block
	mov	es,ax			; ES = free block big enough for it
	call	gmovebusy		; Move moveable block out of the way
	pop	es
	jmp	short aloop		; Restart enumeration to find new free block
aloop1:
	cmp	ds:[di].gi_reserve,di	; Is there a reserved swap area?
	je	anext			; No, next block
	or	si,si			; Stop backwards scan if not moveable
	jz	anotfound
	test	es:[di].ga_flags,GA_DISCCODE	; ... or not discardable code
	jz	anotfound
	jmp	short anext		; Otherwise keep scanning backwards
afree:
	call	gcheckfree		; Yes, room for requested size?
	jae	afound			; Yes, exit search loop
	cmp	ds:[di].gi_reserve,di	; No, is the reserved swap area?
	je	anext			; No, next block
	cmp	bl,ga_prev		; Yes, are we allocating for code?
	je	anotfound		; Yes, then can only go in the first
					; free block.
anext:
	mov	es,ES:[bx]		; ES = address of next block
	loop	aloop			; Loop to next arena block if there

anotfound:
	jmp	[plblFailSearch]	;* jump to retry or fail

afound:
	mov	ax,es:[di].ga_size	; Use actual size of free block
	inc	ax
; Here when we have a block big enough.
;   ES:DI = address of block
;   AX = size of block, including header
;   DX = requested size, including header
;   BX = ga_prev if backwards search and ga_next if forwards search
;
	mov	cx,ax			; See how much extra space there is
	sub	cx,dx			; (found size - requested size)
	xor	si,si			; Assume nothing extra to free
	jcxz	aexit			; No, continue
	cmp	bl,ga_prev		; Yes, scanning forwards or backwards?
	je	abwd			; Backwards.
	mov	si,es			; Forwards.   Put extra space at end of
	add	si,dx			; free block
	call	gsplice 		; ES:DI = block we are allocating
	jmp	short aexit		; SI = block to mark as free
abwd:
	mov	si,ES:[di].ga_next	; Scanning backwards.  Put extra space
	sub	si,dx			; at beginning of free block.
	call	gsplice
	mov	es,si			; ES:DI = block we are allocating
	mov	si,ES:[di].ga_prev	; SI = block to mark as free

; Here with allocated block
;   AX = data address or zero if nothing allocated
;   ES:DI = address of block to mark as busy and zero init if requested
;   SI = address of block to mark as free
;
aexit:
	pop	dx			; Restore flags
	pop	ES:[di].ga_owner	; Mark this block as busy
	pop	ax			;* discard original size request
	mov	al,GA_SEGTYPE
	and	al,dl
	mov	ES:[di].ga_flags,al	; Store segment type bits

	mov	ax,es			; AX = address of client data
	inc	ax

	test	dl,GA_ZEROINIT		; Want it zeroed?
	jz	aexit1			; No, all done
	mov	cx,ES:[di].ga_next	; Yes, zero paragraphs
	dec	cx			; to end of this block
	mov	bx,ax			; from beginning of client data
	call	gzero			; zero them
aexit1:
	mov	es,si			; Free any extra space
	call	gmarkfree
	or	ax,ax
	ret				; Return AX points to client portion
					; of block allocated.

; Subroutine to mark a block as free, coalescing it with any free blocks
; before or after it.
;
;   Inputs:	ES:DI = block to mark as free.
;		DS:DI = address of global arena information structure
;
;   Outputs:	SI = zero if freed a fixed block.  For moveable blocks,
;		SI = handle table entry
;		ES:DI = block freed (may have been coelesced)
;		Updated hi_count field in global arena information structure
;
;   Destroys:	SI
;
gmarkfree:
	mov	si,es
	or	si,si
	jz	free4

	; Mark this block as free by clearing the owner field.
	mov	ES:[di].ga_owner,di	; Mark as free

	; Remember the handle value in DX, before setting to zero.
	push	dx
	xor	dx,dx
	xchg	ES:[di].ga_handle,dx

	; Try to coelesce with next block, if it is free
	push	ES:[di].ga_prev 	; save previous block
	mov	es,ES:[di].ga_next	; ES = next block
	cmp	ES:[di].ga_owner,di	; Is it free?
	jne	free2			; No, continue
	call	gjoin			; Yes, coelesce with block we are freeing
free2:
	pop	es			; ES = previous block
	cmp	ES:[di].ga_owner,di	; Is it free?
	jne	free3			; No, continue
	mov	es,ES:[di].ga_next	; Yes, coelesce with block we are freeing;
	call	gjoin
free3:
	mov	si,dx			; Return 0 or handle in SI
	pop	dx			; restore DX
	cmp	ES:[di].ga_owner,di	; Point to free block?
	je	free4			; Yes, done
	mov	es,ES:[di].ga_next	; No, leave ES pointing at free block
free4:
	or	si,si
	ret

; Subroutine to search for a free block that is big enough but does not
; encroach on the area reserved for code swapping.
;
;   Inputs:	ES:DI = address of existing block to start looking at
;		CX = #arena entries left to look at
;		BX = direction of search, ga_next or ga_prev
;		DX = #paragraphs needed
;		DS:DI = address of global arena information structure
;
;   Outputs:	AX = zero or address of free block that is big enough
;

gfindfree:
	push	es
	push	cx
gffloop:
	cmp	es:[di].ga_owner,di	; Free block?
	jne	gffnext 		; No, continue
	call	gcheckfree		; Yes, is it big enough?
	mov	ax,es
	jae	gffexit 		; Yes, return
	cmp	bl,ga_prev		; No, scanning backwards?
	je	gfffail 		; Yes, fail
gffnext:
	mov	es,es:[bx]		; next or previous block
	loop	gffloop
gfffail:
	xor	ax,ax			; No, return zero in AX
gffexit:
	pop	cx
	pop	es
	ret

; Subroutine to check the size of the passed free block against the passed
; desired size, making sure that the limitations of the code reserve area
; are not violated.
;
;   Inputs:	ES:DI = address of free block
;		DX = #paragraphs needed
;		DS:DI = address of global arena information structure
;
;   Outputs:	AX = apparent size of free block
;
;   Destroys:	SI
;

gcheckfree:
	mov	ax,es:[di].ga_size	; Compute size of free block
	inc	ax
	cmp	[di].gi_reserve,di	; Is there a code reserve area?
	je	gcftest 		; No, size okay
	test	byte ptr [di].gi_cmpflags,GA_DISCCODE
	jnz	gcftest 		; Discardable code not restricted
	push	es
	mov	es,es:[di].ga_next	; Go to block after free block
	cmp	es:[di].ga_sig,GA_ENDSIG    ; Is it the end of the arena?
	je	gcfrsrv 		; Yes, go enforce reserve area
	test	es:[di].ga_flags,GA_DISCCODE	; Is it a discardable code seg?
	jz	gcftest1		; No, test size
gcfrsrv:
	pop	es			; Yes, compute real available size
	mov	si,[di].hi_last 	; See if beginning of reserve area
	sub	si,[di].gi_reserve	; is above the end of the free block
	cmp	si,es:[di].ga_next
	jae	gcftest 		; Yes, return actual size of free block
	sub	si,es:[di].ga_next	; No, compute amount of overlap
	neg	si
	cmp	ax,si			; Is it more than what is free?
	jbe	gcfrsrv1		; Yes, then apparent size is zero
	sub	ax,si			; No, reduce apparent size of free block
	jmp	short gcftest		; Test size.
gcfrsrv1:
	xor	ax,ax			; Nothing left, set apparent size to 0
	jmp	short gcftest		; Test size.
gcftest1:
	pop	es
gcftest:
	cmp	ax,dx			; Return results of the comparison
	ret

SUBRS	ENDP

sEnd	KERNEL

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\assert.c ===
/*
	COW : Character Oriented Windows

	assert.c : AssertPrintf() procedures
*/

#define COW
#include <cow.h>

#include <kmem.h>
#include <kinput.h>
#include <uwindow.h>
#include <umenu.h>			/* Menu structure */
#include <uscreen.h>
#include <cwdebug.h>			/* debugging support */

#ifdef DEBUG	/* entire file for debug only */

extern WORD PASCAL psDebug;	/* 0 if no debugger */

VOID FAR PASCAL	CwOutSz(CHAR *);

/* forward*/
VOID FAR cdecl	AssertPrintf(char *, ...);
static char *	PchConvertHexW(char *, int);
static char *	PchConvertHexL(char *, long);
static char *	PchConvertDecW(char *, int, int);
static void cdecl	sprintf(char *, char *, ...);


VOID FAR cdecl
AssertPrintf(szFmt, ...)
/*
  -- printf to debugging console or main console
*/
char *szFmt;
	{
	int cch = 0;
	char rgch[256];
	char *szT = rgch;

	long *pl = (long *) (&szFmt + 1);

	sprintf(rgch, szFmt, pl[0], pl[1], pl[2], pl[3], pl[4]);

	while (*szT++)
		cch++;

	if (psDebug)
		PrDebugRgch((LPSTR) rgch, cch);
	else
		{
		CwOutSz(rgch);
		}
	}


static char rgchHex[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
	'A', 'B', 'C', 'D', 'E', 'F' };


static char *
PchConvertHexW(pch, w)
/*
  -- fill character array with hex word
*/
char *pch;
int w;
	{
	*pch++ = rgchHex[(w >> 12)&15];
	*pch++ = rgchHex[(w >> 8)&15];
	*pch++ = rgchHex[(w >> 4)&15];
	*pch++ = rgchHex[w&15];
	return (pch);
	}

static char *
PchConvertHexL(pch, l)
/*
  -- fill character array with hex long
*/
char *pch;
long l;
	{
	pch = PchConvertHexW(pch, HIWORD(l));
	return PchConvertHexW(pch, LOWORD(l));
	}


static char *
PchConvertDecW(pch, w, width)
/*
  -- fill character array with decimal word
*/
char *pch;
int w;
int width;
	{
	int wDecMask = 10000;
	BOOL fUse = FALSE;
	int width2;

	if (w < 0)
		{
		*pch++ = '-';
		w = -w;
		}

	for (wDecMask = 10000, width2 = 5; wDecMask != 0; wDecMask /= 10, width2--)
		{
		char ch = '0';

		while (w >= wDecMask)
			{
			ch++;
			w -= wDecMask;
			}

		if (fUse || ch != '0' || wDecMask == 1)
			{
			*pch++ = ch;
			fUse = TRUE;
			}
		else if (width >= width2)
		        *pch++ = ' ';
	        }

	return (pch);
	}


#ifdef FOR_QC
VOID FAR cdecl
dfprintf(fh, szFmt, ...)
/*
  -- fprintf under debugging to file or debugging console
*/
int  fh;
char *szFmt;
	{
	int cch = 0;
	char rgch[256];
	char *szT = rgch;

	long *pl = (long *) (&szFmt + 1);

	sprintf(rgch, szFmt, pl[0], pl[1], pl[2], pl[3], pl[4]);

	while (*szT++)
		cch++;

        if (fh == -1)
	    PrDebugRgch((LPSTR) rgch, cch);
	else
	    DBWrite(fh, rgch, cch);
	}
#endif


VOID FAR cdecl
dprintf(szFmt, ...)
/*
  -- printf to debugging console
*/
char *szFmt;
	{
	int cch = 0;
	char rgch[256];
	char *szT = rgch;

	long *pl = (long *) (&szFmt + 1);

	sprintf(rgch, szFmt, pl[0], pl[1], pl[2], pl[3], pl[4]);

	while (*szT++)
		cch++;

	PrDebugRgch((LPSTR) rgch, cch);
	}


static void cdecl
sprintf(buf, sz, ...)
/* returns pointer to 0 at end of output string */
char *buf, *sz;
	{
	char ch;
	char *szT;
	WORD *parg;
	WORD width;

	parg = (WORD *) (&sz + 1);

	while (*sz != '\0')
		{
		if ((ch = *sz++) == '%')
			{
			width = 0;
			if (*sz >= '0' && *sz < '9')
			  width = *sz++ - '0';
			switch (ch = *sz++)
				{
			case '%':
				*buf++ = '%';
				break;
			case 'd':
				buf = PchConvertDecW(buf, *parg++, width);
				break;
			case 'x':
				buf = PchConvertHexW(buf, *parg++);
				break;
			case 'l':
				switch (*sz++)
					{
				case 'x':
					buf = PchConvertHexL(buf, *(long *)parg);
					parg += sizeof(long) / sizeof(WORD);
					break;
				default:
					*buf++ = 'l';
					sz--;
					}
				break;
			case 's':
				szT = (char *) *parg++;
				while (*szT)
					*buf++ = *szT++;
				break;
			case 'c':
				*buf++ = (char) *parg++;
				break;
			default:
				*buf++ = ch;
				break;
				}
			}
		else if (ch == '\n')
			{
			/* newline => CR/LF */
			*buf++ = '\r';
			*buf++ = '\n';
			}
		else
			{
			*buf++ = ch;
			}
		}
	*buf = '\0';
	}

#endif /* DEBUG (entire file) */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\uscreen.h ===
/*
	COW: Character Oriented Windows
	
	uscreen.h: Public definitions for USER screen and box
*/

/***BEGIN_PUBLIC***/

#ifndef NOCOLOR
#define	DiMake(dm, isa)		((WORD) ((dm) | (isa)))

/*	-- non-special modes --	*/
#define	dmNormal		0
#define	DiNormal(isa)		((WORD) dmNormal | (isa))
#define	dmText			0x100
#define	dmTextOnly		dmText
#define	dmForeBack		0x200
#define	dmAttrOnly		dmForeBack
#define	dmFore			0x300
#define	dmBack			0x400
#define	dmTextFore		0x500
#define	dmTextBack		0x600

/*	-- special modes --	*/
#define	dmSpecialMin		0x700
#define	dmTextMapB		0x700
#define	dmTextMapF		0x800
#define	dmMapB			0x900
#define	dmMapF			0xA00

/* special FFONT control */
#define	fdmKeepFfont		0x8000

#endif /*!NOCOLOR*/

extern BYTE PASCAL fMonochrome;		/* TRUE => monochrome screen */
extern char PASCAL chShadow;		/* shadow character */
extern WORD PASCAL diShadow;		/* shadow draw mode, 0 => no shadow */
VOID		FARPUBLIC SetCursorBlock(BOOL);

/***END_PUBLIC***/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\ucolor.h ===
/*
	COW: Character Oriented Windows
	
	ucolor.h: USER Color control
*/

/***BEGIN_PUBLIC***/

#define	SetSysColor(isa, coBack, coFore, fBlink, fHilite) \
	SetIsaColor(isa,				\
 	    (coFore) + ((fHilite) ? 8 : 0),	\
 	    (coBack) + ((fBlink) ? 8 : 0))

VOID		FARPUBLIC SetIsaColor(ISA, WORD, WORD);
VOID		FARPUBLIC GetIsaColor(ISA, WORD *, WORD *);
VOID		FARPUBLIC SetIsaRgca(ISA, BYTE *);
VOID		FARPUBLIC SetIsaFfont(ISA, WORD);		/*OPTIONAL*/

/***END_PUBLIC***/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\inmou.h ===
/*
	CW: Character Windows
	
	inmou.h: Mouse specifics (not currently installable)
*/

/***BEGIN_PUBLIC***/

/*** mcb - mouse cursor block */
typedef struct mcb
	{
	WORD	colHot;					/* Hot Spot for								*/
	WORD	rowHot;					/*   graphics mouse cursor.				*/
	WORD	rgwAndMaskGfx[16];	/* Bit map masks for							*/
	WORD	rgwXorMaskGfx[16];	/*   graphics mouse cursor.				*/
	WORD	wAndMaskText;			/* Character and Attribute masks for	*/
	WORD	wXorMaskText;			/*   text mouse cursor.						*/
	} MCB; 

/*** mcb - mouse conditional off block */
typedef struct mcob
	{
	WORD	xLeft;
	WORD	yTop;
	WORD	xRight;
	WORD	yBottom;
	} MCOB; 

/* Key state masks for mouse messages (in wParam) */
#define	MK_LBUTTON		0x0001
#define	MK_RBUTTON		0x0002
#define	MK_SHIFT		0x0004
#define	MK_CONTROL		0x0008
#define	MK_MBUTTON		0x0010
#define	MK_NONCLIENT		0x0060	/* either X or Y outside */
#define	MK_NONCLIENT_X		0x0020
#define	MK_NONCLIENT_Y		0x0040
#define	MK_MENU			0x8000

BOOL		FARPUBLIC FEnableMouse(BOOL);
VOID		FARPUBLIC SetMouseCursor(BYTE FAR *);		/*OPTIONAL*/
VOID		FARPUBLIC MouseConditionalOff(PARC);	/*OPTIONAL*/
VOID		FARPUBLIC SetMousePos(WORD, WORD);		/*OPTIONAL*/
VOID		FARPUBLIC SetMouseDoubleSpeed(WORD);		/*OPTIONAL*/
BOOL		FARPUBLIC SwapMouseButton(BOOL);		/*OPTIONAL*/
WORD		FARPUBLIC CbSizeMouseState(void);		/*OPTIONAL*/
VOID		FARPUBLIC SaveMouseState(BYTE FAR *);		/*OPTIONAL*/
VOID		FARPUBLIC RestoreMouseState(BYTE FAR *);	/*OPTIONAL*/

/***END_PUBLIC***/

/*****************************************************************************/
/* Private info */

#ifdef COW

extern AX	PASCAL axMouse;
extern AY	PASCAL ayMouse;
extern WORD	PASCAL sstMouse;

#endif /*COW*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\keyboard.asm ===
;*
;*	CW : Character Windows
;*
;*	keyboard.asm : keyboard interface layer for installable keyboard drivers

	include kernel.inc
	include	indrv.inc
	include	inkbd.inc

;*****************************************************************************

;*	* App supplied callbacks
externFP <UpdateShiftKk>
;*	* CW entries for callbacks
externFP <KeyboardMessage, FTestKeyboardEmpty, SpecialTsrAbort>

;*****************************************************************************

sBegin	DATA
    assumes DS,DGROUP

;*	* INKJ structure
externB	inkj


;*	* INKB structure (maps to structure in "ihnkbd.h")
;*	* exported flags are mapped in to middle of structure !!!!
	PUBLIC	inkb
	PUBLIC	fAbort, fPollKeyboard, fKeyIsUp, fKeyWasUp	;* PUBLIC
	PUBLIC	fNormalKeyboard, fNonAltKey, wRateKeyRepeat

inkb	EQU	THIS BYTE

;*	* Function pointers
		DD	KeyboardMessage
		DD	FTestKeyboardEmpty
		DD	SpecialTsrAbort

fAbort		DW	0
fPollKeyboard	DW	1			;* do it at least once
fKeyIsUp	DB	1
fKeyWasUp	DB	1
wRateKeyRepeat	DW	-1			;* key rate (-1 => default)

fNormalKeyboard	DW	1			;* => non-TSR
fNonAltKey	DB	1			;* => non alt key hit

fDisableExtended DW	0			;* => disable extended

sEnd	DATA


;*****************************************************************************


sBegin	KERNEL
    assumes CS,KERNEL
    assumes DS,DGROUP
    assumes SS,DGROUP

;*****************************************************************************
;* Init/Enable/Poll


;********** EnableKeyboard **********
;*	entry:	fOn => enable else disable
;*	* Enable or disable the keyboard
;*	exit:	n/a

cProc	EnableKeyboard, <PUBLIC,FAR,ATOMIC>
    parmW	fOn
    localW	hModule
cBegin	EnableKeyboard

	mov	bx,dataOffset inkb
	cCall	inkj.pfnEnableKeyboardKbdInkj, <bx, fOn, sp>
					;* (pinkb, fOn, fExit)
cEnd	EnableKeyboard


;********** PollKeyboard **********
;*	entry:	n/a
;*	* poll the keyboard (for non-interrupt driven systems)
;*	exit:	n/a

labelFP	<PUBLIC, PollKeyboard>
	jmp	inkj.pfnPollKeyboardKbdInkj



;********** DisableExtendedKeyboard **********
;*	entry/exit: n/a
;*	* disable extended keyboard operation
;*	* will be valid after next EnableKeyboard(TRUE)

cPublic	DisableExtendedKeyboard, <ATOMIC>
cBegin	DisableExtendedKeyboard

	mov	fDisableExtended,sp		;* set flag

cEnd	DisableExtendedKeyboard

;*****************************************************************************


;********** MkGetShiftStates **********
;*	entry:	n/a
;*	* get current shift states
;*	exit:	AX = current shift states (MK_ format)

labelFP	<PUBLIC, MkGetShiftStates>
	jmp	inkj.pfnMkGetShiftStatesKbdInkj


;********** SetShiftKk **********
;*	entry:	kk = new shift states
;*	* set shift states
;*	exit:	n/a

labelFP	<PUBLIC, SetShiftKk>
	jmp	inkj.pfnSetShiftKkKbdInkj

;*****************************************************************************
;* Kanji support

IFDEF KANJI
;********** ChAlternateKeytop **********
;*	entry:	chIn
;*	* return alternate key for "alt"ed key
;*	exit:	AL = other VK (or 0 if none)

labelFP	<PUBLIC, ChAlternateKeytop>
	jmp	inkj.pfnChAlternateKeytopKbdInkj

ENDIF ;KANJI


sEnd	KERNEL

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\gwinterf.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	gwinterf.asm : Global memory allocator - Windows interface procs

	.xlist
	include kernel.inc
	include galloc.inc
	.list


IFDEF DEBUG

CheckHeap MACRO n
local	ok
	cmp	fCheckCwHeap,0
	je	ok
	cCall	CheckGlobalHeap
	or	ax,ax
	jz	ok
	push	ax
	push	dx
	cCall	<far ptr PrintGlobalHeap> 	;*!! look at heap on exit
	pop	dx
	pop	ax			;* restore ax to see why we died
	cCall	CowAssertFailed
	DB	"&n"
	DB	":invalid global heap$"
ok:
ENDM
ELSE
CheckHeap MACRO n
ENDM
ENDIF


sBegin	DATA

externW     <hGlobalHeap,pGlobalHeap>

IFNDEF NOPCODE
externW     <$q_mpsnq>			;* HandleTable - 2
ENDIF ;!NOPCODE

IFDEF DEBUG
staticB  szThunkFormat, <"Thunk %x: sf=%x, ow=%x, sz=%x, nx=%x",0dh,0ah,0>
globalB	fCheckCwHeap,1
ENDIF ;DEBUG

IFDEF	WINDOWS_OLD_APP
externW	<fWoaPresent>
ENDIF	; WINDOWS_OLD_APP

IFDEF	DUAL
IFDEF	DEBUG
externW	fProtectMode
ENDIF	;DEBUG
ENDIF	;DUAL

sEnd	DATA


IFDEF	WINDOWS_OLD_APP
externFP	<WoaRelease>			;* User supplied
ENDIF	; WINDOWS_OLD_APP

IFDEF DEBUG
externFPublic <_dprintf>			;* in assertsw.c
ENDIF ;DEBUG


sBegin	KERNEL
    assumes CS,KERNEL
    assumes DS,NOTHING			;* DS usually points to MOB
    assumes SS,DATA			;* get variables from here


externNP    <PatchStackMoved, PatchStackDiscarded>
externNP    <PatchThunkMoved, PatchThunkDiscarded>	;* ldthunk.asm

IFDEF DEBUG
externNP    <CheckGlobalHeap>			;* lddebug.asm
ENDIF ;DEBUG

IFDEF	KEEP_SYMDEB_CODE
externNP    <DebugMovedSegment, DebugFreeSegment>	;* lddebug.asm
ENDIF	; KEEP_SYMDEB_CODE

;*	* low level subroutines
externNP    <galloc,grealloc>		; GMEM.ASM
externNP    <gfree>			; GMEM.ASM
externNP    <gdref,ghandle,galign>	; GMEM.ASM
externNP    <gfindfree> 		; GALLOC.ASM
externNP    <gcompact>			; GCOMPACT.ASM
externNP    <halloc,hthread>		; HANDLE.ASM


	PUBLIC	genter
	PUBLIC	gnotify
	PUBLIC	ghexpand
	PUBLIC	xhandle

IFDEF DEBPUB
	PUBLIC	gavail, gbtop
	PUBLIC	gmemfail, gmemcheck
ENDIF ;DEBPUB

SUBRS	PROC	NEAR


; Subroutine to enter a critical region for the global heap.
;
;   Output:	DS:DI = address of GlobalInfo for global heap
;*	* NOTE : gi_lrulock is not needed due to simplified LRU
;*	* and accordingly gleave is not needed !
;
genter:
	mov	ds,pGlobalHeap
	xor	di,di
	ret

; Subroutine to convert a 32-bit byte count to a 16-bit paragraph count.
;
;   Inputs:	AX = allocation flags or -1 if called from GlobalCompact
;		BX = stack address of 32-bit unsigned integer
;		DX = handle being reallocated or zero
;		DS:DI = address of GlobalInfo for global heap
;
;   Outputs:	AX = updated allocation flags
;		BX = #paragraphs needed to contain that many bytes
;		CX = owner value to use
;		DX = handle being reallocated or zero
;
gbtop:
	push	dx
	mov	dx,ss:[bx+2]
	mov	bx,ss:[bx]
	mov	cx,4
	add	bx,15
	adc	dx,0
	jnc	gbtop1
	dec	dx
	dec	bx
gbtop1:
	shr	dx,1
	rcr	bx,1
	loop	gbtop1
	pop	dx
	inc	ax
	jz	gbtopx		; All done if called from GlobalCompact
	dec	ax

	mov	[di].gi_cmpflags,al	; Save flags for gcompact
	test	dl,GA_FIXED		; Are we reallocating a fixed handle?
	jnz	gbtop4			; Yes, then go allocate low
	or	dx,dx			; Reallocating a moveable handle?
	jnz	gbtop3a 		; Yes, allocate high
	test	al,GA_MOVEABLE		; Is this a moveable request?
	jz	gbtop4			; No, then go allocate low
gbtop3a:
	or	al,GA_ALLOCHIGH 	; Yes, allocate high
	cmp	[di].gi_reserve,di	; Reserve area for code?
	je	gbtop4			; No, all moveable allocated high
	test	al,GA_DISCCODE		; Yes, is this discardable code?
	jnz	gbtop4			; Yes, then allocate high
	xor	al,GA_ALLOCHIGH 	; No, then allocate low
gbtop4:
	test	ah,HE_DISCARDABLE	; Discard level?
	jz	gbtop4a
	and	ah,not HE_DISCARDABLE	; Yes, convert to boolean value
	or	ah,GA_DISCARDABLE
gbtop4a:
	mov	cl,GA_SEGTYPE		; Copy segment type bits to handle
	and	cl,al
	or	ah,cl			; table flags
;*	* Figure out the owner field
	or	dx,dx			;* reallocating ?
	mov	cx,ownerData		;* owner for all global data
	jz	gbtopx			;* new block => global data
;*	* use the old owner field
	xchg	dx,si
	mov	cx,[si].he_address	;* owner or ps
	test	[si].he_flags,HE_DISCARDED
	jnz	owner_discarded 	;* owner in cx
;*	* we must get ga_owner field from resident block
	mov	es,cx
	mov	cx,es:[di].ga_owner	;* old owner field
owner_discarded:
	xchg	dx,si			;* restore si/dx
gbtopx:
	ret

; Subroutine to get the available memory.
;
gavail:
	mov	byte ptr [di].gi_cmpflags,0
	call	gcompact
	or	dx,dx
	jz	gavail1
	jmp	gcsize
gavail1:
	push	dx			    ; No max yet
	mov	es,[di].hi_first
gcstat:
	cmp	es:[di].ga_sig,GA_ENDSIG    ; Last block?
	je	gcstat3 		    ; Yes all done
	mov	es,es:[di].ga_next	    ; Next block
	cmp	es:[di].ga_owner,di	    ; Free?
	je	gcstat0 		    ; Yes
	mov	si,es:[di].ga_handle
	or	si,si			    ; Fixed?
	jz	gcstat			    ; Yes, next block
	cmp	[si].he_count,0 	    ; Locked?
	jne	gcstat			    ; Yes, next block
	test	[si].he_flags,GA_DISCARDABLE	; Discardable?
	jz	gcstat			    ; No, next block
	test	es:[di].ga_flags,GA_DISCCODE; No, discardable code?
	jnz	gcstat			    ; Yes, next block
gcstat0:
	push	es			    ; Save starting point
	mov	ax,es:[di].ga_size	    ; Use this size
	mov	cx,[di].hi_count
gcstat0a:
	mov	es,es:[di].ga_next	    ; Next block
	cmp	es:[di].ga_owner,di	    ; Free?
	je	gcstat1 		    ; Yes, include size
	cmp	es:[di].ga_sig,GA_ENDSIG    ; End of arena?
	je	gcstat0b		    ; Yes, handle reserve area
	mov	si,es:[di].ga_handle
	or	si,si			    ; Fixed?
	jz	gcstat2 		    ; Yes, stop looking
	cmp	[si].he_count,0 	    ; Locked?
	jne	gcstat2 		    ; Yes, stop looking
	test	[si].he_flags,GA_DISCARDABLE	; Discardable?
	jz	gcstat1a		    ; No, dont include in count then
	test	es:[di].ga_flags,GA_DISCCODE; Yes, discardable code?
	jz	gcstat1 		    ; No, include in count then
gcstat0b:
	mov	si,es			    ; Yes, see if we are trying
	sub	si,[di].hi_last 	    ; to steal some of the reserve area
	neg	si
	sub	si,[di].gi_reserve
	inc	ax			    ; add in one arena header
	add	ax,si			    ; Adjust amount by reserve area
	jz	gcstat2
	dec	ax			    ; remove one arena header
	jmp	short gcstat2
gcstat1:				    ; Free or Discardable
	add	ax,es:[di].ga_size	    ; Increase availabe space
	inc	ax			    ; by size of this block
gcstat1a:				    ; Moveable
	loop	gcstat0a
gcstat2:
	pop	es			    ; Back to starting point
	cmp	ax,dx			    ; Did we find a bigger block?
	jbe	gcstat			    ; No, then look again
	mov	dx,ax			    ; Yes, remember size
	pop	ax
	push	es			    ; ...and block
	jmp	gcstat
gcstat3:
	pop	es
	mov	ax,dx
gcsize:
	or	ax,ax		    ; zero mem available?
	jz	gcfinal 	    ; yes, return 0
	dec	ax		    ; Dont be too exact
	jz	gcfinal
	dec	ax
gcfinal:
	and	al,GA_MASK	    ; round down to nearest alignment
	xor	dx,dx
	ret

;********** gnotify **********
; Subroutine to update all info if a global object moved / discarded
;
;   Inputs:	AL = message code (GN_MOVE, GN_DISCARD)
;		BX = handle
;		CX = optional argument (new ps, discard flags)
;*		DX = original owner field
;*		DS = pGlobalHeap
;
;   Outputs:	n/a
;
;   Destroys:	AX,BX,CX,DX,ES
;
gnotify:
IFDEF DEBUG
;*	* Test for valid owner
	or	dh,dh
	jz	ok_notify_owner 		;* code segment
	cmp	dx,ownerData
	jz	ok_notify_owner 		;* data segment
	cmp	dx,-1
	jz	ok_notify_owner 		;* master object
bad_notify_owner:
	cCall	CowAssertFailed
	DB	"gnotify : bad owner$"
ok_notify_owner:
ENDIF ;DEBUG

	xor	ah,ah
	push	si
	push	di

IFNDEF NOPCODE
	Save	<ax,bx,cx,dx>
	cCall	FixHandleTable
ENDIF ;NOPCODE

	mov	di,cx				;* di = new ps / discard flags
	mov	cx,dx				;* cx = owner
	AssertReset bl,GA_FIXED 		;* MUST BE MOVEABLE
					;* never discard FIXED objects
	mov	si,[bx].he_address
	AssertNe si,0				;* the old block must exist
	Assert	<GN_MOVE EQ 1>
	dec	ax
	jnz	notify_discard

;*	* MOVING :
	AssertNe di,0				;* di = new destination ps
	mov	[bx].he_address,di		;* update handle address
IFDEF KEEP_SYMDEB_CODE
	Save	<cx>
	cCall	DebugMovedSegment,<si,di>
ENDIF ; KEEP_SYMDEB_CODE
;*	* Test to see if we moved a code segment
	or	ch,ch				;* upper byte zero for CODE
	jnz	notify_move_data
;*	* moving code
	Save	<cx>
	cCall	PatchThunkMoved,<cx,di>
	cCall	PatchStackMoved,<cx,si,di>
	jmp	short notify_exit

notify_move_data:
;*	* Test to see if MOB moved
	mov	ax,ds
	cmp	ax,si			    ; Did we move DS?
	jne	notify_exit		    ; No, continue
;*	* We have moved the Master Object
	push	di				; update DS pointer.
	pop	ds
	mov	pGlobalHeap,ds			;* and the master object pointer
	jmp	short notify_exit

notify_discard:
	Assert	<GN_DISCARD EQ 2>
	AssertEq ax,1

;*	* DISCARDING :
	mov	[bx].he_address,0		;* discarded
IFDEF KEEP_SYMDEB_CODE
	Save	<cx>
	cCall	DebugFreeSegment,<si>
ENDIF ; KEEP_SYMDEB_CODE
	or	ch,ch				;* upper byte zero for CODE
	jnz	notify_exit			;* discarding data

;*	* Discarding code
	Save	<cx>
	cCall	PatchThunkDiscarded,<cx>
	cCall	PatchStackDiscarded,<cx,si>

notify_exit:
	pop	di
	pop	si
	ret


; Procedure to expand a global handle table
;
;   Inputs:	CX = #handle table entries to expand the table by
;		DS:DI global info structure
;
;   Outputs:	AX = address of handle table block of requested size
;
;   Destroys:	ES,BX,CX,DX
;
ghexpand:
	mov	ax,ds
	push	cx
	call	ghandle
	pop	cx
	jz	ghfail
	mov	dx,ax
	xor	ax,ax
	mov	bx,DS:[di].hi_htable
	mov	bx,DS:[bx].ht_count
	inc	bx
	add	bx,cx
	shl	bx,1
	shl	bx,1
	add	bx,DS:[di].hi_htable
	jc	ghfail
	add	bx,15
	jc	ghfail
	mov	cl,4
	shr	bx,cl
	; Dont allow master object into reserve swap area
	and	byte ptr [di].gi_cmpflags,not GA_DISCCODE
	call	grealloc
	jcxz	ghfail
	mov	dx,ax
	call	gdref
	jz	ghfail
	mov	bx,ES:[di].ga_size
	mov	cl,4
	shl	bx,cl
	sub	bx,HE_ALIGN
	and	bl,HE_MASK
	sub	bx,DS:[di].hi_htable
	mov	cl,2
	shr	bx,cl
	mov	ax,bx
	mov	bx,DS:[di].hi_htable
	mov	cx,ax
	xchg	DS:[bx].ht_count,ax
	sub	cx,ax
	inc	bx
	inc	bx
	shl	ax,1
	shl	ax,1
	add	bx,ax
	xchg	bx,di
	call	hthread
	mov	DS:[di],cx
	mov	di,bx
	mov	cx,ax
	ret
ghfail:
	xor	cx,cx
	ret

gmemcheck:
	or	ax,ax
	jz	gmemfail
	ret
gmemfail:
	ret


SUBRS	ENDP


IFNDEF NOPCODE
;********** FixHandleTable **********
;    Inputs:	AL = message code (GN_MOVE, GN_DISCARD)
;		BX = handle
;		CX = optional argument (new ps, discard flags)
;*		DS = pGlobalHeap
;*	* Fix Handle Table
;*	exit : n/a - Trashes AX,BX,CX,DX,DI,ES

cProc	FixHandleTable,<NEAR,ATOMIC>
cBegin	FixHandleTable

;*	* find new address
	cmp	al,GN_MOVE
	je	move_in_handle_table
	xor	cx,cx				;* new ps is 0
move_in_handle_table:

	mov	ax,ss
	mov	es,ax				;* set ES to DDS

;*	* find old address
	mov	ax,ds:[bx].he_address

;*	* set up for test : ax = old ps, cx = new ps
	mov	dx,cx				;* dx = psNew
	mov	di,dataOffset $q_mpsnq
	mov	cx,DGROUP:[DI-4]		;* count of entries

;*	* scan till old value matched
	cld
fix_ht_loop:
	jcxz	fix_ht_end
	repne	scasw
	jne	fix_ht_end
	mov	es:[di-2],dx
	jmp	fix_ht_loop
fix_ht_end:

cEnd	FixHandleTable

ENDIF ;!NOPCODE

;*****************************************************************************

; The remainder of this file implements the exported interface to the
; global memory manager.
;
;   DWORD	far PASCAL GlobalSize( HANDLE );
;   HANDLE	far PASCAL GlobalAlloc( WORD, DWORD );
;   HANDLE	far PASCAL GlobalReAlloc( HANDLE, DWORD, WORD );
;   HANDLE	far PASCAL GlobalFree( HANDLE );
;   DWORD	far PASCAL GlobalCompact( DWORD );
;   #define GlobalDiscard( h ) GlobalReAlloc( h, 0L, GMEM_MOVEABLE )
;   HANDLE	far PASCAL GlobalHandle( WORD );
;


;
; Procedure return the handle for a global segment.
;
;   Inputs:	Stack = sp   -> near return return address of ghandle
;			sp+2 -> far return return address of caller
;			sp+6 -> segment address parameter
;
;   Outputs:	AX = handle or zero if invalid segment address
;		Old DS,DI have been pushed on the stack
;		Z flag set if invalid or fixed segment.  O.W. Z flag
;		reset and BX = pointer to handle table entry
;			  CX = flags and count word from handle table
;			  DX = segment address
;			  ES:DI = arena header of object
;			  DS:DI = master object segment address
;
;
;
xhandle PROC	NEAR
	pop	dx		    ; Get near return address
	mov	bx,sp		    ; Get seg parameter from stack
	mov	ax,SS:[bx+4]
	inc	ax		    ; Is it -1?
	jz	xh2		    ; Yes, handle special
	dec	ax		    ; No, restore AX
xh1:
	push	ds		    ; Save DS:DI
	push	di
	mov	ds,pGlobalHeap		; Point to master object
	xor	di,di
	inc	ds:[di].gi_lrulock
	push	dx		    ; Call ghandle and return
	jmp	ghandle 	    ; to our caller directly
xh2:
	mov	ax,ds		    ; If passed -1 use callers DS
	jmp	xh1
xhandle ENDP


cPublic GlobalHandle
;   parmW   seg
cBegin	nogen
gh0:
	call	xhandle
xhandlex:
	dec	ds:[di].gi_lrulock
	pop	di
	pop	ds
	ret	2
cEnd	nogen ;GlobalHandle


cPublic GlobalSize
;   parmW   h
cBegin	nogen
	call	xhandle 		; Call ghandle with handle in DX
	or	dx,dx			; Did we get a segment address?
	jz	xhandlex		; No, all done then
	mov	ax,ES:[di].ga_size	; Yes, get size in paragraphs
	push	ax
	xor	dx,dx			; Returning a long result
	mov	cx,4
gs2:
	shl	ax,1
	rcl	dx,1
	loop	gs2
	pop	cx			; Return number paragraphs in CX
	jmp	short xhandlex
cEnd	nogen ;GlobalSize


cPublic GlobalAlloc,<>,<ds,si,di>
    parmW   flags
    parmD   nbytes
cBegin
	CheckHeap   GlobalAlloc
IFDEF	WINDOWS_OLD_APP
	cmp	fWoaPresent,0
	jz	GA10
	xor	ax,ax
	cCall	WoaRelease,<nbytes,ax>
GA10:
ENDIF	; WINDOWS_OLD_APP
; EnterCrit
	call	genter			; About to modify memory arena
	xor	dx,dx			; No handle
	mov	ax,flags		; Allocate space for object
	lea	bx,nbytes		; Convert requested bytes to paragraphs
	call	gbtop			; ... into BX
	call	galloc
	call	gmemcheck
cEnd	GlobalAlloc


cPublic GlobalReAlloc,<>,<ds,si,di>
    parmW   h
    parmD   nbytes
    parmW   rflags
cBegin
	CheckHeap   GlobalReAlloc

IFDEF	WINDOWS_OLD_APP
	cmp	fWoaPresent,0
	jz	GR10
	cCall	GlobalSize,<h>
	sub	ax, WORD PTR (nbytes)
	sbb	dx, WORD PTR (nbytes+2)
	jnc	GR10
	xor	ax,ax
	cCall	WoaRelease,<nbytes,ax>
GR10:
ENDIF	; WINDOWS_OLD_APP

; EnterCrit
	call	genter		    ; About to modify memory arena
	mov	dx,h
	mov	ax,rflags
	lea	bx,nbytes	    ; Convert requested bytes to paragraphs
	call	gbtop		    ; ... into BX
	call	grealloc	    ; Reallocate global object
	call	gmemcheck
cEnd	GlobalReAlloc


cPublic GlobalFree,<>,<ds,si,di>
    parmW   h
cBegin
	CheckHeap   GlobalFree
; EnterCrit
	call	genter		    ; About to modify memory arena
IFDEF DEBUG
	mov	dx,h
	call	gdref
	or	si,si
	jz	free_ok
	cmp	ch,00h		    ; Debugging check for count underflow
	je	free_ok
	cCall	CowAssertFailed
	DB	"GlobalFree: freeing locked object$"
free_ok:
ENDIF ;DEBUG
	mov	dx,h		    ; Free handle
	xor	cx,cx		    ; Dont check owner field
	call	gfree
cEnd	GlobalFree


cPublic GlobalCompact,<>,<ds,si,di>
    parmD   minBytes
cBegin
IFDEF	DUAL
IFDEF	DEBUG
	mov	cx,fProtectMode		; real mode only!
	jcxz	@F
	BREAKPOINT			; m3 would call cowassertfaileddos3
@@:
ENDIF
ENDIF
	CheckHeap   GlobalCompact
; EnterCrit
	call	genter		    ; About to modify memory arena
	mov	ax,-1
	lea	bx,minBytes
	call	gbtop
	clc			    ; galign should be called with carry clear
	call	galign
	call	gavail		    ; Returns paragraphs in DX:AX
	mov	cx,4		    ; Convert paragraphs to bytes
	push	ax
gcsize1:
	shl	ax,1
	rcl	dx,1
	loop	gcsize1
	pop	cx		    ; let caller to jcxz to test failure
cEnd	GlobalCompact


;*****************************************************************************
;* Debug support

IFDEF	DEBUG

;********** PrintGlobalHeap **********
;*	entry : n/a
;*	* print the contents of the global heap
;*	exit : n/a
;*	* NOTE : this code must be fixed since it throws everything out.

cProc	PrintGlobalHeap, <FAR, PUBLIC, ATOMIC>, <DS,ES,SI,DI,AX,BX,CX,DX>
cBegin	PrintGlobalHeap

	mov	ax,DGROUP
	mov	ds,ax
    assumes DS,DGROUP

;*	* compact the heap (removing any free gaps) -- throw out code as well

	mov	es,pGlobalHeap
	xor	di,di

	mov	es,es:[di].hi_first	 ;* es => first block.
;*	* scan from end till finding free block

Print_next_thunk:
	xor	ah,ah			;get all pieces to print.
	mov	al,es:[di].ga_sig	; Put sig with flags
	mov	ah,es:[di].ga_flags
	mov	bx,es:[di].ga_owner
	mov	cx,es:[di].ga_size
	mov	dx,es:[di].ga_next	;
	mov	si,offset dgroup:szThunkFormat

	push	es
?PLM = 0
	cCall	dprintf, <si,es,ax,bx,cx,dx>
?PLM = 1
	pop	es

	mov	ax,es
	cmp	ax,dx			;see if at end of list
	jz	end_print		; yes lets get out
	mov	es,dx			; no move to segment
	jmp	Print_next_thunk

end_print:

cEnd	PrintGlobalHeap
ENDIF ;DEBUG


;*****************************************************************************

sEnd	KERNEL

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\lmem.h ===
/*
	LMEM.H : Local Memory Manager Exports
*/

/*	* Heap Compaction Flags	*/
#define	fcmpCompact		1	/* compact data */
#define	fcmpCompactHandles	2	/* compact handles */

/*	* Out Of Memory Errors	*/
#define	merrAllocMoveable	1	/* allocating a moveable block */
#define	merrAllocFixed		2	/* allocating a fixed block */
#define	merrReallocMoveable	3	/* growing a moveable block */
#define	merrAllocBlock		4	/* allocating block of handles */

/*	* Special Zeros		*/
/* NOTE: hard coded numbers to get around compiler limitations */
#define pvZero	((VOID NEAR *)0x12)  /* a pointer to 0 length block, 1st byte is 0 */
#define ppvZero ((VOID NEAR * NEAR *)0x14) /* a pointer to pvZero */

/*	* Allocating a fixed block in a new heap always returns pvFixedMin */
/* NOTE: hard coded numbers to get around compiler limitations */
#define pvFixedMin ((VOID NEAR *)0x18)

/* global flag set after every compact */
extern BOOL PASCAL fCompactedHeap;


#ifdef DEBUG

/*	Debug global variables */
extern BOOL PASCAL fShakeHeap;
extern BOOL PASCAL fCheckHeap;
extern BOOL PASCAL fCheckHeapFree;	/* extra free checking -- slow */

/*	* function for introducing memory failures */
#ifndef MKHDR
extern BOOL (FAR PASCAL *lpfnFailLmemFilter)(WORD, SB, WORD);	/*OPTIONAL*/
#endif


/*	* Heap Info structure */

typedef struct _ckl
	{
	unsigned cblkFixed;
	unsigned cblkMoveable;
	unsigned chUsed;
	unsigned chFree;
	unsigned cbFixed;
	unsigned cbMoveable;
	} CKL;

#endif /*DEBUG*/

/* Error trapping */
extern int pascal cfailLmemError;
#define	DisarmLmemError()	(cfailLmemError++)
#define	RearmLmemError()	(cfailLmemError--)

/* Fast way to find length of block (in current SB only) */
#define	CbSizePpvSbCur(ppv) 	(*((*(WORD **)(ppv))-1))

/* Procedure Prototypes */
#ifdef CC
VOID		FAR PASCAL CreateHeap(SB);
WORD		FAR PASCAL CbCompactHeap(SB, WORD);
WORD		FAR PASCAL CbAvailHeap(SB);
VOID NEAR * NEAR *  FAR PASCAL PpvAllocCb(SB, WORD);
BOOL		FAR PASCAL FReallocPpv(SB, VOID NEAR * NEAR *, WORD);
VOID		FAR PASCAL FreePpv(SB, VOID NEAR * NEAR *);
WORD		FAR PASCAL CbSizePpv(SB, VOID NEAR * NEAR *);	/* CC ONLY */
VOID NEAR *	FAR PASCAL PvAllocFixedCb(SB, WORD);
WORD		FAR PASCAL CbSizeFixedPv(SB, VOID NEAR *);	/* CC ONLY */
VOID		FAR PASCAL LockHeap(SB);			/* OPTIONAL */
VOID		FAR PASCAL UnlockHeap(SB);			/* OPTIONAL */

BOOL		FAR PASCAL FCreateWindowsHeap(SB, WORD);

VOID NEAR * NEAR * FAR PASCAL HFirstAllocBlock(SB, WORD);	/* OPTIONAL */
VOID		FAR PASCAL FreeHandleBlock(SB, VOID NEAR * NEAR *); /* OPTIONAL */
VOID		FAR PASCAL SwapHandles(SB, VOID NEAR * NEAR *, VOID NEAR * NEAR *); /* OPTIONAL */

#ifdef DEBUG
VOID		FAR PASCAL CheckHeap(SB);
VOID		FAR PASCAL ShakeHeapSb(SB);
VOID		FAR PASCAL GetHeapInfo(SB, CKL FAR *);
BOOL		FAR PASCAL FCheckHandle(SB, VOID NEAR * NEAR *);
#endif /*DEBUG*/
/* Pseudo debug functions */
VOID NEAR * NEAR * FAR PASCAL PpvWalkHeap(SB, VOID NEAR * NEAR *);
VOID NEAR *	FAR PASCAL PvWalkFixedHeap(SB, VOID NEAR *);
#endif /*CC*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\newexe.inc ===
;	SCCSWHAT( "@(#)newexe.inc	1.1 87/12/19 16:42:42	" )
;*
;*	COW : Character Oriented Windows
;*
;*	newexe.inc : Munged version of NEWEXE
;*	* things that are not used for COW have been removed

EMAGIC	= 05A4Dh
ERESWDS =  0010h

EXE_HDR     STRUC
e_magic     DW	?		; magic in same location
e_cblp	    DW	?
e_cp	    DW	?
e_crlc	    DW	?
e_cparhdr   DW	?
e_minalloc  DW	?
e_maxalloc  DW	?
e_ss	    DW	?
e_sp	    DW	?
e_csum	    DW	?
e_cs	    DW	?
e_ip	    DW	?
e_lfarlc    DW	?
e_ovno	    DW	?
e_res	    DW	ERESWDS DUP (?)
e_lfanew    DD	?
EXE_HDR     ENDS


magicNe		= 336Eh		;* 'n3' for fast boot format


NERESBYTES	= 2

NEW_EXE 	STRUC
ne_magic	DW  ?		; Magic value 'ne'
ne_ver		DB  ?		; version number
ne_rev		DB  ?		; revision number
ne_enttab	DW  ?		; offset to entry table
ne_cbenttab	DW  ?		; number of bytes in entry table

ne_crc		DD  ?		; CRC of file

ne_flags	DW  ?		; flag word
ne_autodata	DW  ?		; segment number of auto data segment
ne_heap 	DW  ?		; initial size of local heap
ne_stack	DW  ?		; initial size of stack

ne_csip 	DD  ?		; CS:IP start address
ne_sssp 	DD  ?		; SS:SP initial stack pointer.	0 if
				; stack size word non-zero

ne_cseg 	DW  ?		; number of segment in segment table

IFDEF DUAL
ne_cmod 	DW  ?		; number of entries in module reference table
ne_cbnrestab	DW  ?		; number of bytes in non-resident name table
ELSE ;!DUAL
ne_sectorFix	DW  ?		;* sector where Fixed stuff starts
ne_cparaFix	DW  ?		;* # of fixed paragraphs to read
ENDIF ;!DUAL

ne_segtab	DW  ?		; NE relative offset to segment table
;;;ne_rsrctab	DW  ?		; NE relative offset to resource table
ne_cbRlbMax	DW  ?		;* Maximum size of rlb tables
ne_restab	DW  ?		; NE relative offset to resident name table
IFDEF DUAL
ne_rlbtab	DW  ?		;* offset of Rle entries
ne_imptab	DW  ?		; NE relative offset to imported name table
ne_nrestab	DD  ?		; file offset to non-resident name table
ELSE ;!DUAL
ne_cbRlbFix	DW  ?		;* size of rlbFix
ne_cbRlbMove	DW  ?		;* size of rlbMove
ne_lfaRlbMove	DD  ?		;* where rlbMove is located
ENDIF ;!DUAL

ne_cmovent	DW  ?		; Count of movable entries
ne_align	DW  ?		; Alignment shift count for segment data
ne_res		DB  NERESBYTES DUP (?)
ne_cparaReserve	DW  ?		;* # of reserved paragraphs for code
				;* set by fixstub
ne_rgentmove	DW  ?		;* offset to array of ENTMOVE
ne_psegcsum	DW  ?		; offset to segment chksums.
ne_pretthunks	DW  ?		; offset to return thunks
ne_psegrefbytes DW  ?		; offset to segment ref. bytes
NEW_EXE 	ENDS

;*	* Mini-header for swap files:

EXH	STRUC
magicExh	DW	?		;* magic value (magicNe)
chStampExh	DB	?		;* application version stamp
ifileExh	DB	?		;* ifile index check
lfaRlbExh	DD	?		;* address of RLB
cbRlbExh	DW	?		;* size of RLB
EXH	ENDS


;*	* Segment Table Info

NEW_SEG 	STRUC
ns_sector	DW  ?	; logical sector number in file of start of segment
ns_cbseg	DW  ?	; number bytes in file
ns_flags	DW  ?	; segment flags
ns_minalloc	DW  ?	; minimum number bytes to allocate for segment
NEW_SEG 	ENDS

NEW_SEG1        STRUC
                DB  SIZE NEW_SEG DUP (?)
ns_handle       DW  ?   ; Handle to segment (0 if not loaded)
NEW_SEG1        ENDS

NSTYPE		=  0007h    ; Segment type mask
NSCODE		=  0000h    ; Code segment
NSDATA		=  0001h    ; Data segment
NSMOVE		=  0010h    ; Moveable segment
NSPRELOAD	=  0040h    ; Preload this segment
NSRELOC 	=  0100h    ; Relocation information following segment data

NSDPL		=  0C00h	;;* IO priv level (for file index !!)
SHIFTDPL	=  10


;*	* Entry Table Info

ENT_UNUSED	= 000h
ENT_MOVEABLE	= 0FFh
ENT_PUBLIC	= 001h
ENT_DATA	= 002h


ENT		STRUC
ent_flags	DB	?
ENT		ENDS

ENTM		STRUC
		DB	SIZE ENT DUP (?)
entm_int3f	DW	?
entm_seg	DB	?
entm_offset	DW	?
ENTM		ENDS

ENTF		STRUC
		DB	SIZE ENT DUP (?)
entf_offset	DW	?
ENTF		ENDS


;*	* Moveable entry in RAM - already reloaded & re-lru'd
ENTMOVE		STRUC
opcEntmove	DB  ?			;* JMPF opcode
offEntmove	DW  ?			;* offset
segEntmove	DW  ?			;* segment
segnoEntmove	DB  ?			;* segment #
ENTMOVE		ENDS

;*	* Moveable entry in RAM - Near jump to LOM far jump
ENTMOVE1	STRUC
opcEntmove1	DB  ?			;* CALLN opcode
relEntmove1	DW  ?			;* relative jump - Reload or Relru
offDestEntmove1	DW  ?			;* destination offset
segnoEntmove1	DB  ?			;* segment #
ENTMOVE1	ENDS

;*	* Return thunk (in RAM)
ENTRET		STRUC			;* Return thunk
opcEntret	DB	?		;* CALLN opcode
relEntret	DW	?		;* relative jump - RetThunk
segnoEntret	DB	?		;* segment to return to
offEntret	DW	?		;* offset of top return thunk
ENTRET		ENDS


;*	* Opcodes *
opcCallf	= 09ah			;* CALLF opcode
opcCalln	= 0e8h			;* CALLN opcode
opcJmpn		= 0e9h			;* JMPN opcode
opcJmpf		= 0eah			;* JMPF opcode

;*	* SEGREF byte info (i.e. LRU)
segrefFixed	=	0F0h		;* fixed segment no LRU
segrefLoaded	=	000h		;* just loaded
segrefDiscarded	=	0D0h		;* not resident
segrefBound	=	0B0h		;* bound segment
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\indrv.h ===
/*
	CW: Character Oriented Windows
	
	indrv.h: Installable screen driver - driver info
*/

/*****************************************************************************/

/***BEGIN_PUBLIC***/
#define	fmemFixed	1		/* always set !! */
#define	fmemNear	2		/* allocate near */

/* limit of near space / driver service */
#define	cbNearMemServiceMax	128

/* INDT: Driver Service Types */
#define	indtNil			0
#define	indtKeyboard		1			/* .KBD */
#define	indtCharacterScreen	2			/* .CSD */
#define	indtGraphicScreen	3			/* .GSD */
#define	indtCharacterPrinter	4			/* .PRD */
#define	indtGraphicPrinter	5			/* .GPD */
#define	indtSystem		6			/* .SYD */
#define	indtSerialComm		7			/* .SCD */
/* ... others to be defined ... */

typedef struct _indv
	{
	/* input values */
	BYTE	indt;				/* service wanted */
	BYTE	filler;				/* reserved */
	LPFN *	rglpfn;				/* where to put vectors */
	WORD	cpfnNeedMin;			/* # entries needed */
	WORD	cpfnNeedMac;			/* # entries wanted */
	/* return values */
	WORD	psLoaded;			/* != 0 => loaded */
	WORD	cpfnLoaded;			/* # entries loaded */
	} INDV;

WORD	FARPUBLIC RerrLoadDrv(char *, INDV *, WORD);	/* OPTIONAL */
WORD	FARPUBLIC RerrLoadCwDrv(char *);		/* OPTIONAL */

/***END_PUBLIC***/

/*****************************************************************************/
/* installable screen drivers */


#define	szMagicDRV	"DRV0"		/* CW Drivers version #0 */

typedef struct _indh
	{
	char	rgchMagic[4];
	DWORD	dlfaTable;		/* offset from end of file */
	} INDH;		/* driver header (at end of file) */

typedef struct _inds
	{
	BYTE	indt;			/* service type */
	BYTE	fload;			/* load flags */
	WORD	cbCode;			/* size of code (in file) */
	DWORD	dlfaCode;		/* offset from INDH */
	} INDS;		/* driver service */

typedef struct _indt
	{
	char	rgchMagic[4];
	WORD	cinds;				/* # of device services */
	INDS	rginds[1];			/* variable length */
	} INDT;		/* driver table (directory) */


/* FLOAD: load flags */
#define	floadFixed	1			/* must allocated fixed */
#define	floadRealMode	0x10			/* loads under Real Dos */
#define	floadProtMode	0x20			/* loads under OS/2 */
#define	floadAnyMode	(floadRealMode|floadProtMode) /* loads under any OS */
#define	floadStandard	0x80			/* adheres to standard format */

/*****************************************************************************/
/* OS Specific information */


/*
* For OS/2, we provide far pointers several DLL entry points
*/
typedef VOID		(FAR PASCAL *LPFN_DOS)();

typedef	struct _inos
	{
	/* Driver-OS/2 linkage */
	WORD		sdGlis;			/* global info */
	WORD		sdLois;			/* local info */

	WORD		cpfn;			/* # of entries in INOS */

	/* Configuration info */
	LPFN_DOS	lpfnDosGetVersion;	/* DosGetVersion */
	LPFN_DOS	lpfnDosGetEnv;		/* DosGetEnv */
	LPFN_DOS	lpfnDosDevConfig;	/* DosDevConfig */
	LPFN_DOS	lpfnDosGetCtryInfo;	/* DosGetCtryInfo */
	LPFN_DOS	lpfnDosGetDBCSEv;	/* DosGetDBCSEv */
	LPFN_DOS	lpfnDosGetInfoSeg;	/* DosGetInfoSeg */

	/* Low level hardware access */
	LPFN_DOS	lpfnDosDevIOCtl;	/* DosDevIOCtl */
	LPFN_DOS	lpfnDosPortAccess;	/* DosPortAccess */

	/* Linkage to DLL entries (for ones not listed here) */
	LPFN_DOS	lpfnDosGetModHandle;	/* DosGetModHandle */
	LPFN_DOS	lpfnDosLoadModule;	/* DosLoadModule */
	LPFN_DOS	lpfnDosGetProcAddr;	/* DosGetProcAddr */

	/* Threads */
	LPFN_DOS	lpfnDosCreateThread;	/* DosCreateThread */
	LPFN_DOS	lpfnDosSetPrty;		/* DosSetPrty */
	LPFN_DOS	lpfnDosExit;		/* DosExit */

	/* File Routines */
	LPFN_DOS	lpfnDosOpen;		/* DosOpen */
	LPFN_DOS	lpfnDosClose;		/* DosClose */
	LPFN_DOS	lpfnDosRead;		/* DosRead */
	LPFN_DOS	lpfnDosWrite;		/* DosWrite */

	/* Monitor Routines */
	LPFN_DOS	lpfnDosMonOpen;		/* DosMonOpen */
	LPFN_DOS	lpfnDosMonClose;	/* DosMonClose */
	LPFN_DOS	lpfnDosMonReg;		/* DosMonReg */
	LPFN_DOS	lpfnDosMonRead;		/* DosMonRead */
	LPFN_DOS	lpfnDosMonWrite;	/* DosMonWrite */

	/* Memory Allocation */
	LPFN_DOS	lpfnDosAllocSeg;	/* DosAllogSeg */
	LPFN_DOS	lpfnDosReAllocSeg;	/* DosReAllocSeg */
	LPFN_DOS	lpfnDosFreeSeg;		/* DosFreeSeg */

	/* Common VIO Routines */
	LPFN_DOS	lpfnVioGetBuf;		/* VioGetBuf */
	LPFN_DOS	lpfnVioShowBuf;		/* VioShowBuf */
	LPFN_DOS	lpfnVioGetConfig;	/* VioGetConfig */
	LPFN_DOS	lpfnVioGetMode;		/* VioGetMode */
	LPFN_DOS	lpfnVioSetMode;		/* VioSetMode */
	LPFN_DOS	lpfnVioGetState;	/* VioGetState */
	LPFN_DOS	lpfnVioSetState;	/* VioSetState */

	LPFN_DOS	lpfnVioGetCurType;	/* VioGetCurType */
	LPFN_DOS	lpfnVioSetCurType;	/* VioSetCurType */
	LPFN_DOS	lpfnVioGetCurPos;	/* VioGetCurPos */
	LPFN_DOS	lpfnVioSetCurPos;	/* VioSetCurPos */

	LPFN_DOS	lpfnVioGetFont;		/* VioGetFont */
	LPFN_DOS	lpfnVioSetFont;		/* VioSetFont */
	LPFN_DOS	lpfnVioGetCP;		/* VioGetCP */
	LPFN_DOS	lpfnVioSetCP;		/* VioSetCP */

	LPFN_DOS	lpfnVioScrollUp;	/* VioScrollUp */

	/* Common KBD Routines */
	LPFN_DOS	lpfnKbdOpen;		/* KbdOpen */
	LPFN_DOS	lpfnKbdClose;		/* KbdClose */
	LPFN_DOS	lpfnKbdCharIn;		/* KbdCharIn */
	LPFN_DOS	lpfnKbdGetStatus;	/* KbdGetStatus */
	LPFN_DOS	lpfnKbdSetStatus;	/* KbdSetStatus */

	/* Misc */
	LPFN_DOS	lpfnDosBeep;		/* DosBeep */

	LPFN_DOS	lpfnVioGetPhysBuf;	/* VioGetPhysBuf */

	/* special IOPL routines */
	LPFN_DOS	lpfnCwBeginIO;		/* CwBeginIO */
	LPFN_DOS	lpfnCwEndIO;		/* CwEndIO */

	/* more may be added (at the end) in the future */
	} INOS;


/*****************************************************************************/
/* Call Back Services */

typedef	struct _incs
	{
	WORD		cpfn;			/* # of entries in INCS */

#ifdef LATER
	/* to be defined */
#endif /*LATER*/

	} INCS;

/*****************************************************************************/
/* Standard header */

/* When "floadStandard" is specified, this structure should be at the start
	or each service's code segment */

typedef struct _insh
	{
	union
		{
		struct	/* in file representation */
			{
			WORD	cbData;		/* size of data segment */
			WORD	fmem;		/* allocation flags */
			} in_file;
		struct
			{
			WORD FAR * lpwData;	/* far pointer to data */
			} in_mem;
		} lpwData;

	INOS *	pinos;			/* pointer to OS specific info,
						will be 0 for DOS 3 */
	INCS *	pincs;			/* pointer to INCS */

	WORD	cpfn;
	/* followed by an array of NPFN_DRV pointers ("cpfn" of them) */
	} INSH;

typedef WORD	NPFN_DRV; /* offset to near procedure (never use directly) */

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\cow.inc ===
;*
;*	COW : Character Oriented Windows
;*
;*	cow.inc : general assembly include file

DEBPUB = 1		;* always debugging publics

IFDEF ?LOADER
;**** LOADER ****
memS = 1
?WIN = 0

ELSE
;**** NON-LOADER ****
memM = 1

IFDEF COW_SWAPPED
?WIN = 1
?COW = 1
ELSE
?WIN = 0
ENDIF ;!COW_SWAPPED

IFDEF DOS5
?DOS5 = 1
ENDIF

IFDEF PROFILE	;* don't profile loader
PROFILE1 = 1
ENDIF ;PROFILE
ENDIF ;!?LOADER

?PLM = 1
?TF = 1
?DF = 1
?NODATA = 1
	include	cmacros.inc	;* must be version 2.09 or higher

;*	* Create DGROUP
createSeg _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
createSeg _BSS,BSS,WORD,PUBLIC,BSS,DGROUP
defGrp DGROUP,DATA,BSS

	include	version.inc

wo	equ	word ptr
by	equ	byte ptr

;*****************************************************************************
;*	* Model Control *
;*
;*	PUBLIC is always FAR
;*	COW_TINY_SWAPPED		=> private is FAR
;*	!COW_TINY_SWAPPED		=> private is NEAR (all in COW_TEXT)
;*
;*	* PUBLIC => all public (exported) interfaces
;*	* PRIVATE => private normal code (entries not exported)
;*****************************************************************************

;*	* external Absolute values
IFNDEF externA	;* not defined in old CMACROS
externA macro n
?ex1 <n>,0,<ABS>
endm
ENDIF

cPublic	MACRO	n,c,a
	cProc	n,<FAR, PUBLIC, c>,<a>
ENDM

externFPublic MACRO	x
	externFP	<x>
ENDM

IFNDEF COW_TINY_SWAPPED
cPrivate MACRO	n,c,a
	cProc	n,<NEAR, PUBLIC, c>,<a>
ENDM
externFPrivate MACRO	x
	externNP	<x>
ENDM
ELSE
cPrivate MACRO	n,c,a
	cProc	n,<FAR, PUBLIC, c>,<a>
ENDM
externFPrivate MACRO	x
	externFP	<x>
ENDM
ENDIF ;COW_TINY_SWAPPED

; define misc. register pairs
;
regptr  esax,es,ax
regptr  esbx,es,bx
regptr  essi,es,si
regptr  esdi,es,di
regptr  dssi,ds,si
regptr  dsdi,ds,di
regptr  cssi,cs,si
regptr  csdi,cs,di
regptr  dxax,dx,ax
regptr  ssbx,ss,bx
regptr	dsbx,ds,bx

PushArg	MACRO	arg_list		;; Push multiple registers
	irp	x,<arg_list>
		push	x
	endm
ENDM

;============================================================================

;*	* Assembly time Assert *

Assert	MACRO	expr		;;* Assembly time assertion check
    IFE expr
	%OUT Assertion Failed !expr!
	.ERR
    ENDIF
ENDM

;*	* Run time Asserts *

BREAKPOINT MACRO		;;* insert breakpoint if debugging
    IFDEF DEBUG
	INT	3
    ENDIF
ENDM

ifdef	Debug

IFNDEF ?LOADER
IFNDEF ?LDDEBUG
externFP <CowAssertFailed>
ENDIF
ELSE
IFNDEF ?LOADER_ASM
externNP <CowAssertFailed>		;* loader assert trap
ENDIF
ENDIF

AssertEq MACRO	p1,p2		;;* Run time assert 2 values equal
	LOCAL	ok
	cmp	p1,p2
	je	ok
	cCall	CowAssertFailed
ok:
ENDM
AssertNe MACRO	p1,p2		;;* Run time assert 2 values not equal
	LOCAL	ok
	cmp	p1,p2
	jne	ok
	cCall	CowAssertFailed
ok:
ENDM
AssertSet MACRO	p1,m		;;* Run time assert value masked is non-zero
	LOCAL	ok
	test	p1,m
	jnz	ok
	cCall	CowAssertFailed
ok:
ENDM
AssertReset MACRO p1,m		;;* Run time assert value masked is zero
	LOCAL	ok
	test	p1,m
	jz	ok
	cCall	CowAssertFailed
ok:
ENDM
AssertUp MACRO			;;* Run time assert that D flag is clear
	LOCAL	ok
	push	ax
	pushf			;;* push flags
	pop	ax		;;* ax = flags
	test	ax,400h		;;* D flag
	pop	ax		;;* restore AX
	jz	ok
	cCall	CowAssertFailed	;;* D flag not reset !!!
ok:
ENDM
AssertCmp MACRO	a,cond,b	;* assert comparison condition
	LOCAL	ok
	CMP	a,b
	J&cond	ok
	BREAKPOINT
ok:
ENDM
AssertData MACRO sreg		;* assert a segment register is set to DDS (SS)
	LOCAL	ok
	PUSH	AX
	PUSH	BX
	MOV	AX,sreg
	MOV	BX,SS
	CMP	AX,BX
	POP	BX
	POP	AX
	JZ	ok
	BREAKPOINT
ok:
	assumes	sreg,DGROUP
ENDM
AssertZR MACRO			;* assert the zero flag is ZR.
	LOCAL	ok
	JZ	ok
	BREAKPOINT
ok:
ENDM
AssertNZ MACRO			;* assert the zero flag is NZ.
	LOCAL	ok
	JNZ	ok
	BREAKPOINT
ok:
ENDM
AssertCY MACRO			;* assert the carry flag is CY.
	LOCAL	ok
	JC	ok
	BREAKPOINT
ok:
ENDM
AssertNC MACRO			;* assert the carry flag is NC.
	LOCAL	ok
	JNC	ok
	BREAKPOINT
ok:
ENDM

else	; !Debug

AssertEq MACRO	p1,p2
ENDM
AssertNe MACRO	p1,p2
ENDM
AssertSet MACRO	p1,p2
ENDM
AssertReset MACRO p1,p2
ENDM
AssertUp MACRO
ENDM
AssertCmp MACRO	a,cond,b
ENDM
AssertData MACRO sreg
	assumes	sreg,DGROUP
ENDM
AssertZR MACRO
ENDM
AssertNZ MACRO
ENDM
AssertCY MACRO
ENDM
AssertNC MACRO
ENDM

endif	; !Debug

;============================================================================

;***** PROFILE SUPPORT *****
;*	* note do not use the ?PROFILE flag for CMACROS.INC since it will
;*	*   make all far procedures profiled

IFDEF PROFILE1
	externFP <StartCowMeas, StopCowMeas>

StartPublic MACRO
	cCall	StartCowMeas
ENDM
StopPublic MACRO
	cCall	StopCowMeas
ENDM
ELSE
StartPublic MACRO
ENDM
StopPublic MACRO
ENDM
ENDIF ;!PROFILE

;*	* Misc Macros

;********* ExitTrueUnless *********
;*	entry : label = label to jump to to return FALSE
;*	* TRICK : use the MOV AX,.... instruction to hide an XOR AX,AX
;*	exit : if entered from top of macro : AX != 0,
;*		if entered from label : AX == 0.

ExitTrueUnless	MACRO	label
	DB	0B8H			;; MOV AX,....
label:
	XOR	AX,AX
ENDM

;*****************************************************************************
;*	* DUAL mode specifics


IFDEF DUAL
cProcNorF	MACRO	label,save
	cProc	label	<FAR,PUBLIC,ATOMIC>,<save>
ENDM
ELSE ;!DUAL
cProcNorF	MACRO	label,save
	cProc	label	<NEAR,PUBLIC,ATOMIC>,<save>
ENDM
ENDIF ;!DUAL


IFDEF DUAL
externNorFP	MACRO	seg,label
	externFP	label
ENDM
ELSE ;!DUAL
externNorFP	MACRO	seg,label
sBegin	seg
	externNP	label
sEnd	seg
ENDM
ENDIF ;!DUAL


;*****************************************************************************
;*	* Structures:
;*	* NOTE: not generated

_ARC	STRUC		;* Absolute Rectangle
	axLeftArc	DB	?
	ayTopArc	DB	?
	axRightArc	DB	?
	ayBottomArc	DB	?
_ARC	ENDS

STF	RECORD	fEnabledStf:1, styleStf:15		;* style & flag

;*	* WND : window structure *
WND	STRUC
	idWnd		DW	?			;* id
	stfWnd		DB	(WIDTH STF) / 8 DUP (?)
	arcWindow	DB	SIZE _ARC DUP (?)
	arcClipping	DB	SIZE _ARC DUP (?)
	pfnWndProc	DD	?
	pwndParent	DW	?
	pwndSibbling	DW	?
	pwndChild	DW	?
	axCursor	DB	?
	ayCursor	DB	?
	rgwExtra	DW	?			;* array of WORDS
WND	ENDS

BOX	STRUC	;* Single and Double BCS
	chTopLeftBox	DB	?
	chTopRightBox	DB	?
	chBottomLeftBox	DB	?
	chBottomRightBox DB	?
	chTopBox	DB	?
	chBottomBox	DB	?
	chLeftBox	DB	?
	chRightBox	DB	?
BOX	ENDS


;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\cvtitl.c ===
/*
	cvtitl.c : pipe : convert illegal characters to \xxx characters
*/

#include <stdio.h>

main()
	{
	int	ch;

	while ((ch = getchar()) != EOF)
		{
		if (ch < 0x80)
			putchar(ch);
		else
			printf("\\%3o", ch);
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\inscr.h ===
/*
	CW: Character Windows

	inscr.h: CSD Driver specifics
*/

/***BEGIN_PUBLIC***/

/*****************************************************************************/
/* Extra Font info */

typedef struct _inft
	{
	/* character/font size */
	BYTE	dxChar; 		/* width of character in pixels */
	BYTE	dyChar; 		/* height of character in pixels */

	BYTE	dyBaseLine;		/* base line height */
	BYTE	ifont;			/* font index */
	} INFT;

/*****************************************************************************/
/* Installable state */

typedef WORD	FINST;
#define finstText			0x0001	/* text mode */
#define finstGraphics		0x0002	/* graphics mode */
#define finstMonochrome 0x0004	/* monochrome mode */
#define finstAlternate		0x0008	/* alternate adapter (2nd screen) */
#define finstFont			0x0010	/* supports fonts */
#define finstAttrFont		0x0020	/* map Font calls into attribute info */
#define finstExtendedMono	0x0040	/* EGA and VGA mono */
#define finstDisableMouse	0x1000	/* gfx w/o mouse support (hercules,os/2) */
#define finstFastScroll 0x2000	/* fast scroll (BltArc) for gfx text */
#define finstQuestionable	0x4000	/* questionable mode selection */
#define finstAvailable		0x8000	/* available with current hardware */

typedef struct _inst
	{
	FINST	finst;
	BYTE	axMac;
	BYTE	ayMac;

	/* color palette info */
	BYTE	coMac;			/* maximum color index */
	BYTE	covMac; 		/* maximum color value (palette) */
	WORD	coiMac; 		/* maximum color intensity */

	/* Extra information */
	WORD	imode;			/* video mode */

	INFT	inft;			/* font info (pointers may be NULL) */
	WORD	ffontSupported; /* valid ffont values */

	/* buffers (if non-zero then do not need to be allocated */
	WORD	psPrim; 		/* primary screen buffer */
	WORD	psSec;			/* secondary screen buffer */

	WORD	cwExtra;		/* requested extra size */
	WORD	psExtra;		/* extra screen buffer (driver's use) */

	/* CW internal info */
	BIT	fAllocPrim:1;
	BITS	filler:15;

	/* Driver specific info */
	WORD	wDriver1;
	WORD	reserved2[7];
	} INST;

/* Special IMODEs */
#define imodeUnknown	0xffff	/* unknown mode */

/*****************************************************************************/
/* Installable characters */

typedef struct _inch
	{
	/* Single Line Box */
	char	_chTopLeftCorner1;
	char	_chTopRightCorner1;
	char	_chBottomLeftCorner1;
	char	_chBottomRightCorner1;
	char	_chTopSide1;
	char	_chBottomSide1;
	char	_chLeftSide1;
	char	_chRightSide1;

	/* other single line */
	char	_chMiddleLeft1;
	char	_chMiddleRight1;

	/* Double Line Box */
	char	_chTopLeftCorner2;
	char	_chTopRightCorner2;
	char	_chBottomLeftCorner2;
	char	_chBottomRightCorner2;
	char	_chTopSide2;
	char	_chBottomSide2;
	char	_chLeftSide2;
	char	_chRightSide2;
	/*note: no middles */

	/* Arrows */
	char	_chUpArrow;
	char	_chDownArrow;
	char	_chLeftArrow;
	char	_chRightArrow;

	/* Misc */
	char	_chBullet;			/* for menu */
	char	_chMiddleDot;			/* for edit */
	char	_chScrollbar;			/* for scroll bar */
	char	_chElevator;			/* for scroll bar */
	char	_chShadowInit;			/* b&w shadow character */

	/* For Overlapping windows */
	char	_chClose;			/* Close box */
	char	_chZoomIn;			/* Zoom in */
	char	_chZoomOut;			/* Zoom out */
	char	_chUpDownArrow; 		/* double arrow */
	char	_chLeftRightArrow;		/* double arrow */

	WORD	reserved[16];
	} INCH;

/*****************************************************************************/
/* font variations */

#define ffontNormal		0x0000	/* normal attributes */

#define ffontUnderline		0x0001
#define ffontDoubleUnderline	0x0002
#define ffontOrUnderline	0x0003	/* ... underline */
#define ffontStrikeThrough	0x0004	/* horizontal strike through */
#define ffontBold		0x0008
#define ffontSubscript		0x0010
#define ffontSuperscript	0x0020
#define ffontMiniCap		0x0030	/* mini capital */
#define ffontItalic		0x0040
#define ffontOrCharacter	0x0080	/* extra field => font extension */
#define ffontReservedBits	0x0f00
#define ffontExtraMask		0xf000	/* one of 16 extra items */
#define ffontOrUnderlineSupport 0x1000

/*****************************************************************************/
/* screen save info */

typedef WORD	FVIDS;			/* flags */
#define fvidsChAttr	1		/* video buffer is in form ch:attr */

typedef struct _vids
	{
	BYTE	mode;			/* screen mode */
	BYTE	page;			/* page # */
	FVIDS	fvids;			/* flags for saved state */
	WORD	cwVidData;		/* # of bytes of screen data */
	WORD	cwExtra;		/* # of extra bytes for mode info */
	WORD	rgwExtra[1];		/* actually rgwExtra[cwExtra] */
	} VIDS; /* Video state */

/*****************************************************************************/

/***END_PUBLIC***/

/*****************************************************************************/
/* indtCharacterScreen service : loaded representation */

/*
  -- the INSJ structure contains far pointers to routines in an installable
	driver
*/

/* Prototypes for functions */
typedef WORD	(FAR PASCAL *LPFN_SC_CUR)(VOID);
typedef BOOL	(FAR PASCAL *LPFN_SC_QRY)(struct _inst *, WORD);
typedef BOOL	(FAR PASCAL *LPFN_SC_INIT)(struct _inst *, struct _inch *);
typedef VOID	(FAR PASCAL *LPFN_SC_TERM)(VOID);
typedef VOID	(FAR PASCAL *LPFN_SC_CURS)(AX, AY, BOOL);
typedef BOOL	(FAR PASCAL *LPFN_SC_GETPAL)(WORD, WORD *, DWORD *);
typedef VOID	(FAR PASCAL *LPFN_SC_SETPAL)(WORD, WORD, DWORD);

typedef VOID	(FAR PASCAL *LPFN_SC_UPDATE1)(AY, AX, BYTE, WORD, BOOL);
typedef VOID	(FAR PASCAL *LPFN_SC_UPDATE2)(VOID);
typedef VOID	(FAR PASCAL *LPFN_SC_UPDATE3)(VOID);	/* to be defined */

typedef WORD	(FAR PASCAL *LPFN_SC_CBVIDS)(VIDS *, INST *);
typedef WORD	(FAR PASCAL *LPFN_SC_SAVE1)(VIDS *);
typedef WORD	(FAR PASCAL *LPFN_SC_REST1)(VIDS *);
typedef WORD	(FAR PASCAL *LPFN_SC_SAVE2)(VIDS *, WORD FAR *);
typedef WORD	(FAR PASCAL *LPFN_SC_REST2)(VIDS *, WORD FAR *);
typedef VOID	(FAR PASCAL *LPFN_SC_MONITOR)(BOOL);

typedef BOOL	(FAR PASCAL *LPFN_SC_FQINFT)(struct _inft *, WORD);

typedef VOID	(FAR PASCAL *LPFN_SC_BLT)(AX, AY, BYTE, BYTE, AX, AY);

typedef VOID	(FAR PASCAL *LPFN_SC_GCM)(struct _inft *, BYTE, BYTE *);

#ifdef FL_TAIWAN
typedef VOID	(FAR PASCAL *LPFN_SC_END)(VOID);/* add on Chinese CMEX */
#endif

typedef struct _insj
	{
	/* Init */
	LPFN_SC_CUR	lpfnImodeGuessCurrentCsd;
	LPFN_SC_QRY	lpfnFQueryInstCsd;
	LPFN_SC_INIT	lpfnFInitCsd;
	LPFN_SC_TERM	lpfnTermCsd;

	LPFN_SC_CURS	lpfnMoveHwCursCsd;
	LPFN_SC_FQINFT	lpfnFQueryInftCsd;

	/* Color palette */
	LPFN_SC_GETPAL	lpfnFGetColorPaletteCsd;
	LPFN_SC_SETPAL	lpfnSetColorPaletteCsd;

	/* Screen update */
	LPFN_SC_UPDATE1 lpfnPrepUpdateCsd;
	LPFN_SC_UPDATE1 lpfnDoUpdateCsd;
	LPFN_SC_UPDATE2 lpfnDoneUpdateCsd;
	LPFN_SC_UPDATE3 lpfnSpecialUpdateCsd;

	/* Screen save/restore */
	LPFN_SC_CBVIDS	lpfnCbSizeVidsCsd;
	LPFN_SC_SAVE1	lpfnFSaveVidsCsd;
	LPFN_SC_REST1	lpfnFRestoreVidsCsd;
	LPFN_SC_SAVE2	lpfnSaveVidDataCsd;
	LPFN_SC_REST2	lpfnRestoreVidDataCsd;
	LPFN_SC_MONITOR lpfnEnableVidsMonitorCsd;

	/* block move for graphics text modes */
	LPFN_SC_BLT	lpfnBltArcCsd;

	/* return character bit map */
	LPFN_SC_GCM	lpfnGetCharMapCsd;

#ifdef FL_TAIWAN
	/* end of cow for Chinese CMEX function */
	LPFN_SC_END	lpfnEndCowCsd;
#endif
	} INSJ; /* Installable screen jump table */

#ifdef FL_TAIWAN
#define cpfnCsdMin	21
#else
#define cpfnCsdMin      20
#endif

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\gadebug.h ===
/*
	COW : Character Oriented Windows

	gacheck.h : header info for checking global heap
*/

#include "handle.h"


/*	* Additional Types */
typedef int (FAR PASCAL *FARPROC)();		/* Medium Model */
typedef int (NEAR PASCAL *NEARPROC)();		/* Medium Model */

typedef WORD *pWORD;

typedef struct
    {
    WORD Offset;
    WORD Segment;
    } FARADDR;
typedef FARADDR *pFARADDR;


typedef struct
	{
	BYTE            ga_sig;
	WORD            ga_owner;
	WORD            ga_size;
	BYTE            ga_flags;
	WORD            ga_prev;
	WORD            ga_next;
	HANDLEENTRY    *ga_handle;
	HANDLEENTRY    *ga_lruprev;
	HANDLEENTRY    *ga_lrunext;
	} GLOBALARENA;

typedef GLOBALARENA far *LPGLOBALARENA;

typedef struct
	{
	WORD	        hi_check;
	WORD            hi_freeze;
	WORD            hi_count;
	WORD            hi_first;
	WORD            hi_last;
	BYTE            hi_ncompact;
	BYTE            hi_dislevel;
	WORD            hi_distotal;
	HANDLETABLE    *hi_htable;
	HANDLEENTRY    *hi_hfree;
	WORD            hi_hdelta;
	NEARPROC        hi_hexpand;

	WORD            gi_minsize;
	WORD            gi_lrulock;
	HANDLEENTRY    *gi_lruchain;
	WORD            gi_lrucount;
	} GLOBALINFO;

typedef GLOBALINFO far *LPGLOBALINFO;

#define GA_SIGNATURE	0x4D
#define GA_ENDSIG	0x5A
#define GA_HOLESIG      0x4A
#define GA_FIXED 1
#define GA_ALIGN GA_FIXED
#define GA_MASK  (~ GA_ALIGN)

#define lpGlobalArena( w ) (LPGLOBALARENA)((DWORD)(w) << 16)
#define lpHandleEntry( w ) (LPHANDLEENTRY)((DWORD)lpGlobalHeap | (WORD)(w))
#define lpHandleTable( w ) (LPHANDLETABLE)((DWORD)lpGlobalHeap | (WORD)(w))
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\vkoem.h ===
/*
	COW : Character Oriented Windows

	vkoem.h : OEM keys
*/

/***BEGIN_PUBLIC***/
#ifndef NOVIRTUALKEYCODES  
/* OEM keys */
#define VK_OEM_NUMBER    (0x100+0x090)
#define VK_OEM_SCROLL    (0x100+0x091)
#define VK_OEM_SHIFT     (0x100+0x092)
#define VK_OEM_1         (0x100+0x0BA)
#define VK_OEM_PLUS      (0x100+0x0BB)
#define VK_OEM_COMMA     (0x100+0x0BC)
#define VK_OEM_MINUS     (0x100+0x0BD)
#define VK_OEM_PERIOD    (0x100+0x0BE)
#define VK_OEM_2         (0x100+0x0BF)
#define VK_OEM_3         (0x100+0x0C0)
#define VK_OEM_4         (0x100+0x0DB)
#define VK_OEM_5         (0x100+0x0DC)
#define VK_OEM_6         (0x100+0x0DD)
#define VK_OEM_7         (0x100+0x0DE)
#define VK_OEM_8         (0x100+0x0DF)
#define VK_OEM_9         (0x100+0x0E0)
#endif /*!NOVIRTUALKEYCODES*/  
/***END_PUBLIC***/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\umenu.h ===
/*
		COW: Character Oriented Windos
		
		umenu.h : Definitions for User Menu 
*/		

/***BEGIN_PUBLIC***/

#ifndef NOMENUS
/* hack for nameless unions in CC */
#ifdef CC
#define CC_USZ u
#define CC_URG u
#else
#define CC_USZ
#define CC_URG
#endif


typedef struct _mpvkeyid
	{
	WORD	vkey;
	WORD	idItem;
	} MPVKEYID;
#define VkeyOfVkKk(vk, kk)	((vk) | (kk))
typedef struct _menuitem
	{
	WORD	idItem;			/* id for menuitem */
	BITS	fEnabled:1;		/* TRUE => enabled, FALSE => greyed */
	BITS	fChecked:1;		/* TRUE => checked */
	BITS	fSeparator:1;		/* TRUE => separator */
	BITS	fHandle:1;		/* TRUE => use pszItem, else szItem */
	BITS	ichHilite:4;		/* index of prefix character */
	BITS	bParamUser:8;		/* available for application use */
	union
		{
		char *szItem;
		char **pszItem;
		} CC_USZ;
	WORD	wParamUser;		/* available for application use */
#ifdef KANJI
	WORD	chKanaAccel;		/* Kana Accelerators */
#endif /*KANJI*/
	} MENUITEM;
typedef struct _menu
	{
	WORD	idMenu;
	BITS	rxTitle:8;
	BITS	ichHilite:4;		/* index of prefix character */
	BITS	fHandle:1;
	BITS	fEnabled:1;		/* is menu 'enabled' (not greyed) */
	BITS	filler:2;
	WORD	cchTitle;
	char	*pchTitle;
	WORD	citem;
	WORD	cchitemMax;
	union
		{
		MENUITEM *rgmenuitem;
		MENUITEM **prgmenuitem;
		} CC_URG;
	WORD	wParamUser;		/* available for application use */
#ifdef KANJI
	WORD	chKanaAccel;		/* Kana Accelerators */
#endif /*KANJI*/
	} MENU;
typedef struct _menubar
	{
	WORD	cmenu;
	MENU	*rgmenu;
	MPVKEYID *rgmpvkeyid;
	} MENUBAR;

typedef MENU *PMENU;
typedef MENUITEM *PMENUITEM;
typedef MENUBAR *PMENUBAR;

/* menu item define macros :
	D => disabled
	H => string handle
	X => with index (otherwise default to 0)
*/

#ifndef KANJI
/* enabled simple item */
#define menuitem(mid, sz, w) {(mid), TRUE, FALSE, FALSE, FALSE,\
	0, 0, {(sz)}, (WORD) (w)},
#define menuitemD(mid, sz, w) {(mid), FALSE, FALSE, FALSE, FALSE,\
	0, 0, {(sz)}, (WORD) (w)},
#define menuitemDH(mid, psz, w) {(mid), FALSE, FALSE, FALSE, TRUE,\
	0, 0, {(char *)(psz)}, (WORD)(w)},
#define menuitemX(mid, sz, ich, w) {(mid), TRUE, FALSE, FALSE, FALSE,\
	(ich), 0, {(sz)}, (WORD) (w)},
#define menuitemDX(mid, sz, ich, w) {(mid), FALSE, FALSE, FALSE, FALSE,\
	(ich), 0, {(sz)}, (WORD) (w)},
/* separator */
#define	menuitemSep	{0, FALSE, FALSE, TRUE, FALSE, 0, 0, {NULL}, 0},

#else	/* KANJI - 1 extra value needed for Kana Accelerator */
	/* Accelerator should always be at start */

#define menuitem(mid, sz, chKana, w) {(mid), TRUE, FALSE, FALSE, FALSE,\
	0, 0, {(sz)}, (WORD) (w), (WORD) (chKana)},
#define menuitemD(mid, sz, chKana, w) {(mid), FALSE, FALSE, FALSE, FALSE,\
	0, 0, {(sz)}, (WORD) (w), (WORD) (chKana)},
#define	menuitemSep	{0, FALSE, FALSE, TRUE, FALSE, 0, 0, {NULL}, 0, 0},

#endif /*KANJI*/

#endif /*!NOMENUS*/

VOID		FARPUBLIC InitMenu(PWND, PMENUBAR);
BOOL		FARPUBLIC FEnableMenuBar(BOOL);
VOID		FARPUBLIC EnableMenu(WORD, BOOL);
VOID		FARPUBLIC EnableMenuItem(WORD, BOOL);
VOID		FARPUBLIC CheckMenuItem(WORD, BOOL);
BOOL		FARPUBLIC FMenuItemChecked(WORD);
PMENUITEM	FARPUBLIC FindMenuItem(WORD);
VOID		FARPUBLIC DrawMenubar(void);
VOID		FARPUBLIC OpenMenu(WORD);		/*OPTIONAL*/

/***END_PUBLIC***/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\inc\text.inc ===
;/* Text Manager routines - Supplied by the application */
externFP StartBigEdit	; void StartBigEdit(void);
externFP EndBigEdit	; void EndBigEdit(void);
externFP LinesInBuf	; ushort LinesInBuf(ushort);
externFP InsertLineBuf	; bool InsertLineBuf(ushort, ushort, ushort, char *);
externFP hbufScrap	; ushort hbufScrap(void);
externFP InsertBufInBuf ; void InsertBufInBuf(ushort, ushort, ushort);
externFP cbGetLineBuf	; ushort cbGetLineBuf(ushort, ushort, ushort, char *);
externFP FreeScrap	; void FreeScrap(void);
externFP DeleteLinesBuf ; void DeleteLinesBuf(ushort, ushort, ushort);
externFP ReplaceLineBuf ; bool ReplaceLineBuf(ushort, ushort, ushort, char *);
externFP GetLineAttrs	; LineAttr GetLineAttrs(void);
externFP fReadOnlyBuf	; bool fReadOnlyBuf(ushort);

;/* Other Application supplied routines */
externFP IsWordChar	; bool IsWordChar(byte);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\kernel.inc ===
;*
;*	COW : Character Oriented Windows
;*
;*	kernel.inc : kernel include file

.xlist
	include cow.inc
	include lom.inc
.list

;*	* must import from version file (for swapped versions)
;*	cparaRunShell = # paragraphs saved for running shell


IFDEF COW_SWAPPED

createSeg   CORE,KERNEL,BYTE,PUBLIC,CODE;* FIXED code

createSeg   INIT,INIT,BYTE,PUBLIC,CODE	;* Init code (discardable)

IFDEF COW_TINY_SWAP
createSeg   USER,EXIT,BYTE,PUBLIC,CODE	;* Exit code (discardable)
ELSE
createSeg   CORE,LOCALMEM,BYTE,PUBLIC,CODE ;* Local memory management
createSeg   EXIT,EXIT,BYTE,PUBLIC,CODE	;* Exit code (discardable)
ENDIF ;!COW_TINY_SWAP



IFDEF MOUSE_EXTRAS
createSeg   MOUSE_TEXT,MOUSE,BYTE,PUBLIC,CODE	;* Mouse code (discardable)
ENDIF ;MOUSE_EXTRAS

ELSE
;* not swaped => all 1 segment
createSeg   COW_TEXT,KERNEL,BYTE,PUBLIC,CODE;* FIXED code
createSeg   COW_TEXT,INIT,BYTE,PUBLIC,CODE	;* Init code (discardable)
createSeg   COW_TEXT,EXIT,BYTE,PUBLIC,CODE	;* Exit code (discardable)
createSeg   COW_TEXT,MOUSE,BYTE,PUBLIC,CODE	;* Mouse code (discardable)
ENDIF ;!COW_SWAPPED


;*	* Driver Segment
createSeg   DRV_FIXED,DRV,BYTE,PUBLIC,CODE		;* drivers


IFDEF DEBUG
exAssertFailed	=	99		;* exit code for Assert failed
ENDIF ;DEBUG

;*
;*	this will allow the release (non-debug) version of cow to
;*	have the code which communicates with symdeb if so desired
;*
IFNDEF	KEEP_SYMDEB_CODE
IFDEF	DEBUG
KEEP_SYMDEB_CODE = 1
ENDIF	; DEBUG
ENDIF	; !defined KEEP_SYMDEB_CODE

IFDEF KERNEL_SWAP_STACK
;*	*********   Below is QC Only ***********

;*	* Constants for multiple stack implementations

SST_NO_VAP	= 1		; No CC stack is currently present
SST_ACT_VAP	= 2		; CC stack is currently the active stack
SST_INACT_VAP	= 3		; CC stack is currently the inactive stack
ENDIF 	; KERNEL_SWAP_STACK
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\kerninit.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	kerninit : kernel initialization procedure / kernel exit procedure

	include kernel.inc
	include galloc.inc		;* for hi_hexpand
	include indrv.inc		;* for inos
	include inscr.inc		;* for insj
	include inkbd.inc		;* for inkj
	include insyd.inc		;* for inyj


neLomOffset	=	neLom
	PUBLIC	neLomOffset	;* address for Pcode Debugger

;----------------------------------------------------------------------------

IFDEF DUAL
createSeg   CWOS2,CWOS2,BYTE,PUBLIC,CODE
createSeg   OSSPEC_TEXT,OSSPEC_TEXT,BYTE,PUBLIC,CODE

sBegin	DATA

externW	<inosDrv,insj,inkj,inyj>
externW	<insjOS2,inkjOS2,inyjOS2>
externW	<_eData>

globalW	fProtectMode,?

sEnd	DATA

sBegin	CWOS2

externW	    <inosDrvOS2>

sEnd	CWOS2

sBegin	OSSPEC_TEXT

externW	    <rgfnosspec,rgfnosspec3>

sEnd	OSSPEC_TEXT

sBegin	DRV

externW	pinos

sEnd	DRV
ENDIF ;DUAL

createSeg KERNEL_BUFF,KERNEL_BUFF,WORD,PUBLIC,BEFORE_BSS,DGROUP

;----------------------------------------------------------------------------

sBegin	KERNEL_BUFF
    assumes DS,DGROUP

globalB rgbKernelBuff,<2 DUP (?)>
;* Kernel buffer placed before BSS.
;* see KNULL.ASM for special kludge

sEnd	KERNEL_BUFF

;----------------------------------------------------------------------------

sBegin	BSS
    assumes DS,DGROUP

externB iexeCur 		;* set to 255 when closing EXE file

globalW psLom,0 		;* ps of LOM data initialized by loader

globalW hGlobalHeap,0		; Handle to master object
globalW pGlobalHeap,0		; Current physical address

globalB	fShellPresent,0 	;* TRUE if DOS SHELL present

IFDEF	STARTUP_SAVE_DIR
;* szDirOrig : x:\dir....
staticB szDirOrig,<(3+64) DUP (?)>		;* original directory
ENDIF	;STARTUP_SAVE_DIR

sEnd	BSS

;----------------------------------------------------------------------------

sBegin	DATA
    assumes DS,DGROUP

externW     <pStackTop, pStackMin, pStackBot>
externDP    <pwndFocus> 			;* for restoring focus

externW     <fColorModeOld>			;* last color mode

IFDEF DEBUG
externB     <sdVerCow>
externB     <ayMac>
ENDIF ;*DEBUG

sEnd	DATA

;----------------------------------------------------------------------------

;*	* Far entry provided by application
externFPublic	<WinMain>
externFPublic	<GlobalFree>
externFP	<LeaveCow>

IFDEF DUAL
externFP	<FInitCow>
externFP	<ExitKernel>
ENDIF ;DUAL

;*	* screen init - reinit must be fixed !!
externFPublic	<FInitScreenInternal>			;* (private)
externFP	<FInitMouse>			;* from mouse.asm
externFPublic	<FEnableMouse>
externFP	<FInitSysTimer>			;* from ktimer.asm
externFP	<InitThunk> 			;* from ldthunk.asm
externFP	<InitInt24Etc>			;* from int24.asm
externFP	<ReroutePrtSc>

;----------------------------------------------------------------------------

sBegin	KERNEL
externNP  <ghexpand>			; Near procedure in Kernel segment.
sEnd	KERNEL

;----------------------------------------------------------------------------

sBegin	INIT

IFDEF	KEEP_SYMDEB_CODE
externNP    <DebugInit> 			;* from lddebug.asm
ENDIF	; KEEP_SYMDEB_CODE

ifdef	CBox
externNP	<TouchUpTables>
endif	; CBox

;********** BeginKernel **********
;*	entry : es = psLom
;*		ax = handle of LOADER
;*		si = start of DDS local heap
;*		di = end of DDS local heap
;*		sp = Bottom of stack
;*	* rgbKernel filled with rlbMove (relocations for main swap file).
;*	* Called by loader to start up the kernel
;*	exit : NEVER EXITED ! (see ExitKernel()).

    assumes CS,INIT
    assumes DS,DGROUP
    assumes SS,DGROUP
    assumes ES,NOTHING

IFDEF DUAL
os2_startup:

;*	entry:	es == 0
;*		ds == DGROUP
;*		ax == env seg
;*		bx == offset of command line in env seg
;*		cx == cbDGROUP
;*		bp == 0

	mov	pStackBot,sp

	push	ax				;* push parms for WinMain
	push	bx

;*	* Initialize OS specific tables

;*	* NOTE:	No OS specific calls can be made before this operation!!

	lea	ax,_eData
	mov	pStackTop,ax

	push	ds
	pop	es				;* ES => DGROUP
	mov	ax,CWOS2
	mov	ds,ax				;* DS => CWOS2
	assumes	DS,CWOS2
	assumes	ES,DGROUP
;*	* Initialize the OS/2 form of inosDrv
	mov	di,dataOffset inosDrv
	mov	si,cwos2Offset inosDrvOS2
	mov	cx,(cbInosMin + 1) / 2
	Assert	<(cbInosMin + 1) / 2 EQ cbInosMin / 2>
	rep	movsw

	push	es
	pop	ds
	assumes	DS,DGROUP
	assumes	ES,nothing
;*	* insj
	mov	di,dataOffset insj
	mov	si,dataOffset insjOS2
	mov	cx,(cbInsjMin + 1) / 2
	Assert	<(cbInsjMin + 1) / 2 EQ cbInsjMin / 2>
	rep	movsw
;*	* inkj
	mov	di,dataOffset inkj
	mov	si,dataOffset inkjOS2
	mov	cx,(cbInkjMin + 1) / 2
	Assert	<(cbInkjMin + 1) / 2 EQ cbInkjMin / 2>
	rep	movsw
;*	* inyj
	mov	di,dataOffset inyj
	mov	si,dataOffset inyjOS2
	mov	cx,(cbInyjMin + 1) / 2
	Assert	<(cbInyjMin + 1) / 2 EQ cbInyjMin / 2>
	rep	movsw

;*	* OS calls now available

	mov	fProtectMode,sp			;* we are in protect mode

;	cCall	FInitCow
;	or	ax,ax
;	jz	init_err

	cCall	WinMain	;* <ax,bx> already pushed

IFDEF DEBUG
	cCall	CowAssertFailed
	DB	"Return from WinMain$"
ENDIF ;DEBUG

init_err:
	mov	ax,2
	cCall	ExitKernel
ENDIF ;DUAL

LabelFP <PUBLIC, cw_init>			;* special label for Binding
cProc	BeginKernel,<FAR,PUBLIC,ATOMIC>
cBegin	BeginKernel

	push	ax				;* save hmemLoader
	mov	psLom,es			;* save all important psLom
IFDEF DUAL
;*	* check for OS/2 startup
	mov	cx,es
	jcxz	os2_startup

ENDIF ;DUAL

IFDEF DEBUG
IFDEF NOT_WANTED
;*	Print COW version stamp
	mov	dx,dataOffset sdVerCow
	mov	ah,9
	int	21h
ENDIF ;NOT_WANTED
ENDIF ;DEBUG

IFDEF DUAL

;*	* we are in real mode!
	xor	cx,cx
	mov	fProtectMode,cx

;*	* Initialize OS specific tables

;*	* NOTE:	No OS specific calls can be made before this operation!!

	push	ds
	push	es
	push	si
	push	di
;*	* Set OS specific jump table to DOS 3 form
	mov	ax,OSSPEC_TEXT
	mov	ds,ax					;* DS,ES => OSSPEC_TEXT
	mov	es,ax
	assumes	DS,OSSPEC_TEXT
	assumes	ES,OSSPEC_TEXT
	mov	si,osspec_textOffset rgfnosspec3
	mov	di,osspec_textOffset rgfnosspec
	mov	cx,si
	sub	cx,di
	inc	cx
	shr	cx,1
	rep	movsw
;*	* Set pinos to 0,  indicating DOS 3
	mov	ax,DRV_FIXED
	mov	ds,ax					;* DS => DRV
	assumes	DS,DRV_FIXED
	xor	cx,cx
	mov	ds:[pinos],cx
	pop	di
	pop	si
	pop	es
	pop	ds
	assumes	DS,DGROUP
	assumes	ES,nothing

;*	* OS calls now available

ENDIF ;DUAL
;*	* Copy very important variables from LOM into DS
	mov	ax,es:[pGlobalHeapLom]
	mov	pGlobalHeap,ax
	mov	ax,es:[hGlobalHeapLom]
	mov	hGlobalHeap,ax

;*	* Initialize DDS for stack limits
	mov	ax,sp
	mov	pStackBot,ax
	mov	pStackMin,ax
	sub	ax,es:[neLom.ne_stack]		;* less stack size
	mov	pStackTop,ax

;*	* Set global handle expansion proc
	mov	es,pGlobalHeap
	mov	es:[hi_hexpand],kernelOffset ghexpand

IFDEF KEEP_SYMDEB_CODE
;*	* Initialize Debugger
	cCall	DebugInit
ENDIF ;KEEP_SYMDEB_CODE

;*	* Initialize entry table for Thunk control
	cCall	InitThunk

;*	* Initialize the system timer
	cCall	FInitSysTimer

;*	* Initialize INT24 hook
	cCall	InitInt24Etc

;*	* Free the loader
	cCall	GlobalFree			;* handle already on the stack
IFDEF DEBUG
	or	ax,ax
	jz	ok_free_loader
	cCall	CowAssertFailed
	DB	"freeing loader$"
ok_free_loader:
ENDIF ;DEBUG

;*	* save the start-up drive / directory
IFDEF	STARTUP_SAVE_DIR
	mov	si,dataOffset szDirOrig
	mov	ah,19h
	int	21h

	add	al,'A'
	mov	[si],al
	mov	word ptr [si+1], '\:'	;* drive:\
	lea	si,[si+3]		;* after drive

	xor	dl,dl			;* current drive
	mov	ah,47h			;* get directory (current drive)
	int	21h
ENDIF	;STARTUP_SAVE_DIR

;*	* test for shell present
	mov	ah,30h
	int	21h			;* check DOS major version
	cmp	al,3
	jb	ancient_dos
;*	* DOS 3 or higher, we can use the INT 2F multiplex 18H test.
	mov	ax,1800h		;* check shell present
	int	2fh			;* 0 if not present
					;* 80H if stub present
					;* FFH if shell present
	and	al,1			;* TRUE if present
	mov	fShellPresent,al
ancient_dos:

;*	* call the Application's main entry point
	mov	ax,lomOffset szCmdLine		;* address of command line
	cCall	WinMain,<psLom,ax>

IFDEF DEBUG
	cCall	CowAssertFailed
	DB	"Return from WinMain$"
ENDIF ;DEBUG

cEnd	BeginKernel

;----------------------------------------------------------------------------
;
; COW PUBLIC ENTRY
;	entry: pinst => INST structure (NULL => re-init previous mode)
;	* Initialize screen & mouse
;	exit: AX = 1 if ok, 0 if error

    assumes CS,INIT
    assumes DS,DGROUP
    assumes SS,DGROUP
    assumes ES,NOTHING

IFNDEF PROFILE
cProc	FInitScreen,<PUBLIC, FAR, ATOMIC>	;* all calls atomic
ELSE
cProc	FInitScreen,<PUBLIC, FAR>		;* profile needs BP saved
ENDIF ;PROFILE
    parmW pinst					;* mode (pass to internal init)

cBegin	FInitScreen

	StartPublic
	cCall	FInitScreenInternal, <pinst>
	or	ax,ax
	jz	@F
	cCall	FInitMouse			;* ax = success code
	or	ax,ax
	jz	@F

	mov	bx,pinst

ifdef	CBox
	cCall	TouchUpTables
endif	; CBox

	cCall	ReroutePrtSc

	test	[bx].finstInst,finstDisableMouse
	jz	@F
	xor	ax,ax
	cCall	FEnableMouse,<ax>		;* turn mouse off
	mov	ax,sp
@@:
	Save	<ax>
	StopPublic

cEnd	FInitScreen

sEnd	INIT

;----------------------------------------------------------------------------

sBegin	EXIT

;----------------------------------------------------------------------------
;
;  EndCow
;	prepare CW for termination
;
;	entry : fClearScreen => should we clear the screen
;	exit  : n/a (COW disabled)

    assumes CS,EXIT
    assumes SS,DGROUP
    assumes DS,DGROUP
    assumes ES,NOTHING

cPublic EndCow, <ATOMIC>
    parmW fClearScreen
cBegin	EndCow

	cCall	LeaveCow,<fClearScreen>

cEnd	EndCow

sEnd	EXIT

;----------------------------------------------------------------------------

	END	BeginKernel
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\kludge.asm ===
include cmacros.inc

sBegin	DATA
    assumes DS,DGROUP

globalW	fFillBlock,-1
globalW	wFillBlock,0CCCCH
globalW	fNew,0

sEnd


	PUBLIC	kludge_sn, kludge_q
kludge_sn	EQU	0

sBegin	code

labelFP	kludge_q

cProc	SbMgrError, <FAR, PUBLIC>
cBegin	SbMgrError

	int	3

cEnd	SbMgrError

;********** StartCowMeas **********
;*	* Kludge for COW measurements - StartNMeas if crefCow++ == 0
cProc	StartCowMeas,<FAR, PUBLIC>
cBegin	nogen ;StartCowMeas

	RET

cEnd	nogen;StartCowMeas

cProc	StartNMeas,<FAR, PUBLIC>
cBegin	nogen ;StartCowMeas

	RET

cEnd	nogen;StartCowMeas


;********** StopCowMeas **********
;*	* Kludge for COW measurements - StopNMeas if --crefCow == 0

cProc	StopCowMeas,<FAR, PUBLIC>
cBegin	nogen ;StopCowMeas

	RET

cEnd	nogen;StopCowMeas


cProc	StopNMeas,<FAR, PUBLIC>
cBegin	nogen ;StopCowMeas

	RET

cEnd	nogen;StopCowMeas


;********** LTrickCall **********
;*	entry : n/a
;*	* Kludge for making non-continuous measurements look continuous
;*	* set the fTrickCall flag
;*	* Sets next old call address to last new call address.
;*	exit : DX:AX = DWORD value that should be passed to TrickReturn
;*		(This is the sn:bpc that should be used for the return).

cProc	LTrickCall,<FAR, PUBLIC, ATOMIC>
cBegin	LTrickCall

cEnd	LTrickCall



;********** TrickReturn **********
;*	entry : lTrick = trick value (sn:bpc)
;*	* Kludge for making non-continuous measurements look continuous
;*	* set the fTrickReturn flag
;*	* Sets next new return address to value passed.
;*	exit : n/a

cProc	TrickReturn,<FAR, PUBLIC, ATOMIC>
    parmW snTrick
    parmW bpcTrick
cBegin	TrickReturn

cEnd	TrickReturn

sEnd
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\handle.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	handle.asm : handle table control

	TITLE	HANDLE - Handle Table Manager

	include kernel.inc
	include galloc.inc

; This code assumes the following conditions
;
errnz	<he_address>

sBegin	KERNEL
assumes CS,KERNEL

; These are all of the internal subroutines defined in this source file.
;
	PUBLIC	halloc, hthread, hfree, hdref

SUBRS	PROC	NEAR

; HALLOC - Subroutine to allocate a handle for a block.
;
;   Inputs:	AX = block that needs a handle
;		DS:DI = address of local arena infomation structure
;
;   Outputs:	AX,BX = handle for that block
;		DX preserved
;		CX = AX
;		AX = 0 then, DX = original AX and no handle allocated
;
;
halloc: mov	bx,[di].hi_hfree
	or	bx,bx
	jz	hagrow
ha1:
	xor	cx,cx			; Zero lock count and free handle flag
	mov	word ptr [bx].he_flags,cx
	errnz	<2-he_flags>
	errnz	<3-he_count>
	xchg	[bx].he_link,ax 	; Remove handle from head of chain
	errnz	<he_address-he_link>	; and store true address of object
	mov	[di].hi_hfree,ax	; Update head of handle free list
	mov	ax,bx			; Return handle to caller
	mov	cx,ax
	ret

hagrow:
	push	ax
	push	dx
	mov	cx,[di].hi_hdelta
	jcxz	hafail
	call	[di].hi_hexpand
	jcxz	hafail
	mov	bx,ax
	pop	dx
	pop	ax
	jmp	ha1

hafail:
	xor	ax,ax
	pop	dx			; Flush stack
	pop	dx			; Return original AX in DX
	ret				; return error

; HTHREAD - subroutine to thread together a list of free handles
;
;   Inputs:	DI = start of chain
;		CX = #handle entries in chain
;
;   Outputs:	AX = address of first handle entry on free list
;		CX = 0
;		DI = address of first word after handle block
;
hthread:
	push	di			; Save first free handle entry
	push	ds
	pop	es
	cld
ht1:					; Chain entries together via he_link
	errnz	<he_link>
	lea	ax,[di].SIZE HandleEntry
	stosw
	mov	ax,HE_FREEHANDLE
	errnz	<2-he_flags>
	errnz	<3-he_count>
	stosw
	loop	ht1
					; Null terminate free list
	mov	[di-SIZE HandleEntry].he_link,cx
	pop	ax			; Return free handle address
	ret


; HFREE - Subroutine to return a handle to the freelist.
;
;   Inputs:	SI = handle to free
;
;   Outputs:	AX = zero if valid handle or -1 if handle already free
;
hfree:	or	si,si			; Ignore zero handles
	jz	hf1
	mov	ax,HE_FREEHANDLE	; Mark handle as free
	xchg	word ptr [si].he_flags,ax
	errnz	<2-he_flags>
	errnz	<3-he_count>
	inc	ax			; Already free?
	jz	hf2			; Yes, return error
	errnz	<1+HE_FREEHANDLE>
	mov	ax,si			; Push handle on head of freelist
	xchg	[di].hi_hfree,ax
	mov	[si].he_link,ax
hf1:
	xor	ax,ax			; Return zero
	ret
hf2:
	dec	ax
	ret


; HDREF - Subroutine to dereference a handle.
;   Inputs:	SI = handle
;   Outputs:	AX = address of client data or zero for discarded objects
;		CH = lock count
;		CL = zero or HE_DISCARDED flag
;		Z flag set AX is zero and CL is non-zero
;
hdref:
	xor	ax,ax
	mov	cx,word ptr [si].he_flags
	errnz	<2-he_flags>
	errnz	<3-he_count>
	inc	cx
	jz	hdref1
	errnz	<1+HE_FREEHANDLE>
	dec	cx
	and	cl,HE_DISCARDED
	jnz	hdref1
	mov	ax,[si].he_address
hdref1:
	or	ax,ax
	ret

SUBRS	ENDP

sEnd	KERNEL

end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\krun.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	krun.asm : Run/Exec

	TITLE	KRUN - Kernel RUN

	include	kernel.inc
	include	galloc.inc


ifdef	Exec_Alternate
	include	krun2.asm		;* REVIEW -- integrate better !!
else	; Use this file
	.xlist
	include pbi.inc
	.list

;----------------------------------------------------------------------------

MovSeg	MACRO	srDest, srSrc
	push	srSrc
	pop	srDest
ENDM

;----------------------------------------------------------------------------

sBegin	DATA

ifdef	Debug
externB	fCheckCwHeap
endif	; Debug

externW	psLom
externW	pGlobalHeap

externB	fShellPresent				;* from kerninit.asm

ifndef	NopCode
externW	 fNew				;* from interpreter
endif	; !NopCode

ifdef	WINDOWS_OLD_APP
externW	fWoaPresent
externW	psDosRealloc
endif	; WINDOWS_OLD_APP

sEnd	DATA

;----------------------------------------------------------------------------

IFDEF DEBPUB
	PUBLIC	FzGetEnv, ShrinkGlobalHeap, RestoreGlobalHeap
	PUBLIC	PromptMissingExec
ENDIF ;DEBPUB

IFDEF	WINDOWS_OLD_APP
externFP	<WoaToDos, WoaFromDos>
ENDIF	; WINDOWS_OLD_APP

;----------------------------------------------------------------------------

sBegin	KERNEL
    assumes DS,KERNEL


;*	* data that MUST be in code space

ifdef	QC_LINKER
globalD	ShlLinkSave,?			;* save SS:SP
else	; ! QC_LINKER
staticW	ssSave, ?			;* save SS
staticW	spSave, ?			;* save SP
endif	; QCLINKER


;*	* code strings
staticB	szComspec, <"COMSPEC=">		;* COMSPEC name
cchComspec	 EQU	$-szComspec

staticB	szCmdProg, <"\COMMAND.COM", 0>	;* if COMSPEC not found


sEnd	KERNEL

;----------------------------------------------------------------------------

externFPublic <AccessSwapFile>			;* for closing
externFPublic <PromptSwapDisk>			;* from App or stub.


;----------------------------------------------------------------------------

sBegin	KERNEL

    assumes CS,KERNEL
    assumes DS,DGROUP
    assumes SS,DATA
    assumes ES,NOTHING

;********** PromptMissingExec **********
;*	entry : lszPath = far pointer to path name
;*	* Prompt for a missing EXEC program
;*	* NOTE : this function must be in the EXIT module
;*	exit : n/a (trashes SI/DI)

cProc	PromptMissingExec, <FAR, ATOMIC>
    parmD lszPath
cBegin	PromptMissingExec
    assumes DS,DGROUP

;*	* assumes INIT module loaded (from call to BackToCow)
;*	* this routine gets loaded from the EXIT module

;*	* we will not swap from this point on (both INIT and EXIT resident)
;*	* we must close the swap file in order to use the Kernel buffer
	xor	ax,ax
	cCall	AccessSwapFile,<ax>

ifndef	NopCode
	push	fNew
endif	; !NopCode

	mov	es,psLom
	lds	si,lszPath
    assumes DS,NOTHING
	mov	di,es:[offRlbLom]		;* ES:DI => far kernel buffer
	push	es
	push	di				;* TOS = lszPath

@@:	lodsb
	stosb
	or	al,al
	jnz	@B

	MovSeg	ds,ss
    assumes DS,DGROUP

;*	* (TOS) = lszPath
	mov	ax,-1				;* special iexe for exec
	push	ax
	cCall	PromptSwapDisk			;* PromptSwapDisk(lszPath, -1);

	mov	ah,0DH
	int	21h				;* reset disk to try again
ifndef	NopCode
	pop	fNew				;* pcode may have changed fNew
endif	; !NopCode

cEnd	PromptMissingExec

sEnd	KERNEL

;----------------------------------------------------------------------------

sBegin	EXIT
    assumes CS,EXIT
    assumes DS,NOTHING
    assumes SS,DATA

;*	* NOTE :
;*	*  GetEnv is in EXIT segment since LeaveCow will be called first

;********** FzGetEnv **********
;*	entry : ES:DI => environment string to look for (with ending '=')
;*		CX = length of string
;*	* scan environment for Variable
;*	exit : Z => DS:SI => contents on ENV variable
;*	    else NZ=> not found
;*	* NOTE : uses AX/SI/DS
;*
cProc	FzGetEnv,<FAR, ATOMIC>
cBegin	FzGetEnv
	AssertNE	cx,0			; Would produce a "found".
	mov	ds,psLom
	mov	ds,ds:[pdbLom.PDB_environ]	;* psEnvironment
    assumes ds,nothing
	xor	si,si				;* ds:si => environment
	cld
getenv_lp:
	push	di
	push	cx
	repz	cmpsb
	pop	cx
	pop	di
	jz	getenv_end
getenv_skip:
	lodsb
	or	al,al
	jnz	getenv_skip
	cmp	byte ptr ds:[si],al	;* is this the real end ?
	jnz	getenv_lp
	or	cx,cx			;* NZ => not found
getenv_end:
cEnd	FzGetEnv
    assumes ds,nothing



sEnd	EXIT

;----------------------------------------------------------------------------

externFP	GlobalCompact
externFPublic	<LeaveCow, BackToCow>		;* in INIT

;----------------------------------------------------------------------------

sBegin	KERNEL
    assumes CS,KERNEL
    assumes DS,NOTHING
    assumes SS,DATA

externNP	<genter>			; GINTERF.ASM
externNP	<gjoin,gmarkfree,gcheckfree>	; GALLOC.ASM
externNP	<gnotify>		 	; GINTERF.ASM

;-----------------------------------------------

run_special_shell:		; It's up here to be within jcxz range.
	mov	ax,1801h			;* run shell
	int	2fh				;* al = return code
	xor	ah,ah
	jmp	done_run_shell

;********** RerrExec **********
;*	entry : szCmd = program name (or NULL => shell)
;*		pchParm = parameter string:
;*		   Byte-length prefixed, 0Dh terminated.
;*		   Null is invalid, use 01,"0Dh" for subshell.
;*		   Use <length> "/C xxxxx" when szCmd == NULL.
;*		rgchPrompt = "Press a key to resume MangoSoft$"; -1 if none.
;*		fClearScreen = whether to clear it or not.
;*		fRestoreScreenMode = whether to reset mode on way back in.
;*	* shrink memory / run subshell / restore memory
;*	exit : AX = 0 if ok, AX != 0 if error (interpreted as "rerr" code,
;*		(see kmem.h).
;*	       DX = return code of child process (undefined if AX != 0)

cPublic	RerrExec, <>, <DS, SI, DI>		;* NOT ATOMIC !
    parmDP  szCmd
    parmDP  pchParm
    parmDP  rgchPrompt				;* Dollar-sign terminated!
    parmW   fClearScreen
    parmW   fRestoreScreenMode
    localD  lszPath				;* far pointer to path
    localV  pbiT,<SIZE PBI>			;* parameter block
    localW  ChildCode
    localW  ExecCode
cBegin	RerrExec
    assumes DS,DGROUP

ifdef	Debug
	xor	ax,ax				; Set fCheckCWHeap to false,
	xchg	al,fCheckCWHeap			;   and push its old value.
	push	ax
endif	; Debug

;RetryRerrExec:
	AssertNE pchParm,0			;* NULL invalid

	MovSeg	es,cs
	mov	di,kernelOffset szComspec	;* ES:DI => string
	mov	cx,cchComspec
	cCall	FzGetEnv
    assumes DS,NOTHING
	jz	got_comspec			;* DS:SI => comspec

	MovSeg	ds,cs
	mov	si,kernelOffset szCmdProg ;* use COMMAND.COM
got_comspec:	;* ds:si => path/file for COMMAND shell

	mov	OFF_lszPath,si
	mov	SEG_lszPath,ds

	MovSeg	ds,ss
    assumes DS,DGROUP
	cCall	LeaveCow, <fClearScreen>	;* leave & maybe clear screen

	cCall	ShrinkGlobalHeap

	mov	di,pchParm			;* ss:di => string
;*	* lszPath => cmd, SS:DI => parm.

;*	* if szCmd != NULL then exec named program
	mov	cx,szCmd
	jcxz	exec_a_shell
	mov	OFF_lszPath,cx
	mov	SEG_lszPath,ss			;* szCmd
	jmp	short exec_command

exec_a_shell:  ;* (ch == 0)
;*	* if pchParm == "" then we can run a special shell if present
	mov	cl,fShellPresent		;* ch == 0.
	jcxz	exec_command
	mov	cl,ds:[di]			;* ds == ss, ch == 0.
ifdef	QC_LINKER
	jcxz	F@
	jmp	short exec_command
F@:	jmp	run_special_shell
else	; !QC_LINKER
	jcxz	run_special_shell
endif	; QC_LINKER

exec_command:
;*	* Exec a command (SS:DI => command line, lszPath => command).
;*	* set up PBI
	mov	es,psLom
	lea	bx,pbiT
	mov	ax,es:[pdbLom+PDB_environ]
	mov	[bx].psEnviron,ax
	mov	[bx].offCmdLine,di
	mov	[bx].psCmdLine,ss		;* command (on stack)
	mov	[bx].offFcb1,5CH
	mov	[bx].psFcb1,es
	mov	[bx].offFcb2,6CH
	mov	[bx].psFcb2,es

;*	* save the important part of the world
	push	ds
	push	bp
;*	* Save DWORD PTR SS:[2E] since DOS 2.0 has a bug which thinks that SS
;*	*  is pointing to a PSP (and hence stuffs the old stack at this address)
	push	word ptr ss:[2EH]
	push	word ptr ss:[30H]

ifdef	QC_LINKER
	mov	WORD PTR (ShlLinkSave+2),ss	;* Save SS
	mov	WORD PTR (ShlLinkSave),sp	;* Save SP
	sub	WORD PTR (ShlLinkSave),6	;* Add some slop
else	; !QC_LINKER
	mov	ssSave,ss
	mov	spSave,sp
endif	; QC_LINKER

	push	ss
	pop	es

	lds	dx,lszPath			;* command path

	mov	ax,4B00H			;* exec : load + execute
	int	21h

	jc	exec_error
	xor	ax,ax				;* no error
exec_error:

	cli
ifdef	QC_LINKER
	mov	ss, WORD PTR (ShlLinkSave+2)	;* Restore ss
	mov	sp, WORD PTR (ShlLInkSave)	;* Restore sp
	add	sp,6				;* Remove slop
else	; ! QC_LINKER
	mov	ss,ssSave
	mov	sp,spSave
endif	; QC_LINKER
	sti

	pop	word ptr ss:[30H]
	pop	word ptr ss:[2EH]		;* Dos 2.0 tromping restored
	pop	bp
	pop	ds
    assumes DS,DGROUP

	mov	ExecCode,ax			;* save the exec return code
	mov	ChildCode,0			;* init the child return code

	cmp	ax,2				;* If file not found, then
	je	done_run_shell			;*   don't bother with prompt
;	je	run_shell_not_found

	mov	dx,rgchPrompt			;* ds:dx -> "Press a key$"

	or	ax,ax				;* Don't get the child code
	jnz	CheckPrompt			;*   if Exec failed.

	mov	ah,4Dh
	int	21h
	mov	ChildCode,ax			;* save the child return code

ifndef	FOR_QC			;* This should be ifdef'ed for project
	cmp	ax,4				;* This is Word's special
	je	DoPrompt			;*   "Do Prompt" return code.
endif	; !FOR_QC

CheckPrompt:
	cmp	dx,-1
	je	done_run_shell

DoPrompt:
	mov	ah,09h
	int	21h			; Prompt to press any key
	mov	ax,0C07h
	int	21h			; Wait for key input

done_run_shell:
;*	* restore everything (and repaint screen)

	cCall	RestoreGlobalHeap

;*	* the following call calls an INIT procedure
	cCall	BackToCow,<fRestoreScreenMode>	;* in INIT segment

ifdef	Debug
	pop	ax				; Restore fCheckCWHeap to 
	mov	fCheckCWHeap,al			;   its old value.
endif	; Debug

	mov	ax,ExecCode			;* restore these for 
	mov	dx,ChildCode			;*   return values.

cEnd	RerrExec

;*	* special case if exec program is not found

;run_shell_not_found:
;	cCall	RestoreGlobalHeap
;;*	* re-init CW for windowing
;	cCall	BackToCow			;*  Load in INIT module
;	cCall	PromptMissingExec, <lszPath>
;
;	jmp	RetryRerrExec			;* retry


;-----------------------------------------------


;********** ShrinkGlobalHeap **********
;*	entry : n/a
;*	* shrink the global heap
;*	exit : n/a
;*	* NOTE : this code must be fixed since it throws everything out.

cProc	ShrinkGlobalHeap, <NEAR, ATOMIC>, <DS, SI, DI>
cBegin	ShrinkGlobalHeap

    assumes DS,DGROUP

IFDEF	WINDOWS_OLD_APP
	;*
	;*	If win-old-app model is present then claim as much as 
	;*	possible from it.  It will also modify the address
	;*	which is to be used for reallocing the segment.
	;*
	cmp	fWoaPresent,0
	jz	@F
	cCall	WoaToDos			;* Shut down win-old-app code
@@:
ENDIF	; WINDOWS_OLD_APP

;*	* compact the heap (removing any free gaps) -- throw out code as well

	mov	es,pGlobalHeap
	xor	di,di
	mov	ax,1			;* 1 reserved para
					;* NOTE : kludge to get all code
					;*   discarded !!!
	xchg	ax,es:[di].gi_reserve	;* get old reserve
	push	ax
	mov	ax,-1
	cCall	GlobalCompact,<ax, ax>	;* (-1) throw everything out
	mov	es,pGlobalHeap
	pop	es:[di].gi_reserve	;* restore reserve size

	mov	es,es:[di].hi_last	;* es => end sentinal
	mov	dx,es
;*	* scan from end till finding free block
find_free_loop:
	mov	es,es:[di].ga_prev	;* next block
	mov	cx,es:[di].ga_owner
	jcxz	found_free		;* 0 owner => free
	inc	cx
	jnz	find_free_loop		;* -1 owner => MOB or sentinal (stop)
	jmp	end_shrink		;* can't shrink

found_free:
;*	* es:0 => free block, dx:0 => end sentinal
	cmp	es:[di].ga_next,dx
	je	dont_move_bound

;*	* move the bound segments from high to low memory
	mov	ds,es:[di].ga_next	;* 1 after block
    assumes ds,NOTHING
	mov	dx,es:[di].ga_prev
move_bound_seg_loop:
	;* ds:0 => source, es:0 => dest
	;* dx = prev link
	mov	ds:[di].ga_prev,dx
	mov	dx,ds
	mov	cx,ds:[di].ga_next
	sub	cx,dx
	mov	ax,es
	add	ax,cx			;* ax = new dest
;*	* move from source to dest (dest before source => move up)
	xor	si,si
	shl	cx,1
	shl	cx,1
	shl	cx,1			;* cpara -> cw (<64K blocks)
	rep movsw			;* move arena + data
	xor	di,di
;*	* notify everyone
	push	ds
	push	es
	push	ax
	mov	al,GN_MOVE
	mov	bx,es:[di].ga_handle	;* handle
	mov	cx,es
	inc	cx			;* psNew
	mov	dx,es:[di].ga_owner	;* set up owner for gnotify
	mov	ds,pGlobalHeap
	push	cx			;* new address
	push	bx			;* handle
	call	gnotify 		; Call global notify procedure
	pop	bx
	pop	ds:[bx].he_address
	pop	ax
	pop	es
	pop	ds
;*	* update link to next
	mov	dx,es			;* next link
	mov	bx,ax
	xchg	ax,es:[di].ga_next
	mov	es,bx			;* next destination
	mov	ds,ax			;* next block
	cmp	ds:[di].ga_owner,-1	;* stop at sentinal
	jne	move_bound_seg_loop
;*	* ds:0 => end sentinal, es:0 => where sentinal should be
	mov	bx,es
	mov	ds,bx
	mov	ds:[di].ga_prev,dx	;* back link
	jmp	update_end_sentinal

dont_move_bound:
;*	* at the end of the heap MUST be a free block of a reasonably
;*	* large size (the free block due to freeing all code)
	cCall	genter			;* DS:DI => mob
    assumes ds,NOTHING
	mov	es,ds:[di].hi_last	;* pointer to sentinal
	mov	cx,es			;* last block
	mov	bx,es:[di].ga_prev	;* must be a free block
	mov	ds,bx
	cmp	ds:[di].ga_owner,0
	jne	end_shrink
;*	* es:di => free block that should be sentinal
	mov	es,cx			;* es:di =>old sentinal

ifdef	Debug
;*	* check out state of old sentinal
	cmp	es:[di].ga_sig,GA_ENDSIG
	je	ok_old_sent
bad_old_sent:
bad_new_sent:
	int	3
ok_old_sent:
	cmp	es:[di].ga_owner,-1
	jne	bad_old_sent
	cmp	es:[di].ga_size,GA_ALIGN
	jne	bad_old_sent
	cmp	es:[di].ga_flags,0
	jne	bad_old_sent
;*	* check new sentinal
	cmp	ds:[di].ga_sig,GA_SIGNATURE
	jne	bad_new_sent
endif	; Debug

update_end_sentinal:	; ds==bx == para address of end block
	mov	ds:[di].ga_sig,GA_ENDSIG
	mov	ds:[di].ga_owner,-1
	mov	ds:[di].ga_size,GA_ALIGN
	mov	ds:[di].ga_flags,0
	mov	ds:[di].ga_next,ds		;* link to self

	cCall	genter			;* DS:DI => mob
	mov	ds:[di].hi_last,bx	;* now the last block
	dec	ds:[di].hi_count	;* remove free object

;*	* now free up anything to DOS
IFDEF	WINDOWS_OLD_APP
	mov	ax,psDosRealloc
ELSE	; !WINDOWS_OLD_APP
	mov	ax,psLom		;* 1 big block
ENDIF	; WINDOWS_OLD_APP
	mov	es,ax
	sub	bx,ax			;* size of new block (in para)
	add	bx,1+cparaRunShell	;*  add slush (+1 to keep end sentinal)
	mov	ah,4ah			;* modify allocated memory
	int	21h

;*	* resume with smaller global heap

end_shrink:

cEnd	ShrinkGlobalHeap


;-----------------------------------------------


;********** RestoreGlobalHeap **********
;*	entry : n/a
;*	* restore global heap after ShrinkGlobalHeap
;*	exit : n/a

cProc	RestoreGlobalHeap, <NEAR, ATOMIC>, <DS, SI, DI>

cBegin	RestoreGlobalHeap
    assumes ds,DGROUP

;*	* modify block to make as large as possible
IFDEF	WINDOWS_OLD_APP
	mov	es,psDosRealloc
ELSE	; !WINDOWS_OLD_APP
	mov	es,psLom			;* 1 big block
ENDIF	; WINDOWS_OLD_APP
	mov	bx,0ffffh			;* i want it all
	mov	ah,4ah
	int	21h

ifdef	Debug
	jc	ok_we_asked_for_too_much
	int	3				;* we got 1MB ???
ok_we_asked_for_too_much:
endif	; Debug

;*	* now do it for real
	mov	ah,4ah
	int	21h

ifdef	Debug
	jnc	ok_we_got_it_back
	int	3				;* we got 1MB ???
ok_we_got_it_back:
endif	; Debug

;*	* get address of new end sentinal
	mov	ax,es
	add	ax,bx				;* ax = new end
;*	* check to make sure we are within the useable limits
IFDEF	WINDOWS_OLD_APP
	mov	es,psLom
ENDIF	; WINDOWS_OLD_APP
	cmp	ax,es:[psUseMax]
	jb	have_high_limit
;*	* we must adjust our block size (free the rest to DOS)
;*	* (not efficient -- clean up later)
	mov	bx,es:[psUseMax]
	push	bx				;* limit
	mov	ax,es
	sub	bx,ax				;* size we will use
	mov	ah,4AH
	int	21h				;* modify memory size
	pop	ax
	AssertEQ ax,es:[psUseMax]
have_high_limit:
	sub	ax,GA_ALIGN			;* room for arena
	and	al,LOW(GA_MASK)			;* make even
	mov	ds,ax				;* es => new sentinal
    assumes ds,NOTHING
;*	* create new sentinal
	xor	bx,bx
	mov	ds:[bx].ga_sig,GA_ENDSIG
	mov	ds:[bx].ga_owner,-1		;* sentinal
	mov	ds:[bx].ga_size,GA_ALIGN
	mov	ds:[bx].ga_flags,bl
	mov	ds:[bx].ga_handle,bx		;* no handle
	mov	ds:[bx].ga_next,ds		;* link to self
	mov	cx,ax				;* psNew

	cCall	genter				;* DS:DI => mob
	xchg	ax,ds:[bx].hi_last		;* set new last, get old
	inc	ds:[di].hi_count		;* adding free object

	mov	ds,ax
	mov	es,cx
	mov	es:[bx].ga_prev,ds		;* link to other free

ifdef	Debug
	cmp	ds:[bx].ga_sig,GA_ENDSIG
	je	ok_end_sig
	int	3
ok_end_sig:
endif	; Debug

	sub	cx,ax				;* psNew - psOld
	sub	cx,GA_ALIGN			;* less overhead

	mov	ds:[bx].ga_sig,GA_SIGNATURE
	mov	ds:[bx].ga_owner,bx		;* FREE !!!
	mov	ds:[bx].ga_flags,GA_MOVEABLE
	mov	ds:[bx].ga_size,cx		;* new size
	mov	ds:[bx].ga_next,es		;* point to new sentinal

IFDEF	WINDOWS_OLD_APP
	;* Restore win-old-app model if present
	cmp	fWoaPresent,0		;* Is win-old-app segment present?
	jz	@F			;* No -- skip around
	mov	ax,DGROUP		;* Calling c procedure
	mov	ds,ax			;*
	cCall	WoaFromDos		;* Restore win-old-app code
@@:
ENDIF	; WINDOWS_OLD_APP


cEnd	RestoreGlobalHeap

sEnd	KERNEL

endif	; !Exec_Alternate


;*****************************************************************************

sBegin	INIT
    assumes CS,INIT
    assumes DS,DGROUP
    assumes SS,DGROUP


;********** GetProgDir **********
;*	entry : szBuff => string buffer to put path name
;*		(must be 66 characters or longer)
;*	* copy startup directory to this near buffer
;*	exit : n/a

    assumes DS,DGROUP

cPublic GetProgDir, <ATOMIC>, <DS, SI, DI>
    parmDP szBuff
cBegin	GetProgDir

	push	ds
	pop	es				;* destination a near pointer
	assumes ES,NOTHING

	mov	di,szBuff
	mov	ds,psLom
	assumes DS,NOTHING

	mov	si,lomOffset szBootPathLom
@@:	lodsb
	stosb
	or	al,al
	jnz	@B		 		;* assumes zero terminated

szBPL		equ	lomOffset szBootPathLom
szBPLRoot	equ	szBPL + 4

	cmp	si,szBPLRoot
	je	AtRoot
	mov	es:[di-2],al
AtRoot:

cEnd	GetProgDir


sEnd	INIT


;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\knull.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	knull.asm : Kernel NULL segment / Segment ordering
;*
;*	* Kludge Segments to force proper segments
;*
;*	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
;*	* WARNING : only change this file if you know exactly what you are doing
;*	* WARNING : THIS FILE MUST BE POST-PROCESSED BY SEGORDER !!
;*	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

;*	* NOTE :
;*	* the kernel buffer must be after all non-zero initialized data,
;*	*  and before the _BSS segment, this allows loading in the DGROUP +
;*	*  rlbFix in 1 read and zero filling the remaining (thus starting with
;*	*  rlbFix already in the work buffer
;*	* In order for the loader to know where this buffer starts, the address
;*	*  is placed at address 4 in the DGROUP (part of NULL).
;*	*  (the loader asserts that the buffer is right after BSS data), also
;*	*  the work buffer is NOT zero initialized.

include	version.inc

IFNDEF	FOR_QC
public	__acrtused
	__acrtused = 1
ENDIF	; !FOR_QC

;*	* Funny segment order *
_TEXT	SEGMENT PARA PUBLIC 'CODE'
_TEXT	ENDS

NULL	SEGMENT	PARA PUBLIC 'BEGDATA'
NULL	ENDS
_DATA	SEGMENT WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT WORD PUBLIC 'CONST'
CONST	ENDS
KERNEL_BUFF SEGMENT WORD PUBLIC 'BEFORE_BSS'
	EXTRN	rgbKernelBuff:BYTE
KERNEL_BUFF ENDS
_BSS	SEGMENT PARA PUBLIC 'BSS'
_BSS	ENDS

DGROUP	GROUP	NULL,_DATA,CONST,KERNEL_BUFF,_BSS

;*****************************************************************************

	PUBLIC	pbKernelBuff
	PUBLIC	bpOldStack, ssOldStack
	PUBLIC	pStackTop, pStackMin, pStackBot

NULL	SEGMENT
		DW	0		;* first word of DDS is zero
bpOldStack	DW	0		;* old stack's BP
ssOldStack	DW	0		;* old stack's SS
		DW	0		;* reserved
pbKernelBuff	DW	OFFSET DGROUP: rgbKernelBuff	;* offset $A
pStackTop	DW	0	;* top of stack
pStackMin	DW	0	;* minimum value of SP (old stack's SP)
pStackBot	DW	0	;* bottom of stack
NULL	ENDS


	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\krun5.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	krun5.asm : Run/Exec

	TITLE	KRUN - Kernel RUN

	include	kernel.inc
	include uevent.inc

;----------------------------------------------------------------------------

cbArgMax	equ	79+1+3+128+2	; Max size pszArg to DosExecPgm.
					;   79 = max comspec filename size
					;    1 = sepearating zero.
					;    3 = "/C "
					;  128 = max real argument size
					;    2 = 00 00 terminating bytes.

;----------------------------------------------------------------------------

sBegin	KERNEL
    assumes DS,KERNEL


;*	* data that MUST be in code space

;*	* code strings
staticB	szComspec, <"COMSPEC", 0>	; COMSPEC name (note: no '=' for OS/2)

staticB	szCmdProg, <"\CMD.EXE", 0>	; if COMSPEC not found


sEnd	KERNEL

;----------------------------------------------------------------------------

externFP	<PeekMessage>
externFPublic	<LeaveCow,BackToCow>		;* in INIT
externFP	<DosExecPgm>
externFP	<DosScanEnv>
externFP	<VioWrtTty>
externFP	<EnableKeyboard>

sBegin	KERNEL

	assumes CS,KERNEL
	assumes DS,NOTHING
	assumes SS,DATA

;********** RerrExec **********
;*	entry : szCmd = program name (or NULL => shell)
;*		pchParm = parameter string:
;*		   Byte-length prefixed, 0Dh terminated.
;*		   Null is invalid, use 01,"0Dh" for subshell.
;*		   Use <length> "/C xxxxx" when szCmd == NULL.
;*		rgchPrompt = "Press a key to resume MangoSoft$"; -1 if none.
;*		fClearScreen = whether to clear it or not.
;*		fRestoreScreenMode = whether to reset mode on way back in.
;*	exit : AX = 0 if ok, AX != 0 if error (interpreted as "rerr" code,
;*		(see kmem.h).
;*	       DX = return code of child process (undefined if AX != 0)

	assumes CS,KERNEL
	assumes DS,DGROUP
	assumes ES,NOTHING
	assumes SS,DATA

cPublic	RerrExec, <>, <SI,DI,DS>		;* NOT ATOMIC !

	parmDP	szCmd
	parmDP	pchParm
	parmDP	rgchPrompt		; Dollar-sign terminated!
	parmW	fClearScreen
	parmW	fRestoreScreenMode

	localV	msgScreen,cbMsgMin
	localV	pszArgs,cbArgMax	; Where we'll build arg string.
	localD	lszProgram		; far pointer to Comspec
	localD	ReturnCodes	; 1st word = Termination code from OS/2.
				; 2nd word = Result code from child process.

cBegin	RerrExec

	AssertData	DS			; Make sure that ss=ds.

;------ Push the first three arguments to DosExecPgm.
	xor	bx,bx
	push	ss			; pchFailName.  We don't use the name
	push	bx			;   in any case, so give null buffer.
	push	bx			; cbFailName = 0.
	push	bx			; AsyncTraceFlags = synchronous.

	mov	SEG_lszProgram,ss	; If szCmd is not Null, 
	mov	ax,szCmd		;   then that's the program 
	mov	OFF_lszProgram,ax	;   that we'll exec.
	or	ax,ax
	jnz	@F			; Otherwise, we go for a Comspec.

	push	cs
	push	kernelOffset szComspec	; Hey OS/2, go look for "COMSPEC".
	push	ss
	lea	ax,lszProgram		; Where OS/2 will put ptr to Comspec.
	push	ax
	call	DosScanEnv
	or	ax,ax			; Jump if OS/2 found it.
	jz	@F

	mov	SEG_lszProgram,cs			; Guess: use \CMD.EXE
	mov	OFF_lszProgram,kernelOffset szCmdProg	;   for Comspec.
@@:

; At this point, all we've done is get lszProgram containing the segment and
; offset of the program we'll be Exec'ing, whether it be our program itself,
; the Comspec, or our best guess at a Comspec.
;
; Now build the pszArgs string.  Non-direct / Comspec types look like this:
;
;    "c:\os2\pbin\cmd.exe" 00 "/c ourprog /arg1 /arg2" 00 00
;
; Direct / non-Comspec types look like this:
;
;    "ourprog" 00 "/arg1 /arg2" 00 00

	push	ds
	mov	ax,ss
	mov	es,ax
	assumes	es,DATA
	lea	di,pszArgs		; es:si -> buffer.

	lds	si,lszProgram		; ds:si -> program we'll exec
	assumes DS,NOTHING

@@:	lodsb				; Transfer over the entire program
	stosb				;   name, and the 0 byte at the end.
	or	al,al
	jnz	@B
	pop	ds
	assumes DS,DGROUP

	AssertNE pchParm,0		; Null is bogus.
	mov	si,pchParm		; ss:si = ds:si -> the parameters
	xor	ax,ax
	lodsb				; al = count, ah = 00.
	AssertNe	al,0		; Have to at least have the 0D byte.
	dec	ax			; Don't transfer the 0D at the end.
	mov	cx,ax			; cx = count
	rep	movsb			; Move over the argument string.

	mov	es:[di],cx		; Finish it off with a double 0 byte.
	
; --------------------------------------

	push	ss			; Our mondo big and complicated
	lea	ax,pszArgs		;   local buffer
	push	ax

	push	cx			; EnvPointer = 0000:0000 -
	push	cx			;   inherit the parent's env.

	push	ss			; Address of DWord buffer where OS/2
	lea	ax,ReturnCodes		;   will put Termination Code and
	push	ax	    		;   Result Code of the child.

	push	SEG_lszProgram		; Address of ASCIIZ string specifying
	push	OFF_lszProgram		;   drive and dir of prog to execute
	mov	ax,2

; -----------------------			; Do at the last minute:
	cCall	LeaveCow, <fClearScreen>	;   Leave & maybe clear 
; -----------------------			;   the screen.

	call	DosExecPgm		; Do it.

	push	ax
	cCall	EnableKeyboard, <sp>
	pop	cx			; DosExecPgm return code.
	jcxz	@F

	mov	ax,2			; Guess it'll be one of these errors:
	cmp	cx,3			; If "Path not found", then no error
	je	NoFile			;   messages.
	cmp	cx,ax			; If "File not found", then no error
	je	NoFile			;   messages.
	cmp	cx,00BFh		; If ERROR_INVALID_EXE_SIGNATURE
	je	NoFile			;   then treat like "file not found".
	AssertEq	cx,0
@@:

; -----------------------

	mov	di,rgchPrompt		; ds:di -> "Press a key$"
	cmp	di,-1
	je	NoPrompt

	mov	ax,ds
	mov	es,ax
	assumes	es,DGROUP
	push	ax			; ax:di -> "Press a key$"
	push	di

	mov	ax,0124h		; al = "$"
	mov	cx,ax			; Assumption: the "Press a key to
	repne	scasb			;   "resume" string is < 292 bytes.
	AssertZR
	sub	ax,cx
	dec	ax			; Don't count the "$".
	push	ax			; Length of the string.

	push	0			; VioHandle

	call	VioWrtTty
	AssertEq	ax,0		; Shouldn't err.

@@:	AssertData	DS		; Make sure that ss=ds.
	lea	ax,msgScreen		; Wait until we get a message
	push	ax
	call	PeekMessage		;   that's a character.
	or	ax,ax
	jz	@B
	cmp	[msgScreen.messageMsg],WM_CHAR
	jne	@B

NoPrompt:
	mov	ax,OFF_ReturnCodes	; return 1st word = termination code

NoFile:

; -----------------------
	push	ax				; This calls an INIT proc
	cCall	BackToCow,<fRestoreScreenMode>	;   in the INIT segment.
	pop	ax
; -----------------------

	mov	dx,SEG_ReturnCodes	; return 2nd word = child result code

cEnd	RerrExec

sEnd	KERNEL

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\kstart.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	kstart.asm : extra kernel initialization / exit procedures

	include kernel.inc
	include galloc.inc		;* for hi_hexpand


;----------------------------------------------------------------------------

sBegin	BSS
    assumes DS,DGROUP

externB <iexeCur> 		;* set to 255 when closing EXE file

externW <psLom> 		;* ps of LOM data initialized by loader

IFDEF	STARTUP_SAVE_DIR
;* szDirOrig : x:\dir....
staticB szDirOrig,<(3+64) DUP (?)>		;* original directory
ENDIF	;STARTUP_SAVE_DIR

sEnd	BSS

;----------------------------------------------------------------------------

sBegin	DATA
    assumes DS,DGROUP

externDP    <pwndFocus> 			;* for restoring focus

IFDEF DEBUG
externB     <ayMac>
ENDIF ;*DEBUG

sEnd	DATA

;----------------------------------------------------------------------------


externFP	<FInitScreen>

externFPublic	<EnableKeyboard>
externFP	<FlushKeyEvents>

externFPublic	<FEnableMouse>
externFPublic	<EndScreen>				;* (private)

externFP    <FInitSysTimer>			;* from ktimer.asm
externFP    <EndSysTimer>			;* from ktimer.asm
externFP    <FInitMouse>			;* from mouse.asm
externFP    <EndMouse>				;* from mouse.asm
externFP    <InitInt24Etc>			;* from int24.asm

IFDEF DUAL
externFP	<ExitKernelOSSPEC>
ENDIF ;DUAL

;----------------------------------------------------------------------------


sBegin	INIT
    assumes CS,INIT
    assumes DS,DGROUP
    assumes SS,DGROUP


;********** BackToCow **********
;*	* after a LeaveCow -- re-establish COW environment

cPublic BackToCow, <ATOMIC>
parmW	fRestoreScreenMode

cBegin	BackToCow

	cCall	FInitSysTimer
	cCall	InitInt24Etc			; Get back on int24

	mov	cx,fRestoreScreenMode
	jcxz	@F

	xor	ax,ax
	cCall	FInitScreen,<ax>		;* bring screen back

	cCall	FEnableMouse,<sp>

;;;	cCall	SetFocus, <pwndFocus>	; ??? Is this needed ???

@@:
	cCall	EnableKeyboard, <sp>

cEnd	BackToCow


sEnd	INIT

;*****************************************************************************

sBegin	EXIT
    assumes CS,EXIT
    assumes SS,DATA
    assumes DS,DATA

externNP    <EndInt24>				;* from int24.asm


;********** LeaveCow **********
;*	entry : fClearScreen => should we clear the screen
;*	* leave COW for a short while (running subshell)
;*	exit : n/a (COW disabled)

cProc	LeaveCow, <FAR,PUBLIC,ATOMIC>
    parmW fClearScreen
cBegin	LeaveCow

;*	* Unhook int24
	cCall	EndInt24
;*	* end keyboard before unhooking system timer
	xor	ax,ax
	cCall	EnableKeyboard, <ax>
	cCall	FlushKeyEvents

;*	* end system timers
	cCall	EndSysTimer
;*	* end mouse (NOTE:FInitMouse may not have been called)
	cCall	EndMouse
;*	* close the swap file (to be nice)
	mov	ax,-1
	xchg	iexeCur,al			;* set iexeCur = 255, get old
	cmp	al,ah
	je	no_file_open			;* iexeCur == 255
	mov	es,psLom
	mov	bx,es:[fdExeLom]
	AssertNE bx,-1
	mov	ah,3eh
	int	21h				;* close file
no_file_open:

	cCall	EndScreen,<fClearScreen>

cEnd	LeaveCow


;********** ExitKernel alias **********

LabelFP <PUBLIC, cw_exit>			;* special label for Binding
IFNDEF	FOR_QC				;* qc has a routine named _exit
LabelFP <PUBLIC, _exit>
ENDIF	; !FOR_QC
IFDEF DUAL
	jmp	ExitKernelOSSPEC
ELSE ;!DUAL
;*	* fall through to ExitKernel
ENDIF ;!DUAL

;********** ExitKernel / exit (ex) **********
;*	entry : ex = exit code
;*	* Exit from COW system (everything should already be unhooked)
;*	exit : never return to caller - return to system

cPublic ExitKernel,<ATOMIC>
   parmB ex
cBegin	ExitKernel

;*	* restore starting drive / directory
IFDEF	STARTUP_SAVE_DIR
	mov	bx,dataOffset szDirOrig
	mov	dl,[bx]
	sub	dl,'A'				;* A => 0.
	mov	ah,0eH
	int	21h				;* set drive

	mov	dx,bx				;* full drive / path
	mov	ah,3Bh
	int	21h				;* set directory
ENDIF	;STARTUP_SAVE_DIR

;*	* exit to DOS
	mov	al,ex
	mov	ah,4ch				;* terminate a process
	int	21h
IFDEF DUAL
done_exit:
ELSE ;!DUAL
;*	*NOTREACHED*
ENDIF ;!DUAL

cEnd	ExitKernel


sEnd	EXIT

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\krun2.asm ===
TOGGLE  EQU     1       ; degine the toggle        
;*
;*	COW : Character Oriented Windows
;*
;*	krun2.asm : Alternate Run/Exec (for shell)
;*	*KLUDGE* included by "krun.asm" if EXEC_ALTERNATE.

.xlist
include togequ.inc
.list

;*****************************************************************************

MovSeg	MACRO	srDest, srSrc
	push	srSrc
	pop	srDest
ENDM

;*****************************************************************************

sBegin	DATA

externW	<psLom>
externW	<pGlobalHeap>

externB	<fShellPresent>			;* from kerninit.asm
externB <fCompactLowerHeap>             ;* from gcompact.asm
externB fToggle 		        ; Flag indicating toggle state

IFNDEF NOPCODE
externW	 fNew				;* from interpreter
ENDIF ;!NOPCODE

sEnd	DATA




;*****************************************************************************

IFDEF DEBPUB
	PUBLIC	FzGetEnv, ShrinkGlobalHeap, RestoreGlobalHeap
ENDIF ;DEBPUB



sBegin	KERNEL
    assumes DS,KERNEL


;*	* data that MUST be in code space

staticW	ssSave, ?			;* save SS
staticW	spSave, ?			;* save SP
externW MgrSP                           ;* Manager Stack pointer


sEnd	KERNEL

;*****************************************************************************

externFPublic <AccessSwapFile>			;* for closing
externFPublic <PromptSwapDisk>			;* from App or stub.

IFDEF DEBUG
externFPublic <PrintGlobalHeap> 		;* Print contents of heap
ENDIF ;DEBUG

sBegin	EXIT
    assumes CS,EXIT
    assumes DS,NOTHING
    assumes SS,DATA

;*	* NOTE :
;*	*  GetEnv is in EXIT segment since LeaveCow will be called first

;********** FzGetEnv **********
;*	entry : ES:DI => environment string to look for (with ending '=')
;*		CX = length of string
;*	* scan environment for Variable
;*	exit : Z => DS:SI => contents on ENV variable
;*	    else NZ=> not found
;*	* NOTE : uses AX/SI/DS
;*
cProc	FzGetEnv,<FAR, ATOMIC>
cBegin	FzGetEnv
	AssertNE	cx,0			; Would produce a "found".
	mov	ds,psLom
	mov	ds,ds:[pdbLom.PDB_environ]	;* psEnvironment
    assumes ds,nothing
	xor	si,si				;* ds:si => environment
	cld
getenv_lp:
	push	di
	push	cx
	repz	cmpsb
	pop	cx
	pop	di
	jz	getenv_end
getenv_skip:
	lodsb
	or	al,al
	jnz	getenv_skip
	cmp	byte ptr ds:[si],al	;* is this the real end ?
	jnz	getenv_lp
	or	cx,cx			;* NZ => not found
getenv_end:
cEnd	FzGetEnv
    assumes ds,nothing

sEnd    EXIT


;*****************************************************************************

externFP GlobalCompact
externFPublic <LeaveCow, BackToCow>		;* in INIT


sBegin	KERNEL
    assumes CS,KERNEL
    assumes DS,NOTHING
    assumes SS,DATA

externNP    <genter>			; GINTERF.ASM
externNP    <gjoin,gmarkfree,gcheckfree>; GALLOC.ASM
externNP    <gnotify>		 	; GINTERF.ASM


;*****************************************************************************



;********** RerrExecProg **********
;*	entry : szCmd = program name (or NULL => shell)
;*		bCmdTail = Command Tail.
;*		(see kmem.h).
;*	* NOTE : it is the application's responsibility to ShrinkLocalHeap()
;*		all used local heaps.
;
; M003 - Only three arg pointers now passed.
; execl (szName, szArgs, szTokArg1, szTokArg2)
;
cProc   RerrExecProg,<FAR,PUBLIC>,<SI, DI>
        parmDP  szName
        parmDP  bCmdTail
cBegin  RerrExecProg

;
; * First lets Leave Cow and shrink the global Heap
	cCall	LeaveCow, <sp>			;* leave + clear screen

	cCall	ShrinkGlobalHeap, <sp>  ;* Make sure we discard everything

	PUSH	DS			; M004 - ES must be equal to DS for
	POP	ES			; M004 - STOS's and system calls
        
        mov     ax,4b00h                ; setup command tail
        xor     cx,cx                   ; zero out
        MOV     DX,szName               ; Get command name.
	MOV	BX,bCmdTail             ; Have command tail
	CLC

IFDEF   TOGGLE
	cmp	fToggle,FT_LOCKED	; If toggle entries are allowed during
	jne	EXint			;  execs but they are locked out now,
	cli				;  set fToggle to allow them during
	mov	fToggle,FT_NOTTOGGLED	;  this exec.  Only save SP when toggle
	mov	MgrSP,sp		;  entries are allowed.
ENDIF   ;TOGGLE

EXint:	INT	21h

IFDEF   TOGGLE
	push	ax			; Now if toggle entries were allowed
	lahf				;  during the exec, lock them out
	cmp	fToggle,FT_NOTTOGGLED	;  again because the exec has finished.
	jne	EXcln
	mov	fToggle,FT_LOCKED	; ***> HACK ALERT <***
EXcln:					; The CF flag must be saved and restored
	sahf				;  around the fToggle setting so that
	pop	ax			;  the success of the exec can be
	sti				;  determined.	This can't be done with
					;  pushf/popf because of a 286 chip bug
					;  so lahf/sahf were used instead.
					;  Gee - this is the 1st time I ever
					;  used those instructions!

ENDIF   ;TOGGLE
	JC	ExecErr

	mov	ah, 4dh			;Get the child return code.
	int	21h			;to return to the caller.
	
	jmp	ExecvDone
ExecErr:
	MOV	AX,-1
ExecvDone:


;*	* restore everything (and repaint screen)
	push	ax				;* save return value
	cCall	RestoreGlobalHeap

	pop	ax				;* return value

;*      * now return to the caller.
cEnd    RerrExecProg


;********** ShrinkGlobalHeap **********
;*	entry : n/a
;*	* shrink the global heap
;*	exit : n/a
;*	* NOTE : this code must be fixed since it throws everything out.

cProc	ShrinkGlobalHeap, <PUBLIC, NEAR, ATOMIC>, <SI, DI>
        parmW    fDiscardCode

cBegin	ShrinkGlobalHeap

    assumes DS,DGROUP

;*	* compact the heap (removing any free gaps) -- throw out code as well

	push	ds
	mov	es,pGlobalHeap
	xor	di,di
        
        mov     cx,fDiscardCode
        jcxz    NoDiscard               ;* We dont need to discard
	mov	ax,1			;* 1 reserved para
					;* NOTE : kludge to get all code
					;*   discarded !!!
	xchg	ax,es:[di].gi_reserve	;* get old reserve
	push	ax
	mov	ax,-1
	cCall	GlobalCompact,<ax, ax>	;* (-1) throw everything out
	mov	es,pGlobalHeap
	pop	es:[di].gi_reserve	;* restore reserve size

;*      * now lets try to compact everything to the lower heap including
NoDiscard:
;*      * fixed code blocks.
        mov     fCompactLowerHeap,1     ;* turn on special mode
        mov     ax,-1                   ;* It does not mater what number
        cCall   GlobalCompact,<ax, ax>  ;* move everything down

;*      * everything is as low as it can get, now we need to
;*      * shrink memory allocations or release them if they are not needed        
	mov	es,pGlobalHeap
        mov     fCompactLowerHeap,0     ;* Now turn it off

	mov	es,es:[di].hi_last	;* es => end sentinal
	mov	dx,es

;*	* scan from end till finding free block
find_free_loop:
	mov	es,es:[di].ga_prev	;* next block
        cmp     es:[di].ga_sig, GA_HOLE ;* do we have a hole
        jnz     ffl_not_hole            ;* No not a hole
        mov     dx,es                   ;* Save for now we have hole
        jmp     short find_free_loop    ;* continue the search
ffl_not_hole:
	mov	cx,es:[di].ga_owner
	jcxz	found_free		;* 0 owner => free
        mov     ax,es
	cmp     ax,es:[di].ga_prev      ;* previous pointer
	jnz	find_free_loop		;* -1 owner => MOB or sentinal (stop)
	jmp	end_shrink		;* No more to process

found_free:
;*	* es:0 => free block, dx:0 => end sentinal
;*      * see if special case, where previous is Hole and next is sentinal
;*      * or hole, in which case we can get rid of allocation.
;;;;        cmp     es:[di].ga_next,dx      ;* see if free space at end
;;;;        jnz     not_at_end              ;* no?
        mov     ds,es:[di].ga_prev      ;* see if special case
    assumes ds,NOTHING
        cmp     ds:[di].ga_sig,GA_HOLE  ;* See if we can purge the complet allocation
        jnz     part_is_used            ;* part of allocation still used.
;*
;*      * We have a memory allocation that can be freed to system
;*      * first turn hole into endsigniture. (or hole)        
;*      * ds:0 => hole, es:0 => free; dx:0 =>end sentinal        
        mov     es,dx                   ;* es:0 => End sentinal (or hole)
        mov     dx,ds:[di].ga_newpara   ;* dx => now has the allocated paragraph

        mov     al,es:[di].ga_sig       ;* get it signature
        mov     ds:[di].ga_sig,al       ;* put it in the holes.
        cmp     ax,GA_HOLE              ;* see if it was a hole
        jnz     no_hole_after_this_one  ;* no, not hole

;*      * have previous allocation (hole) still in use, need to fixup
        mov     ax,es:[di].ga_newpara   ;* need to save old holes starting pos
        mov     ds:[di].ga_newpara,ax   ;* 
        
;*      * also setup pointer to first allocation
        mov     ax,es:[di].ga_next      ;* Get the next pointer
        mov     ds:[di].ga_next,ax      ;* set as our next pointer
        mov     es,ax                   ;* we need to set its previous pointer
        mov     es:[di].ga_prev,ax      ;* links now setup
;*      * calculate new size of hole
        mov     bx,ds                   ;* pointer to 
        sub     ax,bx                   ;*
        dec     ax                      ;* new size
        mov     ds:[di].ga_size,ax      ;*

        jmp     short free_unused_alloc

;*      * No previous hole, we have the new end signature for now
no_hole_after_this_one:
        mov     ds:[di].ga_size,1       ;* assume it was an endsignature
        mov     ds:[di].ga_next,ds      ;* point to ourself

;*      * now lets free the unused segments.
free_unused_alloc:
        mov     es,dx                   ;* The allocation to delete
        mov     ah,49h
        int     21h                     ;* deleted the allocation.
        mov     dx,ds                   ;* setup to continue
        mov     es,dx                   ;* es:di =>hole

	cCall	genter			;* DS:DI => mob
        cmp     es:[di].ga_sig,GA_ENDSIG
        jnz     free_010
	mov	ds:[di].hi_last,dx	;* now the last block
free_010:
	sub	ds:[di].hi_count,2	;* remove old sentinal and free block
        jmp     short find_free_loop    ;* continue to process

;*****************************
;*      * Part of the allocation is still used.  See if we are in our
;*      * base, or in an extra allocated segment.
;*      * we can find this out, by, scanning backward until we find
;*      * a hole, or the beginning.
;*      * es:0 => free, ds:0 => previous, dx:0 => end of group
part_is_used:
;*      * convert the free block into either sentinal or hole
        push    ds                      ;* save previous pointer
        mov     ds,dx                   ;* End of allocation
        mov     bl,ds:[di].ga_sig       ;* see if hole or endsiz
	mov	es:[di].ga_sig,bl       ;* the signature
	mov	es:[di].ga_owner,-1
	mov	es:[di].ga_flags,0
        cmp     bl,GA_ENDSIG            ;* end or hole?
        jz      piu_end_was_end         ;* end was a end

;*      * End was hole, need to setup size and pointer
        mov     ax,ds:[di].ga_newpara   ;* need to save old holes starting pos
        mov     es:[di].ga_newpara,ax   ;* 
        
;*      * also setup pointer to allocation
        mov     ax,ds:[di].ga_next      ;* Get the next pointer
        mov     es:[di].ga_next,ax      ;* set as our next pointer
        mov     ds,ax                   ;* we need to set its previous pointer
        mov     ds:[di].ga_prev,ax      ;* links now setup
;*      * calculate new size of hole
        mov     cx,es                   ;* pointer to 
        sub     ax,cx                   ;*
        dec     ax                      ;* new size
        mov     es:[di].ga_size,ax      ;*
        jmp     short piu_find_begin    ;* find beginning of memory unit

;*      * No previous hole, we have the new end signature for now
piu_end_was_end:
        mov     es:[di].ga_size,1       ;* assume it was an endsignature
        mov     es:[di].ga_next,es      ;* point to ourself

;*      * now lets find the beginning of the memory unit.
piu_find_begin:
        pop     ds                      ;* restore pointer to previous
                
piu_loop: 
        cmp     ds:[di].ga_sig,GA_HOLE  ;* do we have a hole
        jz      piu_endloop             ;* We are processing hole segment
        mov     ax,ds                   ;* get previous pointer
        cmp     ax,ds:[di].ga_prev      ;* see if beginning of memory
        jz      piu_endloop             ;* we have processed the holes.
        mov     ds,ds:[di].ga_prev      ;* still looking
        jmp     short piu_loop          ;*
piu_endloop:
        push    ds                      ;* save starting point
        cCall   genter                  ;* get DS;DI => mob

;*	* at the end of the heap MUST be a free block of a reasonably
;*	* large size (the free block due to freeing all code)
    assumes ds,NOTHING
        dec     ds:[di].hi_count        ;* decrement the count
        mov     dx,es                   ;* dx = address of sentinal
        cmp     bl,GA_ENDSIG            ;* see if we need to update last ptr
        jnz     piu_not_last
        mov     ds:[di].hi_last,dx      ;* new last pointer
piu_not_last:
        pop     ds                      ;* restore first in block
        cmp     ds:[di].ga_sig,GA_HOLE  ;* see if hole or orignal
        jz     piu_hole                 ;

;*      * the part in use is from the original allocation
	mov	ax,psLom		;* 1 big block
        jmp     short piu_resize        ;* goto resize the block

;*      * was part that was added on
piu_hole:
        mov     ax,ds:[di].ga_newpara   ;* get the starting segment

;*      * now freeup the free part of the segment
piu_resize:
;*	* now free up anything to DOS
	mov	es,ax
        mov     bx,dx                   ;*
	sub	bx,ax			;* size of new block (in para)
	add	bx,1+cparaRunShell	;*  add slush (+1 to keep end sentinal)
	mov	ah,4ah			;* modify allocated memory
	int	21h

;*      * now setup to try to process any other blocks
        mov     dx,ds                   ;* save dx=end of group
        mov     es,dx                   ;* 
        jmp     find_free_loop          ;* see if anymore groups to process

;*	* resume with smaller global heap

end_shrink:
	pop	ds
IFDEF DEBUG
	call	FAR PTR PrintGlobalHeap 	;*!! look at heap on exit
ENDIF ;DEBUG

cEnd	ShrinkGlobalHeap




;********** RestoreGlobalHeap **********
;*	entry : n/a
;*	* restore global heap after ShrinkGlobalHeap
;*	exit : n/a
cProc	RestoreGlobalHeap, <PUBLIC, NEAR, ATOMIC>, <DS, SI, DI>

cBegin	RestoreGlobalHeap
    assumes ds,DGROUP

;*	* modify block to make as large as possible
;*      * first see if we have fragmented memory.  If so, reallocate
;*      * only the top one (for now).
;*
        push    ds                              ;* save for now
	cCall	genter				;* DS:DI => mob
        mov     es,ds:[di].hi_last              ;* Point to last segment
        mov     cx,ds:[di].hi_count             ;* get count
        pop     ds                              ;* restore ds segment
rst_loop:
        cmp     es:[di].ga_sig,GA_HOLE          ;* look for hole
        jz      rst_hole                        ;* found a hole segment
        mov     es,es:[di].ga_prev              ;* nope, lets try the next one
        loop    rst_loop                        ;*
;*      * if we got here, we have only one memory allocation
	mov	es,psLom			;* 1 big block
        jmp     short rst_try_1meg              ;* lets try to get 1 meg

rst_hole:
;*      * found a hole, get its segment number and try to expand
        mov     es,es:[di].ga_newpara           ;* address of memory allocation

rst_try_1meg:
;*      * now try to allocate 1 meg, such that we can find out how much we can get

	mov	bx,0ffffh			;* i want it all
	mov	ah,4ah
	int	21h
IFDEF DEBUG
	jc	ok_we_asked_for_too_much
	int	3				;* we got 1MB ???
ok_we_asked_for_too_much:
ENDIF ;DEBUG

;*	* now do it for real
	mov	ah,4ah
	int	21h
IFDEF DEBUG
	jnc	ok_we_got_it_back
	int	3				;* we got 1MB ???
ok_we_got_it_back:
ENDIF ;DEBUG


;*	* get address of new end sentinal
	mov	ax,es
        mov     cx,es                           ;* have cx save es
	add	ax,bx				;* ax = new end
;*	* check to make sure we are within the useable limits
        mov     es,psLom
	cmp	ax,es:[psUseMax]
	jb	have_high_limit
;*	* we must adjust our block size (free the rest to DOS)
;*	* (not efficient -- clean up later)
	mov	bx,es:[psUseMax]
	push	bx				;* limit
	sub	bx,cx				;* size we will use
        mov     es,cx                           ;* we need our segment
	mov	ah,4AH
	int	21h				;* modify memory size
	pop	ax
;*	AssertEQ ax,es:[psUseMax]
have_high_limit:
        mov     es,cx                           ;* restore our seg
	sub	ax,GA_ALIGN			;* room for arena
	and	al,LOW(GA_MASK)			;* make even
	mov	ds,ax				;* es => new sentinal
    assumes ds,NOTHING
;*	* create new sentinal
	xor	bx,bx
	mov	ds:[bx].ga_sig,GA_ENDSIG
	mov	ds:[bx].ga_owner,-1		;* sentinal
	mov	ds:[bx].ga_size,GA_ALIGN
	mov	ds:[bx].ga_flags,bl
	mov	ds:[bx].ga_handle,bx		;* no handle
	mov	ds:[bx].ga_next,ds		;* link to self
	mov	cx,ax				;* psNew

	cCall	genter				;* DS:DI => mob
        cmp     ax,ds:[bx].hi_last
        je      NoFreeMem                       ;* TSR Got us
	xchg	ax,ds:[bx].hi_last		;* set new last, get old
	inc	ds:[di].hi_count		;* adding free object

	mov	ds,ax
	mov	es,cx
	mov	es:[bx].ga_prev,ds		;* link to other free
IFDEF DEBUG
	cmp	ds:[bx].ga_sig,GA_ENDSIG
	je	ok_end_sig
	int	3
ok_end_sig:
ENDIF ;DEBUG

	sub	cx,ax				;* psNew - psOld
	sub	cx,GA_ALIGN			;* less overhead

	mov	ds:[bx].ga_sig,GA_SIGNATURE
	mov	ds:[bx].ga_owner,bx		;* FREE !!!
	mov	ds:[bx].ga_flags,GA_MOVEABLE
	mov	ds:[bx].ga_size,cx		;* new size
	mov	ds:[bx].ga_next,es		;* point to new sentinal
NoFreeMem:

cEnd	RestoreGlobalHeap



;*****************************************************************************


;********** CompactToUpperHeap **********
;*	entry : n/a
;*	* compact to upper heap
;*	exit : n/a
;*	* NOTE : this code must be fixed since it throws everything out.

cProc	CompactToUpperHeap, <FAR,PUBLIC, ATOMIC>, <DS, SI, DI>
cBegin	CompactToUpperHeap

    assumes DS,DGROUP

;*	* compact the heap (removing any free gaps) -- throw out code as well

	mov	es,pGlobalHeap
	xor	di,di
	xor	ax,ax			;*   discarded !!!

;* setup to compact to upper heap
					;* NOTE : kludge to get all code
	xchg	ax,es:[di].gi_reserve	;* get old reserve
	push	ax
	xor	ax,ax
	cCall	GlobalCompact,<ax, ax>	;* Just get biggest chunk.
	mov	es,pGlobalHeap
	pop	es:[di].gi_reserve	;* restore reserve size

cEnd	CompactToUpperHeap



sEnd	KERNEL
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\ktimer5.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	ktimer5.asm : DOS 5 kernel timer (for ticks)

	include kernel.inc

IFNDEF DOS5
	.error	-- only DOS 5
ENDIF


sBegin	DATA
    assumes DS,DGROUP

externDP pwndAlarm				;* != NULL if alarm set
externD  semaMessage				;* message semaphore

labelD dmsKick					;* time to sleep
staticW	OFF_dmsKick,-1
staticW	SEG_dmsKick,-1

sEnd	DATA

sBegin	BSS
    assumes DS,DGROUP

staticD semaTimer, 0				;* timer semaphore
staticW	idThread, 0				;* id of timer thread
staticB	fTimerLive, 0				;* TRUE => timer alive


;*	* stack
	DB	64 DUP (?)
labelB	wStackMax



sEnd	BSS

;*****************************************************************************

;*	* DOS 5 calls

externFP  <DosCreateThread, DosSemClear, DosSemSetWait, DosSemClear, DosExit>


;*****************************************************************************

sBegin	KERNEL
    assumes CS,KERNEL
    assumes SS,NOTHING
    assumes DS,NOTHING	;* interrupt handler may be called from anywhere

;********* TimerThread **********
;*	entry : semaEvent and semaTimer valid
;*	* THREAD for processing timer
;*	exit : n/a (dies when killed)

labelFP	TimerThread
    assumes DS,DATA
;*	* when timer semaphore gets cleared, clear the message semaphore
;*	* (this thread is necessary since we want 1 semaphore for all
;*	*  input events).

	test	fTimerLive,-1
	jz	TimerDies

	PushArg	<ds, <dataOffset semaTimer>>	;* hsemaTimer
	PushArg	<SEG_dmsKick, OFF_dmsKick>	;* wait time
	cCall	DosSemSetWait
;*	* timer has elapsed, clear message semaphore
	PushArg	<ds, <dataOffset semaMessage>>
	cCall	DosSemClear
	jmp	TimerThread			;* forever

TimerDies:
	xor	ax,ax
	cCall	DosExit, <ax, ax>		;* kill this thread
;*	* NOTREACHED



;********** KickTimer **********
;*	entry : dms = time in ms to kick timer
;*	*
cPrivate KickTimer, <>
    parmD dms
cBegin	KickTimer

	mov	ax,OFF_dms
	mov	dx,SEG_dms
	mov	OFF_dmsKick,ax
	mov	SEG_dmsKick,dx
;*	* now kick the timer to install the new time
	PushArg	<ds, <dataOffset semaTimer>>	;* hsemaTimer
	cCall	DosSemClear

cEnd	KickTimer


sEnd	KERNEL

;*****************************************************************************

sBegin	INIT
    assumes CS,INIT
    assumes DS,DGROUP
    assumes SS,DGROUP


;********** InitSysTimer **********
;*	entry : n/a
;*	* Called to initialize the timer routine
;*	exit : ax != 0 => ok

cProc	FInitSysTimer,<FAR,PUBLIC,ATOMIC>
cBegin	FInitSysTimer

;*	* create the timer thread
	mov	ax,-1
	mov	OFF_dmsKick,ax
	mov	SEG_dmsKick,ax		;* longest time to sleep
	mov	fTimerLive,al

IFNDEF COW_SWAPPED
	mov	dx,cs
ELSE
	mov	dx,SEG kernelBase
ENDIF
	mov	ax,kernelOffset TimerThread
	PushArg	<dx, ax>
	PushArg	<ds, <dataOffset idThread>>
	PushArg	<ss, <dataOffset wStackMax>>
	cCall	DosCreateThread
	or	ax,ax
	jnz	init_timer_error

	ExitTrueUnless init_timer_error

cEnd	FInitSysTimer


sEnd	INIT

;*****************************************************************************

sBegin	EXIT
    assumes CS,EXIT
    assumes SS,DATA
    assumes DS,DATA


;********** EndSysTimer **********
;*	entry : n/a
;*	* Unhook the timer interrupt
;*	exit : n/a

cProc	EndSysTimer,<FAR,PUBLIC,ATOMIC>
cBegin	EndSysTimer

;*	* kill thread
	mov	fTimerLive,0
;*	* kick the thread (timer semaphore) so the thread dies
	PushArg	<ds, <dataOffset semaTimer>>	;* hsemaTimer
	cCall	DosSemClear

cEnd	EndSysTimer

sEnd	EXIT

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\ktimer.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	ktimer.asm : kernel timer routine (for LRU sweep only at present).

	include kernel.inc

ctickLruMax	EQU	6			;* 6/18 = 1/3 s (approx.)


IFDEF DEBPUB
	PUBLIC	HandlerTimer
ENDIF ;DEBPUB


sBegin	DATA
    assumes DS,DGROUP

externDP pwndAlarm				;* != NULL if alarm set
externW  fMessage
globalW  wTimer,0

sEnd	DATA

sBegin	BSS
    assumes DS,DGROUP

labelD	pfnHdlrTimer				;* old int8 handler
staticW	OFF_pfnHdlrTimer,?
staticW	SEG_pfnHdlrTimer,?

staticB	ctickLruCur,0

sEnd	BSS

;*	* Entries to initialize
sBegin	KERNEL

;*	* LRU sweep
externNP    <SweepLru>				;* from ldthunk.asm

sEnd	KERNEL


sBegin	INIT
    assumes CS,INIT
    assumes DS,DGROUP
    assumes SS,DGROUP


;********** FInitSysTimer **********
;*	entry : n/a
;*	* Called to initialize the timer routine
;*	exit : AX == true

cProc	FInitSysTimer,<FAR,PUBLIC,ATOMIC>
cBegin	FInitSysTimer

	mov	ax,3508H			; Get Interrupt Vector 8H
	int	21H
	mov	OFF_pfnHdlrTimer,bx
	mov	SEG_pfnHdlrTimer,es

;*	* Set new interrupt handler
	push	ds
	mov	ax,SEG kernelBase		;* both in KERNEL segment
	mov	ds,ax
    assumes ds,nothing

	mov	dx,kernelOffset HandlerTimer
	mov	ax,2508H			; Set Interrupt Vector 8
	int	21H
	pop	ds
    assumes ds,DATA
	mov	ax,sp				;* always return true

cEnd	FInitSysTimer


sEnd	INIT

;*****************************************************************************

sBegin	EXIT
    assumes CS,EXIT
    assumes SS,DATA
    assumes DS,DATA


;********** EndSysTimer **********
;*	entry : n/a
;*	* Unhook the timer interrupt
;*	exit : n/a

cProc	EndSysTimer,<FAR,PUBLIC,ATOMIC>
cBegin	EndSysTimer

	push	ds
	lds	dx,pfnHdlrTimer
    assumes ds,NOTHING
	mov	ax,2508H			; Set Interrupt Vector 8H
	int	21H
	pop	ds
    assumes ds,DATA

cEnd	EndSysTimer

sEnd	EXIT

;*****************************************************************************

sBegin	KERNEL
    assumes CS,KERNEL
    assumes SS,NOTHING
    assumes DS,NOTHING	;* interrupt handler may be called from anywhere

;********* HandlerTimer **********
;* INTERRUPT HANDLER
;*	entry : hardware timer interrupt (every ~1/18 of a second).
cProc	HandlerTimer,<FAR,ATOMIC>
cBegin	nogen;HandlerTimer

	push	ax
	push	ds

	mov	ax,SEG DGROUP
	mov	ds,ax
    assumes ds,DATA

;*	* call the old int8 handler
	pushf				;* make it look like an interrupt
	call	[pfnHdlrTimer]

;*	* if alarm set, set fMessage
	mov	ax,pwndAlarm
	or	fMessage,ax

;*	* see if we must decrement the pCode's timer counter
	cmp	wTimer,0
	jne	DoDecr
DoneDecr:

;*	* see if we must sweep the LRU
	mov	al,ctickLruCur
	inc	al
	mov	ctickLruCur,al		;* update count
	cmp	al,ctickLruMax
	jb	end_sweep
;*	* Sweep the LRU : Enable interrupts first !!!
	mov	ctickLruCur,0		;* start over
	STI
	Save	<bx,cx,dx,es>		;* save trashable registers
	cCall	SweepLru
end_sweep:

	pop	ds
    assumes ds,nothing
	pop	ax			;* restore everything
	iret

cEnd	nogen;HandlerTimer

; --------------------------------------

	assumes ds,DATA
DoDecr:					;* The pCode has set wTimer != 0.
	dec	wTimer			;* It's our job to decrement it once
	jmp	short DoneDecr		;*   per timer tick until back to 0.
	assumes ds,nothing

; --------------------------------------

sEnd	KERNEL

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\ladebug.h ===
/*
	COW : Character Oriented Windows

	lacheck.h : header info for checking local heap
*/

#include "handle.h"

/*	* Additional Types */
typedef int (FAR PASCAL *FARPROC)();		/* Medium Model */
typedef int (NEAR PASCAL *NEARPROC)();		/* Medium Model */

WORD	NEAR * PASCAL pLocalHeap;

#define LOCALARENA struct localarena

LOCALARENA {
    LOCALARENA     *la_prev;
    LOCALARENA     *la_next;
    HANDLEENTRY    *la_handle;
};
typedef LOCALARENA *PLOCALARENA;

typedef struct {
    WORD            hi_check;
    WORD            hi_freeze;
    WORD            hi_count;
    PLOCALARENA     hi_first;
    PLOCALARENA     hi_last;
    BYTE            hi_ncompact;
    BYTE            hi_dislevel;
    WORD            hi_distotal;
    HANDLETABLE    *hi_htable;
    HANDLEENTRY    *hi_hfree;
    WORD            hi_hdelta;
    NEARPROC        hi_hexpand;

    FARPROC         li_notify;
    WORD            li_lock;
    WORD            li_extra;
#ifdef DEBUG
    WORD	    li_cbOverhead;
    WORD	    li_cblkOverhead;
#endif /*DEBUG*/
} LOCALINFO;

typedef LOCALINFO *PLOCALINFO;

#define LA_BUSY     1
#define LA_MOVEABLE 2
#define LA_ALIGN   (LA_MOVEABLE+LA_BUSY)
#define LA_MASK    (~ LA_ALIGN)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\lddrvd5.asm ===
;*
;*	CW : Character Windows
;*
;*	loaddrv.asm : installable driver loader routines

	include kernel.inc
	include kmem.inc
	include indrv.inc
	include inscr.inc
	include	inkbd.inc
	include insyd.inc
	include	_loaddrv.inc

;*****************************************************************************

;*	App call backs for memory management

;; REVIEW: hard coded driver allocation!
externFP	<LpwAllocDriverMem,FreeDriverMem>

IFDEF DOS5
externFP	<DosOpen, DosClose>
externFP	<DosChgFilePtr, DosRead>
externFP	<DosCreateCSAlias>
ENDIF

sBegin	DATA
    assumes CS,DGROUP
    assumes DS,DGROUP

ifndef	DOS5
externW	chDrivePhantom			; set to "b:" on one floppy systems.
endif	; !DOS5

externW		<inkj>		; keyboard
externW		<insj>		; screen (character)
externW		<inyj>		; system

ifdef	DUAL
ifndef	DOS5
LDRVDATA = 1
endif
else	;!DUAL
LDRVDATA = 1
endif	;!DUAL

ifdef	LDRVDATA

labelW	<PRIVATE, rgindvCw>		;* INDV structures for csd, kbd

labelW	<PUBLIC, indvKbd>		;* Keyboard
	DB	indtKeyboard,0
	DW	dataOffset inkj
	DW	cpfnKbdMin
	DW	cpfnKbdMin
	DW	0
	DW	0

labelW	<PUBLIC, indvCsd>		;* Character Screen
	DB	indtCharacterScreen,0
	DW	dataOffset insj
	DW	cpfnCsdMin
	DW	cpfnCsdMin
	DW	0
	DW	0

labelW	<PUBLIC, indvSyd>		;* System Services
	DB	indtSystem,0
	DW	dataOffset inyj
	DW	cpfnSydMin
	DW	cpfnSydMin
	DW	0
	DW	0

	PUBLIC	cindvCw
cindvCw	EQU	($-rgindvCw)/cbIndvMin

else	;!LDRVDATA

externW	rgindvCw

endif	;!LDRVDATA

IFDEF DOS5
externB		inosDrv				;* INOS info (from loaddrv.asm)
ENDIF ;DOS5

sEnd	DATA


ifndef	LDRVDATA

externA	cindvCw

endif	;!LDRVDATA

;*****************************************************************************

sBegin	KERNEL
    assumes CS,KERNEL
    assumes DS,DGROUP
    assumes SS,DGROUP



;********** RerrLoadDrv **********
;*	entry:	szFile => full file name of driver
;*		rgindv => cindv INDV records
;*	* Loads drivers from given file
;*	exit:	0	ok, otherwise error code: rerrBadRead,
;*						  rerrBadFormat,
;*						  rerrNoMemory,
;*						  rerrBadFile,
;*						  rerrBadMemReq,
;*						  rerrBadVersion
;*
;*	On error, no service is partially installed.  However, only some
;*	services may have been installed.
;*
;*	nop if cindv == 0 


RLD_Err:
	mov	ax,rerrBadFile		; restrict error returned
wlds_Abort1:
	jmp	wlds_Abort

;----------------------------------------


cProc	RerrLoadDrv, <PUBLIC,FAR>,<DI,SI>
    parmW	szFile
    parmW	rgindv
    parmW	cindv
    localW	hFile
IFDEF DOS5
    localW	action
    localW	HI_tmp
    localW	LO_tmp
ENDIF ;DOS5
    localW	HI_lfaMT
    localW	LO_lfaMT
    localW	HI_lpwCSeg
    localW	LO_lpwCSeg
    localW	HI_lfaReadMT
    localW	LO_lfaReadMT
    localW	pindv
    localW	cb			; count of bytes in rgbBuff
    localV	rgbBuff,cbBuff		; buffer for master table entries
cBegin	RerrLoadDrv

	;*	set indv's to not loaded

	xor	ax,ax
	mov	cx,cindv
	jcxz	wlds_Abort1		; no service will be loaded
	mov	di,rgindv

@@:	jcxz	@F
	mov	[di].psLoadedIndv,ax
	mov	[di].cpfnLoadedIndv,ax
	add	di,cbIndvMin
	loop	@B
@@:

	;*	open file

IFDEF	DOS5

	lea	ax,hFile
	lea	bx,action
	cCall	DosOpen,<ss,szFile,ss,ax,ss,bx,0,0,0,01h,openRO,0,0>
	or	ax,ax
	jnz	RLD_Err

ELSE	; !DOS5

	mov	dx,szFile

	mov	bx,dx
	mov	ax,[bx]			; Get first two letters
	or	al,20h			; If the file is "B:xxx" on a single
	cmp	ax,chDrivePhantom	;   floppy system, then no can do.
	je	RLD_Err

	mov	ax,3d00h
	int	21h
	mov	hFile,ax
	jc	RLD_Err

ENDIF	; !DOS5

IFNDEF DOS5
	;*	seek to EOF magic tag

	mov	bx,hFile
	mov	ax,-cbIndhMin
	cwd
	mov	cx,dx
	mov	dx,ax
	mov	ax,4202h		; offset is from EOF
	int	21h
	jc	wlds_AbFileshort2

	;*	compute absolute offset to EOF

	add	ax,cbIndhMin
	adc	dx,0
	mov	LO_lfaReadMT,ax
	mov	HI_lfaReadMT,dx
ELSE
	;*	seek to EOF magic tag

	mov	ax,-cbIndhMin
	cwd
	lea	bx,LO_lfaReadMT		; HI_ is in appropriate position
	cCall	DosChgFilePtr,<hFile,dx,ax,2,ss,bx>
	or	ax,ax
	jnz	wlds_AbFileshort2

	;*	compute absolute offset to EOF

	mov	ax,cbIndhMin
	add	LO_lfaReadMT,ax
	adc	HI_lfaReadMT,0
ENDIF ;DOS5

	;*	read magic tag and dlfaTable

	lea	dx,rgbBuff
IFNDEF DOS5
	mov	ah,3fh
	AssertEQ bx,hFile
	mov	cx,cbIndhMin
	int	21h
	jc	wlds_AbFileshort2
ELSE
	lea	ax,cb
	cCall	DosRead,<hFile,ss,dx,cbIndhMin,ss,ax>
	or	ax,ax
	jnz	wlds_AbFileshort2
	mov	ax,cb
ENDIF ;DOS5

	cmp	ax,cbIndhMin		; check read
	mov	ax,rerrBadRead
	jne	wlds_AbFileshort1

	mov	ax,rerrBadFormat
	mov	cx,rgbBuff+LO_rgchMagicIndh
					; check magic word ("DRV0")
	cmp	cx,'RD'
	jne	wlds_AbFileshort1		; invalid format
	mov	cx,rgbBuff+HI_rgchMagicIndh
	cmp	cx,'0V'
	je	@F
wlds_AbFileshort2:
	mov	ax,rerrBadRead
wlds_AbFileshort1:
	jmp	wlds_AbFile		; invalid format
@@:

	;*	compute offset of master table
	
	mov	dx,LO_lfaReadMT
	mov	cx,HI_lfaReadMT
	sub	dx,rgbBuff+LO_dlfaTableIndh
	sbb	cx,rgbBuff+HI_dlfaTableIndh

	;*	save lfa of master table

	mov	LO_lfaMT,dx
	mov	HI_lfaMT,cx

	;*	prep for master table read

	mov	LO_lfaReadMT,dx
	mov	HI_lfaReadMT,cx
	mov	cx,cbBuff

	;*
	;*	Read from lfaReadMT into rgbBuff
	;*	cx	bytes to read
	;*
	;*	cb	bytes read
	;*	lfaReadMT
	;*		adjusted to next byte to be read
	;*	di	points to first INDS (smart about table header)

wlds_ReadMT:

	;*	seek to lfaReadMT

IFNDEF DOS5
	push	cx
	mov	ax,4200h
	mov	bx,hFile
	mov	dx,LO_lfaReadMT
	mov	cx,HI_lfaReadMT
	int	21h
	pop	cx
	jc	wlds_AbFileshort2
ELSE
	lea	ax,LO_tmp		; dummy
	cCall	DosChgFilePtr,<hFile,HI_lfaReadMT,LO_lfaReadMT,0,ss,ax>
	or	ax,ax
	jnz	wlds_AbFileshort2
ENDIF ;DOS5

	;*	read master table entries

	lea	dx,rgbBuff
IFNDEF DOS5
	mov	ah,3fh
	AssertEQ bx,hFile
	int	21h
	jc	wlds_AbFileshort2
	mov	cb,ax			; save bytes read
ELSE
	lea	ax,cb
	cCall	DosRead,<hFile,ss,dx,cx,ss,ax>
	or	ax,ax
	jnz	wlds_AbFileshort2
	mov	ax,cb
ENDIF ;DOS5

	or	ax,ax
	mov	ax,rerrBadRead
	jnz	@F
	jmp	wlds_AbFile		; check for read beyond EOF
@@:

	;*	cx:dx == lfaRead

	mov	dx,LO_lfaReadMT
	mov	cx,HI_lfaReadMT

	lea	di,rgbBuff		; di points to inds struct

	;*	if we just read from lfaMT, check magic, load number of
	;*		services, and increase di after INDT

	cmp	dx,LO_lfaMT
	jne	not_first_mt_read
	cmp	cx,HI_lfaMT
	jne	not_first_mt_read

	;*	check magic word

	mov	ax,rerrBadFormat
	mov	bx,rgbBuff+LO_rgchMagicIndt
					; check magic word ("DRV0")
	cmp	bx,'RD'
	jne	wlds_AbFileshort1	; invalid format
	mov	bx,rgbBuff+HI_rgchMagicIndt
	cmp	bx,'0V'
	je	@F
	jmp	wlds_AbFile		; invalid format
@@:

	;*	si == number of services

	mov	si,rgbBuff+cindsIndt	; si services in file

	;*	di => INDS

	lea	di,rgbBuff+rgindsIndt
not_first_mt_read:

	;*	adjust lfaReadMT

	add	dx,cb
	adc	cx,0
	mov	LO_lfaReadMT,dx
	mov	HI_lfaReadMT,cx

	;*
	;*	Load next service
	;*	si	number of services left to load
	;*	di	current inds structure
	;*

wlds_Load:

	;*	are we done?

	xor	ax,ax
	dec	si
	jge	@F
	jmp	wlds_done		; load completed
@@:

	;*	have we run out of services in this block?

	lea	ax,rgbBuff
	add	ax,cb
	cmp	ax,di
	ja	@F

	;*	read next block of INDS structures

	inc	si			;* retry this service
	mov	cx,cbBlock
	jmp	wlds_ReadMT
@@:

	;*	should we load this service?

	push	di

;*	* first see if operating system is supported
IFDEF DOS5
	test	[di].floadInds,floadProtMode
ELSE
	test	[di].floadInds,floadRealMode
ENDIF ;!DOS5
	jz	wlds_indtNotfound

	mov	ah,[di].indtInds

	;*	search rgindv

	mov	di,rgindv
	mov	cx,cindv
wlds_nextindv:
	cmp	ah,[di].indtIndv
	jne	@F
					; found indv
	mov	pindv,di
	clc				; flag load
	jmp	short wlds_endIndtLookup
@@:
	add	di,cbIndvMin
	loop	wlds_nextindv
wlds_indtNotfound:
	stc				; no service info, flag no load

wlds_endIndtLookup:

	pop	di
	jnc	@F
	jmp	wlds_loadnext		; unknown service
@@:

	;*
	;*	Load service segment
	;*

	;*	allocate code area

	mov	ax,[di].cbCodeInds
	inc	ax			; round up
	AssertNE ax,0
	shr	ax,1			; convert cb -> cw
	test	[di].floadInds,floadFixed

IFNDEF LATER
	AssertNZ			; only know about fixed segments
	mov	bx,fmemFixed
ENDIF

	cCall	<LpwAllocDriverMem>,<ax,bx>
	mov	cx,ax
	or	cx,dx
	jnz	@F
	mov	ax,rerrNoMemory
	jmp	wlds_AbFile
@@:
IFDEF DEBUG				; valid pointers are either ds:offset
					;  or other:0000
	mov	bx,ds
	cmp	bx,dx
	je	@F
	AssertEQ ax,0
@@:
ENDIF ;DEBUG

	;*	save pointer to code area

	mov	LO_lpwCSeg,ax
	mov	HI_lpwCSeg,dx

	;*	seek to service segment

	mov	dx,LO_lfaMT
	mov	cx,HI_lfaMT
	sub	dx,[di].LO_dlfaCodeInds	; calculate lfaCode
	sbb	cx,[di].HI_dlfaCodeInds
IFNDEF DOS5
	mov	ax,4200h
	mov	bx,hFile
	int	21h
	jc	wlds_AbCodeshort2
ELSE
	lea	ax,LO_tmp		; dummy
	cCall	DosChgFilePtr,<hFile,cx,dx,0,ss,ax>
	or	ax,ax
	jnz	wlds_AbCodeshort2
ENDIF ;DOS5

	;*	read in code segment

IFNDEF DOS5
	push	ds
	mov	ah,3fh
	mov	bx,hFile
	mov	cx,[di].cbCodeInds
	mov	dx,HI_lpwCSeg
	mov	ds,dx
	mov	dx,LO_lpwCSeg
	int	21h
	pop	ds
	jc	wlds_AbCodeshort2
ELSE
	lea	ax,cb
	cCall	DosRead,<hFile,HI_lpwCSeg,LO_lpwCSeg,[di].cbCodeInds,ss,ax>
	or	ax,ax
	jnz	wlds_AbCodeshort2
	mov	ax,cb
ENDIF ;DOS5

	cmp	ax,[di].cbCodeInds	; check for read error
	jne	wlds_AbCodeshort2

	;*	if load type is non-standard, this service is completed

	test	[di].floadInds,floadStandard
	jnz	@F
	jmp	wlds_loadnext		; non-standard driver
@@:

	;*	allocate data area

	mov	bx,HI_lpwCSeg		; es:bx points to service header
	mov	es,bx
	mov	bx,LO_lpwCSeg

	mov	ax,es:[bx].cbDataInsh
	inc	ax
	shr	ax,1			; convert cb -> cw
	cmp	ax,0
	jne	@F
	xor	ax,ax			; no data to allocate
	mov	dx,ax
	jmp	short wlds_load11	; continue with link
@@:
	push	ax			; save word count for later
	mov	cx,fmemFixed
	test	es:[bx].fNearDataInsh,0ffffh
	jz	@F
	mov	cx,fmemNear
	cmp	ax,cbNearMemServiceMax / 2
	jbe	@F
	mov	ax,rerrBadMemReq	; asking for too much near mem!
	jmp	wlds_AbCode
@@:
	cCall	<LpwAllocDriverMem>,<ax,cx>
	;*	put word count in cx
	pop	cx
	or	ax,ax			; 0? failure
	jnz	@F
	or	dx,dx
	jnz	@F
	mov	ax,rerrNoMemory
wlds_AbCodeshort1:
	jmp	wlds_AbCode

wlds_AbCodeshort2:
	mov	ax,rerrBadRead
	jmp	wlds_AbCode
@@:
wlds_load11:
IFDEF DEBUG				; valid pointers are either ds:offset
					;  or other:0000
	mov	bx,ds
	cmp	bx,dx
	je	@F
	AssertEQ ax,0
@@:
ENDIF ;DEBUG

	;*	patch code segment with pointer to data segment and pinos

	mov	es,HI_lpwCSeg			; es => code segment
	xor	bx,bx
	mov	es:[bx].LO_lpwDataInsh,ax
	mov	es:[bx].HI_lpwDataInsh,dx

;*	* set "pinos"
IFNDEF DOS5
	mov	es:[bx].pinosInsh,0
ELSE
	mov	es:[bx].pinosInsh,dataOffset inosDrv
ENDIF

IFDEF DOS5
	;*	create CS alias

	lea	ax,HI_lpwCSeg
	mov	bx,HI_lpwCSeg
	cCall	DosCreateCSAlias,<bx,ss,ax>
	or	ax,ax
	jz	@F
	mov	HI_lpwCSeg,bx		; restore selector on failure
	jmp	wlds_AbCode
@@:
	;*	restore registers used (es,ax,bx,cx,dx are important)
	;*	cx,dx not changed

	mov	es,HI_lpwCSeg
	xor	bx,bx
	mov	ax,es:[bx].LO_lpwDataInsh
ENDIF ;DOS5

	;*	clear data segment to zeros (assume word count in cx)

	;*	es:0 => code segment INSH
	;*	dx:ax => data segment
	;*	cx	 data size (words)

	push	es
	push	di
	mov	di,ax
	mov	es,dx
	xor	ax,ax
	rep stosw
	pop	di
	pop	es

	;*	get function count and rgpfn

	mov	dx,es:[bx].cpfnInsh	; function count
	add	bx,cbInshMin		; rgpfn

	;*	At this point we have:
	;*		es:bx => HI_lpwCSeg:rgpfn
	;*		dx    == cpfn
	;*		ds:di => inds
	;*		pindv OR psld => link info
	
	;*	link service to app

	push	di
	push	ds

	;*	check version

;	check version
;	link
;	set return values of indv struct

	mov	di,pindv
	cmp	dx,ss:[di].cpfnNeedMinIndv
	jae	@F				;* we have at least enough
wlds_linkBadver:
	mov	ax,rerrBadVersion
	stc
	jmp	short wlds_linkdone
@@:
	mov	cx,ss:[di].cpfnNeedMacIndv	;* the max # we want
	cmp	dx,cx
	jae	@F				;* just copy the ones we want
	mov	cx,dx				;* copy what we have < NeedMac
@@:
	mov	di,ss:[di].rglpfnIndv

	;*	link to app

	mov	dx,ds			; segment switch for rep stosw
	mov	ax,es
	mov	ds,ax
	mov	es,dx
	;	ds => HI_lpwCSeg
	;	es => DGROUP

	push	cx			; save cfpn for later

	push	cx
	push	di
	shl	cx,1
	mov	ax,ds
	rep stosw			; fill app jump table with segment value
	pop	di
	pop	cx

@@:					; fill in offsets
	mov	ax,[bx]
	mov	es:[di],ax
	inc	bx
	inc	bx
	add	di,4
	loop	@B

	pop	cx			; restore cpfn

	;*	set return values in indv

	mov	bx,pindv
	mov	ss:[bx].cpfnLoadedIndv,cx
	mov	cx,HI_lpwCSeg
	mov	ss:[bx].psLoadedIndv,cx
	clc				; linkage completed

wlds_linkdone:
	pop	ds
	pop	di
	jc	wlds_AbData

wlds_loadnext:

	add	di,cbIndsMin
	jmp	wlds_Load

wlds_AbData:
	;*	Code and data segments allocated but couldn't link to app.
	;*	Free data then go on to free code and close hFile.

	push	ax			; return code in ax
	mov	ax,HI_lpwCSeg
	mov	es,ax
	xor	bx,bx
	mov	ax,es:[bx]
	mov	dx,es:[bx+2]
	cCall	<far ptr FreeDriverMem>,<ax,dx>
	pop	ax
	
wlds_AbCode:
	;*	Something went wrong before completing code segment that
	;*	was allocated - free it and close hFile.

	push	ax			; return code in ax
	mov	ax,LO_lpwCSeg
	mov	dx,HI_lpwCSeg
	cCall	<far ptr FreeDriverMem>,<ax,dx>
	pop	ax
	
wlds_done:
wlds_AbFile:

	push	ax			; return code in ax
IFNDEF DOS5
	mov	ah,3eh			; close file
	mov	bx,hFile
	int	21h
ELSE
	cCall	DosClose,<hFile>
ENDIF ;DOS5
	pop	ax			; ignore return code from close

wlds_Abort:

cEnd	RerrLoadDrv


;********** RerrLoadDrv **********
;*	entry:	szFile => full file name of driver
;*	* Loads kbd and csd drivers from given file
;*	exit:	same as RerrLoadDrv

cProc	RerrLoadCwDrv, <PUBLIC,FAR>
    parmW	szFile
cBegin	RerrLoadCwDrv

	mov	ax,dataOffset rgindvCw
	mov	cx,cindvCw
	cCall	RerrLoadDrv,<szFile, ax, cx>

cEnd	RerrLoadCwDrv


sEnd	KERNEL

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\lddebug.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	lddebug.asm : debugger support

	TITLE	LDDEBUG - Debugger interface procedures

	.xlist
	?LDDEBUG = 1
	include kernel.inc
	include handle.inc
	.list

	;*	 ENTIRE FILE IS DEBUG SUPPORT !
	;*
	;*	It comes in two parts --
	;*	the code to communicate with symdeb and the code
	;*	which is for doing debug assert checking.
	;*

IFDEF KEEP_SYMDEB_CODE

DEBUGOFFSET  EQU  000FBH
INTOFFSET    EQU  4*3+2				;* int 3 vector : segment

DEBUGCALL    MACRO
call lpfnDebug
ENDM

IFDEF	DEBUG
externFPublic <ExitKernel>			;* from kerninit.asm
ENDIF	; DEBUG

sBegin	DATA
    assumes CS,DATA

externW     <pGlobalHeap, psLom>

;*	* Far pointer to debugger special entry point
	PUBLIC	psDebug
lpfnDebug LABEL   DWORD
	DW	DEBUGOFFSET
psDebug	DW	0

;*	* Special name to test for
szDebug	    DB	'SEGDEBUG',0
cchDebug   =	$-szDebug

IFNDEF	DEBUG
;*	* Special value to test for
globalW	fgDoDebug, 0
ENDIF	; DEBUG

sEnd	DATA

;*****************************************************************************

sBegin	INIT
    assumes CS,INIT
    assumes DS,DATA


;
;   DEBUGINIT - Returns a non zero value in AX if debugger is resident.
;   Inputs: None.
;   Outputs:  AX non zero if debugger resident.
;
cProc	DebugInit,<NEAR,PUBLIC>,<es,si,di>
cBegin
IFNDEF	DEBUG
	cmp	fgDoDebug,0dbdbh	;* Allow debugging?
	jne	debugdone		;* No -- skip over rest of test
ENDIF	; DEBUG

	xor	ax,ax			;
	mov	es,ax			;
	    ;
	    ; If  the debugger	is  present,  a   distinquished  string of
	    ; "SEGDEBUG",0 will be found at 100H off of the interrupt vector
	    ; segment (use breakpoint interupt vector)
	    ;
	mov	bx,word ptr ES:INTOFFSET    ; Get interrupt vector segment.
	mov	es,bx
	mov	di,100H
	mov	si,dataOFFSET szDebug
	mov	cx,cchDebug
	CLD
	repz	cmpsb			;* special name ?
	jnz	debugdone
ok:
	mov	psDebug,bx		;* non-zero segment
;*	* Tell debugger about global heap
	mov	ax,pGlobalHeap
	push	ax
	mov	ax,3
	push	ax
	DEBUGCALL		    ; Tell debugger where the master object is
	add	sp,4
;*	* Tell debugger about thunk segment
	mov	ax,psLom
	push	ax
	mov	ax,10H
	push	ax
	DEBUGCALL		    ; Tell debugger where the master object is
	add	sp,4
;*	* Since the loader loaded in many segments, inform the debugger
;*	   after the fact
	mov	es,psLom
	mov	cx,es:[neLom.ne_cseg]	;* # of segments
	mov	si,es:[neLom.ne_segtab]
	xor	dx,dx			;* zero based segment #
debi_lp:
	mov	bx,es:[si].ns_handle	;* handle or ps
	mov	ax,es:[si].ns_flags
	test	ax,NSMOVE
	jz	debi_inform
	push	es
	mov	es,pGlobalHeap
	test	es:[bx].he_flags,HE_DISCARDED
	mov	bx,es:[bx].he_address	;* dereference
	pop	es
	jnz	debi_nxt
debi_inform:
	and	ax,NSDATA
	Save	<es,cx,dx>
	cCall	<far ptr DebugDefineSegment>,<dx,bx,ax>
debi_nxt:
	add	si,SIZE NEW_SEG1
	inc	dx
	loop	debi_lp
debugdone:
cEnd

sEnd	INIT


;*****************************************************************************

sBegin	KERNEL
    assumes CS,KERNEL
    assumes DS,NOTHING		;* can be called from anywhere
    assumes SS,DATA


; DEBUGDEFINESEGMENT - Inform debugger of physical address and type
;		       of a segment.
;
; Inputs:
;	  SegNumber   - zero based segment index
;	  LoadedSeg   - Physical segment address assigned by user to index.
;	  DataOrCodeFlag  - Whether segment is code or data.
;
; Outputs: None.
; SideEffects: Debugger informed of segment index and corresponding
;	       name and physical segment.
;
cProc  DebugDefineSegment,<FAR,PUBLIC>
	Parmw	SegNumber
	Parmw	LoadedSeg
	Parmw	DataOrCodeFlag
	LocalV	szBuff,10		;* buffer for module name
cBegin
	cmp	psDebug,0
	je	setdone
	push	DataOrCodeFlag	    ; Flag for code or data segment. 0 Code, 1 Data.
	xor	ax,ax
	push	ax		    ; Instance Number (0)
	push	LoadedSeg	    ; Segment value in loader.
	push	SegNumber	    ; Segment number

	lea	bx,szBuff
	cCall	GetModuleName		;* returns in ss:bx
	push	ss		    ;
	push	bx		    ;
	xor	ax,ax		    ;
	push	ax		    ;* call 0
	DEBUGCALL		    ;
	add	sp,14
setdone:
cEnd


;********** GetModuleName **********
;*	entry : SS:BX = buffer
;*	* get module name in buffer
;*	exit : SS:BX = buffer
cProc	GetModuleName,<NEAR, ATOMIC>,<BX,ES,SI>
cBegin

	mov	si,bx
	mov	es,psLom	    ;* segment of module name
	mov	bx,es:[neLom.ne_restab]	;* start of table
	add	bx,es:[bx]		;* point to "sz" string
name_lp:
	mov	al,es:[bx]
	inc	bx
	mov	ss:[si],al
	inc	si
	cmp	al,'.'
	jnz	name_lp
	mov	byte ptr ss:[si-1],0	;* zero term
cEnd

; DEBUGMOVEDSEGMENT - Inform debugger that a segment has moved.
;
; Inputs: SourceSeg   - Original segment value.
;	  DestSeg     - New segment value.
;
; Outputs: None.
; SideEffects: Debugger informed of the old and new values for
;	       a physical segment.
;
cProc	DebugMovedSegment,<NEAR,PUBLIC>
	ParmW	SourceSeg
	ParmW	DestSeg
cBegin
	cmp	psDebug,0
	je	movdone
	push	DestSeg 	    ; Push destination segment of move.
	push	SourceSeg	    ; Push moved source segment.
	mov	ax,1		    ; Function 1.
	push	ax		    ;
	DEBUGCALL
	add	sp,6
movdone:
cEnd


; DEBUGFREESEGMENT - Inform debugger that a segment is being returned
;		     to the global memory pool and is no longer code or
;		     data.
;
; Inputs: SegAddr - segment being freed
;
; Outputs: None.
; SideEffects: Debugger informed that it must remove references
;	       to a physical segment.
;
cProc	DebugFreeSegment,<NEAR,PUBLIC>,<es>
	Parmw	SegAddr
cBegin
	cmp	psDebug,0
	je	killdone
	push	SegAddr 	    ; Push segment address
	mov	ax,2		    ; Function 2
	push	ax		    ;
	DEBUGCALL		    ;
	add	sp,4
killdone:
cEnd

sEnd	KERNEL
ENDIF	; KEEP_SYMDEB_CODE	-- Above code is for dealing with symdeb

IFDEF	DEBUG	;* REST OF FILE IS ONLY DEBUGGING ROUTINES
sBegin	KERNEL

;*	* print debug string to debugging console *

cProc	PrDebugRgch,<FAR,PUBLIC,ATOMIC>
   parmD lpch		;* far pointer to string
   parmW cch		;* character count
cBegin	PrDebugRgch

	cmp	psDebug,0
	je	prdeb_end
	push	cch
	push	SEG_lpch
	push	OFF_lpch
	mov	ax,4
	push	ax
	DEBUGCALL
	add	sp,8
prdeb_end:

cEnd	PrDebugRgch


;********** AssertBreak *********
;*	entry : n/a
;*	* if debugger present BREAK
;*	* if not EXIT

cProc	AssertBreak,<FAR,PUBLIC>
cBegin	AssertBreak

	cmp	psDebug,0
	jne	assert_break
	mov	ax,exAssertFailed
	cCall	ExitKernel,<ax>		;* never return
;*	*NOTREACHED*
assert_break:
	int	3			;* HARD CODED BREAKPOINT !!
					;* type G=ip+1 to resume in SYMDEB
cEnd	AssertBreak


;********** CowAssertFailed **********
;*	entry : after return address = optional sd string that describes error
;*	* print assert failed, followed by message
;*	* Then exit
;*	exit : never return to caller
;*	* NOTE : message must be <31 bytes long

cProc	CowAssertFailed,<FAR,PUBLIC,ATOMIC>
cBegin	nogen ;CowAssertFailed

	mov	dx,kernelOffset sdCowAssertFailed
	push	cs
	pop	ds
	cCall	PrDebugSd
	pop	dx
	mov	di,dx
	pop	ax				;* return address => string
	mov	es,ax
	mov	ds,ax
	mov	al,'$'
	mov	cx,50				;* must be a "$" within 50 bytes
	repne	scasb
	jne	assert_skip
	cCall	PrDebugSd
	mov	dx,kernelOffset sdCrLf
	push	cs
	pop	ds
assert_skip:
	cCall	AssertBreak
cEnd	nogen ;CowAssertFailed

sdCowAssertFailed	DB	"Kernel Assert Failed!"
sdCrLf		DB	13,10,"$"


;********** PrDebugSd **********
;*	entry : DS:DX => sd string to print
;*	* Print string to debugging console
;*	exit : n/a

cProc	PrDebugSd,<NEAR,ATOMIC>
cBegin	PrDebugSd

;*	* Find string length
	mov	di,dx
	push	ds
	pop	es
	mov	cx,-1
	mov	al,'$'				;* sd string
	cld
	repne	scasb
	dec	cx
	not	cx				;* cx = length
	cCall	PrDebugRgch,<es,dx,cx>

cEnd	PrDebugSd



;********** Abort **********
;*	entry : call from debugger ! !
;*	* resident label for exit/ExitKernel
;*	exit : never

cProc	Abort,<FAR, PUBLIC, ATOMIC>
cBegin	nogen ;Abort

	push	ss
	pop	ds				;* restore DS

	mov	al,255				;* exit(255);
	cCall	ExitKernel,<ax>

cEnd	nogen; Abort


;********** LpGlobalHeap **********
;*	entry : n/a
;*	exit : DX:AX = far pointer to global heap
;*	* NOTE : may be called regardless of what DS is

cProc	LpGlobalHeap,<FAR,PUBLIC,ATOMIC>
cBegin	LpGlobalHeap

    assumes DS,NOTHING		;* just to be sure !!!
	MOV	DX,pGlobalHeap
	XOR	AX,AX

cEnd	LpGlobalHeap



cProc	CwOutSz,<FAR,PUBLIC>,<DI,DS>
    parmW	sz
cBegin	CwOutSz

    assumes DS,nothing

	PUBLIC	_cwoutsz
_cwoutsz:
	cld
	push	ss
	pop	es
	mov	di,sz
	xor	ax,ax
	mov	cx,0ffffh
	repne	scasb
	dec	di
	mov	by es:[di],'$'
	mov	ax,9
	push	es
	pop	ds
	mov	dx,sz
	int	21h
	mov	by es:[di],0

cEnd	CwOutSz


sEnd	KERNEL

ENDIF ;DEBUG

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\mouse5.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	mouse5.asm : mouse input control (DOS 5)

	title	mouse - Mouse control code for COW KERNEL (DOS 5)

	include kernel.inc
	include uevent.inc			;* MK_ values & mouse messages
	include inscr.inc
	include inmou.inc			;* MK_ values & mouse messages

	include	mouse5.inc			;* DOS 5 specific info

;*****************************************************************************

IFDEF DEBPUB
	PUBLIC	MouseThread, ProcessRecord
ENDIF ;DEBPUB

;*****************************************************************************

cbBuffer	EQU	128

;----------------------------------------------------------------------------

sBegin	DATA
    assumes DS,DGROUP

externB <axMac, ayMac>				;* screen size
externB	<ayMouse>
externB <instCur>
externB	<ayDrawing, fMouseLockedOut>		; for drawing lockout

staticB fEnableMonitor,0			;* TRUE => monitor is on

	EVEN
areamouOff	AreaMou	<0, 0, 0, 0>


;*	* Info for Mouse monitor thread *
staticW idThread,?				;* Thread ID
	dw	64 dup (?)
labelW	ThreadStack				;* Thread stack


DataBuffer MouseRcd <>				;* DataBuffer for mouse records
	EVEN

staticW Bytecnt,?	  			;* mouse monitor record length

staticW	hDevice,?				;* mouse device handle
staticW hMonitor,?				;* mouse monitor handle
staticW hPointer,?				;* mouse pointer handle
staticB BufferI, ,cbBuffer			;* Monitor buffer In
staticB BufferO, ,cbBuffer			;* Monitor buffer Out

staticB mstateOld, 0				;* old mouse state

sEnd	DATA

;----------------------------------------------------------------------------

sBegin	BSS
    assumes DS,DGROUP

;* PUBLIC
externB	<fMousePresent>				;* TRUE => mouse present

;* PRIVATE
externB	<axMouse>
externW	<sstMouse>

externB	<fMouseOn>				;* TRUE => mouse on

IFDEF MOUSE_SWAP
externB <fSwapButton>				;* TRUE => reverse buttons
ENDIF ;MOUSE_SWAP

externB	<instCur>

sEnd	BSS

;----------------------------------------------------------------------------

;*****************************************************************************

sBegin	INIT
    assumes CS,INIT
    assumes DS,DGROUP

szMouse		db     'MOUSE$',0			;* device string name
szPointer	db     'POINTER$',0			;* pointer string name

;********** FInitMouse **********
;*	entry : n/a
;*	* Initialize mouse if present
;*	exit : TRUE (1) => ok (even if mouse not present), FALSE (0) => error

init_noMouse:
	xor	ax,ax
	jmp	init_ok

cProc	FInitMouse,<FAR,PUBLIC>
    localW  wAction		;* ignored
    localV  rgwPtrPos,4		;* row, col
cBegin	FInitMouse

;*	* if second time initialize, just enable mouse -- the monitor
;*	*   and monitor thread should be still running
	cmp	fMousePresent,0
	je	@F			;* try init
	jmp	done_thread_start	;* thread already started
@@:

;*	* OPEN Mouse device
	PushArg	<cs, initOffset(szMouse)>
	PushArg	<ds, dataOffset(hDevice)>
	lea	ax,wAction
	PushArg <ss, ax>
	xor	ax,ax
	PushArg	<ax, ax>		; filesize (zero)
	PushArg	<ax>			; file attribute (zero)
	push	1			; open flag (open existing file)
	push	0000000011000000b	; open mode
;		DWFRRRRRISSSRAAA	  (private, deny none, read only)
	PushArg	<ax, ax>		; reserved
	call	DosOpen
        or      ax,ax
	jnz	init_noMouse

;*	* Open monitor
	PushArg	<cs, initOffset(szMouse)>
	PushArg	<ds, dataOffset(hMonitor)>
	cCall	DosMonOpen
	or	ax,ax
	jnz	init_error2

;*	* Register monitor
	mov	WORD PTR BufferI,cbBuffer
	mov	WORD PTR BufferO,cbBuffer
	PushArg	<hMonitor>
	PushArg	<ds, dataOffset(BufferI)>
	PushArg	<ds, dataOffset(BufferO)>
	PushArg	<2>			; Posflag = 2 (back)
	PushArg	<-1>			; index = -1 (current group)
	cCall	DosMonReg
	or	ax,ax
init_error2:
	jnz	init_error

;*	* create mouse thread
	PushArg	<SEG kernelBase, kernelOffset(MouseThread)>
	PushArg	<ds, dataOffset(idThread)>
	PushArg	<ds, dataOffset(ThreadStack)>
	cCall	DosCreateThread
	or	ax,ax
	jnz	init_error

;*	* bump priority of mouse thread
	PushArg	<2>		       ; scope = 2 (thread)
	PushArg	<3>		       ; class = 3 (time-critical)
	PushArg	<15>		       ; delta = 15(???)
	PushArg	<idThread>
	cCall	DosSetPrty
	or	ax,ax
	jnz	init_error

done_thread_start:
;*	* open pointer
	PushArg	<cs, initOffset(szPointer)>
	PushArg	<ds, dataOffset(hPointer)>
	cCall	MouOpen
	or	ax,ax
	jnz	init_error

;*	* get current mouse position
	lea	bx,rgwPtrPos
	cCall	MouGetPtrPos,<ds, bx, hPointer>	;* (ds == ss)
	or	ax,ax
	jnz	init_error
	mov	al,byte ptr [bx]
	mov	ayMouse,al
	mov	al,byte ptr [bx]+3
	mov	axMouse,al

;*	* everything enabled
	mov	al,1
init_ok:
	mov	fEnableMonitor,al
	mov	fMousePresent,al
	mov	ax,sp			;* success
init_end:
	mov	fMouseOn,0

cEnd	FInitMouse

init_error:
	xor	ax,ax			;* return error
;--	mov	fMousePresent,0		;* already off
	jmp	init_end


sEnd	INIT

;*****************************************************************************

sBegin	EXIT
    assumes CS,EXIT
    assumes DS,DATA


;********** EndMouse **********
;*	entry : n/a
;*	* Reset mouse if present
;*	* change thread into a literal copy monitor
;*	*  we can't kill the mouse monitor thread at this time so we
;*	*  just nullify the effect of the monitor -- the monitor stays
;*	*  hooked and will remain in literal copy mode until we re-init
;*	*  the mouse or the main process terminates.
;*	exit : n/a

cProc	EndMouse,<PUBLIC, FAR>
    localV   mrcdT,<SIZE MouseRcd>		;* mouse record
cBegin	EndMouse

	cmp	fMousePresent,0
	je	mouse_already_off

	cCall	DisableMouse
	mov	fEnableMonitor,0

;*	* end use of pointer
	cCall	MouClose,<hPointer>

;*	* NOTE: Keep fMousePresent flag set
	mov	fMouseOn,0
mouse_already_off:

cEnd	EndMouse

sEnd	EXIT

;*****************************************************************************

;*	* Discardable Mouse Functions *

sBegin	MOUSE
    assumes CS,MOUSE
    assumes DS,DATA

;********** FEnableMouse **********
;*	entry : fOn => whether mouse should be on or off
;*	* Change state of mouse according to fOn
;*	exit : AX = previous mouse state, always FALSE if no mouse

cPublic	FEnableMouse,<>
    parmW fOn

cBegin	FEnableMouse

	mov	al,fMousePresent
	or	al,al
	jz	already_ok			; no driver => ret FALSE

	mov	al,fMouseOn			; old state
	or	al,al				; ZR/NZ -> now off/on.

	mov	cx,fOn				; cx == 0 => turn off
	jcxz	mouse_off

	jnz	already_ok			; Bail if it's already on.

	test	instCur.finstInst,finstDisableMouse
	jnz	already_ok			; on not allowed now.

	cCall	MouDrawPtr,<hPointer>		; Actually turn mouse on.

	mov	al,0ffh				; New state.
	jmp	short mouse_new_state

mouse_off:
	jz	already_ok			; Bail if it's already off.

	cCall	DisableMouse
	xor	al,al

mouse_new_state:
	mov	fMouseOn,al
	not	al				;* old state

already_ok:
	xor	ah,ah			; clear high order portion

cEnd	FEnableMouse



;********** DisableMouse **********
;*	entry/exit: n/a
;*	* Disable the mouse

cProc	DisableMouse, <NEAR>
cBegin	DisableMouse

;*	* fill in record for turning mouse off (invalidate entire region)
	xor	ah,ah
	mov	al,ayMac
	dec	al
	mov	areamouOff.dayArea,ax		;* not real height
						;* documentation wrong
	mov	al,axMac
	dec	al
	mov	areamouOff.daxArea,ax		;* not real width
						;* documentation wrong
	PushArg	<ds, dataOffset(areamouOff)>
	PushArg	<hPointer>
	cCall	MouRemovePtr			; Actually turn mouse off.

cEnd	DisableMouse


;********** SetMousePos **********
;*	entry : axNewPos
;*		ayNewPos
;*	* Place the mouse cursor somewhere on the screen.
;*	exit : n/a

cPublic	SetMousePos,<>
    parmW axNewPos
    parmW ayNewPos
cBegin	SetMousePos

	mov	ax,ayNewPos
	AssertEq	ah,0

	cmp	fMousePresent,ah
	jz	PM99

	mov	ayMouse,al

	mov	ax,axNewPos
	AssertEq	ah,0
	mov	axMouse,al

	lea	ax,ayNewPos
	cCall	MouSetPtrPos,<ss,ax,hPointer>
	AssertEq	ax,0
PM99:

cEnd	SetMousePos

;********** SetMouseCursor **********
;
;	entry : pmcb = far pointer to a Mouse Cursor Block
;
;	Set the mouse cursor
;
; Amazingly, there is no OS/2 support for the Graphics Mouse Cursor in
; protect mode.

cPublic	SetMouseCursor,<>,<DS>
parmD	pmcb
localV	moupsInfo,<size PtrShapeMou>

;---------------
;localV	pbGetBuffer,100
;localV	moupsGetInfo,<size PtrShapeMou>
;---------------

cBegin	SetMouseCursor

;---------------
;
; These two calls are intended to Get the current mouse shape.  I was hoping
; to what the proper structure is for protect mode, but hey - no such luck.
;
;	mov	cx,hPointer
;	mov	ax,0FFFFh			; cb is bogus - it'll give 
;	mov	moupsGetInfo.cbPtrShapeMou,ax	;   us the size.
;	lea	ax,pbGetBuffer
;	lea	bx,moupsGetInfo
;	cCall	MouGetPtrShape,<ss,ax,ss,bx,cx>
;
;	mov	cx,hPointer
;	lea	ax,pbGetBuffer
;	lea	bx,moupsGetInfo
;	cCall	MouGetPtrShape,<ss,ax,ss,bx,cx>
;
;---------------

	xor	ax,ax				; Set up for text mode.

	cmp	fMousePresent,al
	jz	Nix

	test	instCur.finstInst,finstGraphics
	jnz	Nix

	mov	cx,hPointer		; Get this before we lose ds.

	lds	bx,pmcb			; ds:bx -> Mouse Cursor Block.
	assumes	ds,nothing

	mov	moupsInfo.colHotPtrShapeMou,ax
	mov	moupsInfo.rowHotPtrShapeMou,ax
	inc	ax
	mov	moupsInfo.colPtrShapeMou,ax
	mov	moupsInfo.rowPtrShapeMou,ax
	shl	ax,1
	shl	ax,1
	mov	moupsInfo.cbPtrShapeMou,ax

	lea	ax,[bx].wAndMaskTextMcb
;	jmp	short DoIt
;
;ItsGfx:
;	mov	ax,16				; Set up for graphics mode.
;	mov	moupsInfo.colPtrShapeMou,ax
;	mov	moupsInfo.rowPtrShapeMou,ax
;	shl	ax,1
;	shl	ax,1
;	mov	moupsInfo.cbPtrShapeMou,ax
;	mov	ax,[bx].colHot
;	mov	moupsInfo.colHotPtrShapeMou,ax
;	mov	ax,[bx].rowHot
;	mov	moupsInfo.rowHotPtrShapeMou,ax
;
;	lea	ax,[bx].rgwAndMaskGfxMcb
;
;DoIt:
	lea	dx,moupsInfo

	cCall	MouSetPtrShape,<ds,ax,ss,dx,cx>
	AssertEq	ax,0

Nix:

cEnd	SetMouseCursor


;********** MouseConditionalOff **********
;
;	entry : pmcob = near pointer to a Mouse Conditional Off Block
;
;	Defines a region on the screen for mouse updating
;
; Here's a great catch-22.  This call is only needed in graphics mode, but
; OS/2 doesn't support a graphics mouse cursor.  So it's a big NilFactor.

    assumes CS,KERNEL
    assumes SS,DATA
    assumes DS,DATA
    assumes ES,nothing

cPublic	MouseConditionalOff,<ATOMIC>
;parmW	pmcob
cBegin	nogen	; MouseConditionalOff
	retf	2				; Clean up stack of parm.
cEnd	nogen	; MouseConditionalOff


;********** MouseOn **********
;
;	Un-does the MouseConditionalOff, which means also a big NilFactor.
;
    assumes CS,KERNEL
    assumes SS,DATA
    assumes DS,DATA
    assumes ES,nothing

cPublic	MouseShowCursor,<ATOMIC>
cBegin	MouseShowCursor
cEnd	MouseShowCursor

;********** SetMouseDoubleSpeed **********
;*	entry : mps = mickey / second speed
;*	* Set mouse double speed threshold
;*	exit : n/a

cPublic	SetMouseDoubleSpeed,<>
    parmW mps
cBegin	SetMouseDoubleSpeed

IFDEF LATER
	test	fMousePresent,0ffH
	jz	set_speed_end

	mov	dx,mps
	mov	ax,19
	int	33H			;* Set double speed
set_speed_end:
ENDIF ;LATER

cEnd	SetMouseDoubleSpeed


sEnd	MOUSE

;*****************************************************************************

externFP MouseMessage			;* from event.c

sBegin	KERNEL
    assumes CS,KERNEL
    assumes DS,DATA


; MouseThread - Mouse monitor thread
;
; IMPLEMENTATION:
;	Start
;	    Read Input from Monitor
;	    switch (FLAGS record)
;		case OPEN
;		    break;
;		case FLUSH
;		    Write output to monitor structure
;		    break;
;		case CLOSE
;		    Exit to Dos
;		default
;		    Analyse record and Call Windows Event procedure
;		    break;
;	    goto Start

cProc	MouseThread,<FAR, ATOMIC>
cBegin	nogen ;MouseThread

ThreadStart:
	mov	[Bytecnt],SIZE DataBuffer

	PushArg	<ds, dataOffset(BufferI)>
	PushArg	<0>			; WaitFlag=0 (wait)
	PushArg	<ds, dataOffset(DataBuffer)>
	PushArg	<ds, dataOffset(Bytecnt)>
	cCall	DosMonRead		;* read (do not propagate)
	or	ax,ax
	jnz	Close

	mov	si,dataOffset DataBuffer
	mov	ax,[si].flags
	test	ax,fClose
	jnz	Close			;* close it down

	cmp	fEnableMonitor,0
	jne	not_literal_monitor

;*	* in literal monitor mode
	PushArg	<ds, dataOffset(BufferO)>
	PushArg	<ds, dataOffset(DataBuffer)>
	PushArg	Bytecnt
	cCall	DosMonWrite
	jmp	short ThreadStart

not_literal_monitor:
	test	ax,fOpen OR fFlush OR fClose
	jnz	no_default

	cCall	ProcessRecord  ; default 
	jmp	short ThreadStart
no_default:
	test	ax,fClose
	jz	ThreadStart		;* keep going

Close:				; return will end this thread
	ret

cEnd	nogen ;MouseThread


;  ProcessRecord - Analyze records contents and send event to Windows
;
;  Note: Replace what used to be the hardware mouse service
;
;  IMPLEMENTATION:
;	Set motion mask bit
;	Set buttons mask bits
;	Set Time stamps
;	Call Windows event proc
;

cProc	ProcessRecord, <NEAR, ATOMIC>
cBegin	nogen ;ProcessRecord

	mov	ax,[si].Eventmsk      ; get events mask

	mov	bx,[si].axMouCur
	mov	axMouse,bl
	mov	bx,[si].ayMouCur
	mov	ayMouse,bl

;*	* convert move-with-button-down to button-down
	mov	ah,al
	and	ah,mouButMotion		;* move-with-button-down
	shl	ah,1			;* convert to button-down (only)
	or	al,ah
;*	* figure out the sstMouse states
	xor	dx,dx
	test	al,mouBut1Only
	jz	left_not_down
	or	dl,MK_LBUTTON
left_not_down:
	test	al,mouBut2Only
	jz	right_not_down
	or	dl,MK_RBUTTON
right_not_down:
	mov	sstMouse,dx
	mov	dx,ax			;* save value in dx

not_mouse_move:
;*	* convert state into transitions
	mov	ah,al
	not	ah			;* ah = !new, al = new
	mov	bh,al
	xchg	bh,mstateOld		;* update state, get old (bh = old)
	mov	bl,bh
	not	bl			;* bh = old, bl = !old
	and	ax,bx			;* ah = !new & old = key up
					;* al = new & !old = key down
	mov	dx,ax

;*	* al = dl = key down transitions
;*	* ah = dh = key up transitions
MouseMove?:
	test	ax,(mouBut1Only OR mouBut2Only) * 101H
	jnz	LeftButtonDown?
;*	* no buttons set (just move)

	mov	ax,WM_MOUSEMOVE
	cCall	DoMouseMessage

LeftButtonDown?:
	test	al,mouBut1Only
	jz	LeftButtonUp?

	mov	ax,WM_LBUTTONDOWN
	cCall	DoMouseMessage

LeftButtonUp?:
	test	ah,mouBut1Only
	jz	RightButtonDown?

	mov	ax,WM_LBUTTONUP
	cCall	DoMouseMessage

RightButtonDown?:
	test	al,mouBut2Only
	jz	RightButtonUp?

	mov	ax,WM_RBUTTONDOWN
	cCall	DoMouseMessage

RightButtonUp?:
	test	ah,mouBut2Only
	jz	test_for_mouse_lock

	mov	ax,WM_RBUTTONUP
	cCall	DoMouseMessage

test_for_mouse_lock:
;*	* Check for mouse lockout
;*	* If ABS(ayDrawing - ayMouse{new}) = FE,FF,0,1,2 then kill mouse
	mov	al,ayMouse
	sub	al,ayDrawing
	add	al,2				;* 0, 1, 2, 3, 4 => kill it
	cmp	al,5
	jae	lockout_done			;* no conflict
;*	* drawing conflict, turn mouse of if not already turned off
	test	fMouseOn,0ffh
	jz	lockout_done			;* already off
	test	fMouseLockedOut,0ffh
	jnz	lockout_done			;* already locked out

;*	* turn off mouse
	PushArg	<ds, dataOffset(areamouOff)>
	PushArg	<hPointer>
	cCall	MouRemovePtr			;* turn off
	mov	fMouseOn,0			;* mouse is off
	mov	fMouseLockedOut,0ffh		;* set locked out flag

lockout_done:
	ret

cEnd	nogen ;ProcessRecord




;********** DoMouseMessage **********
;*	entry : ax = Message type
;*		dx = mouse info
;*	* Call MouseMessage with parameter
;*	exit : dx retained
;*		ax restored with dx

cProc	DoMouseMessage,<NEAR,ATOMIC>	;* all code FIXED !
cBegin	DoMouseMessage
	push	dx
	cCall	MouseMessage,<ax>
	pop	dx
	mov	ax,dx
cEnd	DoMouseMessage


sEnd	KERNEL

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\mouse.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	mouse.asm : mouse input control

	title	mouse - Mouse control code for COW KERNEL INPUT

	include kernel.inc
	include	uevent.inc			;* for mouse messages
	include	inscr.inc			;* INST info
	include	inmou.inc

PROJECT_QB_QC = 0
ifdef PROJECT_QB
PROJECT_QB_QC = -1
endif
ifdef PROJECT_QC
PROJECT_QB_QC = -1
endif

PROJECT_QB_QC = -1			;UNDONE - Remove this

if PROJECT_QB_QC
    %out Mouse driver for QuickBASIC or QuickC
endif


;----------------------------------------------------------------------------
;*	* Mouse Status

MOUSE_MOVE		equ	01H
LEFT_BUTTON_DOWN	equ	02H
LEFT_BUTTON_UP		equ	04H
RIGHT_BUTTON_DOWN	equ	08H
RIGHT_BUTTON_UP		equ	10H
MOUSE_MASK		equ	1FH

;----------------------------------------------------------------------------

sBegin	DATA
    assumes DS,DGROUP

externB <axMac, ayMac>
externB <instCur>

;*	* For drawing lockout
externB	<ayDrawing, fMouseLockedOut>

externB	<ayMouse>

sEnd	DATA

;----------------------------------------------------------------------------

sBegin	BSS
    assumes DS,DGROUP

;* PUBLIC
externB	<fMousePresent>				;* TRUE => mouse present

;* PRIVATE
externB	<axMouse>
externW	<sstMouse>

externB	<fMouseOn>				;* TRUE => mouse on

IFDEF MOUSE_SWAP
externB <fSwapButton>				;* TRUE => reverse buttons
ENDIF ;MOUSE_SWAP

externB	<instCur>

if PROJECT_QB_QC
staticW cmdInitMouse,0
endif

sEnd	BSS

;----------------------------------------------------------------------------

sBegin	INIT
    assumes CS,INIT
    assumes DS,DGROUP
    assumes SS,DGROUP


;********** FInitMouse **********
;*	entry : n/a
;*	* Initialize mouse if present
;*	exit : TRUE => ok (even if not present), FALSE => initialize error

cProc	FInitMouse,<FAR,PUBLIC,ATOMIC>,<SI>
cBegin	FInitMouse

;*	* Test for mouse vector present
	mov	ax,3533H
	int	21H		; Get interrupt vector for int 33H
	mov	ax,es
	or	ax,bx
	jnz	@F
J_noMouse:
	jmp	noMouse
@@:
ifdef KANJI
	; this is not for KANJI, but some dos makes int33 going to halt
	; it is not enough to check verctor is zero or not.
	; we have to find out mouse driver be or not.
	push	di		; save DI
	push	ds		; save DS
	push	cs
	pop	ds
	mov	si, initOffset MouseID  ; points to mouse secret message
	mov	cx, offset MouseIDend - offset MouseID ; strlen of message
	mov	di, bx			; before entry point
	sub	di, cx			; back to the message
	cld
	rep	cmpsb
	pop	ds		; restore DS
	pop	di		; restore DI
	jz	MouseIDend
J_noMouse_0:
	mov	al, 0		; make sure NOMOUSE
	jmp	short J_noMouse
MouseID		DB	"*** This is Copyright 1983 Microsoft ***"
MouseIDend:
	xor	di, di
	mov	es, di		; clear es and di
	mov	ax, 'm'
	int	33h
	mov	ax, es
	or	ax, di
	jz	J_noMouse_0	; too old version
	cmp	byte ptr es:[di], 6	; check version number
	jb	J_noMouse_0	; ver6 or later?
endif ; KANJI

;*	* Test for mouse driver present
if PROJECT_QB_QC
	mov	ax, [cmdInitMouse]
else
	xor	ax,ax
endif
	int	33H
	or	ax,ax
	jz	J_noMouse

if PROJECT_QB_QC
	mov	ax,33			; try software reset
	cmp	[cmdInitMouse],ax	; already initialized to software?
	je	@F			; brif so -- got one

;
; 33 is an undocumented mouse call, if the mouse driver is not our's,
; then it may ignore `software reset (33)' so do a full hardware reset
; if we fail the software reset.
;
	int	33h			;
	inc	ax			; -1 means Microsoft mouse
	jnz	@F			; brif not Microsoft mouse

	mov	[cmdInitMouse],33	; From now on a software reset is
					;    sufficient.
@@:
endif

;*	* Set initial mouse mapping type
	xor	bx,bx
	mov	cx,077FFH
	mov	dx,07700H
	mov	ax,10
	int	33H

;*	* Set mouse event handler
	mov	ax,SEG kernelBase
	mov	es,ax
	mov	dx,offset MouseInterrupt
	mov	cx,MOUSE_MASK
	mov	ax,12			;* set mouse extension
	int	33H

	mov	si,8			; 8 is used a lot
	mov	ax,si
	mul	axMac
	sub	ax,si
	mov	dx,ax			; max = 8 pixels from the right.
	mov	cx,3			; min = 3 pixels from the left.
	mov	ax,7
	int	33h			; Set horizontal range.

	xor	cx,cx
	mov	cl,instCur.inftInst.dyCharInft
	or	cl,cl
	jnz	@F
	mov	cx,si			; assume 8 char high (text mode)
@@:					; cx = dyChar
	mov	al,ayMac
	mul	cl
	shr	cx,1
	sub	ax,cx			; max = (dyChar / 2)
	mov	dx,ax			;          pixels from the bottom.
	mov	cx,4			; min = 4 pixels from the top.
	mov	ax,si
	int	33h			; Set vertical range.
	AssertNE	al,0

if PROJECT_QB_QC
	mov	cl, 3
	xor	dx,dx
	mov	dl, [ayMouse]
	shl	dx, cl
	xor	ax,ax
	mov	al, [axMouse]
	shl	ax, cl
	mov	cx, ax
	mov	ax, 4
	int	33H
endif

noMouse:
	mov	fMousePresent,al
	mov	ax,0001			;* always return ok
	mov	fMouseOn,ah		;* mouse is off

cEnd	FInitMouse

sEnd	INIT

;----------------------------------------------------------------------------

sBegin	EXIT
    assumes CS,EXIT
    assumes SS,DATA
    assumes DS,DATA


;********** EndMouse **********
;*	entry : n/a
;*	* Reset mouse if present
;*	exit : n/a

cProc	EndMouse,<PUBLIC, FAR, ATOMIC>
cBegin	EndMouse

	xor	ax,ax
	cmp	fMousePresent,al
	jz	EndMouseExit
	mov	fMouseOn,al

if NOT PROJECT_QB_QC
	mov	fMousePresent,al
	mov	ax,33
	int	33H			; turn off mouse by resetting it.
else
	mov	ax, 33			;Try Software reset first
	int	33H
	inc	ax
	jz	@F
	xor	ax,ax			;If that fails do a hardware reset
	int	33H
@@:
endif

EndMouseExit:
cEnd	EndMouse

sEnd	EXIT

;----------------------------------------------------------------------------

;*	* Fixed : Mouse enable called by MessageBox etc.

sBegin	KERNEL
    assumes CS,KERNEL
    assumes SS,DATA
    assumes DS,DATA

;********** FEnableMouse **********
;*	entry : fOn => whether mouse should be on or off
;*	* Change state of mouse according to fOn
;*	exit : AX = previous mouse state, always FALSE if no mouse

cPublic	FEnableMouse,<ATOMIC>
    parmW fOn
cBegin	FEnableMouse

	StartPublic
	mov	al,fMousePresent
	or	al,al
	jz	already_ok			; no driver => ret FALSE

	mov	al,fMouseOn			; old state
	or	al,al				; ZR/NZ -> now off/on.

	mov	cx,fOn				; cx == 0 => turn off
	jcxz	mouse_off

	jnz	already_ok			; Bail if it's already on.

	test	instCur.finstInst,finstDisableMouse
	jnz	already_ok			; on not allowed now.

	mov	ax,1				; Actually turn mouse on.
	int	33H
;*	* find current mouse position to set axMouse & ayMouse
	mov	ax,3
	int	33H			;* CX = horiz, DX = vertical position
	cCall	SetMousePixelPos

	mov	al,0ffh				;* new state
	jmp	short mouse_new_state

mouse_off:
	jz	already_ok			; Bail if it's already off.

	mov	ax,2				; Actually turn mouse off.
	int	33H
	xor	al,al

mouse_new_state:
	mov	fMouseOn,al
	not	al				;* old state

already_ok:
	xor	ah,ah			; clear high order portion
	StopPublic

cEnd	FEnableMouse


;********** SetMousePos **********
;*	entry : axNewPos
;*		ayNewPos
;*	* Place the mouse cursor somewhere on the screen.  Text only so far.
;*	exit : n/a

cPublic	SetMousePos,<ATOMIC>
    parmW axNewPos
    parmW ayNewPos
cBegin	SetMousePos

	StartPublic
	mov	ax,ayNewPos
	AssertEq	ah,0

	cmp	fMousePresent,ah
	jz	PM99

	mov	ayMouse,al
	mov	cl,instCur.inftInst.dyCharInft
	or	cl,cl
	jnz	@F
	mov	cl,8				;* default 8 pixels high
@@:
	mul	cl
	mov	dx,ax

IFDEF LATER
	-- characters other than 8 pixels wide (graphics modes)
ENDIF
	mov	cx,axNewPos
	AssertEq	ch,0
	mov	axMouse,cl
	shl	cx,1
	shl	cx,1
	shl	cx,1

	mov	ax,4
	int	33H			;* Set Mouse Cursor Position.
PM99:
	StopPublic

cEnd	SetMousePos

;********** SetMouseCursor **********
;
;	entry : pmcb = far pointer to a Mouse Cursor Block
;
;	Set the mouse cursor shape, both text and graphics.
;
; Hercules 48K RAMFont mode means that the 16 bits of the current character 
; are interpreted as the top 4 bits being attribute, and the lower 12 bits 
; being character.  And, those high 4 bits aren't color attributes, they're 
; character attributes: boldface, reverse, overstrike, underline.  So, for 
; 48K RAMFont, we want the mouse cursor to be able to set the character (low
; word) but not screw up the attribute.  Thus we make the mouse cursor toggle
; bit 6 of the high word.

    assumes CS,KERNEL
    assumes SS,DATA
    assumes DS,DATA
    assumes ES,nothing

cPublic	SetMouseCursor,<ATOMIC>,<DS>
parmD	pmcb

cBegin	SetMouseCursor

	StartPublic

	mov	ax,10			; ah = 0
	cmp	fMousePresent,ah
	jz	@F

	mov	dx,instCur.finstInst

	lds	bx,pmcb			; ds:bx -> Mouse Cursor Block.
	assumes	ds,nothing

	push	bx

	and	dx,(finstText OR finstFont)	; This will be true only in
	cmp	dx,(finstText OR finstFont)	;   Hercules RAMFont mode.

	mov	cx,[bx].wAndMaskTextMcb
	mov	dx,[bx].wXorMaskTextMcb

ifndef KANJI
	jne	NotRAMFont		; If 48K RAMFont, then make sure that
	mov	ch,0BFh			;   only bit 6 of the high word gets
	mov	dh,040h			;   toggled (the reverse video bit).
NotRAMFont:
endif	; not KANJI

	xor	bx,bx			; 0/1 -> Soft/hardware text cursor.
	int	33h			; Set Text Cursor
	pop	bx

	; Do not set both cursor, because Japanese machine has super-impose.
ifndef KANJI
	mov	cx,ds
	mov	es,cx
	assumes	es,nothing
	lea	dx,[bx].rgwAndMaskGfxMcb ; es:dx -> And & Xor blocks.
	mov	cx,[bx].rowHotMcb
	mov	bx,[bx].colHotMcb
	dec	al
	AssertEq	ax,9
	int	33h			; Set Graphics Cursor Block
endif	; not KANJI

@@:
	StopPublic

cEnd	SetMouseCursor


;********** MouseConditionalOff **********
;
;	entry : pmcob = near pointer to a Mouse Conditional Off Block
;
;	Defines a region on the screen for mouse updating
;
; This is needed by Word in its Page Preview mode, when Word is working with
; the GSDs.  When Word is in character-graphics mode (with CSDs), the CSD
; driver takes care of turning the mouse off and back on.
; 
; So, we can assume that we're in graphics mode when this gets called.

    assumes CS,KERNEL
    assumes SS,DATA
    assumes DS,DATA
    assumes ES,nothing

cPublic	MouseConditionalOff,<ATOMIC>,<si,di>
parmW	pmcob

cBegin	MouseConditionalOff

	StartPublic

	mov	ax,16			; ah = 0
	cmp	fMousePresent,ah
	jz	@F

	mov	bx,pmcob
	mov	cx,[bx].xLeftMCOB
	mov	dx,[bx].yTopMCOB
	mov	si,[bx].xRightMCOB
	mov	di,[bx].yBottomMCOB
	int	33h
@@:
	StopPublic

cEnd	MouseConditionalOff


;********** MouseOn **********
;
;	Un-does the MouseConditionalOff
;
    assumes CS,KERNEL
    assumes SS,DATA
    assumes DS,DATA
    assumes ES,nothing

cPublic	MouseShowCursor,<ATOMIC>

cBegin	MouseShowCursor

	StartPublic

	mov	ax,1			; ah = 0
	cmp	fMousePresent,ah
	jz	@F
	int	33h
@@:
	StopPublic

cEnd	MouseShowCursor

sEnd	KERNEL

;----------------------------------------------------------------------------

IFDEF MOUSE_EXTRAS 

sBegin	MOUSE			;* discardable MOUSE segment
    assumes CS,MOUSE
    assumes SS,DATA
    assumes DS,DATA
    assumes ES,nothing

;********** SetMouseDoubleSpeed **********
;*	entry : mps = mickey / second speed
;*	* Set mouse double speed threshold
;*	exit : n/a

cPublic	SetMouseDoubleSpeed,<ATOMIC>
    parmW mps
cBegin	SetMouseDoubleSpeed

	StartPublic
	mov	ax,19
	cmp	fMousePresent,ah
	jz	@F

	mov	dx,mps
	int	33H			;* Set double speed
@@:
	StopPublic

cEnd	SetMouseDoubleSpeed



IFDEF MOUSE_SWAP
;********** SwapMouseButton **********
;*	entry : fSwap : TRUE => swap buttons
;*	* Set fSwapButton to state specified
;*	exit : AX = old value of fSwapButton

cPublic	SwapMouseButton,<ATOMIC>
    parmW fSwap
cBegin	SwapMouseButton

	StartPublic
	mov	al,fSwapButton
	xor	ah,ah			;* old value 0 or 1
	mov	cx,fSwap
	jcxz	turn_swap_off
	mov	fSwapButton,1
	jmp	short swap_end
turn_swap_off:
	mov	fSwapButton,0
swap_end:
	StopPublic

cEnd	SwapMouseButton
ENDIF ;MOUSE_SWAP


sEnd	MOUSE
ENDIF ;MOUSE_EXTRAS 


;----------------------------------------------------------------------------

;*	* Mouse Interrupt (in FIXED KERNEL segment)


externFP	MouseMessage			;* from event.c

sBegin	KERNEL
    assumes CS,KERNEL
    assumes SS,NOTHING
    assumes DS,NOTHING

;********** MouseInterrupt **********
;* MOUSE USER DEFINED SUB-ROUTINE (called from mouse driver)
;*	entry : AX = condition mask
;*		BX = button state
;*		CX = horiz. coordinate
;*		DX = vert. coordinate
;*	* Process a mouse event
;*	* If necessary perform mouse lock out
;*	exit : n/a

cProc	MouseInterrupt,<FAR, ATOMIC>,<DS,ES>
cBegin	MouseInterrupt

	CLI			;* DISABLE INTERRUPTS TO AVOID RECURSION
; Establish ds addressing
	push	ax
	mov	ax,SEG dataBase
	mov	ds,ax
    assumes ds,DATA

; Save Button State
	mov	sstMouse,bx

; convert mouse location from pixel to character based.
	cCall	SetMousePixelPos

	pop	ax
; Save interrupt conditions
	mov	dx,ax

IFDEF MOUSE_SWAP
;*	* First see if buttons reversed
	test	fSwapButton,0ffh
	jz	dont_swap_buttons

;*	* Swap Mouse buttons for interrupt state
	Assert	<LEFT_BUTTON_DOWN EQ 2>
	Assert	<LEFT_BUTTON_UP	EQ 4>
	Assert	<RIGHT_BUTTON_DOWN EQ 8>
	Assert	<RIGHT_BUTTON_UP EQ 10H>

	mov	ah,al				;* copy in AH
	and	dl,11100001B			;* clear 4 bits in question
	shl	al,1
	shl	al,1
	and	al,011000B			;* map left to right
	shr	ah,1
	shr	ah,1
	and	ah,000110B			;* map right to left
	or	al,ah
	or	dl,al				;* put back together

;*	* Swap sstMouse (ls2bits)
	mov	ax,sstMouse
	mov	bl,al
	mov	bh,al
	and	al,11111100B			;* clear ls2b
	shr	bl,1
	shl	bh,1
	or	bl,bh
	and	bl,11B
	or	al,bl
	mov	sstMouse,ax

;*	* DX = mouse state
dont_swap_buttons:
ENDIF ;MOUSE_SWAP

; Post Messages according to the events

	mov	al,dl			;* test in AL shorter

MouseMove?:
	test	al,MOUSE_MOVE
	jz	LeftButtonDown?

	mov	ax,WM_MOUSEMOVE
	cCall	DoMouseMessage

LeftButtonDown?:
	test	al,LEFT_BUTTON_DOWN
	jz	LeftButtonUp?

	mov	ax,WM_LBUTTONDOWN
	cCall	DoMouseMessage

LeftButtonUp?:
	test	al,LEFT_BUTTON_UP
	jz	RightButtonDown?

	mov	ax,WM_LBUTTONUP
	cCall	DoMouseMessage

RightButtonDown?:
	test	al,RIGHT_BUTTON_DOWN
	jz	RightButtonUp?

	mov	ax,WM_RBUTTONDOWN
	cCall	DoMouseMessage

RightButtonUp?:
	test	al,RIGHT_BUTTON_UP
	jz	done_messages

	mov	ax,WM_RBUTTONUP
	cCall	DoMouseMessage

done_messages:
;*	* Check for mouse lockout
;*	* If ABS(ayDrawing - ayMouse{new}) = FE,FF,0,1,2 then kill mouse
	mov	al,ayMouse
	sub	al,ayDrawing
	add	al,2				;* 0, 1, 2, 3, 4 => kill it
	cmp	al,5
	jae	lockout_done			;* no conflict
do_lockout:
;*	* drawing conflict, turn mouse of if not already turned off
	test	fMouseOn,0ffh
	jz	lockout_done			;* already off
	test	fMouseLockedOut,0ffh
	jnz	lockout_done			;* already locked out
	mov	ax,2
	int	33H				;* turn off mouse
	mov	fMouseOn,0			;* mouse is off
	mov	fMouseLockedOut,0ffh		;* set locked out flag

lockout_done:
	STI			;* RE-ENABLE INTERRUPTS

cEnd	MouseInterrupt



;********** DoMouseMessage **********
;*	entry : ax = Message type
;*		dx = mouse mask
;*	* Call MouseMessage with parameter
;*	exit : dx retained
;*		al restored with dl

cProc	DoMouseMessage,<NEAR,ATOMIC>	;* all code FIXED !
cBegin	DoMouseMessage
	push	dx
	cCall	MouseMessage,<ax>
	pop	dx
	mov	al,dl
cEnd	DoMouseMessage

;*****************************************************************************


;********** SetMousePixelPos **********
;*	entry:	cx = xMouse (pixels)
;*		dx = yMouse (pixels)
;*	* convert to character coords and store in (axMouse, ayMouse)

cProc	SetMousePixelPos, <NEAR, ATOMIC>
cBegin	SetMousePixelPos

IFDEF LATER
	-- characters other than 8 pixels wide (graphics modes)
ENDIF
	mov	ax,cx
	mov	cl,3				;* 8 pixels wide
	shr	ax,cl
	mov	axMouse,al

	mov	ax,dx				;* vertical
	mov	cl,instCur.inftInst.dyCharInft
	or	cl,cl
	jnz	@F
	mov	cl,8				;* default 8 pixels high
@@:
	div	cl
	mov	ayMouse,al

cEnd	SetMousePixelPos

sEnd	KERNEL

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\ldstack.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	ldstack.asm : stack walking

	TITLE	LDSTACK - stack walking procedures

	.xlist
	include kernel.inc
	include galloc.inc
	.list

;*****************************************************************************

;*	* Stack format (off of BP)
bpNext	EQU	0			;* next BP
pfnRet	EQU	2			;* return far address
offRet	EQU	pfnRet			;* return offset
psRet	EQU	pfnRet+2		;* return segment address
					;* may be < 256 for return thunks

;*****************************************************************************

sBegin	DATA

externW     <psLom>

IFDEF DEBUG
externW     <pGlobalHeap>
ENDIF ;DEBUG

externW <bpOldStack, ssOldStack>

sEnd	DATA

;*****************************************************************************

sBegin	KERNEL
    assumes CS,KERNEL
    assumes DS,NOTHING				;* DS == pGlobalHeap
    assumes SS,DGROUP

externW	<bpSaveThunk, spSaveThunk, ssSaveThunk>	;* saved stack

IFDEF KERNEL_SWAP_STACK
;*	*  These variables are in the kernel for QC's weird stack swapping
externW	sstVap
externW	spVap
externW	ssVap
externW	bpVap
ENDIF	;KERNEL_SWAP_STACK


;********** PrepWalkStack **********
;*	entry:	n/a (SS:BP => this stack)
;*	* prepare for stack walking
;*	exit:	DS:CX => first stack location to walk

cProc	PrepWalkStack, <NEAR, ATOMIC>
cBegin	PrepWalkStack
	mov	ax,ss
	mov	ds,ax
	mov	cx,[bp].bpNext			;* ignore this frame
	mov	ax,bpSaveThunk
	or	ax,ax
	jz	walk_from_stack
;*	* walk from thunk
	mov	cx,ax
	mov	ds,ssSaveThunk
walk_from_stack:
cEnd	PrepWalkStack



;********** PatchStackMoved **********
;*	entry : segno = segment that moved
;*		psOld = old segment address
;*		psNew = new segment address
;*	* Walk the stack, update any address to return to the moved segment
;*	* Walks from the current BP
;*	exit : n/a

cProc	PatchStackMoved,<NEAR,PUBLIC,ATOMIC>,<DS>
    parmB segno
    parmW psOld
    parmW psNew
cBegin	PatchStackMoved

	cCall	PrepWalkStack
	mov	ax,psOld			;* value to scan for
	mov	dx,psNew			;* value to update to
psm_loop:	;* DS:CX => stack
	mov	bx,cx
	mov	cx,ds:[bx].bpNext		;* next BP (odd => far frame)
	jcxz	psm_done_this_stack		;* next BP == 0 => end of frame
	test	cl,1
	jz	psm_loop			;* ignore near frames
;*	* far frame
	dec	cx
	cmp	ax,ds:[bx].psRet		;* see if return to this segment
	jne	psm_loop
	mov	ds:[bx].psRet,dx
	jmp	psm_loop

psm_done_this_stack:

IFNDEF KERNEL_SWAP_STACK
;*	* if the bpOldStack in this stack is set, link to that stack
	mov	cx,ds:[bpOldStack]		;* may or may not be default DS
	jcxz	psm_exit			;* that's all
	mov	ds,ds:[ssOldStack]
	jmp	short psm_loop

ELSE
;* REVIEW: This is Jim's stack walking code, this should be replaced
;*	 by the above multiple stack code
	cmp	sstVap,SST_NO_VAP		;* See if a vap is active
	jz	psm_exit			;* No - then exit

	mov	cx,bpVap
	mov	ds,ssVap

psm_loop1:
	mov	bx,cx
	mov	cx,ds:[bx].bpNext		;* next BP (odd => far frame)
	jcxz	psm_exit			;* next BP == 0 => end of frame
	test	cl,1
	jz	psm_loop1			;* ignmore near frames
;*	* far frame
	dec	cx
	cmp	ax,ds:[bx].psRet		;* see if return to this segment
	jne	psm_loop1
	mov	ds:[bx].psRet,dx
	jmp	psm_loop1

ENDIF			; KERNEL_SWAP_STACK

psm_exit:

cEnd	PatchStackMoved



;********** PatchStackDiscarded **********
;*	entry : segno = segment that moved
;*		psOld = old segment address
;*	* Walk the stack, update any return addresses to return thunk.
;*	exit : n/a

cProc	PatchStackDiscarded,<NEAR,PUBLIC,ATOMIC>,<SI,DS>
    parmB segno
    parmW psOld
cBegin	PatchStackDiscarded

	mov	al,segno
	cCall	PrepareEntret			;* ES:SI => entret
	cCall	PrepWalkStack
	xor	dx,dx				;* special value => stuff thunk

	mov	ax,psOld			;* value to scan for
psd_loop:
	mov	bx,cx
	mov	cx,ds:[bx].bpNext		;* next BP (odd => far frame)
	jcxz	psd_done_this_stack		;* next BP == 0 => end of frame
	test	cl,1
	jz	psd_loop			;* ignore near frames
;*	* far frame
	dec	cx
	cmp	ax,ds:[bx].psRet		;* see if return to this segment
	jne	psd_loop
;*	* if (dx != 0) then set to that value
	mov	ds:[bx].psRet,dx
	or	dx,dx
	jnz	psd_loop
;*	* otherwise we have the first return address => point to return thunk
	mov	dx,ds:[bx].offRet
	mov	es:[si].offEntret,dx		;* save offset in thunk
	mov	ds:[bx].offRet,si
	mov	ds:[bx].psRet,es		;* es:si => thunk
;*	* all remaining returns will be to segno:offset
	xor	dh,dh
	mov	dl,segno
	jmp	psd_loop

psd_done_this_stack:

IFNDEF KERNEL_SWAP_STACK
;*	* if the bpOldStack in this stack is set, link to that stack
	mov	cx,ds:[bpOldStack]		;* may or may not be default DS
	jcxz	psd_exit			;* that's all
	mov	ds,ds:[ssOldStack]
	jmp	short psd_loop

ELSE
;* REVIEW: This is Jim's stack walking code, this should be replaced
;*	 by the above multiple stack code
	cmp	sstVap,SST_NO_VAP		;* Is there a vap in the system?
	je	psd_end1
	
	mov	cx,bpVap			;* Get pointers to vap stack
	mov	ds,ssVap

psd_loop1:
	mov	bx,cx
	mov	cx,ds:[bx].bpNext		;* next BP (odd => far frame)
	jcxz	psd_exit			;* next BP == 0 => end of frame
	test	cl,1
	jz	psd_loop1			;* ignore near frames
;*	* far frame
	dec	cx
	cmp	ax,ds:[bx].psRet		;* see if return to this segment
	jne	psd_loop1
;*	* if (dx != 0) then set to that value
	mov	ds:[bx].psRet,dx
	or	dx,dx
	jnz	psd_loop1
;*	* otherwise we have the first return address => point to return thunk
	mov	dx,ds:[bx].offRet
	mov	es:[si].offEntret,dx		;* save offset in thunk
	mov	ds:[bx].offRet,si
	mov	ds:[bx].psRet,es		;* es:si => thunk
;*	* all remaining returns will be to segno:offset
	xor	dh,dh
	mov	dl,segno
	jmp	psd_loop1

psd_end1:
ENDIF						; KERNEL_SWAP_STACK
psd_exit:

cEnd	PatchStackDiscarded



;********** PatchStackLoaded **********
;*	entry : segno = segment that got loaded
;*		psNew = new segment address
;*	* Walk the stack, update return thunks to real address
;*	exit : n/a

cProc	PatchStackLoaded,<NEAR,PUBLIC,ATOMIC>,<SI,DS>
    parmB segno
    parmW psNew
cBegin	PatchStackLoaded

	mov	al,segno
	cCall	PrepareEntret			;* ES:SI => entret
	cCall	PrepWalkStack
	mov	dx,psNew			;* proper ps
	mov	ax,es				;* first ps to find
	cmp	es:[si].offEntret,-1		;* -1 => top already found
	jne	psl_loop			;* find top entry (a thunk)
;*	* top entry already found, find next
psl_find_next:
	xor	ah,ah
	mov	al,segno

psl_loop:
	mov	bx,cx
	mov	cx,ds:[bx].bpNext		;* next BP (odd => far frame)
	jcxz	psl_done_this_stack		;* next BP == 0 => end of frame
	test	cl,1
	jz	psl_loop			;* ignore near frames
;*	* far frame
	dec	cx
	cmp	ax,ds:[bx].psRet		;* ps's match ?
	jne	psl_loop
;*	* if (ah != 0) then return thunk (may not be ours)
	or	ah,ah
	jnz	psl_retthunk
	mov	ds:[bx].psRet,dx
	jmp	psl_loop

psl_retthunk:
	cmp	ds:[bx].offRet,si		;* is it our return thunk ?
	jne	psl_loop			;* someone else's thunk
;*	* otherwise we have the proper return thunk, fix it up
	mov	ax,es:[si].offEntret
	mov	ds:[bx].offRet,ax
;*	* all remaining scans will be for 00:segno
	mov	ds:[bx].psRet,dx
	jmp	psl_find_next

psl_done_this_stack:

IFNDEF KERNEL_SWAP_STACK
;*	* if the bpOldStack in this stack is set, link to that stack
	mov	cx,ds:[bpOldStack]		;* may or may not be default DS
	jcxz	psl_exit			;* that's all
	mov	ds,ds:[ssOldStack]
	jmp	short psl_loop

ELSE
;* REVIEW: This is Jim's stack walking code, this should be replaced
;*	 by the above multiple stack code

	cmp	sstVap,SST_NO_VAP	;* Is there a vap process?
	je	psl_exit		;* No skip this
	
	mov	cx,bpVap		;* Point to the vap's stack
	mov	ds,ssVap

	mov	ax,es				;* first ps to find
	cmp	es:[si].offEntret,-1		;* -1 => top already found
	jne	psl_loop1			;* find top entry (a thunk)
;*	* top entry already found, find next
psl_find_next1:
	xor	ah,ah
	mov	al,segno

psl_loop1:
	mov	bx,cx
	mov	cx,ds:[bx].bpNext		;* next BP (odd => far frame)
	jcxz	psl_exit			;* next BP == 0 => end of frame
	test	cl,1
	jz	psl_loop1			;* ignore near frames
;*	* far frame
	dec	cx
	cmp	ax,ds:[bx].psRet		;* ps's match ?
	jne	psl_loop1
;*	* if (ah != 0) then return thunk (may not be ours)
	or	ah,ah
	jnz	psl_retthunk1
	mov	ds:[bx].psRet,dx
	jmp	psl_loop1

psl_retthunk1:
	cmp	ds:[bx].offRet,si		;* is it our return thunk ?
	jne	psl_loop1			;* someone else's thunk
;*	* otherwise we have the proper return thunk, fix it up
	mov	ax,es:[si].offEntret
	mov	ds:[bx].offRet,ax
;*	* all remaining scans will be for 00:segno
	mov	ds:[bx].psRet,dx
	jmp	psl_find_next1

ENDIF						; KERNEL_SWAP_STACK
psl_exit:

cEnd	PatchStackLoaded



;********** PrepareEntret **********
;*	entry : al = segno
;*	* prepare ES:SI to point to the specified return thunk (ENTRET)
;*	* also prepare CX for scanning
;*	* This routine is specifically designed for use by PatchStack routines.
;*	exit : ES:SI => entret of proper segment
;*		DS:CX = BP to start scan

cProc	PrepareEntret,<NEAR,ATOMIC>
cBegin	PrepareEntret

;*	* point ES:SI to ENTRET for this return thunk
	mov	es,psLom
	dec	al				;* make zero based
	xor	ah,ah				;* ax = segno-1
	Assert	<SIZE ENTRET EQ 6>
	shl	ax,1
	mov	si,ax
	shl	ax,1				;* times 4
	add	si,ax				;* segno * 6
	add	si,es:[neLom.ne_pretthunks]	;* &entret

;*	* special stack preparations
	cCall	PrepWalkStack

cEnd	PrepareEntret

;*****************************************************************************

;********** ThrowStack **********
;*	entry : bpNew = new BP value
;*	* Patch up any return thunks to reflect the new position
;*	* NOTE : this is not terribly fast, but should be only used for
;*	*  error recovery anyway.
;*	* NOTE : bpNew must be a previous valid bp.
;*	exit : n/a

cProc	ThrowStack,<FAR, PUBLIC, ATOMIC>,<SI>
    parmW  bpNew
cBegin	ThrowStack

;*	* scan from current bp value
;*	* if far return to psLom, assume a return thunk

	mov	dx,bpNew
	mov	cx,[bp].bpNext			;* ignore this frame
ts_resume:
	mov	ax,psLom			;* return thunks segment address
ts_loop:
	mov	bx,cx
	cmp	bx,dx				;* hit the end of throw frame ?
	jae	ts_end				;* done or error
	mov	cx,ss:[bx].bpNext	;* next BP (odd => far frame)
	test	cl,1
	jz	ts_loop			;* ignore near frames
;*	* far frame
	dec	cx
	cmp	ax,ss:[bx].psRet	;* see if return address to this segment
	jne	ts_loop
;*	* get address of thunk
	les	si,ss:[bx].pfnRet	;* get return address (i.e. thunk)
	AssertEq es:[si].opcEntret,opcCalln	;* should be call near
	xor	ah,ah
	mov	al,es:[si].segnoEntret	;* get segment to look for
IFDEF DEBUG
	cCall	AssertSegmentNotResident
ENDIF ;DEBUG
;*	* Scan from the new bp - find first return to "segno"
	push	cx
	mov	cx,bpNew
ts_loop2:
	mov	bx,cx
	jcxz	ts_end_scan
	mov	cx,ss:[bx].bpNext		;* next BP (odd => far frame)
	test	cl,1
	jz	ts_loop2			;* ignore near frames
;*	* far frame
	dec	cx
	cmp	ax,ss:[bx].psRet		;* see if return seg == segno
	jne	ts_loop2
;*	* this is a return to this segment
	mov	ax,ss:[bx].offRet
	mov	es:[si].offEntret,ax		;* save offset in thunk
	mov	ss:[bx].offRet,si
	mov	ss:[bx].psRet,es		;* es:si => thunk
ts_end_scan:					;* no more thunks found
	pop	cx
	jmp	ts_resume

ts_end:
IFDEF DEBUG	;* if above then gone too far => bad bpNew
	je	ts_ok
	cCall	CowAssertFailed
	DB	"ThrowStack - bogus BP$"
ts_ok:
ENDIF ;DEBUG

cEnd	ThrowStack


;*****************************************************************************

IFDEF DEBUG

;********** AssertSegmentNotResident **********
;*	entry : ax = segno
;*	* Debug assert that segment is not resident
;*	exit : n/a : No registers trashed !!!

cProc	AssertSegmentNotResident,<NEAR, ATOMIC>,<ES,DI>
cBegin	AssertSegmentNotResident

	push	ax				;* save segno
	dec	al				;* make zero based
	mov	ah,SIZE NEW_SEG1
	mul	ah
	add	ax,es:[neLom.ne_segtab]
	mov	di,ax
	mov	di,es:[di].ns_handle		;* get handle
	AssertReset di,1			;* must be even
	mov	es,pGlobalHeap
	AssertSet es:[di].he_flags,HE_DISCARDED
	pop	ax				;* restore ax = segno
	AssertEq ax,es:[di].he_owner

cEnd	AssertSegmentNotResident


ENDIF ;DEBUG

;*****************************************************************************

sEnd	KERNEL

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\ldthunk.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	ldthunk.asm : code THUNK reloader

	TITLE	LDTHUNK - THUNK handler

	.xlist
	include kernel.inc
	include galloc.inc
	include sstack.inc
	.list

IFDEF DEBPUB	;* Debugging publics
	PUBLIC	ReloadSegment, RelruSegment, ReturnThunk
ENDIF ;DEBPUB


sBegin	DATA
    assumes DS,DGROUP

externW     <psLom>
externW     <pGlobalHeap>
externW	    <bpOldStack, ssOldStack, pStackMin>

IFNDEF NOPCODE
externW     <$q_mpsnq>			;* HandleTable - 2
ENDIF ;!NOPCODE

sEnd	DATA

sBegin	BSS
    assumes DS,DGROUP

staticB	    levelLru,0			;* 0 => no Relru's since last sweep
					;* 1 => recent Relru's since last sweep
					;* >1 => major Relru's since last sweep
staticB     fLockoutSweep,0		;* TRUE => in the middle of changing thunks

sEnd	BSS


sBegin	KERNEL
    assumes CS,KERNEL
    assumes DS,NOTHING		;* may be called from anywhere
    assumes SS,DGROUP

externNP    <LoadSegment>			;* from ldseg.asm

globalW	bpSaveThunk,0
globalW	spSaveThunk,0
globalW	ssSaveThunk,0
staticW	axSaveThunk,0
staticW	bxSaveThunk,0

IFDEF KERNEL_SWAP_STACK
globalW	sstVap,SST_NO_VAP		; Current Vap Stack State

;*
;*	*  Variables associated with Current Vap Stack

globalW	spVap,?
globalW	ssVap,?
globalW bpVap,?

;*	* Variables associated with Kernel Stack

globalW	spKernel,0
globalW	ssKernel,0
globalW bpKernel,0

ENDIF						;* KERNEL_SWAP_STACK

;*	* Variables in the code segment !!! *

staticW csSave,?
staticW ipSave,?
staticW flagsSave,?

;* * since LRU may occur for resident segments, separate variables are needed
staticW ipSaveLru,?
staticW flagsSaveLru,?
staticW	csSaveLru,?


;********** ReloadSegment **********
;*	entry : MUST be called in the following format
;*		and must be part of ENTMOVE1 structure - in psLom !!
;*			CALLN to near, then JMPF ReloadSegment
;*			DW offset
;*			DB segno
;*	* Load the requested segment, fix up entry table
;*	* then jump to the entry point
;*	exit : never return to caller, jump to destination segment/offset
;*	* DOES NOT ALTER ANY REGISTERS (ignores changing DS)

cProc	ReloadSegment,<FAR>
cBegin	nogen	;ReloadSegment

    assumes DS,NOTHING
	pop	ipSave
	pushf
	pop	flagsSave
;*	* point return address to start of ENTMOVE
	Assert	<offDestEntmove1-opcEntmove1 EQ 3>	;* Near call size
	sub	ipSave,offDestEntmove1-opcEntmove1

IFNDEF KERNEL_SWAP_STACK
	SetStackToDds	1
ELSE
;*	* REVIEW: replace this with CRMGR stack interface
	;*	See if called with the kernel's stack or with a vap stack.

	cmp	sstVap,SST_ACT_VAP	; Is the vap currently active?
	jne	rs10
	
	;*
	;*	Create a stack frame for this function -- may need to back
	;*		batch the call to here if we discard the wrong segment
	;*
	
	inc	bp
	push	bp
	mov	bp,sp
	
	;*	The Vap stack is currently active!!
	;*	Change to the KERNEL stack since ss==DGROUP must be true.
	
	mov	bpVap,bp		; Save the vap's stack
	mov	ssVap,ss
	mov	spVap,sp
	
	mov	bp,bpKernel		; Now load in the kernel's stack
	cli
	mov	ss,ssKernel
	mov	sp,spKernel
	sti
	
	;	Now that stack are changed continue with the real code

rs10:
ENDIF							;* KERNEL_SWAP_STACK
	inc	bp
	push	bp
	mov	bp,sp
	push	ds
	push	es		    ; These registers used
	push	dx
	push	cx
IFDEF KERNEL_SWAP_STACK
	push	bx
	push	ax
ENDIF

	    ; Get address of interrupt instruction within entry table
	mov	es,psLom			;* call from psLom
	mov	csSave,es			;* save this for later
	mov	bx,ipSave
	    ; Get segment number to load
	xor	cx,cx
	mov	cl,es:[bx+segnoEntmove1]
	push	cx			;* segno

	cCall	LoadSegment	;<cx> - returns ax = ps (ignore)

IFDEF KERNEL_SWAP_STACK
	pop	ax
	pop	bx
ENDIF
	pop	cx
	pop	dx
	pop	es
	pop	ds
	pop	bp
	dec	bp
	
IFNDEF KERNEL_SWAP_STACK
	RestoreStackFromDds 1
ELSE
;*	* REVIEW: replace this with CRMGR stack interface
	;	Now - Do we need to restore the vap's stack?

	cmp	sstVap,SST_ACT_VAP	; Is the vap currently active?
	jne	rs99
	
	mov	bp,bpVap
	cli
	mov	ss,ssVap
	mov	sp,spVap
	sti
	
	pop	bp			;* Remove the stack frame
	dec	bp
	
	; Now that the correct stack is pointed to, set-up the return
	;	address as an interupt return.   We indirect back through
	;	the thunk entry which is now a near call to the routine
	;	RelruSegment rather than a near call to this routine.

rs99:
ENDIF						;KERNEL_SWAP_STACK
	push	flagsSave
	push	csSave
	push	ipSave
	iret

cEnd	nogen	;ReloadSegment


;********** RelruSegment **********
;*	entry : MUST be called in the following format
;*		and must be part of ENTMOVE1 structure - in psLom !!
;*			CALLN to near, then JMPF RelruSegment
;*			DW offset
;*			DB segno
;*	* Segment MUST! be loaded, just update LRU
;*	exit : never return to caller, jump to destination segment/offset

cProc	RelruSegment,<FAR>
cBegin	nogen	;ReluSegment

    assumes DS,NOTHING
	pop	ipSaveLru		;* near call return address
	pushf
	pop	flagsSaveLru

IFNDEF KERNEL_SWAP_STACK
	SetStackToDds	0		;* no swapping will occur
ELSE
;*	* REVIEW: replace this with CRMGR stack interface
	;*	See if called with the kernel's stack or with a vap stack.

	cmp	sstVap,SST_ACT_VAP	; Is the vap currently active?
	jne	rls10
	
	;*	The Vap stack is currently active!!
	;*	Change to the KERNEL stack since ss==DGROUP must be true.
	
	mov	bpVap,bp		; Save the vap's stack
	mov	ssVap,ss
	mov	spVap,sp
	
	mov	bp,bpKernel		; Now load in the kernel's stack
	cli
	mov	ss,ssKernel
	mov	sp,spKernel
	sti
	
	;	Now that stack are changed continue with the real code

rls10:
ENDIF						;KERNEL_SWAP_STACK

	push	ds
	push	es		    ; These registers used
	push	dx
	push	cx
IFDEF KERNEL_SWAP_STACK
	push	bx
	push	ax
ENDIF

	mov	fLockoutSweep,1

;*	* point return address to start of ENTMOVE1
	Assert	<offDestEntmove1-opcEntmove1 EQ 3>	;* Near call size
	mov	ax,ipSaveLru
	sub	ax,offDestEntmove1-opcEntmove1
	mov	ipSaveLru,ax
	mov	dx,ax

;*	* Get segment number to re-lru
	mov	ds,psLom
    assumes DS,NOTHING
	mov	csSaveLru,ds
	mov	bx,dx				;* call was in psLom
	mov	al,ds:[bx+segnoEntmove1]
	dec	al
	xor	ah,ah
	mov	bx,ax				;* bx = zero based segment #
	add	bx,ds:[neLom.ne_psegrefbytes]
	xor	cl,cl
	xchg	cl,ds:[bx]			;* re-lru'd
						;* stuff 0, cl = old count
	or	cl,cl
	js	negative_segref
	or	levelLru,cl			;* if segref > 1 then
						;* levelLru will be > 1
	jmp	short resume_segref

;*	* negative_segref
;*	-- a segref was negative, the only allowed negative segrefs are
;*	-- for bound segments (assert that) and restore segref
;*	-- (i.e. bound stay bound).

negative_segref:
	AssertEq cl,segrefBound
	mov	ds:[bx],cl 		;* restore it

resume_segref:

;*	* get segment address
	Assert	<SIZE NEW_SEG1 EQ 10>
	shl	ax,1
	mov	bx,ax				;* times 2
	shl	ax,1
	shl	ax,1
	add	bx,ax				;* times 10
	add	bx,ds:[neLom.ne_segtab]		;* ds:bx => NEW_SEG1
	mov	bx,ds:[bx].ns_handle		;* MUST BE A HANDLE
	AssertReset bx,1			;* (i.e. odd)
;*	* deference handle - cheap
	mov	es,pGlobalHeap
	AssertNe es:[bx].he_flags,HE_DISCARDED	;* MUST be resident
	mov	ax,es:[bx].he_address

;*	* change ENTMOVE1 (relru) to ENTMOVE
	mov	bx,dx				;* ES:BX => ENTMOVE / ENTMOVE1
	AssertEq ds:[bx].opcEntmove,opcCalln	;* should have been a call
	mov	ds:[bx].opcEntmove,opcJmpf
	mov	dx,ds:[bx].offDestEntmove1
	mov	ds:[bx].offEntmove,dx
	mov	ds:[bx].segEntmove,ax		;* ps of loaded code segment

;*	* done
	mov	fLockoutSweep,0
IFDEF KERNEL_SWAP_STACK
	pop	ax
	pop	bx
ENDIF
	pop	cx
	pop	dx
	pop	es
	pop	ds

IFNDEF KERNEL_SWAP_STACK
	RestoreStackFromDds 0		;* no swapping will occur
ELSE
;*	* REVIEW: replace this with CRMGR stack interface
	;	Now - Do we need to restore the vap's stack?

	cmp	sstVap,SST_ACT_VAP	; Is the vap currently active?
	jne	rls99
	
	mov	bp,bpVap
	cli
	mov	ss,ssVap
	mov	sp,spVap
	sti
	
	; Now that the correct stack is pointed to, set-up the return
	;	address as an interupt return.   We indirect back through
	;	the thunk entry which is now a jump to the real address
	;	rather than a near call to this routine.

rls99:
ENDIF						;KERNEL_SWAP_STACK
	push	flagsSaveLru
	push	csSaveLru
	push	ipSaveLru
	iret

cEnd	nogen	;RelruSegment



;********** ReturnThunk **********
;*	entry : MUST be called in the following format
;*		and must be part of entry table:
;*			CALLN then JMPF to ReturnThunk
;*			DB segno
;*			DW offset
;*	* Return via a return thunk
;*	* DS is actually the destination IP
;*	* the return CS:IP has the handle of the proper DS encoded in it.
;*	* load in the returned segment (if needed), return to the proper
;*	*  place with the proper DS
;*	exit : never return to caller, jump to return address
;*	* DOES NOT ALTER ANY REGISTERS (other than DS)

cProc	ReturnThunk,<FAR>
cBegin	nogen ;ReturnThunk

    assumes DS,NOTHING
	pop	ipSave					;* => segno
	pushf
	pop	flagsSave

IFNDEF KERNEL_SWAP_STACK
	SetStackToDds	1
ELSE
;*	* REVIEW: replace this with CRMGR stack interface
	;*	See if called with the kernel's stack or with a vap stack.

	cmp	sstVap,SST_ACT_VAP	; Is the vap currently active?
	jne	rt10
	
	;*
	;*	Create a stack segment for insurance
	;*
	
	inc	bp
	push	bp
	mov	bp,sp
	
	;*	The Vap stack is currently active!!
	;*	Change to the KERNEL stack since ss==DGROUP must be true.
	
	mov	bpVap,bp		; Save the vap's stack
	mov	ssVap,ss
	mov	spVap,sp
	
	mov	bp,bpKernel		; Now load in the kernel's stack
	cli
	mov	ss,ssKernel
	mov	sp,spKernel
	sti
	
	;	Now that stack are changed continue with the real code

rt10:
ENDIF						; KERNEL_SWAP_STACK
	inc	bp
	push	bp
	mov	bp,sp
	push	ds
	push	es		    ; These registers used
	push	dx
	push	cx
IFDEF KERNEL_SWAP_STACK
	push	bx
	push	ax
ENDIF

;*	* Get address after return thunk's call instruction
	mov	es,psLom			;* call from psLom
	mov	bx,ipSave
;*	* Get return offset
	mov	cx,es:[bx+offEntret-3]		;* after near call
	mov	ipSave,cx			;* return offset
	mov	es:[bx+offEntret-3],-1		;* top entry already found
;*	* Get segment number to load
	Assert	<segnoEntret EQ 3>		;* after near call
	xor	cx,cx
	mov	cl,es:[bx+segnoEntret-3]
	push	cx			;* segno

	cCall	LoadSegment	;<es,cx,bx,bx> - returns AX = psLoaded
	mov	csSave,ax

IFDEF KERNEL_SWAP_STACK
	pop	ax
	pop	bx
ENDIF
	pop	cx
	pop	dx
	pop	es
	pop	ds
	pop	bp
	dec	bp

IFNDEF KERNEL_SWAP_STACK	
	RestoreStackFromDds 1
ELSE
;*	* REVIEW: replace this with CRMGR stack interface
	;	Now - Do we need to restore the vap's stack?

	cmp	sstVap,SST_ACT_VAP	; Is the vap currently active?
	jne	rt99
	
	mov	bp,bpVap
	cli
	mov	ss,ssVap
	mov	sp,spVap
	sti

	pop	bp			;* Remove stack frame
	dec	bp
	
rt99:
ENDIF						; KERNEL_SWAP_STACK
	push	flagsSave
	push	csSave				;* return to proper segment
	push	ipSave
	iret

cEnd	nogen ;ReturnThunk

;*****************************************************************************

;*	* Thunk Patch Routines *

    assumes ds,nothing


;********** PatchThunkMoved **********
;*	entry : segno = segment number that moved (1 based)
;*		psNew = new physical segment it is located at
;*	* Fix up thunks & other info for moved segment
;*		1) fix up moveable entry table
;*	exit : n/a

cProc	PatchThunkMoved,<NEAR,PUBLIC>,<DS>
    parmB segno
    parmW psNew
cBegin	PatchThunkMoved

	mov	fLockoutSweep,1

;*	* Scan the entry table
	mov	ds,psLom			;* assumed throughout
	mov	bx,ds:[neLom.ne_rgentmove]
	mov	cx,ds:[neLom.ne_cmovent]
	mov	al,segno
	mov	es,psNew
pmv_lp:
	cmp	al,ds:[bx].segnoEntmove		;* segment in question ?
	jne	pmv_nxt
	cmp	ds:[bx].opcEntmove,opcJmpf
	jnz	pmv_nxt				;* ignore if Relru
	mov	ds:[bx].segEntmove,es		;* fix direct jump address
pmv_nxt:
	add	bx,SIZE ENTMOVE
	loop	pmv_lp

	mov	fLockoutSweep,0

cEnd	PatchThunkMoved



;********** PatchThunkLoaded **********
;*	entry : segno = segment number that got loaded (1 based)
;*		psNew = new physical segment it is located at
;*	* Fix up thunks & other info for moved segment
;*		1) fix up moveable entry table
;*		2) clear segment reference byte
;*	exit : n/a

cProc	PatchThunkLoaded,<NEAR,PUBLIC>,<DS>
    parmB segno
    parmW psNew
cBegin	PatchThunkLoaded

	mov	fLockoutSweep,1

;*	* Scan the entry table
	mov	ds,psLom			;* assumed throughout
	mov	bx,ds:[neLom.ne_rgentmove]
	mov	cx,ds:[neLom.ne_cmovent]
	mov	al,segno
	mov	es,psNew
pld_lp:
	cmp	al,ds:[bx].segnoEntmove		;* segment in question ?
	jne	pld_nxt
	AssertEq ds:[bx].opcEntmove,opcCalln	;* should have been a call
	mov	ds:[bx].opcEntmove,opcJmpf
	mov	dx,ds:[bx].offDestEntmove1
	mov	ds:[bx].offEntmove,dx
	mov	ds:[bx].segEntmove,es
pld_nxt:
	add	bx,SIZE ENTMOVE
	loop	pld_lp

;*	* clear segment reference byte
	dec	al
	xor	ah,ah
	add	ax,ds:[neLom.ne_psegrefbytes]
	mov	bx,ax
	Assert	<segrefLoaded EQ 0>
	mov	byte ptr ds:[bx],segrefLoaded

	mov	levelLru,0ffh			;* force sweep
	mov	fLockoutSweep,0

cEnd	PatchThunkLoaded



;********** PatchThunkDiscarded **********
;*	entry : segno = segment number that got discarded (1 based)
;*		DS => DDS
;*	* Fix up thunks & other info for moved segment
;*		1) fix up moveable entry table
;*		2) set segment reference byte to 0ffh
;*	exit : n/a

cProc	PatchThunkDiscarded,<NEAR,PUBLIC>,<DS>
    parmB segno
cBegin	PatchThunkDiscarded

	mov	fLockoutSweep,1

;*	* Scan the entry table
	mov	ds,psLom			;* assumed throughout
	mov	bx,ds:[neLom.ne_rgentmove]
	mov	cx,ds:[neLom.ne_cmovent]
	mov	al,segno
pds_lp:
	cmp	al,ds:[bx].segnoEntmove		;* segment in question ?
	jne	pds_nxt
	cmp	ds:[bx].opcEntmove1,opcCalln	;* already a calln
	jz	pds_already_entmove1
;*	* convert ENTMOVE -> ENTMOVE1
	AssertEq ds:[bx].opcEntmove1,opcJmpf	;* must have been far call
	mov	ds:[bx].opcEntmove1,opcCalln
	mov	dx,ds:[bx].offEntmove		;* resident offset
	mov	ds:[bx].offDestEntmove1,dx	;* non-resident offset
pds_already_entmove1:
	mov	dx,opcReloadLom-3		;* reload - 3 for call
	sub	dx,bx
	mov	ds:[bx].relEntmove1,dx		;* relative jump
pds_nxt:
	add	bx,SIZE ENTMOVE
	loop	pds_lp

;*	* set segment reference byte
	dec	al
	xor	ah,ah
	add	ax,ds:[neLom.ne_psegrefbytes]
	mov	bx,ax
	mov	byte ptr ds:[bx],segrefDiscarded

	mov	fLockoutSweep,0

cEnd	PatchThunkDiscarded

;*****************************************************************************

;***** LRU SWEEP *****
    assumes ds,DATA
    assumes ss,nothing		;* called by interrupt

;********** SweepLru **********
;*	entry : n/a (DS = DDS)
;*	* if necessary, sweep the LRU
;*	exit : n/a
;*	* NOTE : sweeping the LRU is defined as follows:
;*		1) for all thunks that are direct jumps (ENTMOVE, i.e. JMPF),
;*		    change them to ENTMOVE1 calls to RelruSegment
;*		2) bump all segref bytes by 1, stick if new value negative
;*			NOTE : fixed, discarded or max LRU will not change

cProc	SweepLru,<NEAR,PUBLIC,ATOMIC>
cBegin	SweepLru

    assumes DS,DGROUP

	cmp	levelLru,1			;* <=1 => ignore
ifdef	FOR_QC
	ja	@F
	jmp	sw_end
@@:
else	; !FOR_QC
	jbe	sw_end
endif	; FOR_QC
;*	* if we interrupted internal processing, then ignore interrupt
	test	fLockoutSweep,0ffh
ifdef	FOR_QC
	jz	@F
	jmp	sw_end
@@:
else	; !FOR_QC
	jnz	sw_end
endif	; FOR_QC
;*	* Perform Sweep
	push	ds
	mov	ds,psLom			;* all work in LOM
    assumes ds,NOTHING

;*	* STEP 1 - sweep thunks

	mov	bx,ds:[neLom.ne_rgentmove]
	mov	cx,ds:[neLom.ne_cmovent]
	jcxz	sw_end
	AssertNe cx,0
IFDEF	FOR_QC
	mov	dx,-1
ENDIF	; FOR_QC

swthk_loop:
	Assert	<opcEntmove EQ opcEntmove1>
	cmp	ds:[bx].opcEntmove,opcJmpf	;* JMPF => resident
	jne	swthk_next			;* else not resident
IFDEF	FOR_QC
;*	* See if the segment is bound
	mov	al,ds:[bx].segnoEntmove		;* Get the segment number
	cmp	al,dl				;* Is it the same as the last?
	je	swthk_qc1
	push	bx				;* Save value
	mov	bx,ds:[neLom.ne_psegrefbytes]	;* Point to array of segrefs
	xor	ah,ah				;* Clear byte
	add	bx,ax				;* Offset by segment number
	dec	bx				;* Make zero based
	mov	dh,ds:[bx]			;* Get current value
	mov	dl,al				;* Save segment number
	pop	bx				;* Restore value
swthk_qc1:
	test	dh,080h				;* Is it negative?
	jnz	swthk_next			;* Yes -- bound -- skip
ENDIF	; FOR_QC

;*	* convert from resident to ReLru.
	mov	ds:[bx].opcEntmove1,opcCalln
	mov	ax,ds:[bx].offEntmove		;* resident offset
	mov	ds:[bx].offDestEntmove1,ax	;* non-resident offset
	mov	ax,opcRelruLom-3		;* relru - 3 for call
	sub	ax,bx
	mov	ds:[bx].relEntmove1,ax		;* relative jump

swthk_next:
	add	bx,SIZE ENTMOVE
	loop	swthk_loop

;*	* STEP 2 - sweep seg ref bytes
	Assert	<segrefLoaded EQ 0>
	Assert	<(segrefDiscarded+1) AND 80H>	;* must be negative to stick
	Assert	<(segrefFixed+1) AND 80H>	;*	"	"	"

	mov	cx,ds:[neLom.ne_cseg]
	dec	cx				;* none for DGROUP
	mov	bx,ds:[neLom.ne_psegrefbytes]
	AssertNe cx,0

swref_loop:
	inc	byte ptr ds:[bx]
	jns	swref_next
	dec	byte ptr ds:[bx]		;* overflow => keep at 255
swref_next:
	inc	bx
	loop	swref_loop

	pop	ds
    assumes ds,DATA

IFNDEF NOPCODE
;*	* sweep clear handle table
	push	di
	mov	di,dataOffset $q_mpsnq
	xor	cx,cx
	xchg	cx,ds:[di-2]			;* clear cwClear / get count
	push	ds
	pop	es				;* es:di => entries
	xor	ax,ax
	cld					;* called from interrupt
						;* D flag unknown !
	rep stosw				;* clear table
	pop	di
ENDIF ;!NOPCODE

	mov	levelLru,0			;* not active until Reload or
						;*  Relru is called
sw_end:

cEnd	SweepLru




;********** BindSegment **********
;*	entry : lpfn = pointer to a thunk
;*		fBind => whether to bind or unbind
;*	* Bind or unbind a segment
;*	exit : n/a

cPublic	BindSegment, <>
    parmD lpfn
    parmW fBind
cBegin	BindSegment
    assumes DS,DATA

    assumes DS,DGROUP
	les	bx,lpfn			;* es == psLom

IFDEF DEBUG
;*	* make sure that it is a thunk
	mov	ax,psLom
	mov	cx,es
	cmp	ax,cx
	je	ok_bind
	cCall	CowAssertFailed
	DB	"bad BindSegment call$"
ok_bind:
ENDIF ;DEBUG
;*	* Get segment number to bind/unbind
	xor	dx,dx
	mov	dl,es:[bx+segnoEntmove1]
	mov	bx,dx
	dec	bx
BS10:
	add	bx,es:[neLom.ne_psegrefbytes]

	mov	al,es:[bx]		;* al = segref
	mov	cx,fBind
	jcxz	bind_unbind		;* cl == 0 => just LRU'd

;*	* bind : we may have to reload the segment
	cmp	al,segrefBound
	je	end_bind			;* already bound

	cmp	al,segrefDiscarded
	jne	bind_loaded

	Save	<bx,dx>
	cCall	LoadSegment, <dx>		;* load it
bind_loaded:
	mov	cl,segrefBound
bind_update:	;* cl = segref
	mov	es:[bx],cl

ifdef	FOR_QC
;*	* Walk all thunks for this segment and make jmpfs
	mov	fLockoutSweep,1
	push	ds
	;*	Scan the entry table
	mov	ax,dx			;* Get segment number
	dec	ax			;* Zero base it
	mov	cx,SIZE NEW_SEG1	;* Convert into offset in
	imul	cl			;*    the segment info table
	mov	bx,ax			;*
	add	bx,es:[neLom.ne_segtab]	;* 
	mov	bx,es:[bx].ns_handle	;* Get the segments handle
	mov	es,[pGlobalHeap]	;* Convert handle into segment no
	AssertNe es:[bx].he_flags, HE_DISCARDED
	mov	es,es:[bx].he_address	;*
	mov	ds,[psLom]		;*
	assumes	ds,nothing		;*
	mov	bx,ds:[neLom.ne_rgentmove]
	mov	cx,ds:[neLom.ne_cmovent]
	mov	ax,dx
bs_pld_lp:
	cmp	al,ds:[bx].segnoEntmove		;* Segment in question ?
	jne	bs_pld_nxt
	cmp	ds:[bx].opcEntMove,opcJmpf
	je	bs_pld_nxt
	AssertEq ds:[bx].opcEntmove,opcCalln	;* should have been a call
	mov	ds:[bx].opcEntmove,opcJmpf
	mov	dx,ds:[bx].offDestEntmove1
	mov	ds:[bx].offEntmove,dx
	mov	ds:[bx].segEntmove,es
bs_pld_nxt:
	add	bx,SIZE ENTMOVE
	loop	bs_pld_lp
	pop	ds
	assumes	ds,DGROUP
	mov	fLockoutSweep,0
endif	; FOR_QC

end_bind:
cEnd	BindSegment

bind_unbind:	;* unbind segment
;*	* Note: due to overbinding, the segment could be:
;*	*  normal resident (moveable/discardable), bound or discarded
	cmp	al,segrefDiscarded
	je	end_bind			;* keep discarded
	AssertEQ cx,0
	jmp	short bind_update		;* just re-lru



IFDEF KERNEL_SWAP_STACK
;* the following is QC specific

;********** BindPS **********
;*	entry : ps = physical segment to bind
;*		fBind => whether to bind or unbind
;*	* Bind or unbind a segment
;*	exit : n/a

cPublic	BindPS,<>
    parmW ps
    parmW dummy
    parmW fBind
cBegin	BindPS
    assumes DS,DGROUP
	push	si

	mov	es,psLom
	mov	si,es:[neLom.ne_segtab]
	mov	cx,es:[neLom.ne_cseg]
	xor	dx,dx
BPS10:
	mov	bx,es:[si].ns_handle	;* handle or ps
	mov	ax,es:[si].ns_flags	;* 
	test	ax,NSMOVE		;* can it move?
	jz	BPS50			;* no-
	push	es
	mov	es,pGlobalHeap		;*
	test	es:[bx].he_flags,HE_DISCARDED	;* Can't bind a discarded 
					;* segment this way
	mov	bx,es:[bx].he_address	;* dereference
	pop	es
	jnz	BPS50			;* --- TRUE if segment is discarded
	cmp	bx,ps			;* Is this the segment I want?
	je	BPS60			;* Yes -- bind it down
	
BPS50:
	add	si,SIZE NEW_SEG1
	inc	dx
	loop	BPS10
ifdef	DEBUG
	cCall	CowAssertFailed
	DB	"bad BindPS call$"
endif	; DEBUG

BPS60:
	pop	si
	mov	bx,dx
	inc	dx
	jmp	bs10
	
cEnd	BindPS

ENDIF ;KERNEL_SWAP_STACK



;********** UnbindAll **********
;*	entry : n/a (DS != DDS)
;*	* unbind all bound segments (for low memory conditions)
;*	exit : n/a

cProc	UnbindAll, <NEAR, PUBLIC, ATOMIC>, <DS>
cBegin	UnbindAll
    assumes SS,DGROUP
    assumes DS,NOTHING
	mov	ds,psLom
	mov	cx,ds:[neLom.ne_cseg]
	dec	cx				;* cx = # of code segments
	mov	bx,ds:[neLom.ne_psegrefbytes]	;* es:bx => segref array
unbind_loop:
	cmp	byte ptr ds:[bx],segrefBound
	jne	unbind_next
	mov	byte ptr ds:[bx],segrefLoaded	;* unbound
unbind_next:
	inc	bx
	loop	unbind_loop

cEnd	UnbindAll


;********** GetCodeHandle **********
;*	entry : ps = psThunk, ib = ibThunk
;*	* Return a valid code handle for given thunk
;*	* Code segment will be resident on exit
;*	exit : ax == code handle
;*

cProc	GetCodeHandle,<FAR,PUBLIC,ATOMIC>,<SI>
    parmW	ps
    parmW	ib
cBegin	GetCodeHandle
    assumes DS,DGROUP

	mov	es,ps			; es:bx => thunk
	mov	bx,ib

IFDEF DEBUG
	mov	ax,es
	AssertEq ax,psLom		; thunks are in psLom
ENDIF ;DEBUG

	cmp	es:[bx].opcEntmove,opcJmpf
	jnz	not_ENTMOVE

;*	* ENTMOVE	Segment is resident, return ga_handle from arena

	mov	ax,es:[bx].segEntmove
	dec	ax
	mov	es,ax			; es:0 => arena
	mov	ax,es:[ga_handle]
	jmp	short gch_end

not_ENTMOVE:

;*	* ENTMOVE1 or ENTMOVE2
;			Segment may or may not be resident, load segment
;			if necessary, return ns_handle from NEWSEG1

;*	* get ns_handle

	xor	ax,ax
	mov	al,es:[bx].segnoEntmove1
	AssertSet ax,0ffh		; must be non-zero
	mov	cx,ax			; segno in cx for LoadSegment

	dec	ax
	mov	bl,size NEW_SEG1	; bigger speedier method in LoadSegment
	mul	bl
	mov	si,ax

IFDEF DEBUG
	mov	ax,es
	AssertEq ax,psLom		; es should not have changed
ENDIF ;DEBUG

	add	si,es:[neLom.ne_segtab]	; es:si => NEW_EXE1
	mov	si,es:[si].ns_handle	; si == ns_handle
	mov	es,pGlobalHeap		; es:si => handle entry

;*	* if segment is discarded, load it

	test	es:[si].he_flags,HE_DISCARDED
	jz	no_load
	cCall	LoadSegment,<cx>

no_load:
	mov	ax,si

gch_end:

cEnd	GetCodeHandle


;*****************************************************************************


;IFDEF DEBUG	;* Debug entry for thunk info

;*********** GetCodeInfo **********
;*	entry : lpProc = far pointer to a thunk or code segment
;*		lpSegInfo => buffer of size SIZE(NEW_SEG1) + 2 bytes
;*	exit : ax = 0 if not a valid thunk / entry
;*	    else ax != 0, *lpSegInfo filled with seg info (SEGI: see winreq.doc)


cProc	GetCodeInfo,<PUBLIC,FAR>,<ds,si,di>
	parmD	lpProc
	parmD	lpSegInfo
cBegin

    assumes DS,NOTHING
    assumes SS,DGROUP
	lds	si,lpProc
	mov	ax,ds
	cmp	ax,psLom
	jnz	not_a_thunk
;*	* ds:si => thunk
	mov	al,ds:[si].segnoEntmove
save_segi:	;* al = segno (1 based)
	mov	ds,psLom
	dec	ax			;* (dec al) -- make 0 based
	mov	bl,SIZE NEW_SEG1
	mul	bl
	add	ax,ds:[neLom.ne_segtab]
	mov	si,ax			;* source
	les	di,lpSegInfo		;* destination
	mov	cx,SIZE NEW_SEG1 / 2
;;	cld
	rep	movsw
	mov	bx,lomOffset neLom	;* DS:BX => New Exe header
	mov	ax,ds:[bx].ne_align	; Return segment aligment
	stosw
	sub	si,SIZE NEW_SEG1
	sub	di,SIZE NEW_SEG1+2
	cmp	si,ds:[bx].ne_autodata
	jne	gciExit
	mov	ax,ds:[bx].ne_stack
	add	ax,ds:[bx].ne_heap
	add	es:[di].ns_minalloc,ax
gciExit:
	mov	cx,ax
cEnd

not_a_thunk:	;* ds:si => a procedure in a fixed segment
	mov	dx,ds				;* psFixed
	mov	ds,psLom
	mov	cx,ds:[neLom.ne_cseg]
	mov	bx,ds:[neLom.ne_segtab]
	mov	ax,1				;* 1 based segment #
find_fixed_loop:
	cmp	dx,ds:[bx].ns_handle
	je	save_segi
	add	bx,SIZE NEW_SEG1
	inc	al
	loop	find_fixed_loop
	xor	ax,ax				;* failure
	jmp	short gciExit

;ENDIF ;DEBUG


;*****************************************************************************

sEnd	KERNEL

;*****************************************************************************

sBegin	INIT
    assumes CS,INIT
    assumes DS,DATA
    assumes SS,DGROUP


;********** InitThunk **********
;*	entry : n/a
;*	* Initialize the thunk manager
;*	exit : n/a
;*	* NONCONFORMING (trashes SI/DI)

cProc	InitThunk,<PUBLIC,FAR,ATOMIC>
cBegin	InitThunk

    assumes ds,dgroup
	push	ds
	mov	ds,psLom			;* assumed throughout
    assumes ds,nothing
	xor	di,di

;*	* Patch near calls to far calls
;*	* opcodes
	mov	al,opcJmpf
	mov	ds:[di].opcReloadLom,al
	mov	ds:[di].opcRelruLom,al
	mov	ds:[di].opcRetThunkLom,al
;*	* segments
	mov	ax,SEG kernelBase		;* KERNEL FIXED segment
	mov	ds:[di].psReloadLom,ax
	mov	ds:[di].psRelruLom,ax
	mov	ds:[di].psRetThunkLom,ax
;*	* offsets
	mov	ds:[di].offReloadLom,kernelOffset ReloadSegment
	mov	ds:[di].offRelruLom,kernelOffset RelruSegment
	mov	ds:[di].offRetThunkLom,kernelOffset ReturnThunk
;*	* First re-format the entry table to contain reload pointers
;*	* The loader has put CALLN opcodes in the entries that are not resident
	mov	si,ds:[neLom.ne_rgentmove]
	mov	cx,ds:[neLom.ne_cmovent]
	jcxz	thi_done
thi_lp:
	mov	al,ds:[si].opcEntmove		;* opcJmpf or opcCallf
	cmp	al,opcJmpf
	je	thi_nxt
	AssertEq al,opcCalln
;*	* insert CALLN to ReloadSegment
	mov	ax,opcReloadLom-3		;* where to jump to - 3 for jump
	sub	ax,si				;* relative offset
	mov	ds:[si].relEntmove1,ax
thi_nxt:
	add	si,SIZE ENTMOVE
	loop	thi_lp

;*	* Next, fill in the return thunk table
;*	* The loader has done nothing but allocate this.
	mov	cx,ds:[neLom.ne_cseg]
	dec	cx				;* ignore DGROUP
	mov	si,ds:[neLom.ne_pretthunks]
	mov	dl,1				;* 1 based seg #
thi2_lp:
	mov	ds:[si].opcEntret,opcCalln
	mov	ax,opcRetThunkLom-3		;* where to jump to - 3 for jump
	sub	ax,si				;* relative offset
	mov	ds:[si].relEntret,ax
	mov	ds:[si].segnoEntret,dl
	inc	dl
	add	si,SIZE ENTRET
	loop	thi2_lp

    assumes ds,data
thi_done:
	pop	ds

cEnd	InitThunk


sEnd	INIT

;*****************************************************************************


	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\ldreloc.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	ldreloc.asm : loader relocation
;*	* NOTE : non-conforming procedures (DS == psLom)
;*	* NOTE : this code cloned from loader/loadrelo.asm

	TITLE	LOADRELOC - RelocSegment procedure

	.xlist
	include kernel.inc
	include rlb.inc			;* relocation info
	.list

sBegin	BSS
    assumes DS,DGROUP

externW psLom

sEnd	BSS

;*****************************************************************************

sBegin	KERNEL
    assumes CS,KERNEL
    assumes SS,DGROUP
    assumes DS,NOTHING		;* NOTE : DS == psLom !


;*****************************************************************************

;*	* Jump table for relocations
mprt2pfn	EQU	THIS WORD
	Assert	<rtFixed EQ 0>
	DW	RelocBase			;* rtFixed acts like base
	Assert	<rtOffset EQ 1>
	DW	RelocOffset
	Assert	<rtBase EQ 2>
	DW	RelocBase
	Assert	<rtPtr EQ 3>
	DW	RelocPtr
;*	* if additive (Base only allowed for fixed)
	DW	RelocBaseAdditive

;*****************************************************************************

;********** FRelocSegment **********
;*	entry :
;*		DS == psLom.
;*		pnewseg1 = pointer to a NEW_SEG1
;*		psLoad = physical segment where loaded
;*		segLoaded = 1 based segment # just loaded
;*	* check checksum of segment
;*	* Relocate an already loaded segment
;*	* kernel work buffer contains proper RLB info (lprlb = psLom:offRlbLom)
;*	exit : AX != 0 => ok, AX == 0 => error (checksum error)

cProc	FRelocSegment,<PUBLIC,NEAR>,<SI, DI, DS>
    parmW	pnewseg1
    parmW	psLoad
    parmW	segLoaded
cBegin	FRelocSegment

;{{
;	(lprlb in ds:bx)
;	Assert(lprlb->magic == magicNe);
;	if (segLoaded == lprlb->segSpecial)
;		lprls = &lprlb->rgrls[0];	// rlsSpecial
;	else
;		lprls = &lprlb->rgrls[segLoaded - lprlb->segFirst + 1];
;}}
	mov	bx,ds:[offRlbLom]
	AssertEQ ds:[bx].magicRlb,magicNe
	mov	si,segLoaded
	mov	ax,si
	sub	si,ds:[bx].segFirstRlb	;* si = segLoaded - lprlb->segFirst
	cmp	ax,ds:[bx].segSpecialRlb
	lea	bx,[bx].rgrlsRlb		;* first RLS (rlsSpecial)
	je	use_special_rls
	Assert	<SIZE RLS EQ 4>
	shl	si,1
	shl	si,1
	lea	bx,[bx+si+SIZE RLS]		;* address of sequential one
use_special_rls: ;* ds:bx => RLS

;*	* Check checksum
;{{
;	wSum = lprls->csum;		/* start with total */
;	cw = pnsg->ne_cbseg / 2;
;	lpw = psLoad:0;
;	while (cw--)
;		wSum += *lpw++;
;	if (wSum != 0)
;		return 0;
;}}

	mov	dx,ds:[bx].csumRls		;* wSum
	mov	si,pnewseg1			;* ds:si => NSG info
;*	* Check checksum of code segment
	mov	cx,ds:[si].ns_cbseg		;* in file size
	shr	cx,1
	jcxz	got_checksum

	push	ds
	push	si
	mov	ds,psLoad
	xor	si,si				;* ds:si => code to sum
csum_loop:
	lodsw
	add	dx,ax
	loop	csum_loop
	pop	si
	pop	ds
got_checksum:	;* dx = final sum (should be 0)
	or	dx,dx
	jz	checksum_ok
	xor	ax,ax
	jmp	reloc_end			;* return FALSE if error

checksum_ok:

;{{
;	if (!(pnewseg1->ns_flags & NSRELOC))
;		return;	// no relocation for this one
;}}
	test	ds:[si].ns_flags,NSRELOC
	jnz	reloc_seg
	jmp	reloc_complete			;* no relocations (easy)

reloc_seg:
;{{
;	lpw (ds:si) = lprlb (ds:offRlbLom) + lprls->preloc;
;	crlc = *lpw;				// 1st word is count
;	Assert(crlc != 0);
;	lprlc (ds:si) = lpw;			// followed by relocations
;	while (crlc--)
;		{ /*RelocLoop*/
;		Reloc(lprlc);
;		lprlc++;
;		}
;}}
;*	* ds:bx = lprls (reload DS for each relocation)
	mov	ax,ds:[bx].rltRls		;* ax = rlt
	and	ax,MASK prelocRlt		;* just pointer part
	mov	si,ax
	add	si,ds:[offRlbLom]		;* ds:si = lpw

	lods	word ptr ds:[si]
	mov	cx,ax				;* crlc
	AssertNE cx,0

	mov	es,psLoad			;* es = segment where loaded

RelocLoop:	;* CX = crlc
	push	cx
;{{
;	/* Reloc(lprlc (DS:SI)) - part 1 */
;	rli (cx) = lprlc->rli;
;	offSrc (di) = lprlc->offSrc;
;	Assert(!rli.fImport);
;	/* Determine target value */
;	if (rli.rt == rtFixed)
;		{
;		Assert(rli.seg != 0 && rli.seg <= nexe.ne_cseg);	
;		pnewseg1 (BX) = neLom.ne_segtab[rli.seg];
;		lpDest (DX:AX) = MAKELONG(0, pnewseg1->ns_handle);
;		Assert(!(pnewseg1->ns_flags & NSMOVE));
;		}
;	else
;		{
;		/* moveable */
;		lpDest (DX:AX) = MAKELONG(neLom.ne_enttab[rli.ithunk], neLom);
;		}
;}}
	mov	cx,ds:[si].rliRlc
	mov	di,ds:[si].offSrcRlc

IFDEF DEBUG
	test	cx,MASK fImportRli
	jz	ok_so_far
bad_reloc:
	cCall	CowAssertFailed
	DB	"rlc$"
ok_so_far:
ENDIF ;DEBUG

	Assert	<rtFixed EQ 0>
	test	cx,MASK rtRli
	jnz	entry_moveable

;*	* LOBYTE of RLI is segTarg !
	mov	bl,cl
	xor	bh,bh
IFDEF DEBUG
	or	bx,bx
	jz	bad_reloc
	cmp	bx,ds:[neLom.ne_cseg]
	ja	bad_reloc			;* Error if invalid segno
ENDIF
	Assert	<SIZE NEW_SEG1 EQ 10>
	dec	bx				;* 1 based => zero based
	shl	bx,1
	mov	ax,bx
	shl	bx,1
	shl	bx,1
	add	bx,ax
	add	bx,ds:[neLom.ne_segtab]
	mov	dx,ds:[bx].ns_handle		;* ps of fixed segment
IFDEF DEBUG
;*	* Segment MUST be FIXED !
	test	byte ptr [bx].ns_flags,NSMOVE
	jnz	bad_reloc
ENDIF ;DEBUG
	Assert	<LOW(MASK rtRli) EQ 0>
	jmp	short do_reloc


entry_moveable:
	mov	ax,cx
	and	ax,MASK ithunkRli
	Assert	<SIZE ENTMOVE EQ 6>
	shl	ax,1
	mov	dx,ax
	shl	ax,1
	add	ax,dx				;* times 6
	add	ax,ds:[neLom.ne_rgentmove]	;* point to opcode
	mov	dx,ds				;* dx = ps of entries

do_reloc:
;*	* do relocation : ES:DI => first fixup destination
;*			  DX:AX = fixup value
;*			  CX = rli
	Assert	<MASK rtRli EQ 3000H>
	Assert	<MASK fAddRli EQ 4000H>
	mov	bl,ch
	shr	bx,1				;* *16
	shr	bx,1
	shr	bx,1				;* *2
	and	bx,01110B			;* 1 or 8 vectors
IFDEF DEBUG
;*	* we only have 5 entries
	cmp	bx,01010B
	jae	bad_reloc
ENDIF ;DEBUG
	call	mprt2pfn[bx]			;* do it

;*	* Next relocation please

	add	si,SIZE RLC
	pop	cx				;* crlcRead
	loop	RelocLoop

reloc_complete:
	mov	ax,sp				;* return TRUE
reloc_end:	;* ax = return code

cEnd	FRelocSegment


;*****************************************************************************
;*	* Fixup Routines :

; Offset fixup chain
cProc	RelocOffset,<NEAR, ATOMIC>
cBegin
srsoff1:
	mov	bx,ax
	xchg	es:[di],bx
	mov	di,bx
	inc	bx
	jnz	srsoff1
cEnd

; Segment fixup chain
cProc	RelocBase,<NEAR, ATOMIC>
cBegin
srsseg1:
	mov	bx,dx
	xchg	es:[di],bx
	mov	di,bx
	inc	bx
	jnz	srsseg1
cEnd

; Segment chain fixup Additive
cProc	RelocBaseAdditive,<NEAR, ATOMIC>
cBegin
	add	es:[di],dx
cEnd


; Segment:Offset fixup chain
cProc	RelocPtr,<NEAR, ATOMIC>
cBegin
srsptr1:
	mov	bx,ax
	xchg	es:[di],bx
	mov	es:[di+2],dx
	mov	di,bx
	inc	bx
	jnz	srsptr1
cEnd

;*****************************************************************************

sEnd	KERNEL

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\mouse5.inc ===
;*
;*	COW : Character Oriented Windows
;*
;*	mouse5.inc : DOS 5 specific mouse info

;*****************************************************************************

; Mouse monitor record flags
;
fOpen	equ    00000001b
fClose	equ    00000010b
fFlush	equ    00000100b

; Mouse monitor record event masks
;
mouMotionOnly	equ 0000000000000001b	; motion only
mouButMotion	equ 0000000000101010b   ; motion with button
mouButton	equ 0000000001111110b   ; buttons, with or without motion
mouBut1Only	equ 0000000000000100b   ; button 1 only
mouBut1		equ 0000000000000110b   ; button 1, with or without motion
mouBut2Only	equ 0000000000010000b   ; button 2 only
mouBut2		equ 0000000000011000b   ; button 2, with or without motion
mouBut3Only	equ 0000000001000000b   ; button 3 only
mouBut3		equ 0000000001100000b   ; button 3, with or without motion
mouAny		equ 0000000001111111b	; any

; Mouse monitor record structure
;
MouseRcd	STRUC
	Flags		DW	?	; Open, Flush, Close or 0
	Eventmsk	DW	?	; Event mask (buttons)
	TimeStamp  	DD	?	; Time stamp of the mouse event
	ayMouCur   	DW	?	; new Y
	axMouCur   	DW	?	; new X
MouseRcd  	ENDS

;* Mouse Area
AreaMou	STRUC
	ayTopArea	DW	?	;* top line
	axLeftArea	DW	?	;* left column
	dayArea		DW	?	;* height
	daxArea		DW	?	;* width
AreaMou	ENDS

;* Mouse Pointer Shape
PtrShapeMou	STRUC
	cbPtrShapeMou		dw	?
	colPtrShapeMou		dw	?
	rowPtrShapeMou		dw	?
	colHotPtrShapeMou	dw	?
	rowHotPtrShapeMou	dw	?
PtrShapeMou	ENDS


;* DOS 5 calls

externFP	<DosOpen,DosClose>
externFP	<DosMonClose,DosMonOpen,DosMonReg,DosMonRead,DosMonWrite>
externFP	<DosCreateThread,DosSetPrty>
externFP	<MouOpen,MouClose,MouGetNumButtons>
externFP	<MouDrawPtr,MouRemovePtr,MouGetPtrPos>
externFP	<MouSetPtrPos,MouSetPtrShape>
;externFP	<MouGetPtrShape>
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\ldseg.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	ldseg.asm : segment loader

	.xlist
	include kernel.inc
	include	galloc.inc
	include rlb.inc			;* relocation info
	.list


IFDEF DEBPUB
	PUBLIC	OpenSwapFile
ENDIF


sBegin	DATA
    assumes DS,DGROUP

externW     <psLom>
externW	    <fColorModeOld>		;* last color mode

IFNDEF NOPCODE
externW	 fNew				;* from interpreter
ENDIF ;!NOPCODE

sEnd	DATA

sBegin	BSS
    assumes DS,DGROUP

globalB	    iexeCur, 0		;* current .EXE file open
				;* loader only uses the first file
				;* set to 255 if closing file

globalW	    fFreeOpen, 0	;* TRUE => 1 free open (no warning)
				;* (i.e. don't prompt before opening file)


sEnd	BSS


externFPublic <PromptSwapDisk>			;* from App or stub.

externFP    <GlobalReAlloc, GlobalHandle>
externFPublic <FInitScreenInternal>
externFPublic <ExitKernel>			;* from kerninit.asm
					;* in CORE segment (USER screen)

IFDEF KEEP_SYMDEB_CODE
externFP    <DebugDefineSegment>
ENDIF ; KEEP_SYMDEB_CODE

;*****************************************************************************

sBegin	KERNEL
    assumes CS,KERNEL
    assumes SS,DATA
    assumes DS,NOTHING		;* Called by Reload Segment !

externNP    <FRelocSegment>			;* from ldreloc.asm
externNP    <PatchThunkLoaded>			;* from ldthunk.asm
externNP    <PatchStackLoaded>			;* from ldstack.asm




;********** LoadSegment **********
;*	entry : segno = segment to load
;*	* Load in the segment & relocate
;*	exit : ax = ps of loaded segment

cProc	LoadSegment,<NEAR,PUBLIC>,<si,di>
    parmW segno
    localW psDest			;* destination ps
cBegin	LoadSegment

	mov	fFreeOpen,sp		;* allow 1 free open
;*	* calculate the pnewseg1
	mov	es,psLom
	Assert	<SIZE NEW_SEG1 EQ 10>
	mov	si,segno
	AssertReset si,0ff00h		;* must be byte
	AssertSet   si,000ffh		;* must be non-zero
	dec	si			;* zero base for calculation
	shl	si,1
	mov	ax,si
	shl	si,1
	shl	si,1
	add	si,ax			;* times 10
	add	si,es:[neLom.ne_segtab]		;* ES:SI => NEW_EXE1

;*	* Segment MUST be MOVEABLE CODE
	AssertSet es:[si].ns_flags,NSMOVE
	AssertReset es:[si].ns_flags,NSDATA

;*	* Allocate enough space to read in
        xor     ax,ax
	cCall   GlobalReAlloc,<es:[si].ns_handle,ax,es:[si].ns_minalloc,ax>
;*      * Abort if error
        or      ax,ax
        jnz     lds_ReAllocOK
	BREAKPOINT
        mov     ax,255
        cCall   ExitKernel,<ax>                ;* Fatal error
lds_reAllocOK:
	AssertNe ax,0
	cCall	GlobalHandle,<ax>		;* return dx = ps
;*	* save where loaded
	mov	psDest,dx			;* ps where loaded
;*	* Stuff in the correct flags
	dec	dx				;* point to arena
	mov	es,dx				;* es:0 => arena
	mov	es:[ga_flags],GA_MOVEABLE OR GA_DISCCODE

    assumes DS,NOTHING	;!!!
	push	ds				;* random DS
	mov	ds,psLom

;*	* Make sure we have the correct file open
IFDEF DUAL
loads_retry:
	mov	di,lomOffset neLom
	mov	ax,segno
	cCall	GetRle
	mov	ah,ds:[bx].re_iexe
	cmp	ah,iexeCur
	je	correct_file_open
	Save	<bx>
	cCall	OpenSwapFile
	jmp	short load_rlb
correct_file_open:
	cmp	bx,ds:[pbRleCurLom]
	je	correct_rlb_loaded
load_rlb:
	Save	<bx>
	cCall	LoadRle
correct_rlb_loaded:
ELSE ;!DUAL
	mov	ax,ds:[si].ns_flags
	Assert	<SHIFTDPL EQ 10>
	and	ah,HIGH(NSDPL)
	shr	ah,1
	shr	ah,1
	and	ah,3		;* iexe
	cmp	ah,iexeCur
	je	correct_file_open
loads_retry:
	cCall	OpenSwapFile
correct_file_open:
ENDIF ;!DUAL

;*	* Seek to the proper position in the file
	mov	dx,ds:[si].ns_sector		;* "sector"
	xor	ax,ax				;* ax:dx used for sector
	mov	cx,ds:[neLom.ne_align]		;* shift left count
loads_lp1:
	shl	dx,1
	rcl	ax,1
	loop	loads_lp1
	mov	cx,ax				;* cx:dx = lfa
IFDEF DUAL
IFDEF DEBUG
	AssertEQ bx,ds:[pbRleCurLom]
ENDIF ;DEBUG
	sub	dx,ds:[bx].LO_re_dlfaBias		;* adjust lfa
	sbb	cx,ds:[bx].HI_re_dlfaBias
ENDIF ;DUAL

	mov	bx,ds:[fdExeLom]
	mov	ax,4200h			;* seek device, from start
	int	21h
	jc	loads_error			;* seek error ?

;*	* Read it all in (bx = fd)
	mov	cx,ds:[si].ns_cbseg		;* file length
	push	ds
	mov	ds,psDest			;* where to load
	xor	dx,dx				;* ds:dx = ds:0 = read address
	mov	ah,3fh				;* read from device
	int	21h
	pop	ds
	jc	loads_error			;* read error ?
	cmp	ax,cx
	jne	loads_error			;* read them all ?

;*	* Test to see if we must zero fill the end of the memory block
	mov	di,ds:[si].ns_cbseg		;* offset past end
	mov	cx,ds:[si].ns_minalloc		;* may be larger
	sub	cx,di
	jcxz	loads_end
	cld
	mov	es,psDest
	xor	al,al
	rep	stosb				;* erase it
loads_end:	;* all loaded

	cCall	FRelocSegment,<si, psDest, segno> ;* relocate it, DS == psLom !
	or	ax,ax
	jz	loads_error

	pop	ds				;* restore original DS

;*	* Fix up thunks etc
	cCall	PatchThunkLoaded,<segno, psDest>

;*	* Fix up stack
	cCall	PatchStackLoaded,<segno, psDest>

;*	* Optional inform debugger
IFDEF KEEP_SYMDEB_CODE
        mov     cx,segno
        dec     cx				;* zero based seg #
	xor	ax,ax				;* always code
        cCall   DebugDefineSegment,<cx,psDest,ax>
ENDIF ;KEEP_SYMDEB_CODE

	mov	ax,psDest			;* return value

cEnd	LoadSegment

loads_error:
;*	* close file and try to open again
;*	* if retrying twice, prompt with error line
	mov	ah,iexeCur			;* re-open it
	jmp	loads_retry

;*****************************************************************************


;********** StrCpySiDi **********
;*	entry : ds:si => source
;*		es:di => destination
;*	* copy and zero terminate
;*	exit : es:di => next destination

cProc	StrCpySiDi, <NEAR, ATOMIC>
cBegin	StrCpySiDi

copy_lp:
	lodsb
	stosb
	or	al,al
	jnz	copy_lp

cEnd	StrCpySiDi



;********** OpenSwapFile **********
;*	entry : ah = iexe to open
;*		DS = psLom
;*		fFreeOpen => open before prompt
;*			(FALSE => prompt before open)
;*	* open the swap file (prompt and don't return till open)
;*	exit : n/a (fdExeLom and iexeCur updated).
;*		Kernel buffer filled with RLB info
;*	* TRASHES : DI
;*	* NOTE : will always open !!

cProc	OpenSwapFile, <NEAR, ATOMIC>, <SI>
cBegin	OpenSwapFile

    assumes DS,NOTHING
	xchg	ah,iexeCur			;* set iexeCur, get old
	or	ah,ah
	js	no_file_open			;* negative => 0FFH => closed
;*	* close old file first
	mov	bx,ds:[fdExeLom]
	AssertNE bx,-1
	mov	ah,3eh
	int	21h				;* close file, ignore errors !!
no_file_open:

;*	* otherwise open swap file (ds == psLom, iexeCur set up)
retry_open:	;* old file already closed

	cCall	GetProgFileName

	mov	cx,fFreeOpen
	jcxz	open_file_error			;* prompt first

	;* ds:dx => string
	mov	ax,3d00h
	int	21h				;* open for reading

	jnc	open_file_ok			;* open success

;*	* error when trying to find file (DS = psLom)
open_file_error:
	cCall	GetProgFileName
	push	ds				;* save psLom
	Assert	<?PLM>
IFNDEF NOPCODE
	push	fNew
ENDIF ;!NOPCODE
	;* push lszPath
	push	ds
	push	dx
	;* push ifile
	xor	ax,ax
	mov	al,iexeCur
	push	ax				;* parm.
	;* restore DS to DDS
	push	ss
	pop	ds
    assumes DS,DGROUP
	xor	ax,ax				;* pinst == NULL => prev mode
	cCall	FInitScreenInternal, <ax>	;* to text mode !!
	cCall	PromptSwapDisk			;* tell the user
	mov	ah,0DH
	int	21h				;* reset disk to try again
IFNDEF NOPCODE
	pop	fNew
ENDIF ;!NOPCODE
	mov	fFreeOpen,sp			;* allow retry
	pop	ds				;* restore psLom
    assumes DS,NOTHING
	jmp	retry_open

open_file_ok:
	AssertNE ax,-1
	mov	ds:[fdExeLom],ax		;* save fd

IFDEF DUAL
;*	* reading rlb is done by LoadSegment
ELSE ;!DUAL
;*	* now read in rlb for moveable segments (rlbMove or rlbSwap)
;*	* assume main swap file
	mov	bx,ax					;* fd
	mov	dx,word ptr ds:[neLom.ne_lfaRlbMove]	;* low word
	mov	cx,word ptr ds:[neLom.ne_lfaRlbMove+2]	;* high word
	mov	ax,ds:[neLom.ne_cbRlbMove]		;* size
	cmp	iexeCur,0
	je	reload_rlb				;* all set to go
;*	* auxiliary swap file : read EXH header
	xor	cx,cx
	xor	dx,dx				;* lfa = 0 (start of file)
	mov	ax,SIZE EXH
	cCall	ReadKernelBuff			;* return ss:bx => buffer
	jc	after_open_error
;*	* Validate swap file (must have proper signature, application version
;*	*   stamp and swap file #).
	cmp	ds:[bx].magicExh,magicNe
	jne	after_open_error		;* bad signature
	mov	si,ds:[neLom.ne_restab]		;* start of offsets
	mov	al,ds:[si-1]			;* chStamp
	cmp	ds:[bx].chStampExh,al
	jne	after_open_error		;* bad version stamp
	mov	al,iexeCur
	cmp	ds:[bx].ifileExh,al
	jne	after_open_error		;* bad swap file #
	mov	dx,word ptr ds:[bx].lfaRlbExh	;* low word
	mov	cx,word ptr ds:[bx].lfaRlbExh+2	;* high word
	mov	ax,ds:[bx].cbRlbExh		;* size
	mov	bx,ds:[fdExeLom]		;* restore fd

reload_rlb:	;* Load/Reload RLB into kernel work buffer
	;* cx:dx = lfa, ax = cb, bx = fd
;*	* now read in RLB info (into kernel buffer), ax = cb, bx = fd
	cCall	ReadKernelBuff			;* return ss:bx => buffer
						;* cx = fd
	jc	after_open_error
	cmp	ds:[bx].magicRlb,magicNe
	jne	after_open_error			;* bad signature
ENDIF ;!DUAL
;*	* success !!

cEnd	OpenSwapFile

after_open_error:	;* opened 
;*	* close file
	mov	bx,ds:[fdExeLom]
	AssertNE bx,-1
	mov	ah,3eh
	int	21h				;* close file, ignore errors !!
	jmp	open_file_error



;********** GetProgFileName **********
;*	entry : n/a (DS == psLom)
;*	* copy program drive/dir + file_name into far kernel buffer
;*	exit : ds:dx = start of string (in far kernel buffer)
;*	NOTE : Trashes SI & DI.

cProc	GetProgFileName, <NEAR, PUBLIC, ATOMIC>
cBegin	GetProgFileName

	mov	di,ds:[offRlbLom]
	mov	dx,di				;* start of string
	push	ds
	pop	es				;* es:di => rlb buffer
						;* (far kernel buffer)
	mov	si,lomOffset szBootPathLom

	cCall	StrCpySiDi
	dec	di				;* don't terminate

	mov	al,iexeCur
	mov	si,lomOffset szExeLom
	or	al,al
	jnz	@F				;* use szExeLom if 0
	test	byte ptr ds:[si],0ffh
	jnz	use_sz				;* ...and szExeLom is set
@@:
	xor	ah,ah
	shl	ax,1
	mov	bx,ax
	mov	si,ds:[neLom.ne_restab]		;* start of offsets
	add	si,ds:[si+bx]			;* to proper string
use_sz:
	cCall	StrCpySiDi

cEnd	GetProgFileName


IFDEF DUAL
;********** GetRle ***************
;*	entry:	ds:di => neLom
;*		al == segno
;*	* Return pointer to Rlb entry in Rlbtab for this segment
;*	exit:	bx => Rle
;*	* only bx changed

cProc	GetRle,<PUBLIC,NEAR>
cBegin	GetRle

;*	* Check correct RLB is loaded
	mov	bx,ds:[di].ne_rlbtab
grle_next_rlb_ent:
	cmp	al,ds:[bx].re_segLast
	jbe	grle_rlb_done
	add	bx,SIZE RLB_ENT
	jmp	short grle_next_rlb_ent
grle_rlb_done:

cEnd	GetRle


;********** LoadRle ***************
;*	entry:	ds == psLom
;*		bx => Rle
;*	* Load rlb for given rle
;*	exit:	see ReadKernelBuff for return values

cProc	LoadRle,<PUBLIC,NEAR>
cBegin	LoadRle

;*	* load correct rlb
	mov	ds:[pbRleCurLom],bx		;* set new marker
	mov	dx,ds:[bx].LO_re_lfaRlb
	mov	cx,ds:[bx].HI_re_lfaRlb
	sub	dx,ds:[bx].LO_re_dlfaBias
	sbb	cx,ds:[bx].HI_re_dlfaBias
	mov	ax,ds:[bx].re_cbRlb
	mov	bx,ds:[fdExeLom]
	cCall	ReadKernelBuff

cEnd	LoadRle
ENDIF ;DUAL



;********** ReadKernelBuff **********
;*	entry : ax = # of bytes to read
;*		cx:dx = lfa
;*		bx = fd
;*		ds == psLom
;*	* seek and read # of bytes into far kernel buffer
;*	exit : CY => error
;*	   else: ds:bx => start of kernel buffer,
;*		cx = fd
;*	* DS retained (access buffer off of ss:bx).

cProc	ReadKernelBuff, <NEAR, ATOMIC>
cBegin	ReadKernelBuff

	AssertEQ bx,ds:[fdExeLom]
	push	ax
	mov	ax,4200h			;* seek device, from start
	int	21h
	pop	cx				;* cx = # of bytes
	jc	read_kern_fail			;* seek error

	mov	dx,ds:[offRlbLom]
	mov	ah,3fh				;* read from file
	int	21h
	jc	read_kern_fail			;* read error
	cmp	ax,cx
	stc
	jne	read_kern_fail			;* didn't read it all

	mov	cx,bx				;* save fd
	mov	bx,dx				;* ds:bx => buffer
	clc

read_kern_fail:

cEnd	ReadKernelBuff


;*****************************************************************************


;********** AccessSwapFile **********
;*	entry : fOpen : TRUE => be sure default swap file is open
;*		FALSE => be sure all swap files are closed
;*	* enable / disable the swap file
;*	exit : n/a

cPublic	AccessSwapFile, <ATOMIC>, <DS, DI>
    parmW  fOpen
cBegin	AccessSwapFile

    assumes DS,DATA
	mov	ds,psLom
    assumes DS,NOTHING
	mov	cx,fOpen
	jcxz	close_swap_file

;*	* if iexeCur != 0, then open swap file #0
	xor	ah,ah				;* swap file # 0
	cmp	ah,iexeCur
	je	end_access_swap_file		;* already open

;*	* open the default swap file (ah == 0)
	mov	fFreeOpen,sp			;* allow 1 free open
	cCall	OpenSwapFile

end_access_swap_file:

cEnd	AccessSwapFile

close_swap_file:
	mov	ax,-1
	xchg	iexeCur,al		;* stuff 255 into iexeCur, get old
	cmp	ah,al
	je	end_access_swap_file		;* already closed
	mov	bx,ds:[fdExeLom]
	AssertEQ iexeCur,255
	AssertNE bx,-1
	mov	ah,3eh
	int	21h				;* close file
	jmp	short end_access_swap_file
	



;*****************************************************************************


sEnd	KERNEL

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\loaddrv.asm ===
;*
;*	CW : Character Windows
;*
;*	loaddrv.asm : installable driver loader routines

	include kernel.inc
	include kmem.inc
	include indrv.inc
	include inscr.inc
	include	inkbd.inc
	include insyd.inc
	include	_loaddrv.inc

;*****************************************************************************

;*	App call backs for memory management

;; REVIEW: hard coded driver allocation!
externFP	<LpwAllocDriverMem,FreeDriverMem>

IFDEF DOS5
externFP	<DosOpen, DosClose>
externFP	<DosChgFilePtr, DosRead>
externFP	<DosCreateCSAlias>
ENDIF

sBegin	DATA
    assumes CS,DGROUP
    assumes DS,DGROUP

ifndef	DOS5
externW	chDrivePhantom			; set to "b:" on one floppy systems.
endif	; !DOS5

externW		<inkj>		; keyboard
externW		<insj>		; screen (character)
externW		<inyj>		; system

ifdef	DUAL
ifndef	DOS5
LDRVDATA = 1
endif
else	;!DUAL
LDRVDATA = 1
endif	;!DUAL

ifdef	LDRVDATA

labelW	<PUBLIC, rgindvCw>		;* INDV structures for csd, kbd

labelW	<PUBLIC, indvKbd>		;* Keyboard
	DB	indtKeyboard,0
	DW	dataOffset inkj
	DW	cpfnKbdMin
	DW	cpfnKbdMin
	DW	0
	DW	0

labelW	<PUBLIC, indvCsd>		;* Character Screen
	DB	indtCharacterScreen,0
	DW	dataOffset insj
	DW	cpfnCsdMin
	DW	cpfnCsdMin
	DW	0
	DW	0

labelW	<PUBLIC, indvSyd>		;* System Services
	DB	indtSystem,0
	DW	dataOffset inyj
	DW	cpfnSydMin
	DW	cpfnSydMin
	DW	0
	DW	0

	PUBLIC	cindvCw
cindvCw	EQU	($-rgindvCw)/cbIndvMin

else	;!LDRVDATA

externW	rgindvCw

endif	;!LDRVDATA

IFDEF DOS5
externB		inosDrv				;* INOS info (from loaddrv.asm)
ENDIF ;DOS5

sEnd	DATA


ifndef	LDRVDATA

externA	cindvCw

endif	;!LDRVDATA

;*****************************************************************************

sBegin	KERNEL
    assumes CS,KERNEL
    assumes DS,DGROUP
    assumes SS,DGROUP



;********** RerrLoadDrvFd **********
;*	entry:	hFile => valid file handle
;*		rgindv => cindv INDV records
;*	* Loads drivers from given file
;*	exit:	0	ok, otherwise error code: rerrBadRead,
;*						  rerrBadFormat,
;*						  rerrNoMemory,
;*						  rerrBadFile,
;*						  rerrBadMemReq,
;*						  rerrBadVersion
;*
;*	On error, no service is partially installed.  However, only some
;*	services may have been installed.
;*
;*	nop if cindv == 0 


rldf_badopen:
	mov	ax,rerrBadFile		; restrict error returned
rldf_Abort1:
	jmp	rldf_Abort

;----------------------------------------

cProc	RerrLoadDrvFd, <PUBLIC,FAR>,<DI,SI>
    parmW	hFile
    parmW	rgindv
    parmW	cindv
IFDEF DOS5
    localW	action
    localW	HI_tmp
    localW	LO_tmp
ENDIF ;DOS5
    localW	HI_lfaMT
    localW	LO_lfaMT
    localW	HI_lpwCSeg
    localW	LO_lpwCSeg
    localW	HI_lfaReadMT
    localW	LO_lfaReadMT
    localW	pindv
    localW	cb			; count of bytes in rgbBuff
    localV	rgbBuff,cbBuff		; buffer for master table entries
cBegin	RerrLoadDrvFd

	;*	set indv's to not loaded

	xor	ax,ax
	mov	cx,cindv
	jcxz	rldf_Abort1		; no service will be loaded
	mov	di,rgindv

@@:	jcxz	@F
	mov	[di].psLoadedIndv,ax
	mov	[di].cpfnLoadedIndv,ax
	add	di,cbIndvMin
	loop	@B
@@:

IFNDEF DOS5
	;*	seek to EOF magic tag

	mov	bx,hFile
	mov	ax,-cbIndhMin
	cwd
	mov	cx,dx
	mov	dx,ax
	mov	ax,4202h		; offset is from EOF
	int	21h
	jc	rldf_AbFileshort2

	;*	compute absolute offset to EOF

	add	ax,cbIndhMin
	adc	dx,0
	mov	LO_lfaReadMT,ax
	mov	HI_lfaReadMT,dx
ELSE
	;*	seek to EOF magic tag

	mov	ax,-cbIndhMin
	cwd
	lea	bx,LO_lfaReadMT		; HI_ is in appropriate position
	cCall	DosChgFilePtr,<hFile,dx,ax,2,ss,bx>
	or	ax,ax
	jnz	rldf_AbFileshort2

	;*	compute absolute offset to EOF

	mov	ax,cbIndhMin
	add	LO_lfaReadMT,ax
	adc	HI_lfaReadMT,0
ENDIF ;DOS5

	;*	read magic tag and dlfaTable

	lea	dx,rgbBuff
IFNDEF DOS5
	mov	ah,3fh
	AssertEQ bx,hFile
	mov	cx,cbIndhMin
	int	21h
	jc	rldf_AbFileshort2
ELSE
	lea	ax,cb
	cCall	DosRead,<hFile,ss,dx,cbIndhMin,ss,ax>
	or	ax,ax
	jnz	rldf_AbFileshort2
	mov	ax,cb
ENDIF ;DOS5

	cmp	ax,cbIndhMin		; check read
	mov	ax,rerrBadRead
	jne	rldf_AbFileshort1

	mov	ax,rerrBadFormat
	mov	cx,rgbBuff+LO_rgchMagicIndh
					; check magic word ("DRV0")
	cmp	cx,'RD'
	jne	rldf_AbFileshort1		; invalid format
	mov	cx,rgbBuff+HI_rgchMagicIndh
	cmp	cx,'0V'
	je	@F
rldf_AbFileshort2:
	mov	ax,rerrBadRead
rldf_AbFileshort1:
	jmp	rldf_AbFile		; invalid format
@@:

	;*	compute offset of master table
	
	mov	dx,LO_lfaReadMT
	mov	cx,HI_lfaReadMT
	sub	dx,rgbBuff+LO_dlfaTableIndh
	sbb	cx,rgbBuff+HI_dlfaTableIndh

	;*	save lfa of master table

	mov	LO_lfaMT,dx
	mov	HI_lfaMT,cx

	;*	prep for master table read

	mov	LO_lfaReadMT,dx
	mov	HI_lfaReadMT,cx
	mov	cx,cbBuff

	;*
	;*	Read from lfaReadMT into rgbBuff
	;*	cx	bytes to read
	;*
	;*	cb	bytes read
	;*	lfaReadMT
	;*		adjusted to next byte to be read
	;*	di	points to first INDS (smart about table header)

rldf_ReadMT:

	;*	seek to lfaReadMT

IFNDEF DOS5
	push	cx
	mov	ax,4200h
	mov	bx,hFile
	mov	dx,LO_lfaReadMT
	mov	cx,HI_lfaReadMT
	int	21h
	pop	cx
	jc	rldf_AbFileshort2
ELSE
	lea	ax,LO_tmp		; dummy
	cCall	DosChgFilePtr,<hFile,HI_lfaReadMT,LO_lfaReadMT,0,ss,ax>
	or	ax,ax
	jnz	rldf_AbFileshort2
ENDIF ;DOS5

	;*	read master table entries

	lea	dx,rgbBuff
IFNDEF DOS5
	mov	ah,3fh
	AssertEQ bx,hFile
	int	21h
	jc	rldf_AbFileshort2
	mov	cb,ax			; save bytes read
ELSE
	lea	ax,cb
	cCall	DosRead,<hFile,ss,dx,cx,ss,ax>
	or	ax,ax
	jnz	rldf_AbFileshort2
	mov	ax,cb
ENDIF ;DOS5

	or	ax,ax
	mov	ax,rerrBadRead
	jnz	@F
	jmp	rldf_AbFile		; check for read beyond EOF
@@:

	;*	cx:dx == lfaRead

	mov	dx,LO_lfaReadMT
	mov	cx,HI_lfaReadMT

	lea	di,rgbBuff		; di points to inds struct

	;*	if we just read from lfaMT, check magic, load number of
	;*		services, and increase di after INDT

	cmp	dx,LO_lfaMT
	jne	not_first_mt_read
	cmp	cx,HI_lfaMT
	jne	not_first_mt_read

	;*	check magic word

	mov	ax,rerrBadFormat
	mov	bx,rgbBuff+LO_rgchMagicIndt
					; check magic word ("DRV0")
	cmp	bx,'RD'
	jne	rldf_AbFileshort1	; invalid format
	mov	bx,rgbBuff+HI_rgchMagicIndt
	cmp	bx,'0V'
	je	@F
	jmp	rldf_AbFile		; invalid format
@@:

	;*	si == number of services

	mov	si,rgbBuff+cindsIndt	; si services in file

	;*	di => INDS

	lea	di,rgbBuff+rgindsIndt
not_first_mt_read:

	;*	adjust lfaReadMT

	add	dx,cb
	adc	cx,0
	mov	LO_lfaReadMT,dx
	mov	HI_lfaReadMT,cx

	;*
	;*	Load next service
	;*	si	number of services left to load
	;*	di	current inds structure
	;*

rldf_Load:

	;*	are we done?

	xor	ax,ax
	dec	si
	jge	@F
	jmp	rldf_done		; load completed
@@:

	;*	have we run out of services in this block?

	lea	ax,rgbBuff
	add	ax,cb
	cmp	ax,di
	ja	@F

	;*	read next block of INDS structures

	inc	si			;* retry this service
	mov	cx,cbBlock
	jmp	rldf_ReadMT
@@:

	;*	should we load this service?

	push	di

;*	* first see if operating system is supported
IFDEF DOS5
	test	[di].floadInds,floadProtMode
ELSE
	test	[di].floadInds,floadRealMode
ENDIF ;!DOS5
	jz	rldf_indtNotfound

	mov	ah,[di].indtInds

	;*	search rgindv

	mov	di,rgindv
	mov	cx,cindv
rldf_nextindv:
	cmp	ah,[di].indtIndv
	jne	@F
					; found indv
	mov	pindv,di
	clc				; flag load
	jmp	short rldf_endIndtLookup
@@:
	add	di,cbIndvMin
	loop	rldf_nextindv
rldf_indtNotfound:
	stc				; no service info, flag no load

rldf_endIndtLookup:

	pop	di
	jnc	@F
	jmp	rldf_loadnext		; unknown service
@@:

	;*
	;*	Load service segment
	;*

	;*	allocate code area

	mov	ax,[di].cbCodeInds
	inc	ax			; round up
	AssertNE ax,0
	shr	ax,1			; convert cb -> cw
	test	[di].floadInds,floadFixed

IFNDEF LATER
	AssertNZ			; only know about fixed segments
	mov	bx,fmemFixed
ENDIF

	cCall	<LpwAllocDriverMem>,<ax,bx>
	mov	cx,ax
	or	cx,dx
	jnz	@F
	mov	ax,rerrNoMemory
	jmp	rldf_AbFile
@@:
IFDEF DEBUG				; valid pointers are either ds:offset
					;  or other:0000
	mov	bx,ds
	cmp	bx,dx
	je	@F
	AssertEQ ax,0
@@:
ENDIF ;DEBUG

	;*	save pointer to code area

	mov	LO_lpwCSeg,ax
	mov	HI_lpwCSeg,dx

	;*	seek to service segment

	mov	dx,LO_lfaMT
	mov	cx,HI_lfaMT
	sub	dx,[di].LO_dlfaCodeInds	; calculate lfaCode
	sbb	cx,[di].HI_dlfaCodeInds
IFNDEF DOS5
	mov	ax,4200h
	mov	bx,hFile
	int	21h
	jc	rldf_AbCodeshort2
ELSE
	lea	ax,LO_tmp		; dummy
	cCall	DosChgFilePtr,<hFile,cx,dx,0,ss,ax>
	or	ax,ax
	jnz	rldf_AbCodeshort2
ENDIF ;DOS5

	;*	read in code segment

IFNDEF DOS5
	push	ds
	mov	ah,3fh
	mov	bx,hFile
	mov	cx,[di].cbCodeInds
	mov	dx,HI_lpwCSeg
	mov	ds,dx
	mov	dx,LO_lpwCSeg
	int	21h
	pop	ds
	jc	rldf_AbCodeshort2
ELSE
	lea	ax,cb
	cCall	DosRead,<hFile,HI_lpwCSeg,LO_lpwCSeg,[di].cbCodeInds,ss,ax>
	or	ax,ax
	jnz	rldf_AbCodeshort2
	mov	ax,cb
ENDIF ;DOS5

	cmp	ax,[di].cbCodeInds	; check for read error
	jne	rldf_AbCodeshort2

	;*	if load type is non-standard, this service is completed

	test	[di].floadInds,floadStandard
	jnz	@F
	jmp	rldf_loadnext		; non-standard driver
@@:

	;*	allocate data area

	mov	bx,HI_lpwCSeg		; es:bx points to service header
	mov	es,bx
	mov	bx,LO_lpwCSeg

	mov	ax,es:[bx].cbDataInsh
	inc	ax
	shr	ax,1			; convert cb -> cw
	cmp	ax,0
	jne	@F
	xor	ax,ax			; no data to allocate
	mov	dx,ax
	jmp	short rldf_load11	; continue with link
@@:
	push	ax			; save word count for later
	mov	cx,fmemFixed
	test	es:[bx].fNearDataInsh,0ffffh
	jz	@F
	mov	cx,fmemNear
	cmp	ax,cbNearMemServiceMax / 2
	jbe	@F
	mov	ax,rerrBadMemReq	; asking for too much near mem!
	jmp	rldf_AbCode
@@:
	cCall	<LpwAllocDriverMem>,<ax,cx>
	;*	put word count in cx
	pop	cx
	or	ax,ax			; 0? failure
	jnz	@F
	or	dx,dx
	jnz	@F
	mov	ax,rerrNoMemory
rldf_AbCodeshort1:
	jmp	rldf_AbCode

rldf_AbCodeshort2:
	mov	ax,rerrBadRead
	jmp	rldf_AbCode
@@:
rldf_load11:
IFDEF DEBUG				; valid pointers are either ds:offset
					;  or other:0000
	mov	bx,ds
	cmp	bx,dx
	je	@F
	AssertEQ ax,0
@@:
ENDIF ;DEBUG

	;*	patch code segment with pointer to data segment and pinos

	mov	es,HI_lpwCSeg			; es => code segment
	xor	bx,bx
	mov	es:[bx].LO_lpwDataInsh,ax
	mov	es:[bx].HI_lpwDataInsh,dx

;*	* set "pinos"
IFNDEF DOS5
	mov	es:[bx].pinosInsh,0
ELSE
	mov	es:[bx].pinosInsh,dataOffset inosDrv
ENDIF

IFDEF DOS5
	;*	create CS alias

	lea	ax,HI_lpwCSeg
	mov	bx,HI_lpwCSeg
	cCall	DosCreateCSAlias,<bx,ss,ax>
	or	ax,ax
	jz	@F
	mov	HI_lpwCSeg,bx		; restore selector on failure
	jmp	rldf_AbCode
@@:
	;*	restore registers used (es,ax,bx,cx,dx are important)
	;*	cx,dx not changed

	mov	es,HI_lpwCSeg
	xor	bx,bx
	mov	ax,es:[bx].LO_lpwDataInsh
ENDIF ;DOS5

	;*	clear data segment to zeros (assume word count in cx)

	;*	es:0 => code segment INSH
	;*	dx:ax => data segment
	;*	cx	 data size (words)

	push	es
	push	di
	mov	di,ax
	mov	es,dx
	xor	ax,ax
	rep stosw
	pop	di
	pop	es

	;*	get function count and rgpfn

	mov	dx,es:[bx].cpfnInsh	; function count
	add	bx,cbInshMin		; rgpfn

	;*	At this point we have:
	;*		es:bx => HI_lpwCSeg:rgpfn
	;*		dx    == cpfn
	;*		ds:di => inds
	;*		pindv OR psld => link info
	
	;*	link service to app

	push	di
	push	ds

	;*	check version

;	check version
;	link
;	set return values of indv struct

	mov	di,pindv
	cmp	dx,ss:[di].cpfnNeedMinIndv
	jae	@F				;* we have at least enough
rldf_linkBadver:
	mov	ax,rerrBadVersion
	stc
	jmp	short rldf_linkdone
@@:
	mov	cx,ss:[di].cpfnNeedMacIndv	;* the max # we want
	cmp	dx,cx
	jae	@F				;* just copy the ones we want
	mov	cx,dx				;* copy what we have < NeedMac
@@:
	mov	di,ss:[di].rglpfnIndv

	;*	link to app

	mov	dx,ds			; segment switch for rep stosw
	mov	ax,es
	mov	ds,ax
	mov	es,dx
	;	ds => HI_lpwCSeg
	;	es => DGROUP

	push	cx			; save cfpn for later

	push	cx
	push	di
	shl	cx,1
	mov	ax,ds
	rep stosw			; fill app jump table with segment value
	pop	di
	pop	cx

@@:					; fill in offsets
	mov	ax,[bx]
	mov	es:[di],ax
	inc	bx
	inc	bx
	add	di,4
	loop	@B

	pop	cx			; restore cpfn

	;*	set return values in indv

	mov	bx,pindv
	mov	ss:[bx].cpfnLoadedIndv,cx
	mov	cx,HI_lpwCSeg
	mov	ss:[bx].psLoadedIndv,cx
	clc				; linkage completed

rldf_linkdone:
	pop	ds
	pop	di
	jc	rldf_AbData

rldf_loadnext:

	add	di,cbIndsMin
	jmp	rldf_Load

rldf_AbData:
	;*	Code and data segments allocated but couldn't link to app.
	;*	Free data then go on to free code and close hFile.

	push	ax			; return code in ax
	mov	ax,HI_lpwCSeg
	mov	es,ax
	mov	ax,es:LO_lpwDataInsh
	mov	dx,es:HI_lpwDataInsh
	cCall	<far ptr FreeDriverMem>,<dx,ax>
	pop	ax
	
rldf_AbCode:
	;*	Something went wrong before completing code segment that
	;*	was allocated - free it and close hFile.

	push	ax			; return code in ax
	mov	ax,LO_lpwCSeg
	mov	dx,HI_lpwCSeg
	cCall	<far ptr FreeDriverMem>,<dx,ax>
	pop	ax
	
rldf_done:
rldf_AbFile:
rldf_Abort:

cEnd	RerrLoadDrvFd


;********** RerrLoadDrv **********
;*	entry:	szFile => full path
;*		rgindv => cindv INDV records
;*	* Loads drivers from given file
;*	exit:	see RerrLoadDrvFd


rlds_badopen:
	mov	ax,rerrBadFile		; restrict error returned
	jmp	short rlds_end

;----------------------------------------

cProc	RerrLoadDrv, <PUBLIC,FAR>,<DI,SI>
    parmW	szFile
    parmW	rgindv
    parmW	cindv
    localW	hFile
cBegin	RerrLoadDrv

	;*	open file

IFDEF	DOS5

	lea	ax,hFile
	lea	bx,action
	cCall	DosOpen,<ss,szFile,ss,ax,ss,bx,0,0,0,01h,openRO,0,0>
	or	ax,ax
	jnz	rlds_badopen

ELSE	; !DOS5

	mov	dx,szFile

	mov	bx,dx
	mov	ax,[bx]			; Get first two letters
	or	al,20h			; If the file is "B:xxx" on a single
	cmp	ax,chDrivePhantom	;   floppy system, then no can do.
	je	rlds_badopen

	mov	ax,3d00h
	int	21h
	mov	hFile,ax
	jc	rlds_badopen

ENDIF	; !DOS5

	cCall	RerrLoadDrvFd,<hFile, rgindv, cindv>

	push	ax			; return code in ax
IFNDEF DOS5
	mov	ah,3eh			; close file
	mov	bx,hFile
	int	21h
ELSE
	cCall	DosClose,<hFile>
ENDIF ;DOS5
	pop	ax			; ignore return code from close

rlds_end:

cEnd	RerrLoadDrv


;********** RerrLoadCwDrvFd **********
;*	entry:	hFile => valid file handle
;*	* Loads kbd and csd drivers from given file
;*	exit:	same as RerrLoadDrvFd

cProc	RerrLoadCwDrvFd, <PUBLIC,FAR>
    parmW	hFile
cBegin	RerrLoadCwDrvFd

	mov	ax,dataOffset rgindvCw
	mov	cx,cindvCw
	cCall	RerrLoadDrvFd,<hFile, ax, cx>

cEnd	RerrLoadCwDrvFd


;********** RerrLoadCwDrv **********
;*	entry:	szFile => full file name of driver
;*	* Loads kbd and csd drivers from given file
;*	exit:	same as RerrLoadDrv

cProc	RerrLoadCwDrv, <PUBLIC,FAR>
    parmW	szFile
cBegin	RerrLoadCwDrv

	mov	ax,dataOffset rgindvCw
	mov	cx,cindvCw
	cCall	RerrLoadDrv,<szFile, ax, cx>

cEnd	RerrLoadCwDrv


sEnd	KERNEL

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\mousedat.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	mousedat.asm : data for mouse input control

	include kernel.inc


;----------------------------------------------------------------------------

sBegin	DATA
    assumes DS,DGROUP

ayNil	EQU	253				;* see user\screen.inc
globalB	ayMouse,ayNil

sEnd	DATA

;----------------------------------------------------------------------------

sBegin	BSS
    assumes DS,DGROUP

;* PUBLIC
globalB	fMousePresent,0				;* TRUE => mouse present

;* PRIVATE
globalB	axMouse,0
globalW	sstMouse,0

globalB	fMouseOn,0				;* TRUE => mouse on

IFDEF MOUSE_SWAP
globalB fSwapButton,0				;* TRUE => reverse buttons
ENDIF ;MOUSE_SWAP

sEnd	BSS

;----------------------------------------------------------------------------

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\osspec.asm ===
;*
;*	CW : Character Windows
;*
;*	osspec.asm : jump table for OS specific routines (DUAL only)

	include cmacros.inc
	include version.inc
	include _osspec.inc			;* defines OSSPEC_ENTRIES

;*****************************************************************************

sBegin	DATA

externW	fProtectMode

sEnd	DATA

;*****************************************************************************


OSSPEC_DEF	MACRO	label,os		;* external refernces
	externFP	<label&os>
ENDM


OSSPEC_LABEL	MACRO	label,os		;* jump table, exported labels
	PUBLIC	label
label:
	jmp	label&os
ENDM


OSSPEC_NOLABEL	MACRO	label,os		;* alternate jump table
	jmp	label&os
ENDM


OSSPEC_OS2PROC	MACRO	label,os		;* protect mode only procedure
	PUBLIC	label
label:
IFDEF	DEBUG
	mov	cx,fProtectMode
	jcxz	@F
	jmp	label&OS2
@@:
	jmp	os2_only
ELSE	;!DEBUG
	jmp	label&OS2
ENDIF	;!DEBUG
ENDM


OSSPEC_DOS3PROC	MACRO	label,os		;* real mode only procedure
	PUBLIC	label
label:
IFDEF	DEBUG
	mov	cx,fProtectMode
	jcxz	@F
	jmp	dos3_only
@@:
ENDIF	;DEBUG
	jmp	label&DOS3
ENDM


;*****************************************************************************

createSeg   OSSPEC_TEXT,OSSPEC_TEXT,BYTE,PUBLIC,CODE


;* externFP	CowAssertFailed ;* in _osspec.inc already


OSSPEC_ENTRIES	OSSPEC_DEF,OS2
OSSPEC_ENTRIES	OSSPEC_DEF,DOS3

OSSPEC_OS2ONLY	OSSPEC_DEF,OS2
OSSPEC_DOS3ONLY	OSSPEC_DEF,OS2
OSSPEC_DOS3ONLY	OSSPEC_DEF,DOS3

sBegin	OSSPEC_TEXT
	assumes CS,OSSPEC_TEXT
	assumes DS,DATA

	PUBLIC	rgfnosspec,rgfnosspec3

;*	* rgfnosspec must preceed rgfnosspec3 and the two tables must be
;*	* contiguous!!

rgfnosspec:

;*	General code
	OSSPEC_ENTRIES	OSSPEC_LABEL,OS2

;*	OS/2 only procs
	OSSPEC_OS2ONLY	OSSPEC_LABEL,OS2

;*	Stubs for OS/2 (see stubs.asm)
	OSSPEC_DOS3ONLY	OSSPEC_LABEL,OS2

rgfnosspec3:

;*	General code
	OSSPEC_ENTRIES	OSSPEC_NOLABEL,DOS3

;*	Stubs for DOS3 (see stubs.asm)
	OSSPEC_OS2ONLY	OSSPEC_NOLABEL,DOS3

;*	DOS3 only procs
	OSSPEC_DOS3ONLY	OSSPEC_NOLABEL,DOS3

;*	* mode specific entry points

IFDEF	DEBUG
os2_only:
	cCall	CowAssertFailed
	DB	"Protect mode only proc called during real mode!$"
ENDIF	;DEBUG


IFDEF	DEBUG
dos3_only:
	cCall	CowAssertFailed
	DB	"Real mode only proc called during protect mode!$"
ENDIF	;DEBUG


sEnd	OSSPEC_TEXT

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\prtsc5.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	prtsc.asm : ^PrtSc stuff.

	include kernel.inc
	include inscr.inc		;* for inst


;----------------------------------------------------------------------------

sBegin	DATA
    assumes DS,DATA

sEnd	DATA

;----------------------------------------------------------------------------

sBegin	INIT
    assumes CS,INIT
    assumes SS,DATA
    assumes DS,DATA

;----------------------------------------------------------------------------
;
; Reroute interrupt 05 (^PrtSc) if necessary.
;
;   entry:  ds:bx -> inst structure.
;
;   preserve BX!

    assumes CS,INIT
    assumes DS,DGROUP
    assumes SS,DGROUP
    assumes ES,NOTHING

cProc	ReroutePrtSc,<FAR,PUBLIC,ATOMIC>
cBegin	nogen	; ReroutePrtSc

	retf

cEnd	nogen	; ReroutePrtSc

sEnd	INIT

;----------------------------------------------------------------------------

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\pbi.inc ===
;*
;*	COW : Character Oriented Windows
;*
;*	pbi.inc : PBI structure

PBI	STRUC
	psEnviron	DW	?
	offCmdLine	DW	?
	psCmdLine	DW	?
	offFcb1		DW	?
	psFcb1		DW	?
	offFcb2		DW	?
	psFcb2		DW	?
PBI	ENDS
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\prtsc3.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	prtsc.asm : ^PrtSc stuff.

	include kernel.inc
	include inscr.inc		;* for inst


;----------------------------------------------------------------------------

externFP	<HandlerInt05Dead>

;----------------------------------------------------------------------------

sBegin	DATA
    assumes DS,DATA

externB	fGrabInt05
externW	OFF_pfnHdlrInt05
externW	SEG_pfnHdlrInt05

sEnd	DATA

;----------------------------------------------------------------------------

sBegin	INIT
    assumes CS,INIT
    assumes SS,DATA
    assumes DS,DATA

;----------------------------------------------------------------------------
;
; Reroute interrupt 05 (^PrtSc) if necessary.
;
;   entry:  ds:bx -> inst structure.
;
;   preserve BX!

segROM	equ	0F000h

    assumes CS,INIT
    assumes DS,DGROUP
    assumes SS,DGROUP
    assumes ES,NOTHING

cProc	ReroutePrtSc,<FAR,PUBLIC,ATOMIC>
cBegin	ReroutePrtSc

	cmp	fGrabInt05,0			; If latch is dropped, int05
	jne	dontgrab			;   is already rerouted okay.

	mov	ax,SEG_pfnHdlrInt05		; AX:DX -> the original
	mov	dx,OFF_pfnHdlrInt05		;   int05 vector.

	cmp	ax,segROM			; If the old int05 didn't
	jne	@F				;   point to ROM, use it.

	test	[bx].finstInst,finstGraphics	; If we're not going to gfx
	jz	@F				;   mode, use old int05.

	mov	ax,SEG kernelBase		; Gfx mode w/ ROM int05:
	mov	dx,kernelOffset HandlerInt05Dead ;   reroute to dead routine.

@@:
	push	ds
	mov	ds,ax				; DS:DX -> new int05 vector.
    assumes ds,NOTHING
	mov	ax,2505h
	int	21h
	pop	ds
    assumes ds,DGROUP

dontgrab:

cEnd	ReroutePrtSc

sEnd	INIT

;----------------------------------------------------------------------------

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\promptc.c ===
/*
	COW : Character Oriented Windows

	prompt.c : Default PromptSwapDisk routine
		(english only, app should provide their own)
*/

#define COW
#include <cow.h>
#include <itl.h>
#include <udialog.h>

STATIC char szDrive[] = "Please insert in drive ?:";
#define cchPleaseInsert	25


VOID FARPUBLIC PromptSwapDisk(char far *, WORD);



VOID FARPUBLIC
PromptSwapDisk(lszPath, ifile)
/*
  -- build the prompt string and call message box to get the swap disk
	replaced
  -- NOTE: "lszPath" must be copied before calling MessageBox
	(we can at most call MessageBox at this time)
*/
char far * lszPath;
WORD	ifile;
	{
	REGISTER char *pchSrc;
	REGISTER char *pchDest;
	char	szBuff[50];

	Unreferenced(ifile);

	pchDest = szBuff;
	pchSrc = "Cannot find ";
	while ((*pchDest++ = *pchSrc++) != '\0')
		;
	pchDest--;
	/* now copy the name */
	InitSpecialMessageBox(lszPath);
	szDrive[cchPleaseInsert - 2] = lszPath[0];

	/* copy the string */
	while ((*pchDest++ = *lszPath++) != '\0')
		;

	MessageBox(szBuff, szDrive, NULL, MB_RETRY);
	EndSpecialMessageBox();
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\mouses3.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	mouses3.asm : DOS 3 version for mouse save routines

	title	mouses3 - Mouse save stuff

	include kernel.inc


;*****************************************************************************

sBegin	DATA
    assumes DS,DGROUP

externB	fMousePresent				;* TRUE => mouse present

sEnd	DATA

;*****************************************************************************

IFDEF MOUSE_EXTRAS

sBegin	MOUSE			;* discardable MOUSE segment
    assumes CS,MOUSE
    assumes SS,DATA
    assumes DS,DATA


;********** CbSizeMouseState **********
;*	entry:	n/a
;*	* determine size of save buffer for mouse save
;*	exit:	AX = size in bytes (0=> not supported).

cPublic	CbSizeMouseState,<ATOMIC>
cBegin	CbSizeMouseState

	xor	ax,ax				;* assume failure
	cmp	fMousePresent,al
	je	end_cbsize

	xor	bx,bx			; Won't be changed if not supported
	mov	ax,21				;* save mouse state
	int	33H
	mov	ax,bx				;* AX = cb
end_cbsize:	;* ax = cb

cEnd	CbSizeMouseState



;********** SaveMouseState **********
;*	entry:	lpbBuffer = buffer of proper size (from CbSizeMouseState()).
;*	* save mouse state
;*	exit: n/a	

cPublic	SaveMouseState,<ATOMIC>
    parmD lpbBuffer
cBegin	SaveMouseState
	les	dx,lpbBuffer
	mov	ax,22
	int	33H
cEnd	SaveMouseState



;********** RestoreMouseState **********
;*	entry:	lpbBuffer = buffer previously save (by SaveMouseState)
;*	* save mouse state
;*	exit: n/a	

cPublic	RestoreMouseState,<ATOMIC>
    parmD lpbBuffer
cBegin	RestoreMouseState
	les	dx,lpbBuffer
	mov	ax,23
	int	33H
cEnd	RestoreMouseState


sEnd	MOUSE

ENDIF ;MOUSE_EXTRAS

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\sstack.inc ===
;*
;*	CW : Character Windows
;*
;*	sstack.inc : Stack save/restore macros


;********* SetStackToDds **********
;*	entry:	SS:SP/BP => either main or linked stack
;*		bpSaveThunk must be 0
;*		parm fMaySwap => swap may occur => make real frame
;*	* if linked stack then move stack to DDS
;*	exit:	ssSaveThunk, spSaveThunk and bpSaveThunk set if stack changed
;*		save ax and bx in axSaveThunk and bxSaveThunk

SetStackToDds	MACRO	fMaySwap
	LOCAL	ok_stack
	AssertEQ bpSaveThunk,0
	mov	axSaveThunk,ax
	mov	bxSaveThunk,bx
	mov	ax,SEG DGROUP			;* DDS
	mov	bx,ss
	cmp	ax,bx
	je	ok_stack
;*	* make frame if may swap
IF fMaySwap
	inc	bp
	push	bp
	mov	bp,sp
ENDIF
;*	* save stack etc
	mov	spSaveThunk,sp
	mov	ssSaveThunk,ss
	mov	bpSaveThunk,bp
;*	* switch stacks (AX => DDS)
	AssertEQ ss:[ssOldStack],ax
	mov	bp,ss:[bpOldStack]
	cli
	mov	ss,ax
	mov	sp,ss:[pStackMin]
	sti

ok_stack:
ENDM ;SetStackToDds


;********** RestoreStackFromDds **********
;*	entry:	state as setup from SetStackToDds
;*		parm fMaySwap => swap may occur => remove real frame
;*	* restore stack if necessary
;*	exit:	SS:SP/BP => real stack, ax and bx restored from ax/bxSaveThunk
;*	* does not trash any other registers

RestoreStackFromDds	MACRO fMaySwap
	LOCAL	ok_stack

	cmp	bpSaveThunk,0
	je	ok_stack
	xor	bp,bp
	xchg	bp,bpSaveThunk
	cli
	mov	ss,ssSaveThunk
	mov	sp,spSaveThunk
	sti

;*	* restore frame if may have swapped
IF fMaySwap
	pop	bp
	dec	bp
ENDIF

ok_stack:
	mov	ax,axSaveThunk
	mov	bx,bxSaveThunk
ENDM ;RestoreStackFromDds
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\setjmp.asm ===
;*
;*	CW : Character Windows
;*
;*	setjmp.asm : SetJmp/DoJmp for non-pcode fixed segments (CMerge)

	title	setjmp - setjmp/dojmp for non-pcode

	include kernel.inc
	include galloc.inc


;*****************************************************************************

;*	* Native Code ENV structure (see "qsetjmp.h")
ENVN	STRUC
	spEnv		DW	?	;* saved sp (must be even !)
	ipEnv		DW	?	;* ip to jump to in case of DoJmp
	psEnv		DW	?	;* segment to jump to (must be fixed)
	bpEnv		DW	?	;* saved bp
ENVN	ENDS

;*****************************************************************************

sBegin	DATA
    assumes DS,DGROUP

sEnd	DATA


sBegin	BSS
    assumes DS,DGROUP

sEnd	BSS

;*****************************************************************************

externFP ThrowStack

sBegin	KERNEL		;* code must be fixed for SetJmp/DoJmp
    assumes CS,KERNEL
    assumes DS,DGROUP
    assumes SS,DGROUP


;********** SetJmpFixed **********
;* FAR PASCAL ENTRY POINT
;*	entry: penv = near pointer to ENV structure
;*	* fill ENV structure, return 0

cProc	SetJmpFixed,<FAR,PUBLIC,ATOMIC>
cBegin	nogen

	pop	ax
	pop	dx			;* DX:AX = return address
	pop	bx			;* BX => env

;*	* stack is now empty
	mov	ds:[bx].spEnv,sp
	mov	ds:[bx].ipEnv,ax
	mov	ds:[bx].psEnv,dx
	mov	ds:[bx].bpEnv,bp

	push	dx
	push	ax

	xor	ax,ax			;* return 0
	RETF

cEnd	nogen



;********** DoJmpFixed **********
;* FAR PASCAL ENTRY POINT
;*	entry:	penv = pointer to ENV
;*		wRet = word return value (better not be 0)
;*	* Jump to state saved in ENV
;*	exit:	never!

cProc	DoJmpFixed,<FAR,PUBLIC,ATOMIC>
cBegin	nogen

	pop	ax
	pop	ax			;* forget return address

	pop	ax			;* return value
	AssertNE ax,0
	pop	bx			;* penv

;*	* Throw the stuff off the stack
	Save	<bx,ax>
	cCall	ThrowStack,<ds:[bx].bpEnv>

	mov	bp,ds:[bx].bpEnv	;* set BP (stack has been thrown)
	mov	sp,ds:[bx].spEnv	;* set SP
;*	* push jump address on new stack
	push	ds:[bx].psEnv		;* return segment
	push	ds:[bx].ipEnv		;* return offset

;*	* ax = return value
	RETF

cEnd	nogen


sEnd	KERNEL

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\startup.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	startup.asm : kernel init for DOS 3/5 non-swapped

	include kernel.inc
	include	indrv.inc
	include inscr.inc		;* for inst

;----------------------------------------------------------------------------

IFDEF DUAL

externFP	<FInitScreen>
externFP	<DosExit>

ENDIF ;DUAL

;----------------------------------------------------------------------------

sBegin	DATA

IFDEF	DOS5

ifdef	Debug
staticB		fVersionPrinted,0
externB		<szVerCow, szVerCowMax>
endif	; Debug

externB		inosDrv			;* INOS info (from loaddrv.asm)

ENDIF	; DOS5

externDP	<pwndFocus>		;* for restoring focus

sEnd	DATA

;----------------------------------------------------------------------------

externFPublic	<EnableKeyboard>
externFP	<FlushKeyEvents>

externFPublic	<FEnableMouse>
externFPublic	<EndScreen>				;* (private)

externFP	<FInitMouse>				;* from mouse.asm
externFP	<EndMouse>				;* from mouse.asm

externFPublic	<FInitScreenInternal>			;* (private)

IFDEF	DOS5

externFP	<DosGetInfoSeg>
externFP	<FInitSysTimer>				;* from ktimer5.asm
externFP	<EndSysTimer>				;* from ktimer5.asm

ifdef	Debug
externFP	<VioWrtTty>
endif	; Debug

ENDIF	; DOS5

;----------------------------------------------------------------------------

sBegin	INIT
    assumes CS,INIT
    assumes SS,DATA
    assumes DS,DATA


;********** FInitCow **********
;*	entry : n/a
;*	* hook in all Cow things
;*	exit : AX = TRUE (1) if ok, FALSE (0) if error

cPublic	FInitCow,<FAR,ATOMIC>
cBegin	FInitCow

IFDEF	DOS5
;*	* for DOS5, get Global info (before any possible messages)
	mov	bx,dataOffset inosDrv.sdGlisInos
	PushArg	<ds, bx>			;* lpsdGlis
	mov	ax,dataOffset inosDrv.sdLoisInos
	PushArg	<ds, ax>			;* lpsdLois
	cCall	DosGetInfoSeg
	or	ax,ax
	jnz	init_error
ENDIF	;DOS5

IFDEF	DOS5
ifdef	Debug					; Print COW Version stamp.
	TEST	fVersionPrinted,0FFH
	JNZ	skip_message
	MOV	fVersionPrinted,1

	mov	bx,dataOffset szVerCow
	mov	cx,dataOffset szVerCowMax
	sub	cx,bx				;* cx = cch + 1
	xor	ax, ax
	cCall	VioWrtTty,<dsbx, cx, ax>
	or	ax,ax
	jnz	init_error
;;;;;	int	3			;* start in the debugger !!!

skip_message:
endif	; Debug
ENDIF	;DOS5

IFDEF DOS5
	cCall	FInitSysTimer
	or	ax,ax
	jz	init_error
ENDIF ;DOS5

	ExitTrueUnless init_error

cEnd	FInitCow

;----------------------------------------------------------------------------

IFDEF	DOS5
ifdef	Debug

cProc	Trap,<PUBLIC, FAR, ATOMIC>
cBegin
	BREAKPOINT
cEnd

endif	; Debug
ENDIF	;DOS5

IFNDEF DUAL ;!DUAL
;********** FInitScreen **********
;* COW PUBLIC ENTRY
;*	entry: pinst => INST structure (NULL => re-init previous mode)
;*	* Initialize screen & mouse
;*	exit: AX = 1 if ok, 0 if error

cProc	FInitScreen,<PUBLIC, FAR, ATOMIC>	;* all calls atomic
    parmW pinst
cBegin	FInitScreen

	cCall	FInitScreenInternal, <pinst>
	or	ax,ax
	jz	@F
	cCall	FInitMouse
	mov	bx,pinst
	test	[bx].finstInst,finstDisableMouse
	jz	@F
	xor	ax,ax
	cCall	FEnableMouse,<ax>		;* turn mouse off
	mov	ax,sp
@@:

cEnd	FInitScreen
ENDIF ;!DUAL

;********** BackToCow **********
;*	* after a LeaveCow -- re-establish COW environment

cPublic BackToCow, <ATOMIC>
parmW	fRestoreScreenMode

cBegin	BackToCow

	cCall	FInitCow
	AssertNE	ax,0

	mov	cx,fRestoreScreenMode
	jcxz	@F

	xor	ax,ax
	cCall	FInitScreen,<ax>		;* bring screen back

	cCall	FEnableMouse,<sp>

;;;	cCall	SetFocus, <pwndFocus>	; ??? Is this needed ???
@@:
cEnd	BackToCow

sEnd	INIT


;*****************************************************************************

sBegin	EXIT
    assumes CS,EXIT
    assumes SS,DATA
    assumes DS,DATA



IFNDEF DUAL ;!DUAL
;********** EndCow **********
;*	entry : n/a
;*	* Exit from COW system (unhook everything)
;*	exit : n/a

labelFP	<PUBLIC, EndCow>
ENDIF ;!DUAL


;********** LeaveCow **********
;*	entry : fClearScreen => should we clear the screen
;*	* leave COW, like EndCow but perhaps clear the screen
;*	exit : n/a

cPublic	LeaveCow,<ATOMIC>
    parmW fClearScreen
cBegin	LeaveCow

	xor	ax,ax
	cCall	EnableKeyboard, <ax>
	cCall	FlushKeyEvents
IFDEF DOS5
	cCall	EndSysTimer
ENDIF ;DOS5
	cCall	EndMouse
	cCall	EndScreen,<fClearScreen>

cEnd	LeaveCow


IFDEF DUAL
;********** ExitKernel / exit (ex) **********
;*	entry : ex = exit code
;*	* Exit from COW system (everything should already be unhooked)
;*	exit : never return to caller - return to system

cPublic ExitKernel,<ATOMIC>
   parmB ex
cBegin	ExitKernel
	cCall	DosExit,<1,ex>
cEnd	ExitKernel
ENDIF ;DUAL


sEnd	EXIT


;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\utildrv.asm ===
;*
;*	CW : Character Windows
;*
;*	utildrv.asm : installable driver utility routines

	include kernel.inc
	include kmem.inc
	include indrv.inc
	include inscr.inc
	include	inkbd.inc
	include insyd.inc
	include	_loaddrv.inc

;*****************************************************************************

;*	App call backs for memory management

externFP	<LpwAllocDriverMem,FreeDriverMem>

;*****************************************************************************

sBegin	KERNEL
    assumes CS,KERNEL
    assumes DS,DGROUP
    assumes SS,DGROUP


;********** FreeIndv ***************
;*	entry:	pindv => indv of the service to be freed
;*	* Frees memory allocated to for the given service
;*	* NOTE: any routine pointers into this service will be invalid
;*	*	and are not fixed up, a new service must be loaded before
;*	*	any calls

cProc	FreeIndv, <PUBLIC,FAR>
    parmW	pindv
cBegin	FreeIndv

	mov	bx,pindv
	mov	es,[bx].psLoadedIndv
	mov	ax,es:LO_lpwdataInsh
	mov	dx,es:HI_lpwdataInsh
	Save	<es>
	cCall	<far ptr FreeDriverMem>,<dx,ax>
	xor	ax,ax
	cCall	<far ptr FreeDriverMem>,<es,ax>

cEnd	FreeIndv


sEnd	KERNEL

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\togequ.inc ===
;***	TOGEQU.ASM - Equates needed for MSDOS Manager's toggle code
;
;   By Eric K. Evans, Microsoft Corp, May 1987
;


multMGR     EQU     18h 		; Stub's/Manager's Int 2Fh multiplex
					;  number

; Int 2Fh subfunction numbers

TOGINST     EQU      0h 		; Installation check
TOGRUN	    EQU      1h 		; Run request
TOGREG	    EQU     45h 		; Register Manager
TOGDEREG    EQU     6Bh 		; Deregister Manager


; Return codes

TOGSUC	    EQU      0h 		; Success
TOGERR	    EQU    0FFh 		; Failure
TOGSTUB     EQU     80h 		; Stub is installed
TOGMGR	    EQU    0FFh 		; Manager is installed and registered


; Values for the fToggle flag

FT_NOTINI	EQU	-1		; Toggling hasn't been initialized yet.
FT_NOTTOGGLED	EQU	 0		; The Manager is not toggled.
FT_TOGGLED	EQU	 1		; The Manager is toggled.
FT_LOCKED	EQU	 2		; The Manager is running at task time
					;  so toggle users are locked out.


; SafeMemory subfunctions (this file is probably the wrong place for these)

SM_HIGH 	EQU	0		; Allocate memory high
SM_LOW		EQU	1		; Allocate memory low
SM_EITHER	EQU	2		; Allocate memory high or low


SM_LOWLIMIT	EQU	2000h		; Highest posssible low memory address
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\_loaddrv.inc ===
;*	_loaddrv.inc


cINDSBlock	EQU	1
cbBlock		EQU	cINDSBlock * cbIndsMin
cbBuff		EQU	cbIndtMin + cbBlock - cbIndsMin
					; table header plus service block
					;  (INDT contains one INDS)

cbDataInsh	EQU	LO_lpwDataInsh	; from indrv.inc
fNearDataInsh	EQU	HI_lpwDataInsh

IFDEF DOS5
openRO		EQU	00000000000100000b
			;DWFrrrrrISSSrAAA
ENDIF ;DOS5
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\stubs.asm ===
;*
;*
;*	stubs.asm	Stubs for OS specific routines that exist under
;*			one OS only.
;*

;*******************************************************************************

	include	kernel.inc

;*******************************************************************************


sBegin	KERNEL

	PUBLIC	AccessSwapFileOS2
	PUBLIC	BindSegmentOS2
	PUBLIC	LockSegmentOS2
	PUBLIC	UnLockSegmentOS2
	PUBLIC	CbFreeMemOS2
	PUBLIC	PrepareWildOS2
	PUBLIC	FMatchWildOS2
	PUBLIC	FValidDirOS2
	PUBLIC	CbFreeEmmOS2
	PUBLIC	CbInitEmmOS2
	PUBLIC	CompactEmmOS2
	PUBLIC	EndEmmOS2
	PUBLIC	LcbSizeSbOS2
	PUBLIC	FRestoreSbStateOS2
	PUBLIC	FInitSbSaveOS2
	PUBLIC	FSaveSbStateOS2

IFDEF	DEBUG
	PUBLIC	FCheckGlobalHeapOS2
	PUBLIC	InitJmpSegOS2
ENDIF	;DEBUG

assumes	CS,KERNEL
assumes	DS,nothing
assumes	ES,nothing


CbFreeMemOS2:
CbFreeEmmOS2:
CompactEmmOS2:
EndEmmOS2:
FRestoreSbStateOS2:
	retf

AccessSwapFileOS2:
LockSegmentOS2:
UnLockSegmentOS2:
FValidDirOS2:
LcbSizeSbOS2:
FInitSbSaveOS2:
FSaveSbStateOS2:
IFDEF	DEBUG
InitJmpSegOS2:
ENDIF	;DEBUG
	retf	2

PrepareWildOS2:
FMatchWildOS2:
IFDEF	DEBUG
FCheckGlobalHeapOS2:
ENDIF	;DEBUG
	retf	4

BindSegmentOS2:
CbInitEmmOS2:
	retf	6


sEnd	KERNEL


;*******************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\tools\catresp.c ===
/*
	CW : Character Windows

	catresp.c : helper program for New Make

	Flags "-string" => break lines using string

	1st parm = file to concatenate to
	2nd parm = "@tmp" -- response file containing file name list

	ConCatenate response file to end of specified file
*/

#include <stdio.h>
#include <fcntl.h>


main(argc, argv)
int argc;
char *argv[];
	{
	FILE *	pfileList;
	FILE *	pfileOut;
	int	ch;			/* char + EOF */
	int	cchLine;
	char *	szBreak = NULL;

	if (argc == 4 && argv[1][0] == '-')
		{
		szBreak = &argv[1][1];
		argv++; argc--;
		}

	if (argc != 3 || argv[2][0] != '@')
		{
		printf("usage: catresp [-string] <out_file> @<response_file>\n");
		exit(1);
		}

	if ((pfileList = fopen(argv[2]+1, "rt")) == NULL)
		{
		printf("catresp: can't open response file\n");
		exit(1);
		}

	if ((pfileOut = fopen(argv[1], "at")) == NULL)
		{
		printf("catresp: can't open output file\n");
		exit(1);
		}

	cchLine = 0;
	while ((ch = getc(pfileList)) != EOF)
		{
		if (ch == '\n')
			cchLine = 0;
		else
			cchLine++;

		// optional break lines
		if (szBreak != NULL && ch == ' ' && cchLine > 70)
			{
			/* end that line, start another */
			fputs(szBreak, pfileOut);
			ch = '\n';
			cchLine = 0;
			}
		putc(ch, pfileOut);
		}

	exit(0);
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\_osspec.inc ===
;*
;*	CW : Character Windows
;*
;*	_osspec.inc : OSSPEC_ENTRIES macro for OS specific jump table
;*			construction


;*******************************************************************************


;*	Entries for OS specific routines go here!

;*	* For easy manipulation all entries must be:	mac	`label',os


OSSPEC_ENTRIES	MACRO	mac,os

;*	* kernel
	mac	BackToCow,os
IFDEF	DEBUG
	mac	CowAssertFailed,os
	mac	CowAssertFailedSz,os
	mac	CowAssertFailedLine,os
	mac	CwOutSz,os
	mac	_cwoutsz,os
ENDIF	;DEBUG
	mac	EndMouse,os
	mac	EndSysTimer,os
	mac	ExitKernel,os
	mac	FEnableMouse,os
	mac	FInitMouse,os
	mac	FInitSysTimer,os
	mac	GetCodeHandle,os
	mac	GlobalAlloc,os
	mac	GlobalFree,os
	mac	GlobalHandle,os
	mac	GlobalLock,os
	mac	GlobalReAlloc,os
	mac	GlobalUnlock,os
	mac	LeaveCow,os
	mac	MouseConditionalOff,os
	mac	MouseShowCursor,os
	mac	ReroutePrtSc,os
	mac	RerrExec,os
	mac	RerrLoadDrv,os
	mac	RerrLoadCwDrv,os
	mac	RerrLoadDrvFd,os
	mac	RerrLoadCwDrvFd,os
	mac	SetMouseCursor,os
	mac	SetMousePos,os
	mac	ThrowStack,os

;*	* kernel/cbox
	mac	GetProgDir,os

;*	* user
	mac	DisableInterrupts,os
	mac	EnableInterrupts,os
	mac	FFindFirst,os
	mac	FFindNext,os
	mac	FindClose,os
	mac	AtrOfPath,os
	mac	GetCurDrive,os
	mac	SetCurDrive,os
	mac	GetCurDir,os
	mac	FSetCurDir,os
	mac	FValidDrive,os

;*	* sbmgr
	mac	BltSb,os
	mac	CbAllocSb,os
	mac	CbReallocSb,os
	mac	CbSizeSb,os
	mac	FInitSegTable,os
IFNDEF	DEBUG
	mac	FInitSegOnce,os
ENDIF	;!DEBUG
	mac	FreeSb,os
	mac	GlobalSize,os
	mac	LcbAllocSb,os
	mac	LcbReallocSb,os
	mac	LpLockEs,os
	mac	LpLockHp,os
	mac	LpReLoadHp,os
	mac	SetEs,os
	mac	SetSbCur,os
	mac	SetSbCur2,os
	mac	UnlockEs,os
	mac	UnlockHp,os

;*	* math
	mac	ChkFor87,os

;*	* inter
IFDEF	DEBUG
;*	* non-debug winter.dmd is os-general
	mac	BltBh,os
	mac	_BltBh,os
	mac	CNatRet,os
	mac	DoJmp,os
	mac	NatRet,os
	mac	PcodeBegin,os
	mac	RetNative0,os
	mac	RetNative1,os
	mac	RetNative2,os
	mac	RetToolBox0,os
	mac	RetToolBox1,os
	mac	RetToolBox2,os
	mac	StartNMeas,os
	mac	StopNMeas,os
	mac	StartUMeas,os
	mac	StopUMeas,os
	mac	XOSExit,os
	mac	LTrickCall,os
	mac	StartCowMeas,os
	mac	StopCowMeas,os
	mac	TrickReturn,os
ENDIF	;DEBUG

;*	* cbox

	mac	AccessFile,os
	mac	BuildDriveTable,os
	mac	CbGlobalCompact,os
	mac	CchHandshakePrint,os
	mac	CchReadDosHnd,os
	mac	CchWriteDoshnd,os
	mac	CloseFile,os
	mac	CreateFile,os
	mac	DateStamp,os
	mac	DeleteFile,os
	mac	Exit,os
	mac	FiniWordTsr,os
	mac	FNetworkDrive,os
	mac	FPrintBuffer,os
	mac	FRemoveableDrive,os
	mac	FSetCodePage,os
	mac	FSetPrinter,os
	mac	FSetPrinterHandshake,os
	mac	GetCodePage,os
	mac	GetCountry,os
	mac	GetDate,os
	mac	GetDiskSpace,os
	mac	GetFileAttr,os
	mac	GetFileLength,os
	mac	GetTime,os
	mac	InChar,os
	mac	InitWordTsr,os
	mac	LszGetEnv,os
;	mac	PromptSwapDisk,os
	mac	ReadFile,os
	mac	ReadMouse,os
	mac	RenameFile,os
	mac	SeekFileSector,os
	mac	FSetFilePointer,os
	mac	VerDOSCur,os
	mac	WinMain,os
	mac	WriteFile,os

	mac	IdentifyWinOldApVersion,os
	mac	ClipboardCompact,os
	mac	CloseClipboard,os
	mac	EmptyClipboard,os
	mac	GetClipboardData,os
	mac	GetClipboardDataSize,os
	mac	OpenClipboard,os
	mac	SetClipboardData,os

ENDM


OSSPEC_OS2ONLY	MACRO	mac,os

ENDM


OSSPEC_DOS3ONLY	MACRO	mac,os

;*REVIEW: is this needed ???
	mac	AccessSwapFile,os
	mac	BindSegment,os
	mac	LockSegment,os
	mac	UnLockSegment,os
	mac	CbFreeMem,os
	mac	PrepareWild,os
	mac	FMatchWild,os
	mac	FValidDir,os
	mac	CbFreeEmm,os
	mac	CbInitEmm,os
	mac	CompactEmm,os
	mac	EndEmm,os
	mac	LcbSizeSb,os
	mac	FRestoreSbState,os
	mac	FInitSbSave,os
	mac	FSaveSbState,os
IFDEF	DEBUG
	mac	FCheckGlobalHeap,os
	mac	InitJmpSeg,os
ENDIF	;DEBUG

ENDM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\kernel\_inos.asm ===
;*
;*	CW : Character Windows
;*
;*	_inos.asm : the INOS structure data for OS/2


;*****************************************************************************

INOS_ENTRY MACRO label
	LOCAL	lpfnHere
	externFP <label>
lpfnHere DD	label
	Assert	<(lpfnHere-inosDrv) EQ lpfn&label&Inos>
ENDM	; INOS_ENTRY

	Assert	<($-inosDrv) EQ sdGlisInos>
	DW		0			;* sdGlis

	Assert	<($-inosDrv) EQ sdLoisInos>
	DW		0			;* sdLois

	DW		cpfnInosMin		;* # of entries in INOS

	;* Configuration info
	INOS_ENTRY	DosGetVersion
	INOS_ENTRY	DosGetEnv
	INOS_ENTRY	DosDevConfig
	INOS_ENTRY	DosGetCtryInfo
	INOS_ENTRY	DosGetDBCSEv
	INOS_ENTRY	DosGetInfoSeg

	;* Low level hardware access
	INOS_ENTRY	DosDevIOCtl
	INOS_ENTRY	DosPortAccess

	;* Linkage to DLL entries (for ones not listed here)
	INOS_ENTRY	DosGetModHandle
	INOS_ENTRY	DosLoadModule
	INOS_ENTRY	DosGetProcAddr

	;* Threads
	INOS_ENTRY	DosCreateThread
	INOS_ENTRY	DosSetPrty
	INOS_ENTRY	DosExit

	;* File Routines
	INOS_ENTRY	DosOpen
	INOS_ENTRY	DosClose
	INOS_ENTRY	DosRead
	INOS_ENTRY	DosWrite

	;* Monitor Routines
	INOS_ENTRY	DosMonOpen
	INOS_ENTRY	DosMonClose
	INOS_ENTRY	DosMonReg
	INOS_ENTRY	DosMonRead
	INOS_ENTRY	DosMonWrite

	;* Memory Allocation
	INOS_ENTRY	DosAllocSeg
	INOS_ENTRY	DosReAllocSeg
	INOS_ENTRY	DosFreeSeg

	;* Common VIO Routines
	INOS_ENTRY	VioGetBuf
	INOS_ENTRY	VioShowBuf
	INOS_ENTRY	VioGetConfig
	INOS_ENTRY	VioGetMode
	INOS_ENTRY	VioSetMode
	INOS_ENTRY	VioGetState
	INOS_ENTRY	VioSetState

	INOS_ENTRY	VioGetCurType
	INOS_ENTRY	VioSetCurType
	INOS_ENTRY	VioGetCurPos
	INOS_ENTRY	VioSetCurPos

	INOS_ENTRY	VioGetFont
	INOS_ENTRY	VioSetFont
	INOS_ENTRY	VioGetCP
	INOS_ENTRY	VioSetCP
	INOS_ENTRY	VioScrollUp

	;* Common Kbd Routines
	INOS_ENTRY	KbdOpen
	INOS_ENTRY	KbdClose
	INOS_ENTRY	KbdCharIn
	INOS_ENTRY	KbdGetStatus
	INOS_ENTRY	KbdSetStatus

	;* Misc
	INOS_ENTRY	DosBeep
	INOS_ENTRY	VioGetPhysBuf

	;* NOTE: can't use INOS_ENTRY for internal CW routines
	DD	CwBeginIO
	DD	CwEndIO

cpfnInosMin	equ	($ - inosDrv) / (cbInosMin)	;* cpfn

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\tools\cowstrip.h ===
/*
    -- std.h standard types
*/

#define TRUE 1
#define FALSE 0

#define CDECL cdecl
#define CONST

#define FOREVER while(1)
#define BLOCK

#ifdef D86
#define szROText "rt"
#endif
#ifdef X86
#define szROText "r"
#endif

typedef int BOOL;
typedef char *SZ;
typedef unsigned char BYTE;
typedef BYTE *PB;
typedef unsigned short WORD;
typedef WORD *PW;
typedef unsigned long LONG;

void CDECL ProcessArgs(int, char **);
void CDECL FatalError();
SZ CDECL SzGetArg(void);

extern SZ szNameProgram;	/* Program name (not extension) */
extern int cargCur;		/* Current # of args left */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\tools\echotime.c ===
/*
	COW : Character Oriented Windows

	echotime.c : a simple ECHOTIME utility
		echo arguements, replace /t with ctime time

*/

#include <stdio.h>
#include <fcntl.h>

main(argc, argv)
int argc;
char *argv[];
	{
	int iarg;

	for (iarg = 1; iarg < argc; iarg++)
		{
		char *pch = argv[iarg];

		while (*pch)
			{
			if (*pch == '/' && *(pch+1) == 't')
				{
				long time();
				long l = time(NULL);
				char *ctime();
				char *sz = ctime(&l);

				sz[strlen(sz)-1] = '\0';
				printf("%s", sz);
				pch += 2;
				}
			else
				putchar(*pch++);
			}
		putchar(' ');
		}
	putchar('\n');
	exit(0);
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\tools\cowseg.c ===
/*
	COW : Character Oriented Windows

	cowseg.c : segment order fix utility

	NOTE : This is my (SAR) copy of the DOSSEG tool.
	It only allows addition of the Force segment comment to MASM .OBJ files
*/

#include <stdio.h>
#include <fcntl.h>

#ifdef X86
#define O_BINARY 0
#endif

#define cbInsert 6
char rgbInsert[] = { 0x88, 3, 0, 0, 0x9e, 0x29 };	/* insert Force seg ordering */

#define cbCopy 1024


main(argc, argv)
int argc;
char *argv[];
	{
	int	fdIn, fdOut;
	unsigned char rgbCopy[cbCopy];
	int	cb;
	int	cbHeader;

	if (argc != 3)
		{
		printf("usage: cowseg <src file> <dest file>\n");
		exit(1);
		}

	if ((fdIn = open(argv[1], O_RDONLY | O_BINARY)) == -1)
		{
		printf("cowseg: can't open %s\n", argv[1]);
		exit(1);
		}

	if ((fdOut = open(argv[2], O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, 0777)) == -1)
		{
		printf("cowseg: can't open %s\n", argv[2]);
		exit(1);
		}

	/* read in first 3 bytes: should be 0x80, word size of record */
	if (read(fdIn, rgbCopy, 3) != 3 ||
	    rgbCopy[0] != 0x80 ||		/* valid THEADR ? */
	    rgbCopy[2] != 0 ||			/* < 255 chars ? */
	    read(fdIn, rgbCopy+3, rgbCopy[1]) != rgbCopy[1])
		{
		printf("cowseg: file %s in invalid format\n", argv[1]);
		exit(1);
		}
	cbHeader = 3 + rgbCopy[1];

	/* Copy the header + insert portion */
	if (write(fdOut, rgbCopy, cbHeader) != cbHeader ||
	    write(fdOut, rgbInsert, cbInsert) != cbInsert)
		{
		printf("cowseg: write error\n");
		exit(1);
		}

	/* copy the rest of the file */
	do
		{
		if ((cb = read(fdIn, rgbCopy, cbCopy)) == -1)
			{
			printf("cowseg: read error\n");
			exit(1);
			}

		if (write(fdOut, rgbCopy, cb) != cb)
			{
			printf("cowseg: write error\n");
			exit(1);
			}
		} while (cb>0);

	close(fdIn);
	close(fdOut);
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\tools\cowstrip.c ===
/*
	cowstip.c : CWINDOWS.H stripper

	cowstrip : given list of files, read then in, include from BEGIN to END
		NOTE : begin & end symbols MUST be on the start of a line
	Also strips whitespace lines (i.e. blank)
	Output to stdout
*/



#include <stdio.h>
#include "cowstrip.h"

char szBegin[] = "/***BEGIN_PUBLIC***/";
char szEnd[] = "/***END_PUBLIC***/";

int cchBegin, cchEnd;

void
PrUsage()
	{
	printf("%s [-w] {files ...}\n", szNameProgram);
	printf("Includes files from '%s' to '%s'\n", szBegin, szEnd);
	}



main(argc, argv)
int argc;
char *argv[];
	{
	char chFlag;
	SZ szFn;

	ProcessArgs(argc, argv);

	if (cargCur < 1)
		{
		PrUsage();
		exit(1);
		}

	Init();

	while ((szFn = SzGetArg()) != NULL)
		StripFile(szFn);

	exit(0);
	}



Init()
	{
	cchBegin = strlen(szBegin);
	cchEnd = strlen(szEnd);
	}


#ifdef STRIP_WHITE
BOOL
FWhiteLine(sz)
/*
  -- return TRUE if line is all whitespace
*/
SZ sz;
	{
	while (*sz)
		if (*sz == ' ' || *sz == '\t')
			sz++;
		else
			return FALSE;
	return TRUE;
	}
#endif /*STRIP_WHITE*/



StripFile(szFn)
/*
  -- strip file
*/
SZ szFn;
	{
	FILE *pfileIn;
	BOOL fOut = FALSE;
	char rgchBuffer[256];
	SZ szIn, fgets();

	if ((pfileIn = fopen(szFn, szROText)) == NULL)
		FatalError("can't open %s\n", szFn);

	while ((szIn = fgets(rgchBuffer, sizeof(rgchBuffer), pfileIn)) != NULL)
		{
		int cch = strlen(szIn);
		if (szIn[cch-1] != '\n')
			FatalError("file %s, line too long : %s\n", szFn, szIn);
		szIn[cch-1] = '\0';

		if (!fOut && strncmp(szIn, szBegin, cchBegin) == 0)
			fOut = TRUE;
		else if (fOut && strncmp(szIn, szEnd, cchEnd) == 0)
			fOut = FALSE;
#ifdef STRIP_WHITE
		else if (fOut && !FWhiteLine(szIn))
#else
		else if (fOut)
#endif
			/* we must output this line */
			puts(szIn);
		/* else ignore */
		}
	fclose(pfileIn);
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\alarm.c ===
/*
	COW : Character Oriented Windows
	(COW USER EVENT)

	alarm.c : alarm function
*/

#define COW
#include <cow.h>

#include <uevent.h>
#include <uutil.h>
#include <kinput.h>

#include "event.h"


STATIC DWORD ticksAlarm = 0L;
PUBLIC PWND pwndAlarm = NULL;


PUBLIC VOID FARPUBLIC
SetAlarm(pwnd, ctick)
/*
  -- set alarm to send a WM_ALARM message to window "pwnd" in "ctick" ticks
*/
PWND pwnd;
WORD ctick;
	{
	StartPublic();
	pwndAlarm = pwnd;
	KickTimer((DWORD) ctick);	/* set kick time before finding time */
	ticksAlarm = ClockTicks() + ctick;
	StopPublic();
	}



PUBLIC VOID FARPUBLIC
KillAlarm()
	{
	StartPublic();
	pwndAlarm = NULL;
	KickTimer(ctickIdle);			/* idle timer thread */
	StopPublic();
	}



PRIVATE BOOL FARPRIVATE
FCheckAlarm(pmsg)
MSG *pmsg;
	{
	if (pwndAlarm != NULL && ClockTicks() >= ticksAlarm) 
		{
		pmsg->pwnd = pwndAlarm;
		pmsg->message = WM_ALARM;
		KillAlarm();
		return TRUE;
		}
	return FALSE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\tools\iterate.c ===
/*
	CW : Character Windows

	iterate.c : helper program for New Make

	argv[1] = program string to run (%s replaced by file name)
	argv[2] = "@tmp" -- response file containing file name list

	-- iterate over the file name list running program
*/

#include <stdio.h>
#include <fcntl.h>


char	rgch[5000];		/* buffer for response file */
				/* Nmake spews out just 1 line */

main(argc, argv)
int argc;
char *argv[];
	{
	FILE *	pfileList;

	if (argc != 3 || argv[2][0] != '@')
		{
		printf("usage: iterate <cmd> @<response_file>\n");
		exit(1);
		}

	if ((pfileList = fopen(argv[2]+1, "rt")) == NULL)
		{
		printf("iterate: can't open response file\n");
		exit(1);
		}

	while (fgets(rgch, sizeof(rgch), pfileList) != NULL)
		{
		char *	sz = rgch;

		while (*sz != '\0' && *sz != '\n')
			{
			/* skip whitespace */
			if (*sz == ' ' || *sz == '\t')
				sz++;
			else
				{
				/* we have a name */
				char *	szFile;
				char	szT[128];

				/* we have a file name */
				szFile = sz;
				while (1)
					{
					sz++;
					if (*sz == '\0' || *sz == '\n')
						{
						/* end of line & name */
						*sz = '\0';
						break;
						}
					else if (*sz == ' ' || *sz == '\t')
						{
						/* just end of name */
						*sz++ = '\0';
						break;
						}
					}

				sprintf(szT, argv[1], szFile);
				printf("\t%s\n", szT);
				if (system(szT) != 0)
					{
					printf("error running command\n");
					exit(2);
					}
				}
			}
		}
	exit(0);
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\tools\mkdrv.c ===
/*
	mkdrv driver_file [ [(-|/)flags] service ]*

	Make driver_file from the given services.

	Valid service file extensions are:
		.kbd
		.csd
		.gsd
		.prd
		.gpd
		.syd
		.scd

	Valid flags are: L[fsrp]	 (default is Lfs).
		f => fixed
		s => standard, dual mode (real+protect)
		r => standard service, real mode only
		p => standard service, protect mode only

	ex. mkdrv dos3.drv -Lfs std3.kbd -Lf std3.prd

	See "Installable Drivers Interface (1.00.01)" and "API Guide
	Installable Drivers (2.20.02)" for more details.

	Revision history:
	88.03.24 mikedon	original
	88-04-22 scottra	add real/protect, general extensions, ...
	88-07-12 johng		add SCD (indtSerialComm)

*/


#include <ctype.h>
#include <string.h>
#include <stdio.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <fcntl.h>
#include <memory.h>

#include <cow.h>
#include <indrv.h>


#define	floadDefault	(floadFixed | floadStandard | floadAnyMode)

#define	lcbCodeMax	((long)(65535 - sizeof(INSH)))
#define iindsMax	20
#define cbBuffMax	(8 * 1024)


char		rgb[cbBuffMax];
unsigned	cbBuff = 0;
int		fload;

char	szMagic[5] = szMagicDRV;

typedef struct
	{
	char *	sz;
	WORD	indt;
	} SVI;		/* service info */

SVI rgsvi[] =
	{
	{ ".kbd",	indtKeyboard },
	{ ".csd",	indtCharacterScreen },
	{ ".gsd",	indtGraphicScreen },
	{ ".prd",	indtCharacterPrinter },
	{ ".gpd",	indtGraphicPrinter },
	{ ".syd",	indtSystem },
	{ ".scd",	indtSerialComm },
	{ NULL,		indtNil }
	};

void		main(int, char *([]));
char		IndtFromSzFile(char *);
void		SetFlagsSz(char *);
void		SetFlagsDefaults();
void		OutputFlush(int);
void		OutputHFile(int, int, unsigned long);
void		OutputB(int, void *, unsigned);
void		OutputTableHead(int, unsigned);
void		OutputPinds(int, INDS *);
void		OutputTail(int, unsigned long);


#define	block	/* block */


void
main(csz, rgsz)
int  csz;
char *rgsz[];
	{
	char		**hsz, **hszMax;
	INDS		rginds[iindsMax], *pinds, *pindsMax;
	long		lfaMac = 0;
	int		hFileOut;
	unsigned	cinds;

#ifdef DEBUG
	block
		{
		/* display commandline parameters */

		int i;
	
		for (i = 0; i < csz; i++)
			{
			printf("%s\n", rgsz[i]);
			}
		}
#endif

	/* check usage */

	if (csz <= 1)
		{
		printf("\nUsage: mkdrv output_file [[-Lfds] service]*\n");
		exit(1);
		}

	/* open output file */

	hFileOut = open(rgsz[1], O_CREAT | O_TRUNC | O_WRONLY | O_BINARY, S_IWRITE);
	if (hFileOut == -1)
		{
		printf("cannot write %s\n", rgsz[1]);
		exit(5);
		}

	/* process given parameters */

	hszMax = &(rgsz[csz]);
	pindsMax = &(rginds[iindsMax]);
	SetFlagsDefaults();
	for (	hsz = &(rgsz[2]), pinds = rginds;
		hsz < hszMax && pinds < pindsMax;
		hsz++)
		{
		char ch;

		if ((ch = **hsz) == '-' || ch == '/')
			{
			/* process flags */

			SetFlagsSz(*hsz + 1);
			}
		else
			{
			/* assume we have a file name of a service, process it */

			int  hFile;
			long lcbCode;
	
			hFile = open(*hsz, O_BINARY | O_RDONLY);
			if (hFile == -1)
				{
				printf("cannot read %s\n", *hsz);
				exit(2);
				}
			lcbCode = filelength(hFile);
			if (lcbCode > lcbCodeMax)
				{
				printf("%s is too big (%l > %l)\n", *hsz, lcbCode, lcbCodeMax);
				exit(3);
				}

			/* build INDS record for this service */

			if ((pinds->indt = IndtFromSzFile(*hsz)) == indtNil)
				{
				printf("warning: %s is an unknown service\n", *hsz);
				}
			pinds->fload = (fload == 0) ? floadDefault : fload;
			pinds->cbCode = (int)lcbCode;
			pinds++;

			/* transfer service to output file */

			OutputHFile(hFileOut, hFile, lcbCode);
			lfaMac += lcbCode;

			SetFlagsDefaults();
			}
		}

	/* check for too many services */

	if (hsz < hszMax)
		{
		printf("too many services (%d max)\n", iindsMax);
		exit(4);
		}

	/* output master table */

	pindsMax = pinds;
	cinds = pindsMax - rginds;
	OutputTableHead(hFileOut, cinds);
	block
		{
		/* output INDS records */

		long dlfa = 0;
	
		while (pinds-- > rginds)
			{
			dlfa += pinds->cbCode;
			pinds->dlfaCode = dlfa;
			OutputPinds(hFileOut, pinds);
			}
		}

	/* output file end header (INDH) */

	OutputTail(hFileOut, (unsigned long)(sizeof(INDT) + (cinds - 1) * sizeof(INDS) + sizeof(INDH)));
		/* cinds - 1: 1 INDS already in INDT */
	OutputFlush(hFileOut);
	close(hFileOut);

	exit(0);
	}


void
SetFlagsDefaults()
	{
	fload = 0;
	}


void
SetFlagsSz(pch)
char *pch;
	{
	/* set flag values accordingly */

	char ch = *pch;

	if (ch == 'L')
		{
		++pch;
		while ((ch = *pch++) != '\0')
			{
			if (ch == 'f')
				fload |= floadFixed;
			else if (ch == 's')
				fload |= floadStandard | floadAnyMode;
			else if (ch == 'r')
				fload |= floadStandard | floadRealMode;
			else if (ch == 'p')
				fload |= floadStandard | floadProtMode;
			else
				printf("bad load flag: %c\n", ch);
			}
		}
	else
		{
		printf("unknown flag: %c\n", ch);
		}
	}


char
IndtFromSzFile(szFile)
char *szFile;
	{
	/* return service type based on extension of service name
		(valid service names are assumed to be .xxx)
	*/

	unsigned cch = strlen(szFile);
	char    *pchExt;
	char    szExt[5];
	SVI *	psvi;

	if (cch < 4)
		{
		return(indtNil);
		}

	block
		{
		/* lower the file extension */

		char *pch = szExt;
		char *pchExtMax = szFile + cch;
	
		for (pchExt = pchExtMax - 4; pchExt < pchExtMax;)
			{
			*pch++ = tolower(*pchExt);
			pchExt++;
			}
		szExt[4] = '\0';
		pchExt = szExt;
		}

	/* determine service type */
	for (psvi = rgsvi; psvi->sz != NULL; psvi++)
		if (strcmp(pchExt, psvi->sz) == 0)
			return(psvi->indt);

	return(indtNil);
	}


/* Output Routines:

	Nothing is flushed from the buffer until it is filled.  Only
	OutputFlush does a write.  OutputHFile and OutputB transfer
	data to the buffer and flush accordingly.

*/


void
OutputFlush(hFile)
int hFile;
	{
	if (cbBuff > 0 && cbBuff != write(hFile, rgb, cbBuff))
		{
		printf("...write error\n");
		exit(10);
		}
#ifdef DEBUG
	printf("wrote %u bytes\n", cbBuff);
#endif
	cbBuff = 0;
	}


void
OutputHFile(hFileOut, hFile, lcb)
int      hFileOut;
int      hFile;
unsigned long lcb;
	{
	unsigned cbRead;

#ifdef DEBUG
	printf("process %lu bytes\n", lcb);
#endif
	while (lcb > 0)
		{
		if (cbBuff >= cbBuffMax)
			{
			OutputFlush(hFileOut);
			}
		cbRead = cbBuffMax - cbBuff;
		if ((unsigned long )cbRead > lcb)
			{
			cbRead = (int)lcb;
			}
		if (cbRead != read(hFile, &(rgb[cbBuff]), cbRead))
			{
			printf("...read error\n");
			exit(20);
			}
#ifdef DEBUG
		printf("read %u bytes\n", cbRead);
#endif
		cbBuff += cbRead;
		lcb -= cbRead;
		}
	}


void
OutputB(hFile, pb, cb)
int      hFile;
void     *pb;
unsigned cb;
	{
	unsigned cbMove;

#ifdef DEBUG
	printf("transfer %u bytes\n", cb);
#endif
	while (cb > 0)
		{
		if (cbBuff >= cbBuffMax)
			{
			OutputFlush(hFile);
			}
		cbMove = cbBuffMax - cbBuff;
		if (cbMove > cb)
			{
			cbMove = cb;
			}
		memcpy(&(rgb[cbBuff]), pb, cbMove);
		cbBuff += cbMove;
		cb -= cbMove;
		}
	}


void
OutputTableHead(hFileOut, cinds)
int      hFileOut;
unsigned cinds;
	{
	INDT indt;

	memcpy(indt.rgchMagic, szMagic, 4);
	indt.cinds = cinds;
#ifdef DEBUG
	printf("INDT: magic:%c%c%c%c, cinds:%u\n", indt.rgchMagic[0],
				       indt.rgchMagic[1],
				       indt.rgchMagic[2],
				       indt.rgchMagic[3],
				       indt.cinds);
#endif
	OutputB(hFileOut, &indt, sizeof(INDT) - sizeof(INDS));
		/* do not include the INDS in INDT */
	}


void
OutputPinds(hFileOut, pinds)
int  hFileOut;
INDS *pinds;
	{
#ifdef DEBUG
	printf("INDS: indt:%u, fload:%u, cbCode:%u, dlfaCode:%lu\n", pinds->indt, pinds->fload,
		pinds->cbCode, pinds->dlfaCode);
#endif
	OutputB(hFileOut, pinds, sizeof(INDS));
	}


void
OutputTail(hFileOut, dlfa)
int hFileOut;
unsigned long dlfa;
	{
	INDH indh;

	memcpy(indh.rgchMagic, szMagic, 4);
	indh.dlfaTable = dlfa;
#ifdef DEBUG
	printf("INDH: magic:%c%c%c%c, dlfaTable:%lu\n", indh.rgchMagic[0],
					indh.rgchMagic[1],
					indh.rgchMagic[2],
					indh.rgchMagic[3],
					indh.dlfaTable);
#endif
	OutputB(hFileOut, &indh, sizeof(indh));
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\tools\misc.c ===
/*
	-- COWSTRIP utilities
*/

#include <stdio.h>
#include "cowstrip.h"

/*	- PUBLIC VARIABLES - */
char *szNameProgram;	/* Program name (not extension) */
int cargCur;		/* # of args left */

#ifdef D86
char chDriveProgram;	/* Drive program was ran from */
#endif

static SZ *pszArgNext;


void CDECL
ProcessArgs(argc, argv)
int argc;
SZ argv[];
	{
	char *pch;
	char *szFn;
#ifdef D86
	char *strlwr();
#endif

	if (argc < 1)
		{
		printf("???? : fatal error argc = %d\n", argc);
		exit(1);
		}

	pszArgNext = &argv[1];
	cargCur = argc-1;

#ifdef D86
	pch = strlwr(argv[0]);
	if (pch[1] == ':' && pch[0] >= 'a' && pch[0] <= 'z')
		{
		chDriveProgram = pch[0];
		pch += 2;		/* skip drive */
		}
	else
		chDriveProgram = '\0';		/* no drive specified */
#endif

	szNameProgram = pch;		/* start of path (no drive) */

#ifdef D86
	/* First convert any '\\' into '/' */
	while (*pch != '\0')
		{
		if (*pch == '\\')
			*pch = '/';
		pch++;
		}
#endif

	for (pch--; pch >= pch; pch--)
		if (*pch == '/')
			{
			szNameProgram = pch+1;
			break;
			}
#ifdef D86
		else if (*pch == '.')
			{
			*pch = '\0';	/* forget extension */
			}
#endif
	}



SZ CDECL
SzGetArg()
/*
  -- return sz of next free arguement, return NULL if end
*/
	{
	SZ szRet;
	if (cargCur < 1)
		return NULL;
	cargCur--;
	szRet = pszArgNext[0];
	pszArgNext++;
	return szRet;
	}



void CDECL
FatalError(szFmt, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10)
CONST char *szFmt;
int v1, v2, v3, v4, v5, v6, v7, v8, v9, v10;
	{
	printf("%s: ERROR : ", szNameProgram);
	printf(szFmt, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10);
	exit(1);
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\box.c ===
/*
	COW : Character Oriented Windows
	(COW USER WINDOW)

	box.c : Boxes
*/

#define COW
#include <cow.h>

#include <uwindow.h>
#include <uscreen.h>
#include <uisa.h>
#include "window.h"
#include "screen.h"
#include "util.h"

#include "shadow.h"

/*	* Installable Boxes (init in FInitScreen()) */
PUBLIC char chShadow;
PUBLIC WORD diShadow = diShadowInit;

PUBLIC BOX PASCAL boxSingle;
PUBLIC BOX PASCAL boxDouble;

#ifdef WINDOW_OVERLAP

PUBLIC AX daxShadow = daxShadowInit;
PUBLIC AY dayShadow = dayShadowInit;

PUBLIC BOX PASCAL boxActiveWindowOut;
PUBLIC BOX PASCAL boxInactiveWindowOut;
PUBLIC BOX PASCAL boxActiveWindowIn;
PUBLIC BOX PASCAL boxInactiveWindowIn;

PRIVATE PWND pwndClip;

#endif /*WINDOW_OVERLAP*/



VOID FARPRIVATE
DrawBoxArc(pbox, parc, di, fRight, fBottom, szTitle)
/*
  -- draw box at absolute coordinates
  -- fRight and fBottom if FALSE will simplify the draw for scroll bars
*/
REGISTER BOX * pbox;
REGISTER ARC * parc;
WORD	di;
BOOL	fRight;
BOOL	fBottom;
char *	szTitle;
	{
	AX axLeft, axRight;
	AY ayTop, ayBottom;

	BeginDraw();

	axRight = parc->axRight - daxBorder;
	ayBottom = parc->ayBottom - dayBorder;

#ifdef WINDOW_OVERLAP
	if (pwndClip == NULL)
		{
#endif /*WINDOW_OVERLAP*/

	/* Corners */

	/* top left */
	CharOutAbs(parc->axLeft, parc->ayTop, pbox->chTopLeftCorner, di);
	/* top right */
	CharOutAbs(axRight, parc->ayTop, pbox->chTopRightCorner, di);

	/* bottom left */
	CharOutAbs(parc->axLeft, ayBottom, pbox->chBottomLeftCorner, di);
	/* bottom right */
	CharOutAbs(axRight, ayBottom, pbox->chBottomRightCorner, di);

#ifdef WINDOW_OVERLAP
		}
	else
		{
		if (parc->ayTop <= pwndClip->arcClipping.ayBottom)
			{
			if (parc->axLeft <= pwndClip->arcClipping.axRight)
				CharOutAbs(parc->axLeft, parc->ayTop, 
						pbox->chTopLeftCorner, di);
			if (parc->axRight <= pwndClip->arcClipping.axRight)
				CharOutAbs(axRight, parc->ayTop,
						pbox->chTopRightCorner, di);
			}
		if (parc->ayBottom <= pwndClip->arcClipping.ayBottom)
			{
			if (parc->axLeft <= pwndClip->arcClipping.axRight)
				CharOutAbs(parc->axLeft, ayBottom,
						pbox->chBottomLeftCorner, di);
			if (parc->axRight <= pwndClip->arcClipping.axRight)
				CharOutAbs(axRight, ayBottom,
						pbox->chBottomRightCorner, di);
			}
		}
			
#endif /*WINDOW_OVERLAP*/

	/* adjust for border */
	axLeft = parc->axLeft + daxBorder;
	ayTop = parc->ayTop + dayBorder;

#ifdef WINDOW_OVERLAP
	if (pwndClip != NULL)
		{
		axRight = min(axRight, pwndClip->arcClipping.axRight);
		ayBottom = min(ayBottom, pwndClip->arcClipping.ayBottom);
		}
#endif /*WINDOW_OVERLAP*/
	
	if (axLeft < axRight)
		{
		/* always fill top */
#ifdef WINDOW_OVERLAP
		if ((pwndClip == NULL)||
			(parc->ayTop <= pwndClip->arcClipping.ayBottom))
#endif /*WINDOW_OVERLAP*/
		FillArc(axLeft, parc->ayTop, axRight, ayTop, pbox->chTopSide, di);
		if (fBottom)
#ifdef WINDOW_OVERLAP
		if ((pwndClip == NULL)||
			(parc->ayBottom <= pwndClip->arcClipping.ayBottom))
#endif /*WINDOW_OVERLAP*/
			FillArc(axLeft, ayBottom, axRight, parc->ayBottom, pbox->chBottomSide, di);
		}

	if (ayBottom > ayTop)
		{
		/* always fill left */
#ifdef WINDOW_OVERLAP
		if ((pwndClip == NULL)||
			(parc->axLeft <= pwndClip->arcClipping.axRight))
#endif /*WINDOW_OVERLAP*/
		FillArc(parc->axLeft, ayTop, axLeft, ayBottom,
		    pbox->chLeftSide, di);
		if (fRight)
#ifdef WINDOW_OVERLAP
		if ((pwndClip == NULL)||
			(parc->axRight <= pwndClip->arcClipping.axRight))
#endif /*WINDOW_OVERLAP*/
			FillArc(axRight, ayTop, parc->axRight, ayBottom,
			    pbox->chRightSide, di);
		}

	if (szTitle != NULL)
#ifdef WINDOW_OVERLAP
	if ((pwndClip == NULL)||
		(parc->ayTop <= pwndClip->arcClipping.ayBottom))
#endif /*WINDOW_OVERLAP*/
		{
		WORD	cch;
		int	cchMac;

		/* print title at top */
		if ((cch = strlen(szTitle)) != 0 &&
		    (cchMac = parc->axRight - parc->axLeft - 4) > 0)
			{
			/* enough room for title */
			if (cch > cchMac)
				cch = cchMac;

#ifdef WINDOW_OVERLAP
			axLeft += (parc->axRight - daxBorder 
						- axLeft - cch) / 2;
			if (axLeft + cch > axRight)
				cch = (axRight > axLeft) ? axRight - axLeft : 0;
#else
			axLeft += (axRight - axLeft - cch) / 2;
#endif /*WINDOW_OVERLAP*/
#ifdef WINDOW_OVERLAP
			if (axLeft-1 < axRight)
#endif /*WINDOW_OVERLAP*/
			CharOutAbs(axLeft-1, parc->ayTop, (ACHAR) ' ', di);
#ifdef WINDOW_OVERLAP
			if (axLeft < axRight)
#endif /*WINDOW_OVERLAP*/
			TextOutAbs(axLeft, parc->ayTop, szTitle, cch, di);
#ifdef WINDOW_OVERLAP
			if (axLeft + cch < axRight)
#endif /*WINDOW_OVERLAP*/
			CharOutAbs(axLeft + cch, parc->ayTop, ' ', di);
			}
		}

	EndDraw();

	}



VOID FARPUBLIC
ShadowArc(parc)
/*
  -- throw a shadow at the right bottom of a box
*/
REGISTER PARC parc;
	{
	AssertSz(parc->axRight - parc->axLeft > daxShadow
	    && parc->ayBottom - parc->ayTop > dayShadow,
	    "Box too small to shadow");

#ifdef WINDOW_OVERLAP
	if (pwndClip == NULL)
#endif /*WINDOW_OVERLAP*/
	if (diShadow == 0 ||
	    parc->axRight + daxShadow > axMac ||
	    parc->ayBottom + dayShadow > ayMac)
		return;	/* no shadowing or too big to shadow */

#ifdef WINDOW_OVERLAP
	if (pwndClip != NULL)
		{
		/* fill right hand side */
		if ((parc->axRight < pwndClip->arcClipping.axRight) &&
		    (parc->ayTop + dayShadow <= pwndClip->arcClipping.ayBottom))
			FillArc(parc->axRight, parc->ayTop+dayShadow,
				min(parc->axRight + daxShadow,
					 pwndClip->arcClipping.axRight),
				min(parc->ayBottom,
					 pwndClip->arcClipping.ayBottom),
	   			chShadow, diShadow);

		/* now fill bottom */
		if ((parc->ayBottom < pwndClip->arcClipping.ayBottom) &&
		    (parc->axLeft + daxShadow <= pwndClip->arcClipping.axRight))
			FillArc(parc->axLeft+daxShadow, parc->ayBottom,
				min(parc->axRight + daxShadow,
					 pwndClip->arcClipping.axRight),
				min(parc->ayBottom + dayShadow,
					 pwndClip->arcClipping.ayBottom),
	    			chShadow, diShadow);
		}
	else
#endif /*WINDOW_OVERLAP*/
		{
	/* fill right hand side */
	FillArc(parc->axRight, parc->ayTop+dayShadow, parc->axRight+daxShadow,
	    parc->ayBottom, chShadow, diShadow);
	/* now fill bottom */
	FillArc(parc->axLeft+daxShadow, parc->ayBottom, parc->axRight+daxShadow,
	    parc->ayBottom+dayShadow, chShadow, diShadow);
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\button.c ===
/*
	COW : Character Oriented Windows
	(COW USER DIALOG)

	button.c : button functions
*/

#define COW
#include <cow.h>

#include <uwindow.h>
#include <uevent.h>
#include <vkey.h>
#include <uisa.h>
#include <kinput.h>

#include "dialog.h"
#include "event.h"
#include "window.h"
#include "util.h"
#include "screen.h"

#include "button.h"
#include "_button.h"


/* data for rendering */
BTR btrRadioButton =
	{
	chRadioButtonOff,
	'?',		/* must load from run-time character */
	chRadioButtonPrefix,
	chRadioButtonSuffix,
	'\0',		/* no greyed radio buttons */
	};

BTR btrCheckBox =
	{
	chCheckBoxOff,
	chCheckBoxOn,
	chCheckBoxPrefix,
	chCheckBoxSuffix,
	chCheckBoxGrey,
	};

/* forward */

STATIC VOID	DrawButton(PWND);
STATIC VOID	DrawCheckBox(PWND, BTR *);
STATIC VOID	DrawPushButton(PWND);
STATIC VOID	DrawBracketBox(PWND, WORD);
STATIC VOID	DrawAccel(PWND, RX, WORD, BOOL);
STATIC VOID	DoButton(PWND);



PRIVATE DWORD FARPUBLIC			/* WndProcs are PUBLIC */
ButtonWndProc(pwnd, message, wParam, lParam)
/*
  -- WndProc for handling button windows
*/
PWND pwnd;
WORD message, wParam;
DWORD lParam;
	{
	MSP msp;
	BYTE fUp = FALSE;

	switch (message)
		{
	case WM_PAINT:
		DrawButton(pwnd);
		break;

	case WM_SETFOCUS:
		Assert((pwnd->style & WS_SUBSTYLE) != BS_GROUP);
		Assert(pwnd == pwndFocus);
		SendMessage(pwnd->pwndParent, WM_DIALOG_SETFOCUS, pwnd->id, 0L);
		DrawButton(pwnd);
		break;

	case WM_WANTFOCUS:
		switch (pwnd->style & WS_SUBSTYLE)
			{
		default:
			break;	/* return TRUE => accept focus */
		case BS_GROUP:
ReturnFalse:
			return((DWORD) FALSE);	/* never accept focus */
			/*break*/
		case BS_RADIOBUTTON:
			/* Accept focus if button is on, or demanding it */
			if (BstOfWnd(pwnd) == bstOn || wParam & 1)
				goto ReturnTrue;
			else if (FFirstButton(pwnd))
				{
				REGISTER PWND pwndT = pwnd;
				/* first button -> are we in ninch ?? */

				do
					{
					pwndT = PwndButtonNext(pwndT);
					if (BstOfWnd(pwndT) == bstOn)
						goto ReturnFalse;
					}
				while (pwndT != pwnd);
				/* ninch state -- accept for first button */
				goto ReturnTrue;
				}
			else
				goto ReturnFalse;

			return (wParam);
			/*NOTREACHED*/
			}
		break;

	case WM_KILLFOCUS:
		Assert((pwnd->style & WS_SUBSTYLE) != BS_GROUP);
		SendMessage(pwnd->pwndParent,WM_DIALOG_KILLFOCUS,pwnd->id, 0L);
		SetFButtonDown(pwnd, FALSE);
		Assert(pwnd == pwndFocus);
		pwndFocus = NULL;	/* special signal for losing focus */
		DrawButton(pwnd);
		pwndFocus = pwnd;	/* restore it properly */
		break;

	case WM_MAKEACTIVE:
		DoButton(pwnd);
		break;		/* return TRUE */

	case WM_CHAR:
		/* return FALSE if key ignored */
		UndoRepeat(wParam, lParam);
		switch (wParam)
			{
		default:
			return((DWORD) FALSE);
			break;

		case ' ':
			if (!FButtonDown(pwnd) && pwnd->fEnabled)
				{
				SetFButtonDown(pwnd, TRUE);
				DrawButton(pwnd);
				}
			break;

		case VK_UP:
		case VK_LEFT:
			fUp = TRUE;
			/* fall through */

		case VK_DOWN:
		case VK_RIGHT:
			switch (pwnd->style & WS_SUBSTYLE)
				{
			default:
				return((DWORD) FALSE);
				break;

			case BS_RADIOBUTTON:
				{
				/* move within a radio group */
				REGISTER PWND pwndT = pwnd;

				/* move if current button is on or disabled,
				* (i.e. stay if off and enabled)
				*/
				if (BstOfWnd(pwnd) == bstOn || !pwnd->fEnabled)
					{
					/* move to next or prev */
					do
						{
						pwndT = PwndButtonNext(pwndT);
						}
					while (fUp &&
					   PwndButtonNext(pwndT) != pwnd);
					}
				/* move focus - change selection */
				SetFocus(pwndT);
				Assert(pwnd->pwndParent == pwndT->pwndParent);
				if (pwndT->fEnabled)
					DoButton(pwndT);
				}
				break;

			case BS_CHECKBOX:
			case BS_AUTOCHECKBOX:
				/* checkbox change */
				if (fUp != (BYTE) BstOfWnd(pwnd) &&
				    pwnd->fEnabled)
					DoButton(pwnd);
				break;
				}
			break;
			}
		break;

	case WM_LBUTTONUP:
		if (FCaptured(pwnd))
			ReleaseCapture();
		if (fButtonAction)
			{
			fButtonAction = FALSE;
			DoButton(pwnd);
			}
		break;

	case WM_KEYUP:
		if (FButtonDown(pwnd) && wParam == VK_SPACE)
			DoButton(pwnd);
		break;

	case WM_MOUSEMOVE:
		if (!fButtonAction)
			break;		/* ignore first movement */
	case WM_LBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
		fButtonAction = TRUE;
		if (wParam & MK_LBUTTON &&
		    (pwnd->style & WS_SUBSTYLE) != BS_GROUP)
			{
			/* if button down and mouse move */
			BOOL	fWasDown = FButtonDown(pwnd);

			msp.lParam = lParam;
			SetFButtonDown(pwnd, PtInRect((PRRC) &pwnd->arcWindow,
			    msp.s.ax, msp.s.ay));

			SetFocus(pwnd);	/* grab */

			if (FButtonDown(pwnd))
				{
				SetCapture(pwnd); /* trap all mouse events */
				if (fWasDown)
					goto ReturnTrue;	/* skip draw */
				}
			else
				{
				ReleaseCapture();
				    /* release mouse events to other windows */
				/* re-post the message to proper window */
				RePostMouseMessage(message, wParam, lParam);
				}

			DrawButton(pwnd);
			}
		break;
		}

ReturnTrue:
	return((DWORD) TRUE);
	}



STATIC VOID
DrawButton(pwnd)
/*
  -- draws a button (radio/push/checkbox) or groupbox
*/
REGISTER PWND pwnd;
	{
	switch (pwnd->style & WS_SUBSTYLE)
		{
	default:
		AssertSz(FALSE, "Invalid Button");
		break;

	case BS_RADIOBUTTON:
		btrRadioButton.chOn = chRadioButtonOn;	/* use run-time char */
		DrawCheckBox(pwnd, &btrRadioButton);
		break;

	case BS_CHECKBOX:
	case BS_AUTOCHECKBOX:
		DrawCheckBox(pwnd, &btrCheckBox);
		break;

	case BS_PUSHBUTTON:
	case BS_DEFPUSHBUTTON:
		DrawPushButton(pwnd);
		break;

	case BS_GROUP:
		DrawBorder(pwnd, &boxSingle, isaButton,
		    (char *) pwnd->szDialog);
		break;
		}
	}



STATIC VOID
DrawPushButton(pwnd)
/*
  -- Draw a pushbutton
*/
REGISTER PWND pwnd;
	{
	REGISTER WORD di;
	WORD	cch = CchRealLenSz((char *) pwnd->szDialog);
	BYTE	drx;
	RX	rxText;
	RRC	rrc;

	GetClientRrc(pwnd, &rrc);
	if (cch >= (drx = rrc.rxRight - rrc.rxLeft - daxPushButton))
		{
		/* button text too big (or just right) for window */
		rxText = daxPushButton / 2;
		cch = drx;
		}
	else
		{
		rxText = (RX) (((drx - cch + 1) / 2) + daxPushButton/2);
		}

	/* set cursor position */
	pwnd->axCursor = pwnd->arcClipping.axLeft + rxText;
#ifdef	KANJI
	pwnd->ayCursor = pwnd->arcClipping.ayTop;
#endif

	if (!fDrawItem)
		return;		/* don't actually draw yet */

	di = FButtonDown(pwnd) ? isaButtonDown :
	    ((pwnd->fEnabled) ? isaPushButton : isaButtonDisabled);

	FillRrc(pwnd, &rrc, ' ', di);

	DrawAccel(pwnd, rxText, di, !FButtonDown(pwnd));

	if (FButtonDown(pwnd))
		{
		/* button is down -> there better be no change in status */
		Assert(pwndFocus != NULL);
		/* Assert(pwndFocus == pwnd); -> removed because if you 
		   redraw button on a dlmKillFocus the focus is elsewhere */
		}
	else if (pwndFocus == NULL)
		{
		/* moving off a button (or init) -> restore to default */
		PWND pwndT;

		pwndT = PwndDefaultPushButton(PwndParent(pwnd));
		if (pwndT == pwnd)
			{
			/* losing focus, but we are the default */
			di = isaDialogAccel;	/* hilite this button */
			}
		else if (pwndT != NULL)
			{
			/* restore default button */
			Assert(pwndT->fEnabled);
			DrawBracketBox(pwndT, isaDialogAccel);
			}
		}
	else if (((pwndFocus->style & WS_TYPE) != WS_BUTTON ||
	     (((pwndFocus->style & WS_SUBSTYLE) != BS_PUSHBUTTON) &&
	      ((pwndFocus->style & WS_SUBSTYLE) != BS_DEFPUSHBUTTON))) &&
		(pwnd->style & WS_SUBSTYLE) == BS_DEFPUSHBUTTON)
		{
		/* focus is not a push button, but we are the default */
		di = isaDialogAccel;	/* hilite this button */
		}
	else if (pwnd == pwndFocus)
		{
		/* we are the focus, clear old default */
		PWND pwndT;

		pwndT = PwndDefaultPushButton(PwndParent(pwnd));
		if ((pwndT != pwnd)&&(pwndT != NULL))
			{
			Assert(pwndT->fEnabled);
			DrawBracketBox(pwndT, isaPushButton);
			}
		di = isaDialogAccel;	/* hilite this button */
		}
	DrawBracketBox(pwnd, di);

	/* cursor must be on for dialog tabbing on top line */
	Assert(pwnd->fCursorOn);
	Assert(pwnd->ayCursor = pwnd->arcClipping.ayTop);
	}



STATIC VOID
DrawBracketBox(pwnd, di)
/*
  -- draw brackets or box around a pushbutton
*/
REGISTER PWND pwnd;
WORD di;
	{
#ifdef BUTTON_LARGE
	BOX *	pbox;
	/* for large buttons, draw border instead */

	Assert(pwnd != NULL);
	pbox = &boxSingle;
	if (di == isaDialogAccel)
		{
		/* it has the focus => show as double border */
		pbox = &boxDouble;
		di = isaPushButton;
		}
	DrawBorder(pwnd, pbox, di, NULL);
#else
		{
		RRC rrc;

		Assert(pwnd != NULL);
		GetClientRrc(pwnd,&rrc);
		CharOut(pwnd, 0, 0, '<', di);
		CharOut(pwnd, rrc.rxRight-1, 0, '>', di);
		}
#endif /*BUTTON_LARGE*/
	}



STATIC VOID
DrawCheckBox(pwnd, pbtr)
/*
  -- draw a checkbox or radiobutton (depends on pbtr)
*/
REGISTER PWND pwnd;
REGISTER BTR *pbtr;
	{
	char ch;
	WORD di;

	di = (pwnd->fEnabled) ? isaButton : isaButtonDisabled;

	if ((BstOfWnd(pwnd)) == bstOff)
		ch = pbtr->chOff;
	else if (BstOfWnd(pwnd) == bstGreyed)
		ch = pbtr->chGrey;
	else
		ch = pbtr->chOn;

	BeginDraw();

	CharOut(pwnd, rxPrefix, 0, pbtr->chPrefix, di);
	CharOut(pwnd, rxButton, 0, ch, di);
	CharOut(pwnd, rxSuffix, 0, pbtr->chSuffix, di);

	DrawAccel(pwnd, rxButtonText, di, TRUE);

	EndDraw();

	pwnd->axCursor = pwnd->arcClipping.axLeft + rxButton;

	/* debug check that the cursor is in the correct position */
	Assert(pwnd->fCursorOn);
	Assert(pwnd->ayCursor == pwnd->arcClipping.ayTop);
	}



STATIC VOID
DrawAccel(pwnd, rx, di, fHilite)
/*
  -- draw text with optional accelerator in a window
  -- start at rx
*/
REGISTER PWND pwnd;
RX rx;
WORD di;
BOOL fHilite;		/* should we use isaDialogAccel ?? */
	{
	TextOut(pwnd, rx, 0, (char *) pwnd->szDialog, -1, di);

	if (pwnd->aclDialog == aclNil)
		return;

	if (fShowDlgAccel && pwnd->fEnabled)
		CharOut(pwnd, rx + IchAccel(pwnd), 0, ChAccel(pwnd),
		    fHilite ? isaDialogAccel : di);
	}




WORD FARPRIVATE
WButtonChecked(pwnd)
/*
  -- return state of button
  -- note : pwnd == window of the button !!
  -- for Radio/Push buttons, return TRUE if a button is "on"
  -- for checkboxes, return state (0,1 or 2 for ninch)
*/
PWND pwnd;
	{
	Assert(pwnd != NULL);
	return(BstOfWnd(pwnd));
	}



VOID FARPRIVATE
CheckRadioButton(pwndFirst, bnSet, fDisplay)
/*
  -- check a radiobutton in a group and uncheck all others in the group
  -- pwndFirst is the first button in the group (usually)
  -- bnSet is the button number to set (i.e. 0 based)
  -- if bnSet is invalid then no button will be set
  NOTE : we use the fact the uNinchRadio is -1 to get an invalid bn.
  NOTE : while we are at it, we assert that the button "id"s are sequential
  NOTE : if bnSet == 0, the pwndFirst does not have to be the first button
		in the group (and the order assertion is disabled).
*/
REGISTER PWND pwndFirst;
WORD bnSet;		/* index of button to set */
BOOL fDisplay;		/* TRUE => redraw it */
	 {
	REGISTER PWND pwnd = pwndFirst;
	Debug(WORD idCheck = pwndFirst->id);
	Debug(BOOL fDontCheckOrder = bnSet == 0);

	Assert(pwndFirst != NULL);
	Assert(bstOff == 0 && bstOn == 1);

	do
		{
		BYTE bst;
		AssertSz((pwnd->style & WS_SUBSTYLE) == BS_RADIOBUTTON,
		    "Invalid Radio Group");
		Assert(fDontCheckOrder || pwnd->id == idCheck++);

		bst = (BYTE) (bnSet-- == 0);
			/* 1 iff matching button */

		if (BstOfWnd(pwnd) != bst)
			{
			SetWndBst(pwnd, bst);
			if (fDisplay)
				DrawButton(pwnd);
			}
		pwnd = PwndButtonNext(pwnd);
		}
	while (pwnd != pwndFirst);
	}



VOID FARPRIVATE
CheckDlgButton(pwnd, bst, fDisplay)
/*
  -- set the state of a checkbox
  -- pwnd is a window pointer for a button
*/
REGISTER PWND pwnd;
WORD bst;
BOOL fDisplay;
	{
	Assert(pwnd != NULL);
	AssertSz(bst < bstMax, "Invalid button state");
	SetWndBst(pwnd, bst);
	if (fDisplay)
		DrawWindow(pwnd);
	}



STATIC VOID
DoButton(pwnd)
/*
  -- a button has been pushed
*/
REGISTER PWND pwnd;
	{
	SetFButtonDown(pwnd, FALSE);

	/* If auto then toggle the state */
	if (pwnd->style & BS_AUTO)
		{
		/* toggle button */
		Assert((pwnd->style & WS_SUBSTYLE) == BS_AUTOCHECKBOX);
		pwnd->wButton ^= bstOn;
		Assert((bstGreyed & bstOn) == 0);
		pwnd->wButton &= ~bstGreyed;
		}
	SendMessage(pwnd->pwndParent, WM_DIALOG, pwnd->id, 0L);
	DrawButton(pwnd);
	}



PWND FARPRIVATE
PwndDefaultPushButton(pwnd)
/*
  -- return the first default pushbutton in the dialog
*/
REGISTER PWND pwnd;
	{
	pwnd = pwnd->pwndChild;

	while (pwnd)
		{
		if ((pwnd->style & WS_TYPE) == WS_BUTTON &&
		   (pwnd->style & WS_SUBSTYLE) == BS_DEFPUSHBUTTON)
		        return(pwnd);
		pwnd = PwndSibling(pwnd);
		}
	return NULL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\case.h ===
char FARPRIVATE ChUpperFromChExt(char);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\case.c ===
/*
	COW : Character Oriented Windows

	case.c: conversion of foreign lower case to upper case
*/

#define COW
#include <cow.h>

#include "case.h"

/* 
  -- SzLcUc: maps lower -> upper case for special foreign characters
  -- This string contains the uppercase/lowercase correspondence list for
     extended characters.  Every character in an even position in the list
     is lowercase.  The character following it is its uppercase representation.
     Thus, the even entries contain all the lowercase letters among the upper
     128 characters; the odd entries contain the uppercase letters.
  -- NOTE:  Some entries may contain a normal (ASCII) character.  This
     indicates that there is no uppercase (or lowercase) equivalent for the
     character's partner.
  -- Corresponds to IBM Code Page 850
*/
static char szLcUc[] = "\202\220\212\324\210\322\205\267\227\353\207\200\204\216\206\217\224\231\201\232\221\222\244\245\240\265\203\266\211\323\241\326\215\336\214\327\213\330\242\340\225\343\223\342\243\351\226\352\306\307\246\101\325\111\233\235\344\345\247\117\354\355\230\131";

/*	Here is the character set for the list:
	202		e acute	
	220		E acute
	212		e grave
	324		E grave
	210		e circumflex
	322		E circumflex
	205		a grave
	267		A grave
	227		u grave
	353		U grave
	207		c cedilla
	200		C cedilla
	204		a umlaut
	216		A umlaut
	206		a circle
	217		A circle
	224		o umlaut
	231		O umlaut
	201		u umlaut
	232		U umlaut
	221		ae
	222		AE
	244		n tilde
	245		N tilde
	240		a acute
	265		A acute
	203		a circumflex
	266		A circumflex
	211		e umlaut
	323		E umlaut
	241		i acute
	326		I acute
	215		i grave
	336		I grave
	214		i circumflex
	327		I circumflex
	213		i umlaut
	330		I umlaut
	242		o acute
	340		O acute
	225		o grave
	343		O grave
	223		o circumflex
	342		O circumflex
	243		u acute
	351		U acute
	226		u circumflex
	352		U circumflex
	306		a tilde
	307		A tilde
	246		a ordfeminine
	101		A
	325		i no dot
	111		I
	233		o slash
	235		O slash
	344		o tilde
	345		O tilde
	247		o ordmasculine
	117		O
	354		y acute
	355		Y acute
	230		y umlaut
	131		Y
*/


PRIVATE char FARPRIVATE
ChUpperFromChExt(ch)
char ch;
/*
  -- converts extended lower case to upper case using szLcUc
*/
{
	char *pch;

	for (pch = szLcUc; *pch != 0; pch++)
		{
		if (ch == *pch) 	/* even index means lower case */
			{
			if ((pch - szLcUc) & 1)
				return(ch);
			else
				return(*(pch + 1));
			}
		}
	return(ch);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\color.c ===
/*
	COW : Character Oriented Windows

	color : default colors
	SWAP TUNE NOTE : belongs in INIT module !!!!
*/

#define COW
#include <cow.h>

#include <uscreen.h>
#include <uisa.h>
#include <ucolor.h>

#include "screen.h"
#include "color.h"


extern SA PASCAL rgsa[];			/* isa -> sa */

#ifdef SCREEN_FFONT
extern WORD PASCAL mpisaffont[];		/* isa -> ffont */
#endif /*SCREEN_FFONT*/



PUBLIC VOID FARPUBLIC
SetIsaColor(isa, coFore, coBack)
/*
  -- set colors for a given ISA
*/
ISA	isa;
WORD	coFore;
WORD	coBack;
	{
	StartPublic();

	AssertSz(coFore < 16 && coBack < 16, "SetSysColor invalid color");

	rgsa[isa].u.draw.caSa = (BYTE) CaMake(coFore, coBack);

	StopPublic();
	}



PUBLIC VOID FARPUBLIC
GetIsaColor(isa, pcoFore, pcoBack)
/*
  -- get colors for a given ISA
*/
ISA	isa;
WORD *	pcoFore;
WORD *	pcoBack;
	{
	BYTE ca;

	StartPublic();

	ca = rgsa[isa].u.draw.caSa;

	*pcoBack = (ca >> 4) & 15;
	*pcoFore = ca & 15;

	StopPublic();
	}



PUBLIC VOID FARPUBLIC
SetIsaRgca(isa, rgcaFill)
ISA	isa;
BYTE *	rgcaFill;
	{
	StartPublic();

	rgsa[isa].u.rgcaFill = rgcaFill;	/* note : trashes ca */

	StopPublic();
	}



#ifdef SCREEN_FFONT
PUBLIC VOID FARPUBLIC
SetIsaFfont(isa, ffont)
ISA	isa;
WORD	ffont;
	{
	mpisaffont[isa] = ffont;
	}
#endif /*SCREEN_FFONT*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\defcolor.c ===
/*
	COW : Character Oriented Windows

	defcolor : default colors
	NOTE : the use may define their own colors
	8 User Colors

*/

#define COW
#include <cow.h>

#include <uisa.h>
#include "color.h"

/* Font drawing information */
WORD PASCAL mpisaffont[isaMax] = {0};

SA PASCAL rgsa[isaMax]=
	{
	/* list : b&w ca, color ca */

	/* isaBackground : all backgrounds */
	{ caBlackOnWhite,	Ca(coWhite)			},
	/* isaHilite : Hilited items */
	{ caWhite,		CaMake(coBlack, coBrightWhite)	},
	/* isaGreyed : greyed items */
	{ caBlackOnWhite,	Ca(coWhite)			},
	/* isaEnabled : enabled items */
	{ caBlackOnWhite,	Ca(coWhite)			},
	/* isaDisabled : disabled items */
	{ caBlackOnWhite,	Ca(coBlack)			},

	/* isaAlert : for MessageBox alerts */
	{ caBlackOnWhite,	Ca(CoBright(coRed))		},

	/* isaDialogBox : background for dialogs */
	{ caBlackOnWhite,	Ca(coWhite)			},
	/* isaPushButton : push button color */
	{ caBlackOnWhite,	Ca(coBrightWhite)		},
	/* isaButtonDown : pushed button color */
	{ caWhite,		CaMake(coGrey, coWhite)		},
	/* isaListBox : listbox background */
	{ caBlackOnWhite,	Ca(coWhite)			},
	/* isaScrollbar : scroll bar Background & arrows */
	{ caBlackOnWhite,	Ca(coWhite)			},
	/* isaElevator : scroll bar elevator */
	{ caWhite,		CaMake(coGrey, coWhite)		},

	/* isaMenuBox : background for menus */
	{ caBlackOnWhite,	Ca(coWhite)			},
	/* isaMenu : menu bar color */
	{ caBlackOnWhite,	Ca(coWhite)			},
	/* isaMenuSelected : Selected menus */
	{ caWhite,		CaMake(coWhite, coBlack)	},
	/* isaMenuHilite : for single character */
	{ caBrightBlack, 	Ca(coBrightWhite)		},
	/* isaMenuHiliteSel : for single character (under selection) */
	{ caBrightWhite, 	CaMake(coBrightWhite, coBlack)	},
	/* isaItemHiliteSel : for single character (under selection) */
	{ caBrightWhite, 	CaMake(coWhite, coBrightWhite)	},

	/* isaDialogAccel : dialog accelerators */
	{ caBrightBlack,	Ca(coYellow)			},

	/* isaShadow : shadows */
	{ caWhite,		CaMake(coGrey, coBlack)		},

	/* isaUserMin : 16 USER COLORS */
	{ caWhite, caWhite },
	{ caWhite, caWhite },
	{ caWhite, caWhite },
	{ caWhite, caWhite },
	{ caWhite, caWhite },
	{ caWhite, caWhite },
	{ caWhite, caWhite },
	{ caWhite, caWhite },

	{ caWhite, caWhite },
	{ caWhite, caWhite },
	{ caWhite, caWhite },
	{ caWhite, caWhite },
	{ caWhite, caWhite },
	{ caWhite, caWhite },
	{ caWhite, caWhite },
	{ caWhite, caWhite },
	};
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\button.h ===
/*
	COW : Character Oriented Windows

	button.h : button cow private interface
*/

DWORD	FARPUBLIC	ButtonWndProc(PWND, WORD, WORD, DWORD);



/* button control styles */
#define BS_AUTO				0x10
#define BS_PUSHBUTTON			0
#define BS_DEFPUSHBUTTON		1
#define BS_CHECKBOX			2
#define BS_AUTOCHECKBOX			(BS_CHECKBOX | BS_AUTO)
#define BS_RADIOBUTTON			3
#define BS_GROUP 			4


#define wButton 	rgwExtra[cwExtraText]
					/* flag word for button control */
#define	pwndButtonNext	rgwExtra[cwExtraText+1]	/* next radio button */

#if cwExtraButton != cwExtraText+2
.....
#endif

#define	wButtonFirstRadio	8	/* Initial value for 1st button */
#define	wButtonInit		0	/* Initial value for other buttons */

/* walking the list of radio buttons */
#define	PwndButtonNext(pwnd) ((PWND) (pwnd)->pwndButtonNext)
	/* note : uses "pbox" extra word */


VOID	FARPRIVATE	CheckDlgButton(PWND, WORD, BOOL);
WORD	FARPRIVATE	WButtonChecked(PWND);
VOID	FARPRIVATE	CheckRadioButton(PWND, WORD, BOOL);
PWND	FARPRIVATE	PwndDefaultPushButton(PWND);

#ifndef BUTTON_LARGE
#define	dayPushButton	1		/* single line button */
#define	daxPushButton	2		/* <> overhead */
#define	wsPushButton	(WS_CHILD | WS_BUTTON | BS_PUSHBUTTON)
#define	wsDefPushButton	(WS_CHILD | WS_BUTTON | BS_DEFPUSHBUTTON)
#else
#define	dayPushButton	3		/* fat button */
#define	daxPushButton	0		/* no <> overhead */
#define	wsPushButton	(WS_CHILD | WS_BUTTON | BS_PUSHBUTTON | WS_BORDER)
#define	wsDefPushButton	(WS_CHILD | WS_BUTTON | BS_DEFPUSHBUTTON | WS_BORDER)
#endif /*BUTTON_LARGE*/


#ifdef BUTTON_LARGE
#ifdef DIALOG_LINE
	.... ERROR : BUTTON_LARGE and DIALOG_LINE are mutually exclusive !!
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\dialog.h ===
/*
    	COW : Character Oriented Windows

	dialog.h: Dialog cow private interface
*/

/* special characters in dialog static strings */
#define	chPrefix1	'~'		/* tilde => accelerator */
#define	chPrefix2	((char) 247)	/* double tilde => hidden accelerator */

extern BYTE fShowDlgAccel;	/* show dialog accelerators ? */
extern BYTE fButtonAction;	/* TRUE => mouse button down on button */
extern PWND pwndCapture;

#define	FCaptured(pwnd)	((pwnd) == pwndCapture)

PRIVATE	BYTE	fDrawItem;
PRIVATE	BYTE	fRedrawItem;


/* WndProcs must be the same size as all public entries */
DWORD	FARPUBLIC	DialogWndProc(PWND, WORD, WORD, DWORD);

WORD	FARPRIVATE	DialogBox(PWND, PLFN);
VOID	FARPRIVATE	EndDialog(PWND, WORD);
WORD	FARPRIVATE	GetDlgItemText(PWND, char *, WORD);
VOID	FARPRIVATE	SetDlgItemText(PWND, char *, BOOL);

VOID	FARPRIVATE	DlgDirList(PWND, char *, PWND, BOOL, PWND);
BOOL	FARPRIVATE	DlgDirSelect(PWND, char *, PWND);
BOOL	FARPRIVATE	FMaybeDir(char *);

VOID	FARPRIVATE	AddListString(PWND, char *);
WORD	FARPRIVATE 	GetListText(PWND, char *, WORD);

WORD	FARPRIVATE 	CwSizeDialog(ARC *);
#define	CbSizeDialog(parc) (CwSizeDialog(parc)<<1)


/* Common portion of all dialog windows */
#define	cwExtraMin	1		/* at least 1 field for all items */
					/* not used for dialog box */
#define	aclDialog	rgwExtra[0]	/* dialog accelerator */

/* Text info for : edit, static and button controls */
#define	cwExtraText	(cwExtraMin+2)	/* 2 more for text controls */
#define szDialog	rgwExtra[1]	/* also Dialog Box caption */
#define cchDialog	rgwExtra[2]	/* edit, static & buttons */

/* flag indicating whether EndDialog has been
   called.  Used to prevent multiple calls
   to PostQuitMessage */
#define wParamEnd		rgwExtra[2]


/* sizes of rgwExtra for the various controls */

#define cwExtraDialog	(cwExtraMin+2)	/* szDialog + fEndDb */

#define cwExtraStatic	(cwExtraText)	/* simple text */
#define cwExtraButton	(cwExtraText+2)	/* text + button state + next radio */
#define cwExtraEdit	(cwExtraText+10)	/* see edit.h for details */
#define	cwExtraGeneral	(cwExtraMin+2)	/* see general.h for details */

#ifndef LISTBOX_HORIZ
#define cwExtraListBox	(cwExtraMin+14)	/* see _listbox.h for details */
#else
#define cwExtraListBox	(cwExtraMin+16)	/* see _listbox.h for details */
#endif /*LISTBOX_HORIZ*/


/* Dialog Accelerator control */
#define	aclNil		0	/* no accelerator */
#ifndef KANJI
/* non-Kanji : single character within first 16 characters */
#define	ChAccel(pwnd)	LOBYTE((pwnd)->aclDialog)
#define	IchAccel(pwnd)	HIBYTE((pwnd)->aclDialog)
#else
/* Kanji : either Roman or Kana - first character only */
#define	ChAccel(pwnd)	(fKanaAccel ? HIBYTE(pwnd->aclDialog) : \
			    LOBYTE(pwnd->aclDialog))
#define	IchAccel(pwnd)	0
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\color.h ===
/*
	COW : Character Oriented Windows

	color.h : color info header file

*/

typedef struct _sa
	{
	union
		{
		struct
			{
			BYTE caMono;		/* initial B/W COLOR */
			BYTE caColor;		/* initial COLOR */
			} init;
		struct
			{
			BYTE bFiller;
			BYTE caSa;		/* the actual drawing ca */
			} draw;
		BYTE *rgcaFill;		/* special fill mode array */
		} u;
	} SA;		/* screen attribute */


#define coBlack			0x0
#define coBlue			0x1
#define coGreen			0x2
#define coRed			0x4
#define coCyan			(coBlue + coGreen)
#define coMagenta		(coBlue + coRed)
#define coOrange		(coRed + coGreen)
#define coWhite			(coRed + coGreen + coBlue)
#define	CoBright(co)		((co) | 8)
#define	coGrey			CoBright(coBlack)
#define	coBrightWhite		CoBright(coWhite)
#define coYellow		CoBright(coOrange)

#define CaMake(coFore, coBack)	(((coBack) << 4) | (coFore) )

/* valid monochrome colors */
#define	caWhite			CaMake(coWhite, coBlack)
#define	caBlackOnWhite		CaMake(coBlack, coWhite)
#define	caBrightWhite		CaMake(coBrightWhite, coBlack)
#define	caBrightBlack		CaMake(coBlack, coBrightWhite)
		/* black on bright background */

/* color on standard background (grey) */
#define Ca(coFore)		CaMake(coFore, coGrey)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\charset.h ===
/*
	COW : Character Oriented Windows

	charset.h : special characters and other customizing constants
		(IBM specific)
	ONLY USE SAFE CHARACTERS (VGA codepage 850)
*/

/* Boxes */
#define chTopSide1		((char) 196)
#define chBottomSide1		chTopSide1
#define chLeftSide1		((char) 179)
#define chRightSide1		chLeftSide1

#define chTopSide2		((char) 205)
#define chBottomSide2		chTopSide2
#define chLeftSide2		((char) 186)
#define chRightSide2		chLeftSide2

#define chTopLeftCorner1	((char) 218)
#define chTopRightCorner1	((char) 191)
#define chBottomLeftCorner1	((char) 192)
#define chBottomRightCorner1	((char) 217)
#define chMiddleLeft1		((char) 195)
#define chMiddleRight1		((char) 180)

#define chTopLeftCorner2	((char) 201)
#define chTopRightCorner2	((char) 187)
#define chBottomLeftCorner2	((char) 200)
#define chBottomRightCorner2	((char) 188)

#define chUpArrow		((char) 24)
#define chDownArrow		((char) 25)
#define chRightArrow		((char) 26)
#define chLeftArrow		((char) 27)

#define	chBullet		((char) 7)
#define	chMiddleDot		((char) 0xFA)		/* middle dot */

#define chScrollbar		((char) 0xb0)		/* hash */
#define chElevator		' '

#define	chShadowInit		((char) 0xb1)		/* other hash */


#ifdef WINDOW_OVERLAP
#define	chClose			((char) 0xDC)
#define	chZoomIn		((char) 0x1E)
#endif /*WINDOW_OVERLAP*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\dirlist.c ===
/*
	COW : Character Oriented Windows
	(COW USER DIALOG)

	dirlist.c : Directory dir list control
*/

#define COW
#include <cow.h>


#ifdef LISTBOX_DIR			/* entire file */

#define DIRLIST

#include <udialog.h>
#include <uevent.h>
#include <uwindow.h>
#include <uutil.h>
#include "dialog.h"
#include "event.h"
#include "listbox.h"
#include "window.h"
#include "util.h"

#include "dirlist.h"
#include "_dirlist.h"

#ifdef LISTBOX_LIMIT_SIZE
#define	cchDirMax	80				/* 64 + file name */
#else
#define	cchDirMax	256
#endif


BOOL FAR PASCAL FBuildDirectoryList(PWND, char *, PWND, BOOL, char *);


/* forward */
STATIC BOOL FCorrectDriveDir(char *);
STATIC char *SzChopText(PWND, char *);


char szWildAll[] = "*.*";



PRIVATE VOID FARPRIVATE
DlgDirList(pwndListBox, szPath, pwndStatic, fDisplay, pwndListBox2)
/*
  -- construct a directory listing in the listbox.
  -- return TRUE if the supplied path could be parsed
  -- NOTE : do not change current directory unless redrawing
	(kludgy way to detect startup case)
  -- NOTE : if pwndListBox == NULL, then don't fill
*/
REGISTER PWND pwndListBox;	/* listbox window */
char *szPath;			/* path */
PWND pwndStatic;		/* static item for tracking text or NULL */
BOOL fDisplay;
REGISTER PWND pwndListBox2;	/* extra window for drives / dir */
	{
	char	szDir[cchDirMax];	/* buffer for drive names */

	/* fill in listbox */
	Assert(pwndListBox != NULL || pwndListBox2 != NULL);

	if (pwndListBox2 == NULL)
		pwndListBox2 = pwndListBox;

	if (!FBuildDirectoryList(pwndListBox, szPath, pwndListBox2, fDisplay,
					szDir))
		return;		/* illegal directory */

	if (fDisplay)
		{
		if (pwndListBox != NULL)
			DrawWindow(pwndListBox);
		if (pwndListBox2 != pwndListBox && pwndListBox2 != NULL)
			DrawWindow(pwndListBox2);
		}

	if (pwndStatic != NULL)
		{
		/* fill in static text item */
		GetCurDir(GetCurDrive(), szDir);
		SetDlgItemText(pwndStatic, SzChopText(pwndStatic, szDir),
		    fDisplay);
		}
	}



VOID FAR PASCAL
SetCurrentPath(szPath)
/*
  -- use path to set current drive / directory
  -- NOTE : does not modify szPath
*/
REGISTER char *szPath;
	{
	char *	szTop = szPath;
	REGISTER char * pch;
	REGISTER char *	pchDelim = NULL;	/* after last delimiter */

	while (szPath[0] == ' ')
		szPath++;

	if (szPath[1] == ':')
		{
		/* drive prefix */
		if (!FValidDrive(szPath[0]))
			return;		/* invalid drive */

		SetCurDrive(szPath[0]);
		szPath += 2;
		}

	/* copy path to buffer, record position of last delimiter */
	for (pch = szPath; *pch != '\0'; pch++)
		{
		if (*pch == '/' || *pch == '\\')
			pchDelim = pch+1;		/* point past delim */
		}

	if (pchDelim != NULL)
		{
		/* we have a prefixing drive or directory */
		char	chSave;

		if (pchDelim != szPath+1)
			pchDelim--;		/* lose last slash */
		chSave = *pchDelim;		/* save old */
		*pchDelim = '\0';		/* truncate to directory */
		FSetCurDir(szPath);
		*pchDelim = chSave;		/* restore string */
		}
	}



char * FAR PASCAL
SzDirSpec(szPath, szDir, pfRoot)
/*
  -- fill szDir with the path of the directory defined by szPath
  -- return NULL if bogus directory (invalid drive)
  -- otherwise return address of filename (inside szPath buffer).
  -- set *pfRoot if
	(1) the path is just a root directory (eg. "x:").
	(2) the path is a root directory followed by a wildcard
*/
REGISTER char *szPath;
REGISTER char *szDir;
BOOL *	pfRoot;			/* set if directory is root */
	{
	char *szSlash = szDir;
	BOOL	fSlash = FALSE;		/* => found a slash separator */
	BOOL	fWild = FALSE;		/* => found a wild card */

	*pfRoot = FALSE;
	while (*szPath != '\0')
		{
		switch (*szDir++ = *szPath++)
			{

		case '?':
		case '*':
			fWild = TRUE;
			/*fall through*/
		default:
			*pfRoot = FALSE;
			break;

		case ':':
			if (!FValidDrive(*(szPath-2)))
				return NULL;
			*pfRoot = TRUE;		/* we are at the root */
			goto normal_delim;
		case '\\':
		case '/':
			fSlash = TRUE;
normal_delim:
			szSlash = szDir;
			break;
			}
		}

	if (!fSlash && fWild)
		{
		/* no slashes and wildcards, probably root-like */
		*pfRoot = TRUE;
		}

	strcpy(szSlash, szWildAll);
	return (szPath + (szSlash - szDir));
	}



VOID FAR PASCAL
MakeDirName(sz, szDir)
REGISTER char *sz, *szDir;
	{
	char ch;

	*szDir = '[';
	szDir++;
	for (; (ch = *sz) != '\0'; sz++, szDir++)
		*szDir = ch;
	*szDir++ = ']';
	*szDir = '\0';
	}



PRIVATE BOOL FARPRIVATE
DlgDirSelect(pwndListBox, sz, pwndListBox2)
/*
  -- copy the selected file name to the specified buffer
  -- strip out directory punctuation
  -- return TRUE if a drive / directory only
*/
PWND pwndListBox;
REGISTER char *sz;
PWND pwndListBox2;
	{
	Assert((pwndListBox->style & WS_TYPE) == WS_LISTBOX);

	if (pwndListBox2 != NULL)
		{
		/* ListBox2 => directory / drive */
		WORD cch;
		BOOL fDrive;
		Assert((pwndListBox2->style & WS_TYPE) == WS_LISTBOX);

		GetDlgItemText(pwndListBox2, sz, cchDirMax);
		fDrive = FCorrectDriveDir(sz);
		sz += (cch = strlen(sz));
		if (!fDrive && cch != 0)
			{
			/* no drive & text => prefix directory */
			*sz++ = '\\';
			cch--;
			}
		GetDlgItemText(pwndListBox, sz, cchDirMax - cch);
		if (strlen(sz) == 0)
			return (TRUE); /* if no file name */
		}
	else
		{
		GetDlgItemText(pwndListBox, sz, cchDirMax);
		if (FCorrectDriveDir(sz))
			return(TRUE);
		}

	while( (*sz != '.') && (*sz != '\0'))
		sz++;
	if (*sz == '\0')
		{
		*sz = '.';
		*(sz+1) = '\0';
		}

	return(FALSE);
	}



STATIC BOOL
FCorrectDriveDir(sz)
/*
  -- correct file name if *sz contains a drive or directory
  -- return TRUE if it contained a drive / directory
*/
REGISTER char *sz;
	{
	REGISTER char *szNext = sz;

	if (*szNext++ != '[')
		return FALSE;	/* no drive / dir */

	if (*szNext == '-')
		{
		/* it is a drive */
		*sz++ = szNext[1];
		*sz++ = ':';
		}
	else
		{
		while (*szNext != ']' && *szNext != '\0')
			*sz++ = *szNext++;
		*sz++ = '\\';
		}
	*sz = '\0';

	return TRUE;
	}



STATIC char *
SzChopText(pwnd, szDir)
/*
  -- adjust Directory text "szDir" to fit in window pwnd
  -- munges "szDir"
*/
REGISTER PWND pwnd;
REGISTER char *	szDir;
	{
	WORD	cchField;
	BOOL	fChop = FALSE;
	WORD	cch;
	RRC	rrc;
	char	chDrive;

	/* Get length of static field */
	GetClientRrc(pwnd,&rrc);
	cchField = rrc.rxRight - rrc.rxLeft;

	/* Chop characters off front end of text until short enough */
	while (cchField < (cch = strlen(szDir)))
		{
		if (!fChop)
			{
			chDrive = *szDir;
			if (cchField <= 7)
				break;
			cchField -= 7;
			szDir += 7;
			}
		while (cch-- > 0 && *szDir++ != '\\')
			;
		fChop = TRUE;
		}

	/* if any characters chopped off, replace first three characters in
	   remaining text string with elipsis */
	if (fChop)
		{
		szDir--;
		*--szDir = '.';
		*--szDir = '.';
		*--szDir = '.';
		*--szDir = '\\';
		*--szDir = ':';
		*--szDir = chDrive;
		}

	return (szDir);
	}



BOOL FARPRIVATE
FMaybeDir(szPath)
/*
  -- return TRUE if "sz" might represent a directory
*/
char *	szPath;
	{
	REGISTER char *	sz = szPath;
	REGISTER char	ch;
	BOOL	fAllWhite = TRUE;
	WORD	atr;

	while ((ch = *sz) != '\0')
		{
		if (ch == ':' && !FValidDrive(*(sz-1)))
			return TRUE;	/* bogus drive : keep listbox up */
		if (ch == '*' || ch == '?')
			return TRUE;
		else if (ch != ' ')
			fAllWhite = FALSE;
		sz++;
		}
	/* leave with sz => terminating '\0' */

	if (fAllWhite)
		return TRUE;		/* all white => stay here */

	if (*(--sz) == ':')
		return TRUE;	/* probably a drive */
	if ((*sz == '.') && (*(sz-1) == '.'))
		{				/* probably a directory */
		*(++sz) = '\\';			/* make it look like one */
		*(++sz) = '\0';
		return TRUE;
		}

	/* if ending '\' or '/' at end of path - remove for test */
	if (*sz == '\\' || *sz == '/')
		{
		if ((*(sz-1) == '.') && (*(sz-2) == '.'))
			return TRUE;	/* probably a directory */
		if (*(sz-1) == ':')	/* drive:\ case */
			return TRUE;
		*sz-- = '\0';
		}
	/* sz points to the last character in the string */

	/* check to see if it is a real directory */
	if ((atr = AtrOfPath(szPath)) != atrError &&
	    (atr & atrDir) != 0)
		{
		/* it is a real directory */
		*(++sz) = '\\';			/* make it look like one */
		*(++sz) = '\0';
		return TRUE;
		}
	return FALSE;		/* probably not a directory */
	}


#endif /*LISTBOX_DIR*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\dirlist.h ===
/*
	COW : Character Oriented Windows

	dialog.h : dialog specific stuff
*/

/* File find info; it's the DOS 3 structure, but we mimic it for OS/2. */
typedef struct _fde
	{
	char	reserved[21];	/* MSDOS requires this	*/
	char	atr;		/* File attribute	*/
	WORD	wTime;		/* File time of last write */
	WORD	wDate;		/* File date of last write */
	DWORD	cbFile;		/* File size in bytes	*/
	char	szName[13];	/* File name packed	*/
	} FDE;	/* Find directory entry */

#ifndef DOS5
/* FCB for fast dirlist fill */
typedef struct _fcb
	{
	BYTE	dn;		/* drive number */
	char	rgchFile[8];	/* file name -- blank filled */
	char	rgchExt[3];	/* extension -- blank filled */
	BYTE	reserved[25];	/* DOS usage */
	} FCB;	/* File Control Block */

#endif

#define	atrFile		0
#define	atrDir		0x10
#define atrError	((WORD) -1)	/* error return from AtrOfPath */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\edit.h ===
/*
	COW : Character Oriented Windows

	edit.h : edit cow private interface
*/

/*****************************************************************************/

/* Edit Control Text Styles */
#define ES_LEFT 		0	/* left justified text */
#define ES_CENTER 		1	/* centered text */
#define ES_RIGHT 		2	/* right justified text */

#define	ES_SECRET		4	/* secret edit field */

/*****************************************************************************/

#ifdef EDIT_FULLMGR
#include "medit.h"			/* multi-line edit */
#else
#include "sedit.h"			/* single-line edit */
#endif

PRIVATE DWORD FARPUBLIC InternalEditWndProc(PWND, WORD, WORD, DWORD);

#ifdef EDIT_FULLMGR
VOID	FARPUBLIC InitEditWnd(PWND, BYTE *, WORD);
#endif

/*****************************************************************************/

/* Characters */
#define	chFillEdit	chMiddleDot	/* middle dot */
#ifdef EDIT_SECRET
#define	chSecret	'.'		/* single character for secret edit items */
#endif

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\dirlist3.c ===
/*
	COW : Character Oriented Windows
	(COW USER DIALOG)

	dirlist3.c : DOS3 version of FBuildDirectoryList
*/

#define COW
#include <cow.h>


#ifdef LISTBOX_DIR			/* entire file */

#define DIRLIST

#include <udialog.h>
#include <uevent.h>
#include <uwindow.h>
#include <uutil.h>
#include "dialog.h"
#include "event.h"
#include "listbox.h"
#include "window.h"
#include "util.h"

#include "dirlist.h"
#include "_dirlist.h"


extern char szWildAll[];

STATIC char szParentDir[] = "..";


/* forward */
BOOL FAR PASCAL FBuildDirectoryList(PWND, char *, PWND, BOOL, char *);




BOOL FAR
FBuildDirectoryList(pwnd, szPath, pwndDir, fSetPath, szTemp)
/*
  -- DOS3 VERSION !!

  -- build up the directory list
  -- NOTE : if pwnd == NULL, then don't fill files
  -- return TRUE if ok, FALSE if illegal szPath (bad dir)
  -- if valid path and fSetPath, return in *szPath the path less the file name
*/
char *	szPath;
PWND	pwnd;
PWND	pwndDir;	/* where to put drives / directories */
BOOL	fSetPath;	/* TRUE => set path if ok */
char *	szTemp;		/* temporary storage passed down to save stack space */
	{
	FDE	fde;
	char	chDrive;
	BOOL	fRoot;			/* TRUE => root of directory tree */
	BOOL	fAbsPath;		/* TRUE => absolute path */
	char *	szFileName;		/* simple file name */
	char *	szPathOrig = szPath;	/* original path address */
	FCB	fcb;			/* gross me out */

	while (szPath[0] == ' ')
		szPath++;

	/* check to see if there is a valid directory */
	if ((szFileName = SzDirSpec(szPath, szTemp, &fRoot)) == NULL)
		{
		goto not_valid_dir;
		}

	if (!fRoot)
		{
		/* not a root directory, try looking for the directory
		    (like doing a stat()) */
		BOOL fOk;

		fOk = FFindFirst(&fde, szTemp, atrDir);
		FindClose();

		/* Special check for Novell Network:
		   (is directory really there ?) */
		if (!fOk)
			{
			/* remove "*.*" wildcard at end of directory */
			szTemp[strlen(szTemp)-3] = '\0';	/* kill "*.*" */
			fOk = FValidDir(szTemp);
			}

		if (!fOk)
			{
			/* directory is bogus */
not_valid_dir:
			/* if we get an invalid directory,
			   we don't want to change (with the exception that
			   if this is a drives/directory only listbox
			   (i.e. pwnd == NULL) then we should fill it)
			*/
			if (pwnd != NULL)
				return FALSE;	/* bogus directory */
			fRoot = TRUE;
			fSetPath = FALSE;
			}
		}

	if (fSetPath)
		{
		SetCurrentPath(szPath);
		strcpy(szPathOrig, szFileName);
		szPath = szFileName = szPathOrig;	/* just filename left */
		fAbsPath = FALSE;
		}
	else
		{
		/* starting out, absolute if any prefix (relative if *.*) */
		fAbsPath = (szTemp[0] != '*');
		}
	
	/* we are going to move, reset list boxes */
	if (pwnd != NULL)
		SendMessageShort(pwnd, LB_RESETCONTENT);
	Assert(pwndDir != NULL)
	SendMessageShort(pwndDir, LB_RESETCONTENT);

	/* use FindFirst/Next once if not absolute path
	    (do our own pattern matching) */

	if (fAbsPath && pwnd != NULL)
		{
		/* look for an absolute path */
		if (FFindFirst(&fde, szPath, atrFile))
			{
			do
				{
				Assert(!(fde.atr & atrDir));
				AddListString(pwnd, fde.szName);
				}
			while (FFindNext(&fde));
			}
		FindClose();
		}

	/* tricky 1 pass for directories */
	PrepareWild(&fcb, szFileName);
	if (FFindFirst(&fde, szWildAll, atrDir))
		{
		do
			{
			if (!(fde.atr & atrDir))
				{
				/* got a file we can use */
				if (!fAbsPath &&	/* not absolute */
				    pwnd != NULL &&	/* real window */
				    FMatchWild(&fcb, fde.szName))
							/* and wildcard match */
					{
					Assert(!(fde.atr & atrDir));
					AddListString(pwnd, fde.szName);
					}
				}
			else if (!(fde.szName[0] == '.' &&
			    (fde.szName[1] == '\0' || (fde.szName[1] == '.' &&
			     fde.szName[2] == '\0'))))
				{
				/* got a directory we can use */
				if (pwndDir == pwnd)
					{
					/* 1 listbox => throw in [] */
					MakeDirName(fde.szName, szTemp);
					AddListString(pwndDir, szTemp);
					}
				else
					{
					/* add simple */
					AddListString(pwndDir, fde.szName);
					}
				}
			}
		while (FFindNext(&fde));
		}
	FindClose();

	/* fabricate ".." test since Novell network fails on FindFirst/Next */
	szTemp[0] = '\0';

	GetCurDir(GetCurDrive(), szTemp);
	if (strlen(szTemp) != 3)
		{
		/* current directory is not "x:\", add in ".." */
		AddListString(pwndDir, pwndDir == pwnd ? "[..]" :
		    szParentDir);
		}

	/* lastly drives */
	strcpy(szTemp, "[- -]");
	for (chDrive = 'A'; chDrive <= 'Z'; chDrive++)
		{
		if (FValidDrive(chDrive))
			{
			szTemp[2] = chDrive;
			AddListString(pwndDir, szTemp);
			}
		}
	return TRUE;	/* all ok */
	}


#endif /*LISTBOX_DIR*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\editinit.asm ===
assumes		DS,DGROUP
	assumes		SS,DGROUP
	assumes		ES,NOTHING

fail1:
	jmp	fail2

;***	EditMgrKeyInit(char far * lpTable)
;*
;*
cProc	EditMgrKeyInit,<FAR,PUBLIC>,<di,si,ds>
parmD	lpTable
cBegin
	push	ds
	pop	es
	assumes	es,DGROUP
	
	lds	si,lpTable		;* Get a pointer to the structure
	assumes	DS,NOTHING
	
	;*
	;*	First come a pair of length prefixed, zero terminated
	;*	strings. (The length includes the zero byte).
	
	mov	di, dataOFFSET SzActionPrim	; Destination
	lodsb				;* Get the length
	cbw				;* 
	mov	cx,ax			;*
	repz	movsb			;* Copy over the name
	
	mov	di, dataOFFSET SzCancelPrim	; Destination
	lodsb				;* Get the length
	cbw				;* 
	mov	cx,ax			;*
	repz	movsb			;* Copy over the name
	
	;*
	;*	Second are the action and cancel keys to use
	;*
	
	lodsw				;* Get Primary Action Key
	mov	[vkActionPrim],ax	;* And store
	lodsw				;* Get Secondary Action Key
	mov	[vkActionSec],ax	;* And store
	lodsw				;* Get Primary Cancel Key
	mov	[vkCancelPrim],ax	;* And store
	lodsw				;* Get Secondary Cancel Key
	mov	[vkCancelSec],ax	;* And store
	
	;*
	;*	Third thing in the structure is 33 bytes for the 
	;*		DoCharDispatch table
	;*
	
	mov	di,dataOFFSET DoCharDispatch ;* Destination to copy to
	mov	cx,33			;* 33 bytes of info
	repz	movsb			;* Copy the table over
	
	;*
	;*	Next comes the Vk tables
	;*
	;*	Vk
	
	lodsw				;* Get the length of the table
	push	ax			;* Save the length
	push	ds			;* Save this register
	push	es			;* Set DS = DGROUP
	pop	ds
	assumes	ds,DGROUP
	
	mov	cx,1
	save	<es>
	cCall	PpvAllocCb,<cx,ax>	;* (sbHeap, cbReq)
	or	ax,ax			;* ERROR?
	jz	fail1			;* Yes -- abort
	pop	ds			;* ds:si points to the input table
	assumes	ds,nothing		;*
	pop	cx			;* count of bytes
	mov	di,ax			;* Pointer to allocated area
	mov	pVkTable,di		;* Save pointer to allocated table

	repz	movsb			;* Copy from input table to allocated
					;*     table
	
	
	;*	Cntl Vk
	
	lodsw				;* Get the length of the table
	push	ax			;* Save the length
	push	ds			;* Save this register
	push	es			;* Set DS = DGROUP
	pop	ds
	assumes	ds,DGROUP
	
	mov	cx,1
	save	<es>
	cCall	PpvAllocCb,<cx,ax>	;* (sbHeap, cbReq)
	or	ax,ax			;* ERROR?
	jz	fail1			;* Yes -- abort
	pop	ds			;* ds:si points to the input table
	assumes	ds,nothing		;*
	pop	cx			;* count of bytes
	mov	di,ax			;* Pointer to allocated area
	mov	pVkCtrlTable,di		;* Save pointer to allocated table

	repz	movsb			;* Copy from input table to allocated
					;*     table
	

	;*	Prefix tables

	lodsw				;* Get count of prefix table entries
	mov	cx,ax			;* Move to where it is suppose to be
	jcxz	P20
	
P1:
	push	cx			;* Save counter
	
	lodsw				;* Get the length of the table
	push	ax			;* Save the length
	push	ds			;* Save this register
	push	es			;* Set DS = DGROUP
	pop	ds
	assumes	ds,DGROUP
	
	mov	cx,1	
	save	<es>
	cCall	PpvAllocCb,<cx,ax>	;* (sbHeap, cbReq)
	or	ax,ax			;* ERROR?
	jz	fail3			;* Yes -- abort
	pop	ds			;* ds:si points to the input table
	assumes	ds,nothing		;*
	pop	cx			;* count of bytes
	mov	di,ax			;* Pointer to allocated area
	lodsw				;* Offset in PrefixTable to save at
	mov	bx,ax			;* Move to index register
	mov	PrefixTable[bx],di	;* Save pointer to allocated table

	repz	movsb			;* Copy from input table to allocated
					;*     table
	
	pop	cx			;* Get count back
	loop	P1			;* Loop until done
P20:
	;*	VK prefix tables
	
	lodsw				;* Get count of vk prefix table entries
	mov	cx,ax			;* Move to where it is suppose to be
	jcxz	P40			;* No entries -- done
	
	inc	ax			;* Add one for termination routine
	shl	ax,1			;* Number of bytes needed for table
	push	cx
	save	<es>
	cCall	PpvAllocCb,<cx,ax>	;* (sbHeap, cbReq)
	or	ax,ax			;* ERROR?
	jz	fail3			;* Yes -- abort
	mov	[pDoVkDispatch],ax	;* Save pointer to table
	
	mov	bx,ax			;* Point to table
	pop	cx			;* Restore count
public P22
P22:
	push	cx			;* Save the counter
	lodsw				;* Get the length of the table
	push	ax			;* Save the length
	push	ds			;* save this register
	push	es			;* Set DS = DGROUP
	pop	ds
	assumes	ds,DGROUP
	
	mov	cx,1			;*
	save	<es,bx>			;*
	cCall	PpvAllocCb,<cx,ax>	;* (sbHeap, cbReq)
	or	ax,ax			;* ERROR?
	jz	fail3			;* Yes -- abort
	pop	ds			;* ds:si points to input table
	assumes	ds,nothing		;*
	pop	cx			;* Count of bytes
	mov	di,ax			;* Pointer to allocated area
	lodsw				;* VK character for table
	mov	[bx],ax			;* Save character
	mov	[bx+2],di		;* Save pointer to table
	add	bx,4			;* Move to next table entry
	repz	movsb			;* Copy input table to allocated table	
	pop	cx			;* Restore the countern
	loop	P22			;* Loop until finished
P30:
	xor	ax,ax			;* 
	mov	[bx],ax			;* Add terminator to table
P40:
@@:
cEnd
fail2:
fail3:
	int 3
	mov	ax,1			;* Return failure
	jmp	short @B

	assumes	es,nothing
	assumes	ds,DGROUP

cProc	DefaultEditMgrInit,<FAR,PUBLIC>,<si,di,ds>
cBegin
	mov	ax,initOFFSET DefaultEditMgrTbls
	cCall	EditMgrKeyInit,<cs,ax>
cEnd
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\dlgcore.c ===
/*
	COW : Character Oriented Windows

	dlgcore: dialog core routines
*/

#define COW
#include <cow.h>

#define DIALOG

#include <udialog.h>
#include <uevent.h>
#include <vkey.h>
#include <uwindow.h>
#include <umenu.h>
#include <uutil.h>
#include <uscreen.h>
#include <uisa.h>
#include <kkeyboar.h>
#include <kinput.h>

#include "dialog.h"
#include "button.h"
#include "event.h"
#include "window.h"
#include "screen.h"
#include "util.h"
#include "case.h"
#include "overlap.h"

#include "shadow.h"


#ifdef EXTRAS
#include <cowextra.h>
#endif

#ifdef DUAL
#include <os2.h>
extern	WORD	fProtectMode;
#else
#ifdef DOS5
#include <os2.h>
#endif
#endif

#ifdef SCREEN_FFONT
#ifdef KANJI
	-- Kanji + FFONT is not allowed
#endif
#endif


PRIVATE	BYTE fDrawItem = TRUE;			/* FALSE if don't paint */
PRIVATE	BYTE fRedrawItem = TRUE;		/* FALSE if initializing */

PRIVATE BYTE FAR * lpbWorkTemp = NULL;/* !NULL => use temporary work buffer */


STATIC PLFN_WNDPROC pfnDlg;	/* current Dialog function */

STATIC PWND pwndDlg = NULL;	/* current Dialog Window */
#ifdef DIALOG_NOSAVE
STATIC PWND pwndDlg2 = NULL;	/* previous Dialog Window */
#endif
PRIVATE BYTE fShowDlgAccel;	/* show dialog accelerators ? */
PRIVATE BYTE fButtonAction;	/* TRUE => mouse button down on button */

#ifdef DIALOG_LINE
STATIC BYTE fTwoLineDlg;	/* TRUE => dialog has 2 bottom lines of buttons */
#endif /*DIALOG_LINE*/

/* forward */
STATIC PWND	PwndPreviousControl(PWND, PWND);
BOOL FARPRIVATE	DialogFilterProc(PMSG);
STATIC BOOL	FProcessAccel(WORD);
STATIC VOID	DrawDialogBorder(PWND);

#ifdef	DIALOG_NOSAVE
extern VOID	FAR PASCAL	ScreenRedraw(VOID);
#endif	// DIALOG_NOSAVE


//
// a-emoryh - We need to alter the VK_TAB behavior in certain cases in QHELP
//    mode (new behavior is enabled if pwndPrintEdit != NULL).
//
extern PWND pwndPrintEdit;




WORD FARPRIVATE
DialogBox(pwndDialog, pfn)
/*
  -- process the dialog for a dialog box
  -- NOTE : we never actual send a KILL/SET focus to the current focus
*/
REGISTER PWND pwndDialog;
PLFN pfn;
	{
	MSG msg;

	/* save old state of world */
	PWND pwndDlgOld = pwndDlg;
	PLFN pfnDlgOld = pfnDlg;
	PWND pwndRootOld = pwndRoot;
	PWND pwndFocusOld = pwndFocus;
	PWND pwndCaptureOld = pwndCapture;
	BYTE fShowDlgAccelOld = fShowDlgAccel;
#ifdef DIALOG_LINE
	BYTE fTwoLineOld = fTwoLineDlg;
#endif /*DIALOG_LINE*/

	BOOL fMenuEnabled;
	PFFN_FILTER pfnFilterOld;
#ifdef WINDOW_OVERLAP
	PFFN_FILTER pfnOverlapFilterOld;
#endif /*WINDOW_OVERLAP*/

#ifndef DIALOG_NOSAVE
	BYTE FAR *lpbSave;		/* save under dialog */

	DrawThisWnd(NULL);      /* No window defined yet */

/* use lpbWorkTemp if non-null */
	if (lpbWorkTemp != NULL)
		{
		lpbSave = lpbWorkTemp;
		}
	else
		{
		// allocate a buffer

		lpbSave = LpbAllocWorkFar(
		     CbSizeDialog(&pwndDialog->arcWindow) + daxDbcs * 2 *
		     (pwndDialog->arcWindow.ayBottom - pwndDialog->arcWindow.ayTop +
		     dayShadow) * 2);

		if (lpbSave == NULL)
			return IDCANCEL;		// no memory
		}

#endif	// DIALOG_NOSAVE

	fMenuEnabled = FEnableMenuBar(FALSE);

#ifndef DIALOG_NOSAVE

	/* Save window (ajust for shadow and DBCS padding) */
	SaveArc(pwndDialog->arcWindow.axLeft - daxDbcs,
	    pwndDialog->arcWindow.ayTop,
	    pwndDialog->arcWindow.axRight + daxShadow + daxDbcs,
	    pwndDialog->arcWindow.ayBottom + dayShadow, lpbSave);

#endif	// DIALOG_NOSAVE

#ifdef	DIALOG_NOSAVE
	if (pwndDlg2 == NULL)
		pwndDlg2 = pwndDialog;
#endif	// DIALOG_NOSAVE
	pwndDlg = pwndDialog;
	pwndRoot = pwndDialog;
	pfnDlg = pfn;
	pwndDialog->wParamEnd = 0;
	fShowDlgAccel = FALSE;
	fButtonAction = FALSE;
	pwndCapture = NULL;		/* clear the capture */

#ifdef WINDOW_OVERLAP
	RethinkDisplay();       	/* With new root */
#endif /* WINDOW_OVERLAP */

	pwndFocus = NULL;
	pfnFilterOld = pfnFilter;
#ifdef WINDOW_OVERLAP
	pfnOverlapFilterOld = pfnOverlapFilter;
#endif /*WINDOW_OVERLAP*/
	KillAlarm();			/* just in case */

	/* 3 stages to init :
	*	fDrawItem	fRedrawItem		state
	*	FALSE		FALSE			init (no drawing)
	*	TRUE		FALSE			first time painting
	*	TRUE		TRUE			normal processing
	*/
	fDrawItem = fRedrawItem = FALSE;
	SendMessageShort(pwndDialog, WM_INITDIALOG);

#ifdef DIALOG_LINE
	/* check for pushbutton on bottom line */
	{
	REGISTER WND *	pwnd;
	AY ay = pwndDialog->arcWindow.ayBottom - 3;

	fTwoLineDlg = FALSE;
	for (pwnd = pwndDialog->pwndChild; pwnd != NULL;
	    pwnd = pwnd->pwndSibling)
		{
		if (pwnd->arcWindow.ayTop == ay)
			{
			fTwoLineDlg = TRUE;
			break;
			}
		}
	}	

#endif /*DIALOG_LINE*/

	BeginDraw();

	fDrawItem = TRUE;
	DrawWindow(pwndDialog);
	fRedrawItem = TRUE;

	if (pwndFocus == NULL)
		{
		/* INITDIALOG message did not set focus => set to first item */
		SetFocus(pwndDialog);
		}

	pfnFilter = DialogFilterProc;
#ifdef WINDOW_OVERLAP
	pfnOverlapFilter = DummyFilter;
#endif /*WINDOW_OVERLAP*/
	if (FAltDown())
		HiliteDialogAccel();
		
	EndDraw();

	while (1)
		{
		PollKeyboard();

		while (PeekMessage(&msg))
			{
			/* check to see if the filter ended the dialog */
			if (pwndDialog->wParamEnd != 0)
				goto break_loop;
			if (msg.message == WM_CHAR && msg.wParam == VK_MENU)
				{
				/* ALT DOWN */
				if (!fShowDlgAccel)
					HiliteDialogAccel();
				}
#ifdef	MULTIPLE_ACTION
			else if (msg.message == WM_CHAR)
				{
				if (!(HIWORD(msg.lParam) & KK_MENU) ||
				    !FProcessAccel(msg.wParam))
				    {
				    if (DispatchMessage(&msg) == ((DWORD) FALSE))
				    	{
					    if (!FProcessAccel(msg.wParam))
							{
							/* Dialog Control did not eat key */
							if (HIWORD(msg.lParam) & KK_MENU)
								{
								/* Invalid ALT selection */
								Beep();
								}
							else
						        	SendMessage(pwndDialog, WM_CHAR,
									msg.wParam, msg.lParam);
							}
						}
				    }
			    }
			else
			    {
				DispatchMessage(&msg);
				}	
#else	/* MULTIPLE_ACTION */
			else if (DispatchMessage(&msg) == ((DWORD) FALSE) &&
			    msg.message == WM_CHAR)
				{
				if (!FProcessAccel(msg.wParam))
					{
					/* Dialog Control did not eat key */
					if (HIWORD(msg.lParam) & KK_MENU)
						{
						/* Invalid ALT selection */
						Beep();
						}
					else
						SendMessage(pwndDialog, WM_CHAR,
						    msg.wParam, msg.lParam);
					}
				}
#endif	/* MULTIPLE_ACTION */

			/* now check to see if it ended the dialog */
			if (pwndDialog->wParamEnd != 0)
				goto break_loop;
			}

		/* check for idle case */
		if (pwndDialog->wParamEnd != 0)
			goto break_loop;

		/* else idle */
#ifdef DUAL
		if (fProtectMode)
			{
			/* send idle message (will return TRUE if we should sleep */
			if (SendMessageShort(pwndDialog, WM_IDLE))
				{
				/* see if the idle message told us to die */
				if (pwndDialog->wParamEnd != 0)
					goto break_loop;
				/* sleep, wait for input */
				DosSemWait(hsemaMessage, -1L);
				}
			}
		else
			{
			SendMessageShort(pwndDialog, WM_IDLE);
			}
#else /*!DUAL*/
#ifndef DOS5
		SendMessageShort(pwndDialog, WM_IDLE);
#else
		/* send idle message (will return TRUE if we should sleep */
		if (SendMessageShort(pwndDialog, WM_IDLE))
			{
			/* see if the idle message told us to die */
			if (pwndDialog->wParamEnd != 0)
				goto break_loop;
			/* sleep, wait for input */
			DosSemWait(hsemaMessage, -1L);
			}
#endif
#endif /*!DUAL*/

		}
break_loop:
	Assert(pfnFilter == DialogFilterProc);
	pfnFilter = pfnFilterOld;
#ifdef WINDOW_OVERLAP
	Assert(pfnOverlapFilter == DummyFilter);
	pfnOverlapFilter = pfnOverlapFilterOld;
#endif /*WINDOW_OVERLAP*/

	/* restore old state of world */
	pwndRoot = pwndRootOld;
	pfnDlg = pfnDlgOld;
	pwndDlg = pwndDlgOld;

#ifdef DIALOG_LINE
	fTwoLineDlg = fTwoLineOld;
#endif /*DIALOG_LINE*/

#ifdef WINDOW_OVERLAP
	RethinkDisplay();
#endif /* WINDOW_OVERLAP */

	fShowDlgAccel = fShowDlgAccelOld;
	/* KLUDGE ALERT: restore old capture, if there was window with the
		capture then put in a few fake messages */
	if ((pwndCapture = pwndCaptureOld) != NULL)
		PostMouseUpMessages();

#ifndef DIALOG_NOSAVE

	/* Restore contents under dialog */
	DrawThisWnd(NULL);  /* Set cur window to NULL */
#ifdef KANJI
	fRestoreDbcs = TRUE;		/* for DBCS repaint */
#endif	/*KANJI*/
	RestoreArc(pwndDialog->arcWindow.axLeft - daxDbcs,
	    pwndDialog->arcWindow.ayTop,
	    pwndDialog->arcWindow.axRight + daxShadow + daxDbcs,
	    pwndDialog->arcWindow.ayBottom + dayShadow,
	    lpbSave);
	if (lpbWorkTemp == NULL)
		FreeWorkFar(lpbSave);
#ifdef KANJI
	fRestoreDbcs = FALSE;
#endif	/*KANJI*/

#else	// DIALOG_NOSAVE
	ScreenRedraw();
	pwndFocus = NULL;
	if (pwndDlg != NULL)
		{
		if (pwndDlg2 != pwndDlg && pwndDlg2 != NULL)
			DrawWindow(pwndDlg2);
		if (pwndDlg != pwndDialog)
			DrawWindow(pwndDlg);
		}
	else
		pwndDlg2 = NULL;
#endif	// DIALOG_NOSAVE

	FEnableMenuBar(fMenuEnabled);
	pwndFocus = pwndFocusOld;
	fButtonAction = FALSE;		/* clear for parent dialogs */
	UpdateCursor();
	KillAlarm();			/* just in case */

	return(pwndDialog->wParamEnd);
	}




STATIC PWND
PwndPreviousControl(pwndRoot, pwndControl)
/*
  -- Searches the list of children windows of pwndRoot for the window before
	pwndControl.
  -- If pwndControl is the first window in the list, find the last window
	in the list.
  -- Note: Assumes that there is at least 1 control in the dialog box.
*/
PWND pwndRoot;
REGISTER PWND pwndControl;
	{
	REGISTER PWND pwndCur = pwndRoot->pwndChild;

	if (pwndControl == pwndCur)
		pwndControl = NULL;
	while (pwndCur->pwndSibling != pwndControl)
		pwndCur = pwndCur->pwndSibling;
	return(pwndCur);
	}




BOOL FARPRIVATE
DialogFilterProc(pmsg)
/*
  -- filter procedure for Dialogs (filter characters)
	(ignore repeat counts most of the time)
*/
REGISTER PMSG pmsg;
	{
	REGISTER PWND pwnd;

	switch (pmsg->message)
		{
	default:
		return FALSE;
		/*break*/

	case WM_CHAR:

		pwnd = pwndDlg;
		/* Use LOBYTE of wParam since we
		   don't care about key translation */
		switch (LOBYTE(pmsg->wParam))
		{
		default:
			/* help if HELP key
			   (but not recursive or if using special buffer */
			if (pmsg->wParam == VK_HELP_KEY && lpbWorkTemp == NULL)
				{
				(*pfnDlg)(pwnd, WM_HELP,
					HIWORD(pmsg->lParam), 0L);
				return TRUE;
				}
			return FALSE;
	
		case LOBYTE(VK_RETURN):
			{
			PWND	pwndAction;
			PWND	pwndFocusOld;
	
			if ((pwndFocus->style & WS_TYPE) == WS_BUTTON &&
			    ((pwndFocus->style & WS_SUBSTYLE)
							== BS_PUSHBUTTON ||
			     (pwndFocus->style & WS_SUBSTYLE)
							== BS_DEFPUSHBUTTON))
				pwndAction = pwndFocus;
			else if ((pwndAction = PwndDefaultPushButton(pwnd))
							== NULL)
				return FALSE;
				/*break; let return through */
	

			if (!pwndAction->fEnabled)
				return FALSE;
				/*break: ignore if disabled */

			Assert(pwndFocus != NULL);
			SendMessageShort(pwndFocusOld=pwndFocus,WM_KILLFOCUS);
			pwndFocus = NULL;

			(*pfnDlg)(pwnd, WM_DIALOG, pwndAction->id,
			    MAKELONG(pwndFocus->id, 1));
	
			if (pwnd->wParamEnd == 0 && pwndFocus == NULL)
				{
				/* don't end the dialog yet => restore focus */
				SetFocus(pwndFocusOld);
				}
			}
			break;

		case LOBYTE(VK_ESCAPE):
			/* lParam == 1L => escape key */
			(*pfnDlg)(pwnd, WM_DIALOG, IDCANCEL, MAKELONG(0, 1));
			break;
	
		case LOBYTE(VK_TAB):
			{
			REGISTER PWND pwndCur = pwndFocus;
//
// a-emoryh - Default Shift+Tab handling was not working correctly in the new
//    FilePrint dialog, forcing me to process VK_TAB myself in this case.
//
         if ((pwndPrintEdit != NULL) &&
             (pwndFocus == pwndPrintEdit))
         {
            // Let the edit-control handle the tab.
            return FALSE;
         }

			do
				{
				if (HIWORD(pmsg->lParam) & KK_SHIFT)
					pwndCur =
					  PwndPreviousControl(pwnd, pwndCur);
				else
					{
					pwndCur = pwndCur->pwndSibling;
					if (pwndCur == NULL)
						pwndCur = pwnd->pwndChild;
					}
				}
			while (!SendMessageShort(pwndCur, WM_WANTFOCUS));
			SetFocus(pwndCur);
			UpdateCursor();
			}
			break;

			}
		break;

		}

	if (pwnd->wParamEnd != 0)
		{
		/* turn message into a harmless one */
		pmsg->pwnd = pwnd;
		pmsg->message = WM_ENDDIALOG;
		return FALSE;
		}

	UndoRepeat(pmsg->wParam, pmsg->lParam);	/* undo repeat for key */
	return TRUE;
	}



DWORD FARPUBLIC			/* WndProcs are PUBLIC */
DialogWndProc(pwnd, message, wParam, lParam)
/*
  -- Processes messages in a dialog.
   The Dialog Manager (this routine) receives, and interprets messages sent
   to a dialog. These messages may come from the system (key strokes, mouse
   movement, etc.), or from controls which are in the dialog box.
   The Dialog Manager keeps track of which control has the input focus
   (notifying the controls when they gain or loose the input focus).
   Some messages are passed on to the Dialog Specific Manager for further
   interpretation.
*/
REGISTER PWND pwnd;
WORD message, wParam;
DWORD lParam;
	{
	RRC rrc;
	switch (message)
		{

	case WM_PAINT:
		GetClientRrc(pwnd, &rrc);
		BeginDraw();
		FillRrc(pwnd, &rrc, ' ', isaDialogBox);
		DrawDialogBorder(pwnd);
		DrawThisWnd(NULL);      /* No window defined yet */
		ShadowArc(&pwnd->arcWindow);
		EndDraw();
		/* fall through to propagate message */

	default:
		return ((*pfnDlg)(pwnd, message, wParam, lParam));

	case WM_SETFOCUS:
		{
		REGISTER PWND pwndT = pwnd->pwndChild;
		while (!SendMessageShort(pwndT, WM_WANTFOCUS))
			{
			pwndT = pwndT->pwndSibling;
			AssertSz(pwndT, "No control can receive focus");
			}
		Assert(SendMessageShort(pwndT, WM_WANTFOCUS));
		SendMessageShort(pwndFocus = pwndT, WM_SETFOCUS);
		UpdateCursor();
		}
		break;

		}
	return(0L);
	}




VOID FARPRIVATE
EndDialog(pwnd, wParam)
REGISTER PWND pwnd;
WORD wParam;
/*	This routine is called to terminate a dialog. Quit messages should
   not be posted, it is done through this routine. The reason is to insure
   that only 1 quit message appears in the queue at a time, thus preventing
   the case were the quit message handling is slower then the keyboard and
   we are quited right out of qb. */
	{
	REGISTER PWND pwndCtl = pwnd->pwndChild;

	Assert(wParam != 0);
	Assert(pwnd == pwndDlg);
	if (pwnd->wParamEnd == 0)
		{
		/* free up stuff used by list boxes */
		while (pwndCtl)
			{
			if (pwndCtl->style & WS_LISTBOX)
				SendMessageShort(pwndCtl, LB_RESETCONTENT);
			pwndCtl = pwndCtl->pwndSibling;
			}

		pwnd->wParamEnd = wParam;
		}
	}



STATIC BOOL
FProcessAccel(wParam)
/*
  -- process a key event that may be an accelerator
  -- return TRUE if processed (i.e. key eaten)
  -- NOTE : we only find first match (accelerators MUST be unique) !!!
  -- NOTE : accelerators must be alphabetic
*/
WORD wParam;	/* wParam of WM_CHAR (ch or vk) */
	{
	/* walk the tree looking for a match */
	REGISTER PWND pwnd;
	REGISTER BYTE chTest;
#ifdef ACCEL_MULTIPLE
	WORD	cwndMatch;
#endif /*ACCEL_MULTIPLE*/
#ifdef KANJI
	char	chOther;		/* alternate Roman/Kana */
#endif /*KANJI*/

	Assert(PwndChild(pwnd) != NULL);

	if (wParam > VK_MIN)
		{
		if (wParam == VK_RIGHT)
			wParam = chRightArrow;
		else if (wParam == VK_LEFT)
			wParam = chLeftArrow;
		else if (wParam < VK_0 || wParam > VK_Z)
			{
			/* probably not a valid accelerator */
			return FALSE;
			}
		}

	chTest = LOBYTE(wParam);
	if (chTest >= 'a' && chTest <= 'z')
		chTest -= 'a' - 'A';
	else if ((unsigned) chTest > 0x7f)
		chTest = ChUpperFromChExt(chTest);

#ifdef KANJI
	chOther = ChAlternateKeytop(chTest);
#endif /*KANJI*/

#ifdef ACCEL_MULTIPLE
	/* test for multiple accelerators */
	cwndMatch = 0;

	for (pwnd = PwndChild(pwndDlg); pwnd != NULL; pwnd = PwndSibling(pwnd))
		{
		if (pwnd->aclDialog != aclNil)
			{
			char	ch = ChAccel(pwnd);

			if (ch >= 'a' && ch <= 'z')
				ch -= 'a' - 'A';
			else if ((unsigned) ch > 0x7f)
				ch = ChUpperFromChExt(ch);

			if (ch == chTest)
				cwndMatch++;
			}
		}
	if (cwndMatch == 0)
		return FALSE;
#endif /*ACCEL_MULTIPLE*/

	/* go next from focus */
	Assert(pwndFocus != NULL && PwndParent(pwndFocus) == pwndDlg);

	pwnd = pwndFocus;
	do
		{
		if ((pwnd = PwndSibling(pwnd)) == NULL)
			pwnd = PwndChild(pwndDlg);	/* wrap */

		if (pwnd->aclDialog != aclNil)
			{
			char	ch = ChAccel(pwnd);

			if (ch >= 'a' && ch <= 'z')
				ch -= 'a' - 'A';

#ifndef KANJI
			if (ch == chTest)
#else
			if (ch == chTest || ch == chOther)
#endif
				{
				/* we got one */
				if ((pwnd->style & WS_TYPE) == WS_STATIC)
					{
					/* pointing to preceding text,
					    skip 1 */
					pwnd = PwndSibling(pwnd);
					}

				/* can't have 2 text in a row */
				Assert((pwnd->style & WS_TYPE) != WS_STATIC);

				/* set focus if it will let us demand it */
				if (SendMessage(pwnd, WM_WANTFOCUS, 1, 0L))
					{
					SetFocus(pwnd);
					/* activate enabled items */
#ifdef ACCEL_MULTIPLE
					if (cwndMatch > 1)
						return TRUE;	/* just move */
#endif /*ACCEL_MULTIPLE*/

					/* Activate it if enabled */
					if (pwnd->fEnabled)
						SendMessageShort(pwnd, WM_MAKEACTIVE);
					return TRUE;
					}

				}
			}
		}
	while (pwnd != pwndFocus);

	/* no luck */
	return FALSE;
	}



VOID FARPUBLIC
SetDialogCaption(hdlg, sz)
/*
  -- modify the caption of a dialog
  -- hdlg is not currently used (for modeless dialogs)
*/
HANDLE hdlg;
char *sz;
	{
	AssertSz(hdlg == NULL, "SetDialogCaption : hdlg != NULL");
	AssertSz(pwndDlg != NULL, "SetDialogCaption : no modal dialog");
	
	pwndDlg->szDialog = (WORD) sz;
	DrawDialogBorder(pwndDlg);
	}



STATIC VOID
DrawDialogBorder(pwnd)
/*
  -- draw the border around a dialog
*/
REGISTER PWND pwnd;
	{
	DrawBorder(pwnd, &boxSingle, isaDialogBox, (char *) pwnd->szDialog);
#ifdef DIALOG_LINE
	{
	/* draw the line near the bottom of the Dialog Box */
	AY	ay;
	RRC	rrc;

	GetClientRrc(pwnd, &rrc);
	if (fTwoLineDlg)
		rrc.ryBottom--;
	rrc.ryTop = (rrc.ryBottom -= dayBorder) - dayBorder;
	ay = AyOfRy(pwnd, rrc.ryTop);
	FillRrc(pwnd, &rrc, chTopSide1, isaDialogBox);
	CharOutAbs(pwnd->arcWindow.axLeft, ay, chMiddleLeft1, isaDialogBox);
	CharOutAbs(pwnd->arcWindow.axRight - daxBorder, ay, chMiddleRight1, isaDialogBox);
	}
#endif /*DIALOG_LINE*/
	}



VOID FARPUBLIC
HiliteDialogAccel()
/*
  -- hilite dialog accelerators
*/
	{
	REGISTER PWND pwndT;

	fShowDlgAccel = TRUE;
	/* paint all dialog accelerator windows */
	for (pwndT = PwndChild(pwndDlg);
	    pwndT != NULL;
	    pwndT = PwndSibling(pwndT))
		{
		if (pwndT->aclDialog != aclNil)
			{
			BeginDraw();
			DrawWindow(pwndT);
			EndDraw();
			}
		}
	}



WORD FARPRIVATE
CwSizeDialog(parc)
/*
  -- return size of rectangle needed for dialog
  -- adjust for fFontAvailable and shadow
*/
REG ARC * parc;
	{
	WORD	cw;

	cw = (parc->axRight-parc->axLeft+daxShadow) *
	    (parc->ayBottom-parc->ayTop+dayShadow);

#ifdef SCREEN_FFONT
	if (fFontAvailable)
		cw *= 2;
#endif /*SCREEN_FFONT*/

	return cw;
	}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\dirlist5.c ===
/*
	COW : Character Oriented Windows
	(COW USER DIALOG)

	dirlist.c : Directory dir list control
*/

#define COW
#include <cow.h>


#ifdef LISTBOX_DIR			/* entire file */

#define DIRLIST

#include <udialog.h>
#include <uevent.h>
#include <uwindow.h>
#include <uutil.h>
#include "dialog.h"
#include "event.h"
#include "listbox.h"
#include "window.h"
#include "util.h"

#include "dirlist.h"
#include "_dirlist.h"


extern char szWildAll[];


/* forward */
BOOL FAR PASCAL FBuildDirectoryList(PWND, char *, PWND, BOOL, char *);




BOOL FAR
FBuildDirectoryList(pwnd, szPath, pwndDir, fSetPath, szTemp)
/*
  -- DOS5 VERSION !!

  -- build up the directory list
  -- NOTE : if pwnd == NULL, then don't fill files
  -- return TRUE if ok, FALSE if illegal szPath (bad dir)
  -- if valid path and fSetPath, return in *szPath the path less the file name
*/
char *	szPath;
PWND	pwnd;
PWND	pwndDir;	/* where to put drives / directories */
BOOL	fSetPath;	/* TRUE => set path if ok */
char *	szTemp;		/* temporary storage passed down to save stack space */
	{
	FDE	fde;
	char	chDrive;
	BOOL	fRoot;			/* TRUE => root of directory tree */
	BOOL	fAbsPath;		/* TRUE => absolute path */
	char *	szFileName;		/* simple file name */
	char *	szPathOrig = szPath;	/* original path address */

	while (szPath[0] == ' ')
		szPath++;

	/* check to see if there is a valid directory */
	if ((szFileName = SzDirSpec(szPath, szTemp, &fRoot)) == NULL)
		{
		goto not_valid_dir;
		}

	if (!fRoot)
		{
		/* not a root directory, try looking for the directory
		    (like doing a stat()) */
		BOOL fOk;

		fOk = FFindFirst(&fde, szTemp, atrDir);
		FindClose();

		if (!fOk)
			{
			/* directory is bogus */
not_valid_dir:
			/* if we get an invalid directory,
			   we don't want to change (with the exception that
			   if this is a drives/directory only listbox
			   (i.e. pwnd == NULL) then we should fill it)
			*/
			if (pwnd != NULL)
				return FALSE;	/* bogus directory */
			fRoot = TRUE;
			fSetPath = FALSE;
			}
		}

	if (fSetPath)
		{
		SetCurrentPath(szPath);
		strcpy(szPathOrig, szFileName);
		szPath = szFileName = szPathOrig;	/* just filename left */
		fAbsPath = FALSE;
		}
	else
		{
		/* starting out, absolute if any prefix (relative if *.*) */
		fAbsPath = (szTemp[0] != '*');
		}
	
	/* we are going to move, reset list boxes */
	if (pwnd != NULL)
		SendMessageShort(pwnd, LB_RESETCONTENT);
	Assert(pwndDir != NULL)
	SendMessageShort(pwndDir, LB_RESETCONTENT);

	/* use FindFirst/Next twice */
	if (pwnd != NULL &&
	    *szPath != '\0')
		{
		if (FFindFirst(&fde, szPath, atrFile))
			{
			do
				{
				Assert(!(fde.atr & atrDir));
				AddListString(pwnd, fde.szName);
				}
			while (FFindNext(&fde));
			}
		FindClose();
		}

	if (FFindFirst(&fde, szWildAll, atrDir))
		{
		do
			{
			if ((fde.atr & atrDir) &&
			    !(fde.szName[0] == '.' && fde.szName[1] == '\0'))
				{
				if (pwndDir == pwnd)
					{
					/* 1 listbox => throw in [] */
					MakeDirName(fde.szName, szTemp);
					AddListString(pwndDir, szTemp);
					}
				else
					{
					/* add simple */
					AddListString(pwndDir, fde.szName);
					}
				}
			}
		while (FFindNext(&fde));
		}
	FindClose();

	/* lastly drives */
	strcpy(szTemp, "[- -]");
	for (chDrive = 'A'; chDrive <= 'Z'; chDrive++)
		{
		if (FValidDrive(chDrive))
			{
			szTemp[2] = chDrive;
			AddListString(pwndDir, szTemp);
			}
		}
	return TRUE;	/* all ok */
	}


#endif /*LISTBOX_DIR*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\editmgr.inc ===
include edityp.inc

MAXCHARS equ 256

DEBPUBLIC	macro	n
ifdef DEBPUB
	public	n
endif
ENDM

; CW util provided routines
externFPublic	SetAlarm

; LIBC routines
externFP	_memset
ifndef	PROJECT_QB
externFP        _memmove
endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\dlgutil.c ===
/*
	COW : Character Oriented Windows

	dlgutil.c : dialog utility routines
*/

#define COW
#include <cow.h>

#define DIALOG

#include <udialog.h>
#include <uevent.h>
#include <uwindow.h>
#include <uedit.h>

#include "dialog.h"
#include "window.h"
#include "util.h"


PRIVATE VOID FARPRIVATE
SetDlgItemText(pwnd, szText, fDisplay)
/*
  -- set the text for a given item
  -- allow tilde characters for non-edit items
*/
REGISTER PWND pwnd;		/* the actual item */
char *szText;
BOOL fDisplay;
	{
	REGISTER char *pchSrc = szText;
	Assert(pwnd != NULL);

	if ((pwnd->style & WS_TYPE) == WS_EDIT)
		SetEditText(pwnd, pchSrc, fDisplay);
	else
		{
		WORD cch;			/* max # of chars */
		REGISTER char * pchDest;
		BOOL	fNoAccel;

		fNoAccel = (pwnd->style & WS_TYPE) == WS_STATIC_NOACCEL;
		cch = pwnd->cchDialog;
		Assert(cch > 0);
		pchDest = (char *) pwnd->szDialog;
		Assert(pchDest != NULL);

		pwnd->aclDialog = aclNil;
		while (1)
			{
			switch (*pchSrc)
				{
			default:
default_char:
				*pchDest++ = *pchSrc++;
#ifndef KANJI
add_char:
#endif
				if (--cch != 0)
					break;	/* continue */
				/* else fall through to terminate */
			case '\0':
				/* terminate & we are done */
				*pchDest = '\0';
				goto done_scan;
				
			case chPrefix1:
				if (fNoAccel)
					goto default_char;
				/* set accelerator, show character */
				AssertSz(pwnd->aclDialog == aclNil &&
				    *(pchSrc+1) != '\0',
				    "Bogus ~ name");
#ifndef KANJI
				Assert(pchSrc - szText < 256);
				if (*(pchSrc+1) == chPrefix1)
					{
					/* two accelerators => use one */
					pchSrc++;
					goto default_char;
					}
				pwnd->aclDialog = (((BYTE)
				    (pchSrc - szText)) << 8) +
				    *((unsigned char *)pchSrc+1);
				pchSrc++;
#else
				/* two choices for R/K accelerators */
				AssertSz(pchSrc == szText,
				   "Kana accelerators must be at start of string");
				/* Roman in lobyte, Kana in high */
				pchSrc++;	/* skip prefix */
				pwnd->aclDialog = *(WORD *)pchSrc;
				/* show proper dialog accelerator */
				*pchDest++ = *(fKanaAccel ? pchSrc+1 : pchSrc);
				pchSrc += 2;
#endif /*KANJI*/
				break;

#ifndef KANJI
			case chPrefix2:
				if (fNoAccel)
					goto default_char;
				/* set accelerator, show blank */
				AssertSz(pwnd->aclDialog == aclNil &&
				    *(pchSrc+1) != '\0',
				    "Bogus double~ name");
				Assert(pchSrc - szText < 256);
				pwnd->aclDialog = (((BYTE)
				    (pchSrc - szText)) << 8) +
				    *((unsigned char *)pchSrc+1);
				pchSrc += 2;	/* skip prefix & accel character */
				*pchDest++ = ' ';
				goto add_char;
				/*break;*/
#endif
				}
			}
		}
done_scan:
	if (fDisplay)
		DrawWindow(pwnd);
	}


PRIVATE WORD FARPRIVATE
GetDlgItemText(pwnd, sz, cchMax)
/*
  -- get the text associated with a listbox, edit or static text item;
	copies up to cchsz characters into the buffer sz; returns the number
	of characters copied into the buffer
*/
REGISTER PWND pwnd;	/* the actual item */
WORD cchMax;
REGISTER char *sz;
	{
	WORD cch;

	Assert(pwnd != NULL);
	switch(pwnd->style & WS_TYPE)
		{
	case WS_LISTBOX:
		return(GetListText(pwnd, sz, cchMax));
		break;
	case WS_EDIT:
		return(GetEditText(pwnd, sz, cchMax));
		break;
	default:
		{
		REGISTER char *szDlg = (char *) pwnd->szDialog;

		for (cch = 0; *szDlg != '\0' && cch < cchMax; cch++)
			*sz++ = *szDlg++;
		*sz = '\0';
		return(cch);
		break;
		}

		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\event.c ===
/*
	COW : Character Oriented Windows

	event.c - Main event handler
*/

#define COW
#include <cow.h>

#define EVENT
#include <uevent.h>
#include <vkey.h>
#include <umenu.h>
#include <uwindow.h>
#include <uscreen.h>
#include <kinput.h>
#include <kkeyboar.h>
#include <uutil.h>
#ifdef EXTRAS
#include <cowextra.h>
#endif

#ifdef WINDOW_OVERLAP
#include "overlap.h"
#endif

#include "window.h"
#include "menu.h"
#include "util.h"

#ifdef DUAL
#include <os2.h>
extern	WORD	fProtectMode;
#else
#ifdef DOS5
#include <os2.h>
#endif
#endif

#include "event.h"
#include "_event.h"

#ifdef	KANJI
extern	BYTE	fMenu;
extern	VOID	FAR PASCAL	NotifyKKFocus(BOOL);
#endif	// KANJI

/* ------------------------------------------------------------ */

PUBLIC VOID FARPUBLIC
UngetMessage(pmsg)
/*
  -- push a message onto the front of the queue
*/
PMSG pmsg;
	{
	StartPublic();
	AssertSz(!fUseCache, "too many successive UngetMessage() calls");

	msgCache = *pmsg;
	fUseCache = TRUE;

	StopPublic();
	}



VOID FARPRIVATE
UndoRepeat(wParam, lParam)
/*
  -- call for WM_CHAR messages only !!
  -- unget a message if repeat count > 1
*/
WORD	wParam;
DWORD	lParam;
	{
#ifdef KANJI
	if ((lParam & KJ_COUNT) == 1)
#else
	if (LOWORD(lParam) == 1)
#endif
		return;		/* last key */
	Assert(!fUseCache);
	/* msgCache will be filled in later */
	msgCache.message = WM_CHAR;
	msgCache.wParam = wParam;
	/* DECREMENT LOW WORD */
	(*((WORD *) &lParam))--;
	msgCache.lParam = lParam;
	msgCache.time = 0L;			/* bogus time */
	fUseCache = TRUE;
	}


PRIVATE VOID FARPRIVATE
PostMouseUpMessages()
/*
  -- KLUDGE
  -- when restoring the capture to an old Window, we want to make sure
	that they are not waiting for a MOUSEUP message by posting a
	MOUSEUP message for both the buttons.
  -- This may cause extra MOUSEUP messages to windows which have the focus
  -- NOTE: this uses the last known mouse position and the current keyboard
	 shift states
*/
	{
	WORD	wParam = 0;

	/* get shift states from keyboard handler */
	wParam = MkGetShiftStates();

	FQueueMsg(&msgqMouse, NULL, WM_RBUTTONUP, wParam,
	    mspPrev.lParam, ClockTicks());
	FQueueMsg(&msgqMouse, NULL, WM_LBUTTONUP, wParam,
	    mspPrev.lParam, ClockTicks());
	}



PRIVATE VOID FARPRIVATE
RePostMouseMessage(message, wParam, lParam)
/*
  -- re-post a mouse message if mouse queue empty
  -- used if SetCapture / ReleaseCapture moves outside window.
*/
WORD message;
WORD wParam;
DWORD lParam;
	{
	if (msgqMouse.cmsg == 0)
		FQueueMsg(&msgqMouse, NULL, message, wParam, lParam, 0L);
		/* Note : time == 0L => remove from queue first */
	}


#ifdef EXTRAS

DWORD FARPUBLIC
SendMessageToSibbling(pwnd, message, wParam, lParam)
/*
  -- for fake overlap of windows
  -- send message to sibbling in chain if applicable
  -- capture should not be set
*/
PWND pwnd;
WORD message;
WORD wParam;
DWORD lParam;
	{
	PWND pwndSave;
	MSG msg;

	Assert(pwndCapture == NULL);
	Assert(message >= WM_MOUSEFIRST && message <= WM_MOUSELAST);
	if (PwndSibling(pwnd) == NULL)
		return FALSE;

	/* save old tree */
	pwndSave = pwndRoot;
	/* move tree temporarily */
	pwndRoot = PwndSibling(pwnd);

	msg.pwnd = NULL;
	msg.message = message;
	msg.wParam = wParam;
	msg.lParam = lParam;
	FindMouseWnd(&msg);
	Assert(msg.pwnd != NULL);

	/* move tree back */
	pwndRoot = pwndSave;

	/* send the message to sibbling (or child of sibbling) */
	return (SendMessage(msg.pwnd, msg.message, msg.wParam, msg.lParam));
	}
#endif /*EXTRAS*/


PUBLIC BOOL FARPUBLIC
PostMessage(pwnd, message, wParam, lParam)
/*
  -- queues a message
  -- returns FALSE if it cannot queue the message (queue full)
*/
PWND pwnd;
WORD message, wParam;
DWORD lParam;
	{
	StartPublic();
	SetMessage();
	ReturnPublic(FQueueMsg(&msgqAppl, pwnd, message, wParam, lParam, ClockTicks()), BOOL);
	}



PUBLIC PWND FARPUBLIC
SetCapture(pwnd)
/*
  -- Specify the window to capture mouse messages.
  -- return the old window with the mouse capture
  -- when pwndCapture is set the menu is disabled
*/
PWND pwnd;
	{
	StartPublic();
	PWND pwndRet = pwndCapture;	/* return value */

	AssertSz(pwndCapture == NULL || pwndCapture == pwnd || pwnd == NULL,
	    "Capturing a mouse twice");

	pwndCapture = pwnd;

	ReturnPublic(pwndRet, PWND);
	}



PUBLIC VOID FARPUBLIC
ReleaseCapture()
/*
  -- release the mouse capture
*/
	{
	StartPublic();
	SetCapture(NULL);
	StopPublic();
	}



PUBLIC DWORD FARPUBLIC
DispatchMessage(pmsg)
/*
  -- send message to its proper WndProc
*/
REGISTER PMSG pmsg;
	{
	StartPublic();
	REGISTER PWND pwnd;
	pwnd = pmsg->pwnd;
	if (pwnd)
		{
		/* may leave COW to process WndProc */
		ReturnLeave((*pwnd->pfnWndProc)(pwnd, pmsg->message, pmsg->wParam, pmsg->lParam), DWORD);
		}
	else
		{
		ReturnPublic(0L, DWORD);
		}
	}



DWORD FARPUBLIC
SendMessage(pwnd, message, wParam, lParam)
PWND pwnd;
WORD message;
WORD wParam;
DWORD lParam;
	{
	StartPublic();
	Assert(pwnd != NULL);
	Assert(HIWORD(pwnd->pfnWndProc) != 0);
	ReturnLeave((*pwnd->pfnWndProc)(pwnd, message, wParam, lParam), DWORD);
	}



WORD FARPRIVATE
SendMessageShort(pwnd, message)
/*
  -- shorter send message
  -- returns only WORD
*/
PWND pwnd;
WORD message;
	{
	Assert(pwnd != NULL);
	return (WORD) ((*pwnd->pfnWndProc)(pwnd, message, 0, 0L));
	}

PUBLIC PWND FARPUBLIC
GetFocus()
	{
	StartPublic();
	ReturnPublic(pwndFocus, PWND);
	}

PUBLIC PWND FARPUBLIC
SetFocus(pwnd)
/*
  -- move the input focus to window "pwnd"
  -- send the appropriate messages
  -- control the hardware cursor accordingly
  -- NOTE : weird recursion call
	if the KILLFOCUS message causes a SetFocus(), then this has
	priority (to allow SetFocus() calls for dlmChange).
*/
REGISTER PWND pwnd;
	{
	StartPublic();
	REGISTER PWND pwndOld;

	if (pwnd != (pwndOld = pwndFocus))
		{
		if (pwndOld != NULL)
			{
			SendMessageShort(pwndOld, WM_KILLFOCUS);
			}

		if (pwndFocus == pwndOld)
			{
			/* did not change due to KILLFOCUS */
			SendMessageShort(pwndFocus = pwnd, WM_SETFOCUS);
			}
		}
#ifdef	KK_UNIT
	fMenu = FALSE;
	NotifyKKFocus (TRUE);
#endif	// KK_UNIT


	UpdateCursor();

	ReturnPublic(pwndOld, PWND);
	}


#ifdef MOUSE_EXTRAS

PUBLIC WORD FARPUBLIC
SetDoubleClickTime(time)
/*
  -- 1/18 of a second for DOS 3, ms for DOS 5
*/
WORD time;
	{
	StartPublic();
	WORD timeRet = timeDoubleClick;
	timeDoubleClick = time;			/* save as word */
	ReturnPublic(timeRet, WORD);
	}

#endif /*MOUSE_EXTRAS*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\edityp.inc ===
;*
;*	COW : Character Oriented Windows
;*
;*	edityp.inc : Multi-line edit manager main structures
;*	* REVIEW : these should be cleaned up.
;*	* REVIEW : this should be generated from "umedit.h"
;*	* NOTE: this file is tied to "umedit.h" -- which is currently
;*		a public file !!


; Single line descriptor. All editing is done on this structure and then
; transfered to buffer.
LD	STRUC
	LD_flags	dw	0h
	LD_cb		dw	00h	;number of bytes in line buffer
	LD_cbMax	dw	0100h	;max. of bytes (size) allowed in buffer
	LD_prgch   	dw      0h	;pointer to line buffer
LD	ENDS

; Insertion point. Currency structure for current edit field
IP	STRUC
	IP_ob	dw	0	;offset for left edge of buffer
	IP_oln	dw	0	;offset within file 
IP	ENDS

; Program descripter. Currency for program (current buffer). This is used
; with the text manager to control what part of the current buffer is in
; view and what buffer line is in the line descripter
PD	STRUC
	pd_olntop	dw	0	;offset within file for top of screen
	pd_obleft	dw	0	;offset to left edge of screen
	pd_oln		dw	0	;line offset that is in ldCur
PD	ENDS

; General edit field structure. This is passed into EditMgr. Between calls
; to the edit manager it contains all state information about a particular
; edit field.
EF	STRUC
	EF_hBuffer	dw	0
	EF_pdCur	db	size pd dup(?)
	EF_ipCur	db	size ip dup(?)
	EF_ipAnchor	db	size ip dup(?)
	EF_pldCur	dw	?
	EF_pwndScrollV	dw	0
	EF_pwndScrollH	dw	0
	EF_attrCur	dw	0
	EF_Style	db	0
	EF_fSelection	db	0
EF	ENDS

EF_pdCur_olnTop		equ	word ptr EF_pdCur.PD_olnTop
EF_pdCur_obleft		equ	word ptr EF_pdCur.PD_obleft
EF_pdCur_oln		equ	word ptr EF_pdCur.PD_oln
EF_ipCur_ob		equ	word ptr EF_ipCur.IP_ob
EF_ipCur_oln		equ	word ptr EF_ipCur.IP_oln
EF_ipAnchor_ob		equ	word ptr EF_ipAnchor.IP_ob
EF_ipAnchor_oln		equ	word ptr EF_ipAnchor.IP_oln

LINEATTR STRUC
LA_attr	dw	?
LA_cb	dw	?
LINEATTR ENDS

;styles:
ES_MULTILINE    equ	0001H
ES_NOREDRAW	equ	0002H
ES_NOSELECT	equ	0004H
EF_MOVECURSOR	equ	0008H
ES_KK_UNIT	equ	0080H

;control messages:
EM_SELCHARS	equ	WM_USER+0
EM_REPLACESEL	equ	WM_USER+1
EM_GETWORD	equ	WM_USER+2
EM_GETLINESEL	equ	WM_USER+3
WM_UNDO 	equ	WM_USER+4
WM_CLEAR	equ	WM_USER+5
WM_SETTEXT	equ	WM_USER+6
WM_GETTEXT	equ	WM_USER+7
WM_SEARCHFIND	equ	WM_USER+8
WM_SEARCHCHANGE equ	WM_USER+9
WM_SETBOOKMARK	equ	WM_USER+10
WM_GOTOBOOKMARK equ	WM_USER+11
WM_SETREDRAW	equ	WM_USER+12
WM_SEARCHNEXT	equ	WM_USER+13
WM_MATCHBRACE	equ	WM_USER+14
WM_FLUSHFOCUS	equ	WM_USER+15
EM_MOVECURSOR	equ	WM_USER+16

pefExtra	equ	(rgwExtra+2)

; ldCur.flags values
LD_fDirty			EQU	0001H

; emFlags values
EMF_IN_EDITMGR			EQU	01H
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\edittbls.inc ===
ifdef	EDIT_USE_TABLES
LabelB	DefaultEditMgrTbls
	db	4 , "Alt", 0		; Name of ACTION Key
	db	4 , "Esc", 0		; Name of CANCEL key
	dw	VK_MENU, VK_F11, VK_ESCAPE AND 0ffh, VK_F12
LabelB	DefaultDoCharDispatch
else	; !EDIT_USE_TABLES
LabelB	DoCharDispatch
endif	; EDIT_USE_TABLES
	MainEditTable	IgnoreChar		  ; Null
	MainEditTable	WordLeft		  ; ^A
	MainEditTable	NearBeep		  ; ^B
	MainEditTable	PageDown		  ; ^C
	MainEditTable	CharRight		  ; ^D
	MainEditTable	LineUp			  ; ^E
	MainEditTable	WordRight		  ; ^F
	MainEditTable	Del			  ; ^G
	MainEditTable	Backspace		  ; ^H
	MainEditTable	TabOrBackTab		  ; ^I
	MainEditTable	NextLine		  ; ^J
ifdef	EDIT_USE_TABLES
	MainEditTable	DoPrefixTable		  ; ^K
	MainEditTable	SearchNext		  ; ^L
else	; ! EDIT_USE_TABLES
	MainEditTable	CtrlKState		  ; ^K
	MainEditTable	NearBeep		  ; ^L
endif	; EDIT_USE_TABLES
	MainEditTable	NewLine 		  ; ^M
	MainEditTable	SplitLine		  ; ^N
	MainEditTable	NearBeep		  ; ^O
ifdef	EDIT_USE_TABLES
	MainEditTable	DoQuoteCharacter	  ; ^P
	MainEditTable	DoPrefixTable		  ; ^Q
else	; ! EDIT_USE_TABLES
	MainEditTable	CtrlPState		  ; ^P
	MainEditTable	CtrlQState		  ; ^Q
endif	; EDIT_USE_TABLES
	MainEditTable	PageUp			  ; ^R
	MainEditTable	CharLeft		  ; ^S
	MainEditTable	DelWord 		  ; ^T
ifdef	EDIT_USE_TABLES
	MainEditTable	ResetState		  ; ^U
else	; EDIT_USE_TABLES
	MainEditTable	IgnoreChar		  ; ^U
endif	; EDIT_USE_TABLES
	MainEditTable	ToggleInsertMode	  ; ^V
	MainEditTable	ScrollUp		  ; ^W
	MainEditTable	LineDown		  ; ^X
	MainEditTable	KillLine		  ; ^Y
	MainEditTable	ScrollDown		  ; ^Z
ifdef	EDIT_USE_TABLES
	MainEditTable	DoEsc			  ; ^[ (ESC)	27
	MainEditTable	IgnoreChar		  ; ^\		28
	MainEditTable	MatchBrace		  ; ^]		29
	MainEditTable	IgnoreChar		  ; ^^		30
	MainEditTable	IgnoreChar		  ; ^_		31
	MainEditTable	Del			  ; DEL		127 ****
endif	; EDIT_USE_TABLES

ifdef	EDIT_USE_TABLES
	dw	KeyDispatchEnd - KeyDispatch
endif	; EDIT_USE_TABLES
LabelB	KeyDispatch
	KeyTableEntry	VK_TAB, TabOrBackTab
	KeyTableEntry	VK_INSERT, MaybeToggleInsertMode
	KeyTableEntry	VK_PRIOR, PageUp
	KeyTableEntry	VK_NEXT, PageDown
	KeyTableEntry	VK_END, EndLine
	KeyTableEntry	VK_HOME, HomeLine
	KeyTableEntry	VK_LEFT, CharLeft
	KeyTableEntry	VK_RIGHT, CharRight
	KeyTableEntry	VK_UP, LineUp
	KeyTableEntry	VK_DOWN, LineDown
	KeyTableEntry	0, IgnoreKey
ifdef	EDIT_USE_TABLES
KeyDispatchEnd:

	dw	(CtrlKeyDispatchEnd - CtrlKeyDispatch)
endif	; EDIT_USE_TABLES
LabelB	CtrlKeyDispatch
	KeyTableEntry	VK_PRIOR, FullPageLeft
	KeyTableEntry	VK_NEXT, FullPageRight
	KeyTableEntry	VK_END, EndPgm
	KeyTableEntry	VK_HOME, BegPgm
	KeyTableEntry	VK_LEFT, WordLeft
	KeyTableEntry	VK_RIGHT, WordRight
	KeyTableEntry	VK_UP, ScrollUp
	KeyTableEntry	VK_DOWN, ScrollDown
	KeyTableEntry	0, IgnoreKey
ifdef	EDIT_USE_TABLES
CtrlKeyDispatchEnd:

	dw	2			;* Number of Prefix tables

	;* Ctrl-Q

	dw	(CtrlQDispatchEnd - CtrlQDispatch)
	dw	''*2			;* Offset in table

endif	; EDIT_USE_TABLES
LabelB CtrlQDispatch
ifdef	EDIT_USE_TABLES
	SecondEditTable	'0',GotoBookmark0
	SecondEditTable	'1', GotoBookmark1
	SecondEditTable	'2', GotoBookmark2
	SecondEditTable	'3', GotoBookmark3
	SecondEditTable '', ResetState
endif	; EDIT_USE_TABLES
	SecondEditTable	'', BegLine
	SecondEditTable	's', BegLine
	SecondEditTable	'S', BegLine
	SecondEditTable	'', EndLine
	SecondEditTable	'd', EndLine
	SecondEditTable	'D', EndLine
	SecondEditTable	'', HomeScn
	SecondEditTable	'e', HomeScn
	SecondEditTable	'E', HomeScn
	SecondEditTable	'', EndScn
	SecondEditTable	'x', EndScn
	SecondEditTable	'X', EndScn
	SecondEditTable	'', EraseEol
	SecondEditTable	'y', EraseEol
	SecondEditTable	'Y', EraseEol
	SecondEditTable	'', Undo
	SecondEditTable	'l', Undo
	SecondEditTable	'L', Undo
	SecondEditTable	'', BegPgm
	SecondEditTable	'r', BegPgm
	SecondEditTable	'R', BegPgm
	SecondEditTable	'', EndPgm
	SecondEditTable	'c', EndPgm
	SecondEditTable	'C', EndPgm
	SecondEditTable	'', DispatchFind
	SecondEditTable	'F', DispatchFind
	SecondEditTable	'f', DispatchFind
	SecondEditTable	'', DispatchChange
	SecondEditTable	'A', DispatchChange
	SecondEditTable	'a', DispatchChange
	SecondEditTable	0, IgnoreChar

ifdef	EDIT_USE_TABLES
CtrlQDispatchEnd:
	
	dw	(CtrlKDispatchEnd - CtrlKDispatch)
	dw	''*2

LabelB	CtrlKDispatch
	SecondEditTable '', ResetState
	SecondEditTable	'0', SetBookmark0
	SecondEditTable	'1', SetBookmark1
	SecondEditTable	'2', SetBookmark2
	SecondEditTable	'3', SetBookmark3
	SecondEditTable	0, IgnoreChar
CtrlKDispatchEnd:

	;*
	;*	VK dispatch tables
	;*
	
	dw	0			;* Number of prefix tables
endif	; EDIT_USE_TABLES
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\event.h ===
/*
	COW : Character Oriented Windows

	event.h : event cow private interface
*/

/* internal COW control messages */
#define	WM_INITDIALOG			0x0381
#define	WM_IDLE				0x0382	/* DIALOG IDLE */
#define	WM_HELP				0x0383	/* DIALOG HELP */
#define	WM_ENDDIALOG			0x0384
#define	WM_KEYSTATE			0x0385	/* Change in shift states */
#define	WM_DIALOG_SETFOCUS		0x0386
#define	WM_DIALOG_KILLFOCUS		0x0387

/*PRIVATE*/
WORD		FARPRIVATE SendMessageShort(PWND, WORD);
VOID		FARPRIVATE RePostMouseMessage(WORD, WORD, DWORD);
BOOL		FARPRIVATE DummyFilter(struct _msg *);
/* alarm */
BOOL		FARPRIVATE FCheckAlarm(struct _msg *);
VOID		FARPRIVATE UndoRepeat(WORD, DWORD);
VOID		FARPRIVATE PostMouseUpMessages(void);

VOID		FAR PASCAL MouseMessage(WORD);

typedef union _msp
	{
	struct
		{
		BYTE rx;
		BYTE ry;
		BYTE ax;
		BYTE ay;
		} s;
	DWORD lParam;
	} MSP;	/* Mouse position (maps to lParam) */


typedef BOOL	(FARPRIVATE *PFFN_FILTER)(PMSG);	/* filter */
extern PFFN_FILTER pfnFilter;
extern PWND PASCAL pwndFocus;
#ifdef WINDOW_OVERLAP
extern PFFN_FILTER pfnOverlapFilter;
#endif /*WINDOW_OVERLAP*/

#define	VkOfVw(vw)	((WORD) (vw) + VK_MIN)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\editfuns.inc ===
public EditIndexTable
labelW	EditIndexTable
EDITFUNCTION	Backspace			;0
EDITFUNCTION	BegLine
EDITFUNCTION	BegPgm
EDITFUNCTION	CharLeft
EDITFUNCTION	CharRight
EDITFUNCTION	Del				;10
EDITFUNCTION	DelWord
EDITFUNCTION	DispatchChange
EDITFUNCTION	DispatchFind
EDITFUNCTION	DoEsc
EDITFUNCTION	DoPrefixTable			;20
EDITFUNCTION	EndLine
EDITFUNCTION	EndPgm
EDITFUNCTION	EndScn
EDITFUNCTION	EraseEol
EDITFUNCTION	FullPageLeft			;30
EDITFUNCTION	FullPageRight
EDITFUNCTION	GotoBookmark0
EDITFUNCTION	GotoBookmark1
EDITFUNCTION	GotoBookmark2
EDITFUNCTION	GotoBookmark3			;40
EDITFUNCTION	HomeLine
EDITFUNCTION	HomeScn
EDITFUNCTION	IgnoreChar
EDITFUNCTION	IgnoreKey
EDITFUNCTION	InsertKey			;50
EDITFUNCTION	KillLine
EDITFUNCTION	LineDown
EDITFUNCTION	LineUp
EDITFUNCTION	MaybeToggleInsertMode
EDITFUNCTION	NearBeep			;60
EDITFUNCTION	NextLine
EDITFUNCTION	NewLine
EDITFUNCTION	PageDown
EDITFUNCTION	PageUp
EDITFUNCTION	DoQuoteCharacter		;70
EDITFUNCTION	ResetState
EDITFUNCTION	ScrollDown
EDITFUNCTION	ScrollUp
EDITFUNCTION	SetBookMark0
EDITFUNCTION	SetBookMark1			;80
EDITFUNCTION	SetBookMark2
EDITFUNCTION	SetBookMark3
EDITFUNCTION	SplitLine
EDITFUNCTION	TabOrBackTab
EDITFUNCTION	ToggleInsertMode		;90
EDITFUNCTION	Undo
EDITFUNCTION	WordLeft
EDITFUNCTION	WordRight
EDITFUNCTION	SearchNext
EDITFUNCTION	MatchBrace			;100
EDITFUNCTION	DoVkPrefixTable
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\eventlow.c ===
/*
	COW : Character Oriented Windows

	event.c - Main event handler
*/

#define COW
#include <cow.h>

#define EVENT
#include <uevent.h>
#include <vkey.h>
#include <umenu.h>
#include <uwindow.h>
#include <uscreen.h>
#include <kinput.h>
#include <kkeyboar.h>
#include <uutil.h>
#ifdef EXTRAS
#include <cowextra.h>
#endif

#ifdef KK_UNIT
BOOL	FARPUBLIC KKFilter(PMSG);
#endif

#ifdef WINDOW_OVERLAP
#include "overlap.h"
#endif

#include "window.h"
#include "menu.h"
#include "util.h"

#ifdef DUAL
#include <os2.h>
extern	WORD	fProtectMode;
#else
#ifdef DOS5
#include <os2.h>
#endif
#endif

#include "event.h"
#include "_event.h"

/* ----------------------------------------------------------------------- */

#ifdef RECORD_PLAYBACK
/* Forward declarations */
BOOL FAR PASCAL PlayBackMsg(MSG *);
VOID FAR PASCAL RecordMsg(MSG *);
#endif


#ifdef PROFILE
int PASCAL crefCow = 0;		/* reference count of Cow Public entries */
#endif

#ifdef DOS5
/* NOTE : semaphore is CLEARED when a message is ready !! */
PUBLIC DWORD PASCAL semaMessage = 0;	/* RAM semaphore */
#else
#ifdef	DUAL
PUBLIC DWORD PASCAL semaMessage = 0;	/* RAM semaphore */
#endif
PUBLIC BOOL PASCAL fMessage = FALSE;
#endif

PRIVATE PWND PASCAL pwndRoot = NULL;		/* root window */

MSG msgNull = {0, WM_NULL, 0, 0l, timeMsgMax};	/* a NULL message */

MSGQ msgqAppl = {0, &msgNull, &msgqAppl.rgmsg[0]};
MSGQ msgqKeyboard = {0, &msgNull, &msgqKeyboard.rgmsg[0]};
MSGQ msgqMouse = {0, &msgNull, &msgqMouse.rgmsg[0]};

PMSG pmsgLast = &msgNull;
	/* last message queued used by keyboard and mouse handlers */
PMSG pmsgLastKeyboard = &msgNull;	/* for TSR kludge */

/* window with the focus */
PWND pwndFocus = NULL;
/* window with the mouse capture */
PWND pwndCapture = NULL;

/* Filter of messages */
PRIVATE BOOL FARPRIVATE DummyFilter(PMSG);	/* forward declaration */
PRIVATE PFFN_FILTER pfnFilter = DummyFilter;
#ifdef WINDOW_OVERLAP
PRIVATE PFFN_FILTER pfnOverlapFilter = OverlapFilter;
#endif /*WINDOW_OVERLAP*/

/* Mouse control */
WORD timeDoubleClick = timeDoubleClickDefault;
MSP mspPrev = { 0xff, 0xff, 0xff, 0xff }; /* position of last move */

/* for 1 level of UngetMessage */
BYTE fUseCache = FALSE;
MSG msgCache;

/* Menu Info : see note in MENU.H */
PRIVATE MNI mniCur = { imenuNil, iitemNil, NULL, FALSE, FALSE, FALSE };

/* ----------------------------------------------------------------------- */

/* forward */
STATIC BOOL FNextMsg(MSG *);
STATIC VOID DequeueTopMsg(MSGQ *);
STATIC PWND PwndLocate(PWND, AX, AY);
STATIC VOID CheckDoubleClick(MSG *);

/* ----------------------------------------------------------------------- */


PUBLIC BOOL FARPUBLIC
PeekMessage(pmsg)
/*
  -- check to see if a message is ready
  -- return TRUE if *pmsg filled with a message
  -- return FALSE if no messages pending
  -- always poll the keyboard
*/
PMSG pmsg;
	{
	StartPublic();

	do
		{
		/* don't always poll the keyboard */
		if (fPollKeyboard)
			PollKeyboard();

		ClearMessage();
		fAbort = FALSE;

		/* try to get a message from Cache or Queue */
		if (fUseCache)
			{
			*pmsg = msgCache;
			fUseCache = FALSE;
			/* if cached message is keyboard, use the current
				focus */
			if (msgCache.message >= WM_KEYFIRST &&
			    msgCache.message <= WM_KEYLAST)
				pmsg->pwnd = pwndFocus;
			}
		else
			{
			if (!FNextMsg(pmsg))
				{
				/* event's background process */
				if (!FCheckAlarm(pmsg))
					ReturnPublic(FALSE, BOOL);
				}
#ifdef RECORD_PLAYBACK
			else
				RecordMsg(pmsg);
#endif
			}
		}
#ifndef WINDOW_OVERLAP
#ifdef	KK_UNIT
	while (KKFilter(pmsg) || (*pfnFilter)(pmsg));
#else	// KK_UNIT
	while ((*pfnFilter)(pmsg));
#endif	// KK_UNIT
#else
	while ((*pfnFilter)(pmsg) || (*pfnOverlapFilter)(pmsg));
#endif /*WINDOW_OVERLAP*/

	ReturnPublic(TRUE, BOOL);
	}



STATIC BOOL
FNextMsg(pmsgDest)
/*
  -- Obtain the next message from the queue by looking at the three event queues
  -- return FALSE if there are no messages
  -- fill *pmsgDest with the message
*/
PMSG pmsgDest;
	{
	/* Get a message from each of the queues */
	PMSG pmsgAppl, pmsgKeyboard, pmsgMouse;

retry:
	/* If the menu is active, block application messages */
	pmsgAppl = FMenuActive() ? &msgNull : msgqAppl.pmsgHead;
	pmsgKeyboard = msgqKeyboard.pmsgHead;
	pmsgMouse = msgqMouse.pmsgHead;

	if (pmsgKeyboard->time < pmsgAppl->time)
		{
		if (pmsgMouse->time < pmsgKeyboard->time)
			goto mouse_event;
		/* keyboard earliest */

		pmsgKeyboard->pwnd = pwndFocus;

		*pmsgDest = *pmsgKeyboard;

		DequeueTopMsg(&msgqKeyboard);
		pmsgLastKeyboard = pmsgLast;
#ifdef DOS3
		/* if TSR present, poll to get next message */
		fPollKeyboard = TRUE;
#endif /*DOS3*/

		/* if message is a shift state change, call UpdateShiftKk */
		if (pmsgDest->message == WM_KEYSTATE)
			{
			static WORD	ssOld = 0;
#ifdef KANJI
			static WORD	ssOldKj = 0;
#endif

			UpdateShiftKk(pmsgDest->wParam, ssOld);
			ssOld = pmsgDest->wParam;
#ifdef KANJI
			UpdateShiftKj(LOWORD(pmsgDest->lParam), ssOldKj);
			ssOldKj = LOWORD(pmsgDest->lParam);
#endif
			goto retry;		/* get another */
			}
		}
	else if (pmsgMouse->time < pmsgAppl->time)
		{
		/* mouse earliest */
	mouse_event:
		*pmsgDest = *pmsgMouse;
		DequeueTopMsg(&msgqMouse);
		/* clean up mouse message */
		FindMouseWnd(pmsgDest);
		CheckDoubleClick(pmsgDest);
#ifdef DEBUG
		/* RIGHT BUTTON USED AS DEVELOPMENT HOOK */
		if (pmsgDest->message == WM_RBUTTONDOWN &&
		    FTrapMouseRbutton())
			goto retry;
#endif /*DEBUG*/
		}
	else if (pmsgAppl->time != timeMsgMax)
		{
		/* application earliest */
		*pmsgDest = *pmsgAppl;
		DequeueTopMsg(&msgqAppl);
		}
	else
		{
		/* all 3 queues had null messages when we entered */
#ifdef RECORD_PLAYBACK
		{
		static BOOL fPlayback = FALSE;

		if ((fPlayback = !fPlayback) && PlayBackMsg (pmsgDest))
			{
			if (pmsgDest->message >= WM_MOUSEFIRST &&
			    pmsgDest->message <= WM_MOUSELAST)
				FindMouseWnd(pmsgDest);
			else
				pmsgDest->pwnd = pwndFocus;
			return TRUE;
			}
		}
#endif
		if (!FMenuActive())
			return FALSE;	/* no message available */
		/* never return if inside menu */
		*pmsgDest = msgNull;
		}
	return TRUE;
	}



STATIC VOID
DequeueTopMsg(pmsgq)
/*
  -- dequeue the top message of the specified queue
  -- if pmsgLast == the message being dequeued, then set pmsgLast to &msgNull
  -- the queue must be originally non-empty
  -- if queue gets empty, stick &msgNull in head slot
*/
MSGQ *pmsgq;
	{
	DisableInterrupts();
	AssertSz(pmsgq->cmsg > 0, "Dequeueing an empty queue");
	if (pmsgLast == pmsgq->pmsgHead)
		pmsgLast = &msgNull;
	if (--pmsgq->cmsg == 0)
		pmsgq->pmsgHead = &msgNull;
	else if (++(pmsgq->pmsgHead) == &pmsgq->rgmsg[imsgMax])
		pmsgq->pmsgHead = &pmsgq->rgmsg[0];
	EnableInterrupts();
	}



PUBLIC VOID FARPUBLIC
FlushAbort()
/*
  -- Flush all keyboard messages up to the first ESCAPE
  -- for TSR keyboard input there should be 1 escape key only
  -- can be called from TSR with SS != DS
*/
	{
	REGISTER MSG *pmsg;

	/* if a key in the cache, then flush it */
	if (fUseCache && msgCache.message >= WM_KEYFIRST &&
	    msgCache.message <= WM_KEYLAST)
		{
		/* it was a keyboard message */
		fUseCache = FALSE;
		if (msgCache.message == WM_CHAR && msgCache.wParam == VK_ESCAPE)
			return;	/* already have an escape */
		}

	while ((pmsg = msgqKeyboard.pmsgHead) != &msgNull)
		{
		BOOL	fDone;

		fDone = pmsg->wParam == LOBYTE(VK_ESCAPE);
		DequeueTopMsg(&msgqKeyboard);
		if (fDone)
			break;		/* quit after first ESCAPE */
		}
	}



#ifdef	KANJI
VOID FAR PASCAL /* called by kanji keyboard driver */
KeyboardMessage(sc, vw, wParamKey, kk, fKeyUp)
#else	// !KANJI
VOID FAR PASCAL	/* called by keyboard driver */
KeyboardMessage(vw, wParamKey, kk, fKeyUp)
#endif	// KANJI
/*
  -- called by PollKeyboard for polled input
  -- normally generate only WM_CHAR Messages
  -- two special cases for WM_KEYUP :
		VK_SPACE		(needed for buttons)
		VK_MENU			(needed for menus)
  -- all events at this level set Message
*/
#ifdef	KANJI
BYTE sc;		/* Scan code for KANJI KK-unit */
#endif	// KANJI
BYTE vw;		/* Windows virtual key */
WORD wParamKey;		/* wParam for WM_KEY */
REGISTER WORD kk;	/* KK shift states */
BOOL fKeyUp;		/* TRUE => WM_KEYUP, FALSE => WM_CHAR */
	{
	WORD message;
	WORD vk;				/* the virtual key only */
#ifdef KANJI
	WORD kj;	/* KJ shift states */

	kj = kk & KJ_KK;
	Assert((kj & KJ_COUNT) == 0);
	kk &= ~KK_VK;
#endif

	Assert(vw <= 0xff);
	vk = VkOfVw(vw);			/* change virtual key */

#ifndef KANJI
	Assert((kk & KK_VK) == 0);
#endif

	if (!fKeyUp)
		{
		/* key depressed */
		message = WM_CHAR;
		if (vk == VK_ESCAPE)
			{
			/* ABORT case */
			fAbort = TRUE;
			}
		else if (pmsgLast->message == WM_CHAR &&
#ifdef KANJI
		    (pmsgLast->lParam & KJ_COUNT) < KJ_COUNT &&
#endif
		    pmsgLast->wParam == wParamKey &&
		    kk == HIWORD(pmsgLast->lParam) &&
		    /* BUG FIX FOR WORKS : don't repeat ENTER or ALT KEYS */
		    !(kk & KK_MENU) && wParamKey != LOBYTE(VK_RETURN))
			{
			/* coallese keydown repeat counts */
			pmsgLast->lParam++;
			return;		/* message already posted */
			}
		kk |= vk;
		}
	else if (vw != 0)
		{
		/* key released */
		message = WM_KEYUP;
		kk |= vk;
		}
	else
		{
		/* just change in shift state */
		/* wParamKey = kkOld, kk = kkNew */
		if (pmsgLastKeyboard->message == WM_KEYSTATE)
			{
			/* coalesce shift key transitions */
			pmsgLastKeyboard->wParam = kk;
			SetMessage();
			return;
			}

		message = WM_KEYSTATE;
		wParamKey = kk;		/* new shift states */
		}

#ifdef KANJI
	if (!FQueueMsg(&msgqKeyboard, NULL, message, wParamKey,
		       MAKELONG(MAKEWORD(1 | kj, sc), kk),
#else
	if (!FQueueMsg(&msgqKeyboard, NULL, message, wParamKey, MAKELONG(1, kk),
#endif /*KANJI*/
	    ClockTicks()))
		{
		/* buffer full !! */
		Beep();
		}

	pmsgLastKeyboard = pmsgLast;
	SetMessage();	/* after every key event seen here */
	}



VOID FAR PASCAL
MouseMessage(message)
/*
  -- post a mouse message
  -- This routine is called as part of an interrupt service routine.
	It does not ensure that SS == DS, so this routine, and any routine
	it calls MUST NOT take the address of stack variables (procedure
	parameters and locals).

	Message format :
		message = WM_...
		wParam  = MK_ code for keys down
		lParam  = mouse coordinates
			LOBYTE(LOWORD(lParam)) = rx
			HIBYTE(LOWORD(lParam)) = ry
			LOBYTE(HIWORD(lParam)) = ax
			HIBYTE(HIWORD(lParam)) = ay
*/
WORD message;
	{
	REGISTER WORD wParam = sstMouse;

	if (message == WM_MOUSEMOVE)
		{
		if (mspPrev.s.ay == ayMouse && mspPrev.s.ax == axMouse)
			return;	/* same place */
		mspPrev.s.ax = axMouse;
		mspPrev.s.ay = ayMouse;
		if (pmsgLast->message == WM_MOUSEMOVE)
			{
			/* change coordinates of last message */
			pmsgLast->lParam = mspPrev.lParam;
			return;
			}
		/* only set Message if the mouse moved with a button down */
		if (wParam != 0)
			SetMessage();
		}
	else
		{
		SetMessage();
		}

	/* get shift states from keyboard handler */
	wParam |= MkGetShiftStates();

	FQueueMsg(&msgqMouse, NULL, message, wParam,
	    mspPrev.lParam, ClockTicks());
	}


PRIVATE BOOL
FQueueMsg(pmsgq, pwnd, message, wParam, lParam, time)
/*
  -- Queue a message - return TRUE if Queued
  -- does not set Message
  -- can be called from TSR with SS != DS
*/
MSGQ *pmsgq;
PWND pwnd;
WORD message, wParam;
DWORD lParam;
DWORD time;
	{
	PMSG pmsg;
	if (pmsgq->cmsg == imsgMax)
		return(FALSE);
	pmsg = pmsgq->pmsgNext;
	/* NOTE : we can only change the head if it was pointing at msgNull */
	if (pmsgq->cmsg++ == 0)
		{
		/* count was 0 => we better be pointing to msgNull */
		Assert(pmsgq->pmsgHead == &msgNull);
		pmsgq->pmsgHead = pmsg;		/* set head */
		}
	else
		{
		Assert(pmsgq->pmsgHead != &msgNull);
		}
	if (++(pmsgq->pmsgNext) == &pmsgq->rgmsg[imsgMax])
		pmsgq->pmsgNext = &pmsgq->rgmsg[0];	/* wrap around */

	pmsgLast = pmsg;
	pmsg->pwnd = pwnd;
	pmsg->message = message;
	pmsg->wParam = wParam;
	pmsg->lParam = lParam;
	pmsg->time = time;
	return(TRUE);
	}



STATIC PWND
PwndLocate(pwnd, ax, ay)
REGISTER PWND pwnd;
AX ax;
AY ay;
/*
  -- Check if the mouse is pointing within or to a sibbling of the current
     window.
  -- returns pointer to window in containing mouse or NULL if none
*/
	{
	AssertSz(pwnd != NULL, "invalid call to PwndLocate");

	do
		{
		if ((ax < pwnd->arcWindow.axRight) &&
		    (ax >= pwnd->arcWindow.axLeft) &&
		    (ay < pwnd->arcWindow.ayBottom) &&
		    (ay >= pwnd->arcWindow.ayTop) &&
		    pwnd->fEnabled)
			return(pwnd);
		pwnd = pwnd->pwndSibling;
		}
	while (pwnd);
	return(NULL);


	}



PRIVATE VOID
FindMouseWnd(pmsg)
/*
  -- convert mouse message to indicate the receiver of the message
  -- If WINDOW_OVERLAP is defined we can simply use the Overlap array to
     convert the X,Y to a window pointer, else we must search.
*/
REGISTER PMSG pmsg;
	{
	REGISTER PWND pwnd;
	MSP msp;
	AX ax;
	AY ay;

	msp.lParam = pmsg->lParam;
	ax = msp.s.ax;
	ay = msp.s.ay;

	Assert(pmsg->message >= WM_MOUSEFIRST && pmsg->message <= WM_MOUSELAST);

	if (pwndRoot == NULL)
		{
		/* return absolute coordinates only */
		pmsg->pwnd = NULL;
		pmsg->lParam = msp.lParam;
		return;
		}

	if (pwndCapture != NULL)
		{
		pwnd = pwndCapture;
		}
	else
		{
#ifdef WINDOW_OVERLAP
		if (psOverlap)
			{
			/* psOverlap is the segment of the array containing
			 * the overlapping window array.  */
			pwnd = *((PWND FAR *) MAKELONG(
				sizeof(PWND)*(ay * axMac + ax), psOverlap));
			}
		else
#endif /* WINDOW_OVERLAP */
			{
			if (pwnd = PwndLocate(pwndRoot, ax, ay))
				{
				PWND pwndChild;
				/* found the root window containing mouse */
				/* scan till no more children or mouse is
				   outside all pwnd's children */
				while ((pwndChild = pwnd->pwndChild) != NULL &&
				    (pwndChild = PwndLocate(pwndChild, ax, ay))
				      != NULL)
					pwnd = pwndChild;
				}
			}
		}

	if (pwnd == NULL)
		{
		/* no enabled window to receive mouse input */
		Assert(pmsg->pwnd == NULL);
		return;
		}

	/* update msg with window specific info */
	pmsg->pwnd = pwnd;
	msp.s.rx = ax - pwnd->arcClipping.axLeft;
	msp.s.ry = ay - pwnd->arcClipping.ayTop;

	/* set bits for non-client */
	if (ax < pwnd->arcClipping.axLeft ||
	    ax >= pwnd->arcClipping.axRight)
		pmsg->wParam |= MK_NONCLIENT_X;
	if (ay < pwnd->arcClipping.ayTop ||
	    ay >= pwnd->arcClipping.ayBottom)
		pmsg->wParam |= MK_NONCLIENT_Y;

	pmsg->lParam = msp.lParam;
	}



STATIC VOID
CheckDoubleClick(pmsg)
/*
  -- test to see if message should be converted to a double click
*/
REGISTER PMSG pmsg;
	{
	static DWORD timeLeft = 0L;
	static DWORD timeRight = 0L;
	static DWORD lParamOld;
	if (pmsg->lParam != lParamOld)	/* mouse has moved */
		{
		lParamOld = pmsg->lParam;
		timeLeft = timeRight = 0L;
		}
	else if (pmsg->message == WM_LBUTTONDOWN)
		{
		if (timeLeft && pmsg->time - timeLeft < timeDoubleClick)
			{
			pmsg->message = WM_LBUTTONDBLCLK;
			timeLeft = 0L;
			}
		else
			{
			timeLeft = pmsg->time;
			}
		}
	else if (pmsg->message == WM_RBUTTONDOWN)
		{
		if (timeRight && pmsg->time - timeRight < timeDoubleClick)
			{
			pmsg->message = WM_RBUTTONDBLCLK;
			timeRight = 0L;
			}
		else
			{
			timeRight = pmsg->time;
			}
		}
	}



PRIVATE BOOL FARPRIVATE
DummyFilter(pmsg)
PMSG pmsg;
	{
	Unreferenced(pmsg);
	return(FALSE);
	}


VOID FAR PASCAL	/* called by keyboard driver */
SpecialTsrAbort()
/*
  -- special TSR abort occured
  -- set the fAbort flag
  -- flush the input buffer (should contain at most 1 character)
  -- insert 1 ESCAPE message
  -- can be called from TSR with SS != DS
*/
	{
#ifdef DUAL
	if (fProtectMode)
		return;
#endif /*DUAL */
#ifndef DOS5
	Assert(!fNormalKeyboard);	/* only call if TSR driven keyboard */

	fAbort = TRUE;
	FlushAbort();
	FQueueMsg(&msgqKeyboard, NULL, WM_CHAR, LOBYTE(VK_ESCAPE), MAKELONG(1, VK_ESCAPE),
	    ClockTicks());
#endif /*!DOS5*/
	}



BOOL FAR PASCAL	/* called by keyboard driver */
FTestKeyboardEmpty()
/*
  -- return TRUE if there is enough room to place 1 key event in buffer
  -- we need worst case 4 messages for each key
		(ALT DOWN, SPACE UP, key, ALT UP).
  -- do special work for TSR
*/
	{
	if (fNormalKeyboard)
		return (msgqKeyboard.cmsg < imsgMax - 4);
	else
		{
		/* if TSR (i.e. MSKEY), then only look 1 ahead (for repeat)
			but not if previous was an ALT DOWN */
		if (msgqKeyboard.cmsg > 1)
			return FALSE;		/* no chance */
		else if (msgqKeyboard.cmsg == 0)
			return TRUE;		/* we have room */
		else
			{
			/* if last event was MENU (either UP or DOWN)
				then don't allow any more */
			return (pmsgLastKeyboard->wParam != VK_MENU);
			}
		}
	}


VOID FAR PASCAL
FlushKeyEvents()
/*
  -- flush key events from CW queue
  -- put them back into keyboard buffer
*/
	{
	char	rgch[imsgMax + 10];	/* max queue size + extra */
	char *	pch = rgch;
	REG MSG * pmsg;

	while ((pmsg = msgqKeyboard.pmsgHead) != &msgNull)
		{
		DequeueTopMsg(&msgqKeyboard);
		if (pmsg->message == WM_CHAR && pmsg->wParam < VK_MIN)
			{
			/* a real character */
			*pch++ = (char) pmsg->wParam;
			}
		}
	*pch = '\0';		/* terminate array */

	inkj.pfnFlushKeyRgchKbd(rgch);
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\general.h ===
/*
	COW : Character Oriented Windows

	general.h : general render cow private interface
*/

DWORD	FARPUBLIC	GeneralWndProc(PWND, WORD, WORD, DWORD);

/* Function at end of WND structure !! */
#define	PwfnCtlGeneral(pwnd)	(*((PWFN_CTL *) &pwnd->rgwExtra[cwExtraMin]))

#if cwExtraGeneral != cwExtraMin+2
.....
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\helpstub.c ===
/*
	COW : Character Oriented Windows

	helpstub.c : stub for help

	(included for applications that don't supply help)
	(for those that do, this module will not be included)
*/

#define COW
#include <cow.h>

#include <uevent.h>
#include <udialog.h>
#include <kkeyboar.h>

STATIC BOOL fInsideHelp = FALSE;


VOID FARPUBLIC
Help(hem, hid, pv, kk) 
WORD	hem;		/* help message */
WORD	hid;		/* help id */
VOID *	pv;		/* optional parameter */
WORD	kk;		/* key shift states */
	{
	Unreferenced(hem);
	Unreferenced(hid);
	Unreferenced(pv);

	if (fInsideHelp)
		return;		/* no recursive please */

	fInsideHelp = TRUE;
	MessageBox(
	   (kk & KK_SHIFT) ? "No Tutorial Available" : "No Help Available",
	   "(so leave me alone)", NULL, MB_OK);
	fInsideHelp = FALSE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\getchar.asm ===
;*
;*	CW : Character Oriented Windows
;*
;*	getchar.asm : get character at a given position.

	include	user.inc
	include	screen.inc
	include	inscr.inc

;----------------------------------------------------------------------------

sBegin	DATA
    assumes DS,DGROUP

externB <instCur>		;* INST type
externB	<axMac>			; Maximum column number

sEnd	DATA

;----------------------------------------------------------------------------

sBegin	SCREEN
    assumes CS,SCREEN
    assumes DS,DGROUP
    assumes SS,DGROUP
    assumes ES,nothing

;******  GetChar  ********
;*	entry : ax, ay
;*	exit : n/a

cProc	GetChar,<FAR,PUBLIC,ATOMIC>
parmB	axGetChar
parmB	ayGetChar

cBegin	GetChar

	mov	es,instCur.psPrimInst
	CalcCoord axGetChar,ayGetChar
	mov	bx,ax
	mov	al,es:[bx]

cEnd	GetChar

sEnd	SCREEN

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\general.c ===
/*
	COW : Character Oriented Windows

	general.c : WndProc for general pictures
*/

#define COW
#include <cow.h>

#include <uwindow.h>
#include <uevent.h>

/* really integrated into SDM */
#include <sdmver.h>
#include <usdm.h>
#include <usdmtmpl.h>
#include "sdm.h"

#include "dialog.h"
#include "general.h"


PRIVATE DWORD FARPUBLIC			/* WndProcs are PUBLIC */
GeneralWndProc(pwnd, message, wParam, lParam)
/*
  -- WndProc for general pictures
*/
REGISTER PWND pwnd;
WORD message, wParam;
DWORD lParam;
	{
	Unreferenced(lParam);

	switch(message)
		{
	default:
		break;

	case WM_WANTFOCUS:
		return((DWORD) FALSE);  /* refuse to accept the focus */
		break;

#ifdef DEBUG
	case WM_SETFOCUS:
	case WM_KILLFOCUS:
		Assert(FALSE);
		/*break;*/
#endif
		
	case WM_PAINT:
#ifdef	KANJI
		FlushDraw();
#endif	// KANJI
		(*PwfnCtlGeneral(pwnd))(tmmPaint, (VOID *) pwnd, NULL, wParam,
		    0, 0);
		break;
		}
	return TRUE;
	}



VOID FARPUBLIC
RedisplayTmc(tmc)
TMC tmc;
	{
	SendMessage(PtifFromTmc(tmc)->pwnd, WM_PAINT, tmc, 0L);
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\graphic.asm ===
;*
;*	CW : Character Windows
;*
;*	graphic.asm : GPD/GSD interface layer

	include user.inc
	include	indrv.inc
	include	ingxd.inc

;*****************************************************************************

externFP	<RerrLoadDrv,FreeIndv>

;*****************************************************************************

sBegin	BSS
    assumes DS,DGROUP

	Assert <cpfnGsdMin EQ cpfnGpdMin>

;*	* INDJ structure
labelB	<PUBLIC, indjGsd>
	DD	cpfnGsdMin DUP (0)

labelB	<PUBLIC, indjGpd>
	DD	cpfnGpdMin DUP (0)

sEnd	BSS

sBegin	DATA
    assumes DS,DGROUP

globalW	fPrinting, 0
globalW	pindjCur, <dataOffset indjGsd>

labelB	<PUBLIC, indvGsd>		;* Graphic Screen
	DB	indtGraphicScreen,0
	DW	dataOffset indjGsd
	DW	cpfnGsdMin
	DW	cpfnGsdMin
	DW	0
	DW	0

labelB	<PUBLIC, indvGpd>		;* Graphic Printer
	DB	indtGraphicPrinter,0
	DW	dataOffset indjGpd
	DW	cpfnGpdMin
	DW	cpfnGpdMin
	DW	0
	DW	0

sEnd	DATA

;*****************************************************************************
;* Load GSD file


sBegin	INIT
    assumes CS,INIT
    assumes DS,DGROUP
    assumes SS,DGROUP


;********** FreeGsd/Gpd **********
;*	entry:	bx = pindv for which driver
;*	* Free a GSD/GPD driver
;*	exit:	n/a

;* GPD free
LabelFP	<PUBLIC, FreeGpd>
	mov	bx,dataOffset indvGpd
	jmp	short FreeGsdGpd

;* GSD free
LabelFP	<PUBLIC, FreeGsd>
	mov	bx,dataOffset indvGsd

cPublic	FreeGsdGpd
cBegin	FreeGsdGpd
;* enter with BX => indv
	cCall	FreeIndv, <bx>
	
cEnd	FreeGsdGpd


;********** FLoadGsd/Gpd **********
;*	entry:	szFile = file name
;*		bx = pindv for which driver
;*	* Try and load a GSD/GPD driver
;*	exit:	AX != 0 if loaded successfully

;* GPD load
LabelFP	<PUBLIC, FLoadGpd>
	mov	bx,dataOffset indvGpd
	jmp	short FLoadGsdGpd

;* GSD load
LabelFP	<PUBLIC, FLoadGsd>
	mov	bx,dataOffset indvGsd

cPublic	FLoadGsdGpd
    parmDP szFile
cBegin	FLoadGsdGpd
;* enter with BX => indv
	mov	cx,1
	Save	<bx>
	cCall	RerrLoadDrv, <szFile, bx, cx>
	or	ax,ax
	mov	ax,0
	jnz	end_fload			;* load error
	mov	cx,[bx].psLoadedIndv
	jcxz	end_fload			;* not loaded
	inc	ax				;* success
end_fload:
	
cEnd	FLoadGsdGpd


sEnd	INIT

;*****************************************************************************

sBegin	SCREEN
    assumes CS,SCREEN
    assumes DS,DGROUP
    assumes SS,DGROUP

;********** SetPrinting **********
;*	entry: fEnablePrinting => whether we want printing or not
;*	* set up globals for subsequent graphic driver calls

cPublic	SetPrinting
    parmW  fEnablePrinting
cBegin	SetPrinting

	mov	cx,fEnablePrinting
	mov	ax,dataOffset indjGsd
	jcxz	@F				;* back to screen
	mov	ax,dataOffset indjGpd
@@:
	mov	pindjCur,ax
	mov	fPrinting,cx

cEnd	SetPrinting


;*****************************************************************************
;* Driver Stubs (see Documentation for interface details)

GD_ENTRY	MACRO label
labelFP <PUBLIC, label>
	mov	bx,pindjCur
	AssertNE <word ptr [bx].pfn&label&Indj>,0	;* trap empty vector
	jmp	[bx].pfn&label&Indj
ENDM

	GD_ENTRY	FInitGraphics
	GD_ENTRY	TermGraphics
	GD_ENTRY	Move
	GD_ENTRY	Draw
	GD_ENTRY	SetAreaPat
	GD_ENTRY	SetLinePat
	GD_ENTRY	SetLineWeight
	GD_ENTRY	SetColor
	GD_ENTRY	Text
	GD_ENTRY	Rectangle
	GD_ENTRY	Arc
	GD_ENTRY	Polygon
	GD_ENTRY	BitBlt

;*****************************************************************************

sEnd	SCREEN

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\inswap.asm ===
;*
;*	CW : Character Oriented Windows
;*
;*	inswap.asm : screen swapping (for installable screen)

.xlist
	include	user.inc

	include uisa.inc		;* for isa's
	include	screen.inc		;* screen stuff

	include	indrv.inc
	include	inscr.inc
.list

;*****************************************************************************


sBegin	DATA
    assumes DS,DGROUP

externB <instCur>		;* INST type
externB <insj>			;* INSJ type

sEnd	DATA


;*****************************************************************************


sBegin	SCREEN
    assumes CS,SCREEN
    assumes DS,DGROUP
    assumes SS,DGROUP


;*	* High level routines
;*	* (assume cPublic == FAR)



;********** CbSizeVids **********
;*	entry:	n/a
;*	* return the size of the VIDS structure needed for the current screen
;*		mode
;*	exit:	AX = size, or 0 => screen save not available

labelFP	<PUBLIC, CbSizeVids>
	jmp	insj.lpfnCbSizeVidsCsdInsj



;********** FSaveVids ********
;*	entry:	pvids = near pointer to VIDS structure
;*		pinst = near pointer to INST for new mode
;*	* fill *pvids with state of current screen mode (not screen data)
;*	exit:	AX != 0 if ok, == 0 if error

labelFP	<PUBLIC, FSaveVids>
	jmp	insj.lpfnFSaveVidsCsdInsj



;********** FRestoreVids ********
;*	entry:	pvids = near pointer to VIDS structure
;*	* restore video state with data in *pvids (not screen data)
;*	exit:	AX != 0 if ok, == 0 if error

labelFP	<PUBLIC, FRestoreVids>
	jmp	insj.lpfnFRestoreVidsCsdInsj



;********** SaveVidData ********
;*	entry:	pvids = near pointer to VIDS structure
;*		lpwBuffer = buffer to save data
;*	* save screen data into buffer
;*	exit:	n/a

labelFP	<PUBLIC, SaveVidData>
	jmp	insj.lpfnSaveVidDataCsdInsj



;********** RestoreVidData ********
;*	entry:	pvids = near pointer to VIDS structure
;*		lpwBuffer = buffer to save data (NULL => just clear screen)
;*	* restore screen data from buffer
;*	exit:	n/a

labelFP	<PUBLIC, RestoreVidData>
	jmp	insj.lpfnRestoreVidDataCsdInsj



;********** EnableVidsMonitor ********
;*	entry:	fOn => enable or disable monitor for video state
;*	* hook or unhook monitor for video state (eg. INT 10H hooks)
;*	exit:	n/a

labelFP	<PUBLIC, EnableVidsMonitor>
	jmp	insj.lpfnEnableVidsMonitorCsdInsj





sEnd	SCREEN

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\keystub.c ===
/*
	CW : Character Windows

	keystub.c : stub for keyboard : UpdateShiftKk
					UpdateShiftKj

	(included for applications that don't supply a routine)
	(for those that do, this module will not be included)
*/

#define COW
#include <cow.h>

#include <udialog.h>


VOID FARPUBLIC
UpdateShiftKk(kkNew, kkOld)
WORD kkNew, kkOld;
	{
	Unreferenced(kkNew);
	Unreferenced(kkOld);
	}

#ifdef KANJI
VOID FARPUBLIC
UpdateShiftKj(kjNew, kjOld)
WORD kjNew, kjOld;
	{
	Unreferenced(kjNew);
	Unreferenced(kjOld);
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\listbox.h ===
/*
	COW : Character Oriented Windows

	listbox.h : listbox cow private interface
*/

#define	PwfnCtlLb(pwnd)	(*((PWFN_CTL *) &pwnd->rgwExtra[cwExtraMin]))

/* Listbox Styles */

/*#define LBS_SORT  1 (defined in uwindow.h) */
#define LBS_NOTIFY			0x10
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\keysynth.c ===
/*
	CW : Character Windows

	keysynth.c : Extra shift state synthesis (KK => VK)

	(note: up for VK_SPACE and down/up for VK_ALT is handled by driver)
*/

#define COW
#include <cow.h>

#include <uevent.h>
#include <kkeyboar.h>
#include <vkey.h>


VOID FARPUBLIC
SynthesizeShiftKeys(kkNew, kkOld)
/*
  -- kkNew and kkOld should be the parameters passed to UpdateShiftKk
*/
REG WORD kkNew;
WORD	kkOld;
	{
	REG WORD kkDelta = kkNew ^ kkOld;

	if (kkDelta & KK_SHIFT)
#ifdef KANJI
		KeyboardMessage(0, LOBYTE(VK_SHIFT), VK_SHIFT, kkNew,
#else
		KeyboardMessage(LOBYTE(VK_SHIFT), VK_SHIFT, kkNew,
#endif
		    ~kkNew & KK_SHIFT);
	if (kkDelta & KK_CONTROL)
#ifdef KANJI
		KeyboardMessage(0, LOBYTE(VK_CONTROL), VK_CONTROL, kkNew,
#else
		KeyboardMessage(LOBYTE(VK_CONTROL), VK_CONTROL, kkNew,
#endif
		    ~kkNew & KK_CONTROL);
	/* NOTE: driver does this for KK_ALT */
	if (kkDelta & KK_SCRLOCK)
#ifdef KANJI
		KeyboardMessage(0, LOBYTE(VK_SCRLOCK), VK_SCRLOCK, kkNew,
#else
		KeyboardMessage(LOBYTE(VK_SCRLOCK), VK_SCRLOCK, kkNew,
#endif
		    ~kkNew & KK_SCRLOCK);
	if (kkDelta & KK_NUMLOCK)
#ifdef KANJI
		KeyboardMessage(0, LOBYTE(VK_NUMLOCK), VK_NUMLOCK, kkNew,
#else
		KeyboardMessage(LOBYTE(VK_NUMLOCK), VK_NUMLOCK, kkNew,
#endif
		    ~kkNew & KK_NUMLOCK);
	if (kkDelta & KK_CAPLOCK)
#ifdef KANJI
		KeyboardMessage(0, LOBYTE(VK_CAPLOCK), VK_CAPLOCK, kkNew,
#else
		KeyboardMessage(LOBYTE(VK_CAPLOCK), VK_CAPLOCK, kkNew,
#endif
		    ~kkNew & KK_CAPLOCK);
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\listbox.c ===
/*
	COW : Character Oriented Windows
	(COW USER DIALOG)

	listbox.c : list boxes

    Note : much of the math in the module is excessive (i.e. WORDs for BYTES)
    Note : all far pointer control is performed with limited-lifetime pointers
*/


#define COW
#include <cow.h>

#include <udialog.h>
#include <uscroll.h>
#include <uwindow.h>
#include <uscreen.h>
#include <uisa.h>
#include <uevent.h>
#include <vkey.h>
#include <kinput.h>
#include <kkeyboar.h>
#include <kmem.h>		/* kernel exports for memory management */

/* really integrated into SDM */
#include <sdmver.h>
#include <usdm.h>
#include <usdmtmpl.h>
#include "sdm.h"

#include "window.h"
#include "dialog.h"
#include "event.h"
#include "scroll.h"
#include "screen.h"
#include "util.h"
#include "case.h"

#include "listbox.h"
#include "_listbox.h"

#ifdef LISTBOX_LIMIT_SIZE
#define	cchListTextMax	64
#else
#define	cchListTextMax	256
#endif


#ifdef EXTRAS
#ifndef LISTBOX_HORIZ
#define LISTBOX_COLOR			/* listbox content may contain color */
#endif
#endif

/* REVIEW: move this to WINDOW.H !!! */
#ifdef EXTRAS
#define	chColorPrefix	((char) 0xfe)		/* => special color prefix */
#endif

/* forward */

STATIC VOID DisplayListBox(PWND);
STATIC VOID FillListBox(PWND, RY, RY, WORD);
STATIC VOID ScrollListBox(PWND, short, BOOL);
STATIC VOID ScrollHorizListBox(PWND, short);	/* LISTBOX_HORIZ only */
STATIC VOID HiliteListSel(PWND, BOOL);
STATIC VOID MoveSelection(PWND, WORD);
STATIC VOID MoveSelectionDown(PWND);
STATIC VOID MoveSelectionUp(PWND);
STATIC VOID MoveSelectionLeft(PWND, WORD);	/* LISTBOX_HORIZ only */
STATIC VOID MoveSelectionRight(PWND, WORD);	/* LISTBOX_HORIZ only */
STATIC VOID SetScrollWindow(PWND);
STATIC VOID ResetContent(PWND);
STATIC VOID AddListSz(PWND, char *, WORD);
STATIC VOID InsertSz(PWND, WORD, char *, BOOL, WORD);
STATIC VOID ReplaceSz(PWND, WORD, char *);
STATIC VOID DeleteSz(PWND, WORD, WORD);
STATIC VOID RevertToOomLb(PWND, WORD);
STATIC BOOL FLocateMatch(PWND, WORD);
STATIC VOID GetOnDemand(PWND, WORD, WORD FAR **, char FAR **, char *);
STATIC VOID FAR * LpvDeref(WORD);
#ifdef KANJI
STATIC int fdircmp(char FAR *, char FAR *);
STATIC int fjstrcmp(unsigned char FAR *, unsigned char FAR *);
#endif



PUBLIC DWORD FARPUBLIC			/* WndProcs are PUBLIC */
ListBoxWndProc(pwnd, message, wParam, lParam)
/*
  -- WndProc for List Boxes
  -- handles all messages from SDM and Dialog manager
*/
REG PWND pwnd;
WORD	message;
WORD	wParam;
DWORD	lParam;
	{
	WORD	wSelect;	/* indicates cause of selection */
	WORD	iszNew;
	REG WORD iszCur;
	MSP	msp;
	RRC	rrc;
	short	dryLb;			/* height of listbox */

#ifdef LISTBOX_HORIZ
	BOOL	fHoriz = pwnd->style & WS_HSCROLL;
#endif /*LISTBOX_HORIZ*/

	Assert(pwnd->iszCurLb != iszNil);

#ifndef LISTBOX_HORIZ
	Assert(pwnd->axCursor == AxOfRx(pwnd, rxListBoxMin));
#endif
	GetClientRrc(pwnd,&rrc);
	iszCur = FSelected(pwnd) ? pwnd->iszCurLb : iszNil;
	dryLb = rrc.ryBottom;
	wSelect = 0;

	switch(message)
		{
	default:
	/*case WM_ACTIVATE:*/
ReturnFalse:
		return((DWORD) FALSE);
		break;

	case WM_PAINT:
#ifdef DEBUG
#ifndef LISTBOX_ONELINE
		AssertSz(rrc.ryBottom - rrc.ryTop >= 2,
			    "Listbox too small");
#endif /*LISTBOX_ONELINE*/
#endif /*DEBUG*/
		DrawBorder(pwnd, &boxSingle, pwnd->isaColor, NULL);
		DisplayListBox(pwnd);
		goto ReturnTrue;

	case WM_WANTFOCUS:
		return((DWORD) pwnd->cszLb);	/* returns FALSE if empty */
		/*break;*/

	case WM_SETFOCUS:
		Assert(pwnd->cszLb != 0);
		if (pwnd->pwndParent != NULL)
			SendMessage(pwnd->pwndParent, WM_DIALOG_SETFOCUS,
					pwnd->id, 0L);
		goto ReturnTrue;

	case WM_KILLFOCUS:
		if (pwnd->pwndParent != NULL)
			SendMessage(pwnd->pwndParent, WM_DIALOG_KILLFOCUS,
					pwnd->id, 0L);
		goto ReturnTrue;

	case LB_SETCURSEL:
		if (wParam == iszNil)
			{
			/* unselect it */
			HiliteListSel(pwnd, FALSE);
			SetFSelected(pwnd, FALSE);
			}
		else if (wParam < pwnd->cszLb && wParam != iszCur)
			{
			MoveSelection(pwnd, wParam);	/* move+draw */
			}
		else
			{
			/* invalid selection: if debugging give a warning */
			AssertSz(wParam < pwnd->cszLb, "Invalid listbox selection");
			goto ReturnFalse;	/* selection not set */
			}
	
		goto ReturnTrue;
		/*break;*/

	case WM_MOUSEMOVE:
		/* ignore non-capture & client moves */
		if (!FCaptured(pwnd) || (wParam & MK_NONCLIENT))
			goto ReturnTrue;
		/* else : fall through */

	case WM_LBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
		msp.lParam = lParam;
		/* listbox must be non-empty & left button down */
		if (pwnd->cszLb == 0 || !(wParam & MK_LBUTTON))
			goto ReturnFalse;

		wSelect |= lbrMouse;

		/* we should have the mouse captured */
		if (!FCaptured(pwnd))
			{
			SetCapture(pwnd);
			SetAlarm(pwnd, ctickRepScrollStart);
			}

		if (!(wParam & MK_NONCLIENT))
			{
			/* in middle of listbox */
			SetFocus(pwnd);
			iszNew = pwnd->iszTopLb + msp.s.ry;
#ifdef LISTBOX_HORIZ
			if (fHoriz)
				{
				// bump extra width
				/* which column are we in ? */
				iszNew += ((msp.s.rx - rxListBoxMin) /
				    (pwnd->drxItemLb + 1)) * dryLb;
				}
#endif /*LISTBOX_HORIZ*/
			if (iszNew >= pwnd->cszLb)
				{
				wSelect = lbrOther;
				if (FSelected(pwnd))
					wSelect |= flbrReselect;
				iszCur = iszNil;    /* force message */
				}

			else if (message == WM_LBUTTONDBLCLK &&
			    iszNew == iszCur)
				{
				/* double click selection */
				if (FCaptured(pwnd))
					{
					ReleaseCapture();
					KillAlarm();
					}
				SendMessage(pwnd->pwndParent, WM_DIALOG,
				    pwnd->id, MAKELONG(0, LBN_DBLCLK));
				goto ReturnTrue;
				}
			else
				{
				if (iszNew == iszCur)
					wSelect |= flbrReselect;
				iszCur = iszNil;    /* force message */
				MoveSelection(pwnd, iszNew);
				}
			}
		else if (msp.s.ay < pwnd->arcClipping.ayTop)
			MoveSelectionUp(pwnd);
		else if (msp.s.ay >= pwnd->arcClipping.ayBottom)
			MoveSelectionDown(pwnd);
#ifdef LISTBOX_HORIZ
		/* special horizontal scroll */
		else if (msp.s.ax < pwnd->arcClipping.axLeft)
			MoveSelectionLeft(pwnd, 1);
		else if (msp.s.ax >= pwnd->arcClipping.axRight)
			MoveSelectionRight(pwnd, 1);
#endif /*LISTBOX_HORIZ*/
		break;

	case WM_ALARM:
		if (FCaptured(pwnd))
			{
			wSelect |= lbrMouse;
			SetAlarm(pwnd, pwnd->ctickRepLb);
			if (ayMouse < pwnd->arcClipping.ayTop)
				{
				MoveSelectionUp(pwnd);
				/* fast repeat ? */
				if (ayMouse < pwnd->arcClipping.ayTop - 2)
					SetAlarm(pwnd, pwnd->ctickRepLb / 2);
				}
			else if (ayMouse >= pwnd->arcClipping.ayBottom)
				{
				MoveSelectionDown(pwnd);
				/* fast repeat ? */
				if (ayMouse >= pwnd->arcClipping.ayBottom + 2)
					SetAlarm(pwnd, pwnd->ctickRepLb / 2);
				}
#ifdef LISTBOX_HORIZ
			/* special horizontal scroll (1 speed) */
			else if (axMouse < pwnd->arcClipping.axLeft)
				MoveSelectionLeft(pwnd, 1);
			else if (axMouse >= pwnd->arcClipping.axRight)
				MoveSelectionRight(pwnd, 1);
#endif /*LISTBOX_HORIZ*/
			}
		break;

	case WM_LBUTTONUP:
		if (!FCaptured(pwnd))
			goto ReturnFalse;	/* ignore */
		ReleaseCapture();
		KillAlarm();
		SendMessage(pwnd->pwndParent, WM_DIALOG, pwnd->id,
			MAKELONG(0,LBN_SELECT_DONE));
		goto ReturnTrue;
		/* break; */

	case WM_VSCROLL:
		{
		short	dry = 0;

		if (pwnd->cszLb == 0)
			goto ReturnFalse; /* nothing for empty listboxes */

		wSelect |= lbrScroll;

		switch (wParam)
			{
		default:
			break;

		case SB_LINEDOWN:
			dry++;			/* 1 line down */
			Assert(dry == 1);
			break;

		case SB_LINEUP:
			dry--;			/* 1 line up */
			Assert(dry == -1);
			break;

		case SB_PAGEDOWN:
			dry = dryLb;
			break;

		case SB_PAGEUP:
			dry = -dryLb;
			break;

		case SB_THUMBPOSITION:
			dry = LOWORD(lParam) - pwnd->iszTopLb;
			break;

		case SB_UPCLICK:
			SendMessage(pwnd->pwndParent, WM_DIALOG, pwnd->id,
				MAKELONG(0,LBN_SELECT_DONE));
			break;

			}

		if (dry != 0)
			ScrollListBox(pwnd, dry, TRUE);
		}
		break;

#ifdef LISTBOX_HORIZ

	case WM_HSCROLL:
		{
		if (pwnd->cszLb == 0)
			goto ReturnFalse; /* nothing for empty listboxes */

		wSelect |= lbrScroll;

		/* move selection (since scrolling makes no sense */
		switch (wParam)
			{
		default:
			break;

		case SB_LINEDOWN:
			MoveSelectionRight(pwnd, 1);
			break;

		case SB_LINEUP:
			MoveSelectionLeft(pwnd, 1);
			break;

		case SB_PAGEDOWN:
			MoveSelectionRight(pwnd, pwnd->citemWidthLb);
			break;

		case SB_PAGEUP:
			MoveSelectionLeft(pwnd, pwnd->citemWidthLb);
			break;

		case SB_THUMBPOSITION:
			{
			WORD	iszNew;
			iszNew = LOWORD(lParam) * dryLb + iszCur % dryLb;

			if (iszNew >= pwnd->cszLb)
				iszNew = pwnd->cszLb - 1;
			MoveSelection(pwnd, iszNew);
			}
			break;

			}/*switch*/

		}
		break;
#endif /*LISTBOX_HORIZ*/

	case LB_RESETCONTENT:
		ResetContent(pwnd);
		goto ReturnTrue;
		/*break;*/

	case LB_ADDSTRING:
		AddListSz(pwnd, (char *) wParam, LOWORD(lParam));
		goto ReturnTrue;
		/*break;*/

	case LB_INSERTSTRING:
		InsertSz(pwnd, HIWORD(lParam), (char *) wParam, FALSE, LOWORD(lParam));
		goto ReturnTrue;
		/*break;*/

	case LB_REPLACESTRING:
		ReplaceSz(pwnd, HIWORD(lParam), (char *) wParam);
		goto ReturnTrue;
		/*break;*/

	case LB_DELETESTRING:
		DeleteSz(pwnd, HIWORD(lParam), LOWORD(lParam));
		goto ReturnTrue;
		/*break;*/

	case LB_GETCURSEL:
		return ((DWORD) iszCur);
		/*break;*/

	case LB_GETCOUNT:
		return ((DWORD) pwnd->cszLb);
		/*break;*/

	case LB_GETTEXT:
		return ((DWORD) GetListText(
			pwnd, (char *) wParam, HIWORD(lParam)));
		/*break;*/

#ifdef LISTBOX_HORIZ
	case LB_SETWIDTH:
		/* set # item width for horizontal listboxes
		   (wParam == citem) -- usually sent before repainting */
		Assert(wParam != 0);

		pwnd->citemWidthLb = wParam;
		/* 1 extra at start and after each row */
		Assert(rxListBoxMin == 1);
		pwnd->drxItemLb = ((rrc.rxRight - 1) / wParam) - 1;

		/* KLUDGE: convert vertical listbox into horizontal */
		if (pwnd->style & WS_VSCROLL)
			{
			REG PWND pwndScrl;

			pwndScrl = PwndChild(pwnd);
			Assert(pwndScrl != NULL);
			Assert(pwndScrl->style & SBS_VERT);

			// switch scroll bar position (to bottom)
			pwndScrl->arcWindow.axLeft = pwnd->arcWindow.axLeft +
			    daxBorder;
			pwndScrl->arcWindow.axRight = pwnd->arcWindow.axRight -
			    daxBorder;
			pwndScrl->arcWindow.ayTop =
			   (pwndScrl->arcWindow.ayBottom =
			    pwnd->arcWindow.ayBottom) - dayBorder;

			// switch style & validate
			pwndScrl->style = (pwndScrl->style & ~SBS_VERT) | SBS_HORZ;
			ValidateWindow(pwndScrl);

			// switch parent style
			pwnd->style = (pwnd->style & ~WS_VSCROLL) | WS_HSCROLL;
			ValidateWindow(pwnd);
			}
		goto ReturnTrue;
#endif /*LISTBOX_HORIZ*/

	case WM_CHAR:
		/* return FALSE if key ignored */
		if ((HIWORD(lParam) & KK_MENU) || (!pwnd->fEnabled))
			goto ReturnFalse;	/* pass ALT keys through */

		UndoRepeat(wParam, lParam);

		wSelect |= lbrKeys;

		switch(wParam)
			{
		default:
			/* we should eat all non-control ascii keys
			* (they may or may not do anything)
			* control keys and non-ascii will not be eaten
			*/
			if (!FLocateMatch(pwnd, wParam) &&
			   (wParam < 0x20 || wParam >= VK_MIN))
				{
				/* control or non-ascii did not match */
				goto ReturnFalse;
				}
			break;

		case VK_LEFT:
#ifdef LISTBOX_HORIZ
			MoveSelectionLeft(pwnd, 1);
			break;
#endif /*LISTBOX_HORIZ*/

		case VK_UP:
			MoveSelectionUp(pwnd);
			break;

		case VK_RIGHT:
#ifdef LISTBOX_HORIZ
			MoveSelectionRight(pwnd, 1);
			break;
#endif /*LISTBOX_HORIZ*/

		case VK_DOWN:
			MoveSelectionDown(pwnd);
			break;

		case VK_NEXT:
#ifdef LISTBOX_HORIZ
			if (fHoriz)
				MoveSelectionRight(pwnd, pwnd->citemWidthLb);
			else
#endif /*LISTBOX_HORIZ*/
				ScrollListBox(pwnd, dryLb, TRUE);
			break;

		case VK_PRIOR:
#ifdef LISTBOX_HORIZ
			if (fHoriz)
				MoveSelectionLeft(pwnd, pwnd->citemWidthLb);
			else
#endif /*LISTBOX_HORIZ*/
				ScrollListBox(pwnd, -dryLb, TRUE);
			break;

		case ' ':
			wSelect = flbrReselect | lbrSpace;
			/* force message for change of selection */
			iszCur = iszNil;	/* force a change */
			HiliteListSel(pwnd, TRUE);
			break;

		case VK_HOME:
			if (pwnd->cszLb != 0)
				MoveSelection(pwnd, iszMin);
			break;

		case VK_END:
			if (pwnd->cszLb != 0)
				MoveSelection(pwnd, pwnd->cszLb - 1);
			break;

			}
		break;
		}

	if (FSelected(pwnd) && iszCur != pwnd->iszCurLb)
		{
		/* tell parent that selection has changed */
		Assert((wSelect & lbrCause) != lbrNone)
		SendMessage(pwnd->pwndParent, WM_DIALOG, pwnd->id,
		    MAKELONG(wSelect, LBN_SELCHANGE));
		}

ReturnTrue:
	return((DWORD) TRUE);	/* default case */
	}



STATIC VOID
DisplayListBox(pwnd)
/*
  -- display the contents of the list box
*/
REG PWND pwnd;
	{
	RRC	rrc;

	Assert(fDrawItem);

	GetClientRrc(pwnd, &rrc);
	FillRrc(pwnd, &rrc, ' ', pwnd->isaColor);

	if (pwnd->cszLb > 0)
		FillListBox(pwnd, 0, rrc.ryBottom, pwnd->iszTopLb);

	SetScrollWindow(pwnd);
	}



STATIC VOID
SetScrollWindow(pwnd)
/*
  -- sets the scroll range and position
  -- vertical is simple, horizontal is a pain
*/
REG PWND pwnd;
	{
	RRC	rrc;
	/* check for no scrollbar */
#ifdef LISTBOX_ONELINE
	if (!(pwnd->style & (WS_VSCROLL | WS_HSCROLL)))
		return;
#else
	Assert(pwnd->style & (WS_VSCROLL | WS_HSCROLL));
#endif /*LISTBOX_ONELINE*/

	GetClientRrc(pwnd,&rrc);
#ifdef LISTBOX_HORIZ
	if (pwnd->style & WS_HSCROLL)
		{
		REG short colMac;
		BYTE	dry;

		dry = rrc.ryBottom;
		colMac = (pwnd->cszLb - 1) / dry + 1;

		SetScrollRange(pwnd->pwndChild, 0, colMac, FALSE);
		SetScrollPos(pwnd->pwndChild, pwnd->iszCurLb / dry, TRUE);
		}
	else
#endif	/*LISTBOX_HORIZ*/
		{
		// vertical listbox case
		REG short iszBot;

		iszBot = pwnd->cszLb - rrc.ryBottom;
		if (iszBot < 1)
			iszBot = 1;	/* set range to 1 */

		SetScrollRange(pwnd->pwndChild, 0, iszBot, FALSE);
		SetScrollPos(pwnd->pwndChild, pwnd->iszTopLb, TRUE);
		}
	}



STATIC VOID
FillListBox(pwnd, ryTop, ryBottom, isz)
/*
  -- fill in the specified lines in the listbox
  -- ryTop is the top line, ryBottom is the bottom line
  -- isz is the isz corresponding to the top line
*/
REG PWND pwnd;
RY	ryTop;
RY	ryBottom;
WORD	isz;
	{
	char	sz[cchListTextMax];
	char FAR * lgpsz;
	WORD FAR * lmpiszoff;
	REG RY	ry;
#ifdef LISTBOX_HORIZ
	WORD	ccol;			/* # of columns */
	RX	rxLeft;			/* current left position */
#endif

	/* lock down string buffer and indexes (handles may be NULL) */
	lgpsz = LpvDeref(pwnd->hmemGpszLb);
	lmpiszoff = LpvDeref(pwnd->hmemMpiszoffLb);

	BeginDraw();

#ifdef LISTBOX_HORIZ
	/* Horizontal : fill in vertical list, then go to the right */
	ccol = pwnd->citemWidthLb;
	Assert(ccol != 0);
	rxLeft = RxLeftItem(pwnd, 0);
	while (ccol--)
		{
		WORD	cch;
#endif /*LISTBOX_HORIZ*/
		for (ry = ryTop; ry < ryBottom; ry++)
			{
			WORD	off;

			if (isz >= pwnd->cszLb)
				{
#ifndef LISTBOX_HORIZ
				break;		/* gone too far */
#else
				cch = 0;
				goto BlankFillItem;
#endif /*LISTBOX_HORIZ*/
				}

			if (pwnd->hmemGpszLb != NULL &&
			    (off = lmpiszoff[isz]) != offEmpty)
				{
				/* valid cached string */
				fstrcpy((char FAR *) sz, lgpsz+off);
				}
			else
				{
				/* not in cache */
				GetOnDemand(pwnd, isz, &lmpiszoff, &lgpsz, sz);
				}

#ifndef LISTBOX_HORIZ
			TextOut(pwnd, rxListBoxMin, ry, sz, -1, pwnd->isaColor);
#else
			/* display the string in proper column */
			if ((cch = CchRealLenSz(sz)) > pwnd->drxItemLb)
				cch = pwnd->drxItemLb;
			TextOut(pwnd, rxLeft, ry, sz, cch, pwnd->isaColor);
BlankFillItem:
			if (cch != pwnd->drxItemLb)
				{
				/* fill remaining part of line */
				RRC	rrc;

				rrc.rxLeft = rxLeft + cch;
				rrc.rxRight = rxLeft + pwnd->drxItemLb;
				rrc.ryBottom = (rrc.ryTop = ry) + 1;
				FillRrc(pwnd, &rrc, ' ', pwnd->isaColor);
				}
#endif /*LISTBOX_HORIZ*/

			/* invert the listbox selection */
			if (isz == pwnd->iszCurLb && FSelected(pwnd))
				{
				/* selected */
				RRC	rrc;

#ifndef LISTBOX_HORIZ
				/* entire width of listbox */
				GetClientRrc(pwnd, &rrc);
#else
				/* just this item with 1 before & after */
				rrc.rxRight = (rrc.rxLeft = rxLeft - 1) +
				   pwnd->drxItemLb + 2;
#endif
				rrc.ryBottom = (rrc.ryTop = ry) + 1;
				FillRrc(pwnd, &rrc, '\0', DiMake(dmAttrOnly,
				    pwnd->isaHiliteColor));
				}

			isz++;
			}
#ifdef LISTBOX_HORIZ
		rxLeft += (BYTE) pwnd->drxItemLb + 1;
		}/*end while(ccol--); */
#endif

	EndDraw();

	/* unlock string buffers and indexes */
	/*GlobalUnlock(pwnd->hmemGpszLb);*/
	/*GlobalUnlock(pwnd->hmemMpiszoffLb);*/
	}



STATIC VOID
ScrollListBox(pwnd, dry, fKillOld)
/*
  -- scroll vertical listbox by dry lines (may be negative)
  -- if hit top show top, if hit bottom show bottom
*/
REG PWND pwnd;
short	dry;
BOOL	fKillOld;	/* TRUE => kill old selection */
	{
	WORD	iszTop;
	RRC	rrc;
	WORD	iszBottom;
	short	iszNewTop;
	short	iszNewBottom;	/* note : use for signed compares */
	WORD	ryBottom;

#ifdef LISTBOX_HORIZ
	if (pwnd->style & WS_HSCROLL)
		{
		// horizontal listbox
		Assert(!fKillOld);
		ScrollHorizListBox(pwnd, dry);
		return;
		}
#endif /*LISTBOX_HORIZ*/
	iszTop = pwnd->iszTopLb;

	/* optionally turn off old selection */
	if (fKillOld)
		HiliteListSel(pwnd, FALSE);	/* turn off old */

	GetClientRrc(pwnd, &rrc);
	ryBottom = rrc.ryBottom;
	iszBottom = iszTop + ryBottom - 1;
	iszNewTop = iszTop + dry;
	iszNewBottom = iszBottom + dry;

	/* see if we should stop at top or bottom */
	if (iszNewTop < 0)
		{
		iszNewTop = iszMin;
		iszNewBottom = ryBottom - 1;
		}
	else if (iszNewBottom >= pwnd->cszLb)
		{
		iszNewBottom = pwnd->cszLb - 1;
		if ((iszNewTop = iszNewBottom - (ryBottom - 1)) < 0)
			iszNewTop = iszMin;
		}

	dry = iszNewTop - iszTop;
	/* move selection if necessary */
	if (pwnd->iszCurLb > iszNewBottom)
		pwnd->iszCurLb = iszNewBottom;
	else if (pwnd->iszCurLb < iszNewTop)
		pwnd->iszCurLb = iszNewTop;

	pwnd->iszTopLb = iszNewTop;

	/* smooth scroll */
	if (iszNewTop > iszTop && iszNewTop < iszBottom)
		{
		BltRrc(pwnd, 0, 0, rrc.rxRight, (BYTE) (ryBottom - dry),
		    0, (BYTE) dry);
		rrc.ryTop = (RY) (ryBottom-dry);
		FillRrc(pwnd, &rrc, ' ', pwnd->isaColor);
		FillListBox(pwnd, rrc.ryTop, (RY) ryBottom, iszNewTop+rrc.ryTop);
		}
	else if (iszNewBottom > iszTop && iszNewBottom < iszBottom)
		{
		BltRrc(pwnd, 0, (RY) (0-dry), rrc.rxRight, (BYTE) (ryBottom + dry),
		    0, 0);
		rrc.ryBottom = (RY) (0-dry);
		FillRrc(pwnd, &rrc, ' ', pwnd->isaColor);
		FillListBox(pwnd, 0, (RY) (0-dry), iszNewTop);
		}
	else if (iszNewTop != iszTop)
		{
		/* outside range to scroll => redraw it */
		DisplayListBox(pwnd);
		}

	SetScrollWindow(pwnd);
	HiliteListSel(pwnd, TRUE);
	}


#ifdef LISTBOX_HORIZ

STATIC VOID
ScrollHorizListBox(pwnd, dcol)
/*
  -- scroll a horizontal listbox by dcol columns (may be negative)
  -- if hit top show first column, if hit bottom show last column
*/
REG PWND pwnd;
short	dcol;
	{
	WORD	iszTop;
	BYTE	dry;
	RRC	rrc;
	short	iszNewTop;	/* note : use for signed compares */

	Assert(pwnd->style & WS_HSCROLL);


	GetClientRrc(pwnd,&rrc);
	iszTop = pwnd->iszTopLb;
	dry = rrc.ryBottom;
	Assert(iszTop % dry == 0);
	
	iszNewTop = iszTop + dcol * dry;
	if (iszNewTop < 0)
		{
		pwnd->iszCurLb = iszNewTop = iszMin;
		}
	else if (iszNewTop >= pwnd->cszLb)
		{
		/* adjust to right hand side */
		iszNewTop = ((pwnd->cszLb - 1) / dry) * dry;
		pwnd->iszCurLb = pwnd->cszLb - 1;	/* select last */
		}

	pwnd->iszTopLb = iszNewTop;

	if (iszNewTop != iszTop)
		FillListBox(pwnd, 0, dry, pwnd->iszTopLb = iszNewTop);
	SetScrollWindow(pwnd);

	HiliteListSel(pwnd, TRUE);
	}
#endif /*LISTBOX_HORIZ*/



STATIC VOID
HiliteListSel(pwnd, fHilite)
/*
  -- highlight/unhighlight the iszCur in the listbox.
  -- if iszCur is not displayed force it to be displayed
*/
REG PWND pwnd;
BOOL	fHilite;	/* TRUE => hilite, FALSE => unhilite */
	{
	REG WORD iszCur;
	RRC	rrc;
#ifdef LISTBOX_HORIZ
	BYTE	dry;		/* height */
#endif

	iszCur = pwnd->iszCurLb;

	/* Cursor should be always on */
	Assert(pwnd->fCursorOn);
	/* position must be valid (assume < 32K) */
	Assert((short) iszCur >= 0);

	GetClientRrc(pwnd, &rrc);

#ifdef LISTBOX_HORIZ
	if (!(pwnd->style & WS_HSCROLL))
#endif
		{
		/* if out of visible range, scroll vertically into range */
		if (fHilite &&
		    (iszCur < pwnd->iszTopLb ||
		     iszCur >= (pwnd->iszTopLb +
		     CitemVisible(pwnd, rrc.ryBottom))))
			{
			/* shift visible range */
			if (iszCur > pwnd->cszLb -
			    CitemVisible(pwnd, rrc.ryBottom))
				pwnd->iszTopLb = pwnd->cszLb -
				    CitemVisible(pwnd, rrc.ryBottom);
			else
				pwnd->iszTopLb = iszCur;

			if (fDrawItem)
				DisplayListBox(pwnd);
			}
		/* Vertical : compute 1 whole line to be [un]highlighted */
		rrc.ryBottom = (rrc.ryTop = (RY) (iszCur - pwnd->iszTopLb)) + 1;

		Assert(rrc.rxLeft == 0);
		MoveCursor(pwnd, rxListBoxMin, rrc.ryTop);
		}

#ifdef LISTBOX_HORIZ
	else
		{
		Assert(pwnd->style & WS_HSCROLL);

		dry = rrc.ryBottom - rrc.ryTop;
		/* if out of visible range, scroll horizontally into range */
		if (fHilite && iszCur < pwnd->iszTopLb)
			{
			/* adjust to be at the left column */
			pwnd->iszTopLb = (iszCur / dry) * dry;
			if (fDrawItem)
				DisplayListBox(pwnd);
			}
		else if (fHilite &&
		    iszCur >= (pwnd->iszTopLb +
		     CitemVisible(pwnd, rrc.ryBottom)))
			{
			/* adjust to be at the right column */
			pwnd->iszTopLb = (iszCur / dry) * dry;
			if (pwnd->iszTopLb >= dry * (pwnd->citemWidthLb - 1))
				pwnd->iszTopLb -= dry * (pwnd->citemWidthLb - 1);
			if (fDrawItem)
				DisplayListBox(pwnd);
			}

		/* Horizontal : compute partial line to hilight */
		iszCur -= pwnd->iszTopLb;	/* from top of listbox */
		Assert((short)iszCur >= 0 &&
		    iszCur < CitemVisible(pwnd, rrc.ryBottom));

		rrc.ryBottom = (rrc.ryTop = (RY) (iszCur % dry)) + 1;

		/* width includes 1 space before and after */
		Assert(rxListBoxMin == 1);
		rrc.rxRight =
		    (rrc.rxLeft = RxLeftItem(pwnd, iszCur / dry) - 1) +
		      pwnd->drxItemLb + 2;

		MoveCursor(pwnd, rrc.rxLeft + rxListBoxMin, rrc.ryTop);
		}
#endif /*LISTBOX_HORIZ*/

	if (fDrawItem)
		{
		FillRrc(pwnd, &rrc, '\0', DiMake(dmAttrOnly,
		    fHilite ? pwnd->isaHiliteColor : pwnd->isaColor));
#ifdef LISTBOX_COLOR
		if (!fHilite)
			{
			/* refill the listbox to get correct colors */
			SetFSelected(pwnd, FALSE);	/* fake not selected */
			FillListBox(pwnd, rrc.ryTop, rrc.ryTop+1, iszCur);
			}
#endif
		}
	SetFSelected(pwnd, TRUE);
	}



STATIC VOID
MoveSelection(pwnd, iszNew)
/*
  -- move the selection to iszNew
*/
REG PWND pwnd;
WORD iszNew;
	{
	Assert(iszNew < pwnd->cszLb);

	if (pwnd->iszCurLb == iszNew && FSelected(pwnd))
		return;		/* already there */

	HiliteListSel(pwnd, FALSE);	/* turn old off */
	pwnd->iszCurLb = iszNew;
	HiliteListSel(pwnd, TRUE);
	}



STATIC VOID
MoveSelectionDown(pwnd)
/*
  -- move iszCur down a line
*/
REG PWND pwnd;
	{
	WORD	iszBottom;
	RRC	rrc;

	GetClientRrc(pwnd,&rrc);
	iszBottom = pwnd->iszTopLb + CitemVisible(pwnd, rrc.ryBottom) - 1;

	if (FSelected(pwnd) && pwnd->iszCurLb + 1 < pwnd->cszLb)
		{
		HiliteListSel(pwnd, FALSE);
		if (pwnd->iszCurLb++ == iszBottom)
			{
			ScrollListBox(pwnd, 1, FALSE);
			return;
			}
		}
	HiliteListSel(pwnd, TRUE);
	}



STATIC VOID
MoveSelectionUp(pwnd)
/*
  -- move iszCur up a line
*/
REG PWND pwnd;
	{
	if (FSelected(pwnd) && pwnd->iszCurLb != iszMin)
		{
		HiliteListSel(pwnd, FALSE);
		if (pwnd->iszCurLb-- == pwnd->iszTopLb)
			{
			ScrollListBox(pwnd, -1, FALSE);
			return;
			}
		}
	HiliteListSel(pwnd, TRUE);
	}



#ifdef LISTBOX_HORIZ
STATIC VOID
MoveSelectionLeft(pwnd, dcol)
/*
  -- move selection left "dcol" columns
  -- vertical listboxes => move up
*/
REG PWND pwnd;
WORD	dcol;
	{
	if (pwnd->style & WS_VSCROLL)
		{
		Assert(dcol == 1);
		MoveSelectionUp(pwnd);
		}
	else
		{
		// horizontal

		WORD	cszMove;	/* # strings to move selection by */
		RRC	rrc;

		GetClientRrc(pwnd,&rrc);
		cszMove = rrc.ryBottom * dcol;

		if (pwnd->iszCurLb - iszMin < cszMove)
			MoveSelection(pwnd, iszMin);
		else
			MoveSelection(pwnd, pwnd->iszCurLb - cszMove);
		}
	}



STATIC VOID
MoveSelectionRight(pwnd, dcol)
/*
  -- move selection right "dcol" columns (horizontal only)
  -- vertical listboxes => move down
*/
REG PWND pwnd;
WORD	dcol;
	{
	if (pwnd->style & WS_VSCROLL)
		{
		Assert(dcol == 1);
		MoveSelectionDown(pwnd);
		}
	else
		{
		WORD	iszNew;
		RRC	rrc;

		GetClientRrc(pwnd,&rrc);
		iszNew = pwnd->iszCurLb + rrc.ryBottom * dcol;
		if (iszNew >= pwnd->cszLb)
			MoveSelection(pwnd, pwnd->cszLb - 1);
		else
			MoveSelection(pwnd, iszNew);
		}
	}
#endif /*LISTBOX_HORIZ*/



STATIC BOOL
FLocateMatch(pwnd, wParam)
/*
  -- find the entry in the list box beginning with ch (case insensitive)
  -- move current location if found
  -- return TRUE if selection made
*/
REG PWND pwnd;
WORD	wParam;			/* wParam of WM_CHAR message */
	{
	char FAR * lgpsz;
	WORD FAR * lmpiszoff;
	REG WORD iszCur;
	BOOL	fRet;

	fRet = FALSE;

 	if (wParam > 0xff)
 		return FALSE;	/* non-ascii */
 
	iszCur = pwnd->iszCurLb;
	if (FSelected(pwnd))
		if (++iszCur >= pwnd->cszLb)
			iszCur = iszMin;	/* try from this point on */

	lgpsz = LpvDeref(pwnd->hmemGpszLb);
	lmpiszoff = LpvDeref(pwnd->hmemMpiszoffLb);

	/* convert to upper case */
	if ((char) wParam >= 'a' && (char) wParam <= 'z')
		wParam -= 'a' - 'A';
	else if (wParam > 0x7f)
		wParam = ChUpperFromChExt((char)wParam);

	do
		{
		char FAR * lgpsz2;
		char	ch2;
		WORD	off;

		if (pwnd->hmemGpszLb != NULL &&
		    (off = lmpiszoff[iszCur]) != offEmpty)
			{
			/* valid cached string */
			lgpsz2 = lgpsz+off;		/* &lgpsz[off] */
			}
		else
			{
			/* not in cache */
			char	szBuff[cchListTextMax];

			GetOnDemand(pwnd, iszCur, &lmpiszoff, &lgpsz, szBuff);
			lgpsz2 = (char FAR *) szBuff;
			}
#ifdef EXTRAS
		if (*lgpsz2 == chColorPrefix)
				lgpsz2 += 2;
#endif
		while (((unsigned char)(*lgpsz2) < '0') && (*lgpsz2 != '\0'))
			lgpsz2++;

		ch2 = *lgpsz2;

		if (ch2 >= 'a' && ch2 <= 'z')
			ch2 -= 'a' - 'A';
		else if ((unsigned char) ch2 > 0x7f)
			ch2 = ChUpperFromChExt(ch2);

		if (ch2 == (char) wParam)
			{
			/* got it */
			MoveSelection(pwnd, iszCur);
			fRet = TRUE;
			break;
			}

		/* move iszCur to next possibility */
		if (++iszCur >= pwnd->cszLb)
			iszCur = iszMin;	/* wrap around */

		}
	while (iszCur != pwnd->iszCurLb);

	/*GlobalUnlock(pwnd->hmemGpszLb);*/
	/*GlobalUnlock(pwnd->hmemMpiszoffLb);*/
	return (fRet);
	}




STATIC VOID
ResetContent(pwnd)
/*
  -- resets the contents of the list box
*/
REG PWND pwnd;
	{

#ifdef LISTBOX_HORIZ
	if (pwnd->citemWidthLb == 0)
		{
		RRC rrc;
		GetClientRrc(pwnd,&rrc);
		/* initialize horizontal listbox info */
		pwnd->citemWidthLb = 1;
		pwnd->drxItemLb = rrc.rxRight - 2;
			/* 2 extra for start and end space */
		}
#endif /*LISTBOX_HORIZ*/

	/* free any listbox data */
	if (pwnd->hmemGpszLb != NULL)
		{
		GlobalFree(pwnd->hmemGpszLb);
		Assert(pwnd->hmemMpiszoffLb != NULL);
		GlobalFree(pwnd->hmemMpiszoffLb);
		pwnd->hmemGpszLb = NULL;
		pwnd->hmemMpiszoffLb = NULL;
		}
	else
		{
		Assert(pwnd->hmemMpiszoffLb == NULL);
		}
	pwnd->cszLb = pwnd->iszTopLb = 0;
	pwnd->iszCurLb = iszMin;
	SetFSelected(pwnd, FALSE);
	/* set cursor to no selection */
	MoveCursor(pwnd, rxListBoxMin, 0);
	}


PRIVATE VOID FARPRIVATE
AddListString(pwnd, sz)
/*
  -- add an item to the list box
  -- if sz == NULL, mark as not yet known (for fill on-demand)
*/
REG PWND pwnd;
char *sz;
	{
	AddListSz(pwnd, sz, FALSE);
	}

PRIVATE VOID FARPRIVATE
AddListSz(pwnd, sz, fRedraw)
/*
  -- add an item to the list box
  -- if sz == NULL, mark as not yet known (for fill on-demand)
*/
REG PWND pwnd;
char *sz;
WORD fRedraw;
	{
#ifdef LISTBOX_DIR
	if (!(pwnd->style & LBS_SORT))
		{
		/* not sorted : we must fit it in !!! */
		InsertSz(pwnd, pwnd->cszLb, sz, TRUE, fRedraw);
		}
	else if (pwnd->cszLb == 0)
		{
		/* first element in sorted listbox */
		InsertSz(pwnd, 0, sz, FALSE, fRedraw);
		}
	else
		{
		/* insert in sorted (no OnDemand concerns) */
		char FAR * lgpsz;
		WORD FAR * lmpiszoff;
		short	iszLo, iszHi;

		Assert(sz != NULL);		/* on-demand not allowed */

		lgpsz = LpvDeref(pwnd->hmemGpszLb);
		lmpiszoff = LpvDeref(pwnd->hmemMpiszoffLb);
		iszLo = iszMin;
		iszHi = pwnd->cszLb;
		do
			{
			REG short iszProbe = (iszLo + iszHi) / 2;

#ifdef KANJI
			if (fdircmp((char *) sz, lgpsz+lmpiszoff[iszProbe]) > 0)
#else
			if (fstrcmp((char *) sz, lgpsz+lmpiszoff[iszProbe]) > 0)
#endif
				iszLo = iszProbe+1;
			else
				iszHi = iszProbe;
			}
		while (iszLo < iszHi);

		/*GlobalUnlock(pwnd->hmemGpszLb);*/
		/*GlobalUnlock(pwnd->hmemMpiszoffLb);*/

		InsertSz(pwnd, iszLo, sz, FALSE, fRedraw);
		}
#else
	/* no DIR listboxes -- don't bother with sort option */
	Assert(!(pwnd->style & LBS_SORT));
	InsertSz(pwnd, pwnd->cszLb, sz, FALSE, fRedraw);	/* add at end */
#endif
	}

#ifdef KANJI
STATIC int
/*
 * it is not for KANJI.
 * sorting dirname as same as WINDOWS.
 *  order is as follows
 *  1: x.xxx	files
 *  2: [..]	parent directory
 *  3: [xxx]	directories
 *  4: [-x-]	drives
 */
fdircmp(s1, s2)
char FAR *s1, FAR *s2;
{
	if (*s1 != '[') {
		if (*s2 == '[') return(-1);
	} else if (*s2 != '[') {
		return(1);
	} else {
		++s1, ++s2;
		if (*s1 == '.') return(-1);
		if (*s2 == '.') return(1);
		if (*s1 != '-') {
			if (*s2 == '-') return(-1);
		} else  if (*s2 != '-') return(1);
	}
#ifdef KANJI
	return(fjstrcmp(s1, s2)); /* really needs for KANJI */
#else
	return(fstrcmp(s1, s2));
#endif
}

#define	iskanji(c)	( ((c)>=0x81 && (c)<=0x9F)||((c)>=0xE0 && (c)<= 0xFC) )

STATIC int
fjstrcmp(s1, s2)
unsigned char FAR *s1, FAR *s2;
{
	register unsigned short c1, c2;

	for (;;) {
		c1 = *s1++;
		if (iskanji(c1))
			c1 = (*s1 == 0)? 0: (c1 << 8)|*s1++;
		c2 = *s2++;
		if (iskanji(c2))
			c2 = (*s2 == 0)? 0: (c2 << 8)|*s2++;

		if (c1 < c2) return(-1);
		if (c1 > c2) return(1);
		if (c1 == 0) return(0);
	}
}

#endif /* KANJI */


STATIC VOID
InsertSz(pwnd, isz, sz, fForce, fRedraw)
/*
  -- insert a string at the specified position in the listbox
  -- if no memory left, do not add (no error condition)
  -- if sz == NULL, mark as special (on-demand)
  -- if previous position empty, replace string
  -- if changing size and fForce and no memory then go to low memory case
	(free any blocks and do everything on demand)
*/
REG PWND pwnd;
WORD isz;
char *sz;
BOOL fForce;
WORD fRedraw;
	{
	WORD FAR * lmpiszoff;		/* string pointers */
	WORD	cch;
	WORD	off;
	RRC	rrc;

	cch = (sz != NULL) ? (strlen(sz) + 1) : 0;
	if (pwnd->cszLb == 0)
		{
		/* first time allocation */
		Assert(pwnd->hmemGpszLb == NULL);
		Assert(pwnd->hmemMpiszoffLb == NULL);

		if ((pwnd->hmemGpszLb = GlobalAlloc(GMEM_MOVEABLE,
		    (DWORD) cbInitLb)) == NULL)
			{
			/* out of memory for string data */
			if (!fForce)
				return;
			/* force => no handle on demand all the time */
			}
		else if ((pwnd->hmemMpiszoffLb = GlobalAlloc(GMEM_MOVEABLE,
		    (DWORD) coffInitLb * sizeof(WORD))) == NULL)
			{
			/* out of memory for string indices */
			GlobalFree(pwnd->hmemGpszLb);
			pwnd->hmemGpszLb = NULL;
			if (!fForce)
				return;
			}
		/* initialize it */
		pwnd->offLb = 0;
		pwnd->iszTopLb = iszMin;
		pwnd->offMaxLb = cbInitLb;
		pwnd->iszMacLb = coffInitLb;
		pwnd->iszCurLb = iszMin;	/* start at top */
		}

	if (pwnd->hmemGpszLb == NULL)
		{
		/* we are doing things on demand */
		if (fForce)
			RevertToOomLb(pwnd, isz);
		return;
		}

	/* try to insert into the cache */
	Assert(pwnd->hmemGpszLb != NULL);
	Assert(pwnd->hmemMpiszoffLb != NULL);

	if (pwnd->cszLb >= pwnd->iszMacLb)
		{
		/* try to grow for indices */
		/* if >64K then request to GlobalReAlloc should fail! */
		WORD	hmem;

		if ((hmem = GlobalReAlloc(pwnd->hmemMpiszoffLb,
		    (DWORD) (pwnd->iszMacLb + coffGrowLb) * sizeof(WORD),
		    GMEM_MOVEABLE)) == NULL)
			{
			if (fForce)
				RevertToOomLb(pwnd, isz);
			return;
			}

		pwnd->iszMacLb += coffGrowLb;
		pwnd->hmemMpiszoffLb = hmem;
		}

	if (((off = pwnd->offLb) + cch) >= pwnd->offMaxLb)
		{
		WORD	hmem;

		if ((hmem = GlobalReAlloc(pwnd->hmemGpszLb,
		    (DWORD) pwnd->offMaxLb + cbGrowLb,
		    GMEM_MOVEABLE)) == NULL)
			{
			if (fForce)
				RevertToOomLb(pwnd, isz);
			return;
			}
		pwnd->offMaxLb += cbGrowLb;
		pwnd->hmemGpszLb = hmem;
		}

	/* now place in cache */
	if (sz == NULL)
		{
		off = offEmpty;
		}
	else
		{
		char FAR * lgpsz;		/* string data */

		lgpsz = LpvDeref(pwnd->hmemGpszLb);
		bltbytex((char FAR *) sz, lgpsz+off, cch);
		/*GlobalUnlock(pwnd->hmemGpszLb);*/
		}

	/* Insert offset into list */
	lmpiszoff = LpvDeref(pwnd->hmemMpiszoffLb);
	if (isz >= pwnd->cszLb)
		{
		/* easy insertion at end of list */
		lmpiszoff[pwnd->cszLb++] = off;
		}
	else
		{
		/* may be empty ? */
		WORD FAR * lpoff;

		lpoff = &lmpiszoff[isz];		/* where it should go */

		if (*lpoff != offEmpty)
			{
			/* move space in index block */
			bltbytex(lpoff, lpoff+1,
			    (pwnd->cszLb - isz) * sizeof(WORD));
			pwnd->cszLb++;

			/* if string was added before visible portion, update
			*   listbox indices (for top and current) */
			if (isz < pwnd->iszTopLb)
				{
				pwnd->iszTopLb++;
				pwnd->iszCurLb++;
				}
			}
		Debug(else Assert(off != offEmpty));
			/* else just replacing current on-demand string */

		*lpoff = off;
		}

	GetClientRrc(pwnd,&rrc);

	if ((isz >= pwnd->iszTopLb)
		 && (isz <= pwnd->iszTopLb + (WORD) rrc.ryBottom) && fRedraw)
		DrawWindow(pwnd);

	/*GlobalUnlock(pwnd->hmemMpiszoffLb);*/
	pwnd->offLb += cch;
	}

STATIC VOID
DeleteSz(pwnd, isz, fRedraw)
/*
  -- delete a string at the specified position in the listbox
*/
REG PWND pwnd;
WORD isz;
WORD fRedraw;
	{
	char FAR * lgpsz;		/* string data */
	WORD FAR * lmpiszoff;		/* string pointers */
	WORD	cch;
	WORD	off;
	WORD	offOld;
	WORD	iszLoop;
	WORD FAR * lpoff;
	RRC	rrc;


	Assert((isz >= 0) && (isz < pwnd->cszLb));

	/* try to insert into the cache */
	Assert(pwnd->hmemGpszLb != NULL);
	Assert(pwnd->hmemMpiszoffLb != NULL);

	lgpsz = LpvDeref(pwnd->hmemGpszLb);
	lmpiszoff = LpvDeref(pwnd->hmemMpiszoffLb);
	off = lmpiszoff[isz];

	Assert(off != offEmpty);	/* can't be on-demand */

	cch = fstrlen(lgpsz+off);
	bltbytex(lgpsz+off+cch,lgpsz+off,(pwnd->offLb-off-cch));
	pwnd->offLb -= cch;

	lpoff = &lmpiszoff[isz];		/* where it is */

	if (isz != pwnd->cszLb) bltbytex(lpoff+1, lpoff,
			    (pwnd->cszLb - isz) * sizeof(WORD));
	pwnd->cszLb--;

	for (iszLoop = 0; iszLoop < pwnd->cszLb; iszLoop++)
		{
		if ((offOld = lmpiszoff[iszLoop]) >= off)
			lmpiszoff[iszLoop] = offOld-cch;
		}

	GetClientRrc(pwnd,&rrc);

	if (pwnd->cszLb == 0)
		{
		SendMessage(pwnd,LB_RESETCONTENT,0,0L);
		}
	else
		{
		if (isz < pwnd->iszTopLb)
			{
			pwnd->iszTopLb--;
			if (pwnd->iszCurLb > 0) pwnd->iszCurLb--;
			}

		if (pwnd->iszCurLb >= pwnd->cszLb)
			pwnd->iszCurLb--;
		if ((pwnd->iszTopLb > 0)
			&&(pwnd->iszTopLb + (WORD) rrc.ryBottom > pwnd->cszLb))
			pwnd->iszTopLb--;
		}

	if ((isz >= pwnd->iszTopLb)
		 && (isz <= pwnd->iszTopLb + (WORD) rrc.ryBottom) && fRedraw)
		DrawWindow(pwnd);

	}



STATIC VOID
ReplaceSz(pwnd, isz, sz)
/*
  -- replace a string in the listbox
  -- update the screen if necessary
*/
REG PWND pwnd;
WORD isz;
char *sz;
	{
	char FAR * lgpsz;
	WORD FAR * lmpiszoff;
	WORD	off;
	RY	ry;
	RRC	rrc;

	/* lock down string buffer and indexes (handles may be NULL) */
	lgpsz = LpvDeref(pwnd->hmemGpszLb);
	lmpiszoff = LpvDeref(pwnd->hmemMpiszoffLb);


	Assert(isz < pwnd->cszLb);

	if (pwnd->hmemGpszLb != NULL &&
	    (off = lmpiszoff[isz]) != offEmpty)
		{
		/* valid cached string */
		Assert(strlen(sz) == fstrlen((char FAR *)(lgpsz+off)));
		fstrcpy(lgpsz+off, (char FAR *) sz);
		}

	GetClientRrc(pwnd,&rrc);

	if ((isz >= pwnd->iszTopLb)
		 && (isz < pwnd->iszTopLb + (WORD) rrc.ryBottom))
		{
		/* item is displayed */
		ry = (RY) (isz - pwnd->iszTopLb);
		TextOut(pwnd, rxListBoxMin, ry, sz, -1, isaListBox);
		if (isz == pwnd->iszCurLb && FSelected(pwnd))
			{
			rrc.ryBottom = (rrc.ryTop = ry) + 1;
			FillRrc(pwnd, &rrc, '\0', DiMake(dmAttrOnly,
				pwnd->isaHiliteColor));
			}
		}
	}




STATIC VOID
RevertToOomLb(pwnd, isz)
/*
  -- revert to low memory useage of listbox data
    (both handles NULL, all data by on-demand)
  -- must not be sorted
*/
REG PWND pwnd;
WORD	isz;		/* string that is inserted */
	{
	Assert(!(pwnd->style & LBS_SORT));

	if (pwnd->hmemGpszLb != NULL)
		{
		GlobalFree(pwnd->hmemGpszLb);
		Assert(pwnd->hmemMpiszoffLb != NULL);
		GlobalFree(pwnd->hmemMpiszoffLb);
		pwnd->hmemGpszLb = NULL;
		pwnd->hmemMpiszoffLb = NULL;
		}
	/* if the new string is after the end of the listbox, adjust size */
	if (isz >= pwnd->cszLb)
		pwnd->cszLb = isz + 1;
	}




PRIVATE WORD FARPRIVATE
GetListText(pwnd, sz, cchMax)
/*
  -- fill sz with the contents of the currently selected string
  -- return number of characters copied
*/
REG PWND pwnd;
char *sz;
WORD cchMax;
	{
	char FAR * lgpsz;
	WORD FAR * lmpiszoff;
	char FAR * lsz;
	WORD	cch;
	char	szBuff[cchListTextMax];

	/* don't copy anything if the listbox is empty or cursor is not
	   on anything. */

	if (pwnd->cszLb == 0 || !FSelected(pwnd))
		{
		sz[0] = '\0';
		return (0);
		}

	if (pwnd->hmemGpszLb != NULL)
		{
		/* get from cache */
		lgpsz = LpvDeref(pwnd->hmemGpszLb);
		lmpiszoff = LpvDeref(pwnd->hmemMpiszoffLb);
		Assert(lmpiszoff[pwnd->iszCurLb] != offEmpty);
		lsz = (char FAR *) lgpsz + lmpiszoff[pwnd->iszCurLb];
		/*GlobalUnlock(pwnd->hmemMpiszoffLb);*/
		}
	else
		{
		GetOnDemand(pwnd, pwnd->iszCurLb, NULL, NULL, szBuff);
		lsz = (char FAR *) szBuff;
		}

	if ((cch = fstrlen(lsz) + 1) > cchMax)
		cch = cchMax;
	/* copy on the number of characters needed */
	bltbytex(lsz, (char FAR *) sz, cch);

	/*GlobalUnlock(pwnd->hmemGpszLb);*/
	return(cchMax);
	}



STATIC VOID
GetOnDemand(pwnd, isz, plmpiszoff, plgpsz, szDest)
/*
  -- get a string for an on-demand listbox
  -- unlock the blocks, call listbox proc, relock the block
  -- fill szDest with string
  -- save string (so we don't have to go through this again) if room
*/
REG PWND pwnd;
WORD	isz;
WORD FAR ** plmpiszoff;
char FAR ** plgpsz;
char *	szDest;
	{
	/*GlobalUnlock(pwnd->hmemGpszLb);*/
	/*GlobalUnlock(pwnd->hmemMpiszoffLb);*/

	(*PwfnCtlLb(pwnd))(tmmText, szDest, isz, pwnd->id, 0, 0);

	if (pwnd->cszLb == 0 || pwnd->hmemGpszLb)
		{
		/* starting a new listbox or not oom listbox */
		InsertSz(pwnd, isz, szDest, FALSE, FALSE); /* may fail */
		}

	*plgpsz = LpvDeref(pwnd->hmemGpszLb);
	*plmpiszoff = LpvDeref(pwnd->hmemMpiszoffLb);
	}



STATIC VOID FAR *
LpvDeref(hmem)
/*
  -- defererence a handle
  -- (or return NULL if handle is NULL)
*/
WORD	hmem;
	{
	return (hmem == NULL) ? NULL : LpvGlobalDeref(hmem);
	}

/**************************************************************************/
/*   Public interface for listboxes                                       */
/**************************************************************************/

#ifndef LISTBOX_HORIZ	// only supported for vertical

PUBLIC VOID	FARPUBLIC
InitListBox(pwnd, pwfn_ctl)
PWND	 pwnd;
PWFN_CTL pwfn_ctl;
/*
  -- fix color
  -- put on demand function supplied into the wnd struct
  -- reset listbox
  -- fill listbox
*/
	{
	StartPublic();

		/* Non-directory ListBox */
	WORD	isz;
	WORD	csz;
	char	szBuffer[cchListTextMax];

	if (pwfn_ctl != NULL) PwfnCtlLb(pwnd) = pwfn_ctl;
	pwfn_ctl = PwfnCtlLb(pwnd);

	SendMessageShort(pwnd, LB_RESETCONTENT);
	csz = (*pwfn_ctl)(tmmCount, NULL, NULL, pwnd->id, 0, 0);
	isz = 0;

	if ((csz == cszUnknown)||(pwnd->style && LBS_SORT))
		{
		/* we must fill in the listbox */
		while (csz == cszUnknown || isz < csz)
			{
			if ((*pwfn_ctl)(tmmText, szBuffer, isz++, pwnd->id,
				    0, 0))
				{
				/* we have a string */
				SendMessage(pwnd, LB_ADDSTRING,
				    (WORD) szBuffer, 0L);
				}
			else if (csz == cszUnknown)
				break;	/* stop filling */
			}
		}
	else
		{
		/* fill on demand (fill with empties) */
		Assert(csz != cszUnknown);
		while (csz--)
			SendMessage(pwnd, LB_ADDSTRING, 0, 0L);
		}

	StopPublic();

	}



PUBLIC VOID FARPUBLIC
GetListBoxOrientation(pwnd, pisz, pdisz)
PWND pwnd;
WORD * pisz;
WORD * pdisz;
	{
	*pisz = (WORD) SendMessage(pwnd, LB_GETCURSEL, 0, 0L);
	*pdisz = (*pisz == iszNil) ? 0 : (*pisz - pwnd->iszTopLb);
	}



PUBLIC VOID	FARPUBLIC
InitListBoxOriented(pwnd, pwfn_ctl, pisz, pdisz)
PWND	 pwnd;
PWFN_CTL pwfn_ctl;
WORD	* pisz;			/* current selection */
WORD	* pdisz;		/* distance from top of box */
/*
  -- Init then orient listbox
*/
	{
	StartPublic();

	InitListBox(pwnd, pwfn_ctl);

	if (*pisz != iszNil) 
		{
		if (pwnd->cszLb == 0)
			{
			*pisz = iszNil;
			*pdisz = 0;
			}
		else
			{
			RRC	rrc;
			WORD	dry;

			GetClientRrc(pwnd,&rrc);
			dry = (WORD) rrc.ryBottom;

			/* 1 - make selection legal
			   2 - make sure no blank space at the bottom
			   3 - make distance from top legal */

			*pisz  = min(*pisz, pwnd->cszLb - 1);
			if (pwnd->cszLb + *pdisz < *pisz + dry)
				*pdisz = *pisz + dry - pwnd->cszLb;
			*pdisz = min(*pisz, min(*pdisz, dry-1));

			pwnd->iszTopLb = *pisz - *pdisz;
			pwnd->iszCurLb = *pisz;
			}
		}

	DrawWindow(pwnd);
	SendMessage(pwnd,LB_SETCURSEL,*pisz,0L);

	StopPublic();
	}

#endif /*!LISTBOX_HORIZ*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\editmgr2.asm ===
;*	SCCSWHAT( "@(#)editmgr2.asm	1.6 88/04/22 19:46:59	" ) */
;*
;*	COW : Character Oriented Windows
;*
;*	editmgr2.asm : Multi-line edit manager (part2)
;*	(included by editmgr.asm)

;*******************************************************************************
;_Del
;
;Purpose:
;	Delete the current ip character
;Entry:
;	ipCur
;	hBuffer
;	pdCur
;	ldCur
;Exit:
;	ldCur
;Uses:
;	si
;Exceptions:
;
;*******************************************************************************
cProc Del,<NEAR,PUBLIC>,<SI>
cBegin
ifdef	KANJI
	cCall	DbcsAdjCur
endif	; KANJI
	cCall	NoSelection			;remove any selected region
	cCall	ModifyLine			;mark line as modified
	jz	ExitDel
	mov	si, ipCur.ip_ob 		;check if ip after last char
	cmp	si, ldCur.ld_cb
	jb	NormalDel			;brif if ip < last char

	mov	ax, [clnCur]			;check if last line of file
	dec	ax				;last line is offset
	cmp	ax,ipCur.ip_oln
	jne	@F				;brif not last line

	cCall	NearBeep			;can't join line if last
	jmp	SHORT EndDel			;exit
;Here if a join line not del (i.e. del after last char)
@@:
	mov	ax,1				;reverse normal sense of join
						;which is above to below 
	cCall	JoinLine,<ax>			;current line
	jmp	SHORT EndDel			;exit

;Here if a normal del and not join
;si = ipCur.ip_ob
NormalDel:					;del works to right of ip
ifdef	KANJI
	mov	bx,[ldCur.LD_prgch]
	add	bx,si				;pointer to current line pos
	cCall	PchNextDbcs,<bx>		;Get next character
	sub	ax,[ldCur.LD_prgch]		; What is the new offset
	sub	ax,si				;delete 1 or 2 chars
	add	si,ax				;and move 1 or 2 for deleting
else	; KANJI
	mov	ax,1				;delete 1 char.
	inc	si				;so move 1 char for deleting
endif	; KANJI

	cCall	DelCh,<ax,si>
	cmp	si,pdCur.pd_obleft		;check if ip left of margin
	jge	@F				;brif if ip to right of margin
	cCall	DisplayCurPos			;recalc screen position
	jmp	SHORT EndDel			;exit

;Here if del did not move to left of left margin
@@:
	cCall	RefreshLine,<ipCur.ip_oln>	;refresh current line
EndDel:
	mov	[fResetAnchor], 1
ExitDel:
cEnd

;*******************************************************************************
;EMGetWord
;
;Purpose:
; Copies the word the cursor is on (or just after) to fpWord
; The string is null terminated.
; no more than cbMax bytes (including null) will be copied.
;
;Entry:
; fpWord - Where to store the word.
; cbMax  - Max number of chars to copy.
;
;Exit:
; Return number of bytes in the current word.
;
;Uses:
;Exceptions:
;
;*******************************************************************************

cProc EMGetWord,<NEAR,PUBLIC>,<SI,DI>
	parmD	fpWord
	parmW	cbMax

	localW	cb
cBegin

; Leave room for the null terminator
	dec	[cbMax]

	xor	ax,ax
	mov	[cb], ax

	cCall	GetLineScratch,<[ipCur.ip_oln]>
	mov	di, [ipCur.ip_ob]
	mov	ax, [ldEMScratch.ld_cb]
	cmp	di, ax
	jb	GW1
	dec	ax
	mov	di, ax
GW1:
	mov	si, [ldEMScratch.ld_prgch]
	add	si, di

GW2:
	inc	di
	jz	GW5
	dec	di


	cCall	IsWordChar,<[si]>
	or	ax,ax
	jnz	GW3

	dec	si
	dec	di
	jmp	short GW2

GW3:
	inc	di
	jz	GW5
	dec	di

	cCall	IsWordChar,<[si]>
	or	ax,ax
	jz	GW5

	dec	si
	dec	di
	jmp	short GW3
GW5:
	inc	si

	mov	dx, di
	les	di, fpWord

GW6:
	cmp	dx, [ldEMScratch.ld_cb]
	jae	GW7
	mov	ax, [cb]
	cmp	ax, [cbMax]
	jae	GW7
	push	dx
	cCall	IsWordChar,<[si]>
	pop	dx
	or	ax, ax
	jz	GW7

	lodsb
	stosb
	inc	[cb]
	inc	dx
	jmp	short GW6

GW7:
	xor	al,al
	stosb
	mov	ax, [cb]
cEnd

cProc NearBeep,<NEAR,PUBLIC>
cBegin
;;;	cCall	Beep
	xor	ax,ax
	cCall	DoSound,<ax>
cEnd

cProc SetInverseIsa,<FAR,PUBLIC>
	parmW	isa

	localW	coBack
	localW	coFore
cBegin
	;set up the isa isaUserMax-1 to be the inverse of the
	;specified isa.
	push	isa
	lea	ax, coBack
	push	ax
	lea	ax, coFore
	push	ax
	cCall	GetIsaColor
	mov	ax, isaUserMax-1
	push	ax			;*	isa
	push	coFore
	push	coBack
	mov	ax,coFore
	cCall	SetIsaColor

	mov	ax, isaUserMax-1	;return value
cEnd


;/***
;	TabOrBackTab - Handles single or multi line Tab or BackTab.
;	Description:
;		Do Tab/BackTab over all the selected lines (or just the current
;		line if no selection).
;	Input: DX - TRUE for BackTab
;	Output:
;****/
cProc TabOrBackTab,<NEAR,PUBLIC>,<SI,DI>

	localW	fBack
	localD	ipSave
	localB	fInsertModeSave
	localW	olnFirst
	localW	olnLast
	localW	obFirst
	localW	obLast
cBegin
	mov	[fBack], dx
	mov	al, 1
	xchg	al, [fInsertMode]
	mov	[fInsertModeSave],al

	mov	ax, [ipCur.ip_oln]
	mov	word ptr [ipSave.ip_oln],ax
	mov	ax, [ipCur.ip_ob]
	mov	word ptr [ipSave.ip_ob],ax

	lea	ax, olnFirst
	lea	bx, obFirst
	lea	cx, olnLast
	lea	dx, obLast
	cCall	BuildSelection,<ax,bx,cx,dx>
	cCall	GetCurLine

	mov	si, User_EditOFFSET Tab
	cmp	[fBack], 0
	jz	TBT_1

;
; We are BackTabing, figure out how much to backtab.
;
	mov	si, User_EditOFFSET BackTab

	mov	ax, [olnFirst]
	cmp	ax, [ipCur.ip_oln]
	je	TBT_1a
	cCall	GetLine,<ax>
TBT_1a:
	cCall	obGetFirst
	mov	di, ax
	or	ax,ax
	jz	TBT_1
	cCall	obGetPrev
	sub	di,ax

TBT_1:
	mov	ax, [olnFirst]
	cmp	ax, [olnLast]
	jne	TBT_MultiLineSelection

;
; No selection Tab or BackTab is simple
;
	cCall	NoSelection
	call	si
	jmp	TBT_Common

TBT_MultiLineSelection:
;
; For multiline selection, we want to Tab or BackTab each line
;

	cmp	[obLast], 0
	jne	TBT_3
	dec	[olnLast]
TBT_3:
	cCall	UpdateLine
	mov	ax, [olnFirst]
	mov	[ipCur.ip_oln], ax
	or	[emState], ES_NOREDRAW

TBT_NextLine:
	mov	[ipCur.ip_ob],0
	call	si
	inc	[ipCur.ip_oln]
	mov	ax, [olnLast]
	cmp	ax, [ipCur.ip_oln]
	jae	TBT_NextLine

	and	[emState], NOT ES_NOREDRAW
	mov	ax, word ptr [ipSave.ip_oln]
	mov	[ipCur.ip_oln], ax
	mov	ax, word ptr [ipSave.ip_ob]
	mov	[ipCur.ip_ob], ax
	mov	[fResetAnchor], 0

TBT_Common:
	mov	ax, [pdCur.pd_obleft]
	add	ax, [cColumnsCur]
	cmp	ax, [ipCur.ip_ob]
	ja	TBT_4
	cCall	DisplayCurPos
	jmp	short TBT_5

TBT_4:
	cCall	RefreshLines,<[olnFirst],[olnLast]>
	

TBT_5:
	mov	al, [fInsertModeSave]
	mov	[fInsertMode], al
cEnd

;*******************************************************************************
;_Backspace 
;
;Purpose:
;	Do a destructive backspace
;Entry:
;	ipCur
;	ldCur
;Exit:
;	ldCur
;Uses:
;	si - cbDel
;	di - obFirstCur
;	obFirstPref
;Exceptions:
;
;*******************************************************************************
cProc Backspace,<NEAR,PUBLIC>,<SI,DI>
cBegin
ifdef	KANJI
	cCall	DbcsAdjCur
endif	; KANJI
	cCall	NoSelection			;Turn off any selection
	cCall	ModifyLine
	jz	ExitBackspace
	cmp	ipCur.ip_ob,0			;If at start of line do join
	jne	BackspaceNormal 		;brif not at start of line

;Here if backspace at start of line. Then we join with line above
	cmp	ipCur.IP_oln,0
	jne	JoinOk
ifndef SILENT
	cCall	NearBeep
endif
	jmp	SHORT ExitBackspace			;exit

JoinOk:
	sub	ax,ax			;set false to join below
	cCall	JoinLine,<ax>
	jmp	SHORT ExitBackspace			;exit

;Here if backspace is not at start of line
BackspaceNormal:
	mov	ax,[ldCur.LD_cb]
	or	ax,ax
	mov	ax,[ipCur.IP_ob]
	jz	@F
	cCall	obGetFirst			;get beginning text on line
@@:
	mov	di,ax
ifdef	KANJI
	mov	ax,[ldCur.LD_prgch]
	mov	si,[ipCur.ip_ob]
	add	si,ax
	cCall	PchPrevDbcs,<si,ax>
	or	ax,ax				;If NULL, we are off end
	jz	@F
	sub	si,ax
	jmp	SHORT CheckBackspaceIndent
@@:
	mov	si,1				;default deletions = 1
CheckBackspaceIndent:
else	; KANJI
	mov	si,1				
endif	; KANJI

	cmp	ipCur.ip_ob,di			;check to adjust indent
	jne	@F				;if at start of line or blank

;Here if at start of indent on line
	cCall	obGetPrev		;get new indent. level
	mov	si,di
	sub	si,ax			; si = delta to move line left

;Here when ready to delete either 1 or n characters
@@:
	cCall	DelCh,<si,[ipCur.ip_ob]>
	sub	ipCur.ip_ob,si		;adjust ip for deletion
	cCall	DisplayCurPos		;recalc screen position
	cCall	RefreshLine,<[ipCur.ip_oln]>
ExitBackspace:
	mov	[fResetAnchor], 1
cEnd

;*******************************************************************************
;_Tab
;
;Purpose:
;	Insert a tab at current ip. Adjust screen
;Entry:
;	ipCur
;	pdCur.obleft
;Exit:
;	ldCur
;	ipCur
;Uses:
;	si - obCur
;Exceptions:
;
;*******************************************************************************
cProc Tab,<NEAR,PUBLIC>,<SI>
cBegin
	cCall	GetCurLine
	cCall	NextTab,<[ipCur.ip_ob]>
	mov	si, ax			;offset for next tab position
	mov	ax,ldCur.ld_cbMax	;Make sure tab is within line
	dec	ax
	cmp	si, ax			;check if next pos. with line
	jnb	$I511			;brif if tab was within line
	mov	cx, [ldCur.ld_cb]
	jcxz	Tab_JustMove
	jmp	short $I511a

$I511:
	cCall	NearBeep		;warn user
	jmp	SHORT ExitTab

;Here if tab is within max line width and not on a blank line.
$I511a:
	cCall	ModifyLine
	jz	ExitTab
	mov	bx,32
	mov	ax, si			;calc. # of spaces to add
	sub	ax,ipCur.ip_ob
	mov	cl, [fInsertMode]
	cCall	InsCh,<ax,bx,cx>	;insert tabs for spaces
Tab_JustMove:
	mov	ipCur.ip_ob,si		;update current pos. after tabs
ExitTab:
cEnd

;*******************************************************************************
;_InsCh
;
;Purpose:
;	Low level routine to insert a character into ldCur at ip
;Entry:
;	cbAdd
;	InsertCh
;	ipCur
;	ldCur
;Exit:
;	ldCur
;Uses:
;	ob - offset to start insertion
;	cbFill - # of space to insert before char. (if ip of end of line)
;	cbMove - # of character to move to right of ip
;	pIns - buffer pointer to start move
;	di - ldCur.cb
;	si - cbAdd
;Exceptions:
;
;*******************************************************************************
cProc InsCh,<PUBLIC,NEAR>,<SI,DI>
	parmW	cbAdd
	parmB	char
	parmB	fInsert

	localW	pIns
cBegin
ifdef	KANJI
	sub	ah,ah
	mov	al,[fCharIsDbcs]		; See if we have
	dec	ax				;   a DBCS byte
	jns	@F				; If not
	cCall	DbcsAdjCur			;   then Adjust cursor
	jmp	SHORT StartInsCh

@@:						; otherwise
	dec	ax				;   See if we have second byte
	js	StartInsCh			;   If we do
	mov	[fCharIsDbcs],al		;     Then clear flag
StartInsCh:
endif	; KANJI

; registers SI = cbAdd
;           DI = ldCur.cb
;
	mov     si,[cbAdd]
	mov     di,[ldCur.LD_cb]

;
; Are we past the current end of the line?
;
	mov     ax, [ipCur.IP_ob]
	cmp     [ipCur.IP_ob],di
	jle	@F

;
; Fill from end of line to cursor with spaces
;
	sub     ax,di				; cbFill = ipCur.ob - ldCur.cb;

	push    ax
	mov     ax,' '
	push    ax
	mov     ax,[ldCur.LD_prgch]
	add     ax,di
	push    ax
	call    _memset
	add     sp,6

	mov     di,[ipCur.IP_ob]		; ldCur.cb = ipCur.ob;

;
; If cbAdd is too big, figure out how much can be added
;
@@:
	mov     ax,[ldCur.LD_cbMax]
	dec	ax
	cmp     [fInsert],0
	je	@F

	sub     ax,di			; cbMax = ldCur.cbMax - 1 - ldCur.cb
	jmp	short $LL20042

@@:
	sub     ax,[ipCur.IP_ob]	; cbMax = (ldCur.cbMax - 1) - ipCur.ob

$LL20042:
	cmp     ax,si			; Is cbMax >= cbAdd
	jae	@F			; Yes
	mov	si, ax			; cbAdd = cbMax

;
; Now, if there is any room, do it
@@:
	or      si,si
	jle	EndInsCh

	mov     ax,[ipCur.IP_ob]
	add     ax,[ldCur.LD_prgch]
	mov     [pIns],ax

	cmp     [fInsert],0
	je	OverwriteInsCh

;
; We are in Insert Mode so move the stuff after the cursor to make room for
; the stuff we are inserting.
;
	cmp     [ipCur.IP_ob],di
	jge	@F

	mov     ax,di
	sub     ax,[ipCur.IP_ob]

	or      ax,ax
	je	@F

ifdef	PROJECT_QB
	mov     bx,[pIns]
	push	bx				; source
	add     bx,si
	push    bx				; dest
	push	ax				; count
	call	bltbyte			 	; pascal Calling convention
else	;PROJECT_QB
	push    ax
	push    [pIns]
	mov     ax,[pIns]
	add     ax,si
	push    ax
	call	_memmove
	add     sp,6
endif	;PROJECT_QB

@@:
	add     di,si
	jmp	SHORT DoInsCh			; ldCur.cb += cbAdd;
OverwriteInsCh:
	mov     ax,[ipCur.IP_ob]
	add     ax,si
	cmp     ax,di
	jle	DoInsCh

	mov     di,ax				; ldCur.cb = ipCur.ob + cbAdd;

DoInsCh:
	push    si
	mov     al,[char]
	cbw
	push    ax
	push    [pIns]
	call    _memset
	add     sp,6
EndInsCh:
	mov	[ldCur.LD_cb], di		; Save cached value
	mov     ax,si
cEnd

;*******************************************************************************
;_DelCh
;
;Purpose:
;	Low level routine to delete character from ldCur at specified loc.
;Entry:
;	cbDel - # of characters to delete
;	ob - where to delete
;Exit:
;	ldCur
;Uses:
;	cb - temp. for # of bytes
;	si - pszDst - buffer destination pointer
;	di - pszSrc - buffer source pointer
;Exceptions:
;
;*******************************************************************************
cProc DelCh,<NEAR>,<SI,DI>
	parmW	cbDel
	parmW	ob

	localW	cb
cBegin
;
; Adjust if trying to delete past end of line.
;
	mov	ax,[ob]
	sub	ax,[ldCur.ld_cb]
	jle	DelCh1
	cmp	ax, [cbDel]
	jae	DelCh_Exit
	sub	[ob],ax
	sub	[cbDel],ax
DelCh1:

	cmp	ldCur.ld_cb,0		;make sure something to delete
	je	DelCh_Exit		;brif nothing to delete
	cmp	[cbDel],0 		;make sure need to delete something
	je	DelCh_Exit		;brif no need to delete
	mov	ax,ldCur.ld_cb
	cmp	[cbDel],ax
	jb	DelCh2
	xor	ax,ax
	mov	[ldCur.ld_cb],ax
	jmp	short DelCh_Exit

DelCh2:
	cmp	[ob],ax			;check if deleting from with line
	jae	$I535			;brif deleting to right of eol
	sub	ax,[ob]			;trim buffer back display does rest
	mov	[cb],ax
	mov	di,[ob]
	add	di,ldCur.ld_prgch	;di - pointer into buffer
	mov	ax,di	 		;ax - prgch[ob]
	sub	ax,[cbDel]
	mov	si,ax			;dst
	jmp	SHORT $L20049

; UNDONE: fix this
;!!! why isn't this either a memcpy? if not then make it string move!
;While loop till cb == 0 move buffer down by cb.
$WC536:
	mov	al,[di]
	inc	di
	mov	[si],al
	inc	si
$L20049:
	mov	ax,[cb]
	dec	[cb]
	or	ax,ax
	jne	$WC536

;Here after moving buffer down
$I535:
	mov	ax,[cbDel]		;adjust buffer size
	sub	ldCur.ld_cb,ax
DelCh_Exit:
cEnd


;*******************************************************************************
;_obGetFirst
;
;Purpose:
;	Get first non-whilte space character on line
;Entry:
;	ldCur
;
;Exit:
;	return - offset to start of text
;Uses:
;	si - ob current offset 
;	di - obLim limit of search with line (ldCur.cb)
;	bx
;Exceptions:
;
;*******************************************************************************
cProc obGetFirst,<NEAR,PUBLIC>,<DI>
cBegin
	mov	di, [ldCur.ld_prgch]
	mov	cx, [ldCur.ld_cb]
	cCall	$obGetFirst
cEnd

cProc obGetFirstScratch,<NEAR>,<DI>
cBegin
	mov	di, [ldEMScratch.ld_prgch]
	mov	cx, [ldEMScratch.ld_cb]
	cCall	$obGetFirst
cEnd

cProc $obGetFirst,<NEAR>
cBegin
	mov	ax, cx
	jcxz	$obGetFirst_Exit

	push	ds
	pop	es
	mov	al, ' '
	mov	bx, di
	repe scasb
	jne	NoClear
	sub	ax,ax
	jmp	short $obGetFirst_Exit
NoClear:
	mov	ax, di
	sub	ax, bx
	dec	ax

$obGetFirst_Exit:
cEnd

;*******************************************************************************
;_obGetPrev
;
;Purpose:
;	Get the indent level for the line above and to the left
;	of the current ip. If none then 0 returned.
;Entry:
;	ipCur
;Exit:
;	return - indent level
;Uses:
;	si == indent level of ldCur
;Exceptions:
;
;*******************************************************************************
cProc obGetPrev,<NEAR,PUBLIC>,<SI,DI>
cBegin
	mov	ax, [ipCur.ip_ob]
	mov	cx, [ldCur.ld_cb]
	jcxz	GP1
	cCall	obGetFirst
GP1:
	mov	si, ax

	mov	di, [ipCur.ip_oln]
GP2:
	mov	ax, di			; If oln == 0 return 0
	or	ax, ax
	jz	GP4

	dec	di
	cCall	GetLineScratch,<di>

	mov	cx, [ldEMScratch.ld_cb]	; Ignore blank lines.
	jcxz	GP2

	cCall	obGetFirstScratch
	cmp	ax,si
	jae	GP2

GP4:
cEnd

;*******************************************************************************
;_RefreshScreen
;
;Purpose:
;	Redraw the entire visible screen
;Entry:
;	none.
;Exit:
;	none.
;Uses:
;	none.
;Exceptions:
;
;*******************************************************************************
cProc RefreshScreen,<NEAR,PUBLIC>
cBegin
	mov	bx,-1		;refresh max. number of lines
	sub	ax,ax
	cCall	RefreshLines,<ax,bx>	;refresh 0 to max. lines
cEnd

;*******************************************************************************
;_RefreshLines
;
;Purpose:
;	Redraw the specified line if present on screen
;Entry:
;	olnFirst - first line offset to redraw
;	olnLast  - last line offset to redraw
;Exit:
;	none.
;Uses:
;	olnBottom - offset for bottom of screen
;Exceptions:
;
;*******************************************************************************
cProc RefreshLines,<NEAR,PUBLIC>,<SI,DI>
	parmW	olnFirst
	parmW	olnLast
cBegin
	test	[emState], ES_NOREDRAW
	jnz	$EX558
	mov	si,[olnFirst]
	mov	di,[olnLast]
	cmp	si,di		
	jbe	$I561			;brif olnFirst <= olnLast
;Here if order was wrong on range
	xchg	si,di
;Here when order is correct
$I561:
	;!!! get structure definition for this
	mov	cx,[cLinesCur]
	add	cx,[pdCur.pd_olntop]
	dec	cx
	cmp	cx, si			;if first line below screen
	jl	$EX558			;then exit		;????
	cmp	[pdCur.pd_olntop],di	;or if last line above screen
	ja	$EX558			;exit
	cmp	[pdCur.pd_olntop],si
	jbe	$I564			;brif first above top of screen
	mov	si,[pdCur.pd_olntop]	;make first in range top of screen
$I564:
	cmp	cx, di
	jae	$L20052			;brif if last above bottom of screen
	mov	di, cx
	jmp	SHORT $L20052
;Loop refreshing line at a time within range that is entirely on screen
$WC566:
	cCall	RefreshLine,<si>
	inc	si
$L20052:
	cmp	si,di			;
	jbe	$WC566			;brif olnFirst <= olnLast
$EX558:
cEnd

cProc RefreshLine,<NEAR,PUBLIC>,<SI,DI>
	parmW	ln

	localW	row
	localW	olnFirst
	localW	obFirst
	localW	olnLast
	localW	obLast
	localW	attrSave
	localW	ob
	localW	cb
	localW	obRight
	localW	pLineAttr
cBegin
	mov	si,[ln]

	test	[emState], ES_NOREDRAW
	jz	RL1
	jmp	RL_Exit

; Do nothing if line is not in the window
RL1:
	mov	ax,[pdCur.PD_olnTop]
	cmp	si,ax
	jae	RL2
	jmp	RL_Exit
RL2:
	add	ax,[cLinesCur]
	cmp	ax,si
	ja	RL3
	jmp	RL_Exit
RL3:

	mov	ax,si
	sub	ax,[pdCur.PD_olnTop]
	mov	[row],ax

	cCall	GetLineScratchPad,<si>

;
; See if we should display the line (or part of it) in reverse video
;
	test	[emState], ES_NOSELECT
	jnz	RL6a
	mov	bx,[pefCur]
	cmp	[bx.EF_fSelection],0
	je	RL6a

;
; Get the selection extents
;
	lea	ax,[olnFirst]
	lea	bx,[obFirst]
	lea	cx,[olnLast]
	lea	dx,[obLast]
	cCall	BuildSelection,<ax,bx,cx,dx>

;
; See if the entire line should be selected
;
	mov	ax,si
	cmp	[olnFirst],ax
	ja	RL6a
	cmp	[olnLast],ax
	ja	RL6
	cmp	WORD PTR [obLast],0
	je	RL6a
	cmp	[olnLast],ax
	jne	RL6a

RL6:
	mov	ax,[olnLast]
	cmp	[olnFirst],ax
	je	RL7

	mov	[obFirst],0
	mov	[obLast],0ffffH
	jmp	short RL7

RL6a:
; There is a selection but the line we are refreshing is not part of the
; selected area.
	sub	ax,ax
	mov	[obLast],ax
	mov	[obFirst],ax
	jmp	short RL7a			; al MUST be zero


;
; At this point we are ready to build the line attributes
;
RL7:
	mov	bx,[pefCur]
	mov	al, [bx.EF_fSelection]

RL7a:
	mov	di,[CurattrCur]

	or	al, al
	jnz	RL8

	test	[emState], ES_MULTILINE
	jz	RL8
	test	[ldEMScratch.ld_flags],ld_fDirty
	jne	RL8
	cmp	si,[clnCur]
	jae	RL8

;
; There is no selection, the line is not dirty, and not single line edit field.
; So, ask the application for the line attributes.
;
	cCall	GetLineAttrs,<di>
	jmp	SHORT RL9

RL8:
	mov	ax,[obFirst]
	mov	[rgLineAttr0.LA_cb],ax
	mov	[rgLineAttr0.LA_attr],di	; attrDefault

	mov	ax,[obLast]
	sub	ax,[obFirst]
	mov	[rgLineAttr1.LA_cb],ax

	cCall	SetInverseIsa, <di>		; sets up isaUserMax-1
	mov	[rgLineAttr1.LA_attr],ax

	mov	[rgLineAttr2.LA_cb],0ffffH
	mov	[rgLineAttr2.LA_attr],di	; attrDefault

	mov	[rgLineAttr3.LA_attr],0ffffH
	lea	ax,[rgLineAttr0]

RL9:
	mov	[pLineAttr],ax

;
; Ok now, let's print out the line.
;
	mov	ax,[CurattrCur]
	mov	[attrSave],ax

	mov	ax,[cColumnsCur]
	add	ax,[pdCur.PD_obLeft]
	mov	[obRight],ax

	mov	[ob],0

RL10:
	mov	bx,[pLineAttr]
	cmp	WORD PTR [bx.LA_attr],-1
	je	JRL15

	mov	ax,[obRight]
	cmp	[ob],ax
	jae	JRL15

	mov	ax,[bx.LA_cb]
	and	ax,07fffH		;clear high bit, so no overflow in add
	mov	[cb],ax

	mov	ax,[pdCur.PD_obLeft]
	cmp	[ob],ax
	jae	RL12

	mov	ax,[cb]
	add	[ob],ax

	mov	ax,[pdCur.PD_obLeft]
	cmp	[ob],ax
	jae	RL11
	jmp	short RL13

JRL15:
	jmp	RL15

RL11:

	mov	ax,[ob]
	sub	ax,[pdCur.PD_obLeft]
	mov	[cb],ax

	mov	ax,[pdCur.PD_obLeft]
	mov	[ob],ax

RL12:
	cmp	WORD PTR [cb],0
	je	RL13

	mov	di,[pLineAttr]
	mov	ax,[di.LA_attr]
	mov	[CurattrCur],ax

	mov	si,[ob]
	mov	bx,[ldEMScratch.LD_prgch]
	add	si,bx

ifdef	KANJI
	cmp	si,bx
	je	NoKanjiPad
	cCall	PchPrevDbcs,<si,bx>
	cCall	PchNextDbcs,<ax>
	cmp	si,ax
	je	NoKanjiPad
	mov	byte ptr [si],' '
NoKanjiPad:
endif	; KANJI

	mov	cx,[ob]
	sub	cx,[pdCur.PD_obLeft]
	cCall	TextOut,<[pwndEditCur],cx,[row],si,[cb],[CurattrCur]>
	mov	ax,[cb]
	add	[ob],ax

RL13:
	add	[pLineAttr],size LINEATTR
	jmp	RL10

RL15:
	mov	ax,[attrSave]
	mov	[CurattrCur],ax

ifdef	KK_UNIT
	mov	ax,[ln]
	cmp	ax,[ipCur.ip_oln]
	jne	@F
	mov	ax,[ipCur.ip_ob]
	sub	ax,[pdCur.PD_obLeft]
	cCall	DisplayKKBuf,<[pwndEditCur],ax,[row]>
@@:
endif	; KK_UNIT

RL_Exit:
cEnd

;*******************************************************************************
; _HomeScn
;
;Purpose:
;	Move cursor to top of screen
;Entry:
;	pdCur
;	ipCur
;Exit:
;	ipCur
;Uses:
;	none.
;Exceptions:
;
;*******************************************************************************
cProc HomeScn,<NEAR,PUBLIC>
cBegin
	cCall	UpdateLine
	mov	ax,[pdCur.pd_olntop]
	mov	[ipCur.ip_oln],ax	;make current line top of screen
cEnd

;*******************************************************************************
;_EndScn
;
;Purpose:
;	Move cursor to end of screen
;     - the global register set (grs)
;     - the module register set (mrsCur and bdtMrs), via MrsMake
;Entry:
;	pwndEditCur
;	ipCur
;	pdCur
;Exit:
;	ipCur
;	pdCur
;Uses:
;	none.
;Exceptions:
;	If run out of memory trying to allocate a buffer, runtime error
;		"Error during Initialization" or some such.
;*******************************************************************************
cProc EndScn,<NEAR,PUBLIC>
cBegin
	cCall	UpdateLine
	mov	ax,[cLinesCur]	       ;pwndEditCur.cLines
	add	ax,[pdCur.pd_olntop]	;set ip to bottom of screen
	dec	ax
	mov	cx, [clnCur] 
	cmp	ax, cx
	jbe	$I597
	mov	ax, cx
$I597:
	mov	[ipCur.ip_oln],ax
cEnd

;*******************************************************************************
;_BeginPgm
;
;Purpose:
;	Move cursor to beginning of program
;Entry:
;	none.
;Exit:
;	ipCur
;	pdCur
;Uses:
;	none.
;Exceptions:
;
;*******************************************************************************
cProc BegPgm,<NEAR,PUBLIC>
cBegin
	cCall	UpdateLine
	mov	ipCur.ip_oln,0
	cCall	AutoIndent
	cCall	DisplayCurPos
cEnd

;*******************************************************************************
;_EndPgmInitContext()
;
;Purpose:
;	_EndPgm
;Entry:
;	ipCur
;Exit:
;	ipCur
;Uses:
;	none.
;Exceptions:
;
;*******************************************************************************
cProc EndPgm,<NEAR,PUBLIC>
cBegin
	cCall	UpdateLine
	mov	ax, [clnCur]
	mov	ipCur.ip_oln,ax
	mov	ipCur.ip_ob,0
	cCall	DisplayCurPos
cEnd

;*******************************************************************************
;_HomeLine
;
;Purpose:
;	Move Cursor to beginning of line
;Entry:
;	none.
;Exit:
;	ipCur
;Uses:
;	none.
;Exceptions:
;
;*******************************************************************************
cProc HomeLine,<NEAR,PUBLIC>
cBegin
	cCall	AutoIndent
	cCall	DisplayCurPos
cEnd

;*******************************************************************************
;_EndLine
;
;Purpose:
;	Move cursor to end of current line
;Entry:
;	ldCur
;	ipCur
;Exit:
;	ipCur
;Uses:
;	none.
;Exceptions:
;
;*******************************************************************************
cProc EndLine,<NEAR,PUBLIC>
cBegin
	xor	ax,ax
	mov	bx, [ipCur.ip_oln]
	cmp	bx, [clnCur]
	jae	EL_1
	cCall	GetCurLine
	mov	ax,ldCur.ld_cb
EL_1:
	mov	ipCur.ip_ob,ax
	cCall	DisplayCurPos
cEnd

;*******************************************************************************
;_CharRight
;
;Purpose:
;	Move cursor to the right 1 character. Non-destructive	
;Entry:
;	ldCur
;	ipCur
;	pdCur
;	pwndEditCur
;Exit:
;	ipCur
;Uses:
;	none.
;Exceptions:
;*******************************************************************************
cProc CharRight,<NEAR,PUBLIC>
cBegin
ifdef	KANJI
	cCall	DbcsAdjCur
endif	; KANJI
	mov	ax,ldCur.ld_cbMax
	dec	ax
	cmp	ax,ipCur.ip_ob
	ja	$I604		;brif if ip is not a max. line width
ifndef SILENT
	cCall	NearBeep	;warn user
endif
	jmp	SHORT $I606

;Here if ok to move right
$I604:
ifdef	KANJI
	cCall	RightKanji
else	; KANJI
	inc	ipCur.ip_ob
endif	; KANJI
	mov	ax,[cColumnsCur]    ;pwndEditCur.cColumns
	add	ax,pdCur.pd_obleft
	cmp	ax,ipCur.ip_ob
	ja	$I606		;brif if ip to left of screen right edge
	sub	ax,ax		;moved offset screen so page right
	cCall	PageRight,<shiftWidth,ax>
$I606:
cEnd

;*******************************************************************************
;WordRight
;
;Purpose:
;	Move the cursor one word to the right. Moving to the next line if
;	no more word on the current line.
;Entry:
;  DX - if Zero position at start of word
;       if Non-Zero position at end of word
;Exit:
;Uses:
;Exceptions:
;
;*******************************************************************************
cProc WordRight,<NEAR,PUBLIC>,<SI>
cBegin
	push	dx			; Save
	cCall	GetCurLine
	pop	ax			; Restore

	mov	si, User_EditOFFSET RightToWordStart
	or	ax,ax
	jz	WR_CheckEol

	mov	si, User_EditOFFSET RightPastWordEnd

WR_CheckEol:
	mov	ax, [ipCur.ip_ob]
	cmp	ax, [ldCur.ld_cb]
	jae	WR_NextLine

WR_Repeat:
	call	si
	jnz	WR_Exit

WR_NextLine:
	mov	ax, [ipCur.ip_oln]
	inc	ax
	cmp	ax, [clnCur]
	jae	WR_Beep

	mov	[ipCur.ip_oln], ax
	cCall	GetCurLine
	mov	[ipCur.ip_ob], 0
	cCall	FOnWord
	jnz	WR_Exit
	jmp	short WR_Repeat

WR_Beep:
ifndef SILENT
	cCall	NearBeep
endif
WR_Exit:
	cCall	DisplayCurPos
cEnd

;*******************************************************************************
;WordLeft
;
;Purpose:
;	Move left 1 word. See RightWord
;Entry:
;Exit:
;Exit:
;Uses:
;Exceptions:
;
;*******************************************************************************
cProc WordLeft,<NEAR,PUBLIC>
cBegin
	cCall	GetCurLine
	mov	ax, [ldCur.ld_cb]
	cmp	ax, [ipCur.ip_ob]
	ja	WL_Repeat

	mov	[ipCur.ip_ob], ax

WL_Repeat:
	call	LeftToWordStart
	jnz	WL_Exit

	mov	ax, [ipCur.ip_oln]
	or	ax,ax
	jz	WL_NearBeep

	dec	ax
	mov	[ipCur.ip_oln], ax
	cCall	GetCurLine
	mov	ax, [ldCur.ld_cb]
	mov	[ipCur.ip_ob], ax
	jmp	short WL_Repeat

WL_NearBeep:
ifndef SILENT
	cCall	NearBeep
endif
WL_Exit:
	cCall	DisplayCurPos
cEnd

;*******************************************************************************
;_LeftToWordStart
;
;Purpose:
; Moves the cursor left on the current line until the begining of a word
; or the begining of the line is found
;
; if x is a word character
; and . is a non word character
; search for:
;      start position of cursor ---------vvvvvvvvvv
;                                  .....XXXXX.....XXXXX.....
;                                       ^
;      end position of cursor ----------/
;
;Entry:
;Exit:
; Return Z if no word found before begining of line.
;
;Uses:
;Exceptions:
;
;*******************************************************************************
cProc LeftToWordStart,<NEAR,PUBLIC>
cBegin
	cCall	LeftUntilWord
	jz	WSL_Exit		; Return Z - no word found
	cCall	LeftUntilNonWord
	or	sp,sp			; Set NZ flag
WSL_Exit:
cEnd

;*******************************************************************************
;_LeftPastWordEnd
;
;Purpose:
; Moves the cursor left on the current line until the end of a word
; or the begining of the line is found
;
; if x is a word character
; and . is a non word character
; search for:
;      start position of cursor -------------vvvvvvvvvvv
;                                  .....XXXXX.....XXXXX.......
;                                            ^
;      end position of cursor ---------------/
;
;Entry:
;Exit:
; Return Z - if no between word gap is found before start of line.
;
;Uses:
;Exceptions:
;
;*******************************************************************************
cProc LeftPastWordEnd,<NEAR,PUBLIC>
cBegin
	cCall	LeftUntilNonWord
	cCall	LeftUntilWord
cEnd

;*******************************************************************************
;_RightToWordStart
;
;Purpose:
; Moves the cursor right on the current line until the start of a word
; or the end of the line is found
;
; if x is a word character
; and . is a non word character
; search for:
;      start position of cursor --------vvvvvvvvvv
;                                  .....XXXXX.....XXXXX.....
;                                                 ^
;      end position of cursor --------------------/
;
;Entry:
;Exit:
; Return Z - if end of line before begining of word.
;
;Uses:
;Exceptions:
;
;*******************************************************************************
cProc RightToWordStart,<NEAR,PUBLIC>
cBegin
	cCall	RightWhileWord
	cCall	RightWhileNonWord
cEnd


;*******************************************************************************
;_RightPastWordEnd
;
;Purpose:
; Moves the cursor right on the current line until the end of a word
; or the end of the line is found
;
; if x is a word character
; and . is a non word character
; search for:
;      start position of cursor -------------vvvvvvvvvvv
;                                  .....XXXXX.....XXXXXX.....
;                                                       ^
;      end position of cursor --------------------------/
;
;Entry:
;Exit:
; Return Z if no word found before end of line.
;
;Uses:
;Exceptions:
;
;*******************************************************************************
cProc RightPastWordEnd,<NEAR,PUBLIC>
cBegin
	cCall	RightWhileNonWord
	jz	WER_Exit		; Return Z - No word found
	cCall	RightWhileWord
	or	sp,sp			; Return NZ - word found
WER_Exit:
cEnd

;*******************************************************************************
;LeftUntilWord
;
;Purpose:
; Moves the cursor left on the current line until the character to the
; left of the cursor is a word character or until the begining of the line
; is found.
;
; if x is a word character
; and . is a non word character
; search for:
;      start position of cursor ------=------vvvvvv
;                                  .....XXXXX.....XXXXXX.....
;                                            ^
;      end position of cursor ---------------/
;
;Entry:
;Exit:
; Return Z if cursor moved to begining of line.
;
;Uses:
;Exceptions:
;
;*******************************************************************************
cProc LeftUntilWord,<NEAR,PUBLIC>
cBegin
ifdef	KANJI
	cCall	DbcsAdjCur
endif	; KANJI
LUW_Repeat:
	mov	ax, [ipCur.ip_ob]
	or	ax,ax				; Begining of line?
	jz	LUW_Exit			; Yes - Return Z

	cCall	FAfterWord			; Is char to left of cursor
						;    a word char?
	jnz	LUW_Exit			; Yes - Return NZ

ifdef	KANJI
	cCall	LeftKanji
else	; KANJI
	dec	[ipCur.ip_ob]			; Otherwise move cursor left
endif	; KANJI
	jmp	short LUW_Repeat

LUW_Exit:
cEnd

;*******************************************************************************
;LeftUntilNonWord
;
;Purpose:
; Moves the cursor left on the current line until the character to the
; left of the cursor is a non word character or until the begining of the line
; is found.
;
; if x is a word character
; and . is a non word character
; search for:
;      start position of cursor --------vvvvvv
;                                  .....XXXXX.....XXXXXX.....
;                                       ^
;      end position of cursor ----------/
;
;Entry:
;Exit:
; Return Z if cursor moved to begining of line.
;
;Uses:
;Exceptions:
;
;*******************************************************************************
cProc LeftUntilNonWord,<NEAR,PUBLIC>
cBegin
ifdef	KANJI
	cCall	DbcsAdjCur
endif	; KANJI
LUNW_Repeat:
	mov	ax, [ipCur.ip_ob]
	or	ax,ax				; Begining of line?
	jz	LUNW_Exit			; Yes - Return Z

	cCall	FAfterWord			; Is char to left of cursor
						;    a word char?
	jz	LUNW_ExitNZ			; Yes - Return NZ

ifdef	KANJI
	cCall	LeftKanji
else	; KANJI
	dec	[ipCur.ip_ob]			; Otherwise move cursor left
endif	; KANJI
	jmp	short LUNW_Repeat

LUNW_ExitNZ:
	or	sp,sp				; Set NZ flag
LUNW_Exit:
cEnd

;*******************************************************************************
;RightWhileWord
;
;Purpose:
; Moves the cursor right on the current line until the character under
; the cursor is a non word character or until the end of the line is found.
;
; if x is a word character
; and . is a non word character
; search for:
;      start position of cursor --------vvvvvv
;                                  .....XXXXX.....XXXXXX.....
;                                            ^
;      end position of cursor ---------------/
;
;Entry:
;Exit:
; Return Z if cursor moved to end of line.
;
;Uses:
;Exceptions:
;
;*******************************************************************************
cProc RightWhileWord,<NEAR,PUBLIC>
cBegin
ifdef	KANJI
	cCall	DbcsAdjCur
endif	; KANJI
RWW_Repeat:
	mov	ax, [ipCur.ip_ob]
	cmp	ax, [ldCur.ld_cb]		; End of line?
	jae	RWW_ExitZ			; Yes - Return Z

	cCall	FOnWord				; On a word char?
	jz	RWW_ExitNZ			; No - Return NZ

ifdef	KANJI
	cCall	RightKanji
else	; KANJI
	inc	[ipCur.ip_ob]
endif	; KANJI
	jmp	short RWW_Repeat

RWW_ExitNZ:
	or	sp,sp				; Return - NZ
	jmp	short RWW_Exit

RWW_ExitZ:
	xor	ax,ax				; Return - Z
RWW_Exit:
cEnd

;*******************************************************************************
;RightWhileNonWord
;
;Purpose:
; Moves the cursor right on the current line until the character under
; the cursor is a word character or until the end of the line is found.
;
; if x is a word character
; and . is a non word character
; search for:
;      start position of cursor -------------vvvvvv
;                                  .....XXXXX.....XXXXXX.....
;                                                 ^
;      end position of cursor --------------------/
;
;Entry:
;Exit:
; Return Z if cursor moved to end of line.
;
;Uses:
;Exceptions:
;
;*******************************************************************************
cProc RightWhileNonWord,<NEAR,PUBLIC>
cBegin
ifdef	KANJI
	cCall	DbcsAdjCur
endif	; KANJI
RWNW_Repeat:
	mov	ax, [ipCur.ip_ob]
	cmp	ax, [ldCur.ld_cb]		; End of line?
	jae	RWNW_ExitZ			; Yes - Return Z

	cCall	FOnWord				; On a word char?
	jnz	RWNW_Exit			; Yes - Return NZ

ifdef	KANJI
	cCall	RightKanji
else	; KANJI
	inc	[ipCur.ip_ob]
endif	; KANJI
	jmp	short RWNW_Repeat

RWNW_ExitZ:
	xor	ax,ax				; Return - Z
RWNW_Exit:
cEnd

;*******************************************************************************
;FOnWord
;
;Purpose:
; Checks if the cursor is on a word character
;
;
;Entry:
;Exit:
; Return NZ if cursor is on a word.
;
;Uses:
;Exceptions:
;
;*******************************************************************************
cProc FOnWord,<NEAR,PUBLIC>
cBegin
	mov	bx, [ldCur.ld_prgch]
	add	bx, [ipCur.ip_ob]
	mov	al,[bx]
	cCall	IsWordChar,<ax>
	or	ax,ax
cEnd

;*******************************************************************************
;FAfterWord
;
;Purpose:
; Checks if the character to the left of the cursor is a word character.
;
;
;Entry:
;Exit:
; Return NZ if the character to the left of the cursor is a word character.
;
;Uses:
;Exceptions:
;
;*******************************************************************************
cProc FAfterWord,<NEAR,PUBLIC>
cBegin
	mov	bx, [ldCur.ld_prgch]
	add	bx, [ipCur.ip_ob]
	dec	bx
	mov	al,[bx]
	cCall	IsWordChar,<ax>
	or	ax,ax
cEnd


;*******************************************************************************
;_LineUp
;
;Purpose:
;	Scroll screen up on line leaving cursor in place on screen
;Entry:
;	fMultiLine
;	ipCur
;	pdCur
;Exit:
;	ipCur
;	pdCur
;Uses:
;	none
;Exceptions:
;
;*******************************************************************************
cProc LineUp,<NEAR,PUBLIC>
cBegin
	test	[emState], ES_MULTILINE
	jnz	$I653
ifndef SILENT
	cCall	NearBeep
endif
	jmp	SHORT $I655
$I653:
	cCall	UpdateLine
	mov	ax,[pdCur.pd_olntop]
	mov	bx, [ipCur.ip_oln]
	or	bx,bx
	jz	$I655

	cmp	bx,ax			;if at top of screen scroll up
	jne	$I654

	cCall	ScrollUp
$I654:
	cmp	[cLinesCur],1		;if there is only one line in buffer
	je	$I655			;then don't move up.
	dec	ipCur.ip_oln		;else move ip up
$I655:
cEnd

;*******************************************************************************
;_LineDown
;
;Purpose:
;	Scroll file down on screen 1 line. Leave cursor in place.
;Entry:
;	fMultiLine
;	pwndEditCur
;	hBuffer
;	pdCur
;	ipCur
;	
;Exit:
;	ipCur
;Uses:
;	bx
;Exceptions:
;
;*******************************************************************************
cProc LineDown,<NEAR,PUBLIC>
cBegin
	test	[emState], ES_MULTILINE
	jz	$I660
	cCall	UpdateLine
	;!!! get structure
	mov	ax,[cLinesCur]			;pwndEditCur.cLines
	add	ax,pdCur.pd_olntop
	dec	ax
	cmp	ax,ipCur.ip_oln			;if at bottom scroll down
	jne	$I658
	cCall	ScrollDown
$I658:
	mov	ax, [clnCur]			;check not at end of file
	cmp	ax,ipCur.ip_oln
	jbe	$I660				;brif can go down
	cmp	[cLinesCur],1			;if there is only one line in
	je	$I661				;buffer, don't move down.
	inc	ipCur.ip_oln
	jmp	SHORT $I661
$I660:
ifndef SILENT
	cCall	NearBeep
endif
$I661:
cEnd

;*******************************************************************************
;_CharLeft
;
;Purpose:
;	Move cursor to the left 1 character
;Entry:
;	ipCur
;Exit:
;	ipCur
;	pdCur
;	shiftWidth
;Uses:
;	none
;Exceptions:
;
;*******************************************************************************
cProc CharLeft,<NEAR,PUBLIC>
cBegin
ifdef	KANJI
	cCall	DbcsAdjCur
endif	; KANJI
	cmp	ipCur.ip_ob,0			;if already to left don't move
	jne	$I663
ifndef SILENT
	cCall	NearBeep
endif
	jmp	SHORT $I665
$I663:
ifdef	KANJI
	cCall	LeftKanji
else	; KANJI
	dec	ipCur.ip_ob
endif	; KANJI
	mov	ax,pdCur.pd_obleft		;check if past left margin
	cmp	ipCur.ip_ob,ax
	jge	$I665				;brif to right of left margin
	sub	ax,ax
	cCall	PageLeft,<shiftWidth,ax>
$I665:
cEnd

;*******************************************************************************
;_PageUp
;
;Purpose:
;	Move toward start of file 1 page (screen height)
;Entry:
;	fMultiLine
;	ipCur
;	pdCur
;	pwndEditCur
;Exit:
;	fRefreshScreen
;	ipCur
;Uses:
;	bx
;Exceptions:
;
;*******************************************************************************
cProc PageUp,<NEAR,PUBLIC>
cBegin
	test	[emState], ES_MULTILINE
	jnz	$I667
$L20059:
ifndef SILENT
	cCall	NearBeep
endif
	jmp	SHORT $I669
$I667:
	cCall	UpdateLine
	cmp	pdCur.pd_olntop,0		;can't page up if a top file
	je	$L20059
	mov	ax,[cLinesCur]			;pwndEditCur.cLines
	sub	pdCur.pd_olntop,ax		;move up 1 screen 
	jns	$I670				;brif did not wrap past 0
	mov	pdCur.pd_olntop,0		;not enough room so goto top
$I670:
	mov	ax,[cLinesCur]			;pwndEditCur.cLines
	sub	ipCur.ip_oln,ax 		;move ip up 1 sceen
	jns	$I671				;check did not underflow
	mov	ipCur.ip_oln,0			;not enough room
$I671:
	inc	[fRefreshScreen]
$I669:
cEnd

;*******************************************************************************
;_Scrolldown
;
;Purpose:
;	Scroll down 1 screen
;Entry:
;	fMultiLine
;	pdCur
;	ipCur
;Exit:
;	ipCur
;Uses:
;	si = oln
;Exceptions:
;
;*******************************************************************************
cProc ScrollDown,<NEAR,PUBLIC>,<SI>
cBegin
	test	[emState], ES_MULTILINE
	jz	$I675
	cCall	UpdateLine
	mov	si,[cLinesCur]			;pwndEditCur.cLines
	add	si,[pdCur.pd_olntop]		;move top down 1 screen
	mov	ax, [clnCur]			;check if past end of file
	cmp	ax,si				;si - oln
	jb	$I675
	mov	ax,[cLinesCur]			;pwndEditCur.cLInes
	dec	ax				;scroll 1 less then screen
	sub	cx,cx
	mov	dx,1

	push	[pwndEditCur]
	xor	cx,cx
	push	cx				; rxDest = 0
	push	cx				; ryDest = 0
	push	[cColumnsCur]			; drx = cColumnsCur
	mov	ax,[cLinesCur]
	dec	ax
	push	ax				; dry = cLinesCur - 1
	push	cx				; rxSrc = 0
	mov	ax,1
	push	ax				; rySrc = 1
	cCall	BltRrc

	inc	[pdCur.pd_olntop]		;adjust for new top of screen
	cCall	RefreshLine,<si>		;refresh scrolled over line

	mov	ax, [ipCur.ip_oln]
	cmp	ax, [pdCur.pd_olntop]
	jae	$I677
	inc	ipCur.ip_oln
	jmp	SHORT $I677
$I675:
ifndef SILENT
	cCall	NearBeep
endif
$I677:
cEnd

;*******************************************************************************
;ScrollUp
;
;Purpose:
;	Move up 1 line.  See ScrollDown
;Entry:
;	fMultiLine
;	pdCur
;	ipCur
;Exit:
;	ipCur
;Uses:
;	si = oln
;Exceptions:
;
;*******************************************************************************
cProc ScrollUp,<NEAR,PUBLIC>,<SI>
cBegin
	test	[emState], ES_MULTILINE
	jz	$I681
	cCall	UpdateLine
	mov	si,[pdCur.pd_olntop]		;scroll off top line
	dec	si
	js	$I681				;but don't scroll at top file

	cCall	GetLineScratch,<si>

	push	[pwndEditCur]			; pwnd
	xor	cx,cx				; cx = 0
	push	cx				; rxDest = 0
	mov	ax,1
	push	ax				; ryDest = 1
	push	[cColumnsCur]			; drx = cColumnsCur
	mov	ax,[cLinesCur]
	dec	ax
	push	ax				; dry = cLinesCur - 1
	push	cx				; rxSrc = 0
	push	cx				; rySrc = 0
	cCall	BltRrc

	mov	pdCur.pd_olntop,si		;new top of screen
	cCall	RefreshLine,<si>

	mov	ax, [pdCur.pd_olntop]
	add	ax, [cLinesCur]
	cmp	ax, [ipCur.ip_oln]
	ja	$I683
	dec	ipCur.ip_oln
	jmp	SHORT $I683
$I681:
ifndef SILENT
	cCall	NearBeep
endif
$I683:
cEnd

;*******************************************************************************
;_PageDown
;
;Purpose:
;	Move down file 1 page
;Entry:
;	fMultiLine
;	ipCur
;	pdCur
;	hBuffer
;Exit:
;	ipCur
;	fRefreshScreen
;Uses:
;	none
;Exceptions:
;
;*******************************************************************************
cProc PageDown,<NEAR,PUBLIC>
cBegin
	test	[emState], ES_MULTILINE
	jnz	$I685
$L20062:
ifndef SILENT
	cCall	NearBeep
endif
	jmp	SHORT $I687
$I685:
	cCall	UpdateLine
	mov	ax, [clnCur]			;check that page down won't
	mov	cx,[cLinesCur]			;pwndEditCur.cLines
	add	cx,WORD PTR pdCur.pd_olntop
	cmp	cx,ax
	jae	$L20062				;brif if paging off eof
	mov	ax,[cLinesCur]			;pwndEditCur.cLines
	add	pdCur.pd_olntop,ax		;adjust screen down 1 page
	add	ipCur.ip_oln,ax
	mov	ax, [clnCur]			;check if new ip is off eof
	cmp	ax,ipCur.ip_oln
	ja	$I688				;brif new ip still within file
	dec	ax				;else put ip at eof
	mov	ipCur.ip_oln,ax
$I688:
	inc	[fRefreshScreen]
$I687:
cEnd

;*******************************************************************************
;_PageLeft
;
;Purpose:
;	Page file to left.
;Entry:
;	ipCur
;	pdCur
;	pwndEditCur
;Exit:
;	ipCur
;	fRefreshScreen
;Uses:
;	shiftWidth
;	fMoveIp
;Exceptions:
;
;*******************************************************************************
cProc PageLeft,<NEAR,PUBLIC>
	parmW	$shiftWidth
	parmB	fMoveIp
cBegin
	cmp	pdCur.pd_obleft,0		;check if already to far left
	jne	$I692				;brif can still move to left
ifndef SILENT
	cCall	NearBeep			    ;no room to page left
endif
	jmp	SHORT $I693			;exit
$I692:
	mov	ax,pdCur.pd_obleft		;see if room to movu shiftwidth
	cmp	[$shiftWidth],ax
	jbe	$I694				;brif room move left shiftwidth
	mov	pdCur.pd_obleft,0		;else move the way left
	jmp	SHORT $I695
$I694:
	mov	ax,[$shiftWidth]			;adjust left margin
	sub	pdCur.pd_obleft,ax
$I695:
	cmp	[fMoveIp],0	
	je	$I698
	mov	ax,ipCur.ip_ob			;move ip with page left
	cmp	[$shiftWidth],ax
	jbe	$I697
	mov	ipCur.ip_ob,0
	jmp	SHORT $I698
$I697:
	mov	ax,[$shiftWidth]
	sub	ipCur.ip_ob,ax
$I698:
	mov	ax,[cColumnsCur]		;pwndEditCur.cColumns
	add	ax,pdCur.pd_obleft		;check if ip still on screen
	cmp	ax,ipCur.ip_ob
	ja	$I699				;brif so
	mov	ax,pdCur.pd_obleft		;if off screen move to margin
	mov	ipCur.ip_ob,ax
$I699:
	inc	[fRefreshScreen]
$I693:
cEnd

cProc PageRight,<NEAR,PUBLIC>
	parmW	$shiftWidth
	parmB	fMoveIp

	localW	obMax
cBegin
	mov	cx,pdCur.pd_obleft
	mov	dx,ipCur.ip_ob

	mov	ax,ldCur.ld_cbMax		;calc. max. offset can move
	mov	bx,pwndEditCur			;move to the right
	sub	ax,[cColumnsCur]		;pwndEditCur.cColumns
	jle	PR_1				;brif cbMax < cColumns
	mov	[obMax],ax	
	cmp	[obMax],cx	
	ja	$I704				;brif ok to page right

PR_1:
ifndef SILENT
	cCall	NearBeep
endif
	jmp	SHORT $I705			;return
$I704:
	mov	ax,[$shiftWidth]
	add	ax, cx				;ax = $shiftWidth+obleft
;	add	ax,pdCur.pd_obleft		;check if new margin+shiftwidth
	cmp	ax,[obMax]			;check if over limit
	jb	$I706				;brif not over limit
	mov	ax,[obMax]			;else put margin at max.
	mov	cx, ax				;cx = obleft
;	mov	pdCur.pd_obleft,ax
	jmp	SHORT $I707
$I706:
	mov	ax,[$shiftWidth]		;move margin to shift
	add	cx, ax				;cx = obleft+shiftwidth
;	add	pdCur.pd_obleft,ax
$I707:
	cmp	[fMoveIp],FALSE	
	je	$I708				;brif ip not to follow page
	mov	ax,[$shiftWidth]
	add	dx, ax				;dx = ipCur.ob+shiftWidth
;	add	ipCur.ip_ob,ax
$I708:
;	mov	ax,pdCur.pd_obleft
	cmp	dx, cx				;check if ip still on screen
;	cmp	ipCur.ip_ob,ax			;check if ip still on screen
	jge	$I709
	mov	dx, ax
$I709:
	mov	ax,ldCur.ld_cbMax		;could have gone past eol
	cmp	dx, ax
;	cmp	ipCur.ip_ob,ax
	jb	$I710				;brif ip still on line
	dec	ax				;if not then put at eol
	mov	dx, ax
$I710:
	inc	[fRefreshScreen]
$I705:
	mov	ipCur.ip_ob, dx
	mov	pdCur.pd_obleft, cx
cEnd

ifdef	KANJI

cProc LeftKanji,<NEAR,PUBLIC>
cBegin
	cCall	GetLineScratchPad,<[ipCur.ip_oln]>
	mov	ax,[ipCur.ip_ob]
	mov	bx,[ldEMScratch.LD_prgch]
	add	ax,bx
	cCall	PchPrevDbcs,<ax,bx>
	sub	ax,[ldEMScratch.LD_prgch]
	mov	[ipCur.ip_ob],ax
cEnd

cProc RightKanji,<NEAR,PUBLIC>
cBegin
	cCall	GetLineScratchPad,<[ipCur.ip_oln]>
	mov	bx,[ldEMScratch.LD_prgch]
	add	bx,[ipCur.ip_ob]
	cCall	PchNextDbcs,<bx>
	sub	ax,[ldEMScratch.LD_prgch]
	mov	[ipCur.ip_ob],ax
cEnd

cProc DbcsAdjCur,<NEAR,PUBLIC>
cBegin
	cCall	DbcsAdjCursor
	mov	[ipCur.ip_ob],ax
SkipAdjCur:
cEnd

cProc DbcsAdjCursor,<NEAR,PUBLIC>,<si,di>
cBegin
	cCall	GetLineScratchPad,<[ipCur.ip_oln]>
	mov	si,[ipCur.ip_ob]
	mov	bx,[ldEMScratch.LD_prgch]
	add	si,bx
	cCall	PchPrevDbcs,<si,bx>
	xchg	ax,di
	cCall	PchNextDbcs,<di>
	cmp	ax,si
	je	@F
	xchg	ax,di
@@:
	sub	ax,[ldEMScratch.LD_prgch]
cEnd

endif	; KANJI

;*******************************************************************************
;_DisplayCurPos
;
;Purpose:
;	Recalc. the file offset for the top of screen and left margin. This
;	is done when a seek to an arbitrary position within file is done
;	and a total calc. of position relative to currency is needed.
;Entry:
;	fRedraw 
;	pdCur
;	ipCur
;	pwndEditCur
;Exit:
;	ipCur
;	pdCur
;	fRefreshScreen
;Uses:
;	ax, bx, cx, dx, si, di
;	si = margin
;	di - ipCur.ob and olnBottom
;	obRight
;	shiftWidthSave
;Exceptions:
;	If run out of memory trying to allocate a buffer, runtime error
;		"Error during Initialization" or some such.
;*******************************************************************************
cProc DisplayCurPos,<NEAR,PUBLIC>,<SI,DI>

	localW	obRight
	localW	shiftWidthSave
cBegin

ifdef	KANJI
	cCall	DbcsAdjCur
endif	; KANJI
	test	[emState], ES_NOREDRAW
	jz	$JCC6737		;brif ok to redraw screen
	jmp	$EX711			;don't do recalc if no redraw
$JCC6737:
	mov	si,[cLinesCur]		;pwndEditCur.cLines
	shr	si,1			;calc. margin at 1/4 screen width
	shr	si,1			;margin - space left at edge
	;Compute file offset to move to top of screen
	mov	cx, pdCur.pd_olntop
	mov	dx, ipCur.ip_oln
;First check ipCur.oln < pdCur.olntop -  is ip above current top of screen
	cmp	dx, cx
	jae	$I718			;brif if ip below top of screen
	cmp	dx, si			;is ip within margin of beg. file
	jae	$I719			;brif if not
	xor	cx, cx	  		;if that close to bof, set at top
	jmp	SHORT $L20063
$I719:
	mov	ax, cx
	sub	ax,si			;check if ip between top of screen(tos)
	cmp	ax,dx			;and tos-margin (just above screen)
	jae	$I721			;brif if father above then that
	mov	cx,dx			;if that close make it tos
	jmp	SHORT $L20063
$I721:
	mov	cx, dx			;else tos to ip - margin
	sub	cx, si		       
$L20063:
	mov	pdCur.pd_olntop,cx	;adjust to new tos
$I720:
	inc	[fRefreshScreen]

;Here after check for ip above tos
; Now check if ip below last line on screen
$I718:
	mov	di, [cLinesCur] 	;pwndEditCur.cLines
	add	di, cx			;di = olntop + cLines
	dec	di			;di = olnBottom of screen
	cmp	di, dx			;dx = ipCur.ip_oln
	jae	$I723			;brif ip below last line of screen
	mov	ax, di			;check if ip between bot. and margin
	add	ax, si
	cmp	ax, dx			;dx = ipCur.ip_oln
	jbe	$I724			;brif below more then margin 
	mov	ax, dx			;else set tos so ip is at bottom
	sub	ax, di
	add	cx, ax
	jmp	SHORT $I725
$I724:
	mov	cx, dx			;ok to adjust tos to put move by
	sub	cx, si			;by margin distance
$I725:
	mov	pdCur.pd_olntop, cx
	inc	[fRefreshScreen]
	
;Here when ready to recalc the columns
$I723:
	mov	cx, pdCur.pd_obleft
	mov	si,[cColumnsCur]	;pwndEditCur.cColumns
	shr	si,1			;calc. margin for columns again
	shr	si,1			;a factor of 1/4 screen width
	mov	ax,shiftWidth
	mov	[shiftWidthSave],ax	;use new shiftWidth based on margin
	cmp	ax,si
	jbe	$I726			;brif shiftWidth less then margin
	mov	shiftWidth,si		;if bigger use margin as shiftWidth
$I726:
	mov	ax,[cColumnsCur]	;pwndEditCur.cColumns
	add	ax,cx			;calc. left edge of screen
	dec	ax
	mov	[obRight],ax		;line offset for left edge
	mov	di,ipCur.ip_ob		;di - ip col. offset
;Check if ip is to left of left margin
	cmp	cx,di
	jbe	$I727			;brif ip to right of left margin
	cmp	di,si			;is ip with margin of start of line
	jae	$I728			;brif ip more the margin from start
	xor	cx, cx			;just set to start of line
	jmp	SHORT $L20064
$I728:
	mov	ax,cx			;check if ip is within margin of 
	sub	ax,si			;left edge
	cmp	ax,di
	jbe	$I730			;brif ip more then margin away
	mov	cx,di
	sub	cx,si			;adjust by margin
	jmp	SHORT $L20064
$I730:
	mov	cx,di			;else don't use margin to adjust
	sub	cx,shiftWidth		;but shiftWidth
$L20064:
	mov	pdCur.pd_obleft, cx	;set up new left margin
$I729:
	inc	[fRefreshScreen]
;How check if ip past right edge of screen
$I727:
	mov	ax,[cColumnsCur]	;pwndEditCur.cColumns
	add	ax, pdCur.pd_obleft
	cmp	ax,di
	;!!! why can't use obright in above compare with temp inc.
	ja	$I732			;brif to left of right edge
	mov	ax,ldCur.ld_cbMax	;check if ip within full screen of edge
	sub	ax,[cColumnsCur]	;pwndEditCur.cColumns
	cmp	ax,di		
	jbe	$L20065			;brif ?
	mov	ax,[obRight]		
	add	ax,si
	cmp	ax,di			;check if ip with margin region
	jbe	$I735			;brif if not
	mov	ax,shiftWidth		;with margin of edge so use shiftWidth
	sub	ax,[cColumnsCur]	;pwndEditCur.cColumns
	add	ax,di
	jmp	SHORT $L20065
$I735:
	mov	ax,di			;else adjust it by margin
	sub	ax,si
$L20065:
	mov	pdCur.pd_obleft,ax
	inc	[fRefreshScreen]
$I732:
	mov	ax,[shiftWidthSave]	;restore shiftWidth
	mov	shiftWidth,ax
$EX711:
cEnd


cProc AutoIndent,<NEAR,PUBLIC>
cBegin
	xor	ax,ax			; Use 0 for last line.
	mov	bx, [ipCur.ip_oln]
	cmp	bx, [clnCur]
	jae	AI_1

	cCall	GetCurLine
	cCall	obGetFirst		;get offset for first non-white spe
AI_1:
	mov	ipCur.ip_ob,ax
cEnd

;*******************************************************************************
;BackTab
;
;Purpose:
;  Back Tab the current line
;Entry:
;	ipCur
;  di == amount to backtab the line
;Exit:
;Uses:
;Exceptions:
;
;*******************************************************************************
cProc BackTab,<NEAR,PUBLIC>
cBegin
	cCall	ModifyLine
	jz	BackTab_Exit

	or	di,di
	jz	BackTab_Exit

	cCall	obGetFirst
	mov	[ipCur.ip_ob], ax
	cmp	ax, di
	jbe	BT_1
	mov	ax, di

BT_1:
	or	ax,ax
	jz	BackTab_Exit

	cCall	DelCh,<ax,ax>
BackTab_Exit:
	mov	[fResetAnchor], 1
cEnd

;Do what little undo we support
cProc Undo,<NEAR,PUBLIC>
cBegin
	and	ldCur.ld_flags, not ld_fDirty
	mov	pdCur.pd_oln,-1		;set to no current line in ld
	cCall	RefreshLine,<[ipCur.ip_oln]>	;get line from buffer
	cCall	HomeLine
	cCall	ResetAnchor		;set ipAnchor to ipCur
cEnd

cProc Cut,<NEAR,PUBLIC>
	parmB	fCopy

	localW	olnBottom
	localW	olnFirst
	localW	obFirst
	localW	olnLast
	localW	obLast
cBegin
	cCall	fCheckReadOnly
	jnz	ExitCut
	mov	bx,pefCur
	cmp	[bx].ef_fSelection,FALSE
	je	$I751			;if no selection then no cut

	lea	ax,[olnFirst]
	lea	bx,[obFirst]
	lea	cx,[olnLast]	
	lea	dx,[obLast]
	cCall	BuildSelection,<ax,bx,cx,dx>
	mov	bx,pefCur		;after cut don't have any selection
	mov	[bx].ef_fSelection,FALSE
	mov	ax,[olnLast]		;check if single line cut
	cmp	[olnFirst],ax	;i.e. first line == last line
	jne	$I749			;brif if multi-line cut
	mov	al,[fCopy]		;check if distructive cut
	sub	ah,ah
	cCall	CutChars,<olnFirst,obFirst,obLast,ax>
	jmp	SHORT $I751
;Here for mult-line cut
$I749:
	cmp	WORD PTR [obLast],0	;if selection is only first ch. of last
	jne	$I752			;line then don't current last line
	dec	WORD PTR [olnLast]	;this is to cut all of current line
$I752:
	mov	ax,[olnLast]
	sub	ax,[olnFirst]
	inc	ax
	mov	bl,[fCopy]
	sub	bh,bh
	cCall	CutLines,<olnFirst,ax,bx>
$I751:
	cCall	ResetAnchor
ExitCut:
cEnd


cProc CutChars,<NEAR>
	parmW	oln
	parmW	obFirst
	parmW	obLast
	parmB	fCopy
cBegin
	cmp	[fCopy],0
	je	$I759
;Here to copy chars to scrap first
	cCall	CopyCharsToScrap,<oln,obFirst,obLast>
$I759:
	cCall	ModifyLine
	mov	ax,[obFirst]		;first character to delete
	mov	ipCur.ip_ob,ax	
	mov	ax,ldCur.ld_cb
	cmp	[obFirst], ax
	jae	$I762

	cmp	[obLast],ax
	jbe	$I761			;brif last char. is not past eol

	mov	[obLast],ax		;cut off del. to eol
$I761:
	mov	ax,[obLast]
	sub	ax,[obFirst]		;ax - # of chars to delete
	cCall	DelCh,<ax,obLast>
$I762:
	cCall	DisplayCurPos		;recalc. screen position in file
	cCall	RefreshLine,<oln>	;redraw the current line
cEnd

cProc CutLines,<NEAR>
	parmW	olnFirst
	parmW	cln
	parmB	fCopy
cBegin
	cmp	[fCopy],0	;check if destructive?
	je	$I766
	cCall	CopyLines,<olnFirst,cln>
	jz	CutLinesExit
$I766:
	cCall	UpdateLine
	mov	[pdCur.pd_oln], -1
	cCall	DeleteLinesBuf,<hBuffer,olnFirst,cln>
	cCall	EMRefreshCache
	mov	ax,[olnFirst]		;update new insertion point
	mov	ipCur.ip_oln,ax
	cCall	AutoIndent		;adjust to start of valid text
	mov	ax,pdCur.pd_olntop
	cmp	[olnFirst],ax		;check of cut start below screen
	jae	$I768			;brif if start of cut below screen
	mov	ax,[olnFirst]		;move screen top to start of cut
	mov	pdCur.pd_olntop,ax
$I768:
	cCall	DisplayCurPos
CutLinesExit:
	inc	[fRefreshScreen]
cEnd

cProc Copy,<NEAR,PUBLIC>

	localW	olnFirst
	localW	obFirst
	localW	olnLast
	localW	obLast
cBegin
	mov	bx,pefCur
	cmp	BYTE PTR [bx].ef_fSelection,0
	je	$I776

	lea	ax,[olnFirst]
	lea	bx,[obFirst]
	lea	cx,[olnLast]
	lea	dx,[obLast]
	cCall	BuildSelection,<ax,bx,cx,dx>
	mov	ax,[olnLast]			;check if multi-line copy
	cmp	[olnFirst],ax
	jne	$I775				;brif if multi-line copy
	cCall	CopyCharsToScrap,<olnFirst,obFirst,obLast>
	jmp	SHORT $I776			;jmp around multi-copy
$I775:
	cmp	[obLast],0			;check if last line is copied
	jne	$I777				;brif last line included in copy
	dec	[olnLast]			;no first ch. select. not last
						;line copy
$I777:
	mov	ax,[olnLast]	
	sub	ax,[olnFirst]
	inc	ax
	push	ax
	cCall	UpdateLine
	pop	ax
	cCall	CopyLines,<olnFirst,ax>
$I776:
cEnd

cProc CopyCharsToScrap,<PUBLIC,NEAR>
	parmW	oln
	parmW	obFirst
	parmW	obLast
cBegin
	cCall	FreeScrap
	cCall	EMRefreshCache

	mov     ax,MAXCHARS

	push	[oln]
	push	[obFirst]
	push	[obLast]
ifdef	PROJECT_QB
	mov	dx,SEG sb_buffer
	push	dx
	mov	bx,OFFSET sb_buffer
else	;PROJECT_QB
	push	ds
	mov     bx,OFFSET DGROUP:sb_buffer
endif	;PROJECT_QB
	push	bx
	push	ax
	call    CopyChars

	mov     [_scrap.sb_cb],ax
	mov     [_scrap.sbfMultiLine],0
	mov	[fPasteOk],1
cEnd

ifdef	KK_UNIT

cProc AdjustKKDisplay,<PUBLIC,FAR>,<si>
	parmW	cch
cBegin
	mov	si,[ipCur.ip_ob]
	mov	ax,[cch]
	add	[ipCur.ip_ob],ax
	cCall	DisplayCurPos
	mov	[ipCur.ip_ob],si
	cmp	[fRefreshScreen],0
	jz	@F
	cCall	RefreshScreen
@@:
	cCall	Refreshline,<[ipCur.ip_oln]>
cEnd

endif	; KK_UNIT

cProc CopyChars,<NEAR,PUBLIC>,<SI>
	parmW	oln
	parmW	obFirst
	parmW	obLast
	parmD	fpBuffer
	parmW	cbMax
cBegin
;       register si = cbText

	cCall    GetLine,<oln>

	mov     si,[obLast]
	sub     si,[obFirst]

	mov     ax,[ldCur.LD_cbMax]
	sub     ax,[ldCur.LD_cb]
	jz      CC1

	push    ax
	mov     ax,' '
	push    ax
	mov     ax,[ldCur.LD_cb]
	add     ax,[ldCur.LD_prgch]
	push    ax
	call    _memset
	add     sp,6
CC1:

	cmp     [cbMax],si
	ja      CC2
	mov     si,[cbMax]
	dec     si
CC2:
	or      si,si
	je      CC3

	mov     ax,[obFirst]
	add     ax,[ldCur.LD_prgch]
	push    ds
	push    ax
	push    word ptr [fpBuffer+2]
	push    word ptr [fpBuffer]
	push    si
	call	bltbytex
CC3:
	mov     bx,[ldCur.LD_cb]
	add     bx,[ldCur.LD_prgch]
	mov     BYTE PTR [bx],0

	les     bx,[fpBuffer]
	mov     BYTE PTR es:[bx][si],0

	mov     ax,si
cEnd


cProc CopyLines,<NEAR,PUBLIC>,<SI,DI>
	parmW	olnFirst
	parmW	cln
cBegin
	mov	si,[olnFirst]
	mov	di,[cln]
	inc	di
	cCall	FreeScrap
	cCall	EMRefreshCache
	jmp	SHORT $L20067
$WC793:
	cmp	si, [clnCur]
	jae	CopyLines_Done
	cCall	EMRefreshCache
	cCall	GetLine,<si>
	inc	si

	cCall	hBufScrap
	push	ax			; 1st parm of InsertLineBuf
	cCall	LinesInBuf,<ax>
	push	ax			; 2nd parm of InsertLineBuf
	push	ldCur.ld_cb		; 3rd parm of InsertLineBuf
	push	ldCur.ld_prgch		; 4th parm of InsertLineBuf
	call	InsertLineBuf		;insert into scrap
	cbw
	or	ax,ax			;text of insert was a success
	je	$WB794			;break out of out of memory
$L20067:
	dec	di
	jnz	$WC793

CopyLines_Done:
	mov	ax, sp			; Return TRUE

$WB794:
	push	ax			; Save return value
	cCall	EMRefreshCache
	pop	ax

	or	ax,ax
	jz	CopyLines_Fail
					; NZ flag still set
	mov	_scrap.SBfMultiLine,1	; NZ flag still set
	mov	[fPasteOk],1            ; NZ flag still set
	jmp	short CopyLines_Exit    ; return NZ

CopyLines_Fail:
	cCall	FreeScrap		; Ran out of memory - free the scrap
	cCall	EMRefreshCache
	xor	ax,ax			; Return Z
CopyLines_Exit:
cEnd

cProc Paste,<NEAR,PUBLIC>,<SI,DI>
	parmDP	pch
cBegin
	cCall	fCheckReadOnly
	jz	@F
	jmp	ExitPaste
@@:
	mov	di,pch
	cmp	_scrap.SBfMultiLine,0
	je	@F			;brif single line scrap
	or	di,di
	je	MultilinePaste		;brif if nothing to paste
@@:
	cmp	_scrap.SB_cb,0
	jne	@F			;brif something in scrap
	or	di,di
	jne	@F
	jmp	ExitPaste
@@:
;Here if single line paste
	cCall	StartBigEdit
	sub	ax,ax
	cCall	Cut,<ax>
	cCall	ModifyLine
	cCall	EndBigEdit
	cCall	EMRefreshCache
	push	ipCur.ip_ob		;save where to start insertion
	or	di,di
	je	@F			;brif to insert from scrap
	push	ds
	push	di			;get size of insertion
	call	fstrlen
	xchg	si,ax			;si = cb
ifdef	PROJECT_QB
	push	ds			;save source segment
endif	;PROJECT_QB
	jmp	SHORT PasteSpaces
@@:
	mov	si,_scrap.SB_cb	;just insert scrap
ifdef	PROJECT_QB
	mov	di,OFFSET SB_buffer	; source offset
	mov	bx,SEG SB_buffer	; source segment
	push	bx			; save source segment
else	;PROJECT_QB
	mov	di,OFFSET DGROUP:SB_buffer
endif	;PROJECT_QB
PasteSpaces:
	;insert spaces to make room for insertion
	mov	ax,32
	cCall	InsCh,<si,ax,ax>	; InsCh( obFirst, ' ', TRUE );
	mov	si,ax
ifdef	PROJECT_QB
	pop	bx			; BX = source segment
endif	;PROJECT_QB
	pop	cx			; CX = thing saved way above
	or	si,si
	je	@F
ifdef	PROJECT_QB
	push	bx			; source addr
	push	di
	push	ds			; dest addr
	add	cx,ldCur.ld_prgch
	push	cx
	push	si			; length 
	call	bltbytex		; do the copy
else	;PROJECT_QB
	push	si
	push	di
	add	cx,ldCur.ld_prgch
	push	cx
	call	_memmove		;copy over spaces just inserted
	add	sp,6
endif	;PROJECT_QB
@@:
	cCall	RefreshLine,<[ipCur.ip_oln]>
	jmp	SHORT ExitPaste

;Here if multi-line paste
MultilinePaste:
	cCall	StartBigEdit
	sub	ax,ax
	cCall	Cut,<ax>
	cCall	UpdateLine
	cCall	EndBigEdit
	cCall	EMRefreshCache
	push	hBuffer
	push	ipCur.ip_oln
	cCall	hBufScrap
	push	ax
	call	InsertBufInBuf		;insert scrap into source
	cCall	EMRefreshCache
	mov	pdCur.pd_oln,-1 	;invalidate ldCur
	inc	[fRefreshScreen]
ExitPaste:
cEnd

cProc NextTab,<NEAR,PUBLIC>,<SI>
	parmW	obCur
cBegin
	;return (obCur/tabStops + 1)*tabStops)
	mov	si,[obCur]
	mov	ax,si
	sub	dx,dx
	div	tabStops
	inc	ax
	mul	tabStops
cEnd

cProc GetTabs,<FAR,PUBLIC>
cBegin
	mov	ax,tabStops
cEnd

cProc SetTabs,<FAR,PUBLIC>
	parmW	value
cBegin
	mov	ax,[value]
	mov	tabStops,ax
cEnd

cProc ResetAnchor,<NEAR,PUBLIC>
cBegin
	mov	ax, ipCur.ip_ob
	mov	ipAnchor.ip_ob, ax
	mov	ax, ipCur.ip_oln
	mov	ipAnchor.ip_oln, ax
cEnd

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\editmgr1.asm ===
;*
;*      COW : Character Oriented Windows
;*
;*      editmgr1.asm : Multi-line edit manager (part1)
;*      (included by editmgr.asm)


cProc   InternalEditWndProc,<FAR,PUBLIC>,<SI,DI>
        parmW   pwnd
        parmW   message
        parmW   wParam
        parmD   lParam

        localW  oln
        localW  olnT
        localW  ob
        localW  clnT
        localW  ptMouseX
        localW  ptMouseY
        localB  fGrabFocus
        localW  olnFirst
        localW  olnLast
        localW  obFirst
        localW  obLast
        localW  fOk
cBegin
;
; We are not re-entrant!!!
; If we are in the middle of a big edit we could be re-entered
; because the text manager may put up a dialog box.
; If this happens, just ignore the messages
;
        test    [emFlags],EMF_IN_EDITMGR
        jz      NotReEntering
        cmp     [message],WM_PAINT
        jne     @F
ifdef   PROJECT_LQB
        mov     [pdCur.pd_oln],-1       ;edit buffer may be new
endif   ;PROJECT_LQB
        cCall   RefreshScreen           ; We can redraw the screen
@@:
        mov     [fOk],FALSE
        jmp     QuickExitEditMgr
NotReEntering:
        or      [emFlags],EMF_IN_EDITMGR
        mov     [fGrabFocus],FALSE
        mov     [fOk],TRUE

NoUpdate:
        mov     bx,[pwnd]               ;pwnd
        mov     pwndEditCur, bx         ;bx = pwnd
        mov     ax,[bx].pefExtra        ; pwnd->pef = pwnd->pefExtra
        mov     [pefCur],ax
        xor     ax,ax
        mov     al,[bx].arcClipping.axRightArc
        sub     al,[bx].arcClipping.axLeftArc
        mov     [cColumnsCur],ax
        mov     al,[bx].arcClipping.ayBottomArc
        sub     al,[bx].arcClipping.ayTopArc
        mov     [cLinesCur],ax
        mov     bx,[pefCur]
        mov     ax,[bx].EF_attrCur
        mov     [CurattrCur],ax
        mov     al,[bx].EF_Style
        mov     [emState],al
        mov     fResetAnchor,FALSE

        ; !!! change later to a single big move !!!
        mov     ax,[bx.EF_ipCur.ip_ob]  ;transfer insertion to local var.
        mov     dx,[bx.EF_ipCur.ip_oln]
        mov     ipCur.ip_ob, ax
        mov     ipCur.ip_oln, dx
        mov     ipStart.ip_ob, ax       ;local start for text selection
        mov     ipStart.ip_oln, dx

        mov     ax, [bx.EF_ipAnchor.ip_ob];
        mov     dx, [bx.EF_ipAnchor.ip_oln];
        mov     ipAnchor.ip_ob, ax
        mov     ipAnchor.ip_oln, dx
        mov     ipAnchorStart.ip_ob, ax
        mov     ipAnchorStart.ip_oln, dx

        mov     di,OFFSET DGROUP:ldCur  ;get pefCur.ldCur
        mov     si,[bx.EF_pldCur]       ;restore current line descriptor
        push    ds
        pop     es
        movsw
        movsw
        movsw
        movsb

        mov     di,OFFSET DGROUP:pdCur  ;get pefCur.pdCur
        lea     si,[bx.EF_pdCur]
        push    ds
        pop     es
        movsw
        movsw
        movsw

        cCall   EMRefreshCache

;
; Make sure the window is not past the end of the buffer
;
        mov     ax, [clnCur]
        cmp     ax, [pdCur.pd_olntop]
        jae     @F
        mov     [pdCur.pd_olntop], ax
@@:
;
; Make sure the cursor is not past the end of the buffer
;
        cmp     ax, [ipCur.ip_oln]
        jae     @F
        mov     [ipCur.ip_oln], ax
@@:
        cmp     ax, [ipAnchor.ip_oln]
        jae     @F
        mov     [ipAnchor.ip_oln], ax
@@:

        push    ds
        push    [ldCur.ld_prgch]
        call    fstrlen
        mov     bx, [ldCur.ld_cbMax]
        cmp     ax, bx          ; brif ldCur.cb < ldCur.cbMax
        jb      @F
        mov     ax, bx
        dec     ax
@@:
        mov     [ldCur.LD_cb], ax

        mov     [fRefreshScreen],0

; Finished initializing editor state

; Start case statement for message
        mov     ax,[message]    ;message
        ;jump   for primary (message)

;case WM_SETFOCUS
$SetFocus:
        cmp     ax, WM_SETFOCUS
        jne     FlushFocus

        mov     [pdCur.pd_oln],-1       ;edit buffer may be new even
                                        ; though pwndEditCur is same
                                        ; which would cause EditMgr entry
                                        ; to not reset pdCur.pd_oln to -1
;; a-emoryh - Don't screw ES_NOSELECT if in QHelp mode
        test    [cmdSwitches],CMD_SW_QHELP
        jnz     QHelpSkip1
        and     [emState], NOT ES_NOSELECT
QHelpSkip1:

        cCall   RefreshSelection

        mov     ax,1
        cCall   EnableCursor,<[pwndEditCur],ax> ;make sure cursor in on now that we
        test    [emState], ES_MULTILINE
        jnz     NotSingleline

        mov     ax, ldCur.ld_cb         ;for single line make end of line
        mov     ipCur.ip_ob,ax          ;current ip position
        mov     ipAnchor.ip_ob,0        ;Anchor to start so whole line selected

NotSingleline:
        cCall   DisplayCurPos           ;force recal of current postion
        jmp     ExitMainCase

;case   WM_FLUSHFOCUS
FlushFocus:
        cmp     ax, WM_FLUSHFOCUS
        jne     WantFocus

        cCall   UpdateLine
        mov     [pdCur.pd_oln],-1
        jmp     ExitMainCase

;case   WM_WANTFOCUS
WantFocus:
        cmp     ax, WM_WANTFOCUS
        jne     KillFocus

        mov     bx,[pwnd]
        mov     ax, word ptr [bx].stfWnd
        and     ax,MASK fEnabledStf
        mov     [fOk],ax
        jmp     ExitMainCase

;case   WM_KILLFOCUS
KillFocus:
        cmp     ax, WM_KILLFOCUS
        jne     SetReDraw

;; a-emoryh - Don't screw ES_NOSELECT if in QHelp mode
        test    [cmdSwitches],CMD_SW_QHELP
        jnz     QHelpSkip2
        or      [emState], ES_NOSELECT
QHelpSkip2:

        cCall   UpdateLine              ;make sure text buffer is correct
        cCall   RefreshSelection
        test    [emState],EF_TRACKING_MOUSE
        je      NoTrack_1               ;brif not tracking the mouse

        cCall   ReleaseCapture          ;if so make sure others get mouse
        and     [emState],NOT EF_TRACKING_MOUSE

NoTrack_1:
        xor     ax, ax
        cCall   EnableCursor,<[pwndEditCur],ax> ;turn cursor off
        test    [emState], ES_MULTILINE
        jnz     Multiline_2             ;brif multiline edit

        mov     ipCur.ip_ob,0           ;reset position for single line case
        mov     pdCur.pd_obleft,0       ;and offset into line

Multiline_2:
        cCall   DisplayCurPos
        jmp     ExitMainCase

;case   WM_SETREDRAW
SetReDraw:
        cmp     ax, WM_SETREDRAW
        jne     Paint

        mov     cx,[wParam]
        jcxz    NoRedraw

        and     [emState], NOT ES_NOREDRAW

        inc     [fRefreshScreen]
        cCall   DisplayCurPos
        jmp     ExitMainCase
NoRedraw:
        or      [emState], ES_NOREDRAW
        jmp     ExitMainCase

;case   WM_PAINT
Paint:
        cmp     ax, WM_PAINT
        jne     SetText
        mov     ax,[cColumnsCur]
        add     ax,WORD PTR pdCur.pd_obleft
        cmp     ax,ldCur.ld_cbMax
        jb      NoRecalc

        mov     ax,ldCur.ld_cbMax       ;change in border forces recalc of
        sub     ax,[cColumnsCur]
        dec     ax
        mov     WORD PTR pdCur.pd_obleft,ax
        cCall   DisplayCurPos

NoRecalc:
        inc     [fRefreshScreen]
        jmp     ExitMainCase

; case WM_SETTEXT
DEBPUBLIC SetText
SetText:
        cmp     ax, WM_SETTEXT
        jne     GetText

        push    ds                      ; Destination for fstrcpy
        push    [ldCur.LD_prgch]
        push    word ptr [lParam+2]     ; Source for fstrcpy
        push    word ptr [lParam]
        call    fstrcpy

        push    ds
        push    [ldCur.LD_prgch]
        call    fstrlen
        mov     [ldCur.LD_cb],ax

        cCall   GetFocus                ;if Focus is this window
        cmp     ax,[pwndEditCur]        ; then select the line
        jne     @F                      ; otherwise don't
        mov     ax,[ldCur.LD_cb]
        mov     ipCur.ip_ob,ax          ;current ip position
        mov     ipAnchor.ip_ob,0        ;Anchor to start so whole line selected
@@:

        cmp     [wParam],0
        jz      SetNoRefresh
        cCall   DisplayCurPos
        cCall   RefreshLine,<ipCur.IP_oln>
SetNoRefresh:
        jmp     ExitMainCase2

;case   WM_GETTEXT
DEBPUBLIC GetText
GetText:
        cmp     ax,WM_GETTEXT
        je      DoGetText
        jmp     $Undo

DoGetText:
        test    [emState], ES_MULTILINE
        jnz     MultiLineGetText

        mov     ax, [ldCur.LD_cb]
        mov     bx,[wParam]
        dec     bx                              ; ensure enough room for null.
        cmp     ax,bx
        jbe     LenOk
        xchg    ax,bx                           ; ax := wParam
LenOk:
        mov     [fOk],ax                        ; Save for return value

        push    ds                              ; Source for bltbytex
        mov     si,[ldCur.LD_prgch]             ; Source for bltbytex
        mov     es,[seg_lParam]                 ; Destination for bltbytex
        mov     di,[off_lParam]                 ; Destination for bltbytex
        mov     bx,ax                           ; bx = count
        add     bx,di                           ; bx = offset of dest. end
        mov     byte ptr es:[bx],0              ; NULL terminate destination.
        cCall   bltbytex,<ds,si,es,di,ax>
        jmp     ExitMainCase1

MultiLineGetText:
        mov     bx,[pefCur]
        test    [bx.EF_fSelection],0ffH
        jz      NoTextToGet

        lea     ax,[olnFirst]
        lea     bx,[obFirst]
        lea     cx,[olnLast]
        lea     dx,[obLast]
        cCall   BuildSelection,<ax,bx,cx,dx>
; Line 206
        mov     ax,[olnLast]
        cmp     [olnFirst],ax
        jne     NoTextToGet


        push    [olnFirst]
        push    [obFirst]
        push    [obLast]
        push    word ptr [lParam+2]
        push    word ptr [lParam]
        push    [wParam]
        call    CopyChars
        mov     [fOk],ax

        jmp     short ExitGetText

NoTextToGet:
        xor     ax,ax
        les     bx, [lParam]
        mov     byte ptr [bx], 0
        mov     [fOk],ax
ExitGetText:
        jmp     ExitMainCase1

;case   WM_UNDO
$Undo:
        cmp     ax, WM_UNDO
        jne     $Clear
        cCall   Undo
        jmp     ExitMainCase

;case   WM_CLEAR
$Clear:
        cmp     ax, WM_CLEAR
        jne     $Cut

        xor     ax,ax
        jmp     short DoCut

;case   WM_CUT
$Cut:
        cmp     ax, WM_CUT
        jne     $Copy

        mov     ax,1
DoCut:
        mov     bx,[pefCur]
        cmp     [bx.EF_fSelection],0
        je      NoSel
        cCall   Cut,<ax>
        cCall   DisplayCurPos
        jmp     ExitMainCase
NoSel:                  ;with no selection Del key is a delete
        cCall   Del
        jmp     ExitMainCase

;case   WM_COPY
$Copy:
        cmp     ax, WM_COPY
        jne     $Paste
        cCall   Copy
        jmp     ExitMainCase

;case   WM_PASTE
$Paste:
        cmp     ax, WM_PASTE
        jne     ReplaceSel
DoPaste:
        cCall   Paste,<wParam>
        cCall   DisplayCurPos
        jmp     ExitMainCase

;case   EM_REPLACESEL
ReplaceSel:
        cmp     ax, EM_REPLACESEL
        jne     GetLineSel
        cCall   Paste,<wParam>
        cCall   UpdateLine
        jmp     ExitMainCase

;case   EM_GETLINESEL
GetLineSel:
        cmp     ax, EM_GETLINESEL
        jne     GetSel

; Get the current selection (lines)
; wParam points to an array of two words.
; The numbers of the first and the last lines in the selection are stored here.
; Return the number of lines selected.
        lea     ax, [olnFirst]
        lea     bx, [obFirst]
        lea     cx, [olnLast]
        lea     dx, [obLast]
        cCall   BuildSelection,<ax,bx,cx,dx>

        mov     bx, [olnFirst]
        mov     cx, [obLast]
        mov     dx, [olnLast]

        xor     ax,ax
        cmp     bx,dx
        je      yyy2

        dec     dx
        jcxz    yyy1
        inc     dx
yyy1:
        mov     ax,dx
        sub     ax, bx
        inc     ax
        mov     [fOk],ax
yyy2:
        mov     si, [wParam]
        mov     [si], bx
        mov     [si+2], dx
        jmp     ExitMainCase

; case EM_GETSEL
GetSel:
        cmp     ax, EM_GETSEL
        jne     SetSel
        mov     ax,[ipAnchor.ip_ob]
        mov     dx,[ipCur.ip_ob]

        jmp     ExitMainCase

; case EM_SETSEL
DEBPUBLIC SetSel
SetSel:
        cmp     ax, EM_SETSEL
        jne     SelChars
        mov     [wParam],0
        jmp     short StartSel

SelChars:
        cmp     ax, EM_SELCHARS
        jne     DoChar

StartSel:

;; a-emoryh - Don't screw ES_NOSELECT if in QHelp mode
        test    [cmdSwitches],CMD_SW_QHELP
        jnz     QHelpSkip3
        and     [emState], NOT ES_NOSELECT
QHelpSkip3:

        mov     ax,[wParam]
        cmp     ax,[ipCur.ip_oln]
        je      @F
        cCall   UpdateLine
        cCall   NoSelection
        cCall   RefreshLine,<[ipCur.ip_oln]>

; wParm == Line
; HIWORD(lParam) = start column
; LOWORD(lParam) = end column + 1
@@:
        mov     bx, [clnCur]
        mov     ax, [wParam]
        cmp     ax, bx
        jbe     SelChars1
        xchg    ax, bx
SelChars1:
        mov     [ipCur.ip_oln], ax
        mov     [ipAnchor.ip_oln], ax

;
; First make ipAnchor.ob visible.
; then make ipCur.ob visible.
; Note: DisplayCurPos makes ipCur.ob visible, so first set ipCur.ob
;       to what ipAnchor.ob will be, then swap ipCur.ob and ipAnchor.ob
;
        mov     ax, [off_lParam]
        mov     [ipAnchor.ip_ob], ax
        mov     ax, [seg_lParam]
        mov     [ipCur.ip_ob], ax
        cCall   DisplayCurPos
        mov     ax, [ipCur.ip_ob]
        xchg    ax, [ipAnchor.ip_ob]
        xchg    ax, [ipCur.ip_ob]
        cCall   DisplayCurPos

        inc     [fRefreshScreen]
        jmp     ExitMainCase

;case   WM_CHAR
DEBPUBLIC DoChar
DoChar:
        cmp     ax, WM_CHAR
        jne     VScroll

ifdef   KANJI
        cmp     [fCharIsDbcs],0
        jz      CheckCharIsDbcs
        inc     [fCharIsDbcs]
        jmp     SHORT EndCharIsDbcs
CheckCharIsDbcs:
        cCall   FIsDbcsChar,<[wParam]>
        mov     [fCharIsDbcs],al
EndCharIsDbcs:
endif   ; KANJI

        mov     ax,[seg_lParam]
        mov     bx,ax
ifndef  MULTIPLE_ACTION
        test    ax,KK_ALT
        jz      NotMenu
        mov     [fOk],FALSE
        jmp     ExitMainCase
endif   ; !MULTIPLE_ACTION
NotMenu:
        and     ax,KK_SHIFT
        and     bx,KK_CONTROL
        mov     dx,[wParam]

        cmp     dx,VK_MIN
        jae     CHAR_DoKey
        cCall   EditMgrDoChar,<dx,ax>
        jmp     ExitMainCase

CHAR_DoKey:
        cCall   EditMgrDoKey,<dx,ax,bx>
        jmp     ExitMainCase

;case   WM_VSCROLL
VScroll:
        cmp     ax, WM_VSCROLL
        jne     HScroll
;Vertical Scroll case
        ;new case statement on wParam
        mov     ax,[wParam]

;case   SB_LINEUP
VLineUp:
        cmp     ax, SB_LINEUP
        jne     VLineDown
        cCall   ScrollUp
        jmp     ExitVScrollCase

;case   SB_LINEDOWN
VLineDown:
        cmp     ax, SB_LINEDOWN
        jne     VPageUp
        cCall   ScrollDown
        jmp     ExitVScrollCase

;case   SB_PAGEUP
VPageUp:
        cmp     ax, SB_PAGEUP
        jne     VPageDown
        cCall   PageUp
        jmp     ExitVScrollCase


;case   SB_PAGEDOWN
VPageDown:
        cmp     ax, SB_PAGEDOWN
        jne     VThumbPosition
        cCall   PageDown
        jmp     ExitVScrollCase

;case   SB_THUMBPOSITION
VThumbPosition:
        cmp     ax, SB_THUMBPOSITION
        jne     DefaultVScrollCase
        cCall   UpdateLine
        mov     cx, [clnCur]
        mov     ax, word ptr [lParam]
        cmp     cx, ax          ;is new position past end of file?
        ja      @F
        mov     ax, cx
        jcxz    @F
        dec     ax              ;move line position within file range
@@:
        mov     pdCur.pd_olntop,ax
        mov     ipCur.ip_oln,ax
        inc     [fRefreshScreen]
        
ExitVScrollCase:
        mov     fResetAnchor,1
        jmp     ExitMainCase
DefaultVScrollCase:
        jmp     ExitEditMgr     ;Must do this, otherwise we mess up tracking

;End Vertical Scroll inner case

; Line 256
$SC237:
HScroll:
        ;case   WM_HSCROLL
        cmp     ax, WM_HSCROLL
        je      HScroll1
        jmp     LButtonDblClk
HScroll1:               ;out of range!
;New case for Horizonal Scroll
        ;new case statement for (wParam)
        mov     ax,[wParam]

;case   SB_LINEUP
HLineUp:
        cmp     ax, SB_LINEUP
        jne     HLineDown
        mov     ax,1
        cCall   PageLeft,<shiftWidth,ax>
; Line 260
        jmp     ExitHScrollCase

;case   SB_LINEDOWN
HLineDown:
; Line 263
        cmp     ax, SB_LINEDOWN
        jne     HPageUp
        mov     ax,1
        cCall   PageRight,<shiftWidth,ax>
        jmp     ExitHScrollCase

;case   SB_PAGEUP
HPageUp:
        cmp     ax, SB_PAGEUP
        jne     HPageDown
        mov     ax,1
        cCall   PageLeft,<[cColumnsCur],ax>
        jmp     ExitHScrollCase

;case   SB_PAGEDOWN
HPageDown:
        cmp     ax, SB_PAGEDOWN
        jne     HThumbPosition
        mov     ax,1
        cCall   PageRight,<[cColumnsCur],ax>
        jmp     ExitHScrollCase

;case   SB_THUMBPOSITION
HThumbPosition:
        cmp     ax, SB_THUMBPOSITION
        jne     DefaultHScrollCase

        mov     dx,ldCur.ld_cbMax       ;dx = get cbMax (max line size)
        sub     dx,[cColumnsCur]        ;dx = cbMax - cColumns
        mov     ax, word ptr [lParam]   ;lParam (low word) new position
        cmp     ax, dx
        jb      HInRange                ;new col. position out of range?
        mov     ax, dx
HInRange:
        mov     pdCur.pd_obleft,ax
        mov     ipCur.ip_ob,ax
        inc     [fRefreshScreen]

ExitHScrollCase:
        mov     fResetAnchor,1
        jmp     ExitMainCase
DefaultHScrollCase:
        jmp     ExitEditMgr     ;Must do this, otherwise we mess up tracking

;End Horizonal Scroll inner case

;case   WM_LBUTTONDBLCLK
LButtonDblClk:
        cmp     ax, WM_LBUTTONDBLCLK
        jne     LButtonDown
        cCall   GetCurLine
        cCall   obGetFirst      ;ax = ob offset to first non-space char
        
        mov     bx,ipCur.ip_ob  ;bx = column offset for insertion point
        cmp     bx, ax          ;clicking to left of start of line
        jbe     Dbl1            ;ipCur.ob < ob
        cCall   FOnWord         ;if at start of word, no need to move left
        jz      Dbl0
        cCall   FAfterWord
        jz      Dbl2
Dbl0:
        cCall   LeftToWordStart ;if not then move left one word
        jmp     Dbl2            ;   this will adjust ipCur
Dbl1:
        mov     ipCur.ip_ob,ax  ;assume ipCur.ob < ob
Dbl2:
        ;adjust anchor and ipcur to equal i.e. remove text selection
        cCall   ResetAnchor             ;set ipAnchor to ip
        cCall   RightPastWordEnd        ;select word
        mov     ax,ipAnchor.ip_oln      ;
        cmp     ipCur.ip_oln,ax ;was it a multi-line selection?
        je      Dbl3                    ;brif ipCur.oln == ipAnchor.oln
        mov     ipCur.ip_oln,ax
        cCall   GetCurLine
        mov     ax,ldCur.ld_cb          ;ldCur.cb
        mov     ipCur.ip_ob,ax          ;ipCur.ob set ip to end of line
Dbl3:
        cCall   DisplayCurPos
        or      [emState],EF_TRACKING_MOUSE OR EF_WORD_SELECTING OR EF_IN_WINDOW
        cCall   SetCapture,<[pwndEditCur]>
        jmp     ExitMainCase

;case   WM_LBUTTONDOWN
LButtonDown:
        cmp     ax, WM_LBUTTONDOWN
        je      LButtonDown0
        jmp     LButtonUp
LButtonDown0:
        mov     [fGrabFocus],TRUE
;ptMouse.x and ptMouse.y in low word (lParam)
        mov     cx,word ptr [lParam]
        mov     al,cl           ;ptMouse.x in low byte
        cbw
        or      ax,ax           ;Check if negative
        jns     @F              ;If it is
        xor     ax,ax           ; then clear value
@@:
        mov     dx,[cColumnsCur]
        dec     dx
        cmp     ax,dx           ; See if ptMouse.x is out of range
        jna     @F              ; If so
        xchg    ax,dx           ;  then ptMouse.x = cColumnsCur-1
@@:
        mov     [ptMouseX],ax   ;ptMouse.x = rx
        mov     al,ch           ;ptMouse.y in low byte
        cbw
        or      ax,ax           ;Check if negative
        jns     @F              ;If it is
        xor     ax,ax           ; then clear value
@@:
        mov     dx,[cLinesCur]
        dec     dx
        cmp     ax,dx           ; See if ptMouse.y is out of range
        jna     @F              ; If so
        xchg    ax,dx           ;  then ptMouse.y = cLinesCur-1
@@:
        mov     [ptMouseY],ax   ;ptMouse.y = ry

        add     ax,pdCur.pd_olntop      ;ptMouse.y + pdCur.olntop
        mov     bx, ax                  ;save as temp
        mov     ax,ipCur.ip_oln
        cmp     bx,ax                   ;olnT to ipCur.oln
        je      LButtonDown1            ;don't distroy undo unless need be
        push    bx
        cCall   UpdateLine
        pop     bx
        mov     ipCur.ip_oln,bx ;ipCur.oln = ptMouse.y + pdCur.olntop
LButtonDown1:
        mov     ax,[ptMouseX]           ;ptMouse
        add     ax,pdCur.pd_obleft      ;ptMouse.x + pdCur.obleft
        mov     bx, [ldCur.ld_cbMax]
        cmp     ax, bx
        jb      LButtonDown1a
        xchg    ax, bx                  ; really mov ax,bx
        dec     ax
LButtonDown1a:
        mov     ipCur.ip_ob,ax          ;ipCur.ob
        mov     cx,ax                   ; save for later
        mov     ax, [clnCur]
        or      ax,ax
        jz      LButtonDown1c
        cmp     ax,ipCur.ip_oln ;check if of end of file
        ja      LButtonDown2            ;brif (file size) >= ipCur.oln
        jne     LButtonDown1b
        jcxz    LButtonDown1c
LButtonDown1b:
        dec     ax
LButtonDown1c:
        mov     ipCur.ip_oln,ax ;set to bottom of file is so
LButtonDown2:
        mov     al,0                    ;prepare fResetAnchor=!(wParam&MK_SHIFT)
        test    byte ptr [wParam],MK_SHIFT;wParam test if shift key down
        jne     LButtonDown3
        mov     al,1
LButtonDown3:
        mov     fResetAnchor,al
        mov     al,[emState]
        or      al,EF_IN_WINDOW OR EF_TRACKING_MOUSE
        and     al,NOT EF_WORD_SELECTING
        mov     [emState],al
        cCall   SetCapture,<[pwndEditCur]>
        jmp     ExitMainCase

;case   WM_LBUTTONUP
LButtonUp:
        cmp     ax, WM_LBUTTONUP
        jne     MouseMove

DoLButtonUp:
        mov     al,[emState]
        test    al,EF_TRACKING_MOUSE
        jz      LButtonUp1
        and     al,NOT EF_TRACKING_MOUSE
        mov     [emState],al
        cCall   ReleaseCapture
LButtonUp1:
        jmp     ExitMainCase

;case   WM_ALARM
;case   WM_MOUSEMOVE
MouseMove:
        cmp     ax, WM_MOUSEMOVE
        je      MouseMove1
        cmp     ax, WM_ALARM
        je      MouseMove1      
        jmp     CheckGetWord
MouseMove1:
        xor     bx,bx
        xor     dx,dx
;ptMouse.x and ptMouse.y in low word (lParam)
        mov     cx,word ptr [lParam]
        mov     al,cl           ;ptMouse.x in low byte
        cbw
        xchg    dx,ax
        mov     [ptMouseX],dx   ;ptMouse.x = rx
        mov     al,ch           ;ptMouse.y in low byte
        cbw
        xchg    bx,ax
        mov     [ptMouseY],bx   ;ptMouse.y = ry

        ;fInWindow= (ptMouse.x>=0 && ptMouse.x<pwnd->cColumns
        ;&& ptMouse.y>=0 && ptMouse.y < pwnd->cLines)
        ;set flag if mouse motion within window
        ;dx = ptMouse.x, bx = ptMouse.y
        mov     al,[emState]
        mov     cx,[cColumnsCur];cx = pwnd->cColumns
        cmp     dx, 0           ;
        jl      OutOfWindow     ;brif ptMouse.x < 0
        cmp     dx, cx
        jge     OutOfWindow     ;brif ptMouse.x > pwnd->cColumns
        mov     cx, [cLinesCur] ;cx = pwnd->cLines
        cmp     bx, 0
        jl      OutOfWindow     ;brif ptMouse.y < 0
        cmp     bx, cx
        jge     OutOfWindow     ;brif ptMouse.y >= pwnd->cColumns
        or      al,EF_IN_WINDOW
        jmp     InWindow
OutOfWindow:
        and     al,NOT EF_IN_WINDOW
InWindow:
        mov     [emState],al
        test    al,EF_TRACKING_MOUSE
        jnz     InWindow1
        mov     [fOk],False
        jmp     ExitEditMgr     ;brif if not tracking
InWindow1:
        test    [wParam], MK_LBUTTON
        jz      DoLButtonUp
        test    al,EF_IN_WINDOW
        jz      MouseMove9      ;brif if not in window

        ;we are both tracking and within window boundaries
        ;update insertion line position
        ;bx = ptMouse.y from above

        add     bx,pdCur.pd_olntop
        mov     ipCur.ip_oln,bx ;ipCur.oln = pdCur.oln + ptMouse.y
        mov     ax,[ptMouseX]           ;ptMouse.x
        add     ax,pdCur.pd_obleft
        mov     ipCur.ip_ob,ax          ;ipCur.ob = pdCur.obleft + ptMouse.x
        mov     cx,ax

        mov     ax, [clnCur]
        or      ax,ax
        jz      MM_3b
        cmp     ax,ipCur.ip_oln ;is new insertion point off file?
        ja      MouseMove4
        jne     MM_3a
        jcxz    MM_3b
MM_3a:
        dec     ax
MM_3b:
        mov     ipCur.ip_oln,ax
MouseMove4:
        test    [emState],EF_WORD_SELECTING
        jz      MouseMove8              ;brif not selecting a word
        cCall   GetCurLine
        cCall   FOnWord
        jz      MouseMove8

        mov     ax, [ipCur.ip_ob]
        cmp     ax, [ipAnchor.ip_ob]
        je      MouseMove8
        jb      MouseMove5

        cCall   RightPastWordEnd
        jmp     short MouseMove8

MouseMove5:
        cCall   FAfterWord
        jz      MouseMove8

        cCall   LeftToWordStart

MouseMove8:
        cCall   DisplayCurPos
        jmp     ExitMainCase

MouseMove9:
        ;check for scrolling
        cmp     [ptMouseX],0
        jge     NoLeftScroll            ;brif ptMouse.x is not at left border
        mov     ax,1                    ;scroll to left
        cCall   PageLeft,<shiftWidth,ax>
        jmp     CheckAlarm
NoLeftScroll:
        ;check for right border scroll
        mov     ax,[ptMouseX]
        cmp     [cColumnsCur],ax
        ja      NoRightScroll   ;brif ptMouse.x is not to right border
        mov     ax,1
        cCall   PageRight,<shiftWidth,ax>
        jmp     CheckAlarm
NoRightScroll:
        cmp     [ptMouseY],0
        jge     NoUpScroll
        ;now check for top/bottom of window scroll
        cCall   LineUp
        jmp     CheckAlarm
NoUpScroll:
        mov     ax,[ptMouseY]
        cmp     [cLinesCur],ax
        ja      CheckAlarm
        cCall   LineDown
CheckAlarm:
        mov     ax,2
        cCall   SetAlarm,<[pwnd],ax>
; Line 385
        jmp     ExitMainCase

; case EM_GETWORD
CheckGetWord:
        cmp     ax, EM_GETWORD
        jne     NoMsgMatch

        push    word ptr [lParam+2]
        push    word ptr [lParam]
        push    [wParam]
        cCall   EMGetWord
        mov     [fOk],ax
        jmp     ExitEditMgr

NoMsgMatch:
        mov     [fOk],FALSE

ExitMainCase:

        ;end of EditMgr

ExitMainCase1:
        cmp     fResetAnchor,0
        je      $I284

        ;reset insertion point for no selection
        cCall   ResetAnchor             ;set Anchor to ip (remove sel.)
$I284:
        cCall   HiliteSelection
ExitMainCase2:
        cmp     fRefreshScreen,0
        je      $I286
        cCall   RefreshScreen
$I286:
        test    [emState], ES_NOREDRAW
        jz      @F
J_DoneRedraw:
        jmp     DoneRedraw
@@:
        cCall   GetFocus
        cmp     ax,[pwndEditCur]
        jne     J_DoneRedraw
        ;In case cursor has been moved reset to correct position
ifdef   KANJI
        cCall   DbcsAdjCursor
else    ; !KANJI
        mov     ax,[ipCur.ip_ob]
endif   ; KANJI
        sub     ax,[pdCur.pd_obleft]
        mov     cx,[ipCur.ip_oln]
        sub     cx,[pdCur.pd_olntop]
        cCall   MoveCursor,<[pwndEditCur],ax,cx>

        sub     di,di
        mov     si,pefCur
        cmp     [si].ef_pwndScrollV,di  ;Do scroll if neccessary
        je      AdjustHorizontalScroll

        mov     ax,[clnCur]
        or      ax,ax
        jnz     @F
        inc     ax
@@:
        cCall   SetScrollRange,<[si].ef_pwndScrollV, di, ax, di>
        mov     dx,[ipCur.ip_oln]
        cmp     dx,[clnCur]
        ja      AdjustHorizontalScroll
        mov     ax,1
        cCall   SetScrollPos,<[si].ef_pwndScrollV, dx, ax>

AdjustHorizontalScroll:
        cmp     [si].ef_pwndScrollH,di  ;Do scroll if necessary
        je      DoneRedraw

        mov     ax,[ldCur.ld_cbmax]
        sub     ax,[cColumnsCur]
        jbe     DoneRedraw
        cCall   SetScrollRange,<[si].ef_pwndScrollH, di, ax, di>
        mov     ax,1
        cCall   SetScrollPos,<[si].ef_pwndScrollH, [pdCur.pd_obleft], ax>

DoneRedraw:
        mov     bx,[pefCur]
        mov     al,[emState]
        mov     [bx].EF_Style,al

        mov     bx,ldCur.ld_cb
        mov     si,ldCur.ld_prgch
        mov     BYTE PTR [bx][si],0
        ; Reset values for edit field
        mov     bx,[pefCur]
        mov     ax,hBuffer
        mov     [bx].EF_hBuffer,ax
        mov     ax,ipCur.ip_ob
        mov     dx,ipCur.ip_oln
        mov     [bx].EF_ipCur.ip_ob,ax
        mov     [bx].EF_ipCur.ip_oln,dx
        mov     ax,ipAnchor.ip_ob
        mov     dx,ipAnchor.ip_oln
        mov     [bx].EF_ipAnchor.ip_ob,ax
        mov     [bx].EF_ipAnchor.ip_oln,dx
        mov     di,[bx].EF_pldCur
        mov     si,OFFSET DGROUP:ldCur
        push    ds
        pop     es
        movsw
        movsw
        movsw
        movsb
        lea     di,[bx].EF_pdCur
        mov     si,OFFSET DGROUP:pdCur.pd_olntop
        push    ds
        pop     es
        movsw
        movsw
        movsw
;
; See if the cursor has moved.
;
        mov     ax,[ipCur.IP_oln]
        cmp     ax,[ipStart.IP_oln]
        jne     NotifyCursorMoved
        mov     ax,[ipCur.IP_ob]
        cmp     ax,[ipStart.IP_ob]
        je      NoCursorMove
NotifyCursorMoved:
        mov     bx, [pwndEditCur]
        mov     ax, [bx].pwndParent
        or      ax,ax
        jz      NoCursorMove
        push    ax
        mov     ax, WM_COMMAND
        push    ax
        mov     ax, EN_CURSORMOVED
        push    ax
        mov     ax, [bx].idWnd
        push    ax
        push    bx
        cCall   SendMessage
NoCursorMove:

ExitEditMgr:
        and     [emFlags],NOT EMF_IN_EDITMGR
;
; See if we want the focus
;
        test    [fGrabFocus],0ffH
        jz      NoGrabFocus
        cCall   SetFocus,<pwnd>
NoGrabFocus:
QuickExitEditMgr:
        mov     ax,[fOk]
        xor     dx,dx
cEnd

cProc EMRefreshCache,<NEAR>,<SI>
cBegin
        mov     si, [pefCur]
        mov     ax, [si].EF_hBuffer
        mov     [hBuffer], ax
        cCall   LinesInBuf,<ax>
        mov     [clnCur], ax
        mov     bx, [si].ef_pldCur
        mov     ax, [bx].ld_cbMax
        mov     [ldCur.ld_cbMax], ax
        mov     ax, [bx].ld_prgch
        mov     [ldCur.ld_prgch], ax
cEnd

ifdef   EDIT_USE_TABLES

EDITFUNCTION    macro   a
iFn&a   dw      User_EditOFFSET a
        endm

MainEditTable   macro   name
        db      (iFn&name - EditIndexTable)
        endm

SecondEditTable macro   ch,name
        dw      ch
        db      (iFn&name - EditIndexTable)
        endm

KeyTableEntry   macro   key,name
        dw      key
        db      (iFn&name - EditIndexTable)
        endm
else    ; ! EDIT_USE_TABLES

EDITFUNCTION    macro   a
        endm

MainEditTable   macro   name
        dw      User_EditOFFSET name
        endm

SecondEditTable macro   ch,name
        db      ch
        dw      User_EditOFFSET name
        endm

KeyTableEntry   macro   key,name
        dw      key, User_EditOFFSET name
        endm
endif   ; EDIT_USE_TABLES

include editfuns.inc

ifdef   EDIT_USE_TABLES
sEnd    USER_EDIT

sBegin  DATA
LabelW  pEditTbls
pCharTable      dw      dataOFFSET DoCharDispatch
pPrefixTable    dw      dataOFFSET PrefixTable
pVkTable        dw      0
pVkCtrlTable    dw      0

StaticB DoCharDispatch,0,33             ;* Control characters + DEL
StaticW PrefixTable,0,32                ;* Control characters only
StaticW pDoVkDispatch,0                 ;* Pointer to VkDispatch Table

GlobalB SzActionPrim,0,20               ;* Name of action key
GlobalB SzCancelPrim,0,20               ;* Name of cancel key

externW vkActionPrim
externW vkActionSec
externW vkCancelPrim
externW vkCancelSec

sEnd    DATA

externFP PpvAllocCb                     ;* Local memory manager - (used incorrectly)

sBegin  INIT
        assumes CS,INIT
endif   ; EDIT_USE_TABLES

include edittbls.inc

ifdef   EDIT_USE_TABLES
LabelW  pDefaultEditTbls
        dw      initOFFSET KeyDispatch, (CtrlKeyDispatch - KeyDispatch)
        dw      initOFFSET CtrlKeyDispatch, (pDefaultEditTbls - CtrlKeyDispatch)
        dw      initOFFSET CtrlQDispatch, (CtrlKDispatch - CtrlQDispatch)
        dw      initOFFSET CtrlKDispatch, (KeyDispatch - CtrlKDispatch)
        dw      0,0

include editinit.asm

sEnd    INIT

sBegin  USER_EDIT
        assumes CS,User_Edit
endif   ; EDIT_USE_TABLES

cProc EditMgrDoChar,<NEAR,PUBLIC>
        parmW   wParam
        parmW   fShift
cBegin
        mov     ax,[wParam]             ;wParam, ax = character code
        mov     dx,[fShift]             ;* If shift is not down then we
        or      dx,dx                   ;*     need to reset the anchor
        jnz     EMDC_NoResetAnchor      ;*     when we finish this character
        mov     [fResetAnchor],TRUE
EMDC_NoResetAnchor:
ifdef   EDIT_USE_TABLES
else    ; !EDIT_USE_TABLES
        cmp     al, ''                 ;* Hardcoded edit command -- Reset
        je      EMDC_ResetState
endif   ; EDIT_USE_TABLES
        jmp     [EditMgrDoCharState]    ;* Jump to controller for this state

EMDC_InitialState:
ifdef   EDIT_USE_TABLES
        cmp     al, ''                 ;* Hard coded edit command --- DEL
        je      DoDel
        cmp     ax,' '                  ;* Is character >= space?
        jae     DefaultEditMgrDoChar    ;* Yes -- do the default action
        mov     bx,ax                   ;* No -- look up and do the
DoDel2:
        add     bx,pEditTbls[0]         ;* Add offset of Table
        mov     bl,[bx]                 ;* Load the function index
        xor     bh,bh                   ;* Clear high end
        call    EditIndexTable[bx]      ;* for this character
        jmp     ExitEditMgrDoChar

DoDel:
        mov     bx,32                   ;* Last entry in table
        jmp     short   DoDel2          ;* Normal dispatch now

else    ; ! EDIT_USE_TABLES
        cmp     al, ''                 ;* Hard coded edit command --- DEL
        je      Do_DelRight
        cmp     al, ''                 ;* Hard coded edit command --- ESC
        je      DoEsc
        cmp     ax,'Z' - 'A' + 1
        ja      DefaultEditMgrDoChar
        mov     bx,ax
        add     bx,bx
        call    WORD PTR cs:DoCharDispatch[bx]
        jmp     ExitEditMgrDoChar
endif   ; EDIT_USE_TABLES

ifdef   EDIT_USE_TABLES

EMDC_SecondState:
        mov     bx, SecondDispatch
        cCall   DispatchAX
        jmp     short EMDC_ResetState
        

QuoteCharacter:
else    ; !EDIT_USE_TABLES

EMDC_CtrlQState:
        cmp     al, '0'
        jb      EMDC_DispatchCtrlQ
        cmp     al, '3'
        ja      EMDC_DispatchCtrlQ

        cCall   GotoBookmark
        jmp     short EMDC_ResetState

EMDC_DispatchCtrlQ:
        mov     bx, User_EditOFFSET CtrlQDispatch
        cCall   DispatchAL
        jmp     short EMDC_ResetState

EMDC_CtrlKState:
        cmp     al, '0'
        jb      EMDC_ResetState
        cmp     al, '3'
        ja      EMDC_ResetState
        cCall   SetBookmark
        jmp     short EMDC_ResetState


EMDC_CtrlPState:
endif   ; EDIT_USE_TABLES
        cmp     al, 0dH                 ; Carriage return?
        je      EMDC_Beep
        cmp     al, 0aH                 ; Line Feed?
        je      EMDC_Beep
        or      al,al                   ; Null?
        je      EMDC_Beep

DefaultEditMgrDoChar:
        cCall   InsertKey,<wParam>
ifndef  EDIT_USE_TABLES
DoEsc:
endif   ; EDIT_USE_TABLES
        mov     fResetAnchor,1
        jmp     short EMDC_ResetState

EMDC_Beep:
        cCall   NearBeep
        jmp     short EMDC_ResetState

ifndef  EDIT_USE_TABLES
Do_DelRight:
        cCall   Del
endif   ; EDIT_USE_TABLES

EMDC_ResetState:
        cCall   SetEMDC_InitialState

ExitEditMgrDoChar:
cEnd

ifdef   EDIT_USE_TABLES

cProc   ResetState,<NEAR>
cBegin
        cCall   SetEMDC_InitialState
cEnd


cProc   DoEsc,<NEAR>
cBegin
        mov     fResetAnchor,1
        cCall   SetEMDC_InitialState
cEnd

cProc   DoQuoteCharacter,<NEAR>
cBegin
        mov     ax,User_EditOFFSET QuoteCharacter ;* Routine to use on next
        mov     [EditMgrDoCharState],ax         ;* character when recieved
cEnd

cProc   DoPrefixTable,<NEAR>
cBegin
        mov     [chEditMgrState], al            ;* Setup status line display
        mov     bx,ax                           ;* Move into an index register
        shl     bx,1                            ;* Convert to byte offset
        add     bx,pPrefixTable                 ;* .. From the beginning of table
        mov     ax,[bx]                         ;* Load next dispatch table
        mov     [SecondDispatch],ax             ;* And save it away
        mov     ax,User_EditOFFSET EMDC_SecondState ;* Secondary dispatch routine
        mov     [EditMgrDoCharState],ax         ;*
        cCall   DrawToggles                     ;* Update status line
cEnd

cProc   DoVkPrefixTable,<NEAR>
cBegin
        mov     bx,pDoVkDispatch                ;* Set of dispatch tables
@@:     
        cmp     word ptr [bx],0                 ;* End of table?
        je      DVPT_01                         ;* Yes - Fail

        cmp     ax,[bx]                         ;* Match?
        je      @F                              ;* Yes dispatch routine
        add     bx,4                            ;* Move to next table entry
        jmp     short @B

@@:
        mov     [chEditMgrState], al            ;* Setup status line display
        mov     ax,[bx]                         ;* Get Table Pointer
        mov     [SecondDispatch],ax             ;* Load next dispatch table
        mov     ax,User_EditOFFSET EMDC_SecondState ;* Secondary dispatch routine
        mov     [EditMgrDoCharState],ax         ;*
        cCall   DrawToggles                     ;* Update status line
DVPT_02:
cEnd

DVPT_01:
        cCall   NearBeep                        ;* Complain
        jmp     short DVPT_02                   ;*

else    ; !EDIT_USE_TABLES
cProc CtrlPState,<NEAR>
cBegin
ifndef  KANJI
        mov     [chEditMgrState], al            ;* Setup status line display
        mov     ax,User_EditOFFSET EMDC_CtrlPState  ;* Secondary dispatch routine
        mov     [EditMgrDoCharState],ax         ;*
        cCall   DrawToggles                     ;* Update status line
endif   ; !KANJI
cEnd

cProc CtrlKState,<NEAR>
cBegin
        mov     [chEditMgrState], al
        mov     ax, User_EditOFFSET EMDC_CtrlKState
        mov     [EditMgrDoCharState], ax
        cCall   DrawToggles
cEnd

cProc CtrlQState,<NEAR>
cBegin
        mov     [chEditMgrState], al
        mov     ax, User_EditOFFSET EMDC_CtrlQState
        mov     [EditMgrDoCharState], ax
        cCall   DrawToggles
        mov     [fResetAnchor], 0
cEnd

endif   ; EDIT_USE_TABLES

cProc GetEditMgrState,<FAR,PUBLIC>
cBegin
        mov     al, [chEditMgrState]
        xor     ah,ah
cEnd

cProc IgnoreChar,<NEAR>
cBegin
        mov     fResetAnchor,0
        cCall   SetEMDC_InitialState
cEnd

cProc SetEMDC_InitialState,<NEAR>
cBegin

        xor     al,al
        mov     [chEditMgrState], al
        mov     ax, User_EditOFFSET EMDC_InitialState
        mov     [EditMgrDoCharState], ax
        cCall   DrawToggles
cEnd

cProc DispatchFind,<NEAR>
cBegin
        mov     cx, WM_SEARCHFIND
        jmp     short SendParentMsg
cEnd <NOGEN>

cProc DispatchChange,<NEAR>
cBegin
        mov     cx, WM_SEARCHCHANGE

SendParentMsg:
        xor     ax,ax

SendParentMsgWithWParam:
        xor     dx,dx
        mov     bx, [pwndEditCur]
        cCall   PostMessage,<[bx.pwndParent], cx, ax, dx, dx>
        mov     [fResetAnchor], 0
cEnd


;*******************************************************************************
;SetBookmark - Set bookmark to current cursor position
;
;Purpose:
;Entry:
;       AL - Which bookmark to set
;            Ascii number '0' through '3'
;Exit:
;Uses:
;Exceptions:
;*******************************************************************************

ifdef   EDIT_USE_TABLES
SetBookmark0:
        mov     al,'0'
        jmp     short SetBookmark

SetBookmark1:
        mov     al,'1'
        jmp     short SetBookmark

SetBookmark2:
        mov     al,'2'
        jmp     short SetBookmark

SetBookmark3:
        mov     al,'3'
;       jmp     short SetBookmark
endif   ; EDIT_USE_TABLES

cProc SetBookmark,<NEAR>
cBegin
        mov     cx, WM_SETBOOKMARK
        xor     ah,ah
        jmp     short SendParentMsgWithWParam
cEnd <NOGEN>

;*******************************************************************************
;GotoBookmark - Moves cursor to previously set bookmark
;
;Purpose:
;Entry:
;       AL - Which bookmark to goto
;            Ascii number '0' through '3'
;Exit:
;Uses:
;Exceptions:
;*******************************************************************************

ifdef   EDIT_USE_TABLES
GotoBookmark0:
        mov     al,'0'
        jmp     short GotoBookmark

GotoBookmark1:
        mov     al,'1'
        jmp     short GotoBookmark

GotoBookmark2:
        mov     al,'2'
        jmp     short GotoBookmark

GotoBookmark3:
        mov     al,'3'
;       jmp     short GotoBookmark
endif   ; EDIT_USE_TABLES

cProc GotoBookmark,<NEAR>
cBegin
        mov     cx, WM_GOTOBOOKMARK
        xor     ah,ah
        jmp     short SendParentMsgWithWParam
cEnd <NOGEN>

ifdef   EDIT_USE_TABLES
;*******************************************************************************
;SearchNext - Send a WM_SEARCHNEXT message to the parent window to continue
;       a search previously started
;
;ENTRY
;Exit:
;Uses:
;Exceptions:
;*******************************************************************************

cProc   SearchNext,<NEAR>
cBegin
        mov     cx,WM_SEARCHNEXT
        xor     ax,ax
        jmp     short SendParentMsgWithWParam
cEnd

;*******************************************************************************
;MatchBrace - Send a WM_MATCHBRACE message to the parent window
;
;ENTRY
;Exit:
;Uses:
;Exceptions:
;*******************************************************************************

cProc   MatchBrace,<NEAR>
cBegin
        mov     cx,WM_MATCHBRACE
        xor     ax,ax
        jmp     short SendParentMsgWithWParam
cEnd
endif   ; EDIT_USE_TABLES

;*******************************************************************************
;DispatchAX - Dispatch to a routine based on AX and table.
;
;Purpose:
;Entry:
;       AX - Value to dispatch on
;       DS:BX - points to table
;            Table is word pairs (match, routine)
;       All other registers are passed to the routine unchanged.
;Exit:
;Uses:
;Exceptions:
;*******************************************************************************
cProc DispatchAX,<NEAR,PUBLIC>
cBegin
TD_1:
ifdef   EDIT_USE_TABLES
        cmp     word ptr [bx],0                 ; End of table?
        je      TD_2                            ; Yes - Dispatch default routine

        cmp     ax, [bx]                        ; Match?
        je      TD_2                            ; Yes - Dispatch routine.

        add     bx, 3                           ; Move to next table entry
        jmp     short TD_1
else    ; !EDIT_USE_TABLES
        cmp     word ptr cs:[bx],0              ; End of table?
        je      TD_2                            ; Yes - Dispatch default routine

        cmp     ax, cs:[bx]                     ; Match?
        je      TD_2                            ; Yes - Dispatch routine.
        add     bx, 4                           ; Move to next table entry
        jmp     short TD_1
endif   ; EDIT_USE_TABLES

TD_2:
ifdef   EDIT_USE_TABLES
        mov     bl,BYTE PTR [bx+2]              ;* Get Function Index
        xor     bh,bh                           ;* Clear hi byte
        call    EditIndexTable[bx]              ;* Call function
else    ; !EDIT_USE_TABLES
        call    cs:[bx+2]
endif   ; EDIT_USE_TABLES
cEnd

ifndef  EDIT_USE_TABLES
;*******************************************************************************
;DispatchAL - Dispatch to a routine based on AL and table.
;
;Purpose:
;Entry:
;       AL - Value to dispatch on
;       CS:BX - points to table
;            Table is word pairs (match, routine)
;       All other registers are passed to the routine unchanged.
;Exit:
;Uses:
;Exceptions:
;*******************************************************************************
cProc DispatchAL,<NEAR,PUBLIC>
cBegin
DAL_1:
        cmp     byte ptr cs:[bx],0              ; End of table?
        je      DAL_2                           ; Yes - Dispatch default routine

        cmp     al, cs:[bx]                     ; Match?
        je      DAL_2                           ; Yes - Dispatch routine.

        add     bx, 3                           ; Move to next table entry
        jmp     short DAL_1

DAL_2:
        call    cs:[bx+1]
cEnd
endif   ; !EDIT_USE_TABLES

cProc EditMgrDoKey,<NEAR,PUBLIC>
        parmW   wParam
        parmW   fShift
        parmW   fCtrlKey

cBegin
        mov     dx,[fShift]
        or      dx,dx
        jnz     DoKeyNoResetAnchor
        mov     [fResetAnchor],TRUE
DoKeyNoResetAnchor:

ifdef   EDIT_USE_TABLES
        mov     bx, 0                           ; Assume Ctrl not down
        cmp     [fCtrlKey],0
        je      DoKeyNoCtrl                     ;brif control key is not down
        add     bx, 2                           ;If Control Key down!

DoKeyNoCtrl:
        mov     bx,pVkTable[bx]
else    ; !EDIT_USE_TABLES
        mov     bx, User_EditOFFSET KeyDispatch ; Assume Ctrl not down
        cmp     [fCtrlKey],0
        je      DoKeyDispatch                   ;brif control key is not down

        mov     bx, User_EditOFFSET CtrlKeyDispatch ;If Control Key down!

DoKeyDispatch:
endif   ; EDIT_USE_TABLES

        push    bx                              ;?????
        mov     cx, [cColumnsCur]
        pop     bx                              ;?????
        mov     ax, [wParam]
        cCall   DispatchAX

ExitEditMgrDoKey:
cEnd

cProc IgnoreKey,<NEAR>
cBegin
        mov     [fResetAnchor], 0
        mov     [fOk],FALSE
cEnd

cProc FullPageLeft,<NEAR>
cBegin
        mov     ax, 1
        cCall   PageLeft,<cx,ax>
cEnd

cProc FullPageRight,<NEAR>
cBegin
        mov     ax, 1
        cCall   PageRight,<cx,ax>
cEnd


;*******************************************************************************
;_HiliteSelection
;
;Purpose:
;       The current selection region defined by the delta for ipCur and
;       ipAnchor is rewritten to reflect and changes since entering the
;       EditMgr. The initial setting is in ipCurStart and ipAnchorStart.
;Entry:
;       ipCur - Current insertion point
;       ipAnchor - End of selection region if any
;       pefCur.ef_fSelection - flag if selection is know to be active
;       ?? under what conditions can this be false a selection is present
;Exit:
;       pefCur.ef_fSelection set to selection state.
;Uses:
;       cl - fSelection - selection flag at start of call
;       ax, dx, cx
;Exceptions:
;       none
;       
;*******************************************************************************
cProc HiliteSelection,<NEAR,PUBLIC>
cBegin
        mov     bx,pefCur
        mov     cl,[bx.ef_fSelection]

        mov     ax, ipCur.ip_oln        ;check for any current selection
        mov     dx, ipCur.ip_ob
        xor     ax, ipAnchor.ip_oln
        xor     dx, ipAnchor.ip_ob
        or      ax, dx
        or      al, ah

;al = state of current selection (ef_fSelection)
;bx = pefCur
;cl = state of selection to start with
        mov     [bx.ef_fSelection],al   ;note state of selection
        or      al, cl
        jz      Hilite16                ; There was no selection, and there
                                        ; is no selection so do nothing

;Here if either fWasSelection or current have a selection
Hilite8:
        ;Check if our current position has moved from the starting position
        mov     ax, ipStart.ip_oln
        mov     cx, ipCur.ip_ob

        cmp     ipCur.ip_oln, ax
        jne     Hilite10                ;brif move off of starting line

        cmp     ipStart.ip_ob, cx
        je      Hilite12                ;brif have not moved off start offset

;Here if current position is not the same as the starting position
Hilite10:
        cCall   RefreshLines,<ax,ipCur.ip_oln>

;Here if have selection but the start and current points were equal
Hilite12:
        mov     ax, ipAnchorStart.ip_oln
        mov     cx, ipAnchor.ip_ob

        cmp     ipAnchor.ip_oln,ax
        jne     Hilite14                        ;brif Anchor has moved

        cmp     ipAnchorStart.ip_ob, cx
        je      Hilite16                        ;brif Anchor has not moved

;Here if Anchor has moved from it's starting position
Hilite14:
        cCall   RefreshSelection

Hilite16:
cEnd

cProc RefreshSelection,<NEAR,PUBLIC>
cBegin
        cCall   RefreshLines,<[ipAnchorStart.ip_oln],[ipStart.ip_oln]>
cEnd

;*******************************************************************************
;_NoSelection
;
;Purpose:
;    Removes any selection present on screen and resets ipAnchor to ipCu
;Entry:
;       ipCur
;       ipAnchor
;Exit:
;       ipAnchor set to ipCur
;Uses:
;       none.
;Exceptions:
;       none
;*******************************************************************************
cProc NoSelection,<NEAR,PUBLIC>
cBegin
        cCall   ResetAnchor
        cCall   HiliteSelection
cEnd

;*******************************************************************************
;_BuildSelection
;
;Purpose:
;       Takes the current selection region defined by ipAnchor and ipCur and
;       returns an ordered pair of positions (ob, oln) that defines the
;       current selected region.
;Entry:
;       Parameters
;       polnFirst - pointer to lowest oln for selected region
;       pobFirst  - pointer to left most ob for selected region
;       polnLast  - pointer to highest oln
;       pobLast   - pointer to right most ob
;
;       register di = polnLast
;       register si = polnFirst
;
;Exit:
;       
;Uses:
;      ax, bx, cx, dx, si, di
;Exceptions:
;       none
;*******************************************************************************
cProc BuildSelection,<NEAR,PUBLIC>,<SI,DI>
        parmDP  polnFirst
        parmDP  pobFirst
        parmDP  polnLast
        parmDP  pobLast
cBegin

        ;assume multi-line selection
        mov     ax,[ipCur.ip_oln]
        mov     bx,[ipCur.ip_ob]
        mov     cx,[ipAnchor.ip_oln]
        mov     dx,[ipAnchor.ip_ob]
        cmp     ax, cx                  ;check if multiline
        jne     BuildSel10

;Single line case
        cmp     bx, dx
        jb      BuildAssign             ;brif ip < anchor
        xchg    bx, dx                  ;reverse ob's
        jmp     SHORT BuildAssign

;Here for multi-line case (ip.oln <> anchor.oln)
BuildSel10:
        cmp     ax, cx
        jb      BuildAssign             ;brif ip < anchor
        xchg    ax, cx
        xchg    bx, dx

BuildAssign:
        mov     si,[pobFirst]
        mov     di,[pobLast]
        mov     [si],bx
        mov     [di],dx
        mov     si,[polnFirst]
        mov     di,[polnLast]
        mov     [si],ax
        mov     [di],cx

;Check that selection is not off end of file
        mov     ax, [clnCur]            ;ax = last line number in file
        mov     bx, [si]                ;bx = olnFirst
        mov     cx, [di]                ;cx = olnLast
        cmp     bx, ax
        jbe     BuildSel20              ;brif first <= end of file
        mov     [si], ax                ;set first to end of file

BuildSel20:
        cmp     cx, ax
        jbe     BuildSel22              ;brif last <= end of file
        mov     [di], ax

BuildSel22:
        xor     dx, dx
        cmp     cx, ax  
        jne     BuildSel24              ;brif last <> end of file
        mov     di, [pobFirst]
        mov     [di], dx                ;at bottom make start of sel. at 0

BuildSel24:
        cmp     bx, ax
        jne     BuildSel26              ;brif first <> end of file
        mov     si, [pobLast]
        mov     [si], dx

BuildSel26:

cEnd

;*******************************************************************************
;fCheckReadOnly
;
;Purpose:
; Check if the buffer is read only, and sound alarm if it is
;Entry:
;Exit:
; Returns TRUE if the buffer is read only.
;Uses:
;Exceptions:
;
;*******************************************************************************
cProc fCheckReadOnly,<NEAR,PUBLIC>
cBegin
        xor     ax,ax
        test    [emState], ES_MULTILINE
        jz      ExitCheckRO                             ; return FALSE

        cCall   fReadOnlyBuf,<[hBuffer]>
        or      ax,ax
        jz      ExitCheckRO                             ; return FALSE
        push    ax
        cCall   NearBeep
        pop     ax
ExitCheckRO:
        or      ax,ax
cEnd

;*******************************************************************************
;_ModifyLine
;
;Purpose:
;       Fetch the current line at ipCur.oln into the line descripter ldCur.
;       Mark the line in ldCur as dirty. This will cause UpdateLine
;       to replace the line in the buffer when called.
;Entry:
;       ldCur
;Exit:
;       ldCur.ld_fDirty - set to TRUE
;Uses:
;       none.
;Exceptions:
;
;*******************************************************************************

cProc ModifyLine,<NEAR,PUBLIC>
cBegin
        cCall   GetCurLine
        cCall   fCheckReadOnly
        jz      DoModifyLine
        xor     ax,ax
        jmp     SHORT ExitModifyLine
DoModifyLine:
        or      [ldCur.ld_flags],LD_fDirty
        inc     ax
ExitModifyLine:
cEnd

;*******************************************************************************
;cbGetLine
;
;Purpose:
;  Same as cbGetLineBuf followed by EMRefreshCache
;Entry:
;Exit:
;Uses:
;Exceptions:
;*******************************************************************************
cProc cbGetLine,<NEAR,PUBLIC>
        parmW   oln
        parmW   cbMax
        parmDP  prgch
cBegin
        cCall   cbGetLineBuf,<[hBuffer], [oln], [cbMax], [prgch]>
        push    ax                      ; save return value
        cCall   EMRefreshCache
        pop     ax                      ; restore return value
cEnd

;*******************************************************************************
;_GetLine
;
;Purpose:
;       Get the specified line offset (ipCur.oln) into ldCur. If it is already
;       in ldCur then do nothing. If in multi-line mode then don't get anything
;Entry:
;       fMultiline - flag if in multi-line or single-line mode
;       pdCur.oln - line offset currently in ldCur
;       pefCur.ef_fFocus - flag if edit field has focus
;       hBuffer - handle to source buffer
;Exit:
;       ldCur
;Uses:
;       oln - line offset to fetch
;       register si - oln
;       bx
;Exceptions:
;       none
;*******************************************************************************
cProc   GetLine,<NEAR,PUBLIC>,<SI>
        parmW   oln
cBegin
        mov     si,[oln]                ;oln
        test    [emState], ES_MULTILINE ;If not multi-line nothing to get
        jz      $I405                   ;brif not multi-line

        mov     ax,si                   ;si - oln (line to get)
        cmp     ax,pdCur.pd_oln         ;check line already in ldCur
        jne     $I406                   ;brif if line no current line

        cCall   GetFocus                ; Current Focus in ax
        cmp     ax,[pwndEditCur]
        je      $I405                   ;brif we do have focus

$I406:
        cCall   UpdateLine              ;make sure current line is back is src.
        mov     ax, [clnCur]
        cmp     ax,si                   ;si - current line
        jne     $I407                   ;brif not at end of file

        cCall   fCheckReadOnly          ;if read only
        jnz     $I405                   ; then don't insert line
        ;for get at end of file (1 past last line) we insert a blank line
        ;so that a new line is added to end of file
        sub     ax,ax
        cCall   InsertLineBuf,<hBuffer,si,ax,ldCur.ld_prgch>
        cCall   EMRefreshCache
        mov     ldCur.ld_cb,0           ;make line is zero width

;Here if line is not 1 past last line or eof
$I407:
        cCall   cbGetLine,<si,ldCur.ld_cbMax,ldCur.ld_prgch>
        mov     ldCur.ld_cb,ax

;Here after either inserting line or get line
$I408:
        mov     pdCur.pd_oln,si ;make it official line in ldCur
$I405:
cEnd

;*******************************************************************************
;_GetCurLine
;
;Purpose:
;       Fetch the current line offset (ipCur.oln) into ldCur.
;       Same as GetLine but line offset is not specified.
;Entry:
;       ipCur
;Exit:
;       ldCur
;Uses:
;       none.
;Exceptions:
;       none
;*******************************************************************************
cProc GetCurLine,<NEAR>
cBegin
        cCall   GetLine,<ipCur.ip_oln>
cEnd

;*******************************************************************************
;GetLineScratch
;
;Purpose:
;       Like GetLine, but into ldEMScratch
;Entry:
;       oln
;Exit:
;       ldEMScratch
;Uses:
;Exceptions:
;*******************************************************************************
cProc GetLineScratch,<NEAR>
        parmW   oln
cBegin
        xor     ax, ax
        mov     [ldEMScratch.LD_cb],ax
        mov     ax, [oln]
        cmp     ax, [clnCur]
        ja      GLS_Exit

        test    [emState], ES_MULTILINE
        jz      GLS1

        test    [ldCur.ld_flags], LD_fDirty
        jz      GLS2

        cmp     ax, [pdCur.pd_oln]
        jne     GLS2

GLS1:
        mov     ax, [ldCur.ld_cb]
        mov     [ldEMScratch.ld_cb], ax
        inc     ax
ifdef   PROJECT_QB
        push    [ldCur.ld_prgch]
        push    [ldEMScratch.ld_prgch]
        push    ax
        call    bltbyte                         ; pascal Calling convention
else    ;PROJECT_QB
        push    ax
        push    [ldCur.ld_prgch]
        push    [ldEMScratch.ld_prgch]
        call    _memmove                         ; C Calling convention
        add     sp, 6
endif   ;PROJECT_QB

        mov     ax, [ldCur.ld_flags]
        mov     [ldEMScratch.ld_flags], ax
        jmp     short GLS_Exit

GLS2:
        xor     bx, bx
        cmp     ax, [clnCur]
        xchg    ax,bx
        jae     GLS3

        cCall   cbGetLine,<bx,[ldEMScratch.ld_cbMax],[ldEMScratch.ld_prgch]>

GLS3:
        mov     [ldEMScratch.ld_cb], ax
        xor     ax,ax
        mov     [ldEMScratch.ld_flags],ax

GLS_Exit:
cEnd

cProc GetLineScratchPad,<NEAR>
        parmW   oln
cBegin
        cCall   GetLineScratch,<[oln]>

;
; Pad line with spaces
;
        mov     ax,[ldEMScratch.LD_cbMax]
        sub     ax,[ldEMScratch.LD_cb]
        push    ax
        mov     ax,' '
        push    ax
        mov     ax,[ldEMScratch.LD_cb]
        add     ax,[ldEMScratch.LD_prgch]
        push    ax
        call    _memset
        add     sp,6
cEnd

;*******************************************************************************
;_UpdateLine
;
;Purpose:
;       Use ldCur to replace the current buffer line. The line offset is
;       in pdCur.oln. Line is only replace if ldCur is marked as Dirty.
;       If out of memory to replace line old line is refetched and update
;       fails. Text manager will report error.
;Entry:
;       ldCur
;       pdCur
;       hBuffer
;Exit:
;       none
;Uses:
;       ax
;Exceptions:
;       none
;*******************************************************************************
cProc UpdateLine,<NEAR,PUBLIC>
cBegin

        mov     ax, 1
        push    ax                      ; Default Return value of TRUE

        test    ldCur.ld_flags,ld_fDirty
        je      $I413                   ;brif current line not modified

        mov     ax, [clnCur]
        cmp     ax,pdCur.pd_oln ;only happens for out of memory
        jbe     $I413                   ;brif if current ld past eof

        pop     ax                      ; Throw away default return value

        and     ldCur.ld_flags, not ld_fDirty   ;current line no longer dirty
        cCall   ReplaceLineBuf,<hBuffer,pdCur.pd_oln,ldCur.ld_cb,ldCur.ld_prgch>

        push    ax                      ; Save return value
        cCall   EMRefreshCache

        mov     ax,-1
        xchg    ax,[pdCur.PD_oln]
        cCall   RefreshLine,<ax>

        mov     [pdCur.pd_oln], -1
$I413:
        pop     ax                      ; restore return value.
        or      ax,ax
cEnd

cProc MaybeToggleInsertMode,<NEAR>
cBegin
        or      dl,dl
        jnz     MTIM_Exit

        cCall   ToggleInsertMode
MTIM_Exit:
cEnd

cProc ToggleInsertMode,<NEAR>
cBegin
        xor     ax,ax
        xor     cx,cx
        mov     [fResetAnchor],al
        inc     ax
        mov     cl,[fInsertMode]
        xor     ax,cx
        mov     [fInsertMode],al
        cCall   SetCursorBlock,<cx>
cEnd

;*******************************************************************************
; JoinLine - merge two consecative lines
; Description:
;       Merge lines at ip and previous line. The current line is copied into
;       a temperary buffer. The previous line is fetched. A check is made to
;       see if the current line ipCur.oln and the previous line will fit into
;       a single buffer (ldCur.cbMax). If so then the temperary buffer is copied
;       into ldCur.prgch after the previous line. The current line is then
;       deleted.
;
;       Checks are made to see if any special updating is needed such as
;       paging left or right.
;
;       Should be called when backspace at start of line.
;
; Input:
;       fBelow - TRUE  Join ipCur.oln with ipCur.oln + 1
;                               FALSE Join ipCur.oln with ipCur.oln - 1;
; Output:
;
;*******************************************************************************
cProc JoinLine,<NEAR,PUBLIC>,<SI,DI>
        parmB   fBelow

        localW  saveIpOln
        localW  saveIpOb
cBegin
        test    [emState], ES_MULTILINE
        jnz     JL2

JL1:
        cCall   NearBeep
J_JL_Exit:
        jmp     JL_Exit

JL2:
        cCall   fCheckReadOnly
        jnz     J_JL_Exit
;
; Save ipCur in case we have to restore it.
;
        mov     ax,[ipCur.IP_oln]
        mov     [saveIpOln],ax
        mov     ax,[ipCur.IP_ob]
        mov     [saveIpOb],ax

;
; Get the top line into ldCur
; Get the bottom line into ldEMScratch.
; Warning: Be very carefull here. ldCur.fDirty may be true
;          but we don't want to update the current line yet.
;
        cCall   GetCurLine

        cmp     [fBelow],0      ;fBelow
        je      JL3

        mov     ax,[ipCur.IP_oln]
        inc     ax
        cCall   GetLineScratch,<ax>

        mov     ax, [ldEMScratch.ld_cb]
        inc     ax                              ; error if ldEMScratch.cb == -1
        jnz     JL4
        jmp     SHORT JL1
JL3:

ifdef   PROJECT_QB
        push    [ldCur.LD_prgch]
        push    [ldEMScratch.LD_prgch]
        push    [ldCur.LD_cb]
        call    bltbyte                         ; pascal Calling convention
else    ;PROJECT_QB
        push    [ldCur.LD_cb]
        push    [ldCur.LD_prgch]
        push    [ldEMScratch.LD_prgch]
        call    _memmove
        add     sp,6
endif   ;PROJECT_QB

        mov     ax,[ldCur.LD_cb]
        mov     [ldEMScratch.LD_cb],ax

        dec     [ipCur.IP_oln]

        cCall   cbGetLine,<ipCur.ip_oln,ldCur.ld_cbMax,ldCur.ld_prgch>
        mov     [ldCur.LD_cb],ax

JL4:
;
; Pad the top line to the cursor position.
;
        mov     ax, [ipCur.IP_ob]
        sub     ax, [ldCur.LD_cb]
        jbe     JL4a

        push    ax                              ; cb - for memset

        mov     ax, ' '
        push    ax                              ; ch - for memset

        mov     ax, [ldCur.LD_prgch]
        add     ax, [ldCur.LD_cb]
        push    ax                              ; pb - for memset
        call    _memset                         ; C calling convention
        add     sp, 6

        mov     ax, [ipCur.IP_ob]
        mov     [ldCur.LD_cb], ax

JL4a:
;
; Move ip to end of the top line.
;
        mov     ax,[ldCur.LD_cb]
        mov     [ipCur.IP_ob],ax


;
; Get rid of leading spaces in the bottom line.
;
; UNDONE - This can be optimised with scasb
        mov     si,[ldEMScratch.LD_cb]
        sub     di,di
        mov     bx,[ldEMScratch.LD_prgch]

JL5:
        or      si,si
        jz      JL6

        cmp     BYTE PTR [bx][di],' '
        jne     JL6

        inc     di
        dec     si
        jmp     short JL5
JL6:

;
; Check if both lines will fit on the max line
;
        mov     ax,si
        add     ax,[ldCur.LD_cb]
        mov     cx,[ldCur.LD_cbMax]
        dec     cx
        cmp     ax,cx
        jbe     JL8

;
; If fBelow then restore ldCur from ldEMScratch
;
        cmp     [fBelow],0
        jne     JL7

ifdef   PROJECT_QB
        push    [ldEMScratch.LD_prgch]
        push    [ldCur.LD_prgch]
        push    [ldEMScratch.LD_cb]
        call    bltbyte                         ; pascal Calling convention
else    ;PROJECT_QB
        push    [ldEMScratch.LD_cb]
        push    [ldEMScratch.LD_prgch]
        push    [ldCur.LD_prgch]
        call    _memmove
        add     sp,6
endif   ;PROJECT_QB

        mov     ax,[ldEMScratch.LD_cb]
        mov     [ldCur.LD_cb],ax

JL7:
;
; Restore ipCur
;
        mov     ax,[saveIpOln]
        mov     [ipCur.IP_oln],ax
        mov     ax,[saveIpOb]
        mov     [ipCur.IP_ob],ax
        jmp     JL1

;
; Append the bottom line to the top line.
;
JL8:
        or      si,si
        je      JL9

ifdef   PROJECT_QB
        mov     ax,[ldEMScratch.LD_prgch]
        add     ax,di
        push    ax
        mov     ax,[ldCur.LD_cb]
        add     ax,[ldCur.LD_prgch]
        push    ax
        push    si
        call    bltbyte                         ; pascal Calling convention
else    ;PROJECT_QB
        push    si
        mov     ax,[ldEMScratch.LD_prgch]
        add     ax,di
        push    ax
        mov     ax,[ldCur.LD_cb]
        add     ax,[ldCur.LD_prgch]
        push    ax
        call    _memmove
        add     sp,6
endif   ;PROJECT_QB

JL9:
        add     [ldCur.LD_cb],si

        cCall   StartBigEdit

        mov     ax,2
        cCall   DeleteLinesBuf,<hBuffer,ipCur.ip_oln,ax>
        cCall   EMRefreshCache

        cCall   InsertLineBuf,<hBuffer,ipCur.ip_oln,ldCur.ld_cb,ldCur.ld_prgch>
        cCall   EMRefreshCache

        and     [ldCur.ld_flags], not ld_fDirty
        mov     [pdCur.PD_oln],-1

        cCall   EndBigEdit
        cCall   EMRefreshCache

;
; Determine what has to be redrawn
;
        cCall   NoSelection
JL10:
        cCall   DisplayCurPos
JL11:
        cmp     fRefreshScreen,0
        jne     JL_Exit

        mov     ax,-1
        cCall   RefreshLines,<ipCur.ip_oln,ax>
JL_Exit:
cEnd


;*******************************************************************************
; DoNewLine - Create a new line
; Description:
;       Create a new line of text at ip and display. The current line is
;       terminated at ipCur.ob.  If ipCur.ob is past the end of the line
;       the line is spaced filled out to ipCur.ob. If their was remaining
;       text on the line such as for a line split the truncated line is
;       inserted for the current line and a new line created consisting
;       of the remaining fragment.
;
;       Should be called on carriage return.
; Input:
;
;
; Output:
;
;*******************************************************************************
cProc DoNewLine,<NEAR,PUBLIC>,<SI>
        parmB   fMoveCursor

        localW  obFirst
        localW  obSave
        localW  olnSave
cBegin
        cCall   fCheckReadOnly
        jnz     J_NL_Exit

        test    [emState], ES_MULTILINE
        jnz     NL0

NL_Beep:
        cCall   NearBeep

J_NL_EXIT:
        jmp     NL_Exit
NL0:
        mov     ax, [ipCur.ip_ob]               ; Save current ip in case
        mov     [obSave], ax                    ;    it must be restored.
        mov     ax, [ipCur.ip_oln]
        mov     [olnSave], ax

        cCall   NoSelection

        cCall   ModifyLine
        jz      J_NL_Exit

        mov     ax,[ldCur.LD_cb]
        cmp     [ipCur.IP_ob],ax
        jb      NL1

        push    ax                              ; Save ldCur.ld_cb
        cCall   InsertLineBelow
        pop     cx                              ; Restore ldCur.ld_cb
        jz      NL_Beep

        test    [fMoveCursor], 0ffH
        jz      J_NL10

        jcxz    NL_0a                   ; Don't change ob for blank lines

        cCall   AutoIndent
NL_0a:
        inc     [ipCur.ip_oln]
if 1
        jmp     NL5a
else
        cCall   AdjustAfterInsertLine
        jmp     NL_Exit
endif

J_NL10:
        jmp     NL10

;
; Scan for first non-space
; UNDONE - optimise with scasb
;
NL1:
        mov     bx,[ipCur.IP_ob]
        mov     si,[ldCur.LD_prgch]
NL2:
        cmp     bx,[ldCur.LD_cb]
        jnb     NL3

        cmp     BYTE PTR [bx][si],' '
        jne     NL3

        inc     bx
        jmp     NL2

NL3:
        mov     [ipCur.IP_ob],bx

;
; Save start of line for autoindent
;
        cCall   obGetFirst
        mov     [obFirst],ax

        cCall   StartBigEdit

;
; Delete (logically - not really) to end of line.
;
; Warning: ReplaceLineBuf MUST not tamper with ldCur.prgch
;
        cCall   ReplaceLineBuf,<hBuffer,pdCur.pd_oln,ipCur.ip_ob,ldCur.ld_prgch>
        cCall   EMRefreshCache

;
; Delete (really) from begining of line to cursor
;
        cmp     [ipCur.IP_ob],0
        je      NL4

        mov     ax,[ipCur.IP_ob]
        cCall   DelCh,<ax,ax>

;
; Auto indent.
;
NL4:
        mov     [ipCur.IP_ob],0

        cmp     [obFirst],0
        je      NL5

        mov     ax, ' '
        cCall   InsCh,<obFirst,ax, ax>  ; InsCh( obFirst, ' ', TRUE );

NL5:
        mov     ax,[obFirst]
        mov     [ipCur.IP_ob],ax

        inc     [ipCur.IP_oln]
        cCall   InsertLineBuf,<hBuffer,ipCur.ip_oln,ldCur.ld_cb,ldCur.ld_prgch>
        cCall   EMRefreshCache

        and     [ldCur.ld_flags], not ld_fDirty

        mov     [pdCur.PD_oln],-1

        cCall   EndBigEdit
        cCall   EMRefreshCache

        test    [fMoveCursor], 0ffH
        jnz     NL5a

        mov     ax, [obSave]
        mov     [ipCur.ip_ob], ax
        mov     ax, [olnSave]
        mov     [ipCur.ip_oln], ax
        jmp     short NL10

NL5a:
;
; Ok - Now let's see what has to be redrawn
;
        mov     ax,[cLinesCur]
        add     ax,[pdCur.PD_olnTop]
        cmp     ax,[ipCur.IP_oln]
        ja      NL7

        inc     [pdCur.PD_olnTop]
        cCall   DisplayCurPos
NL6:
        inc     [fRefreshScreen]
        jmp     short NL_Exit

NL7:
        mov     ax,[pdCur.PD_obLeft]
        cmp     [ipCur.IP_ob],ax
        jge     NL10

        mov     ax,[ipCur.IP_ob]
        mov     [pdCur.PD_obLeft],ax

        mov     ax,[cColumnsCur]
        shr     ax,1
        cmp     ax,[pdCur.PD_obLeft]
        jbe     NL9

NL8:
        mov     [pdCur.PD_obLeft],0
        jmp     SHORT NL6

NL9:
        cmp     [pdCur.PD_obLeft],5
        jle     NL8

        sub     [pdCur.PD_obLeft],5

        jmp     SHORT NL6
NL10:
        mov     bx,-1
        mov     cx,[ipCur.IP_oln]
        jcxz    NL11
        dec     cx
NL11:
        cCall   RefreshLines,<cx,bx>
NL_Exit:
        mov     [fResetAnchor], 1
cEnd

cProc NewLine,<NEAR,PUBLIC>
cBegin
        mov     ax, 1
        cCall   DoNewLine,<ax>
cEnd

cProc SplitLine,<NEAR,PUBLIC>
cBegin
        xor     ax,ax
        cCall   DoNewLine,<ax>
cEnd

cProc NextLine,<NEAR,PUBLIC>
cBegin
        cCall   LineDown

        cCall   GetCurLine
        mov     ax, [ldCur.ld_cb]
        or      ax,ax
        je      NxL_1

        cCall   HomeLine
        jmp     short NxL_Exit

NxL_1:
        mov     [ipCur.ip_ob], -1
        cCall   obGetPrev
        mov     [ipCur.ip_ob], ax
        cCall   DisplayCurPos
NxL_Exit:
cEnd

cProc BegLine,<NEAR>
cBegin
        mov     [ipCur.ip_ob], 0
        cCall   DisplayCurPos
cEnd

;*******************************************************************************
;_InsertLineBelow
;
;Purpose:
;       Insert a blank line in the text buffer.
;Entry:
;       ldCur
;       ipCur
;       pdCur
;       hBuffer
;Exit:
;       none
;Uses:
;Exceptions:
;*******************************************************************************
cProc InsertLineBelow,<NEAR,PUBLIC>,<SI,DI>
cBegin
        cCall   fCheckReadOnly
        mov     al, 0                   ; mov does NOT affect flags
        jnz     ExitInsertLineBelow

        cCall   UpdateLine              ;make sure current line is in text buf.
        mov     al, 1                   ; Return TRUE even if above failed.
        jz      ExitInsertLineBelow

        cCall   NoSelection             ;turn off any selected region

        mov     [ldCur.ld_cb],0         ;make blank line
        mov     [pdCur.PD_oln],-1       ;

        mov     ax, [ipCur.ip_oln]
        inc     ax
        cCall   InsertLineBuf,<hBuffer,ax,ldCur.ld_cb,ldCur.ld_prgch>
        push    ax                      ; Save until after this call
        cCall   EMRefreshCache
        pop     ax                      ; restore result of InsertLineBuf

ExitInsertLineBelow:
        or      al,al                   ; Return Z or NZ.
cEnd

cProc AdjustAfterInsertLine,<NEAR>
cBegin
        mov     ax, [ipCur.ip_ob]
        mov     bx, [pdCur.pd_obleft]
        cmp     ax, bx
        jae     AAIL_1
        mov     [ipCur.ip_ob], bx
AAIL_1:
        mov     ax,[cLinesCur]          ;pwndEditCur.cLines (lines on screen)
        add     ax,[pdCur.pd_olntop]    ;set olnBottom 1 above last line on
        dec     ax                      ;screen  di - olnBottom

        cmp     [ipCur.ip_oln],ax       ;ax - olnBottom
        jbe     AAIL_2                  ;brif ip is above bottom

        inc     [pdCur.pd_olntop]       ;move top of screen up 1 line
        inc     [fRefreshScreen]
        jmp     SHORT AAIL_Exit 
AAIL_2:
        mov     bx,[ipCur.IP_oln]
        dec     bx
        cCall   RefreshLines,<bx,ax>
AAIL_Exit:
cEnd

cProc InsertLine,<NEAR,PUBLIC>
cBegin
        test    [emState], ES_MULTILINE
        jnz     IL_1

IL_Beep:
        cCall   NearBeep
        jmp     IL_Exit

IL_1:
        cCall   InsertLineBelow
        jz      IL_Beep

        cCall   GetCurLine
        mov     cx, [ldCur.ld_cb]
        jcxz    IL_2

        cCall   AutoIndent
        inc     [ipCur.ip_oln]
IL_2:
        cCall   AdjustAfterInsertLine
IL_Exit:
cEnd


;*******************************************************************************
;_KillLine
;
;Purpose:
;       Delete the current line from the text buffer. The current line is
;       first selected and the a distructive cut is done.
;Entry:
;       fMultiLine
;       hBuffer
;       pefCur.ef_fSelection
;       ipCur
;Exit:
;       ldCur
;Uses:
;       none.
;Exceptions:
;       none
;*******************************************************************************
cProc KillLine,<NEAR,PUBLIC>
cBegin
        test    [emState], ES_MULTILINE ;don't delete line if only single line
        jz      $I471                   ;brif not multiline
                                        ;also don't delete if last line in text
        mov     ax, [clnCur]            ;buffer
        cmp     ax,ipCur.ip_oln
        jne     $I470                   ;brif ip not last line in text buffer

;Here if not ok to delete line
$I471:
        cCall   NearBeep                ;warn user
        jmp     SHORT $EX469            ;return

;Here if ok to delete line
$I470:
        cCall   fCheckReadOnly
        jnz     $EX469

        cCall   StartBigEdit            ; Don't parse the dirty line
        cCall   UpdateLine
        cCall   EndBigEdit
        cCall   EMRefreshCache
                
        cCall   NoSelection             ;remove any selection
        inc     ipCur.ip_oln            ;Delete by forcing full selection
        mov     ipCur.ip_ob,0           ;of line. ipAnchor is still at old spot
        cCall   HiliteSelection         ;hilite whole line
        mov     bx,pefCur               ;set flag that we do have selection
        mov     [bx].ef_fSelection,TRUE
        mov     ax,TRUE
        cCall   Cut,<ax>                ;do cut. This will force old line
                                        ;into scrap for later recovery
        cCall   DisplayCurPos           ;recal. ip screen state
$EX469:
cEnd

;*******************************************************************************
;_EraseEol
;
;Purpose:
;       Delete characters from ip to end of line. Line is refreshed.
;       Deletion is done by selecting and then cutting.
;Entry:
;       ipCur
;       ldCur
;       pefCur.ef_fSelection
;Exit:
;       ldCur
;Uses:
;       none.
;Exceptions:
;
;*******************************************************************************
cProc EraseEol,<NEAR,PUBLIC>
cBegin
        cCall   fCheckReadOnly
        jnz     ExitEraseEol
        cCall   NoSelection                     ;remove any selection
        cCall   GetCurLine                      ;get the line in ld
        mov     ax,ldCur.ld_cb
        mov     ipAnchor.ip_ob,ax               ;move anchor to eol
        cCall   HiliteSelection                 ;hilite from ip to eol
        ;!!! This code can be shared with Kill Line
        mov     bx,pefCur                       ;set selection true
        mov     [bx].ef_fSelection,TRUE
        mov     ax,TRUE
        cCall   Cut,<ax>
ExitEraseEol:
cEnd

;*******************************************************************************
;DelWord
;
;Purpose:
; If the cursor is on a word then delete to the end of the word
; else do Del().
;
;Entry:
;Exit:
;Uses:
;Exceptions:
;
;*******************************************************************************
cProc DelWord,<NEAR,PUBLIC>,<SI>
cBegin
        cCall   NoSelection

        cCall   ModifyLine
        jz      DW_Exit

        mov     si, [ipCur.ip_ob]

        cmp     si, [ldCur.ld_cb]
        jae     DW_0                            ; Cursor is past end of line
                                                ; do Del which will do JoinLine

        cCall   FOnSpace
        jz      DW_1                            ; Cursor is on a space

        cCall   FOnWord                         ; Is cursor on a word char?
        jnz     DW_2                            ; Yes - Delete word

DW_0:
;
; Cursor is not on a word and not on a space.
; So just delete one character (or JoinLine).
;
        cCall   Del
        jmp     short DW_Exit

DW_1:
;
; Cursor is on a space. So delete all white space after cursor
;
        inc     [ipCur.ip_ob]
        cCall   FOnSpace
        jz      DW_1
        jmp     short DW_3

DW_2:
;
; Cursor is on a word so delete to the end of the word.
;
        cCall   RightPastWordEnd                ; Find end of word
DW_3:
        mov     ax, [ipCur.ip_ob]
        mov     bx, ax
        mov     [ipCur.ip_ob], si
        sub     ax, si                          ; How many chars to delete
        cCall   DelCh,<ax,bx>
        cCall   RefreshLine,<ipCur.ip_oln>
DW_Exit:
cEnd

;*******************************************************************************
;FOnSpace
;
;Purpose:
; Checks if the cursor is on a space
;
;
;Entry:
;Exit:
; Return Z if cursor is on a space.
;
;Uses:
;Exceptions:
;
;*******************************************************************************
cProc FOnSpace,<NEAR>
cBegin
        mov     bx, [ldCur.ld_prgch]
        add     bx, [ipCur.ip_ob]
        mov     al,[bx]
        cmp     al, ' '
cEnd

;*******************************************************************************
;_InsertKey
;
;Purpose:
;       Insert the specfied character at the current ip
;Entry:
;       InsertCh - character to insert
;       ipCur
;       pdCur
;       ldCur
;       pwndEditCur.cColumns
;       fRedraw
;Exit:
;       ldCur
;       ipCur
;Uses:
;       si, di, cx, bx
;Exceptions:
;
;*******************************************************************************
cProc InsertKey,<NEAR,PUBLIC>,<SI,DI>
        parmB   InsertCh
cBegin
        cCall   fCheckReadOnly
        jnz     J_ExitInsertKey
        cmp     [InsertCh],0
        jne     @F                      ;if not null contine
J_ExitInsertKey:
        jmp     ExitInsertKey           ;if null don't insert key

;Here if key ok to insert
@@:
        sub     ax,ax                   ;first cut any selection
        cCall   Cut,<ax>                ;so that insertion replaces text
        cCall   ModifyLine              ;mark line as modified
        mov     di,ldCur.ld_cbMax
        dec     di
        cmp     [fInsertMode],0         ; Can always insert another char when
        jnz     @F                      ;   not in insert mode
ifdef   KANJI
        mov     si,[ldCur.LD_prgch]     ;If we are in overwrite, then
        cCall   DbcsAdjCursor
        add     si,ax
        cCall   FIsDbcsChar,<[si]>      ; See if current char is DBCS
        or      ax,ax
        jz      SkipInsertSpace
        inc     si                      ; if so,
        mov     byte ptr [si],' '       ; put a space at next byte
SkipInsertSpace:
endif   ; KANJI
        jmp     SHORT DoInsertKey
@@:
        cmp     di,ldCur.ld_cb          ;if line almost full don't insert
        je      NoInsertKey             ;alway leave 1 InsertCh space

;Here if room to insert key
DoInsertKey:
        cmp     di, [ipCur.ip_ob]       ;beep if cursor past cbMax
        jbe     NoInsertKey

        mov     al,[InsertCh]
        cbw     
        mov     bx,1                    ;insert only 1 copy of character
        mov     cl, [fInsertMode]
        cCall   InsCh,<bx,ax, cx>       ;insert into ldCur
        or      ax,ax                   ;test if insert successfull
        je      NoInsertKey             ;brif if not
        inc     ipCur.ip_ob             ;move to right on screen
        mov     si,[cColumnsCur]        ;pwndEditCur.cColumns
        add     si,pdCur.pd_obleft
        cmp     ipCur.ip_ob,si          ;compute max. right position
        jl      @F                      ;brif if new position to right of max
;Here if new position if off right end of screen
        sub     ax,ax
        cCall   PageRight,<shiftWidth,ax>               ;page 1 to right
        jmp     SHORT ExitInsertKey
;Here if new position is still on screen
@@:
ifdef   KANJI
        cmp     [fCharIsDbcs],0
        jnz     SHORT ExitInsertKey
endif   ; KANJI
        cCall   RefreshLine,<ipCur.ip_oln>
        jmp     SHORT ExitInsertKey

;Here if insert can't be done
NoInsertKey:
        cCall   NearBeep
ExitInsertKey:
cEnd

;*****************************************************************************

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\kanji.asm ===
;*
;*	CW : Character Oriented Windows
;*
;*	kanji.asm : Kanji (DBCS) support routines

.xlist
	include	user.inc

IFDEF KANJI	;* entire file

	include kanji.inc
.list


sBegin USER_CORE
    assumes CS,USER_CORE
    assumes DS,DATA
    assumes SS,DATA

;*****************************************************************************
;* single character checks

;********** FIsDbcsChar(ch) **********
;*	entry: ch = char which may be first byte of double byte character
;*	* Check for double byte character
;*	exit: AX != 0 if LOBYTE(ch) is in DBCS range
;*		else AX == 0 => single byte character

cPublic	FIsDbcsChar, <FAR, PUBLIC, ATOMIC>
    parmW  chTest	;* CHAR
cBegin	FIsDbcsChar
	xor	cx,cx				;* return value (assume 0)
	mov	ax,chTest
	JmpNotDbc not_dbc
	inc	cx				;* return TRUE
not_dbc:
	mov	ax,cx

cEnd	FIsDbcsChar



;*****************************************************************************
;* String length


;********** CchLenDbcs(sz) **********
;*	entry:	sz = string (CHAR *)
;*	* count number of real characters
;*	exit: AX == # of real characters
;*	NOTE: does not check 2nd byte of DBCS characters.

cPublic	CchLenDbcs, <FAR, PUBLIC, ATOMIC>, <SI>
    parmDP sz
cBegin	CchLenDbcs

	mov	si,sz
	xor	cx,cx				;* cch
loop_cchlen:
	lodsb
	or	al,al
	jz	end_cchlen
	inc	cx
	JmpNotDbc loop_cchlen
;*	* is double byte character
	inc	si				;* bump si, don't bump cx
	jmp	short loop_cchlen
end_cchlen:
	mov	ax,cx

cEnd	CchLenDbcs


;*****************************************************************************
;* String navagation

;********** PchNextDbcs(sz) **********
;*	entry:	sz = string (CHAR *)
;*	* navigate to next character
;*	exit: AX => next character
;*	NOTE: does not check 2nd byte of DBCS characters.
;*	NOTE: if positioned on '\0', then will return '\0'

cPublic	PchNextDbcs, <FAR, PUBLIC, ATOMIC>
    parmDP sz
cBegin	PchNextDbcs
	mov	bx,sz
	mov	al,ds:[bx]
	or	al,al
	jz	end_pch_next			;* stay pointing to end
	inc	bx				;* assume single byte
	JmpNotDbc end_pch_next
	inc	bx
end_pch_next:	;* bx = pch to return
	mov	ax,bx
cEnd	PchNextDbcs



;********** PchPrevDbcs(pchChar, szMin) **********
;*	entry:	pchChar => current character position
;*		szMin => start of string (to prevent going back too far)
;*	* navigate to next character
;*	exit: AX => next character, NULL if error (sz not in range of szMin)
;*	NOTE: does not check 2nd byte of DBCS characters.

cPublic	PchPrevDbcs, <FAR, PUBLIC, ATOMIC>
    parmDP pchChar
    parmDP szMin
cBegin	PchPrevDbcs

;*	* Note: we could do this intelligently, but easier to do it from
;*	*  the start of the string
	mov	bx,szMin
	mov	cx,pchChar			;* try to get here
	cmp	bx,cx
	mov	ax,bx
	je	end_pch_prev			;* stay at start
loop_pch_prev:
	mov	al,ds:[bx]
	or	al,al
	jz	err_pch_prev			;* return error if not found
	mov	dx,bx				;* start of char
	inc	bx				;* assume single byte
	JmpNotDbc skip_pch_prev
	inc	bx
skip_pch_prev:
	cmp	bx,cx				;* at the specified character ?
	jl	loop_pch_prev
	mov	ax,dx
end_pch_prev:	;* ax = pch to return

cEnd	PchPrevDbcs

err_pch_prev:
	xor	ax,ax				;* assume error
	jmp	short end_pch_prev







;*****************************************************************************

sEnd	USER_CORE

;*****************************************************************************

ENDIF ;KANJI (entire file)

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\medit.h ===
/*
	COW : Character Oriented Windows

	medit.h : multi-line edit item
*/

/*****************************************************************************/

VOID	FARPUBLIC InitEditWnd(PWND, BYTE *, WORD);


/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\menu.h ===
/*
	COW : Character Oriented Windows

	menu.h : menu specific stuff
*/


#define	vkMenuPrefix	VK_MENU

#define	idNil		((WORD) -2)	/* allow -1 for wrap backwards */
#define	imenuNil	idNil
#define	iitemNil	idNil



/* Menu Modes : HIWORD(lParam) for WM_COMMAND / WM_MENUSELECT messages */
/* should be in cwindows.h somewhere .... */
#define	mmdItem		0		/* dropdown item */
#define	mmdAccel	1		/* keyboard accelerator */
#define	mmdMenu		2		/* dropdown not item */



/* Menu processing is locked out by changing the filter proc */
PRIVATE BOOL FARPRIVATE		MenuFilterProc(PMSG);
#define FMenuAllowed() (pfnFilter == MenuFilterProc)


typedef struct _mni
	{
	WORD	imenu;			/* current menu selected */
	WORD	iitem;			/* current item */
	MENU	*pmenuOpen;		/* Open menu, or NULL */
	BITS	fMenuMnem:1;		/* mnemonics on ? */
	BITS	fMouse:1;		/* Mouse mode ? */
	BITS	fMouseOnTitle:1;	/* Mouse stay on title ? */
	} MNI;	/* Menu Information */

PRIVATE MNI mniCur;

#define FMenuActive()		(mniCur.imenu != imenuNil)
#define FMenuOpen()		(mniCur.pmenuOpen != NULL)

extern PMENUBAR pmenubarCur;
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\medit.c ===
/*
	COW : Character Oriented Windows
	(COW USER EDIT)

	medit.c : multiline edit manager (C portion)
*/

#define COW
#include <cow.h>

#ifdef EDIT_FULLMGR		/* entire file */

#include <uedit.h>
#include <umedit.h>		/* public structures */
#include <uevent.h>
#include <uwindow.h>
#include <uisa.h>

#include "edit.h"		/* includes "medit.h" */
#include "util.h"
#include "strings.h"
#include "dialog.h"


PUBLIC DWORD FARPUBLIC
EditWndProc(pwnd, message, wParam, lParam)
/*
  -- for edit windows
*/
PWND	pwnd;
WORD	message;
WORD	wParam;
DWORD	lParam;
	{
	StartPublic();

	DWORD lRet = InternalEditWndProc(pwnd, message, wParam, lParam);

	ReturnPublic(lRet, DWORD);
	}



PUBLIC VOID FARPUBLIC
SetEditText(pwnd, sz, fDrawWindow)
PWND	pwnd;
char *	sz;
BOOL	fDrawWindow;
	{
	StartPublic();

	SendMessage(pwnd, WM_SETTEXT, fDrawWindow, (DWORD) ((char far *) sz));

	StopPublic();
	}



PUBLIC WORD FARPUBLIC
GetEditText(pwnd, sz, cchMac)
PWND	pwnd;
char *	sz;
WORD	cchMac;
	{
	WORD cchRet;
	StartPublic();

	cchRet = (WORD) SendMessage(pwnd, WM_GETTEXT, cchMac,
	    (DWORD) ((char far *) sz));

	ReturnPublic(cchRet, WORD);
	}



PUBLIC VOID FARPUBLIC
InitEditWnd(pwnd, pb, cchMac)
REGISTER PWND pwnd;
BYTE *	pb;
REGISTER WORD cchMac;
	{
	EF *	pef;
	StartPublic();

	pef = (EF *)(pwnd->rgwExtra[cwExtraMin] = (WORD) pb);
	pb += sizeof(EF);

	pef->pldCur = (LD *) pb;
	pb += sizeof(LD);
	cchMac -= sizeof(EF) + sizeof(LD);

	pef->ipCur.ob = 0;
	pef->ipCur.oln = 0;
	pef->ipAnchor.ob = 0;
	pef->ipAnchor.oln = 0;

	pef->Style = 0;
	pef->fSelection = FALSE;
	pef->attrCur = isaEdit;
	pef->hBuffer = hBufferUndefined;
	pef->pwndScrollV = NULL;
	pef->pwndScrollH = NULL;

	pef->pldCur->prgch = pb;
	pef->pldCur->cbMax = cchMac;
	pef->pldCur->cb = 0;

	SetEditText(pwnd, szEmptyString, FALSE);

	StopPublic();
	}

#endif /*EDIT_FULLMGR*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\menucore.c ===
/*
	COW : Character Oriented Windows

	menucore.c : menu handler

	Contains functions that must be in core segment.
*/

#define COW
#include <cow.h>

#include <uevent.h>
#include <umenu.h>
#include <kkeyboar.h>

#include "event.h"
#include "menu.h"
#include "_menu.h"


PUBLIC BOOL FARPUBLIC
FEnableMenuBar(fEnable)
/*
  -- Enable/Disable menu bar
*/
BOOL fEnable;
	{
	StartPublic();
	BOOL fEnabled = FMenuAllowed();
	
	if (fEnable && !fEnabled)
		{
		Assert(pfnFilter == DummyFilter);
		pfnFilter = MenuFilterProc;
		}
	else if (!fEnable && fEnabled)
		{
		Assert(pfnFilter == MenuFilterProc);
		pfnFilter = DummyFilter;
		}

	ReturnPublic(fEnabled, BOOL);
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\menu2.c ===
/*
	COW : Character Oriented Windows

	menu2.c : menu extras
*/

#define COW
#include <cow.h>

#include <umenu.h>
#include <uwindow.h>
#include <uevent.h>

#include "menu.h"
#include "_menu.h"

STATIC PMENU	FindMenu(WORD);


PUBLIC VOID FARPUBLIC
EnableMenu(id, fEnable)
/*
  -- Enable/Disable a particular menu
*/
WORD id;
BOOL fEnable;
	{
	StartPublic();
	REGISTER PMENU pmenu;
	
	if ((pmenu = FindMenu(id)) != NULL)
		pmenu->fEnabled = (fEnable != 0);
	StopPublic();
	}



PUBLIC VOID FARPUBLIC
EnableMenuItem(id, fEnable)
/*
  -- Enable/Disable a particular menu item
*/
WORD id;
BOOL fEnable;
	{
	StartPublic();
	REGISTER PMENUITEM pmenuitem;
	
	if ((pmenuitem = FindMenuItem(id)) != NULL)
		pmenuitem->fEnabled = (fEnable != 0);
	StopPublic();
	}



PUBLIC VOID FARPUBLIC
CheckMenuItem(id, fChecked)
/*
  -- check specified menu item
*/
WORD id;
BOOL fChecked;
	{
	StartPublic();
	REGISTER PMENUITEM pmenuitem;
	
	if ((pmenuitem = FindMenuItem(id)) != NULL)
		pmenuitem->fChecked = (fChecked != 0);
	StopPublic();
	}



PUBLIC BOOL FARPUBLIC
FMenuItemChecked(id)
/*
  -- return state of menu item check flag
*/
WORD id;
	{
	StartPublic();
	REGISTER PMENUITEM pmenuitem;
	
	if ((pmenuitem = FindMenuItem(id)) != NULL)
		{
		ReturnPublic(pmenuitem->fChecked, BOOL);
		}
	else
		{
		ReturnPublic(FALSE, BOOL);
		}
	}

STATIC PMENU
FindMenu(id)
WORD id;
/* FindMenu - Find specified menu */
	{
	StartPublic();
	PMENU pmenu = pmenubarCur->rgmenu;
	WORD cmenu = pmenubarCur->cmenu;

	while (cmenu--)
		{
		if (pmenu->idMenu == id) return(pmenu);
		pmenu++;
		}
	return(NULL);
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\menu.c ===
/*	SCCSWHAT() */
/*
	COW : Character Oriented Windows

	menu.c : menu handler
*/

#define COW
#include <cow.h>

#include <umenu.h>
#include <uwindow.h>
#include <uisa.h>
#include <uevent.h>
#include <vkey.h>
#include <uscreen.h>
#include <uutil.h>
#include <kkeyboar.h>

#include "dialog.h"
#include "event.h"
#include "window.h"
#include "screen.h"
#include "util.h"
#include "case.h"
#include "overlap.h"
#include "shadow.h"

#ifdef DUAL
#include <os2.h>
extern	WORD	fProtectMode;
#else
#ifdef DOS5
#include <os2.h>
#endif
#endif

#include "menu.h"
#include "_menu.h"


#ifdef KANJI
PUBLIC BOOL fKanaAccel = FALSE;		/* Kana accelerators ?? */
#endif /*KANJI*/


#define FShowMenuBar()	(pmenubarCur != NULL)
STATIC PMENUBAR pmenubarCur; 		/* current menu bar being displayed */
STATIC ARC arcMenu;
STATIC PWND pwndMenu;

STATIC BYTE FAR *lpbMenu;	/* where the screen image under menu is kept */

#ifdef ACCEL_MULTIPLE
BOOL	fOneOfMultiple;		/* => if one of multiple matching accelerators */
#endif /*ACCEL_MULTIPLE*/

#ifdef	MULTIPLE_ACTION
WORD	vkActionPrim = VK_MENU;		/* Primary Action Key */
WORD	vkActionSec = VK_F11;		/* Secondary Action Key */
WORD	vkCancelPrim = LOBYTE(VK_ESCAPE);	/* Primary Cancel Key */
WORD	vkCancelSec = VK_F12;		/* Secondary Cancel Key */
#endif	/* MULTIPLE_ACTION */

/* Menu Info : see note in MENU.H */
extern	MNI mniCur;
/* PRIVATE MNI mniCur = { imenuNil, iitemNil, NULL, FALSE, FALSE, FALSE }; */



STATIC MENU *pmenuFound;
/* set by FindMenuItem to indicate which menu contains
   the item that was found */


/* forward */
STATIC PMENUITEM PmenuitemOfPmenu(PMENU);

/* menus */
STATIC VOID	SelectMenu(WORD);
STATIC VOID	HiliteMenuTitle(BOOL);
STATIC VOID	ReportMenuInactive(void);
STATIC VOID	OpenMenuCur(void);
#ifdef	DIALOG_NOSAVE
STATIC VOID	DrawMenuCur(void);
#endif	// DIALOG_NOSAVE
STATIC VOID	CloseMenuCur(BOOL);

/* menu title selection */
STATIC VOID	HiliteMenuMnem(BOOL);
STATIC BOOL	FMakeSelection(void);
STATIC WORD	ImenuPickVk(WORD);
STATIC WORD	ImenuPickMsp(MSP);

/* menu items */
STATIC VOID	DrawMenuItem(AX, AX, AY, PMENUITEM);
STATIC VOID	HiliteItem(BOOL);
STATIC BOOL	FSelectItem(WORD);
STATIC BOOL	FMatchItemVk(WORD);
STATIC BOOL	FSelectItemMsp(MSP);
STATIC BOOL	FInsideMenuMsp(AX, AY);

/* filter */
STATIC VOID	SetIdleState(void);

/* utilities */
STATIC BOOL	FTranslateAccelerator(WORD, WORD);
STATIC BOOL	FMatchVkCh(WORD, char);
STATIC char *	SzItem(PMENUITEM);

STATIC VOID	SendMenuHelp(WORD);

#ifdef	MENU_NOSAVE
extern VOID	FAR PASCAL	ScreenRedraw(VOID);
#endif	// MENU_NOSAVE




STATIC PMENUITEM
PmenuitemOfPmenu(pmenu)
/*
  -- return address of first menu item in menu
*/
REGISTER PMENU pmenu;
	{
	return (pmenu->fHandle ? *(pmenu->u.prgmenuitem) : pmenu->u.rgmenuitem);
	}



PUBLIC PMENUITEM FARPUBLIC
FindMenuItem(id)
WORD id;
/* FindMenuItem - Find specified menu item in tree */
	{
	StartPublic();
	PMENU pmenu = pmenubarCur->rgmenu;
	WORD cmenu = pmenubarCur->cmenu;

	while (cmenu--)
		{
		REGISTER PMENUITEM pmenuitem = PmenuitemOfPmenu(pmenu);
		REGISTER WORD citem = pmenu->citem;
		
		while (citem--)
			{
			if (pmenuitem->idItem == id &&
			    !pmenuitem->fSeparator)
				{
				pmenuFound = pmenu;
				ReturnPublic(pmenuitem, PMENUITEM);
				}
			pmenuitem++;
			}
		pmenu++;
		}
	ReturnPublic(NULL, PMENUITEM);
	}




PUBLIC VOID FARPUBLIC
InitMenu(pwnd, pmenubar)
/*
  -- initialize menu state
*/
REGISTER PWND pwnd;
PMENUBAR pmenubar;
	{
	StartPublic();

	CloseMenuCur(TRUE);
	ReportMenuInactive();

	AssertSz(mniCur.imenu == imenuNil, "Init Menu while another menu still active");
	mniCur.iitem = iitemNil;
	mniCur.fMouse = FALSE;
	pwndMenu = pwnd;
	pmenubarCur = pmenubar;
	FEnableMenuBar(pwnd != NULL);
	DrawMenubar();
	StopPublic();
	}



PUBLIC VOID FARPUBLIC
DrawMenubar()
/*
  -- Draw Menu Bar and optionally fill with MENU item strings
*/
	{
	StartPublic();
	REGISTER PMENU pmenu;
	REGISTER WORD imenu;

	if (!FShowMenuBar())
		return;

	DrawThisWnd(NULL);

	FillArc(axMenuMin, ayMenu, axMenuMac, ayMenu+1, ' ', isaMenu);

	for (imenu = 0, pmenu = pmenubarCur->rgmenu;
	    imenu < pmenubarCur->cmenu;
	    imenu++, pmenu++)
		{
		WORD di = pmenu->fEnabled ? dmTextOnly :
			DiNormal(isaDisabledMenuItem);

		TextOutAbs(axMenuMin + pmenu->rxTitle, ayMenu,
		    pmenu->pchTitle, pmenu->cchTitle, di);
#ifdef KANJI
		/* kana accelerator at start ? */
		if (fKanaAccel)
			CharOutAbs(axMenuMin + pmenu->rxTitle, ayMenu,
			    pmenu->chKanaAccel, di);
#endif
		}

#ifdef DEBUG
	/* special stuff if we want to redraw menubar while not idle,
		i.e. for the HELLO application.
	*/
	if (FMenuActive())
		HiliteMenuTitle(TRUE);
#endif /*DEBUG*/

	StopPublic();
	}

/*****************************************************************************/


STATIC VOID
SelectMenu(imenu)
/*
  -- select the specified menu (may be imenuNil)
  -- clears old menu title
  -- modifies mniCur.imenu
*/
WORD imenu;
	{
	Assert(mniCur.pmenuOpen == NULL);	/* no drop downs open */

	/* if we don't have a menubar -- get one !! */
	if (pmenubarCur == NULL)
		{
		SendMessageShort(pwndMenu, WM_MENUSTART);
		AssertSz(pmenubarCur != NULL, "WM_MENUSTART error");
		}

	if (imenu != mniCur.imenu)
		{
		/* close old */
		CloseMenuCur(TRUE);		/* close current */
		HiliteMenuTitle(FALSE);	/* & clear title */
		mniCur.imenu = imenu;
		mniCur.iitem = iitemNil;
		HiliteMenuTitle(TRUE);	/* hilite new title */
		}
	}



STATIC VOID
HiliteMenuTitle(fHilite)
/*
  -- hilite/unhilite the menu title "hilite" characters, for current menu
  -- do nothing if no current menu
  -- menu should not be open.
*/
BOOL fHilite;		/* hilite ? */
	{
	REGISTER AX ax;
	REGISTER PMENU pmenu;
	AX axRight;

	if (!FShowMenuBar() || mniCur.imenu == imenuNil)
		return;

	DrawThisWnd(NULL);

	Assert(mniCur.imenu != imenuNil);
	Assert(!FMenuOpen());
	MoveHardwareCursor(0, 0, FALSE);

	/* 1 character before & after */
	pmenu = &pmenubarCur->rgmenu[mniCur.imenu];
	ax = ((AX) pmenu->rxTitle) - daxBorder;
	axRight = ax + pmenu->cchTitle + 2;
	/* Pin hilite to edges of screen */
	if (pmenu->rxTitle == 0)
		ax = 0;
	if (axRight > axMax)
		axRight = axMax;

	FillArc(ax, ayMenu, axRight, ayMenu + 1, '\0',
	     (fHilite) ? (dmAttrOnly | isaMenuSelected) :
	      ((pmenu->fEnabled) ? (dmAttrOnly | isaMenu) :
				   (dmAttrOnly | isaDisabledMenuItem) ));
	ax = ((AX) pmenu->rxTitle) + (BYTE) pmenu->ichHilite;
	Assert(ax < axMax);	/* Hilited character must be on screen */
	/* only single width characters for accelerators */
	if (mniCur.fMenuMnem)
		FillArc(ax, ayMenu, ax + 1, ayMenu + 1, '\0',
		    (fHilite) ? (dmAttrOnly | isaMenuHiliteSel) :
		     (dmAttrOnly | isaMenuHilite));

	if (fHilite)
		SendMessage(pwndMenu, WM_MENUSELECT, pmenu->idMenu,
		    MAKELONG(pmenu, mmdMenu));
	}



STATIC VOID
ReportMenuInactive()
/*
  -- send a MENUSELECT message with NULL pmenuitem
  -- normally application will clear the help line
*/
	{
	Assert(mmdItem == 0);
	if (pwndMenu != NULL)
		SendMessageShort(pwndMenu, WM_MENUSELECT);
	}




STATIC VOID
OpenMenuCur()
/*
  -- open current menu (mniCur.imenu)
  -- all other menus must be closed
  -- turn of mnemonics in menu titles
  -- if imenuNil then do nothing
  -- if items, select first one
*/
	{
	REGISTER PMENU pmenu;
	AX axLeft, axRight;
#ifdef	DIALOG_NOSAVE
	AY ayBottom, ayTop;
#else
	AY ay, ayBottom, ayTop;
	WORD citem;
#endif

	Assert(mniCur.pmenuOpen == NULL);
	DrawThisWnd(NULL);
	HiliteMenuMnem(FALSE);

	if (mniCur.imenu == imenuNil)
		return;

	pmenu = mniCur.pmenuOpen = &pmenubarCur->rgmenu[mniCur.imenu];

	SendMessage(pwndMenu, WM_INITMENUPOPUP, pmenu->idMenu,
	    MAKELONG(pmenu, 0));	/* Must not enter dialogs */

	BeginDraw();

	if (pmenu->citem)
		{
#ifndef DIALOG_NOSAVE
		REGISTER PMENUITEM pmenuitem;
#endif	// DIALOG_NOSAVE
		WORD	cw;

		arcMenu.axLeft = axLeft = (AX) pmenu->rxTitle + daxMenuBox;
			/* to left side of box */
		arcMenu.axRight = axRight = (AX) pmenu->rxTitle +
		    pmenu->cchitemMax + 2;
			/* bord+gap+"text"+gap+bord */

		/* adjust for too near screen borders */
		if (axRight > axMac - daxShadow)
			{
			/* adjust for too large (too near right) */
			arcMenu.axLeft = axLeft = axLeft - (axRight - 
						(axMac - daxShadow));
			arcMenu.axRight = axRight = (axMac - daxShadow);
			}
		if (pmenu->rxTitle < -daxMenuBox)
			{
			/* adjust for too small (too near left) */
			arcMenu.axRight = axRight - axLeft;
			arcMenu.axLeft = 0;
			}

		arcMenu.ayTop = ayTop = ayMenu + 1;
			/* 1 for menu title */
		arcMenu.ayBottom = ayBottom = ayTop + pmenu->citem + 2;
			/* 2 for top and bottom sides of menu box */

		cw = (WORD) (ayBottom - ayTop + dayShadow) *
		    (WORD) (axRight - axLeft + daxShadow + daxDbcs * 2);
#ifdef SCREEN_FFONT
		if (fFontAvailable)
			cw *= 2;
#endif /*SCREEN_FFONT*/

#ifndef MENU_NOSAVE

		SaveArc(axLeft - daxDbcs, ayTop, axRight + daxShadow + daxDbcs,
		    ayBottom + dayShadow,
		    lpbMenu = LpbAllocWorkFar(cw * 2));

#endif	// MENU_NOSAVE

#ifdef	DIALOG_NOSAVE
		/* Hilite first item if not in mouse mode */
		if (!mniCur.fMouse)
			{
			mniCur.iitem = 0;
			}
		DrawMenuCur();
#else	// !DIALOG_NOSAVE
		FillArc(axLeft, ayTop, axRight, ayBottom, ' ',
		    DiNormal(isaEnabledMenuItem));
		DrawBoxArc(&boxSingle, &arcMenu, isaMenuBox,
			TRUE, TRUE, NULL);
		ShadowArc(&arcMenu);
		pmenuitem = PmenuitemOfPmenu(pmenu);
		citem = pmenu->citem;
		ay = ayTop + 1;
		while (citem--)
			{
			if (pmenuitem->fSeparator)
				{
				/* draw a separator */
				FillArc(axLeft + daxBorder, ay,
				    axRight - daxBorder, ay + dayBorder,
				    (ACHAR) chTopSide1,
				    DiNormal(isaMenuBox));
				CharOutAbs(axRight - daxBorder, ay,
				    (ACHAR) chMiddleRight1,
				     DiNormal(isaMenuBox));
				CharOutAbs(axLeft, ay, (ACHAR) chMiddleLeft1,
				    DiNormal(isaMenuBox));
				}
			else
				{
				DrawMenuItem(axLeft, ay,
				   (AX) axRight - daxBorder, pmenuitem);
				}
			ay++;
			pmenuitem++;
			}
		/* Hilite first item if not in mouse mode */
		if (!mniCur.fMouse)
			{
			mniCur.iitem = 0;
			HiliteItem(TRUE);
			}
#endif	// DIALOG_NOSAVE
		}
	else
		{
		/* no items => no mouse selection of items */
		arcMenu.ayTop = 0;
		arcMenu.ayBottom = 1;
		mniCur.iitem = iitemNil;
		}

	EndDraw();

	/* just to be sure */
	Assert(pmenu == mniCur.pmenuOpen);
	}

#ifdef	DIALOG_NOSAVE
STATIC VOID
DrawMenuCur()
	{
	WORD citem;
	REGISTER PMENUITEM pmenuitem;
	AX axLeft = arcMenu.axLeft;
	AX axRight = arcMenu.axRight;
	AY ayTop = arcMenu.ayTop;
	AY ayBottom = arcMenu.ayBottom;
	AY ay;

	if (mniCur.pmenuOpen == NULL)
		{
		HiliteMenuTitle(TRUE);
		return;
		}

	FillArc(axLeft, ayTop, axRight, ayBottom, ' ',
	    DiNormal(isaEnabledMenuItem));
	DrawBoxArc(&boxSingle, &arcMenu, isaMenuBox,
		TRUE, TRUE, NULL);
	ShadowArc(&arcMenu);
	pmenuitem = PmenuitemOfPmenu(mniCur.pmenuOpen);
	citem = mniCur.pmenuOpen->citem;
	ay = ayTop + 1;
	while (citem--)
		{
		if (pmenuitem->fSeparator)
			{
			/* draw a separator */
			FillArc(axLeft + daxBorder, ay,
			    axRight - daxBorder, ay + dayBorder,
			    (ACHAR) chTopSide1,
			    DiNormal(isaMenuBox));
			CharOutAbs(axRight - daxBorder, ay,
			    (ACHAR) chMiddleRight1,
			     DiNormal(isaMenuBox));
			CharOutAbs(axLeft, ay, (ACHAR) chMiddleLeft1,
			    DiNormal(isaMenuBox));
			}
		else
			{
			DrawMenuItem(axLeft, ay,
			   (AX) axRight - daxBorder, pmenuitem);
			}
		ay++;
		pmenuitem++;
		}
	HiliteItem(TRUE);
	}
#endif	// DIALOG_NOSAVE


STATIC VOID
CloseMenuCur(fMessage)
BOOL fMessage;	/* send WM_COMMAND message? */
/*
  -- close the body of current menu
  -- can be called if menu not open (do nothing)
*/
	{
	if (mniCur.imenu == imenuNil || mniCur.pmenuOpen == NULL)
		return;		/* not open */

	Assert(mniCur.pmenuOpen == &pmenubarCur->rgmenu[mniCur.imenu]);

#ifndef MENU_NOSAVE

	DrawThisWnd(NULL);
	if (mniCur.pmenuOpen->citem)
		{
#ifdef KANJI
		fRestoreDbcs = TRUE;
#endif	/*KANJI*/

		RestoreArc(arcMenu.axLeft - daxDbcs, arcMenu.ayTop,
		    arcMenu.axRight + daxShadow + daxDbcs,
		    arcMenu.ayBottom + dayShadow,
		    lpbMenu);
		FreeWorkFar(lpbMenu);

#ifdef KANJI
		fRestoreDbcs = FALSE;
#endif	/*KANJI*/

		}

	mniCur.pmenuOpen = NULL;
	mniCur.iitem = iitemNil;

#else	// MENU_NOSAVE
	mniCur.pmenuOpen = NULL;
	mniCur.iitem = iitemNil;

	ScreenRedraw();
#endif	// MENU_NOSAVE

	if (fMessage)
		SendMessage(pwndMenu, WM_COMMAND, mniCur.pmenuOpen->idMenu,
				MAKELONG(mniCur.pmenuOpen,mmdMenu));
	ReportMenuInactive();
	}



/********** MENU selection **********/


STATIC VOID
HiliteMenuMnem(fOn)
/*
  -- hilite or unhilite the menu mnemonics
  -- do nothing if menu is open
  -- update global state (mniCur.fMenuMnem)
*/
BOOL fOn;
	{
	REGISTER PMENU pmenu;
	REGISTER WORD imenu;
	WORD di;

	if (FMenuOpen())
		{
		/* menu is open, this should be a no op */
		Assert(mniCur.fMenuMnem == fOn);
		return;
		}

	if (!FShowMenuBar())
		return;

	DrawThisWnd(NULL);

	for (imenu = 0, pmenu = pmenubarCur->rgmenu;
	    imenu < pmenubarCur->cmenu;
	    imenu++, pmenu++)
		{
		AX ax = axMenuMin + pmenu->rxTitle + (BYTE) pmenu->ichHilite;

		if (imenu != mniCur.imenu)
			di = (fOn) ? (dmAttrOnly | isaMenuHilite) :
				( (pmenu->fEnabled) ? (dmAttrOnly | isaMenu) :
				 	(dmAttrOnly | isaDisabledMenuItem));
		else
			{
			di = (fOn) ? (dmAttrOnly | isaMenuHiliteSel) :
			   (dmAttrOnly | isaMenuSelected);
			}

		FillArc(ax, ayMenu, ax + 1, ayMenu + 1, '\0', di);
		}
	mniCur.fMenuMnem = fOn;
	}



STATIC BOOL
FMakeSelection()
/*
  -- attempt to make a selection
  -- if applicable send messages for menu selection
  -- valid selection closes menu and returns TRUE
  -- invalid selection (i.e. disabled item) optionally beeps,
	keeps menu open, and returns FALSE
  -- note : will set menu state to idle before returning TRUE
*/
	{
	WORD id;
	DWORD lParam;
	REGISTER PMENU pmenu = mniCur.pmenuOpen;
	
	Assert(mniCur.imenu != imenuNil);
	if (mniCur.iitem != iitemNil)
		{
		PMENUITEM pmenuitem = &(PmenuitemOfPmenu(pmenu)[mniCur.iitem]);
		if (!pmenuitem->fEnabled)
			{
			/* selection of disabled item */
			Beep();
			return FALSE;
			}

		id = pmenuitem->idItem;
		lParam = MAKELONG(pmenuitem, mmdItem);
		}
	else
		{
		id = pmenu->idMenu;	/* menu but no selection */
		lParam = MAKELONG(pmenu, mmdMenu);
		}

	/* valid selection : close menu - keep menu name hilited */
	CloseMenuCur(FALSE);
	/* send message while menu name hilited - the menu may change */
	mniCur.imenu = imenuNil;
	SendMessage(pwndMenu, WM_COMMAND, id, lParam);
	ReportMenuInactive();
	/* do both : unhilite menu title and redraw optionally changed bar */
	DrawMenubar();
	UpdateCursor();
	return TRUE;
	}



STATIC WORD
ImenuPickVk(vk)
/*
  -- Search for menu based on "hilite" character in menu title
  -- if found return imenu
  -- if not found, return imenuNil
*/
WORD vk;	/* virtual key of first character */
	{
	WORD imenu;
	REGISTER PMENU pmenu = pmenubarCur->rgmenu;
	
	for (imenu = 0; imenu < pmenubarCur->cmenu; imenu++, pmenu++)
		{
#ifndef KANJI
		if (FMatchVkCh(vk, *(pmenu->pchTitle + pmenu->ichHilite)))
#else
		if (FMatchVkCh(vk, fKanaAccel ? (char) pmenu->chKanaAccel :
		    *(pmenu->pchTitle + pmenu->ichHilite)))
#endif /*KANJI*/
			{
			/* go one */
			return imenu;
			}
		}
	return imenuNil;
	}



STATIC WORD
ImenuPickMsp(msp)
/*
  -- mouse is on menu title line
  -- return index of selected menu or imenuNil
*/
MSP msp;
	{
	REGISTER MENU *pmenu;
	REGISTER AX ax = msp.s.ax;
	WORD imenu;

	Assert(msp.s.ay == ayMenu);

	pmenu = pmenubarCur->rgmenu;
	
	for (imenu = 0; imenu < pmenubarCur->cmenu; imenu++, pmenu++)
		{
		if (ax + 1 >= (AX) pmenu->rxTitle &&
		    ax <= ((AX) pmenu->rxTitle + pmenu->cchTitle))
			{
			return imenu;
			}
		}
	return imenuNil;
	}




/********** MENUITEMS **********/

STATIC VOID
DrawMenuItem(axLeft, ay, axRight, pmenuitem)
/*
  -- output a menu item
  -- left justify the portion to the left of a tab
  -- right justify the portion after the tab
  -- output checkmark if on
  -- only called by OpenMenuCur().
*/
AX axLeft, axRight;
AY ay;
REGISTER PMENUITEM pmenuitem;
	{
	char * sz = SzItem(pmenuitem);
	WORD di = pmenuitem->fEnabled ?
	    DiNormal(isaEnabledMenuItem) :
	    DiNormal(isaDisabledMenuItem);
	AX ax = axLeft + rxMenuText;

#ifdef MENU_RIGHT_JUSTIFY
	REGISTER char * szT = sz;
	WORD cch;

	for (cch = 0; *szT != '\t' && *szT != '\0'; cch++)
		szT++;
	Assert(pmenuitem->ichHilite < cch);
	TextOutAbs(ax, ay, sz, cch, di);
#else
	TextOutAbs(ax, ay, sz, strlen(sz), di);
	Unreferenced(axRight);	/* right coordinate not used */
#endif

#ifdef KANJI
	/* kana accelerator at start ? */
	if (fKanaAccel)
		CharOutAbs(ax, ay, pmenuitem->chKanaAccel, di);
#endif /*KANJI*/

	/* select hilited character (if enabled) */
	if (pmenuitem->fEnabled)
		{
		ax += (BYTE) pmenuitem->ichHilite;
		FillArc(ax, ay, ax + 1, ay + 1, '\0',
		    (dmAttrOnly | isaMenuHilite));
		}

	if (pmenuitem->fChecked)
		CharOutAbs(axLeft + rxMenuMark, ay, chMenuMark, di);

#ifdef MENU_RIGHT_JUSTIFY
	/* output right aligned stuff if any */
	if (*szT != '\0')
		{
		cch = strlen(++szT);
		TextOutAbs(axRight - cch - 1, ay, szT, cch, di);
		}
#endif
	}



STATIC VOID
HiliteItem(fSelected)
/*
  -- highlight current menu item within current menu list
*/
BOOL fSelected;
	{
	if (mniCur.iitem != iitemNil)
		{
		REGISTER PMENUITEM pmenuitem;
		REGISTER ISA isa;
		AX ax;
		AY ay;

		Assert(mniCur.pmenuOpen != NULL && mniCur.pmenuOpen->citem != 0);
		Assert(mniCur.pmenuOpen == &pmenubarCur->rgmenu[mniCur.imenu]);

		DrawThisWnd(NULL);
		pmenuitem = &PmenuitemOfPmenu(mniCur.pmenuOpen)[mniCur.iitem];

		if (fSelected)
			isa = isaSelectedMenuItem;
		else
			isa = (ISA) (pmenuitem->fEnabled ?
			    isaEnabledMenuItem :
			    isaDisabledMenuItem);

		ay = arcMenu.ayTop + mniCur.iitem + 1;
		FillArc(arcMenu.axLeft + daxBorder, ay,
		    arcMenu.axRight - daxBorder,
		    ay + dayBorder, '\0', dmAttrOnly | isa);

		/* restore hilite character */
		if (pmenuitem->fEnabled)
			{
			ax = arcMenu.axLeft + rxMenuText + pmenuitem->ichHilite;
			FillArc(ax, ay, ax + 1, ay + 1,
			    '\0', fSelected ? (dmAttrOnly | isaItemHiliteSel) :
			     (dmAttrOnly | isaMenuHilite));
			}

		/* If Selected then update help line */
		if (fSelected)
			SendMessage(pwndMenu, WM_MENUSELECT, pmenuitem->idItem,
			    MAKELONG(pmenuitem, mmdItem));
		}
	}



STATIC BOOL
FSelectItem(iitem)
/*
  -- set specified item to be current selected item
  -- if item is valid, change current selection and return TRUE
  -- if item is invalid (separator), change to no selection, return FALSE
  -- return TRUE if selection made
  -- item may be beyond valid range, do wrapping here
*/
WORD iitem;
	{
	Assert(FMenuOpen());
	Assert(mniCur.pmenuOpen == &pmenubarCur->rgmenu[mniCur.imenu]);

	/* check for empty drop downs */
	if (mniCur.pmenuOpen->citem == 0)
		return TRUE;

	/* check for menu wrapping */
	if (iitem != imenuNil && iitem >= mniCur.pmenuOpen->citem)
		{
		/* perform wrap */
		if (iitem == (WORD) -1)	/* wrapped to -1 */
			iitem = mniCur.pmenuOpen->citem - 1;
		else
			{
			Assert(iitem == mniCur.pmenuOpen->citem);
			iitem = 0;
			}
		}

	Assert(iitem == iitemNil || iitem < mniCur.pmenuOpen->citem);

	if (iitem != mniCur.iitem)
		{
		HiliteItem(FALSE);

		if (PmenuitemOfPmenu(mniCur.pmenuOpen)[iitem].fSeparator)
			{
			mniCur.iitem = iitemNil;
			ReportMenuInactive();
			return FALSE;
			}
		else
			{
			/* real item : hilite even if disabled */
			mniCur.iitem = iitem;
			HiliteItem(TRUE);
			}
		}
	return TRUE;
	}



STATIC BOOL
FMatchItemVk(vk)
/*
  -- Search for menu item based on first character (using ichHilite)
  -- if found changed current selection
  -- if found and enabled : select item and return TRUE
  --  otherwise return FALSE
*/
WORD vk;
	{
	REGISTER PMENU pmenu = mniCur.pmenuOpen;
	WORD	citem;
	WORD	iitem;
	REGISTER PMENUITEM pmenuitem;
#ifdef ACCEL_MULTIPLE
	WORD	citemMatch;

	citemMatch = 0;
	pmenuitem = &(PmenuitemOfPmenu(pmenu)[0]);
	citem = pmenu->citem;
	while (citem--)
		{
#ifdef KANJI
		/* Kanji Accelerator matching */
		if (!pmenuitem->fSeparator &&
		    FMatchVkCh(vk, fKanaAccel ? (char) pmenuitem->chKanaAccel :
		    *(SzItem(pmenuitem) + pmenuitem->ichHilite)))
#else
		if (!pmenuitem->fSeparator &&
		    FMatchVkCh(vk, *(SzItem(pmenuitem) + pmenuitem->ichHilite)))
#endif
			citemMatch++;
		pmenuitem++;
		}
	if (citemMatch == 0)
		return FALSE;	/* no match */
	fOneOfMultiple = (citemMatch > 1);
#endif /*ACCEL_MULTIPLE*/

	citem = pmenu->citem;
	iitem = mniCur.iitem;
	pmenuitem = &(PmenuitemOfPmenu(pmenu)[++iitem]);

	while (citem--)
		{
		if (iitem >= pmenu->citem)
			{
			/* wrap to top */
			iitem = 0;
			pmenuitem = PmenuitemOfPmenu(pmenu);
			}
#ifdef KANJI
		/* Kanji Accelerator matching */
		if (!pmenuitem->fSeparator &&
		    FMatchVkCh(vk, fKanaAccel ? (char) pmenuitem->chKanaAccel :
		    *(SzItem(pmenuitem) + pmenuitem->ichHilite)))
#else
		if (!pmenuitem->fSeparator &&
		    FMatchVkCh(vk, *(SzItem(pmenuitem) + pmenuitem->ichHilite)))
#endif
			{
			/* found ! */
			return (FSelectItem(iitem) && pmenuitem->fEnabled);
			}

		pmenuitem++;
		iitem++;
		}
	return FALSE;	/* not found */
	}



STATIC BOOL
FSelectItemMsp(msp)
/*
  -- Mouse form to pick an item
  -- returns TRUE if picking an item (and changes item selection)
*/
MSP msp;
	{
	Assert(msp.s.ay != ayMenu);

	if (FInsideMenuMsp(msp.s.ax, msp.s.ay))
		{
		Assert(mniCur.pmenuOpen->citem != 0);
		FSelectItem(msp.s.ay - arcMenu.ayTop - 1);
		mniCur.fMouseOnTitle = FALSE;	/* selected something */
		return TRUE;
		}

	/* not selecting anything */
	HiliteItem(FALSE);
	mniCur.iitem = iitemNil;
	return FALSE;
	}



STATIC BOOL
FInsideMenuMsp(ax, ay)
/*
  -- return TRUE if inside Menu dropdown, or on menu title bar
*/
REGISTER AX ax;
REGISTER AY ay;
	{
	if (ay == ayMenu)
		{
		mniCur.fMouseOnTitle = TRUE;
		return TRUE;
		}
	if (!FMenuOpen())
		return FALSE;
	return (ay > arcMenu.ayTop &&
	    ay < arcMenu.ayBottom - 1 &&
	    ax >= arcMenu.axLeft &&
	    ax < arcMenu.axRight);
	}





/********** The Filter **********/


PRIVATE BOOL FARPRIVATE
MenuFilterProc(pmsg)
/*
  -- menu manager filter procedure
  -- returns true if message is to be filtered out
*/
REGISTER PMSG pmsg;  /* access pmsg-> with same speed as local auto vars */
	{
	REGISTER WORD kk;		/* Key bits + vk */
	MSP msp;
	BOOL fMenuAction;

	if (pwndCapture != NULL)
		return(FALSE);
	kk = HIWORD(pmsg->lParam);
	fMenuAction = FALSE;

	msp.lParam = pmsg->lParam;

	/* is it a valid (LEFT) menu mouse message ?? */
	if (pmsg->message >= WM_MOUSEFIRST && pmsg->message <= WM_LMOUSELAST &&
	    FShowMenuBar())
		{
		if ((pmsg->message == WM_LBUTTONDBLCLK ||
		    pmsg->message == WM_LBUTTONDOWN) && !mniCur.fMouse)
			{
			/* Menu Button */
			BOOL fInside = FInsideMenuMsp(msp.s.ax, msp.s.ay);

			if (!mniCur.fMouse && !fInside &&
			   (FMenuActive() || mniCur.fMenuMnem))
				{
				/* click not in drop down */
				SetIdleState();
				return FALSE; /* pass message through */
				}
			mniCur.fMouse |= fInside;
			}

		/* now see if we should do any mouse work */
		if (!mniCur.fMouse)
			return FMenuActive();	/* eat if menu active */

		if (msp.s.ay == ayMenu)
			{
			WORD imenuT;

			imenuT = ImenuPickMsp(msp);
			if (imenuT != imenuNil && !FMenuOpen())
				goto open_new_menu;
			else if (imenuT != mniCur.imenu)
				{
				CloseMenuCur(TRUE);
open_new_menu:
				mniCur.fMouseOnTitle = FALSE; /* selection */
				SelectMenu(imenuT);
				OpenMenuCur();
				}
			else if (FMenuActive())
				{
				/* clear any selection */
				Assert(FMenuOpen());
				FSelectItem(iitemNil);
				}
			/* re-send menu title message (for help) */
				if (mniCur.pmenuOpen->citem != 0)
			if (mniCur.pmenuOpen != NULL)
				SendMessage(pwndMenu, WM_MENUSELECT,
				    mniCur.pmenuOpen->idMenu,
				    MAKELONG(mniCur.pmenuOpen, mmdMenu));
			}
		else if (FMenuActive())
			{
			/* selecting an item (maybe) */
			if (!FSelectItemMsp(msp))
				ReportMenuInactive();
			}

		/* is he releasing the mouse button ?? */
		if (pmsg->message == WM_LBUTTONUP)
			{
			if (!FMenuActive())
				{
				/* do nothing (except cursor enable) */
				UpdateCursor();
				}
			else if (mniCur.iitem != iitemNil)
				{
				FMakeSelection();
				}
			else if (msp.s.ay == ayMenu)
				{
				/* selecting title - close or keep open */
				Assert(FMenuOpen());
				if (mniCur.fMouseOnTitle)
					{
					/* stay on title => close it */
					SetIdleState();
					}
				/* else : keep it open */
				else if (mniCur.pmenuOpen->citem != 0)
					{
					FSelectItem(0);
					}
				else
					{
					FMakeSelection();
					}
				}
			else
				SetIdleState();
			mniCur.fMouse = FALSE;
			}

		return TRUE;		/* eat it */
		}
	else if (mniCur.fMouse)
		{
		/* mouse control of the menu --> nothing gets through */
		return TRUE;
		}
#ifdef	MULTIPLE_ACTION
	else if ((pmsg->wParam == vkActionPrim ||
		  pmsg->wParam == vkActionSec) &&
		 (pmsg->wParam == VK_MENU) && 
		 (pmsg->message == WM_KEYUP))
#else	/* MULTIPLE_ACTION */
	else if (pmsg->wParam == VK_MENU && pmsg->message == WM_KEYUP)
#endif	/* MULTIPLE_ACTION */
		{
		/* convert keys to Menu Action events */
		if (fNonAltKey)
			{
			/* ignore it */
			if (!FMenuActive())
				HiliteMenuMnem(FALSE);
			return TRUE;
			}
		fMenuAction = TRUE;
		}
#ifdef	MULTIPLE_ACTION
	else if ((pmsg->wParam == vkActionPrim ||
		  pmsg->wParam == vkActionSec) &&
		 (pmsg->message == WM_CHAR))
		 {
		     fMenuAction = TRUE;
		 }   
#endif	/* MULTIPLE_ACTION */
	else if (pmsg->message == WM_CHAR)
		fNonAltKey = (BYTE) (pmsg->wParam != VK_MENU);

	/* allow all non-alt key shifted keys to slip by (if accelerators) */
	if (pmsg->message == WM_CHAR)
		{
		if (FTranslateAccelerator(pmsg->wParam, kk))
			return TRUE;	/* eat it */

#ifdef	MULTIPLE_ACTION
      		if ((!FMenuActive()) &&
		    (pmsg->wParam != vkActionPrim) &&
		    (pmsg->wParam != vkActionSec))
			return FALSE;	/* pass through if menu off */
		}
#else	/* ! MULTIPLE_ACTION */
		if (!(kk & KK_ALT) && !FMenuActive())
			return FALSE;	/* pass through if menu off */
		}
#endif	/* MULTIPLE_ACTION */

	if (!FMenuActive())
		{
		/* we are in idle - handle as fast as possible */
		Assert(mniCur.imenu == imenuNil);	/* no menu yet */

		if (fMenuAction)
			{
			/* Turn on first menu - don't open */
			SelectMenu(0);
			HiliteMenuTitle(TRUE);
			HiliteMenuMnem(TRUE);
			return TRUE;		/* eat it */
			}
		else if (pmsg->message == WM_CHAR)
			{
			/* a character */
#ifdef	MULTIPLE_ACTION
			if ((pmsg->wParam == vkActionPrim) ||
			    (pmsg->wParam == vkActionSec))
#else	/* MULTIPLE_ACTION */
			if (pmsg->wParam == VK_MENU)
#endif	/* MULTIPLE_ACTION */
				{
				HiliteMenuMnem(TRUE);
				return TRUE;	/* eat it */
				}

			if (kk & KK_ALT)
#ifdef	MULTIPLE_ACTION
				{
				WORD imenuT;
				/* otherwise a menu selection */
				if ((imenuT = ImenuPickVk(kk & KK_VK))
				    != imenuNil)
					{
					/* if we don't have a menubar -- get one !! */
					if (pmenubarCur == NULL)
					    SendMessageShort(pwndMenu, WM_MENUSTART);
					/* open that menu */
					SelectMenu(imenuT);
					OpenMenuCur();
					}
				else
					return FALSE;
				return TRUE;		/* eat it */
			    	}
#else	/* !MULTIPLE_ACTION */
			        {
				WORD imenuT;


				/* if we don't have a menubar -- get one !! */
				if (pmenubarCur == NULL)
					SendMessageShort(pwndMenu, WM_MENUSTART);
				/* otherwise a menu selection */
				if ((imenuT = ImenuPickVk(kk & KK_VK))
				    != imenuNil)
					{
					/* open that menu */
					SelectMenu(imenuT);
					OpenMenuCur();
					}
				else
					Beep();
				return TRUE;		/* eat it */
				}
#endif	/* MULTIPLE_ACTION */

			return FALSE;	/* pass through */
		        }

		return FALSE;	/* let the message pass */
		}

	/* not in idle !!!! */
	Assert(mniCur.imenu != imenuNil);
	AssertSz(pmenubarCur != NULL, "processing without a menu bar");

#ifdef DUAL
	/* if we get a null message while processing the menu, we are
	* therefore in an idle loop and should go to sleep for DOS 5
	*/
	if (fProtectMode && pmsg->message == WM_NULL)
		{
		SendMessageShort(pwndMenu, WM_MENUIDLE);
		DosSemWait(hsemaMessage, -1L);
		return TRUE;		/* eat the message */
		}
#else /*!DUAL*/
#ifdef DOS5
	/* if we get a null message while processing the menu, we are
	* therefore in an idle loop and should go to sleep for DOS 5
	*/
	if (pmsg->message == WM_NULL)
		{
		SendMessageShort(pwndMenu, WM_MENUIDLE);
		DosSemWait(hsemaMessage, -1L);
		return TRUE;		/* eat the message */
		}
#endif
#endif /*!DUAL*/

	if (fMenuAction)
		{
		/* Menu Action */
		if (FMenuOpen())
			{
			PMENU pmenu;
			/* close menu */
			CloseMenuCur(TRUE);
			HiliteMenuMnem(TRUE);	/* back to menu browse */
			/* update the help */
			pmenu = &pmenubarCur->rgmenu[mniCur.imenu];
			SendMessage(pwndMenu, WM_MENUSELECT, pmenu->idMenu,
			    MAKELONG(pmenu, mmdMenu));
			}
		else
			{
			/* go back to idle */
			SetIdleState();
			}
		}
	else if (pmsg->message == WM_CHAR)
		{
		WORD imenuT;
		BOOL fWasOpen;

		/* undo repeat before processing */
		UndoRepeat(pmsg->wParam, pmsg->lParam);

		imenuT = mniCur.imenu;

#ifdef	MULTIPLE_ACTION
		if (pmsg->wParam == vkActionPrim ||
      			pmsg->wParam == vkActionSec)
		      return(TRUE);

		if (pmsg->wParam == vkCancelPrim || pmsg->wParam == vkCancelSec) {
		    SetIdleState();
		    return TRUE;
		}
#endif	/* MULTIPLE_ACTION */

		/* Cases : similar whether menu is open or not */
		switch (pmsg->wParam)
			{
		default:
			break;		/* drop out & do second set of cases */

#ifndef	MULTIPLE_ACTION
		case LOBYTE(VK_ESCAPE):	/* escape character */
			SetIdleState();
			return TRUE;
#endif	/* !MULTIPLE_ACTION */

		case VK_LEFT:
			imenuT -= 2;
			/* fall through to right */
		case VK_RIGHT:
			imenuT++;	/* right +1, left -2+1 == -1 */
			/* check for wrap */
			if (imenuT >= pmenubarCur->cmenu)
				{
				if (imenuT == (WORD) -1) /* wrapped */
					imenuT = pmenubarCur->cmenu - 1;
				else
					{
					Assert(imenuT == pmenubarCur->cmenu);
					imenuT = 0;
					}
				}
			/* select new menu */
			fWasOpen = FMenuOpen();
			BeginDraw();
			CloseMenuCur(TRUE);
			ReportMenuInactive();
			HiliteMenuTitle(FALSE);
			SelectMenu(imenuT);
			if (fWasOpen)
				OpenMenuCur();
			EndDraw();
			return TRUE;

#ifndef	MULTIPLE_ACTION
		case VK_MENU:
			return TRUE;
#endif	/* !MULTIPLE_ACTION */

		case VK_HELP_KEY:
			SendMenuHelp(kk);
			MoveHardwareCursor(0, 0, FALSE);
			return TRUE;
			}

		/* cases which are different whether FMenuOpen() or not */
		if (!FMenuOpen())
			{
			/* Menu not open, let's try and open one */

			switch (pmsg->wParam)
				{
			default:
				/* select menu */
				if ((imenuT = ImenuPickVk(pmsg->wParam))
				    != imenuNil)
					{
					SelectMenu(imenuT);
					OpenMenuCur();
					}
				else
					Beep();	/* bad choice */
				break;

			case LOBYTE(VK_RETURN):
			case VK_UP:
			case VK_DOWN:	/* same as up */
				/* Open the current menu */
				OpenMenuCur();
				break;
				}
			}
		else
			{
			/* Menu open, keys effect item selection */
			WORD iitemT = mniCur.iitem;

			switch (pmsg->wParam)
				{
			default:
				/* select item */
				if (!FMatchItemVk(pmsg->wParam))
					{
					/* bad key */
					Beep();
					break;
					}
#ifdef ACCEL_MULTIPLE
				if (fOneOfMultiple)
					break;
#endif /*ACCEL_MULTIPLE*/
				/* fall through to accept */
			case LOBYTE(VK_RETURN):
				FMakeSelection();
				break;

			case VK_UP:
			case VK_DOWN:
				/* previous / next menu item */
				do
					{
					if (pmsg->wParam == VK_UP)
						iitemT--;
					else
						iitemT++;
					}
				while (!FSelectItem(iitemT));
				}
			}
		}
	return TRUE;	/* normally eat */
	}



STATIC VOID
SetIdleState()
/*
  -- jump to idle state
*/
	{
	/* do it all -- all routines handle nil cases */
	CloseMenuCur(TRUE);
	HiliteMenuTitle(FALSE);
	mniCur.imenu = imenuNil;
	HiliteMenuMnem(FALSE);
	ReportMenuInactive();
	mniCur.fMouse = FALSE;
	UpdateCursor();
	}



/********** Utilities **********/


STATIC BOOL
FTranslateAccelerator(vk, kk)
/*
  -- check to see if key "vk" should be treated as an accelerator
  -- send 2 messages if it is an accelerator (DO NOT POST!!!) and return TRUE
  -- return FALSE if not translated
*/
WORD vk;
WORD kk;
	{
	REGISTER MPVKEYID *pmpvkeyid = pmenubarCur->rgmpvkeyid;
	WORD vkeyCur, vkeyFind;

	/* look for correct "VKEY" value & proper shift states */
	vkeyFind = VkeyOfVkKk(vk, kk & (KK_ALT | KK_CONTROL | KK_SHIFT));

	while ((vkeyCur = pmpvkeyid->vkey) != 0)
		{
		if (vkeyCur == vkeyFind)
			{
			WORD idItem = pmpvkeyid->idItem;
			PMENUITEM pmenuitem = FindMenuItem(idItem);
			
			/* found an accelerator */
			if (FMenuActive())
				SetIdleState();

			if (pmenuitem != NULL)
				{
				SendMessage(pwndMenu, WM_INITMENUPOPUP,
				    pmenuFound->idMenu, MAKELONG(pmenuFound, 1));
				if (!pmenuitem->fEnabled)
					return TRUE;
				}
			/* send item message even if not with menu item */
			SendMessage(pwndMenu, WM_COMMAND, idItem,
			    MAKELONG(pmenuitem, mmdAccel));

			return TRUE;
			}
		else
			pmpvkeyid++;
		}
	return FALSE;
	}



STATIC BOOL
FMatchVkCh(vk, chMenu)
/*
  -- return TRUE if virtual key "vk" matches matches menu character "ch"
  -- (i.e. vk will be Upper case ASCII, menu char may be upper or lower case)
  -- for KANJI -- also check the alternate KANA/ROMAN key
*/
WORD vk;
char chMenu;
	{
	char ch = (char) LOBYTE(vk);

	if (vk >= 'a' && vk <= 'z')
		ch -= ('a' - 'A');
	else if ((unsigned) ch > 0x7f)
		ch = ChUpperFromChExt(ch);

	if (chMenu >= 'a' && chMenu <= 'z')
		chMenu -= ('a' - 'A');
	else if ((unsigned) chMenu > 0x7f)
		chMenu = ChUpperFromChExt(chMenu);

#ifdef KANJI
	if (ch != chMenu)
		{
		/* possibly the alternate character on that key -- try it */
		ch = ChAlternateKeytop(ch);
		}
#endif /*KANJI*/
	return(chMenu == ch);
	}



STATIC char *
SzItem(pmenuitem)
/*
  -- return the text of the menu item
*/
REGISTER PMENUITEM pmenuitem;
	{
	return (pmenuitem->fHandle ? *(pmenuitem->u.pszItem) :
	    pmenuitem->u.szItem);
	}



STATIC VOID
SendMenuHelp(kk)
/*
  -- send menu help message
*/
WORD	kk;
	{
	/* process HELP */
	WORD imenuSave;

	/* save old state, turn off menu for the help portion */
	imenuSave = mniCur.imenu;
	Assert(imenuSave != imenuNil);
	mniCur.imenu = imenuNil;

	if (mniCur.iitem != iitemNil)
		{
		PMENUITEM pmenuitem;
		Assert(FMenuOpen());

		pmenuitem = &PmenuitemOfPmenu(mniCur.pmenuOpen)[mniCur.iitem];
		Help(hemMenuItem, pmenuitem->idItem, pmenuitem, kk);
		}
	else
		{
		PMENU pmenu;

		pmenu = &pmenubarCur->rgmenu[imenuSave];
		Help(hemMenu, pmenu->idMenu, pmenu, kk);
		}
	mniCur.imenu = imenuSave;
#ifdef	DIALOG_NOSAVE
	DrawMenuCur();
#endif
	}




#ifdef MENU_UTILS
VOID FARPUBLIC
OpenMenu(idMenu)
/*
  -- application wants a menu open
*/
WORD idMenu;	/* id of menu to open */
	{
	REGISTER PMENU pmenu;
	WORD imenu;

	Assert(mniCur.imenu == imenuNil);	/* must be closed */

	for (imenu = 0, pmenu = pmenubarCur->rgmenu;
	    imenu < pmenubarCur->cmenu;
	    pmenu++, imenu++)
		{
		if (pmenu->idMenu == idMenu)
			{
			/* found it */
			SelectMenu(imenu);
			OpenMenuCur();
			fNonAltKey = FALSE;	/* allow up transition */
			return;
			}
		}
	AssertSz(FALSE, "Invalid call to OpenMenu()");
	}
#endif /*MENU_UTILS*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\meditasm.asm ===
;*      SCCSWHAT( "@(#)meditasm.asm     1.6 88/04/22 19:47:41   " ) */
;*
;*      COW : Character Oriented Windows
;*
;*      meditasm.inc : Multi-line edit manager main ASM file
;*      * REVIEW : these should be cleaned up.

        page    ,132
        TITLE   editmgr
        NAME    editmgr

SILENT = 1

        .xlist
        include user.inc

IFDEF EDIT_FULLMGR      ;(entire file)

        include cwproc.inc                      ;* CW procedures
        include uevent.inc                      ;* for messages
        include uisa.inc                        ;* for colors
        include uscroll.inc                     ;* for scroll messages
        include vkey.inc                        ;* for VK_ values
        include uscreen.inc                     ;* for draw modes
        include uedit.inc                       ;* for EN_ values
        include inmou.inc                       ;* for MK_ values
        include inkbd.inc                       ;* for KK_ values

        include util.inc

        include editmgr.inc             ;* REVIEW danger (this is public !!)
        include text.inc                ;* REVIEW (this entire interface)

        .list
        .sall

IFNDEF COW_SWAPPED
?win = 0
?cow = 0
ENDIF ;!COW_SWAPPED

TRUE            equ     01h
FALSE           equ     00h

sBegin DATA
    assumes ds,DGROUP

DEBPUBLIC       <clnCur, ldCur, fPasteOk, fInsertMode>
clnCur          dw      0

externB         ldEMScratch
ldCur           ld      <>

fPasteOk        DB      00H
fInsertMode     db      01H

ifdef KANJI
fCharIsDbcs     db      00H
externB         fReverse
endif

DEBPUBLIC       <pwndEditCur, cLinesCur, cColumnsCur, CurattrCur>
pwndEditCur     DW      00H
cLinesCur       DW      00H
cColumnsCur     DW      00H
CurattrCur      DW      isaBackground

DEBPUBLIC       <shiftWidth, tabStops, fResetAnchor>
shiftWidth      DW      01H
tabStops        DW      08H
fResetAnchor    DB      00H

DEBPUBLIC       <emFlags, emState>
;Global editmgr state flags
emFlags         db      00H     ;modified by EMF_xxx

;Local editmgr state flags
emState         db      00H     ;modified by EF_xxx
                                ;modified by ES_xxx
EF_TRACKING_MOUSE       equ     20H
EF_IN_WINDOW            equ     40H
EF_WORD_SELECTING       equ     80H

DEBPUBLIC       <pefCur, fRefreshScreen, hBuffer>
        EVEN
pefCur          dw      0

        EVEN
fRefreshScreen  db      0
hBuffer dw      0

DEBPUBLIC       <ipCur, ipStart, ipAnchor, ipAnchorStart, pdCur>
        EVEN
ipCur           ip      <>
ipStart         ip      <>
ipAnchor        ip      <>
ipAnchorStart   ip      <>
pdCur           pd      <>

EditMgrDoCharState      dw      User_EditOFFSET EMDC_InitialState
chEditMgrState  db      0

ifdef   EDIT_USE_TABLES
SecondDispatch  dw      0               ;* Current Secondary dispatch table
endif   ; EDIT_USE_TABLES

sb      struc
        sbfMultiLine    db      0
        sb_cb           dw      0
sb      ends

DEBPUBLIC       <_scrap>
_scrap          sb      <>
ifndef  PROJECT_QB
sb_buffer       db      MAXCHARS dup(?) ; NEAR massive buffer
endif   ;PROJECT_QB

DEBPUBLIC       <rgLineAttr0, rgLineAttr1, rgLineAttr2, rgLineAttr3>
rgLineAttr0     LINEATTR<0,0>
rgLineAttr1     LINEATTR<0,0>
rgLineAttr2     LINEATTR<0,0>
rgLineAttr3     LINEATTR<0,0>

pfnFilterSave   dw      0


;;
;; a-emoryh - Include cmwSwitches (from ..\..\..\qb5\ir\init.asm), so we can
;;      enable ES_NOSELECT when in QHelp mode.  Existing behavior is unaltered
;;      in any other modes.
;;
externW cmdSwitches

;; a-emoryh:
;; This must match up with the define in ..\..\..\qb\hd\ui.inc
;;
CMD_SW_QHELP equ 0800h          ;/QHELP switch found


sEnd DATA

ifdef   PROJECT_QB
sBegin  FAR_PRESERVED
DEBPUBLIC       <sb_buffer>
sb_buffer       db      MAXCHARS dup(?) ; FAR massive buffer
sEnd    FAR_PRESERVED
endif   ;PROJECT_QB

        externFP DrawToggles

IFDEF   KANJI
        externFP FIsDbcsChar
        externFP PchPrevDbcs
        externFP PchNextDbcs
ENDIF   ; KANJI

IFDEF   KK_UNIT
        externFP DisplayKKBuf
ENDIF   ; KK_UNIT

sBegin USER_EDIT
Assumes cs,USER_EDIT
Assumes ds,DGROUP
Assumes ss,DGROUP

;*      * REVIEW : these should be broken up
IFDEF   KANJI
        include qbj\editmgr1.asm
        include qbj\editmgr2.asm
ELSE    ; !KANJI
        include editmgr1.asm
        include editmgr2.asm
ENDIF   ; KANJI

sEnd USER_EDIT

ENDIF; EDIT_FULLMGR (entire file)

        END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\overlap.c ===
/*
	COW : Character Oriented Windows

	overlap.c  : Overlapping Window Support

*/


#define COW
#include <cow.h>

#define WINDOW
#include <uwindow.h>
#include <uevent.h>
#include <umenu.h>
#include <uisa.h>
#include <uscreen.h>
#include <vkey.h>
#include <kkeyboar.h>
#include <kinput.h>

#include "event.h"
#include "screen.h"
#include "util.h"
#include "dialog.h"
#include "window.h"
#include "shadow.h"
#include "overlap.h"


#ifdef WINDOW_OVERLAP	/* entire file */

extern void MemSetW(WORD, WORD, WORD, WORD);
extern PWND pwndClip;

/* forward */
STATIC VOID ThinkWindowAndSiblings(PWND);
STATIC BOOL FAllocDragSave(void);
STATIC VOID InitDragRrc(PWND);
STATIC VOID SaveDragRrc(void);
STATIC VOID RestoreDragRrc(void);
STATIC VOID DisplayDrag(void);
STATIC VOID EndDrag(void);
STATIC BOOL FAdjustDragRrc(int *, int *);


PRIVATE BOOL fDragging = FALSE;	/* am moving a window */
PRIVATE OWDS owds;		/* current window drag status */
				/* is valid only if fDragging == TRUE */
/*
  -- OWDF's contain the overlapping window drag flags
  -- rgowdf contains the initial settings for when a mouse clicks
          on the window.
  -- owdfKeyboardMove/Size contain the initial settings for keyboard
          moves and sizes
  -- format: { fMouse, fButton, fOutline, fXDrag, fYDrag, fEscapeMove, message}
*/
PRIVATE OWDF rgowdf[] =
	{
		{ 1, 1, 0, 0, 0, 0, WM_CLOSE },	/* top left corner */
		{ 1, 0, 1, 0, 0, 0, WM_MOVE },  /* top side */
		{ 1, 1, 0, 0, 0, 0, WM_ZOOM },	/* top right corner */
		{ 1, 0, 1, 0, 0, 0, WM_MOVE },	/* left side */
		{ 0, 0, 0, 0, 0, 0, 0 },	/* middle */
		{ 1, 0, 1, 1, 0, 0, WM_SIZE },	/* right side */
		{ 1, 0, 1, 0, 0, 0, WM_MOVE },	/* bottom left corner */
		{ 1, 0, 1, 0, 1, 0, WM_SIZE },	/* bottom side */
		{ 1, 0, 1, 1, 1, 0, WM_SIZE }	/* bottom right corner */
	};

PRIVATE OWDF owdfKeyboardMove = { 0, 0, 1, 0, 0, 0, WM_MOVE };
PRIVATE OWDF owdfKeyboardSize = { 0, 0, 1, 1, 1, 0, WM_SIZE };

PRIVATE PWND pwndCur;		/* current drawing window */
PRIVATE WORD psOverlap;		/* overlapping window table */

VOID FARPUBLIC
AddChildHead(pwndParent, pwndChild)
/*
  -- add child to head of child list
*/
PWND pwndParent, pwndChild;
	{
	StartPublic();

	Assert(pwndParent != NULL && pwndChild != NULL);

	pwndChild->pwndSibling = pwndParent->pwndChild;
	pwndChild->pwndParent = pwndParent;
	pwndParent->pwndChild = pwndChild;
	if (pwndParent->style & WS_CLIPOUT)
		{
		pwndChild->style |= WS_CLIPOUT;
		ClipoutWindowAndSiblings(pwndChild->pwndChild);
		}
	StopPublic();
	}

VOID FARPRIVATE
ClipoutWindowAndSiblings(pwnd)
/*
  -- pwnd inherits the clipout type along with its children
*/
PWND	pwnd;
	{

	while (pwnd != NULL)
		{
		pwnd->style |= WS_CLIPOUT;
		ClipoutWindowAndSiblings(pwnd->pwndChild);
		pwnd = pwnd->pwndSibling;
		}
	}



BOOL FARPUBLIC
FIsTopWindow(pwnd)
PWND	pwnd;
	{
	StartPublic();
	ReturnPublic(pwnd->pwndSibling == NULL, BOOL);
	}

PWND FARPUBLIC
PwndGetTopWindow(pwnd)
PWND	pwnd;
	{
	StartPublic();
	while (pwnd->pwndSibling != NULL)
		pwnd = pwnd->pwndSibling;
	ReturnPublic(pwnd, PWND);
	}

VOID FARPUBLIC
AddChildTail(pwndParent, pwndChild)
PWND pwndParent, pwndChild;
/*
  -- add child to tail of child list
*/
	{
	StartPublic();
	PWND pwndCur, pwndPrev;

	Assert(pwndParent != NULL && pwndChild != NULL);

	if ((pwndPrev = pwndParent->pwndChild) == NULL)
		pwndParent->pwndChild = pwndChild;
	else
		{
		while ((pwndCur = pwndPrev->pwndSibling) != NULL)
			pwndPrev = pwndCur;
		pwndPrev->pwndSibling = pwndChild;
		}
	pwndChild->pwndParent = pwndParent;
	if (pwndParent->style & WS_CLIPOUT)
		{
		pwndChild->style |= WS_CLIPOUT;
		ClipoutWindowAndSiblings(pwndChild->pwndChild);
		}
	StopPublic();
	}


VOID FARPRIVATE
DrawThisWndProc(pwnd)
REGISTER PWND pwnd;
/*
  -- sets the current window for clipping purposes
  -- NULL means no overlap clipping
*/
	{
	if (!(pwnd->style & WS_CLIPOUT) || !(psOverlap))
		{
		/* window isn't clipout type or there is no overlap table */
		pwndCur = NULL;
		return;
		}
	pwndCur = pwnd;
	}
	


STATIC VOID
ThinkWindowAndSiblings(pwnd)
REGISTER PWND pwnd;
/*
  -- fills the overlap table for pwnd and its children
  -- the overlap table is an array that maps screen positions onto the
	window that is in the foreground at a given position
  -- this is accomplished by walking through the tree and filling the
	table for each window.  hence the window that is lower in the
	tree has higher priority and overwrites window that are higher.
*/
	{
	while (pwnd != NULL)
		{
		WORD	off;			/* pointer to array position */
		AY	ay;
		ARC	arc;
		WORD	cwRow;			/* Count of words in each row */

		if ((pwnd->pwndParent != NULL) && (pwnd->style & WS_CLIPOUT))
			{
			if ((pwnd->style & WS_TYPE) == WS_SCROLL)
				{
				Assert(pwnd->pwndParent->pwndParent != NULL);
				IntersectRect((PRRC) &arc,
					 (PRRC) &pwnd->arcWindow, (PRRC)
				    &pwnd->pwndParent->pwndParent->arcClipping);
				}
			else
				{
				IntersectRect((PRRC) &arc,
					(PRRC) &pwnd->arcWindow,
					(PRRC) &pwnd->pwndParent->arcClipping);
				}
			}
		else
			arc = pwnd->arcWindow;

		off = (arc.ayTop * axMac + arc.axLeft) * sizeof(PWND);
		cwRow = arc.axRight - arc.axLeft;

		if (cwRow != 0)
			{
			/* Now simply work through each row */
			for (ay = arc.ayTop; ay < arc.ayBottom; ay++)
				{
				Assert(sizeof(PWND) == sizeof(WORD));
				/* otherwise this won't work */
				MemSetW(psOverlap, off,(WORD)pwnd,cwRow);
				off += axMac * sizeof(PWND);
				}
			}
		ThinkWindowAndSiblings(pwnd->pwndChild);
		pwnd = pwnd->pwndSibling;
		}
	}




VOID FARPUBLIC
RethinkDisplay()
/*
  -- recalculate overlap table
*/
	{
	StartPublic();

	/* first fill in base windows */
	if (psOverlap != 0)
		MemSetW(psOverlap, 0, NULL, axMac * ayMac);

	ThinkWindowAndSiblings(pwndRoot);

	StopPublic();
	}


VOID FARPUBLIC
RedrawDamagedRegions()
/*
  -- This function will redraw only the damaged regions of the screen
  -- Especially after a window has been moved/Deleted/ etc.
*/
	{
	StartPublic();

#ifdef LATER
    -- Put optimizer in here
#endif /* LATER */

	RethinkDisplay();   /* For now just rethink display on draw */
	DrawWindow(NULL);   /* All windows */

	StopPublic();
	}


VOID FARPUBLIC
DrawOverlapShadow(pwnd)
PWND	pwnd;
/*
  -- does a shadow for an overlapping window
*/
	{
	StartPublic();
	AX	daxShadowSave = daxShadow;

	Assert(pwnd->pwndParent != NULL);

	pwndClip = pwnd->pwndParent;
	DrawThisWnd(pwnd->pwndParent);
	ShadowArc(&pwnd->arcWindow);
	daxShadow /= 2;
	DrawThisWnd(NULL);
	ShadowArc(&pwnd->arcWindow);
	daxShadow = daxShadowSave;
	pwndClip = NULL;

	StopPublic();
	}


BOOL FARPUBLIC
FWindowToTop(pwnd)
PWND pwnd;
/*
  -- bring window to tail of child list
*/
	{
	StartPublic();
	PWND pwndParent = pwnd->pwndParent;
	PWND pwndOldTop = PwndGetTopWindow(pwnd);

	Assert(pwndParent != NULL && pwnd != NULL);

	if(SendMessage( pwndOldTop, WM_ACTIVATE, FALSE, 0L))
		{
		if(SendMessage(pwnd, WM_ACTIVATE, TRUE, 0L))
			{
			RemoveChild(pwnd);
			AddChildTail(pwndParent, pwnd);
			ThinkWindowAndSiblings(pwndOldTop);
			DrawWindow(pwndOldTop);
			DrawWindow(pwnd);
			UpdateCursor();
			ReturnPublic(TRUE,BOOL);
			}
		}

	ReturnPublic(FALSE,BOOL);
	}





BOOL FARPUBLIC
FMoveSizeWithKeyboard(pwnd,fMove)
PWND	pwnd;
BOOL	fMove;		/* true move false size */
/*
  -- Moves or sizes the window with the cursor
*/
	{
	StartPublic();
	MSG	msg;
	PWND	pwndRootOld = pwndRoot;
	PWND	pwndFocusOld = pwndFocus;
	PWND	pwndCaptureOld = pwndCapture;
	PFFN_FILTER	pfnFilterOld = pfnFilter;

	AssertSz(((pwnd->style & WS_CLIPOUT) && (pwnd->style & WS_OVERLAP)),
			"can only move overlap windows");

	Assert(!fDragging);

	if (!FIsTopWindow(pwnd))
		{
		if (!FWindowToTop(pwnd))
			ReturnPublic(FALSE,BOOL);
		}

	if (fMove)
		owds.owdf = owdfKeyboardMove;
	else
		owds.owdf = owdfKeyboardSize;

	owds.pwndMoving = pwnd;
	owds.pwndBackground = pwnd->pwndParent;

	if (!FAllocDragSave()) ReturnPublic(FALSE,BOOL);

	InitDragRrc(pwnd);
	fDragging = TRUE;	/* we are dragging and owds is valid */
	SaveDragRrc();
	DisplayDrag();

	pfnFilter = DummyFilter;
	pwndRoot = NULL;	/* set stuff to null so mouse input 
				   doesn't muck us up */
	pwndFocus = NULL;
	pwndCapture = NULL;
	UpdateCursor();

	/* we don't return control to the application until we're
	   done dragging */

	while(fDragging)
		{
		PollKeyboard();

		while (PeekMessage(&msg))
			DispatchMessage(&msg);
		}

	pfnFilter = pfnFilterOld;
	pwndRoot = pwndRootOld;
	pwndFocus = pwndFocusOld;
	pwndCapture = pwndCaptureOld;

	EndDrag();

	if (owds.owdf.fEscapeMove)
		{
		owds.owdf.fEscapeMove = 0;
		ReturnPublic(FALSE,BOOL);
		}

	UpdateCursor();
	ReturnPublic(TRUE,BOOL);
	}



BOOL PASCAL
OverlapFilter(pmsg)
PMSG	pmsg;
/*
  -- Does handling for overlapping windows
*/
	{
	AX		ax;		/* The Abs position of event */
	AY		ay;		/* The Abs position of event */
	short		iZoneX,iZoneY;	/* Location inside the window */
	PWND		pwnd = pmsg->pwnd;

	ax = LOBYTE(HIWORD(pmsg->lParam));        /* Get x, y position */
	ay = HIBYTE (HIWORD(pmsg->lParam));

	switch (pmsg->message)
		{
	case WM_LBUTTONDOWN:
		if (fDragging)
			return(FALSE);
		if (!(pwnd->style & WS_CLIPOUT))
			return(FALSE);

			/*
			 * find the overlapping window that we have
			 * clicked upon and then bring it to the top
			 * if it is not already there
			*/
			{
			PWND	pwndNewTop;

			pwndNewTop = pwnd;
			while (!(pwndNewTop->style & WS_OVERLAP)
					&&(pwndNewTop != NULL))
				pwndNewTop = pwndNewTop->pwndParent;
			if ((pwndNewTop == NULL) || (!pwndNewTop->fEnabled))
				 return(FALSE);
			if (!FIsTopWindow(pwndNewTop))
				{
				if (!FWindowToTop(pwndNewTop)) return(FALSE);
				}
			}

		if (!(pwnd->style & WS_OVERLAP))
			return(FALSE);

		/* (iZoneY * 3 + iZoneX) yields:
		 *  0 - Top left corner		*  1 - Top side
		 *  2 - Top right corner	*  3 - Left side
		 *  4 - middle of window	*  5 - Right side
		 *  6 - Bottom left corner	*  7 - Bottom side
		 *  8 - Bottom right corner
		 */

		iZoneY = (ay == pwnd->arcWindow.ayTop) ? 0 :
			 ((ay == pwnd->arcWindow.ayBottom-1) ? 2 : 1);
		iZoneX = (ax == pwnd->arcWindow.axLeft) ? 0 :
			 ((ax == pwnd->arcWindow.axRight-1) ? 2 : 1);

		if (iZoneY * 3 + iZoneX == 4)  /* not on the border */
			return(FALSE);

		owds.owdf = rgowdf[iZoneY * 3 + iZoneX];

		owds.pwndMoving = pwnd;
		owds.pwndBackground = pwnd->pwndParent;

		if (!FAllocDragSave()) return(FALSE);

		SetCapture (pwnd);  /* we want the mouse captured */
		owds.ax = ax;
		owds.ay = ay;
		fDragging = TRUE;	/* we are dragging -> owds is valid */
		InitDragRrc(pwnd);
		SaveDragRrc();
		DisplayDrag();
		return(TRUE);


	case WM_MOUSEMOVE:
		/* if we're not dragging or not dragging due to mouse */
		if ((!fDragging)||(!owds.owdf.fMouse))
			return (FALSE);

		{
		int	dax, day;
		PWND	pwndParent = pwnd->pwndParent;

		ax = (AX) max((int)ax, (int)pwndParent->arcClipping.axLeft);
		ay = (AY) max((int)ay, (int)pwndParent->arcClipping.ayTop);
		ax = (AX) min((int)ax, (int)pwndParent->arcClipping.axRight -1);
		ay = (AY) min((int)ay, (int)pwndParent->arcClipping.ayBottom-1);
		dax = ax - owds.ax;
		day = ay - owds.ay;

		if (FAdjustDragRrc(&dax, &day))
			{
			if (owds.owdf.fOutline)
				{
				owds.ax = (AX) ((int) owds.ax + dax);
				owds.ay = (AY) ((int) owds.ay + day);
				}
			SaveDragRrc();
			DisplayDrag();
			}
		}
		return (TRUE);


	case WM_LBUTTONUP:
		if ((!fDragging) || (!owds.owdf.fMouse))
			return (FALSE);
		ReleaseCapture ();
		EndDrag();
		return (TRUE);


	case WM_CHAR:
		if (HIWORD(pmsg->lParam) & KK_MENU)
			return(FALSE);
		if ((fDragging) && (!owds.owdf.fMouse))
			{
			int	dax = 0, day = 0;

			switch(LOBYTE(pmsg->wParam))
				{
			default:
				return(FALSE);

			case LOBYTE(VK_LEFT):
				dax = -1;
				break;
			case LOBYTE(VK_RIGHT):
				dax = 1;
				break;
			case LOBYTE(VK_DOWN):
				day = 1;
				break;
			case LOBYTE(VK_UP):
				day = -1;
				break;
			case LOBYTE(VK_ESCAPE):
				owds.owdf.fEscapeMove = 1;
			case LOBYTE(VK_RETURN):
				fDragging = FALSE;
				return (TRUE);
				}

			if (HIWORD(pmsg->lParam) & KK_CONTROL)
				{
				dax *= 8;
				day *= 4;
				}
			if (owds.owdf.message == WM_MOVE)
				{
				/* make sure that we don't move off
				 * the right side or bottom
				*/
				dax = min( dax,
				 (int) owds.pwndBackground->arcClipping.axRight
				  - 1 - (int) AxOfRx(owds.pwndBackground,
					 owds.rrc.rxLeft));
				day = min( day,
				 (int) owds.pwndBackground->arcClipping.ayBottom
				  - 1 - (int) AyOfRy(owds.pwndBackground,
					owds.rrc.ryTop));
				}
			else
				{
				/* stop window from extending beyond
				 * right or bottom
				*/
				Assert(owds.owdf.message == WM_SIZE);
				dax = min( dax,
				 (int) owds.pwndBackground->arcClipping.axRight
				  - (int) AxOfRx(owds.pwndBackground,
					 owds.rrc.rxRight));
				day = min( day,
				 (int) owds.pwndBackground->arcClipping.ayBottom
				  - (int) AyOfRy(owds.pwndBackground,
					owds.rrc.ryBottom));
				}
			if (FAdjustDragRrc(&dax, &day))
				{
				SaveDragRrc();
				DisplayDrag();
				}
			return(TRUE);
			}
		}

	return(FALSE);
	}




STATIC BOOL
FAllocDragSave()
/*
  -- Allocate the save buffers, return FALSE if not possible
*/
	{
	RRC	rrc;

	if (owds.owdf.fOutline)
		{
		RX	rxSave;

		GetClientRrc(owds.pwndBackground, &rrc);

		/*
		 * We allocate enough space to save the top side
		 * right, left and bottom sides of the moveable outline.
		*/
		rxSave		= rrc.rxRight;
		rrc.rxRight	= 1;
		owds.cbSaveSide	= CbSizeRrc(&rrc);
		rrc.rxRight	= rxSave;
		rrc.ryBottom	= 1;
		owds.cbSaveTop	= CbSizeRrc(&rrc);

		owds.lpbSave	= LpbAllocWorkFar(owds.cbSaveTop * 2
						 + owds.cbSaveSide * 2);

		if (owds.lpbSave == NULL)
			return(FALSE);
		}
	else
		{
		/* we just need enough space to save the
		 * corner button
		*/
		rrc.rxLeft = rrc.ryTop = 0;
		rrc.ryBottom = 1;
		rrc.rxRight = 3;

		owds.cbSaveTop = CbSizeRrc(&rrc);

		owds.lpbSave = LpbAllocWorkFar(owds.cbSaveTop);

		if (owds.lpbSave == NULL)
			return(FALSE);
		}

	return(TRUE);
	}




STATIC VOID
InitDragRrc(pwnd)
PWND	pwnd;
/*
  -- initialize the rrcDrag
*/
	{
	if (owds.owdf.fOutline)
		{
		/* moveable outline is initialized to be the border of
		 * the window being moved
		*/
		owds.rrc.rxLeft
			 = RxOfAx(owds.pwndBackground,pwnd->arcWindow.axLeft);
		owds.rrc.rxRight
			 = RxOfAx(owds.pwndBackground,pwnd->arcWindow.axRight);
		owds.rrc.ryTop
			 = RyOfAy(owds.pwndBackground,pwnd->arcWindow.ayTop);
		owds.rrc.ryBottom
			 = RyOfAy(owds.pwndBackground,pwnd->arcWindow.ayBottom);
		}
	else
		{
		/* for a corner button, we save the corner and a space
		 * to the left and right
		*/
		owds.rrc.rxLeft = RxOfAx(owds.pwndBackground,owds.ax);
		owds.rrc.ryTop = RyOfAy(owds.pwndBackground,owds.ay);
		owds.rrc.rxRight = owds.rrc.rxLeft + 2;
		owds.rrc.ryBottom = owds.rrc.ryTop + 1;
		if (owds.rrc.rxLeft > 0) owds.rrc.rxLeft--;
		}
	}



STATIC VOID
DisplayDrag()
/*
  -- display the border or button
*/
	{
	DrawThisWnd(NULL);
	if (owds.owdf.fOutline)
		{
		ARC	arc;

		arc.axLeft	= AxOfRx(owds.pwndBackground,owds.rrc.rxLeft);
		arc.ayTop	= AyOfRy(owds.pwndBackground,owds.rrc.ryTop);
		arc.axRight	= AxOfRx(owds.pwndBackground,owds.rrc.rxRight);
		arc.ayBottom	= AyOfRy(owds.pwndBackground,owds.rrc.ryBottom);

		pwndClip = owds.pwndBackground;
		DrawBoxArc(&boxActiveWindowOut, &arc, isaButtonDown,
				 TRUE, TRUE, NULL);
		pwndClip = NULL;
		}
	else
		{
		if (owds.owdf.fButton)
			{
			CharOutAbs(owds.ax,owds.ay,chBullet, isaButtonDown);
			if (owds.ax > owds.pwndBackground->arcClipping.axLeft)
				CharOutAbs(owds.ax-1,owds.ay,'<',isaButtonDown);
			if (owds.ax <owds.pwndBackground->arcClipping.axRight-1)
				CharOutAbs(owds.ax+1,owds.ay,'>',isaButtonDown);
			}
		}
	}


STATIC VOID
SaveDragRrc()
/*
  -- save the  rrcDrag
*/
	{
	if (owds.owdf.fOutline)
		{
		/* just save the outline around the rrcDrag */
		RRC	rrc;

		rrc = owds.rrc;
		rrc.ryBottom = rrc.ryTop + 1;	/* save the top side */
		SaveRrc(owds.pwndBackground, &rrc, owds.lpbSave);
		rrc.ryBottom = owds.rrc.ryBottom;

		rrc.rxRight = rrc.rxLeft + 1;	/* save the left side */
		SaveRrc(owds.pwndBackground, &rrc, owds.lpbSave
						 + owds.cbSaveTop);
		rrc.rxRight = owds.rrc.rxRight;

		rrc.ryTop = rrc.ryBottom - 1;	/* save the bottom side */
		SaveRrc(owds.pwndBackground, &rrc, owds.lpbSave
				 + owds.cbSaveTop + owds.cbSaveSide);
		rrc.ryTop = owds.rrc.ryTop;

		rrc.rxLeft = rrc.rxRight - 1;	/* save the right side */
		SaveRrc(owds.pwndBackground, &rrc, owds.lpbSave
				 + 2*owds.cbSaveTop + owds.cbSaveSide);
		rrc.rxLeft = owds.rrc.rxLeft;
		}
	else
		{
		/* for a corner button */
		SaveRrc(owds.pwndBackground, &owds.rrc, owds.lpbSave);
		}
	}



STATIC VOID
RestoreDragRrc()
/*
  -- save the rrcDrag
*/
	{
	if (owds.owdf.fOutline)
		{
		RRC	rrc;

		rrc = owds.rrc;
		rrc.ryBottom = rrc.ryTop + 1;	/* restore top side */
		RestoreRrc(owds.pwndBackground, &rrc, owds.lpbSave);
		rrc.ryBottom = owds.rrc.ryBottom;

		rrc.rxRight = rrc.rxLeft + 1;	/* restore left side */
		RestoreRrc(owds.pwndBackground, &rrc, owds.lpbSave
						 + owds.cbSaveTop);
		rrc.rxRight = owds.rrc.rxRight;

		rrc.ryTop = rrc.ryBottom - 1;   /* restore the bottom */
		RestoreRrc(owds.pwndBackground, &rrc, owds.lpbSave 
					+ owds.cbSaveTop + owds.cbSaveSide);
		rrc.ryTop = owds.rrc.ryTop;

		rrc.rxLeft = rrc.rxRight - 1;	/* restore the right side */
		RestoreRrc(owds.pwndBackground, &rrc, owds.lpbSave 
					+ 2*owds.cbSaveTop + owds.cbSaveSide);
		rrc.rxLeft = owds.rrc.rxLeft;
		}
	else
		{
		RestoreRrc(owds.pwndBackground, &owds.rrc, owds.lpbSave);
		}
	}



STATIC BOOL
FAdjustDragRrc(pdax, pday)
int	*pdax;
int	*pday;
/*
  -- adjust the dragged rectangle, restore the old one if necessary
  -- return true if adjustment was made
  -- dax and day must already be adjusted so that the window doesn't
     go off the right side or the bottom (since the cursor and keyboard
     cases are different)
*/
	{
	int	dax = *pdax;
	int	day = *pday;

	if (owds.owdf.fOutline)
		{
		if (owds.owdf.message == WM_MOVE)
			{
			/* don't go off the left or top */
			dax = max(dax, - (int) owds.rrc.rxLeft);
			day = max(day, - (int) owds.rrc.ryTop);
			}
		else
			{
			/* don't size too small */
			Assert(owds.owdf.message == WM_SIZE);
			if (owds.owdf.fXDrag)
				dax = max(dax, (int) axMinSize + (int)
					owds.rrc.rxLeft -(int)owds.rrc.rxRight);
			else
				dax = 0;
			if (owds.owdf.fYDrag)
				day = max(day, (int) ayMinSize + (int)
					owds.rrc.ryTop -(int)owds.rrc.ryBottom);
			else
				day = 0;
			}

		if ((dax == 0) && (day == 0))
			return(FALSE);

		RestoreDragRrc();

		owds.rrc.rxRight  = (RX) ((int) owds.rrc.rxRight + dax);
		owds.rrc.ryBottom = (RY) ((int) owds.rrc.ryBottom + day);
		if (owds.owdf.message == WM_MOVE)
			{
			owds.rrc.rxLeft = (RX) ((int) owds.rrc.rxLeft + dax);
			owds.rrc.ryTop  = (RY) ((int) owds.rrc.ryTop + day);
			}
		}
	else
		{ /* dealing with a corner button */
		if (((dax > -2) && (dax < 2)) && (day == 0))
			{
			if (owds.owdf.fButton)
				return(FALSE);
			else
				owds.owdf.fButton = 1;
			}
		else
			{
			if (!(owds.owdf.fButton))
				return(FALSE);
			else
				owds.owdf.fButton = 0;
			}

		RestoreDragRrc();
		}

	*pdax = dax;
	*pday = day;
	return(TRUE);
	}

VOID PRIVATE
EndDrag()
/*
  -- deallocate the buffers and send the message and restore the screen
*/
	{
	WORD	wParam = 0;
	DWORD	lParam = 0L;

	fDragging = FALSE;
	RestoreDragRrc();
	FreeWorkFar(owds.lpbSave);

	if ((!(owds.owdf.fOutline) && !(owds.owdf.fButton))
				   || owds.owdf.fEscapeMove)
		return;

	if (owds.owdf.fOutline)
		{
		/*
		 * include the location and size of the moved window
		 * ax,ay in the high word, dax,day in the low word
		*/
		lParam = MAKELONG(
			MAKEWORD((owds.rrc.ryBottom - owds.rrc.ryTop),
				 (owds.rrc.rxRight - owds.rrc.rxLeft)), 
			MAKEWORD(AyOfRy(owds.pwndBackground,owds.rrc.ryTop),
				 AxOfRx(owds.pwndBackground,owds.rrc.rxLeft))
				 );
		}

	SendMessage(owds.pwndMoving, owds.owdf.message, wParam, lParam);
	RedrawDamagedRegions();
	UpdateCursor();
	}

#endif /* WINDOW_OVERLAP, entire file */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\msgbox.c ===
/*
	COW : Character Oriented Windows

	msgbox.c : message boxes
*/

#define COW
#define cwExtraWnd	5	/* for static structure size */
#include <cow.h>

#include <udialog.h>
#include <uevent.h>
#include <uwindow.h>
#include <uisa.h>
#include <uutil.h>
#ifdef	HELP_BUTTON
#include <itl.h>
#endif	// HELP_BUTTON

#include "dialog.h"
#include "event.h"
#include "window.h"
#include "button.h"
#include "util.h"

#include "shadow.h"

#include "strings.h"

#include "_msgbox.h"

#ifdef DUAL
extern	WORD	fProtectMode;
#endif

/* forward */
STATIC VOID PrepareMbs(MBS *);

#ifdef ADJUST_MSGBOX
AY FAR PASCAL GetUILine (void);
#endif
#ifdef	DIALOG_NOSAVE
extern VOID	FAR PASCAL	ScreenRedraw(VOID);
#endif	// DIALOG_NOSAVE

PRIVATE DWORD FARPUBLIC MboxWndProc(PWND, WORD, WORD, DWORD);

/* NOTE : using chAccel's as acl's assumes 1st letter uniqueness (ich == 0) */

STATIC WND PASCAL wndDialog =
	wndGeneric(0, WS_CHILD | WS_BORDER | WS_DIALOG, 1, 0, 0, 1, 1,
		  DialogWndProc, NULL, NULL, NULL)
	{aclNil, NULL /* no caption */, 0}
	endWndGeneric;

STATIC WND wndCancel =
	wndGenericCursor(IDCANCEL, wsPushButton, 1, 0, 0, 0xff, 1,
		   ButtonWndProc, &wndDialog, NULL, NULL, 0, 0)
	{aclNil /* no accelerator */, (WORD) szCancelString, 0xff }
	endWndGeneric;

STATIC WND wndNo =
	wndGenericCursor(IDNO, wsPushButton, 1, 0, 0, 0xff, 1,
		   ButtonWndProc, &wndDialog, &wndCancel, NULL, 0, 0)
	{/* chAccelNo */ 0, (WORD) szNoString, 0xff }
	endWndGeneric;

STATIC WND wndOk =
	wndGenericCursor(IDOK, wsDefPushButton, 1, 0, 0, 0xff, 1,
		   ButtonWndProc, &wndDialog, NULL, NULL, 0, 0)
	{aclNil /* no accelerator */, (WORD) szOkString, 0xff }
	endWndGeneric;

STATIC WND wndYes =
	wndGenericCursor(IDYES, wsDefPushButton, 1, 0, 0, 0xff, 1,
		   ButtonWndProc, &wndDialog, &wndNo, NULL, 0, 0)
	{/* chAccelYes */ 0, (WORD) szYesString, 0xff }
	endWndGeneric;

STATIC WND wndRetry =
	wndGenericCursor(IDRETRY, wsDefPushButton, 1, 0, 0, 0xff, 1,
		   ButtonWndProc, &wndDialog, &wndCancel, NULL, 0, 0)
	{/* chAccelRetry */ 0, (WORD) szRetryString, 0xff }
	endWndGeneric;

STATIC WND wndAbort =
	wndGenericCursor(IDABORT, wsDefPushButton, 1, 0, 0, 0xff, 1,
		   ButtonWndProc, &wndDialog, NULL, NULL, 0, 0)
	{/* chAccelAbort */ 0, (WORD) szAbortString, 0xff }
	endWndGeneric;

#ifdef	HELP_BUTTON
static WND wndHelp =
	wndGenericCursor(IDHELP, wsDefPushButton, 1, 0, 0, 0xff, 1,
		   ButtonWndProc, &wndDialog, NULL, NULL, 0, 0)
	{/* chAccelHelp */ 0, (WORD) szHelpString, 0xff }
	endWndGeneric;
#endif	// HELP_BUTTON

/***
 * Define a bit mask for which buttons are used in the different message
 * box types each nibble from reverse to front is a index into the
 * array of button windows.
 */
STATIC WORD mpmbrgn[]=	/* rgn = array of 4 nibbles */
#ifdef	HELP_BUTTON
	{0x0071, 0x7234, 0x0725, 0x0721, 0x0076, 0x0734, 0x075};
#else	// HELP_BUTTON
 	{0x0001, 0x0234, 0x0025, 0x0021, 0x0006, 0x0034, 0x005};
#endif	// HELP_BUTTON

STATIC PWND rgpwndButton[] =
#ifdef	HELP_BUTTON
	{NULL, &wndOk, &wndCancel, &wndNo, &wndYes, &wndRetry, &wndAbort, &wndHelp};
#else	// HELP_BUTTON
	{NULL, &wndOk, &wndCancel, &wndNo, &wndYes, &wndRetry, &wndAbort};
#endif	// HELP_BUTTON


STATIC MBS *	pmbsCur;		/* current state */



PUBLIC WORD FARPUBLIC
MessageBox(sz0, sz1, sz2, mb)
/*
  -- display a message box.
  -- see udialog.h for allowed MB_xxxxxx values
  -- Up to three lines of text can be displayed in the message box.
*/
char *sz0, *sz1, *sz2;
WORD mb;
	{
	StartPublic();

	MBS	mbs;			/* the message-box state */
	REGISTER MBI *pmbi;

	if (mb & MB_CAPTION)
		{
		AssertSz(sz0 != NULL, "MessageBox(MB_CAPTION) but no caption");
		mbs.szTitle = sz0;
		sz0 = NULL;
		}
	else
		{
		mbs.szTitle = NULL;		/* no caption */
		}

#ifdef	HELP_BUTTON
	mbs.fNoHelp = (mb & MB_NOHELP);
#endif	// HELP_BUTTON

	mbs.rgmbi[0].sz = sz0;
	mbs.rgmbi[1].sz = sz1;
	mbs.rgmbi[2].sz = sz2;

	/* Figure out how many lines we have, what their lengths are, and
		what the maximum length is. */
#ifdef	HELP_BUTTON
#ifdef	BUTTON_CENTER
	mbs.cchMac = mpmbcchButton[(mbs.mbSimple = mb & MB_TYPE) - mbMin] -
				   (mbs.fNoHelp ? 3+(cchHelp+2) : 0);
#else	// BUTTON_CENTER
	mbs.cchMac = mpmbcchButton[(mbs.mbSimple = mb & MB_TYPE) - mbMin] -
				   (mbs.fNoHelp ? 2+(cchHelp+2) : 0);
#endif	// BUTTON_CENTER
#else	// HELP_BUTTON
	mbs.cchMac = mpmbcchButton[(mbs.mbSimple = mb & MB_TYPE) - mbMin];
#endif	// HELP_BUTTON
	mbs.imbiMac = 0;

	for (pmbi = mbs.rgmbi; pmbi < &mbs.rgmbi[imbiMax]; pmbi++)
		{
		if (pmbi->sz == NULL)
			continue;		/* first NULL ends */
		if ((pmbi->cch = strlen(pmbi->sz)) > mbs.cchMac)
			{
			if (pmbi->cch > axMac - 6)
				pmbi->cch = axMac - 6;
			mbs.cchMac = pmbi->cch;
			}
		mbs.imbiMac++;
		}
	AssertSz(mbs.imbiMac != 0, "MessageBox(NULL,NULL,NULL,...)");

	/* Calculate start location of each of the strings */
	for (pmbi = mbs.rgmbi; pmbi < &mbs.rgmbi[imbiMax]; pmbi++)
		pmbi->rx = (RX) ((mbs.cchMac + 4 - pmbi->cch) >> 1);

	PrepareMbs(&mbs);

	if (mb & MB_BEEP)
		Beep();

	ReturnPublic(DialogBox(&wndDialog, MboxWndProc), WORD);
	}




STATIC VOID
PrepareMbs(pmbs)
/*
  -- given a message box state, prepare the global windows to reflect this
	new state, and set pmbsCur to pmbs
*/
REGISTER MBS *	pmbs;
	{
	AX		ax;
	AY		ayButton;
	WORD		rgn;		/* array of 4 nibbles */
	PWND *		ppwndPrev;

	wndDialog.szDialog = (WORD) pmbs->szTitle;

#ifdef ADJUST_MSGBOX
	{
	extern BYTE fAdjustMsgBox;
	AY day = (AY) pmbs->imbiMac + dayMsgBox + dayPushButton;
	AY ay = (ayMac - pmbs->imbiMac - dayMsgBox - dayPushButton) / 2;
	AY ayUI = GetUILine ();
	AX dax = (AX) pmbs->cchMac + 6;

	SetWindowSize(&wndDialog, dax, day);
	if (fAdjustMsgBox && ayUI >= ay && ayUI < (ay + day))
		MoveWindow(&wndDialog, (axMac - dax) / 2, ayMac - (day+1));
	else
		MoveWindow(&wndDialog, (axMac - dax) / 2, ay);
	}
#else
	/* Build the main dialog box */
	SetWindowSize(&wndDialog, (BYTE) pmbs->cchMac+6,
	    (BYTE) pmbs->imbiMac + dayMsgBox + dayPushButton);
	MoveWindow(&wndDialog, (axMac - pmbs->cchMac - 6) / 2,
	    (ayMac - pmbs->imbiMac - dayMsgBox - dayPushButton) / 2);
#endif /*ADJUST_MSGBOX*/

#ifdef	HELP_BUTTON
#ifdef	BUTTON_CENTER
	/* more complicated button centering to match TWIN */
	ax = (((wndDialog.arcClipping.axRight - wndDialog.arcClipping.axLeft) -
	       mpmbcchButton[pmbs->mbSimple - mbMin] +
	       (pmbs->fNoHelp ? 3+(cchHelp+2) : 0)) / 2) +
	     wndDialog.arcClipping.axLeft;
#else
	ax = wndDialog.arcClipping.axRight -
	     mpmbcchButton[pmbs->mbSimple - mbMin] +
	     (pmbs->fNoHelp ? 2+(cchHelp+2) : 0);
#endif	/*!BUTTON_CENTER*/
#else	// HELP_BUTTON
#ifdef	BUTTON_CENTER
	/* more complicated button centering to match TWIN */
	ax = (((wndDialog.arcClipping.axRight - wndDialog.arcClipping.axLeft) -
	       mpmbcchButton[pmbs->mbSimple - mbMin]) / 2) +
	     wndDialog.arcClipping.axLeft;
#else
	ax = wndDialog.arcClipping.axRight -
	     mpmbcchButton[pmbs->mbSimple - mbMin];
#endif	/*!BUTTON_CENTER*/
#endif	// HELP_BUTTON
	ayButton = wndDialog.arcClipping.ayBottom - dayPushButton;

	rgn = mpmbrgn[pmbs->mbSimple - mbMin];
	Assert(rgn != 0);	/* must have at least 1 */

	ppwndPrev = &wndDialog.pwndChild;

	do
		{
		REGISTER PWND 	pwnd;
		REGISTER MBB	*pmbb;

	 	/* Point to the correct button for the item */
		pwnd = rgpwndButton[rgn & 0xf];
		Assert(pwnd != NULL);
		pmbb = &rgmbb[rgn & 0xf];

		*ppwndPrev = pwnd;		/* link to prev */
		ppwndPrev = &pwnd->pwndSibling;

		/* Set the button value to zero */
		pwnd->wButton = 0;

		/* Make sure we have the accelerator set right */
		Assert(aclNil == 0);
		pwnd->aclDialog = pmbb->chAccel;

		/* Setup the window size and position */
		pwnd->cchDialog = pmbb->cch;
		MoveWindow(pwnd, ax, ayButton);
		SetWindowSize(pwnd, pmbb->drx, dayPushButton);
		/* Setup position of next button */
#ifdef BUTTON_CENTER
		ax += (AX) (pmbb->drx + 3);
#else
		ax += (AX) (pmbb->drx + 2);
#endif /*!BUTTON_CENTER*/
		}
#ifdef HELP_BUTTON
	while ((rgn >>= 4) != 0 &&	/* next nibble */
	       (!pmbs->fNoHelp || ((rgn >> 4) != 0)));/* Skip last nibble if fNoHelp */
#else	// HELP_BUTTON
	while ((rgn >>= 4) != 0);	/* next nibble */
#endif	// HELP_BUTTON
	*ppwndPrev = NULL;

	/* set global for information */
	pmbsCur = pmbs;
	}



PRIVATE DWORD FARPUBLIC		/* WndProcs PUBLIC SIZE */
MboxWndProc(pwnd, message, wParam, lParam)
/*
  -- dialog specific procedure for message boxes
*/
REGISTER PWND pwnd;
WORD message, wParam;
DWORD lParam;
	{
	Unreferenced(lParam);

	switch (message)
		{
	default:
		break;

	case WM_PAINT:
		{
		REGISTER MBS *pmbs = pmbsCur;
		REGISTER MBI *pmbi;
		RY ry = 1;

		for (pmbi = pmbs->rgmbi; pmbi < &pmbs->rgmbi[imbiMax]; pmbi++)
			if (pmbi->sz != NULL)
				TextOut(pwnd, pmbi->rx, ry++, (char *) pmbi->sz,
				    pmbi->cch, isaMessageBox);
		}
		break;

	case WM_DIALOG:
#ifdef HELP_BUTTON
		if (wParam == IDHELP)
			{
			wParam = 0;	/* No shift states for Help */
			goto do_help;
			}
#endif
		/* pass button hit to who invoked dialog box */
		EndDialog(pwnd, wParam);
		break;

	case WM_HELP:
#ifdef HELP_BUTTON
do_help:
#endif
		/* HELP : this may in turn call MessageBox recursively,
		*  so we must re-initialize the message box
		*/
		{
		MBS *	pmbsSave = pmbsCur;

		Help(hemMbox, pmbsCur->mbSimple, NULL, wParam);
			/* wParam contains the shift states */

		/* restore the world */
		PrepareMbs(pmbsSave);
#ifdef	DIALOG_NOSAVE
		DrawWindow(&wndDialog);
#endif	// DIALOG_NOSAVE
		UpdateCursor();
		wndDialog.wParamEnd = 0;    /* not finished this dialog yet */
		}
		break;

#ifdef DUAL
	case WM_IDLE:
		/* for DOS 5, in idle return TRUE (=> dialog processor
		*  will put us to sleep
		*/
		if (fProtectMode)
			return TRUE;		/* default idle */
#else /*!DUAL*/
#ifdef DOS5
	case WM_IDLE:
		/* for DOS 5, in idle return TRUE (=> dialog processor
		*  will put us to sleep
		*/
		return TRUE;		/* default idle */
#endif
#endif /*!DUAL*/
		}
	return (0L);
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\private.c ===
/*
	CW : Character Windows

	private.c : Includes headers for making .inc files
	NOTE: does not include all headers, just those needed for assembler
*/

#define COW
#include <cow.h>		/* NOTE: cow.inc not generated !! */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\overlutl.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	util.asm : user utilities (DOS 3 & 5)

	title	util - low level utilities for COW USER

.xlist
	include	user.inc
.list


sBegin USER_CORE
    assumes CS,USER_CORE
    assumes DS,DATA
    assumes SS,DATA

subttl memset
page
;----
;
;   MemSetW - Memory set Words
;
;   Purpose:
;	Sets the first cnt words of dest to the word value w
;
;   void MemSetW(WORD ps, WORD off, WORD w, unsigned cnt);
;
;   Args:
;	ps:off - the Destination buffer.
;	w - The character to fill the buffer with
;	cnt - The count of the number of bytes to fill.
;
;   Returns:
;	'non'
;
;----

IFDEF WINDOW_OVERLAP

cProc  MemSetW,<PUBLIC, NEAR>,<DI>
    parmW	psDest
    parmW	offDest
    parmW	w
    parmW	cnt
cBegin	MemSetW

	mov	es,psDest	; set es = ds
	mov	di,offDest	; Get destination 
	mov	ax,w		; Get character to fill buffer with
	mov	cx,cnt		; get number of bytes to move
	rep	stosw		; Fill the buffer

cEnd	MemSetW

ENDIF	;WINDOW_OVERLAP

sEnd    USER_CORE
;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\overlap.h ===
/*
    	COW : Character Oriented Windows

	overlap.h : overlapping window control
*/

#ifdef WINDOW_OVERLAP

BOOL	FARPRIVATE OverlapFilter(PMSG);
VOID	FARPRIVATE DrawThisWndProc(PWND);
VOID	FARPRIVATE ClipoutWindowAndSiblings(PWND);

extern PWND pwndCur;
extern WORD psOverlap;

#define	DrawThisWnd(pwnd)	DrawThisWndProc(pwnd);

typedef struct _owdf
	{
	BITS	fMouse : 1;		/* Cause by mouse? (or keyboard) */
	BITS	fButton : 1;		/* Corner button down? */
	BITS	fOutline : 1;		/* Moving outline of window? */
	BITS	fXDrag : 1;		/* Drag in X direction? */
	BITS	fYDrag : 1;		/* Drag in Y direction? */
	BITS	fEscapeMove : 1;	/* escaped from window move */
	WORD	message;		/* message to be sent */
	} OWDF; /* Overlapping window drag flags */

typedef struct _owds
	{
	AX      ax;			/* Last mouse position */
	AY      ay;
	RRC     rrc;			/* current hilited rectangle */
	PWND	pwndMoving;		/* window that is being moved */
	PWND	pwndBackground;		/* parent of current overlap window */
	OWDF	owdf;			/* flags */
	BYTE FAR *lpbSave;		/* space to save screen under outline*/
	WORD	cbSaveTop;		/* number of bytes to save top/bottom*/
	WORD	cbSaveSide;		/* number of bytes to save side */
	} OWDS;	/* Overlapping window drag status */

#define     ayMinSize      2
#define     axMinSize      3

#else /* no overlapping */

#define	DrawThisWnd(pwnd)

#endif /*!WINDOW_OVERLAP*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\rect.c ===
/*
	COW : Character Oriented Windows

	rect.c : Rectangle support
*/

#define COW
#include <cow.h>

#define WINDOW
#include <uwindow.h>
#include <inscreen.h>



PUBLIC BOOL FARPUBLIC
PtInRect(prrc, rx, ry)
/*
  -- retuurn TRUE if point is in the rectangle
  -- Works for both rrcs and prrc
*/
RX rx;
RY ry;
REGISTER PRRC prrc;
	{
	StartPublic();
	ReturnPublic(rx >= prrc->rxLeft &&
		rx < prrc->rxRight &&
		ry >= prrc->ryTop &&
		ry < prrc->ryBottom, BOOL);
	}



PUBLIC VOID FARPUBLIC
SetRect(prrc, rxLeft, ryTop, rxRight, ryBottom)
/*
  -- set the coordinates of a rectangle
*/
REGISTER PRRC prrc;
RX rxLeft, rxRight;
RY ryTop, ryBottom;
	{
	StartPublic();
	prrc->rxLeft = rxLeft;
	prrc->ryTop = ryTop;
	prrc->rxRight = rxRight;
	prrc->ryBottom = ryBottom;
	StopPublic();
	}




PUBLIC BOOL FARPUBLIC
IntersectRect(prrcDest, prrcSrc1, prrcSrc2)
/*
  -- fille *prrcDest with the intersection of two rectangles
*/
REGISTER PRRC prrcSrc1;
REGISTER PRRC prrcSrc2;
REGISTER PRRC prrcDest;
	{
	StartPublic();
	prrcDest->rxLeft = max(prrcSrc1->rxLeft, prrcSrc2->rxLeft);
	prrcDest->rxRight = min(prrcSrc1->rxRight, prrcSrc2->rxRight);
	prrcDest->ryTop = max(prrcSrc1->ryTop, prrcSrc2->ryTop);
	prrcDest->ryBottom = min(prrcSrc1->ryBottom, prrcSrc2->ryBottom);
	if (IsRectEmpty(prrcDest))
		{
		prrcDest->rxLeft = 0;
		prrcDest->rxRight = 0;
		prrcDest->ryTop = 0;
		prrcDest->ryBottom = 0;
		ReturnPublic(FALSE, BOOL);
		}
	else
		ReturnPublic(TRUE, BOOL);
	}



PUBLIC VOID FARPUBLIC
UnionRect(prrcDest, prrcSrc1, prrcSrc2)
/*
  -- fill *prrcDest with the union of two rectangles
*/
REGISTER PRRC prrcSrc1, prrcSrc2;
PRRC prrcDest;
	{
	StartPublic();
	if (IsRectEmpty(prrcSrc1))
		*prrcDest = *prrcSrc2;
	else if (IsRectEmpty(prrcSrc2))
		*prrcDest = *prrcSrc1;
	else
		{
		prrcDest->rxLeft = min(prrcSrc1->rxLeft, prrcSrc2->rxLeft);
		prrcDest->rxRight = max(prrcSrc1->rxRight, prrcSrc2->rxRight);
		prrcDest->ryTop = min(prrcSrc1->ryTop, prrcSrc2->ryTop);
		prrcDest->ryBottom =
			max(prrcSrc1->ryBottom, prrcSrc2->ryBottom);
		}
	StopPublic();
	}



PUBLIC BOOL FARPUBLIC
IsRectEmpty(prrc)
/*
  -- return TRUE if rectangle is empty
*/
REGISTER PRRC prrc;
	{
	StartPublic();
	ReturnPublic(prrc->rxLeft >= prrc->rxRight ||
		prrc->ryTop >= prrc->ryBottom, BOOL);
	}



PUBLIC WORD FARPUBLIC
CwSizeRrc(prrc)
/*
  -- return the size (in words) needed to save the rectangle
  -- NOTE : also works for ARC's
*/
REGISTER PRRC prrc;
	{
	WORD	cw;

	cw = ((prrc)->rxRight-(prrc)->rxLeft) *
	    ((prrc)->ryBottom-(prrc)->ryTop);

#ifdef SCREEN_FFONT
	if (fFontAvailable)
		cw *= 2;
#endif /*SCREEN_FFONT*/

	return cw;
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\parse.c ===
/*
	COW : Character Oriented Windows

	parse.c : Parsing functions for SDM

??????? rewrite so non-recursive ????????????
*/

#define COW
#include <cow.h>

#include <usdm.h>
#include <udialog.h>

#include "sdm.h"

/* forward */
STATIC int	WParseSz(char *, WORD *);
STATIC int	CchIntToPpch(int, char **);
STATIC VOID	SzFromInt(char *, int);



STATIC BOOL
WParseSz(sz, pichErr)
/*
  -- parse string to integer
  -- return wError if invalid
  -- return wNinch if empty
*/
REGISTER char *sz;
WORD *pichErr;		/* where to put index to error if bad */
	{
	int val = 0;
	char ch;
	int fNeg;
	char *szStart = sz;

	/* skip leading spaces */
	while (*sz == ' ')
		sz++;

	/* if null string, return special ninch value */
	if (*sz == '\0')
		return wNinch;

	/* check for negative number */
	if (fNeg = (*sz == '-'))
		sz++;

	/* parse number up to space or end of string */
	while ((ch = *sz) != '\0' && ch != ' ')
		{
		/* if character not a digit or value too large then error */
		if (ch < '0' || ch > '9' || val >= 3277 ||
		     (val >= 3276 && ch > '5'))
			{
			*pichErr = sz - szStart;
			return wError;
			}

		/* accumulate result */
		val = val * 10 + (ch - '0');
		sz++;
		}

	/* skip trailing spaces */
	while (*sz == ' ')
		sz++;

	*pichErr = sz - szStart;	/* set in case number == wError */
	/* if not at end of string, error */
	if (*sz != '\0')
		return wError;

	/* account for sign */
	return (fNeg ? -val : val);
	}



STATIC int
CchIntToPpch(w, ppch)
int w;
char **ppch;
	{
	int cch = 0;

	if (w < 0)
		{
		*(*ppch)++ = '-';
		w = -w;
		cch++;
		}

	if (w >= 10)
		{
		cch += CchIntToPpch(w / 10, ppch);
		w %= 10;
		}

	*(*ppch)++ = (char) ('0' + w);
	return(cch + 1);
	}



STATIC VOID	
SzFromInt(sz, w)
char *sz;
int w;
	{
	char *pch;
	int cch;

	AssertSz(w != wError, "SzFromInt: wError");
	/* if value is ninch, return null string */
	if (w == wNinch)
		cch = 0;
	else
		{
		pch = &sz[0];
		cch = CchIntToPpch(w, &pch);
		}
	sz[cch] = 0;
	}



PUBLIC WORD FARPUBLIC
ParseInt(tmm, sz, hObj, tmc, wParam, bArg)
/*
  -- simple int parse/format
*/
WORD tmm;
char *sz;
HANDLE hObj;
TMC tmc;
WORD wParam;		/* ignored */
WORD bArg;
	{
	StartPublic();
	int * pw = (int *) PvParseArg(hObj, bArg);
	WORD ichErr;

	Unreferenced(wParam);

	switch(tmm)
		{
	default:
		Assert(FALSE);
		break;

	case tmmParse:
		if ((*pw = WParseSz(sz, &ichErr)) != wError)
			{
			ReturnPublic(TRUE, WORD);
			}
		else
			{
			SetTmcSel(tmc, ichErr, 0x7fff);
			Alert("Parse Error");
			ReturnPublic(FALSE, WORD);
			}
		/*break*/

	case tmmFormat:
		SzFromInt(sz, *pw);
		ReturnPublic(0, WORD);
		/*break*/

	case tmmCwVal:
		ReturnPublic(sizeof(int)/sizeof(WORD), WORD);
		/*break*/
		}
	}



#ifdef LATER	/* maybe */

PUBLIC unsigned FARPUBLIC
ParseUns(tmm, sz, ppval, tmc)
int tmm;
char *sz;
int **ppval;
TMC tmc;
/*
  -- unsigned int parse/format function
*/
	{
	Alert("ParseUns() not yet implemented");
	return(FALSE);
	}



PUBLIC long FARPUBLIC
ParseFloat(tmm, sz, ppval, tmc)
/*
  -- float parse/format function
*/
int tmm;
char *sz;
int **ppval;
TMC tmc;
	{
	Alert("ParseFloat() not yet implemented");
	return(FALSE);
	}

#endif /*LATER*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\screen.h ===
/*
	COW: Character Oriented Windows
	
	screen.h: cow private screen interface
*/

/*****************************************************************************/
/* characters */

#include <inscreen.h>

/* Border width */
#define	daxBorder	1
#define	dayBorder	1

extern BYTE		cHoldUpdate;		/* defer DoneUpdate */

#define BeginDraw()     (cHoldUpdate++)

/*****************************************************************************/

VOID	FARPUBLIC	MoveHardwareCursor(AX, AY, BOOL);
#ifdef KANJI
VOID	FARPRIVATE	FlushDraw(void);
#endif
VOID	FARPRIVATE	EndDraw(void);

/* ABS coordinate routunes */
VOID	FARPRIVATE 	CharOutAbs(AX, AY, ACHAR, WORD);
VOID	FARPRIVATE	TextOutAbs(AX, AY, char *, WORD, WORD);
VOID	FARPRIVATE	FillArc(AX, AY, AX, AY, ACHAR, WORD);
VOID    FARPRIVATE      BltArc(AX, AY, WORD, WORD, AX, AY);

VOID	FARPRIVATE	SaveArc(AX, AY, AX, AY, BYTE FAR *);
VOID	FARPRIVATE	RestoreArc(AX, AY, AX, AY, BYTE FAR *);

/*****************************************************************************/

#ifdef KANJI
extern BOOL		fRestoreDbcs;		/* restore 1/2 characters ? */
#define	daxDbcs		1			/* 1 byte for DBCS 1/2 character
						  padding */
#else
#define	daxDbcs		0
#endif

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\screen.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	screen.asm : installable screen drivers

	title	screen - Screen control code for CW

.xlist
	include	user.inc
	include uisa.inc		;* for isa's
	include	screen.inc		;* screen stuff

	include	inscr.inc
	include	indrv.inc

ifdef	KANJI
	include kanji.inc
endif	;KANJI

.list

;----------------------------------------------------------------------------
;
;	* Video Support Macros *

;********** PrepareDraw **********
;*	entry : axPos = ax position
;*		ayPos = ay position
;*	* Calculate the screen position of the character specified
;*	* set ayDrawing to the row being drawn, clear fMouseLockedOut first
;*	* set axDrawFirst
;*	exit : ES:DI = address of character (lpch)
;*	* TRASHES AX,BX

PrepareDraw MACRO axPos,ayPos
	mov	al,ayPos
	mov	ayDrawing,al			;* set drawing location
	mul	axMac
	mov	bl,axPos
	mov	axDrawFirst,bl
	xor	bh,bh
	add	ax,bx
	shl	ax,1		; ax = (ayPos * axMac + ayPos) * 2
ifdef	DEBUG
	cmp	instCur.psPrimInst,0	;* no buffer! (FAllocInstBuffers)
	jne	@F
	cCall	CowAssertFailed
	DB	"no primary buffer for current mode$"
@@:
endif	;DEBUG
	mov	es,instCur.psPrimInst
	mov	di,ax		;* ES:DI => primary buffer
ENDM

;*****************************************************************************

ifdef	DEBPUB	;* Debugging Publics
	PUBLIC	DoDraw
endif

;*****************************************************************************

sBegin	DATA
	assumes DS,DGROUP

;* PUBLIC
externW <rgsa>			;* array of SA's
externB <inch, insj>

IFNDEF	CBOX
externB	<boxSingle, boxDouble, chShadow>
endif	; !CBOX

ifdef	WINDOW_OVERLAP
externW <psOverlap>		;* windows for overlap check
externW <pwndCur>		;* current drawing window
externB <boxActiveWindowOut>
externB <boxInactiveWindowOut>
externB <boxActiveWindowIn>
externB <boxInactiveWindowIn>
endif	;WINDOW_OVERLAP

;* PRIVATE
externB <ayMouse>		;* current mouse position


globalB	ayDrawing,ayNil		;* current drawing ay
globalB	axDrawFirst,ayNil	;* start drawing ax

ifdef	SCREEN_FFONT
externW	<mpisaffont>		;* ffont values
endif	;SCREEN_FFONT

ifdef	BUILTIN_SNOW
globalB fWaitRetrace,0		;* snow protect for twin compatibility,QC only
endif	;BUILTIN_SNOW

sEnd	DATA

;----------------------------------------------------------------------------

sBegin	BSS
	assumes DS,DGROUP

globalB instCur,<cbInstMin DUP (?)>	; data for installable drivers.

globalW	fRestoreDbcs,0		;* => restore DBCS characters
				;* stays 0 for non-KANJI

ifdef	SCREEN_FFONT
globalW	fFontAvailable,0	;* => ffont support allowed
endif	;SCREEN_FFONT

globalB	axMac,0			; Maximum column number
globalB	ayMac,0			; Maximum row number (start at 0)
globalW	axMacTimes2,0		; for row modulus - WORD !!!

globalB	fMonochrome,0		;* Is b/w display

;*	* Variable for implementing mouse lockout (see kernel/mouse.asm)
globalB	fMouseLockedOut,0	;* set by mouse handler

globalB cHoldUpdate,0		;* used by BeginDraw EndDraw

;* PRIVATE *
globalW	fColorModeOld,0		;* last color mode

globalW	offDrawFirst,0		;* offset where drawing started
staticW	ffontCur,0		;* current ffont value

;*	* KLUDGE for clear screen !!
globalB	caOld,0			;* old screen attribute
	DB	0

sEnd	BSS

;*****************************************************************************


sBegin	SCREEN
	assumes CS,SCREEN
	assumes DS,DGROUP
	assumes SS,DGROUP

;*	* High level routines

;********** FillArc **********
;*	entry : axLeft, ayTop, axRight, ayBottom : rectangle to fill
;*		chFill	: fill character (CHAR -- may be DBCS character)
;*		diCur	: draw info (HIBYTE = dm, LOBYTE = isa).
;*	* apply draw mode & data to specified rectangle
;*		D flag MUST BE CLEARED !!!
;*	exit : n/a

cPrivate FillArc,<ATOMIC>,<SI,DI>		;* PRIVATE
	parmB  axLeft
	parmB  ayTop 
	parmB  axRight 
	parmB  ayBottom			;* also day
ifdef	KANJI
	parmW  chFill			;* CHAR type
ELSE
	parmB  chFill
endif	;!KANJI
	parmW  diCur			;* draw info

	LocalW daxMax			;* line wrap value

cBegin	FillArc

	StartPublic
	AssertUp

;*	* Find row count
	mov	al,ayTop
	sub	ayBottom,al		;* day
ifdef	KANJI
	jz	J_fill_end
else	; KANJI
	jz	fill_end		;* no rows to fill
endif	; KANJI

;*	* Find character count
	mov	cl,axRight
	sub	cl,axLeft
ifdef	KANJI
	jnz	@F
J_fill_end:
	jmp	fill_end
@@:
else	; KANJI
	jz	fill_end		;* no width to fill
endif	; KANJI
	xor	ch,ch

;*	* Prepare for the fill
	PrepareDraw axLeft,ayTop	;* sets ES:DI
	mov	dx,screenOffset mpdmnpfnDrawFR	;* normal fill row
ifdef	KANJI
	mov	ax,chFill		;* fill character
	JmpNotDbc fill_normal
;*	* fill as double byte character
	and	cx,not 1		;* force even
	mov	dx,screenOffset mpdmnpfnDrawFR_DBCS	;* DBCS fill row
fill_normal:
ELSE
	mov	al,chFill		;* fill character
endif
	mov	si,ax			;* SI = char save value

;*	* SI = character (AL for non KANJI), DX = dispatch table, CX = count
fill_row_loop:
;*	* Perform Draw
	mov	bx,diCur
	Save	<dx,cx,di>			;* cx = dax, di + start
	cCall	DoDraw			;* fill it in
	inc	ayDrawing		;* next row
	add	di,axMacTimes2		;* to next row
	dec	ayBottom		;* day
	jnz	fill_row_loop

	cCall	FinishDraw

fill_end:
	AssertUp
	StopPublic

cEnd	FillArc



;********** TextOutAbs **********
;*	entry : axLeft, ayTop : start position
;*		pch	: pointer to string data
;*		cch	: # of characters
;*		diCur	: draw info (HIBYTE = dm, LOBYTE = isa).
;*	* apply draw mode & string data to 1 row of text
;*		D flag MUST BE CLEARED !!!
;*	exit : n/a

cPrivate TextOutAbs,<ATOMIC>,<SI,DI>
	parmB  axLeft
	parmB  ayTop
	parmDP pch  
	parmW  cch
	parmW  diCur			;* draw mode + isa
  
cBegin	TextOutAbs

	StartPublic

	AssertUp

;*	* Prepare for the fill
	PrepareDraw axLeft,ayTop	;* sets ES:DI
	mov	si,pch			;* array

	mov	cx,cch

	mov	dx,screenOffset mpdmnpfnDrawTO
	mov	bx,diCur
	cCall	DoDraw			;* perform Text Out

	cCall	FinishDraw

textout_end:
	AssertUp

	StopPublic

cEnd	TextOutAbs



;********** CharOutAbs **********
;*	entry : axCur, ayCur : start position
;*		chPut	: character to put (CHAR)
;*		diCur	: draw info (HIBYTE = dm, LOBYTE = isa).
;*	* TextOutAbs for a single character
;*		D flag MUST BE CLEARED !!!
;*	exit : n/a

cPrivate CharOutAbs,<ATOMIC>,<SI,DI>
	parmB axCur
	parmB ayCur
	parmW chPut		;* could be double byte
	parmW diCur
cBegin	CharOutAbs

	StartPublic

	AssertUp

	PrepareDraw axCur,ayCur		;* sets ES:DI
	lea	si,chPut

	mov	cx,1			;* 1 character TextOut
ifdef	KANJI
	mov	al,ds:[si]		;* get first byte
	JmpNotDbc single_char_out
	inc	cx
single_char_out:
endif	;KANJI

	mov	dx,screenOffset mpdmnpfnDrawTO
	mov	bx,diCur
	cCall	DoDraw			;* perform Text Out

	cCall	FinishDraw

put_ch_end:
	AssertUp

	StopPublic

cEnd	CharOutAbs


ifdef	DRAW_MODE_MINIMIZE

;*****************************************************************************

;*	* * * Drawing info tables * * *
;*	* Drawing routine table for TextOut
mpdmnpfnDrawTO:
	DW	TO_dmTFB		;* Normal
	DW	TO_dmT			;* Text only
	DW	InvalidMode		;* attribute only for TextOut => bogus
	DW	InvalidMode		;* foreground only
	DW	InvalidMode		;* background only
	DW	InvalidMode		;* text & foreground
	DW	InvalidMode		;* text & background
	DW	InvalidMode		;* Text Map background
	DW	InvalidMode		;* Text Map foreground
	DW	InvalidMode		;* Map background
	DW	InvalidMode		;* Map foreground
	DW	InvalidMode		;* Map attr: back 2 back, fore 2 fore
	DW	InvalidMode		;* Map attribute to attribute

;*	* Drawing routine table for FillRectangle
mpdmnpfnDrawFR:
	DW	FR_dmTFB		;* Normal
	DW	InvalidMode		;* Text only
	DW	FR_dmFB			;* ca only
	DW	InvalidMode		;* foreground only
	DW	InvalidMode		;* background only
	DW	InvalidMode		;* text & foreground
	DW	InvalidMode		;* text & background
	DW	InvalidMode		;* Text Map background
	DW	InvalidMode		;* Text Map foreground
	DW	InvalidMode		;* Map background
	DW	InvalidMode		;* Map foreground
	DW	InvalidMode		;* Map attr: back 2 back, fore 2 fore
	DW	InvalidMode		;* Map attribute to attribute

ifdef	KANJI
;*	* Drawing routine table for FillRectangle for DBCS fill
;*	* (attribute only functions stay the same)
mpdmnpfnDrawFR_DBCS:
	DW	FR_dmTFB_DBCS		;* Normal
	DW	InvalidMOde		;* Text only
	DW	FR_dmFB			;* ca only (same as normal)
	DW	InvalidMode		;* foreground only
	DW	InvalidMode		;* background only
	DW	InvalidMode		;* text & foreground
	DW	InvalidMode		;* text & background
	DW	InvalidMode		;* Text Map background
	DW	InvalidMode		;* Text Map foreground
	DW	InvalidMode		;* Map background
	DW	InvalidMode		;* Map foreground
	DW	InvalidMode		;* Map attr: back 2 back, fore 2 fore
	DW	InvalidMode		;* Map attribute to attribute
endif	;KANJI

else	; !DRAW_MODE_MINIMIZE

;*****************************************************************************

;*	* * * Drawing info tables * * *
;*	* Drawing routine table for TextOut
mpdmnpfnDrawTO:
	DW	TO_dmTFB		;* Normal
	DW	TO_dmT			;* Text only
	DW	InvalidMode		;* attribute only for TextOut => bogus
	DW	TO_dmF			;* foreground only
	DW	TO_dmB			;* background only
	DW	TO_dmTF			;* text & foreground
	DW	TO_dmTB			;* text & background
	DW	TO_dmTMb		;* Text Map background
	DW	TO_dmTMf		;* Text Map foreground
	DW	TO_dmMb			;* Map background
	DW	TO_dmMf			;* Map foreground
	DW	TO_dmMfb		;* Map attr: back 2 back, fore 2 fore
	DW	TO_dmMAttr		;* Map attribute to attribute

;*	* Drawing routine table for FillRectangle
mpdmnpfnDrawFR:
	DW	FR_dmTFB		;* Normal
	DW	FR_dmT			;* Text only
	DW	FR_dmFB			;* ca only
	DW	FR_dmF			;* foreground only
	DW	FR_dmB			;* background only
	DW	FR_dmTF			;* text & foreground
	DW	FR_dmTB			;* text & background
	DW	FR_dmTMb		;* Text Map background
	DW	FR_dmTMf		;* Text Map foreground
	DW	FR_dmMb			;* Map background
	DW	FR_dmMf			;* Map foreground
	DW	FR_dmMfb		;* Map attr: back 2 back, fore 2 fore
	DW	FR_dmMAttr		;* Map attribute to attribute

ifdef	KANJI
;*	* Drawing routine table for FillRectangle for DBCS fill
;*	* (attribute only functions stay the same)
mpdmnpfnDrawFR_DBCS:
	DW	FR_dmTFB_DBCS		;* Normal
	DW	FR_dmT_DBCS		;* Text only
	DW	FR_dmFB			;* ca only (same as normal)
	DW	FR_dmF			;* foreground only
	DW	FR_dmB			;* background only
	DW	FR_dmTF_DBCS		;* text & foreground
	DW	FR_dmTB_DBCS		;* text & background
	DW	FR_dmTMb_DBCS		;* Text Map background
	DW	FR_dmTMf_DBCS		;* Text Map foreground
	DW	FR_dmMb			;* Map background
	DW	FR_dmMf			;* Map foreground
	DW	FR_dmMfb		;* Map attr: back 2 back, fore 2 fore
	DW	FR_dmMAttr		;* Map attribute to attribute.
endif	;KANJI

endif	; !DRAW_MODE_MINIMIZE

;*****************************************************************************

;********** DoDraw **********
;*	entry : ES:DI => screen location
;*		DX = pointer to table (mpdmnpfnDrawXX)
;*		CX = # of screen locations
;*		BX = di (drawing info) : BH = dm, BL = isa
;*		DS:SI => string (Text Out variant)
;*		 (DS => default DS (==SS))
;*		non-kanji LOBYTE(SI) = fill character (Fill Rectangle variant)
;*		kanji SI = fill double byte character (double byte Fill variant)
;*		D flag cleared !!
;*		ayDrawing and axDrawFirst set up !
;*		for overlap pwndCur is the current window (0=>draw always)
;*	* Prepare & call draw routine
;*	exit : ES:DI => after last character/attrib munged over
;*	TRASHES SI !!!!

do_draw_end1:
	jmp	do_draw_end

cProc	DoDraw,<NEAR,ATOMIC>,<BP>
cBegin	DoDraw

	AssertUp
	Assert <caSa EQ rgcaFill+1>		;* caSa MUST be in high byte

	Save	<es, bx, cx, dx>
	cCall	insj.lpfnPrepUpdateCsdInsj, <ayDrawing, axDrawFirst, cx, di, fRestoreDbcs>

	jcxz	do_draw_end1			;* trivial case

ifdef	MOUSE_TEXT
;*	* If ayDrawing == ayMouse{new} then kill mouse
	mov	al,ayMouse
	cmp	al,ayDrawing
	jne	not_drawing_over_mouse
else	; MOUSE_TEXT
;*	* If ABS(ayDrawing - ayMouse{new}) = FE,FF,0,1,2 then kill mouse
	mov	al,ayMouse
	sub	al,ayDrawing
	add	al,2				;* 0, 1, 2, 3, 4 => kill it
	cmp	al,5
	jae	not_drawing_over_mouse
endif	; MOUSE_TEXT
;*	* We may be drawing over mouse
	mov	al,0ffh				;* set value
	xchg	fMouseLockedOut,al		;* set flag, get old contents
	or	al,al
	jnz	already_locked_out
;*	* Turn mouse off
	xor	ax,ax				;* turn off
	Save	<bx,cx,dx>
	cCall	FEnableMouse,<ax>
	mov	fMouseLockedOut,al		;* save old state
already_locked_out:

not_drawing_over_mouse:

	Assert	<SIZE SA EQ 2>
	mov	ah,bh				;* ah = dm
	xor	bh,bh
	shl	bx,1				;* bx = isa * sizeof(SA)
ifdef	SCREEN_FFONT
	Assert	<SIZE SA EQ 2>			;* sizeof(SA) == sizeof(FFONT)
	mov	bp,[bx]+dataOffset mpisaffont
	mov	ffontCur,bp
endif	;SCREEN_FFONT
	mov	bp,[bx].rgcaFill+dataOffset rgsa;* bp = rgcaFill, bp(high) = caSa
	mov	bl,ah				;* ah = bl = dm
	shl	bx,1				;* bl = dm * sizeof(PROC NEAR)
						;*  lose the fdmKeepFfont bit
	xor	bh,bh
	add	bx,dx				;* bx = &mpdmnpfnDrawXX[dm]
	mov	bx,cs:[bx]			;* table look up procedure

ifdef	SCREEN_FFONT
;*	* ah = dm
	or	ah,ah				;* fdmKeepFfont bit set ?
	js	no_draw_ffont			;* keep the old FFONT
	cmp	fFontAvailable,0
	jz	no_draw_ffont
;*	* DI => start offset, CX = # of chars
	push	es
	push	di
	push	cx
	AssertNE instCur.psSecInst,0
	mov	es,instCur.psSecInst
	mov	ax,ffontCur
	rep stosw				;* fill in FFONT values
	pop	cx
	pop	di
	pop	es
no_draw_ffont:
endif	;SCREEN_FFONT

	push	di				;* start buffer offset
	push	cx				;* dax
	call	bx				;* call routine
	pop	cx
	pop	bx

;*	* inform driver that the line is done
	Save	<es>
	cCall	insj.lpfnDoUpdateCsdInsj, <ayDrawing, axDrawFirst, cx, bx, fRestoreDbcs>
					;* (ay, axFirst, dax, offFirst)
					;* note -- offset in primary!
do_draw_end:

cEnd	DoDraw


ifdef	KANJI
;*********** FlushDraw **********
;*	entry: n/a
;*	* update must be drawn NOW
;*	*  calls FinishDraw, sets hold update counter to zero
;*	exit: n/a

cPrivate FlushDraw, <ATOMIC>
cBegin	nogen

	mov	cHoldUpdate,0
	jmp	short finished_drawing

cEnd	nogen
endif	; KANJI


;*********** EndDraw **********
;*	entry: n/a
;*	* decrements the hold update counter which defers the call
;*	*  to DoUpdate.  If necessary, calls FinishDraw.
;*	exit: n/a

cPrivate EndDraw, <ATOMIC>
cBegin	EndDraw

ifdef	KANJI
	cmp	cHoldUpdate,0		;* FlushDraw may occur at any level of
	je	finished_drawing	;*  nesting, stop cHoldUpdate < 0
endif	; KANJI

	dec	cHoldUpdate
	jnz	not_finished_drawing
finished_drawing:			;* from FlushDraw aswell!!
	cCall	FinishDraw
not_finished_drawing:

cEnd	EndDraw

;*********** FinishDraw **********
;*	entry: n/a
;*	* drawing is done for now
;*	* inform the screen driver
;*	*  then turn mouse back on (if it was turned off)
;*	exit: n/a

cProc	FinishDraw, <NEAR, ATOMIC>
cBegin	FinishDraw

	test	cHoldUpdate,0ffh
	jnz	mouse_ok

	cCall	insj.lpfnDoneUpdateCsdInsj		;* ()

	mov	ayDrawing,ayNil			;* clear ayDrawing first
	test	fMouseLockedOut,0ffh
	jz	mouse_ok			;* it was not turned off
	cCall	FEnableMouse,<sp>

ifdef	DEBUG
	or	ax,ax				;* MUST have been turned off
	jz	clear_locked_out_flag
	cCall	CowAssertFailed
	DB	"mouse$"
endif	;DEBUG

clear_locked_out_flag:
	mov	fMouseLockedOut,al

mouse_ok:

cEnd	FinishDraw

;*****************************************************************************

;********** Draw Routines **********
;*	entry : ES:DI => screen (character, attribute at +1)
;*		CX = # of operations
;*		AL = new character (Fill Only)
;*		DS:SI => string (TextOut Only)
;*		DX = CGA video status port (3DAh)
;*		BP = rgcaFill (for map modes only) or high byte = caSa
;*		D flag cleared
;*	available registers :
;*		BX = work register
;*		AL, AH = work
;*	exit : n/a
;*	* NOTE: for overlapping windows, check that psOverlap:DI is pointing to
;*	*  our window (pwndDraw).

DRAW_ROUTINES	PROC NEAR

;*	* TextOut Variants
TO_dmTFB:	;* Text + attributes
	lodsb
	CheckWnd TO_dmTFB_next
	mov	bx,bp				;* set bh = attribute
	mov	bl,al				;* set bl = character
ifdef	BUILTIN_SNOW
	mov	dx,3DAh			;* CGA video status port
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	ax,bx
	stosw					;* only time for 1 store
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
TO_dmTFB_next:
	loop	TO_dmTFB
	ret

TO_dmT:		;* Text only
	lodsb					;* get byte
	CheckWnd TO_dmT_next
	mov	bl,al
ifdef	BUILTIN_SNOW
	mov	dx,3DAh
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	al,bl
	stosb
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
	inc	di
TO_dmT_next:
	loop	TO_dmT
	ret

ifndef	DRAW_MODE_MINIMIZE

TO_dmTF:	;* leave background alone
	mov	bh,ah
l1_tf:	lodsb
	CheckWnd TO_dmTF_next
	mov	bx,bp				;* bh = attribute
	mov	bl,al
ifdef	BUILTIN_SNOW
	mov	dx,3DAh
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	ah,es:[di+1]
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
	and	ah,0F0H
	or	bh,ah
ifdef	BUILTIN_SNOW
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	ax,bx
	stosw
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
TO_dmTF_next:
	loop	l1_tf
	ret

TO_dmB:		;* background only
	CheckWnd TO_dmB_next
	mov	bx,bp				; bh has new bg in hi nybble
	and	bh,0F0H				; change background only
	inc	di
ifdef	BUILTIN_SNOW
	mov	dx,3DAh
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	al,es:[di]			; al = old attribute
	and	al,0Fh				; al = old foreground only
	or	al,bh				; al = old fore & new back
	stosb					;* only time for 1 store
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
TO_dmB_next:
	loop	TO_dmB
	ret

TO_dmTMb:	;* character + map background
	CheckWnd TO_dmTMb_next
ifdef	BUILTIN_SNOW
	mov	dx,3DAh
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	bl,es:[di+1]
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
	lodsb					;* get character in AL
	and	bx,00F0H
	shr	bx,1
	shr	bx,1
	shr	bx,1
	shr	bx,1
	add	bx,bp
	mov	ah,ds:[bx]			;* look up new attribute
	mov	bx,ax
ifdef	BUILTIN_SNOW
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	ax,bx
	stosw
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
TO_dmTMb_next:
	loop	TO_dmTMb
	ret

FR_dmMf:
TO_dmMf:		;* map foreground
	CheckWnd FR_dmMf_next
	inc	di
ifdef	BUILTIN_SNOW
	mov	dx,3DAh
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	bl,es:[di]
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
	and	bx,000FH
	add	bx,bp
	mov	bl,ds:[bx]			;* look up new attribute
ifdef	BUILTIN_SNOW
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	al,bl
	stosb
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
FR_dmMf_next:
	loop	TO_dmMf
	ret


TO_dmMfb:	;* Map attribute: old background maps to new background, 
		;                 old foreground maps to new foreground.
		;  Note: the tables for these guys are 16 + 16 bytes each.

	inc	di
ifdef	BUILTIN_SNOW
	mov	dx,3DAh
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	bl,es:[di]			;* get old attribute
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
	and	bx,000FH			;* mask to foreground
	add	bx,bp
	mov	bl,ds:[bx]			;* look up new foreground
	push	bx				;* save BL = new foreground

ifdef	BUILTIN_SNOW
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	bl,es:[di]			;* get old attribute
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
	and	bx,00F0H			;* mask to background
	shr	bx,1
	shr	bx,1
	shr	bx,1
	shr	bx,1
	add	bx,bp				;* bx = &rgca[background]
	add	bx,16				;* bg's follow fg's in array.

ifdef	BUILTIN_SNOW
	StartDrawCrit
endif	;BUILTIN_SNOW
	pop	ax				;* restore AL = new fground
	or	al,ds:[bx]			;* Merge in new background
	stosb
ifdef	BUILTIN_SNOW
	EndDrawCrit
	dec	cx
	or	cx,cx
	jz	@F
	jmp	TO_dmMfb
@@:
ELSE	;NOT DEFINED BUILTIN_SNOW
	loop	TO_dmMfb
endif	;BUILTIN_SNOW
	ret

TO_dmMAttr:	;* Map entire attribute: old attr maps to new attr.
		;  Note that the tables for these guys are 256 bytes each.

	inc	di
ifdef	BUILTIN_SNOW
	mov	dx,3DAh
	StartDrawCrit
endif	;BUILTIN_SNOW
	xor	bx,bx				; BH = 0 for indexing.
	mov	bl,es:[di]			;* get old attribute
	add	bx,bp
	mov	al,ds:[bx]			;* look up new attribute
	stosb
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
	loop	TO_dmMAttr
	ret

endif	; !DRAW_MODE_MINIMIZE


;*****************************************************************************
;*	* Fill Rectangle Variants
FR_dmTFB:	;* normal
	mov	ax,si				;* al = character
	mov	bx,bp				;* bh = attribute
	mov	bl,al				;* bx = ca:ch
FR_dmTFB_1:
	CheckWnd FR_dmTFB_next
ifdef	BUILTIN_SNOW
	mov	dx,3DAh
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	ax,bx
	stosw					;* store one
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
FR_dmTFB_next:
	loop	FR_dmTFB_1
	ret

ifndef	DRAW_MODE_MINIMIZE

FR_dmT:		;* text only
	mov	bx,si				;* bl = character
	jmp	short FR_dmFB_1

endif	; !DRAW_MODE_MINIMIZE

FR_dmFB:	;* ca only
	mov	bx,bp				;* bh = attribute
	mov	bl,bh				;* bl = value to store
	inc	di				;* point to ca
;*	* this breaks the window test!!!!

FR_dmFB_1:
	CheckWnd FR_dmFB_next
ifdef	BUILTIN_SNOW
	mov	dx,3DAh
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	al,bl
	stosb					;* store one
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
	inc	di				;* to next ca
FR_dmFB_next:
	loop	FR_dmFB_1
	ret

ifndef	DRAW_MODE_MINIMIZE

FR_dmB:	;* fill background only
	mov	bx,bp				;* bh = attribute
	and	bh,0F0H				;* change background only
	mov	bl,00FH				;* keep mask
	jmp	short FR_dmF_1

FR_dmF:	;* fill foreground only
	mov	bx,bp				;* bh = attribute
	and	bh,00FH				;* change foreground only
	mov	bl,0F0H				;* keep mask
FR_dmF_1:
	inc	di				;* point to ca
;*	* this breaks the window test!!!!
	push	bp				;* bp used for temp
FR_dmF_2:
	CheckWnd FR_dmF_next
ifdef	BUILTIN_SNOW
	mov	dx,3DAh
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	al,es:[di]			;* get old background
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
	and	al,bl				;* keep half
	or	al,bh				;* replace half
	mov	bp,ax
ifdef	BUILTIN_SNOW
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	ax,bp
	stosb
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
	inc	di
FR_dmF_next:
	loop	FR_dmF_2
	pop	bp				;* restored trashed bp
	ret

FR_dmTMb:	;* character + map background
	CheckWnd FR_dmTMb_next
ifdef	BUILTIN_SNOW
	mov	dx,3DAh
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	bl,es:[di+1]			;* get old attribute
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
	and	bx,00F0H			;* mask background
	shr	bx,1
	shr	bx,1
	shr	bx,1
	shr	bx,1
	add	bx,bp				;* bx = &rgca[background]
	mov	ax,si				;* load character (into al)
	mov	ah,ds:[bx]			;* look up new attribute
	mov	bx,ax
ifdef	BUILTIN_SNOW
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	ax,bx
	stosw
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
FR_dmTMb_next:
	loop	FR_dmTMb
	ret


FR_dmMb:	;* map background only
	CheckWnd FR_dmMb_next
	inc	di				;* point to attribute
ifdef	BUILTIN_SNOW
	mov	dx,3DAh
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	bl,es:[di]			;* get old attribute
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
	and	bx,00F0H			;* mask background
	shr	bx,1
	shr	bx,1
	shr	bx,1
	shr	bx,1
	add	bx,bp				;* bx = &rgca[background]
	mov	bl,ds:[bx]			;* look up new attribute
ifdef	BUILTIN_SNOW
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	al,bl
	stosb
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
FR_dmMb_next:
	loop	FR_dmMb
	ret

endif	; !DRAW_MODE_MINIMIZE


;*****************************************************************************
;*	* DBCS Fill Rectangle Variants (text modify only)
;*	* all entry points should start with "shr cx,1"

ifdef	KANJI

FR_dmTFB_DBCS:	;* normal
	shr	cx,1
	mov	dx,si				;* dx = DB character (dl first)
	mov	bx,bp				;* bh = attribute
	mov	bl,dl				;* BX = first ca:ch
	mov	dl,dh
	mov	dh,bh				;* DX = second ca:ch
FR_dmTFB_1_DBCS:
	CheckWnd FR_dmTFB_next_DBCS
ifdef	BUILTIN_SNOW
	push	cx
	mov	cx,dx
	mov	dx,3DAh
	StartDrawCrit
	mov	ax,bx
	stosw					;* store first character
	mov	ax,cx
	stosw					;* store second character
	EndDrawCrit
	pop	cx
ELSE	; !BUILTIN_SNOW
	mov	ax,bx
	stosw					;* store first character
	mov	ax,dx
	stosw					;* store second character
endif	;BUILTIN_SNOW

FR_dmTFB_next_DBCS:
	loop	FR_dmTFB_1_DBCS
	ret

ifndef	DRAW_MODE_MINIMIZE

FR_dmT_DBCS:		;* text only
	shr	cx,1
	mov	bx,si				;* bl = 1st, bh = 2nd
FR_dmFB_1_DBCS:
	CheckWnd FR_dmFB_next_DBCS
ifdef	BUILTIN_SNOW
	mov	dx,3DAh
	StartDrawCrit
endif	;BUILTIN_SNOW
	mov	al,bl
	stosb					;* store one
	inc	di				;* to next ca
	mov	al,bh
	stosb					;* store one
ifdef	BUILTIN_SNOW
	EndDrawCrit
endif	;BUILTIN_SNOW
	inc	di				;* to next ca
FR_dmFB_next_DBCS:
	loop	FR_dmFB_1_DBCS
	ret

endif	; !DRAW_MODE_MINIMIZE

endif	;KANJI

;*****************************************************************************

ifndef	DRAW_MODE_MINIMIZE

;*	???? UNIMPLEMENTED !!!!!!
TO_dmF:
TO_dmTB:
TO_dmTMf:
TO_dmMb:
FR_dmTF:
FR_dmTB:
FR_dmTMf:
FR_dmMfb:
FR_dmMAttr:
ifdef	KANJI
FR_dmTF_DBCS:
FR_dmTB_DBCS:
FR_dmTMf_DBCS:
FR_dmTMb_DBCS:
endif	;KANJI

;??????

endif	; !DRAW_MODE_MINIMIZE

InvalidMode:
ifdef	DEBUG
	cCall	CowAssertFailed
	DB	"Invalid draw mode $"
endif	;DEBUG
	ret

DRAW_ROUTINES	ENDP		;* all near

;*****************************************************************************

;********** EndScreen **********
;*	entry:	fClear => clear screen
;*	* Exit procedure - clear the screen
;*	exit:	n/a

cPublic	EndScreen,<PUBLIC, ATOMIC>
	parmW fClear
cBegin	EndScreen

	StartPublic

	mov	cx,fClear
	jcxz	dont_clear

ifdef	REVIEW
	mov	al,caOld
ELSE
	mov	al,7
endif	;!REVIEW
	mov	ah,al				;* duplicate for MONO
	xchg	ax,[rgsa]			;* change isa == 0
	push	ax				;* save old

	xor	ax,ax
	mov	bx,' '
	xor	cx,cx
	xor	dx,dx
	mov	cl,axMac
	mov	dl,ayMac
ifdef	WINDOW_OVERLAP
	xor	ax,ax
	mov	pwndCur,ax
endif	;WINDOW_OVERLAP
	cCall	FillArc,<ax,ax,cx,dx,bx,ax>	;* fill all with ' ' isaDefault

	pop	word ptr [rgsa]			;* restore old isaDefault

	xor	ax,ax
	cCall	insj.lpfnMoveHwCursCsdInsj,<ax,ax,sp>	;* top of screen & on

dont_clear:
;*	* kill the screen driver
	cCall	insj.lpfnTermCsdInsj		;* ()

	StopPublic

cEnd	EndScreen

;*****************************************************************************


;********** ImodeGuessCurrent **********
;*	entry: n/a
;*	* call driver to guess current mode
;*	exit:	AX = imode (or -1 (imodeUnkown) if not known)

labelFP	<PUBLIC, ImodeGuessCurrent>
	jmp	insj.lpfnImodeGuessCurrentCsdInsj



;********** FQueryInst **********
;*	entry:
;*		pinst : pointer to INST structure to fill
;*		imode : index of mode to test
;*	* Get information about modes available
;*	* just call the INSJ procedure
;*	exit:	AX != 0 => ok (*pinst filled in)
;*		== 0 => error (imode too high or can't query)

IFDEF	DEBUG

cPublic	FQueryInst,<PUBLIC>
	parmW pinst
	parmW imode
cBegin	FQueryInst

	cCall	insj.lpfnFQueryInstCsdInsj,<pinst,imode>

	or	ax,ax					; If bogus mode, 
	jz	fqi_done				;   can't check inst.

	mov	bx,pinst

	test	[bx].finstInst,finstExtendedMono	; If ExtendedMono,
	jz	@F					;   then must have
	test	[bx].finstInst,finstAttrFont		;   AttrFont.
	jz	bust
@@:
	test	[bx].finstInst,finstAttrFont
	jz	fqi_done
	test	[bx].finstInst,finstMonochrome		; If AttrFont, then
	jz	bust					;   must have Mono
	test	[bx].finstInst,finstText		;   and Text.
	jnz	fqi_done
bust:	
	cCall	CowAssertFailed
	DB	"FQueryInst fInst bits not in sync.$"

fqi_done:

cEnd	FQueryInst

ELSE	;!DEBUG

labelFP	<PUBLIC, FQueryInst>
	jmp	insj.lpfnFQueryInstCsdInsj

ENDIF	;!DEBUG



;********** FGetColorPalette **********
;*	entry:	co	color
;*		pcoi	color combination index (returned)
;*		rgcov	RGB palette info (returned)
;*	* get current palette setting for co
;*	exit:	AX = 0 => no color palette available, pcoi, rgcov

labelFP	<PUBLIC, FGetColorPalette>
	jmp	insj.lpfnFGetColorPaletteCsdInsj



;********** SetColorPalette **********
;*	entry:	co	color
;*		coi	color combination index
;*		rgcov	RGB palette info
;*	* set current palette setting for co, does nothing if no color palette
;*	exit:	n/a

labelFP	<PUBLIC, SetColorPalette>
	jmp	insj.lpfnSetColorPaletteCsdInsj



;********** MoveHardwareCursor **********
;*	entry:	axCurs, ayCurs = new absolute cursor position
;*		fOn => whether on or off
;*	exit:	n/a

labelFP	<PUBLIC, MoveHardwareCursor>
	jmp	insj.lpfnMoveHwCursCsdInsj



;********** FQueryInft **********
;*	entry:	pinft, ifont
;*	* get font info
;*	exit:	AX = 0 => no more fonts

labelFP	<PUBLIC, FQueryInft>
	jmp	insj.lpfnFQueryInftCsdInsj


;********** GetCharMap **********
;*	entry:	pinft, ifont
;*	* get font info
;*	exit:	AX = 0 => no more fonts

labelFP	<PUBLIC, GetCharMap>
	jmp	insj.lpfnGetCharMapCsdInsj


ifdef	WINDOW_OVERLAP
;********** FAllocOverlapTable **********
;*	entry:	pfnAlloc => allocation function (supplied by App)
;*		pinst    => current INST infor
;*	* Allocate memory for the overlapping windows table
;*	* Note!! pinst must have been set up already (FQueryInst)
;*	exit:	AX != 0 if successful

cPublic	FAllocOverlapTable, <>, <SI>
	parmDP pinst		;* INST info
	parmD  pfnAlloc2		;* FAR PASCAL routine
cBegin	FAllocOverlapTable

	mov	si,pinst

	mov	al,[si].axMacInst
	mov	ah,[si].ayMacInst
	mul	ah
	mov	bx,ax

	mov	ax,fmemFixed
	Save	<bx>
	cCall	pfnAlloc2, <bx, ax>
	AssertEQ ax,0

	or	dx,dx
	jz	end_alloc_overlap		;* return AX == 0

	mov	psOverlap,dx

	mov	ax,sp				;* success

end_alloc_overlap:

cEnd	FAllocOverlapTable




;********** FreeOverlapTable **********
;*	entry:	pfnFree => free function (supplied by App)
;*	* free video driver buffers
;*	exit:	n/a

cPublic	FreeOverlapTable, <>, <SI>
	parmD  pfnFree2		;* FAR PASCAL routine
cBegin	FreeOverlapTable

	xor	cx,cx
	xchg	cx,psOverlap
	jcxz	done_overlap_free
	xor	ax,ax
	cCall	pfnFree2, <cx, ax>
done_overlap_free:

cEnd	FreeOverlapTable
endif	;*WINDOW_OVERLAP




;********** FAllocInstBuffers **********
;*	entry:	pinstAlloc => INST info to fill
;*		pfnAlloc => allocation function (supplied by App)
;*		fFonts => if secondary buffer wanted
;*	* Allocate memory for video driver buffers
;*	exit:	AX != 0 if successful

cPublic	FAllocInstBuffers, <>, <SI>
	parmDP pinstAlloc
	parmD  pfnAlloc		;* FAR PASCAL routine
	parmW  fFonts
cBegin	FAllocInstBuffers

	StartPublic

	mov	si,pinstAlloc

IFNDEF SCREEN_FFONT
	AssertEQ fFonts,0			;* not allowed
endif	;!SCREEN_FFONT

;*	* determine size of buffer (axMac * ayMac WORDS)
	mov	al,[si].axMacInst
	mov	ah,[si].ayMacInst
	mul	ah
	mov	bx,ax

	xor	ax,ax
	mov	[si].bits0Inst,ax		;* clear bits
;*	* first check to see if primary buffer needs allocation
	cmp	[si].psPrimInst,ax		;* == 0 ?
	jne	done_prim_alloc

	mov	ax,fmemFixed
	Save	<bx>
	cCall	pfnAlloc, <bx, ax>
	AssertEQ ax,0

	or	dx,dx
	jz	end_alloc			;* return AX == 0

	mov	[si].psPrimInst,dx
	or	[si].bits0Inst,MASK fAllocPrimInst
done_prim_alloc:

ifdef	SCREEN_FFONT
;*	* allocate secondary buffer if needed (bx = size of buffer)
	mov	cx,fFonts
	jcxz	no_sec_buffer
	test	[si].finstInst,finstFont
	jz	no_sec_buffer
	mov	ax,fmemFixed
	cCall	pfnAlloc, <bx, ax>
	AssertEQ ax,0

	or	dx,dx
	jz	end_alloc			;* return AX == 0

	mov	[si].psSecInst,dx
no_sec_buffer:
endif	;SCREEN_FFONT

;*	* allocate any needed driver specific memory
	mov	cx,[si].cwExtraInst
	jcxz	done_extra_alloc

	mov	ax,fmemFixed
	cCall	pfnAlloc, <cx, ax>
	AssertEQ ax,0

	or	dx,dx
	jz	end_alloc			;* return AX == 0

	mov	[si].psExtraInst,dx
done_extra_alloc:

	mov	ax,sp				;* success

end_alloc:

	StopPublic

cEnd	FAllocInstBuffers



;********** FreeInstBuffers **********
;*	entry:	pinstFree => INST info to free
;*		pfnFree => free function (supplied by App)
;*	* free video driver buffers
;*	exit:	n/a

cPublic	FreeInstBuffers, <>, <SI>
	parmDP pinstFree
	parmD  pfnFree		;* FAR PASCAL routine
cBegin	FreeInstBuffers

	StartPublic

	mov	si,pinstFree

	test	[si].bits0Inst,MASK fAllocPrimInst
	jz	done_prim_free

	xor	ax,ax
	cCall	pfnFree, <[si].psPrimInst, ax>

	and	[si].bits0Inst,NOT (MASK fAllocPrimInst)
done_prim_free:

ifdef	SCREEN_FFONT
	xor	cx,cx
	xchg	cx,[si].psSecInst
	jcxz	done_sec_free
	xor	ax,ax
	cCall	pfnFree, <cx, ax>
done_sec_free:
ELSE
	AssertEQ [si].psSecInst,0
endif	;!SCREEN_FFONT

;*	* free driver buffer
	xor	cx,cx
	xchg	cx,[si].psExtraInst
	jcxz	done_extra_free
	xor	ax,ax
	cCall	pfnFree, <cx, ax>

done_extra_free:

	StopPublic

cEnd	FreeInstBuffers



;*****************************************************************************


;********** FInitScreenInternal **********
;*	entry: pinst => INST structure (NULL => re-init previous mode)
;*	* Initialize the screen as needed
;*	* NOTE : this routine can be called ONLY ONCE.
;*	exit: AX != 0 => ok
;*		* NOTE: failure may destroy old instCur

cPublic FInitScreenInternal,<ATOMIC>, <SI, DI>
	parmW pinst
cBegin	FInitScreenInternal

	StartPublic

	mov	bx,dataOffset instCur
	mov	si,pinst
	or	si,si
	jz	use_current
;*	* set new INST (copy into instCur)
	push	ds
	pop	es
	mov	di,bx
	mov	cx,cbInstMin / 2
	rep movsw
use_current:	;* bx => instCur (instCur filled with *pinst)

	mov	ax,ds:[bx].finstInst
	and	ax,finstAvailable
	jnz	dont_end
end_init_jump:
	jmp	end_init			;* variant not available

dont_end:
	mov	ax,dataOffset inch
	Save	<bx>
	cCall	insj.lpfnFInitCsdInsj, <bx, ax>	;* (pinst, pinch)
	or	ax,ax
	jz	end_init_jump

;*	* move info from INCH to other globals, bx => instCur
	mov	al,[bx].axMacInst
	mov	axMac,al
	xor	ah,ah
	shl	ax,1
	mov	axMacTimes2,ax
	mov	al,[bx].ayMacInst
	mov	ayMac,al
	mov	ax,[bx].finstInst
	and	al,finstMonochrome	;* finstMonochrome in lower byte
	mov	fMonochrome,al

IFNDEF	CBOX
;*	* copy information from INCH into boxes
	lea	bx,inch
	push	ds
	pop	es			;* all in default data segment

;*	* copy single box
	lea	si,[bx]._chTopLeftCorner1Inch
	lea	di,boxSingle
	mov	cx,SIZE BOX / 2
	rep movsw
;*	* copy double box
	lea	si,[bx]._chTopLeftCorner2Inch
	lea	di,boxDouble
	mov	cx,SIZE BOX / 2
	rep movsw

	mov	al,[bx]._chShadowInitInch
	mov	chShadow,al

ifdef	WINDOW_OVERLAP
;*	* base window is single box
	lea	si,[bx]._chTopLeftCorner1Inch
	lea	di,boxActiveWindowOut
	mov	cx,SIZE BOX / 2
	rep movsw
	mov	al,[bx]._chCloseInch
	mov	boxActiveWindowOut.chTopLeftBox,al
	mov	al,[bx]._chZoomOutInch
	mov	boxActiveWindowOut.chTopRightBox,al
	mov	al,[bx]._chTopSide2Inch
	mov	boxActiveWindowOut.chTopBox,al
	lea	si,[bx]._chTopLeftCorner1Inch
	lea	di,boxInactiveWindowOut
	mov	cx,SIZE BOX / 2
	rep movsw
	mov	al,[bx]._chCloseInch
	mov	boxInactiveWindowOut.chTopLeftBox,al
	mov	al,[bx]._chZoomOutInch
	mov	boxInactiveWindowOut.chTopRightBox,al

	lea	si,[bx]._chTopLeftCorner1Inch
	lea	di,boxActiveWindowIn
	mov	cx,SIZE BOX / 2
	rep movsw
	mov	al,[bx]._chCloseInch
	mov	boxActiveWindowIn.chTopLeftBox,al
	mov	al,[bx]._chZoomInInch
	mov	boxActiveWindowIn.chTopRightBox,al
	mov	al,[bx]._chTopSide2Inch
	mov	boxActiveWindowIn.chTopBox,al
	lea	si,[bx]._chTopLeftCorner1Inch
	lea	di,boxInactiveWindowIn
	mov	cx,SIZE BOX / 2
	rep movsw
	mov	al,[bx]._chCloseInch
	mov	boxInactiveWindowIn.chTopLeftBox,al
	mov	al,[bx]._chZoomInInch
	mov	boxInactiveWindowIn.chTopRightBox,al
endif	;WINDOW_OVERLAP

endif	; !CBOX

ifdef	SCREEN_FFONT
;*	* set the fFontAvailable flag
	xor	ax,ax			;* assume off
	mov	cx,instCur.finstInst
	test	cx,finstFont
	jz	set_ffont_available	;* not available in this mode
	mov	cx,instCur.psSecInst
	jcxz	set_ffont_available	;* no secondary buffer => forget it
	inc	ax			;* yes, we can use ffonts
set_ffont_available:
	mov	fFontAvailable,ax
endif	;SCREEN_FFONT

	mov	ax,sp			;* success

end_init:	;* ax = return code

	StopPublic

cEnd	FInitScreenInternal



;********** BltArc **********
;*	entry : axSrc, aySrc : upper left of source
;*		axDest, ayDest : upper left of destination
;*		dax, day : shift amount
;*	* Move a rectangle from one portion of the screen to another.
;*	exit : n/a

cPrivate BltArc,<ATOMIC>,<SI,DI>
	parmB axDest
	parmB ayDest
	parmB dax 
	parmB day
	parmB axSrc
	parmB aySrc

	localW fMouseOn				;* FEnableMouse old state
	localW offDestLim				;* last offset written
cBegin	BltArc

	StartPublic

	xor	ax,ax
	cCall	FEnableMouse,<ax>		;* turn mouse off
	mov	fMouseOn,ax

	AssertUp

	mov	al,day
	or	al,al
	jz	blt_end1			;* trivial case (day == 0)

	CalcCoord axDest,ayDest
	mov	di,ax
	mov	offDrawFirst,ax			;* save for driver inform

;*	* Do either a Prep, Do, Done sequence or a fast BltArcCsd call
	test	instCur.finstInst,finstFastScroll
	jnz	skip_prep

;*	* Prepare screen driver for update
	mov	si,word ptr (dax)	;* low byte is all that's interesting
;*	* si = dax, di = offset in Prim buffer
;*	* ax = ayDest, cx = day
	xor	ax,ax
	mov	al,ayDest
	xor	cx,cx
	mov	cl,day
	push	di
loop_prep:
	Save	<ax,cx>
	cCall	insj.lpfnPrepUpdateCsdInsj, <ax, axDest, si, di, fRestoreDbcs>
	add	di,axMacTimes2			;* point to next row
	inc	ax
	loop	loop_prep
	pop	di
skip_prep:

	CalcCoord axSrc,aySrc
	mov	si,ax			; save pointer to source
	mov	dx,axMacTimes2		;* row modulus
	cmp	ax,di
	jge	blt_hilo		; going from high memory to low

; go from low memory to high.  Do backwards Blt  Blt Row by row either 
; fast or slow depending on the retrace parameter; ax has source, di
; destination of top left hand point

	mov	al,day
	dec	al
	mul	axMac
	mov	bl,dax
	xor	bh,bh
	add	ax,bx
	shl	ax,1
	dec	ax			;* back 1 byte (for movsb)

	add	di,ax			; move source to bottom right
	add	si,ax			; move dest to bottom, right 

	neg	dx			;* negate row modulus
	std				; bltting backwards
	jmp	short blt_go

blt_end1:	;* jump extender
	jmp	blt_end

blt_hilo:
;	cld				;* D flag already cleared
blt_go:
;*	* dx = row modulus (+ or - axMac * 2)
	mov	cl,dax			; setup number of columns
	xor	ch,ch
	jcxz	blt_end1			;* trivial case (dax == 0)
	shl	cx,1			;* ccol -> cb
	mov	bx,cx			;* CX = BX = cb

	push	ds
ifdef	DEBUG
	cmp	instCur.psPrimInst,0	;* no buffer! (FAllocInstBuffers)
	jne	@F
	cCall	CowAssertFailed
	DB	"no primary buffer for current mode$"
@@:
endif	;DEBUG
	mov	es,instCur.psPrimInst
	push	es
	pop	ds			;* DS & ES set to video segment

	xor	ax,ax
	mov	al,day
ifdef	SCREEN_FFONT
	Save	<ax,bx,cx,dx,si,di>	;* needed for second call
	cCall	DoBltArc
	pop	ds
	cmp	fFontAvailable,0
	jz	no_blt_ffont

	push	ds
	mov	es,instCur.psSecInst
	push	es
	pop	ds			;* DS & ES set to video segment
endif	;SCREEN_FFONT
	cCall	DoBltArc
	pop	ds
no_blt_ffont:

	cld					;* Clear D flag (convention)

;* Check for fast scrolling in graphics text modes	
	test	instCur.finstInst,finstFastScroll
	jz	no_fast
	cCall	insj.lpfnBltArcCsdInsj, <axDest, ayDest, dax, day, axSrc, aySrc>
	jmp	skip_updatedone
no_fast:
	
;*	* Inform screen driver of the destination area
	mov	si,word ptr (dax)	;* low byte is all that's interesting
	mov	di,offDrawFirst
;*	* si = dax, di = offset in Prim buffer
loop_inform_blt:
	cCall	insj.lpfnDoUpdateCsdInsj, <ayDest, axDest, si, di, fRestoreDbcs>
	add	di,axMacTimes2			;* point to next row
	inc	ayDest
	dec	day
	jnz	loop_inform_blt

;*	* all done, refresh
	cCall	insj.lpfnDoneUpdateCsdInsj		;* ()

blt_end:

	cld					;* Clear D flag (convention)

skip_updatedone:

	cCall	FEnableMouse,<fMouseOn>		;* restore mouse state

	StopPublic

cEnd	BltArc


;********** DoBltArc **********
;*	entry : ax = day, bx = cx = cb, dx = row modulus, si = source,
;*		di = dest, es and ds => video segment
;*	* blt screen memory
;*	* NOTE: direction flag either set or clear on entry.
;*	exit : n/a

cProc	DoBltArc,<NEAR,PUBLIC,ATOMIC>
cBegin	DoBltArc

	assumes ds,nothing

ifdef	WINDOW_OVERLAP
	push	bp			;* current window do blt
	mov	bp,pwndCur
endif	;WINDOW_OVERLAP

blt_row:
	push	si
	push	di

blt_fast:
;*	* We can BLT fast
ifdef	WINDOW_OVERLAP
	or	bp,bp
	jz	blt_fast_allowed
blt_overlap:
	push	di
	and	di,not 1
	push	ds
	mov	ds,ss:psOverlap
	cmp	bp,[di]
	pop	ds
	je	move_two
;*	* skip this movement
	push	ax
	mov	di,si			;* old position
	lodsw				;* bump by 2 in right direction
	mov	ax,si
	sub	ax,di			;* ax = delta (+2 or -2)
	pop	di			;* old DI
	add	di,ax			;* DI points to new position
	pop	ax
	jmp	short move_overlap_next
move_two:
	pop	di
ifdef	BUILTIN_SNOW
	push	ax
	push	dx
	mov	dx,3DAh			;* CGA video status port
	StartDrawCrit
endif	;BUILTIN_SNOW	
	movsb
	movsb
ifdef	BUILTIN_SNOW
	EndDrawCrit
	pop	dx
	pop	ax
endif	;BUILTIN_SNOW
move_overlap_next:
	dec	cx
	loop	blt_overlap
	jmp	short blt_next_row

blt_fast_allowed:	;* fall through to rep move
endif	;WINDOW_OVERLAP
ifdef	BUILTIN_SNOW
	push	ax
	push	dx
	mov	dx,3DAh			;* CGA video status port
SnowL1:
	StartDrawCrit
	movsb
	EndDrawCrit
	loop	SnowL1
	pop	dx
	pop	ax
ELSE	;NOT DEFINED BUILTIN_SNOW
	rep	movsb			;* move byte to keep backward case
endif	;BUILTIN_SNOW
					;* simple.
blt_next_row:
	pop	di
	pop	si
	mov	cx,bx			;* restore cx as cb
	add	di,dx
	add	si,dx			; move to next/previous row
	dec	ax
	jnz	blt_row

ifdef	WINDOW_OVERLAP
	pop	bp
endif	;WINDOW_OVERLAP

cEnd	DoBltArc

sEnd	SCREEN

;----------------------------------------------------------------------------

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\screen.inc ===
;*
;*	CW : Character Oriented Windows
;*
;*	screen.inc : screen specific stuff (DOS version general)

;*	* Assembler version of SA structure (see color.c for C version) *
SA	STRUC
	bFiller	DB	?		;* filler
	caSa	DB	?		;* character attribute
SA	ENDS


;*	* UNIONS :
caColor		EQU BYTE PTR caSa		;* color initial value
caMono		EQU BYTE PTR bFiller		;* b&w initial value
rgcaFill	EQU WORD PTR bFiller		;* near pointer to array

dmNormal	EQU	0
dmText		EQU	1
dmForeBack	EQU	2
dmFore		EQU	3
dmBack		EQU	4
dmTextFore	EQU	5
dmTextBack	EQU	6

dmSpecialMin	EQU	7
dmTextMapB	EQU	7
dmTextMapF	EQU	8
dmMapB		EQU	9
dmMapF		EQU	10

;*	* Special values (for mouse drawing)
ayNil		EQU	253		;* set ayDrawing to ayNil if not drawing
		;* (can't be 254/255 since we allow 2 char for mouse height).

externFPublic <FEnableMouse>


;********** CalcCoord **********
;*	entry : axPos = ax position
;*		ayPos = ay position
;*	exit : AX = address of character in video segment
;*	* ONLY USE THIS MACRO IF YOU KNOW THE MOUSE IF OFF !!!
;*	* TRASHES AX,BX

CalcCoord MACRO axPos,ayPos
	mov	al,ayPos
	mul	axMac
	mov	bl,axPos
	xor	bh,bh
	add	ax,bx
	shl	ax,1		; ax = (ayPos * axMac + ayPos) * 2
ENDM

;********** CheckWnd **********
;*	entry:	di => offset in video segment
;*		skip = label to jump to
;*	* check if pwndCur is NULL or drawable window
;*	*  if not, add 2 to DI and jump to skip.
;*	exit:	only di changed (if jump taken)
IFDEF LATER
	... re-adjust DoDraw do that BP is free
ENDIF

IFDEF WINDOW_OVERLAP
externW <psOverlap>

CheckWnd MACRO skip
	LOCAL	do_it
	push	cx
	mov	cx,pwndCur
	jcxz	do_it
        push    di
        and     di,0fffeh
	push	ds
	mov	ds,psOverlap
	cmp	cx,[di]
	pop	ds
        pop     di
	je	do_it
	pop	cx
	lea	di,[di+2]		;* skip to next char
	jmp	short skip
do_it:
	pop	cx
ENDM	;CheckWnd

ELSE ; no overlap

CheckWnd MACRO skip
ENDM	;CheckWnd

ENDIF ;WINDOW_OVERLAP


IFDEF BUILTIN_SNOW

;;* CGA-old only
;;* QC/QB only
;;* For Twin compatibility sake

;********** WaitRetraceDefinite **********
;* MACRO
;*	entry : DX = portVideoStatus
;*	* waits for the start of a horizontal retrace
;*	* so video memory can be accessed flicker-free.
;*	exit : INTERRUPT DISABLED
;*		TRASHES AX, DX retained

WaitRetraceDefinite MACRO
	local	enable_int_window, wait_for_noretrace, wait_for_retrace, do_it

enable_int_window:
	sti
	mov	ah,20			;* magic number of iterations
	cli				;* clear interrupts for magic loop
wait_for_noretrace:
	dec	ah
	jz	enable_int_window
	in	al,dx			; fetch status
	test	al,8
	jnz	do_it
	test	al,1			; horizontal retracing?
	jnz	wait_for_noretrace	; yes, wait until no retrace
wait_for_retrace:
	in	al,dx			; fetch status
	test	al,9			; horizontal/vertical retracing?
	jz	wait_for_retrace	; no, wait...
do_it:
ENDM



;********** StartDrawCrit **********
;* MACRO
;*	* like WaitRetraceDefinite, but test if we have to wait first
;*	* next critical regions with StartDrawCrit/EndDrawCrit

StartDrawCrit MACRO
	local	no_wait
	cmp	fWaitRetrace,0
	je	no_wait

	WaitRetraceDefinite
no_wait:
ENDM


;********** EndDrawCrit **********
;* MACRO
;*	* after StartDrawCrit and the critical operation, enable interrupts

EndDrawCrit MACRO
	sti
ENDM

ENDIF 	;BUILTIN_SNOW

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\screen2.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	screen2.asm : more of installable screen drivers

	title	screen2 - More screen control code for CW

.xlist
	include	user.inc
	include uisa.inc		;* for isa's
	include	screen.inc		;* screen stuff

	include	inscr.inc
	include	indrv.inc

ifdef	KANJI
	include kanji.inc
endif	;KANJI

.list

;----------------------------------------------------------------------------

sBegin	DATA

	assumes DS,DGROUP

externB insj

ifdef	BUILTIN_SNOW
externB fWaitRetrace		;* snow protect for twin compatibility,QC only
endif	;BUILTIN_SNOW

sEnd	DATA

;----------------------------------------------------------------------------

sBegin	BSS

	assumes DS,DGROUP

externB	instCur			; data for installable drivers

externW	fRestoreDbcs		; => restore DBCS characters
				; stays 0 for non-KANJI

ifdef	SCREEN_FFONT
externW	fFontAvailable		; => ffont support allowed
endif	;SCREEN_FFONT

externW	offDrawFirst		; offset where drawing started
externB	axMac			; Maximum column number
externW	axMacTimes2		; for row modulus - WORD !!!

sEnd	BSS

;----------------------------------------------------------------------------

sBegin	SCREEN

	assumes CS,SCREEN
	assumes DS,DGROUP
	assumes SS,DGROUP
	assumes	ES,nothing

;********** SaveArc **********
;*	entry : axLeft, ayTop, axRight, ayBottom : rectangle
;*		lpb = buffer to save data in (assumed to be large enough).
;*	* Save ARC - NOTE: no interface to screen driver !!
;*	exit : n/a

	assumes DS,DATA

cPrivate SaveArc,<ATOMIC>,<SI,DI>

	parmB axLeft
	parmB ayTop
	parmB axRight
	parmB ayBottom			;* also day
	parmD lpb

ifdef	SCREEN_FFONT
	localW dbSec			;* secondary - primary (in lpb)
endif	;SCREEN_FFONT

	localW fMouseOn				;* FEnableMouse old state

cBegin	SaveArc

	AssertUp

	xor	ax,ax
	cCall	FEnableMouse,<ax>		;* turn mouse off
	mov	fMouseOn,ax

	mov	al,axMac
	cmp	axRight,al
	jbe	@F
	mov	axRight,al
@@:

ifdef	SCREEN_FFONT
;*	* calculate the dbSec (ayBottom-ayTop)*(axRight-axLeft)*2
	mov	al,ayBottom
	sub	al,ayTop
	mov	ah,axRight
	sub	ah,axLeft
	mul	ah			;* ax = cch
	shl	ax,1
	mov	dbSec,ax
endif	;SCREEN_FFONT

	CalcCoord axLeft,ayTop
	mov	si,ax			; setup video as source
	les	di,lpb			; setup far destination

	mov	cl,axRight		; load cx with #columns
	sub	cl,axLeft
	xor	ch,ch

	mov	al,ayTop
	sub	ayBottom,al		;* day
;	cld				-- already cleared
	push	ds
	mov	ds,instCur.psPrimInst
	assumes ds,nothing

savearc_loop:
	push	si
	push	cx

ifdef	SCREEN_FFONT
;*	* extra copy for FFONT
	cmp	fFontAvailable,0
	je	@F
	push	ds				;* ds=> prim buffer
	AssertNE instCur.psSecInst,0
	mov	ds,instCur.psSecInst
	push	si				;* si is correct
	push	di				;* must adjust to 2nd part
	add	di,dbSec
	push	cx				;* save count
	rep	movsw
	pop	cx
	pop	di
	pop	si
	pop	ds
@@:
endif	;SCREEN_FFONT

ifdef	BUILTIN_SNOW
	push	dx
	mov	dx,3DAh			;* CGA video status port
SnowL2:
	StartDrawCrit
	movsw
	EndDrawCrit
	loop	SnowL2
	pop	dx
ELSE	;NOT DEFINED BUILTIN_SNOW
	rep	movsw
endif	;BUILTIN_SNOW

	pop	cx
	pop	si
	add	si,axMacTimes2		; point to next row
	dec	ayBottom		;* day
	jnz	savearc_loop

	pop	ds
	assumes ds,dgroup

	cCall	FEnableMouse,<fMouseOn>	;* restore mouse state

cEnd	SaveArc



;********** RestoreArc **********
;*	entry : axLeft, ayTop, axRight, ayBottom : rectangle
;*		lpb => buffer to restore data from (assumed to be right size)
;*	exit : n/a

cPrivate RestoreArc,<ATOMIC>,<SI,DI>

	parmB axLeft
	parmB ayTop				;* also used to save day
	parmB axRight
	parmB ayBottom
	parmD lpb

ifdef	SCREEN_FFONT
	localW dbSec			;* secondary - primary (in lpb)
endif	;SCREEN_FFONT

	localW fMouseOn				;* FEnableMouse old state
	localB dayT
cBegin	RestoreArc

	AssertUp

	mov	al,axMac
	cmp	axRight,al
	jbe	@F
	mov	axRight,al
@@:

ifdef	SCREEN_FFONT
;*	* calculate the dbSec (ayBottom-ayTop)*(axRight-axLeft)*2
	mov	al,ayBottom
	sub	al,ayTop
	mov	ah,axRight
	sub	ah,axLeft
	mul	ah			;* ax = cch
	shl	ax,1
	mov	dbSec,ax
endif	;SCREEN_FFONT

	xor	ax,ax
	cCall	FEnableMouse,<ax>		;* turn mouse off
	mov	fMouseOn,ax

	CalcCoord axLeft,ayTop
	mov	di,ax
	mov	offDrawFirst,ax
	mov	es,instCur.psPrimInst
	push	ds
	lds	si,lpb			; setup pb as source
	assumes ds,nothing
	
	mov	cl,axRight		; load cx with #columns
	sub	cl,axLeft
	xor	ch,ch

	mov	al,ayTop
	sub	ayBottom,al		;* ayBottom == day
	mov	al,ayBottom
	mov	dayT,al			;* save for second use
;	cld				-- already cleared

restorearc_loop:
	push	cx
	push	di

ifdef	SCREEN_FFONT
;*	* extra copy for FFONT
	cmp	fFontAvailable,0
	je	@F
	push	es				;* es=> prim buffer
	AssertNE instCur.psSecInst,0
	mov	es,instCur.psSecInst
	push	di				;* di is correct
	push	si				;* must adjust to 2nd part
	add	si,dbSec
	push	cx				;* save count
	rep	movsw
	pop	cx
	pop	si
	pop	di
	pop	es
@@:
endif	;SCREEN_FFONT

ifdef	BUILTIN_SNOW
	push	dx
	mov	dx,3DAh			;* CGA video status port
SnowL3:
	StartDrawCrit
	movsw
	EndDrawCrit
	loop	SnowL3
	pop	dx
ELSE	;NOT DEFINED BUILTIN_SNOW
	rep	movsw
endif	;BUILTIN_SNOW

	pop	di
	pop	cx
	add	di,axMacTimes2		;* point to next row
	dec	ayBottom		;* day
	jnz	restorearc_loop
	
	pop	ds			;* restore DS since part of far pointer

;*	* inform the screen driver that we have invalidated a lot
;*	* cx = dax
	mov	si,cx
	mov	di,offDrawFirst
loop_inform_restore:
	cCall	insj.lpfnDoUpdateCsdInsj, <ayTop, axLeft, si, di, fRestoreDbcs>
	add	di,axMacTimes2		;* point to next row
	inc	ayTop
	dec	dayT
	jnz	loop_inform_restore

;*	* all done, refresh
	cCall	insj.lpfnDoneUpdateCsdInsj		;* ()

	cCall	FEnableMouse,<fMouseOn>	;* restore mouse state

cEnd	RestoreArc

sEnd	SCREEN

;----------------------------------------------------------------------------

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\scroll.h ===
/*
	COW : Character Oriented Windows

	scroll.h : scroll bar cow private interface
*/


#define cwExtraScroll	5	/* size of rgwExtra for scroll windows */

/* scroll bar definitions */

#define ctickRepSb 	rgwExtra[0]	/* # of ticks to repeat */
#define ptCurSb 	rgwExtra[1]	/* current position on scroll line */
#define ptMinSb 	rgwExtra[2]	/* minimum position on scroll line */
#define ptMaxSb 	rgwExtra[3]	/* end position on scroll line */
#define ptElevatorSb	rgwExtra[4]	/* elevator position (lower byte) */

/*	Repeat timing values :
 *	ctickRepScrollStart	: time till start scrolling
 *	ctickRepScrollDefault	: repeat rate (default SDM scroll bars)
 *	ctickRepList		: repeat rate (for listbox contents), slow
 *					(fast is 2*)
 *
 *	ctick values are in 1/18 th sec
*/

#define ctickRepScrollStart	9		/* 1/2 second */
#define ctickRepScrollDefault	1		/* as fast as possible */
#define ctickRepList		2

/* private message */
#define SB_UPCLICK	15
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\sdmasm.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	sdmasm.asm : SDM specific hand coded stuff

	title	sdmasm - low level utilities for COW SDM

.xlist
	include	user.inc
.list


sBegin	SDM
    assumes CS,SDM
    assumes DS,DATA
    assumes SS,DATA


; FillBuf
; pch: character string
; chFill: fill character
; cch: number of characters

cProc	FillBuf,<NEAR,PUBLIC,ATOMIC>,<DI>
    parmDP pch
    parmB  chFill
    parmW  cch

cBegin	FillBuf
;;;	cld			-- assumed
	push	ds
	pop	es		;* size optimize
	mov	di,pch		; set up for fill
	mov	al,chFill
	mov	cx,cch
	rep	stosb
cEnd	FillBuf

sEnd	SDM

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\sdm.c ===
/*
	CW : Character Oriented Windows

	sdm.c : Standard Dialog Manager (COW variant)

	from Windows SDM Version 1.3 (2/14/86)
*/

#ifndef LATER
#define	wParamLater	0
#endif

#define COW
#include <cow.h>

#define SDM
#define SDM_ENGINE

#include <sdmver.h>
#include <kmem.h>
#include <usdm.h>
#include <usdmtmpl.h>

#include <uevent.h>
#include <udialog.h>
#include <uwindow.h>
#include <uisa.h>

#include <uscroll.h>
#include <uedit.h>

#include "dialog.h"
#include "event.h"
#include "window.h"
#include "util.h"
#include "screen.h"
#include "shadow.h"

#include "edit.h"
#ifdef EDIT_FULLMGR
#include <umedit.h>
#endif

#include "scroll.h"
#include "button.h"
#include "static.h"
#include "general.h"
#include "listbox.h"
#include "_listbox.h"

#include "sdm.h"
#include "_sdm.h"

#include "strings.h"

#ifdef LISTBOX_LIMIT_SIZE
#define	cchDirMax	80				/* 64 + file name */
#else
#define	cchDirMax	256
#endif

#ifdef LISTBOX_LIMIT_SIZE
#define	cchListTextMax	64
#else
#define	cchListTextMax	256
#endif

/* G L O B A L S */

#ifdef DUAL
extern	WORD	fProtectMode;
#endif

STATIC  SDS sdsCur;			/* current SDM state */

static  BYTE *pbWorkCur;		/* current position in work buffer */


#ifdef DEBUG
static BYTE *pbWorkMac;		/* max value of pbWorkCur - for assertions */
#endif /*DEBUG*/


/* forward */
STATIC DWORD FARPUBLIC SdmDialogProc(PWND, WORD, TMC, DWORD);
STATIC PWND	PwndAllocArc(PARC, WORD);
STATIC PWND 	PwndBuildDialog(PDLG);
STATIC VOID	AllocDialogString(PWND, char *);
STATIC HCAB	HcabFromDialog(void);
STATIC BOOL	FSetDialogFromCab(void);

STATIC VOID	TextToCab(HCAB, PWND, WORD);
STATIC VOID	TextFromCab(PWND, WORD);
STATIC BOOL	FParseToCabTif(HCAB, PTIF);
STATIC VOID	FormatFromCabTif(HCAB, PTIF);

STATIC char *	SzWildCard(char *);
STATIC BOOL	FFillComboDir(PTIF, BOOL);
STATIC VOID	SelChangeComboListBox(PTIF);

#ifdef DEBUG
STATIC VOID	AssertTableOrder(void);
#endif



/* Important Tables : see AssertTableOrder for assertion */

/* item creation info :: should really go in CS */
STATIC TCI mptmttci[] =	/* # of bytes needed */
	{
	TciMake(cwExtraDialog,	0 /* n/a */,
		WS_TILED | WS_DIALOG | WS_BORDER),	/* tmtDialog !! */
	TciMake(cwExtraStatic,	cwRect,
		WS_CHILD | WS_STATIC),			/* tmtStaticText */
	TciMake(cwExtraStatic,	cwRect,
		WS_CHILD | WS_STATIC_NOACCEL),		/* tmtFormattedText */
	TciMake(cwExtraStatic,	cwRect,
		WS_CHILD | WS_STATIC_NOACCEL),		/* tmtTrackingText */
	TciMake(cwExtraButton,	cwRect,
		WS_CHILD | WS_BUTTON | BS_GROUP | WS_BORDER),
							/* tmtGroupBox */
	TciMake(cwExtraButton,	cwRect, wsPushButton),
							/* tmtPushButton */
	TciMake(cwExtraButton,	cwRect,
		WS_CHILD | WS_BUTTON | BS_AUTOCHECKBOX),
							/* tmtCheckBox */
	TciMake(cwExtraButton,	cwRect,
		WS_CHILD | WS_BUTTON | BS_RADIOBUTTON),	/* tmtRadioButton */
	TciMake(cwExtraButton,	cwRect,
		WS_CHILD | WS_BUTTON | 0xffff /*not implemented*/),
							/* tmtToggleBox */
	TciMake(cwExtraButton,	cwRect,
		WS_CHILD | WS_BUTTON | 0xffff /*not implemented*/),
							/* tmtToggleButton */
#ifdef EDIT_FULLMGR
	TciMake(cwExtraEdit,	cwEditBuffer + ((sizeof (EF) + sizeof (LD))/2),
		WS_CHILD | WS_EDIT),			/* tmtEdit */
#else
	TciMake(cwExtraEdit,	cwEditBuffer,
		WS_CHILD | WS_EDIT),			/* tmtEdit */
#endif
	TciMake(cwExtraListBox,	cwWnd + cwExtraScroll,
		WS_CHILD | WS_LISTBOX | WS_VSCROLL | WS_BORDER),
							/* tmtListBox */
	TciMake(cwExtraButton,	cwRect, wsPushButton),
							/* tmtStandardButton */
	TciMake(cwExtraStatic,	cwRect,
		WS_CHILD | WS_STATIC),			/* tmtDummyText */
	TciMake(cwExtraGeneral,	0,
		WS_CHILD),				/* tmtGeneralPicture */

	/* past end of normal tmts */
	TciMake(cwExtraScroll,	0 /* n/a */,
		WS_CHILD | SBS_VERT)			/* tmtScroll !! */

	};


#ifdef DEBUG
STATIC VOID
AssertTableOrder()
/*
  -- assert table ordering !!!
  -- isn't C wonderful
*/
	{
	Assert(sizeof(mptmttci) == sizeof(TCI) * (tmtNormalMax+1));
	Assert(tmtDialog == 0);		/* special tmt */
	Assert(tmtStaticText == 1);
	Assert(tmtFormattedText == 2);
	Assert(tmtTrackingText == 3);
	Assert(tmtGroupBox == 4);
	Assert(tmtPushButton == 5);
	Assert(tmtCheckBox == 6);
	Assert(tmtRadioButton == 7);
	Assert(tmtToggleBox == 8);
	Assert(tmtToggleButton == 9);
	Assert(tmtEdit == 10);
	Assert(tmtListBox == 11);
	Assert(tmtStandardButton == 12);
	Assert(tmtDummyText == 13);
	Assert(tmtGeneralPicture == 14);
	Assert(tmtScroll == 15);	/* special tmt */
	}
#endif /*DEBUG*/



PUBLIC TMC FARPUBLIC
TmcDoDlg(pdlg, hcab)
/*
  -- Dialog interpreter procedure.
  -- save old SDM state
  -- create a dialog tree (tree of windows), return tmcCancel if no memory
  -- call DialogBox() to start dialog
*/
VOID *pdlg;	/* Really PDLG */
HCAB hcab;
	{
	StartPublic();
	TMC tmc;
	SDS sdsSave;			/* save old state for re-entrancy */

	Debug(AssertTableOrder());

	/* re-entrant SDM */
	sdsSave = sdsCur;

	/* our global handle to the current dialog cab */
	sdsCur.hcab = hcab;
	sdsCur.pdlg = pdlg;

	if ((sdsCur.pwndDialog = PwndBuildDialog(pdlg)) == NULL)
		{
		/* out of memory, restore old state & return */
		sdsCur = sdsSave;
		ReturnPublic(tmcCancel, TMC);
		}

	tmc = DialogBox(sdsCur.pwndDialog, SdmDialogProc);
	FreeWork(sdsCur.pbWorkBuffer);

	/* restore old state */
	sdsCur = sdsSave;
	ReturnPublic(tmc, TMC);
	}



STATIC PWND
PwndAllocArc(parc, tmt)
/*
  -- allocate space for a window of given size and type
  -- zero fill, enable window
   special tmt's:
		tmtNull		: allocate the entire dialog window
		tmtNormalMax	: allocate a scroll bar window
*/
PARC parc;
WORD tmt;
	{
	REGISTER PWND pwnd;
	REGISTER TCI *ptci = &mptmttci[tmt];

	Assert(tmt <= tmtNormalMax);

	/* allocate room for window + any extra words */
 	pwnd = (PWND) pbWorkCur;
	pbWorkCur += ptci->cbWnd;
	Assert(pbWorkCur <= pbWorkMac);

	FillBuf((char *) pwnd, 0, ptci->cbWnd);
	pwnd->arcWindow	= *parc;
	pwnd->fEnabled	= TRUE;		/* default enabled */
	pwnd->style	= ptci->style;
	return(pwnd);
	}



STATIC PWND
PwndBuildDialog(pdlg)
/*
  -- build the dialog window tree
  -- return the top window, or NULL if out of memory
*/
PDLG pdlg;
	{
	/* Dialog Box info */
	REGISTER PWND	pwndDialog;
	WORD		ddxDialog, ddyDialog;	/* amount to grow by */
	ARC		arcDialog;
	AX		axLeft;
	AY		ayTop;

	/* General TM info */
	WORD		tmcNext;
	WORD		ctmSkip;
	/* TM scanning variables */
	REGISTER PTM	ptm;
	PTIF		ptif;
	WORD		tmt;			/* type */
	WORD		tmc;
	ARC		arcTm;

	/* Arg info */
	WORD		iagHandle;
	WORD		iagNonHandle;
	/* Radio Buttons */
	PWND		pwndRadioBase;		/* base for radio buttons */
	PWND		pwndRadioPrev;		/* previous radio buttons */
	TMC		tmcRadioLast;

	WORD		cbNeed;			/* the number of bytes needed */

	/* consistency variables */
	BOOL		fControlProc;		/* do we have a control proc ?*/

	/* Init */
	tmcNext		= tmcSysMin;	/* start here */
	ddxDialog	= ddyDialog = 0;

	Debug(pwndRadioBase = NULL);
	Debug(pwndRadioPrev = NULL);

	cbNeed = (cwWnd + cwExtraDialog) * sizeof(WORD);
			/* room for the actual dialog box */

	/* scan the array of TM's to
		a) find out must extra work buffer space we will need
		b) find sdsCur.ctif
	*/

	sdsCur.ctif = 0;
	for (ptm = pdlg->rgtm; (tmt = ptm->tmtBase) != tmtEnd; ptm++)
		{
		REGISTER TCI *ptci;

		if (FSpecialTmt(tmt))
			{
			if (tmt == tmtConditional)
				{
				/* check subdialog for larger rectangle */
				/* Must have a CAB */
				AssertSz(sdsCur.hcab != NULL,
				    "Sub Dialog without CAB");
				if (FUseSubDialog(ptm,
				    PcabxOfCab(sdsCur.hcab)->sab))
					{
#ifdef LATER /* resizing dialogs */
					if (PtmoOfTm(ptm)->ddxDialog > ddxDialog)
						ddxDialog =
						    PtmoOfTm(ptm)->ddxDialog;
					if (PtmoOfTm(ptm)->ddyDialog > ddyDialog)
						ddyDialog =
						     PtmoOfTm(ptm)->ddyDialog;
#endif /*LATER*/
					}
				}
			continue;
			}

		/* standard stuff for all items ************************/

		Assert(tmt < tmtNormalMax);
		ptci = &mptmttci[tmt];

		cbNeed += ptci->cbWnd;
		if (ptci->cbAdditional != cbRect)
			cbNeed += ptci->cbAdditional;
		else
			{
			/* figure extra size from ARC requirements */
			cbNeed += (PcrcOfTm(ptm)->dx + 2) & ~1;
			if (ptci->style & WS_BORDER)
				cbNeed -= 2;	/* because of border */
			}

		if (tmt != tmtDummyText)
			sdsCur.ctif++;
		}

	Assert(sdsCur.ctif != 0);

	/* figure out new dialog size */
	arcDialog.axRight  = (arcDialog.axLeft = pdlg->crcDlg.x)
	    + pdlg->crcDlg.dx + (BYTE) ddxDialog;
	arcDialog.ayBottom = (arcDialog.ayTop = pdlg->crcDlg.y)
	    + pdlg->crcDlg.dy + (BYTE) ddyDialog;

	cbNeed += (sdsCur.ctif + 1) * sizeof(TIF);
	pbWorkCur = sdsCur.pbWorkBuffer = PbAllocWork(cbNeed);
	if (pbWorkCur == NULL)
		return NULL;

	Debug(pbWorkMac = sdsCur.pbWorkBuffer + cbNeed);

	/* Now fill in the real stuff ************************/

	/* allocate the TIF info */
	ptif = sdsCur.rgtif = (PTIF) pbWorkCur;
	pbWorkCur += (sdsCur.ctif + 1) * sizeof(TIF);
	/* fill last tif with guard info */
	sdsCur.rgtif[sdsCur.ctif].ptm = NULL;
	sdsCur.rgtif[sdsCur.ctif].tmc = tmcNull;

	/* allocate main dialog window */
	pwndDialog = PwndAllocArc(&arcDialog, tmtDialog /*special*/);
	Assert(pwndDialog->style & WS_BORDER);

	/* Adjust for larger displays -- assumes dialogs are laid out to
	   look nice on an 80x25 display */
	if (pwndDialog->arcWindow.ayBottom < 25)	/* if small dialog */
		MoveWindow(pwndDialog,
		    pwndDialog->arcWindow.axLeft + ((axMac - 80) >> 1),
		    pwndDialog->arcWindow.ayTop + ((ayMac - 25) >> 1));

	pwndDialog->pfnWndProc = DialogWndProc;
	if (pdlg->bpTitle != NULL)
		{
		/* title for Window -- just point into dialog template */
		/* NOTE : kludge for BASE pointer */
		pwndDialog->szDialog = ((WORD) pdlg) + pdlg->bpTitle;
		}
	ValidateWindow(pwndDialog);

	axLeft	= pwndDialog->arcClipping.axLeft;
	ayTop	= pwndDialog->arcClipping.ayTop;

	/* prepare for real scan of tm's */
	Assert(ptif == sdsCur.rgtif);
	Assert(sdsCur.hcab != NULL);
	iagHandle	= 0;
	iagNonHandle	= PcabxOfCab(sdsCur.hcab)->cabh.cagHandle;
				/* check later */

	/* go thru all tm's, constructing the dialog template */
	ctmSkip = 0;
	for (ptm = pdlg->rgtm; (tmt = ptm->tmtBase) != tmtEnd; ptm++)
		{
		REGISTER PWND pwnd;
		PTM ptmSpecial;

		if (FSpecialTmt(tmt))
			{
			if (tmt == tmtConditional &&
			    !FUseSubDialog(ptm, PcabxOfCab(sdsCur.hcab)->sab))
				{
				/* don't use it */
				ctmSkip = PtmoOfTm(ptm)->ctmNormal;
				}
			continue;
			}

		/* standard stuff for all items ************************/

		/* Make rrc into an arc */
		arcTm.axRight	= (arcTm.axLeft = PcrcOfTm(ptm)->x + axLeft)
		    + PcrcOfTm(ptm)->dx;
		arcTm.ayBottom	= (arcTm.ayTop = PcrcOfTm(ptm)->y + ayTop)
		    + PcrcOfTm(ptm)->dy;

		pwnd = PwndAllocArc(&arcTm, tmt);	/* zero filled */
		pwnd->aclDialog = aclNil;

		ValidateWindow(pwnd);

		if (ptif->fReal = (ctmSkip == 0))
			{
			/* real window */
			AddChild(pwndDialog, pwnd);
			}
		else
			{
			/* fake window (skip due to sub-dialogs) */
			ctmSkip--;
			}

		if (tmt == tmtDummyText)
			{
			/* Dummy text does not have TMCs, extensions or
			  or anything special */
			Assert(!FExtensionTmt((ptm+1)->tmtBase));
			Assert(ptm->bpString != NULL &&
			    ptm->bpString != bpStringFromCab);

			pwnd->id = tmcNull;
			ptif--;	/* counteract ending ptif++ */
			goto FillDummyText;
			}

		/* scan ahead for extension records ********************/

		tmc = tmcNext;		/* next tmc in a row */
		Assert(ptif - sdsCur.rgtif == tmcNext - tmcSysMin);
			/* itif & tmc have weird arrangement */
		tmcNext++;

		fControlProc = FALSE;
		for (ptmSpecial = ptm+1;
		    FExtensionTmt(ptmSpecial->tmtBase);
		    ptmSpecial++)
			{
			switch (ptmSpecial->tmtBase)
				{
			default:
				Assert(FALSE);
				break;
			case tmtExtension1:
				/* Extension 1 must be right after normal */
				Assert(ptmSpecial == ptm+1);
				if (Ptm1OfTm(ptmSpecial)->tmcImport != tmcNull)
					{
					/* imported TMC */
					tmc = Ptm1OfTm(ptmSpecial)->tmcImport;
					AssertSz(tmc < tmcSysMin ||
					    tmc >= tmcSysMax,
					    "invalid Imported TMC");
					}

				fControlProc = Ptm1OfTm(ptmSpecial)->pfnCtl != NULL;
				break;

			case tmtExtension2:
				Assert(FALSE);	/* do later */
				break;

			case tmtExtension3:
				Assert(FALSE);	/* do later */
				break;

				}
			}
		/* fill in default info ********************************/

		/* Cursor : on, in upper left */
		pwnd->fCursorOn = TRUE;
		pwnd->axCursor = pwnd->arcClipping.axLeft;
		pwnd->ayCursor = pwnd->arcClipping.ayTop;
		pwnd->id = tmc;

		/* fill in TIF info ***********************************/

		ptif->tmc  = tmc;
		ptif->ptm  = ptm;
		ptif->pwnd = pwnd;

		/* check for string from cab */
		ptif->iagText = (ptm->bpString == bpStringFromCab) ?
		    iagHandle++ : iagNil;

		ptif->iagMain = iagNil;	/* assume no cab arg */

		/* special init cases ********************************/

		/* Vertical Scroll Bar */
		if (pwnd->style & WS_VSCROLL)
			{
			PWND pwndScroll;

#ifdef LISTBOX_ONELINE
			/* if only 1 line (+border) then no scroll bar */
			{
#ifdef LISTBOX_NOSCROLL
			extern BYTE fNoScroll;
			if (arcTm.ayBottom == arcTm.ayTop + 3 || fNoScroll)
#else
			if (arcTm.ayBottom == arcTm.ayTop + 3)
#endif
				{
				/* turn off style as well as eating allocated memory */

				pwnd->style &= ~WS_VSCROLL;
				pbWorkCur += (cwWnd + cwExtraScroll) * sizeof(WORD);
				Assert(pbWorkCur <= pbWorkMac);
				goto skip_add_scroll;
				}
			}
#endif /*LISTBOX_ONELINE*/

			/* vertical scroll bar on right hand side */
			arcTm.axLeft = arcTm.axRight - daxBorder;
			/* less top&bottom corners */
			arcTm.ayTop += dayBorder;
			arcTm.ayBottom -= dayBorder;

			pwndScroll = PwndAllocArc(&arcTm, tmtScroll);
			pwndScroll->pfnWndProc = ScrollBarWndProc;
			pwndScroll->ctickRepSb = ctickRepScrollDefault;
			ValidateWindow(pwndScroll);
			AddChild(pwnd, pwndScroll);
#ifdef LISTBOX_ONELINE
skip_add_scroll:	;
#endif /*LISTBOX_ONELINE*/
			}


		switch (tmt)
			{
		default:
			Assert(FALSE);
			break;

		case tmtStaticText:
		case tmtFormattedText:
		case tmtTrackingText:
FillDummyText:	/* case tmtDummyText: */
			Assert((pwnd->style & WS_TYPE) == WS_STATIC ||
			    (pwnd->style & WS_TYPE) == WS_STATIC_NOACCEL);
#ifndef KANJI	/* kanji mucks with coordinates */
			Assert(PcrcOfTm(ptm)->dx
			 == (pwnd->arcClipping.axRight - pwnd->arcClipping.axLeft));
						/* size must be exact */
#endif /*!KANJI*/
			pwnd->pfnWndProc = StaticWndProc;
			pwnd->fCursorOn = FALSE;

			Assert(SS_LEFT == 0);
			if (ptm->fNotLeftJustify)
				{
				pwnd->style |= (ptm->fNotRightJustify) ?
				    SS_CENTER : SS_RIGHT;
				}

			goto init_string;

#ifndef MUCH_LATER
		case tmtToggleBox:
		case tmtToggleButton:
			AssertSz(FALSE, "Toggleboxes/buttons not yet");
#endif
		case tmtGroupBox:
			pwnd->fEnabled = FALSE;
#ifndef KANJI	/* kanji mucks with coordinates */
			/* size check : with border */
			Assert(PcrcOfTm(ptm)->dx - 2
			 == (pwnd->arcClipping.axRight - pwnd->arcClipping.axLeft));
#endif /*!KANJI*/
			goto init_button;

		case tmtRadioButton:
			if (!ptif->fReal)
				{
				/* not a real button => don't link in */
				if (ptm->fFirstButton)
					iagNonHandle++;	/* bump iag anyway */
				goto init_button;
				}
			if (ptm->fFirstButton)
				{
				/* first button in group */
				pwndRadioBase = pwnd;
				pwnd->wButton = wButtonFirstRadio;
				ptif->iagMain = iagNonHandle++;
				tmcRadioLast  = tmc;
				}
			else
				{
				/* not first button */
				Assert(pwndRadioBase != NULL);
				Assert(pwndRadioPrev != NULL);
				pwndRadioPrev->pwndButtonNext = (WORD) pwnd;
				/* take into account imported tmcs */
				pwnd->id = ptif->tmc = ++tmcRadioLast;
				}
			/* fill with start (this will hook the last button) */
			pwnd->pwndButtonNext = (WORD) pwndRadioBase;
			pwndRadioPrev = pwnd;
			goto init_button;

		case tmtCheckBox:
			ptif->iagMain = iagNonHandle++;
			/* fall through to pushbutton */
		case tmtPushButton:
			Assert(pwnd->wButton == wButtonInit);
init_button:
			Assert(pwnd->style & WS_BUTTON);
#ifndef KANJI	/* kanji mucks with coordinates */
			Assert(PcrcOfTm(ptm)->dx
			 == (pwnd->arcWindow.axRight - pwnd->arcWindow.axLeft));
							/* size must be exact */
#endif /*!KANJI*/
			pwnd->pfnWndProc = ButtonWndProc;
			if (ptm->fDefaultPushButton)
				pwnd->style |= BS_DEFPUSHBUTTON;
init_string:
			if (ptm->bpString == bpStringFromCab)
				{
				/* string data from CAB : fill in later */
				Assert(ptif->iagText != iagNil);
				}
			else
				{
				/* normal base pointer */
				Assert(ptif->iagText == iagNil ||
				    tmt == tmtDummyText);
				}
			AllocDialogString(pwnd,
			    (ptm->bpString > bpStringFromCab) ?
			    (char *) ((WORD) ptm + ptm->bpString) : szEmptyString);
			break;

		case tmtListBox:
			Assert(pwnd->style & WS_LISTBOX);
			/* must have listbox proc or be directory */
			Assert(fControlProc || ptm->fDirListBox);
			Assert(!(fControlProc && ptm->fDirListBox));

			pwnd->pfnWndProc = ListBoxWndProc;
			pwnd->axCursor++;
			pwnd->isaColor = isaListBox;
			pwnd->isaHiliteColor = isaListBoxSelection;
			pwnd->ctickRepLb = ctickRepList;
			if (!ptm->fComboListBox)
				{
				ptif->iagMain = iagNonHandle++;
				}
#ifdef LISTBOX_DIR	/* Dir and or sorted */
#ifdef DEBUG /* remove later */
			if (ptm->fDirListBox)
				{
				AssertSz(ptm->fSortedListBox, "old SDM template format");
				}
#endif
			if (ptm->fSortedListBox)
				pwnd->style |= LBS_SORT;

			/* save listbox proc (if there is one) */
#endif /*LISTBOX_DIR*/
			PwfnCtlLb(pwnd) = Ptm1OfTif(ptif)->pfnCtl;
			break;

		case tmtEdit:
			Assert(pwnd->style & WS_EDIT);
			/* should set ES_ styles if we supported them */
			pwnd->pfnWndProc = EditWndProc;
			/* allocate string for edit control for work buffer */
#ifdef EDIT_FULLMGR
			InitEditWnd(pwnd, pbWorkCur,
				    (cwEditBuffer  * sizeof (WORD)) +
				    sizeof (EF) + sizeof (LD));
			pbWorkCur += (cwEditBuffer * sizeof (WORD)) +
				     sizeof (EF) + sizeof (LD);
#else
			pwnd->szDialog = (WORD) pbWorkCur;
			pwnd->cchDialog = cwEditBuffer * sizeof(WORD) - 1;
			Assert(pwnd->cchDialog == 255);	/* must be 255 */
			pwnd->chFillDialog = (WORD) chFillEdit;
			pwnd->isaEb = isaEdit;	/* set variable color */
			pwnd->isaSelEb = isaHiliteEdit;
			pwnd->cchMaxEb = pwnd->cchDialog;
			pbWorkCur += cwEditBuffer * sizeof(WORD);
#endif /*EDIT_FULLMGR*/

#ifdef EDIT_SECRET
			/* just SecretEdit for now */
			if (ptm->fCharValidated)
				pwnd->style |= ES_SECRET;
#endif /*EDIT_SECRET*/

			Assert(pbWorkCur <= pbWorkMac);
			ptif->iagMain = fControlProc ? iagNonHandle++ :
			    iagHandle++;
			break;

		case tmtStandardButton:
			Assert(pwnd->wButton == wButtonInit);
			Assert(pwnd->style & WS_BUTTON);
#ifndef KANJI	/* kanji mucks with coordinates */
			Assert(PcrcOfTm(ptm)->dx
			 == (pwnd->arcWindow.axRight - pwnd->arcWindow.axLeft));
							/* size must be exact */
#endif /*!KANJI*/
			Assert(ptm->bpString == NULL && ptif->iagText == iagNil);
			AllocDialogString(pwnd,
			    ptm->fStandardCancel ? szCancelString : szOkString);
			pwnd->pfnWndProc = ButtonWndProc;
			if (ptm->fStandardCancel)
				{
				/* Cancel */
				tmc = tmcCancel;
				}
			else
				{
				/* OK */
				tmc = tmcOk;
				Assert(ptm->fDefaultPushButton);
				pwnd->style |= BS_DEFPUSHBUTTON;
				}
			/* change tmc */
			pwnd->id = ptif->tmc = tmc;
			break;

		case tmtGeneralPicture:
			pwnd->fEnabled = FALSE;
			pwnd->pfnWndProc = GeneralWndProc;
			AssertSz(FExtension1(ptif), "General Picture without wnd proc");
			Assert(Ptm1OfTif(ptif)->pfnCtl != NULL);
			PwfnCtlGeneral(pwnd) = Ptm1OfTif(ptif)->pfnCtl;
			break;

			} /*switch*/

		ptif++;
		}

	/* all real tm's better be filled in "rgtif" array */
	Assert(ptif - sdsCur.rgtif == sdsCur.ctif);

	/* the work buffer should be all used up */
	AssertSz(pbWorkCur == pbWorkMac, "SDM alloc fail");

	/* the CAB & DialogTemplate better match */
#ifdef PROJECT_WORKS
	/* WORKS wan't to be sleazy and use overallocated Handles */
	AssertSz(PcabxOfCab(sdsCur.hcab)->cabh.cagHandle >= iagHandle,
	    "CAB / DLG mismatch (handles)");
#else
	AssertSz(PcabxOfCab(sdsCur.hcab)->cabh.cagHandle == iagHandle,
	    "CAB / DLG mismatch (handles)");
#endif
	AssertSz(PcabxOfCab(sdsCur.hcab)->cabh.cwData >= iagNonHandle,
	    "CAB / DLG mismatch (non-handles)");

	return(pwndDialog);
	}



STATIC VOID
AllocDialogString(pwnd, szText)
/*
  -- allocate string space for string specified by szText
  -- need room for largest text + zero terminator
  -- strip sz from szText to fill in acl
*/
REGISTER PWND pwnd;
char *szText;
	{
	pwnd->szDialog = (WORD) pbWorkCur;
	pwnd->cchDialog = pwnd->arcClipping.axRight - pwnd->arcClipping.axLeft;

	Assert(sizeof(WORD) == 2);
	pbWorkCur += (pwnd->cchDialog + 2) & ~1;	/* + 1 & make even */
	Assert(pbWorkCur <= pbWorkMac);

	Assert(pwnd->aclDialog == aclNil);
	SetDlgItemText(pwnd, szText, FALSE);
	}



STATIC HCAB
HcabFromDialog()
/*
  -- Allocates a cab and fills it in with values from the specified dialog box.
  -- get size info from global CAB
*/
	{
	REGISTER PTIF	ptif;
	WORD		ctif;

	HCAB		hcab;		/* work CAB */

	CABX *		pcabxSrc;	/* original */
	CABX *		pcabxDest;	/* destination */
	WORD		cagHandle;	/* # of handles in CAB */
	WORD		cwData;		/* # of words of data */

	pcabxSrc = PcabxOfCab(sdsCur.hcab);
	cagHandle = pcabxSrc->cabh.cagHandle;
	cwData = pcabxSrc->cabh.cwData;
	/* allocate a new cab the size of the original cab */
	if ((hcab = HcabAlloc((cagHandle << 8) + cwData)) == NULL)
		{
		/* out of memory - stay in dialog */
		return NULL;
		}

	/* headers must be the same */
	pcabxSrc = PcabxOfCab(sdsCur.hcab);
	pcabxDest = PcabxOfCab(hcab);
	Assert(pcabxDest->cabh.cagHandle == cagHandle);
	Assert(pcabxDest->cabh.cwData == cwData);

	/* copy data from old to new : skip over handles */
	pcabxDest->sab = pcabxSrc->sab;
	bltbyte(&pcabxSrc->rgh[cagHandle], &pcabxDest->rgh[cagHandle],
	    (cwData - cagHandle) * sizeof(WORD));

	/* go thru all tm's and store dialog values into cab */
	for (ctif = sdsCur.ctif, ptif = sdsCur.rgtif; ctif--; ptif++)
		{
		REGISTER PTM	ptm;
		PTM		ptmNext;	/* next item */
		WORD *		pwArg;		/* pointer to arg */

		/* first restore text back in CAB */
		if (ptif->iagText != iagNil)
			TextToCab(hcab, ptif->pwnd, ptif->iagText);

		if (ptif->iagMain == iagNil)
			continue;	/* no arg */

		pwArg = &PcabxOfCab(hcab)->rgh[ptif->iagMain];
		ptm = ptif->ptm;
		ptmNext = (ptif+1)->ptm;	/* next or end guard */

		switch (ptm->tmtBase)
			{
		default:
			continue;

		case tmtEdit:
#ifdef LISTBOX_DIR
			if (ptmNext != NULL &&
			     ptmNext->tmtBase == tmtListBox &&
			     ptmNext->fDirListBox)
				{
				/* Dir => Combo Dir */
				AssertSz(ptmNext->fComboListBox,
				   "Dir Listbox must be ComboDir");

				/* A Combo Dir ListBox, ptm=>edit item */
				if (!FFillComboDir(ptif+1, FALSE))
					{
					/* don't exit */
					FreeCab(hcab);
					return ((HCAB) -1);
					}
				}
#endif /*LISTBOX_DIR*/
			if (!FExtension1(ptif) ||
			    Ptm1OfTif(ptif)->pfnCtl == NULL)
				{
				/* no parse proc : normal edit */
				TextToCab(hcab, ptif->pwnd, ptif->iagMain);
				}
			else if (!FParseToCabTif(hcab, ptif))
				{
				/* error when parsing */
				FreeCab(hcab);
				return(NULL);
				}
			break;

		case tmtCheckBox:
			*pwArg = WButtonChecked(ptif->pwnd);
			break;

		case tmtRadioButton:
			/* must be first in group */
			if (ptm->fFirstButton);
			*pwArg = GetRadVal(ptif);
			break;

		case tmtListBox:
#ifdef LISTBOX_DIR
			if (ptm->fDirListBox)
				{
				if (ptm->fComboListBox)
					{
					continue;
					/* no CAB entry for combo directory
					    list boxes */
					}
				else
					{
#ifdef REMOVE_LATER
					... dir/drive listbox (dummy cab)...
					char szBuffer[cchDirMax];
					DlgDirSelect(ptif->pwnd, szBuffer,
					    (ptif+2)->ptm->tmtBase == tmtListBox ?
					    (ptif+2)->pwnd : NULL);
					SzToCab(hcab, szBuffer, ptif->iagMain);
#endif
					}
				}
			else
#endif /*LISTBOX_DIR*/
				{
				/* we assume the right val for SendMessage */
				*pwArg = (WORD) SendMessageShort(ptif->pwnd, LB_GETCURSEL);
				}
			break;

			}
		}
	return(hcab);
	}



STATIC BOOL
FSetDialogFromCab()
/*
  -- sets field values in dialog box with values in cab
  -- get global info from sdsCur
  -- returns false if initial selection was made
*/
	{
	WORD tmcSel;

	if (sdsCur.hcab != NULL)
		{
		REGISTER PTIF	ptif;
		WORD		ctif;

		for (ctif = sdsCur.ctif, ptif = sdsCur.rgtif; ctif--; ptif++)
			{
			REGISTER PTM	ptm;
			WORD		wArg;

			/* check for CAB text */
			if (ptif->iagText != iagNil)
				TextFromCab(ptif->pwnd, ptif->iagText);

			/* note : wArg will be bogus if iagMain == iagNil */
			ptm = ptif->ptm;
			wArg = (ptif->iagMain == iagNil) ? uNinch :
			    PcabxOfCab(sdsCur.hcab)->rgh[ptif->iagMain];

			switch (ptm->tmtBase)
				{
			default:
				continue;

			case tmtEdit:
				Assert(ptif->iagMain != iagNil);

				if (!FExtension1(ptif) ||
				    Ptm1OfTif(ptif)->pfnCtl == NULL)
					TextFromCab(ptif->pwnd, ptif->iagMain);
				else
					FormatFromCabTif(sdsCur.hcab, ptif);
				break;

			case tmtCheckBox:
				Assert(ptif->iagMain != iagNil);
				CheckDlgButton(ptif->pwnd, wArg, FALSE);
				break;

			case tmtRadioButton:
				/* must be first in group */
				if (wArg != uNinch)
					{
					Assert(ptif->ptm->fFirstButton);
					Assert(ptif->iagMain != iagNil);
					CheckRadioButton(ptif->pwnd, wArg, FALSE);
					}
				break;

			case tmtListBox:
				/* wArg may be bogus (if Combo) */
#ifdef DEBUG
				if (ptif->ptm->fComboListBox)
					{Assert(ptif->iagMain == iagNil);}
				else
					{Assert(ptif->iagMain != iagNil);}
#endif
				FillListBoxTif(ptif, wArg);
				break;
				} /*switch*/
			}
		}

	/* make initial selection */
	if ((tmcSel = sdsCur.pdlg->tmcSelInit) != tmcNull)
		{
		SetTmcSel(tmcSel, 0, 0x7fff);
		return(FALSE);
		}
	return(TRUE);
	}



STATIC VOID
TextToCab(hcab, pwnd, iag)
/*
  -- get string from Dialog item (window pwnd) put in CAB
*/
HCAB hcab;		/* destination CAB */
PWND pwnd;		/* window to place string in */
WORD iag;		/* arg in default CAB to get string from */
	{
	char sz[cwEditBuffer * sizeof (WORD)];

	Assert(hcab != NULL);
	Assert(pwnd != NULL);
	Assert(iag != iagNil);

	GetDlgItemText(pwnd, sz, sizeof(sz)-1);
	SzToCab(hcab, sz, iag);
	}



STATIC VOID
TextFromCab(pwnd, iag)
/*
  -- get string from default CAB, put in dialog item
*/
PWND pwnd;		/* window to place string in */
WORD iag;		/* arg in default CAB to get string from */
	{
	char sz[cwEditBuffer * sizeof (WORD)];

	Assert(sdsCur.hcab != NULL);
	Assert(pwnd != NULL);
	Assert(iag != iagNil);

	SzFromCab(sdsCur.hcab, sz, sizeof(sz), iag);
	SetDlgItemText(pwnd, sz, FALSE);
	}



STATIC BOOL
FParseToCabTif(hcab, ptif)
/*
  -- parses sz at itm using parse function *pfn.
  -- return TRUE if no error
*/
HCAB hcab;
REGISTER PTIF ptif;
	{
	char	sz[cwEditBuffer * sizeof (WORD)];
	WORD	cwVal;
	PWFN_CTL pfnCtl;
	TMC	tmc;

	/* Item must have an parse proc */
	AssertExtension1(ptif);
	pfnCtl = Ptm1OfTif(ptif)->pfnCtl;
	Assert(pfnCtl != NULL);

	tmc	= ptif->tmc;

	GetDlgItemText(ptif->pwnd, sz, sizeof(sz)-1);
	cwVal = (*pfnCtl)(tmmCwVal, sz, NULL, tmc, wParamLater, 0);
#ifdef LATER
	...allow arbitrary fixed & variable length things in CAB
#endif
	if (cwVal == 1)
		{
		/* parse value and store it into cab at iag */
		Assert(ptif->iagMain != iagNil);
		Assert(ptif->iagMain >= PcabxOfCab(hcab)->cabh.cagHandle);

		if (!(*pfnCtl)(tmmParse, sz, (WORD) hcab, tmc, wParamLater,
		    (WORD) &((CABX *) 0)->rgh[ptif->iagMain]))
			{
			/* parse error */
			return(FALSE);
			}
		}
	else
		{
		char **hval;

		if ((hval = HeapAlloc(cwVal * sizeof(int))) == NULL)
			{
			OutOfMemory();
			return FALSE;
			}

		/* parse large value and store it into cab at iag */
		if (!(*pfnCtl)(tmmParse, sz, (WORD) hval, tmc, wParamLater, 0))
			{
			/* parse error */
			HeapFree(hval);
			return FALSE;
			}

		/* ??????? real sleazy way to put argument into cab */
		RgbToCab(hcab, *hval, cwVal * 2, ptif->iagMain);
		HeapFree(hval);
		}
	return TRUE;
	}



STATIC VOID
FormatFromCabTif(hcab, ptif)
/*
  -- format information into CAB
*/
HCAB hcab;
REGISTER PTIF ptif;
	{
	REGISTER PCABX pcabx;
	WORD iag;
	char sz[cwEditBuffer * sizeof (WORD)];
	PWFN_CTL pfnCtl;

	/* Item must have an parse proc */
	/* Item must have an parse proc */
	AssertExtension1(ptif);
	pfnCtl = Ptm1OfTif(ptif)->pfnCtl;
	Assert(pfnCtl != NULL);

	pcabx = PcabxOfCab(hcab);
	iag = ptif->iagMain;
	if (iag < pcabx->cabh.cagHandle)
		{
		/* item with a handle */
		(*pfnCtl)(tmmFormat, sz, (WORD) &pcabx->rgh[iag], ptif->tmc,
		    wParamLater, 0);
		}
	else
		{
		(*pfnCtl)(tmmFormat, sz, (WORD) hcab, ptif->tmc, wParamLater,
		    (WORD) &((CABX *) 0)->rgh[ptif->iagMain]);
		}
	SetDlgItemText(ptif->pwnd, sz, FALSE);
	}



STATIC DWORD FARPUBLIC
SdmDialogProc(pwnd, message, tmc, lParam)
/*
  -- Dialog procedure for SDM dialogs
*/
PWND pwnd;
WORD message;
TMC tmc;		/* wParam = pwnd->id */
DWORD lParam;
	{
	REGISTER PTM ptm;
	PTIF	ptif;
	BOOL	fDismiss;
	DLM	dlm = dlmClick;

#ifdef	DIALOG_NOSAVE
	Assert(message == WM_PAINT || pwnd == sdsCur.pwndDialog);
#else	// DIALOG_NOSAVE
	Assert(pwnd == sdsCur.pwndDialog);
#endif	// DIALOG_NOSAVE

	switch (message)
		{

	default:
		return FALSE;

	case WM_DIALOG_SETFOCUS:
		if (FExistsDialogProc())
			FCallDialogProc(dlmSetFocus, tmc, 0, 0, 0);
		return FALSE;

	case WM_DIALOG_KILLFOCUS:
		if (FExistsDialogProc())
			FCallDialogProc(dlmKillFocus, tmc, 0, 0, 0);
		return FALSE;

	case WM_DIALOG:
#ifdef HELP_BUTTON
		if (tmc == tmcHelp)
			{
			tmc = 0;	/* No shift states for Help */
			goto do_help;
			}
#endif
		break;		/* fall through */

	case WM_INITDIALOG:
		{
		/* Initializing dialog */
		BOOL fRet;
		fRet = FSetDialogFromCab();
		if (FExistsDialogProc())
			{
			FCallDialogProc(dlmInit, tmcNull, 0, 0,
			    (WORD) sdsCur.hcab);
			}
		return(fRet);
		}
		/*break*/

	case WM_HELP:
#ifdef HELP_BUTTON
do_help:
#endif
		/* really the tmc contains the KK value */
		Help(hemDialog, sdsCur.pdlg->hid, sdsCur.pdlg, tmc);
		return FALSE;
		/*break*/

	case WM_CHAR:
		dlm = dlmKey;
		goto send_dlm;

	case WM_IDLE:
#ifdef DUAL
		/* for DOS 5, in idle return TRUE (=> dialog processor
		*  will put us to sleep
		*/
		if (fProtectMode && !FExistsDialogProc())
			return TRUE;		/* default idle */
#else /*!DUAL*/
#ifdef DOS5
		/* for DOS 5, in idle return TRUE (=> dialog processor
		*  will put us to sleep
		*/
		if (!FExistsDialogProc())
			return TRUE;		/* default idle */
#endif
#endif /*!DUAL*/
		dlm = dlmIdle;

send_dlm:
		/* call the dialog proc -- if it returns FALSE, cancel dialog */
		if (FExistsDialogProc() &&
		    !FCallDialogProc(dlm, tmc, tmc, 0, 0))
			{
			/* dismiss it */
			ptif = PtifFromTmc(tmc = tmcCancel);
			ptm = ptif->ptm;
			goto DoOK;
			}
		return FALSE;
		/* break */
		}

	/* else WM_DIALOG */
	Assert(message == WM_DIALOG);

	ptif	 = PtifFromTmc(tmc);
	ptm	 = ptif->ptm;
	fDismiss = ptm->fDismiss;	/* clear if not acknowledged */

	/* process regular tmc BEFORE calling dialog proc */
	switch (ptm->tmtBase)
		{

	case tmtRadioButton:
		/* check one button, clear rest */
		CheckRadioButton(ptif->pwnd, 0, TRUE);
		break;

	case tmtListBox:
		switch (HIWORD(lParam))
			{

		default:
			Assert(FALSE);
			break;

		case LBN_SELECT_DONE:
			dlm = dlmUnclick;
			break;

		case LBN_SELCHANGE:
			/* ListBox selection changed */
			if (ptm->fComboListBox)
				{
				if ((ptif+1)->ptm->tmtBase == tmtTrackingText &&
				    (ptif+2)->ptm->tmtBase == tmtListBox)
					/* clear selection in dir/drive */
					SendMessage((ptif+2)->pwnd,
					    LB_SETCURSEL, (WORD) -1, 0L);
				SelChangeComboListBox(ptif);
				}
			else if (ptm->fDirListBox)
				{
				/* change in split dir/drives */
				Assert((ptif-1)->ptm->tmtBase == tmtTrackingText);
				Assert((ptif-2)->ptm->tmtBase == tmtListBox);
				/* clear the file selection */
				SendMessage((ptif-2)->pwnd, LB_SETCURSEL,
				    (WORD) -1, 0L);
				SelChangeComboListBox(ptif-2);
				}
			break;

		case LBN_DBLCLK:	/* Double Click in listbox */
			{
			Assert(!fDismiss);	/* not normal dismiss */
			fDismiss = (FExistsDialogProc()) ?
			    FCallDialogProc(dlmDblClk, tmc, 0, 0, wParamLater) :
			    TRUE;

			if (fDismiss)
				{
				/* Dismiss via double click */
				PWND pwndT;
				if ((pwndT =
				    PwndDefaultPushButton(pwnd)) != NULL)
					{
					/* Change item */
					ptif = PtifFromTmc(tmc = pwndT->id);
					ptm = ptif->ptm;
					goto DoOK;
					}
				}
			}
			break;

			} /*switch(LBN_)*/
		} /*switch(tmt)*/

	if (ptm->fProc)
		{
		/* call client's dialog procedure */
		BOOL	fAck;

		AssertSz(FExistsDialogProc(),
		     "SdmDialogProc: missing dialog function");

		if (ptm->tmtBase == tmtEdit)
			{
			/* Check for change message */
			dlm = (HIWORD(lParam) == EN_CHANGE) ? dlmChange :
			    0;
			}

		fAck = (dlm == 0) ||
		    FCallDialogProc(dlm, tmc, LOWORD(lParam), HIWORD(lParam),
		     wParamLater);
#ifdef LATER
		... do something with fAck
#endif
		if (fDismiss)
			fDismiss = fAck;
		}


	if (fDismiss)
		{
		/* dismiss dialog (maybe) */
		HCAB hcabT;
DoOK:

		hcabT = NULL;	/* NULL => don't place changes in CAB */

		if (!FEnabledTmc(tmc))
			return TRUE;	/* exit button not enabled */
			/* NOTE : disabling a OK/CANCEL button is dangerous */

		if (ptm->fCabDismiss && sdsCur.hcab != NULL)
			{
			/* try to fill in the CAB */
			if ((hcabT = HcabFromDialog()) == NULL)
				{
				/* and error returned, cancel the dialog */
				EndDialog(pwnd, tmcCancel);
				return TRUE;
				}
			}
			if (hcabT == (HCAB) -1)
				return TRUE;

		if (FExistsDialogProc() &&
		    !FCallDialogProc(dlmTerm, tmc, LOWORD(lParam), HIWORD(lParam), 0))
			{
			/* Dialog proc does not want us to dismiss */
			if (hcabT != NULL)
				FreeCab(hcabT);
			return TRUE;
			}

		if (hcabT != NULL)
			{
			/* replace original cab's handles */
			PCABX pcabxDest;

			FreeCabData(sdsCur.hcab);
			pcabxDest = PcabxOfCab(sdsCur.hcab);
			bltbyte((char *) PcabxOfCab(hcabT)->rgh,
			    (char *) pcabxDest->rgh,
			    pcabxDest->cabh.cwData * sizeof(WORD));
			HeapFree(hcabT);
			}

		EndDialog(pwnd, tmc);
		}
	return(TRUE);
	}



PRIVATE PTIF
PtifFromTmc(tmc)
/*
  -- return TM for a given TMC
  -- read info about TIF's in header for special mapping
*/
TMC tmc;
	{
	REGISTER PTIF ptif;
	WORD ctif;

	if (tmc >= tmcSysMin && tmc < tmcSysMax)
		{
		/* in array if at all */
		AssertSz(ItifOfTmc(tmc) < sdsCur.ctif, "invalid TMC");
		ptif = &sdsCur.rgtif[ItifOfTmc(tmc)];
		AssertSz(ptif->tmc == tmc, "invalid TMC");
		return ptif;
		}

	ptif = sdsCur.rgtif;
	ctif = sdsCur.ctif;
	while (ctif--)
		{
		if (ptif->tmc == tmc)
			return ptif;
		ptif++;
		}
	AssertSz(FALSE, "invalid TMC");
	}


/*****************************************************************************/

/*	* ListBox Utilities */



STATIC char *
SzWildCard(sz)
/*
  -- return pointer to wildcard at end of long path
  -- return empty string (not NULL) if no wild cards
*/
REGISTER char *sz;
	{
	REGISTER char ch;
	char *pchAfterSlash = sz;
	BOOL	fWild = FALSE;

	while ((ch = *sz) != '\0')
		{
		sz++;
		if (ch == '\\' || ch == '/' || ch == ':')
			pchAfterSlash = sz;
		else if (ch == '*' || ch == '?')
			fWild = TRUE;
		}

	Assert(*sz == '\0');		/* sz => empty string */
	return (fWild ? pchAfterSlash : sz);
	}



#ifdef LISTBOX_DIR

STATIC BOOL
FFillComboDir(ptif, fInit)
/*
  -- fill CAB arg with thing selected from directory
  -- return TRUE if can exit, FALSE if wildcard (or directory)
	 (don't end dialog)
  -- ptif-1 => TIF of edit item
  -- ptif   => TIF of a combo dir listbox
  -- ptif+1 => TIF of a tracking text (optional)
  -- if fInit set => always fill listbox / don't move focus
*/
REGISTER PTIF ptif;
BOOL fInit;
	{
	BOOL fCantExit;
	char szBuffer[cwEditBuffer * sizeof (WORD)];
	Debug(PTM ptmListBox = ptif->ptm);
	Debug(PTM ptmEdit = (ptif-1)->ptm);

	Assert(ptmListBox->tmtBase == tmtListBox && ptmListBox->fDirListBox);
	if (!ptif->ptm->fComboListBox)
		return TRUE;		/* directory listbox */

	/* get edit item (path name) */
	GetDlgItemText((ptif-1)->pwnd, szBuffer, sizeof(szBuffer)-1);

	if ((fCantExit = FMaybeDir(szBuffer)) || fInit)
		{
		/* re-fill */
		PWND	pwnd = ptif->fReal ? ptif->pwnd : NULL;

		if ((ptif+1)->ptm->tmtBase != tmtTrackingText)
			DlgDirList(pwnd, szBuffer, NULL, fRedrawItem, NULL);
		else
			{
			DlgDirList(pwnd, szBuffer, (ptif+1)->pwnd,
			    fRedrawItem,
			    (ptif+2)->ptm->tmtBase == tmtListBox ?
			    (ptif+2)->pwnd : NULL);
			}

		if (!fInit)
			SetFocus((ptif-1)->pwnd);
		}

	/* real path, no wild-cards */
	SetDlgItemText((ptif-1)->pwnd, szBuffer, fRedrawItem);
	return !fCantExit;
	}
#endif /*LISTBOX_DIR*/



PRIVATE VOID
FillListBoxTif(ptif, iszInit)
/*
  -- fill listbox from CAB info
*/
REGISTER PTIF ptif;
WORD iszInit;		/* initial selection : if non-combo */
	{
	Assert(ptif->ptm->tmtBase == tmtListBox);
	Assert(sdsCur.hcab != NULL);
	Assert(ptif->pwnd != NULL);

#ifdef LISTBOX_DIR
	if (ptif->ptm->fDirListBox)
		{
		/* Directory ListBox */
		FFillComboDir(ptif, TRUE);
		}
	else
#else
	Assert(!(ptif->ptm->fDirListBox));
#endif /*!LISTBOX_DIR*/
		{
		/* Non-directory ListBox */
		WORD	isz;
		WORD	csz;
		PWFN_CTL pfnCtl;
		char szBuffer[cchListTextMax];

		AssertExtension1(ptif);
		pfnCtl = Ptm1OfTif(ptif)->pfnCtl;
		Assert(pfnCtl != NULL);

		SendMessageShort(ptif->pwnd, LB_RESETCONTENT);
		csz = (*pfnCtl)(tmmCount, NULL, NULL, ptif->tmc, wParamLater, 0);
		isz = 0;

		if (ptif->ptm->fSortedListBox || csz == cszUnknown)
			{
			/* we must fill in the listbox */
			while (csz == cszUnknown || isz < csz)
				{
				if ((*pfnCtl)(tmmText, szBuffer, isz++, ptif->tmc,
				    wParamLater, 0))
					{
					/* we have a string */
					SendMessage(ptif->pwnd, LB_ADDSTRING,
					    (WORD) szBuffer, 0L);
					}
				else if (csz == cszUnknown)
					break;	/* stop filling */
				}
			}
		else
			{
			/* fill on demand (fill with empties) */
			Assert(csz != cszUnknown);
			while (csz--)
				SendMessage(ptif->pwnd, LB_ADDSTRING, 0, 0L);
			}

		/* we assume the right val for SendMessage */
		if (!ptif->ptm->fComboListBox && iszInit != iszNinchList)
			SendMessage(ptif->pwnd, LB_SETCURSEL, iszInit, 0L);
		}
	}




STATIC VOID
SelChangeComboListBox(ptif)
/*
  -- respond to combo listbox selection change
  -- ptif-1  => Edit Item
  -- ptif    => Listbox
  -- ptif+2  => second listbox (if ptif+1 => Tracking text)
*/
PTIF ptif;
	{
	char szBuffer[cchDirMax];

	/* Combo listbox must be prefixed by edit item */
	Assert(ptif > sdsCur.rgtif && (ptif-1)->ptm->tmtBase == tmtEdit);
	Assert(ptif->ptm->tmtBase == tmtListBox);

#ifdef LISTBOX_DIR
	if (ptif->ptm->fDirListBox)
		{
		char szBuffer2[cchDirMax];

		/* select new item in directory */
		if (DlgDirSelect(ptif->pwnd, szBuffer
		    ,(ptif+2)->ptm->tmtBase == tmtListBox ?
		    (ptif+2)->pwnd : NULL))
			{
			GetDlgItemText((ptif-1)->pwnd, szBuffer2,
			    sizeof(szBuffer2)-1);
			/* skip directory or drive info */
			SzAppendSDM(szBuffer, SzWildCard(szBuffer2));
			}
		}
	else
#endif /*LISTBOX_DIR*/
		{
		/* Non directory listbox */
		WORD isz;

		AssertExtension1(ptif);
		isz = (WORD) SendMessageShort(ptif->pwnd, LB_GETCURSEL);
		/* call listbox proc to get the proper text */
		if (isz != iszNinchList)
			{
			if (!(*Ptm1OfTif(ptif)->pfnCtl)(tmmEditText, szBuffer,
			    isz, ptif->tmc, wParamLater, 0))
				{
				/* get string from listbox */
				GetListText(ptif->pwnd, szBuffer, sizeof(szBuffer));
				}
			}
		else
			szBuffer[0] = '\0';

		}

	Assert(fRedrawItem);
	SetEditText((ptif - 1)->pwnd, szBuffer, TRUE);
	}

/**************************/
/*      button utilities  */

PRIVATE VOID
KillDefaultButton()
	{
	PWND pwnd = sdsCur.pwndDialog;
	PWND pwndT;

	AssertSz((pwnd != NULL),"SetDefaultTmc : no dialog");
	while ((pwndT = PwndDefaultPushButton(pwnd)) != NULL)
		{
		pwndT->style = (pwndT->style & WS_TYPE) | BS_PUSHBUTTON;
		DrawWindow(pwndT);
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\sdm.h ===
/*
	CW : Character Windows

	sdm.h : sdm specific stuff
*/

typedef WORD	SB;
#include <lmem.h>		/* requires LMEM for local allocations */

/* ODD pwnds don't really exist */
#define	FFakeWnd(pwnd)	((int) (pwnd) & 1)
#define	FRealWnd(pwnd)	(((int) (pwnd) & 1) == 0)


#define ichTextMax 256    /* size for string buffers */

typedef struct _sdmtm	*PTM;		/* generic TM */

/* CAB Arg info */
#define	iagNil		((WORD) -1)	/* if no CAB arg */


/*
  TIF's : are stored in a global array (sdsCur.rgtif) with size sdsCur.ctif
  mapping from tmc->tif is performed in the following manner :
	1) if tmc <= tmcSysMin && tmc < tmcSysMax then rgtif[tmc-tmcSysMin]
		must contain the tmc (if it is defined).
	2) if tmc < tmcSysMin or tmc >= tmcSysMax (i.e. a special or imported
		TMC), then the array must be scanned.
  NOTE : there is always a guard TIF at the end of rgtif (ptm == NULL,
							tmc == tmcNull).
*/
  
/* if tmc is in tmcSys range */
#define ItifOfTmc(tmc)		((tmc) - tmcSysMin)

typedef struct _tif
	{
	TMC	tmc;
	PTM	ptm;			/* start of extension records */
	WORD	iagText;		/* CAB entry for text from CAB */
	WORD	iagMain;		/* index to main CAB arg */
	PWND	pwnd;			/* pointer to window */
	BIT	fReal:1;		/* a real window ?? */
	} TIF;	/* iTem InFo */

typedef TIF	*PTIF;			/* pointer to a TIF */


PRIVATE TIF * 	PtifFromTmc(TMC);
PRIVATE WORD	GetRadVal(PTIF);
PRIVATE VOID	FillListBoxTif(PTIF, WORD);
PRIVATE VOID	KillDefaultButton(VOID);

/* generic heap procedure equivalents */
#define	sbHeap		1
#define HeapAlloc(cb)		PpvAllocCb(sbHeap, cb)
#define HeapFree(h)		FreePpv(sbHeap, (VOID **) (h))
#define CwFromCch(cch)	(((cch) + 1) / 2)

#define cwWnd (sizeof(WND)/sizeof(WORD) - cwExtraWnd)


#ifdef EDIT_LIMIT_SIZE
/* Limit size for QB */
#define cwEditBuffer 64 			/* 128 char limit */
#else
#define cwEditBuffer 128			/* 256 char limit */
#endif /*!EDIT_LIMIT_SIZE*/

#define Alert(sz) \
	MessageBox(sz, NULL, NULL, MB_OK)

/* append sz2 to end of sz1 */
#define SzAppendSDM(sz1, sz2) \
	fstrcpy((char far *) sz1+strlen(sz1), (char far *) sz2)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\scroll.c ===
/*
	COW : Character Oriented Windows

	scroll.c : scroll bar control
*/

#define COW
#include <cow.h>

#define SCROLL

#include <uscroll.h>
#include <uwindow.h>
#include <uscreen.h>
#include <uisa.h>
#include <uevent.h>
#include <kinput.h>

#include "dialog.h"
#include "event.h"
#include "util.h"
#include "screen.h"

#include "scroll.h"
#include "_scroll.h"



/*
	scroll bar slots

ptCurSb		current logical position in range 
ptMinSb		minimum logical position in scroll range 
ptMaxSb		maximum logical position in scroll range 
wSb		extra word for info defined below
*/



/* ScrollBarWndProc(pwnd, message, wParam, lParam) - 
*  Process scroll bar messages.
*  Purpose:
*	Handles user interaction with scroll bars.
*
*	Scroll Bar:
*	^	<--- Up Arrow
*	+	<-------------------
*	+     ^                     ^
*	+     |                     |
*	+     |                     |
*	+     +--- Page Up Area     |
*	+     |                     |
*	+     |                     |
*	+     v                     |
*	+  <---                     |
*	#	<------ Elevator         +--- Scroll range
*	+  <---                     |
*	+     ^                     |
*	+     |                     |
*	+     |                     |
*	+     +--- Page Down Area   |
*	+     |                     |
*	+     |                     |
*	+     v                     v
*	+	<-------------------
*	v	<--- Down Arrow
*
*	The scroll bar manager sends WM_VSCROLL or WM_HSCROLL messages to
*	its Parent when a scroll bar event is detected.
*	The value of the wParam and lParam parameters of this
*       message determine what event has occured.
*
*	wParam			Event
*	------			-----
*	SB_LINEUP		The mouse was clicked on the Up Arrow
*	SB_LINEDOWN		The mouse was clicked on the Down Arrow
*	SB_PAGEUP		The mouse was clicked in the Page Up Area
*	SB_PAGEDOWN		The mouse was clicked in the Page Down Area
*	SB_THUMBPOSITION	The elevator was dragged to a new position.
*	SB_THUMBTRACK		The elevator has moved but the mousebutton
*				is still down.
*
*	The Application sees the elevator as being in the logical range
*	ptMin..ptMax. These logical values are used for communication between
*	the Scroll Bar Manager, and the Application. 
*
*
*****************************************************************************/


PUBLIC DWORD FARPUBLIC 
ScrollBarWndProc(pwnd, message, wParam, lParam)
/*
  -- the real scroll bar Wnd Proc
*/
REGISTER PWND pwnd;
DWORD lParam;
WORD message, wParam;
	{
	StartPublic();
	RRC rrc;
	BYTE ptDownLine, ptElevator;
	short ptNew;
	MSP msp;
	WORD messageScroll;
	WORD wNonClient;		/* value to mask for non-client */
	BOOL fSmallScroll;

	/* statics for the scroll bar with capture */
	static WORD wParamScroll;
	static BOOL fInWindow = TRUE;
	static BYTE ptStartElevator;
	static BYTE ptMouse;
	BYTE pt;		/* the position if a mouse message */
	
	GetClientRrc(pwnd, &rrc);
	/* set up parameter based on whether horizontal or vertical scroll */
	ptElevator = PtElevatorSb(pwnd);
	msp.lParam = lParam;

	if (pwnd->style & SBS_VERT)
		{
		messageScroll = WM_VSCROLL;
		ptDownLine = rrc.ryBottom-rrc.ryTop-1;
		pt = msp.s.ry;
		wNonClient = MK_NONCLIENT_Y;
		fSmallScroll = rrc.ryBottom - rrc.ryTop == dyScrollMin;
		}
	else 
		{
		messageScroll = WM_HSCROLL;
		ptDownLine = rrc.rxRight-rrc.rxLeft-1;
		pt = msp.s.rx;
		wNonClient = MK_NONCLIENT_X;
		fSmallScroll = rrc.rxRight - rrc.rxLeft == dxScrollMin;
		}

	switch (message) 
		{
	default:
		break;
		
	case WM_PAINT:
		/* draw the scroll bar */
#ifdef DEBUG
		if (pwnd->style & SBS_VERT)
			{
			AssertSz(rrc.ryBottom - rrc.ryTop >= dyScrollMin,
			    "Scroll bars too small");
			}
		else
			{
			AssertSz(rrc.rxRight - rrc.rxLeft >= dxScrollMin,
			    "Scroll bars too small");
			}
#endif /*DEBUG*/
#ifndef REMOVE_LATER
		if (pwnd->style & SBS_VERT)
			{
			rrc.ryTop++;
			rrc.ryBottom--;
			}
		else
			{
			rrc.rxLeft++;
			rrc.rxRight--;
			}
#endif

		BeginDraw();

		FillRrc(pwnd, &rrc, (ACHAR) chScrollbar, DiNormal(isaScrollbar));

		if (pwnd->style & SBS_VERT)
			{
			CharOut(pwnd, 0, 0, chUpArrow,
			    DiNormal(isaScrollbar));
			CharOut(pwnd, 0, ptDownLine, chDownArrow,
			    DiNormal(isaScrollbar));
			if (!fSmallScroll)
				CharOut(pwnd, 0, ptElevator, chElevator,
				    DiNormal(isaElevator));
			}
		else 
			{
			CharOut(pwnd, 0, 0, chLeftArrow,
			    DiNormal(isaScrollbar));
			CharOut(pwnd, ptDownLine, 0, chRightArrow,
			    DiNormal(isaScrollbar));
			if (!fSmallScroll)
				CharOut(pwnd, ptElevator, 0, chElevator,
				    DiNormal(isaElevator));
			}

		EndDraw();

		break;
		
	case WM_LBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
		fInWindow = TRUE;
		/* capture mouse for repeated scrolling or thumbtrack */
		SetCapture(pwnd);

		if ((ptMouse = pt) == 0)
			wParamScroll = SB_LINEUP;
		else if (ptMouse == ptDownLine)
			wParamScroll = SB_LINEDOWN;
		else if (ptMouse > ptElevator)
			wParamScroll = SB_PAGEDOWN;
		else if (ptMouse < ptElevator)
			wParamScroll = SB_PAGEUP;
		else 
			{
			/* capturing the elevator */
			wParamScroll = SB_THUMBPOSITION;
			ptStartElevator = ptElevator;
			break;	/* do not set alarm or send message */
			}

		SetAlarm(pwnd, ctickRepScrollStart);
		SendMessage(pwnd->pwndParent, messageScroll,
		    wParamScroll, MAKELONG(0, (WORD) pwnd));

		break;
		
	case WM_MOUSEMOVE:
		/* mouse movements are only used for Thumb-tracking */

		/* see if mouse is still in the window */
		fInWindow = FCaptured(pwnd) && !(wParam & wNonClient);
		if (fSmallScroll)
			break;		/* not thumbtrack possible */

		ptMouse = pt;

		if (wParamScroll == SB_THUMBPOSITION) 
			{
			if (!fInWindow)
				/* reset thumb */
				ptMouse = ptStartElevator;
			if (ptMouse != ptElevator &&
			    ptMouse > 0 && 
			    ptMouse < ptDownLine)
				{
				/* change thumbposition */
				SetPtElevatorSb(pwnd, ptMouse);
				/* ??? efficiency ??? */
				if (pwnd->style & SBS_VERT)
					{
					CharOut(pwnd, 0, ptElevator, 
					    (ACHAR) chScrollbar,
					    DiNormal(isaScrollbar));
					/*maybe*/CharOut(pwnd, 0, ptMouse,
					    chElevator, DiNormal(isaElevator));
					}
				else 
					{
					CharOut(pwnd, ptElevator, 0, 
					    (ACHAR) chScrollbar,
					    DiNormal(isaScrollbar));
					/*maybe*/CharOut(pwnd, ptMouse, 0,
					    chElevator, DiNormal(isaElevator));
					}
				/* translate physical to logical; round up */
				ptNew = TranslatePosition(ptMouse, 
				    1, ptDownLine-1,
				    pwnd->ptMinSb, pwnd->ptMaxSb, TRUE);

				pwnd->ptCurSb = ptNew;
				SendMessage(pwnd->pwndParent, messageScroll,
				    SB_THUMBTRACK,
				    MAKELONG(ptNew, (WORD) pwnd));
				}
			}
		break;
		
	case WM_ALARM:
		if (FCaptured(pwnd))
			{
			SetAlarm(pwnd, pwnd->ctickRepSb);
			if (fInWindow) 
				{
				switch (wParamScroll) 
					{
				default:
					goto ReturnFalse;

				case SB_LINEUP:
					if (ptMouse != 0)
						goto ReturnFalse;
					break;
					
				case SB_LINEDOWN:
					if (ptMouse != ptDownLine)
						goto ReturnFalse;
					break;
					
				case SB_PAGEUP:
					if (ptMouse == 0 || 
					    ptMouse >= ptElevator)
						goto ReturnFalse;
					break;
					
				case SB_PAGEDOWN:
					if (ptMouse == ptDownLine ||
					    ptMouse <= ptElevator)
						goto ReturnFalse;
					break;
					
					}
				SendMessage(pwnd->pwndParent, messageScroll,
				    wParamScroll, MAKELONG(0, (WORD) pwnd));
				}
			}
		break;
		
	case WM_LBUTTONUP:
		if (wParamScroll == SB_THUMBPOSITION && !fSmallScroll)
			{
			/* end tracking elevator */
			ptNew = TranslatePosition(ptElevator, 1, ptDownLine-1, 
			    pwnd->ptMinSb, pwnd->ptMaxSb, TRUE);

			if (ptNew != -1)	/* -1 if calculation error */
				{
				SendMessage(pwnd->pwndParent, messageScroll,
				    SB_THUMBPOSITION,
				    MAKELONG(ptNew, (WORD) pwnd));

				SendMessage(pwnd->pwndParent, messageScroll,
				    SB_ENDSCROLL,
				    MAKELONG(ptNew, (WORD) pwnd));
				}
			}
		SendMessage(pwnd->pwndParent, messageScroll, SB_UPCLICK, 0L);
		wParamScroll = 0;
		if (FCaptured(pwnd))
			{
			ReleaseCapture();
			KillAlarm();
			}
		break;
		
#ifdef DEBUG
	case WM_KEYDOWN:
	case WM_KEYUP:
	case WM_CHAR:		/* just an extra check */
		Assert(FALSE);
#endif

		}
ReturnFalse:
	ReturnPublic(0L, DWORD);
	}



PUBLIC VOID FARPUBLIC
SetScrollRange(pwnd, ptMin, ptMax, fRedraw)
/*
  -- set the scroll range for the scrollbar window "pwnd"
  -- 
*/
PWND pwnd;
short ptMin, ptMax;
BOOL fRedraw;
	{
	StartPublic();

	AssertSz(ptMax > ptMin, "SetScrollRange : invalid range");
	pwnd->ptCurSb = pwnd->ptMinSb = ptMin;
	pwnd->ptMaxSb = ptMax;
	if (PtElevatorSb(pwnd) == 0)
		SetPtElevatorSb(pwnd, 1);
	if (fRedraw)
		DrawWindow(pwnd);
	StopPublic();
	}



PUBLIC short FARPUBLIC
SetScrollPos(pwnd, ptNew, fRedraw)
/*
  -- set the scroll position for the scrollbar window "pwnd"
  -- useless operation if scroll-bar is 2-wide
*/
PWND pwnd;
short ptNew;
BOOL fRedraw;
	{
	StartPublic();
	short ptOld = pwnd->ptCurSb;
	RRC rrc;
	WORD ptMax;

	AssertSz((short) pwnd->ptMaxSb >= (short) pwnd->ptMinSb, "SetScrollPos : invalid range");
	AssertSz(ptNew >= pwnd->ptMinSb && ptNew <= pwnd->ptMaxSb,
	    "SetScrollPos : out of range");

	GetClientRrc(pwnd, &rrc);
	pwnd->ptCurSb = ptNew;
	if (pwnd->style & SBS_VERT)
		{
		ptMax = rrc.ryBottom - 2;	/* one position for downline */
		if (rrc.ryBottom - rrc.ryTop == dyScrollMin)
			ReturnPublic(ptOld, short);
		}
	else
		{
		ptMax = rrc.rxRight - 2;	/* one position for downline */
		if (rrc.rxRight - rrc.rxLeft == dxScrollMin)
			ReturnPublic(ptOld, short);
		}

	/* translate from logical to physical range, round down */
	ptNew = TranslatePosition(ptNew, pwnd->ptMinSb, pwnd->ptMaxSb,
				  1, ptMax, FALSE);
	Assert(!(ptNew & 0xff00));
  	SetPtElevatorSb(pwnd, ptNew);
	/* redraw elevator */
	if (fRedraw)
		DrawWindow(pwnd);

	ReturnPublic(ptOld, short);
	}	



PUBLIC short FARPUBLIC
GetScrollPos(pwnd)
PWND pwnd;
	{
	StartPublic();
	ReturnPublic(pwnd->ptCurSb, short);
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\sdmcab.c ===
/*
	COW : Character Oriented Windows

	sdmcab.c : SDM Cab functions

	NOTE : critical assumption that a HANDLE is a ** near pointer

*/

#define COW
#include <cow.h>

#define SDM

#include <sdmver.h>

#include <kmem.h>
#include <usdm.h>
#include <udialog.h>

#include "dialog.h"
#include "util.h"

#include "sdm.h"

#ifdef KANJI
#include <ukanji.h>
#endif


PUBLIC VOID FARPUBLIC
InitCab(hcab, cabi)
/*
  -- initialize a CAB that is assumed to contain trash
  -- LOBYTE(cabi) = cwData, HIBYTE(cabi) = cagHandle
*/
HCAB hcab;
WORD cabi;	/* cab init info */
	{
	REGISTER CABX *pcabx;
	WORD cagHandle = HIBYTE(cabi);

	Assert(cagHandle <= LOBYTE(cabi));
	pcabx = *hcab;
	pcabx->cabh.cwData = LOBYTE(cabi);
	pcabx->cabh.cagHandle = cagHandle;
	FillBuf((char *) pcabx->rgh, 0, cagHandle * sizeof(WORD));
		/* make all handles NULL */
	}



PUBLIC VOID FARPUBLIC
ReinitCab(hcab, cabi)
/*
  -- re-initialize a CAB that was previously a CAB
  -- LOBYTE(cabi) = cwData, HIBYTE(cabi) = cagHandle
*/
HCAB hcab;
WORD cabi;	/* cab init info */
	{
	FreeCabData(hcab);
	InitCab(hcab, cabi);
	}



PUBLIC HCAB FARPUBLIC
HcabAlloc(cabi)
/*
  -- allocate a new cab
  -- initialize cab fields
  -- return hcab or NULL if out of memory
  -- LOBYTE(cabi) = cwData, HIBYTE(cabi) = cagHandle
*/
WORD cabi;	/* cab init info */
	{
	StartPublic();

	HCABX hcabx;
	WORD cb = cbCabOverhead + LOBYTE(cabi) * sizeof(WORD);

	if ((hcabx = (HCABX) HeapAlloc(cb)) == NULL)
		{
		OutOfMemory();
		ReturnPublic(NULL, HCAB);
		}
	InitCab(hcabx, cabi);
	ReturnPublic(hcabx, HCAB);
	}



PUBLIC VOID FARPUBLIC
FreeCab(hcab)
/*
  -- Free the cab and any handles it contains
*/
HCAB hcab;
	{
	FreeCabData(hcab);
	HeapFree(hcab);
	}



PUBLIC VOID FARPUBLIC
FreeCabData(hcab)
/*
  -- Free any handles associated with hcab
*/
HCAB hcab;
	{
	WORD cag = PcabxOfCab(hcab)->cabh.cagHandle;
	REGISTER HANDLE *ph = ((CABX *) (*hcab))->rgh;

	while (cag--)
		{
		if (*ph != NULL)
			{
			HeapFree(*ph);
			*ph = NULL;
			}
		ph++;
		}
	}


PUBLIC VOID FARPUBLIC
RgbToCab(hcab, rgbSrc, cb, iag)
/*
  -- store cb bytes from rgb into memory allocated from heap
  -- store handle in hcab at ag specified by iag
  -- if previous contained data -- free it
*/
HCAB hcab;
BYTE *rgbSrc;
WORD cb;
WORD iag;
	{
	StartPublic();
	REGISTER HANDLE *ph;
	REGISTER BYTE **ppb;

	Assert(hcab != NULL);
	Assert(iag <= PcabxOfCab(hcab)->cabh.cagHandle);

 	ph = &PcabxOfCab(hcab)->rgh[iag];
	if (*ph != NULL)
		{
		HeapFree(*ph);
		*ph = NULL;
		}

	if ((ppb = HeapAlloc(cb)) == NULL)
		{
		OutOfMemory();
		return;		/* no error value
				   -- hopefully OutOfMemory() will handle it */
		}

	/* ph is potentially bogus */
 	PcabxOfCab(hcab)->rgh[iag] = (HANDLE) ppb;
	bltbyte(rgbSrc, *ppb, cb);
	StopPublic();
	}



PUBLIC BYTE * FARPUBLIC
RgbFromCab(hcab, rgbDest, cb, iag)
HCAB hcab;
BYTE *rgbDest;
WORD cb;
WORD iag;
	{
	StartPublic();
	REGISTER BYTE **ppb = PpvFromCab(hcab, iag);

	AssertSz(ppb != NULL, "RgbFromCab : NULL handle");
	ReturnPublic(bltbyte(*ppb, rgbDest, cb), BYTE *);
	}



#ifndef SDM_ST
/* SZ strings */


#ifdef EXTRAS

PUBLIC VOID FARPUBLIC
PszToCab(hcab, psz, iag)
/*
  -- put a handle in a cab, no data copy
*/
HCAB hcab;
char **psz;
WORD iag;
	{
	StartPublic();
	REGISTER HANDLE *ph;

	Assert(hcab != NULL);
	Assert(iag <= PcabxOfCab(hcab)->cabh.cagHandle);

 	ph = &PcabxOfCab(hcab)->rgh[iag];
	if (*ph != NULL)
		HeapFree(*ph);

	*ph = (HANDLE) psz;
	StopPublic();
	}
#endif /*EXTRAS*/



PUBLIC VOID FARPUBLIC
SzToCab(hcab, sz, iag)
HCAB hcab;
char *sz;
WORD iag;
	{
	StartPublic();
	WORD cb = strlen(sz) + 1;
	RgbToCab(hcab, sz, cb, iag);
	StopPublic();
	}



PUBLIC char * FARPUBLIC
SzFromCab(hcab, sz, cbMac, iag)
/*
  -- return string that will be zero terminated
*/
HCAB hcab;
char *sz;
REGISTER WORD cbMac;
WORD iag;
	{
	WORD	cbCur;
	StartPublic();

	Assert(cbMac > 1);		/* must have room for something */
	/* blt but don't trash null */
	Assert(PpvFromCab(hcab, iag) != NULL);
	cbCur = strlen(*PpvFromCab(hcab, iag)) + 1;	/* include trailing 0 */
	if (cbMac > cbCur)
		cbMac = cbCur;		/* only copy real data */
#ifdef KANJI
	else {
		char *szcab = *PpvFromCab(hcab, iag);
		cbMac = PchPrevDbcs(szcab + cbMac, szcab) - szcab + 1;
	}
#endif
	sz[cbMac-1] = '\0';
	ReturnPublic(RgbFromCab(hcab, sz, cbMac-1, iag), char *);
	}


#else
/* ST strings : This implementation is bogus */
PUBLIC VOID FARPUBLIC
StToCab(hcab, st, iag)
HCAB hcab;
char *st;
WORD iag;
	{
	StartPublic();
	RgbToCab(hcab, st, *st + 1, iag);
	StopPublic();
	}


PUBLIC char * FARPUBLIC
StFromCab(hcab, st, cb, iag)
HCAB hcab;
char *st;
WORD iag, cb;
	{
	StartPublic();
	.... this is wrong !!!!!
	ReturnPublic(RgbFromCab(hcab, st, cb, iag), char *);
	}

#endif /*SDM_ST*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\sdmtmc.c ===
/*
	COW : Character Oriented Windows

	sdmtmc.c : SDM TMC functions
*/

#define COW
#include <cow.h>

#define SDM

#include <sdmver.h>
#include <usdm.h>
#include <usdmtmpl.h>

#include <uevent.h>
#include <uedit.h>
#include <udialog.h>
#include <uwindow.h>
#include <uisa.h>

#include "dialog.h"
#include "event.h"
#include "button.h"
#include "util.h"

#include "sdm.h"

/* G L O B A L S */



PUBLIC VOID FARPUBLIC
SetTmcText(tmc, sz)
TMC tmc;
char *sz;
	{
	StartPublic();
	SetDlgItemText(PtifFromTmc(tmc)->pwnd, sz, fRedrawItem);
	StopPublic();
	}



PUBLIC VOID FARPUBLIC
GetTmcText(tmc, sz, cb)
TMC tmc;
char *sz;
WORD cb;
	{
	StartPublic();
	GetDlgItemText(PtifFromTmc(tmc)->pwnd, sz, cb);
	StopPublic();
	}



PUBLIC VOID FARPUBLIC
EnableTmc(tmc, fEnable)
TMC tmc;
BOOL fEnable;
	{
	REGISTER PTIF ptif = PtifFromTmc(tmc & ~tmcGrouped);
	REGISTER PWND pwnd;

	if (tmc & tmcGrouped)
		{
		Assert(ptif->ptm->tmtBase == tmtRadioButton);
		Assert(ptif->ptm->fFirstButton);
		do
			{
			pwnd = ptif->pwnd;
			Assert(pwnd != NULL);
			EnableWindow(pwnd, fEnable);
			if (fRedrawItem)
				DrawWindow(pwnd);
			ptif++;
			}
		while (ptif->ptm->tmtBase == tmtRadioButton &&
			!ptif->ptm->fFirstButton);
		}
	else
		{
		pwnd = ptif->pwnd;
		Assert(pwnd != NULL);
		EnableWindow(pwnd, fEnable);
		/* update window if necessary */
		if (fRedrawItem)
			DrawWindow(pwnd);
		}
	}



PUBLIC BOOL FARPUBLIC
FEnabledTmc(tmc)
/*
  -- return TRUE if item enabled
*/
TMC tmc;
	{
	StartPublic();
	ReturnPublic(PtifFromTmc(tmc)->pwnd->fEnabled, BOOL);
	}



PUBLIC VOID FARPUBLIC
SetTmcVal(tmc, val)
TMC tmc;
WORD val;
	{
	StartPublic();
	REGISTER PTIF ptif = PtifFromTmc(tmc & ~tmcGrouped);

	switch(ptif->ptm->tmtBase)
		{
#ifdef DEBUG
	default:
		Assert(FALSE);
		break;
#endif
	case tmtEdit:
		{
		WORD *pval = &val;
		char sz[cwEditBuffer * sizeof (WORD)];

		AssertExtension1(ptif);
		AssertSz(Ptm1OfTif(ptif)->pfnCtl != NULL, "SetTmcVal : edit with no Parse Proc");
		(*Ptm1OfTif(ptif)->pfnCtl)(tmmFormat, sz, (WORD) &pval, tmc, 0, 0);
		SetDlgItemText(ptif->pwnd, sz, fRedrawItem);
		}
		break;
	case tmtCheckBox:
		CheckDlgButton(ptif->pwnd, val, fRedrawItem);
		break;
	case tmtRadioButton:
		Assert(tmc & tmcGrouped);
		Assert(ptif->ptm->fFirstButton);
		CheckRadioButton(ptif->pwnd, val, fRedrawItem);
		break;
	case tmtListBox:
		/* we assume the right val for SendMessage */
		SendMessage(ptif->pwnd, LB_SETCURSEL, val, 0L);
		break;
		}
	StopPublic();
	}



PUBLIC WORD FARPUBLIC
GetTmcVal(tmc)
TMC tmc;
	{
	StartPublic();
	REGISTER PTIF ptif = PtifFromTmc(tmc & ~tmcGrouped);

	switch(ptif->ptm->tmtBase)
		{
#ifdef DEBUG
	default:
		Alert("GetTmcVal: bad tmt");
		ReturnPublic(0, WORD);
		/*break*/
#endif
	case tmtEdit:
		{
		WORD val;
		WORD *pval = &val;
		char sz[cwEditBuffer * sizeof (WORD)];

		AssertExtension1(ptif);
		AssertSz(Ptm1OfTif(ptif)->pfnCtl != NULL, "GetTmcVal : edit with no Parse Proc");
		GetDlgItemText(ptif->pwnd, sz, sizeof(sz)-1);
		(*Ptm1OfTif(ptif)->pfnCtl)(tmmParse, sz, (WORD) &pval, tmc, 0, 0);
		ReturnPublic(val, WORD);
		}
		/*break*/

	case tmtCheckBox:
		ReturnPublic(WButtonChecked(ptif->pwnd), WORD);
	case tmtRadioButton:
		Assert(ptif->ptm->fFirstButton);
		Assert(tmc & tmcGrouped);
		ReturnPublic(GetRadVal(ptif), WORD);
	case tmtListBox:
		/* we assume the right val for SendMessage */
		ReturnPublic((WORD) SendMessage(ptif->pwnd, LB_GETCURSEL,
		    0, 0L), WORD);
		}
	}



PRIVATE WORD
GetRadVal(ptif)
/*
  -- given a Radio Button (must be first) return radio value
  -- return -1 if none.
*/
REGISTER PTIF ptif;
	{
	WORD itm;

	Assert(ptif->ptm->tmtBase == tmtRadioButton);
	Assert(ptif->ptm->fFirstButton);

	itm = 0;
	do
		{
		if (WButtonChecked(ptif->pwnd))
			return itm;
		ptif++;
		itm++;
		}
	while (ptif->ptm->tmtBase == tmtRadioButton &&
		!ptif->ptm->fFirstButton);

	return((WORD)-1);	/* nothing set */
	}





PUBLIC VOID FARPUBLIC
SetTmcSel(tmc, ichSelFirst, ichSelLim)
/*
  -- set selection for edit item
*/
TMC tmc;			/* item code of Edit Item */
WORD ichSelFirst;		/* first character */
WORD ichSelLim;			/* last character + 1 */
	{
	StartPublic();
	REGISTER PTIF ptif = PtifFromTmc(tmc);

	SetFocus(ptif->pwnd);
	SendMessage(ptif->pwnd, EM_SETSEL, 0, MAKELONG(ichSelFirst, ichSelLim));
	StopPublic();
	}



PUBLIC VOID FARPUBLIC
SetFocusTmc(tmc)
/*
  -- move focus in dialog
*/
TMC tmc;
	{
	StartPublic();
	REGISTER PWND pwnd = PtifFromTmc(tmc)->pwnd;

	AssertSz(pwnd->fEnabled, "SetFocusTmc (item disabled)");

	SetFocus(pwnd);
	StopPublic();
	}


#ifndef LISTBOX_HORIZ	// only supported for vertical

PUBLIC VOID FARPUBLIC
GetTmcListBoxOrientation(tmc, pisz, pdisz)
/*
  -- gets the listbox orientation
*/
TMC tmc;
WORD	* pisz;
WORD	* pdisz;
	{
	StartPublic();
	REGISTER PTIF ptif;

	ptif = PtifFromTmc(tmc);

	Assert(ptif->ptm->tmtBase == tmtListBox);

	GetListBoxOrientation(ptif->pwnd, pisz, pdisz);

	StopPublic();
	}

PUBLIC VOID FARPUBLIC
RedisplayListBoxOriented(tmc,pisz,pdisz)
/*
  -- cause a listbox to be redisplayed
*/
TMC tmc;
WORD	* pisz;
WORD	* pdisz;
	{
	StartPublic();
	REGISTER PTIF ptif;

	ptif = PtifFromTmc(tmc);

	Assert(ptif->ptm->tmtBase == tmtListBox);

	InitListBoxOriented(ptif->pwnd, NULL, pisz, pdisz);
	StopPublic();
	}

#endif /*!LISTBOX_HORIZ*/

PUBLIC VOID FARPUBLIC
RedisplayListBox(tmc)
/*
  -- cause a listbox to be redisplayed
*/
TMC tmc;
	{
	StartPublic();
	REGISTER PTIF ptif;

	ptif = PtifFromTmc(tmc);

	AssertSz(fRedrawItem, "RedisplayListBox called in init");
	Assert(ptif->ptm->tmtBase == tmtListBox);

	FillListBoxTif(ptif, iszNinchList);
	DrawWindow(ptif->pwnd);
	StopPublic();
	}


PUBLIC PWND FARPUBLIC
PwndOfListbox(tmc)
/*
  -- sends a message to a listbox
*/
TMC tmc;
	{
	StartPublic();
	REGISTER PTIF ptif;

	ptif = PtifFromTmc(tmc);

	/*Assert(ptif->ptm->tmtBase == tmtListBox);*/

	ReturnPublic(ptif->pwnd, PWND);
	}

PUBLIC VOID FARPUBLIC
SetDefaultTmc(tmc)
/*
  -- change the default pushbutton
*/
TMC tmc;
	{
	StartPublic();
	PWND	pwnd;

	KillDefaultButton();
	if (tmc != tmcNull)
		{
		pwnd = PtifFromTmc(tmc)->pwnd;
		pwnd->style = (pwnd->style & WS_TYPE) | BS_DEFPUSHBUTTON;
		DrawWindow(pwnd);
		}
	}

#ifndef EDIT_FULLMGR

PUBLIC VOID FARPUBLIC
SetTmcEditWidth(tmc, cch)
/*
  -- set width of horizontal listbox
*/
TMC	tmc;
WORD	cch;
	{
	StartPublic();
	REGISTER PTIF ptif;

	ptif = PtifFromTmc(tmc);

	Assert(ptif->ptm->tmtBase == tmtEdit);

	SetEditWidth(ptif->pwnd,cch);

	StopPublic();
	}

#endif	/*EDIT_FULLMGR*/

#ifdef LISTBOX_HORIZ

PUBLIC VOID FARPUBLIC
SetTmcListWidth(tmc, citem)
/*
  -- set width of horizontal listbox
*/
TMC	tmc;
WORD	citem;
	{
	StartPublic();
	REGISTER PTIF ptif;

	ptif = PtifFromTmc(tmc);

	Assert(ptif->ptm->tmtBase == tmtListBox);

	SendMessage(ptif->pwnd, LB_SETWIDTH, citem, 0L);
	StopPublic();
	}

#endif /*LISTBOX_HORIZ*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\sedit.c ===
/*
	COW : Character Oriented Windows
	(COW USER DIALOG)

	sedit.c : simple (single-line) edit wnd proc
*/

#define COW
#include <cow.h>

#include <uedit.h>
#include <uevent.h>
#include <udialog.h>
#include <vkey.h>
#include <uwindow.h>
#include <uscreen.h>
#include <uisa.h>
#include <uutil.h>
#include <kinput.h>
#include <kkeyboar.h>

#include "dialog.h"
#include "event.h"
#include "screen.h"
#include "util.h"
#include "overlap.h"

#include "edit.h"		/* includes "sedit.h" */
#include "_sedit.h"

#ifndef EDIT_FULLMGR

/* forward */
STATIC VOID DisplayEb(PWND);
STATIC BOOL FAddCh(PWND, char);
STATIC VOID DelCh(PWND, WORD);
STATIC VOID MoveCursorLeft(PWND);
STATIC VOID MoveCursorRight(PWND);
STATIC VOID DelChLeft(PWND);
STATIC VOID DelChRight(PWND);
STATIC VOID MoveCursorBegin(PWND);
STATIC VOID MoveCursorEnd(PWND);
STATIC VOID HiliteEditSel(PWND, BOOL);
STATIC VOID DeleteSelection(PWND, char *);
STATIC VOID PasteSz(PWND, char *);
STATIC VOID CopySelection(PWND, char *);



STATIC VOID
DisplayEb(pwnd)
/*
  -- display the text in the edit box
*/
REGISTER PWND pwnd;
	{
	WORD ichMac = pwnd->ichMacEb;
	WORD cch;
	RRC rrc;

	/* For fixed length edit items:
	   In order to prevent scrolling to the right due to cursor
	   or mouse moves, we reset the left edge here */
	if (pwnd->cchDialog != pwnd->cchMaxEb) pwnd->ichLeftEb = 0;

	GetClientRrc(pwnd,&rrc);
	cch = min( (WORD) rrc.rxRight, ichMac - pwnd->ichLeftEb);
#ifdef EDIT_SECRET
	/* Secret edit items for password protection */
	if (pwnd->style & ES_SECRET)
		{
		/* Fill edit item with chSecret */
		RRC rrcFill;
		rrcFill.rxLeft = rrcFill.ryTop = 0;
		rrcFill.ryBottom = 1;
		rrcFill.rxRight = (RX) cch;
		FillRrc(pwnd, &rrcFill, chSecret, pwnd->isaEb);
		}
	else
#endif /*EDIT_SECRET*/
	/*maybe*/TextOut(pwnd, 0, 0, (char *) pwnd->szDialog + pwnd->ichLeftEb,
	    cch, pwnd->isaEb);

	/* fill trailing width with fill character */
	rrc.rxLeft = (RX) cch;
	FillRrc(pwnd, &rrc, (char) pwnd->chFillDialog, pwnd->isaEb);
	}



STATIC BOOL
FAddCh(pwnd, ch)
/*
  -- add a character at the cursor position
*/
REGISTER PWND pwnd;
char ch;
	{
	WORD ichCursor = pwnd->ichCursorEb;
	short ichMac = pwnd->ichMacEb;
	char *sz = SzEdit(pwnd);
	RRC	rrc;
	RX rx;

	if (ichMac >= pwnd->cchDialog)
		return(FALSE);
	rx = (RX) (ichCursor - pwnd->ichLeftEb);
	if (ichMac >= pwnd->cchMaxEb)
		{
		if (ichCursor < pwnd->cchMaxEb)
			{
			sz[ichCursor] = ch;
			pwnd->ichCursorEb++;
			CharOut(pwnd, rx, 0, ch, pwnd->isaEb);
			}
		else
			{
			Beep();
			}
		return(TRUE);
		}
	GetClientRrc(pwnd,&rrc);
	if ((rx >= rrc.rxRight-1)&&(pwnd->cchDialog == pwnd->cchMaxEb))
		{
		pwnd->ichLeftEb++;
		BltRrc(pwnd, 0, 0, rrc.rxRight-1, 1, 1, 0);
		rx--;
		}
	if (ichCursor < ichMac)
		{
		bltbyte(sz+ichCursor, sz+ichCursor+1, ichMac-ichCursor);
		if (rx < rrc.rxRight-1)
			BltRrc(pwnd, rx+1, 0, rrc.rxRight-rx-1, 1, rx, 0);
		}
	sz[ichCursor] = ch;
#ifdef EDIT_SECRET
	if (pwnd->style & ES_SECRET)
		ch = chSecret;
#else
	AssertSz(!(pwnd->style & ES_SECRET), "Secret Edit Items not supported");
#endif /*!EDIT_SECRET*/
	CharOut(pwnd, rx, 0, ch, pwnd->isaEb);
	pwnd->ichMacEb++;
	pwnd->ichCursorEb++;
	return(TRUE);
	}



STATIC VOID
DelCh(pwnd, ichCur)
/*
  -- delete a character at the cursor position
  -- called by DelChLeft/DelChRight
*/
REGISTER PWND pwnd;
WORD ichCur;
	{
	char *sz = SzEdit(pwnd);
	WORD ichMac = pwnd->ichMacEb;

	pwnd->ichMacEb--;
	bltbyte(sz+ichCur+1, sz+ichCur, ichMac-ichCur-1);

	/* if room, make it look like we are 1 back from where we are
	*  (so that we will see an empty item only when it is really empty)
        */

	if (ichCur > 0)
		ichCur--;	/* try to fake it back one */
	if (ichCur < pwnd->ichLeftEb)
		pwnd->ichLeftEb = ichCur;

	DisplayEb(pwnd);
	}



STATIC VOID
MoveCursorLeft(pwnd)
/*
  -- move the cursor left; scroll if necessary
*/
REGISTER PWND pwnd;
	{
	short ichNew;

	if ((ichNew = pwnd->ichCursorEb-1) < 0)
		return;
	pwnd->ichCursorEb = ichNew;
	if (ichNew < pwnd->ichLeftEb)
		{
		pwnd->ichLeftEb = ichNew;
		DisplayEb(pwnd);
		}
	}



STATIC VOID
MoveCursorRight(pwnd)
/*
  -- move the cursor right; scroll if necessary
*/
REGISTER PWND pwnd;
	{
	RRC	rrc;
	WORD ichNew;
	WORD ichRight;

	GetClientRrc(pwnd,&rrc);
	ichRight = pwnd->ichLeftEb + rrc.rxRight;
	if ((ichNew = pwnd->ichCursorEb+1) > pwnd->ichMacEb)
		return;
	pwnd->ichCursorEb = ichNew;
	if (ichNew >= ichRight)
		{
		pwnd->ichLeftEb = ichNew - rrc.rxRight + 1;
		DisplayEb(pwnd);
		}
	}



STATIC VOID
DelChLeft(pwnd)
/*
  -- delete the character to the left of the cursor
*/
REGISTER PWND pwnd;
	{
	if (pwnd->ichCursorEb > 0)
		DelCh(pwnd, --pwnd->ichCursorEb);
	}



STATIC VOID
DelChRight(pwnd)
/*
  -- delete the character at the cursor
*/
REGISTER PWND pwnd;
	{
	if (pwnd->ichCursorEb < pwnd->ichMacEb)
		DelCh(pwnd, pwnd->ichCursorEb);
	}



STATIC VOID
MoveCursorBegin(pwnd)
/*
  -- move the cursor to the beginning of the edit buffer
  -- scroll as needed
*/
REGISTER PWND pwnd;
	{
	pwnd->ichCursorEb = 0;
	if (pwnd->ichLeftEb > 0)
		{
		pwnd->ichLeftEb = 0;
		DisplayEb(pwnd);
		}
	}



STATIC VOID
MoveCursorEnd(pwnd)
/*
  -- move the cursor to the end of the edit buffer
  -- scroll as needed
*/
REGISTER PWND pwnd;
	{
	REGISTER WORD ichCursor = pwnd->ichMacEb;
	WORD ichNewLeft;
	RRC	rrc;

	GetClientRrc(pwnd,&rrc);
	pwnd->ichCursorEb = ichCursor = pwnd->ichMacEb;
	if (ichCursor >= rrc.rxRight &&
	    (ichNewLeft = ichCursor - rrc.rxRight) >= pwnd->ichLeftEb)
		{
		pwnd->ichLeftEb = ichNewLeft+1;
		DisplayEb(pwnd);
		}
	}



STATIC VOID
HiliteEditSel(pwnd, fHilite)
/*
  -- hilite the current selection
*/
REGISTER PWND pwnd;
BOOL fHilite;
	{
	int ichCursor = (int) pwnd->ichCursorEb - pwnd->ichLeftEb;
	int ichSel = (int) pwnd->ichSelEb - pwnd->ichLeftEb;
	RRC rrc;

	GetClientRrc(pwnd, &rrc);
	rrc.rxLeft = (RX) ((ichSel < 0) ? 0 : ichSel);
	rrc.rxLeft = min( rrc.rxLeft, rrc.rxRight);
	rrc.rxRight = (RX) ((ichCursor < 0) ? 0 : ichCursor);

	if (ichSel >= ichCursor)
		{
		/* reverse rxLeft & right */
		RX rxT = rrc.rxLeft;
		rrc.rxLeft = rrc.rxRight;
		rrc.rxRight = rxT;
		}
	FillRrc(pwnd, &rrc, ' ', dmAttrOnly |
	    (fHilite ? pwnd->isaSelEb : pwnd->isaEb));
	}



STATIC VOID
DeleteSelection(pwnd, sz)
/*
  -- cut the current selection
  -- copying it to sz if it is not NULL
*/
REGISTER PWND pwnd;
char *sz;
	{
	WORD ichLeft, ichSel = pwnd->ichSelEb;
	WORD ichStart, ichEnd, ichMac = pwnd->ichMacEb;
	int ichCursor = pwnd->ichCursorEb;
	int cch;
	char *szStart, *szEnd;

	if (ichSel == ichCursor)
		return;
	else if (ichSel < ichCursor)
		{
		ichStart = ichSel;
		ichEnd = ichCursor-1;
		}
	else
		{
		ichStart = ichCursor;
		ichEnd = ichSel-1;
		}
	if (ichEnd >= ichMac)
		ichEnd = ichMac-1;
	cch = ichEnd - ichStart + 1;
	pwnd->ichMacEb -= cch;

	szStart = (char *) (pwnd->szDialog + ichStart);
	szEnd = (char *) (pwnd->szDialog + ichEnd);

	if (sz != NULL)
		{
		bltbyte(sz, szStart, cch);
		sz[cch] = '\0';
		}

	bltbyte(szEnd+1, szStart, ichMac-ichEnd-1);
	if (pwnd->ichLeftEb > ichEnd)
		pwnd->ichLeftEb = ichLeft - cch;
	else if (pwnd->ichLeftEb > ichStart)
		pwnd->ichLeftEb = ichStart;
	else if (pwnd->ichLeftEb == ichStart && ichStart != 0)
		pwnd->ichLeftEb = ichStart - 1;
	pwnd->ichCursorEb = ichStart;

	DisplayEb(pwnd);
	}



STATIC VOID
PasteSz(pwnd, szPaste)
/*
  -- paste the contents of szPaste at the cursor
*/
REGISTER PWND pwnd;
char *szPaste;
	{
	WORD cch = strlen(szPaste);
	WORD ichCursor = pwnd->ichCursorEb;
	char *sz = SzEdit(pwnd) + ichCursor;
	short cchShift = min(pwnd->cchDialog - ichCursor - cch,
			     min(pwnd->cchMaxEb - ichCursor - cch,
			     pwnd->ichMacEb - ichCursor));
	RRC rrc;
	WORD ichRight;

	GetClientRrc(pwnd,&rrc);
	ichRight = pwnd->ichLeftEb + rrc.rxRight;
	bltbyte(sz, sz+cch, cchShift);
	cch = min(cch, min(pwnd->cchDialog - ichCursor,
			pwnd->cchMaxEb - ichCursor));
	pwnd->ichMacEb += cch;
	pwnd->ichCursorEb +=cch;
	bltbyte(szPaste, sz, cch);
	if (pwnd->ichCursorEb > ichRight)
		pwnd->ichLeftEb += cch;
	DisplayEb(pwnd);
	}



STATIC VOID
CopySelection(pwnd, sz)
/*
  -- copy the current selection into the paste buffer (sz)
  -- assume buffer to be large enough
*/
REGISTER PWND pwnd;
char *sz;
	{
	WORD ichSel = pwnd->ichSelEb;
	WORD ichStart, ichEnd, ichMac = pwnd->ichMacEb;
	WORD cch, ichCursor = pwnd->ichCursorEb;

	if (ichSel != ichCursor)
		{
		if (ichSel < ichCursor)
			{
			ichStart = ichSel;
			ichEnd = ichCursor-1;
			}
		else
			{
			ichStart = ichCursor+1;
			ichEnd = ichSel;
			}
		ichEnd = min(ichMac-1, ichEnd);
		cch = ichEnd - ichStart + 1;
		bltbyte((char *) (pwnd->szDialog) + ichStart, sz, cch);
		sz[cch] = '\0';
		}
	else
		*sz = '\0';
	}



PRIVATE DWORD FARPUBLIC			/* WndProcs are PUBLIC */
InternalEditWndProc(pwnd, message, wParam, lParam)
/*
  -- the Edit Window Procedure
*/
REGISTER PWND pwnd;
WORD message, wParam;
DWORD lParam;
	{
	MSP	msp;
	RRC	rrc;
	BOOL	fResetSelection;
	WORD	ichRight;
	BOOL	fOk;	/* for return */

	Assert(!FFocus(pwnd) || pwnd == pwndFocus);

	GetClientRrc(pwnd,&rrc);

	fResetSelection = FALSE;
	ichRight = min(pwnd->ichLeftEb + rrc.rxRight - 1, pwnd->ichMacEb);

	switch(message)
		{
	default:
	/*case WM_ACTIVATE:*/
		return FALSE;
		/*break;*/

	case WM_PAINT:
		if (!pwnd->fNoBracketEb)
			{
			/* put brackets at start and end of edit item */
			/*  NOTE : brackets drawn outside the window !! */
			DrawThisWnd(NULL);
			CharOutAbs(pwnd->arcWindow.axLeft-1,
			    pwnd->arcWindow.ayTop, '[', pwnd->isaEb);
			CharOutAbs(pwnd->arcWindow.axRight,
			    pwnd->arcWindow.ayTop, ']', pwnd->isaEb);
			}
		DisplayEb(pwnd);
		break;

	case WM_LBUTTONDOWN:
		SetFocus(pwnd);
		HiliteEditSel(pwnd, FALSE);
		msp.lParam = lParam;
		if (msp.s.ax < pwnd->arcClipping.axLeft)
			pwnd->ichCursorEb = pwnd->ichLeftEb;
		else if (msp.s.ax > pwnd->arcClipping.axRight)
			pwnd->ichCursorEb = ichRight-1;
		else
			pwnd->ichCursorEb =
			    min(pwnd->ichMacEb, msp.s.rx+pwnd->ichLeftEb);
		pwnd->ichSelEb = pwnd->ichCursorEb;
		SetCapture(pwnd);
		fResetSelection = TRUE;
		break;

	case WM_MOUSEMOVE:
		if (FCaptured(pwnd))
			{
			HiliteEditSel(pwnd, FALSE);
			msp.lParam = lParam;
			if (msp.s.ax < pwnd->arcClipping.axLeft)
				{
				MoveCursorLeft(pwnd);
				SetAlarm(pwnd, ctickRepEdit);
				}
			else if (msp.s.ax >= pwnd->arcClipping.axRight)
				{
				MoveCursorRight(pwnd);
				SetAlarm(pwnd, ctickRepEdit);
				}
			else
				{
				pwnd->ichCursorEb =
				      min((WORD) msp.s.rx + pwnd->ichLeftEb,
				          pwnd->ichMacEb);
				}
			}
		break;

	case WM_ALARM:
		if (FCaptured(pwnd))
			{
			if (axMouse < pwnd->arcClipping.axLeft)
				{
				MoveCursorLeft(pwnd);
				SetAlarm(pwnd, ctickRepEdit);
				}
			else if (axMouse > pwnd->arcClipping.axRight)
				{
				MoveCursorRight(pwnd);
				SetAlarm(pwnd, ctickRepEdit);
				}
			}
		break;

	case WM_LBUTTONUP:
		if (FCaptured(pwnd))
			{
			ReleaseCapture();
			KillAlarm();
			}

		break;

	case WM_KILLFOCUS:
		HiliteEditSel(pwnd, FALSE);
		EnableCursor(pwnd, FALSE);
		SetFFocus(pwnd, FALSE);
		SendMessage(pwnd->pwndParent,WM_DIALOG_KILLFOCUS,pwnd->id,0L);
		if (FChanged(pwnd))
			SendMessage(pwnd->pwndParent, WM_DIALOG, pwnd->id,
			    MAKELONG((PWND) pwnd, EN_CHANGE));
		return TRUE;
		/*break;*/

	case WM_WANTFOCUS:
		return (pwnd->fEnabled); /* don't go to disabled edit item */
		/*break;*/

	case WM_SETFOCUS:
		SetFFocus(pwnd, TRUE);
		SetFChanged(pwnd, FALSE);
		SendMessage(pwnd->pwndParent,WM_DIALOG_SETFOCUS,pwnd->id,0L);
		if (pwnd->fRetainSelEb)
			break;	/* retain old selection */
		/* set selection to all of edit window */
		lParam = MAKELONG(0, ichSelectEnd);
		/* fall through to set selection */

	case EM_SETSEL:
		{
		REGISTER WORD ichLim;

		if ((ichLim = HIWORD(lParam)) == ichSelectEnd)
			{
			/* special case for select till end */
			ichLim = pwnd->ichMacEb;
			}

		AssertSz(LOWORD(lParam) <= ichLim && ichLim <= pwnd->ichMacEb,
		    "invalid Edit selection");

		HiliteEditSel(pwnd, FALSE);
		pwnd->ichCursorEb = ichLim;
		pwnd->ichSelEb = LOWORD(lParam);
		if (ichLim < pwnd->ichLeftEb || ichLim > ichRight)
			{
			/* selection outside visible region */
			WORD cchMac = rrc.rxRight;

			pwnd->ichLeftEb = (ichLim < cchMac) ? 0 :
			    ichLim - cchMac + cchMac / 8;
				/* show end of selection */
			DisplayEb(pwnd);
			}
		} /*EM_SETSEL*/
		break;

	case EM_GETSEL:
		{
		if (pwnd->ichCursorEb > pwnd->ichSelEb)
			return(MAKELONG(pwnd->ichSelEb, pwnd->ichCursorEb));
		else
			return(MAKELONG(pwnd->ichCursorEb, pwnd->ichSelEb));
		break;
		}

	/*
	*  NOTE : for WM_CUT, WM_PASTE and WM_COPY
	*	API specifies "lParam" contains far pointer,
	*	make sure it is in the DDS, then use near pointer
	*/

	case WM_CUT:
		HiliteEditSel(pwnd, FALSE);
		AssertSz(HIWORD(lParam) == HIWORD((char far *) pwnd),
		    "CUT buffer must be in default data segment");
		DeleteSelection(pwnd, (char *) LOWORD(lParam));
		SetFChanged(pwnd, TRUE);
		fResetSelection = TRUE;
		break;

	case WM_PASTE:
		HiliteEditSel(pwnd, FALSE);
		DeleteSelection(pwnd, NULL);
		fResetSelection = TRUE;
		AssertSz(HIWORD(lParam) == HIWORD((char far *) pwnd),
		    "PASTE buffer must be in default data segment");
		PasteSz(pwnd, (char *) LOWORD(lParam));
		SetFChanged(pwnd, TRUE);
		break;

	case WM_COPY:
		HiliteEditSel(pwnd, FALSE);
		AssertSz(HIWORD(lParam) == HIWORD((char far *) pwnd),
		    "COPY buffer must be in default data segment");
		CopySelection(pwnd, (char *) LOWORD(lParam));
		break;

	case WM_INSERT:
		goto insert_char;
		
	case WM_CHAR:
		{
		UndoRepeat(wParam, lParam);

		if (HIWORD(lParam) & KK_MENU)
			return FALSE;	/* ignore ALT keys */

		HiliteEditSel(pwnd, FALSE);
		if (FCaptured(pwnd))
			{
			ReleaseCapture();
			KillAlarm();
			}
		fResetSelection = TRUE;

		if (wParam >= wEditFirst && wParam <= wEditLast)
			{
			if (wParam == chDelete)
				{
				if (pwnd->ichCursorEb != pwnd->ichSelEb)
					DeleteSelection(pwnd, NULL);
				else
					DelChRight(pwnd);
				}
			else
				{
insert_char:
				/* fast case for simple typing */
				SetFChanged(pwnd, TRUE);
				DeleteSelection(pwnd, NULL);
				FAddCh(pwnd, (char) wParam);
				/* reset the selection */
				pwnd->ichSelEb = pwnd->ichCursorEb;
				SetFChanged(pwnd, TRUE);
				}
			}
		else
			{
			/* check for special keys */
			switch(wParam)
				{
			default:
				/* pass character back to Dialog manager */
				fOk = FALSE;
				goto restore_selection;

			case VK_LEFT:
				MoveCursorLeft(pwnd);
				if (HIWORD(lParam) & KK_SHIFT)
					fResetSelection = FALSE;
				break;

			case VK_RIGHT:
				MoveCursorRight(pwnd);
				if (HIWORD(lParam) & KK_SHIFT)
					fResetSelection = FALSE;
				break;

			case LOBYTE(VK_BACK):	/* translated */
				if (pwnd->ichCursorEb != pwnd->ichSelEb)
					DeleteSelection(pwnd, NULL);
				else if ((HIWORD(lParam) & KK_SHIFT) != 0)
					DelChRight(pwnd);
				else
					DelChLeft(pwnd);

				SetFChanged(pwnd, TRUE);
				break;

			case VK_HOME:
				MoveCursorBegin(pwnd);
				if (HIWORD(lParam) & KK_SHIFT)
					fResetSelection = FALSE;
				break;

			case VK_END:
				MoveCursorEnd(pwnd);
				if (HIWORD(lParam) & KK_SHIFT)
					fResetSelection = FALSE;
				}
			}
		} /*WM_CHAR*/
		break;

		}/*switch*/

	if (fResetSelection)
		pwnd->ichSelEb = pwnd->ichCursorEb;

	fOk = TRUE;

restore_selection:
#ifdef LATER
	// cursor should be visible during selections
	if (FFocus(pwnd))
		{
		WORD rx = max(pwnd->ichCursorEb - pwnd->ichLeftEb, 0);
		if (pwnd->ichCursorEb != pwnd->ichSelEb)
			HiliteEditSel(pwnd, TRUE);
		EnableCursor(pwnd, TRUE);
		MoveCursor(pwnd, (RX) rx, 0);
		}
#else
	if (FFocus(pwnd))
		{
		if (pwnd->ichCursorEb != pwnd->ichSelEb)
			{
			EnableCursor(pwnd, FALSE);
			HiliteEditSel(pwnd, TRUE);
			}
		else
			{
			WORD rx = max(pwnd->ichCursorEb - pwnd->ichLeftEb, 0);
			EnableCursor(pwnd, TRUE);
			MoveCursor(pwnd, (RX) rx, 0);
			}
		}
#endif /*!LATER*/

	return((DWORD) fOk);
	}



PUBLIC VOID FARPUBLIC
SetEditText(pwnd, sz, fDrawWindow)
REGISTER PWND pwnd;
char *sz;
BOOL fDrawWindow;
	{
	StartPublic();
	WORD cch;

	stringcpy((char *) pwnd->szDialog, sz, pwnd->cchMaxEb + 1);

	pwnd->ichMacEb = cch = strlen((char *) pwnd->szDialog);
	pwnd->ichLeftEb = 0;
	pwnd->ichCursorEb = 0;
	pwnd->ichSelEb = cch;
	if (fDrawWindow)
		DrawWindow(pwnd);
	StopPublic();
	}

PUBLIC VOID FARPUBLIC
SetEditWidth(pwnd, cch)
REGISTER PWND pwnd;
WORD cch;
	{
	StartPublic();

	pwnd->cchMaxEb = (cch >= 0) ? cch : pwnd->cchDialog;

	StopPublic();
	}

PUBLIC WORD FARPUBLIC
GetEditText(pwnd, sz, cchMac)
REGISTER PWND pwnd;
char *sz;
REGISTER WORD cchMac;
	{
	StartPublic();
	char *szDlg = (char *) pwnd->szDialog;

	if (cchMac > pwnd->ichMacEb + 1)	/* +1 for terminator */
		cchMac = pwnd->ichMacEb + 1;
	stringcpy(sz, szDlg, cchMac);

	StopPublic();
	return(cchMac);
	}



PUBLIC DWORD FARPUBLIC
EditWndProc(pwnd, message, wParam, lParam)
/*
  -- for edit windows
*/
PWND pwnd;
WORD wParam, message;
DWORD lParam;
	{
	StartPublic();

	DWORD lRet = InternalEditWndProc(pwnd, message, wParam, lParam);

	ReturnPublic(lRet, DWORD);
	}

#endif /* EDIT_FULLMGR */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\sedit.h ===
/*
	COW : Character Oriented Windows

	sedit.h : single line edit header
	-- single line edit intimately tied with SDM
*/

/*****************************************************************************/
/* extra word usage (filled by SDM) */

#define	isaEb		rgwExtra[cwExtraText+0]
				/* color */
#define	isaSelEb	rgwExtra[cwExtraText+1]
				/* selected color */
#define chFillDialog	rgwExtra[cwExtraText+2]
				/* fill char for trailing spaces */
#define ichMacEb	rgwExtra[cwExtraText+3]
				/* last character in edit buffer */
#define ichLeftEb	rgwExtra[cwExtraText+4]
				/* leftmost character displayed */
#define ichCursorEb	rgwExtra[cwExtraText+5]
				/* current cursor position, to the left of
				    insertion point */
#define ichSelEb	rgwExtra[cwExtraText+6]
				/* start of selection */
#define	fNoBracketEb	rgwExtra[cwExtraText+7]
				/* don't show brackets ?? */
#define wEb		rgwExtra[cwExtraText+8]
				/* random flags */
#define cchMaxEb	rgwExtra[cwExtraText+9]
				/* for fixed length edit items */

/* option for retaining selection : same as no brackets !!! */
#define	fRetainSelEb	fNoBracketEb

#if cwExtraEdit != cwExtraText+10
.....
#endif

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\static.c ===
/*
	COW : Character Oriented Windows

	static.c : WndProc for static text items
*/

#define COW
#include <cow.h>

#include <uwindow.h>
#include <uevent.h>
#include <uisa.h>

#include "dialog.h"
#include "util.h"

#include "static.h"


PRIVATE DWORD FARPUBLIC			/* WndProcs are PUBLIC */
StaticWndProc(pwnd, message, wParam, lParam)
/*
  -- WndProc for static text items
*/
REGISTER PWND pwnd;
WORD message, wParam;
DWORD lParam;
	{
	RX rx;
	char *sz = (char *) pwnd->szDialog;
	BYTE cch;
	RRC rrc;
	REGISTER WORD di;

	Unreferenced(wParam);
	Unreferenced(lParam);

	Assert((pwnd->style & WS_TYPE) == WS_STATIC ||
	    (pwnd->style & WS_TYPE) == WS_STATIC_NOACCEL);

	switch(message)
		{
	default:
		break;

	case WM_WANTFOCUS:
		return((DWORD) FALSE);  /* refuse to accept the focus */
		break;

#ifdef DEBUG
	case WM_SETFOCUS:
	case WM_KILLFOCUS:
		Assert(FALSE);
		/*break;*/
#endif
		
	case WM_PAINT:
		di = pwnd->fEnabled ? isaStatic : isaDisabled;

		DrawBorder(pwnd, NULL, di, NULL);
		GetClientRrc(pwnd, &rrc);
		FillRrc(pwnd, &rrc, ' ', di);
		cch = (BYTE) CchRealLenSz(sz);
		switch(pwnd->style & WS_SUBSTYLE)
			{
		default:
			Assert(FALSE);
			break;

		case SS_LEFT:
			rx = 0;
			break;

		case SS_RIGHT:
			rx = rrc.rxRight - min(cch, rrc.rxRight);
			break;

		case SS_CENTER:
			rx = (rrc.rxRight - min(cch, rrc.rxRight)) / 2;
			break;
			}
		TextOut(pwnd, rx, 0, sz, cch, di);
		if (fShowDlgAccel &&
		    pwnd->aclDialog != aclNil &&
		    pwnd->fEnabled)
			{
			CharOut(pwnd, rx + IchAccel(pwnd), 0,
			    ChAccel(pwnd), isaDialogAccel);
			}
		break;
		}
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\strings.h ===
/*
	COW : Character Oriented Windows

	strings.h : string pool (+special message-box stuff)

	-- use these variables if string is duplicated, otherwise use the
		explicit #defines as found in <itl.h>
*/

/* PRIVATE */
extern char szEmptyString[];

extern char szOkString[];
extern char szCancelString[];

extern char szYesString[];
extern char szNoString[];
extern char szRetryString[];
extern char szAbortString[];
#ifdef HELP_BUTTON
extern char szHelpString[];
#endif


/* international info for message box */

typedef struct _mbbi 
	{
	BYTE	cch;		/* Size of the string */
	BYTE	drx;		/* Size of the window */
	BYTE	chAccel;	/* The accelerator to user */
	} MBB;

extern BYTE mpmbcchButton[];
extern MBB rgmbb[];
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\strings.c ===
/*
	COW : Character Oriented Windows

	strings.c : common string pool (multiused strings)

	(compiles with minimal headers)
	NOTE : the types of data in this file must track strings.h
*/

#ifndef COW
/* International build */
/* define language in compile flags
#else	/* normal build */
#include <version.h>
#endif

#include <itl.h>

char	szEmptyString[]		=	"";
char	szOkString[]		=	szOk;
char	szCancelString[]	=	szCancel;
char 	szYesString[]		=	szYes;
char	szNoString[]		=	szNo;
char	szRetryString[]		=	szRetry;
char	szAbortString[]		=	szAbort;
#ifdef HELP_BUTTON
char	szHelpString[]		=	szHelp;
#endif

/* Array of bytes containing info (see MBB structure for details) */
/* 3 bytes per option */
char pascal rgmbb[] =
	{
	0,				0,		0,
	sizeof(szOkString)-1,		cchOk+2,	'\0',
	sizeof(szCancelString)-1,	cchCancel+2,	'\0',
	sizeof(szNoString)-1,		cchNo+2,	chAccelNo,
	sizeof(szYesString)-1,		cchYes+2,	chAccelYes,
	sizeof(szRetryString)-1,	cchRetry+2,	chAccelRetry,
	sizeof(szAbortString)-1,	cchAbort+2,	chAccelAbort
#ifdef HELP_BUTTON
	, sizeof(szHelpString)-1,	  cchHelp+2,	  chAccelHelp
#endif
	};

char pascal mpmbcchButton[] =
	{
#ifdef HELP_BUTTON
#ifdef BUTTON_CENTER
	(cchOk+2) + 3 + (cchHelp+2),
	(cchYes+2) + 3 + (cchNo+2) + 3 + (cchCancel+2) + 3 + (cchHelp+2),
	(cchRetry+2) + 3 + (cchCancel+2) + 3 + (cchHelp+2),
	(cchOk+2) + 3 + (cchCancel+2) + 3 + (cchHelp+2),
	(cchAbort+2) + 3 + (cchHelp+2),
	(cchYes+2) + 3 + (cchNo+2) + 3 + (cchHelp+2),
	(cchRetry+2) + 3 + (cchHelp+2)
#else
	(cchOk+2) + 2 + (cchHelp+2) + 2,
	(cchYes+2) + 2 + (cchNo+2) + 2 + (cchCancel+2) + 2 + (cchHelp+2) + 2,
	(cchRetry+2) + 2 + (cchCancel+2) + 2 + (cchHelp+2) + 2,
	(cchOk+2) + 2 + (cchCancel+2) + 2 + (cchHelp+2) + 2,
	(cchAbort+2) + 2 + (cchHelp+2) + 2,
	(cchYes+2) + 2 + (cchNo+2) + 2 + (cchHelp+2) + 2,
	(cchRetry+2) + 2 + (cchHelp+2) + 2
#endif /*BUTTON_CENTER*/
#else /*HELP_BUTTON*/
#ifdef BUTTON_CENTER
	(cchOk+2),
	(cchYes+2) + 3 + (cchNo+2) + 3 + (cchCancel+2),
	(cchRetry+2) + 3 + (cchCancel+2),
	(cchOk+2) + 3 + (cchCancel+2),
	(cchAbort+2),
	(cchYes+2) + 3 + (cchNo+2),
	(cchRetry+2)
#else
	(cchOk+2) + 2,
	(cchYes+2) + 2 + (cchNo+2) + 2 + (cchCancel+2) + 2,
	(cchRetry+2) + 2 + (cchCancel+2) + 2,
	(cchOk+2) + 2 + (cchCancel+2) + 2,
	(cchAbort+2) + 2,
	(cchYes+2) + 2 + (cchNo+2) + 2,
	(cchRetry+2) + 2
#endif /*BUTTON_CENTER*/
#endif /*HELP_BUTTON*/
	};
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\shadow.h ===
/*
	COW : Character Oriented Windows

	shadow.h : shadow specifics
*/

#define	diShadowInit		(dmAttrOnly | isaShadow)

#ifdef WINDOW_OVERLAP
#define	daxShadowInit		2
#define	dayShadowInit		1

extern AX daxShadow;
extern AY dayShadow;
#else
#define	daxShadow		2
#define	dayShadow		1
#endif /*WINDOW_OVERLAP*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\trapstub.c ===
/*
	COW : Character Oriented Windows

	trapstub.c : stub for mouse trap

	(included for development hook)
	(this module should not be included in any final versions)
*/

#define COW
#include <cow.h>

#include <udialog.h>

#ifdef DEBUG

BOOL FARPUBLIC
FTrapMouseRbutton()
	{
	return FALSE;		/* ignore */
	}

#endif /*DEBUG*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\static.h ===
/*
	COW : Character Oriented Windows

	static.h : static cow private interface
*/

/* Static Text Styles */

#define SS_LEFT 		0	/* left justified text */
#define SS_CENTER 		1	/* centered text */
#define SS_RIGHT 		2	/* right justified text */


DWORD	FARPUBLIC	StaticWndProc(PWND, WORD, WORD, DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\util.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	util.asm : user utilities (DOS 3 & 5)

	title	util - low level utilities for COW USER

.xlist
	include	user.inc
.list
	include insyd.inc


sBegin	DATA

externB <inyj>				;* SYD jump vector

sEnd	DATA


sBegin USER_CORE
    assumes CS,USER_CORE
    assumes DS,DATA
    assumes SS,DATA



;********** BltBackwards **********
;*	entry : DS:SI => source, ES:DI => dest, CX = size
;*	* blt backwards

cProc	BltBackwards, <NEAR, ATOMIC>
cBegin	BltBackwards

	mov	ax,cx
	sub	ax,2			;* end less 1 word
	add	si,ax
	add	di,ax			;* past end of each + 1 word

	std
	shr	cx,1			;* save lower bit in CY flag
	rep	movsw			;* move words
	cld				;* restore D
	jnc	end_blt_back		;* all done
	inc	si
	inc	di
	movsb				;* and last byte
end_blt_back:

cEnd	BltBackwards



; bltbyte
; pchSource: source string
; pchDest: destination string
; cb: number of bytes to copy
; copies both backwards and forwards
; returns pointer to end of destination string.

cPrivate bltbyte,<ATOMIC>,<SI, DI>
    parmDP  pchSource
    parmDP  pchDest
    parmW   cb
cBegin	bltbyte

	mov	ax,ds
	mov	es,ax
	mov	cx,cb
	mov	si,pchSource
	mov	di,pchDest

	cmp	si,di
	jb	blt_backwards	; source less than destination

	shr	cx,1			;* save lower bit in CY flag
	rep	movsw			;* move words
	rcl	cx,1			;* restore last bit
	rep	movsb			;* optional 1 byte clean up

blt_end:
	mov	ax,pchDest
	add	ax,cb

cEnd	bltbyte

blt_backwards:
	cCall	BltBackwards
	jmp	short blt_end



;***
;
;  bltbytex(lpSrc, lpDst, cb)
;
;  Move cb bytes from Src to Dst
;
;  Inputs:
;		far pointer source.
;		far pointer destination.
;		unsigned integer for number of bytes to move.
;
;  Outputs:	none.
;
;****

cPrivate bltbytex,<ATOMIC>,<SI, DI>
    parmD lpSrc
    parmD lpDst
    parmW cb
cBegin	bltbytex

	push	ds			;* Cmacros BUG
	lds	si,lpSrc
	les	di,lpDst
	mov	cx,cb

	mov	ax,es
	mov	bx,ds
	cmp	ax,bx
	jne	bltx_forward		;* different segments => no overlap

	cmp	si,di
	jb	bltx_backwards	; source less than destination

bltx_forward:
	shr	cx,1			;* save lower bit in CY flag
	rep	movsw			;* move words
	rcl	cx,1			;* restore last bit
	rep	movsb			;* optional 1 byte clean up

bltx_end:
	pop	ds

cEnd	bltbytex

bltx_backwards:
	cCall	BltBackwards
	jmp	short bltx_end


;********** stringcpy **********
;*	entry : szDest = destination buffer (cchMac + 1 bytes long)
;*		szSource = source string
;*		cchMac = max # of characters to copy
;*	* Copy at most "cchMac" characters, always zero terminate destination
;*	exit : n/a

cPrivate stringcpy,<ATOMIC>,<SI,DI>
    parmDP  szDest
    parmDP  szSource
    parmW   cchMac

cBegin	stringcpy

	mov	ax,ds
	mov	es,ax
	mov	si,szSource
	mov	di,szDest
	mov	cx,cchMac
	jcxz	stuff_zero

ncopy_loop:
	lodsb
	stosb
	or	al,al
	jz	end_ncopy
	loop	ncopy_loop
	dec	di		;* back to last character copied
stuff_zero:
	xor	al,al		;* must be room for 1 more
	stosb
end_ncopy:

cEnd	stringcpy



;***
;
;  fstrcpy( fpDst, fpSrc )
;
;  Move null terminated string from Src to Dst
;
;  Inputs:
;		far pointer destination.
;		far pointer source.
;
;  Outputs:	none.
;
;****

cPrivate fstrcpy,<ATOMIC>,<SI, DI>
    parmD fpDst
    parmD fpSrc
cBegin	fstrcpy

	push	ds			;* Cmacros BUG
	les	di,fpDst
	lds	si,fpSrc
fstrcpy1:
	lodsb
	stosb
	or	al,al
	jnz	fstrcpy1
	pop	ds

cEnd	fstrcpy

;***
;
;  fstrcmp( string1, string2 )
;
;  Compare two null terminated strings
;
;  Inputs:
;		far pointer string1.
;		far pointer string2.
;
;  Outputs:	ax < 0 if string1 < string2
;				ax = 0 if string1 = string2
;				ax > 0 if string1 > string2
;
;****

cPrivate fstrcmp,<ATOMIC>,<SI, DI>
    parmD string1
    parmD string2
cBegin	fstrcmp

	push	ds			;* Cmacros BUG
	les	di,fpDst
	lds	si,string1
	les	di,string2

; Find the length of string2 (to limit the cmpsb)
	mov	bx,di
	xor	ax,ax
	mov	cx,0ffffH
	repne scasb
	inc	cx
	neg	cx
	mov	di,bx

; Compare the strings.
	repe cmpsb
	xor	cx,cx
	mov	al,[si-1]
	cmp	al,es:[di-1]
	je	equal
	jb	below
above:
	dec	cx		; cx <-- FFFF
	dec	cx		; cx <-- FFFE
below:
	not	cx		; if cx == 0000 then cx <-- FFFF (-1)
				; if cx == FFFE then cx <-- 0001
equal:
	mov	ax, cx
	pop	ds

cEnd	fstrcmp



;***
;
;  fstrlen( string1 )
;
;  return length of string
;
;  Inputs:
;		far pointer string1.
;
;  Outputs:	ax - length of string.
;
;****

cPrivate fstrlen,<ATOMIC>,<DI>
    parmD string1
cBegin	fstrlen

	les	di,string1
	xor	ax,ax
	mov	cx,0ffffH
	repne scasb
	mov	ax,cx
	inc	ax
	not	ax

cEnd	fstrlen


sEnd	USER_CORE

;*****************************************************************************

sBegin	USER_SCROLL
    assumes CS,USER_SCROLL
    assumes DS,DATA
    assumes SS,DATA

; Translates a point in the first range range to a point in the second range.
; Rounds up or down.
;* see listbox.c for usage

cProc	TranslatePosition,<NEAR,PUBLIC,ATOMIC>
    parmW wRange1Position
    parmW wRange1Min		
    parmW wRange1Max
    parmW wRange2Min
    parmW wRange2Max
    parmW fRoundUp
cBegin	TranslatePosition

	mov	ax,wRange1Position
	sub	ax,wRange1Min
	mov	bx,wRange2Max
	sub	bx,wRange2Min
	mul	bx
	cmp	fRoundUp,0
	jz	noroundup
	mov	bx,wRange1Max
	sub	bx,wRange1Min
	dec	bx
	add	ax,bx
	adc	dx,0

noroundup:
	mov	cx,wRange1Max
	sub	cx,wRange1Min
	jcxz	dont_divide		;* don't really divide (/1)
	div	cx
dont_divide:
	add	ax,wRange2Min

cEnd	TranslatePosition

sEnd	USER_SCROLL

;*****************************************************************************
;* Installable SYD driver routines

sBegin USER_CORE
    assumes CS,USER_CORE
    assumes DS,DATA
    assumes SS,DATA

;********** DoSound **********
;*	entry : req = sound request
;*		0 => beep
;*		1 => click
;*	* Beep
;*	exit : n/a

labelFP	<PUBLIC, DoSound>
	jmp	inyj.lpfnDoSoundSydInyj



;********** ClockTicks **********
;*	entry : n/a
;*	* Get the clock time
;*	exit : DX:AX = long time (signed) (1/18th of a second increments)
;*	!! DO NOT PROFILE : called by interrupt handlers !!!

labelFP	<PUBLIC, ClockTicks>
	jmp	inyj.lpfnLGetTimeSydInyj

sEnd	USER_CORE

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\util.h ===
/*
	COW : Character Oriented Windows

	util.h : utilities, cow private interface
		Cmerge definitions from util.asm + sdmasm.asm
*/


#ifdef DUAL
#define	NEARorFAR	FAR
#else /*!DUAL*/
#define	NEARorFAR	NEAR
#endif /*!DUAL*/

/* BLTS : both : source, destination, count_of_bytes */
VOID *	FARPRIVATE	bltbyte(VOID *, VOID *, WORD);
VOID	FARPRIVATE	bltbytex(VOID far *, VOID far *, WORD);

VOID	FARPRIVATE	stringcpy(char *, char *, WORD);
WORD	FARPRIVATE	fstrlen(char far *);
short	FARPRIVATE	fstrcmp(char far *, char far *);
VOID	FARPRIVATE	fstrcpy(char far *, char far *);
#define strlen(sz) fstrlen((char far *) (sz))
#define strcpy(sz1, sz2) fstrcpy((char far *) (sz1), (char far *) (sz2))

#ifdef EXTRAS
int	FARPRIVATE	CchRealLenSz(char *);
#else
/* no special character => a character is a character */
#define	CchRealLenSz(sz)	strlen(sz)
#endif

#define strlen(sz) fstrlen((char far *) (sz))

/*	* NEAR helper procedures */

/* CORE segment */
VOID	NEARorFAR PASCAL	DisableInterrupts(void);
VOID	NEARorFAR PASCAL	EnableInterrupts(void);

#ifdef DIRLIST	/* in LISTBOX segment */
BOOL	NEARorFAR PASCAL	FFindNext(struct _fde *);
BOOL	NEARorFAR PASCAL	FFindFirst(struct _fde *, char *, WORD);
VOID	NEARorFAR PASCAL	FindClose(void);
WORD	NEARorFAR PASCAL	AtrOfPath(char *);
char	NEARorFAR PASCAL	GetCurDrive(void);
VOID	NEARorFAR PASCAL	SetCurDrive(char);
VOID	NEARorFAR PASCAL	GetCurDir(char, char *);
BOOL	NEARorFAR PASCAL	FSetCurDir(char *);

#ifndef DOS5	/* fast fill for DOS 3 */
VOID	NEARorFAR PASCAL	PrepareWild(struct _fcb *, char *);
BOOL	NEARorFAR PASCAL	FMatchWild(struct _fcb *, char *);
BOOL	NEARorFAR PASCAL	FValidDir(char *);
#endif /*!DOS5*/

#endif /*DIRLIST*/

#ifdef SCROLL
WORD	NEAR PASCAL	TranslatePosition(WORD, WORD, WORD, WORD, WORD, BOOL);
#endif

#ifdef SDM
VOID	NEAR PASCAL	FillBuf(char *, char, WORD);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\util.inc ===
;
;	COW : Character Oriented Windows
;
;	util.inc : utilities, cow private interface
;
;

;*	* Find First/Next info (must jive with dirlist.h)

FDE	STRUC
	dtaFde		DB	21 DUP (?)	;* 21 bytes filler
	atrFde		DB	?
	wTimeFde	DW	?
	wDateFde	DW	?
	cbFileFde	DD	?
	szNameFde	DB	13 DUP (?)	;* file name
FDE	ENDS

; BLTS : both : source, destination, count_of_bytes
externFPrivate bltbyte
externFPrivate bltbytex

externFPrivate stringcpy
externFPrivate fstrlen
externFPrivate fstrcmp
externFPrivate fstrcpy

; NEAR helper procedures

; CORE segment
externNP DisableInterrupts
externNP EnableInterrupts

ifdef DIRLIST  ; in LISTBOX segment
externNP FFindNext
externNP FFindFirst
externNP FindClose
externNP AtrOfPath
externNP GetCurDrive
externNP SetCurDrive
externNP GetCurDir
externNP SetCurDir

ifndef DOS5    ; fast fill for DOS 3
externNP PrepareWild
externNP FMatchWild
endif ; !DOS5

endif ; DIRLIST

ifdef SCROLL
externNP TranslatePosition
endif

ifdef SDM
externNP FillBuf
endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\user.inc ===
;*
;*	COW : Character Oriented Windows
;*
;*	user.inc : user assembly segments

.xlist
	include cow.inc
.list

IFDEF COW_SWAPPED

createSeg   INIT,INIT,BYTE,PUBLIC,CODE			;* init code
createSeg   EXIT,EXIT,BYTE,PUBLIC,CODE			;* exit code
createSeg   CORE,USER_CORE,BYTE,PUBLIC,CODE		;* user fixed code

createSeg   CORE,SCREEN,BYTE,PUBLIC,CODE		;* screen code

IFDEF COW_TINY_SWAPPED
;* mostly everything in USER
createSeg   USER,USER_SCROLL,BYTE,PUBLIC,CODE		;* scroll helpers
createSeg   USER,USER_DIALOG,BYTE,PUBLIC,CODE		;* dialog helpers
createSeg   USER,USER_LISTBOX,BYTE,PUBLIC,CODE		;* listbox helpers
createSeg   USER,USER_EDIT,BYTE,PUBLIC,CODE		;* edit helpers
createSeg   USER,SDM,BYTE,PUBLIC,CODE			;* sdm helpers
ELSE
;* mostly everything in CORE
createSeg   CORE,USER_SCROLL,BYTE,PUBLIC,CODE		;* scroll helpers
createSeg   CORE,USER_DIALOG,BYTE,PUBLIC,CODE		;* dialog helpers
createSeg   CORE,USER_LISTBOX,BYTE,PUBLIC,CODE		;* listbox helpers
createSeg   CORE,USER_EDIT,BYTE,PUBLIC,CODE		;* edit helpers
createSeg   CORE,SDM,BYTE,PUBLIC,CODE			;* sdm helpers
ENDIF ;COW_TINY_SWAPPED


ELSE
;* not swapped => all 1 segment

createSeg   COW_TEXT,INIT,BYTE,PUBLIC,CODE
createSeg   COW_TEXT,EXIT,BYTE,PUBLIC,CODE
createSeg   COW_TEXT,USER_CORE,BYTE,PUBLIC,CODE
createSeg   COW_TEXT,SCREEN,BYTE,PUBLIC,CODE
createSeg   COW_TEXT,USER_SCROLL,BYTE,PUBLIC,CODE
createSeg   COW_TEXT,USER_DIALOG,BYTE,PUBLIC,CODE
createSeg   COW_TEXT,USER_LISTBOX,BYTE,PUBLIC,CODE
createSeg   COW_TEXT,USER_EDIT,BYTE,PUBLIC,CODE
createSeg   COW_TEXT,SDM,BYTE,PUBLIC,CODE
IFDEF	PROJECT_QB
createSeg   FAR_PRESERVED,FAR_PRESERVED,BYTE,PUBLIC,CODE
ENDIF	;PROJECT_QB

ENDIF ;!COW_SWAPPED
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\util3.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	util3.asm : user utilities : DOS 3 specifics : included by util.asm

.xlist
	include	user.inc
.list
	include insyd.inc
	include util3.inc


sBegin	DATA

externB	drivePhantom			; set to 2 on single floppy systems.
externW	chDrivePhantom			; set to "b:" on one floppy systems.

staticD	lpdtaOldFde,0		; Hold the pointer to the old DTA.

;* from kernel init
externB fInt24Error				;* checked for all file i/o

sEnd	DATA


sBegin USER_CORE
    assumes CS,USER_CORE
    assumes DS,DATA
    assumes SS,DATA
    assumes ES,nothing


;********** DisableInterrupts **********
;*	* CLI for Cmerge code

cProcNorF	DisableInterrupts,<>
cBegin
	CLI
cEnd


;********** EnableInterrupts **********
;*	* STI for Cmerge code

cProcNorF	EnableInterrupts,<>
cBegin
	STI
cEnd

sEnd	USER_CORE

;*****************************************************************************

;*	* Directory listbox helpers

sBegin	USER_LISTBOX
    assumes CS,USER_LISTBOX
    assumes DS,DATA
    assumes SS,DATA
    assumes ES,nothing



;********** FDoFile **********
;*	entry : all registers set for INT 21H call
;*	* call INT 21, check for INT 24 errors
;*	exit : AX != 0 if ok, AX == 0 if error
;*		all other registers set from INT 21H call

cProcNorF	FDoFile,<>
cBegin	FDoFile
	mov	fInt24Error,0
	int	21h
	mov	ax,0			;* assume error
	jc	dofile_end
	cmp	fInt24Error,al
	jne	dofile_end		;* an INT 24 error
	inc	ax			;* success
dofile_end:

cEnd	FDoFile



;********** FFindFirst **********
;*	entry : pfde = pointer to FDE to fill
;*		szPath = path to search for
;*		atr = file attribute to search for
;*	* Find first occurance of a file spec with given attributes for search.
;*	exit : AX = TRUE if file found, FALSE otherwise

cProcNorF	FFindFirst,<>
    parmDP pfde
    parmDP szPath
    parmW  atr
cBegin	FFindFirst

	StartPublic

	mov	ah,2fh		;* get old Dta
	int	21h

	mov	wo lpdtaOldFde,bx
	mov	wo lpdtaOldFde+2,es	;* save old Dta
	
	mov	dx,pfde
	mov	ah,1ah		; set dta
	int	21h

	mov	dx,szPath

	mov	bx,dx
	mov	ax,[bx]			; Get first two letters
	or	al,20h			; If the file is "B:xxx" on a single
	cmp	ax,chDrivePhantom	;   floppy system, then no can do.
	mov	ax,0
	je	@F

	mov	ah,4eh		;Search for first occurance.
	mov	cx,atr

	cCall	FDoFile
@@:

	StopPublic

cEnd	FFindFirst



;********** FFindNext **********
;*	entry : pfde (not used) (uses info set by previous FFindFirst)
;*	* Find next occurance.
;*	exit : AX = TRUE if file found, FALSE otherwise
;*	* NOTE : assumes DTA already set

cProcNorF	FFindNext,<>
   parmDP pfde			;* not used (assuming DTA already set)
cBegin	FFindNext

	StartPublic

	mov	ah,4fh		;Find next occurance of file string.
	cCall	FDoFile

	StopPublic

cEnd	FFindNext


;********** FindClose **********
;*	entry : none.
;*	* Close find (restore old DTA)
;*	exit : n/a

cProcNorF	FindClose,<DS>
cBegin	FindClose

	StartPublic

	lds	dx,lpdtaOldFde		;* get old dta
	mov	ah,1ah			;* set dta
	int	21h

	StopPublic

cEnd	FindClose



;********** AtrOfPath **********
;*	entry : sz = path (file / directory or other)
;*	* get the status of the file/path
;*	exit : ax = ATR = attribute

cProcNorF	AtrOfPath,<DS>
   parmDP szPath
cBegin	AtrOfPath

	mov	dx,szPath

	mov	bx,dx
	mov	ax,[bx]			; Get first two letters
	or	al,20h			; If the file is "B:xxx" on a single
	cmp	ax,chDrivePhantom	;   floppy system, then no can do.
	mov	ax,-1
	je	atr_error

	mov	ax,4300h		;* CHMOD (get old status)
	cCall	FDoFile
	or	ax,ax
	mov	ax,-1
	jz	atr_error		;* error
	mov	ax,cx			;* return attribute
atr_error:

cEnd	AtrOfPath



IFNDEF REMOVE_LATER

;********** GetCurDrive **********
;*	entry : n/a
;*	* get the current drive letter
;*	exit : AL = current drive letter 'A' ...

cProcNorF	GetCurDrive,<>
cBegin	GetCurDrive

	StartPublic

	mov	ah,19h
	int	21h
	add	al,'A'			; (0..25) -> (A..Z)

	StopPublic

cEnd	GetCurDrive


;********** SetCurDrive **********
;*	entry : chDrive = drive letter
;*	* set the current drive letter
;*	exit : rets AL = number of logical drives (used for True = nonzero)
;*	       This is used by FSetCurDir,
;*	       Note that the OS/2 version of this doesn't return anything.

cProcNorF	SetCurDrive,<>
    parmB chDrive
cBegin	SetCurDrive

	StartPublic

	mov	dl,chDrive
	and	dl,not 20H			; convert lower case to upper
	sub	dl,'A'				; A->0, B->1, etc.
	AssertCmp	dl,be,25		; Legit range = (0..25).
	mov	ah,0eH

	mov	al,drivePhantom		; Note! This stupid Dos call has 
	dec	al			;   0=A, 1=B unlike all others.
	cmp	dl,al			; Don't set B to current drive with
	je	@F			;   single floppy (still ret AX!=0)

	int	21h
@@:
	StopPublic

cEnd	SetCurDrive



;********** GetCurDir **********
;*	entry : chDrive = drive letter
;*		szBuff = string buffer for directory <=64 bytes
;*	* get the current default directory
;*	* asserts if you give it a bogus drive letter.
;*	exit : n/a

    assumes CS,USER_LISTBOX
    assumes DS,DATA
    assumes SS,DATA
    assumes ES,nothing

cProcNorF	GetCurDir,<si,di>
    parmB chDrive
    parmDP szBuff
cBegin	GetCurDir

	StartPublic

	AssertUP

	mov	si,szBuff		; Get pointer to target area.
	mov	al,chDrive
	and	ax,LOW (not 20H)	; convert lower case to upper case.

	AssertCmp	al,ae,'A'	; Bust out if we're not in the 
	AssertCmp	al,be,'Z'	;   (A..Z) range.

	mov	[si],al
	mov	word ptr [si+1], '\:'	; C:\
	lea	si,[si+3]

	mov	byte ptr [si],ah	; zero terminate in case of error.
	sub	al,'A' - 1		; 0:Current drive, 1:A, 2:B, ...

	cmp	al,drivePhantom		; CurDir of B w/single floppy system
	je	@F			;   is "B:\".

	mov	dl,al
	mov	ah,47h
	int	21h
@@:
	StopPublic

cEnd	GetCurDir



;********** FSetCurDir **********
;*	entry : szDir : directory
;*	* set the default directory
;*	exit : AX = TRUE if ok, FALSE if bogus drive and/or directory

    assumes CS,USER_LISTBOX
    assumes DS,DATA
    assumes SS,DATA
    assumes ES,nothing

cProcNorF	FSetCurDir,<si>
parmDP	szDir
localW	OrigDrive
cBegin	FSetCurDir

; Get the current drive, and save it away
;
; If the second char is a colon, then
;   If !FValidDrive(szDir[0]) then return FALSE
;   SetCurDrive(szDir[0])
;   If szDir[2] = NULL, then it's just drive & no directory: ret TRUE
;
; Do the DOS call to Set Current Dir.
;   if no error, return TRUE
;   else call SetCurDrive(saved original current drive), and ret FALSE

	StartPublic

	call	GetCurDrive
	mov	OrigDrive,ax

	mov	si,szDir
	cmp	byte ptr [si+1], ':'
	jne	noDriveSpec

	push	[si]			; If the requested drive is bogus,
	call	far ptr FValidDrive	;   then return False.
	or	ax,ax
	jz	end_set_dir

	push	[si]			; Set the drive to the request.
	call	SetCurDrive		; Rets al = # drives, so AX = True.
	AssertNE	ax,0		; Prove it.

	cmp	byte ptr [si+2],0	; If setting drive, but not setting
	je	end_set_dir		; directory, then quit now & ret True

noDriveSpec:
	mov	dx,szDir
	mov	ah,3Bh
	int	21h
	mov	ax,sp			; Guess no error
	jnc	end_set_dir		; If no error, jump and return True.

	push	OrigDrive		; Error in setting directory!
	call	SetCurDrive		; Reset drive to original, and
	xor	ax,ax			;   return False.
end_set_dir:

	StopPublic

cEnd	FSetCurDir


ENDIF ;!REMOVE_LATER


;----------------------------------------------------------------------------
;
; FValidDrive
;
;   Check for phantom drives and non-existant drives.  Note: for single
;   floppy systems, either 'A' or 'B' will not exist.
;
;   input  : chDrive = drive to see if exists
;   output : AX = TRUE if ok, FALSE if bogus drive
;

cPublic	FValidDrive, <ATOMIC>
    parmB chDrive				; 'A'...'Z' (case insensitive)
cBegin	FValidDrive

	StartPublic

	xor	ax,ax				; Guess invalid.
	mov	dl,chDrive
	or	dl,20h				; tolower
	cmp	dl,by chDrivePhantom
	je	phantom

; Test for existance by setting then checking if set.

	mov	ah,19h
	int	21h
	push	ax				; Save old drive

	sub	dl,'a'				; 'A' -> 0, etc.
	mov	ah,0eH
	int	21h				; Set query drive.
	mov	ah,19h
	int	21h				; And get current drive.
	xor	cx,cx
	cmp	al,dl				; Are they the same ?
	jnz	@F
	inc	cx				; They're diffo.
@@:
	pop	dx
	mov	ah,0eH				; Restore original
	int	21h				;   current drive.

	mov	ax,cx

phantom:

	StopPublic

cEnd	FValidDrive


;********** PrepareWild **********
;*	entry : pfcb => FCB structure to fill.
;*		szFile => file name to parse
;*	* parse path name, fill FCB with wild find info
;*	exit : *pfcb filled with FCB info for FMatchWild calls

cProcNorF	PrepareWild,<SI,DI>
    parmDP pfcb
    parmDP szFile
cBegin	PrepareWild

	mov	si,szFile
	mov	di,pfcb
	push	ds
	pop	es				;* es:di => FCB
	mov	ax,2900H			;* Parse filename
						;* (no special processing).
	int	21h
;*	* no error codes make sense

cEnd	PrepareWild



;********** TestWildPart **********
;*	entry : SI => source (ending in '.' or '\0').
;*		DI => fcb image
;*		CX = # of characters in fcb image
;*	* scan for part of wildcard match
;*	* NOTE : may pop return address !!!
;*	exit : if match so far, return AL = '.' or '\0' terminator
;*		SI => after terminator
;*	  if no match, pop return address, jump to "fmatch_fail"

cProcNorF	TestWildPart,<>
cBegin	nogen	;TestWildPart

test_filename_loop:
	lodsb
	or	al,al
	jz	finish_test_wild
	cmp	al,'.'
	je	finish_test_wild
	mov	ah,ds:[di]			;* get match character
	inc	di
	cmp	ah,'?'
	je	match_this_one
	cmp	ah,al
	je	match_this_one
;*	* comparison failed
match_one_failed:
	pop	ax				;* kill return address
	jmp	short fmatch_fail			;* no match

match_this_one:
	AssertNE cx,0				;* must never run out
	dec	cx
	jmp	short test_filename_loop

finish_test_wild:
;*	* if CX != 0, then remaining FCB characters must be ' ' or '?'
	jcxz	end_test_wild

test_end_loop:
	mov	ah,ds:[di]
	inc	di
	cmp	ah,'?'
	je	test_end_next
	cmp	ah,' '
	jne	match_one_failed
test_end_next:
	loop	test_end_loop
end_test_wild:	;* SI => after terminator, AL == terminator ('.' or ' ').
	ret

cEnd	nogen	;TestWildPart



;********** FMatchWild **********
;*	entry : pfcb => FCB structure (prepared with PrepareWild)
;*		szFile => file name to match (must be well formed)
;*	* check to see if file name will match wildcard
;*	exit : ax != 0 if match, ax == 0 if no match

cProcNorF	FMatchWild,<SI,DI>
    parmDP pfcb
    parmDP szFile
cBegin	FMatchWild

	mov	si,szFile
	mov	bx,pfcb
;*	* test for filename (first 0->8 characters will be filename)
	lea	di,[bx+1]			;* start with filename
	mov	cx,8
	cCall	TestWildPart

	or	al,al
	jz	no_extension

	lea	di,[bx+1+8]
	mov	cx,3
	cCall	TestWildPart

;*	* if we get here we have succeeded
fmatch_ok:
	mov	ax,sp
fmatch_end:

cEnd	FMatchWild

no_extension:	;* if there is no extension, we should match no or any extension
	mov	al,[bx+1+8]		;* 1st char of extension
	cmp	al,'?'
	je	fmatch_ok		;* match anything
	cmp	al,' '
	je	fmatch_ok		;* match no extension
fmatch_fail:
	xor	ax,ax
	jmp	short fmatch_end



;********** FValidDir **********
;*	entry :	szTestDir = path of a directory (maybe)
;*	* perform "stat" to see if a path is a directory
;*	exit : AX = TRUE if a real directory, FALSE otherwise

cProcNorF	FValidDir,<>
    parmDP szTestDir
cBegin	FValidDir

	mov	dx,szTestDir

	mov	bx,dx
	mov	ax,[bx]			; Get first two letters
	or	al,20h			; If the file is "B:xxx" on a single
	cmp	ax,chDrivePhantom	;   floppy system, then no can do.
	je	err_fvalid_dir

	mov	ax,4300H			;* read attrib
	int	21h
	jc	err_fvalid_dir
	and	ax,10H				;* AX != 0 if directory
	jnz	end_fvalid_dir
;*	* unfortunately sometimes directory stat returns non-directory flags
;*	* if it was a ".." then assume it is ok
	mov	bx,szTestDir
	cmp	word ptr [bx],'..'
	jne	err_fvalid_dir
	mov	ax,sp				;* assume success
	cmp	byte ptr [bx+2],0		;* "..\0" ?
	je	end_fvalid_dir

err_fvalid_dir:	;* an error occured
	xor	ax,ax				;* return 0
end_fvalid_dir:
cEnd	FValidDir


sEnd	USER_LISTBOX

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\util5.inc ===
;*
;*	COW : Character Oriented Windows

FDE_OS2	STRUC
	wDateCreateFdeOS2	dw	?
	wTimeCreateFdeOS2	dw	?
	wDateAccessFdeOS2	dw	?
	wTimeAccessFdeOS2	dw	?
	wDateWriteFdeOS2	dw	?
	wTimeWriteFdeOS2	dw	?
	cbFileFdeOS2		dd	?
	OFF_cbFileAllocFdeOS2	dw	?
	SEG_cbFileAllocFdeOS2	dw	?
	attrFileFdeOS2		dw	?
	cchNameFdeOS2		db	?
	szNameFdeOS2		db	13 dup (?)
FDE_OS2	ENDS

FDE	STRUC
	dtaFde		DB	21 DUP (0)	;* 21 bytes filler
	atrFde		DB	0
	wTimeWriteFde	DW	0
	wDateWriteFde	DW	0
	cbFileFde	DD	0
	szNameFde	DB	13 DUP (0)	;* file name
FDE	ENDS
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\util3.inc ===
;*
;*	COW : Character Oriented Windows
;*
;*	util3.inc : DOS 3 specific stuff
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\util5.asm ===
;*
;*	COW : Character Oriented Windows
;*
;*	util5.asm : user utilities : DOS 5 specifics : included by util.asm

.xlist
	include	user.inc
.list
	include insyd.inc
	include util5.inc


externFP	<DosEnterCritSec, DosExitCritSec>
externFP	<DosBeep>

;****************************************************************************

sBegin	DATA

staticW	hDirFde,0		; Handle used by FindFirst/FindNext/FindClose

sEnd	DATA

;****************************************************************************

sBegin USER_CORE
    assumes CS,USER_CORE
    assumes DS,DATA
    assumes SS,DATA

;********** DisableInterrupts **********
;*	* CLI for Cmerge code

cProcNorF	DisableInterrupts,<>
cBegin
	cCall	DosEnterCritSec
cEnd


;********** EnableInterrupts **********
;*	* STI for Cmerge code

cProcNorF	EnableInterrupts,<>
cBegin
	cCall	DosExitCritSec
cEnd

sEnd	USER_CORE

;*****************************************************************************


;*	* Directory listbox helpers

externFP  <DosFindFirst, DosFindNext, DosFindClose>
externFP  <DosQCurDisk, DosQCurDir>
externFP  <DosSelectDisk, DosChdir>
externFP  <DosQFileMode>


sBegin	USER_LISTBOX
    assumes CS,USER_LISTBOX
    assumes DS,DATA
    assumes SS,DATA
    assumes ES,nothing


;********** FFindFirst **********
;*	entry : pfde = address of FDE buffer for file find
;*		szPath = path to search for
;*		atr = file attribute to search for
;*	* Find first occurance of a file spec with given attributes for search.
;*	exit : AX = TRUE if file found, FALSE otherwise

cProcNorF	FFindFirst,<di,si>
    parmDP pfde
    parmDP szPath
    parmW  atr
    localW centryFirst			; Number of directory entries.
    localV FindFirstBuf,<size FDE_OS2>	; Xfer from here to passed-in buffer
cBegin	FFindFirst

	PushArg	<ss, szPath>		;* Path file name

	mov	[hDirFde],-1		;* request new directory handle
	PushArg	<ds>			;* place for
	PushArg	<offset hDirFde>	;*   directory handle

	PushArg	<atr>			;* attribute for match

	lea	ax,FindFirstBuf
	PushArg	<ss, ax>		;* result buffer
	PushArg	<size FDE_OS2>		;* size of result buffer

	lea	bx,centryFirst
	mov	wo [bx],1
	PushArg	<ss, bx>

	xor	ax,ax
	PushArg	<ax>
	PushArg	<ax>

	cCall	DosFindFirst
	or	ax,ax
	mov	ax,0			; Preserve flags!
	jnz	FF99			; Jump if none found.
	AssertEq	centryFirst,1	; Should have found exactly 1 file.

;   Transfer info from FindFirstBuf.FDE_OS2 structure to pfde.FDE struct.

	mov	ax,ss
	mov	es,ax
	assumes	es,data
	mov	bx,pfde
	lea	di,[bx.atrFde]		; Where we transfer to.

	mov	ax,FindFirstBuf.attrFileFdeOS2
	xor	ah,ah
	stosb

	mov	ax,FindFirstBuf.wTimeWriteFdeOS2
	stosw
	
	mov	ax,FindFirstBuf.wDateWriteFdeOS2
	stosw
	
	mov	ax,FindFirstBuf.OFF_cbFileAllocFdeOS2
	stosw

	mov	ax,FindFirstBuf.SEG_cbFileAllocFdeOS2
	stosw

	xor	cx,cx
	mov	cl,FindFirstBuf.cchNameFdeOS2
	lea	si,FindFirstBuf.szNameFdeOS2	; Where we transfer from.
	rep	movsb				; Transfer the filename.
	xor	ax,ax
	stosb					; Zero-terminate.

	dec	ax				; Success
FF99:

cEnd	FFindFirst


;********** FFindNext **********
;*	entry : pfde = pointer to FDE initialized by FFindFirst
;*	* Find next occurance / close directory handle if no more found
;*	exit : AX = TRUE if file found, FALSE otherwise

    assumes CS,USER_LISTBOX
    assumes DS,DATA
    assumes SS,DATA
    assumes ES,nothing

cProcNorF	FFindNext,<di,si>
    parmDP pfde
    localW centryNext			; Number of directory entries.
    localV FindNextBuf,<size FDE_OS2>	; Xfer from here to passed-in buffer
cBegin	FFindNext

	PushArg	<hDirFde>	;* directory handle
	
	lea	ax,FindNextBuf
	PushArg	<ss, ax>		;* result buffer
	PushArg	<size FDE_OS2>		;* size of result buffer

	lea	bx,centryNext
	mov	wo [bx],1
	PushArg	<ss, bx>

	cCall	DosFindNext
	or	ax,ax
	mov	ax,0			; Preserve flags!
	jnz	FN99			; Jump if none found.
	AssertEq	centryFirst,1	; Should have found exactly 1 file.

;   Transfer info from FindNextBuf.FDE_OS2 structure to pfde.FDE struct.

	mov	ax,ss
	mov	es,ax
	assumes	es,data
	mov	bx,pfde
	lea	di,[bx.atrFde]		; Where we transfer to.

	mov	ax,FindNextBuf.attrFileFdeOS2
	xor	ah,ah
	stosb

	mov	ax,FindNextBuf.wTimeWriteFdeOS2
	stosw
	
	mov	ax,FindNextBuf.wDateWriteFdeOS2
	stosw
	
	mov	ax,FindNextBuf.OFF_cbFileAllocFdeOS2
	stosw

	mov	ax,FindNextBuf.SEG_cbFileAllocFdeOS2
	stosw

	xor	cx,cx
	mov	cl,FindNextBuf.cchNameFdeOS2
	lea	si,FindNextBuf.szNameFdeOS2	; Where we transfer from.
	rep	movsb				; Transfer the filename.
	xor	ax,ax
	stosb					; Zero-terminate.

	dec	ax				; Success
FN99:

cEnd	FFindNext


;********** FindClose *********
;*	entry : none.
;*	* close directory handle
;*	exit : n/a
;*
;*  It seems that DosFindClose will return an error if you've already
;*  found all the files with DosFindNext.

    assumes CS,USER_LISTBOX
    assumes DS,DATA
    assumes SS,DATA
    assumes ES,nothing

cProcNorF	FindClose,<>
cBegin	FindClose

	push	hDirFde
	call	DosFindClose

cEnd	FindClose



;********** AtrOfPath **********
;*	entry : sz = path (file / directory or other)
;*	* get the status of the file/path
;*	exit : ax = ATR = attribute (-1 for error)

cProcNorF	AtrOfPath,<DS>
    parmDP szPath
    localW atrCur	;* where to put attrib.
cBegin	AtrOfPath

	mov	bx,szPath
	PushArg	<ss,bx>
	lea	bx,atrCur
	PushArg	<ss,bx>
	xor	ax,ax
	PushArg	<ax,ax>			;* reserved
	cCall	DosQFileMode
	or	ax,ax
	mov	ax,atrCur		;* ax = atr
	jz	atr_ok			;* return atr
	mov	ax,-1			;* return error
atr_ok:

cEnd	AtrOfPath




;********** GetCurDrive **********
;*	entry : n/a
;*	* get the current drive letter
;*	exit : AL = current drive letter 'A' ...

cProcNorF	GetCurDrive,<>
    localD rgfExists	;* not used
    localW dnCur	;* current drive # result
cBegin	GetCurDrive
	lea	bx,dnCur
	PushArg	<ss,bx>
	lea	bx,rgfExists
	PushArg	<ss,bx>
	cCall	DosQCurDisk
	AssertEq	ax,0		; Shouldn't err.
	mov	ax,dnCur
	add	al,'A'-1		; (1..26) -> (A..Z)
cEnd	GetCurDrive


;********** SetCurDrive **********
;*	entry : chDrive = drive letter
;*	* set the current drive letter
;*	exit : n/a
;*
;*   Note that it is NOT allowed to call this procedure with a bogus drive
;*   letter.  Use FValidDrive to determine legitimacy.

cProcNorF	SetCurDrive,<>
    parmB chDrive
cBegin	SetCurDrive
	mov	al,chDrive
	and	ax,LOW(NOT 20H)			; convert lower case to upper
	sub	al,'A'-1			; A->1, B->2, etc.
	AssertCmp	ax,be,26		; Legit range = 
	AssertNE	ax,0			;          (1..26).
	cCall	DosSelectDisk,<ax>
	AssertEq	ax,0			; Shouldn't err.
cEnd	SetCurDrive



;********** GetCurDir **********
;*	entry : chDrive = drive letter
;*		szBuff = string buffer for directory <=256 bytes
;*	* get the current default directory
;*	* asserts if you give it a bogus drive letter.
;*	exit : n/a

    assumes CS,USER_LISTBOX
    assumes DS,DATA
    assumes SS,DATA
    assumes ES,nothing

cProcNorF	GetCurDir,<si,di>
    parmB chDrive
    parmDP szBuff
    localW cchBuff		;* size of buffer
cBegin	GetCurDir

	AssertUP

	mov	si,szBuff		; Get pointer to target area.
	mov	al,chDrive
	and	ax,LOW (not 20H)	; convert lower case to upper case.

	AssertCmp	al,ae,'A'	; Bust out if we're not in the 
	AssertCmp	al,be,'Z'	;   (A..Z) range.

	mov	[si],al
	mov	word ptr [si+1], '\:'	; C:\
	lea	si,[si+3]

	mov	byte ptr [si],ah	; zero terminate in case of error.
	sub	al,'A' - 1		; 0:Current drive, 1:A, 2:B, ...
	lea	bx,cchBuff
	mov	word ptr ss:[bx],256	; Hard coded maximum

	cCall	DosQCurDir, <ax, ds, si, ss, bx>

cEnd	GetCurDir



;********** FSetCurDir **********
;*	entry : szDir : directory
;*	* set the default directory
;*	exit : AX = TRUE if ok, FALSE if bogus drive and/or directory

    assumes CS,USER_LISTBOX
    assumes DS,DATA
    assumes SS,DATA
    assumes ES,nothing

cProcNorF	FSetCurDir,<si>
parmDP	szDir
localW	OrigDrive
cBegin	FSetCurDir

; Get the current drive, and save it away
;
; If the second char is a colon, then
;   If !FValidDrive(szDir[0]) then return FALSE
;   SetCurDrive(szDir[0])
;   If szDir[2] = NULL, then it's just drive & no directory: ret TRUE
;
; Do the DOS call to Set Current Dir.
;   if no error, return TRUE
;   else call SetCurDrive(saved original current drive), and ret FALSE

	call	GetCurDrive
	mov	OrigDrive,ax

	mov	si,szDir
	cmp	by [si+1], ':'
	jne	noDriveSpec

	push	[si]			; If the requested drive is bogus,
	call	far ptr FValidDrive	;   then return False.
	or	ax,ax
	jz	end_set_dir

	push	[si]			; Set the drive to the request.
	call	SetCurDrive

	mov	ax,sp			; Guess the following is True.
	cmp	by [si+2],0		; If setting drive, but not setting
	je	end_set_dir		; directory, then quit now & ret True

noDriveSpec:

	cCall	DosChdir, <ds, si, 0, 0>
	or	ax,ax
	mov	ax,sp			; Guess no error
	jz	end_set_dir		; If no error, jump and return True.

	push	OrigDrive		; Error in setting directory!
	call	SetCurDrive		; Reset drive to original, and
	xor	ax,ax			;   return False.
end_set_dir:

cEnd	FSetCurDir



;********** FValidDrive **********
;*	entry : chDrive = drive to see if exists
;*	* check whether drive exists or not
;*	exit : AX = TRUE if ok, FALSE if bogus drive

cPublic	FValidDrive, <ATOMIC>
    parmB chDrive		;* 'A' -> 'Z' (case insensitive)
    localD rgfExists	;* array of bits (1 per drive)
    localW dnCur	;* current drive (not used).
cBegin	FValidDrive

	lea	bx,dnCur
	PushArg	<ss,bx>
	lea	bx,rgfExists
	PushArg	<ss,bx>
	cCall	DosQCurDisk
	or	ax,ax
	jnz	fval_drive_error

;*	* bit lookup
	mov	cl,chDrive
	and	cl,NOT 20H			;* toupper
	sub	cl,'A'				;* cl = bit index
	mov	ax,word ptr (rgfExists)		;* assume low word
	test	cl,16
	jz	use_low_word
	mov	ax,word ptr (rgfExists+2)	;* use high word
use_low_word:	;* ax = value, cx = index
	and	cl,15				;* lower 4 bits
	shr	ax,cl
	and	ax,1				;* 1 if exists
fval_drive_end:

cEnd	FValidDrive

fval_drive_error:
	xor	ax,ax
	jmp	short fval_drive_end


sEnd	USER_LISTBOX

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\_dirlist.h ===
/*
	COW : Character Oriented Windows

	_dirlist.h : dirlist call-backs for FBuildDirectoryList
*/


char * FAR PASCAL SzDirSpec(char *, char *, BOOL *);
VOID FAR PASCAL SetCurrentPath(char *);
VOID FAR PASCAL MakeDirName(char *, char *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\window.h ===
/*
    	COW : Character Oriented Windows

	window.h : Window cow private interface
*/

extern PWND PASCAL pwndRoot;

VOID	FARPRIVATE	ValidateWindow(PWND);
VOID	FARPRIVATE	UpdateCursor(void);
VOID	FARPRIVATE	DrawBoxArc(BOX *, PARC, WORD, BOOL, BOOL, char *);
BOOL	FARPRIVATE	FArcFromRrc(PWND, PRRC, PARC);

#define AssertCorrectRrc(prrc) \
	AssertSz((prrc->rxLeft < prrc->rxRight) && \
	         (prrc->ryTop < prrc->ryBottom), \
		 "Invalid Rectangle")
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\window.c ===
/*
	COW : Character Oriented Windows

	window.c  : Window Support

	This module contains the window relative output routines
        as well as routines for accessing and changing the window
        data structure.
*/

#define COW
#include <cow.h>

#define WINDOW
#include <uwindow.h>
#include <uevent.h>
#include <umenu.h>
#include <uscreen.h>
#include <uisa.h>

#include "event.h"
#include "screen.h"
#include "util.h"
#include "overlap.h"

#include "window.h"


#ifdef EXTRAS
#define	chColorPrefix	((char) 0xfe)		/* => special color prefix */
#endif

STATIC WORD	fBlockCursor = 1;		/* see SetCursorBlock() */

#ifdef WINDOW_OVERLAP
extern PWND pwndClip;
#endif /*WINDOW_OVERLAP*/

/* forward declarations for STATIC procedures */
STATIC VOID EnableWindowAndSiblings(PWND, BOOL);
STATIC VOID DrawWindowAndSiblings(PWND);
STATIC VOID TextOutColor(AX, AY, char *, WORD, WORD);
#ifdef WINDOW_OVERLAP
STATIC VOID MoveWindowAndSiblings(PWND, BYTE, BYTE);
STATIC VOID ValidateAWindow(PWND);
STATIC VOID ValidateWindowAndSiblings(PWND);
STATIC VOID ValidateWindowAndParents(PWND);
STATIC VOID MoveCursorClipped(PWND);
#endif /*WINDOW_OVERLAP*/



PUBLIC VOID FARPUBLIC
AddChild(pwndParent, pwndChild)
PWND pwndParent, pwndChild;
/* AddChild adds a child to the specified window.  If pwndParent is
   null then a child is added to the root directory.  Child is added
   to the end of the sibling chain. */
	{
	StartPublic();
	PWND pwndCur, pwndPrev;
	if (pwndParent)
		{
		if ((pwndPrev = pwndParent->pwndChild) == NULL)
			pwndParent->pwndChild = pwndChild;
		else
			{
			while ((pwndCur = pwndPrev->pwndSibling) != NULL)
				pwndPrev = pwndCur;
			pwndPrev->pwndSibling = pwndChild;
			}
		pwndChild->pwndSibling = NULL;
		EnableWindow(pwndChild, pwndParent->fEnabled);
#ifdef WINDOW_OVERLAP
		if (pwndParent->style & WS_CLIPOUT)
			{
			pwndChild->style |= WS_CLIPOUT;
			ClipoutWindowAndSiblings(pwndChild->pwndChild);
			}
#endif /*WINDOW_OVERLAP*/
		}
	else
		{
		pwndChild->pwndSibling = pwndRoot;
		pwndRoot = pwndChild;
		EnableWindow(pwndChild, TRUE);
		}
	pwndChild->pwndParent = pwndParent;
	StopPublic();
	}



PUBLIC VOID FARPUBLIC
EnableWindow(pwnd, fEnabled)
PWND pwnd;
BOOL fEnabled;
/* Enable or disable a window.  All children are enabled or disabled as well */
	{
	StartPublic();
	pwnd->fEnabled = (fEnabled != FALSE);
	EnableWindowAndSiblings(pwnd->pwndChild, fEnabled);
	StopPublic();
	}



STATIC VOID
EnableWindowAndSiblings(pwnd, fEnabled)
REGISTER PWND pwnd;
BOOL fEnabled;
	{
	while (pwnd)
		{
		pwnd->fEnabled = (fEnabled != FALSE);
		EnableWindowAndSiblings(pwnd->pwndChild, fEnabled);
		pwnd = pwnd->pwndSibling;
		}
	}



PUBLIC VOID FARPUBLIC
RemoveChild(pwndChild)
/*
  -- removes a child from its parent window
  -- special case allows removal of root windows
*/
REGISTER PWND pwndChild;
	{
	StartPublic();
	PWND pwndParent = pwndChild->pwndParent;
	REGISTER PWND pwnd;

	AssertSz(pwndChild, "RemoveChild(NULL)");

	if (pwndParent == NULL)
		{
		/* should be a root window */
		if (pwndChild == pwndRoot)
			{
			/* remove first root */
			pwndRoot = pwndChild->pwndSibling;
			}
		else
			{
			pwnd = pwndRoot;
			goto scan_sibling;
			}
		}
	else if ((pwnd = pwndParent->pwndChild) == pwndChild)
		{
		/* remove first child */
		pwndParent->pwndChild = pwndChild->pwndSibling;
		}
	else
		{
scan_sibling:
		while (pwnd->pwndSibling != pwndChild)
			{
			pwnd = pwnd->pwndSibling;
			AssertSz(pwnd != NULL, "child window not found");
			}
		pwnd->pwndSibling = pwndChild->pwndSibling;
		}
	pwndChild->pwndParent = NULL;
	pwndChild->pwndSibling = NULL;
	StopPublic();
	}



PUBLIC VOID FARPUBLIC
GetClientRrc(pwnd, prrc)
/*
  -- create a rectangle that composes the entire clent area.
  -- Note that the top left hand corner of the client rrc is
	always 0,0 since all output is relative to this point.
*/
REGISTER PWND pwnd;
REGISTER PRRC prrc;
	{
	StartPublic();
	prrc->ryTop = 0;
	prrc->rxLeft = 0;
	prrc->ryBottom = (pwnd->arcWindow.ayBottom)-(pwnd->arcWindow.ayTop);
	prrc->rxRight = (pwnd->arcWindow.axRight)-(pwnd->arcWindow.axLeft);
	if (pwnd->style & WS_BORDER)
		{
		/* border around window */
		prrc->ryBottom -= 2 * dayBorder;
		prrc->rxRight -= 2 * daxBorder;
#ifdef WINDOW_OVERLAP
		if (pwnd->style & WS_OVERLAP)
			{
			if (pwnd->style & WS_HSCROLL)
				prrc->ryBottom -= dayBorder;
			if (pwnd->style & WS_VSCROLL)
				prrc->rxRight -= daxBorder;
			}
#endif /*WINDOW_OVERLAP*/
		}
	else
		{
		if (pwnd->style & WS_HSCROLL)
			prrc->ryBottom -= dayBorder;
		if (pwnd->style & WS_VSCROLL)
			prrc->rxRight -= daxBorder;
		}
	StopPublic();
	}



PUBLIC VOID FARPUBLIC
SetWindowSize(pwnd, drx, dry)
/*
  -- changes the size of a window to be (drx, dry).
  -- Actual window and client window are adjusted appropriately
*/
REGISTER PWND pwnd;
BYTE drx, dry;
	{
	StartPublic();
	pwnd->arcWindow.axRight = pwnd->arcWindow.axLeft+drx;
	pwnd->arcWindow.ayBottom = pwnd->arcWindow.ayTop+dry;
	ValidateWindow(pwnd);
	StopPublic();
	}



PUBLIC VOID FARPUBLIC
SetWindowStyle(pwnd, style)
/*
  -- change the style of the window.
*/
PWND pwnd;
WORD style;
	{
	StartPublic();
	pwnd->style = style;
	ValidateWindow(pwnd);
	StopPublic();
	}


#ifdef WINDOW_OVERLAP

PRIVATE VOID FARPRIVATE
ValidateWindow(pwnd)
/*
  -- computes the clipping rectangle for a window and all of its children
*/
REGISTER PWND pwnd;
	{
	StartPublic();

	ValidateWindowAndParents(pwnd->pwndParent);
	ValidateAWindow(pwnd);
	ValidateWindowAndSiblings(pwnd->pwndChild);
	StopPublic();
	}

STATIC VOID
ValidateAWindow(pwnd)
/*
  -- computes the clipping rectangle for a window
*/
REGISTER PWND pwnd;
	{
	RRC	rrc;


	GetClientRrc(pwnd,&rrc);
	pwnd->arcClipping = pwnd->arcWindow;
	if (pwnd->style & WS_BORDER)
		{
		/* border around window */
		pwnd->arcClipping.axLeft += daxBorder;
		pwnd->arcClipping.ayTop += dayBorder;
		}
	pwnd->arcClipping.axRight = pwnd->arcClipping.axLeft + rrc.rxRight;
	pwnd->arcClipping.ayBottom = pwnd->arcClipping.ayTop + rrc.ryBottom;

	if ((pwnd->pwndParent != NULL) && (pwnd->style & WS_CLIPOUT))
		{
		if ((pwnd->style & WS_TYPE) == WS_SCROLL) 
			{
			if (pwnd->pwndParent->pwndParent != NULL)
				{
				pwnd->arcClipping.axRight =
				 min(pwnd->arcClipping.axRight,
			 pwnd->pwndParent->pwndParent->arcClipping.axRight);
				pwnd->arcClipping.ayBottom =
				 min(pwnd->arcClipping.ayBottom,
			 pwnd->pwndParent->pwndParent->arcClipping.ayBottom);
				}
			}
		else
			{
			pwnd->arcClipping.axRight =
				 min(pwnd->arcClipping.axRight,
				 pwnd->pwndParent->arcClipping.axRight);
			pwnd->arcClipping.ayBottom =
				 min(pwnd->arcClipping.ayBottom,
				 pwnd->pwndParent->arcClipping.ayBottom);
			}
		}

	StopPublic();
	}


STATIC VOID
ValidateWindowAndSiblings(pwnd)
/*
  -- computes the clipping rectangle for a window and all of its children
*/
REGISTER PWND pwnd;
	{
	while (pwnd != NULL)
		{
		ValidateAWindow(pwnd);
		ValidateWindowAndSiblings(pwnd->pwndChild);
		pwnd = pwnd->pwndSibling;
		}
	}


STATIC VOID
ValidateWindowAndParents(pwnd)
/*
  -- computes the clipping rectangle for a window and all of its children
*/
REGISTER PWND pwnd;
	{
	if (pwnd != NULL)
		{
		ValidateWindowAndParents(pwnd->pwndParent);
		ValidateAWindow(pwnd);
		}
	}

#else

/* No Overlapping windows to worry about */

PRIVATE VOID FARPRIVATE
ValidateWindow(pwnd)
/*
  -- computes the clipping rectangle for a window and all of its children
*/
REGISTER PWND pwnd;
	{
	StartPublic();
	RRC	rrc;


	GetClientRrc(pwnd,&rrc);
	pwnd->arcClipping = pwnd->arcWindow;
	if (pwnd->style & WS_BORDER)
		{
		/* border around window */
		pwnd->arcClipping.axLeft += daxBorder;
		pwnd->arcClipping.ayTop += dayBorder;
		}
	pwnd->arcClipping.axRight = pwnd->arcClipping.axLeft + rrc.rxRight;
	pwnd->arcClipping.ayBottom = pwnd->arcClipping.ayTop + rrc.ryBottom;

	StopPublic();
	}


#endif /*WINDOW_OVERLAP*/

PUBLIC VOID FARPUBLIC
DrawWindow(pwnd)
/*
  -- draw window and children
*/
PWND pwnd;
	{
	StartPublic();
	if (pwnd)
		{
		SendMessageShort(pwnd, WM_PAINT);
		DrawWindowAndSiblings(pwnd->pwndChild);
		}
	else if (pwndRoot)
		{
		DrawMenubar();
		DrawWindowAndSiblings(pwndRoot);
		}
	StopPublic();
	}



STATIC VOID
DrawWindowAndSiblings(pwnd)
PWND pwnd;
	{
	while (pwnd != NULL)
		{
		SendMessageShort(pwnd, WM_PAINT);
		DrawWindowAndSiblings(pwnd->pwndChild);
		pwnd = pwnd->pwndSibling;
		}
	}



PUBLIC VOID FARPUBLIC
DrawBorder(pwnd, pbox, di, szTitle)
/*
  -- draw a box around the window only if WS_STYLE includes WS_BORDER
  -- MERGE ABS/REL
*/
REGISTER PWND pwnd;
BOX *	pbox;
WORD	di;
char *	szTitle;
	{
	StartPublic();
	if (pwnd->style & WS_BORDER)
		{
#ifdef WINDOW_OVERLAP
		if (pwnd->style & WS_CLIPOUT)
			pwndClip = pwnd->pwndParent;
#endif /*WINDOW_OVERLAP*/
		DrawThisWnd(pwnd);
		DrawBoxArc(pbox, &pwnd->arcWindow, di,
			   !(pwnd->style & WS_VSCROLL),
			   !(pwnd->style & WS_HSCROLL),
			   szTitle);
#ifdef WINDOW_OVERLAP
		if (pwnd->style & WS_CLIPOUT)
			pwndClip = NULL;
#endif /*WINDOW_OVERLAP*/
		}
	StopPublic();
	}



#ifdef EXTRAS
PRIVATE int FARPRIVATE
CchRealLenSz(sz)
/*
  -- return string length (excluding special color characters)
*/
REG char * sz;
	{
	REG WORD cch;

	cch = 0;
	while (*sz != '\0')
		{
		if (*sz == chColorPrefix)
			{
			/* skip prefix and following character */
			Assert(sz[1] != '\0');
			sz += 2;
			}
		else
			{
			cch++;
			sz++;
			}
		}
	return cch;
	}



VOID FARPRIVATE
TextOutColor(ax, ay, pch, cch, diOrig)
AX	ax;
AY	ay;
char *	pch;
WORD	cch;
WORD	diOrig;
/*
  -- text out with special color check
*/
	{
	REG char * pchT;
	REG WORD cchT;
	WORD	di = diOrig;

	cchT = 0;

	while (1)
		{
		/* skip to end of string or to color prefix character */
		pchT = pch;
		while (cchT < cch && *pchT != chColorPrefix)
			{
			cchT++;
			pchT++;
			}

		TextOutAbs(ax, ay, pch, cchT, di);
		if (cchT == cch)
			break;		/* done */
		ax += (BYTE) cchT;
		Assert(*pchT == chColorPrefix);
		if (pchT[1] < '0' || pchT[1] > '9')
			{
			/* revert to original color */
			di = diOrig;
			}
		else
			{
			/* set to specified user color */
			di = (diOrig & 0xff00) | (isaUserMin + pchT[1] - '0');
			}

		pch = pchT+2;		/* after color magic */
		}
	}

#endif /*EXTRAS*/



PUBLIC VOID FARPUBLIC
TextOut(pwnd, rx, ry, pch, cch, di)
/*
  -- output a line of text to the specified window
  -- (rx, ry) specify the relative position to start output
  -- cch is the number of characters to display, -1 indicates sz string
  -- di is the display info
  -- MERGE ABS/REL
*/
REGISTER PWND pwnd;
RX	rx;
RY	ry;
char *	pch;
short	cch;
WORD	di;
	{
	StartPublic();
	AX ax;
	AY ay;

	if (cch == -1)
		cch = CchRealLenSz(pch);

	DrawThisWnd(pwnd);

	if (pwnd == NULL)
		{
#ifdef EXTRAS
		TextOutColor((AX) rx, (AY) ry, pch, cch, di);
#else
		TextOutAbs((AX) rx, (AY) ry, pch, cch, di);
#endif
		StopPublic();
		return;
		}

	ax = pwnd->arcClipping.axLeft+rx;
	ay = pwnd->arcClipping.ayTop+ry;
	if ((ax < pwnd->arcClipping.axRight) && (ay < pwnd->arcClipping.ayBottom) && (ry >= 0))
		{
		if ((ax+cch) > pwnd->arcClipping.axRight)
			cch = (pwnd->arcClipping.axRight-ax);
#ifdef EXTRAS
		TextOutColor(ax, ay, pch, cch, di);
#else
		TextOutAbs(ax, ay, pch, cch, di);
#endif
		}
	StopPublic();
	}



PUBLIC VOID FARPUBLIC
FillRrc(pwnd, prrc, ch, di)
/*
  -- fill a rectangle with a given character
  -- MERGE ABS/REL
*/
PWND	pwnd;
PRRC	prrc;
ACHAR	ch;
WORD	di;
	{
	StartPublic();
	ARC arc;

	if (FArcFromRrc(pwnd, prrc, &arc))
		{
		DrawThisWnd(pwnd);
		FillArc(arc.axLeft, arc.ayTop, arc.axRight, arc.ayBottom,
			ch, di);
		}
	StopPublic();
	}



PRIVATE BOOL FARPRIVATE
FArcFromRrc(pwnd, prrc, parc)
/*
  -- convert a relative rectangle into an absolute rectangle
  -- return TRUE if rectangle within client area
*/
PWND pwnd;
PRRC prrc;
REGISTER PARC parc;
	{
	if (pwnd == NULL)
		{
		*parc = *(PARC)prrc;
		return TRUE;
		}
	parc->axLeft = prrc->rxLeft+pwnd->arcClipping.axLeft;
	parc->axRight = prrc->rxRight+pwnd->arcClipping.axLeft;
	parc->ayTop = prrc->ryTop+pwnd->arcClipping.ayTop;
	parc->ayBottom = prrc->ryBottom+pwnd->arcClipping.ayTop;
	return(IntersectRect((PRRC) parc, (PRRC) &(pwnd->arcClipping), (PRRC) parc));
	}




PUBLIC VOID FARPUBLIC
BltRrc(pwnd, rxDest, ryDest, drx, dry, rxSrc, rySrc)
/*
  -- moves source rectangle to destination
*/
REGISTER PWND pwnd;
RX rxDest, rxSrc;
RY ryDest, rySrc;
BYTE drx, dry;
	{
	StartPublic();

	if (pwnd != NULL)
		{
		/* convert Relative to Absolute */
		rxSrc += pwnd->arcClipping.axLeft;
		rySrc += pwnd->arcClipping.ayTop;
		rxDest += pwnd->arcClipping.axLeft;
		ryDest += pwnd->arcClipping.ayTop;

		/* from this point on rx & ry are really ax & ay */
		if ((rxSrc >= pwnd->arcClipping.axRight) ||
		    (rxDest >= pwnd->arcClipping.axRight) ||
		    (rySrc >= pwnd->arcClipping.ayBottom) ||
		    (ryDest >= pwnd->arcClipping.ayBottom))
			{
			/* outside range */
			StopPublic();
			return;
			}
		if ((rxSrc+drx) >= pwnd->arcClipping.axRight)
			drx = pwnd->arcClipping.axRight - rxSrc;
		if ((rxDest+drx) >= pwnd->arcClipping.axRight)
			drx = pwnd->arcClipping.axRight - rxDest;
		if ((rySrc+dry) >= pwnd->arcClipping.ayBottom)
			dry = pwnd->arcClipping.ayBottom - rySrc;
		if ((ryDest+dry) >= pwnd->arcClipping.ayBottom)
			dry = pwnd->arcClipping.ayBottom - ryDest;
		}

	DrawThisWnd(pwnd);	/* this one is tricky */
	BltArc((AX) rxDest, (AY) ryDest, drx, dry, (AX) rxSrc, (AY) rySrc);
	}



PUBLIC VOID FARPUBLIC
DrawBox(pwnd, prrc, pbox, di)
/*
  -- draws a box specified by the rectangle prrc using the characters
	defined by pbox.
  -- note : the entire rectangle must be contained in the window
  -- MERGE ABS/REL
*/
PWND pwnd;
REGISTER PRRC prrc;
BOX *pbox;
WORD di;
	{
	StartPublic();
	ARC arc;
	AssertCorrectRrc(prrc)
	if (FArcFromRrc(pwnd, prrc, &arc))
		{
		DrawThisWnd(pwnd);
		DrawBoxArc(pbox, &arc, di, TRUE, TRUE, NULL);
		}
	StopPublic();
	}

#ifdef WINDOW_OVERLAP
STATIC VOID
MoveCursorClipped(pwnd)
REGISTER PWND pwnd;
	{
	if (pwnd->style & WS_CLIPOUT)
		{
		if (((pwnd->axCursor >= pwnd->arcClipping.axRight) || 
		     (pwnd->ayCursor >= pwnd->arcClipping.ayBottom)) || 
		    ((psOverlap) &&
		     (pwnd != *((PWND FAR *) 
		        MAKELONG( sizeof(PWND) *
				        (pwnd->ayCursor*axMac + pwnd->axCursor),
				  psOverlap
		   )))         ))
			MoveHardwareCursor(0, 0, FALSE);
		else
			{
			MoveHardwareCursor(pwnd->axCursor, pwnd->ayCursor,
			    pwnd->fCursorOn ? fBlockCursor : FALSE);
			}
		}
	else
		{
		MoveHardwareCursor(pwnd->axCursor, pwnd->ayCursor,
		    pwnd->fCursorOn ? fBlockCursor : FALSE);
		}
	}
#endif /*WINDOW_OVERLAP*/

PUBLIC VOID FARPUBLIC
MoveCursor(pwnd, rx, ry)
/*
  -- move the character cursor to the appropriate position within the window
  -- only changes the hardware cursor for the window in focus
*/
REGISTER PWND pwnd;
RX rx;
RY ry;
	{
	StartPublic();
	RRC	rrc;

	GetClientRrc(pwnd,&rrc);
	AssertSz((rx <= rrc.rxRight) && (ry <= rrc.ryBottom),
		 "Attempt to Move Cursor Outside of Rectangle");

	pwnd->axCursor = pwnd->arcClipping.axLeft + rx;
	pwnd->ayCursor = pwnd->arcClipping.ayTop + ry;
	if (pwnd == pwndFocus)
#ifdef WINDOW_OVERLAP
		MoveCursorClipped(pwnd);
#else
		{
		MoveHardwareCursor(pwnd->axCursor, pwnd->ayCursor,
		    pwnd->fCursorOn ? fBlockCursor : FALSE);
		}
#endif /*WINDOW_OVERLAP*/
	StopPublic();
	}



PRIVATE VOID FARPRIVATE
UpdateCursor()
/*
  -- call this to update the state of the hardware cursor
*/
	{
	REGISTER PWND pwnd;

	if ((pwnd = pwndFocus) != NULL)
		{
		DrawThisWnd(pwnd);
#ifdef WINDOW_OVERLAP
		MoveCursorClipped(pwnd);
#else
		MoveHardwareCursor(pwnd->axCursor, pwnd->ayCursor,
		    pwnd->fCursorOn ? fBlockCursor : FALSE);
#endif /*WINDOW_OVERLAP*/
		}
	else
		{
		/* no window with focus */
		MoveHardwareCursor(0, 0, FALSE);
		}
	}



PUBLIC VOID FARPUBLIC
EnableCursor(pwnd, fOn)
/*
  -- enable/disable cursor in given window
*/
REGISTER PWND pwnd;
BOOL fOn;	/* TRUE => turn on */
	{
	StartPublic();
	pwnd->fCursorOn = (fOn != FALSE);
	if (pwnd == pwndFocus)
		{
		DrawThisWnd(pwnd);
#ifdef WINDOW_OVERLAP
		MoveCursorClipped(pwnd);
#else
		MoveHardwareCursor(pwnd->axCursor, pwnd->ayCursor,
		    pwnd->fCursorOn ? fBlockCursor : FALSE);
#endif /*WINDOW_OVERLAP*/
		}
	StopPublic();
	}


PUBLIC VOID FARPUBLIC
SetCursorBlock(fBlock)
/*
  -- set cursor size	
*/
BOOL fBlock;	/* 0-underline, 1-block */
	{
	fBlockCursor = fBlock ? 2 : 1;
	UpdateCursor();
	}
		

PUBLIC VOID FARPUBLIC
MoveWindow(pwnd, ax, ay)
/*
  -- move the window to absolute coordinates (ax, ay).
  -- update all absolute position items in the WND structure

*/
REGISTER PWND pwnd;
AX ax;
AY ay;
	{
	StartPublic();
	BYTE dax = ax - pwnd->arcWindow.axLeft;
	BYTE day = ay - pwnd->arcWindow.ayTop;

	/* Note : following explicit & 0xff is needed due to Cmerge 4.0
		bug with LOBYTE() */
#ifndef WINDOW_OVERLAP
	AssertSz(((pwnd->arcWindow.ayBottom + day) & 0xff) <= ayMac &&
	    ((pwnd->arcWindow.axRight + dax) & 0xff) <= axMac,
	    "Moving rectangle off the screen");
#endif

	pwnd->arcWindow.axLeft = ax;
	pwnd->arcWindow.ayTop = ay;
	pwnd->arcWindow.axRight += dax;
	pwnd->arcWindow.ayBottom += day;

	pwnd->axCursor += dax;
	pwnd->ayCursor += day;
	if (pwnd == pwndFocus)
		{
#ifdef WINDOW_OVERLAP
		MoveCursorClipped(pwnd);
#else
		MoveHardwareCursor(pwnd->axCursor, pwnd->ayCursor,
		    pwnd->fCursorOn ? fBlockCursor : FALSE);
#endif /*WINDOW_OVERLAP*/
		}

#ifdef WINDOW_OVERLAP
	MoveWindowAndSiblings(pwnd->pwndChild, dax, day);
#endif /*WINDOW_OVERLAP*/

	ValidateWindow(pwnd);

	StopPublic();
	}


#ifdef WINDOW_OVERLAP
STATIC VOID
MoveWindowAndSiblings(pwnd, dax, day)
/*
  -- move the window to absolute coordinates (ax, ay).
  -- update all absolute position items in the WND structure
*/
REGISTER PWND pwnd;
BYTE dax;
BYTE day;
	{
	while (pwnd != NULL)
		{
		pwnd->arcWindow.axLeft += dax;
		pwnd->arcWindow.ayTop += day;
		pwnd->arcWindow.axRight += dax;
		pwnd->arcWindow.ayBottom += day;

		pwnd->axCursor += dax;
		pwnd->ayCursor += day;
		if (pwnd == pwndFocus)
			{
			MoveCursorClipped(pwnd);
			}

		MoveWindowAndSiblings(pwnd->pwndChild, dax, day);
		pwnd = pwnd->pwndSibling;
		}
	}
#endif /*WINDOW_OVERLAP*/




PUBLIC VOID FARPUBLIC
SaveRrc(pwnd, prrc, lpbBuf)
/*
  -- restores the relative rectangle prrc in the near buffer pbBuf
  -- MERGE ABS/REL
*/
PWND	pwnd;
PRRC	prrc;
BYTE FAR * lpbBuf;
	{
	StartPublic();
	ARC arc;

	AssertCorrectRrc(prrc);
	if (FArcFromRrc(pwnd, prrc, &arc))
		{
		DrawThisWnd(pwnd);	/* this is sort of stupid */
		SaveArc(arc.axLeft, arc.ayTop, arc.axRight, arc.ayBottom,
		    lpbBuf);
		}
	StopPublic();
	}



PUBLIC VOID FARPUBLIC
RestoreRrc(pwnd, prrc, lpbBuf)
/*
  -- restores the relative rectangle prrc in the near buffer pbBuf
  -- MERGE ABS/REL
*/
PWND	pwnd;
PRRC	prrc;
BYTE FAR * lpbBuf;
	{
	StartPublic();
	ARC arc;

	AssertCorrectRrc(prrc);
	if (FArcFromRrc(pwnd, prrc, &arc))
		{
		DrawThisWnd(pwnd);
		RestoreArc(arc.axLeft, arc.ayTop, arc.axRight, arc.ayBottom,
		    lpbBuf);
		}
	StopPublic();
	}



PUBLIC VOID FARPUBLIC
CharOut(pwnd, rx, ry, ch, di)
/*
  -- put single character in window
  -- MERGE ABS/REL
*/
REGISTER PWND pwnd;
RX	rx;
RY	ry;
ACHAR	ch;
WORD	di;
	{
	if (pwnd != NULL)
		{
		rx += pwnd->arcClipping.axLeft;
		ry += pwnd->arcClipping.ayTop;
		if (rx >= pwnd->arcClipping.axRight ||
		    ry >= pwnd->arcClipping.ayBottom)
			return;		/* clip that character */
		}

	DrawThisWnd(pwnd);
	CharOutAbs((AX) rx, (AY) ry, ch, di);
	}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\_menu.h ===
/*
	COW : Character Oriented Windows

	_menu.h : menu private info
*/

/* Menu Bar */
#define ayMenu		((AY) 0)	/* menu at top of screen */
#define axMenuMin	((AX) 0)	/* start at left of screen */
#define axMenuMac	axMac 		/* use entire width */

/* Menu Items */
#define	rxMenuMark	((RX) daxBorder)   /* where check goes */
#define	rxMenuText	((RX) daxBorder+1) /* where text starts */
#define	daxMenuBox	(-daxBorder*2)	 /* left of menu title to left of box */

#define chMenuMark	chBullet	/* marked (checked) items */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\_button.h ===
/*
	COW : Character Oriented Windows

	_button.h : button specific stuff
*/


/* bits :
   0..1 => bst (button state)
   2 => fButtonDown
   3 => first in group
*/

/* button states */

#define bstOff		0
#define bstOn		1
#define bstGreyed	2		/*Assert(bstGreyed == wNinchCheck); */
#define bstMax		3


/* button characters */

#define chRadioButtonOff	' '
#ifdef KANJI
#define chRadioButtonOn		chMiddleDot
#else
#define chRadioButtonOn		chBullet
#endif
#define chRadioButtonPrefix	'('
#define chRadioButtonSuffix	')'
#define chCheckBoxOff		' '
#define chCheckBoxOn		'X'
#define chCheckBoxGrey		'-'
#define chCheckBoxPrefix	'['
#define chCheckBoxSuffix	']'


/* structure for rendering */
typedef struct _btr
	{
	char	chOff;
	char	chOn;
	char	chPrefix;
	char	chSuffix;
	char	chGrey;
	} BTR;		/* Button rendering */

#define	rxPrefix	0
#define	rxButton	1
#define	rxSuffix	2
#define	rxButtonText	4		/* one space after suffix */


/* Macros for bit accesses */
#define BstOfWnd(pwnd) ((pwnd)->wButton & 3)

#define SetWndBst(pwnd, bst) {\
	(pwnd)->wButton = (pwnd->wButton & ~(3+8)) | (bst) ;}

#define FButtonDown(pwnd) ((pwnd)->wButton & 4)

#define SetFButtonDown(pwnd, fDown) \
	{if (fDown) (pwnd)->wButton |= 4; \
	  else (pwnd)->wButton &= ~4;}

#define FFirstButton(pwnd) ((pwnd)->wButton & 8)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\_event.h ===
/*
	COW : Character Oriented Windows

	_event.h : event specific stuff
*/

#ifdef	MSG_LIMIT_SIZE
#define imsgMax 8		/* 8 key type ahead */
#else	// MSG_LIMIT_SIZE
#define imsgMax 16		/* 16 key type ahead */
#endif	// MSG_LIMIT_SIZE

typedef struct _msgq
	{
	WORD	cmsg;			/* # of messages */
	PMSG	pmsgHead;		/* head of list */
	PMSG	pmsgNext;		/* after tail (next free) */
	MSG	rgmsg[imsgMax];
	} MSGQ;

#define timeMsgMax 0x7fffffffl

#define	timeDoubleClickDefault	10	/* >.5 sec */

// defined in eventlow.c
extern MSGQ msgqAppl, msgqKeyboard, msgqMouse;
extern PMSG pmsgLast;
extern PWND pwndCapture;
extern MSP mspPrev;
extern BYTE fUseCache;
extern MSG msgCache;
extern WORD timeDoubleClick;

PRIVATE BOOL FQueueMsg(MSGQ *, PWND, WORD, WORD, DWORD, DWORD);
PRIVATE VOID FindMouseWnd(MSG *);

#ifndef DOS5
extern BOOL PASCAL fMessage;
#define	SetMessage()	{ fMessage = TRUE; }
#define	ClearMessage()	{ fMessage = FALSE; }
#else
/* NOTE : semaphore is CLEARED when a message is ready !! */
extern DWORD PASCAL semaMessage;	/* RAM semaphore */
#define	SetMessage()	DosSemClear(hsemaMessage);	/* message ready */
#define	ClearMessage()	DosSemSet(hsemaMessage);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\_listbox.h ===
/*
	COW : Character Oriented Windows

	_listbox.h : listbox specific stuff
*/

/* customization */
#define	rxListBoxMin		1	/* 1 extra space to left */


/* special on-demand value */
#define	offEmpty		((WORD) -1)


/* extra word usage */

/* 0,1 are listbox function (for on-demand) */
#define iszTopLb 	rgwExtra[cwExtraMin+2]
				/* first item in Display */
#define cszLb		rgwExtra[cwExtraMin+3]
				/* # of strings in list in list */
#define iszCurLb	rgwExtra[cwExtraMin+4]
				/* currently selected item */
#define hmemMpiszoffLb	rgwExtra[cwExtraMin+5]
				/* array of offsets in string buffer*/
#define hmemGpszLb	rgwExtra[cwExtraMin+6]
				/* string buffer pool */
#define offLb 		rgwExtra[cwExtraMin+7]
				/* next string buffer pointer */
#define offMaxLb 	rgwExtra[cwExtraMin+8]
				/* size of string buffer */
#define iszMacLb 	rgwExtra[cwExtraMin+9]
				/* max isz before index buf is grown*/
#define fSelectedLb	rgwExtra[cwExtraMin+10]
				/* do we have a selection ? */
#define isaColor	rgwExtra[cwExtraMin+11]
				/* colour of the listbox */
#define isaHiliteColor	rgwExtra[cwExtraMin+12]
				/* colour of the listbox hilite*/
#define ctickRepLb	rgwExtra[cwExtraMin+13]
				/* scrolling rate */
#ifndef LISTBOX_HORIZ
#define	cwExtraNeeded	(cwExtraMin+14)
#else
/* Horizontal scrolling extra info */
#define	drxItemLb	rgwExtra[cwExtraMin+14]
				/* width of a single item (add 1 for space) */
#define	citemWidthLb	rgwExtra[cwExtraMin+15]
				/* max # of items wide */
#define	cwExtraNeeded	(cwExtraMin+16)
#endif /*LISTBOX_HORIZ*/

#if cwExtraListBox != cwExtraNeeded
.....
#endif


#define FSelected(pwnd) ((pwnd)->fSelectedLb)

#define SetFSelected(pwnd, fSelected) (pwnd)->fSelectedLb = (fSelected);

/* info for listbox memory allocation */

#define coffInitLb	48	/* initial size of mpiszoff */
#define coffGrowLb 	32	/* amount to grow index buffer by */
#define cbInitLb 	512	/* initial size of string buffer */
#define cbGrowLb 	256	/* amount to grow string buffer by */


#ifndef LISTBOX_HORIZ
/* Vertical listboxes (only 1 column) */
#define	CitemVisible(pwnd, dry)	(dry)
#else
#define	CitemVisible(pwnd, dry)	((dry) * (pwnd)->citemWidthLb)
/* start of item display */
#define RxLeftItem(pwnd, icol)	\
	((RX) ((BYTE)(icol) * (BYTE) (pwnd->drxItemLb+1) + rxListBoxMin))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\_scroll.h ===
/*
	COW : Character Oriented Windows

	_scroll.h : scroll bar stuff
*/

/* ptElevator is the physical position of the elevator */

#define PtElevatorSb(pwnd) ((BYTE)((pwnd)->ptElevatorSb & 0xff))

#define SetPtElevatorSb(pwnd, pt) (pwnd)->ptElevatorSb = (pt);
	
#define	dxScrollMin	2
#define	dyScrollMin	2
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\_msgbox.h ===
/*
	COW : Character Oriented Windows

	_msgbox.h : message box private structures
*/


#define	mbMin		1		/* one based request #s */

typedef struct _mbi
	{
	char *	sz;
	WORD	cch;
	RX	rx;
	} MBI;		/* Message Box Info */

#define imbiMax	3		/* 3 lines max */

typedef struct _mbs
	{
	char *  szTitle;		/* dialog title (NULL if none) */
	WORD	mbSimple;		/* MB_CAPTION and MB_BEEP removed */
#ifdef	HELP_BUTTON
	WORD	fNoHelp;		/* MB_NOHELP bit set */
#endif	// HELP_BUTTON
	WORD	imbiMac;		/* # of strings */
	WORD	cchMac;			/* max width of text */
	MBI	rgmbi[imbiMax];		/* string details */
	} MBS;		/* message box state */


/* height overhead of a message box */
#ifdef DIALOG_LINE
#define	dayMsgBox	5
#else
#define	dayMsgBox	4
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\inc\bios.inc ===
;*
;*	CW : Character Windows Drivers
;*
;*	bios.inc : Screen BIOS addresses


;*****************************************************************************
;*	* Magic values we are peeking/poking around the BIOS variable with


BIOS_cursor_posn	EQU	450H		;* 8 cursor positions
BIOS_addr_6845		EQU	463H		;* base address
BIOS_crt_mode_set	EQU	465H		;* mode register out
BIOS_info		EQU	487H		;* mode options

;*****************************************************************************

;*	* PORT_ relative to BIOS_addr_6845

PORT_mode		EQU	4

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\_sedit.h ===
/*
	COW : Character Oriented Windows

	_sedit.h : single line edit specific stuff
*/

/*	* Range for valid wParam for WM_CHAR (9 bits) */
/* NOTE : be careful if you change these */
#define wEditFirst	' '		/* ignore control characters */
#define	wEditLast	0xff		/* ignore untranslated VK_'s */
#define chDelete	0x7f		/* special delete character */

#define	ctickRepEdit	1		/* edit repeat time */

/* flags are:
	0=> fFocus
	1=> fChanged
*/


#define lszNull ((char far *) NULL)

#define FFocus(pwnd) ((pwnd)->wEb & 1)

#define SetFFocus(pwnd, fFocus) \
	{if (fFocus) (pwnd)->wEb |= 1; \
	 else (pwnd)->wEb &= ~1;}
 
#define FChanged(pwnd) ((pwnd)->wEb & 2)

#define SetFChanged(pwnd, fChanged) \
	{if (fChanged) (pwnd)->wEb |= 2; \
	 else (pwnd)->wEb &= ~2;}

#define SzEdit(pwnd) ((char *) pwnd->szDialog)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\cw\user\_sdm.h ===
/*
	_sdm.h : Really local SDM info
*/


/* State Of SDM Engine */

typedef struct _sds
	{
	WORD	ctif;			/* count of TIFs */
	PTIF	rgtif;			/* pointer to array of TIF's */
	PWND	pwndDialog;		/* window of dialog */
	HCAB	hcab;			/* original CAB */
	PDLG	pdlg;			/* start of template */
	BYTE *	pbWorkBuffer;
	} SDS;	/* SDM state */

/* macros to mask access to global state */
#define FExistsDialogProc()	(sdsCur.pdlg->pfnDlg != NULL)
#define	FCallDialogProc(dlm, tmc, wNew, wOld, wParam)	\
	(*sdsCur.pdlg->pfnDlg)(dlm, tmc, wNew, wOld, wParam)

extern SDS PASCAL sdsCur;

/* SDM template initialization */

typedef struct _tci
	{
	WORD	cbWnd;		/* # of bytes for the window */
	WORD	cbAdditional;	/* # additional bytes or cbRect */
	WORD	style;		/* normal style */
	} TCI;	/* iTem Creation Info */


/* make a TCI item with extra info */
#define TciMake(cwExtra, cwAdditional, style)	\
	{ (cwWnd + (cwExtra)) * sizeof(WORD), (cwAdditional) * sizeof(WORD),\
	  (style) }

/* the special "rect" value means calculate additional size from rectangle */
#define	cwRect	((WORD) -1)
#define	cbRect	((WORD) -2)


#define	tmtDialog	tmtNull
#define	tmtScroll	(tmtNormalMax+0)

/* Special masking to get stuff from normal TM */

#define	PcrcOfTm(ptm)		((CRC *) &(ptm)->l)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\inc\csd_bios.asm ===
;*
;*	CW : Character Windows
;*
;*	csd_bios.asm : contains the default routines for BIOS video I/O
;*


ifndef PrepUpdateCsd_NonDefault
;*****************************************************************************
;********** PrepUpdateCsd **********
;*	* CSD entry point (see documentation for interface)
;*	not used for BIOS version

cProc	PrepUpdateCsd,<FAR, PUBLIC, ATOMIC>
    parmB ayLine
    parmB axFirst
    parmB dax
    parmW offFirst
    parmW fRestoreDbcs
cBegin	PrepUpdateCsd
cEnd	PrepUpdateCsd

;*****************************************************************************
endif	;* PrepUpdateCsd_NonDefault


ifndef DoUpdateCsd_NonDefault
;*****************************************************************************
;********** DoUpdateCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* BIOS version: update the screen

cProc	DoUpdateCsd,<FAR, PUBLIC, ATOMIC>, <DS, SI, DI>
    parmB ayLine
    parmB axFirst
    parmB dax
    parmW offFirst
    parmW fRestoreDbcs
cBegin	DoUpdateCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment
	mov	bx,[di].pinstDrv
	mov	ds,ds:[bx].psPrimInst		;* DS:SI => primary buffer
	mov	si,offFirst

;*	* DS:SI => start character in primary buffer
;*	* SS:BX => INST info
;*	* SS:DI => Driver data

;*	* BIOS Update
;*	* move to proper position
	mov	dl,axFirst
	mov	dh,ayLine

;*	* copy all characters to screen

	xor	bx,bx				;* BH = 0, page #0 always
	mov	bl,dax
	mov	di,bx				;* count
	mov	cx,1				;* 1 char always
loop_update:
;*	* set cursor & bump column for next
	mov	ah,2
	int	10h				;* SetCursorPosition
	inc	dl				;* next position

	lodsw					;* al = char, ah = attr
	mov	bl,ah
	mov	ah,9
	int	10h				;* WriteCharAttr

	dec	di
	jnz	loop_update

cEnd	DoUpdateCsd
;*****************************************************************************
endif	;* DoUpdateCsd_NonDefault


ifndef DoneUpdateCsd_NonDefault
;*****************************************************************************
;********** DoneUpdateCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* for BIOS version: restore cursor

cProc	DoneUpdateCsd,<FAR, PUBLIC, ATOMIC>,<DI>
cBegin	DoneUpdateCsd

;*	* restore old cursor position
	mov	di,OFF_lpwDataCsd		;* Data in data segment

	mov	dx,[di].posCurs
	mov	ah,2
	int	10h				;* SetCursorPosition

cEnd	DoneUpdateCsd
;*****************************************************************************
endif	;* DoneUpdateCsd_NonDefault



ifndef SpecialUpdateCsd_NonDefault
;*****************************************************************************
;********** SpecialUpdateCsd **********
;*	* CSD entry point (see documentation for interface)
;*	??? to be defined

cProc	SpecialUpdateCsd,<FAR, PUBLIC, ATOMIC>
cBegin	SpecialUpdateCsd

cEnd	SpecialUpdateCsd

;*****************************************************************************
endif	;* SpecialUpdateCsd_NonDefault


ifndef BltArcCsd_NonDefault
;*****************************************************************************
;********** BltArcCsd **********
;*	* CSD entry point (see documentation for interface)
;*	entry : axSrc, aySrc : upper left of source
;*		axDest, ayDest : upper left of destination
;*		dax, day : shift amount
;*	* Move a rectangle from one portion of the screen to another.
;*	exit : n/a

cProc BltArcCsd,<FAR, PUBLIC, ATOMIC>
    parmB axDest
    parmB ayDest
    parmB dax 
    parmB day
    parmB axSrc
    parmB aySrc
cBegin	BltArcCsd

cEnd	BltArcCsd
;*****************************************************************************
endif	;* BltArcCsd_NonDefault


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\inc\csd_data.inc ===
;*
;*	CW : Character Windows Drivers
;*
;*	csd_data.inc : Standard CSD data (and DM structure)


;*****************************************************************************

SDDATA	STRUC		;* Screen driver data
	pinstDrv	DW	0		;* driver's pointer to instCur
	vparmCursOn	DW	0		;* cursor on parameter
	vparmCursSize	DW	0		;* cursor size (underline)
	posCurs		DW	0		;* cursor position
	wExtra		DW	0		;* extra value
	fvmCurAdap	DB	0		;* current adapter and monitor
	fvmCurDisp	DB	0		;* current adapter and monitor
	fCurs		DB	0		;* graphics cursor On/off
			DB	0		;* align

;*	* font drawing variables
	ayBox		DW	0		;* # points for a char
	OFF_lpbFont	DW	0		;* first 128 char table
	SEG_lpbFont	DW	0		;*  "
IFDEF	TWINCSD
;for int10 hook, see saveega.asm
	rgbEGAPaletteMirror	DB	16 DUP (0)	;* attr ctrl regs
	bOverScanMirror	DB	0
	bCGAPaletteMirror	DB	0		;* 4-color graphics
	fBlinkEnable	DW	0			;enable blink attribute
ENDIF	;TWINCSD
SDDATA	ENDS

Assert	<(SIZE SDDATA AND 1) EQ 0>		;* MUST BE EVEN SIZE

ifndef SDDATA_NonDefault
cbDataCsd	equ	(size SDDATA)		;* size of data structure
endif ;standard SDDATA

fmemDataCsd	equ	fmemNear		;* must be in near space

;*****************************************************************************

ifndef DM_NonDefault
;*****************************************************************************
;*	* Structure describing Standard Display Modes (in CS)
DM	STRUC
    ;* Mode availability info
	fvmReqAdapDm	DB	?		;* hardware requirements
	fvmReqDispDm	DB	?
	modeDm		DB	?		;* the mode to set

    ;* INST info:
	;* copy the following to INST
	finstDm		DW	?
	axMacDm		DB	?
	ayMacDm		DB	?
	coMacDm		DB	?

	;* font info
	dxCharDm	DB	?
	dyCharDm	DB	?
	dyBaseDm	DB	?
	ifontDm		DB	?

	;* misc
	psVideoDm	DW	?		;* video address

    ;* Extra info
	vparmCursOnDm	DW	?		;* cursor on param (INT 10/#1)
	wExtraDm	DW	?		;* extra info
DM	ENDS
;*****************************************************************************
endif ;DM_NonDefault

pdmInst		EQU	wDriver1Inst		;* pointer to DM info (in CS)

;*****************************************************************************

	include csd_fvm.inc

;*****************************************************************************


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\inc\csd_head.inc ===
;*
;*	CW : Character Windows
;*
;*	csd_head.inc : header file for all CSD drivers

;*****************************************************************************

.xlist
	include drv.inc

	include inscr.inc				;* installable screen

	;* special stuff for DOS 3 driver
	include bios.inc
.list

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\inc\csd_fvm.inc ===
;*
;*	CW : Character Windows Drivers
;*
;*	csd_fvm.inc : Standard fvm values


;*****************************************************************************

;*	* flags for IBM adapters
fvmMDA		EQU	00000001B
fvmCGA		EQU	00000010B
fvm64KEGA	EQU	00000100B
fvmEGA		EQU	00001000B
fvmEGAM		EQU	00010000B
fvmMCGA		EQU	00100000B
fvmVGA		EQU	01000000B
fvmMouse	EQU	10000000B	; check EGA.SYS (extend int10)

;*	* flags for IBM monitors
fvmMD		EQU	00000001B
fvmCD		EQU	00000010B
fvmECD		EQU	00000100B

;*	* flags for Hercules adapters
fvmHerc102	EQU	00000001B	;* Graphics
fvmHerc112	EQU	00000010B	;* Graphics Plus (RAMfont)
fvmHerc222	EQU	00000100B	;* In-Color

;*	* flags for Amstrad adapters
fvmAmstradMD	equ	00000001B	;* Monochrome/Hercules compatible
fvmAmstradCD	equ	00000010B	;* CGA compatible
fvmAmstradECD	equ	00000100B	;* EGA compatible
fvmAmstradCM	equ	00001000B	;* PC1512 color monitor

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\inc\csd_code.asm ===
;*
;*	CW : Character Windows
;*
;*	csd_code.asm : Start of CSD code

;*****************************************************************************

sBegin	DRV
    assumes CS,DRV
    assumes ds,NOTHING
    assumes ss,NOTHING

	ORG	0H			;* start of .CSD file

;*****************************************************************************

;*	* Format of Start of CSD file
;*	* DO NOT CHANGE THIS FORMAT !!!

lpwDataCsd		label	dword		;* allocated by driver loader
OFF_lpwDataCsd	DW	cbDataCsd	;* at load time:  cbData
					;* after loading: OFF_lpwDataCsd
SEG_lpwDataCsd	DW	fmemDataCsd	;* at load time:  fmemData
					;* after loading: SEG_lpwDataCsd

pinos		DW	0		;* pinos
pincs		DW	0		;* pincs

		DW	cpfnCsdMin	;* # of entries in table

rgpfn:
;*	* init/term
		DW	ImodeGuessCurrentCsd
		DW	FQueryInstCsd
		DW	FInitCsd
		DW	TermCsd	
;*	* special
		DW	MoveHwCursCsd
		DW	FQueryInftCsd
		DW	FGetColorPaletteCsd
		DW	SetColorPaletteCsd
;*	* update
		DW	PrepUpdateCsd
		DW	DoUpdateCsd
		DW	DoneUpdateCsd
		DW	SpecialUpdateCsd
;*	* screen saving routines
		DW	CbSizeVidsCsd
		DW	FSaveVidsCsd
		DW	FRestoreVidsCsd
		DW	SaveVidDataCsd
		DW	RestoreVidDataCsd
		DW	EnableVidsMonitorCsd

		DW	BltArcCsd
		DW	GetCharMapCsd
	Assert <(($ - rgpfn) / 2) EQ cpfnCsdMin>

;*****************************************************************************


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\inc\csd_ibm.asm ===
;*
;*	CW : Character Windows
;*
;*	csd_ibm.asm : contains default routines "IBM and compatible" routines
;*

;*****************************************************************************


ifndef ModeGetCur_NonDefault
;********** ModeGetCur *********
;*	entry:	n/a
;*	* get current machine mode
;*	exit:	al = mode, ah = ayMac (or 0 if unknown)

cProc	ModeGetCur, <NEAR, PUBLIC, ATOMIC>, <ES>
cBegin	ModeGetCur

	AssertEQ di,OFF_lpwDataCsd
	mov	dl,25			;default 25 rows for CGA
	cmp	[di].fvmCurAdap,fvmCGA	;single card case
	je	@F
	mov	ax,40H
	mov	es,ax
	mov	dl,es:[0084H]		;* read BIOS rows
	inc	dl			;* dl = screen height
@@:
	push	bx
	mov	ah,0fh
	int	10h			;* get current state, return al = mode
	pop	bx
	mov	ah,dl

cEnd	ModeGetCur
endif	;* ModeGetCur_NonDefault



ifndef FvmGetCur_NonDefault
;*****************************************************************************
;********** FvmGetCur **********
;*	entry:	DS:DI => driver data
;*	* if first time called, identify the current screen and set fvmCur
;*	*  subsequent calls will return fvmCur
;*	*  After this call: fvmCur is initialized
;*	exit:	AL == adapter (0 => no supported screen found)
;*		AH == monitor
cProc	FvmGetCur, <NEAR, PUBLIC, ATOMIC>
cBegin	FvmGetCur

	AssertEQ di,OFF_lpwDataCsd
	mov	al,[di].fvmCurAdap
	mov	ah,[di].fvmCurDisp
	or	ax,ax
	jz	init_get
	jmp	end_fvm_get
init_get:	;* initial get

	push	bp			; Int10's on some machines crunch bp.

	mov	ax,1A00h		; Test for MCGA and VGA.
	int	10h
	cmp	al,1Ah
	jne	notPS2			; Jump if not PS/2 (MCGA or VGA)

	mov	ax,fvmVGA
	cmp	bl,7
;	je	@F
	je	found_EGA
	cmp	bl,8
	je	found_EGA
;	je	@F
	mov	ax,fvmMCGA
	cmp	bl,0Bh
	je	@F
	cmp	bl,0Ch
	je	@F
	xor	ax,ax			;it's PS2, but currently inactive
	jmp 	found_EGA		;go check for MDA/CGA
@@:
	jmp	found_fvm

notPS2:
	mov	ah,12h			;Test for EGA
	mov	bl,10h
	int	10h
	xor	dx,dx			; see below (CGA detection)
	cmp	bl,10h
	je	notEGA
;
; Now, figure out if the EGA is the active display.
;
	int	11H			;Get the BIOS equipment flags
	and	al, 00110000B		;
	add	al, 11010000B		;Carry flag is set only if
					;   a mono monitor is active.
	sbb	bh,0			;Result is zero only if the
					;   ega is the active adapter
	jnz	notEGA			

	mov	ax,fvmEGAM		; Test for a monochrome EGA display
	cmp	cl,0BH	 
	je	found_EGA
	cmp	cl,0AH
	je	found_EGA
	cmp	cl,04H
	je	found_EGA
	cmp	cl,05H
	je	found_EGA

	mov	ax,fvmEGA		; It's got more than 64K of RAM
	cmp	cl,3			; HiRes display for settings 9 & 3
	je	found_EGA
	cmp	cl,9
	je	found_EGA
	mov	ax,fvm64KEGA		;UNDONE - Is this correct

found_EGA:
	or	bl,bl			; Test for 64K of EGA RAM
	jnz	@F
	or	ax,fvm64KEGA
@@:
	mov	dx,ax			; allow co-exist of EGA and CGA/MDA
notEGA:					
; Test for MDA
	push	bx
	mov	ah,0fh			
	int	10h
	pop	bx
	cmp	al,7			; 7 == monochrome text mode
	jne	@F
	or	dx,fvmMDA		; assume it's an MDA	
	mov	ax,dx
	jmp	found_fvm
@@:
; Test for CGA (Note that Hercules will pass the CGA 6845 test so 
; it is put after the MDA test.)
	test	dx,fvmEGAM		
	jz	@F
; this test used in dual card config
	cmp	al,2			;al from previous int10 call
	je	jCGA
	cmp	al,3
	je	jCGA
	cmp	al,6
	je	jCGA
	mov	al,dl
	jmp	found_fvm
@@:
	push	dx
	mov	dx,3D4h			;CGA's 6845 CRTC port 3D4h
	mov	al,0Fh			
	out	dx,al			;register 0Fh (Cursor Low)
	inc	dx
	in	al,dx
	mov	ah,al			;preserve Cursor Low value in AH
	mov	al,66h			;send aributrary value
	out	dx,al
	mov	cx,7FFFh
L102:	loop	L102			;delay
	in	al,dx
	xchg	ah,al
	out	dx,al			;restore Cursor Low 
	pop	dx
	xor	ah,al			;AH=AL if CGA present
	jnz	@F
jCGA:
	or	dx,fvmCGA
	mov	ax,dx
	jmp	found_fvm
@@:
	mov	ax,dx
	or	ax,ax			; ax!=0 == card identified
	jnz	found_fvm		

; If no display card identified then use default CGA	
	mov	ax,fvmCGA		

found_fvm:	;* al = fvm
	AssertEQ [di].fvmCurAdap,0
	mov	dl,al
	mov	ah,0FAh 		; Find out if there is an EGA.SYS
	xor	bx,bx			; installed
	int	10h
	or	bx,bx
	jz	@F			; Jump if there isn't.
	or	dl,fvmMouse		; EGA.SYS is there (mirror registers)
@@:
	mov	al,dl
	mov	[di].fvmCurAdap,al
	mov	ah,0FFh			; assume no monitor chk
	test	al,fvmEGAM or fvmVGA or fvmMCGA	or fvm64KEGA or fvmEGA
	jz	NoDispCheck

	push	bx    			;* check monochrome
	test	al,fvmMCGA
	jz	@F

	push	ax			;save al (adapter info)
	mov	ax,1A00h		;read display combination code
	int	10h
	cmp	al,1Ah	
	pop	ax
	jne	ColorMode
	
	mov	ah,fvmECD or fvmCD
	cmp	bl,0Ch			;analog color ?
	je	ColorMode
	mov	ah,fvmMD		;analog mono (0Bh) 
	jmp	ColorMode
@@:	
;* EGA/VGA
	test	al,fvmCGA or fvmMDA	;MDA/EGA or CGA/EGA co-exist ?
	jnz	ColorMode		;if dual-card then enble all monitors
	push	ax			;save al (adapter info)
	mov	ah,12h
	mov	bl,10h
	int	10h	
	pop	ax
	mov	ah,fvmMD
	or	bh,bh			;0 = color, 1 = mono
	jnz	ColorMode
	mov	ah,fvmCD
	and	cl,00000110b		;switches 2 and 3 
	jnz	ColorMode		;off?
	mov	ah,fvmECD		;on.
ColorMode:
	pop	bx		
NoDispCheck:	
	mov	[di].fvmCurDisp,ah		;
	pop	bp

end_fvm_get: ;* ax = fvm

cEnd	FvmGetCur

;*****************************************************************************
endif	;* FvmGetCur_NonDefault


ifndef CoiCovFromFvm_NonDefault
;*****************************************************************************
;********** CoiCovFromFvm **********
;*	entry:	AL = fvm
;*	* Produce coiMac, covMac for fvm (AL)
;*	exit:	AL = fvm, AH = covMac, DX = coiMac

cProc	CoiCovFromFvm, <NEAR, PUBLIC, ATOMIC>
cBegin	CoiCovFromFvm

	xor	ah,ah
	xor	dx,dx
	test	al,fvmMDA		;* monochrome coiMac = 0, covMac = 0
	jnz	@F
	test	al,fvmCGA		;* CGA coiMac = 0, covMac = 0
	jnz	@F
	mov	ah,64
	test	al,fvmVGA		;* EGA coiMac = 0, covMac = 64
	jz	@F
	push	ax
	mov	ax,101ah		;* read color page state
	int	10h
	pop	ax
	mov	dx,64			;* VGA coiMac = 64, covMac = 64?
	or	bl,bl
	jz	@F
	mov	ah,16			;* VGA coiMac = 64, covMac = 16
@@:

cEnd	CoiCovFromFvm
;*****************************************************************************
endif	;* CoiCovFromFvm_NonDefault



ifndef GetPFonts_NonDefault
;*****************************************************************************
;********** GetPFonts **********
;*	entry:	AL = ifont
;*	* get font information
;*	exit:	DX:AX = lpbFont for first 128 characters
;*		CX:BX = lpbFont for last 128 characters

cProc	GetPFonts, <NEAR, PUBLIC, ATOMIC>
cBegin	GetPFonts


cEnd	GetPFonts
;*****************************************************************************
endif	;* GetPFonts_NonDefault


ifndef FInitCsd_NonDefault
;*****************************************************************************
;********** FInitCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* Initialize the screen to the given mode
;*	exit:	AX != 0 if ok

cProc	FInitCsd, <FAR, PUBLIC, ATOMIC>, <DI>
    parmDP pinst
    parmDP pinch
cBegin	FInitCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment

;*	* set mode
	mov	bx,pinst
	mov	[di].pinstDrv,bx
	mov	bx,ds:[bx].pdmInst		;* CS:BX => DM info

;*	* copy mode info into driver globals
	mov	ax,cs:[bx].vparmCursOnDm
	mov	[di].vparmCursOn,ax		;initialize underline cursor
	mov	[di].vparmCursSize,ax
	mov	ax,cs:[bx].wExtraDm
	mov	[di].wExtra,ax

	mov	ah,0fh
	int	10h				;* return al = mode
	and	al,7Fh				;* mask off clr vid buff bit.
	mov	cl,al				;* current mode

	xor	ah,ah				;* set mode
	mov	al,cs:[bx].modeDm
	cmp	al,cl
	je	@F				;* don't reset
	int	10h				;* set mode
@@:
	mov	ax,1111h			;default 8x14 font
	push	bx
	cmp	cs:[bx].ayMacDm,25		;80x25 text ?
	mov	bx,0E00h
	je	InitFont

	inc	al				;load 8x8 char into RAM
	mov	bh,08

InitFont:
	int	10h				
	pop	bx

;*	* the INCH array already contains the standard Code Page 437
;*	*  character set, so it usually can be left the same.

;*	* Do other diddling
	cCall	DiddleBlinkBit

	mov	ax,sp				;* success
cEnd	FInitCsd
;*****************************************************************************
endif	;* FInitCsd_NonDefault



ifndef DiddleBlinkBit_NonDefault
;*****************************************************************************
;********** DiddleBlinkBit **********
cProc	DiddleBlinkBit, <NEAR, ATOMIC, PUBLIC>, <DS>
cBegin	DiddleBlinkBit

;*	* Diddle blink bit via BIOS call (or diddle CGA bit)

	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	test	[bx].fvmCurAdap, fvmCGA or fvmMDA
	jz	DBB_NotCGA

	xor	ax,ax
	mov	ds,ax
	mov	dx,ds:[BIOS_addr_6845]
	add	dx,PORT_mode
;*	* diddle the mode set flag
	and	ds:[BIOS_crt_mode_set],NOT 20H
	mov	al,ds:[BIOS_crt_mode_set]
	out	dx,al				;* send to port

;Fall through because fvmEGAM is also marked as fvmMDA
;   and the above OUT would not work

;*	* EGA etc has a BIOS call for this
DBB_NotCGA:
	mov	ax,1003H			;* set intensify
	xor	bx,bx				;* intensify
	int	10h
cEnd	DiddleBlinkBit
;*****************************************************************************
endif	;* DiddleBlinkBit_NonDefault



ifndef MoveHwCursCsd_NonDefault
;*****************************************************************************

;********** MoveHwCursCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* Standard BIOS call for hardware cursor
;*	* save new position in "posCurs"

cProc	MoveHwCursCsd,<FAR, PUBLIC, ATOMIC>, <DI>
    parmB axCurs
    parmB ayCurs
    parmW fOn
    localB axCursor
    localB ayCursor
cBegin	MoveHwCursCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment

;*	* move cursor position
	xor	bh,bh
	mov	dh,ayCurs
	mov	dl,axCurs

	mov	ah,2
	int	10h				;* SetCursorPosition

	mov	cx,2000H			;* assume off
	mov	byte ptr [di].fCurs,cl		;* graphics cursor 
	cmp	fOn,0
	je	SetCursorOnOff			;* turn off

	mov	dx,[di].vparmCursSize
	cmp	fOn,2
	jne	@F
	xor	dh,dh				;(fOn = 2) Set block cursor
@@:
	mov	[di].vparmCursOn,dx		;* update cursor size
	mov	bx,[di].pinstDrv
	test	ss:[bx].finstInst,finstGraphics	;graphics text 8x14
	jz	DrawCursDone

	mov	dx,[di].posCurs		;dl = axFirst
	mov	ayCursor,dh
	mov	axCursor,dl
	xor	cx,cx			;fRestoreDbcs
	mov	ah,cl
	mov	al,ss:[bx].axMacInst
	mul	dh
	mov	dh,cl
	add	ax,dx			
	shl	ax,1			;ax = offFirst
	mov	dx,1
	cCall	<Near ptr DoUpdateCsd>, <ayCursor,axCursor,dx,ax,cx,cs>	;erase cursor
	xor	cx,cx
	mov	dh,ayCurs
	mov	dl,axCurs
	mov	[di].posCurs,dx		;update position
	mov	ah,cl
	mov	bx,[di].pinstDrv
	mov	al,ss:[bx].axMacInst
	mul	dh
	mov	dh,cl
	add	ax,dx
	shl	ax,1			;ax = offFirst
	mov	dx,1
	mov	byte ptr [di].fCurs,1		;* graphics cursor on
	cCall	<Near ptr DoUpdateCsd>, <ayCurs,axCurs,dx,ax,cx,cs>		;draw cursor

DrawCursDone:
	mov	cx,[di].vparmCursOn		;* turn on
		
SetCursorOnOff:
	mov	ah,1
	int	10h				;* SetCursorType

cEnd	MoveHwCursCsd

;*****************************************************************************
endif	;* MoveHwCursCsd_NonDefault


ifndef FGetColorPaletteCsd_NonDefault
;*****************************************************************************
;********** FGetColorPaletteCsd **********
;*	* CSD entry point (see documentation for interface)

cProc	FGetColorPaletteCsd, <FAR, PUBLIC, ATOMIC>,<DI,SI>
    parmW  coGet
    parmDP pcovGet
    parmDP pcoiGet
cBegin	FGetColorPaletteCsd

	mov	di,OFF_lpwDataCsd

	cCall	FvmGetCur
	mov	di,[di].pinstDrv
	mov	bx,coGet
	cmp	bl,[di].coMacInst
	jae	fgcpc_fail		;* color number does not exist
	mov	cx,pcoiGet
	test	al,fvmVGA
	jz	fgcpc_notVGA

;*	* VGA

	mov	ax,1007h		;* palette, read palette value
	int	10h

;*	* save cov value

	xchg	bl,bh
	xor	bh,bh
	mov	si,pcovGet
	mov	[si],bx

	jcxz	fgcpc_success		;* not interested in RGB info

;*	* get RGB info

	cCall	IcrFromCov
	mov	ax,1015h		;* palette, read color register
	int	10h
	push	ss
	pop	es
	xor	ah,ah
	mov	di,pcoiGet
	mov	al,dh
	stosw
	mov	al,ch
	stosw
	mov	al,cl
	stosw
	jmp	short fgcpc_success

fgcpc_notVGA:
	jcxz	fgcpc_getcov

fgcpc_fail:
	xor	ax,ax
	jmp	short fgcpc_done

fgcpc_getcov:
	test	al,fvmMouse		;* check for ega.sys
	jz	fgcpc_fail		;* not available

;*	* EGA.SYS

	mov	ah,0f0h			;* read one register
	mov	dx,18h
	int	10h
	mov	si,pcovGet
	mov	[si],bx

fgcpc_success:
	mov	ax,sp

fgcpc_done:

cEnd	FGetColorPaletteCsd


;********** IcrFromCov **********
;*	entry:	bl = cov
;*	Determine color register number for cov.
;*	exit:	bx = icr (color register index)
;*	TRASHES: ax,cx,dx

cProc	IcrFromCov, <NEAR, PUBLIC, ATOMIC>
cBegin	IcrFromCov

	push	bx
	mov	ax,101ah		;* palette, read color page mode
	int	10h
	pop	dx
	xchg	bl,bh
	mov	cl,6
	or	bh,bh			;* check page mode for 6 or 4 bit
	jz	ifc_makeicr

	dec	cl
	dec	cl
	jmp	short ifc_makeicr

ifc_makeicr:

	shl	bl,cl
	or	bl,dl
	xor	bh,bh

cEnd	IcrFromCov
;*****************************************************************************
endif	;* FGetColorPaletteCsd_NonDefault


ifndef SetColorPaletteCsd_NonDefault
;*****************************************************************************
;********** SetColorPaletteCsd **********
;*	* CSD entry point (see documentation for interface)

cProc	SetColorPaletteCsd, <FAR, PUBLIC, ATOMIC>,<DI,SI>
    parmW  coSet
    parmW  covSet
    parmDP pcoiSet
cBegin	SetColorPaletteCsd

	mov	di,OFF_lpwDataCsd

	cCall	FvmGetCur
	mov	di,[di].pinstDrv
	mov	bx,coSet
	cmp	bl,[di].coMacInst
	jae	scpc_done		;* color number does not exist

	;* EGA.SYS f1 and EGA 1000h calls use bl == co, bh == cov

	mov	cx,covSet
	mov	bh,cl
	AssertCmp bh,L,[di].covMacInst	;* check range

	test	al,fvmVGA		;* check for VGA
	jnz	scpc_RGB

scpc_cov:
IFNDEF NEWEGASYS
;* This code is required until we get the new EGA.SYS
;*  Taken from QINTER\mcload.asm
	test	al,fvmMouse		;* check for EGA.SYS
	jz	scpc_notEGASYS
	mov	dx,3dah
	in	al,dx
	mov	ah,0f1h
	mov	dx,18h
	int	10h
	mov	dx,3c0h
	mov	al,20h
	out	dx,al
	jmp	short scpc_done
scpc_notEGASYS:
ENDIF ;!NEWEGASYS
	mov	ax,1000h		;* set palette registers, individual
	jmp	short scpc_int10

;*	* RGB color palette

scpc_RGB:
	mov	cx,[di].coiMacInst
	jcxz	scpc_cov		;* not an RGB system
	mov	cx,pcoiSet
	jcxz	scpc_cov		;* not interested in RGB
	push	cx
	mov	ax,1007h		;* palette, read palette value
	int	10h
	mov	bl,bh
	cCall	IcrFromCov
	pop	si			;* si = pcoiSet
IFDEF DEBUG
	mov	ax,[si]
	AssertCmp ax,L,[di].coiMacInst	;* check ranges
	mov	ax,[si+2]
	AssertCmp ax,L,[di].coiMacInst
	mov	ax,[si+4]
	AssertCmp ax,L,[di].coiMacInst
ENDIF ;DEBUG
	mov	ax,1010h		;* set color register
	mov	dh,[si]
	mov	ch,[si+2]
	mov	cl,[si+4]

scpc_int10:
	int	10h

scpc_done:

cEnd	SetColorPaletteCsd

;*****************************************************************************
endif	;* SetColorPaletteCsd_NonDefault


ifndef FQueryInftCsd_NonDefault
;*****************************************************************************
;********** FQueryInftCsd **********	(assume called after FQueryInst)
;*	entry:	pinft, ifont
;*	* get font info
;*	exit:	AX = 0 => no more fonts
;*		ax != 0	Success,filled INFT
;*		trash bx,dx

cProc	FQueryInftCsd, <FAR, PUBLIC, ATOMIC>, <si, di>
    parmDP pinft
    parmW  ifont
cBegin	FQueryInftCsd

	xor	ax,ax
	mov	si,ifont
	cmp	si,cdmMax
	jae	ExitFQueryInft			; no more fonts

	mov	ax,SIZE DM
	mul	si
	mov	si,ax
	add	si,drvOffset rgdm		;* CS:SI => INST info
	mov	di,pinft			;* ds:di => INFT
	Assert	<dyCharDm EQ dxCharDm+1>
	Assert	<dyCharInft EQ dxCharInft+1>
	mov	dx,word ptr cs:[si].dxCharDm
	mov	wo ds:[di].dxCharInft,dx
					;* move both dxChar and dyChar
	mov	dl,cs:[si].dyBaseDm
	mov	ds:[di].dyBaseLineInft,dl
	
	mov	ax,ifont
	mov	ds:[di].ifontInft,al		;font index

	mov	ax,sp

ExitFQueryInft:
cEnd	FQueryInftCsd

;*****************************************************************************
endif	;* FQueryInftCsd_NonDefault



ifndef GetCharMapCsd_NonDefault
;*****************************************************************************
;********** GetCharMapCsd **********
;*	entry:	pinft, ch, pbitmap
;*	* get character bit map

cProc	GetCharMapCsd, <FAR, ATOMIC, PUBLIC>
    parmDP pinft
    parmB  char
    parmDP pbitmap    
cBegin	GetCharMapCsd

cEnd	GetCharMapCsd
;*****************************************************************************
endif	;* GetCharMapCsd_NonDefault
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\inc\csd_oax.asm ===
;*
;*	CW : Character Windows
;*
;*	csd_oax.asm : contains the OAX routines for direct
;*			video RAM access (primary buffer = video RAM)
;*			(update routines are no-ops)
;*


;*****************************************************************************
;********** PrepUpdateCsd **********
;*	entry:
;*		ayLine = ay of line drawn
;*		axFirst = first character drawn
;*		dax = # of characters drawn
;*		offFirst = offset in primary buffer where started
;*		fRestoreDbcs = bool to tell us to restore double byte
;*			characters or not.
;*	* prepare for screen update
;*	* For KANJI -- erase any dangling 1/2 characters
;*	exit: n/a

cProc	PrepUpdateCsd,<FAR, PUBLIC, ATOMIC>, <DS, SI, DI>
    parmB ayLine
    parmB axFirst
    parmB dax
    parmW offFirst
    parmW fRestoreDbcs
cBegin	PrepUpdateCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment
	mov	bx,[di].pinstDrv
	mov	ds,ds:[bx].psPrimInst		;* DS:SI => primary buffer
	mov	si,offFirst

;*	* DS:SI => start character in primary buffer
;*	* SS:BX => INST info
;*	* SS:DI => Driver data

;*	* if not restoring: 1/2 of double wide characters must be erased
	cmp	fRestoreDbcs,0
	jne	done_half_char_check

;*	* if first character is in middle of character, erase previous half
	mov	al,axFirst
	or	al,al
	jz	check_end_character		;* start of line is always safe
	cmp	byte ptr ds:[si+1],0		;* is this a second byte char ?
	jne	check_end_character
;*	* erase previous character (CW will restore this later)
	mov	byte ptr ds:[si-2],' '
	mov	byte ptr ds:[si],' '		; ['88/07/18 KazuK]
check_end_character:
;*	* AX = axFirst, DS:SI => primary buffer position of first char
	xor	dx,dx				; ['88/07/18 KazuK]
	mov	dl,axFirst			; ['88/07/18 KazuK]
	add	dl,dax				; ['88/07/18 KazuK]
	cmp	dl,ss:[bx].axMacInst		; ['88/07/18 KazuK]
	jae	done_half_char_check		;* end of screen is safe
	xor	bx,bx				; ['88/07/18 KazuK]
	mov	bl,dax
;	dec	bx				; ['88/07/18 KazuK]
	shl	bx,1
	cmp	byte ptr ds:[si+bx+1],0		;* after last a 1/2 char ?
	jne	done_half_char_check
;*	* erase the character at end of line
	mov	byte ptr ds:[si+bx],' '
	mov	byte ptr ds:[si+bx-2],' '	; ['88/07/18 KazuK]
	mov	al,ds:[si+bx-1]			;* attribute of first half
	mov	byte ptr ds:[si+bx+1],al

done_half_char_check:

cEnd	PrepUpdateCsd
;*****************************************************************************


;*****************************************************************************
;********** DoUpdateCsd **********
;*	entry:
;*		parameters just like PrepUpdateCsd
;*	* after primary buffer has been updated
;*	* For BIOS version -- send to screen
;*	* for Kanji -- parse for DBCS boundaries (OAX)
;*	exit: n/a

cProc	DoUpdateCsd,<FAR, PUBLIC, ATOMIC>, <DS, SI, DI>
    parmB ayLine
    parmB axFirst
    parmB dax			;* will never be 0
    parmW offFirst
    parmW fRestoreDbcs		;* => restore DBCS 1/2 characters
cBegin	DoUpdateCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment
	mov	bx,[di].pinstDrv
	mov	ds,ds:[bx].psPrimInst		;* DS:SI => primary buffer
	mov	si,offFirst

;*	* DS:SI => start character in primary buffer
;*	* SS:BX => INST info
;*	* SS:DI => Driver data

;*	* For the OAX, we parse what we have printed and set the attribute
;*	*  byte to 0 for the second byte of double byte characters.
	cmp	fRestoreDbcs,0
	jne	end_update
	mov	si,offFirst
	xor	cx,cx
	mov	cl,dax				;* # of bytes
loop_parse_dbcs:
	lodsw					;* get char(al) + attribute(ah)
	JmpNotDbc parse_single
;*	* second byte follows
	inc	si				;* skip 2nd char
	mov	byte ptr ds:[si],0		;* clear attrib
	inc	si
	
	cmp	cx, 1			; ['88/07/18 KazuK] This step is
	je	parse_single		; ['88/07/18 KazuK]   illegal cording
	
	AssertNE cx,1				;* must be enough
	dec	cx
parse_single:
	loop	loop_parse_dbcs

end_update:

cEnd	DoUpdateCsd

;*****************************************************************************


;*****************************************************************************
;********** DoneUpdateCsd **********
;*	entry: n/a
;*	* Update complete
;*	exit: n/a

cProc	DoneUpdateCsd,<FAR, PUBLIC, ATOMIC>
cBegin	DoneUpdateCsd

cEnd	DoneUpdateCsd

;*****************************************************************************


ifndef SpecialUpdateCsd_NonDefault
;*****************************************************************************
;********** SpecialUpdateCsd **********
;*	* CSD entry point (see documentation for interface)
;*	??? to be defined

cProc	SpecialUpdateCsd,<FAR, PUBLIC, ATOMIC>
cBegin	SpecialUpdateCsd

cEnd	SpecialUpdateCsd

;*****************************************************************************
endif	;* SpecialUpdateCsd_NonDefault


ifndef BltArcCsd_NonDefault
;*****************************************************************************
;********** BltArcCsd **********
;*	* CSD entry point (see documentation for interface)
;*	entry : axSrc, aySrc : upper left of source
;*		axDest, ayDest : upper left of destination
;*		dax, day : shift amount
;*	* Move a rectangle from one portion of the screen to another.
;*	exit : n/a

cProc BltArcCsd,<FAR, PUBLIC, ATOMIC>
    parmB axDest
    parmB ayDest
    parmB dax 
    parmB day
    parmB axSrc
    parmB aySrc
cBegin	BltArcCsd

cEnd	BltArcCsd
;*****************************************************************************
endif	;* BltArcCsd_NonDefault


;*****************************************************************************

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\inc\csd_save.asm ===
;*
;*	CW : Character Windows
;*
;*	csd_save.asm : stub routines for screen saving (not supported
;*			by default)
;*

ifndef CbSizeVidsCsd_NonDefault
;*****************************************************************************
;********** CbSizeVidsCsd **********
;*	* CSD entry point (see documentation for interface)

cProc	CbSizeVidsCsd, <FAR, PUBLIC, ATOMIC>
cBegin	CbSizeVidsCsd

	xor	ax,ax			;* return 0 => not available

cEnd	CbSizeVidsCsd
;*****************************************************************************
endif	;* CbSizeVidsCsd_NonDefault


ifndef FSaveVidsCsd_NonDefault
;*****************************************************************************
;********** FSaveVidsCsd ********
;*	* CSD entry point (see documentation for interface)

cProc	FSaveVidsCsd, <FAR, PUBLIC, ATOMIC>
    parmDP pvidsSave
    parmDP pinst
cBegin	FSaveVidsCsd

	xor	ax,ax					;* failure

cEnd	FSaveVidsCsd
;*****************************************************************************
endif	;* FSaveVidsCsd_NonDefault


ifndef FRestoreVidsCsd_NonDefault
;*****************************************************************************
;********** FRestoreVidsCsd ********
;*	* CSD entry point (see documentation for interface)

cProc	FRestoreVidsCsd, <FAR, PUBLIC, ATOMIC>
    parmDP pvidsRestore
cBegin	FRestoreVidsCsd

	xor	ax,ax					;* failure

cEnd	FRestoreVidsCsd

;*****************************************************************************
endif	;* FRestoreVidsCsd_NonDefault


ifndef SaveVidDataCsd_NonDefault
;*****************************************************************************
;********** SaveVidDataCsd ********
;*	* CSD entry point (see documentation for interface)

cProc	SaveVidDataCsd, <FAR, PUBLIC, ATOMIC>
    parmDP pvidsSaveData
    parmD  lpwBuffer
cBegin	SaveVidDataCsd

cEnd	SaveVidsDataCsd
;*****************************************************************************
endif	;* SaveVidsDataCsd_NonDefault


ifndef RestoreVidDataCsd_NonDefault
;*****************************************************************************
;********** RestoreVidDataCsd ********
;*	* CSD entry point (see documentation for interface)

cProc	RestoreVidDataCsd, <FAR, PUBLIC, ATOMIC>
    parmDP pvidsRestoreData
    parmD  lpwBuffer
cBegin	RestoreVidDataCsd

cEnd	RestoreVidDataCsd
;*****************************************************************************
endif	;* RestoreVidDataCsd_NonDefault


ifndef EnableVidsMonitorCsd_NonDefault
;*****************************************************************************
;********** EnableVidsMonitorCsd ********
;*	entry:	fMonitorOn => monitor should be on
;*	* enable/disable INT 10 monitor
;*	exit:	n/a

cProc	EnableVidsMonitorCsd, <FAR, PUBLIC, ATOMIC>
    parmW  fMonitorOn
cBegin	EnableVidsMonitorCsd

cEnd	EnableVidsMonitorCsd
;*****************************************************************************
endif	;* EnableVidsMonitorCsd_NonDefault
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\inc\csd_std.asm ===
;*
;*	CW : Character Windows
;*
;*	csd_std.asm : standard defaults
;*	(not machine specific)

ifndef ImodeGuessCurrentCsd_NonDefault
;*****************************************************************************
;********** ImodeGuessCurrentCsd **********
;*	* CSD entry point (see documentation for interface)

cProc	ImodeGuessCurrentCsd, <FAR, PUBLIC, ATOMIC>, <SI,DI>
cBegin	ImodeGuessCurrentCsd

	mov	di,OFF_lpwDataCsd

	cCall	FvmGetCur		;* get fvm

	push	ax
	cCall	ModeGetCur		;* al = mode, ah = ayMac (0=>unknown)
	pop	bx			;* bx = fvm

;*	* Search for current mode and fvm in rgdm

	mov	si,drvOffset rgdm
	mov	cx,cdmMax
	xor	dx,dx

;*	* al = current mode, ah = ayMac (or 0=>unknown)
;*	* bx = fvm
;*	* si = pdm
;*	* dx = idm = imode
;*	* cx = loop count


imgc_next:
	cmp	al,cs:[si].modeDm
	jne	@F
	test	bl,cs:[si].fvmReqAdapDm
	jz	@F				
	test	bh,cs:[si].fvmReqDispDm
	jz	@F			;* not available
	or	ah,ah
	jz	imgc_end		;* height unknown => use this one
	cmp	ah,cs:[si].ayMacDm
	jz	imgc_end		;* same height => use this one

@@:
	add	si,size DM
	inc	dx
	loop	imgc_next
	mov	dx,-1			;* unknown
imgc_end:	;* dx = imode
	mov	ax,dx			;* guess this mode

cEnd	ImodeGuessCurrentCsd
;*****************************************************************************
endif	;* ImodeGuessCurrentCsd_NonDefault


ifndef FQueryInstCsd_NonDefault
;*****************************************************************************
;********** FQueryInstCsd **********
;*	* CSD entry point (see documentation for interface)

cProc	FQueryInstCsd, <FAR, PUBLIC, ATOMIC>, <si, di>
    parmDP pinst
    parmW imode
    localW fvm
cBegin	FQueryInstCsd

	mov	di,OFF_lpwDataCsd
	cCall	FvmGetCur	;* find out what we got ...
				;* will query hardware at first call
	mov	fvm,ax

	mov	si,imode
	cmp	si,cdmMax
	jb	got_imode
fail_query:
	xor	ax,ax			;* failure
	jmp	end_qmode

got_imode: ;* si = imode
	mov	ax,SIZE DM
	mul	si
	mov	si,ax
	add	si,drvOffset rgdm		;* CS:SI => INST info

;*	* copy DM info into INST
	mov	di,pinst			;* ds:di => dest
;*	* clear out the INST structure
	push	di
	push	ds
	pop	es
	mov	cx,cbInstMin / 2
	xor	ax,ax
	rep stosw
	pop	di

;*	* move information from DM to INST
	;* finst
	mov	ax,fvm			;* al=adapter, ah=monitor
	mov	dx,cs:[si].finstDm
	test	al,cs:[si].fvmReqAdapDm
	jz	@F
	test	ah,cs:[si].fvmReqDispDm
	jz	@F
	or	dx,finstAvailable	;* this mode is currently available
@@: ;* dx = finst
IFDEF BUILTIN_SNOW
;*	* KLUDGE: set finstQuestionable for a builtin CGA.
	test	al,fvmCGA
	jz	@F
	or	dx,finstQuestionable
@@:
ENDIF ;BUILTIN_SNOW
	mov	ds:[di].finstInst,dx

IFDEF EARLIER
	Assert	<ayMacDm EQ axMacDm+1>
	Assert	<ayMacInst EQ axMacInst+1>
	;* axMac, ayMac
	mov	dx,word ptr cs:[si].axMacDm
ELSE
	mov	dl,cs:[si].axMacDm
	mov	dh,cs:[si].ayMacDm
ENDIF
	mov	wo ds:[di].axMacInst,dx		;* move both axMac and ayMac

	;* mode index
	mov	dx,imode
	mov	ds:[di].imodeInst,dx

	;* coMac, covMac, coiMac
	mov	dl,cs:[si].coMacDm
	mov	ds:[di].coMacInst,dl
	cCall	CoiCovFromFvm			;* al = fvm
	mov	ds:[di].covMacInst,ah
	mov	ds:[di].coiMacInst,dx

	;* INFT information
	Assert	<dyCharDm EQ dxCharDm+1>
	Assert	<dyCharInft EQ dxCharInft+1>
	mov	dx,word ptr cs:[si].dxCharDm
	mov	word ptr ds:[di].inftInst.dxCharInft,dx
					;* move both dxChar and dyChar
	mov	dl,cs:[si].dyBaseDm
	mov	ds:[di].inftInst.dyBaseLineInft,dl
	mov	dl,cs:[si].ifontDm
	mov	ds:[di].inftInst.ifontInft,dl

	mov	dx,0FFFFh			;default ffont values
	mov	ds:[di].ffontSupportedInst,dx

	;* Buffer info
	mov	ax,cs:[si].psVideoDm
	mov	ds:[di].psPrimInst,ax
	AssertEQ ds:[di].psSecInst,0
	AssertEQ ds:[di].cwExtraInst,0

;*	* set private info (store pointer to DM in the INST structure)
	mov	[di].pdmInst,si

	mov	ax,sp				;* ok
end_qmode:

cEnd	FQueryInstCsd


;*****************************************************************************
endif	;* FQueryInstCsd_NonDefault


ifndef TermCsd_NonDefault
;*****************************************************************************
;********** TermCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* normally a no-op

cProc	TermCsd, <FAR, PUBLIC, ATOMIC>
cBegin	TermCsd
ifdef	KANJI
	cCall	EnableBlinkBit
endif	; KANJI
cEnd	TermCsd
;*****************************************************************************
endif	;* TermCsd_NonDefault
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\inc\csd_vram.asm ===
;*
;*	CW : Character Windows
;*
;*	csd_vram.asm : contains the default routines for direct
;*			video RAM access (primary buffer = video RAM)
;*			(update routines are no-ops)
;*


ifndef PrepUpdateCsd_NonDefault
;*****************************************************************************
;********** PrepUpdateCsd **********
;*	* CSD entry point (see documentation for interface)

cProc	PrepUpdateCsd,<FAR, PUBLIC, ATOMIC>
    parmB ayLine
    parmB axFirst
    parmB dax
    parmW offFirst
    parmW fRestoreDbcs
cBegin	PrepUpdateCsd

cEnd	PrepUpdateCsd
;*****************************************************************************
endif	;* PrepUpdateCsd_NonDefault


ifndef DoUpdateCsd_NonDefault
;*****************************************************************************
;********** DoUpdateCsd **********
;*	* CSD entry point (see documentation for interface)

cProc	DoUpdateCsd,<FAR, PUBLIC, ATOMIC>
    parmB ayLine
    parmB axFirst
    parmB dax
    parmW offFirst
    parmW fRestoreDbcs
cBegin	DoUpdateCsd

cEnd	DoUpdateCsd

;*****************************************************************************
endif	;* DoUpdateCsd_NonDefault


ifndef DoneUpdateCsd_NonDefault
;*****************************************************************************
;********** DoneUpdateCsd **********
;*	* CSD entry point (see documentation for interface)

cProc	DoneUpdateCsd,<FAR, PUBLIC, ATOMIC>
cBegin	DoneUpdateCsd

cEnd	DoneUpdateCsd

;*****************************************************************************
endif	;* DoneUpdateCsd_NonDefault


ifndef SpecialUpdateCsd_NonDefault
;*****************************************************************************
;********** SpecialUpdateCsd **********
;*	* CSD entry point (see documentation for interface)
;*	??? to be defined

cProc	SpecialUpdateCsd,<FAR, PUBLIC, ATOMIC>
cBegin	SpecialUpdateCsd

cEnd	SpecialUpdateCsd

;*****************************************************************************
endif	;* SpecialUpdateCsd_NonDefault


ifndef BltArcCsd_NonDefault
;*****************************************************************************
;********** BltArcCsd **********
;*	* CSD entry point (see documentation for interface)
;*	entry : axSrc, aySrc : upper left of source
;*		axDest, ayDest : upper left of destination
;*		dax, day : shift amount
;*	* Move a rectangle from one portion of the screen to another.
;*	exit : n/a

cProc BltArcCsd,<FAR, PUBLIC, ATOMIC>
    parmB axDest
    parmB ayDest
    parmB dax 
    parmB day
    parmB axSrc
    parmB aySrc
cBegin	BltArcCsd

cEnd	BltArcCsd
;*****************************************************************************
endif	;* BltArcCsd_NonDefault


;*****************************************************************************

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\inc\csd_tail.asm ===
;*
;*	CW : Character Windows
;*
;*	csd_tail.asm : trailer file for all CSD drivers

sEnd	DRV
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\cga.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	cga.asm : CGA CSD
;*
;*****************************************************************************

	MDACSD = 0
	CGACSD = 1
	EGACSD = 0
	MCGACSD = 0
	VGACSD = 0
	
	GRAPHICSTEXT = 1

	include	ibmfont.asm


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\biossafe.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	biossafe.asm : BIOS safe CSD 
;* 	
;*	## This version is built for MP only
;*****************************************************************************

	include	csd_head.inc
	include	csd_data.inc

;*****************************************************************************

	include	csd_code.asm			;* first part of code

;*	* Display modes table
rgdm:
;* #0 - standard color mode
	DB	fvmCGA				;* fake 
	DB	fvmCD or fvmECD or fvmMD	;* fake 
	DB	3				;* mode 
	DW	finstText or finstMonochrome 	;* flags
	DB	80, 25				;* screen size
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0B800H				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved
	Assert	<($-rgdm) EQ SIZE DM>

cdmMax	equ	($ - rgdm) / (size DM)		;* # of modes

;*****************************************************************************

Nonstandard	FInitCsd
Nonstandard	ModeGetCur
Nonstandard	FvmGetCur

;*****************************************************************************

;********** FvmGetCur **********
;*	entry:	DS:DI => driver data
;*	* if first time called, identify the current screen and set fvmCur
;*	*  subsequent calls will return fvmCur
;*	*  After this call: fvmCur, codepageBase, codepageAlt are initialized
;*	exit:	AL == fvm for current screen (0 => no supported screen found)

cProc	FvmGetCur, <NEAR, PUBLIC, ATOMIC>
cBegin	FvmGetCur
	mov	al,fvmCGA	;fake CGA for running within window
	mov	ah,0FFh
cEnd	FvmGetCur



;********** ModeGetCur *********
;*	entry:	n/a
;*	* get current machine mode
;*	exit:	al = mode, ah = ayMac (or 0 if unknown)

cProc	ModeGetCur, <NEAR, PUBLIC, ATOMIC>, <ES>
cBegin	ModeGetCur

	mov	ax,40H
	mov	es,ax
	mov	dl,es:[0084H]		;* read BIOS rows
	inc	dl			;* dl = screen height
	mov	al,3			;fake mode 7 for running within window
	mov	ah,dl

cEnd	ModeGetCur



;********** FInitCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* Initialize the screen to the given mode
;*	exit:	AX != 0 if ok

cProc	FInitCsd, <FAR, PUBLIC, ATOMIC>, <DI>
    parmDP pinst
    parmDP pinch
cBegin	FInitCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment

;*	* set mode
	mov	bx,pinst
	mov	[di].pinstDrv,bx
	mov	bx,ds:[bx].pdmInst		;* CS:BX => DM info

;*	* copy mode info into driver globals
	mov	ax,cs:[bx].vparmCursOnDm
	mov	[di].vparmCursOn,ax
	mov	ax,cs:[bx].wExtraDm
	mov	[di].wExtra,ax

	;*	No mode set here

;*	* the INCH array already contains the standard Code Page 437
;*	*  character set, so it usually can be left the same.

;*	* Do other diddling
	cCall	DiddleBlinkBit

	mov	ax,sp				;* success
cEnd	FInitCsd


;*****************************************************************************


	include	csd_std.asm		;* standard init/term

	include	csd_ibm.asm		;* IBM specific routines

;*****************************************************************************

	include	csd_bios.asm		;* default procs for BIOS video I/O

	include	csd_save.asm		;* default screen save (none)

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************

	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\cga8x8.inc ===
;-----------------------------------------------------------;
	;							    ;
	;  CGA RAM Charcter Set.  8 x 8 System Font		    ;
	;							    ;
	;	  Extended Character Set (128-255)		    ;
	;							    ;
	;-----------------------------------------------------------;

rgbCGAExFont8x8:

	DB	078H,0CCH,0C0H,0CCH,078H,018H,00CH,078H ;128*
	DB	000H,0CCH,000H,0CCH,0CCH,0CCH,076H,000H ;129*
	DB	00EH,000H,078H,0CCH,0FCH,0C0H,078H,000H ;130*
	DB	07CH,082H,078H,00CH,07CH,0CCH,076H,000H ;131*
	DB	048H,000H,078H,00CH,07CH,0CCH,076H,000H ;132* 
	DB	0E0H,000H,078H,00CH,07CH,0CCH,076H,000H ;133*
	DB	030H,030H,078H,00CH,07CH,0CCH,076H,000H ;134*
	DB	000H,000H,078H,0C0H,0C0H,078H,00CH,038H ;135*
	DB	07CH,082H,078H,0CCH,0FCH,0C0H,078H,000H ;136*
	DB	0CCH,000H,078H,0CCH,0FCH,0C0H,078H,000H ;137*
	DB	0E0H,000H,078H,0CCH,0FCH,0C0H,078H,000H ;138*
	DB	0CCH,000H,070H,030H,030H,030H,078H,000H ;139*
	DB	070H,088H,070H,030H,030H,030H,078H,000H ;140*
	DB	0E0H,000H,070H,030H,030H,030H,078H,000H ;141*
	DB	0CCH,030H,078H,0CCH,0FCH,0CCH,0CCH,000H ;142*
	DB	030H,030H,000H,078H,0CCH,0FCH,0CCH,000H ;143*
	DB	00EH,000H,0FEH,060H,078H,060H,0FEH,000H ;144*
	DB	000H,000H,07EH,00CH,07EH,0CCH,07EH,000H ;145*
	DB	03EH,06CH,0CCH,0FEH,0CCH,0CCH,0CEH,000H ;146*
	DB	078H,0CCH,000H,078H,0CCH,0CCH,078H,000H ;147*
	DB	000H,0CCH,000H,078H,0CCH,0CCH,078H,000H ;148*
	DB	000H,0E0H,000H,078H,0CCH,0CCH,078H,000H ;149*
	DB	078H,0CCH,000H,0CCH,0CCH,0CCH,076H,000H ;150* 
	DB	000H,0E0H,000H,0CCH,0CCH,0CCH,076H,000H ;151* 
	DB	000H,0CCH,000H,0CCH,0CCH,07CH,00CH,0F8H ;152* 
	DB	06CH,000H,038H,06CH,06CH,06CH,038H,000H ;153* 
	DB	0CCH,000H,0CCH,0CCH,0CCH,0CCH,0FCH,000H ;154* 
	DB	018H,018H,07CH,0C0H,0C0H,07CH,018H,018H ;155* 
	DB	038H,06CH,064H,0F0H,060H,0E6H,0FCH,000H ;156*
	DB	0CCH,0CCH,078H,0FCH,030H,0FCH,030H,030H ;157*
	DB	0F8H,0C4H,0C4H,0FAH,0C6H,0CFH,0C6H,0C7H ;158* 
	DB	01CH,036H,030H,078H,030H,030H,0B0H,060H ;159*
	DB	00EH,000H,078H,00CH,07CH,0CCH,076H,000H ;160*
	DB	00EH,000H,070H,030H,030H,030H,078H,000H ;161*
	DB	000H,00EH,000H,078H,0CCH,0CCH,078H,000H ;162*
	DB	000H,00EH,000H,0CCH,0CCH,0CCH,076H,000H ;163*
	DB	0F8H,000H,0F8H,0CCH,0CCH,0CCH,0CCH,000H ;164*
	DB	0FEH,000H,0C6H,0F6H,0DEH,0CEH,0C6H,000H ;165*
	DB	07CH,0CCH,0CCH,07EH,000H,0FEH,000H,000H ;166*
	DB	07CH,0C6H,0C6H,07CH,000H,0FEH,000H,000H ;167*
	DB	030H,000H,030H,060H,0C0H,0CCH,078H,000H ;168*
	DB	000H,000H,000H,0FCH,0C0H,0C0H,000H,000H ;169*
	DB	000H,000H,000H,0FCH,00CH,00CH,000H,000H ;170*
	DB	0C3H,0C6H,0CCH,0DEH,033H,066H,0CCH,00FH ;171*
	DB	0C3H,0C6H,0CCH,0DBH,037H,06FH,0CFH,003H ;172*
	DB	030H,000H,030H,030H,078H,078H,030H,000H ;173*
	DB	000H,000H,033H,066H,0CCH,066H,033H,000H ;174*
	DB	000H,000H,0CCH,066H,033H,066H,0CCH,000H ;175*
	DB	088H,022H,088H,022H,088H,022H,088H,022H ;176*
	DB	055H,0AAH,055H,0AAH,055H,0AAH,055H,0AAH ;177*
	DB	0EEH,0BBH,0EEH,0BBH,0EEH,0BBH,0EEH,0BBH ;178*
	DB	018H,018H,018H,018H,018H,018H,018H,018H ;179*
	DB	018H,018H,018H,0F8H,018H,018H,018H,018H ;180*
	DB	018H,018H,0F8H,018H,0F8H,018H,018H,018H ;181*
	DB	066H,066H,066H,0E6H,066H,066H,066H,066H ;182*
	DB	000H,000H,000H,0FEH,066H,066H,066H,066H ;183*
	DB	000H,000H,0F8H,018H,0F8H,018H,018H,018H ;184*
	DB	066H,066H,0E6H,006H,0E6H,066H,066H,066H ;185*
	DB	066H,066H,066H,066H,066H,066H,066H,066H ;186*
	DB	000H,000H,0FEH,006H,0E6H,066H,066H,066H ;187*
	DB	066H,066H,0E6H,006H,0FEH,000H,000H,000H ;188*
	DB	066H,066H,066H,0FEH,000H,000H,000H,000H ;189*
	DB	018H,018H,0F8H,018H,0F8H,000H,000H,000H ;190*
	DB	000H,000H,000H,0F8H,018H,018H,018H,018H ;191*
	DB	018H,018H,018H,01FH,000H,000H,000H,000H ;192*
	DB	018H,018H,018H,0FFH,000H,000H,000H,000H ;193*
	DB	000H,000H,000H,0FFH,018H,018H,018H,018H ;194*
	DB	018H,018H,018H,01FH,018H,018H,018H,018H ;195*
	DB	000H,000H,000H,0FFH,000H,000H,000H,000H ;196*
	DB	018H,018H,018H,0FFH,018H,018H,018H,018H ;197*
	DB	018H,018H,01FH,018H,01FH,018H,018H,018H ;198*
	DB	066H,066H,066H,067H,066H,066H,066H,066H ;199*
	DB	066H,066H,067H,060H,07FH,000H,000H,000H ;200*
	DB	000H,000H,07FH,060H,067H,066H,066H,066H ;201*
	DB	066H,066H,0E7H,000H,0FFH,000H,000H,000H ;202*
	DB	000H,000H,0FFH,000H,0E7H,066H,066H,066H ;203*
	DB	066H,066H,067H,060H,067H,066H,066H,066H ;204*
	DB	000H,000H,0FFH,000H,0FFH,000H,000H,000H ;205*
	DB	066H,066H,0E7H,000H,0E7H,066H,066H,066H ;206*
	DB	018H,018H,0FFH,000H,0FFH,000H,000H,000H ;207*
	DB	066H,066H,066H,0FFH,000H,000H,000H,000H ;208*
	DB	000H,000H,0FFH,000H,0FFH,018H,018H,018H ;209*
	DB	000H,000H,000H,0FFH,066H,066H,066H,066H ;210*
	DB	066H,066H,066H,07FH,000H,000H,000H,000H ;211*
	DB	018H,018H,01FH,018H,01FH,000H,000H,000H ;212*
	DB	000H,000H,01FH,018H,01FH,018H,018H,018H ;213*
	DB	000H,000H,000H,07FH,066H,066H,066H,066H ;214*
	DB	066H,066H,066H,0FFH,066H,066H,066H,066H ;215*
	DB	018H,018H,0FFH,018H,0FFH,018H,018H,018H ;216*
	DB	018H,018H,018H,0F8H,000H,000H,000H,000H ;217*
	DB	000H,000H,000H,01FH,018H,018H,018H,018H ;218*
	DB	0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH ;219*
	DB	000H,000H,000H,000H,0FFH,0FFH,0FFH,0FFH ;220*
	DB	0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H ;221*
	DB	00FH,00FH,00FH,00FH,00FH,00FH,00FH,00FH ;222*
	DB	0FFH,0FFH,0FFH,0FFH,000H,000H,000H,000H ;223*
	DB	000H,000H,076H,0DCH,0C8H,0DCH,076H,000H ;224*
	DB	000H,078H,0CCH,0F8H,0CCH,0F8H,0C0H,0C0H ;225*
	DB	000H,0FCH,0CCH,0C0H,0C0H,0C0H,0C0H,0C0H ;226*
	DB	000H,0FEH,06CH,06CH,06CH,06CH,06CH,000H ;227*
	DB	0FCH,0CCH,060H,030H,060H,0CCH,0FCH,000H ;228*
	DB	000H,000H,07EH,0D8H,0D8H,0D8H,070H,000H ;229*
	DB	000H,066H,066H,066H,066H,07CH,060H,0C0H ;230*
	DB	000H,076H,0DCH,018H,018H,018H,018H,000H ;231*
	DB	0FCH,030H,078H,0CCH,0CCH,078H,030H,0FCH ;232*
	DB	038H,06CH,0C6H,0FEH,0C6H,06CH,038H,000H ;233*
	DB	038H,06CH,0C6H,0C6H,06CH,06CH,0EEH,000H ;234*
	DB	01CH,030H,018H,07CH,0CCH,0CCH,078H,000H ;235*
	DB	000H,000H,066H,0DBH,0DBH,066H,000H,000H ;236*
	DB	006H,00CH,07EH,0DBH,0DBH,07EH,060H,0C0H ;237*
	DB	01CH,030H,060H,0FCH,060H,030H,01CH,000H ;238*
	DB	078H,0CCH,0CCH,0CCH,0CCH,0CCH,0CCH,000H ;239*
	DB	000H,0FCH,000H,0FCH,000H,0FCH,000H,000H ;240*
	DB	030H,030H,0FCH,030H,030H,000H,0FCH,000H ;241*
	DB	060H,030H,018H,030H,060H,000H,0FCH,000H ;242*
	DB	018H,030H,060H,030H,018H,000H,0FCH,000H ;243*
	DB	00EH,01BH,018H,018H,018H,018H,018H,018H ;244*
	DB	018H,018H,018H,018H,018H,018H,0D8H,070H ;245*
	DB	030H,030H,000H,0FCH,000H,030H,030H,000H ;246*
	DB	000H,076H,0DCH,000H,076H,0DCH,000H,000H ;247*
	DB	070H,0D8H,0D8H,070H,000H,000H,000H,000H ;248*
	DB	000H,000H,018H,018H,000H,000H,000H,000H ;249*
	DB	000H,000H,000H,018H,000H,000H,000H,000H ;250*
	DB	00EH,00CH,00CH,00CH,0ECH,06CH,03CH,01CH ;251*
	DB	0F8H,0CCH,0CCH,0CCH,0CCH,000H,000H,000H ;252*
	DB	0F0H,018H,030H,060H,0F8H,000H,000H,000H ;253*
	DB	000H,000H,038H,038H,038H,038H,000H,000H ;254*
	DB	000H,000H,000H,000H,000H,000H,000H,000H ;255*


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\cgasnow.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	cgasnow.asm : snow protect CGA (Text) CSD
;*
;*****************************************************************************

	CGASNOW = 1
	MDACSD = 0
	CGACSD = 1
	EGACSD = 0
	MCGACSD = 0
	VGACSD = 0

	GRAPHICSTEXT = 1
	
	include	ibmfont.asm


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\amstrad.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	Amstrad.asm : for Amstrad PC1512 and PC1640
;*****************************************************************************

	include	csd_head.inc

	include	csd_data.inc

;*****************************************************************************

	include	csd_code.asm			;* first part of code

;*	* Display modes table
rgdm:
;* #0 - standard monochrome text mode (9 x 14 characters)
	DB	fvmAmstradMD
	DB	0ffh				;* any
	DB	7				;* mode
	DW	finstText OR finstMonochrome
	DB	80, 25				;* screen size
	DB	2				;* coMac
	DB	0, 0, 0, 0			;* INFT
	DW	0B000H				;* video address
	DW	0b0cH				;* cursor
	DW	0				;* extra (RamFont info)
;* #1 - standard color mode (CGA)
	DB	fvmAmstradCD or fvmAmstradECD or fvmAmstradCM
	DB	0ffh				;* any
	DB	3 
	DW	finstText
	DB	80, 25
	DB	16				;* coMac
	DB	0, 0, 0, 0			;* INFT
	DW	0B800H
	DW	0607H
	DW	0				;* reserved

cdmMax	equ	($ - rgdm) / (size DM)		;* # of modes

;*****************************************************************************

NonStandard	FvmGetCur

; array to map switch 2-4 settings to fvm
mpSwitchFvm	db	0
		db	0		
		db	fvmAmstradMD
		db	fvmAmstradECD
		db	fvmAmstradCD
		db	fvmAmstradMD
		db	fvmAmstradECD
		db	fvmAmstradCD

;*****************************************************************************
;********** FvmGetCur **********
;*	entry:	DS:DI => driver data
;*	* if first time called, identify the current screen and set fvmCur
;*	*  subsequent calls will return fvmCur
;*	*  After this call: fvmCur is initialized
;*	exit:	AL == fvm for current screen (0 => no supported screen found)
;*		AH == monitor

cProc	FvmGetCur, <NEAR, PUBLIC, ATOMIC>, <DS>
cBegin	FvmGetCur
	AssertEQ di,OFF_lpwDataCsd
	mov	al,[di].fvmCurAdap
	mov	ah,[di].fvmCurDisp
	or	ax,ax
	jnz	end_fvm_get

; Check for an Amstrad computer
;	    Code is from MS WORD
	xor	bx,bx			; Preset result to invalid function
	mov	ah, 6			; Sub-Function 6:  Get ROS Version
	stc				; Just in case no one answers
	int	015h			; Query the BIOS as to the machine nature
	mov	ax, 0			; Don't change the flags
	jc	end_fvm_get		; Carry still set -> Not Amstrad
	or	bx,bx			; Did the Amstrad BIOS change the register?
	jz	end_fvm_get		; If not, no Amstrad

; This test for a PC1512 is described in section 1.10.2 (Printer
; Control Latch) in the Amstrad PC1640 Technical Reference Manual.

	mov	dx, 03DAh
	cli
	in	al, dx
	mov	dx, 037Ah
	in	al, dx
	sti
	test	al, 020h		; if bit 5 == 1,
	mov	ax, fvmAmstradCM
	jnz	FvmQueryRet		;    we have a PC1512

	xor	ax,ax
	push	ds
	mov	ds,ax
	mov	bl,ds:[0488h]		; read switch settings
	pop	ds
	and	bx,000fh
	shr	bx, 1			; ignore switch 1 (bit 0)
	mov	al, cs:mpSwitchFvm[bx]
FvmQueryRet:
	mov	[di].fvmCurAdap,al
	mov	[di].fvmCurDisp,0FFh	;any monitor
end_fvm_get: ;* ax = fvm
cEnd	FvmGetCur


;*****************************************************************************

	include	csd_std.asm		;* standard init/term

	include	csd_ibm.asm		;* IBM specific routines

;*****************************************************************************

	include	csd_vram.asm		;* default procs for direct video I/O

	include	csd_save.asm		;* default screen save (none)

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\ega.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	ega.asm : EGA CSD
;*
;*****************************************************************************

	MDACSD = 0
	CGACSD = 0
	EGACSD = 1
	MCGACSD = 0
	VGACSD = 0

	GRAPHICSTEXT = 1

	CPF814 = 1

	include	ibmfont.asm


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\fx_csd3.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	fx_csd3.asm : Dos 3 Fixed screen driver (IBM or compatible) (linked in)
;*	* DOES NOT INCLUDE "csd_code"
;*	* has data in application's data segment
;*****************************************************************************

	include	csd_head.inc

	include	fxdrv.inc

	include	csd_data.inc

;*****************************************************************************

	include	fx_data.asm

;*****************************************************************************

sBegin	DRV
    assumes CS,DRV
    assumes ds,NOTHING
    assumes ss,NOTHING

;*****************************************************************************

;*	* There is no low memory structure for the linked driver
OFF_lpwDataCsd	DW	dataOffset rgwDataCsd


;*	* Display modes table

	MDACSD = 1		;enable all drivers
	CGACSD = 1
	EGACSD = 1
	MCGACSD = 1
	VGACSD = 1

	include genmodes.asm

	include geninit.asm		;* general FInitCsd


;*****************************************************************************

	include	csd_std.asm		;* standard init/term
	include	csd_ibm.asm		;* IBM specific routines

;*****************************************************************************
;*	* only include one of the following, as appropriate

	include	csd_vram.asm		;* default procs for direct video I/O
	include	csd_save.asm		;* default screen save (none)

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************

	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\compaq3.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	compaq3.asm : Compaq III portable (LCD) CSD	(very similar to t3100.asm)
;*
;*****************************************************************************

	include	csd_head.inc
	include	csd_data.inc

;*****************************************************************************

	include	csd_code.asm			;* first part of code

;*	* Display modes table
rgdm:

;* #0 - standard mono mode
	DB	0ffh				;* any
	DB	0ffh				;* any
	DB	3				;* mode
	DW	finstText or finstMonoChrome 	;* flags
	DB	80, 25				;* screen size
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0B800H				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved
	Assert	<($-rgdm) EQ SIZE DM>

;* #1 - 25 line Graphics text mode (mono)
	DB	0ffh				;* any
	DB	0ffh				;* any
	DB	74h				;* mode
	DW	finstGraphics OR finstFont OR finstMonoChrome or finstFastScroll	;* flags
	DB	80, 25				;* screen size
	DB	2				;* coMac
	DB	8, 16, 0, 0			;* INFT
	DW	0				;* video address
	DW	0E0FH				;* cursor
	DW	0				;* reserved

;* #2 - 50 line Graphics text mode (mono)
	DB	0ffh				;* any
	DB	0ffh				;* any
	DB	74h				;* mode
	DW	finstGraphics OR finstFont OR finstMonoChrome or finstFastScroll	;* flags
	DB	80, 50				;* screen size
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved

cdmMax	equ	($ - rgdm) / (size DM)		;* # of modes

segROM	equ	0F000H

;*****************************************************************************
;*	* Special routines

NonStandard	FInitCsd

;*****************************************************************************


;********** FInitCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* Initialize the screen to the given mode
;*	exit:	AX != 0 if ok

cProc	FInitCsd, <FAR, PUBLIC, ATOMIC>, <DI>
    parmDP pinst
    parmDP pinch
    localB modeCur
cBegin	FInitCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment

;*	* save old mode
	cCall	ModeGetCur			;* al = mode, ah = ayMac
	mov	modeCur,al			;* current mode

	mov	bx,pinst
	cmp	ds:[bx].ayMacInst,ah		;* new = current rows ?
	je	@F				;* same resolution
	mov	modeCur,0			;* cause mode reset
@@:

;*	* set mode
	mov	bx,pinst
	mov	[di].pinstDrv,bx
	mov	bx,ds:[bx].pdmInst		;* CS:BX => DM info

;*	* copy mode info into driver globals
	mov	ax,cs:[bx].wExtraDm
	mov	[di].wExtra,ax
	mov	ax,cs:[bx].vparmCursOnDm
	mov	[di].vparmCursOn,ax
	mov	[di].vparmCursSize,ax

	xor	ah,ah				;* set mode
	mov	al,cs:[bx].modeDm
	cmp	al,modeCur
	je	@F				;* don't reset
	int	10h				;* set mode
@@:
	mov	ax,40H
	mov	es,ax
	mov	al,cs:[bx].ayMacDm
	dec	al				; rows - 1
	mov	byte ptr es:[0084H],al		;* update BIOS rows

	test	cs:[bx].finstDm,finstGraphics
	jz	InitText

	xor	ah,ah	
	mov	al,cs:[bx].dyCharDm
	mov	[di].ayBox,ax			;* points
	cmp	ax,8
	je	@F

	mov	[di].SEG_lpbFont,cs				;8x16 font
	mov	[di].OFF_lpbFont,drvOffset rgbVectFont8x16
	jmp short font1

@@: 
	mov	[di].SEG_lpbFont,segROM		;8x8 font (lower 128)
	mov	[di].OFF_lpbFont,0FA6Eh
font1:	
	jmp	short InitDone

InitText:	
;*	* the INCH array already contains the standard Code Page 437
;*	*  character set, so it usually can be left the same.

;*	* Do other diddling
	cCall	DiddleBlinkBit

InitDone:
	mov	ax,sp				;* success
cEnd	FInitCsd

;*****************************************************************************

	COMPAQ3CSD = 1
	include	update2.asm
	include	vect8x16.inc		;* hard code font table

;*****************************************************************************

	include	csd_std.asm		;* standard init/term
	include	csd_ibm.asm		;* IBM specific routines

;*****************************************************************************

	include	csd_vram.asm		;* default procs for direct video I/O
	include	csd_save.asm		;* default screen save (none)

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************


	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\ericsson.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	ericsson.asm : Ericsson CSD
;*
;*****************************************************************************

	include	csd_head.inc
	include	csd_data.inc

;*****************************************************************************

	include	csd_code.asm			;* first part of code

;*	* Display modes table
rgdm:

;* #0 - standard mono mode
	DB	0ffh				;* any
	DB	0ffh				;* any
	DB	3				;* mode
	DW	finstText or finstMonoChrome 	;* flags
	DB	80, 25				;* screen size
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0B800H				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved
	Assert	<($-rgdm) EQ SIZE DM>

;* #1 - 25 line Graphics text mode (mono)
	DB	0ffh				;* any
	DB	0ffh				;* any
	DB	0FEh				;* mode
	DW	finstGraphics OR finstFont OR finstMonoChrome or finstFastScroll	;* flags
	DB	80, 25				;* screen size
	DB	2				;* coMac
	DB	8, 16, 0, 0			;* INFT
	DW	0				;* video address
	DW	0E0FH				;* cursor
	DW	0				;* reserved

;* #2 - 50 line Graphics text mode (mono)
	DB	0ffh				;* any
	DB	0ffh				;* any
	DB	0FEh				;* mode
	DW	finstGraphics OR finstFont OR finstMonoChrome or finstFastScroll	;* flags
	DB	80, 50				;* screen size
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved

cdmMax	equ	($ - rgdm) / (size DM)		;* # of modes

segROM	equ	0F000H
T3100_Font_Off	EQU	0CA00H		; Offset in BIOS for 640X400 fonts

;*****************************************************************************
;*	* Special routines

NonStandard	ModeGetCur
NonStandard	FInitCsd

;*****************************************************************************



;********** ModeGetCur *********
;*	entry:	n/a
;*	* get current machine mode
;*	exit:	al = mode, ah = ayMac (or 0 if unknown)

cProc	ModeGetCur, <NEAR, PUBLIC, ATOMIC>, <ES>
cBegin	ModeGetCur

	mov	ax,40H
	mov	es,ax
	mov	dl,es:[0084H]		;* read BIOS rows
	inc	dl			;* dl = screen height
	push	bx
	mov	ah,0fh
	int	10h			;* get current state, return al = mode
	pop	bx
	cmp	al,3			;text mode ?
	je	@F
	mov	al,0FEh			;set graphics mode
@@:
	mov	ah,dl

cEnd	ModeGetCur


;********** FInitCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* Initialize the screen to the given mode
;*	exit:	AX != 0 if ok

cProc	FInitCsd, <FAR, PUBLIC, ATOMIC>, <DI>
    parmDP pinst
    parmDP pinch
    localB modeCur
cBegin	FInitCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment

;*	* save old mode
	cCall	ModeGetCur			;* al = mode, ah = ayMac
	mov	modeCur,al			;* current mode

	mov	bx,pinst
	cmp	ds:[bx].ayMacInst,ah		;* new = current rows ?
	je	@F				;* same resolution
	mov	modeCur,0			;* cause mode reset
@@:

;*	* set mode
	mov	bx,pinst
	mov	[di].pinstDrv,bx
	mov	bx,ds:[bx].pdmInst		;* CS:BX => DM info

;*	* copy mode info into driver globals
	mov	ax,cs:[bx].wExtraDm
	mov	[di].wExtra,ax
	mov	ax,cs:[bx].vparmCursOnDm
	mov	[di].vparmCursOn,ax
	mov	[di].vparmCursSize,ax

	xor	ah,ah				;* set mode
	mov	al,cs:[bx].modeDm
	cmp	al,modeCur
	je	@F				;* don't reset
	int	10h				;* set mode
@@:
	mov	ax,40H
	mov	es,ax
	mov	al,cs:[bx].ayMacDm
	dec	al				; rows - 1
	mov	byte ptr es:[0084H],al		;* update BIOS rows

	test	cs:[bx].finstDm,finstGraphics
	jz	InitText

	xor	ah,ah	
	mov	al,cs:[bx].dyCharDm
	mov	[di].ayBox,ax			;* points
	cmp	ax,8
	je	@F

	mov	[di].SEG_lpbFont,cs		;8x16 font
	mov	[di].OFF_lpbFont,drvOffset rgbVectFont8x16
	jmp short font1

@@: 
	mov	[di].SEG_lpbFont,0F000h		;8x8 font (lower 128)
	mov	[di].OFF_lpbFont,0FA6Eh
font1:	
	jmp	short InitDone

InitText:	
;*	* the INCH array already contains the standard Code Page 437
;*	*  character set, so it usually can be left the same.

;*	* Do other diddling
	cCall	DiddleBlinkBit

InitDone:
	mov	ax,sp				;* success
cEnd	FInitCsd

;*****************************************************************************

	ERICSSONCSD = 1
	include	vect8x16.inc		;* hard code font table
	include	update2.asm

;*****************************************************************************

	include	csd_std.asm		;* standard init/term
	include	csd_ibm.asm		;* IBM specific routines

;*****************************************************************************

	include	csd_vram.asm		;* default procs for direct video I/O
	include	csd_save.asm		;* default screen save (none)

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************


	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\fx_csd5.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	fx_csd5.asm : Fixed screen driver, OS/2 (linked in)
;*	* DOES NOT INCLUDE "csd_code"
;*	* has data in application's data segment
;*****************************************************************************

	include	csd_head.inc

	include	fxdrv.inc

DM_NonDefault = 1
SDDATA_NonDefault = 1
	include	csd_data.inc			;* standard data

	include scr5.inc

	include scr5data.inc			;* extra data

;*****************************************************************************

	include	fx_data.asm

;*****************************************************************************

sBegin	DRV
    assumes CS,DRV
    assumes ds,NOTHING
    assumes ss,NOTHING

;*****************************************************************************

;*	* There is no low memory structure for the linked driver
OFF_lpwDataCsd	DW	dataOffset rgwDataCsd

;*****************************************************************************

	include scr5.asm
	include csd_std.asm
	include csd_vram.asm
	include csd_save.asm

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\fx_data.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	fx_data.asm : Fixed driver data (linked in)
;*****************************************************************************


sBegin	DATA
    assumes DS,DGROUP
    assumes CS,DGROUP

IFDEF DUALOS2

;*	* default characters (tracks INCH strucure)
;*	* NOT NEEDED FOR DUALOS2 - SUPPLIED BY FX_CSD3

ELSE ;!DUALOS2

;*	* default characters (tracks INCH strucure)
labelB	<PUBLIC, inch>

IFNDEF KANJI
;*	* IBM characters
	DB	218	;* chTopLeftCorner1
	DB	191	;* chTopRightCorner1
	DB	192	;* chBottomLeftCorner1
	DB	217	;* chBottomRightCorner1
	DB	196	;* chTopSide1
	DB	196	;* chBottomSide1
	DB	179	;* chLeftSide1
	DB	179	;* chRightSide1
	DB	195	;* chMiddleLeft1
	DB	180	;* chMiddleRight1
	DB	201	;* chTopLeftCorner2
	DB	187	;* chTopRightCorner2
	DB	200	;* chBottomLeftCorner2
	DB	188	;* chBottomRightCorner2
	DB	205	;* chTopSide2
	DB	205	;* chBottomSide2
	DB	186	;* chLeftSide2
	DB	186	;* chRightSide2
	DB	24	;* chUpArrow
	DB	25	;* chDownArrow
	DB	27	;* chLeftArrow
	DB	26	;* chRightArrow
	DB	7	;* chBullet
	DB	0FAH	;* chMiddleDot
	DB	0B0H	;* chScrollbar
	DB	' '	;* chElevator
	DB	0B1H	;* chShadowInit
	DB	009H	;* chClose
	DB	01FH	;* chZoomIn
	DB	01EH	;* chZoomOut
	DB	012H	;* chUpDownArrow
	DB	01DH	;* chLeftRightArrow
ELSE
;*	* Kanji characters (for Sanyo OAX card)
	DB	00AH	;* chTopLeftCorner1
	DB	00BH	;* chTopRightCorner1
	DB	00DH	;* chBottomLeftCorner1
	DB	00CH	;* chBottomRightCorner1
	DB	008H	;* chTopSide1
	DB	008H	;* chBottomSide1
	DB	009H	;* chLeftSide1
	DB	009H	;* chRightSide1
	DB	00EH	;* chMiddleLeft1
	DB	010H	;* chMiddleRight1
	DB	015H	;* chTopLeftCorner2
	DB	016H	;* chTopRightCorner2
	DB	018H	;* chBottomLeftCorner2
	DB	017H	;* chBottomRightCorner2
	DB	013H	;* chTopSide2
	DB	013H	;* chBottomSide2
	DB	014H	;* chLeftSide2
	DB	014H	;* chRightSide2
	DB	004H	;* chUpArrow
	DB	005H	;* chDownArrow
	DB	007H	;* chLeftArrow
	DB	006H	;* chRightArrow
	DB	'>'	;* chBullet
	DB	'*'	;* chMiddleDot
	DB	07FH	;* chScrollbar
	DB	0DBH	;* chElevator
	DB	' '	;* chShadowInit or 7Fh
	DB	'C'	;* chClose
	DB	'?'	;* chZoomIn
	DB	'?'	;* chZoomOut
	DB	002H	;* chUpDownArrow
	DB	003H	;* chLeftRightArrow
ENDIF ;KANJI
;*	* filler for "inch" structure
	DW	16 DUP (?)	;* reserved
	Assert <($-inch) EQ cbInchMin>
ENDIF ;!DUALOS2

;*****************************************************************************

labelB	<PUBLIC, insj>			;* jump table (see header for INSJ)
	DD	ImodeGuessCurrentCsd
	DD	FQueryInstCsd
	DD	FInitCsd
	DD	TermCsd	
	DD	MoveHwCursCsd
	DD	FQueryInftCsd
	DD	FGetColorPaletteCsd
	DD	SetColorPaletteCsd
	DD	PrepUpdateCsd
	DD	DoUpdateCsd
	DD	DoneUpdateCsd
	DD	SpecialUpdateCsd

;*	* screen save
	DD	CbSizeVidsCsd
	DD	FSaveVidsCsd
	DD	FRestoreVidsCsd
	DD	SaveVidDataCsd
	DD	RestoreVidDataCsd
	DD	EnableVidsMonitorCsd

	DD	BltArcCsd
	DD	GetCharMapCsd
	Assert <(($ - insj) / 4) EQ cpfnCsdMin>

sEnd	DATA

;*****************************************************************************

sBegin	BSS
    assumes DS,DGROUP

IFDEF DUALDOS3
externW	rgwDataCsd
;*	* NOT NEEDED FOR DUALOS2 - SUPPLIED BY FX_CSD3
;*	* NOTE: Assertion cbDataCsd(fxdcsd3) <= cbDataCsd(fxdcsd5)
ELSE ;!DUALDOS3
globalW	rgwDataCsd, <(cbDataCsd / 2) DUP (?)>	;* Screen driver data
ENDIF ;!DUALDOS3

sEnd	BSS

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\cpfont.asm ===
;********** CrisPFont **********
;*	entry:	cx = points (box height)
;*		al = character 
;*		ah = color attribute
;*		dl = ffont attributes
;*		dh = ffontExtraMask
;*		ds:bx = current INST
;*		ds:si = char bit map
;*	exit:	ds:si = ChrisP char bit map
;*	trash:	ax,cx,dx
;*	Fonts: 8x8, 8x14, 8x16

cProc	ChrisPFont, <NEAR>
   localB fExtraMask
   localW dyChar
cBegin	ChrisPFont

	mov	dyChar,cx
	test	dl,ffontOrCharacter
	jz	@F
	shr	dh,1
	shr	dh,1
	shr	dh,1
	shr	dh,1
	mov	fExtraMask,dh		;take upper 4-bits of ffont word
@@:
	cmp	cx,8
	je	ffont8x8
	jmp	not8x8font

ffont8x8:	

;*************************************************
;*	8 X 8
;*

	XOR	AX,AX

	TEST	DL,ffontSuperscript			; Test for superscripted
	JZ	NotSuper
	TEST	DL,ffontSubscript			; If bits 10H and 20H are set, then
	JZ	GotSuper		; we have mini-caps.
	MOV	CX,[SI + 3]
	MOV	[SI + 4],CX
	MOV	CL,[SI]
	MOV	CH,[SI + 2]
	MOV	[SI + 2],CX
	MOV	[SI],AX
	JMP	SHORT NotSub

GotSuper:
	MOV	CX,[SI + 2]		; If superscript, scrunch up
					; the character
	MOV	[SI + 1],CX
	MOV	CL,[SI + 4]
	MOV	[SI + 3],CL
	MOV	CX,[SI + 6]
	MOV	[SI + 4],CX
	MOV	[SI + 6],AX

NotSuper:
	TEST	DL,ffontSubscript			; If subscripted character, scrunch the
	JZ	NotSub			; character down
	MOV	CL,[SI + 6]
	MOV	[SI + 7],CL
	MOV	CX,[SI + 3]
	MOV	[SI + 5],CX
	MOV	CL,[SI]
	MOV	CH,[SI + 2]
	MOV	[SI + 3],CX
	MOV	[SI],AX
	MOV	[SI + 2],AL

NotSub:
	TEST	DL,ffontBold 		; If we want a bold character
	JZ	NotBold8x8 		; then get the old font, shift it over
	MOV	CX,[SI] 		; one pixel, and OR in the result with
	SHR	CL,1			; the original character.
	SHR	CH,1
	OR	[SI],CX
	MOV	CX,[SI + 2]
	SHR	CL,1
	SHR	CH,1
	OR	[SI + 2],CX
	MOV	CX,[SI + 4]
	SHR	CL,1
	SHR	CH,1
	OR	[SI + 4],CX
	MOV	CX,[SI + 6]
	SHR	CL,1
	SHR	CH,1
	OR	[SI + 6],CX

NotBold8x8:
	test	dl,ffontItalic			; If printing italic character
	Jz	NotItalics		; shift the top part 3 pixels,
	SHR	BYTE PTR [SI],1
	SHR	BYTE PTR [SI],1
	SHR	BYTE PTR [SI],1
	SHR	BYTE PTR [SI + 1],1	; The middle part 2 pixels
	SHR	BYTE PTR [SI + 1],1
	SHR	BYTE PTR [SI + 2],1
	SHR	BYTE PTR [SI + 2],1
	SHR	BYTE PTR [SI + 3],1	; And near-the-bottom part one pixel
	SHR	BYTE PTR [SI + 4],1

NotItalics:
	TEST	DL,ffontUnderline			; If an underscore or double underscore,
	JZ	NotUnderScore		; fill in the bottom line
	TEST	DL,ffontDoubleUnderline			; If both underscore and double
	JZ	Underscore		; underscore, make bottom line
					; dotted (hidden)
	OR	BYTE PTR [SI + 7],088H
	JMP	SHORT NotDoubleScore

NotUnderScore:
	TEST	DL,ffontDoubleUnderline			; If a double underscore, fill in
	JZ	NotDoubleScore		; 2nd from bottom line
	MOV	BYTE PTR [SI + 6],-1

Underscore:
	MOV	BYTE PTR [SI + 7],-1

NotDoubleScore:
	TEST	DL,ffontStrikeThrough			; If a strike through, fill in middle
	JZ	NotStrike		; line of character
	MOV	BYTE PTR [SI + 3],-1

NotStrike:
	jmp	exitChrisP

not8x8font:

IFDEF CPF814

;*************************************************
;*	8 X 14
;*

	cmp	cx,14
	je	ffont8x14
	jmp	not8x14font
	
ffont8x14:
	mov	ah,dl
	xor	dx,dx

	TEST	AH,ffontSuperscript			; Test for superscripted
	JZ	OCENoSuper
	TEST	AH,ffontSubscript			; If bits 10H and 20H are set, then
	JZ	OCESuper		; we have mini-caps.
	MOV	AL,[SI + 8]
	MOV	[SI + 9],AL
	MOV	AL,[SI + 7]
	MOV	[SI + 8],AL
	MOV	AL,[SI + 6]
	MOV	[SI + 7],AL
	MOV	AL,[SI + 5]
	MOV	[SI + 6],AL
	MOV	AL,[SI + 4]
	MOV	[SI + 5],AL
	MOV	AL,[SI + 2]
	MOV	[SI + 4],AL
	MOV	AL,[SI + 1]
	MOV	[SI + 3],AL
	MOV	[SI + 2],DL
	MOV	[SI + 1],DL
	MOV	[SI + 0],DL
	JMP	OCENoSub

OCESuper:				; If superscript, scrunch up
					; the character
	MOV	AL,[SI + 1]
	MOV	[SI + 0],AL
	MOV	AL,[SI + 2]
	MOV	[SI + 1],AL
	MOV	AL,[SI + 4]
	MOV	[SI + 2],AL
	MOV	AL,[SI + 5]
	MOV	[SI + 3],AL
	MOV	AL,[SI + 6]
	MOV	[SI + 4],AL
	MOV	AL,[SI + 7]
	MOV	[SI + 5],AL
	MOV	AL,[SI + 8]
	MOV	[SI + 6],AL
	MOV	AL,[SI + 10]
	MOV	[SI + 7],AL
	MOV	AL,[SI + 12]
	MOV	[SI + 8],AL
	MOV	[SI + 9],DL
	MOV	[SI + 10],DL
	MOV	[SI + 11],DL
	MOV	[SI + 12],DL

OCENoSuper:
	TEST	AH,ffontSubscript			; If subscripted character, scrunch the
	JZ	OCENoSub		; character down
	MOV	AL,[SI + 12]
	MOV	[SI + 13],AL
	MOV	AL,[SI + 10]
	MOV	[SI + 12],AL
	MOV	AL,[SI + 8]
	MOV	[SI + 11],AL
	MOV	AL,[SI + 7]
	MOV	[SI + 10],AL
	MOV	AL,[SI + 6]
	MOV	[SI + 9],AL
	MOV	AL,[SI + 5]
	MOV	[SI + 8],AL
	MOV	AL,[SI + 4]
	MOV	[SI + 7],AL
	MOV	AL,[SI + 2]
	MOV	[SI + 6],AL
	MOV	AL,[SI + 1]
	MOV	[SI + 5],AL
	MOV	AL,[SI + 0]
	MOV	[SI + 4],AL
	MOV	[SI + 3],DL
	MOV	[SI + 2],DL
	MOV	[SI + 1],DL
	MOV	[SI + 0],DL

OCENoSub:
	TEST	AH,ffontBold	 	; If we want a bold character
	JZ	OCENoBold		; Then get the old font, shift it over
					; one pixel, and OR in the result with
	mov	dx,si
OCEBoldLp:				; the original character
	mov	al,[si]
	SHR	AL,1
	OR	[SI],AL
	inc	si
	LOOP	OCEBoldLp
	mov	si,dx

OCENoBold:
	test	AH,ffontItalic			; If printing italic character,
	jz	OCENoItalic		; shift the top part 2 pixels
	MOV	CL,2
	SHR	BYTE PTR [SI],CL
	SHR	BYTE PTR [SI + 1],CL
	SHR	BYTE PTR [SI + 2],CL
	SHR	BYTE PTR [SI + 3],CL
	SHR	BYTE PTR [SI + 4],CL
	SHR	BYTE PTR [SI + 5],1	; Middle part 1 pixel
	SHR	BYTE PTR [SI + 6],1
	SHR	BYTE PTR [SI + 7],1
	SHL	BYTE PTR [SI + 12],1	; Bottom line 1 pixel other way

OCENoItalic:
	TEST	AH,ffontUnderline			; If an underscore or double underscore,
	JZ	OCENoUnder		; fill in the bottom line
	TEST	AH,ffontDoubleUnderline			; If both underscore and double
	JZ	OCEUnder		; underscore, make bottom line
					; dotted (hidden)
	OR	BYTE PTR [SI + 13],088H
	JMP	SHORT OCENoDouble

OCENoUnder:
	TEST	AH,ffontDoubleUnderline			; If a double underscore, fill in
	JZ	OCENoDouble		; 2nd from bottom line
	MOV	BYTE PTR [SI + 12],-1

OCEUnder:
	MOV	BYTE PTR [SI + 13],-1

OCENoDouble:
	TEST	AH,ffontStrikeThrough			; If a strike through, fill in
	JZ	OCENoStrike		; middle line of character
	MOV	BYTE PTR [SI + 6],-1

OCENoStrike:
	mov	dl,ah			;restore ffont attribute
	jmp	exitChrisP

not8x14font:

ENDIF
IFDEF CPF816

;*************************************************
;*	8 X 16
;*

	cmp	cx,16
	je	ffont8x16
	jmp	exitChrisP

ffont8x16:
	mov	ch,dl
	xor	dx,dx

	test	ch,ffontSuperscript			; Test for superscripted
	JNZ	OSHIsMiniCaps
	JMP	SHORT OSHNotSuper

OSHIsMiniCaps:
	TEST	CH,ffontSubscript			; IF bits 10H and 20H are set, THEN
	JZ	OSHGotSuper		; we have mini-caps.
	MOV	AX,[SI + 6]
	MOV	[SI + 7],AX
	MOV	AL,[SI + 5]
	MOV	[SI + 6],AL
	MOV	AX,[SI + 2]
	MOV	[SI + 4],AX
	MOV	[SI + 1],DL
	MOV	[SI + 2],DX
	JMP	SHORT OSHNotSub

OSHGotSuper:
	MOV	AX,[SI + 2]		; IF superscript, scrunch up the
					; character
	MOV	[SI],AX
	MOV	AX,[SI + 5]
	MOV	[SI + 2],AX
	MOV	AX,[SI + 7]
	MOV	[SI + 4],AX
	MOV	AL,[SI + 10]
	MOV	[SI + 6],AL
	MOV	AX,[SI + 11]
	MOV	[SI + 7],AX
	MOV	AL,[SI + 14]
	MOV	[SI + 9],AL
	MOV	[SI + 10],DX
	MOV	[SI + 12],DX
	MOV	[SI + 14],DX

OSHNotSuper:
	TEST	CH,ffontSubscript			; IF subscripted character, scrunch the
	JZ	OSHNotSub		; character down
	MOV	AX,[SI + 13]
	MOV	[SI + 14],AX
	MOV	AX,[SI + 10]
	MOV	[SI + 12],AX
	MOV	AX,[SI + 7]
	MOV	[SI + 10],AX
	MOV	AX,[SI + 5]
	MOV	[SI + 8],AX
	MOV	AX,[SI + 2]
	MOV	[SI + 6],AX
	MOV	AX,[SI]
	MOV	[SI + 4],AX
	MOV	[SI],DX
	MOV	[SI + 2],DX

OSHNotSub:
	TEST	CH,ffontBold	  	; IF we want a bold character
	JZ	OSHNotBold		; THEN get the old font, shift it over
	mov	ah,ch			;save ffont
	MOV	CX,16			; one pixel, and OR in the result with
	mov	dx,si			; the original character.

OSHboldL:
	MOV	AL,[SI]
	SHR	AL,1
	OR	[SI],AL
	INC	SI
	LOOP	OSHboldL
	mov	si,dx
	mov	ch,ah

OSHNotBold:
	test	ch,ffontItalic			; IF printing italic character
	Jz	OSHNotItalics
	SHR	BYTE PTR [SI + 0],1
	SHR	BYTE PTR [SI + 1],1
	SHR	BYTE PTR [SI + 2],1
	SHR	BYTE PTR [SI + 3],1
	SHR	BYTE PTR [SI + 4],1
	SHL	BYTE PTR [SI + 10],1
	SHL	BYTE PTR [SI + 11],1	; And near-the-bottom part two pixels
	SHL	BYTE PTR [SI + 12],1
	SHL	BYTE PTR [SI + 13],1
	SHL	BYTE PTR [SI + 14],1

OSHNotItalics:
	TEST	CH,ffontUnderline			; IF an underscore or double underscore,
	JZ	OSHNotUnderScore	; fill in the bottom line
	TEST	CH,ffontDoubleUnderline		; IF both under and double underscore
	JZ	OCSHUnder		; make bottom dotted ( hidden )
	OR	BYTE PTR [SI + 15],088H
	JMP	SHORT OSHNotDoubleScore

OSHNotUnderScore:
	TEST	CH,ffontDoubleUnderline			; IF double underscore, fill in 2nd from
	JZ	OSHNotDoubleScore	; bottom line
	MOV	BYTE PTR [SI + 14],-1

OCSHUnder:
	MOV	BYTE PTR [SI + 12],-1

OSHNotDoubleScore:
	TEST	CH,ffontStrikeThrough			; IF strike through, fill in middle line
	JZ	No16Strike				; of character
	MOV	BYTE PTR [SI + 7],-1
No16Strike:
	mov	dl,ch			;restore ffont attribute
ENDIF

exitChrisP:
	test	dl,ffontOrCharacter
	jz	@F

	mov	cx,dyChar
	cmp	fExtraMask,0
	jne	NotOr0
	mov	al,00011000b		;* or in normal vertical line
	jmp short OrCharBit
NotOr0:	
	cmp	fExtraMask,1
	jne	@F
	mov	al,00011100b		;* or in bold vertical bar
OrCharBit:
	mov	dx,si	
LoopOr:
	or	[si],al
	inc	si
	loop	LoopOr
	mov	si,dx
@@:
	
cEnd 	ChrisPFont

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\fx_twin.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	fx_ega.asm : CSD for IBM version with screen saving
;*		     (code taken from twin.asm for QC/QB)
;*	* DOES NOT INCLUDE "csd_code"
;*************************************************************************

BUILTIN_SNOW = 1		;* builtin snow control
TWINCSD = 1
	include	csd_head.inc
	include fxdrv.inc
	include	csd_data.inc

;*****************************************************************************

	include fx_data.asm

;*****************************************************************************

sBegin	DRV
    assumes CS,DRV
    assumes ds,NOTHING
    assumes ss,NOTHING

;*****************************************************************************
;*	* There is no low memory structure for the linked driver
OFF_lpwDataCsd	DW	dataOffset rgwDataCsd

	include	saveega.inc			;* screen save specifics

;*****************************************************************************

	MDACSD = 1		;enable all drivers
	CGACSD = 1
	EGACSD = 1
	MCGACSD = 1
	VGACSD = 1

	include genmodes.asm			;* modes table

;*****************************************************************************

NonStandard	FInitCsd


;********** FInitCsd **********
;*	entry:
;*		pinch = near pointer to INCH structure to fill
;*	* Initialize the screen to the given mode
;*	exit:	AX != 0 if ok

cProc	FInitCsd, <FAR, PUBLIC, ATOMIC>, <ds,di>
    parmDP pinst
    parmDP pinch
    localB modeCur
    localB fscanset
cBegin	FInitCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment

;*	* save old mode
	cCall	ModeGetCur			;* al = mode, ah = ayMac
	mov	modeCur,al			;* current mode

	mov	bx,pinst
	cmp	ds:[bx].ayMacInst,ah
	je	@F				;* same resolution
	mov	modeCur,0			;* cause mode reset
@@:

;*	* set mode
	mov	[di].pinstDrv,bx
	mov	bx,ds:[bx].pdmInst		;* CS:BX => DM info

;*	* copy mode info into driver globals
	mov	ax,cs:[bx].vparmCursOnDm
	mov	[di].vparmCursOn,ax		;initialize underline cursor
	mov	[di].vparmCursSize,ax
	mov	ax,cs:[bx].wExtraDm
	mov	[di].wExtra,ax

	mov	al,cs:[bx].modeDm
	cmp	al,modeCur
	jne	@F				
	jmp	finitdone			;same mode, no reset
@@:
	mov	fscanset,0
	test	[di].fvmCurAdap,fvmVGA 		;Test for VGA
	jz	initvideomode			

	mov	al,2				;default 400 scan lines
	cmp	cs:[bx].modeDm,7
	je	@F
	cmp	cs:[bx].ayMacDm,43		;80x43 text ?
	jne	not43line
@@:	
	dec	al				;350 lines (EGA)
	mov	fscanset,al
not43line:
	mov	ah,12h				;set vertical scan line for VGA
	push	bx
	mov	bl,30h
	int	10h
	pop	bx

initvideomode:	
	xor	ah,ah				;* set mode
	mov	al,cs:[bx].modeDm
	or	al,80h				;* don't clear REGEN
	int	10h

	test	ss:[bx].fvmCurAdap, fvmEGA or fvmVGA or fvm64KEGA or fvmMCGA or fvmEGAM
	jz	@F

;* Clear the "don't clear regen" bit in the BIOS image
	xor	ax,ax
	mov	es,ax
	and	byte ptr es:[BIOS_info],7fH	;487H
@@:
	mov	ax,40H
	mov	es,ax
	mov	al,cs:[bx].ayMacDm
	dec	al				; rows - 1
	mov	byte ptr es:[0084H],al		;* update BIOS rows

	test	[di].fvmCurAdap,fvmCGA		 
	jnz	finitdone

	mov	al,12h				;8x8 fonts
	mov	ah,8
	cmp	cs:[bx].ayMacDm,25		
	jne	@F
	
	test	[di].fvmCurAdap,fvmEGA or fvmEGAM or fvm64KEGA		 
	jnz	finitdone
		
	mov	al,14h				;8x16
	mov	ah,16

	cmp	fscanset,1
	jne	@F

	mov	al,11h				;8x14 (VGA 350 scan mode)
	mov	ah,14
@@:
	push	bx
	xor	bl,bl
	mov	bh,ah
	mov	ah,11h				;load char set
	int	10h				
	pop	bx

	cmp	cs:[bx].ayMacDm,50		;* 50 line mode ?
	jne	finitdone
	
	test	[di].fvmCurAdap,fvmMCGA		 
	jz	finitdone	
					;extra works for MCGA 50 line mode
	mov	ax,1103h		;load font page
	xor	bx,bx
	int	10h			

	mov	dx,3D4h			;program CRT
	mov	ax,309h
	out	dx,ax
	mov	al,0Ah
	out	dx,ax
	mov	al,0Bh
	out	dx,ax

	push	ds
	mov	ax,40h				;update video Bios data segment
	mov	ds,ax
	mov	word ptr ds:[4Ch],1F40h		;80x50x2
	mov	byte ptr ds:[84h],31h		;50-1 rows
	mov	word ptr ds:[85h],8		;points	
	pop	ds

finitdone:

;*	* normally the INCH array would be copied (but since it is already
;*	*  setup in DATA just leave it alone).

;*	* Do other diddling
	cCall	DiddleBlinkBit
	mov	[di].fBlinkEnable,0		;disable blink attribute

	mov	ax,sp				;* success
cEnd	FInitCsd


;*****************************************************************************

IFDEF	PROJECT_LQB
	include saveega.new			;* save stuff + bug fix
ELSE	;PROJECT_LQB
	include saveega.asm			;* save stuff
ENDIF	;PROJECT_LQB

;*****************************************************************************

	include	csd_std.asm		;* standard init/term
	include	csd_ibm.asm		;* IBM specific routines

;*****************************************************************************

	include	csd_vram.asm		;* default procs for direct video I/O
	include	csd_save.asm		;* default screen save (none)

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\genmodes.asm ===
;*	Standard Screen Modes
;*	included in fx_twin, ibmtext, and fx_csd3

;*	* Display modes table
rgdm:

IF (MDACSD OR EGACSD OR VGACSD)
;* #0 - standard 25 line monochrome mode 
	DB	fvmMDA or fvmEGAM or fvmVGA
	DB	fvmMD
	DB	7				;* mode
  	DW	finstText OR finstMonochrome
	DB	80, 25
	DB	2				;* coMac
	DB	0, 0, 0, 0			;* INFT (unknown 9x14 or 9x16)
	DW	0B000H				;* video address
	DW	0C0DH				;* cursor
	DW	0				;* reserved
	Assert	<($-rgdm) EQ SIZE DM>
ENDIF	;(MDACSD OR EGACSD)

IF MCGACSD
;* #0 - standard 25 line monochrome mode 
	DB	fvmMCGA
	DB	fvmMD
	DB	2				;* mode
  	DW	finstText OR finstMonochrome
	DB	80, 25
	DB	2				;* coMac
	DB	8, 16, 0, 0			;* INFT
	DW	0B800H				;* video address
	DW	0E0FH				;* cursor
	DW	0				;* reserved
ENDIF	;MCGACSD

IF (EGACSD OR VGACSD)
;* #1 - standard 43 line monochrome mode 
	DB	fvmEGAM or fvmVGA
	DB	fvmMD
	DB	7				;* mode
	DW	finstText OR finstMonochrome
	DB	80, 43
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0B000H				;* video address
	DW	0406H				;* cursor
	DW	0				;* reserved
ENDIF	;(EGACSD OR VGACSD)

IF VGACSD
;* #0 - standard 50 line monochrome mode 
	DB	fvmVGA
	DB	fvmMD
	DB	7				;* mode
  	DW	finstText OR finstMonochrome
	DB	80, 50
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0B000H				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved
ENDIF	;VGACSD

IFNDEF	CGASNOW
IF CGACSD
;* #2 - non-color burst mode (composit)
	DB	fvmCGA
	DB	fvmMD
	DB	2				;* mode
	DW	finstText or finstMonochrome
	DB	80, 25
	DB	16				;* coMac (gray level in this mode)
	DB	0, 0, 0, 0			;* INFT 
	DW	0B800H				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved
ENDIF	;CGACSD

IF (CGACSD OR MCGACSD OR EGACSD OR VGACSD)
;* #3 - standard color mode (CGA/EGA/MCGA/VGA)
	DB	fvmCGA or fvmEGA or fvm64KEGA or fvmMCGA or fvmVGA
	DB	fvmECD or fvmCD
	DB	3				;* mode
	DW	finstText
	DB	80, 25
	DB	16				;* coMac
	DB	0, 0, 0, 0			;* INFT (unknown)
	DW	0B800H				;* video address
	DW	0607H				;* cursor !!REVIEW
	DW	0				;* reserved
ENDIF 	;(CGACSD OR MCGACSD OR EGACSD OR VGACSD)
ENDIF	;NOT DEFINED CGASNOW

IFDEF	CGASNOW
;* #0 - non-color burst mode
	DB	fvmCGA OR fvm64KEGA OR fvmEGA OR fvmEGAM OR fvmMCGA OR fvmVGA
	DB	fvmMD 
	DB	2				;* mode
	DW	finstText or finstCgaSnow	;* flags
	DB	80, 25				;* screen size
	DB	16				;* coMac (gray level)
	DB	8, 8, 0, 0			;* INFT
	DW	0h				;* video address (Null, so allocate buffer)
	DW	0607H				;* cursor
	DW	0				;* reserved

;* #1 - standard color mode
	DB	fvmCGA OR fvm64KEGA OR fvmEGA OR fvmEGAM OR fvmMCGA OR fvmVGA
	DB	fvmCD or fvmECD 
	DB	3				;* mode
	DW	finstText or finstCgaSnow	;* flags
	DB	80, 25				;* screen size
	DB	16				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0h				;* video address (Null, so allocate buffer)
	DW	0607H				;* cursor
	DW	0				;* reserved
ENDIF	;CGASNOW

IF (EGACSD OR VGACSD)
;* #4 - 43 line mode (EGA/VGA 640x350)
	DB	fvmEGA or fvm64KEGA or fvmVGA
	DB	fvmECD
	DB	3				;* mode
	DW	finstText
	DB	80, 43
	DB	16				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0B800H				;* video address
	DW	0406H				;* cursor
	DW	0				;* reserved
ENDIF	;(EGACSD OR VGACSD)

IF VGACSD
;* #5 - 50 line (VGA 640x400)
	DB	fvmVGA
	DB	fvmECD
	DB	3				;* mode
	DW	finstText
	DB	80, 50
	DB	16				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0B800H				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved
ENDIF	;(MCGACSD OR VGACSD)

IFDEF GRAPHICSTEXT

;''''''''''''''
; Graphics Text
;,,,,,,,,,,,,,,

IF CGACSD
;* #2 - mono graphics text (CGA)
	DB	fvmCGA
	DB	fvmECD or fvmCD			;
	DB	6				;* mode
	DW	finstGraphics or finstFont or finstMonochrome or finstFastScroll
	DB	80, 25				;* screen size
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved

;* #3 - 4-color graphics text (8x8 fonts, CGA)
	DB	fvmCGA 
	DB	fvmECD or fvmCD
	DB	4				;* mode
	DW	finstGraphics or finstFont
	DB	40,25				;* 40,25 REVIEW!!!
	DB	4				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved
ENDIF	;CGACSD

IF MCGACSD
;* #3 - 256 Color graphics text (40X25)
	DB	fvmMCGA 
	DB	fvmECD or fvmCD
	DB	13h				;* mode
	DW	finstGraphics or finstFont
	DB	40,25				;* 40,25 REVIEW!!!
	DB	16				;* coMac (see MCGA.GSD)
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved
ENDIF	;MCGACSD

IF EGACSD
;* #4a - mono graphics text (8x14 fonts, EGA[64K])
	DB	fvm64KEGA or fvmEGAM
	DB	fvmMD
	DB	0Fh				;* mode
	DW	finstGraphics or finstFont OR finstMonochrome or finstFastScroll
	DB	80, 25
	DB	2				;* coMac
	DB	8, 14, 0, 0			;* INFT
	DW	0				;* video address
	DW	0D0EH				;* cursor
	DW	0				;* reserved

;* #5a - mono 43 line graphics text (8x8 fonts, EGA[64K])
	DB	fvm64KEGA or fvmEGAM
	DB	fvmMD
	DB	0FH				;* mode
	DW	finstGraphics or finstFont OR finstMonochrome or finstFastScroll
	DB	80, 43
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved

;* #4b - mono graphics text (8x14 fonts, EGA[64K])
	DB	fvm64KEGA
	DB	fvmECD
	DB	10h				;* mode
	DW	finstGraphics or finstFont OR finstMonochrome or finstFastScroll
	DB	80, 25
	DB	2				;* coMac
	DB	8, 14, 0, 0			;* INFT
	DW	0				;* video address
	DW	0D0EH				;* cursor
	DW	0				;* reserved

;* #5b - mono 43 line graphics text (8x8 fonts, EGA[64K])
	DB	fvm64KEGA 
	DB	fvmECD
	DB	10H				;* mode
	DW	finstGraphics or finstFont OR finstMonochrome or finstFastScroll
	DB	80, 43
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved

;* #6 - color graphics text (8x8 fonts,640x200 EGA[64K])
	DB	fvm64KEGA
	DB	fvmECD or fvmCD
	DB	0EH				;* mode
	DW	finstGraphics or finstFont or finstFastScroll 
	DB	80, 25
	DB	16				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved
ENDIF 	;EGACSD

IF (EGACSD OR VGACSD)
;* #7 - color graphics text (8x14 fonts, EGA[>64K]/VGA)
	DB	fvmEGA or fvmVGA 
	DB	fvmECD
	DB	10H				;* mode
	DW	finstGraphics or finstFont or finstFastScroll
	DB	80, 25				;* screen size
	DB	16				;* coMac
	DB	8, 14, 0, 0			;* INFT
	DW	0				;* video address
	DW	0D0EH
	DW	0				;* reserved

;* #8 - color 43 line graphics text (8x8 fonts, EGA[>64K]/VGA)
	DB	fvmEGA or fvmVGA
	DB	fvmECD
	DB	10H				;* mode
	DW	finstGraphics or finstFont or finstFastScroll
	DB	80, 43
	DB	16				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved
ENDIF 	;EGACSD OR VGACSD

IF MCGACSD
;* #9 - mono 30 line graphics text (8x16 fonts, MCGA/VGA)
	DB	fvmMCGA 
	DB	fvmMD or fvmECD
	DB	11H				;* mode
	DW	finstGraphics or finstFont OR finstMonochrome or finstFastScroll
	DB	80, 30
	DB	2				;* coMac
	DB	8, 16, 0, 0			;* INFT
	DW	0				;* video address
	DW	0F10H				;* cursor
	DW	0				;* reserved

;* #10 - mono 60 line graphics text (8x8 fonts, MCGA/VGA)
	DB	fvmMCGA 
	DB	fvmMD or fvmECD
	DB	11H				;* mode
	DW	finstGraphics or finstFont OR finstMonochrome or finstFastScroll
	DB	80, 60
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved
ENDIF 	;MCGACSD

IF VGACSD
;* #9 - mono 30 line graphics text (8x16 fonts, MCGA/VGA)
	DB	fvmVGA 
	DB	fvmMD 
	DB	11H				;* mode
	DW	finstGraphics or finstFont OR finstMonochrome or finstFastScroll
	DB	80, 30
	DB	2				;* coMac
	DB	8, 16, 0, 0			;* INFT
	DW	0				;* video address
	DW	0F10H				;* cursor
	DW	0				;* reserved

;* #10 - mono 60 line graphics text (8x8 fonts, MCGA/VGA)
	DB	fvmVGA 
	DB	fvmMD
	DB	11H				;* mode
	DW	finstGraphics or finstFont OR finstMonochrome or finstFastScroll
	DB	80, 60
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved

;* #11 - color 30 line graphics text (8x16 fonts, 16 color, VGA)
	DB	fvmVGA
	DB	fvmECD
	DB	12H				;* mode
	DW	finstGraphics or finstFont or finstFastScroll
	DB	80, 30
	DB	16				;* coMac
	DB	8, 16, 0, 0			;* INFT
	DW	0				;* video address
	DW	0F10H				;* cursor
	DW	0				;* reserved

;* #12 - color 34 line graphics text (8x14 fonts, 16 color, VGA)
	DB	fvmVGA
	DB	fvmECD
	DB	12H				;* mode
	DW	finstGraphics or finstFont or finstFastScroll
	DB	80, 34
	DB	16				;* coMac
	DB	8, 14, 0, 0			;* INFT
	DW	0				;* video address
	DW	0D0EH				;* cursor
	DW	0				;* reserved

;* #13 - color 60 line graphics text (8x8 fonts, VGA)
	DB	fvmVGA
	DB	fvmECD
	DB	12H				;* mode
	DW	finstGraphics or finstFont or finstFastScroll
	DB	80, 60
	DB	16				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved
ENDIF	;VGACSD
ENDIF 	;GRAPHICSTEXT

cdmMax	equ	($ - rgdm) / (size DM)		;* # of modes


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\herc102.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	herc102.asm : for Hercules monographics
;*****************************************************************************

	GB102CSD = 1
	GB112CSD = 0
	GB222CSD = 0
	
	include	herc.asm


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\herc.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	hercules.asm : for Hercules monographics, graphics plus, & in-color
;*****************************************************************************

	include	csd_head.inc

	include	csd_data.inc

;*****************************************************************************

	include	csd_code.asm			;* first part of code

;*	* Display modes table
rgdm:
;* text mode = 7, graphics mode = 5 just for identification
IF (GB102CSD OR GB112CSD)
;* #0 - standard monochrome text mode (9 x 14 characters)
	DB	fvmHerc102 or fvmHerc112 	;* hardware needed
	DB	fvmMD
	DB	7				;* mode
	DW	finstText OR finstMonochrome
	DB	80, 25				;* screen size
	DB	2				;* coMac
	DB	9, 14, 0, 0			;* INFT
	DW	0B000H				;* video address
	DW	0b0cH				;* cursor
	DW	0				;* extra (RamFont info)
	Assert	<($-rgdm) EQ SIZE DM>
ENDIF	

IF (GB112CSD OR GB222CSD)
;* #1 - RamFont 80 x 25 (9 x 14 characters)
	DB	fvmHerc112 or fvmHerc222	;* hardware needed
	DB	fvmMD
	DB	7				;* mode
	DW	finstText OR finstMonochrome OR finstFont
	DB	80, 25				;* screen size
	DB	2				;* coMac
	DB	9, 14, 0, 0			;* INFT
	DW	0				;* video address
	DW	0b0cH				;* cursor
	DW	14				;* extra (RamFont info)

;* #2 - RamFont 90 x 35 (8x 10 characters)
	DB	fvmHerc112 or fvmHerc222	;* hardware needed
	DB	fvmMD
	DB	7				;* mode
	DW	finstText OR finstMonochrome OR finstFont
	DB	90, 35				;* screen size
	DB	2				;* coMac
	DB	8, 10, 0, 0			;* INFT
	DW	0				;* video address
	DW	0809H				;* cursor
	DW	10				;* extra (RamFont info)
ENDIF

IF GB222CSD
;* #3 - standard color text mode (9 x 14 characters)
	DB	fvmHerc222			;* hardware needed
	DB	fvmECD
	DB	7				;* mode
	DW	finstText
	DB	80, 25				;* screen size
	DB	16				;* coMac
	DB	9, 14, 0, 0			;* INFT
	DW	0B000H				;* video address
	DW	0b0cH				;* cursor
	DW	0				;* extra (RamFont info)

;* #4 - (4K) RamFont 90 x 35 (8x 10 characters)
	DB	fvmHerc222			;* hardware needed
	DB	fvmECD
	DB	7				;* mode
	DW	finstText 
	DB	90, 35				;* screen size
	DB	16				;* coMac
	DB	8, 10, 0, 0			;* INFT
	DW	0B000H				;* video address
	DW	0809H				;* cursor
	DW	16				;* extra (RamFont info)
ENDIF

;IF (GB102CSD OR GB112CSD)
;* #5 - standard monochrome graphics text mode (8 x 14 characters)
	DB	fvmHerc102 or fvmHerc112 or fvmHerc222	;* hardware needed
	DB	fvmMD or fvmECD
	DB	5				;* mode
	DW	finstGraphics OR finstMonochrome OR finstFont
	DB	90, 25				;* screen size
	DB	2				;* coMac
	DB	8, 14, 0, 0			;* INFT
	DW	0				;* video address
	DW	0C0DH				;* cursor
	DW	0				;* extra (RamFont info)

IF GB102CSD
lastdm:		;* This points to the last (best) DM entry
ENDIF
;* #6 - standard monochrome graphics text mode (8 x 8 characters)
	DB	fvmHerc102 or fvmHerc112 or fvmHerc222	;* hardware needed
	DB	fvmMD or fvmECD
	DB	5				;* mode
	DW	finstGraphics OR finstMonochrome OR finstFont
	DB	90, 43				;* screen size
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* extra (RamFont info)
;ENDIF

IF GB222CSD  
;* #7 - standard color graphics text mode (8 x 14 characters)
	DB	fvmHerc222			;* hardware needed
	DB	fvmECD
	DB	5				;* mode
	DW	finstGraphics OR finstFont OR finstDisableMouse
	DB	90, 25				;* screen size
	DB	16				;* coMac
	DB	8, 14, 0, 0			;* INFT
	DW	0				;* video address
	DW	0C0DH				;* cursor
	DW	0				;* extra (RamFont info)

lastdm:		;* This points to the last (best) DM entry
;* #8 - standard color graphics text mode (8 x 8 characters)
	DB	fvmHerc222			;* hardware needed
	DB	fvmECD
	DB	5				;* mode
	DW	finstGraphics OR finstFont OR finstDisableMouse
	DB	90, 43				;* screen size
	DB	16				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* extra (RamFont info)
ENDIF

cdmMax	equ	($ - rgdm) / (size DM)		;* # of modes

;*****************************************************************************

;*	* initialization bytes for 6845
rgbInit	label	byte
cRegInit	equ	12		;* number of registers to load

rgb9x14	db	61h, 50h, 52h, 0fh		;* 80 x 25 (9 x 14 characters)
	db	19h, 06h, 19h, 19h
	db	02h, 0dh, 0bh, 0ch

rgb8x10	db	6dh, 5ah, 5ch, 0fh		;* 90 x 35 (8 x 10 characters)
	db	24h, 00h, 23h, 23h
	db	02h, 09h, 07h, 08h

GTABLE		EQU	THIS BYTE
		DB	53, 45, 46, 7, 91, 2, 87, 87, 2, 3, 0, 0, 0, 0, 0, 0

;*****************************************************************************
hgcIndex	equ	03b4h		;* 6845 index register
hgcControl	equ	03b8h		;* display mode control port
hgcStatus	equ	03bah		;* Display Status Port
hgcConfig	equ	03bfh		;* configuration port
xmodereg	equ	14h		;* xMode register
scorereg	equ	15h		;* underscore register
strikereg	equ	16h		;* overstrike register
exceptreg	equ	17h		;* exception register
fHercGr		equ	82h		;* bits for turning on Hercules graphics mode
fHercTxt	equ	00h		;* bits for turning on Hercules text mode
fHercVideo	equ	08h		;* bits for turning on Hercules video
idmask_222	equ	01110000b
idcode_222	equ	01010000b
idmask_112	equ	00110000b
idcode_112	equ	00010000b
RamFontON	EQU	00000001B	; 0 - ROM generator (normal text)
					; 1 - RamFont ON
CharacterWidth	EQU	00000010B	; 0 - 9 bits wide, 1 - 8 bits wide
RamFont_48k	EQU	00000100B	; 0 - 4k RamFont, 1 - 48k RamFont
ramfont_48k_9d	equ	RamFont_48k OR RamFontON
ramfont_48k_8d	equ	RamFont_48k OR CharacterWidth OR RamFontON
ramfont_4k_8d	equ	CharacterWidth OR RamFontON
text_buf_seg	equ	0b000h
ramfont_seg	equ	0b400h

;* for RamFont modes:
hbold	equ	80h
hrev	equ	40h
hstrike	equ	20h
hunder	equ	10h
hnormal	equ	0
font1	equ	0	;this is the italics font
font2	equ	1	;this is the italics+overstrike font
font3	equ	2	;this is the superscript font, also minicaps
font4	equ	3	;superscript+overstrike, also minicaps+overstrike
font5	equ	4	;superscript+italics, also minicaps+italics
font6	equ	5	;superscript+italics+overstrike, and mini+ital+strike
font7	equ	6	;the subscript font
font8	equ	7	;contains the normal font
font9	equ	8	;contains the normal+overstrike font
font10	equ	9	;the subscript+overstrike font
font11	equ	10	;the subscript+italics font
font12	equ	11	;the subscript+italics+overstrike font
;*****************************************************************************

NonStandard	FvmGetCur
NonStandard	ModeGetCur
NonStandard	ImodeGuessCurrentCsd
NonStandard	FInitCsd
NonStandard	MoveHwCursCsd
NonStandard	DoUpdateCsd
NonStandard	TermCsd			
NonStandard	FQueryInstCsd		;temporary

;*****************************************************************************


;********** FvmGetCur **********
;*	* Identify the current screen and return the appropriate fvm in AL
;*	* NOTE:	This is a NEAR routine.
;*	*	This routine may trash AX, BX, CX, DX, SI, DI, or ES
;*	exit:	AL == fvm for current screen or 0 if no supported screen found

cProc	FvmGetCur, <NEAR, PUBLIC, ATOMIC>, <DS>
cBegin	FvmGetCur

	AssertEQ di,OFF_lpwDataCsd
	mov	al,[di].fvmCurAdap
	mov	ah,[di].fvmCurDisp
	or	ax,ax
	jnz	end_fvm_get

IF GB102CSD
	mov	ax,fvmHerc102
ELSE
	MOV	DX,hgcStatus		; First check for a GB112
	IN	AL,DX
	AND	AL,idmask_222		; Strip to just the 222 bits
	CMP	AL,idcode_222		; Check for the GB222 id code
	mov	ax,fvmHerc222		; assume we have a GB222
	JE	@f			; yes, we do
	mov	ax,fvmHerc112		; Indicate we have a GB112
@@:
ENDIF
	mov	ah,0ffh			;* currently allow all monitors
	mov	[di].fvmCurAdap,al
	mov	[di].fvmCurDisp,ah
end_fvm_get: ;* ax = fvm

cEnd	FvmGetCur

;********** ModeGetCur *********
;*	entry:	n/a
;*	* get current machine mode
;*	exit:	al = mode, ah = ayMac (or 0 if unknown)

cProc	ModeGetCur, <NEAR, PUBLIC, ATOMIC>, <ES>
cBegin	ModeGetCur

	mov	ax,40H
	mov	es,ax
	mov	dl,es:[0084H]		;* read BIOS rows
	inc	dl			;* dl = screen height
	cmp	dl,25			;do this since some clones don't
	je	@F			;update BIOS data
	cmp	dl,35
	je	@F
	cmp	dl,43
	je	@F
	mov	dl,25			;* default to 25 rows
@@:	
	push	bx
	mov	ah,0fh
	int	10h			;* get current state, return al = mode
	pop	bx
	mov	ah,dl

cEnd	ModeGetCur

;********** ImodeGuessCurrentCsd **********
;*	
;*	*This version starts guessing from the best mode

cProc	ImodeGuessCurrentCsd, <FAR, PUBLIC, ATOMIC>, <SI,DI>
cBegin	ImodeGuessCurrentCsd

	mov	di,OFF_lpwDataCsd

	cCall	FvmGetCur		;* get fvm

	push	ax
	cCall	ModeGetCur		;* al = mode, ah = ayMac (0=>unknown)
	pop	bx			;* bx = fvm

;*	* Search for current mode and fvm in rgdm

	mov	si,drvOffset lastdm	;* start from last (best) mode
	mov	cx,cdmMax
	mov	dx,cx
	dec	dx

;*	* al = current mode, ah = ayMac (or 0=>unknown)
;*	* bx = fvm
;*	* si = pdm
;*	* dx = idm = imode
;*	* cx = loop count

imgc_next:
	cmp	al,cs:[si].modeDm
	jne	@F
	test	bl,cs:[si].fvmReqAdapDm
	jz	@F				
	test	bh,cs:[si].fvmReqDispDm
	jz	@F			;* not available
	or	ah,ah
	jz	imgc_end		;* height unknown => use this one
	cmp	ah,cs:[si].ayMacDm
	jz	imgc_end		;* same height => use this one

@@:
	sub	si,size DM
	dec	dx
	loop	imgc_next
	mov	dx,-1			;* unknown
imgc_end:	;* dx = imode
	mov	ax,dx			;* guess this mode

cEnd	ImodeGuessCurrentCsd


;********** FQueryInstCsd **********
;*	* CSD entry point (see documentation for interface)

cProc	FQueryInstCsd, <FAR, PUBLIC, ATOMIC>, <si, di>
    parmDP pinst
    parmW imode
    localW fvm
cBegin	FQueryInstCsd

	mov	di,OFF_lpwDataCsd
	cCall	FvmGetCur	;* find out what we got ...
				;* will query hardware + codepage first call
	mov	fvm,ax

	mov	si,imode
	cmp	si,cdmMax
	jb	got_imode
fail_query:
	xor	ax,ax			;* failure
	jmp	end_qmode

got_imode: ;* si = imode
	mov	ax,SIZE DM
	mul	si
	mov	si,ax
	add	si,drvOffset rgdm		;* CS:SI => INST info

;*	* copy DM info into INST
	mov	di,pinst			;* ds:di => dest
;*	* clear out the INST structure
	push	di
	push	ds
	pop	es
	mov	cx,cbInstMin / 2
	xor	ax,ax
	rep stosw
	pop	di

;*	* move information from DM to INST
	;* finst
	mov	ax,fvm
	mov	dx,cs:[si].finstDm
	test	al,cs:[si].fvmReqAdapDm
	jz	@F
	test	ah,cs:[si].fvmReqDispDm
	jz	@F
	or	dx,finstAvailable	;* this mode is currently available
@@: ;* dx = finst
	mov	ds:[di].finstInst,dx

IFDEF EARLIER
	Assert	<ayMacDm EQ axMacDm+1>
	Assert	<ayMacInst EQ axMacInst+1>
	;* axMac, ayMac
	mov	dx,word ptr cs:[si].axMacDm
ELSE
	mov	dl,cs:[si].axMacDm
	mov	dh,cs:[si].ayMacDm
ENDIF
	mov	wo ds:[di].axMacInst,dx		;* move both axMac and ayMac

	;* mode index
	mov	dx,imode
	mov	ds:[di].imodeInst,dx

	;* coMac, covMac, coiMac
	mov	dl,cs:[si].coMacDm
	mov	ds:[di].coMacInst,dl
	cCall	CoiCovFromFvm			;* al = fvm
	mov	ds:[di].covMacInst,ah
	mov	ds:[di].coiMacInst,dx

	;* INFT information
	Assert	<dyCharDm EQ dxCharDm+1>
	Assert	<dyCharInft EQ dxCharInft+1>
	mov	dx,word ptr cs:[si].dxCharDm
	test	cs:[si].finstDm,finstGraphics	;!!!REVIEW
	jz	@F
	mov	word ptr ds:[di].inftInst.dxCharInft,dx
					;* move both dxChar and dyChar
@@:
	mov	dl,cs:[si].dyBaseDm
	mov	ds:[di].inftInst.dyBaseLineInft,dl
	mov	dl,cs:[si].ifontDm
	mov	ds:[di].inftInst.ifontInft,dl

	mov	dx,0FFFFh
	test	cs:[si].finstDm,finstFont
	jz	@F
	cmp	cs:[si].wExtraDm,0
	je	@F
	and	dx,NOT ffontOrUnderlineSupport	;not supported by Ramfont modes
@@:
	mov	ds:[di].ffontSupportedInst,dx

	;* Buffer info
	mov	ax,cs:[si].psVideoDm
	mov	ds:[di].psPrimInst,ax
	AssertEQ ds:[di].psSecInst,0
	AssertEQ ds:[di].cwExtraInst,0

;*	* set private info (store pointer to DM in the INST structure)
	mov	[di].pdmInst,si

	mov	ax,sp				;* ok
end_qmode:

cEnd	FQueryInstCsd


;********** FInitCsd **********
;*	entry:
;*		pinch = near pointer to INCH structure to fill
;*	* Initialize the screen to the given mode
;*	exit:	AX != 0 if ok

cProc	FInitCsd, <FAR, PUBLIC, ATOMIC>, <DI,SI>
    parmDP pinst
    parmDP pinch
    localB bRamFont
cBegin	FInitCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment

;*	* set mode
	mov	bx,pinst
	mov	[di].pinstDrv,bx
	mov	bx,ds:[bx].pdmInst		;* CS:BX => DM info

;*	* copy mode info into driver globals
	mov	ax,cs:[bx].vparmCursOnDm
	mov	[di].vparmCursOn,ax
	mov	[di].vparmCursSize,ax
	mov	ax,cs:[bx].wExtraDm
	mov	[di].wExtra,ax
	mov	bRamFont,al			;* save the RamFont info byte

	mov	dx,hgcConfig		
	mov	al,3				;* fake mouse
	out	dx,al

;set hgc full
	mov	dx,hgcIndex
	mov	ax,(20h SHL 8) OR exceptreg	;* reg 17
	test	cs:[bx].fInstDm,fInstMonochrome
	jnz	SetMono
	xor	ah,ah
SetMono:
	out	dx,ax

	test	cs:[bx].finstDm,fInstGraphics
	jz	notGraf

;*** Graphics mode
	
	xor	ah,ah
	mov	al,cs:[bx].dyCharDm		;points
	mov	[di].ayBox,ax

	mov	al,40h			;segBios
	mov	es,ax
	mov	di,49h			;CRT_MODE
	mov	byte ptr es:[di],5	;fake mode 6 for mouse sake
	mov	di,4Ah			;CRT_COLS
	mov	word ptr es:[di],90	;
	mov	di,84h			;CRT_ROWS
	mov	al,cs:[bx].ayMacDm 	;rows - 1
	dec	al
	mov	byte ptr es:[di],al	
		
	mov	dx,hgcControl		;set graphics mode
	mov	al,fHercGr
	out	dx,al
	mov	dx,hgcIndex		;write index register
	mov	cx,16
	xor	bx,bx
IN9hLp:
	mov	ah,cs:GTABLE[bx]	
	mov	al,bl
	out	dx,ax
	jmp	$ + 2
	inc	bx
	loop	IN9hLp

	mov	ch,40h
	mov	ax,0B800h
	mov	es,ax
	xor	di,di
	mov	ax,di
	rep	stosw
	mov	ax,fHercGr
	push	ax
	jmp	FInitRet

;*** Text mode

notGraf:
	xor	ah,ah
	mov	al,40h
	mov	es,ax
	mov	si,49h			;CRT_MODE
	mov	byte ptr es:[si],7	
	mov	si,4Ah			;CRT_COLS
	mov	al,cs:[bx].axMacDm
	mov	word ptr es:[si],ax	
	mov	si,84h			;CRT_ROWS
	mov	al,cs:[bx].ayMacDm 	;rows - 1
	dec	al
	mov	byte ptr es:[si],al	

	mov	si,drvOffset rgbInit	;default 80x25 (9x14 font)
	cmp	cs:[bx].ayMacDm,35	
	jne	@F
	add	si,cRegInit		;use 90x35 (8x10 font) 
@@:
	mov	ax,fHercTxt
	push	ax			; save mode byte
	mov	dx,hgcControl		; set to graphics or text mode...
	out	dx,al			;   ... with video off

	mov	dx,hgcIndex		; initialize 6845 chip with table
	mov	cx,cRegInit		;
	xor	ah,ah			;
	cld				;
SMloop:
	mov	al,ah			;
	out	dx,al			; send register number to index port
	inc	dx			;
	lods	byte ptr cs:[si]	; get byte of data to send
	out	dx,al			; and send it to index+1
	jmp	$ + 2			; WARNING -- THIS DELAY IS REQUIRED
	jmp	$ + 2			; FOR 8MHz ATs!
	inc	ah			;
	dec	dx			;
	loop	SMloop			; loop until all 16 bytes are output

	;dx = hgcIndex
IF (GB112CSD OR GB222CSD)
	mov	al,bRamFont
	cmp	al,16
	je	Init8x10Color
	cmp	al,14
	je	Init9x14
	cmp	al,10
	je	Init8x10
ENDIF

;select ROM character generator
	MOV	AX,(0) OR xmodereg
	OUT	DX,AX

;set underscore at 14
	MOV	AX,(13 SHL 8) OR scorereg
	OUT	DX,AX

IF (GB112CSD OR GB222CSD)
	jmp	short FInitRet

Init8x10Color:
	cCall	Init4KRamFont8x10
	jmp	short FInitRet

Init8x10:
	cCall	InitRamFont8x10
	jmp	short FInitRet

Init9x14:
	cCall	InitRamFont9x14
ENDIF

;*	* the INCH array already contains the standard Code Page 437
;*	*  character set, so it usually can be left the same.

FInitRet:
	pop	ax			; now turn video on
	or	al,fHercVideo		;
	mov	dx,hgcControl		;
	out	dx,al			;

	mov	ax,sp				;* success
cEnd	FInitCsd


IF (GB112CSD OR GB222CSD)

;********** InitRamFont9x14 **********
;*	Loads the RamFont memory with the 9x14 fonts
;*	entry:	DX = hgcIndex

cProc	InitRamFont9x14, <NEAR>, <ds, si, di>
cBegin	InitRamFont9x14

;* This code is from QINTER (MCV9X14.ASM):

;select 48k ramfont
	MOV	AX,(ramfont_48k_9d SHL 8) OR xmodereg
	OUT	DX,AX

;set underscore at 14
	MOV	AX,(13 SHL 8) OR scorereg
	OUT	DX,AX

;set overstrike at 13, it becomes double underline
	MOV	AX,(12 SHL 8) OR strikereg
	OUT	DX,AX

;load the fonts into ramfont memory
;first, clear all of ramfont memory
	mov	bx,ramfont_seg
	mov	es,bx
	MOV	CX,6000H
	XOR	AX,AX
	MOV	DI,AX
rep	stosw

;load the normal font into t8
	mov	bx,cs
	mov	ds,bx
	mov	si,offset rgbHercFont9x14
	mov	di,7000h
	mov	bx,256

mak_norm:
	MOV	CL,7			; CH = 0 from last REP
rep	movsw
	INC	DI
	INC	DI
	dec	bx
	jnz	mak_norm

;copy the normal font into t9
	mov	bx,es
	mov	ds,bx
	mov	di,8000h
	mov	si,7000h
	MOV	CH,8			; CL = 0 from last REP
rep	movsw

;create the normal strike font
	mov	di,8000h + 7
	MOV	CH,1			; CL = 0 from last REP
	mov	ax,0ffh

make_str:
	stosb
	add	di,15
	loop	make_str

;create the superscript font
	mov	di,2000h
	mov	si,7000h + 1
	MOV	CH,1			; CL = 0 from last REP

mak_super:
	movsw
	INC	SI
	movsw
	movsw
	INC	SI
	movsw
	movsw
	add	si,4
	add	di,6
	loop	mak_super

;fix a few individual characters to be acceptable
;start with the lower case superscript e
	mov	di,2650h + 6
	mov	al,60h
	stosb

;fix the lower case superscript j
	mov	di,26a0h + 6
	mov	al,36h
	stosb
	mov	al,1ch
	stosb
	XOR	AL,AL
	MOV	CL,3			; CH = 0 from last LOOP
rep	stosb

;fix the lower case superscript s
	mov	di,2730h + 3
	mov	al,3eh
	stosb
	mov	al,60h
	stosb
	mov	al,3eh
	stosb
	mov	al,3
	stosb
	mov	al,3eh
	stosb

;create the superscript+overstrike font
	mov	si,2000h
	mov	di,3000h
	MOV	CH,8			; CL = 0 from last REP
rep	movsw
	mov	di,3000h + 4
	mov	ax,0ffh
	MOV	CH,1			; CL = 0 from last REP

mak_sup_str:
	stosb
	add	di,15
	loop	mak_sup_str

;create the subscript font
	mov	di,6000h + 6
	mov	si,2000h
	mov	cx,800h - 3
rep	movsw

;help a few of the subscripted characters to look better
;start with the subscripted lower case g
	mov	di,6670h + 6 - 2	;shift up by 2
	mov	si,6670h + 6
	MOV	CL,5			; CH = 0 from last REP
	XOR	AX,AX
rep	movsw
	stosw
;fix the subscripted lower case p
	mov	di,6700h + 6 - 2	;shift up by 2
	mov	si,6700h + 6
	MOV	CL,5			; CH = 0 from last REP
rep	movsw
	stosw

;fix the subscripted lower case q
	mov	di,6710h + 6 - 2	;shift up by 2
	mov	si,6710h + 6
	MOV	CL,5			; CH = 0 from last REP
rep	movsw
	stosw

;fix the subscript lower case y
	mov	di,6790h + 6 - 2	;shift up by 2
	mov	si,6790h + 6
	MOV	CL,5			; CH = 0 from last REP
rep	movsw
	stosw

;create the subscript+overstrike font
	mov	di,9000h
	mov	si,6000h
	MOV	CH,8			; CL = 0 from last REP
rep	movsw
	mov	di,9000h + 10
	NOT	AL			; AX = 0FFH
	MOV	CH,1			; CL = 0 from last REP

mak_sub_str:
	stosb
	add	di,15
	loop	mak_sub_str

;create the italic font
mak_ital:
	mov	ax,ramfont_seg
	mov	es,ax
	mov	ds,ax
	cld
	mov	si,7000h
	XOR	DI,DI
	mov	cx,800h
rep	movsw
	mov	bx,256
	XOR	SI,SI
	MOV	DI,SI

itals0:
	MOV	CL,5			; CH = 0 from last REP

itals1:
	lodsb
	shr	al,1
	stosb
	loop	itals1
	add	di,3
	add	si,3
	MOV	CL,4			; CH = 0 from last REP

itals2:
	lodsw
	shl	al,1
	shl	ah,1
	stosw
	loop	itals2
	dec	bx
	jnz	itals0

;create the italics+overstrike font

do_ital_str:
	mov	di,1000h
	XOR	SI,SI
	MOV	CH,8			; CL = 0 from last LOOP
rep	movsw
	MOV	CH,1			; CL = 0 from last REP
	mov	ax,0ffh
	mov	di,1000h + 7

mak_ital_str:
	stosb
	add	di,15
	loop	mak_ital_str

;create the superscript+italics font
	mov	di,4000h
	mov	si,2000h
	MOV	CH,8			; CL = 0 from last LOOP
rep	movsw
	mov	si,4000h
	MOV	DI,SI
	MOV	CH,1			; CL = 0 from last REP

mak_sup_ital:
	push	cx
	lodsw
	shr	ah,1
	shr	al,1
	stosw
	lodsb
	shr	al,1
	stosb
	INC	SI
	INC	SI
	INC	DI
	INC	DI
	mov	cx,4

sh_lft:
	lodsw
	shl	ah,1
	shl	al,1
	stosw
	loop	sh_lft
	add	si,3
	add	di,3
	pop	cx
	loop	mak_sup_ital

;create the superscript+italics+overstrike font
	mov	si,4000h
	mov	di,5000h
	MOV	CH,8			; CL = 0 from last LOOP
rep	movsw
	mov	di,5000h + 4
	mov	ax,0ffh
	MOV	CH,1			; CL = 0 from last REP

mak_sup_istr:
	stosb
	add	di,15
	loop	mak_sup_istr

;create the subscript+italics font
	mov	di,0a000h + 6
	mov	si,4000h
	mov	cx,800h - 3
rep	movsw

;help a few of the subscripted characters to look better
;start with the subscripted lower case g
	mov	di,0a670h + 6 - 2	;shift up by 2
	mov	si,0a670h + 6
	MOV	CL,5			; CH = 0 from last REP
	XOR	AX,AX
rep	movsw
	stosw
;fix the subscripted lower case p
	mov	di,0a700h + 6 - 2	;shift up by 2
	mov	si,0a700h + 6
	MOV	CL,5			; CH = 0 from last REP
rep	movsw
	stosw

;fix the subscripted lower case q
	mov	di,0a710h + 6 - 2	;shift up by 2
	mov	si,0a710h + 6
	MOV	CL,5			; CH = 0 from last REP
rep	movsw
	stosw

;fix the subscript lower case y
	mov	di,0a790h + 6 - 2	;shift up by 2
	mov	si,0a790h + 6
	MOV	CL,5			; CH = 0 from last REP
rep	movsw
	stosw

;create the subscript+italics+overstrike font
	mov	di,0b000h
	mov	si,0a000h
	MOV	CH,8			; CL = 0 from last REP
rep	movsw
	mov	di,0b000h + 10
	NOT	AL			; AX = 0FFH
	MOV	CH,1			; CL = 0 from last REP

mak_sub_ita_str:
	stosb
	add	di,15
	loop	mak_sub_ita_str

;make the mini caps font
	mov	si,2410h
	mov	di,2010h
	XOR	AX,AX
	stosw
	stosb
	MOV	CL,26 * 8 - 2		; CH = 0 from last LOOP
rep	movsw

;make the mini caps+overstrike font
	mov	si,3410h
	mov	di,3010h
	stosw
	stosb
	MOV	CL,26 * 8 - 2		; CH = 0 from last REP
rep	movsw

;make the mini caps italics characters
	mov	si,4410h
	mov	di,4010h
	stosw
	stosb
	MOV	CL,26 * 8 - 2		; CH = 0 from last REP
rep	movsw

;make the mini caps and italics overstrike font
	mov	si,5410h
	mov	di,5010h
	stosw
	stosb
	MOV	CL,26 * 8 - 2		; CH = 0 from last REP
rep	movsw

cEnd	InitRamFont9x14


;********** InitRamFont8x10 **********
;*	Loads the RamFont memory with the 8x10 fonts

cProc	InitRamFont8x10, <NEAR>, <ds, si, di>
cBegin	InitRamFont8x10

;* This code is from QINTER (MCV9X14.ASM):

;select 48k ramfont
	MOV	AX,(ramfont_48k_8d SHL 8) OR xmodereg	
	OUT	DX,AX

;set underscore at 10
	MOV	AX,(9 SHL 8) OR scorereg
	OUT	DX,AX

;set overstrike at 9
	MOV	AX,(8 SHL 8) OR strikereg
	OUT	DX,AX

;load the fonts into ramfont memory
;first clear all of ramfont memory
	mov	bx,ramfont_seg		; 0b400h
	mov	es,bx
	MOV	CX,6000H		;  
	XOR	AX,AX
	MOV	DI,AX			; start from b000:4000
rep	stosw

;load the normal font into t8
;	mov	bx,segROM
	mov	bx,0f000h		; PC ROM Fonts (0-127)
	mov	ds,bx
;	mov	si,offset rgFont
	mov	si,0fa6eh
	mov	di,7000h + 1		;t8
	mov	bx,128

norm88:
	MOV	CL,4			; CH = 0 from last REP
rep	movsw
	add	di,8
	dec	bx
	jnz	norm88

	mov	bx,cs			; Hard coded Fonts (128-255)
	mov	ds,bx
	mov	si,offset rgbHercExFont8x10
	mov	bx,128
	dec	di

norm188:
	MOV	CL,5			; CH = 0 from last REP
rep	movsw
	add	di,6
	dec	bx
	jnz	norm188

;copy the normal font into t9
	mov	bx,es
	mov	ds,bx
	mov	di,8000h		;t9
	mov	si,7000h
	MOV	CH,8			; CL = 0 from last REP
rep	movsw

;create the normal strike font
	mov	di,8000h + 4
	MOV	CH,1			; CL = 0 from last REP
	NOT	AL			; AX = 0FFH

norm_str88:
	stosb
	add	di,15
	loop	norm_str88

;create the superscript font
	mov	si,7000h + 1
	mov	bx,256
	mov	di,2000h
	XOR	AX,AX

super88:
	movsb				;0 = 1 pos
	inc	si
	movsw
	movsb
	inc	si
	movsw
	MOV	CL,4			; CH = 0 from last LOOP
rep	stosw
	INC	DI
	INC	DI
	add	si,8
	dec	bx
	jnz	super88

;fix some of the superscript characters to look acceptable
	mov	al,30h
	mov	di,2670h + 3
	or	es:[di],al	;fix the superscript g
	mov	di,2700h + 3
	or	es:[di],al	;fix the superscript p
	mov	di,2710h + 3
	or	es:[di],al	;fix the superscript q
	mov	di,2790h + 3
	or	es:[di],al	;fix the superscript y

;fix the superscript Q
	mov	di,2510h
	mov	al,78h
	stosb
	MOV	AX,0CCCCH
	STOSW
	mov	al,0d8h
	stosb
	mov	al,7ch
	stosb
	mov	al,06h
	stosb

;fix the superscript e
	mov	di,2650h
	XOR	AL,AL
	stosb
	mov	al,78h
	stosb
	mov	al,0fch
	stosb
	mov	al,0c0h
	stosb
	mov	al,78h
	stosb

;create the superscript+overstrike font
	mov	di,3000h
	mov	si,2000h
	MOV	CH,8			; CL = 0 from last REP
rep	movsw
	mov	di,3000h + 2
	mov	ax,0ffh
	MOV	CH,1			; CL = 0 from last REP

sup_str88:
	stosb
	add	di,15
	loop	sup_str88

;create the subscript font
	mov	di,6000h + 5
	mov	si,2000h
	mov	cx,800h - 3
rep	movsw

;create the subscript+overstrike font
	mov	di,9000h + 5
	mov	si,3000h
	mov	cx,800h - 3
rep	movsw

;create the italics font using an algorithm

mak8_ital:
	cld
	mov	ax,ramfont_seg
	mov	es,ax
	mov	ds,ax
	XOR	DI,DI
	mov	si,7000h
	mov	cx,800h
rep	movsw
	XOR	DI,DI
	MOV	SI,DI
	mov	bx,256

itals_88:
	lodsb
	shr	al,1
	shr	al,1
	stosb
	lodsw
	shr	al,1
	shr	ah,1
	stosw
	INC	DI
	INC	DI
	mov	si,di
	MOV	CL,3			; CH = 0 from last REP

ital_881:
	lodsw
	shl	al,1
	shl	ah,1
	stosw
	loop	ital_881
	add	di,5
	mov	si,di
	dec	bx
	jnz	itals_88

;create the italics+overstrike font

do8_ital_str:
	mov	di,1000h
	XOR	SI,SI
	MOV	CH,8			; CL = 0 from last LOOP
rep	movsw
	MOV	CH,1			; CL = 0 from last REP
	mov	ax,0ffh
	mov	di,1000h + 4

mak8_ital_str:
	stosb
	add	di,15
	loop	mak8_ital_str

;create the superscript+italics font
	mov	si,2000h
	mov	di,4000h
	MOV	CH,8			; CL = 0 from last LOOP
rep	movsw
	mov	si,4000h
	MOV	DI,SI
	mov	bx,256

ital_sup88:
	lodsw
	shr	al,1
	shr	ah,1
	stosw
	INC	DI
	INC	DI
	INC	SI
	INC	SI
	MOV	CL,3			; CH = 0 from last REP

shl_sup:
	lodsw
	shl	al,1
	shl	ah,1
	stosw
	loop	shl_sup
	add	di,6
	mov	si,di
	dec	bx
	jnz	ital_sup88

;create the superscript+italics+overstrike font
	mov	di,5000h
	mov	si,4000h
	MOV	CH,8			; CL = 0 from last LOOP
rep	movsw
	mov	di,5000h + 2
	MOV	CH,1			; CL = 0 from last REP
	mov	ax,0ffh

sup_ita_ovr:
	stosb
	add	di,15
	loop	sup_ita_ovr

;create the subscript+italics font
	mov	di,0a000h + 5
	mov	si,4000h
	mov	cx,800h - 3
rep	movsw

;create the subscript+italics+overstrike font
	mov	di,0b000h + 5
	mov	si,5000h
	mov	cx,800h - 3
rep	movsw

;make the mini caps font
	mov	si,2410h
	mov	di,2010h
	XOR	AX,AX
	stosw
	stosb
	MOV	CL,26 * 8 - 1		; CH = 0 from last REP
rep	movsw

;make the mini+overstrike font
	mov	si,3410h
	mov	di,3010h
	stosw
	stosb
	MOV	CL,26 * 8 - 1		; CH = 0 from last REP
rep	movsw

;make the mini+italics font
	mov	si,4410h
	mov	di,4010h
	stosw
	stosb
	MOV	CL,26 * 8 - 1		; CH = 0 from last REP
rep	movsw

;make the mini+italics+overstrike font
	mov	si,5410h
	mov	di,5010h
	stosw
	stosb
	MOV	CL,26 * 8 - 1		; CH = 0 from last REP
rep	movsw

Exit8x10:
cEnd	InitRamFont8x10


;********** Init4KRamFont8x10 **********
;*	Loads the RamFont memory with the 8x10 fonts

cProc	Init4KRamFont8x10, <NEAR>, <ds, si, di>
cBegin	Init4KRamFont8x10

;* This code is from QINTER (MCV9X14.ASM):

;select 4k ramfont
	mov	dx,hgcIndex
	MOV	AX,(ramfont_4k_8d SHL 8) OR xmodereg	
	OUT	DX,AX

;make RAM at B000:4000 addressable
	mov	dx,hgcConfig		
	mov	al,1				
	out	dx,al

;set underscore at 10
	MOV	AX,(9 SHL 8) OR scorereg
	OUT	DX,AX

;set overstrike at 9
	MOV	AX,(8 SHL 8) OR strikereg
	OUT	DX,AX

;* load the fonts into ramfont memory

;first clear all of ramfont memory
	mov	bx,ramfont_seg		; 0b400h
	mov	es,bx
	mov	cx,800h			; 4K
	XOR	AX,AX
	MOV	DI,AX			; start from b000:4000
	rep	stosw

;load the normal font 
	mov	bx,0f000h		; PC ROM Fonts (0-127)
	mov	ds,bx
	mov	si,0fa6eh
	mov	di,1			
	mov	bx,128
L0_127:
	MOV	CL,4			; 8 bytes-map/char
rep	movsw				
	add	di,8			; 16 bytes/char 
	dec	bx
	jnz	L0_127

;;;	di points to Ex128
	mov	bx,cs			; Hard coded Fonts (128-255)
	mov	ds,bx
	mov	si,offset rgbHercExFont8x10
	mov	bx,128
	dec	di
L128_255:
	MOV	CL,5			; 10 bytes-map/char
rep	movsw
	add	di,6			; 16 bytes/char
	dec	bx
	jnz	L128_255

cEnd	Init4KRamFont8x10

ENDIF 	;(GB112CSD OR GB222CSD)


;********** MoveHwCursCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* Standard BIOS call for hardware cursor
;*	* save new position in "posCurs"

cProc	MoveHwCursCsd,<FAR, PUBLIC, ATOMIC>, <DI>
    parmB axCurs
    parmB ayCurs
    parmW fOn
    localB axCursor
    localB ayCursor
cBegin	MoveHwCursCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment

;*	* move cursor position
	mov	bh,0
	mov	dh,ayCurs
	mov	dl,axCurs

	mov	bx,[di].pinstDrv
	mov	al,dh
	mul	[bx].axMacInst
	xor	dh,dh
	add	ax,dx
	mov	dx,hgcIndex
	mov	bl,al
	mov	al,14
	out	dx,ax
	mov	ah,bl
	mov	al,15
	out	dx,ax				;* SetCursorPosition

	mov	ax,2000H			;* assume off
	mov	byte ptr [di].fCurs,0		;* graphics cursor 
	cmp	fOn,0
	je	SetCursorOnOff			;* turn off

	mov	bx,[di].pinstDrv
	test	ss:[bx].finstInst,finstGraphics	;graphics text 8x14
	jz	DrawCursDone

	mov	dx,[di].posCurs		;dl = axFirst
	mov	ayCursor,dh
	mov	axCursor,dl
	xor	cx,cx			;fRestoreDbcs
	mov	ah,cl
	mov	al,90
	mul	dh
	mov	dh,cl
	add	ax,dx			
	shl	ax,1			;ax = offFirst
	mov	dx,1
	cCall	<Near ptr DoUpdateCsd>, <ayCursor,axCursor,dx,ax,cx,cs>	;erase cursor
	xor	cx,cx
	mov	dh,ayCurs
	mov	dl,axCurs
	mov	[di].posCurs,dx		;update position
	mov	ah,cl
	mov	al,90
	mul	dh
	mov	dh,cl
	add	ax,dx
	shl	ax,1			;ax = offFirst
	mov	dx,1
	mov	byte ptr [di].fCurs,1		;* graphics cursor on
	cCall	<Near ptr DoUpdateCsd>, <ayCurs,axCurs,dx,ax,cx,cs>		;draw cursor

DrawCursDone:
	mov	ax,[di].vparmCursOn		;* turn on
SetCursorOnOff:
	mov	bl,al
	mov	al,10
	mov	dx,hgcIndex
	out	dx,ax
	mov	ah,bl
	mov	al,11
	out	dx,ax				;* SetCursorType

cEnd	MoveHwCursCsd


;********** DoUpdateCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* BIOS version: update the screen

cProc	DoUpdateCsd,<FAR, PUBLIC, ATOMIC>, <DS, SI, DI>
    parmB ayLine
    parmB axFirst
    parmB dax
    parmW offFirst
    parmW fRestoreDbcs
    localB axCurs
    localB axCurrent
    localW wTemp
    localW wSec
    localB bLastAttr
    localB curattr
    LocalV LocalChar,14
cBegin	DoUpdateCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment

IF (GB112CSD OR GB222CSD)
	cmp	[di].wExtra,0
	jne	UpdateRamFont
	jmp	CheckGrafText

UpdateRamFont:
	mov	bx,[di].pinstDrv
	test	ds:[bx].finstInst, finstMonoChrome
	jnz	@F
	jmp	DoUpdateExit			;* 16 color mode (90x35)
@@:
	mov	ah,ds:[bx].axMacInst
	mov	dx,ds:[bx].psSecInst		;* DX:SI => secondary buffer
	mov	ds,ds:[bx].psPrimInst		;* DS:SI => primary buffer
	mov	si,offFirst

	mov	cx,text_buf_seg
	mov	es,cx
	mov	al,ayLine
	mul	ah
	shl	ax,1
	xor	ch,ch
	mov	cl,axFirst
	add	ax,cx
	add	ax,cx
	mov	di,ax				;* ES:DI => video buffer

;*	* DS:SI => start character in primary buffer
;*	* DX:SI => start character in secondary buffer
;*	* ES:DI => start character in video buffer

;*	* copy all characters to screen

	mov	cl,dax
loop_update:
	lodsw					;* al = char, ah = attr

	;*	* Need to adjust attribute byte here
	xor	ch,ch				;* start with normal attributes
	cmp	ah,070h				;* check for reverse video
	jne	NotRevVideo
	or	ch,hrev
NotRevVideo:
	and	dx,dx
	jnz	ChkFonts

	;*	* no secondary buffer, check normal display attributes
	test	ah,40h
	jz	NotBoldAttr
	or	ch,hbold
NotBoldAttr:
	cmp	al,176
	jl	ChkUnderline
	cmp	al,223
	jle	NotUnderlineAttr
ChkUnderline:
	mov	bh,ah
	and	bh,07h
	cmp	bh,01h
	jne	NotUnderlineAttr
	or	ch,hunder
NotUnderlineAttr:
	jmp	jus_normal

ChkFonts:
	push	ds
	mov	ds,dx
	mov	ah,ds:[si-2]			;* get ffont byte
	pop	ds
	test	ah,ffontBold
	jz	NotBold
	or	ch,hbold
NotBold:
	
;deal with graphics characters mapping, first
	cmp	al,176
	jl	not_graph
	cmp	al,223
	jg	not_graph
	jmp	jus_normal

not_graph:
	test	ah,ffontUnderline
	jz	NotUnderline
	or	ch,hunder
NotUnderline:
	test	ah,ffontDoubleUnderline
	jz	NotDoubleUnderline
	or	ch,hstrike OR hunder	; StrikeThrough is the second underline
NotDoubleUnderline:

	test	ah,ffontSuperScript
	jz	chk_sub
	test	ah,ffontSubScript
	jz	chk_control

	;*	* SuperScript+SubScript = MiniCaps
	;*	* check for a valid minicaps character
	cmp	al,'A'
	jl	chk_italics
	cmp	al,'Z'
	jg	chk_italics
	sub	al,40h		; adjust ascii code to point to right position
				; in the superscript font which
				; contains minicaps characters
	jmp	SHORT do_super_mini

;if superscript control code ascii characters then map to normal font

chk_control:
	cmp	al,27
	jle	do_normal

;its superscript or minicaps

do_super_mini:
	test	ah,ffontItalic	;check for super+italics
	jnz	do_sup_ital
	test	ah,ffontStrikeThrough	;check for super+strike
	jz	just_sup
	add	ch,font4	;its super+overstrike
	jmp	SHORT store_char

just_sup:
	add	ch,font3	;its just superscript
	jmp	SHORT store_char

;its superscript+italics

do_sup_ital:
	test	ah,ffontStrikeThrough	;check for super+italics+over
	jz	jus_sup_ita
	add	ch,font6	;its super+italics+overstrike
	jmp	SHORT store_char

jus_sup_ita:
	add	ch,font5	;its super+italics
	jmp	SHORT store_char

;check for subscripted characters

chk_sub:
	test	ah,ffontSubScript
	jz	chk_italics
	test	ah,ffontItalic	;check for subscript+italics
	jnz	do_sub_ital
	test	ah,ffontStrikeThrough	;check for subscript+overstrike
	jz	just_sub
	add	ch,font10	;its the subscript+overstrike font
	jmp	SHORT store_char

;its just subscript

just_sub:
	add	ch,font7
	jmp	SHORT store_char

;its subscript+italics

do_sub_ital:
	test	ah,ffontStrikeThrough	;check for subscript+italics+overstrike
	jz	jus_sub_ita
	add	ch,font12
	jmp	SHORT store_char

;its just subscript+italics

jus_sub_ita:
	add	ch,font11
	jmp	SHORT store_char

;check for normal italics characters

chk_italics:
				; The following = TEST AH,mitalic
	test	ah,ffontItalic	;check for italics characters
	jz	do_normal
	test	ah,ffontStrikeThrough	;check for italics+overstrike
	jz	jus_italics
	add	ch,font2
	jmp	SHORT store_char

;its just the normal italics font

jus_italics:
	add	ch,font1
	jmp	SHORT store_char

;its the normal character set

do_normal:
	test	ah,ffontStrikeThrough	;check for normal+overstrike
	jz	jus_normal
	add	ch,font9	;its normal+overstrike
	jmp	SHORT store_char

;its the normal font

jus_normal:
	add	ch,font8

;store the character and attributes
store_char:
	mov	ah,ch
OColor8x10:
	stosw
	dec	cl
	jz	DoUpdateRet
	jmp	loop_update

DoUpdateRet:
	jmp	DoUpdateExit
	
CheckGrafText:
ENDIF	;(GB112CSD OR GB222CSD)

	mov	bx,[di].pinstDrv
	test	[bx].finstInst,finstGraphics
	jnz	UpdateGrafText
	jmp	DoUpdateExit

	;***************************
	;*     			   *
	;*	Graphics Text	   *
	;*			   *
	;***************************

UpdateGrafText:
	mov	ax,[di].posCurs			;for cursor drawing
	mov	axCurs,-1
	mov	axCurrent,0
	cmp	byte ptr [di].fCurs,0		;cursor on ?
	je	NoCursUpdate

	cmp	ah,ayLine			;check if cursor on ayLine
	jne	NoCursUpdate

	cmp	al,axFirst			;check if cursor outside axFirst
	jb	NoCursUpdate

	mov	axCurs,al			;need to update cursor
	mov	al,axFirst
	mov	axCurrent,al
NoCursUpdate:	
	mov	dx,ds:[bx].psSecInst		;* DX:SI => secondary buffer
	mov	wSec,dx
	mov	ds,ds:[bx].psPrimInst		;* DS:SI => primary buffer
	mov	si,offFirst

;*	* DS:SI => start character in primary buffer
;*	* DX:SI => start ffont in secondary buffer

	;find cursor position (pixel starting address)		
	mov	cl,ss:[bx].axMacInst		;screen width
	mov	al,ayLine 
	xor	ah,ah
	mul	cl
	mov	cx,ax
	shl	ax,1			;mul 2
	xor	dh,dh
	mov	dl,axFirst
	add	ax,dx
	cmp     ss:[di].ayBox,14
	jne	SkipShl
	
	mov	ax,cx
	shl	ax,1
	shl	ax,1
	shr	cx,1
	sub	ax,cx			;mul 3.5
	add	ax,dx
	test	ayLine,1	    	;even - plane 0,odd - plane 2
	jz	SkipShl
	
	add	ax,4000h - 45
SkipShl:
	mov	di,ax			;* ES:DI => video buffer (pixel address)

	mov	bLastAttr,0
	xor	ch,ch
	mov	cl,dax			;# of characters to be updated

out_next_char:
	lodsw			;ah - attr, al - char
	mov	curattr,ah		;save color attribute
	push	cx		;save dax
	push	ds		;save pointer to primary buffer
	push	si			
	mov	wTemp,di		;save video address
	mov	di,OFF_lpwDataCsd
	test	ss:[bx].finstInst,fInstMonoChrome
	jnz	SameAttr

	cmp	ah,bLastAttr
	je	SameAttr		
					;* update color attribute
	mov	bLastAttr,ah
	mov	cx,ax
	mov	dx,hgcIndex
	mov	al,1Ah			;* write color register
	out	dx,ax
	mov	ax,cx			;* restore attribute

SameAttr:
	mov	cx,cs
	mov	ds,cx			;DS:[SI] -> char table
	mov	cx,ss:[di].ayBox
	mov	si,drvOffset rgbHercFont8x14
	cmp	cl,8
	jne	First128

	mov	dx,ax
	mov	ax,0F000h		;System Font Table (8x8)
	mov	ds,ax
	mov	ax,dx
	mov	si,0FA6Eh
	cmp	al,80h
	jb	First128

	sub	al,80h
	mov	si,drvOffset rgbHercExFont8x8
	push	cs
	pop	ds
First128:
	mov	dx,ax			;save char + attribute
	xor	ah,ah
	mul	cl
	add	si,ax			

	mov	ax,ss
	mov	es,ax
	lea	di,LocalChar			;es:[di] -> local storage
	rep	movsb  	   			;copy char bit map into local area
	mov	di,OFF_lpwDataCsd		;restore points
	mov	cx,ss:[di].ayBox	
	test	ss:[bx].finstInst,finstMonochrome	;Test for mono
	jz	@F
	cmp	curattr,70H			;highlighting ?
	jne	@F

	lea	si,LocalChar
loopnot:
	not	byte ptr ss:[si]
	inc	si
	loop	loopnot
	mov	cx,ss:[di].ayBox	
@@:	
	mov	ds,ax				;DS:[SI] -> local storage
	lea	si,LocalChar

	cmp	wSec,0			;check Sec. buffer
	je	notFont			;****

	test	ss:[bx].finstInst,finstFont	;FFont mode ?
	jz	notFont	

	pop	di			;si -> di (buffer offset)
	push	di	

	mov	ax,wSec
	mov	es,ax			;ES:[DI-2] -> ffont buffer
	mov	al,dl			;restore character
	mov	dx,es:[di-2]		
	or	dl,dl
	jz	notFont

	cmp	al,' ' 			;check spaces
	jne	notspace1
	
	test	dl,ffontUnderline or ffontDoubleUnderline or ffontStrikeThrough or ffontOrCharacter
	jz	notfont

notspace1:
	cCall	ChrisPFont 
notFont:
	mov	cx,0B800h		;video seg
	mov	es,cx
	mov	di,OFF_lpwDataCsd		;restore points
	mov	cx,ss:[di].ayBox	;restore points

	mov	al,axCurrent		;cursor position ?
	cmp	al,axCurs
	jne	CursOff1

	push	cx
	push	si
	mov	cx,ss:[di].vparmCursOn
	xchg	ch,cl
	xor	ch,ch
	add	si,cx
	mov	cx,ss:[di].vparmCursOn
	sub	cl,ch
	xor	ch,ch
outCurs1:				;display the cursor
	not	byte ptr [si]
	inc	si
	loop	outCurs1
	pop	si
	pop	cx

CursOff1:
	shr	cl,1
	mov	di,wTemp
	mov	ax,2000h - 1
OC9Lp:
	movsb				; And put back to screen memory
	ADD	DI,AX			; Move down to next scan line
	movsb				; And put back to screen memory
	ADD	DI,AX			; Move down to next scan line
	cmp	di,8000h
	jb	OC9lp0

	ADD	DI,90 - 8000H
OC9lp0:
	loop	OC9Lp

	mov	di,wTemp
	inc	di
	inc	axCurrent		;bump update position
	pop	si
	pop	ds
	pop	cx
	dec	cx
	jz	DoUpdateExit
	jmp	out_next_char
		
DoUpdateExit:

	mov	di,OFF_lpwDataCsd		;* Data in data segment
	mov	bx,[di].pinstDrv
	test	ss:[bx].finstInst,fInstMonoChrome
	jnz	@F
	mov	ax,0F1Ah		;* restore color register (1Ah) to
	mov	dx,hgcIndex		;* default color (0Fh = mono)
	out	dx,ax
@@:
cEnd	DoUpdateCsd

	CPF814 = 1
	include cpfont.asm		;* ChrisPFont with 8x8,8x14



;********** TermCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* normally a no-op

cProc	TermCsd, <FAR, PUBLIC, ATOMIC>, <di,si>
cBegin	TermCsd

;* resume text mode 80x25
	xor	ah,ah			; update Bios data
	mov	al,40h
	mov	es,ax
	mov	di,49h			;CRT_MODE
	mov	byte ptr es:[di],7
	mov	di,4Ah			;CRT_COLS
	mov	word ptr es:[di],80	
	mov	di,84h			;CRT_ROWS
	mov	byte ptr es:[di],24	

	mov	si,drvOffset rgbInit	;default 80x25 (9x14 font)
	mov	ax,fHercTxt
	mov	dx,hgcControl		; set to graphics or text mode...
	out	dx,al			;   ... with video off

	mov	dx,hgcIndex		; initialize 6845 chip with table
	mov	cx,cRegInit		;
	xor	ah,ah			;
	cld				;
TermLp:
	mov	al,ah			;
	out	dx,al			; send register number to index port
	inc	dx			;
	lods	byte ptr cs:[si]	; get byte of data to send
	out	dx,al			; and send it to index+1
	jmp	$ + 2			; WARNING -- THIS DELAY IS REQUIRED
	jmp	$ + 2			; FOR 8MHz ATs!
	inc	ah			;
	dec	dx			;
	loop	TermLp			; loop until all 16 bytes are output

;select ROM character generator
	MOV	AX,(0) OR xmodereg
	OUT	DX,AX

;set underscore at 14
	MOV	AX,(13 SHL 8) OR scorereg
	OUT	DX,AX

;resume monochrome
	mov	ax,(20h SHL 8) OR exceptreg	;* reg 17
	out	dx,ax

	mov	ax,fHercTxt
	or	al,fHercVideo		;turn video on
	mov	dx,hgcControl		;
	out	dx,al			;

	mov	ah,1			;set cursor shape
	mov	cx,0C0Dh		
	int	10h

cEnd	TermCsd

;*****************************************************************************

IF (GB112CSD OR GB222CSD)
	include	Herc9x14.inc
	include	Herc8x10.inc
ENDIF
	include	Herc8x14.inc
	include	Herc8x8.inc

;*****************************************************************************

	include	csd_std.asm		;* standard init/term

	include	csd_ibm.asm		;* IBM specific routines

;*****************************************************************************

	include	csd_vram.asm		;* default procs for direct video I/O

	include	csd_save.asm		;* default screen save (none)

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************

	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\fx_twink.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	fx_ega.asm : CSD for IBM version with screen saving
;*		     (code taken from twin.asm for QC/QB)
;*	* DOES NOT INCLUDE "csd_code"
;*************************************************************************

BUILTIN_SNOW = 1		;* builtin snow control
TWINCSD = 1
KANJI = 1
	include	csd_head.inc
	include fxdrv.inc
	include	csd_data.inc

;*****************************************************************************

	include fx_data.asm

;*****************************************************************************

sBegin	DRV
    assumes CS,DRV
    assumes ds,NOTHING
    assumes ss,NOTHING

;*****************************************************************************
;*	* There is no low memory structure for the linked driver
OFF_lpwDataCsd	DW	dataOffset rgwDataCsd

	include	saveega.inc			;* screen save specifics

;*****************************************************************************

	MDACSD = 1		;enable all drivers
	CGACSD = 1
	EGACSD = 1
	MCGACSD = 1
	VGACSD = 1

	include genmodes.asm			;* modes table

;*****************************************************************************

NonStandard	FInitCsd


;********** FInitCsd **********
;*	entry:
;*		pinch = near pointer to INCH structure to fill
;*	* Initialize the screen to the given mode
;*	exit:	AX != 0 if ok

cProc	FInitCsd, <FAR, PUBLIC, ATOMIC>, <ds,di>
    parmDP pinst
    parmDP pinch
    localB modeCur
    localB fscanset
cBegin	FInitCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment

;*	* save old mode
	cCall	ModeGetCur			;* al = mode, ah = ayMac
	mov	modeCur,al			;* current mode

	mov	bx,pinst
	cmp	ds:[bx].ayMacInst,ah
	je	@F				;* same resolution
	mov	modeCur,0			;* cause mode reset
@@:

;*	* set mode
	mov	[di].pinstDrv,bx
	mov	bx,ds:[bx].pdmInst		;* CS:BX => DM info

;*	* copy mode info into driver globals
	mov	ax,cs:[bx].vparmCursOnDm
	mov	[di].vparmCursOn,ax		;initialize underline cursor
	mov	[di].vparmCursSize,ax
	mov	ax,cs:[bx].wExtraDm
	mov	[di].wExtra,ax

	mov	al,cs:[bx].modeDm
	cmp	al,modeCur
	jne	@F				
	jmp	finitdone			;same mode, no reset
@@:
	mov	fscanset,0
	test	[di].fvmCurAdap,fvmVGA 		;Test for VGA
	jz	initvideomode			

	mov	al,2				;default 400 scan lines
	cmp	cs:[bx].modeDm,7
	je	@F
	cmp	cs:[bx].ayMacDm,43		;80x43 text ?
	jne	not43line
@@:	
	dec	al				;350 lines (EGA)
	mov	fscanset,al
not43line:
	mov	ah,12h				;set vertical scan line for VGA
	push	bx
	mov	bl,30h
	int	10h
	pop	bx

initvideomode:	
	xor	ah,ah				;* set mode
	mov	al,cs:[bx].modeDm
	or	al,80h				;* don't clear REGEN
	int	10h

	test	ss:[bx].fvmCurAdap, fvmEGA or fvmVGA or fvm64KEGA or fvmMCGA or fvmEGAM
	jz	@F

;* Clear the "don't clear regen" bit in the BIOS image
	xor	ax,ax
	mov	es,ax
	and	byte ptr es:[BIOS_info],7fH	;487H
@@:
	mov	ax,40H
	mov	es,ax
	mov	al,cs:[bx].ayMacDm
	dec	al				; rows - 1
	mov	byte ptr es:[0084H],al		;* update BIOS rows

	test	[di].fvmCurAdap,fvmCGA		 
	jnz	finitdone

	mov	al,12h				;8x8 fonts
	mov	ah,8
	cmp	cs:[bx].ayMacDm,25		
	jne	@F
	
	test	[di].fvmCurAdap,fvmEGA or fvmEGAM or fvm64KEGA		 
	jnz	finitdone
		
	mov	al,14h				;8x16
	mov	ah,16

	cmp	fscanset,1
	jne	@F

	mov	al,11h				;8x14 (VGA 350 scan mode)
	mov	ah,14
@@:
	push	bx
	xor	bl,bl
	mov	bh,ah
	mov	ah,11h				;load char set
	int	10h				
	pop	bx

	cmp	cs:[bx].ayMacDm,50		;* 50 line mode ?
	jne	finitdone
	
	test	[di].fvmCurAdap,fvmMCGA		 
	jz	finitdone	
					;extra works for MCGA 50 line mode
	mov	ax,1103h		;load font page
	xor	bx,bx
	int	10h			

	mov	dx,3D4h			;program CRT
	mov	ax,309h
	out	dx,ax
	mov	al,0Ah
	out	dx,ax
	mov	al,0Bh
	out	dx,ax

	push	ds
	mov	ax,40h				;update video Bios data segment
	mov	ds,ax
	mov	word ptr ds:[4Ch],1F40h		;80x50x2
	mov	byte ptr ds:[84h],31h		;50-1 rows
	mov	word ptr ds:[85h],8		;points	
	pop	ds

finitdone:

;*	* normally the INCH array would be copied (but since it is already
;*	*  setup in DATA just leave it alone).

;*	* Do other diddling
	cCall	DiddleBlinkBit

	mov	dx,drvOffset ColourPalette   	; Default Enhanced colour
	test	[di].fvmCurAdap, fvmEGAM
	jz	@F
	mov	dx,drvOffset MonoPalette   	; Default Monochrome palette
@@:	
	push	cs
	pop	es				; es:dx = color array
	mov	ax,1002H
	int	10H				; Set default palette

        mov     ax, 0500H
	int	10H				; Set default page to 0

	mov	ax,sp				;* success
cEnd	FInitCsd


;*****************************************************************************

	include saveega.asm			;* save stuff

;*****************************************************************************

	include	csd_std.asm		;* standard init/term
	include	csd_ibm.asm		;* IBM specific routines

;*****************************************************************************

	include kanji.inc
	include csd_oax.asm		;* OAX procs for direct video I/O
	include	csd_save.asm		;* default screen save (none)

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************

	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\genius.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	genius.asm : MDS (Micro Display System) Genius CSD
;*****************************************************************************

	include	csd_head.inc
	include	csd_data.inc

;*****************************************************************************

	include	csd_code.asm			;* first part of code

;*	* Display modes table
rgdm:
;;;* mode = 7(IBM), 8(MDS)
;* #0 - IBM text mode
	DB	0ffh				;* any
	DB	0ffh				;* any
	DB	7				;* mode
	DW	finstText or finstMonoChrome	;* flags
	DB	80,25				;* screen size
	DB	2				;* coMac
	DB	0, 0, 0, 0			;* INFT
	DW	0B000H				;* video address
	DW	0C0DH				;* cursor
	DW	0800H				;* port 3B8/3D8H
	Assert	<($-rgdm) EQ SIZE DM>

;* #1 - MDS text mode (80 col)
	DB	0ffh				;* any
	DB	0ffh				;* any
	DB	8				;* mode
	DW	finstText or finstMonoChrome	;* flags
	DB	80,66				;* screen size
	DB	2				;* coMac
	DB	0, 0, 0, 0			;* INFT
	DW	0B000H				;* video address
	DW	0D0EH				;* cursor
	DW	0800H				;* port 3B8/3D8H

;* #2 - MDS graphics text mode (63 row)
	DB	0ffh				;* any
	DB	0ffh				;* any
	DB	8				;* mode
	DW	finstGraphics or finstMonoChrome OR finstFont	;* flags
	DB	91,63				;* screen size
	DB	2				;* coMac
	DB	8, 16, 0, 0			;* INFT
	DW	0				;* video address
	DW	0E0FH				;* cursor
	DW	0008H				;* port 3B8/3D8H

cdmMax	equ	($ - rgdm) / (size DM)		;* # of modes

Genius_Mode	EQU	8		; Special Genius mode for full screen
CRTPort2	EQU	3B0H		; Genius CRT Control Port # 2
MDSMode_Mask	EQU	00000001B	; 1 = MDS Mode, 0 = IBM Mode
Upper_Screen	EQU	0A000H
Lower_Screen	EQU	0B800H
BWModeCtrlReg	EQU	3B8H
ColorModeCtrlReg EQU	3D8H

;*****************************************************************************
;*	* Special routines

NonStandard	ModeGetCur
NonStandard	FInitCsd

;*****************************************************************************

;********** ModeGetCur *********
;*	entry:	n/a
;*	* get current machine mode
;*	exit:	al = mode, ah = ayMac (or 0 if unknown)
cProc	ModeGetCur, <NEAR, PUBLIC, ATOMIC>, <ES>
cBegin	ModeGetCur

	mov	dx,3B0h
	in	al,dx
	and 	al,1
	jnz	@F
	mov	ax,1907h 		;ibm 80x25 mono
	jmp short exitMGCur
@@:
	mov	ax,40H
	mov	es,ax
	mov	ah,es:[0084H]		;* read BIOS rows
	inc	ah			;* screen height
	cmp	ah,66		       	;MDS text
	je	@F
	cmp	ah,63			;MDS graphics
	je	@F
	mov	ah,66			;* default to text mode
@@:	
	mov	al,8			;* MDS mode 8
exitMGCur:
cEnd	ModeGetCur


;********** FInitCsd **********
;*	entry:
;*		pinch = near pointer to INCH structure to fill
;*	* Initialize the screen to the given mode
;*	exit:	AX != 0 if ok

cProc	FInitCsd, <FAR, PUBLIC, ATOMIC>, <ds,di>
    parmDP pinst
    parmDP pinch
    localB modeCur
    localB fInverse
cBegin	FInitCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment

;*	* save old mode
	cCall	ModeGetCur			;* al = mode, ah = ayMac
	mov	modeCur,al			;* current mode

	mov	bx,pinst
	cmp	ds:[bx].ayMacInst,ah
	je	@F				;* same resolution
	mov	modeCur,0			;* cause mode reset
@@:

;*	* set mode
	mov	[di].pinstDrv,bx
	mov	bx,ds:[bx].pdmInst		;* CS:BX => DM info

;*	* copy mode info into driver globals
	mov	ax,cs:[bx].vparmCursOnDm
	mov	[di].vparmCursOn,ax
	mov	[di].vparmCursSize,ax
	mov	ax,cs:[bx].wExtraDm
	mov	[di].wExtra,ax

	mov	al,cs:[bx].modeDm
	cmp	al,modeCur
	jne	@F				
	jmp	initdone			;* don't reset
@@:
	mov	dx,3B0h
	in	al,dx
	and	al,00100000b			;get inverse bit
	mov	fInverse,al

	mov	al,cs:[bx].modeDm
	xor	ah,ah				;* set mode
	int	10h

	in	al,dx
	and	al,11011111b
	or	al,fInverse
	cmp	cs:[bx].modeDm,7
	jne	@F
	cmp	fInverse,0
	je	@F
	or	al,10h				;clear bottom graphics screen
@@:	
	out	dx,al

	mov	ax,40H
	mov	es,ax
	mov	al,cs:[bx].modeDm
	mov	byte ptr es:[0049H],al		;* modes
	mov	al,cs:[bx].ayMacDm
	dec	al				; rows - 1
	mov	byte ptr es:[0084H],al		;* update BIOS rows

	mov	ax,cs:[bx].wExtraDm
	mov	dx,3D8h			
	out	dx,al
	mov	al,ah
	mov	dx,3B8h
	out	dx,al

	xor	al,al
	cmp	cs:[bx].modeDm,7		;IBM 80x25 text ?
	jne	@F
	mov	al,90h				;set double height character
@@:
	mov	dx,3B1h
	out	dx,al

	test	cs:[bx].finstDm,finstGraphics
	jz	finittext

; KLUDGE ALERT!!  Genius designed themselves into a box, so we need to
;	communicate with the mouse through the cursor position for
;	page 3 (an arbitrarily chosen location, hopefully safe).
	mov	ax,40H				;IBM segment
	mov	es,ax
	mov	al,cs:[bx].modeDm
	mov	byte ptr es:[50h + (3 * 2)],al	;CURSOR_POSN
initdone:
	xor	ah,ah	
	mov	al,cs:[bx].dyCharDm
	mov	[di].ayBox,ax			;* points
	mov	[di].SEG_lpbFont,cs		;* 8x16 font
	mov	[di].OFF_lpbFont,drvOffset rgbVectFont8x16
finitdone:
;*	* normally the INCH array would be copied (but since it is already
;*	*  setup in DATA just leave it alone).

;*	* Do other diddling
	test	cs:[bx].finstDm,finstText
	jz	@F
finittext:
	cCall	DiddleBlinkBit
@@:
	mov	ax,sp				;* success
cEnd	FInitCsd

;*****************************************************************************

	GENIUSCSD = 1
	include update2.asm
	include	vect8x16.inc		;* hard code font table

;*****************************************************************************
	include	csd_std.asm		;* standard init/term
	include	csd_ibm.asm		;* IBM specific routines

;*****************************************************************************

	include	csd_vram.asm		;* default procs for direct video I/O
	include	csd_save.asm		;* default screen save (none)

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************


	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\herc112.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	herc102.asm : for Hercules graphics plus and InColor card
;*****************************************************************************

	GB102CSD = 0
	GB112CSD = 1
	GB222CSD = 1
	
	include	herc.asm


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\geninit.asm ===
;*	General Purpose FInitCsd Routine
;*

NonStandard	FInitCsd

;*****************************************************************************

;********** FInitCsd **********
;*	entry:
;*		pinch = near pointer to INCH structure to fill
;*	* Initialize the screen to the given mode
;*	exit:	AX != 0 if ok

cProc	FInitCsd, <FAR, PUBLIC, ATOMIC>, <ds,di>
    parmDP pinst
    parmDP pinch
    localB modeCur
cBegin	FInitCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment

;*	* save old mode
	cCall	ModeGetCur			;* al = mode, ah = ayMac
	mov	modeCur,al			;* current mode

	mov	bx,pinst
	cmp	ds:[bx].ayMacInst,ah
	je	@F				;* same resolution
	mov	modeCur,0			;* cause mode reset
@@:

;*	* set mode
	mov	[di].pinstDrv,bx
	mov	bx,ds:[bx].pdmInst		;* CS:BX => DM info

;*	* copy mode info into driver globals
	mov	ax,cs:[bx].vparmCursOnDm
	mov	[di].vparmCursOn,ax		;initialize underline cursor
	mov	[di].vparmCursSize,ax
	mov	ax,cs:[bx].wExtraDm
	mov	[di].wExtra,ax

	mov	al,cs:[bx].modeDm
	cmp	al,modeCur
	jne	@F				
IFDEF	GRAPHICSTEXT
	test	cs:[bx].finstDm,finstGraphics	
	jz	ttext
	cmp	[di].ayBox,8
	jne	@F				;need to init drv data
ttext:
ENDIF	;GRAPHICSTEXT
	jmp	finitdone
@@:

IFDEF	GRAPHICSTEXT
	test	cs:[bx].finstDm,finstText
	jz	initvideomode			
ENDIF	;GRAPHICSTEXT

	test	[di].fvmCurAdap,fvmVGA 		;Test for VGA
	jz	initvideomode			

	mov	al,2				;default 400 scan lines
	cmp	cs:[bx].ayMacDm,43		;80x43 text ?
	jne	@F

	dec	al				;350 lines (EGA)
@@:
	mov	ah,12h				;set vertical scan line for VGA
	push	bx
	mov	bl,30h
	int	10h
	pop	bx

initvideomode:	
	xor	ah,ah				;* set mode
						;* REVIEW: always clear RGEN ??
	mov	al,cs:[bx].modeDm
	int	10h

	mov	ax,40H
	mov	es,ax
	mov	al,cs:[bx].ayMacDm
	dec	al				; rows - 1
	mov	byte ptr es:[0084H],al		;* update BIOS rows

IFDEF	GRAPHICSTEXT
	test	cs:[bx].finstDm,finstGraphics
	jz	@F
	jmp	InitGraf
@@:
ENDIF	;GRAPHICSTEXT

	;* if only a CGA (not a dual mode) then skip font load
	test	[di].fvmCurAdap,NOT fvmCGA
	jz	textinitdone

	mov	ax,0812h			;8x8 fonts
	cmp	cs:[bx].ayMacDm,25		
	jne	@F
	
	test	[di].fvmCurAdap,fvmEGA or fvmEGAM or fvm64KEGA or fvmMDA
	jnz	textinitdone

	mov	ax,1014h			;8x16 PS/2		
@@:
	push	bx
	xor	bl,bl
	mov	bh,ah
	mov	ah,11h				;load char set
	int	10h				
	pop	bx
textinitdone:
	jmp	finitdone

IFDEF	GRAPHICSTEXT
InitGraf:
	mov	al,2			;default 25 rows

	cmp	cs:[bx].modeDm,13h	;MCGA 256 color mode ?
	je	font8x8
			
	cmp	cs:[bx].modeDm,6	;CGA mode 4 or 6 ?
	ja	notmode6

	test	[di].fvmCurAdap,fvmCGA
	jz	font8x8			;8x8 -> EGA,MCGA,VGA

	mov	[di].SEG_lpbFont,0F000h		;load PC ROM Font (CGA only)
	mov	[di].OFF_lpbFont,0FA6Eh
	mov	[di].ayBox,8
	jmp	finitdone

notmode6:
	cmp	cs:[bx].ayMacDm,25
	jne	not14font		;8x14 -> EGA,VGA

	cmp	cs:[bx].dyCharDm,14
	je	@F
	xor	al,al			
	mov	dl,25			;25 scan rows
	jmp	short font8x8		;8x8 -> 64KEGA
@@:
	mov	bl,2	
	jmp	load14

not14font:
	cmp	cs:[bx].ayMacDm,30
	jne	not80x30		

	mov	al,6			;8x16 -> MCGA,VGA
	jmp	defaultfont

not80x30:	
	cmp	cs:[bx].ayMacDm,34	
	jne	not80x34	     

	xor	bl,bl			;8x14 -> VGA only
	mov	dl,34
load14:
	mov	ax,1122h		;load 8x14 fonts
	int	10h
	mov	al,2			;return 8x14 fonts
	jmp	defaultfont
	
not80x34:
	cmp	cs:[bx].ayMacDm,43
	jne	not80x43		

	xor	al,al			
	mov	dl,43			;43 scan rows
	jmp	short font8x8		;8x8 -> EGA,VGA

not80x43:
	cmp	cs:[bx].ayMacDm,60
	xor	ax,ax
	jne	finitret		;error, this mode is not supprt !
	
	mov	dl,60
font8x8:
	mov	bl,al			;scan rows 
	mov	ax,1123h		;load 8x8 fonts
	int	10h
	mov	al,3			;return 8x8 fonts

defaultfont:
	mov	bh,al
	mov	ax,1130h
	push	bp
	int	10h
	mov	[di].SEG_lpbFont,es
	mov	[di].OFF_lpbFont,bp
	mov	[di].ayBox,cx
	pop	bp

ENDIF	;GRAPHICSTEXT
finitdone:

;*	* normally the INCH array would be copied (but since it is already
;*	*  setup in DATA just leave it alone).

;*	* Do other diddling
	cCall	DiddleBlinkBit

	mov	ax,sp				;* success
finitret:
cEnd	FInitCsd

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\herc8x10.inc ===
;-----------------------------------------------------------;
	;							    ;
	;  Hercules RAM Charcter Set.  8 x 10 System Font	    ;
	;							    ;
	;	     ASCII Character Set (128-255)		    ;
	;							    ;
	;-----------------------------------------------------------;

rgbHercExFont8x10	LABEL	BYTE

ExFont	DB	078H,0CCH,0C0H,0CCH,078H,018H,00CH,078H,0,0 ;128*
	DB	000H,0CCH,000H,0CCH,0CCH,0CCH,076H,000H,0,0 ;129*
	DB	00EH,000H,078H,0CCH,0FCH,0C0H,078H,000H,0,0 ;130*
	DB	07CH,082H,078H,00CH,07CH,0CCH,076H,000H,0,0 ;131*
	DB	048H,000H,078H,00CH,07CH,0CCH,076H,000H,0,0  ;132* a
	DB	0E0H,000H,078H,00CH,07CH,0CCH,076H,000H,0,0 ;133*
	DB	0F8H,000H,078H,00CH,07CH,0CCH,076H,000H,0,0  ;134*
	DB	000H,000H,078H,0C0H,0C0H,078H,00CH,038H,0,0 ;135*
	DB	07CH,082H,078H,0CCH,0FCH,0C0H,078H,000H,0,0 ;136*
	DB	0CCH,000H,078H,0CCH,0FCH,0C0H,078H,000H,0,0 ;137*
	DB	0E0H,000H,078H,0CCH,0FCH,0C0H,078H,000H,0,0 ;138*
	DB	0CCH,000H,070H,030H,030H,030H,078H,000H,0,0 ;139*
	DB	070H,088H,070H,030H,030H,030H,078H,000H,0,0 ;140*
	DB	0E0H,000H,070H,030H,030H,030H,078H,000H,0,0  ;141*
	DB	0CCH,030H,078H,0CCH,0FCH,0CCH,0CCH,000H,0,0  ;142*
	DB	030H,030H,000H,078H,0CCH,0FCH,0CCH,000H,0,0  ;143*
	DB	00EH,000H,0FEH,060H,078H,060H,0FEH,000H,0,0 ;144*
	DB	000H,000H,07EH,00CH,07EH,0CCH,07EH,000H,0,0  ;145*
	DB	03EH,06CH,0CCH,0FEH,0CCH,0CCH,0CEH,000H,0,0  ;146*
	DB	078H,0CCH,000H,078H,0CCH,0CCH,078H,000H,0,0 ;147*
	DB	000H,0CCH,000H,078H,0CCH,0CCH,078H,000H,0,0  ;148*
	DB	000H,0E0H,000H,078H,0CCH,0CCH,078H,000H,0,0  ;149*
	DB	078H,0CCH,000H,0CCH,0CCH,0CCH,076H,000H,0,0 ;150*
	DB	000H,0E0H,000H,0CCH,0CCH,0CCH,076H,000H,0,0 ;151*
	DB	000H,0CCH,000H,0CCH,0CCH,07CH,00CH,0F8H,0,0 ;152*
	DB	06CH,000H,038H,06CH,06CH,06CH,038H,000H,0,0  ;153* 
	DB	0CCH,000H,0CCH,0CCH,0CCH,0CCH,0FCH,000H,0,0 ;154*
	DB	018H,018H,07CH,0C0H,0C0H,07CH,018H,018H,0,0  ;155* 
	DB	038H,06CH,064H,0F0H,060H,0E6H,0FCH,000H,0,0 ;156*
	DB	0CCH,0CCH,078H,0FCH,030H,0FCH,030H,030H,0,0  ;157*
	DB	0F8H,0C4H,0C4H,0FAH,0C6H,0CFH,0C6H,0C7H,0,0  ;158* 
	DB	01CH,036H,030H,078H,030H,030H,0B0H,060H,0,0 ;159*
	DB	00EH,000H,078H,00CH,07CH,0CCH,076H,000H,0,0  ;160*
	DB	00EH,000H,070H,030H,030H,030H,078H,000H,0,0  ;161*
	DB	000H,00EH,000H,078H,0CCH,0CCH,078H,000H,0,0 ;162*
	DB	000H,00EH,000H,0CCH,0CCH,0CCH,076H,000H,0,0 ;163*
	DB	0F8H,000H,0F8H,0CCH,0CCH,0CCH,0CCH,000H,0,0  ;164*
	DB	0FEH,000H,0C6H,0F6H,0DEH,0CEH,0C6H,000H,0,0  ;165*
	DB	07CH,0CCH,0CCH,07EH,000H,0FEH,000H,000H,0,0  ;166*
	DB	07CH,0C6H,0C6H,07CH,000H,0FEH,000H,000H,0,0  ;167*
	DB	030H,000H,030H,060H,0C0H,0CCH,078H,000H,0,0  ;168*
	DB	000H,000H,000H,0FCH,0C0H,0C0H,000H,000H,0,0 ;169*
	DB	000H,000H,000H,0FCH,00CH,00CH,000H,000H,0,0 ;170*
	DB	0C3H,0C6H,0CCH,0DEH,033H,066H,0CCH,00FH,0,0 ;171*
	DB	0C3H,0C6H,0CCH,0DBH,037H,06FH,0CFH,003H,0,0 ;172*
	DB	030H,000H,030H,030H,078H,078H,030H,000H,0,0  ;173*
	DB	000H,000H,033H,066H,0CCH,066H,033H,000H,0,0 ;174*
	DB	000H,000H,0CCH,066H,033H,066H,0CCH,000H,0,0 ;175*
	DB	088H,022H,088H,022H,088H,022H,088H,022H,88h,22h ;176*
	DB	055H,0AAH,055H,0AAH,055H,0AAH,055H,0AAH,55h,0aah ;177*
	DB	0EEH,0BBH,0EEH,0BBH,0EEH,0BBH,0EEH,0BBH,0eeh,0bbh ;178*
	DB	018H,018H,018H,018H,018H,018H,018H,018H,18h,18h ;179*
	DB	018H,018H,018H,0F8H,018H,018H,018H,018H,18h,18h ;180*
	DB	018H,018H,0F8H,018H,0F8H,018H,018H,018H,18h,18h ;181*
	DB	066H,066H,066H,0E6H,066H,066H,066H,066H,66h,66h ;182*
	DB	000H,000H,000H,0FEH,066H,066H,066H,066H,66h,66h ;183*
	DB	000H,000H,0F8H,018H,0F8H,018H,018H,018H,18h,18h ;184*
	DB	066H,066H,0E6H,006H,0E6H,066H,066H,066H,66h,66h ;185*
	DB	066H,066H,066H,066H,066H,066H,066H,066H,66h,66h ;186*
	DB	000H,000H,0FEH,006H,0E6H,066H,066H,066H,66h,66h ;187*
	DB	066H,066H,0E6H,006H,0FEH,000H,000H,000H,0,0 ;188*
	DB	066H,066H,066H,0FEH,000H,000H,000H,000H,0,0 ;189*
	DB	018H,018H,0F8H,018H,0F8H,000H,000H,000H,0,0 ;190*
	DB	000H,000H,000H,0F8H,018H,018H,018H,018H,18h,18h ;191*
	DB	018H,018H,018H,01FH,000H,000H,000H,000H,0,0 ;192*
	DB	018H,018H,018H,0FFH,000H,000H,000H,000H,0,0 ;193*
	DB	000H,000H,000H,0FFH,018H,018H,018H,018H,18h,18h ;194*
	DB	018H,018H,018H,01FH,018H,018H,018H,018H,18h,18h ;195*
	DB	000H,000H,000H,0FFH,000H,000H,000H,000H,0,0 ;196*
	DB	018H,018H,018H,0FFH,018H,018H,018H,018H,18h,18h ;197*
	DB	018H,018H,01FH,018H,01FH,018H,018H,018H,18h,18h ;198*
	DB	066H,066H,066H,067H,066H,066H,066H,066H,66h,66h ;199*
	DB	066H,066H,067H,060H,07FH,000H,000H,000H,0,0 ;200*
	DB	000H,000H,07FH,060H,067H,066H,066H,066H,66h,66h ;201*
	DB	066H,066H,0E7H,000H,0FFH,000H,000H,000H,0,0 ;202*
	DB	000H,000H,0FFH,000H,0E7H,066H,066H,066H,66h,66h ;203*
	DB	066H,066H,067H,060H,067H,066H,066H,066H,66h,66h ;204*
	DB	000H,000H,0FFH,000H,0FFH,000H,000H,000H,0,0 ;205*
	DB	066H,066H,0E7H,000H,0E7H,066H,066H,066H,66h,66h ;206*
	DB	018H,018H,0FFH,000H,0FFH,000H,000H,000H,0,0 ;207*
	DB	066H,066H,066H,0FFH,000H,000H,000H,000H,0,0 ;208*
	DB	000H,000H,0FFH,000H,0FFH,018H,018H,018H,18h,18h ;209*
	DB	000H,000H,000H,0FFH,066H,066H,066H,066H,66h,66h ;210*
	DB	066H,066H,066H,07FH,000H,000H,000H,000H,0,0 ;211*
	DB	018H,018H,01FH,018H,01FH,000H,000H,000H,0,0 ;212*
	DB	000H,000H,01FH,018H,01FH,018H,018H,018H,18h,18h ;213*
	DB	000H,000H,000H,07FH,066H,066H,066H,066H,66h,66h ;214*
	DB	066H,066H,066H,0FFH,066H,066H,066H,066H,66h,66h ;215*
	DB	018H,018H,0FFH,018H,0FFH,018H,018H,018H,18h,18h ;216*
	DB	018H,018H,018H,0F8H,000H,000H,000H,000H,0,0 ;217*
	DB	000H,000H,000H,01FH,018H,018H,018H,018H,18h,18h ;218*
	DB	0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0ffh,0ffh ;219*
	DB	000H,000H,000H,000H,0FFH,0FFH,0FFH,0FFH,0ffh,0ffh ;220*
	DB	0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0f0h,0f0h ;221*
	DB	00FH,00FH,00FH,00FH,00FH,00FH,00FH,00FH,0fh,0fh ;222*
	DB	0FFH,0FFH,0FFH,0FFH,000H,000H,000H,000H,0,0 ;223*
	DB	000H,000H,076H,0DCH,0C8H,0DCH,076H,000H,0,0  ;224*
	DB	000H,078H,0CCH,0F8H,0CCH,0F8H,0C0H,0C0H,0,0  ;225*
	DB	000H,0FCH,0CCH,0C0H,0C0H,0C0H,0C0H,0C0H,0,0  ;226*
	DB	000H,0FEH,06CH,06CH,06CH,06CH,06CH,000H,0,0  ;227*
	DB	0FCH,0CCH,060H,030H,060H,0CCH,0FCH,000H,0,0  ;228*
	DB	000H,000H,07EH,0D8H,0D8H,0D8H,070H,000H,0,0  ;229*
	DB	000H,066H,066H,066H,066H,07CH,060H,0C0H,0,0  ;230*
	DB	000H,076H,0DCH,018H,018H,018H,018H,000H,0,0  ;231*
	DB	0FCH,030H,078H,0CCH,0CCH,078H,030H,0FCH,0,0 ;232*
	DB	038H,06CH,0C6H,0FEH,0C6H,06CH,038H,000H,0,0 ;233*
	DB	038H,06CH,0C6H,0C6H,06CH,06CH,0EEH,000H,0,0 ;234*
	DB	01CH,030H,018H,07CH,0CCH,0CCH,078H,000H,0,0 ;235*
	DB	000H,000H,066H,0DBH,0DBH,066H,000H,000H,0,0 ;236*
	DB	006H,00CH,07EH,0DBH,0DBH,07EH,060H,0C0H,0,0 ;237*
	DB	01CH,030H,060H,0FCH,060H,030H,01CH,000H,0,0 ;238*
	DB	078H,0CCH,0CCH,0CCH,0CCH,0CCH,0CCH,000H,0,0 ;239*
	DB	000H,0FCH,000H,0FCH,000H,0FCH,000H,000H,0,0 ;240*
	DB	030H,030H,0FCH,030H,030H,000H,0FCH,000H,0,0 ;241*
	DB	060H,030H,018H,030H,060H,000H,0FCH,000H,0,0 ;242*
	DB	018H,030H,060H,030H,018H,000H,0FCH,000H,0,0 ;243*
	DB	00EH,01BH,018H,018H,018H,018H,018H,018H,0,0 ;244*
	DB	018H,018H,018H,018H,018H,018H,0D8H,070H,0,0 ;245*
	DB	030H,030H,000H,0FCH,000H,030H,030H,000H,0,0 ;246*
	DB	000H,076H,0DCH,000H,076H,0DCH,000H,000H,0,0 ;247*
	DB	070H,0D8H,0D8H,070H,000H,000H,000H,000H,0,0 ;248*
	DB	000H,000H,018H,018H,000H,000H,000H,000H,0,0 ;249*
	DB	000H,000H,000H,018H,000H,000H,000H,000H,0,0 ;250*
	DB	00EH,00CH,00CH,00CH,0ECH,06CH,03CH,01CH,0,0 ;251*
	DB	0F8H,0CCH,0CCH,0CCH,0CCH,000H,000H,000H,0,0 ;252*
	DB	0F0H,018H,030H,060H,0F8H,000H,000H,000H,0,0 ;253*
	DB	000H,000H,038H,038H,038H,038H,000H,000H,0,0 ;254*
	DB	000H,000H,000H,000H,000H,000H,000H,000H,0,0 ;255*
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\herc8x14.inc ===
;-----------------------------------------------------------;
	;							    ;
	;  EGA RAM Charcter Set.  8 x 14 System Font		    ;
	;							    ;
	;	     ASCII Character Set (000-127)		    ;
	;							    ;
	;  (Commnented out for now)				    ;
	;							    ;
	;-----------------------------------------------------------;

rgbHercFont8x14:
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	; [ ] 0
	DB	000H, 000H, 07EH, 081H, 0A5H, 081H, 081H, 0BDH, 099H, 081H, 07EH, 000H, 000H, 000H	; [] 1
	DB	000H, 000H, 07EH, 0FFH, 0DBH, 0FFH, 0FFH, 0C3H, 0E7H, 0FFH, 07EH, 000H, 000H, 000H	; [] 2
	DB	000H, 000H, 000H, 06CH, 0FEH, 0FEH, 0FEH, 0FEH, 07CH, 038H, 010H, 000H, 000H, 000H	; [] 3
	DB	000H, 000H, 000H, 010H, 038H, 07CH, 0FEH, 07CH, 038H, 010H, 000H, 000H, 000H, 000H	; [] 4
	DB	000H, 000H, 018H, 03CH, 03CH, 0E7H, 0E7H, 0E7H, 018H, 018H, 03CH, 000H, 000H, 000H	; [] 5
	DB	000H, 000H, 018H, 03CH, 07EH, 0FFH, 0FFH, 07EH, 018H, 018H, 03CH, 000H, 000H, 000H	; [] 6
	DB	000H, 000H, 000H, 000H, 000H, 018H, 03CH, 03CH, 018H, 000H, 000H, 000H, 000H, 000H	; [] 7
	DB	0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0E7H, 0C3H, 0C3H, 0E7H, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH	; [] 8
	DB	000H, 000H, 000H, 000H, 03CH, 066H, 042H, 042H, 066H, 03CH, 000H, 000H, 000H, 000H	; [] 9
	DB	0FFH, 0FFH, 0FFH, 0FFH, 0C3H, 099H, 0BDH, 0BDH, 099H, 0C3H, 0FFH, 0FFH, 0FFH, 0FFH	; [] 10
	DB	000H, 000H, 01EH, 00EH, 01Ah, 032H, 078H, 0CCH, 0CCH, 0CCH, 078H, 000H, 000H, 000H
	DB	000H, 000H, 03CH, 066H, 066H, 066H, 03CH, 018H, 07EH, 018H, 018H, 000H, 000H, 000H	; [] 12
	DB	000H, 000H, 03FH, 033H, 03FH, 030H, 030H, 030H, 070H, 0F0H, 0E0H, 000H, 000H, 000H	; [ ] 13
	DB	000H, 000H, 07FH, 063H, 07FH, 063H, 063H, 063H, 067H, 0E7H, 0E6H, 0C0H, 000H, 000H	; [] 14
	DB	000H, 000H, 018H, 018H, 0DBH, 03CH, 0E7H, 03CH, 0DBH, 018H, 018H, 000H, 000H, 000H	; [] 15
	DB	000H, 000H, 080H, 0C0H, 0E0H, 0F8H, 0FEH, 0F8H, 0E0H, 0C0H, 080H, 000H, 000H, 000H	; [] 16
	DB	000H, 000H, 002H, 006H, 00EH, 03EH, 0FEH, 03EH, 00EH, 006H, 002H, 000H, 000H, 000H	; [] 17
	DB	000H, 000H, 018H, 03CH, 07EH, 018H, 018H, 018H, 07EH, 03CH, 018H, 000H, 000H, 000H	; [] 18
	DB	000H, 000H, 066H, 066H, 066H, 066H, 066H, 066H, 000H, 066H, 066H, 000H, 000H, 000H	; [] 19
	DB	000H, 000H, 07FH, 0DBH, 0DBH, 0DBH, 07BH, 01BH, 01BH, 01BH, 01BH, 000H, 000H, 000H	; [] 20
	DB	000H, 07CH, 0C6H, 060H, 038H, 06CH, 0C6H, 0C6H, 06CH, 038H, 00CH, 0C6H, 07CH, 000H	; [] 21
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 0FEH, 0FEH, 0FEH, 000H, 000H, 000H	; [] 22
	DB	000H, 000H, 018H, 03CH, 07EH, 018H, 018H, 018H, 07EH, 03CH, 018H, 07EH, 000H, 000H	; [] 23
	DB	000H, 000H, 018H, 03CH, 07EH, 018H, 018H, 018H, 018H, 018H, 018H, 000H, 000H, 000H	; [] 24
	DB	000H, 000H, 018H, 018H, 018H, 018H, 018H, 018H, 07EH, 03CH, 018H, 000H, 000H, 000H	; [] 25
	DB	000H, 000H, 000H, 000H, 018H, 00CH, 0FEH, 00CH, 018H, 000H, 000H, 000H, 000H, 000H	; [ ] 26
   	DB	000H, 000H, 000H, 000H, 030H, 060H, 0FEH, 060H, 030H, 000H, 000H, 000H, 000H, 000H	; [] 27
   	DB	000H, 000H, 000H, 000H, 000H, 0C0H, 0C0H, 0C0H, 0FEH, 000H, 000H, 000H, 000H, 000H	; [] 28
   	DB	000H, 000H, 000H, 000H, 028H, 06CH, 0FEH, 06CH, 028H, 000H, 000H, 000H, 000H, 000H	; [] 29
   	DB	000H, 000H, 000H, 010H, 038H, 038H, 07CH, 07CH, 0FEH, 0FEH, 000H, 000H, 000H, 000H	; [] 30
   	DB	000H, 000H, 000H, 0FEH, 0FEH, 07CH, 07CH, 038H, 038H, 010H, 000H, 000H, 000H, 000H	; [] 31
   	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	; [ ] 32
   	DB	000H, 000H, 018H, 03CH, 03CH, 03CH, 018H, 018H, 000H, 018H, 018H, 000H, 000H, 000H	; [!] 33
   	DB	000H, 066H, 066H, 066H, 024H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	; ["] 34
   	DB	000H, 000H, 06CH, 06CH, 0FEH, 06CH, 06CH, 06CH, 0FEH, 06CH, 06CH, 000H, 000H, 000H	; [#] 35
   	DB	018H, 018H, 07CH, 0C6H, 0C2H, 0C0H, 07CH, 006H, 086H, 0C6H, 07CH, 018H, 018H, 000H	; [$] 36
   	DB	000H, 000H, 000H, 000H, 0C2H, 0C6H, 00CH, 018H, 030H, 066H, 0C6H, 000H, 000H, 000H	; [%] 37
   	DB	000H, 000H, 038H, 06CH, 06CH, 038H, 076H, 0DCH, 0CCH, 0CCH, 076H, 000H, 000H, 000H	; [&] 38
   	DB	000H, 030H, 030H, 030H, 060H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	; ['] 39
   	DB	000H, 000H, 00CH, 018H, 030H, 030H, 030H, 030H, 030H, 018H, 00CH, 000H, 000H, 000H	; [(] 40
   	DB	000H, 000H, 030H, 018H, 00CH, 00CH, 00CH, 00CH, 00CH, 018H, 030H, 000H, 000H, 000H	; [)] 41
   	DB	000H, 000H, 000H, 000H, 066H, 03CH, 0FFH, 03CH, 066H, 000H, 000H, 000H, 000H, 000H	; [*] 42
   	DB	000H, 000H, 000H, 000H, 018H, 018H, 07EH, 018H, 018H, 000H, 000H, 000H, 000H, 000H	; [+] 43
   	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 018H, 018H, 018H, 030H, 000H, 000H	; [,] 44
   	DB	000H, 000H, 000H, 000H, 000H, 000H, 0FEH, 000H, 000H, 000H, 000H, 000H, 000H, 000H	; [-] 45
   	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 018H, 018H, 000H, 000H, 000H	; [.] 46
   	DB	000H, 000H, 002H, 006H, 00CH, 018H, 030H, 060H, 0C0H, 080H, 000H, 000H, 000H, 000H	; [/] 47
   	DB	000H, 000H, 07CH, 0C6H, 0CEH, 0DEH, 0F6H, 0E6H, 0C6H, 0C6H, 07CH, 000H, 000H, 000H	; [0] 48
   	DB	000H, 000H, 018H, 038H, 078H, 018H, 018H, 018H, 018H, 018H, 07EH, 000H, 000H, 000H	; [1] 49
   	DB	000H, 000H, 07CH, 0C6H, 006H, 00CH, 018H, 030H, 060H, 0C6H, 0FEH, 000H, 000H, 000H	; [2] 50
   	DB	000H, 000H, 07CH, 0C6H, 006H, 006H, 03CH, 006H, 006H, 0C6H, 07CH, 000H, 000H, 000H	; [3] 51
   	DB	000H, 000H, 00CH, 01CH, 03CH, 06CH, 0CCH, 0FEH, 00CH, 00CH, 01EH, 000H, 000H, 000H	; [4] 52
   	DB	000H, 000H, 0FEH, 0C0H, 0C0H, 0C0H, 0FCH, 006H, 006H, 0C6H, 07CH, 000H, 000H, 000H	; [5] 53
   	DB	000H, 000H, 038H, 060H, 0C0H, 0C0H, 0FCH, 0C6H, 0C6H, 0C6H, 07CH, 000H, 000H, 000H	; [6] 54
   	DB	000H, 000H, 0FEH, 0C6H, 006H, 00CH, 018H, 030H, 030H, 030H, 030H, 000H, 000H, 000H	; [7] 55
   	DB	000H, 000H, 07CH, 0C6H, 0C6H, 0C6H, 07CH, 0C6H, 0C6H, 0C6H, 07CH, 000H, 000H, 000H	; [8] 56
   	DB	000H, 000H, 07CH, 0C6H, 0C6H, 0C6H, 07EH, 006H, 006H, 00CH, 078H, 000H, 000H, 000H	; [9] 57
   	DB	000H, 000H, 000H, 018H, 018H, 000H, 000H, 000H, 018H, 018H, 000H, 000H, 000H, 000H	; [:] 58
   	DB	000H, 000H, 000H, 018H, 018H, 000H, 000H, 000H, 018H, 018H, 030H, 000H, 000H, 000H	; [;] 59
   	DB	000H, 000H, 006H, 00CH, 018H, 030H, 060H, 030H, 018H, 00CH, 006H, 000H, 000H, 000H	; [<] 60
   	DB	000H, 000H, 000H, 000H, 000H, 07EH, 000H, 000H, 07EH, 000H, 000H, 000H, 000H, 000H	; [=] 61
   	DB	000H, 000H, 060H, 030H, 018H, 00CH, 006H, 00CH, 018H, 030H, 060H, 000H, 000H, 000H	; [>] 62
   	DB	000H, 000H, 07CH, 0C6H, 0C6H, 00CH, 018H, 018H, 000H, 018H, 018H, 000H, 000H, 000H	; [?] 63
   	DB	000H, 000H, 07CH, 0C6H, 0C6H, 0DEH, 0DEH, 0DEH, 0DCH, 0C0H, 07CH, 000H, 000H, 000H	; [@] 64
   	DB	000H, 000H, 010H, 038H, 06CH, 0C6H, 0C6H, 0FEH, 0C6H, 0C6H, 0C6H, 000H, 000H, 000H	; [A] 65
   	DB	000H, 000H, 0FCH, 066H, 066H, 066H, 07CH, 066H, 066H, 066H, 0FCH, 000H, 000H, 000H	; [B] 66
   	DB	000H, 000H, 03CH, 066H, 0C2H, 0C0H, 0C0H, 0C0H, 0C2H, 066H, 03CH, 000H, 000H, 000H	; [C] 67
   	DB	000H, 000H, 0F8H, 06CH, 066H, 066H, 066H, 066H, 066H, 06CH, 0F8H, 000H, 000H, 000H	; [D] 68
   	DB	000H, 000H, 0FEH, 066H, 062H, 068H, 078H, 068H, 062H, 066H, 0FEH, 000H, 000H, 000H	; [E] 69
   	DB	000H, 000H, 0FEH, 066H, 062H, 068H, 078H, 068H, 060H, 060H, 0F0H, 000H, 000H, 000H	; [F] 70
   	DB	000H, 000H, 03CH, 066H, 0C2H, 0C0H, 0C0H, 0DEH, 0C6H, 066H, 03AH, 000H, 000H, 000H	; [G] 71
   	DB	000H, 000H, 0C6H, 0C6H, 0C6H, 0C6H, 0FEH, 0C6H, 0C6H, 0C6H, 0C6H, 000H, 000H, 000H	; [H] 72
   	DB	000H, 000H, 03CH, 018H, 018H, 018H, 018H, 018H, 018H, 018H, 03CH, 000H, 000H, 000H	; [I] 73
   	DB	000H, 000H, 01EH, 00CH, 00CH, 00CH, 00CH, 00CH, 0CCH, 0CCH, 078H, 000H, 000H, 000H	; [J] 74
   	DB	000H, 000H, 0E6H, 066H, 06CH, 06CH, 078H, 06CH, 06CH, 066H, 0E6H, 000H, 000H, 000H	; [K] 75
   	DB	000H, 000H, 0F0H, 060H, 060H, 060H, 060H, 060H, 062H, 066H, 0FEH, 000H, 000H, 000H	; [L] 76
   	DB	000H, 000H, 0C6H, 0EEH, 0FEH, 0FEH, 0D6H, 0C6H, 0C6H, 0C6H, 0C6H, 000H, 000H, 000H	; [M] 77
   	DB	000H, 000H, 0C6H, 0E6H, 0F6H, 0FEH, 0DEH, 0CEH, 0C6H, 0C6H, 0C6H, 000H, 000H, 000H	; [N] 78
   	DB	000H, 000H, 038H, 06CH, 0C6H, 0C6H, 0C6H, 0C6H, 0C6H, 06CH, 038H, 000H, 000H, 000H	; [O] 79
   	DB	000H, 000H, 0FCH, 066H, 066H, 066H, 07CH, 060H, 060H, 060H, 0F0H, 000H, 000H, 000H	; [P] 80
   	DB	000H, 000H, 07CH, 0C6H, 0C6H, 0C6H, 0C6H, 0D6H, 0DEH, 07CH, 00CH, 00EH, 000H, 000H	; [Q] 81
   	DB	000H, 000H, 0FCH, 066H, 066H, 066H, 07CH, 06CH, 066H, 066H, 0E6H, 000H, 000H, 000H	; [R] 82
   	DB	000H, 000H, 07CH, 0C6H, 0C6H, 060H, 038H, 00CH, 0C6H, 0C6H, 07CH, 000H, 000H, 000H	; [S] 83
   	DB	000H, 000H, 07EH, 07EH, 05AH, 018H, 018H, 018H, 018H, 018H, 03CH, 000H, 000H, 000H	; [T] 84
   	DB	000H, 000H, 0C6H, 0C6H, 0C6H, 0C6H, 0C6H, 0C6H, 0C6H, 0C6H, 07CH, 000H, 000H, 000H	; [U] 85
   	DB	000H, 000H, 0C6H, 0C6H, 0C6H, 0C6H, 0C6H, 0C6H, 06CH, 038H, 010H, 000H, 000H, 000H	; [V] 86
   	DB	000H, 000H, 0C6H, 0C6H, 0C6H, 0C6H, 0D6H, 0D6H, 0FEH, 07CH, 06CH, 000H, 000H, 000H	; [W] 87
   	DB	000H, 000H, 0C6H, 0C6H, 06CH, 038H, 038H, 038H, 06CH, 0C6H, 0C6H, 000H, 000H, 000H	; [X] 88
   	DB	000H, 000H, 066H, 066H, 066H, 066H, 03CH, 018H, 018H, 018H, 03CH, 000H, 000H, 000H	; [Y] 89
   	DB	000H, 000H, 0FEH, 0C6H, 08CH, 018H, 030H, 060H, 0C2H, 0C6H, 0FEH, 000H, 000H, 000H	; [Z] 90
   	DB	000H, 000H, 03CH, 030H, 030H, 030H, 030H, 030H, 030H, 030H, 03CH, 000H, 000H, 000H	; [[] 91
   	DB	000H, 000H, 080H, 0C0H, 0E0H, 070H, 038H, 01CH, 00EH, 006H, 002H, 000H, 000H, 000H	; [\] 92
   	DB	000H, 000H, 03CH, 00CH, 00CH, 00CH, 00CH, 00CH, 00CH, 00CH, 03CH, 000H, 000H, 000H	; []] 93
   	DB	010H, 038H, 06CH, 0C6H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	; [^] 94
   	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 0FFH, 000H	; [_] 95
   	DB	030H, 030H, 018H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	; [`] 96
   	DB	000H, 000H, 000H, 000H, 000H, 078H, 00CH, 07CH, 0CCH, 0CCH, 076H, 000H, 000H, 000H	; [a] 97
   	DB	000H, 000H, 0E0H, 060H, 060H, 078H, 06CH, 066H, 066H, 066H, 07CH, 000H, 000H, 000H	; [b] 98
   	DB	000H, 000H, 000H, 000H, 000H, 07CH, 0C6H, 0C0H, 0C0H, 0C6H, 07CH, 000H, 000H, 000H	; [c] 99
   	DB	000H, 000H, 01CH, 00CH, 00CH, 03CH, 06CH, 0CCH, 0CCH, 0CCH, 076H, 000H, 000H, 000H	; [d] 100
   	DB	000H, 000H, 000H, 000H, 000H, 07CH, 0C6H, 0FEH, 0C0H, 0C6H, 07CH, 000H, 000H, 000H	; [e] 101
   	DB	000H, 000H, 038H, 06CH, 064H, 060H, 0F0H, 060H, 060H, 060H, 0F0H, 000H, 000H, 000H	; [f] 102
   	DB	000H, 000H, 000H, 000H, 000H, 076H, 0CCH, 0CCH, 0CCH, 07CH, 00CH, 0CCH, 078H, 000H	; [g] 103
   	DB	000H, 000H, 0E0H, 060H, 060H, 06CH, 076H, 066H, 066H, 066H, 0E6H, 000H, 000H, 000H	; [h] 104
   	DB	000H, 000H, 018H, 018H, 000H, 038H, 018H, 018H, 018H, 018H, 03CH, 000H, 000H, 000H	; [i] 105
   	DB	000H, 000H, 006H, 006H, 000H, 00EH, 006H, 006H, 006H, 006H, 066H, 066H, 03CH, 000H	; [j] 106
   	DB	000H, 000H, 0E0H, 060H, 060H, 066H, 06CH, 078H, 06CH, 066H, 0E6H, 000H, 000H, 000H	; [k] 107
   	DB	000H, 000H, 038H, 018H, 018H, 018H, 018H, 018H, 018H, 018H, 03CH, 000H, 000H, 000H	; [l] 108
   	DB	000H, 000H, 000H, 000H, 000H, 0ECH, 0FEH, 0D6H, 0D6H, 0D6H, 0C6H, 000H, 000H, 000H	; [m] 109
   	DB	000H, 000H, 000H, 000H, 000H, 0DCH, 066H, 066H, 066H, 066H, 066H, 000H, 000H, 000H	; [n] 110
   	DB	000H, 000H, 000H, 000H, 000H, 07CH, 0C6H, 0C6H, 0C6H, 0C6H, 07CH, 000H, 000H, 000H	; [o] 111
   	DB	000H, 000H, 000H, 000H, 000H, 0DCH, 066H, 066H, 066H, 07CH, 060H, 060H, 0F0H, 000H	; [p] 112
   	DB	000H, 000H, 000H, 000H, 000H, 076H, 0CCH, 0CCH, 0CCH, 07CH, 00CH, 00CH, 01EH, 000H	; [q] 113
   	DB	000H, 000H, 000H, 000H, 000H, 0DCH, 076H, 066H, 060H, 060H, 0F0H, 000H, 000H, 000H	; [r] 114
   	DB	000H, 000H, 000H, 000H, 000H, 07CH, 0C6H, 070H, 01CH, 0C6H, 07CH, 000H, 000H, 000H	; [s] 115
   	DB	000H, 000H, 010H, 030H, 030H, 0FCH, 030H, 030H, 030H, 036H, 01CH, 000H, 000H, 000H	; [t] 116
   	DB	000H, 000H, 000H, 000H, 000H, 0CCH, 0CCH, 0CCH, 0CCH, 0CCH, 076H, 000H, 000H, 000H	; [u] 117
   	DB	000H, 000H, 000H, 000H, 000H, 066H, 066H, 066H, 066H, 03CH, 018H, 000H, 000H, 000H	; [v] 118
   	DB	000H, 000H, 000H, 000H, 000H, 0C6H, 0C6H, 0D6H, 0D6H, 0FEH, 06CH, 000H, 000H, 000H	; [w] 119
   	DB	000H, 000H, 000H, 000H, 000H, 0C6H, 06CH, 038H, 038H, 06CH, 0C6H, 000H, 000H, 000H	; [x] 120
   	DB	000H, 000H, 000H, 000H, 000H, 0C6H, 0C6H, 0C6H, 0C6H, 07EH, 006H, 00CH, 0F8H, 000H	; [y] 121
   	DB	000H, 000H, 000H, 000H, 000H, 0FEH, 0CCH, 018H, 030H, 066H, 0FEH, 000H, 000H, 000H	; [z] 122
   	DB	000H, 000H, 00EH, 018H, 018H, 018H, 070H, 018H, 018H, 018H, 00EH, 000H, 000H, 000H	; [{] 123
   	DB	000H, 000H, 018H, 018H, 018H, 018H, 000H, 018H, 018H, 018H, 018H, 000H, 000H, 000H	; [|] 124
   	DB	000H, 000H, 070H, 018H, 018H, 018H, 00EH, 018H, 018H, 018H, 070H, 000H, 000H, 000H	; [}] 125
   	DB	000H, 000H, 076H, 0DCH, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	; [~] 126
   	DB	000H, 000H, 000H, 000H, 010H, 038H, 06CH, 0C6H, 0C6H, 0FEH, 000H, 000H, 000H, 000H	; [] 127


	;-----------------------------------------------------------;
	;							    ;
	;  EGA RAM Charcter Set.  8 x 14 System Font		    ;
	;							    ;
	;      Extended  ASCII Character Set (128-255)		    ;
	;							    ;
	;-----------------------------------------------------------;

rgbHercExFont8x14:
	DB	000H, 000H, 03CH, 066H, 0C2H, 0C0H, 0C0H, 0C2H, 066H, 03CH, 00CH, 006H, 07CH, 000H	; [] 128
	DB	000H, 000H, 0CCH, 0CCH, 000H, 0CCH, 0CCH, 0CCH, 0CCH, 0CCH, 076H, 000H, 000H, 000H	;  129
	DB	000H, 00CH, 018H, 030H, 000H, 07CH, 0C6H, 0FEH, 0C0H, 0C6H, 07CH, 000H, 000H, 000H	;  130
	DB	000H, 010H, 038H, 06CH, 000H, 078H, 00CH, 07CH, 0CCH, 0CCH, 076H, 000H, 000H, 000H	;  131
	DB	000H, 000H, 0CCH, 0CCH, 000H, 078H, 00CH, 07CH, 0CCH, 0CCH, 076H, 000H, 000H, 000H	;  132
	DB	000H, 060H, 030H, 018H, 000H, 078H, 00CH, 07CH, 0CCH, 0CCH, 076H, 000H, 000H, 000H	;  133
	DB	000H, 038H, 06CH, 038H, 000H, 078H, 00CH, 07CH, 0CCH, 0CCH, 076H, 000H, 000H, 000H	;  134
	DB	000H, 000H, 000H, 000H, 03CH, 066H, 060H, 066H, 03CH, 00CH, 006H, 03CH, 000H, 000H	;  135
	DB	000H, 010H, 038H, 06CH, 000H, 07CH, 0C6H, 0FEH, 0C0H, 0C6H, 07CH, 000H, 000H, 000H	;  136
	DB	000H, 000H, 0CCH, 0CCH, 000H, 07CH, 0C6H, 0FEH, 0C0H, 0C6H, 07CH, 000H, 000H, 000H	;  137
	DB	000H, 060H, 030H, 018H, 000H, 07CH, 0C6H, 0FEH, 0C0H, 0C6H, 07CH, 000H, 000H, 000H	;  138
	DB	000H, 000H, 066H, 066H, 000H, 038H, 018H, 018H, 018H, 018H, 03CH, 000H, 000H, 000H	;  139
	DB	000H, 018H, 03CH, 066H, 000H, 038H, 018H, 018H, 018H, 018H, 03CH, 000H, 000H, 000H	;  140
	DB	000H, 060H, 030H, 018H, 000H, 038H, 018H, 018H, 018H, 018H, 03CH, 000H, 000H, 000H	;  141
	DB	000H, 0C6H, 0C6H, 010H, 038H, 06CH, 0C6H, 0C6H, 0FEH, 0C6H, 0C6H, 000H, 000H, 000H	;  142
	DB	038H, 06CH, 038H, 000H, 038H, 06CH, 0C6H, 0C6H, 0FEH, 0C6H, 0C6H, 000H, 000H, 000H	;  143
	DB	018H, 030H, 060H, 000H, 0FEH, 066H, 060H, 07CH, 060H, 066H, 0FEH, 000H, 000H, 000H	;  144
	DB	000H, 000H, 000H, 000H, 0CCH, 076H, 036H, 07EH, 0D8H, 0D8H, 06EH, 000H, 000H, 000H	;  145
	DB	000H, 000H, 03EH, 06CH, 0CCH, 0CCH, 0FEH, 0CCH, 0CCH, 0CCH, 0CEH, 000H, 000H, 000H	;  146
	DB	000H, 010H, 038H, 06CH, 000H, 07CH, 0C6H, 0C6H, 0C6H, 0C6H, 07CH, 000H, 000H, 000H	;  147
	DB	000H, 000H, 0C6H, 0C6H, 000H, 07CH, 0C6H, 0C6H, 0C6H, 0C6H, 07CH, 000H, 000H, 000H	;  148
	DB	000H, 060H, 030H, 018H, 000H, 07CH, 0C6H, 0C6H, 0C6H, 0C6H, 07CH, 000H, 000H, 000H	;  149
	DB	000H, 030H, 078H, 0CCH, 000H, 0CCH, 0CCH, 0CCH, 0CCH, 0CCH, 076H, 000H, 000H, 000H	;  150
	DB	000H, 060H, 030H, 018H, 000H, 0CCH, 0CCH, 0CCH, 0CCH, 0CCH, 076H, 000H, 000H, 000H	;  151
	DB	000H, 000H, 0C6H, 0C6H, 000H, 0C6H, 0C6H, 0C6H, 0C6H, 07EH, 006H, 00CH, 078H, 000H	;  152
	DB	000H, 0C6H, 0C6H, 038H, 06CH, 0C6H, 0C6H, 0C6H, 0C6H, 06CH, 038H, 000H, 000H, 000H	;  153
	DB	000H, 0C6H, 0C6H, 000H, 0C6H, 0C6H, 0C6H, 0C6H, 0C6H, 0C6H, 07CH, 000H, 000H, 000H	;  154
	DB	000H, 018H, 018H, 03CH, 066H, 060H, 060H, 066H, 03CH, 018H, 018H, 000H, 000H, 000H	;  155
	DB	000H, 038H, 06CH, 064H, 060H, 0F0H, 060H, 060H, 060H, 0E6H, 0FCH, 000H, 000H, 000H	;  156
	DB	000H, 000H, 066H, 066H, 03CH, 018H, 07EH, 018H, 07EH, 018H, 018H, 000H, 000H, 000H	;  157
	DB	000H, 0F8H, 0CCH, 0CCH, 0F8H, 0C4H, 0CCH, 0DEH, 0CCH, 0CCH, 0C6H, 000H, 000H, 000H	;  158
	DB	000H, 00EH, 01BH, 018H, 018H, 018H, 07EH, 018H, 018H, 018H, 018H, 0D8H, 070H, 000H	;  159
	DB	000H, 018H, 030H, 060H, 000H, 078H, 00CH, 07CH, 0CCH, 0CCH, 076H, 000H, 000H, 000H	;  160
	DB	000H, 00CH, 018H, 030H, 000H, 038H, 018H, 018H, 018H, 018H, 03CH, 000H, 000H, 000H	;  161
	DB	000H, 018H, 030H, 060H, 000H, 07CH, 0C6H, 0C6H, 0C6H, 0C6H, 07CH, 000H, 000H, 000H	;  162
	DB	000H, 018H, 030H, 060H, 000H, 0CCH, 0CCH, 0CCH, 0CCH, 0CCH, 076H, 000H, 000H, 000H	;  163
	DB	000H, 000H, 076H, 0DCH, 000H, 0DCH, 066H, 066H, 066H, 066H, 066H, 000H, 000H, 000H	;  164
	DB	076H, 0DCH, 000H, 0C6H, 0E6H, 0F6H, 0FEH, 0DEH, 0CEH, 0C6H, 0C6H, 000H, 000H, 000H	;  165
	DB	000H, 03CH, 06CH, 06CH, 03EH, 000H, 07EH, 000H, 000H, 000H, 000H, 000H, 000H, 000H	;  166
	DB	000H, 038H, 06CH, 06CH, 038H, 000H, 07CH, 000H, 000H, 000H, 000H, 000H, 000H, 000H	;  167
	DB	000H, 000H, 030H, 030H, 000H, 030H, 030H, 060H, 0C6H, 0C6H, 07CH, 000H, 000H, 000H	;  168
	DB	000H, 000H, 000H, 000H, 000H, 000H, 0FEH, 0C0H, 0C0H, 0C0H, 000H, 000H, 000H, 000H	;  169
	DB	000H, 000H, 000H, 000H, 000H, 000H, 0FEH, 006H, 006H, 006H, 000H, 000H, 000H, 000H	;  170
	DB	000H, 0C0H, 0C0H, 0C6H, 0CCH, 0D8H, 030H, 060H, 0DCH, 086H, 00CH, 018H, 03EH, 000H	;  171
	DB	000H, 0C0H, 0C0H, 0C6H, 0CCH, 0D8H, 030H, 066H, 0CEH, 09EH, 03EH, 006H, 006H, 000H	;  172
	DB	000H, 000H, 018H, 018H, 000H, 018H, 018H, 03CH, 03CH, 03CH, 018H, 000H, 000H, 000H	;  173
	DB	000H, 000H, 000H, 000H, 036H, 06CH, 0D8H, 06CH, 036H, 000H, 000H, 000H, 000H, 000H	;  174
	DB	000H, 000H, 000H, 000H, 0D8H, 06CH, 036H, 06CH, 0D8H, 000H, 000H, 000H, 000H, 000H	;  175
	DB	011H, 044H, 011H, 044H, 011H, 044H, 011H, 044H, 011H, 044H, 011H, 044H, 011H, 044H	;  176
	DB	055H, 0AAH, 055H, 0AAH, 055H, 0AAH, 055H, 0AAH, 055H, 0AAH, 055H, 0AAH, 055H, 0AAH	;  177
	DB	0DDH, 077H, 0DDH, 077H, 0DDH, 077H, 0DDH, 077H, 0DDH, 077H, 0DDH, 077H, 0DDH, 077H	;  178
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H	;  179
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 0F8H, 018H, 018H, 018H, 018H, 018H, 018H	;  180
	DB	018H, 018H, 018H, 018H, 018H, 0F8H, 018H, 0F8H, 018H, 018H, 018H, 018H, 018H, 018H	;  181
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 0F6H, 036H, 036H, 036H, 036H, 036H, 036H	;  182
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 0FEH, 036H, 036H, 036H, 036H, 036H, 036H	;  183
	DB	000H, 000H, 000H, 000H, 000H, 0F8H, 018H, 0F8H, 018H, 018H, 018H, 018H, 018H, 018H	;  184
	DB	036H, 036H, 036H, 036H, 036H, 0F6H, 006H, 0F6H, 036H, 036H, 036H, 036H, 036H, 036H	;  185
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H	;  186
	DB	000H, 000H, 000H, 000H, 000H, 0FEH, 006H, 0F6H, 036H, 036H, 036H, 036H, 036H, 036H	;  187
	DB	036H, 036H, 036H, 036H, 036H, 0F6H, 006H, 0FEH, 000H, 000H, 000H, 000H, 000H, 000H	;  188
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 0FEH, 000H, 000H, 000H, 000H, 000H, 000H	;  189
	DB	018H, 018H, 018H, 018H, 018H, 0F8H, 018H, 0F8H, 000H, 000H, 000H, 000H, 000H, 000H	;  190
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 0F8H, 018H, 018H, 018H, 018H, 018H, 018H	;  191
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 01FH, 000H, 000H, 000H, 000H, 000H, 000H	;  192
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 0FFH, 000H, 000H, 000H, 000H, 000H, 000H	;  193
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 0FFH, 018H, 018H, 018H, 018H, 018H, 018H	;  194
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 01FH, 018H, 018H, 018H, 018H, 018H, 018H	;  195
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 0FFH, 000H, 000H, 000H, 000H, 000H, 000H	;  196
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 0FFH, 018H, 018H, 018H, 018H, 018H, 018H	;  197
	DB	018H, 018H, 018H, 018H, 018H, 01FH, 018H, 01FH, 018H, 018H, 018H, 018H, 018H, 018H	;  198
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 037H, 036H, 036H, 036H, 036H, 036H, 036H	;  199
	DB	036H, 036H, 036H, 036H, 036H, 037H, 030H, 03FH, 000H, 000H, 000H, 000H, 000H, 000H	;  200
	DB	000H, 000H, 000H, 000H, 000H, 03FH, 030H, 037H, 036H, 036H, 036H, 036H, 036H, 036H	;  201
	DB	036H, 036H, 036H, 036H, 036H, 0F7H, 000H, 0FFH, 000H, 000H, 000H, 000H, 000H, 000H	;  202
	DB	000H, 000H, 000H, 000H, 000H, 0FFH, 000H, 0F7H, 036H, 036H, 036H, 036H, 036H, 036H	;  203
	DB	036H, 036H, 036H, 036H, 036H, 037H, 030H, 037H, 036H, 036H, 036H, 036H, 036H, 036H	;  204
	DB	000H, 000H, 000H, 000H, 000H, 0FFH, 000H, 0FFH, 000H, 000H, 000H, 000H, 000H, 000H	;  205
	DB	036H, 036H, 036H, 036H, 036H, 0F7H, 000H, 0F7H, 036H, 036H, 036H, 036H, 036H, 036H	;  206
	DB	018H, 018H, 018H, 018H, 018H, 0FFH, 000H, 0FFH, 000H, 000H, 000H, 000H, 000H, 000H	;  207
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 0FFH, 000H, 000H, 000H, 000H, 000H, 000H	;  208
	DB	000H, 000H, 000H, 000H, 000H, 0FFH, 000H, 0FFH, 018H, 018H, 018H, 018H, 018H, 018H	;  209
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 0FFH, 036H, 036H, 036H, 036H, 036H, 036H	;  210
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 03FH, 000H, 000H, 000H, 000H, 000H, 000H	;  211
	DB	018H, 018H, 018H, 018H, 018H, 01FH, 018H, 01FH, 000H, 000H, 000H, 000H, 000H, 000H	;  212
	DB	000H, 000H, 000H, 000H, 000H, 01FH, 018H, 01FH, 018H, 018H, 018H, 018H, 018H, 018H	;  213
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 03FH, 036H, 036H, 036H, 036H, 036H, 036H	;  214
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 0FFH, 036H, 036H, 036H, 036H, 036H, 036H	;  215
	DB	018H, 018H, 018H, 018H, 018H, 0FFH, 018H, 0FFH, 018H, 018H, 018H, 018H, 018H, 018H	;  216
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 0F8H, 000H, 000H, 000H, 000H, 000H, 000H	;  217
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 01FH, 018H, 018H, 018H, 018H, 018H, 018H	;  218
	DB	0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH	;  219
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH	;  220
	DB	0F0H, 0F0H, 0F0H, 0F0H, 0F0H, 0F0H, 0F0H, 0F0H, 0F0H, 0F0H, 0F0H, 0F0H, 0F0H, 0F0H	;  221
	DB	00FH, 00FH, 00FH, 00FH, 00FH, 00FH, 00FH, 00FH, 00FH, 00FH, 00FH, 00FH, 00FH, 00FH	;  222
	DB	0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 000H, 000H, 000H, 000H, 000H, 000H, 000H	;  223
	DB	000H, 000H, 000H, 000H, 000H, 076H, 0DCH, 0D8H, 0D8H, 0DCH, 076H, 000H, 000H, 000H	;  224
	DB	000H, 000H, 000H, 000H, 07CH, 0C6H, 0FCH, 0C6H, 0C6H, 0FCH, 0C0H, 0C0H, 040H, 000H	;  225
	DB	000H, 000H, 0FEH, 0C6H, 0C6H, 0C0H, 0C0H, 0C0H, 0C0H, 0C0H, 0C0H, 000H, 000H, 000H	;  226
	DB	000H, 000H, 000H, 000H, 0FEH, 06CH, 06CH, 06CH, 06CH, 06CH, 06CH, 000H, 000H, 000H	;  227
	DB	000H, 000H, 0FEH, 0C6H, 060H, 030H, 018H, 030H, 060H, 0C6H, 0FEH, 000H, 000H, 000H	;  228
	DB	000H, 000H, 000H, 000H, 000H, 07EH, 0D8H, 0D8H, 0D8H, 0D8H, 070H, 000H, 000H, 000H	;  229
	DB	000H, 000H, 000H, 000H, 066H, 066H, 066H, 066H, 07CH, 060H, 060H, 0C0H, 000H, 000H	;  230
	DB	000H, 000H, 000H, 000H, 076H, 0DCH, 018H, 018H, 018H, 018H, 018H, 000H, 000H, 000H	;  231
	DB	000H, 000H, 07EH, 018H, 03CH, 066H, 066H, 066H, 03CH, 018H, 07EH, 000H, 000H, 000H	;  232
	DB	000H, 000H, 038H, 06CH, 0C6H, 0C6H, 0FEH, 0C6H, 0C6H, 06CH, 038H, 000H, 000H, 000H	;  233
	DB	000H, 000H, 038H, 06CH, 0C6H, 0C6H, 0C6H, 06CH, 06CH, 06CH, 0EEH, 000H, 000H, 000H	;  234
	DB	000H, 000H, 01EH, 030H, 018H, 00CH, 03EH, 066H, 066H, 066H, 03CH, 000H, 000H, 000H	;  235
	DB	000H, 000H, 000H, 000H, 000H, 07EH, 0DBH, 0DBH, 07EH, 000H, 000H, 000H, 000H, 000H	;  236
	DB	000H, 000H, 003H, 006H, 07EH, 0DBH, 0DBH, 0F3H, 07EH, 060H, 0C0H, 000H, 000H, 000H	;  237
	DB	000H, 000H, 01CH, 030H, 060H, 060H, 07CH, 060H, 060H, 030H, 01CH, 000H, 000H, 000H	;  238
	DB	000H, 000H, 000H, 07CH, 0C6H, 0C6H, 0C6H, 0C6H, 0C6H, 0C6H, 0C6H, 000H, 000H, 000H	;  239
	DB	000H, 000H, 000H, 0FEH, 000H, 000H, 0FEH, 000H, 000H, 0FEH, 000H, 000H, 000H, 000H	;  240
	DB	000H, 000H, 000H, 018H, 018H, 07EH, 018H, 018H, 000H, 000H, 0FFH, 000H, 000H, 000H	;  241
	DB	000H, 000H, 030H, 018H, 00CH, 006H, 00CH, 018H, 030H, 000H, 07EH, 000H, 000H, 000H	;  242
	DB	000H, 000H, 00CH, 018H, 030H, 060H, 030H, 018H, 00CH, 000H, 07EH, 000H, 000H, 000H	;  243
	DB	000H, 000H, 00EH, 01BH, 01BH, 018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H	;  244
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H, 0D8H, 0D8H, 070H, 000H, 000H, 000H	;  245
	DB	000H, 000H, 000H, 018H, 018H, 000H, 07EH, 000H, 018H, 018H, 000H, 000H, 000H, 000H	;  246
	DB	000H, 000H, 000H, 000H, 076H, 0DCH, 000H, 076H, 0DCH, 000H, 000H, 000H, 000H, 000H	;  247
	DB	000H, 038H, 06CH, 06CH, 038H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	;  248
	DB	000H, 000H, 000H, 000H, 000H, 000H, 018H, 018H, 000H, 000H, 000H, 000H, 000H, 000H	;  249
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 018H, 000H, 000H, 000H, 000H, 000H, 000H	;  250
	DB	000H, 00FH, 00CH, 00CH, 00CH, 00CH, 00CH, 0ECH, 06CH, 03CH, 01CH, 000H, 000H, 000H	;  251
	DB	000H, 0D8H, 06CH, 06CH, 06CH, 06CH, 06CH, 000H, 000H, 000H, 000H, 000H, 000H, 000H	;  252
	DB	000H, 070H, 0D8H, 030H, 060H, 0C8H, 0F8H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	;  253
	DB	000H, 000H, 000H, 000H, 07CH, 07CH, 07CH, 07CH, 07CH, 07CH, 000H, 000H, 000H, 000H	;  254
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	;  255

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\hercules.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	hercules.asm : for Hercules monographics, graphics plus, & in-color
;*****************************************************************************

	include	csd_head.inc

	include	csd_data.inc

;*****************************************************************************

	include	csd_code.asm			;* first part of code

;*	* Display modes table
rgdm:
;* for text mode, mode = 0 (9x14), 1 (8x10)
;* for graphics mode, mode = 5 just for identification
;* #0 - standard monochrome text mode (9 x 14 characters)
	DB	fvmHerc102 or fvmHerc112 or fvmHerc222	;* hardware needed
	DB	fvmMD
	DB	7				;* mode
	DW	finstText OR finstMonochrome
	DB	80, 25				;* screen size
	DB	2				;* coMac
	DB	9, 14, 0, 0			;* INFT
	DW	0B000H				;* video address
	DW	0b0cH				;* cursor
	DW	0				;* extra (RamFont info)
	Assert	<($-rgdm) EQ SIZE DM>
;* #1 - RamFont 80 x 25 (9 x 14 characters)
	DB	fvmHerc112 or fvmHerc222	;* hardware needed
	DB	fvmMD
	DB	7				;* mode
	DW	finstText OR finstMonochrome OR finstFont
	DB	80, 25				;* screen size
	DB	2				;* coMac
	DB	9, 14, 0, 0			;* INFT
	DW	0				;* video address
	DW	0b0cH				;* cursor
	DW	14				;* extra (RamFont info)
;* #2 - RamFont 90 x 35 (8x 10 characters)
	DB	fvmHerc112 or fvmHerc222	;* hardware needed
	DB	fvmMD
	DB	7				;* mode
	DW	finstText OR finstMonochrome OR finstFont
	DB	90, 35				;* screen size
	DB	2				;* coMac
	DB	8, 10, 0, 0			;* INFT
	DW	0				;* video address
	DW	0809H				;* cursor
	DW	10				;* extra (RamFont info)
;* #3 - standard color text mode (9 x 14 characters)
	DB	fvmHerc222			;* hardware needed
	DB	fvmECD
	DB	7				;* mode
	DW	finstText
	DB	80, 25				;* screen size
	DB	16				;* coMac
	DB	9, 14, 0, 0			;* INFT
	DW	0B000H				;* video address
	DW	0b0cH				;* cursor
	DW	0				;* extra (RamFont info)

;* #4 - (4K) RamFont 90 x 35 (8x 10 characters)
	DB	fvmHerc222			;* hardware needed
	DB	fvmECD
	DB	7				;* mode
	DW	finstText 
	DB	90, 35				;* screen size
	DB	16				;* coMac
	DB	8, 10, 0, 0			;* INFT
	DW	0B000H				;* video address
	DW	0809H				;* cursor
	DW	16				;* extra (RamFont info)

;* #5 - standard monochrome graphics text mode (8 x 14 characters)
	DB	fvmHerc102 or fvmHerc112 	;* hardware needed
	DB	fvmMD
	DB	5				;* mode
	DW	finstGraphics OR finstMonochrome OR finstFont
	DB	90, 25				;* screen size
	DB	2				;* coMac
	DB	8, 14, 0, 0			;* INFT
	DW	0				;* video address
	DW	0C0DH				;* cursor
	DW	0				;* extra (RamFont info)

;* #6 - standard monochrome graphics text mode (8 x 8 characters)
	DB	fvmHerc102 or fvmHerc112 	;* hardware needed
	DB	fvmMD
	DB	5				;* mode
	DW	finstGraphics OR finstMonochrome OR finstFont
	DB	90, 43				;* screen size
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* extra (RamFont info)
  
;* #7 - standard color graphics text mode (8 x 14 characters)
	DB	fvmHerc222			;* hardware needed
	DB	fvmECD
	DB	5				;* mode
	DW	finstGraphics OR finstFont
	DB	90, 25				;* screen size
	DB	16				;* coMac
	DB	8, 14, 0, 0			;* INFT
	DW	0				;* video address
	DW	0C0DH				;* cursor
	DW	0				;* extra (RamFont info)

lastdm:		;* This points to the last (best) DM entry
;* #8 - standard color graphics text mode (8 x 8 characters)
	DB	fvmHerc222			;* hardware needed
	DB	fvmECD
	DB	5				;* mode
	DW	finstGraphics OR finstFont
	DB	90, 43				;* screen size
	DB	16				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* extra (RamFont info)


cdmMax	equ	($ - rgdm) / (size DM)		;* # of modes

;*****************************************************************************

;*	* initialization bytes for 6845
rgbInit	label	byte
cRegInit	equ	12		;* number of registers to load

rgb9x14	db	61h, 50h, 52h, 0fh		;* 80 x 25 (9 x 14 characters)
	db	19h, 06h, 19h, 19h
	db	02h, 0dh, 0bh, 0ch

rgb8x10	db	6dh, 5ah, 5ch, 0fh		;* 90 x 35 (8 x 10 characters)
	db	24h, 00h, 23h, 23h
	db	02h, 09h, 07h, 08h

GTABLE		EQU	THIS BYTE
		DB	53, 45, 46, 7, 91, 2, 87, 87, 2, 3, 0, 0, 0, 0, 0, 0

;*****************************************************************************
hgcIndex	equ	03b4h		;* 6845 index register
hgcControl	equ	03b8h		;* display mode control port
hgcStatus	equ	03bah		;* Display Status Port
hgcConfig	equ	03bfh		;* configuration port
xmodereg	equ	14h		;* xMode register
scorereg	equ	15h		;* underscore register
strikereg	equ	16h		;* overstrike register
exceptreg	equ	17h		;* exception register
fHercGr		equ	82h		;* bits for turning on Hercules graphics mode
fHercTxt	equ	00h		;* bits for turning on Hercules text mode
fHercVideo	equ	08h		;* bits for turning on Hercules video
idmask_222	equ	01110000b
idcode_222	equ	01010000b
idmask_112	equ	00110000b
idcode_112	equ	00010000b
RamFontON	EQU	00000001B	; 0 - ROM generator (normal text)
					; 1 - RamFont ON
CharacterWidth	EQU	00000010B	; 0 - 9 bits wide, 1 - 8 bits wide
RamFont_48k	EQU	00000100B	; 0 - 4k RamFont, 1 - 48k RamFont
ramfont_48k_9d	equ	RamFont_48k OR RamFontON
ramfont_48k_8d	equ	RamFont_48k OR CharacterWidth OR RamFontON
ramfont_4k_8d	equ	CharacterWidth OR RamFontON
text_buf_seg	equ	0b000h
ramfont_seg	equ	0b400h

;* for RamFont modes:
hbold	equ	80h
hrev	equ	40h
hstrike	equ	20h
hunder	equ	10h
hnormal	equ	0
;each 256 font table eats up 4K, so 48K RamFont can store up to 12 fonts
font1	equ	0	;this is the italics font
font2	equ	1	;this is the italics+overstrike font
font3	equ	2	;this is the superscript font, also minicaps
font4	equ	3	;superscript+overstrike, also minicaps+overstrike
font5	equ	4	;superscript+italics, also minicaps+italics
font6	equ	5	;superscript+italics+overstrike, and mini+ital+strike
font7	equ	6	;the subscript font
font8	equ	7	;contains the normal font
font9	equ	8	;contains the normal+overstrike font
font10	equ	9	;the subscript+overstrike font
font11	equ	10	;the subscript+italics font
font12	equ	11	;the subscript+italics+overstrike font
;*****************************************************************************

NonStandard	FvmGetCur
NonStandard	ImodeGuessCurrentCsd
NonStandard	FQueryInftCsd
NonStandard	FInitCsd
NonStandard	MoveHwCursCsd
NonStandard	DoUpdateCsd
NonStandard	TermCsd			
NonStandard	FQueryInstCsd		;temporary

;*****************************************************************************

;********** ImodeGuessCurrentCsd **********
;*	
;*	*This version starts guessing from the best mode

cProc	ImodeGuessCurrentCsd, <FAR, PUBLIC, ATOMIC>, <SI,DI>
cBegin	ImodeGuessCurrentCsd

	mov	di,OFF_lpwDataCsd

	cCall	FvmGetCur		;* get fvm

	push	ax
	cCall	ModeGetCur		;* al = mode, ah = ayMac (0=>unknown)
	pop	bx			;* bx = fvm

;*	* Search for current mode and fvm in rgdm

	mov	si,drvOffset lastdm	;* start from last (best) mode
	mov	cx,cdmMax
	mov	dx,cx
	dec	dx

;*	* al = current mode, ah = ayMac (or 0=>unknown)
;*	* bx = fvm
;*	* si = pdm
;*	* dx = idm = imode
;*	* cx = loop count

imgc_next:
	cmp	al,cs:[si].modeDm
	jne	@F
	test	bl,cs:[si].fvmReqAdapDm
	jz	@F				
	test	bh,cs:[si].fvmReqDispDm
	jz	@F			;* not available
	or	ah,ah
	jz	imgc_end		;* height unknown => use this one
	cmp	ah,cs:[si].ayMacDm
	jz	imgc_end		;* same height => use this one

@@:
	sub	si,size DM
	dec	dx
	loop	imgc_next
	mov	dx,-1			;* unknown
imgc_end:	;* dx = imode
	mov	ax,dx			;* guess this mode

cEnd	ImodeGuessCurrentCsd


;********** FQueryInstCsd **********
;*	* CSD entry point (see documentation for interface)

cProc	FQueryInstCsd, <FAR, PUBLIC, ATOMIC>, <si, di>
    parmDP pinst
    parmW imode
    localW fvm
cBegin	FQueryInstCsd

	mov	di,OFF_lpwDataCsd
	cCall	FvmGetCur	;* find out what we got ...
				;* will query hardware + codepage first call
	mov	fvm,ax

	mov	cx,[di].codepageBase
	mov	si,imode
	cmp	si,cdmMax
	jb	got_imode
;*	* see if alternate code page
	mov	cx,[di].codepageAlt		; Bail if no alternate
	jcxz	fail_query			;   codepage.

	cmp	cx,[di].codepageBase		; Bail if alternate codepage
	je	fail_query			;   is the same as base.

	sub	si,cdmMax			;* back to mode 0
	cmp	si,cdmMax			;* times 2 for alternate code page
	jb	got_imode
fail_query:
	xor	ax,ax			;* failure
	jmp	end_qmode

got_imode: ;* si = imode, cx = codepage
	mov	ax,SIZE DM
	mul	si
	mov	si,ax
	add	si,drvOffset rgdm		;* CS:SI => INST info

;*	* copy DM info into INST
	mov	di,pinst			;* ds:di => dest
;*	* clear out the INST structure
	push	cx				;* save codepage
	push	di
	push	ds
	pop	es
	mov	cx,cbInstMin / 2
	xor	ax,ax
	rep stosw
	pop	di
	pop	ds:[di].codepageInst

;*	* move information from DM to INST
	;* finst
	mov	ax,fvm
	mov	dx,cs:[si].finstDm
	test	al,cs:[si].fvmReqAdapDm
	jz	@F
	test	ah,cs:[si].fvmReqDispDm
	jz	@F
	or	dx,finstAvailable	;* this mode is currently available
@@: ;* dx = finst
	mov	ds:[di].finstInst,dx

IFDEF EARLIER
	Assert	<ayMacDm EQ axMacDm+1>
	Assert	<ayMacInst EQ axMacInst+1>
	;* axMac, ayMac
	mov	dx,word ptr cs:[si].axMacDm
ELSE
	mov	dl,cs:[si].axMacDm
	mov	dh,cs:[si].ayMacDm
ENDIF
	mov	wo ds:[di].axMacInst,dx		;* move both axMac and ayMac
	;* coMac, covMac, coiMac
	mov	dl,cs:[si].coMacDm
	mov	ds:[di].coMacInst,dl
	cCall	CoiCovFromFvm			;* al = fvm
	mov	ds:[di].covMacInst,ah
	mov	ds:[di].coiMacInst,dx

	;* INFT information
	Assert	<dyCharDm EQ dxCharDm+1>
	Assert	<dyCharInft EQ dxCharInft+1>
	mov	dx,word ptr cs:[si].dxCharDm
	test	cs:[si].finstDm,finstGraphics	;!!!REVIEW
	jz	@F
	mov	word ptr ds:[di].inftInst.dxCharInft,dx
					;* move both dxChar and dyChar
@@:
	mov	dl,cs:[si].dyBaseDm
	mov	ds:[di].inftInst.dyBaseLineInft,dl
	mov	al,cs:[si].ifontDm
	cCall	GetPfonts
	mov	ds:[di].inftInst.OFF_lpbFontLower128Inft,AX
	mov	ds:[di].inftInst.SEG_lpbFontLower128Inft,DX
	mov	ds:[di].inftInst.OFF_lpbFontUpper128Inft,BX
	mov	ds:[di].inftInst.SEG_lpbFontUpper128Inft,CX

	;* Buffer info
	mov	ax,cs:[si].psVideoDm
	mov	ds:[di].psPrimInst,ax
	AssertEQ ds:[di].psSecInst,0
	AssertEQ ds:[di].cwExtraInst,0

;*	* set private info (store pointer to DM in the INST structure)
	mov	[di].pdmInst,si

	mov	ax,sp				;* ok
end_qmode:

cEnd	FQueryInstCsd


;********** FvmGetCur **********
;*	* Identify the current screen and return the appropriate fvm in AL
;*	* NOTE:	This is a NEAR routine.
;*	*	This routine may trash AX, BX, CX, DX, SI, DI, or ES
;*	exit:	AL == fvm for current screen or 0 if no supported screen found

cProc	FvmGetCur, <NEAR, PUBLIC, ATOMIC>, <DS>
cBegin	FvmGetCur

	AssertEQ di,OFF_lpwDataCsd
	mov	al,[di].fvmCurAdap
	mov	ah,[di].fvmCurDisp
	or	ax,ax
	jz	init_get
	jmp	end_fvm_get

init_get:	;* initial get
	MOV	DX,hgcStatus		; First check for a GB112
	XOR	BX,BX			; Start with no 112 or 222 successes
	MOV	CX,100			; Get a majority for 100 tries

Check_GB112:
	IN	AL,DX
	AND	AL,idmask_222		; Strip to just the 222 bits
	CMP	AL,idcode_222		; Check for the GB222 id code
	JNE	Check_112		; No - skip to test for 112
	INC	BH			; Count another 222 success

Check_112:
	AND	AL,idmask_112		; Strip furthur, to just the 112 bits
	CMP	AL,idcode_112		; Check for the GB112 id code
	JNE	Check_Again		; No - skip
	INC	BL			; Count another 112 success

Check_Again:
	LOOP	Check_GB112		; Loop back and check again
	CMP	BL,50			; Did we get a majority of 112 hits?
	JBE	Check_GB102		; If not, check for a Hercules GB102
	mov	ax,fvmHerc112		; Indicate we have a GB112
	CMP	BH,50			; Did we get a majority for the 222?
	JBE	FvmQueryRet
	mov	ax,fvmHerc222		; Indicate we have a GB222
Not_GB222:
	JMP	SHORT FvmQueryRet	; Skip the GB102 check

Check_GB102:
	MOV	DX,hgcStatus 		; Bit 7 at port 3BA changes pretty often
	MOV	CX,0FFFFH		; on a Hercules so check it to see if
	IN	AL,DX			; it flips.
	MOV	BL,AL

INIThLp:
	IN	AL,DX			; Current value of Port 3BA
	XOR	AL,BL			; XOR to see if it changes
	OR	AL,AL			; Did it?
	JS	INITh1			; Yes, we must have a Hercules
	LOOP	INIThLp 		; No, try again
	xor	ax,ax
	JMP	SHORT end_fvm_get	; If we didn't get it, give up

INITh1:
	mov	ax,fvmHerc102		;* Indicate we have a GB102
FvmQueryRet:
	mov	ah,0ffh			;* currently allow all monitors
	mov	[di].fvmCurAdap,al
	mov	[di].fvmCurDisp,ah
	mov	[di].codepageBase,437		;* assume standard ASCII
	mov	[di].codepageAlt,0		;* assume no alternate
end_fvm_get: ;* ax = fvm

cEnd	FvmGetCur


;********** FInitCsd **********
;*	entry:
;*		pinch = near pointer to INCH structure to fill
;*	* Initialize the screen to the given mode
;*	exit:	AX != 0 if ok

cProc	FInitCsd, <FAR, PUBLIC, ATOMIC>, <DI,SI>
    parmDP pinst
    parmDP pinch
    localB bRamFont
cBegin	FInitCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment

;*	* set mode
	mov	bx,pinst
	mov	[di].pinstDrv,bx
	mov	bx,ds:[bx].pdmInst		;* CS:BX => DM info

;*	* copy mode info into driver globals
	mov	ax,cs:[bx].vparmCursOnDm
	mov	[di].vparmCursOn,ax
	mov	ax,cs:[bx].wExtraDm
	mov	[di].wExtra,ax
	mov	bRamFont,al			;* save the RamFont info byte

	mov	dx,hgcConfig		
	mov	al,3				;* use 48K RamFont mode
	out	dx,al

;set hgc full
	mov	dx,hgcIndex
	mov	ax,(20h SHL 8) OR exceptreg	;* reg 17
	test	cs:[bx].fInstDm,fInstMonochrome
	jnz	SetMono
	xor	ah,ah
SetMono:
	out	dx,ax

	test	cs:[bx].finstDm,fInstGraphics
	jz	notGraf

;*** Graphics mode
	
	xor	ah,ah
	mov	al,cs:[bx].dyCharDm		;points
	mov	[di].ayBox,ax

	mov	al,40h			;segBios
	mov	es,ax
	mov	di,49h			;CRT_MODE
	mov	byte ptr es:[di],5	;fake mode 6 for mouse sake
	mov	di,4Ah			;CRT_COLS
	mov	word ptr es:[di],90	;
	mov	di,84h			;CRT_ROWS
	mov	al,cs:[bx].ayMacDm 	;rows - 1
	dec	al
	mov	byte ptr es:[di],al	
		
	mov	dx,hgcControl		;set graphics mode
	mov	al,fHercGr
	out	dx,al
	mov	dx,hgcIndex		;write index register
	mov	cx,16
	xor	bx,bx
IN9hLp:
	mov	ah,cs:GTABLE[bx]	
	mov	al,bl
	out	dx,ax
	jmp	$ + 2
	inc	bx
	loop	IN9hLp

	mov	ch,40h
	mov	ax,0B800h
	mov	es,ax
	xor	di,di
	mov	ax,di
	rep	stosw
	mov	ax,fHercGr
	push	ax
	jmp	FInitRet

;*** Text mode

notGraf:
	xor	ah,ah
	mov	al,40h
	mov	es,ax
	mov	si,49h			;CRT_MODE
	mov	byte ptr es:[si],7	
	mov	si,4Ah			;CRT_COLS
	mov	al,cs:[bx].axMacDm
	mov	word ptr es:[si],ax	
	mov	si,84h			;CRT_ROWS
	mov	al,cs:[bx].ayMacDm 	;rows - 1
	dec	al
	mov	byte ptr es:[si],al	

	mov	si,drvOffset rgbInit	;default 80x25 (9x14 font)
	cmp	cs:[bx].ayMacDm,35	
	jne	@F
	add	si,cRegInit		;use 90x35 (8x10 font) 
@@:
	mov	ax,fHercTxt
	push	ax			; save mode byte
	mov	dx,hgcControl		; set to graphics or text mode...
	out	dx,al			;   ... with video off

	mov	dx,hgcIndex		; initialize 6845 chip with table
	mov	cx,cRegInit		;
	xor	ah,ah			;
	cld				;
SMloop:
	mov	al,ah			;
	out	dx,al			; send register number to index port
	inc	dx			;
	lods	byte ptr cs:[si]	; get byte of data to send
	out	dx,al			; and send it to index+1
	jmp	$ + 2			; WARNING -- THIS DELAY IS REQUIRED
	jmp	$ + 2			; FOR 8MHz ATs!
	inc	ah			;
	dec	dx			;
	loop	SMloop			; loop until all 16 bytes are output

	;dx = hgcIndex
	mov	al,bRamFont
	cmp	al,16
	je	Init8x10Color
	cmp	al,14
	je	Init9x14
	cmp	al,10
	je	Init8x10

;select ROM character generator
	MOV	AX,(0) OR xmodereg
	OUT	DX,AX

;set underscore at 14
	MOV	AX,(13 SHL 8) OR scorereg
	OUT	DX,AX

	jmp	short FInitRet

Init8x10Color:
	cCall	Init4KRamFont8x10
	jmp	short FInitRet

Init8x10:
	cCall	InitRamFont8x10
	jmp	short FInitRet

Init9x14:
	cCall	InitRamFont9x14

;*	* the INCH array already contains the standard Code Page 437
;*	*  character set, so it usually can be left the same.

FInitRet:
	pop	ax			; now turn video on
	or	al,fHercVideo		;
	mov	dx,hgcControl		;
	out	dx,al			;

	mov	ax,sp				;* success
cEnd	FInitCsd


;********** InitRamFont9x14 **********
;*	Loads the RamFont memory with the 9x14 fonts
;*	entry:	DX = hgcIndex

cProc	InitRamFont9x14, <NEAR>, <ds, si, di>
cBegin	InitRamFont9x14

;* This code is from QINTER (MCV9X14.ASM):

;select 48k ramfont
	MOV	AX,(ramfont_48k_9d SHL 8) OR xmodereg
	OUT	DX,AX

;set underscore at 14
	MOV	AX,(13 SHL 8) OR scorereg
	OUT	DX,AX

;set overstrike at 13, it becomes double underline
	MOV	AX,(12 SHL 8) OR strikereg
	OUT	DX,AX

;load the fonts into ramfont memory
;first, clear all of ramfont memory
	mov	bx,ramfont_seg		
	mov	es,bx
	MOV	CX,6000H		;48K bytes
	XOR	AX,AX
	MOV	DI,AX
rep	stosw

;load the normal font into t8
	mov	bx,cs
	mov	ds,bx
	mov	si,offset rgbHercFont9x14
	mov	di,7000h
	mov	bx,256

mak_norm:
	MOV	CL,7			; CH = 0 from last REP
rep	movsw
	INC	DI
	INC	DI
	dec	bx
	jnz	mak_norm

;copy the normal font into t9
	mov	bx,es
	mov	ds,bx
	mov	di,8000h
	mov	si,7000h
	MOV	CH,8			; CL = 0 from last REP
rep	movsw

;create the normal strike font
	mov	di,8000h + 7
	MOV	CH,1			; CL = 0 from last REP
	mov	ax,0ffh

make_str:
	stosb
	add	di,15
	loop	make_str

;create the superscript font
	mov	di,2000h
	mov	si,7000h + 1
	MOV	CH,1			; CL = 0 from last REP

mak_super:
	movsw
	INC	SI
	movsw
	movsw
	INC	SI
	movsw
	movsw
	add	si,4
	add	di,6
	loop	mak_super

;fix a few individual characters to be acceptable
;start with the lower case superscript e
	mov	di,2650h + 6
	mov	al,60h
	stosb

;fix the lower case superscript j
	mov	di,26a0h + 6
	mov	al,36h
	stosb
	mov	al,1ch
	stosb
	XOR	AL,AL
	MOV	CL,3			; CH = 0 from last LOOP
rep	stosb

;fix the lower case superscript s
	mov	di,2730h + 3
	mov	al,3eh
	stosb
	mov	al,60h
	stosb
	mov	al,3eh
	stosb
	mov	al,3
	stosb
	mov	al,3eh
	stosb

;create the superscript+overstrike font
	mov	si,2000h
	mov	di,3000h
	MOV	CH,8			; CL = 0 from last REP
rep	movsw
	mov	di,3000h + 4
	mov	ax,0ffh
	MOV	CH,1			; CL = 0 from last REP

mak_sup_str:
	stosb
	add	di,15
	loop	mak_sup_str

;create the subscript font
	mov	di,6000h + 6
	mov	si,2000h
	mov	cx,800h - 3
rep	movsw

;help a few of the subscripted characters to look better
;start with the subscripted lower case g
	mov	di,6670h + 6 - 2	;shift up by 2
	mov	si,6670h + 6
	MOV	CL,5			; CH = 0 from last REP
	XOR	AX,AX
rep	movsw
	stosw
;fix the subscripted lower case p
	mov	di,6700h + 6 - 2	;shift up by 2
	mov	si,6700h + 6
	MOV	CL,5			; CH = 0 from last REP
rep	movsw
	stosw

;fix the subscripted lower case q
	mov	di,6710h + 6 - 2	;shift up by 2
	mov	si,6710h + 6
	MOV	CL,5			; CH = 0 from last REP
rep	movsw
	stosw

;fix the subscript lower case y
	mov	di,6790h + 6 - 2	;shift up by 2
	mov	si,6790h + 6
	MOV	CL,5			; CH = 0 from last REP
rep	movsw
	stosw

;create the subscript+overstrike font
	mov	di,9000h
	mov	si,6000h
	MOV	CH,8			; CL = 0 from last REP
rep	movsw
	mov	di,9000h + 10
	NOT	AL			; AX = 0FFH
	MOV	CH,1			; CL = 0 from last REP

mak_sub_str:
	stosb
	add	di,15
	loop	mak_sub_str

;create the italic font
mak_ital:
	mov	ax,ramfont_seg
	mov	es,ax
	mov	ds,ax
	cld
	mov	si,7000h
	XOR	DI,DI
	mov	cx,800h
rep	movsw
	mov	bx,256
	XOR	SI,SI
	MOV	DI,SI

itals0:
	MOV	CL,5			; CH = 0 from last REP

itals1:
	lodsb
	shr	al,1
	stosb
	loop	itals1
	add	di,3
	add	si,3
	MOV	CL,4			; CH = 0 from last REP

itals2:
	lodsw
	shl	al,1
	shl	ah,1
	stosw
	loop	itals2
	dec	bx
	jnz	itals0

;create the italics+overstrike font

do_ital_str:
	mov	di,1000h
	XOR	SI,SI
	MOV	CH,8			; CL = 0 from last LOOP
rep	movsw
	MOV	CH,1			; CL = 0 from last REP
	mov	ax,0ffh
	mov	di,1000h + 7

mak_ital_str:
	stosb
	add	di,15
	loop	mak_ital_str

;create the superscript+italics font
	mov	di,4000h
	mov	si,2000h
	MOV	CH,8			; CL = 0 from last LOOP
rep	movsw
	mov	si,4000h
	MOV	DI,SI
	MOV	CH,1			; CL = 0 from last REP

mak_sup_ital:
	push	cx
	lodsw
	shr	ah,1
	shr	al,1
	stosw
	lodsb
	shr	al,1
	stosb
	INC	SI
	INC	SI
	INC	DI
	INC	DI
	mov	cx,4

sh_lft:
	lodsw
	shl	ah,1
	shl	al,1
	stosw
	loop	sh_lft
	add	si,3
	add	di,3
	pop	cx
	loop	mak_sup_ital

;create the superscript+italics+overstrike font
	mov	si,4000h
	mov	di,5000h
	MOV	CH,8			; CL = 0 from last LOOP
rep	movsw
	mov	di,5000h + 4
	mov	ax,0ffh
	MOV	CH,1			; CL = 0 from last REP

mak_sup_istr:
	stosb
	add	di,15
	loop	mak_sup_istr

;create the subscript+italics font
	mov	di,0a000h + 6
	mov	si,4000h
	mov	cx,800h - 3
rep	movsw

;help a few of the subscripted characters to look better
;start with the subscripted lower case g
	mov	di,0a670h + 6 - 2	;shift up by 2
	mov	si,0a670h + 6
	MOV	CL,5			; CH = 0 from last REP
	XOR	AX,AX
rep	movsw
	stosw
;fix the subscripted lower case p
	mov	di,0a700h + 6 - 2	;shift up by 2
	mov	si,0a700h + 6
	MOV	CL,5			; CH = 0 from last REP
rep	movsw
	stosw

;fix the subscripted lower case q
	mov	di,0a710h + 6 - 2	;shift up by 2
	mov	si,0a710h + 6
	MOV	CL,5			; CH = 0 from last REP
rep	movsw
	stosw

;fix the subscript lower case y
	mov	di,0a790h + 6 - 2	;shift up by 2
	mov	si,0a790h + 6
	MOV	CL,5			; CH = 0 from last REP
rep	movsw
	stosw

;create the subscript+italics+overstrike font
	mov	di,0b000h
	mov	si,0a000h
	MOV	CH,8			; CL = 0 from last REP
rep	movsw
	mov	di,0b000h + 10
	NOT	AL			; AX = 0FFH
	MOV	CH,1			; CL = 0 from last REP

mak_sub_ita_str:
	stosb
	add	di,15
	loop	mak_sub_ita_str

;make the mini caps font
	mov	si,2410h
	mov	di,2010h
	XOR	AX,AX
	stosw
	stosb
	MOV	CL,26 * 8 - 2		; CH = 0 from last LOOP
rep	movsw

;make the mini caps+overstrike font
	mov	si,3410h
	mov	di,3010h
	stosw
	stosb
	MOV	CL,26 * 8 - 2		; CH = 0 from last REP
rep	movsw

;make the mini caps italics characters
	mov	si,4410h
	mov	di,4010h
	stosw
	stosb
	MOV	CL,26 * 8 - 2		; CH = 0 from last REP
rep	movsw

;make the mini caps and italics overstrike font
	mov	si,5410h
	mov	di,5010h
	stosw
	stosb
	MOV	CL,26 * 8 - 2		; CH = 0 from last REP
rep	movsw

cEnd	InitRamFont9x14


;********** InitRamFont8x10 **********
;*	Loads the RamFont memory with the 8x10 fonts

cProc	InitRamFont8x10, <NEAR>, <ds, si, di>
cBegin	InitRamFont8x10

;* This code is from QINTER (MCV9X14.ASM):

;select 48k ramfont
	MOV	AX,(ramfont_48k_8d SHL 8) OR xmodereg	
	OUT	DX,AX

;set underscore at 10
	MOV	AX,(9 SHL 8) OR scorereg
	OUT	DX,AX

;set overstrike at 9
	MOV	AX,(8 SHL 8) OR strikereg
	OUT	DX,AX

;load the fonts into ramfont memory
;first clear all of ramfont memory
	mov	bx,ramfont_seg		; 0b400h
	mov	es,bx
	MOV	CH,60H			; CL = 0 from last LOOP
	XOR	AX,AX
	MOV	DI,AX			; start from b000:4000
rep	stosw

;load the normal font into t8
;	mov	bx,segROM
	mov	bx,0f000h		; PC ROM Fonts (0-127)
	mov	ds,bx
;	mov	si,offset rgFont
	mov	si,0fa6eh
	mov	di,7000h + 1		;t8
	mov	bx,128

norm88:
	MOV	CL,4			; CH = 0 from last REP
rep	movsw
	add	di,8
	dec	bx
	jnz	norm88

	mov	bx,cs			; Hard coded Fonts (128-255)
	mov	ds,bx
	mov	si,offset rgbHercExFont8x10
	mov	bx,128
	dec	di

norm188:
	MOV	CL,5			; CH = 0 from last REP
rep	movsw
	add	di,6
	dec	bx
	jnz	norm188

;copy the normal font into t9
	mov	bx,es
	mov	ds,bx
	mov	di,8000h		;t9
	mov	si,7000h
	MOV	CH,8			; CL = 0 from last REP
rep	movsw

;create the normal strike font
	mov	di,8000h + 4
	MOV	CH,1			; CL = 0 from last REP
	NOT	AL			; AX = 0FFH

norm_str88:
	stosb
	add	di,15
	loop	norm_str88

;create the superscript font
	mov	si,7000h + 1
	mov	bx,256
	mov	di,2000h
	XOR	AX,AX

super88:
	movsb				;0 = 1 pos
	inc	si
	movsw
	movsb
	inc	si
	movsw
	MOV	CL,4			; CH = 0 from last LOOP
rep	stosw
	INC	DI
	INC	DI
	add	si,8
	dec	bx
	jnz	super88

;fix some of the superscript characters to look acceptable
	mov	al,30h
	mov	di,2670h + 3
	or	es:[di],al	;fix the superscript g
	mov	di,2700h + 3
	or	es:[di],al	;fix the superscript p
	mov	di,2710h + 3
	or	es:[di],al	;fix the superscript q
	mov	di,2790h + 3
	or	es:[di],al	;fix the superscript y

;fix the superscript Q
	mov	di,2510h
	mov	al,78h
	stosb
	MOV	AX,0CCCCH
	STOSW
	mov	al,0d8h
	stosb
	mov	al,7ch
	stosb
	mov	al,06h
	stosb

;fix the superscript e
	mov	di,2650h
	XOR	AL,AL
	stosb
	mov	al,78h
	stosb
	mov	al,0fch
	stosb
	mov	al,0c0h
	stosb
	mov	al,78h
	stosb

;create the superscript+overstrike font
	mov	di,3000h
	mov	si,2000h
	MOV	CH,8			; CL = 0 from last REP
rep	movsw
	mov	di,3000h + 2
	mov	ax,0ffh
	MOV	CH,1			; CL = 0 from last REP

sup_str88:
	stosb
	add	di,15
	loop	sup_str88

;create the subscript font
	mov	di,6000h + 5
	mov	si,2000h
	mov	cx,800h - 3
rep	movsw

;create the subscript+overstrike font
	mov	di,9000h + 5
	mov	si,3000h
	mov	cx,800h - 3
rep	movsw

;create the italics font using an algorithm

mak8_ital:
	cld
	mov	ax,ramfont_seg
	mov	es,ax
	mov	ds,ax
	XOR	DI,DI
	mov	si,7000h
	mov	cx,800h
rep	movsw
	XOR	DI,DI
	MOV	SI,DI
	mov	bx,256

itals_88:
	lodsb
	shr	al,1
	shr	al,1
	stosb
	lodsw
	shr	al,1
	shr	ah,1
	stosw
	INC	DI
	INC	DI
	mov	si,di
	MOV	CL,3			; CH = 0 from last REP

ital_881:
	lodsw
	shl	al,1
	shl	ah,1
	stosw
	loop	ital_881
	add	di,5
	mov	si,di
	dec	bx
	jnz	itals_88

;create the italics+overstrike font

do8_ital_str:
	mov	di,1000h
	XOR	SI,SI
	MOV	CH,8			; CL = 0 from last LOOP
rep	movsw
	MOV	CH,1			; CL = 0 from last REP
	mov	ax,0ffh
	mov	di,1000h + 4

mak8_ital_str:
	stosb
	add	di,15
	loop	mak8_ital_str

;create the superscript+italics font
	mov	si,2000h
	mov	di,4000h
	MOV	CH,8			; CL = 0 from last LOOP
rep	movsw
	mov	si,4000h
	MOV	DI,SI
	mov	bx,256

ital_sup88:
	lodsw
	shr	al,1
	shr	ah,1
	stosw
	INC	DI
	INC	DI
	INC	SI
	INC	SI
	MOV	CL,3			; CH = 0 from last REP

shl_sup:
	lodsw
	shl	al,1
	shl	ah,1
	stosw
	loop	shl_sup
	add	di,6
	mov	si,di
	dec	bx
	jnz	ital_sup88

;create the superscript+italics+overstrike font
	mov	di,5000h
	mov	si,4000h
	MOV	CH,8			; CL = 0 from last LOOP
rep	movsw
	mov	di,5000h + 2
	MOV	CH,1			; CL = 0 from last REP
	mov	ax,0ffh

sup_ita_ovr:
	stosb
	add	di,15
	loop	sup_ita_ovr

;create the subscript+italics font
	mov	di,0a000h + 5
	mov	si,4000h
	mov	cx,800h - 3
rep	movsw

;create the subscript+italics+overstrike font
	mov	di,0b000h + 5
	mov	si,5000h
	mov	cx,800h - 3
rep	movsw

;make the mini caps font
	mov	si,2410h
	mov	di,2010h
	XOR	AX,AX
	stosw
	stosb
	MOV	CL,26 * 8 - 1		; CH = 0 from last REP
rep	movsw

;make the mini+overstrike font
	mov	si,3410h
	mov	di,3010h
	stosw
	stosb
	MOV	CL,26 * 8 - 1		; CH = 0 from last REP
rep	movsw

;make the mini+italics font
	mov	si,4410h
	mov	di,4010h
	stosw
	stosb
	MOV	CL,26 * 8 - 1		; CH = 0 from last REP
rep	movsw

;make the mini+italics+overstrike font
	mov	si,5410h
	mov	di,5010h
	stosw
	stosb
	MOV	CL,26 * 8 - 1		; CH = 0 from last REP
rep	movsw

Exit8x10:
cEnd	InitRamFont8x10


;********** Init4KRamFont8x10 **********
;*	Loads the RamFont memory with the 8x10 fonts

cProc	Init4KRamFont8x10, <NEAR>, <ds, si, di>
cBegin	Init4KRamFont8x10

;* This code is from QINTER (MCV9X14.ASM):

;select 4k ramfont
	mov	dx,hgcIndex
	MOV	AX,(ramfont_4k_8d SHL 8) OR xmodereg	
	OUT	DX,AX

;make RAM at B000:4000 addressable
	mov	dx,hgcConfig		
	mov	al,1				
	out	dx,al

;set underscore at 10
	MOV	AX,(9 SHL 8) OR scorereg
	OUT	DX,AX

;set overstrike at 9
	MOV	AX,(8 SHL 8) OR strikereg
	OUT	DX,AX

;* load the fonts into ramfont memory

;first clear all of ramfont memory
	mov	bx,ramfont_seg		; 0b400h
	mov	es,bx
	mov	cx,800h			; 4K bytes
	XOR	AX,AX
	MOV	DI,AX			; start from b000:4000
rep	stosw

;load the normal font 
	mov	bx,0f000h		; PC ROM Fonts (0-127)
	mov	ds,bx
	mov	si,0fa6eh
	mov	di,1			
	mov	bx,128
L0_127:
	MOV	CL,4			; 8 bytes-map/char
rep	movsw				
	add	di,8			; 16 bytes/char 
	dec	bx
	jnz	L0_127

;;;	di points to Ex128
	mov	bx,cs			; Hard coded Fonts (128-255)
	mov	ds,bx
	mov	si,offset rgbHercExFont8x10
	mov	bx,128
	dec	di
L128_255:
	MOV	CL,5			; 10 bytes-map/char
rep	movsw
	add	di,6			; 16 bytes/char
	dec	bx
	jnz	L128_255

cEnd	Init4KRamFont8x10


;********** MoveHwCursCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* Standard BIOS call for hardware cursor
;*	* save new position in "posCurs"

cProc	MoveHwCursCsd,<FAR, PUBLIC, ATOMIC>, <DI>
    parmB axCurs
    parmB ayCurs
    parmW fOn
    localB axCursor
    localB ayCursor
cBegin	MoveHwCursCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment

;*	* move cursor position
	mov	bh,0
	mov	dh,ayCurs
	mov	dl,axCurs

	mov	bx,[di].pinstDrv
	mov	al,dh
	mul	[bx].axMacInst
	xor	dh,dh
	add	ax,dx
	mov	dx,hgcIndex
	mov	bl,al
	mov	al,14
	out	dx,ax
	mov	ah,bl
	mov	al,15
	out	dx,ax				;* SetCursorPosition

	mov	ax,2000H			;* assume off
	mov	byte ptr [di].fCurs,0		;* graphics cursor 
	cmp	fOn,0
	je	SetCursorOnOff			;* turn off

	mov	bx,[di].pinstDrv
	test	ss:[bx].finstInst,finstGraphics	;graphics text 8x14
	jz	DrawCursDone

	mov	dx,[di].posCurs		;dl = axFirst
	mov	ayCursor,dh
	mov	axCursor,dl
	xor	cx,cx			;fRestoreDbcs
	mov	ah,cl
	mov	al,90
	mul	dh
	mov	dh,cl
	add	ax,dx			
	shl	ax,1			;ax = offFirst
	mov	dx,1
	cCall	<Near ptr DoUpdateCsd>, <ayCursor,axCursor,dx,ax,cx,cs>	;erase cursor
	xor	cx,cx
	mov	dh,ayCurs
	mov	dl,axCurs
	mov	[di].posCurs,dx		;update position
	mov	ah,cl
	mov	al,90
	mul	dh
	mov	dh,cl
	add	ax,dx
	shl	ax,1			;ax = offFirst
	mov	dx,1
	mov	byte ptr [di].fCurs,1		;* graphics cursor on
	cCall	<Near ptr DoUpdateCsd>, <ayCurs,axCurs,dx,ax,cx,cs>		;draw cursor

DrawCursDone:
	mov	ax,[di].vparmCursOn		;* turn on
SetCursorOnOff:
	mov	bl,al
	mov	al,10
	mov	dx,hgcIndex
	out	dx,ax
	mov	ah,bl
	mov	al,11
	out	dx,ax				;* SetCursorType

cEnd	MoveHwCursCsd


;********** DoUpdateCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* BIOS version: update the screen

cProc	DoUpdateCsd,<FAR, PUBLIC, ATOMIC>, <DS, SI, DI>
    parmB ayLine
    parmB axFirst
    parmB dax
    parmW offFirst
    parmW fRestoreDbcs
    localB axCurs
    localB axCurrent
    localW wTemp
    localW wSec
    localB bLastAttr
    LocalV LocalChar,14
cBegin	DoUpdateCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment
	cmp	[di].wExtra,0
	jne	UpdateRamFont
	jmp	CheckGrafText

UpdateRamFont:
	mov	bx,[di].pinstDrv
	test	ds:[bx].finstInst, finstMonoChrome
	jnz	@F
	jmp	DoUpdateExit			;* 16 color mode (90x35)
@@:
	mov	ah,ds:[bx].axMacInst
	mov	dx,ds:[bx].psSecInst		;* DX:SI => secondary buffer
	mov	ds,ds:[bx].psPrimInst		;* DS:SI => primary buffer
	mov	si,offFirst

	mov	cx,text_buf_seg
	mov	es,cx
	mov	al,ayLine
	mul	ah
	shl	ax,1
	xor	ch,ch
	mov	cl,axFirst
	add	ax,cx
	add	ax,cx
	mov	di,ax				;* ES:DI => video buffer

;*	* DS:SI => start character in primary buffer
;*	* DX:SI => start character in secondary buffer
;*	* ES:DI => start character in video buffer

;*	* copy all characters to screen

	mov	cl,dax
loop_update:
	lodsw					;* al = char, ah = attr

	;*	* Need to adjust attribute byte here
	xor	ch,ch				;* start with normal attributes
	cmp	ah,087h				;* check for reverse video
	jne	NotRevVideo
	or	ch,hrev
NotRevVideo:
	and	dx,dx
	jnz	ChkFonts

	;*	* no secondary buffer, check normal display attributes
	test	ah,40h
	jz	NotBoldAttr
	or	ch,hbold
NotBoldAttr:
	cmp	al,176
	jl	ChkUnderline
	cmp	al,223
	jle	NotUnderlineAttr
ChkUnderline:
	mov	bh,ah
	and	bh,07h
	cmp	bh,01h
	jne	NotUnderlineAttr
	or	ch,hunder
NotUnderlineAttr:
	jmp	jus_normal

ChkFonts:
	push	ds
	mov	ds,dx
	mov	ah,ds:[si-2]			;* get ffont byte
	pop	ds
	test	ah,ffontBold
	jz	NotBold
	or	ch,hbold
NotBold:
	
;deal with graphics characters mapping, first
	cmp	al,176
	jl	not_graph
	cmp	al,223
	jg	not_graph
	jmp	jus_normal

not_graph:
	test	ah,ffontUnderline
	jz	NotUnderline
	or	ch,hunder
NotUnderline:
	test	ah,ffontDoubleUnderline
	jz	NotDoubleUnderline
	or	ch,hstrike OR hunder	; StrikeThrough is the second underline
NotDoubleUnderline:

	test	ah,ffontSuperScript
	jz	chk_sub
	test	ah,ffontSubScript
	jz	chk_control

	;*	* SuperScript+SubScript = MiniCaps
	;*	* check for a valid minicaps character
	cmp	al,'A'
	jl	chk_italics
	cmp	al,'Z'
	jg	chk_italics
	sub	al,40h		; adjust ascii code to point to right position
				; in the superscript font which
				; contains minicaps characters
	jmp	SHORT do_super_mini

;if superscript control code ascii characters then map to normal font

chk_control:
	cmp	al,27
	jle	do_normal

;its superscript or minicaps

do_super_mini:
	test	ah,ffontItalic	;check for super+italics
	jnz	do_sup_ital
	test	ah,ffontStrikeThrough	;check for super+strike
	jz	just_sup
	add	ch,font4	;its super+overstrike
	jmp	SHORT store_char

just_sup:
	add	ch,font3	;its just superscript
	jmp	SHORT store_char

;its superscript+italics

do_sup_ital:
	test	ah,ffontStrikeThrough	;check for super+italics+over
	jz	jus_sup_ita
	add	ch,font6	;its super+italics+overstrike
	jmp	SHORT store_char

jus_sup_ita:
	add	ch,font5	;its super+italics
	jmp	SHORT store_char

;check for subscripted characters

chk_sub:
	test	ah,ffontSubScript
	jz	chk_italics
	test	ah,ffontItalic	;check for subscript+italics
	jnz	do_sub_ital
	test	ah,ffontStrikeThrough	;check for subscript+overstrike
	jz	just_sub
	add	ch,font10	;its the subscript+overstrike font
	jmp	SHORT store_char

;its just subscript

just_sub:
	add	ch,font7
	jmp	SHORT store_char

;its subscript+italics

do_sub_ital:
	test	ah,ffontStrikeThrough	;check for subscript+italics+overstrike
	jz	jus_sub_ita
	add	ch,font12
	jmp	SHORT store_char

;its just subscript+italics

jus_sub_ita:
	add	ch,font11
	jmp	SHORT store_char

;check for normal italics characters

chk_italics:
				; The following = TEST AH,mitalic
	test	ah,ffontItalic	;check for italics characters
	jz	do_normal
	test	ah,ffontStrikeThrough	;check for italics+overstrike
	jz	jus_italics
	add	ch,font2
	jmp	SHORT store_char

;its just the normal italics font

jus_italics:
	add	ch,font1
	jmp	SHORT store_char

;its the normal character set

do_normal:
	test	ah,ffontStrikeThrough	;check for normal+overstrike
	jz	jus_normal
	add	ch,font9	;its normal+overstrike
	jmp	SHORT store_char

;its the normal font

jus_normal:
	add	ch,font8

;store the character and attributes
store_char:
	mov	ah,ch
OColor8x10:
	stosw
	dec	cl
	jz	DoUpdateRet
	jmp	loop_update

DoUpdateRet:
	jmp	DoUpdateExit
	
CheckGrafText:
	mov	bx,[di].pinstDrv
	test	[bx].finstInst,finstGraphics
	jnz	UpdateGrafText
	jmp	DoUpdateExit

	;***************************
	;*     			   *
	;*	Graphics Text	   *
	;*			   *
	;***************************

UpdateGrafText:
	mov	ax,[di].posCurs			;for cursor drawing
	mov	axCurs,-1
	mov	axCurrent,0
	cmp	byte ptr [di].fCurs,0		;cursor on ?
	je	NoCursUpdate

	cmp	ah,ayLine			;check if cursor on ayLine
	jne	NoCursUpdate

	cmp	al,axFirst			;check if cursor outside axFirst
	jb	NoCursUpdate

	mov	axCurs,al			;need to update cursor
	mov	al,axFirst
	mov	axCurrent,al
NoCursUpdate:	
	mov	dx,ds:[bx].psSecInst		;* DX:SI => secondary buffer
	mov	wSec,dx
	mov	ds,ds:[bx].psPrimInst		;* DS:SI => primary buffer
	mov	si,offFirst

;*	* DS:SI => start character in primary buffer
;*	* DX:SI => start ffont in secondary buffer

	;find cursor position (pixel starting address)		
	mov	cl,ss:[bx].axMacInst		;screen width
	mov	al,ayLine 
	xor	ah,ah
	mul	cl
	mov	cx,ax
	shl	ax,1			;mul 2
	xor	dh,dh
	mov	dl,axFirst
	add	ax,dx
	cmp     ss:[di].ayBox,14
	jne	SkipShl
	
	mov	ax,cx
	shl	ax,1
	shl	ax,1
	shr	cx,1
	sub	ax,cx			;mul 3.5
	add	ax,dx
	test	ayLine,1	    	;even - plane 0,odd - plane 2
	jz	SkipShl
	
	add	ax,4000h - 45
SkipShl:
	mov	di,ax			;* ES:DI => video buffer (pixel address)

	mov	bLastAttr,0
	xor	ch,ch
	mov	cl,dax			;# of characters to be updated

out_next_char:
	lodsw			;ah - attr, al - char
	push	cx		;save dax
	push	ds		;save pointer to primary buffer
	push	si			
	mov	wTemp,di		;save video address
	mov	di,OFF_lpwDataCsd
	test	ss:[bx].finstInst,fInstMonoChrome
	jnz	SameAttr

	cmp	ah,bLastAttr
	je	SameAttr		
					;* update color attribute
	mov	bLastAttr,ah
	mov	cx,ax
	mov	dx,hgcIndex
	mov	al,1Ah			;* write color register
	out	dx,ax
	mov	ax,cx			;* restore attribute

SameAttr:
	mov	cx,cs
	mov	ds,cx			;DS:[SI] -> char table
	mov	cx,ss:[di].ayBox
	mov	si,drvOffset rgbHercFont8x14
	cmp	cl,8
	jne	First128

	mov	dx,ax
	mov	ax,0F000h		;System Font Table (8x8)
	mov	ds,ax
	mov	ax,dx
	mov	si,0FA6Eh
	cmp	al,80h
	jb	First128

	sub	al,80h
	mov	si,drvOffset rgbHercExFont8x8
	push	cs
	pop	ds
First128:
	mov	dx,ax			;save char + attribute
	xor	ah,ah
	mul	cl
	add	si,ax			

	mov	ax,ss
	mov	es,ax
	lea	di,LocalChar			;es:[di] -> local storage
	rep	movsb  	   			;copy char bit map into local area
	mov	di,OFF_lpwDataCsd		;restore points
	mov	cx,ss:[di].ayBox	
	mov	ds,ax				;DS:[SI] -> local storage
	lea	si,LocalChar

	cmp	wSec,0			;check Sec. buffer
	je	notFont			;****

	test	ss:[bx].finstInst,finstFont	;FFont mode ?
	jz	notFont	

	pop	di			;si -> di (buffer offset)
	push	di	

	mov	ax,wSec
	mov	es,ax			;ES:[DI-2] -> ffont buffer
	mov	al,dl			;restore character
	mov	dl,es:[di-2]		
	or	dl,dl
	jz	notFont

	cmp	al,' ' 			;check spaces
	jne	notspace1
	
	test	dl,ffontUnderline or ffontDoubleUnderline or ffontStrikeThrough
	jz	notfont

notspace1:
	cCall	ChrisPFont 
notFont:
	mov	cx,0B800h		;video seg
	mov	es,cx
	mov	di,OFF_lpwDataCsd		;restore points
	mov	cx,ss:[di].ayBox	;restore points

	mov	al,axCurrent		;cursor position ?
	cmp	al,axCurs
	jne	CursOff1

	push	cx
	push	si
	mov	cx,ss:[di].vparmCursOn
	xchg	ch,cl
	xor	ch,ch
	add	si,cx
	mov	cx,ss:[di].vparmCursOn
	sub	cl,ch
	xor	ch,ch
outCurs1:				;display the cursor
	not	byte ptr [si]
	inc	si
	loop	outCurs1
	pop	si
	pop	cx

CursOff1:
	shr	cl,1
	mov	di,wTemp
	mov	ax,2000h - 1
OC9Lp:
	movsb				; And put back to screen memory
	ADD	DI,AX			; Move down to next scan line
	movsb				; And put back to screen memory
	ADD	DI,AX			; Move down to next scan line
	cmp	di,8000h
	jb	OC9lp0

	ADD	DI,90 - 8000H
OC9lp0:
	loop	OC9Lp

	mov	di,wTemp
	inc	di
	inc	axCurrent		;bump update position
	pop	si
	pop	ds
	pop	cx
	dec	cx
	jz	DoUpdateExit
	jmp	out_next_char
		
DoUpdateExit:

	mov	di,OFF_lpwDataCsd		;* Data in data segment
	mov	bx,[di].pinstDrv
	test	ss:[bx].finstInst,fInstMonoChrome
	jnz	@F
	mov	ax,0F1Ah		;* restore color register (1Ah) to
	mov	dx,hgcIndex		;* default color (0Fh = mono)
	out	dx,ax
@@:
cEnd	DoUpdateCsd


	CPF814 = 1
	include cpfont.asm		;* ChrisPFont with 8x8,8x14


;********** FQueryInftCsd **********
;*	* CSD entry point (see documentation for interface)
;*	ax != 0	Success
;*	filled INFT

cProc	FQueryInftCsd, <FAR, PUBLIC, ATOMIC>, <SI, DI>
    parmDP pinft
    parmW ifont
cBegin	FQueryInftCsd

	mov	di,OFF_lpwDataCsd
	mov	di,[di].pinstDrv
	xor	ax,ax
	test	[di].finstInst,finstAvailable
	mov	di,pinft			;* ds:di => dest
	mov	ds:[di].OFF_lpbFontLower128Inft,0	;null pointers
	mov	ds:[di].SEG_lpbFontLower128Inft,0
	jz	ExitFQueryInft

	mov	si,ifont
	cmp	si,cdmMax			;* end of table ?
	jae	ExitFQueryInft

	mov	ax,SIZE DM
	mul	si
	mov	si,ax
	add	si,drvOffset rgdm		;* CS:SI => INST info
	mov	di,pinft			;* ds:di => dest
	Assert	<dyCharDm EQ dxCharDm+1>
	Assert	<dyCharInft EQ dxCharInft+1>
	mov	dx,word ptr cs:[si].dxCharDm
	cmp	dh, 10
	jne	N8
	mov	dh, 8			;* change 8x10 font to 8x8
N8:
	mov	wo ds:[di].dxCharInft,dx
					;* move both dxChar and dyChar
	mov	dl,cs:[si].dyBaseDm
	mov	ds:[di].dyBaseLineInft,dl

	mov	ds:[di].SEG_lpbFontLower128Inft,CS
	mov	ds:[di].SEG_lpbFontUpper128Inft,CS
	cmp	ds:[di].dxCharInft,9
	jne	N9
	;* 9x14
	mov	ds:[di].OFF_lpbFontLower128Inft,drvOffset rgbHercFont9x14
	mov	ds:[di].OFF_lpbFontUpper128Inft,drvOffset rgbHercExFont9x14
	jmp	short FillInst

N9:
	cmp	ds:[di].dyCharInft,14
	jne	N14
	;* 8x14
	mov	ds:[di].OFF_lpbFontLower128Inft,drvOffset rgbHercFont8x14
	mov	ds:[di].OFF_lpbFontUpper128Inft,drvOffset rgbHercExFont8x14
	jmp	short FillInst

N14:
	mov	ds:[di].OFF_lpbFontLower128Inft,0FA6Eh
	mov	ds:[di].SEG_lpbFontLower128Inft,0F000h
	cmp	ds:[di].dyCharInft,8
	jne	ExitFQueryInft		;Failure
	;* 8x8

	mov	ds:[di].OFF_lpbFontUpper128Inft,drvOffset rgbHercExFont8x8

FillInst:
	mov	ax,sp			;Success

ExitFQueryInft:
cEnd	FQueryInftCsd


;********** TermCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* normally a no-op

cProc	TermCsd, <FAR, PUBLIC, ATOMIC>, <di,si>
cBegin	TermCsd

;* resume text mode 80x25
	xor	ah,ah			; update Bios data
	mov	al,40h
	mov	es,ax
	mov	di,49h			;CRT_MODE
	mov	byte ptr es:[di],7
	mov	di,4Ah			;CRT_COLS
	mov	word ptr es:[di],80	
	mov	di,84h			;CRT_ROWS
	mov	byte ptr es:[di],24	

	mov	si,drvOffset rgbInit	;default 80x25 (9x14 font)
	mov	ax,fHercTxt
	mov	dx,hgcControl		; set to graphics or text mode...
	out	dx,al			;   ... with video off

	mov	dx,hgcIndex		; initialize 6845 chip with table
	mov	cx,cRegInit		;
	xor	ah,ah			;
	cld				;
TermLp:
	mov	al,ah			;
	out	dx,al			; send register number to index port
	inc	dx			;
	lods	byte ptr cs:[si]	; get byte of data to send
	out	dx,al			; and send it to index+1
	jmp	$ + 2			; WARNING -- THIS DELAY IS REQUIRED
	jmp	$ + 2			; FOR 8MHz ATs!
	inc	ah			;
	dec	dx			;
	loop	TermLp			; loop until all 16 bytes are output

;select ROM character generator
	MOV	AX,(0) OR xmodereg
	OUT	DX,AX

;set underscore at 14
	MOV	AX,(13 SHL 8) OR scorereg
	OUT	DX,AX

;resume monochrome
	mov	ax,(20h SHL 8) OR exceptreg	;* reg 17
	out	dx,ax

	mov	ax,fHercTxt
	or	al,fHercVideo		;turn video on
	mov	dx,hgcControl		;
	out	dx,al			;

	mov	ah,1			;set cursor shape
	mov	cx,0C0Dh		
	int	10h

cEnd	TermCsd

;*****************************************************************************

	include	Herc9x14.inc
	include	Herc8x10.inc
	include	Herc8x14.inc
	include	Herc8x8.inc

;*****************************************************************************

	include	csd_std.asm		;* standard init/term

	include	csd_ibm.asm		;* IBM specific routines

;*****************************************************************************

	include	csd_vram.asm		;* default procs for direct video I/O

	include	csd_save.asm		;* default screen save (none)

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************

	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\herc8x8.inc ===
;-----------------------------------------------------------;
	;							    ;
	;  Hercules RAM Charcter Set.  8 x 8 System Font      	    ;
	;							    ;
	;	  Extended Character Set (128-255)		    ;
	;							    ;
	;-----------------------------------------------------------;

rgbHercExFont8x8:

	DB	078H,0CCH,0C0H,0CCH,078H,018H,00CH,078H ;128*
	DB	000H,0CCH,000H,0CCH,0CCH,0CCH,076H,000H ;129*
	DB	00EH,000H,078H,0CCH,0FCH,0C0H,078H,000H ;130*
	DB	07CH,082H,078H,00CH,07CH,0CCH,076H,000H ;131*
	DB	048H,000H,078H,00CH,07CH,0CCH,076H,000H ;132* 
	DB	0E0H,000H,078H,00CH,07CH,0CCH,076H,000H ;133*
	DB	030H,030H,078H,00CH,07CH,0CCH,076H,000H ;134*
	DB	000H,000H,078H,0C0H,0C0H,078H,00CH,038H ;135*
	DB	07CH,082H,078H,0CCH,0FCH,0C0H,078H,000H ;136*
	DB	0CCH,000H,078H,0CCH,0FCH,0C0H,078H,000H ;137*
	DB	0E0H,000H,078H,0CCH,0FCH,0C0H,078H,000H ;138*
	DB	0CCH,000H,070H,030H,030H,030H,078H,000H ;139*
	DB	070H,088H,070H,030H,030H,030H,078H,000H ;140*
	DB	0E0H,000H,070H,030H,030H,030H,078H,000H ;141*
	DB	0CCH,030H,078H,0CCH,0FCH,0CCH,0CCH,000H ;142*
	DB	030H,030H,000H,078H,0CCH,0FCH,0CCH,000H ;143*
	DB	00EH,000H,0FEH,060H,078H,060H,0FEH,000H ;144*
	DB	000H,000H,07EH,00CH,07EH,0CCH,07EH,000H ;145*
	DB	03EH,06CH,0CCH,0FEH,0CCH,0CCH,0CEH,000H ;146*
	DB	078H,0CCH,000H,078H,0CCH,0CCH,078H,000H ;147*
	DB	000H,0CCH,000H,078H,0CCH,0CCH,078H,000H ;148*
	DB	000H,0E0H,000H,078H,0CCH,0CCH,078H,000H ;149*
	DB	078H,0CCH,000H,0CCH,0CCH,0CCH,076H,000H ;150* 
	DB	000H,0E0H,000H,0CCH,0CCH,0CCH,076H,000H ;151* 
	DB	000H,0CCH,000H,0CCH,0CCH,07CH,00CH,0F8H ;152* 
	DB	06CH,000H,038H,06CH,06CH,06CH,038H,000H ;153* 
	DB	0CCH,000H,0CCH,0CCH,0CCH,0CCH,0FCH,000H ;154* 
	DB	018H,018H,07CH,0C0H,0C0H,07CH,018H,018H ;155* 
	DB	038H,06CH,064H,0F0H,060H,0E6H,0FCH,000H ;156*
	DB	0CCH,0CCH,078H,0FCH,030H,0FCH,030H,030H ;157*
	DB	0F8H,0C4H,0C4H,0FAH,0C6H,0CFH,0C6H,0C7H ;158* 
	DB	01CH,036H,030H,078H,030H,030H,0B0H,060H ;159*
	DB	00EH,000H,078H,00CH,07CH,0CCH,076H,000H ;160*
	DB	00EH,000H,070H,030H,030H,030H,078H,000H ;161*
	DB	000H,00EH,000H,078H,0CCH,0CCH,078H,000H ;162*
	DB	000H,00EH,000H,0CCH,0CCH,0CCH,076H,000H ;163*
	DB	0F8H,000H,0F8H,0CCH,0CCH,0CCH,0CCH,000H ;164*
	DB	0FEH,000H,0C6H,0F6H,0DEH,0CEH,0C6H,000H ;165*
	DB	07CH,0CCH,0CCH,07EH,000H,0FEH,000H,000H ;166*
	DB	07CH,0C6H,0C6H,07CH,000H,0FEH,000H,000H ;167*
	DB	030H,000H,030H,060H,0C0H,0CCH,078H,000H ;168*
	DB	000H,000H,000H,0FCH,0C0H,0C0H,000H,000H ;169*
	DB	000H,000H,000H,0FCH,00CH,00CH,000H,000H ;170*
	DB	0C3H,0C6H,0CCH,0DEH,033H,066H,0CCH,00FH ;171*
	DB	0C3H,0C6H,0CCH,0DBH,037H,06FH,0CFH,003H ;172*
	DB	030H,000H,030H,030H,078H,078H,030H,000H ;173*
	DB	000H,000H,033H,066H,0CCH,066H,033H,000H ;174*
	DB	000H,000H,0CCH,066H,033H,066H,0CCH,000H ;175*
	DB	088H,022H,088H,022H,088H,022H,088H,022H ;176*
	DB	055H,0AAH,055H,0AAH,055H,0AAH,055H,0AAH ;177*
	DB	0EEH,0BBH,0EEH,0BBH,0EEH,0BBH,0EEH,0BBH ;178*
	DB	018H,018H,018H,018H,018H,018H,018H,018H ;179*
	DB	018H,018H,018H,0F8H,018H,018H,018H,018H ;180*
	DB	018H,018H,0F8H,018H,0F8H,018H,018H,018H ;181*
	DB	066H,066H,066H,0E6H,066H,066H,066H,066H ;182*
	DB	000H,000H,000H,0FEH,066H,066H,066H,066H ;183*
	DB	000H,000H,0F8H,018H,0F8H,018H,018H,018H ;184*
	DB	066H,066H,0E6H,006H,0E6H,066H,066H,066H ;185*
	DB	066H,066H,066H,066H,066H,066H,066H,066H ;186*
	DB	000H,000H,0FEH,006H,0E6H,066H,066H,066H ;187*
	DB	066H,066H,0E6H,006H,0FEH,000H,000H,000H ;188*
	DB	066H,066H,066H,0FEH,000H,000H,000H,000H ;189*
	DB	018H,018H,0F8H,018H,0F8H,000H,000H,000H ;190*
	DB	000H,000H,000H,0F8H,018H,018H,018H,018H ;191*
	DB	018H,018H,018H,01FH,000H,000H,000H,000H ;192*
	DB	018H,018H,018H,0FFH,000H,000H,000H,000H ;193*
	DB	000H,000H,000H,0FFH,018H,018H,018H,018H ;194*
	DB	018H,018H,018H,01FH,018H,018H,018H,018H ;195*
	DB	000H,000H,000H,0FFH,000H,000H,000H,000H ;196*
	DB	018H,018H,018H,0FFH,018H,018H,018H,018H ;197*
	DB	018H,018H,01FH,018H,01FH,018H,018H,018H ;198*
	DB	066H,066H,066H,067H,066H,066H,066H,066H ;199*
	DB	066H,066H,067H,060H,07FH,000H,000H,000H ;200*
	DB	000H,000H,07FH,060H,067H,066H,066H,066H ;201*
	DB	066H,066H,0E7H,000H,0FFH,000H,000H,000H ;202*
	DB	000H,000H,0FFH,000H,0E7H,066H,066H,066H ;203*
	DB	066H,066H,067H,060H,067H,066H,066H,066H ;204*
	DB	000H,000H,0FFH,000H,0FFH,000H,000H,000H ;205*
	DB	066H,066H,0E7H,000H,0E7H,066H,066H,066H ;206*
	DB	018H,018H,0FFH,000H,0FFH,000H,000H,000H ;207*
	DB	066H,066H,066H,0FFH,000H,000H,000H,000H ;208*
	DB	000H,000H,0FFH,000H,0FFH,018H,018H,018H ;209*
	DB	000H,000H,000H,0FFH,066H,066H,066H,066H ;210*
	DB	066H,066H,066H,07FH,000H,000H,000H,000H ;211*
	DB	018H,018H,01FH,018H,01FH,000H,000H,000H ;212*
	DB	000H,000H,01FH,018H,01FH,018H,018H,018H ;213*
	DB	000H,000H,000H,07FH,066H,066H,066H,066H ;214*
	DB	066H,066H,066H,0FFH,066H,066H,066H,066H ;215*
	DB	018H,018H,0FFH,018H,0FFH,018H,018H,018H ;216*
	DB	018H,018H,018H,0F8H,000H,000H,000H,000H ;217*
	DB	000H,000H,000H,01FH,018H,018H,018H,018H ;218*
	DB	0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH ;219*
	DB	000H,000H,000H,000H,0FFH,0FFH,0FFH,0FFH ;220*
	DB	0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H ;221*
	DB	00FH,00FH,00FH,00FH,00FH,00FH,00FH,00FH ;222*
	DB	0FFH,0FFH,0FFH,0FFH,000H,000H,000H,000H ;223*
	DB	000H,000H,076H,0DCH,0C8H,0DCH,076H,000H ;224*
	DB	000H,078H,0CCH,0F8H,0CCH,0F8H,0C0H,0C0H ;225*
	DB	000H,0FCH,0CCH,0C0H,0C0H,0C0H,0C0H,0C0H ;226*
	DB	000H,0FEH,06CH,06CH,06CH,06CH,06CH,000H ;227*
	DB	0FCH,0CCH,060H,030H,060H,0CCH,0FCH,000H ;228*
	DB	000H,000H,07EH,0D8H,0D8H,0D8H,070H,000H ;229*
	DB	000H,066H,066H,066H,066H,07CH,060H,0C0H ;230*
	DB	000H,076H,0DCH,018H,018H,018H,018H,000H ;231*
	DB	0FCH,030H,078H,0CCH,0CCH,078H,030H,0FCH ;232*
	DB	038H,06CH,0C6H,0FEH,0C6H,06CH,038H,000H ;233*
	DB	038H,06CH,0C6H,0C6H,06CH,06CH,0EEH,000H ;234*
	DB	01CH,030H,018H,07CH,0CCH,0CCH,078H,000H ;235*
	DB	000H,000H,066H,0DBH,0DBH,066H,000H,000H ;236*
	DB	006H,00CH,07EH,0DBH,0DBH,07EH,060H,0C0H ;237*
	DB	01CH,030H,060H,0FCH,060H,030H,01CH,000H ;238*
	DB	078H,0CCH,0CCH,0CCH,0CCH,0CCH,0CCH,000H ;239*
	DB	000H,0FCH,000H,0FCH,000H,0FCH,000H,000H ;240*
	DB	030H,030H,0FCH,030H,030H,000H,0FCH,000H ;241*
	DB	060H,030H,018H,030H,060H,000H,0FCH,000H ;242*
	DB	018H,030H,060H,030H,018H,000H,0FCH,000H ;243*
	DB	00EH,01BH,018H,018H,018H,018H,018H,018H ;244*
	DB	018H,018H,018H,018H,018H,018H,0D8H,070H ;245*
	DB	030H,030H,000H,0FCH,000H,030H,030H,000H ;246*
	DB	000H,076H,0DCH,000H,076H,0DCH,000H,000H ;247*
	DB	070H,0D8H,0D8H,070H,000H,000H,000H,000H ;248*
	DB	000H,000H,018H,018H,000H,000H,000H,000H ;249*
	DB	000H,000H,000H,018H,000H,000H,000H,000H ;250*
	DB	00EH,00CH,00CH,00CH,0ECH,06CH,03CH,01CH ;251*
	DB	0F8H,0CCH,0CCH,0CCH,0CCH,000H,000H,000H ;252*
	DB	0F0H,018H,030H,060H,0F8H,000H,000H,000H ;253*
	DB	000H,000H,038H,038H,038H,038H,000H,000H ;254*
	DB	000H,000H,000H,000H,000H,000H,000H,000H ;255*


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\ibmcvt.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	ibmcvt.asm : PC convertible (LCD) CSD
;*
;*****************************************************************************

	include csd_head.inc
	include	csd_data.inc

;*****************************************************************************

	include	csd_code.asm			;* first part of code

;*	* Display modes table
rgdm:

;* #0 - standard text mode
	DB	0ffh 
	DB	0ffh 
	DB	3				;* mode
	DW	finstText or finstMonoChrome	;* flags
	DB	80, 25				;* screen size
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0B800h				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved

;* #1 - mono graphics text 
	DB	0ffh
	DB	0ffh
	DB	6				;* mode
	DW	finstGraphics or finstFont OR finstMonochrome or finstFastScroll
	DB	80, 25				;* screen size
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved

cdmMax	equ	($ - rgdm) / (size DM)		;* # of modes

segROM	equ	0F000H

;*****************************************************************************

	include update1.asm		;* finitcsd,doupdatecsd
	include cpfont.asm		;* ChrisPFont with 8x8 only

;*****************************************************************************

	include	csd_std.asm		;* standard init/term
	include	csd_ibm.asm		;* IBM specific routines

;*****************************************************************************

	include	csd_vram.asm		;* default procs for direct video I/O
	include	csd_save.asm		;* default screen save (none)

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************

	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\ibm3270.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	3270.asm : for IBM 3270 PC AT
;*****************************************************************************

	include	csd_head.inc

	include	csd_data.inc

;*****************************************************************************

	include	csd_code.asm			;* first part of code

;*	* Display modes table
rgdm:
;* #0 - standard monochrome text mode (9 x 14 characters)
	DB	0ffh			 	;* hardware needed
	DB	0ffh
	DB	3				;* mode
	DW	finstText 
	DB	80, 25				;* screen size
	DB	8				;* coMac
	DB	0, 0, 0, 0			;* INFT
	DW	0B800H				;* video address
	DW	0C0DH				;* cursor
	DW	0				;* extra (RamFont info)
	Assert	<($-rgdm) EQ SIZE DM>

;* #2 - monochrome graphics text mode (8 x 8 characters)
	DB	0ffh			 	;* hardware needed
	DB	0ffh
	DB	30h				;* mode
	DW	finstGraphics OR finstMonochrome OR finstFont
	DB	90, 25				;* screen size
	DB	2				;* coMac
	DB	8, 14, 0, 0			;* INFT
	DW	0				;* video address
	DW	0C0DH				;* cursor
	DW	0				;* extra 

;* #1 - standard monochrome graphics text mode (8 x 8 characters)
	DB	0ffh			 	;* hardware needed
	DB	0ffh
	DB	30h				;* mode
	DW	finstGraphics OR finstMonochrome OR finstFont
	DB	90, 43				;* screen size
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* extra 

cdmMax	equ	($ - rgdm) / (size DM)		;* # of modes

;*****************************************************************************

NonStandard	FvmGetCur
NonStandard	ModeGetCur
NonStandard	FInitCsd
NonStandard	DoUpdateCsd

;*****************************************************************************


;********** FvmGetCur **********
;*	* Identify the current screen and return the appropriate fvm in AL
;*	* NOTE:	This is a NEAR routine.
;*	exit:	AL == fvm for current screen or 0 if no supported screen found

cProc	FvmGetCur, <NEAR, PUBLIC, ATOMIC>
cBegin	FvmGetCur

	AssertEQ di,OFF_lpwDataCsd
	mov	ax,-1
	mov	[di].fvmCurAdap,al
	mov	[di].fvmCurDisp,ah
end_fvm_get: ;* ax = fvm
cEnd	FvmGetCur

;********** ModeGetCur *********
;*	entry:	n/a
;*	* get current machine mode
;*	exit:	al = mode, ah = ayMac (or 0 if unknown)

cProc	ModeGetCur, <NEAR, PUBLIC, ATOMIC>, <ES>
cBegin	ModeGetCur

	mov	ax,40H
	mov	es,ax
	mov	dl,es:[0084H]		;* read BIOS rows
	inc	dl
	cmp	dl,25			;do this since some clones don't
	je	@F			;update BIOS data
	cmp	dl,43
	je	@F
	mov	dl,25			;* default to 25 rows
@@:	
	push	bx
	mov	ah,0fh
	int	10h			;* get current state, return al = mode
	mov	bx,es:[004Ah]
	cmp	bx,90
	jne	@F
	mov	al,30h			;90 columns indicates graphics-text mode
@@:
	pop	bx
	mov	ah,dl

cEnd	ModeGetCur


;********** FInitCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* Initialize the screen to the given mode
;*	exit:	AX != 0 if ok

cProc	FInitCsd, <FAR, PUBLIC, ATOMIC>, <DI>
    parmDP pinst
    parmDP pinch
    localB modeCur
cBegin	FInitCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment

;*	* save old mode
	cCall	ModeGetCur			;* al = mode, ah = ayMac
	mov	modeCur,al			;* current mode

	mov	bx,pinst
	cmp	ds:[bx].ayMacInst,ah
	je	@F				;* same resolution
	mov	modeCur,0			;* cause mode reset
@@:

;*	* set mode
	mov	[di].pinstDrv,bx
	mov	bx,ds:[bx].pdmInst		;* CS:BX => DM info

;*	* copy mode info into driver globals
	mov	ax,cs:[bx].vparmCursOnDm
	mov	[di].vparmCursOn,ax
	mov	[di].vparmCursSize,ax
	mov	ax,cs:[bx].wExtraDm
	mov	[di].wExtra,ax

	mov	al,cs:[bx].modeDm
	cmp	al,modeCur
	jne	@F				
	jmp	initdrv				;* don't reset
@@:
	xor	ah,ah				;* set mode
	int	10h

	mov	cx,40H
	mov	es,cx
	mov	cl,cs:[bx].ayMacDm
	dec	cl				; rows - 1
	mov	byte ptr es:[0084H],cl		;* update BIOS rows
	mov	cl,cs:[bx].axMacDm
	mov	word ptr es:[004Ah],cx		;updates columns
initdrv:
	test	cs:[bx].finstDm,finstGraphics
	jz	finitdone

	xor	ch,ch	
	mov	cl,cs:[bx].dyCharDm
	mov	[di].ayBox,cx			;* points
	cmp	cx,8
	je	@F

	mov	[di].SEG_lpbFont,cs				;8x16 font
	mov	[di].OFF_lpbFont,drvOffset rgbHercFont8x14
	jmp short font1
@@:
	mov	[di].SEG_lpbFont,0F000h		;8x8 font (first 128)
	mov	[di].OFF_lpbFont,0FA6Eh
font1:	
	jmp	short @F

finitdone:	
	test	cs:[bx].finstDm,finstGraphics
	jnz	@F

;*	* the INCH array already contains the standard Code Page 437
;*	*  character set, so it usually can be left the same.

;*	* Do other diddling
	cCall	DiddleBlinkBit
@@:
	mov	ax,sp				;* success
cEnd	FInitCsd



;********** DoUpdateCsd **********
;*	entry:
;*		parameters just like PrepUpdateCsd
;*	* after primary buffer has been updated
;*	exit: n/a

cProc	DoUpdateCsd,<FAR, PUBLIC, ATOMIC>, <DS, ES, SI, DI>
    parmB ayLine
    parmB axFirst
    parmB dax			;* will never be 0
    parmW offFirst
    parmW fRestoreDbcs		;* => restore DBCS 1/2 characters
    localB axCurs
    localB axCurrent
    localW wTemp
    localV LocalChar,14		;storage of char bit map for ffont mode

cBegin	DoUpdateCsd
	
	mov	di,OFF_lpwDataCsd		;* Data in data segment
	mov	bx,[di].pinstDrv

	test	ss:[bx].finstInst,finstGraphics	;graphics text 8x14
	jnz	graf_update

	jmp	done_graf_update

graf_update:

	mov	ax,[di].posCurs			;for cursor drawing
	mov	axCurs,-1
	mov	axCurrent,0
	cmp	byte ptr [di].fCurs,0		;cursor on ?
	je	NoCursUpdate

	cmp	ah,ayLine			;check if cursor on ayLine
	jne	NoCursUpdate

	cmp	al,axFirst			;check if cursor outside axFirst
	jb	NoCursUpdate

	mov	axCurs,al			;need to update cursor
	mov	al,axFirst
	mov	axCurrent,al
NoCursUpdate:	
	mov	si,ds:[bx].pdmInst		
	mov	ds,ds:[bx].psPrimInst		;* DS:SI => primary buffer

;*	* DS:SI => start character in primary buffer
;*	* SS:BX => INST info
;*	* SS:DI => Driver data

	mov	cx,ss:[di].ayBox
	xor	ax,ax			;calculate start of screen address
	mov	al,ayLine
	mul	cx			;ayLine * charHeight
	mov	cx,90
	mul	cx
	xor	cx,cx
	mov	cl,axFirst
	add	ax,cx			;ax = ayLine x 80 x ayBox + axFirst
	mov	di,ax			;point to video buffer

	xor	cx,cx
	mov	cl,dax			;no. of char to be updated

	mov	dx,si
	mov	si,offFirst

out_next_char:
	lodsw				;load character+attribute
	push	cx			;save dax
	push	ds			;save pointer to primary buffer
	push 	si
	mov	dx,ax			;save char
	mov	wTemp,di  		;save di
	mov	di,OFF_lpwDataCsd	;load cx with points
	mov	cx,ss:[di].ayBox	

	mov	si,ss:[di].OFF_lpbFont
	mov	ds,ss:[di].SEG_lpbFont
	cmp	cl,8
	jne	@F
	cmp	al,80h
	jb	@F
		     			;use extend font (128 - 255)
	push	cs
	pop	ds
	mov	si,drvOffset rgbCGAExFont8x8	;see cga8x8.inc
	sub	al,80h
@@:
	xor	ah,ah
	mul	cl			;ax = character table offset
	add	si,ax			;ds:[si] -> char bit map

	mov	ax,ss
	mov	es,ax
	lea	di,LocalChar		;es:[di] -> local storage
	rep	movsb			;copy bitmap to local area
	mov	di,OFF_lpwDataCsd	;restore points
	mov	cx,ss:[di].ayBox	
	mov	ds,ax
	lea	si,LocalChar

	cmp	ss:[bx].psSecInst,0		;is sec. buffer allocated ?
	je	notfont14or16

	test	ss:[bx].finstInst,finstFont	;graphics text 8x14, 8x16
	jz	notfont14or16

	mov	ax,dx
	pop	di	;si -> di
	push	di
	mov	es,ss:[bx].psSecInst	;* es:[di] => ffont buffer
	mov	dx,es:[di-2]		
	or	dl,dl			;zero ffont
	jz 	notfont14or16

	cmp	al,' ' 			;check spaces
	jne	@F
	
	test	dl,ffontUnderline or ffontDoubleUnderline or ffontStrikeThrough or ffontOrCharacter
	jz	notfont14or16

@@:
;*	ax = char + attribute
;*	dx = ffont word
	cCall	ChrisPFont
	mov	di,OFF_lpwDataCsd	;restore points
	mov	cx,ss:[di].ayBox	
notfont14or16:
	mov	al,axCurrent
	cmp	al,axCurs
	jne	CursOff2

	mov	di,OFF_lpwDataCsd	
	push	cx
	push	si
	mov	cx,ss:[di].vparmCursOn
	xchg	ch,cl
	xor	ch,ch
	add	si,cx
	mov	cx,ss:[di].vparmCursOn
	sub	cl,ch
	xor	ch,ch
outCurs2:
	not	byte ptr [si]
	inc	si
	loop	outCurs2
	pop	si
	pop	cx

CursOff2:
	mov	di,OFF_lpwDataCsd	

	mov	di,OFF_lpwDataCsd	;restore points
	mov	cx,ss:[di].ayBox	
	mov	ax,0B800h		;set video segment
	mov	es,ax
	mov	di,wTemp		;restore di
	mov	ax,90-1			;column

out_char_map:
	movsb
	add	di,ax			;go to next scan line (+90-1)
	loop	out_char_map
	
	mov	di,wTemp		;restore di
	inc	di			;next char
J13:
	inc	axCurrent		;bump update position
	pop	si
	pop	ds
	pop	cx			;restore dax
	dec 	cx
	jz	out_done2
	jmp	out_next_char

out_done2:
done_graf_update:

end_update:

cEnd	DoUpdateCsd

	CPF814 = 1
	include cpfont.asm		;* ChrisPFont with 8x8,8x14,8x16
	
;*****************************************************************************

	include cga8x8.inc
	include	Herc8x14.inc

;*****************************************************************************

	include	csd_std.asm		;* standard init/term

	include	csd_ibm.asm		;* IBM specific routines

;*****************************************************************************

	include	csd_vram.asm		;* default procs for direct video I/O

	include	csd_save.asm		;* default screen save (none)

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************

	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\ibmtext.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	ibmtext.asm : general purposes (MDA/CGA/EGA/MCGA/VGA, Text) CSD
;*
;*****************************************************************************

	include	csd_head.inc
	include	csd_data.inc

;*****************************************************************************

	include	csd_code.asm			;* first part of code

;*	* Display modes table

	MDACSD = 1		;enable all drivers
	CGACSD = 1
	EGACSD = 1
	MCGACSD = 1
	VGACSD = 1

	include	genmodes.asm
	include	geninit.asm			;* general FInitCsd


;*****************************************************************************

	include	csd_std.asm		;* standard init/term
	include	csd_ibm.asm		;* IBM specific routines

;*****************************************************************************
;*	* only include one of the following, as appropriate

	include	csd_vram.asm		;* default procs for direct video I/O
	include	csd_save.asm		;* default screen save (none)

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************


	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\herc9x14.inc ===
;-----------------------------------------------------------;
	;							    ;
	;  Hercules RAM Charcter Set.  9 x 14 System Font	    ;
	;							    ;
	;	     ASCII Character Set (000-255)		    ;
	;							    ;
	;-----------------------------------------------------------;

rgbHercFont9x14	LABEL	BYTE

	DB 000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H
	DB 000H,000H,07EH,081H,0A5H,081H,081H,0BDH,099H,081H,07EH,000H,000H,000H
	DB 000H,000H,07EH,0FFH,0DBH,0FFH,0FFH,0C3H,0E7H,0FFH,07EH,000H,000H,000H
	DB 000H,000H,000H,036H,07FH,07FH,07FH,07FH,03EH,01CH,008H,000H,000H,000H
	DB 000H,000H,000H,008H,01CH,03EH,07FH,03EH,01CH,008H,000H,000H,000H,000H
	DB 000H,000H,018H,03CH,03CH,0E7H,0E7H,0E7H,018H,018H,03CH,000H,000H,000H
	DB 000H,000H,018H,03CH,07EH,0FFH,0FFH,07EH,018H,018H,03CH,000H,000H,000H
	DB 000H,000H,000H,000H,000H,018H,03CH,03CH,018H,000H,000H,000H,000H,000H
	DB 0FFH,0FFH,0FFH,0FFH,0FFH,0E7H,0C3H,0C3H,0E7H,0FFH,0FFH,0FFH,0FFH,0FFH
	DB 000H,000H,000H,000H,03CH,066H,042H,042H,066H,03CH,000H,000H,000H,000H
ASC010	DB 0FFH,0FFH,0FFH,0FFH,0C3H,099H,0BDH,0BDH,099H,0C3H,0FFH,0FFH,0FFH,0FFH
	DB 000H,000H,00FH,007H,00DH,019H,03CH,066H,066H,066H,03CH,000H,000H,000H
	DB 000H,000H,03CH,066H,066H,066H,03CH,018H,07EH,018H,018H,000H,000H,000H
	DB 000H,000H,03FH,033H,03FH,030H,030H,030H,070H,0F0H,0E0H,000H,000H,000H
	DB 000H,000H,07FH,063H,07FH,063H,063H,063H,067H,0E7H,0E6H,0C0H,000H,000H
	DB 000H,000H,018H,018H,0DBH,03CH,0E7H,03CH,0DBH,018H,018H,000H,000H,000H
	DB 000H,000H,040H,060H,070H,07CH,07FH,07CH,070H,060H,040H,000H,000H,000H
	DB 000H,000H,001H,003H,007H,01FH,07FH,01FH,007H,003H,001H,000H,000H,000H
	DB 000H,000H,018H,03CH,07EH,018H,018H,018H,07EH,03CH,018H,000H,000H,000H
	DB 000H,000H,033H,033H,033H,033H,033H,033H,000H,033H,033H,000H,000H,000H
ASC020	DB 000H,000H,07FH,0DBH,0DBH,0DBH,07BH,01BH,01BH,01BH,01BH,000H,000H,000H
	DB 000H,03EH,063H,030H,01CH,036H,063H,063H,036H,01CH,006H,063H,03EH,000H
	DB 000H,000H,000H,000H,000H,000H,000H,000H,07FH,07FH,07FH,000H,000H,000H
	DB 000H,000H,018H,03CH,07EH,018H,018H,018H,07EH,03CH,018H,07EH,000H,000H
	DB 000H,000H,018H,03CH,07EH,018H,018H,018H,018H,018H,018H,000H,000H,000H
	DB 000H,000H,018H,018H,018H,018H,018H,018H,07EH,03CH,018H,000H,000H,000H
	DB 000H,000H,000H,000H,00CH,006H,07FH,006H,00CH,000H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,018H,030H,07FH,030H,018H,000H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,060H,060H,060H,07FH,000H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,024H,066H,0FFH,066H,024H,000H,000H,000H,000H,000H
ASC030	DB 000H,000H,000H,008H,01CH,01CH,03EH,03EH,07FH,07FH,000H,000H,000H,000H
	DB 000H,000H,000H,07FH,07FH,03EH,03EH,01CH,01CH,008H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H
	DB 000H,000H,018H,03CH,03CH,03CH,018H,018H,000H,018H,018H,000H,000H,000H
	DB 000H,063H,063H,063H,022H,000H,000H,000H,000H,000H,000H,000H,000H,000H
	DB 000H,000H,036H,036H,07FH,036H,036H,036H,07FH,036H,036H,000H,000H,000H
	DB 00CH,00CH,03EH,063H,061H,060H,03EH,003H,043H,063H,03EH,00CH,00CH,000H
	DB 000H,000H,000H,000H,061H,063H,006H,00CH,018H,033H,063H,000H,000H,000H
	DB 000H,000H,01CH,036H,036H,01CH,03BH,06EH,066H,066H,03BH,000H,000H,000H
	DB 000H,030H,030H,030H,060H,000H,000H,000H,000H,000H,000H,000H,000H,000H
ASC040	DB 000H,000H,00CH,018H,030H,030H,030H,030H,030H,018H,00CH,000H,000H,000H
	DB 000H,000H,018H,00CH,006H,006H,006H,006H,006H,00CH,018H,000H,000H,000H
	DB 000H,000H,000H,000H,066H,03CH,0FFH,03CH,066H,000H,000H,000H,000H,000H
	DB 000H,000H,000H,018H,018H,018H,0FFH,018H,018H,018H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,000H,000H,000H,018H,018H,018H,030H,000H,000H
	DB 000H,000H,000H,000H,000H,000H,0FFH,000H,000H,000H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,000H,000H,000H,000H,018H,018H,000H,000H,000H
	DB 000H,000H,001H,003H,006H,00CH,018H,030H,060H,040H,000H,000H,000H,000H
	DB 000H,000H,03EH,063H,067H,06FH,07BH,073H,063H,063H,03EH,000H,000H,000H
	DB 000H,000H,00CH,01CH,03CH,00CH,00CH,00CH,00CH,00CH,03FH,000H,000H,000H
ASC050	DB 000H,000H,03EH,063H,003H,006H,00CH,018H,030H,063H,07FH,000H,000H,000H
	DB 000H,000H,03EH,063H,003H,003H,01EH,003H,003H,063H,03EH,000H,000H,000H
	DB 000H,000H,006H,00EH,01EH,036H,066H,07FH,006H,006H,00FH,000H,000H,000H
	DB 000H,000H,07FH,060H,060H,060H,07EH,003H,003H,063H,03EH,000H,000H,000H
	DB 000H,000H,01CH,030H,060H,060H,07EH,063H,063H,063H,03EH,000H,000H,000H
	DB 000H,000H,07FH,063H,003H,006H,00CH,018H,018H,018H,018H,000H,000H,000H
	DB 000H,000H,03EH,063H,063H,063H,03EH,063H,063H,063H,03EH,000H,000H,000H
	DB 000H,000H,03EH,063H,063H,063H,03FH,003H,003H,006H,03CH,000H,000H,000H
	DB 000H,000H,000H,018H,018H,000H,000H,000H,018H,018H,000H,000H,000H,000H
	DB 000H,000H,000H,018H,018H,000H,000H,000H,018H,018H,030H,000H,000H,000H
ASC060	DB 000H,000H,006H,00CH,018H,030H,060H,030H,018H,00CH,006H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,07EH,000H,000H,07EH,000H,000H,000H,000H,000H
	DB 000H,000H,060H,030H,018H,00CH,006H,00CH,018H,030H,060H,000H,000H,000H
	DB 000H,000H,03EH,063H,063H,006H,00CH,00CH,000H,00CH,00CH,000H,000H,000H
	DB 000H,000H,03EH,063H,063H,06FH,06FH,06FH,06EH,060H,03EH,000H,000H,000H
	DB 000H,000H,008H,01CH,036H,063H,063H,07FH,063H,063H,063H,000H,000H,000H
	DB 000H,000H,07EH,033H,033H,033H,03EH,033H,033H,033H,07EH,000H,000H,000H
	DB 000H,000H,01EH,033H,061H,060H,060H,060H,061H,033H,01EH,000H,000H,000H
	DB 000H,000H,07CH,036H,033H,033H,033H,033H,033H,036H,07CH,000H,000H,000H
	DB 000H,000H,07FH,033H,031H,034H,03CH,034H,031H,033H,07FH,000H,000H,000H
ASC070	DB 000H,000H,07FH,033H,031H,034H,03CH,034H,030H,030H,078H,000H,000H,000H
	DB 000H,000H,01EH,033H,061H,060H,060H,06FH,063H,033H,01DH,000H,000H,000H
	DB 000H,000H,063H,063H,063H,063H,07FH,063H,063H,063H,063H,000H,000H,000H
	DB 000H,000H,03CH,018H,018H,018H,018H,018H,018H,018H,03CH,000H,000H,000H
	DB 000H,000H,00FH,006H,006H,006H,006H,006H,066H,066H,03CH,000H,000H,000H
	DB 000H,000H,073H,033H,036H,036H,03CH,036H,036H,033H,073H,000H,000H,000H
	DB 000H,000H,078H,030H,030H,030H,030H,030H,031H,033H,07FH,000H,000H,000H
	DB 000H,000H,0C3H,0E7H,0FFH,0DBH,0C3H,0C3H,0C3H,0C3H,0C3H,000H,000H,000H
	DB 000H,000H,063H,073H,07BH,07FH,06FH,067H,063H,063H,063H,000H,000H,000H
	DB 000H,000H,01CH,036H,063H,063H,063H,063H,063H,036H,01CH,000H,000H,000H
ASC080	DB 000H,000H,07EH,033H,033H,033H,03EH,030H,030H,030H,078H,000H,000H,000H
	DB 000H,000H,03EH,063H,063H,063H,063H,06BH,06FH,03EH,006H,007H,000H,000H
	DB 000H,000H,07EH,033H,033H,033H,03EH,036H,033H,033H,073H,000H,000H,000H
	DB 000H,000H,03EH,063H,063H,030H,01CH,006H,063H,063H,03EH,000H,000H,000H
	DB 000H,000H,0FFH,0DBH,099H,018H,018H,018H,018H,018H,03CH,000H,000H,000H
	DB 000H,000H,063H,063H,063H,063H,063H,063H,063H,063H,03EH,000H,000H,000H
	DB 000H,000H,0C3H,0C3H,0C3H,0C3H,0C3H,0C3H,066H,03CH,018H,000H,000H,000H
	DB 000H,000H,0C3H,0C3H,0C3H,0C3H,0DBH,0DBH,0FFH,066H,066H,000H,000H,000H
	DB 000H,000H,0C3H,0C3H,066H,03CH,018H,03CH,066H,0C3H,0C3H,000H,000H,000H
	DB 000H,000H,0C3H,0C3H,0C3H,066H,03CH,018H,018H,018H,03CH,000H,000H,000H
ASC090	DB 000H,000H,0FFH,0C3H,086H,00CH,018H,030H,061H,0C3H,0FFH,000H,000H,000H
	DB 000H,000H,03CH,030H,030H,030H,030H,030H,030H,030H,03CH,000H,000H,000H
	DB 000H,000H,040H,060H,070H,038H,01CH,00EH,007H,003H,001H,000H,000H,000H
	DB 000H,000H,03CH,00CH,00CH,00CH,00CH,00CH,00CH,00CH,03CH,000H,000H,000H
	DB 008H,01CH,036H,063H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,0FFH,000H
	DB 018H,018H,00CH,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,03CH,006H,03EH,066H,066H,03BH,000H,000H,000H
	DB 000H,000H,070H,030H,030H,03CH,036H,033H,033H,033H,06EH,000H,000H,000H
	DB 000H,000H,000H,000H,000H,03EH,063H,060H,060H,063H,03EH,000H,000H,000H
ASC100	DB 000H,000H,00EH,006H,006H,01EH,036H,066H,066H,066H,03BH,000H,000H,000H
	DB 000H,000H,000H,000H,000H,03EH,063H,07FH,060H,063H,03EH,000H,000H,000H
	DB 000H,000H,01CH,036H,032H,030H,07CH,030H,030H,030H,078H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,03BH,066H,066H,066H,03EH,006H,066H,03CH,000H
	DB 000H,000H,070H,030H,030H,036H,03BH,033H,033H,033H,073H,000H,000H,000H
	DB 000H,000H,00CH,00CH,000H,01CH,00CH,00CH,00CH,00CH,01EH,000H,000H,000H
	DB 000H,000H,006H,006H,000H,00EH,006H,006H,006H,006H,066H,066H,03CH,000H
	DB 000H,000H,070H,030H,030H,033H,036H,03CH,036H,033H,073H,000H,000H,000H
	DB 000H,000H,01CH,00CH,00CH,00CH,00CH,00CH,00CH,00CH,01EH,000H,000H,000H
	DB 000H,000H,000H,000H,000H,0E6H,0FFH,0DBH,0DBH,0DBH,0DBH,000H,000H,000H
ASC110	DB 000H,000H,000H,000H,000H,06EH,033H,033H,033H,033H,033H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,03EH,063H,063H,063H,063H,03EH,000H,000H,000H
	DB 000H,000H,000H,000H,000H,06EH,033H,033H,033H,03EH,030H,030H,078H,000H
	DB 000H,000H,000H,000H,000H,03BH,066H,066H,066H,03EH,006H,006H,00FH,000H
	DB 000H,000H,000H,000H,000H,06EH,03BH,033H,030H,030H,078H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,03EH,063H,038H,00EH,063H,03EH,000H,000H,000H
	DB 000H,000H,008H,018H,018H,07EH,018H,018H,018H,01BH,00EH,000H,000H,000H
	DB 000H,000H,000H,000H,000H,066H,066H,066H,066H,066H,03BH,000H,000H,000H
	DB 000H,000H,000H,000H,000H,0C3H,0C3H,0C3H,066H,03CH,018H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,0C3H,0C3H,0DBH,0DBH,0FFH,066H,000H,000H,000H
ASC120	DB 000H,000H,000H,000H,000H,063H,036H,01CH,01CH,036H,063H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,063H,063H,063H,063H,03FH,003H,006H,03CH,000H
	DB 000H,000H,000H,000H,000H,07FH,066H,00CH,018H,033H,07FH,000H,000H,000H
	DB 000H,000H,00EH,018H,018H,018H,070H,018H,018H,018H,00EH,000H,000H,000H
	DB 000H,000H,018H,018H,018H,018H,000H,018H,018H,018H,018H,000H,000H,000H
	DB 000H,000H,070H,018H,018H,018H,00EH,018H,018H,018H,070H,000H,000H,000H
	DB 000H,000H,03BH,06EH,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,008H,01CH,036H,063H,063H,07FH,000H,000H,000H,000H

	;-----------------------------------------------------------;
	;							    ;
	;  Hercules RAM Charcter Set.  9 x 14 System Font	    ;
	;							    ;
	;	Extended   Character Set (128-255)		    ;
	;							    ;
	;-----------------------------------------------------------;

rgbHercExFont9x14	LABEL	BYTE

	DB 000H,000H,01EH,033H,061H,060H,060H,061H,033H,01EH,006H,003H,03EH,000H
	DB 000H,000H,000H,066H,066H,000H,066H,066H,066H,066H,03DH,000H,000H,000H
ASC130	DB 000H,006H,00CH,018H,000H,03EH,063H,07FH,060H,063H,03EH,000H,000H,000H
	DB 000H,008H,01CH,036H,000H,03CH,006H,03EH,066H,066H,03BH,000H,000H,000H
	DB 000H,000H,066H,066H,000H,03CH,006H,03EH,066H,066H,03BH,000H,000H,000H
	DB 000H,030H,018H,00CH,000H,03CH,006H,03EH,066H,066H,03BH,000H,000H,000H
	DB 000H,01CH,036H,01CH,000H,03CH,006H,03EH,066H,066H,03BH,000H,000H,000H
	DB 000H,000H,000H,000H,03CH,066H,060H,066H,03CH,00CH,006H,03CH,000H,000H
	DB 000H,008H,01CH,036H,000H,03EH,063H,07FH,060H,063H,03EH,000H,000H,000H
	DB 000H,000H,066H,066H,000H,03EH,063H,07FH,060H,063H,03EH,000H,000H,000H
	DB 000H,030H,018H,00CH,000H,03EH,063H,07FH,060H,063H,03EH,000H,000H,000H
	DB 000H,000H,066H,066H,000H,038H,018H,018H,018H,018H,03CH,000H,000H,000H
ASC140	DB 000H,018H,03CH,066H,000H,038H,018H,018H,018H,018H,03CH,000H,000H,000H
	DB 000H,060H,030H,018H,000H,038H,018H,018H,018H,018H,03CH,000H,000H,000H
	DB 000H,063H,063H,008H,01CH,036H,063H,063H,07FH,063H,063H,000H,000H,000H
	DB 01CH,036H,01CH,000H,01CH,036H,063H,063H,07FH,063H,063H,000H,000H,000H
	DB 00CH,018H,030H,000H,07FH,033H,030H,03EH,030H,033H,07FH,000H,000H,000H
	DB 000H,000H,000H,000H,06EH,03BH,01BH,07EH,0D8H,0DCH,077H,000H,000H,000H
	DB 000H,000H,01FH,036H,066H,066H,07FH,066H,066H,066H,067H,000H,000H,000H
	DB 000H,008H,01CH,036H,000H,03EH,063H,063H,063H,063H,03EH,000H,000H,000H
	DB 000H,000H,063H,063H,000H,03EH,063H,063H,063H,063H,03EH,000H,000H,000H
	DB 000H,030H,018H,00CH,000H,03EH,063H,063H,063H,063H,03EH,000H,000H,000H
ASC150	DB 000H,018H,03CH,066H,000H,066H,066H,066H,066H,066H,03BH,000H,000H,000H
	DB 000H,030H,018H,00CH,000H,066H,066H,066H,066H,066H,03BH,000H,000H,000H
	DB 000H,000H,063H,063H,000H,063H,063H,063H,063H,03FH,003H,006H,03CH,000H
	DB 000H,063H,063H,01CH,036H,063H,063H,063H,063H,036H,01CH,000H,000H,000H
	DB 000H,063H,063H,000H,063H,063H,063H,063H,063H,063H,03EH,000H,000H,000H
	DB 000H,018H,018H,07EH,0C3H,0C0H,0C0H,0C3H,07EH,018H,018H,000H,000H,000H
	DB 000H,01CH,036H,032H,030H,078H,030H,030H,030H,073H,07EH,000H,000H,000H
	DB 000H,000H,0C3H,066H,03CH,018H,0FFH,018H,0FFH,018H,018H,000H,000H,000H
	DB 000H,0FCH,066H,066H,07CH,062H,066H,06FH,066H,066H,0F3H,000H,000H,000H
	DB 000H,00EH,01BH,018H,018H,018H,07EH,018H,018H,018H,018H,0D8H,070H,000H
ASC160	DB 000H,00CH,018H,030H,000H,03CH,006H,03EH,066H,066H,03BH,000H,000H,000H
	DB 000H,00CH,018H,030H,000H,038H,018H,018H,018H,018H,03CH,000H,000H,000H
	DB 000H,00CH,018H,030H,000H,03EH,063H,063H,063H,063H,03EH,000H,000H,000H
	DB 000H,00CH,018H,030H,000H,066H,066H,066H,066H,066H,03BH,000H,000H,000H
	DB 000H,000H,03BH,06EH,000H,06EH,033H,033H,033H,033H,033H,000H,000H,000H
	DB 03BH,06EH,000H,063H,073H,07BH,07FH,06FH,067H,063H,063H,000H,000H,000H
	DB 000H,03CH,06CH,06CH,03EH,000H,07EH,000H,000H,000H,000H,000H,000H,000H
	DB 000H,038H,06CH,06CH,038H,000H,07CH,000H,000H,000H,000H,000H,000H,000H
	DB 000H,000H,018H,018H,000H,018H,018H,030H,063H,063H,03EH,000H,000H,000H
	DB 000H,000H,000H,000H,000H,000H,07FH,060H,060H,060H,000H,000H,000H,000H
ASC170	DB 000H,000H,000H,000H,000H,000H,07FH,003H,003H,003H,000H,000H,000H,000H
	DB 000H,060H,0E0H,063H,066H,06CH,018H,030H,06EH,0C3H,006H,00CH,01FH,000H
	DB 000H,060H,0E0H,063H,066H,06CH,018H,033H,067H,0CFH,01FH,003H,003H,000H
	DB 000H,000H,018H,018H,000H,018H,018H,03CH,03CH,03CH,018H,000H,000H,000H
	DB 000H,000H,000H,000H,01BH,036H,06CH,036H,01BH,000H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,06CH,036H,01BH,036H,06CH,000H,000H,000H,000H,000H
	DB 011H,044H,011H,044H,011H,044H,011H,044H,011H,044H,011H,044H,011H,044H
	DB 055H,0AAH,055H,0AAH,055H,0AAH,055H,0AAH,055H,0AAH,055H,0AAH,055H,0AAH
	DB 0DDH,077H,0DDH,077H,0DDH,077H,0DDH,077H,0DDH,077H,0DDH,077H,0DDH,077H
	DB 018H,018H,018H,018H,018H,018H,018H,018H,018H,018H,018H,018H,018H,018H
ASC180	DB 018H,018H,018H,018H,018H,018H,018H,0F8H,018H,018H,018H,018H,018H,018H
	DB 018H,018H,018H,018H,018H,0F8H,018H,0F8H,018H,018H,018H,018H,018H,018H
	DB 036H,036H,036H,036H,036H,036H,036H,0F6H,036H,036H,036H,036H,036H,036H
	DB 000H,000H,000H,000H,000H,000H,000H,0FEH,036H,036H,036H,036H,036H,036H
	DB 000H,000H,000H,000H,000H,0F8H,018H,0F8H,018H,018H,018H,018H,018H,018H
	DB 036H,036H,036H,036H,036H,0F6H,006H,0F6H,036H,036H,036H,036H,036H,036H
	DB 036H,036H,036H,036H,036H,036H,036H,036H,036H,036H,036H,036H,036H,036H
	DB 000H,000H,000H,000H,000H,0FEH,006H,0F6H,036H,036H,036H,036H,036H,036H
	DB 036H,036H,036H,036H,036H,0F6H,006H,0FEH,000H,000H,000H,000H,000H,000H
	DB 036H,036H,036H,036H,036H,036H,036H,0FEH,000H,000H,000H,000H,000H,000H
ASC190	DB 018H,018H,018H,018H,018H,0F8H,018H,0F8H,000H,000H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,000H,000H,0F8H,018H,018H,018H,018H,018H,018H
	DB 018H,018H,018H,018H,018H,018H,018H,01FH,000H,000H,000H,000H,000H,000H
	DB 018H,018H,018H,018H,018H,018H,018H,0FFH,000H,000H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,000H,000H,0FFH,018H,018H,018H,018H,018H,018H
	DB 018H,018H,018H,018H,018H,018H,018H,01FH,018H,018H,018H,018H,018H,018H
	DB 000H,000H,000H,000H,000H,000H,000H,0FFH,000H,000H,000H,000H,000H,000H
	DB 018H,018H,018H,018H,018H,018H,018H,0FFH,018H,018H,018H,018H,018H,018H
	DB 018H,018H,018H,018H,018H,01FH,018H,01FH,018H,018H,018H,018H,018H,018H
	DB 036H,036H,036H,036H,036H,036H,036H,037H,036H,036H,036H,036H,036H,036H
ASC200	DB 036H,036H,036H,036H,036H,037H,030H,03FH,000H,000H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,03FH,030H,037H,036H,036H,036H,036H,036H,036H
	DB 036H,036H,036H,036H,036H,0F7H,000H,0FFH,000H,000H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,0FFH,000H,0F7H,036H,036H,036H,036H,036H,036H
	DB 036H,036H,036H,036H,036H,037H,030H,037H,036H,036H,036H,036H,036H,036H
	DB 000H,000H,000H,000H,000H,0FFH,000H,0FFH,000H,000H,000H,000H,000H,000H
	DB 036H,036H,036H,036H,036H,0F7H,000H,0F7H,036H,036H,036H,036H,036H,036H
	DB 018H,018H,018H,018H,018H,0FFH,000H,0FFH,000H,000H,000H,000H,000H,000H
	DB 036H,036H,036H,036H,036H,036H,036H,0FFH,000H,000H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,0FFH,000H,0FFH,018H,018H,018H,018H,018H,018H
ASC210	DB 000H,000H,000H,000H,000H,000H,000H,0FFH,036H,036H,036H,036H,036H,036H
	DB 036H,036H,036H,036H,036H,036H,036H,03FH,000H,000H,000H,000H,000H,000H
	DB 018H,018H,018H,018H,018H,01FH,018H,01FH,000H,000H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,01FH,018H,01FH,018H,018H,018H,018H,018H,018H
	DB 000H,000H,000H,000H,000H,000H,000H,03FH,036H,036H,036H,036H,036H,036H
	DB 036H,036H,036H,036H,036H,036H,036H,0FFH,036H,036H,036H,036H,036H,036H
	DB 018H,018H,018H,018H,018H,0FFH,018H,0FFH,018H,018H,018H,018H,018H,018H
	DB 018H,018H,018H,018H,018H,018H,018H,0F8H,000H,000H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,000H,000H,01FH,018H,018H,018H,018H,018H,018H
	DB 0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH
ASC220	DB 000H,000H,000H,000H,000H,000H,000H,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH
	DB 0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H
	DB 00FH,00FH,00FH,00FH,00FH,00FH,00FH,00FH,00FH,00FH,00FH,00FH,00FH,00FH
	DB 0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,000H,000H,000H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,03BH,06EH,06CH,06CH,06EH,03BH,000H,000H,000H
	DB 000H,000H,000H,000H,03EH,063H,07EH,063H,063H,07EH,060H,060H,020H,000H
	DB 000H,000H,07FH,063H,063H,060H,060H,060H,060H,060H,060H,000H,000H,000H
	DB 000H,000H,000H,000H,07FH,036H,036H,036H,036H,036H,036H,000H,000H,000H
	DB 000H,000H,07FH,063H,030H,018H,00CH,018H,030H,063H,07FH,000H,000H,000H
	DB 000H,000H,000H,000H,000H,03FH,06CH,06CH,06CH,06CH,038H,000H,000H,000H
ASC230	DB 000H,000H,000H,000H,033H,033H,033H,033H,03EH,030H,030H,060H,000H,000H
	DB 000H,000H,000H,000H,03BH,06EH,00CH,00CH,00CH,00CH,00CH,000H,000H,000H
	DB 000H,000H,07EH,018H,03CH,066H,066H,066H,03CH,018H,07EH,000H,000H,000H
	DB 000H,000H,01CH,036H,063H,063H,07FH,063H,063H,036H,01CH,000H,000H,000H
	DB 000H,000H,01CH,036H,063H,063H,063H,036H,036H,036H,077H,000H,000H,000H
	DB 000H,000H,01EH,030H,018H,00CH,03EH,066H,066H,066H,03CH,000H,000H,000H
	DB 000H,000H,000H,000H,000H,07EH,0DBH,0DBH,07EH,000H,000H,000H,000H,000H
	DB 000H,000H,003H,006H,07EH,0DBH,0DBH,0F3H,07EH,060H,0C0H,000H,000H,000H
	DB 000H,000H,01CH,030H,060H,060H,07CH,060H,060H,030H,01CH,000H,000H,000H
	DB 000H,000H,000H,03EH,063H,063H,063H,063H,063H,063H,063H,000H,000H,000H
ASC240	DB 000H,000H,000H,07FH,000H,000H,07FH,000H,000H,07FH,000H,000H,000H,000H
	DB 000H,000H,018H,018H,018H,0FFH,018H,018H,018H,000H,0FFH,000H,000H,000H
	DB 000H,000H,030H,018H,00CH,006H,00CH,018H,030H,000H,07EH,000H,000H,000H
	DB 000H,000H,00CH,018H,030H,060H,030H,018H,00CH,000H,07EH,000H,000H,000H
	DB 000H,000H,00EH,01BH,01BH,018H,018H,018H,018H,018H,018H,018H,018H,018H
	DB 018H,018H,018H,018H,018H,018H,018H,018H,0D8H,0D8H,070H,000H,000H,000H
	DB 000H,000H,018H,018H,000H,000H,0FFH,000H,000H,018H,018H,000H,000H,000H
	DB 000H,000H,000H,000H,03BH,06EH,000H,03BH,06EH,000H,000H,000H,000H,000H
	DB 000H,038H,06CH,06CH,038H,000H,000H,000H,000H,000H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,000H,018H,018H,000H,000H,000H,000H,000H,000H
ASC250	DB 000H,000H,000H,000H,000H,000H,000H,018H,000H,000H,000H,000H,000H,000H
	DB 000H,00FH,00CH,00CH,00CH,00CH,00CH,0ECH,06CH,03CH,01CH,000H,000H,000H
	DB 000H,0D8H,06CH,06CH,06CH,06CH,06CH,000H,000H,000H,000H,000H,000H,000H
	DB 000H,070H,0D8H,030H,060H,0C8H,0F8H,000H,000H,000H,000H,000H,000H,000H
	DB 000H,000H,000H,000H,03EH,03EH,03EH,03EH,03EH,03EH,000H,000H,000H,000H
	DB 000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H,000H
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\ibmfont.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	ibmfont.asm : general purposes (CGA/EGA/MCGA/VGA, Graphics-Text) CSD
;*****************************************************************************

	include	csd_head.inc
	include	csd_data.inc

;*****************************************************************************

	include	csd_code.asm			;* first part of code

;*****************************************************************************

	include	genmodes.asm			;display mode table
	include	geninit.asm			;finitcsd

;*****************************************************************************
;*	* Special routines

NonStandard	DoUpdateCsd
NonStandard	FvmGetCur

;*****************************************************************************

IF CGACSD OR MCGACSD

;* 320x200 CGA mode 4
rgb4ColorCode	DB	00000000b	; 0
		DB	01010101b	; 1
		DB	10101010b	; 2
		DB	11111111b	; 3

ENDIF	;CGACSD OR MCGACSD

;*****************************************************************************

;********** FvmGetCur **********
;*	entry:	DS:DI => driver data
;*	* if first time called, identify the current screen and set fvmCur
;*	*  subsequent calls will return fvmCur
;*	*  After this call: fvmCur, codepageBase, codepageAlt are initialized
;*	exit:	AL == adapter (0 => no supported screen found)
;*		AH == monitor
cProc	FvmGetCur, <NEAR, PUBLIC, ATOMIC>
cBegin	FvmGetCur

	AssertEQ di,OFF_lpwDataCsd
	mov	al,[di].fvmCurAdap
	mov	ah,[di].fvmCurDisp
	or	ax,ax
	jz	init_get
	jmp	end_fvm_get

init_get:	;* initial get
	push	bp			; Int10's on some machines crunch bp.

;* set adapter flag

IF MDACSD
	mov	al,fvmMDA
ENDIF

IF CGACSD
	mov	al,fvmCGA
ENDIF

IF MCGACSD
	mov	al,fvmMCGA
ENDIF

IF VGACSD
	mov	al,fvmVGA
ENDIF

IF EGACSD
	mov	ah,12h			;Test for EGA
	mov	bl,10h
	int	10h

	mov	ax,fvmEGAM		; Test for a monochrome EGA display
	cmp	cl,0BH	 
	je	found_EGA
	cmp	cl,0AH
	je	found_EGA
	cmp	cl,04H
	je	found_EGA
	cmp	cl,05H
	je	found_EGA

	mov	ax,fvm64KEGA		; Text for 64K of EGA RAM
	or	bl,bl
	jz	found_EGA
	cmp	cl,3			; HiRes display for settings 9 & 3
	je	highRes
	cmp	cl,9
	jne	found_EGA
highRes:
	mov	ax,fvmEGA		; It's got more than 64K of RAM
found_EGA:
	mov	dx,ax			; allow co-exist of EGA and CGA
notEGA:					; Test for CGA
	mov	ax,0B800h		; The following test must use word
	mov	es,ax			; values.  Otherwise, it screws up on
	assume	es:nothing		; some monochrome systems.
	mov	es:[07FFEH],1234h	; See if offsets 7FFEH and 3FFEH
	mov	es:[03FFEH],5678h	; are the same - if so then we have
	cmp	es:[07FFEH],5678h	; a color card
	jne	@F
	or	dx,fvmCGA
	mov	ax,dx
	jmp	found_fvm
@@:
	mov	ax,dx
found_fvm:	;* al = fvm
ENDIF 	;EGACSD

	mov	dl,al
	mov	ah,0FAh 		; Find out if there is an EGA driver
	xor	bx,bx			; installed
	int	10h
	or	bx,bx
	jz	@F			; Jump if there isn't.
	or	dl,fvmMouse		; EGA.SYS is there (mirror registers)
@@:
	mov	al,dl
	mov	ah,0FFh			; assume no monitor chk
	push	bx    			;* check monochrome

IF MCGACSD
	push	ax			;save al (adapter info)
	mov	ax,1A00h		;read display combination code
	int	10h
	cmp	al,1Ah	
	pop	ax
	jne	ColorMode
	
	mov	ah,fvmECD or fvmCD
	cmp	bl,0Ch			;analog color ?
	je	ColorMode
	mov	ah,fvmMD		;analog mono (0Bh) 
ENDIF 	;MCGSCSD

IF EGACSD OR VGACSD
	test	al,fvmCGA		;CGA co-exist ?
	jnz	ColorMode		;if dual-card then enble all monitor
	push	ax			;save al (adapter info)
	mov	ah,12h
	mov	bl,10h
	int	10h	
	pop	ax
	mov	ah,fvmMD
	or	bh,bh			;0 = color, 1 = mono
	jnz	ColorMode
	mov	ah,fvmCD
	and	cl,00000110b		;switches 2 and 3 
	jnz	ColorMode		;off?
	mov	ah,fvmECD		;on.
ENDIF	;EGACSD OR VGACSD

ColorMode:
	pop	bx		
	mov	[di].fvmCurAdap,al		;* update drivers' data
	mov	[di].fvmCurDisp,ah		;* fill drivers' data
	pop	bp

end_fvm_get: ;* ax = fvm

cEnd	FvmGetCur


;********** DoUpdateCsd **********
;*	entry:
;*		parameters just like PrepUpdateCsd
;*	* after primary buffer has been updated
;*	exit: n/a

cProc	DoUpdateCsd,<FAR, PUBLIC, ATOMIC>, <DS, ES, SI, DI>
    parmB ayLine
    parmB axFirst
    parmB dax			;* will never be 0
    parmW offFirst
    parmW fRestoreDbcs		;* => restore DBCS 1/2 characters
    localB axCurs
    localB axCurrent
    localB flastattr		;check repeat attribute
IF CGACSD 
    localW wfgd			;needed for mode 4 (320x200x4)
    localW wbkgd
ENDIF	;CGACSD 
    localB curattr
    localW wTemp
    localV LocalChar,16		;storage of char bit map for ffont mode
IF VGACSD OR EGACSD
    ;* for extend int10 call
    localV rgbGraphicsRegSave,4	;* save buffer
    localV rgbGraphicsRegT,4	;* work buffer
ENDIF 	;VGACSD OR EGACSD

cBegin	DoUpdateCsd
	
	mov	di,OFF_lpwDataCsd		;* Data in data segment
	mov	bx,[di].pinstDrv

	test	ss:[bx].finstInst,finstGraphics	;graphics text 8x14
	jnz	graf_update

IFDEF	CGASNOW			;specific code for snow protect CGA
	mov	ds,ds:[bx].psPrimInst		;* DS:SI => primary buffer
	mov	si,offFirst

;*	* DS:SI => start character in primary buffer
;*	* SS:BX => INST info
;*	* SS:DI => Driver data

;*** Snow Protected CGA (Text) **
;*			    	*
;*			    	*	
	xor	cx,cx
	mov	cl,dax			;byte count
	mov	di,offFirst		;store starting address
	mov	ax,0B800h		;video segment
	mov	es,ax
	mov	dx,03DAh		;CGA status reg.
loop_update:
	lodsw				;primary buffer ds:[si] -> ax
	mov	bx,ax			;save char
enable_int_window:			;waitretracedefinte
	sti
	mov	ah,20			;* magic number of iterations
	cli				;* clear interrupts for magic loop
wait_for_noretrace:
	dec	ah
	jz	enable_int_window
	in	al,dx			; fetch status
	test	al,8
	jnz	do_it
	test	al,1			; horizontal retracing?
	jnz	wait_for_noretrace	; yes, wait until no retrace
wait_for_retrace:
	in	al,dx			; fetch status
	test	al,9			; horizontal/vertical retracing?
	jz	wait_for_retrace	; no, wait...
do_it:
	mov	ax,bx			;restore char
	stosw				;ax -> screen buffer es:[di]
	sti				;enable interrupts
	loop	loop_update

ENDIF	;CGASNOW
	jmp	done_graf_update

graf_update:

	mov	ax,[di].posCurs			;for cursor drawing
	mov	axCurs,-1
	mov	axCurrent,0
	cmp	byte ptr [di].fCurs,0		;cursor on ?
	je	NoCursUpdate

	cmp	ah,ayLine			;check if cursor on ayLine
	jne	NoCursUpdate

	cmp	al,axFirst			;check if cursor outside axFirst
	jb	NoCursUpdate

	mov	axCurs,al			;need to update cursor
	mov	al,axFirst
	mov	axCurrent,al
NoCursUpdate:	
	mov	si,ds:[bx].pdmInst		
	mov	dl,cs:[si].modeDm		;save video mode in dl
	mov	ds,ds:[bx].psPrimInst		;* DS:SI => primary buffer

;*	* DS:SI => start character in primary buffer
;*	* SS:BX => INST info
;*	* SS:DI => Driver data

	mov	flastattr,0		;initialize with black:black
	mov	cx,ss:[di].ayBox
	cmp	dl,6			;CGA mode 4 or 6
	ja	@F

	shr	cx,1			;memory interleave addressing
@@:
	xor	dh,dh
	mov	si,dx			;save video mode dl
	xor	ax,ax			;calculate start of screen address
	mov	al,ayLine
	mul	cx			;ayLine * charHeight
	mov	cx,80
	mul	cx
IF MCGACSD
	cmp	si,13h			;MCGA 256-color mode (320x200, 40x25)
	jne	@F
	shl	ax,1			;1 byte/pixel
	shl	ax,1
@@:
ENDIF	;MCGACSD
	xor	cx,cx
	mov	cl,axFirst
IF CGACSD
	cmp	si,4			;CGA 320x200x4 mode
	jne	@F
	shl	cx,1
@@:
ENDIF	;CGACSD
IF MCGACSD
	cmp	si,13h
	jne	@F
	shl	cx,1
	shl	cx,1
	shl	cx,1
@@:
ENDIF	;MCGACSD
	add	ax,cx			;ax = ayLine x 80 x ayBox + axFirst
	mov	di,ax			;point to video buffer

	xor	cx,cx
	mov	cl,dax			;no. of char to be updated

	mov	dx,si
	mov	si,offFirst

IF CGACSD
	cmp	dl,6			;CGA mode 4 or 6
	jbe	out_next_char1

	jmp	notmode6b


;* CGA graphics mode 4 or 6
	

out_next_char1:
	lodsw				;load character+attribute
	mov	curattr,ah
	push	cx			;save dax
	mov	wTemp,di		;save di
	mov	di,OFF_lpwDataCsd	
	mov	cx,ss:[di].ayBox	;calculate character table address

	push	ds			;save pointer to primary buffer
	push 	si

	mov	si,ss:[di].OFF_lpbFont	;default
	mov	ds,ss:[di].SEG_lpbFont

	mov	dx,ax			;save char + attribute
	test	ss:[di].fvmCurAdap,fvmCGA
	jz	first128

	cmp	al,80h
	jb	first128
		     			;use extend font (128 - 255)
	push	cs
	pop	ds
	mov	si,drvOffset rgbCGAExFont8x8	;see cga8x8.inc
	sub	al,80h

first128:
	xor	ah,ah
	mul	cl			
	add	si,ax				;ds:[si] -> char bit map

	mov	ax,ss
	mov	es,ax
	lea	di,LocalChar			;es:[di] -> local storage
	rep	movsb	 			;copy char bit map into local area
	mov	di,OFF_lpwDataCsd		;restore points
	mov	cx,ss:[di].ayBox	
	test	ss:[bx].finstInst,finstMonochrome	;Test for mono
	jz	@F
	cmp	curattr,70H			;highlighting ?
	jne	@F

	lea	si,LocalChar
loopnot:
	not	byte ptr ss:[si]
	inc	si
	loop	loopnot
	mov	cx,ss:[di].ayBox	
@@:	
	mov	ds,ax				;ds=ss
	lea	si,LocalChar
	cmp	ss:[bx].psSecInst,0		;is sec. buffer allocated ?
	je	notfont8

	test	ss:[bx].finstInst,finstFont	;ffont mode ?
	jz 	notfont8

	mov	ax,dx				;save char
	pop	di	;si -> di
	push	di
	mov	es,ss:[bx].psSecInst		;es:[di] => ffont buffer
	mov	dx,es:[di-2]			;dx = ffont word
	or	dl,dl				;normal ?
	jz	notfont8

	cmp	al,' ' 			;check spaces
	jne	@F
	
	test	dl,ffontUnderline or ffontDoubleUnderline or ffontStrikeThrough or ffontOrCharacter
	jz	notfont8
@@:
;*	ax = char + attribute
;*	dx = ffont word
	cCall	ChrisPFont 
notfont8:
	mov	di,OFF_lpwDataCsd	;restore points
	mov	cx,ss:[di].ayBox	;restore points
	mov	al,axCurrent		;cursor position ?
	cmp	al,axCurs
	jne	CursOff1

	mov	di,OFF_lpwDataCsd	
	push	si
	mov	cx,ss:[di].vparmCursOn
	xchg	ch,cl
	xor	ch,ch
	add	si,cx
	mov	cx,ss:[di].vparmCursOn
	sub	cl,ch
	xor	ch,ch

outCurs1:				;display the cursor
	not	byte ptr [si]
	inc	si
	loop	outCurs1
	pop	si
	mov	di,OFF_lpwDataCsd	;restore points
	mov	cx,ss:[di].ayBox	

CursOff1:

	mov	dh,curattr
	cmp	dh,flastattr		;same attr ?
	je	@F
	
	mov	flastattr,dh		;update attribute
	push	bx
	mov	dl,curattr
	mov	al,dl			;al = foreground
	and	al,03h
	mov	cl,4
	shr	dl,cl			;dl = background value
	and	dl,03h
	mov	bx,drvOffset rgb4ColorCode
	xlat	cs:rgb4ColorCode	
	mov	ah,al
	mov	wfgd,ax
	mov	al,dl
	xlat	cs:rgb4ColorCode	
	mov	ah,al
	mov	wbkgd,ax	
	pop	bx
	mov	cx,ss:[di].ayBox	
@@:					;* same attribute
	mov	ax,0B800h		;CGA video segment
	mov	es,ax
	mov	ax,1FFFh
	mov	dx,79-2000h
	cmp	ss:[bx].axMacInst,80
	je	@F
	dec	dx
	dec	ax
@@:
	mov	di,wTemp		;restore di
	test	di,2000h
	jz	@F

	xchg	ax,dx 			;exchange inc if 1st pixel lies in
		      			;odd interleave 
@@:
	cmp	ss:[bx].axMacInst,80
	je	out_one_byte

;;;320x200x4 mode (40x25)
out_1_byte:
	push	ax
	push	dx
	lodsb	
	xor	dx,dx
	mov	ah,8
L11:
	shr	al,1
	rcr	dx,1
	sar	dx,1
	dec	ah
	jnz	L11
	mov	ax,dx
	and 	ax,wfgd
	not	dx
	and	dx,wbkgd
	or	ax,dx
	xchg	ah,al
	stosw	
	pop	dx
	pop	ax
	add	di,ax	
	xchg	ax,dx
	loop	out_1_byte
	jmp short D11
	
out_one_byte:				;output the character
	movsb
	add	di,ax
	xchg	ax,dx
	loop	out_one_byte
D11:
	mov	di,wTemp
	inc	di			;next char
	cmp	ss:[bx].axMacInst,80
	je	@F
	inc	di
@@:
	inc	axCurrent		;bump update position
	pop	si
	pop	ds
	pop	cx			;restore dax
	dec	cx
	jz	out_done1
	jmp	out_next_char1

out_done1:
	jmp	done_graf_update	;done

ENDIF 	;CGACSD 

notmode6b:				

IF EGACSD OR VGACSD OR MCGACSD

;******* EGA/MCGA/VGA ********
;*
;*

out_next_char:
	lodsw				;load character+attribute
	mov	curattr,ah
	push	cx			;save dax
	push	ds			;save pointer to primary buffer
	push 	si
	mov	dx,ax			;save char
	mov	wTemp,di  		;save di
	mov	di,OFF_lpwDataCsd	;load cx with points
	mov	cx,ss:[di].ayBox	
	xor	ah,ah
	mul	cl			;ax = character table offset
	
	mov	si,ss:[di].OFF_lpbFont
	mov	ds,ss:[di].SEG_lpbFont
	add	si,ax			;ds:[si] -> char bit map

	mov	ax,ss
	mov	es,ax
	lea	di,LocalChar		;es:[di] -> local storage
	rep	movsb			;copy bitmap to local area
	mov	di,OFF_lpwDataCsd	;restore points
	mov	cx,ss:[di].ayBox	
	test	ss:[bx].finstInst,finstMonochrome	;Test for mono
	jz	@F
	cmp	curattr,70H			;highlighting ?
	jne	@F

	lea	si,LocalChar
loopnot:
	not	byte ptr ss:[si]
	inc	si
	loop	loopnot
	mov	cx,ss:[di].ayBox	
@@:	
	mov	ds,ax
	lea	si,LocalChar

	cmp	ss:[bx].psSecInst,0		;is sec. buffer allocated ?
	je	notfont14or16

	test	ss:[bx].finstInst,finstFont	;graphics text 8x14, 8x16
	jz	notfont14or16

	mov	ax,dx
	pop	di	;si -> di
	push	di
	mov	es,ss:[bx].psSecInst	;* es:[di] => ffont buffer
	mov	dx,es:[di-2]		
	or	dl,dl			;zero ffont
	jz 	notfont14or16

	cmp	al,' ' 			;check spaces
	jne	@F
	
	test	dl,ffontUnderline or ffontDoubleUnderline or ffontStrikeThrough or ffontOrCharacter
	jz	notfont14or16

@@:
;*	ax = char + attribute
;*	dx = ffont word
	cCall	ChrisPFont
	mov	di,OFF_lpwDataCsd	;restore points
	mov	cx,ss:[di].ayBox	
notfont14or16:
	mov	al,axCurrent
	cmp	al,axCurs
	jne	CursOff2

	mov	di,OFF_lpwDataCsd	
	push	cx
	push	si
	mov	cx,ss:[di].vparmCursOn
	xchg	ch,cl
	xor	ch,ch
	add	si,cx
	mov	cx,ss:[di].vparmCursOn
	sub	cl,ch
	xor	ch,ch
outCurs2:
	not	byte ptr [si]
	inc	si
	loop	outCurs2
	pop	si
	pop	cx

CursOff2:
	mov	di,OFF_lpwDataCsd	

IF EGACSD OR VGACSD
	test	ss:[bx].finstInst,finstMonochrome	;Test for mono
	jnz	@F
	mov	dh,curattr
	cmp	dh,flastattr		;same attr ?
	jne	SetAttr
@@:
	jmp	SameAttr
SetAttr:
	push	bx
	mov	flastattr,dh
	mov	di,OFF_lpwDataCsd	;restore points
	test	ss:[di].fvmCurAdap,fvmMouse	;Test for EGA.SYS
	jz	@F
					;* Use extend int10 call
	mov	ax,ss			;save register values
	mov	es,ax
	lea	bx,rgbGraphicsRegSave
	mov	dx,10h			;Graphics control registers port
	mov	ah,0F2h
	mov	cx,4
	int	10h

;*	* move new state into register : al, ah, cl, ch
	mov	ah,curattr
	mov	al,ah			;al = foreground
	mov	cl,4
	shr	ah,cl			;ah = background value
	push	ax			;save attribute
	mov	al,ah			;load S/R with bkgd
	mov	ah,0Fh			;set Enable register
	mov	cl,ss:[bx+2]
	mov	ch,0		 	;data rotate

	lea	bx,rgbGraphicsRegT	;initiate buffer
	mov	ss:[bx],ax
	mov	ss:[bx+2],cx

	mov	ah,0F3h			;write registers
	mov	cx,4
	mov	dx,10h			;Graphics control registers port
	int	10h

	mov	ax,0A000h		;set video segment
	mov	es,ax
	mov	al,0FFh
	mov	di,wTemp		;restore di
	mov	es:[di],al
	mov	al,es:[di]		;load bit plane latches

	lea	bx,rgbGraphicsRegSave
	mov	byte ptr ss:[bx],0	;clear S/R (default)
	pop	ax
	xor	ah,al			;ah = bkgd xor fgd
	not	ah
	and 	ah,0Fh
	mov	byte ptr ss:[bx+1],ah	;load En S/R
	mov	byte ptr ss:[bx+3],18h	;set data rot reg (cpu xor latches)
	mov	ax,ss
	mov	es,ax
	mov	ah,0F3h			;write registers
	mov	cx,4
	mov	dx,10h			;Graphics control registers port
	int	10h
	jmp	SetAttrDone
@@:
					;* Direct hardware I/O
	mov	dx,3CEh			;Graphics control registers port
	mov	ax,0F01h		;set Enable register
	out 	dx,ax

	mov	ax,0003			;data rotate
	out	dx,ax

	mov	bh,curattr
	mov	bl,bh			;bl = foreground
	mov	cl,4
	shr	bh,cl			;bh = background value

	xor	al,al			;load S/R with bkgd
	mov	ah,bh
	out 	dx,ax

	mov	ax,0A000h		;set video segment
	mov	es,ax
	mov	al,0FFh
	mov	di,wTemp		;restore di
	mov	es:[di],al
	mov	al,es:[di]		;load bit plane latches

	xor	ax,ax			;clear S/R (default)
	out	dx,ax

	mov	ah,bh			;ah = bkgd xor fgd
	xor	ah,bl

	not	ah
	and 	ah,0Fh
	mov	al,1			;load En S/R
	out	dx,ax

	mov	ax,1803h		;set data rot reg (cpu xor latches)
	out	dx,ax

SetAttrDone:
	pop	bx

SameAttr:
ENDIF 	;EGACSD OR VGACSD

	mov	di,OFF_lpwDataCsd	;restore points
	mov	cx,ss:[di].ayBox	
	mov	ax,0A000h		;set video segment
	mov	es,ax
	mov	di,wTemp		;restore di
IF MCGACSD
	cmp	ss:[bx].axMacInst,40
	jne	Not256

;;;256-color mode, 40x25
	push	bx
	mov	bh,curattr
	mov	bl,bh			;bl = foreground
	shr	bh,1			;bh = background value
	shr	bh,1
	shr	bh,1
	shr	bh,1
	and	bx,0F0Fh
L10:
	push	cx
	mov	cx,8			;1 byte/pixel (256-color)
	lodsb	
	mov	ah,al			;ah = bit pattern
L11:
	mov	al,bl			;al = foreground
	shl	ah,1			;carry = hi-bit
	jc	L12			;jmp if fgd
	mov	al,bh			;al = bkgd
L12:
	stosb				;update one pixel
	loop	L11
	add	di,320-8		;next line
	pop	cx
	loop	L10	

	pop	bx
	mov	di,wTemp
	add	di,8			;next char
	jmp short J13
Not256:
ENDIF	;MCGACSD
	mov	ax,04Fh			;column(80 - 1)

out_char_map:
	movsb
	add	di,ax			;go to next scan line (+80-1)
	loop	out_char_map
	
	mov	di,wTemp		;restore di
	inc	di			;next char
J13:
	inc	axCurrent		;bump update position
	pop	si
	pop	ds
	pop	cx			;restore dax
	dec 	cx
	jz	out_done2
	jmp	out_next_char

out_done2:
	mov	di,OFF_lpwDataCsd	;ss:[di] => drive data

IF EGACSD OR VGACSD
			  		;EGA and VGA only
	cmp	flastattr,0
	je	done_graf_update
			 		;restore default Graphics control registers
	mov	di,OFF_lpwDataCsd	
	test	ss:[di].fvmCurAdap,fvmMouse	;Test for EGA.SYS
	;STI
	jz	done_graf_update_no_ega_sys

;*	* Restore state of EGA.SYS
	mov	ax,ss
	mov	es,ax
	lea	bx,rgbGraphicsRegSave
	mov	dx,10h			;Graphics control registers port
	mov	ah,0F3h
	mov	cx,4
	int	10h
	jmp short done_graf_update

done_graf_update_no_ega_sys:
	mov	dx,3CEh			;restore Graphics control registers
	mov	ax,0003			;data rotate
	out	dx,ax
	mov	ax,0001			;zero En S/R
	out 	dx,ax
ENDIF	;EGACSD	OR VGACSD

ENDIF 	;EGACSD OR VGACSD OR MCGACSD

done_graf_update:

end_update:

cEnd	DoUpdateCsd

IF (CGACSD OR MCGACSD OR EGACSD OR VGACSD)
IF CGACSD	
	include cga8x8.inc		; extend font (128 - 255)
ENDIF
	include cpfont.asm		;* ChrisPFont with 8x8,8x14,8x16
ENDIF 	;(CGACSD OR MCGACSD OR EGACSD OR VGACSD)



NonStandard	BltArcCsd

;********** BltArcCsd **********
;*	* CSD entry point (see documentation for interface)
;*	entry : axSrc, aySrc : upper left of source
;*		axDest, ayDest : upper left of destination
;*		dax, day : shift amount
;*	* Move a rectangle from one portion of the screen to another.
;*	exit : n/a

cProc	BltArcCsd,<FAR, PUBLIC, ATOMIC>, <SI,DI,DS>
    parmB axDest
    parmB ayDest
    parmB dax 
    parmB day
    parmB axSrc
    parmB aySrc
    localW cRows
cBegin	BltArcCsd
	mov	di,OFF_lpwDataCsd		;* Data in data segment

;*	* SS:BX => INST info
;*	* SS:DI => Driver data

;set up Src pointer si
	mov	cx,ss:[di].ayBox
IF CGACSD
	shr	cx,1			;memory interleave
ENDIF	;CGACSD
	mov	al,80			;assume 80 columns (IBM)
	mul	cl			;
	mov	bx,ax			;bx = 80 * charHeight
	mov	cl,aySrc		
	mul	cx
	mov	cl,axSrc
	add	ax,cx			;ax = ay x 80 x Height + ax
	mov	si,ax			;si points to starting byte Src

;set up Dest pointer di
;assume (Scroll down) Hi -> Lo memory
	mov	ax,bx
	mov	cl,ayDest		
	mul	cx
	mov	cl,axDest
	add	ax,cx
	mov	cx,ss:[di].ayBox	;for later use
	mov	di,ax

	mov	al,day		
	mul	cl			;ax = ayBox * day
	mov	cRows,ax		;total scan rows needed to be blt

 	mov	cl,ayDest
	cmp	cl,aySrc
	jb	fwd
	ja	bkwd
;ayDest = aySrc
	mov	cl,axDest
	cmp	cl,axSrc
	jb	fwd		
bkwd:	
;have to blt backward (Lo -> Hi memory)
;(Scroll up) 
IF CGACSD
	shr	ax,1
ENDIF	;CGACSD
	dec	ax
	mov	cx,80
	mul	cx
	mov	cl,dax
	dec	cx
	add	ax,cx			;ax = block offset
IF CGACSD
	add	ax,2000h		;start blt from odd line
ENDIF	;CGACSD
	add	di,ax			;si, di point to end of block
	add	si,ax	
	std				;set direction flag
fwd:

IF (EGACSD OR VGACSD)
	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	mov	bx,ss:[bx].pinstDrv
	test	ss:[bx].finstInst,finstMonochrome
	jnz	@F
	mov	dx,3CEh			;Graphics Ctrl port
;	read mode 0, write mode 1
	mov	ax,0105h
	out	dx,ax
@@:
ENDIF	;(EGACSD OR VGACSD)
IF CGACSD
	mov	ax,0B800h
ELSE
	mov	ax,0A000h
ENDIF	;CGACSD
	mov	ds,ax			;ds,es point to video buffer
	mov	es,ax
	mov	cx,cRows				
Blt1:
	mov	ax,si
	mov	bx,di
	mov	dx,cx
;	push	si
;	push	di
;	push	cx	

	xor	ch,ch
	mov	cl,dax
	rep	movsb 			;load latches/store video memory

;	pop	cx
;	pop	di
;	pop	si
	mov	cx,dx
	mov	di,bx
	mov	si,ax
IF CGACSD
	cmp	di,si
	jb	bf
;blt backward
	cmp	si,2000h
	jb	@F
	mov	dx,-2000h
	jmp short Blt2
@@:
	mov	dx,2000h - 80
	jmp short Blt2
bf:
;blt forward
	cmp	si,2000h
	jb	@F
	mov	dx,-2000h + 80
	jmp short Blt2
@@:
	mov	dx,2000h
Blt2:
ELSE	;!CGACSD
	mov	dx,80
	cmp	di,si
	jb	@F
	neg	dx			;blt backward
@@:
ENDIF	;CGACSD
	add	si,dx			;go to next row
	add	di,dx
	loop	Blt1

IF (EGACSD OR VGACSD)
;restore default			
;	read mode 0, write mode 0
	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	mov	bx,ss:[bx].pinstDrv
	test	ss:[bx].finstInst,finstMonoChrome
	jnz	@F
	mov	dx,3CEh
	mov	ax,0005h
	out	dx,ax
@@:
ENDIF	;(EGACSD OR VGACSD)

	cld				;clear direction flag

cEnd	BltArcCsd



NonStandard	GetCharMapCsd

;********** GetCharMapCsd **********
;*	entry:	pinft, ch, pbitmap
;*	* copy character bit map into buffer

cProc	GetCharMapCsd, <FAR, ATOMIC, PUBLIC>, <DS,SI,DI>
    parmDP pinft
    parmB  char
    parmDP pbitmap    
cBegin	GetCharMapCsd
	mov	di,pinft			;* ds:di => INFT
	xor	ch,ch
	mov	cl,ds:[di].dyCharInft
IF CGACSD
	mov	al,char
	cmp	al,128
	jb	@F
	sub	al,128
	mov	dx,cs
	mov	ds,dx
	mov	si,drvOffset rgbCGAExFont8x8	;see cga8x8.inc
	jmp short RetFonts
@@:
	mov	dx,0F000h
	mov	ds,dx
	mov	si,0FA6Eh
RetFonts:
	mul	cl
	add	si,ax				;ds:si => character bit map		

ELSE	;EGACSD or VGACSD or MCGACSD
	mov	bh,3				;assume 8x8 fonts
	cmp	cl,14
	jne	@F
	dec	bh				;return 8x14 fonts
	jmp short RetFonts
@@:	
	cmp	cl,16
	jne	RetFonts
	mov	bh,6				;return 8x16 fonts
RetFonts:	
	mov	ax,1130h
	push	bp
	int	10h
	mov	si,bp
	pop	bp
	mov	cl,ds:[di].dyCharInft
	mov	al,char
	mul	cl
	add	si,ax
	mov	ax,es
	mov	ds,ax				;ds:si => character bit map
ENDIF	;CGACSD

	mov	ax,ss
	mov	es,ax
	mov	di,pbitmap			;es:di => destination
	rep	movsb
	
cEnd	GetCharMapCsd


;*****************************************************************************


	include	csd_std.asm		;* standard init/term
	include	csd_ibm.asm		;* IBM specific routines

;*****************************************************************************
;*	* only include one of the following, as appropriate

	include	csd_vram.asm		;* default procs for direct video I/O
	include	csd_save.asm		;* default screen save (none)

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************


	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\mcga.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	mcga.asm : MCGA CSD
;*
;*****************************************************************************

	MDACSD = 0
	CGACSD = 0
	EGACSD = 0
	MCGACSD = 1
	VGACSD = 0
	
	GRAPHICSTEXT = 1

	CPF816 = 1

	include	ibmfont.asm


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\olivetti.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	olivetti.asm : Olivetti and AT&T 6300 CSD
;*
;*****************************************************************************

	include	csd_head.inc
	include	csd_data.inc

;*****************************************************************************

	include	csd_code.asm			;* first part of code

;*	* Display modes table
rgdm:

;* #0 - standard color mode
	DB	0ffh				;* any
	DB	0ffh				;* any
	DB	3				;* mode
	DW	finstText			;* flags
	DB	80, 25				;* screen size
	DB	16				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0B800H				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved
	Assert	<($-rgdm) EQ SIZE DM>

;* #1 - Graphics text mode (mono)
	DB	0ffh				;* any
	DB	0ffh				;* any
	DB	40h				;* mode
	DW	finstGraphics OR finstFont OR finstMonoChrome or finstFastScroll	;* flags
	DB	80, 25				;* screen size
	DB	2				;* coMac
	DB	8, 16, 0, 0			;* INFT
	DW	0				;* video address
	DW	0E0FH				;* cursor
	DW	0				;* reserved

;* #2 - Graphics text mode (mono)
	DB	0ffh				;* any
	DB	0ffh				;* any
	DB	40h				;* mode
	DW	finstGraphics OR finstFont OR finstMonoChrome or finstFastScroll	;* flags
	DB	80, 50				;* screen size
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved
cdmMax	equ	($ - rgdm) / (size DM)		;* # of modes

;*****************************************************************************
;*	* Special routines

NonStandard	FInitCsd

;*****************************************************************************


;********** FInitCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* Initialize the screen to the given mode
;*	exit:	AX != 0 if ok

cProc	FInitCsd, <FAR, PUBLIC, ATOMIC>, <DI>
    parmDP pinst
    parmDP pinch
cBegin	FInitCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment

;*	* set mode
	mov	bx,pinst
	mov	[di].pinstDrv,bx
	mov	bx,ds:[bx].pdmInst		;* CS:BX => DM info

;*	* copy mode info into driver globals
	mov	ax,cs:[bx].vparmCursOnDm
	mov	[di].vparmCursOn,ax
	mov	[di].vparmCursSize,ax
	mov	ax,cs:[bx].wExtraDm
	mov	[di].wExtra,ax

	cCall	ModeGetCur			;* al = mode, ah = ayMac
	cmp	ah,cs:[bx].ayMacDm
	je	@F
	xor	al,al
@@:
	cmp	al,cs:[bx].modeDm
	je	@F				;* don't reset

	mov	al,cs:[bx].modeDm
	xor	ah,ah			
	int	10h				;* set mode
@@:

	mov	ax,40H
	mov	es,ax
	mov	al,cs:[bx].ayMacDm
	dec	al				; rows - 1
	mov	byte ptr es:[0084H],al		;* update BIOS rows

	test	cs:[bx].finstDm,finstGraphics
	jz	InitText

	xor	ah,ah	
	mov	al,cs:[bx].dyCharDm
	mov	[di].ayBox,ax			;* points
	cmp	ax,8
	je	@F

	mov	[di].SEG_lpbFont,cs				;8x16 font
	mov	[di].OFF_lpbFont,drvOffset rgbVectFont8x16
	jmp short font1

@@:	mov	[di].SEG_lpbFont,0F000h		;8x8 font (lower 128)
	mov	[di].OFF_lpbFont,0FA6Eh
font1:	
	jmp	short InitDone

InitText:	
;*	* the INCH array already contains the standard Code Page 437
;*	*  character set, so it usually can be left the same.

;*	* Do other diddling
	cCall	DiddleBlinkBit

InitDone:
	mov	ax,sp				;* success
cEnd	FInitCsd

;*****************************************************************************

	OLIVETTICSD = 1
	include update2.asm
	include	vect8x16.inc		;* hard code font table

;*****************************************************************************

	include	csd_std.asm		;* standard init/term
	include	csd_ibm.asm		;* IBM specific routines

;*****************************************************************************

	include	csd_vram.asm		;* default procs for direct video I/O
	include	csd_save.asm		;* default screen save (none)

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************


	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\saveega.inc ===
;*
;*	CW : Character Windows
;*
;*	egasave.inc : Screen Save IBM specific info


;*****************************************************************************


EGA_VIDS	STRUC		;* VIDS structure + private info
	vidsPrefix	DB	cbVidsMin DUP (?)
	vparmCursorVids	DW	?			;* cursor size
	rgwCursorPosVids DW	8 DUP (?)		;* cursor positions
							;* for 8 pages
	fClearRegenVids	db	?			;* 80H for no regen clr
	ayPointsVids	DB	?			;* char points
	ayMacVids	DB	?			;* rows
	ayOverScanVids	DB	?
	cwSwapVids	DW	?			;* lines*columes
	bCGABgVids	DB	?			;* CGA Background color
	bCGAPalVids	DB	?			;* 4-color palette
	rgbEGAPaletteVids	DB	21 DUP (?)	;* attr ctrl regs
	rgbPS2PaletteVids	DB	3 DUP (?)	;* reserved for DAC color regs
EGA_VIDS	ENDS


;*****************************************************************************

GRChipOffset	EQU	10H
CRTCChipOffset	EQU	00H
SEQChipOffset	EQU	08H
AttrChipOffset	EQU	18H

CGA_6845_MODE	EQU	3D8H
CGA_6845_STATUS	EQU	3DAH

; Number of lines when 8x8 character set is used in the following graphics
; modes:            0d  0e  0f  10  11  12  13
;                   |   |   |   |   |   |   |
;                   v   v   v   v   v   v   v
GraphicsModeRows DB 25, 25, 43, 43, 60, 60, 25

		
;
; ColourPalette - used to reset the EGA palette for 16-color
;		  modes with a Color Display.
;
labelB	<ColourPalette>
	;	RGBrgb
	DB	000000B 	;black
	DB	000001B 	;blue
	DB	000010B 	;green
	DB	000011B 	;cyan
	DB	000100B 	;red
	DB	000101B 	;magenta
labelB <ColourPaletteYellow>
	DB	000110B 	;yellow
	DB	000111B 	;white
	DB	111000B 	;gray
	DB	111001B 	;light blue
	DB	111010B 	;light green
	DB	111011B 	;light cyan
	DB	111100B 	;light red
	DB	111101B 	;light magenta
	DB	111110B 	;light yellow
	DB	111111B 	;bright white
	db	0		;Overscan
;
; MonoPalette - used to reset the EGA palette for 16-color
;		  modes with a monochrome Display.
;
labelB	<MonoPalette>
	;	 IV   
	DB	000000B 	;black
	DB	001000B 	;white
	DB	001000B 	;white
	DB	001000B 	;white
	DB	001000B 	;white
	DB	001000B 	;white
	DB	001000B 	;white
	DB	001000B 	;white
	DB	010000B 	;gray
	DB	011000B 	;bright white
	DB	011000B 	;bright white
	DB	011000B 	;bright white
	DB	011000B 	;bright white
	DB	011000B 	;bright white
	DB	011000B 	;bright white
	DB	011000B 	;bright white
	db	0		;Overscan

BIOSINT10	label	dword
lpbBIOSINT10_Offset	dw	0
lpbBIOSINT10_Segment	dw	0

EgaPaletteMirror db	0,1,2,3,4,5,14H,7,38H,39H,3aH,3bH,3cH,3dH,3eH,3fH
OverScanMirror	db	0

;
; bCGABg - CGA background colour
;          Set by INT 10 with AH=0B, BH=0, BL=bCGABg
;
; bCGAPal - CGA 320x200 4-colour palette
;	    Set by INT 10 with AH=0B, BH=1, BL=bCGAPal
;
; -1 indicates value not set.
;
bCGABg		db	-1
bCGAPal		db	-1
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\scr5.inc ===
;*
;*	CW : Character Windows
;*
;*	scr5.inc : screen driver data info (OS/2)


;*****************************************************************************
;*	* CursorData structure (VioXxxCurType)
CT	STRUC
	lineStartCt	DW	?
	lineEndCt	DW	?
	widthCt		DW	?
	atrCt		DW	?
CT	ENDS

cbCtMin	EQU	size CT
;*****************************************************************************
;*	* ModeData structure (VioXxxMode)
MD	STRUC
	cbMd		DW	?
	typeMd		DB	?
	colorMd		DB	?
	axMacMd		DW	?
	ayMacMd		DW	?
	hResMd		DW	?
	vResMd		DW	?
;	fmtMd		DB	?
;	attribMd	DB	?
MD	ENDS

cbMdMin	EQU	size MD
;*****************************************************************************
;*	* ConfigData structure (VioGetConfig)
CD	STRUC
	cbCd		DW	?
	adapCd		DW	?
	dispCd		DW	?
	lcbmemCd	DD	?
CD	ENDS

cbCdMin	EQU	size CD
;*****************************************************************************
;*	* FontInfo structure (VioxxxFont)
FI	STRUC
	cbFi		DW	?
	typeFi		DW	?
	axCellFi	DW	?
	ayCellFi	DW	?
	pbDataFi	DD	?
	cbDataFi	DW	?
FI	ENDS

cbFiMin	EQU	size FI

PB	STRUC
	pBufPb		DD	?
	cbPb  		DD	?
	sel0Pb		DW	?
	sel1Pb		DW	?
	sel2Pb		DW	?
	sel3Pb		DW	?
PB	ENDS

cbPbMin EQU	size PB
;*****************************************************************************
;*	* Palette request block (VioXxxState)

;*	* PR is a variable structure.  The number of cov's set/received
;*	* depends on cbPr.  To get info for n palettes starting with coFirstPr
;*	* use:
;*	*	cbPr equ cbPrMin + n * 2
;*	*	localV pr,cbPr
;*	*	mov pr.cbPr,cbPr

PR	STRUC
	cbPr		DW	?
	rtPr		DW	?
	coFirstPr	DW	?
PR	ENDS

rgcovPr	EQU	coFirstPr + 2

cbPrMin	EQU	size PR
cbPr1	EQU	cbPrMin + 2
cbPrMax	EQU	38
;*****************************************************************************

adapMDA		EQU	0
adapCGA		EQU	1
adapEGA		EQU	2
adapVGA		EQU	3

dispMDA		EQU	0
dispCGD		EQU	1
dispEGD		EQU	2

hvioCur		EQU	0			;* Vio Handle (0 for OS/2 1.x)
atrCurOff	EQU	-1

;*****************************************************************************

PushArg	MACRO	arg_list		;; Push multiple registers
	irp	x,<arg_list>
		push	x
	endm
ENDM

Os2Call	MACRO	ofn			;* Call through link table
	call	[bx+lpfn&ofn&Inos]
ENDM


;*****************************************************************************

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\oax.asm ===
;*
;*	CW : Character Windows
;*
;*	csd_kanj.inc : contains the default routines for kanji
;*
;*

	include	kanji.inc


ifndef	PrepUpdateCsd
;*****************************************************************************
;********** PrepUpdateCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* For KANJI -- erase any dangling 1/2 characters

cProc	PrepUpdateCsd,<FAR, PUBLIC, ATOMIC>, <DS, SI, DI>
    parmB ayLine
    parmB axFirst
    parmB dax
    parmW offFirst
    parmW fRestoreDbcs		;* => restore DBCS 1/2 characters
cBegin	PrepUpdateCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment
	mov	bx,[di].pinstDrv
	mov	ds,ds:[bx].psPrimInst		;* DS:SI => primary buffer
	mov	si,offFirst

;*	* DS:SI => start character in primary buffer
;*	* SS:BX => INST info
;*	* SS:DI => Driver data

;*	* if not restoring: 1/2 of double wide characters must be erased
	cmp	fRestoreDbcs,0
	jne	done_half_char_check

;*	* if first character is in middle of character, erase previous half
	mov	al,axFirst
	or	al,al
	jz	check_end_character		;* start of line is always safe
	cmp	byte ptr ds:[si+1],0		;* is this a second byte char ?
	jne	check_end_character
;*	* erase previous character (CW will restore this later)
	mov	byte ptr ds:[si-2],' '
check_end_character:
;*	* AX = axFirst, DS:SI => primary buffer position of first char
	xor	bx,bx
	mov	bl,axFirst
	add	bl,dax
	cmp	bl,ss:[bx].axMacInst
	jae	done_half_char_check		;* end of screen is safe
	mov	bl,dax
	dec	bx
	shl	bx,1
	cmp	byte ptr ds:[si+bx+1],0		;* after last a 1/2 char ?
	jne	done_half_char_check
;*	* erase the character at end of line
	mov	byte ptr ds:[si+bx],' '
	mov	al,ds:[si+bx-1]			;* attribute of first half
	mov	byte ptr ds:[si+bx+1],al

done_half_char_check:

cEnd	PrepUpdateCsd
;*****************************************************************************
endif	;* PrepUpdateCsd


ifndef	DoUpdateCsd
;*****************************************************************************
;********** DoUpdateCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* for Kanji -- parse for DBCS boundaries (OAX)
;*	exit: n/a

cProc	DoUpdateCsd,<FAR, PUBLIC, ATOMIC>, <DS, SI, DI>
    parmB ayLine
    parmB axFirst
    parmB dax			;* will never be 0
    parmW offFirst
    parmW fRestoreDbcs		;* => restore DBCS 1/2 characters
    localB attrMaskT
cBegin	DoUpdateCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment
	mov	bx,[di].pinstDrv
	mov	al,[di].attrMask
	mov	attrMaskT,al
	mov	ds,ds:[bx].psPrimInst		;* DS:SI => primary buffer
	mov	si,offFirst

;*	* DS:SI => start character in primary buffer
;*	* attrMaskT is set up for attribute mask
;*	* SS:BX => INST info
;*	* SS:DI => Driver data

	cmp	ss:[di].fBios,0
	je	done_bios_update		;* no update for non-bios

;*	* BIOS Update
;*	* move to proper position
	mov	dl,axFirst
	mov	dh,ayLine

;*	* copy all characters to screen

	xor	bx,bx				;* BH = 0, page #0 always
	mov	bl,dax
	mov	di,bx				;* count
	mov	cx,1				;* 1 char always
loop_update:
;*	* set cursor & bump column for next
	mov	ah,2
	int	10h				;* SetCursorPosition
	inc	dl				;* next position

	lodsw					;* al = char, ah = attr
	mov	bl,ah
	and	bl,attrMaskT
	mov	ah,9
	int	10h				;* WriteCharAttr

	dec	di
	jnz	loop_update

done_bios_update:

;*	* For the OAX, we parse what we have printed and set the attribute
;*	*  byte to 0 for the second byte of double byte characters.
	cmp	fRestoreDbcs,0
	jne	end_update
	mov	si,offFirst
	xor	cx,cx
	mov	cl,dax				;* # of bytes
loop_parse_dbcs:
	lodsw					;* get char(al) + attribute(ah)
	JmpNotDbc parse_single
;*	* second byte follows
	inc	si				;* skip 2nd char
	mov	byte ptr ds:[si],0		;* clear attrib
	inc	si
	AssertNE cx,1				;* must be enough
	dec	cx
parse_single:
	loop	loop_parse_dbcs

end_update:

cEnd	DoUpdateCsd
;*****************************************************************************
endif	;* DoUpdateCsd


ifndef	DoneUpdateCsd
;*****************************************************************************
;********** DoneUpdateCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* Restore cursor

cProc	DoneUpdateCsd,<FAR, PUBLIC, ATOMIC>,<DI>
cBegin	DoneUpdateCsd

;*	* restore old cursor position
	mov	di,OFF_lpwDataCsd		;* Data in data segment
	cmp	[di].fBios,0
	je	end_refresh			;* no update for non-bios

	mov	dx,[di].posCurs
	mov	ah,2
	int	10h				;* SetCursorPosition
end_refresh:

cEnd	DoneUpdateCsd
;*****************************************************************************
endif	;* DoneUpdateCsd
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\scr5data.inc ===
;*
;*	CW : Character Windows
;*
;*	scr5.inc : screen driver data info (OS/2)


;*****************************************************************************
;*	* Structure describing Vio Modes
DM	STRUC
	fvmReqAdapDm	DB	?		;* hardware requirements
	fvmReqDispDm	DB	?
						;*  LO == adapter, HI == monitor
	finstDm		DW	?		;* flags
	coMacDm		DB	?		;* coMac

	;* font info
	dxCharDm	DB	?
	dyCharDm	DB	?
	dyBaseDm	DB	?
	ifontDm		DB	?

	mdDm		DB	size MD dup (?)	;* mode data
	psVideoDm	DW	?
	vparmCursOnDm	DW	?		;* cursor on param (INT 10/#1)
DM	ENDS

fvmRequired	EQU	[word ptr fvmReqAdapDm]	;* fvmReqAdap & Disp
axMacDm		EQU	[byte ptr mdDm + 4]	;* really a word in mdDm
ayMacDm		EQU	[byte ptr mdDm + 6]	;* really a word in mdDm
;psVideoDm	EQU	[word ptr 0]		;* junk, not used

cbDmMin	EQU	size DM

;*****************************************************************************

SDDATA2	STRUC		;* Screen driver data (0 at driver load)

	;* filler for SDDATA data
	DB	(SIZE SDDATA) DUP (?)

	fUpdating	DB	0		;* between prep and doneupdate
			DB	0		;* align

	atrCurOn	DW	0		;* cursor on parameter
	offMin		DW	0		;* buffer update min
	offMac		DW	0		;* buffer update mac
	curType		DB	cbCtMin dup (?)
						;* cursor parms
	SEG_lpbVideo	DW	0		;* video segment
SDDATA2	ENDS

	Assert		<NOT ((SIZE SDDATA2) AND 1)>

cbDataCsd	EQU	(size SDDATA2)

IFDEF DUALOS2
Assert	<SIZE SDDATA2 GE SIZE SDDATA>
ENDIF ;DUALOS2

;*****************************************************************************

	include csd_fvm.inc

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\scr5.asm ===
;*
;*	CW : Character Windows
;*
;*	scr5g.asm : OS/2 text+graphcis text installable screen driver
;*		included in vio.asm

	.286p
 
;*****************************************************************************

;*	* Display modes table (see scr5data.inc for DM2 and VM structures)

rgdm:

;* #0 text mode 0, monochrone adapter

	DB	fvmMDA					;* fvmRequired
	DB	fvmMD					;* fvmRequired
	DW	finstText OR finstMonochrome		;* flags
	DB	2					;* coMac
	DB	9, 14, 0, 0				;* font info
	MD	<12,00000000b,0,80,25,720,350>		;* mode data
	DW	1					;* video segment
	DW	0607H					;* cursor

	Assert	<($-rgdm) EQ SIZE DM>

;* #1 text mode 2, CGA adapter

	DB	fvmCGA					;* fvmRequired
	DB	fvmCD OR fvmECD				;* fvmRequired
	DW	finstText				;* flags
	DB	16					;* coMac
	DB	8, 8, 0, 0				;* font info
	MD	<12,00000101b,4,80,25,640,200>		;* mode data
	DW	1
	DW	0607H					;* cursor

;* #2 text mode 14, EGA adapter, ECD or CD

	DB	fvmEGA					;* fvmRequired
	DB	fvmCD OR fvmECD				;* fvmRequired
	DW	finstText				;* flags
	DB	16					;* coMac
	DB	8, 8, 0, 0				;* font info
	MD	<12,00000001b,4,80,25,640,200>		;* mode data
	DW	1
	DW	0607H				;* cursor

;* #3 text mode 7, EGA adapter, 25 lines

	DB	fvmEGA					;* fvmRequired
	DB	fvmECD					;* fvmRequired
	DW	finstText				;* flags
	DB	16					;* coMac
	DB	8, 14, 0, 0				;* font info
	MD	<12,00000001b,4,80,25,640,350>		;* mode data
	DW	1
	DW	0C0DH					;* cursor

;* #4 text mode 7, EGA/VGA adapter, 43 lines

	DB	fvmEGA or fvmVGA			;* fvmRequired
	DB	fvmECD					;* fvmRequired
	DW	finstText				;* flags
	DB	16					;* coMac
	DB	8, 8, 0, 0				;* font info
	MD	<12,00000001b,4,80,43,640,350>		;* mode data
	DW	1
	DW	0607H					;* cursor

;* #5 text mode 7, PS2, 25 lines

	DB	fvmVGA					;* fvmRequired
	DB	fvmECD					;* fvmRequired
	DW	finstText				;* flags
	DB	16					;* coMac
	DB	8, 16, 0, 0				;* font info
	MD	<12,00000001b,4,80,25,720,400>		;* mode data
	DW	1
	DW	0E0FH					;* cursor

;* #6 text mode 7, PS2, 50 lines

	DB	fvmVGA			;* fvmRequired
	DB	fvmECD					;* fvmRequired
	DW	finstText				;* flags
	DB	16					;* coMac
	DB	8, 8, 0, 0				;* font info
	MD	<12,00000001b,4,80,50,720,400>		;* mode data
	DW	1
	DW	0607H					;* cursor

IFDEF GRAPHICSTEXT

;'''''''''''''''
; Graphics Text
;,,,,,,,,,,,,,,,

;* OS/2 protect mode does not support a mouse under graphics (finstDisableMouse)

;* #7 graphics text mode, EGA adapter, 25 lines

	DB	fvmEGA					;* fvmRequired
	DB	fvmECD					;* fvmRequired
	DW	finstGraphics OR finstFont OR finstDisableMouse
							;* flags
	DB	16					;* coMac
	DB	8, 14, 0, 0				;* font info
	MD	<12,00000011b,4,80,25,640,350>		;* mode data
	DW	0
	DW	0C0DH					;* cursor

;* #8 graphics text mode, EGA adapter, 43 lines

	DB	fvmEGA					;* fvmRequired
	DB	fvmECD					;* fvmRequired
	DW	finstGraphics OR finstFont OR finstDisableMouse
							;* flags
	DB	16					;* coMac
	DB	8, 8, 0, 0				;* font info
	MD	<12,00000011b,4,80,43,640,350>		;* mode data
	DW	0
	DW	0607H					;* cursor

;* #9 graphics text mode, VGA, 30 lines

	DB	fvmVGA					;* fvmRequired
	DB	fvmECD					;* fvmRequired
	DW	finstGraphics OR finstFont OR finstDisableMouse
							;* flags
	DB	16					;* coMac
	DB	8, 16, 0, 0				;* font info
	MD	<12,00000011b,4,80,30,640,480>		;* mode data
	DW	0					
	DW	0E0FH					;* cursor

;* #10 graphics text mode, VGA adapter, 60 lines

	DB	fvmVGA					;* fvmRequired
	DB	fvmECD					;* fvmRequired
	DW	finstGraphics OR finstFont OR finstDisableMouse
							;* flags
	DB	16					;* coMac
	DB	8, 8, 0, 0				;* font info
	MD	<12,00000011b,4,80,60,640,480>		;* mode data
	DW	0
	DW	0607H					;* cursor

ENDIF	;GRAPHICSTEXT

cdmMax	equ	($ - rgdm) / (cbDmMin)		;* # of modes


mpadapfvm:
	DB	fvmMDA,fvmCGA,fvmEGA,fvmVGA
pfvmMaxAdap	EQU	$

mpdispfvm:
	DB	fvmMD,fvmCD,fvmECD
pfvmMaxDisp	EQU	$


;*****************************************************************************

NonStandard 	FvmGetCur
NonStandard	ImodeGuessCurrentCsd
NonStandard	FInitCsd
NonStandard	MoveHwCursCsd
NonStandard	PrepUpdateCsd
NonStandard	DoUpdateCsd
NonStandard	DoneUpdateCsd
NonStandard 	FGetColorPaletteCsd
NonStandard 	SetColorPaletteCsd
NonStandard 	FQueryInftCsd
NonStandard 	CoiCovFromFvm
NonStandard 	GetPFonts
NonStandard 	GetCharMapCsd

;*****************************************************************************


;********** FvmGetCur **********
;*	entry:	DS:DI => driver data
;*	* if first time called, identify the current screen and set fvmCur
;*	*  subsequent calls will return fvmCur
;*	*  After this call: fvmCur will be initialized
;*	exit:	AL == fvm for current adapter (0 => no supported screen found)
;*		AH == fvm for current monitor

cProc	FvmGetCur, <NEAR, PUBLIC, ATOMIC>
    localV	cdT,cbCdMin
cBegin	FvmGetCur

	mov	bx,pinos			;* prep for Os2Call

	AssertEQ di,OFF_lpwDataCsd
	mov	al,[di].fvmCurAdap
	mov	ah,[di].fvmCurDisp
	or	ax,ax
	jz	@F
	jmp	fgc_end
@@:	
	lea	si,cdT
	mov	cdT.cbCd,10
	PushArg	<0,ss,si,hvioCur>
	Os2Call	VioGetConfig
	or	ax,ax
	jz	@F
	xor	ax,ax				;* no hardware available !?
	jmp	short fgc_end
@@:
	mov	bx,drvOffset mpadapfvm
	add	bx,cdT.adapCd
	cmp	bx,drvOffset pfvmMaxAdap
	mov	al,fvmEGA			;* default if strange OS
	mov	ah,cs:[bx]
	jae	@F
	mov	al,cs:[bx]
@@:
	mov	bx,drvOffset mpdispfvm
	add	bx,cdT.dispCd
	cmp	bx,drvOffset pfvmMaxDisp
	mov	ah,fvmECD			;* default if strange OS
	jae	@F
	mov	ah,cs:[bx]
@@:
	mov	[di].fvmCurAdap,al
	mov	[di].fvmCurDisp,ah

fgc_end: ;* ax = fvm

cEnd	FvmGetCur



;********** ImodeGuessCurrentCsd **********
;*	entry:
;*	* Get information about current mode
;*	exit:	AX == current mode or imodeUnknown

cProc	ImodeGuessCurrentCsd, <FAR, PUBLIC, ATOMIC>, <ds,si,di>
    localW	fvm
    localV	mdT,cbMdMin
cBegin	ImodeGuessCurrentCsd

	mov	bx,pinos			;* prep for Os2Call

	mov	mdT.cbMd,cbMdMin
	lea	ax,mdT
	PushArg	<ss,ax,hvioCur>
	Os2Call	VioGetMode
	or	ax,ax
	jz	@F
imgcc_unknown:
	mov	ax,imodeUnknown
	jmp	short imgcc_end
@@:

;*	* Determine adapter type

	mov	di,OFF_lpwDataCsd
	call	FvmGetCur
	mov	fvm,ax

;*	* Search rgdm for appropriate imode

	push	cs
	pop	es
	mov	bx,drvOffset rgdm
	mov	dx,cdmMax
	xor	ax,ax
	
imgcc_search:
	lea	si,mdT
	mov	di,bx
	add	di,mdDm
	mov	cx,cbMdMin
	repz	cmpsb
	jcxz	@F
	jmp	short imgc_next
@@:
	push	ax				;* modes match, check fvm
	mov	ax,fvm
	test	al,cs:[bx].fvmReqAdapDm
	jz	@F				;* not this one but need pop
	test	ah,cs:[bx].fvmReqDispDm
@@:
	pop	ax
	jnz	short imgcc_end			;* found mode
imgc_next:
	add	bx,cbDmMin
	inc	ax
	dec	dx
	jg	imgcc_search

;*	* mode not present

	mov	ax,imodeUnknown

imgcc_end:

cEnd	ImodeGuessCurrentCsd



;********** FInitCsd **********
;*	entry:
;*		pinch = near pointer to INCH structure to fill
;*	* Initialize the screen to the given mode
;*	exit:	AX != 0 if ok

cProc	FInitCsd, <FAR, PUBLIC, ATOMIC>, <ds,di,si>
    parmDP pinstInit
    parmDP pinch
    localD lpwPrim
    localW cbLVB
    localV mdT,cbMdMin
IFDEF	GRAPHICSTEXT
    localV fiT,cbFiMin
    localV pbT,cbPbMin
ENDIF	;GRAPHICSTEXT
cBegin	FInitCsd
	
	mov	di,OFF_lpwDataCsd		;* Data in data segment
	mov	mdT.cbMd,cbMdMin

;*	* set mode
	mov	bx,pinstInit			; add
	mov	[di].pinstDrv,bx
	mov	[di].fupdating,0
	mov	si,[bx].pdmInst			;* CS:SI => DM info

;*	* copy mode info into driver globals
	mov	ax,cs:[si].vparmCursOnDm
	mov	[di].vparmCursOn,ax
	mov	[di].vparmCursSize,ax
	mov	bx,pinos

;IFDEF DEBUG
	lea	ax,mdT
	PushArg	<ss,ax,hvioCur>
	Os2Call	VioGetMode
;ENDIF
	test	mdT.typeMd,02H			;graphics mode enable ?
	jnz	@F
	test	cs:[si].finstDm,finstGraphics	;text to graphics mode ? 
	jz	@F
; Need to clean up text buffer before switching into graphics mode
	push	si
	push	0	; blank cell
	mov	si,sp
	mov	bx,pinos
	PushArg	<0,0,-1,-1,-1,ss,si,hvioCur>
	Os2Call	VioScrollUp
	pop	ax	; remove cell
	pop	si
@@:
	lea	ax,[si].mdDm
	PushArg	<cs,ax,hvioCur>
	Os2Call	VioSetMode
	or	ax,ax
	jnz	fic_vioerr

IFDEF	GRAPHICSTEXT
	test	cs:[si].finstDm,finstGraphics
	jz	@F
	jmp	InitGraf			;* go to graphics modes
@@:
ENDIF	;GRAPHICSTEXT

	mov	dx,cs:[si].mdDm.axMacMd
	mov	ax,cs:[si].mdDm.ayMacMd
	mul	dl
	shl	ax,1
	mov	cbLVB,ax			;buffer length (bytes)
	lea	si,lpwPrim
	lea	ax,cbLVB
	PushArg	<ss,si,ss,ax,hvioCur>
	Os2Call	VioGetBuf
	or	ax,ax
	jnz	fic_vioerr

;*	* primary buffer must start at offset 0
	les	ax,lpwPrim
	or	ax,ax
	jnz	fic_vioerr

	mov	si,pinstInit
	mov	[si].psPrimInst,es		;* point to primary buffer

	lea	ax,[di].curType
	PushArg	<ds,ax,hvioCur>
	Os2Call	VioGetCurType
	or	ax,ax
	jnz	fic_vioerr

	mov	ax,[di].curType.atrCt		;* cursor is on after SetMode
	mov	[di].atrCurOn,ax

;*	* Clear the screen
	push	0	; blank cell
	mov	si,sp
	mov	bx,pinos
	PushArg	<0,0,-1,-1,-1,ss,si,hvioCur>
	Os2Call	VioScrollUp
	pop	ax	; remove cell
	jmp	short set_text_mode

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
fic_vioerr:
	xor	ax,ax
	jmp	fic_end
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

set_text_mode:
;*	* default (IBM) INCH array is ok

;*	* make a local for the requestblock to VioSetState, init and call

	sub	sp,6			; allocate temp
;!!! REVIEW     ^^^^
	mov	si,sp
	mov	word ptr [si],6		; length
	mov	word ptr [si+2],2	; set blink/background intensity
	mov	word ptr [si+4],1	; enable high intensity background
	PushArg	<ds,si,hvioCur>
	Os2Call	VioSetState
	add	sp,6			; remove temp
;!!! REVIEW     ^^^^

IFDEF	GRAPHICSTEXT
	jmp	finitdone

InitGraf:
	;;;REVIEW: load font should be taken care by FQueryInft
	mov	fiT.cbFi,cbFiMin
	mov	fiT.typeFi,1		;get rom font
	mov	dl,cs:[si].dxCharDm	;== [di].InftInst.dxCharInft
	xor	dh,dh
	mov	fiT.axCellFi,dx
	mov	dl,cs:[si].dyCharDm	;== [di].InftInst.dyCharInft
	xor	dh,dh
	mov	fiT.ayCellFi,dx
	mov	[di].ayBox,dx
	mov	word ptr fiT.pbDataFi,0
	lea	si,fiT			;bios data
	mov	word ptr ss:[si+2].pbDataFi,0
	mov	fiT.cbDataFi,dx
	PushArg	<ss,si,hvioCur>
	Os2Call	VioGetFont		;get font table
	lea	si,fiT			
	mov	ax,word ptr ss:[si].pbDataFi	;load font pointers
	mov	[di].OFF_lpbFont,ax
	mov	ax,word ptr ss:[si+2].pbDataFi
	mov	[di].SEG_lpbFont,ax

	lea	di,pbT				;get video buffer address
	mov	word ptr ss:[di].pBufPb,0
	mov	word ptr ss:[di+2].pBufPb,0Ah
	mov	word ptr ss:[di].cbPb,6D60h	;* 640 * 350 / 8 bytes (EGA)
 	mov	word ptr ss:[di+2].cbPb,0

	mov	si,OFF_lpwDataCsd		;* Data in data segment
	test	[si].fvmCurAdap,fvmVGA or fvmMCGA
	jz	@F
	mov	word ptr ss:[di].cbPb,9600h	;* 640 * 480 / 8 bytes (PS2)
@@:
	test	[si].fvmCurAdap,fvmCGA
	jz	@F
	mov	word ptr ss:[di].pBufPb,8000h
	mov	word ptr ss:[di+2].pBufPb,0Bh
	mov	word ptr ss:[di].cbPb,3E80h	;* 640 * 200 / 8 bytes (CGA)
@@:
	PushArg	<ss,di,hvioCur>
	Os2Call	VioGetPhysBuf
	mov	ax,pbT.sel0Pb
	mov	di,OFF_lpwDataCsd		;* Data in data segment
	mov	[di].SEG_lpbVideo,ax
						; Clear the bit planes 
	mov	es,ax
	xor	ax, ax
	mov	di, ax
	mov	cx, word ptr pbT.cbPb 		;cx = bits to clean
	cmp	cx,3E80h
	jne	@F
	shr	cx,1				;CGA use memory interleave
@@:
	shr	cx,1				;cx/8/2 = words to clean
	push	cx
	rep	stosw
	pop	cx
	cmp	word ptr pbT.cbPb,3E80h
	jne	finitdone
	mov	di,2000h
	rep	stosw				;clear odd field
finitdone:
ENDIF	;GRAPHICSTEXT

	mov	ax,sp				;* success

fic_end:	; ax == return code

cEnd	FInitCsd




;********** MoveHwCursCsd **********
;*	entry:
;*		axCurs, ayCurs = new absolute cursor position
;*		fOn => whether on or off
;*	* move and enable/disable cursor
;*	* save position in global for drawing
;*	exit:	n/a

cProc	MoveHwCursCsd,<FAR, PUBLIC, ATOMIC>, <DI>
    parmB axCurs
    parmB ayCurs
    parmW fOn
IFDEF	GRAPHICSTEXT
    localB axCursor
    localB ayCursor
ENDIF	;GRAPHICSTEXT
cBegin	MoveHwCursCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment
	mov	bx,pinos

;*	* move cursor position

	xor	ah,ah
	mov	al,ayCurs
	push	ax
	mov	al,axCurs
	push	ax
	push	hvioCur
	Os2Call	VioSetCurPos

;*	* enable/disable

	mov	ax,atrCurOff			;* assume off (-1)
	mov	byte ptr [di].fCurs,0		;* graphics cursor 
	cmp	fOn,0
	je	setCursorOnOff

	mov	dx,[di].vparmCursSize
	cmp	fOn,1
	je	@F
	xor	dh,dh				;(fOn = 2) Set block cursor
@@:
	mov	[di].vparmCursOn,dx		;* update cursor size
IFDEF	GRAPHICSTEXT
	mov	bx,[di].pinstDrv
	test	ss:[bx].finstInst,finstGraphics	;graphics text 8x14
	jz	DrawCursDone

	mov	dx,[di].posCurs		;dl = axFirst
	mov	ayCursor,dh
	mov	axCursor,dl
	xor	cx,cx			;fRestoreDbcs
	mov	ah,cl
	mov	al,80
	mul	dh
	mov	dh,cl
	add	ax,dx			
	shl	ax,1			;ax = offFirst
	mov	dx,1
	cCall	<Near ptr DoUpdateCsd>, <ayCursor,axCursor,dx,ax,cx,cs>	;erase cursor
	xor	cx,cx
	mov	dh,ayCurs
	mov	dl,axCurs
	mov	[di].posCurs,dx		;update position
	mov	ah,cl
	mov	al,80
	mul	dh
	mov	dh,cl
	add	ax,dx
	shl	ax,1			;ax = offFirst
	mov	dx,1
	mov	byte ptr [di].fCurs,1		;* graphics cursor on
	cCall	<Near ptr DoUpdateCsd>, <ayCurs,axCurs,dx,ax,cx,cs>		;draw cursor

DrawCursDone:
ENDIF	;GRAPHCISTEXT
	mov	ax,[di].atrCurOn		;* turn on
setCursorOnOff:
	mov	[di].curType.atrCt,ax
	
	mov	bx,pinos
	lea	ax,[di].curType
	PushArg	<ds,ax,hvioCur>
	Os2Call	VioSetCurType

cEnd	MoveHwCursCsd



;*****************************************************************************
;* Update


;********** PrepUpdateCsd **********
;*	entry:
;*		ayLine = ay of line drawn
;*		axFirst = first character drawn
;*		dax = # of characters drawn
;*		offFirst = offset in primary buffer where started
;*		fRestoreDbcs = bool to tell us to restore double byte
;*			characters or not.
;*	* prepare for screen update
;*	* For KANJI -- erase any dangling 1/2 characters
;*	exit: n/a

cProc	PrepUpdateCsd,<FAR, PUBLIC, ATOMIC>, <DI>
    parmB ayLine
    parmB axFirst
    parmB dax			;* will never be 0
    parmW offFirst
    parmW fRestoreDbcs		;* => restore DBCS 1/2 characters
cBegin	PrepUpdateCsd

IFDEF KANJI
	Assert
ENDIF ;KANJI

	mov	di,OFF_lpwDataCsd

;*	* set offMac and offMin to initial values

	test	[di].fupdating,0ffh
	jnz	@F			; already updating, ignore this prep
	mov	ax,offFirst
	mov	[di].offMin,ax
	xor	bh,bh
	mov	bl,dax
	shl	bx,1
	add	ax,bx
	mov	[di].offMac,ax
	mov	[di].fupdating,1
@@:

cEnd	PrepUpdateCsd



;********** DoUpdateCsd **********
;*	entry:
;*		parameters just like PrepUpdateCsd
;*	* after primary buffer has been updated
;*	* For BIOS version -- send to screen
;*	* for Kanji -- parse for DBCS boundaries (OAX)
;*	exit: n/a

cProc	DoUpdateCsd,<FAR, PUBLIC, ATOMIC>, <DS, ES, DI, SI, BX>
    parmB ayLine
    parmB axFirst
    parmB dax			;* will never be 0
    parmW offFirst
    parmW fRestoreDbcs		;* => restore DBCS 1/2 characters
IFDEF	GRAPHICSTEXT
    localB axCurs
    localB axCurrent
    localB flastattr		;check repeat attribute
    localB curattr
    localW wTemp
    localV LocalChar,16		;storage of char bit map for ffont mode
ENDIF	;GRAPHICSTEXT
cBegin	DoUpdateCsd

	mov	di,OFF_lpwDataCsd
IFDEF	GRAPHICSTEXT
	mov	bx,[di].pinstDrv
	test	ss:[bx].finstInst,finstGraphics	;graphics text 8x14
	jnz	graf_update
ENDIF	;GRAPHICSTEXT
;*	* enlarge dirty section if necessary

	mov	ax,offFirst
	cmp	ax,[di].offMin
	jae	@F
	mov	[di].offMin,ax
@@:
	xor	bh,bh
	mov	bl,dax
	shl	bx,1
	add	ax,bx
	cmp	ax,[di].offMac
	jbe	@F
	mov	[di].offMac,ax
@@:

IFDEF	GRAPHICSTEXT
	jmp	done_graf_update

graf_update:
	mov	ax,[di].posCurs			;for cursor drawing
	mov	axCurs,-1
	mov	axCurrent,0
	cmp	byte ptr [di].fCurs,0		;cursor on ?
	je	NoCursUpdate

	cmp	ah,ayLine			;check if cursor on ayLine
	jne	NoCursUpdate

	cmp	al,axFirst			;check if cursor outside axFirst
	jb	NoCursUpdate

	mov	axCurs,al			;need to update cursor
	mov	al,axFirst
	mov	axCurrent,al
NoCursUpdate:	
	mov	si,ds:[bx].pdmInst		
	mov	ds,ds:[bx].psPrimInst		;* DS:SI => primary buffer

;*	* DS:SI => start character in primary buffer
;*	* SS:BX => INST info
;*	* SS:DI => Driver data

;***** Graphics Text ****
;*			*
;*			*

	mov	cx,ss:[di].ayBox
	test	ss:[di].fvmCurAdap,fvmCGA
	jz	notmode6a

	shr	cx,1			;memory interleave addressing

notmode6a:
	mov	si,dx			;save video mode dl
	xor	ax,ax			;calculate start of screen address
	mov	al,ayLine
	mul	cx
	mov	cx,80
	mul	cx
	xor	cx,cx
	mov	cl,axFirst
	add	ax,cx			;ax = ayLine x 80 x ayBox + axFirst
	mov	di,ax			;point to video buffer

	xor	cx,cx
	mov	cl,dax			;no. of char to be updated

	mov	dx,si
	mov	si,offFirst
;	cmp	dl,6			;CGA mode 6
;	jmp	out_next_char1

	jmp	notmode6b

;* CGA 640x200, mono, 80x25, 8x8 fonts
	
out_next_char1:
	lodsw				;load character+attribute
	push	cx
	mov	wTemp,di		;save di
	mov	di,OFF_lpwDataCsd	
	mov	cx,ss:[di].ayBox	;calculate character table address

	push	ds			;save pointer to primary buffer
	push 	si

	mov	si,ss:[di].OFF_lpbFont	;default
	mov	ds,ss:[di].SEG_lpbFont

	test	ss:[di].fvmCurAdap,fvmCGA
	jz	first128

	cmp	al,80h
	jb	first128
		     			;use extend font (128 - 255)
	mov	dx,cs
	mov	ds,dx
	mov	si,drvOffset rgbCGAExFont8x8	;see cga8x8.inc
	sub	al,80h
first128:
	mov	dx,ax			;save char + attribute
	xor	ah,ah
	mul	cl			
	add	si,ax				;ds:[si] -> char bit map

	mov	ax,ss
	mov	es,ax
	lea	di,LocalChar			;es:[di] -> local storage
	rep	movsb  				;copy char bit map into local area
	mov	di,OFF_lpwDataCsd		;restore points
	mov	cx,ss:[di].ayBox	
	mov	ds,ax
	lea	si,LocalChar
	cmp	ss:[bx].psSecInst,0		;is sec. buffer allocated ?
	je	notfont8

	test	ss:[bx].finstInst,finstFont	;ffont mode ?
	jz 	notfont8

	mov	al,dl			;save char
	pop	di	;si -> di
	push	di
	mov	es,ss:[bx].psSecInst		;es:[di] => ffont buffer
	mov	dl,es:[di-2]			;dx = ffont + attribute
	or	dl,dl				;normal ?
	jz	notfont8

	cmp	al,' ' 			;check spaces
	jne	notspace1
	
	test	dl,ffontUnderline or ffontDoubleUnderline or ffontStrikeThrough
	jz	notfont8

notspace1:
	cCall	ChrisPFont 
	mov	di,OFF_lpwDataCsd	;restore points
	mov	cx,ss:[di].ayBox	;restore points

notfont8:
	mov	al,axCurrent		;cursor position ?
	cmp	al,axCurs
	jne	CursOff1

	mov	di,OFF_lpwDataCsd	
	push	cx
	push	si
	mov	cx,ss:[di].vparmCursOn
	xchg	ch,cl
	xor	ch,ch
	add	si,cx
	mov	cx,ss:[di].vparmCursOn
	sub	cl,ch
	xor	ch,ch
outCurs1:				;display the cursor
	not	byte ptr [si]
	inc	si
	loop	outCurs1
	pop	si
	pop	cx

CursOff1:
	mov	ax,0B800h			;CGA video segment
	mov	es,ax

	mov	ax,1FFFh
	mov	dx,79-2000h
	mov	di,wTemp			;restore di
	test	di,2000h
	jz	out_one_byte

	xchg	ax,dx 			;exchange inc if 1st pixel lies in
		      			;odd interleave 
out_one_byte:				;output the character
	movsb
	add	di,ax
	xchg	ax,dx
	loop	out_one_byte

	mov	di,wTemp
	inc	di			;next char
	inc	axCurrent		;bump update position
	pop	si
	pop	ds
	pop	cx			;restore dax
	dec	cx
	jz	out_done1
	jmp	out_next_char1

out_done1:
	jmp	done_graf_update	;done


;******* EGA/MCGA/VGA ********
;*
;*

notmode6b:				
	mov	flastattr,0		;initialize with black:black

out_next_char:
	lodsw				;load character+attribute
	mov	curattr,ah
	push	cx			;save dax
	push	ds			;save pointer to primary buffer
	push 	si
	mov	dx,ax			;save char
	mov	wTemp,di  		;save di
	mov	di,OFF_lpwDataCsd	;load cx with points
	mov	cx,ss:[di].ayBox	
	xor	ah,ah
	mul	cl			;ax = character table offset
	
	mov	si,ss:[di].OFF_lpbFont
	mov	ds,ss:[di].SEG_lpbFont
; REVIEW: use lines below when FQueryInft is ready
;	mov	si,ss:[bx].inftInst.OFF_lpbFontLower128Inft
;	mov	ds,ss:[bx].inftInst.SEG_lpbFontLower128Inft
	add	si,ax			;ds:[si] -> char bit map

	mov	ax,ss
	mov	es,ax
	lea	di,LocalChar		;es:[di] -> local storage
	rep	movsb	   		;copy bitmap to local area
	mov	di,OFF_lpwDataCsd	;restore points
	mov	cx,ss:[di].ayBox	
	mov	ds,ax
	lea	si,LocalChar

	cmp	ss:[bx].psSecInst,0		;is sec. buffer allocated ?
	je	@F

	test	ss:[bx].finstInst,finstFont	;graphics text 8x14, 8x16
	jz	@F

	mov	ax,dx
	pop	di	;si -> di
	push	di
	mov	es,ss:[bx].psSecInst	;* es:[di] => ffont buffer
	mov	dx,es:[di-2]		;dx = ffont + attribute
	or	dl,dl			;zero ffont
	jz 	@F

	cmp	al,' ' 			;check spaces
	jne	notspace2
	
	test	dl,ffontUnderline or ffontDoubleUnderline or ffontStrikeThrough
	jnz 	notspace2
@@:
	jmp 	notfont14or16

notspace2:
	cCall	ChrisPFont
	mov	di,OFF_lpwDataCsd	;restore points
	mov	cx,ss:[di].ayBox	

notfont14or16:
	mov	al,axCurrent
	cmp	al,axCurs
	jne	CursOff2

	mov	di,OFF_lpwDataCsd	
	push	cx
	push	si
	mov	cx,ss:[di].vparmCursOn
	xchg	ch,cl
	xor	ch,ch
	add	si,cx
	mov	cx,ss:[di].vparmCursOn
	sub	cl,ch
	xor	ch,ch
outCurs2:
	not	byte ptr [si]
	inc	si
	loop	outCurs2
	pop	si
	pop	cx

CursOff2:
	mov	di,OFF_lpwDataCsd	
	test	ss:[di].fvmCurAdap,fvmEGA or fvmVGA	;Test for EGA or VGA
	jz	same_attr

	test	ss:[bx].finstInst,finstMonochrome	;Test for mono
	jnz	same_attr

	mov	ah,curattr
	cmp	ah,flastattr		;same attr ?
	jne	set_attribute

same_attr:
	jmp	same_attribute

set_attribute:
	mov	flastattr,ah
	mov	cl,ah
	push	bx
	mov	di,wTemp		;restore di
	mov	bx,pinos
	PushArg	<0,0,3CEh,3CFh>		;access EGA graphics ctrl chip
	Os2Call	DosPortAccess
	mov	bx,pinos
	call	[bx].lpfnCwBeginIOInos

	mov	bh,cl			;free ax for i/o

	mov	dx,3CEh			;Graphics control registers port
	mov	ax,0F01h		;set Enable register
	out 	dx,ax

	mov	ax,0003			;data rotate
	out	dx,ax

	mov	bl,bh			;bl = foreground
	mov	cl,4
	shr	bh,cl			;bh = background value

	xor	al,al			;load S/R with bkgd
	mov	ah,bh
	out 	dx,ax

	mov	cx,di
	mov	di,OFF_lpwDataCsd	;load cx with points
	mov	ax,[di].SEG_lpbVideo	;set video segment
	mov	es,ax
	mov	al,0FFh
	mov	di,cx
	mov	es:[di],al
	mov	al,es:[di]		;load bit plane latches

	xor	ax,ax			;clear S/R (default)
	out	dx,ax

	mov	ah,bh			;ah = bkgd xor fgd
	xor	ah,bl

	not	ah
	and 	ah,0Fh
	mov	al,1			;load En S/R
	out	dx,ax

	mov	ax,1803h		;set data rot reg (cpu xor latches)
	out	dx,ax

	mov	bx,pinos
	call	[bx].lpfnCwEndIOInos
	PushArg	<0,1,3CEh,3CFh>		;release EGA graphics ctrl chip
	Os2Call	DosPortAccess
	pop	bx

same_attribute:
;;;* output the character
	mov	di,OFF_lpwDataCsd	
	mov	ax,ss:[di].SEG_lpbVideo	;set video segment
	mov	cx,ss:[di].ayBox	
	mov	es,ax
	mov	ax,04Fh			;column(80) - 1
	mov	di,wTemp		;restore di

out_char_map:
	movsb
	add	di,ax			;go to next scan line (+80-1)
	loop	out_char_map
	
	mov	di,wTemp		;restore di
	inc	di			;next char
	inc	axCurrent		;bump update position
	pop	si
	pop	ds
	pop	cx			;restore dax
	dec 	cx
	jz	out_done2
	jmp	out_next_char

out_done2:
	mov	di,OFF_lpwDataCsd	;ss:[di] => drive data
	test	ss:[di].fvmCurAdap,fvmMCGA	;Test for MCGA
	jnz	done_graf_update
			  		;EGA and VGA only
			 		;restore default Graphics control registers
	mov	bx,ss
	mov	ds,bx
	mov	bx,pinos
	PushArg	<0,0,3CEh,3CFh>		;access EGA graphics ctrl chip
	Os2Call	DosPortAccess
	mov	bx,pinos
	call	[bx].lpfnCwBeginIOInos
	mov	dx,3CEh			;restore Graphics control registers
	mov	ax,0003			;data rotate
	out	dx,ax
	mov	ax,0001			;zero En S/R
	out 	dx,ax
	mov	bx,pinos
	mov	bx,pinos
	call	[bx].lpfnCwEndIOInos
	PushArg	<0,1,3CEh,3CFh>		;release EGA graphics ctrl chip
	Os2Call	DosPortAccess

done_graf_update:

ENDIF	;GRAPHICSTEXT

IFDEF KANJI
;*	* For the OAX, we parse what we have printed and set the attribute
;*	*  byte to 0 for the second byte of double byte characters.
	cmp	fRestoreDbcs,0
	jne	end_update
	mov	si,offFirst
	xor	cx,cx
	mov	cl,dax				;* # of bytes
loop_parse_dbcs:
	lodsw					;* get char(al) + attribute(ah)
	JmpNotDbc parse_single
;*	* second byte follows
	inc	si				;* skip 2nd char
	mov	byte ptr ds:[si],0		;* clear attrib
	inc	si
	AssertNE cx,1				;* must be enough
	dec	cx
parse_single:
	loop	loop_parse_dbcs

ENDIF ;KANJI

end_update:

cEnd	DoUpdateCsd





;********** DoneUpdateCsd **********
;*	entry: n/a
;*	* Update complete
;*	exit: n/a

cProc	DoneUpdateCsd,<FAR, PUBLIC, ATOMIC>,<DI>
cBegin	DoneUpdateCsd

;*	* restore old cursor position

	mov	di,OFF_lpwDataCsd

	mov	ax,[di].offMin
	mov	cx,[di].offMac
	sub	cx,ax
	mov	bx,pinos
	PushArg	<ax,cx,hvioCur>
	Os2Call	VioShowBuf
	mov	[di].fupdating,0

cEnd	DoneUpdateCsd


;********** FQueryInftCsd **********	(assume called after FQueryInst)
;*	entry:	pinft, ifont
;*	* get font info
;*	exit:	AX = 0 => no more fonts
;*		ax != 0	Success,filled INFT
;*		trash bx,dx

cProc	FQueryInftCsd, <FAR, PUBLIC, ATOMIC>, <si, di>
    parmDP pinft
    parmW  ifont
cBegin	FQueryInftCsd

	mov	si,ifont
	cmp	si,cdmMax
	jb	@F
	jmp	ExitFQueryInft			; no more fonts
@@:
	mov	ax,SIZE DM
	mul	si
	mov	si,ax
	add	si,drvOffset rgdm		;* CS:SI => INST info
	mov	di,pinft			;* ds:di => INFT
	Assert	<dyCharDm EQ dxCharDm+1>
	Assert	<dyCharInft EQ dxCharInft+1>
	mov	dx,word ptr cs:[si].dxCharDm
	mov	wo ds:[di].dxCharInft,dx
					;* move both dxChar and dyChar
	mov	dl,cs:[si].dyBaseDm
	mov	ds:[di].dyBaseLineInft,dl
	
	mov	ax,ifont
	mov	ds:[di].ifontInft,al		;font index

	mov	ax,sp

ExitFQueryInft:
cEnd	FQueryInftCsd


;*****************************************************************************



;********** FGetColorPaletteCsd **********
;*	* CSD entry point (see documentation for interface)

cProc	FGetColorPaletteCsd, <FAR, PUBLIC, ATOMIC>,<DI>
    parmW	coGet
    parmDP	pcovGet
    parmDP	pcoiGet
    localV	prT,cbPr1
cBegin	FGetColorPaletteCsd

	mov	bx,pinos

	lea	di,prT
	mov	prT.cbPr,cbPr1
	xor	ax,ax
	mov	prT.rtPr,ax
	mov	ax,coGet
	test	ax,0fff0h			;* check co range (0-15)
	jnz	fgcp_fail
	mov	cx,pcoiGet
	jcxz	fgcp_cov
fgcp_fail:
	xor	ax,ax
	jmp	short fgcp_end
fgcp_cov:
	mov	prT.coFirstPr,ax
	PushArg	<ss,di,hvioCur>
	Os2Call	VioGetState
	or	ax,ax
	jnz	fgcp_fail
	mov	bx,pcovGet
	mov	ax,prT.rgcovPr
	mov	[bx],ax
	mov	ax,sp				;* success
fgcp_end:

cEnd	FGetColorPaletteCsd



;********** SetColorPaletteCsd **********
;*	* CSD entry point (see documentation for interface)

cProc	SetColorPaletteCsd, <FAR, PUBLIC, ATOMIC>,<DI>
    parmW	coSet
    parmW	covSet
    parmDP	pcoiSet
    localV	prT,cbPr1
cBegin	SetColorPaletteCsd

	mov	bx,pinos

	lea	di,prT
	mov	prT.cbPr,cbPr1
	xor	ax,ax
	mov	prT.rtPr,ax
	mov	ax,coSet
	test	ax,0fff0h			;* check co range (0-15)
	jnz	@F
	mov	prT.coFirstPr,ax
	mov	ax,covSet
	mov	prT.rgcovPr,ax
	PushArg	<ss,di,hvioCur>
	Os2Call	VioSetState
@@:

cEnd	SetColorPaletteCsd





;********** CoiCovFromFvm **********
;*	entry:	AL = fvm
;*	* Produce coiMac, covMac for fvm (AL)
;*	exit:	AL = fvm, AH = covMac, DX = coiMac

cProc	CoiCovFromFvm, <NEAR, PUBLIC, ATOMIC>
cBegin	CoiCovFromFvm

	xor	ah,ah
	xor	dx,dx
	test	al,fvmMDA		;* monochrome coiMac = 0, covMac = 0
	jnz	@F
	test	al,fvmCGA		;* CGA coiMac = 0, covMac = 0
	jnz	@F
	mov	ah,64			;* EGA/VGA coiMac = 0, covMac = 64
@@:

cEnd	CoiCovFromFvm



;********** GetPFonts **********
;*	entry:	AL = ifont
;*	* get font information
;*	exit:	DX:AX = lpbFont for first 128 characters
;*		CX:BX = lpbFont for last 128 characters

cProc	GetPFonts, <NEAR, PUBLIC, ATOMIC>
cBegin	GetPFonts

	xor	ax,ax
	xor	dx,dx
	xor	cx,cx
	xor	bx,bx

IFDEF REVIEW
	.... implement this
ENDIF ;REVIEW

cEnd	GetPFonts


;********** GetCharMapCsd **********
;*	entry:	pinft, ch, pbitmap
;*	* get character bit map

cProc	GetCharMapCsd, <FAR, ATOMIC, PUBLIC>
    parmDP pinft
    parmB  char
    parmDP pbitmap    
cBegin	GetCharMapCsd

cEnd	GetCharMapCsd

;*****************************************************************************

	include	cga8x8.inc

IFDEF	GRAPHICSTEXT
;*****************************************************************************

	CPF814 = 1
	CPF816 = 1
	include cpfont.asm

;*****************************************************************************
ENDIF	;GRAPHICSTEXT

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\t3100.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	t3100.asm : Toshiba 3100 (LCD) CSD
;*
;*****************************************************************************

	include	csd_head.inc
	include	csd_data.inc

;*****************************************************************************

	include	csd_code.asm			;* first part of code

;*	* Display modes table
rgdm:

;* #0 - standard mono mode
	DB	0ffh				;* any
	DB	0ffh				;* any
	DB	3				;* mode
	DW	finstText or finstMonoChrome 	;* flags
	DB	80, 25				;* screen size
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0B800H				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved
	Assert	<($-rgdm) EQ SIZE DM>

;* #1 - 25 line Graphics text mode (mono)
	DB	0ffh				;* any
	DB	0ffh				;* any
	DB	74h				;* mode
	DW	finstGraphics OR finstFont OR finstMonoChrome or finstFastScroll	;* flags
	DB	80, 25				;* screen size
	DB	2				;* coMac
	DB	8, 16, 0, 0			;* INFT
	DW	0				;* video address
	DW	0E0FH				;* cursor
	DW	0				;* reserved

;* #2 - 50 line Graphics text mode (mono)
	DB	0ffh				;* any
	DB	0ffh				;* any
	DB	74h				;* mode
	DW	finstGraphics OR finstFont OR finstMonoChrome or finstFastScroll	;* flags
	DB	80, 50				;* screen size
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved

cdmMax	equ	($ - rgdm) / (size DM)		;* # of modes

segROM	equ	0F000H
T3100_Font_Off	EQU	0CA00H		; Offset in BIOS for 640X400 fonts

;*****************************************************************************
;*	* Special routines

NonStandard	FInitCsd

;*****************************************************************************


;********** FInitCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* Initialize the screen to the given mode
;*	exit:	AX != 0 if ok

cProc	FInitCsd, <FAR, PUBLIC, ATOMIC>, <DI>
    parmDP pinst
    parmDP pinch
    localB modeCur
cBegin	FInitCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment

;*	* save old mode
	cCall	ModeGetCur			;* al = mode, ah = ayMac
	mov	modeCur,al			;* current mode

	mov	bx,pinst
	cmp	ds:[bx].ayMacInst,ah		;* new = current rows ?
	je	@F				;* same resolution
	mov	modeCur,0			;* cause mode reset
@@:

;*	* set mode
	mov	bx,pinst
	mov	[di].pinstDrv,bx
	mov	bx,ds:[bx].pdmInst		;* CS:BX => DM info

;*	* copy mode info into driver globals
	mov	ax,cs:[bx].wExtraDm
	mov	[di].wExtra,ax
	mov	ax,cs:[bx].vparmCursOnDm
	mov	[di].vparmCursSize,ax
	mov	[di].vparmCursOn,ax

	xor	ah,ah				;* set mode
	mov	al,cs:[bx].modeDm
	cmp	al,modeCur
	je	@F				;* don't reset
	int	10h				;* set mode
@@:
	mov	ax,40H
	mov	es,ax
	mov	al,cs:[bx].ayMacDm
	dec	al				; rows - 1
	mov	byte ptr es:[0084H],al		;* update BIOS rows

	test	cs:[bx].finstDm,finstGraphics
	jz	InitText

	xor	ah,ah	
	mov	al,cs:[bx].dyCharDm
	mov	[di].ayBox,ax			;* points
	cmp	ax,8
	je	@F

	mov	[di].SEG_lpbFont,segROM		;8x16 font
	mov	[di].OFF_lpbFont,T3100_Font_Off
	jmp short font1

@@: 
	mov	[di].SEG_lpbFont,segROM		;8x8 font (lower 128)
	mov	[di].OFF_lpbFont,0FA6Eh
font1:	
	jmp	short InitDone

InitText:	
;*	* the INCH array already contains the standard Code Page 437
;*	*  character set, so it usually can be left the same.

;*	* Do other diddling
	cCall	DiddleBlinkBit

InitDone:
	mov	ax,sp				;* success
cEnd	FInitCsd

;*****************************************************************************

	T3100CSD = 1
	include	update2.asm

;*****************************************************************************

	include	csd_std.asm		;* standard init/term
	include	csd_ibm.asm		;* IBM specific routines

;*****************************************************************************

	include	csd_vram.asm		;* default procs for direct video I/O
	include	csd_save.asm		;* default screen save (none)

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************


	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\saveega.asm ===
;*
;*	CW : Character Windows
;*
;*	ega.asm : DOS3 TWIN compatible screen driver
;*
;*****************************************************************************

;*	* Special screen save
NonStandard	CbSizeVidsCsd
NonStandard	FSaveVidsCsd
NonStandard	FRestoreVidsCsd
NonStandard	SetVideoMode
NonStandard	SaveVidDataCsd
NonStandard	RestoreVidDataCsd
NonStandard	EnableVidsMonitorCsd

;********** CbSizeVidsCsd **********
;*	* CSD entry point (see documentation for interface)

cProc	CbSizeVidsCsd, <FAR, PUBLIC, ATOMIC>
cBegin	CbSizeVidsCsd

	mov	ax,SIZE EGA_VIDS
	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	test	[bx].fvmCurAdap, fvmEGA or fvmVGA or fvm64KEGA or fvmEGAM or fvmMCGA
	jnz	notCGAVids

	sub	ax,24				;for EGA palette settings
	jmp	short CbSizeExit
notCGAVids:
	test	[bx].fvmCurAdap, fvmMCGA or fvmVGA
	jz	CbSizeExit

	add	ax,255*3			;for PS2 palette settings
CbSizeExit:
	inc	ax				;get even cb
	and	ax,0FFFEh      
cEnd	CbSizeVidsCsd


;********** FSaveVidsCsd ********
;*	entry:	pvidsSave = near pointer to VIDS structure
;*		pinst = near pointer to INST for new mode
;*	* fill *pvidsSave with state of current screen mode (not screen data)
;*	exit:	AX != 0 if ok, == 0 if error

cProc	FSaveVidsCsd, <FAR, PUBLIC, ATOMIC>, <si, di>
    parmDP pvidsSave
    parmDP pinst
cBegin	FSaveVidsCsd

	mov	di,pvidsSave

	mov	ah,0Fh
	int	10h				;* GetMode and page
	and 	al,07Fh				; clear msb
	mov	[di].modeVids,al
	mov	[di].pageVids,bh

	mov	[di].fClearRegenVids,00H
				      
	mov	ax,SIZE EGA_VIDS - cbVidsMin	;default EGA
	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	test	[bx].fvmCurAdap, fvmEGA or fvmVGA or fvm64KEGA or fvmEGAM or fvmMCGA
	jnz	notFSCGA
	
	sub	ax,24			;EGA palette regs
	jmp	short notFSPS2
notFSCGA:
	test	[bx].fvmCurAdap, fvmMCGA or fvmVGA
	jz	notFSPS2

	add	ax,255*3		;DAC color regs
notFSPS2:
	inc	ax			;get even cb
	and	ax,0FFFEh      
	shr	ax,1
	mov	[di].cwExtraVids,ax

	mov	ah,3
	int	10h				;* GetCursorPos
	mov	[di].vparmCursorVids,cx

	mov	ax,ds
	mov	es,ax
	mov	dx,di
	lea	di,[di].rgwCursorPosVids	;* save cursor positions here

	push	ds
	xor	ax,ax
	mov	ds,ax
	mov	si,BIOS_cursor_posn		;* 8 Cursor positions in BIOS

	mov	cx,8
	rep movsw
	pop	ds
	mov	di,dx			; restore di

public saveCGAPal			;UNDONE - remove these two lines
saveCGAPal:				;UNDONE
	;
	; Assumes bCGABg is immediately before bCGAPal
	; and bCGABgVids is immediately before bCGAPalVids
	;
	.errnz	(bCGABgVids+1) - bCGAPalVids
	.errnz	(bCGABg+1) - bCGAPal
	mov	ax, word ptr cs:[bCGABg]
	mov	word ptr [di].bCGABgVids, ax

	mov	dl, [di].modeVids
	cmp	dl,40H			;Olivetti
	jz	@F

	test	[bx].fvmCurAdap, fvmCGA
	jz	skipCGA
@@:

;* for CGA only
	xor	ax,ax
	mov	es,ax
	mov	al, byte ptr es:[466H]
	mov	[di].ayOverScanVids, al
	mov	ax, 80*25	; Maybe we can get by just saving what we use (4k b).
	cmp	dl, 2
	je	save_not_graphics
	cmp	dl, 3
	je	save_not_graphics
	mov	ax, 8*1024	; Must mode switch (4,5,6) so must save all of regen(16k b)
	cmp	dl, 40H		; Is this an Olivetti graphics screen mode?
	jne	@F
	add	ax, ax		; Yes, there is twice as much memory to save
@@:

save_graphics:
	and	[di].fvidsVids,not fvidsChAttr	;graphics modes 
save_not_graphics:	;* ax = # of words to swap
	mov	[di].cwSwapVids,ax
	jmp	EgaSS_Exit

skipCGA:
	test	[bx].fvmCurAdap, fvmEGA or fvmVGA or fvm64KEGA or fvmEGAM or fvmMCGA
	jz	@F
	cCall	EgaSavePalette		;save palette regs
@@:	
	push	bp
	mov	ax,1130h		; get info
	xor	bx,bx
	xor	cx,cx
	int	10h
	pop	bp

	inc	dl			; dl = scan lines
	mov	[di].ayMacVids,dl	; rows
	mov	[di].ayPointsVids,cl	; cl = number of lines in char

	cmp	[di].modeVids,4		;check simple graphics
	jb	notmode4to6

	cmp	[di].modeVids,6
	ja	notmode4to6

	mov	ax,8*1024	; Must mode switch (4,5,6) so must save all of regen(16k b)
	mov	[di].cwSwapVids,ax
	and	[di].fvidsVids,not fvidsChAttr	;graphics modes 
	jmp	EgaSS_Exit

notmode4to6:
	mov	ax,80			;default 80 columns
	mov	si,pinst
	cmp	dl,[si].ayMacInst	;rows
	ja	AboveNewAy

	mov	dl,[si].ayMacInst	;assume going into text mode
AboveNewAy:
	mul	dl			;columns * rows
	mov	cl,[di].modeVids
	cmp	cl, 08H
	ja	EgaSS_Hard
	cmp	cl, 07H
	jb	NotHerc

; We are in mode 7 or 8 so we might have a Hercules card.
	push	ax			;Save cwSwap
	mov	ah,0efH
	mov	dl, -1
	int	10H
	pop	ax			;restore cwSwap
	inc	dl
	jz	NotHerc			;DL not changed by INT 10 unless herc.
	mov	ax,8*1024		;Must save 8k words for herc
					;We would only have to save 4K words
					;If it weren't for Compaq's stupid
					;BIOS which always clears 16K bytes
					;when switching into mode 7.
	mov	[di].fClearRegenVids,80H
NotHerc:
	mov	[di].cwSwapVids,ax	
	mov	[di].fvidsVids,fvidsChAttr	;Text modes 
	jmp	EgaSS_Exit

; *** Graphics Text ***
; Ok, we are in one of the difficult graphics modes.
; We must save cLines*80 words from bit plane 0 and the same from bit plane 1
; and we must save 4k words from bit plane 2 (because the character
; generator gets loaded into this area when we switch to alpha mode).

EgaSS_Hard:
	mov	[di].cwSwapVids,ax	
	and	[di].fvidsVids,not fvidsChAttr	;graphics modes 
	mov	ax, 2*1024			; MCGA uses 2k words
	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	test	[bx].fvmCurAdap, fvmMCGA
	jnz	EgaSS_Alloc

	mov	ax,[di].cwSwapVids		; ax == cLines*cColumns words
	shl	ax,1				; for bit plane 0 and 1
EgaSS_Alloc:
	add	ax, 4*1024		; Save 4k words of bit plane 2
	test	[bx].fvmCurAdap, fvm64KEGA
	jz	EgaSS_Exit

; More memory gets trashed by the BIOS doing a mode reset on a 64k Ega.
; Note: On a 64k Ega, the 4k words starting at 16k of bit plane 2 also get
;       trashed by the BIOS for some reason (so we gotta save that too).

	add	ax,4*1024

EgaSS_Exit:
	mov	[di].cwVidDataVids,ax
	mov	ax,sp				;* success

cEnd	FSaveVidsCsd


;********** EgaSavePalette ********
;*
;*	entry: ds:[di] => Vids

cProc EgaSavePalette,<NEAR,PUBLIC>,<SI,DI,ES>
cBegin EgaSavePalette

	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	mov	ax,ds
	mov	es,ax
	test	[bx].fvmCurAdap, fvmMCGA or fvmVGA 	;PS2 ?
	jz	@F

	lea	dx, [di].rgbPS2PaletteVids		
	mov	ax, 1017H			; Read block of Palette regs
	xor	bx,bx				;    start at reg 0
	mov	cx, 256				;    read 256 regs
	int	10H
@@:
	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	test	[bx].fvmCurAdap, fvmEGA or fvmVGA or fvm64KEGA or fvmEGAM
	jz	@F

	push	ds
	pop	es
	lea	di, [di].rgbEgaPaletteVids	;es:[di] -> buffer
	push	cs
	pop	ds
	mov	si, DrvOffset EGAPaletteMirror
	mov	cx,17				;16 palette + overscan regs
	rep	movsb
	push	ss
	pop	ds				;restore ds
@@:
cEnd EgaSavePalette


;********** FRestoreVidsCsd ********
;*	entry:	pvidsRestore = near pointer to VIDS structure
;*	* restore video state with data in *pvidsRestore (not screen data)
;*	exit:	AX != 0 if ok, == 0 if error

cProc	FRestoreVidsCsd, <FAR, PUBLIC, ATOMIC>, <si, di>
    parmDP pvidsRestore
cBegin	FRestoreVidsCsd

	mov	di,pvidsRestore
	mov	al, [di].modeVids
	cmp	al, 2
	je	EgaFRS_Text

	cmp	al, 3
	je	EgaFRS_Text

	cmp	al, 40H				;[==] Olivetti
	je	EgaFRS_SimpleGraphics		;[==]

	cmp	al, 8
	ja	EgaFRs_HardGraphics
	cmp	al, 7
	jae	EgaFRS_Text

EgaFRS_SimpleGraphics:			;mode 4,5 & 6
	cCall	SetVideoMode
	jmp	EgaFRS_Common

EgaFRS_Text:	; mode 2,3 and 7
ifndef	KANJI
	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	cmp	[bx].fBlinkEnable,0
	je	@F				;trash ax,dx

	mov	[bx].fBlinkEnable,0		;disable Blink
	cCall	DiddleBlinkbit
	jmp short RestoreBlink
@@:
	mov	[bx].fBlinkEnable,1		;enable Blink
	cCall	EnableBlinkbit
RestoreBlink:
endif	; !KANJI
	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	test	[bx].fvmCurAdap, fvmVGA 	;VGA ?
	jz	EgaFRs_SetScanLines_done

	mov	al,2			;default 400 lines
	cmp	[di].ayMacVids,43     	; 43 line mode
	jne	useDefaultLine

	dec	al			;set 350 scan line

useDefaultLine:
	mov	ah,12h			;set vertical scan line
	mov	bl,30h
	int	10h			;takes effect on next mode set

EgaFRs_SetScanLines_done:
	cCall	SetVideoMode
	or	ax,ax			;mode set ?
	jz	EgaFRS_Common
	cmp	[di].ayPointsVids,8	;8x8 font ?
	jne	EgaFRS_Common

	mov	ax,1112h
	mov	bh,8
	xor	bl,bl
	int	10h
	jmp	EgaFRS_Common

EgaFRS_HardGraphics:
	cCall	ClearRegen
	cCall	SetVideoMode
	cmp	[di].ayPointsVids, 8
	jne	EgaFRs_NoLoad8

	mov	ax,1123h
	xor	bh,bh
	mov	bl,[di].modeVids
	sub	bl,0dh
	mov	dl,cs:[GraphicsModeRows+bx]
	xor	bl,bl
	int	10h

EgaFRs_NoLoad8:

EgaFRs_Common:
	mov	al,[di].pageVids
	mov	ah,5
	int	10h				;* SetPage

	mov	dx,di
	xor	ax,ax
	mov	es,ax
	lea	si,[di].rgwCursorPosVids
	mov	di,BIOS_cursor_posn
	mov	cx,8
	rep movsw
	mov	di,dx

	mov	bl,[di].pageVids
	xor	bh,bh
	shl	bx,1
	mov	dx,[di+bx].rgwCursorPosVids	;* get cursor pos for this page
	shr	bx,1
	mov	bh,bl
	mov	ah,2
	int	10h				;* SetCursorPos

	mov	cx,[di].vparmCursorVids
	mov	ah,1
	int	10h				;* SetCursor

	cmp	[di].modeVids,40H		;Don't EgaRestore palette for
	je	@F				; Olivetti
	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	test	[bx].fvmCurAdap, fvmEGA or fvmVGA or fvm64KEGA or fvmEGAM or fvmMCGA
	jz	@F

	cCall	EgaRestorePalette
@@:
public restoreCGAPal				;UNDONE - remove
restoreCGAPal:					;UNDONE - remove

	push	bx
	mov	bl, [di].bCGAPalVids
	or	bl,bl
	js	@F				;* skip if negative
	mov	bh,1
	mov	ah,0BH
	int	10H				;* set color palette
@@:
	mov	bl, [di].bCGABgVids
	or	bl,bl
	js	@F				;* skip if negative
	xor	bh,bh
	mov	ah,0BH
	int	10H				;* set background color
@@:
	pop	bx

	test	[bx].fvmCurAdap, fvmCGA 		;CGA ?
	jz	@F

	xor	ax,ax
	mov	es,ax
	mov	al, [di].ayOverScanVids
	mov	byte ptr es:[466H],al
	mov	dx, 3d9H
	out	dx, al
@@:
	mov	ax,sp				;* success

cEnd	FRestoreVidsCsd


;********** EgaRestorePalette ********
;*
;*
cProc	EgaRestorePalette,<NEAR,PUBLIC>,<SI,DI,ES>
cBegin  EgaRestorePalette

	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	mov	ax,ds
	mov	es,ax
	test	[bx].fvmCurAdap, fvmMCGA or fvmVGA 	;PS2 ?
	jz	@F

	lea	dx, [di].rgbPS2PaletteVids		
	mov	ax, 1012H			; write block of Palette regs
	xor	bx,bx				;    start at reg 0
	mov	cx, 256				;    read 256 regs
	int	10H

@@:
	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	test	[bx].fvmCurAdap, fvmEGA or fvmVGA or fvm64KEGA or fvmEGAM
	jz	@F

	cmp	cs:[lpbBIOSINT10_Offset],0	;save check
	je	@F
	
	mov	ax,1002h
	lea	dx, [di].rgbEGAPaletteVids	;es:[dx] -> buffer
	int	10h
@@:	
cEnd	EgaRestorePalette


;***********************
cProc	EnableBlinkBit, <NEAR, ATOMIC, PUBLIC>, <DS>
cBegin	EnableBlinkBit

;*	* Diddle blink bit via BIOS call (or diddle CGA bit)

	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	test	[bx].fvmCurAdap, fvmCGA or fvmMDA
	jz	EBB_NotCGA

	xor	ax,ax
	mov	ds,ax
	mov	dx,ds:[BIOS_addr_6845]
	add	dx,PORT_mode
;*	* set the mode set flag
	or	byte ptr ds:[BIOS_crt_mode_set],20H
	mov	al,ds:[BIOS_crt_mode_set]
	out	dx,al				;* send to port

;*	* EGA etc has a BIOS call for this
EBB_NotCGA:
	mov	ax,1003H			;* set intensify/blink
	mov	bl,1				;* enable blink
	int	10h

cEnd	EnableBlinkBit


;********** SetVideoMode **********
;*	entry:	al = video mode
;*	* Set specified video mode
;*	exit:	trash ax,cx,es
;*	ax = 0 same mode,-1 mode set

cProc	SetVideoMode,<NEAR>,<es>
cBegin	SetVideoMode
	mov	ah,0Fh
	int	10h				;* GetMode
	and	al,7fh
	cmp	al,[di].modeVids
	jne	SVM_SetMode	    		;reset

;same mode, check rows		
	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	test	ss:[bx].fvmCurAdap, fvmCGA	;CGA only support 25 rows
	jnz	mode_already_set
	push	bp
	mov	ax,1130h		; get info
	xor	bx,bx
	xor	cx,cx
	int	10h
	pop	bp
	inc	dl			; dl = scan lines
	cmp	dl,[di].ayMacVids	; rows
	jne	SVM_SetMode
	jmp	mode_already_set

SVM_SetMode:
	mov	al,[di].modeVids
	or	al,[di].fClearRegenVids
	
	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	test	ss:[bx].fvmCurAdap, fvmEGA or fvmVGA or fvm64KEGA or fvmMCGA or fvmEGAM
	jz	TrashRegen	;CGA doesn't support the function below
	cmp	al, 40H		;Olivetti doesn't support it either.
	je	TrashRegen

	or	al,80h				;* don't clear RGEN

TrashRegen:
	xor	ah,ah
	push	ax				;save mode
	int	10h				;* set mode
	pop	ax				;restore
;*	* Delay so that we won't start writting to the display before it has
;*	* settled down.
	mov	cx,500
delay_me:
	loop	delay_me

;
; When the olivetti is in mode 40H the value at BIOS_info is a pointer to
; the character set (NOT flags as it is in EGA modes)
; So let's not trash the pointer by clearing the "don't clear regen" bit.
;
	cmp	al, 40H
	je	@F

	test	ss:[bx].fvmCurAdap, fvmEGA or fvmVGA or fvm64KEGA or fvmMCGA or fvmEGAM
	jz	@F

;* Clear the "don't clear regen" bit in the BIOS image
	xor	ax,ax
	mov	es,ax
	and	byte ptr es:[BIOS_info],7fH	;487H
	mov	ax,40h
	mov	es,ax
	mov	al,[di].ayMacVids		;
	dec	al				; rows - 1
	mov	byte ptr es:[0084H],al		;* update BIOS rows
@@:
;
;	The following is provided only to overcome a bug in the EGA BIOS
;	routines which support the graphics "compatibility mode" (BIOS 4)
;	so that the two calls related to PALETTE (INT10 AH = 0BH and
;	INT10H AH = 10H) work correctly.  If we use the first call once
;	when user invokes SCREEN 1 to set the background color, then the
;	BIOS will subsequently reference the correct (low-intensity)
;	color values for the 4 palette attributes whenever the call using
;	INT10H, AH = 0BH is used to toggle the palette, and whenever the
;	call INT10H, AH = 10H is used to set an individual palette regis-
;	ter.  In the absence of this initialization, the high-intensity
;	color values for both palettes are referenced.
;
	test	ss:[bx].fvmCurAdap, fvmEGA or fvmVGA or fvm64KEGA or fvmEGAM
	jz	SkipKludge
	mov	al, [di].modeVids
	cmp	al,4
	je	@F
	cmp	al,5
	jne	SkipKludge
@@:
	push	bx
	xor	bx,bx
	mov	ah, 0BH
	int	10H		;set background color
	pop	bx
SkipKludge:
	mov	ax,-1		;mode set
	jmp short @F
mode_already_set:
	xor	ax,ax		;same mode
@@:
cEnd	SetVideoMode


;********** SaveVidDataCsd ********
;*	entry:	pvidsSaveData = near pointer to VIDS structure
;*		lpwBuffer = buffer to save data
;*	* save screen data into buffer
;*	exit:	n/a

cProc	SaveVidDataCsd, <FAR, PUBLIC, ATOMIC>, <DS, SI, DI>
    parmDP pvidsSaveData
    parmD  lpwBuffer
cBegin	SaveVidDataCsd

	mov	di,pvidsSaveData
	mov	si,di
	mov	dl,[di].modeVids
	mov	cx,0B800h
	cmp	dl,7			
	jb	@F
	cmp	dl,8			
	ja	@F
	mov	cx,0B000h			;video segment for mono mode
@@:
	mov	ax,[di].cwSwapVids
	les	di,lpwBuffer			;es:[di] -> buffer
	cmp	dl,40h				;Olivetti ?
	je	@F
	cmp	dl,8			
	ja	save_graphics_text
@@:						;Text modes or mode 6
	cCall	SaveRegen
	mov	di,si
	cCall 	ClearRegen
	jmp	SaveVidsDataExit

save_graphics_text:
	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	mov	ax, 0a000H			; Address of bit planes
	mov	ds, ax				;ds:[si] -> video buffer
	test	ss:[bx].fvmCurAdap, fvmMCGA
	jz	EgaSS_NotMCGA

	mov	si, 8000H
	mov	cx, 2*1024
EgaSS_MCGA1:
	xor	ax,ax
	xchg	ax, [si]
	inc	si
	inc	si
	stosw
	loop	EgaSS_MCGA1
	
	jmp	short EgaSS_SaveBitPlane2

EgaSS_NotMCGA:
	mov	cl, 0		   	;bit plane 0
	mov	bx,pvidsSaveData

	mov	ax, ss:[bx].cwSwapVids
	cCall	SaveBitPlane

	mov	cl, 1			;bit plane 1
	mov	bx,pvidsSaveData
	mov	ax, ss:[bx].cwSwapVids
	cCall	SaveBitPlane

EgaSS_SaveBitPlane2:
	mov	cl, 2			;bit plane 2
	mov	ax, 4*1024
	cCall	SaveBitPlane

;
; The 8k bytes starting at 16k only gets trashed on 64k Ega cards
;
	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	test	ss:[bx].fvmCurAdap, fvm64KEGA
	jz	EgaSs_64plus

	mov	cl, 2
	mov	ax, 4*1024
	mov	si, 16*1024
	cCall	SaveBitPlane2

EgaSs_64plus:
	push	ss				; Restore ds
	pop	ds
	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	test	[bx].fvmCurAdap, fvmMCGA
	jnz	EgaSS_NotMCGA2

	mov	di,pvidsSaveData
	cCall	ClearBitPlanes

EgaSS_NotMCGA2:

SaveVidsDataExit:

cEnd	SaveVidsDataCsd

;***
;
;  SaveRegen - Saves the video regen buffer to global memory
;
;  Inputs:	[ax] - Number of words to save
;		[di] - Points to a VideoState buffer where handle to
;		       global memory used to save the regen buffer is
;		       store (along with the size of the saved buffer)
;		[es] - Segment of video regen buffer
;		
;
;  Outputs:	none.
;
;  Uses:	es, si
;
;****
cProc	SaveRegen,<NEAR>,<DI,SI>
cBegin	SaveRegen
	push	ds
	mov	ds,cx
	mov	cx,ax
	xor	si,si
;	cCall	VideoOff		; (CGA) Only affects ax and dx
	rep movsw
	pop	ds

;	cCall	VideoOn
NoRegenSave:
cEnd	SaveRegen


cProc	VideoOff,<NEAR,PUBLIC>,<ES>	;trash ax,dx
cBegin	VideoOff
	mov	dx,CGA_6845_STATUS
WaitVerticalRetrace:
	in	al,dx 
	test	al,08H
	jz	WaitVerticalRetrace

	xor	ax,ax
	mov	es,ax 
	mov	ax,es:[0465H]		; Get Current CRT mode
	and	ax, NOT 0008H		; turn off video signal bit
	mov	dx,CGA_6845_MODE
	out	dx,al 
cEnd	VideoOff


cProc	VideoOn,<NEAR,PUBLIC>,<ES>	;trash ax,dx
cBegin	VideoOn
	xor	ax,ax
	mov	es,ax 
	mov	ax,es:[0465H] 		; Get Current CRT mode
	or	ax,0008H		; Turn on video signal bit
	mov	dx,CGA_6845_MODE
	out	dx,al 
cEnd	VideoOn


;***
;
;  ClearRegen - Clears the part of the regen buffer used by TWIN.
;
;  Inputs:	[di] - Points to a VideoState buffer containing the
;		       video state to be restored.
;		[videoseg] - Segment of video regen buffer
;
;  Outputs:	The global memory used to save the regen buffer is freed.
;		i.e. don't call RestoreRegen again with the save video state.
;
;  Uses:	es,di
;
;****
cProc	ClearRegen,<NEAR>,<di,es>
cBegin	ClearRegen
	mov	ax, 0720H		; Assume text mode (clear to spaces)
	mov	cx, 0B800h		; EGA
	mov	bl, [di].modeVids
	cmp	bl, 3
	jbe	CR_1
	cmp	bl,7
	jb	@F
	cmp	bl,8
	ja	@F
	mov	cx,0B000h
	jmp short CR_1
@@:
	xor	ax,ax			; Clear to Null for graphics modes.
CR_1:
	mov	es, cx			; Clear the part of the regen buffer
	mov	cx, [di].cwSwapVids	; Save for later
	xor	di,di			; that we used.
	rep stosw
cEnd	ClearRegen


;***
;
;  RestoreRegen - Restores the video regen buffer from pVideoState
;
;  Inputs:	[di] - Points to a VideoState buffer containing the
;		       video state to be restored.
;		[videoseg] - Segment of video regen buffer
;		cx = video segment
;
;  Outputs:	NZ - if restore ok
;		Z - if not restored
;
;               The global memory used to save the regen buffer is freed.
;		i.e. don't call RestoreRegen again with the save video state.
;
;  Uses:	es, si
;
;****

cProc	RestoreRegen,<NEAR>,<di>
cBegin	RestoreRegen
	mov	es,cx
	mov	cx,ax
	xor	di,di
	rep movsw
cEnd	RestoreRegen



; SaveBitPlane - Saves a given number of words from a given bit plane.
;
; INPUT:
;    ax - Number of words to save
;    cl - Number of bit plane
;    ds - is the segment address of the bit plane.
;    es:di - where to save.
;              
; OUTPUT:
;    ES:DI - Points 1 word past the last saved word
;
; USES:
;    SI
;
cProc	SaveBitPlane,<NEAR>
cBegin	SaveBitPlane
	xor	si,si

LabelNP	<SaveBitPlane2>
	push	ax			; Save count of words
	cCall	MapBitPlane
	pop	cx			; Restore
	rep movsw
cEnd	SaveBitPlane

;
; RestoreBitPlane - Restores a given number of words to a given bit plane.
;
; INPUT:
;    ax - Number of words to restore
;    cl - Number of bit plane
;    es - is the segment address of the bit plane.
;    ds:si - where to restore from.
;              
; OUTPUT:
;    ds:si - Points 1 word past the last restored word
;
; USES:
;    DI
;
cProc	RestoreBitPlane,<NEAR>
cBegin	RestoreBitPlane
	xor	di,di
LabelNP <RestoreBitPlane2>
	push	ax			; Save count of words
	cCall	MapBitPlane
	pop	cx			; Restore
	rep movsw
cEnd	RestoreBitPlane


;
; MapBitPlane - Maps the specified bit plane in for read/write
;
; INPUT:
;    CL - the bit plane.
;
cProc	MapBitPlane,<NEAR>
cBegin	MapBitPlane
	mov	al, 2			; Set Map Mask register
	mov	ah, 1
	shl	ah, cl
	cCall	SetEgaSequencer		; Only trashes DX,AX

	mov	al, 4			; Read Map Select
	mov	ah,cl
	mov	dx, 3ceH		; Graphics Controler Address Port
	cCall	OutWord
cEnd	MapBitPlane

cProc	ClearBitPlanes,<NEAR>,<DI,SI>
cBegin	ClearBitPlanes
	mov	si,di				; ds:si -> saved video state

	mov	ax, 0a000H
	mov	es,ax

	mov	cl, 0				; Map in bit plane 0
	cCall	MapBitPlane

	xor	di,di
	mov	cx, [si].cwSwapVids
	xor	ax,ax
	rep stosw

	mov	cl, 1				; Map in bit plane 1
	cCall	MapBitPlane

	xor	di,di
	mov	cx, [si].cwSwapVids
	xor	ax,ax
	rep stosw

	mov	cl, 2				; Map in bit plane 2
	cCall	MapBitPlane
	xor	di,di
	mov	cx, 8*1024/2
	xor	ax,ax
	rep stosw

	push	ss
	pop	ds				; Restore ds
cEnd	ClearBitPlanes



; SetEgaSequencer - Sends data to the Ega sequencer
;
; INPUT:
;    AL - Sequencer register number
;         00 Reset
;         01 Clocking Mode
;         02 Map Mask
;         03 Character Map Select
;         04 Memory Mode
;    AH - Data for the register
;
cProc	SetEgaSequencer,<NEAR>
cBegin	SetEgaSequencer
	mov	dx, 3c4H		; Ega Sequencer Address Port
	cCall	OutWord
cEnd	SetEgaSequencer

;
; This is just an `out dx,ax' kludge to ensure that it works on
; AT&T 6300
;
cProc	OutWord,<NEAR>
cBegin	OutWord
	out	dx, al
	jmp	short OUTWORD_1		; I/O delay
OUTWORD_1:
	inc	dx
	mov	al,ah
	out	dx, al
cEnd	OutWord


;********** RestoreVidDataCsd ********
;*	entry:	pvidsRestoreData = near pointer to VIDS structure
;*		lpwBuffer = buffer to save data (NULL => just clear screen)
;*	* restore screen data from buffer
;*	exit:	n/a

cProc	RestoreVidDataCsd, <FAR, PUBLIC, ATOMIC>, <DS, SI, DI>
    parmDP pvidsRestoreData
    parmD  lpwBuffer
cBegin	RestoreVidDataCsd

	mov	di,pvidsRestoreData
	mov	al, [di].modeVids

	cmp	al, 3
	jb	EgaRS_Text

	cmp	al, 7
	je	EgaRS_Text
	jb	EgaRS_SimpleGraphics
	cmp	al,8
	je	EgaRs_Text
	cmp	al,40h				;Olivetti ?
	je	EgaRS_SimpleGraphics
	jmp	short EgaRs_HardGraphics

EgaRS_SimpleGraphics:			;mode 6
	push	ax
	cCall	ClearRegen
	pop	ax
EgaRS_Text:	; mode 2,3 and 7,8
	mov	cx,0B800h
	cmp	al, 7
	jb	@F
	cmp	al,8			
	ja	@F
	mov	cx,0B000h
@@:
	mov	ax,[di].cwSwapVids
	lds	si,lpwBuffer
	cCall	RestoreRegen
	jmp	RestoreVidsCsd_exit

EgaRS_HardGraphics:
	cCall	ClearRegen
	mov	ax, 0a000H			; Address of bit planes
	mov	es, ax
	lds	si,lpwBuffer			;ds:[si] -> buffer

	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	test	ss:[bx].fvmCurAdap, fvmMCGA
	jz	EgaRs_NotMCGA

	mov	di, 8000H
	mov	cx, 2*1024
	rep movsw
	jmp	short EgaRs_RestoreBitPlane2

EgaRs_NotMCGA:
	mov	cl, 0
	mov	di,pvidsRestoreData
	mov	ax, ss:[di].cwSwapVids
	cCall	RestoreBitPlane

	mov	cl, 1
	mov	di,pvidsRestoreData
	mov	ax, ss:[di].cwSwapVids
	cCall	RestoreBitPlane

EgaRs_RestoreBitPlane2:
	mov	cl, 2
	mov	ax, 4*1024
	cCall	RestoreBitPlane

;
; The 8k bytes starting at 16k only gets trashed on 64k Ega cards
;
	mov	bx,OFF_lpwDataCsd		;* Data in data segment
	test	ss:[bx].fvmCurAdap, fvm64KEGA
	jz	EgaRs_64plus

	mov	cl, 2
	mov	ax, 4*1024
	mov	di, 16*1024
	cCall	RestoreBitPlane2

EgaRs_64Plus:
	mov	ax,ss				; Restore ds
	mov	ds,ax

;
; Set Map Mask register back to what BASIC expects
;
	mov	ax, 0f02H			; Set map mask to 0fH
	cCall	SetEgaSequencer
	jmp	RestoreVidsCsd_exit

EgaRs_HardNoRegen:
	cCall	ClearBitPlanes

RestoreVidsCsd_exit:

cEnd	RestoreVidDataCsd

;
; INT10Handler
;    The BIOS INT10 (Video Sevices) is hooked to mirror the palette
;    registers (so they can be restored).
;


	RegPtr	cs_bx, cs, bx
	RegPtr	es_bx, es, bx


;********** EnableVidsMonitorCsd ********
;*	entry:	fMonitorOn => monitor should be on
;*	* enable/disable INT 10 monitor
;*	exit:	n/a

cProc	EnableVidsMonitorCsd, <FAR, PUBLIC, ATOMIC>,<di>
    parmW  fMonitorOn
cBegin	EnableVidsMonitorCsd
	mov	di,OFF_lpwDataCsd		;* Data in data segment

	cmp	fMonitorOn,0
	je	Unhook

; Hook int10 trap
	test	ss:[di].fvmCurAdap, fvmEGA or fvmVGA or fvmMCGA
	jz	@F
	mov	[ColourPaletteYellow], 010100B 	;brown
@@:
	mov	dx,drvOffset ColourPalette   	; Default Enhanced colour
	test	ss:[di].fvmCurAdap, fvmEGAM
	jz	@F
	mov	dx,drvOffset MonoPalette   	; Default Monochrome palette
@@:	
	push	cs
	pop	ds				;now ds:dx points to source
	cCall	CopyPalette			; Initialise the user palette
	push	ss
	pop	ds				;restore ds
	

	mov	ax, 10H
	mov	bx, drvOffset INT10Handler
	cCall	HookVector,<ax, cs_bx>
	mov	cs:[lpbBIOSINT10_Offset], ax
	mov	cs:[lpbBIOSINT10_Segment], dx
	jmp	EVM_Exit

Unhook:
; Unhook int10 trap
	les	bx, cs:[BIOSINT10]
	mov	ax, 10H
	cCall	HookVector,<ax,es_bx>
	xor	ax,ax			     	; clear handler
	mov	cs:[lpbBIOSINT10_Offset], ax
	mov	cs:[lpbBIOSINT10_Segment], ax
EVM_Exit:	
cEnd	EnableVidsMonitorCsd


;***
;
;  HookVector(vecNum, vector)
;
;  Sets an interrupt vector and returns the old interrupt vector
;
;  Inputs:	vecNum - Which vector to set
;		vector - address of the new vector
;
;  Outputs:	DX:AX == old interrupt vector
;
;****

cProc	HookVector,<NEAR,PUBLIC>,<DS>
	parmB	vecNum
	parmD	vector
cBegin	HookVector

	mov	ah, 35H
	mov	al, [vecNum]
	int	21H			; Get old vector
	push	bx			; save for return
	push	es			; save for return

	mov	ah, 25H
	mov	al, [vecNum]
	lds	dx, [vector]
	int	21H			; Set new vector

	pop	dx			; return the old vector
	pop	ax			; return the old vector
cEnd	HookVector

;-------------------------------------------------------------------;

INT10Handler:
	or	ah,ah
	jz	INT10SetMode
	cmp	ah, 10h			;set palette regs ?
	je	INT10SetPalette
	cmp	ah, 0Bh
	je	INT10SetCGABgPal
INT10_Chain:
	jmp	cs:[BIOSINT10]

INT10SetMode:
	mov	cs:[bCGABg],-1		; bCGABg is now invalid.
	mov	cs:[bCGAPal],-1		; bCGAPal is now invalid.
	jmp	short INT10_Chain

public INT10SetCGABgPal			;UNDONE - Remove.

INT10SetCGABgPal:
	or	bh,bh			;Set Background colour?
	jnz	@F			;brif no.
;*	* assume BH == 1 for setting palette (if not CGA who cares anyway)
	mov	cs:[bCGABg],bl
	jmp	short INT10_Chain
@@:
	mov	cs:[bCGAPal],bl		;Must be setting CGA Palette
	jmp	short INT10_Chain

INT10SetPalette:
	push	ax			; Save the regs we use
	or	al,al
	jz	INT10_SetIndividualPaletteReg	;ax = 1000h
	dec	al
	jz	INT10_SetOverscanReg		;     1001h
	dec	al
	jz	INT10_SetAllPaletteRegs		;     1002h

INT10_Exit:
	pop	ax
	jmp	short INT10_Chain

;
; INT10_SetIndividualPaletteReg
;    Sets the specified palette register
;
; BL - Is the register number (0-15)
; BH - Is the value
;
INT10_SetIndividualPaletteReg:
	push	bx
	xchg	al, bh			; BH <-- 0, AL <-- value
	mov	cs:[EgaPaletteMirror+bx], al
	pop	bx
	jmp	short INT10_SetPaletteCommon

;
; INT10_SetOverscanReg
;    Sets the overscan register
;
; BH - Is the value.
;
INT10_SetOverscanReg:
	mov	cs:[OverScanMirror], bh
	jmp	short INT10_Exit

;
; INT10_SetAllPaletteRegs
;    Sets all the palette registers and the overscan register.
;
; ES:DX - points to table of values for the 16 palette registers and
;         the overscan register
;
INT10_SetAllPaletteRegs:
	push	ds

	push	es
	pop	ds		; now ds:dx points to source
	call	CopyPalette

	pop	ds
	mov	cs:[bCGAPal],-1		; bCGAPal is now invalid.
INT10_SetPaletteCommon:
	mov	cs:[bCGABg],-1		; bCGABg is now invalid.
	jmp	short INT10_Exit

;
; Copy DS:DX to CS:EgaPaletteMirror
;
cProc CopyPalette,<NEAR>,<SI,DI,CX,ES>
cBegin CopyPalette
	push	cs
	pop	es
	mov	si, dx
	mov	di, DrvOffset EgaPaletteMirror
	mov	cx, 17
	rep movsb
cEnd CopyPalette

ifndef	KANJI
;***** UNDONE - HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK
;***** UNDONE	This piece of code is called directly by QB 4.5
;***** UNDONE	It must not be called by QBJ
;***** UNDONE	Remove this as soon as QB 4.5 ships.
cProc SetBlinkBit,<FAR,PUBLIC>
	parmB	fOn
cBegin
	cmp	[fOn],0
	je	@F
	cCall	EnableBlinkBit
	jmp	short SBB_Exit
@@:
	cCall	DiddleBlinkBit
SBB_Exit:
cEnd
endif	; !KANJI
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\update1.asm ===
;* included in:
;*		tandy, ibmcvt

NonStandard	FvmGetCur
NonStandard	ModeGetCur
NonStandard	FInitCsd
NonStandard	DoUpdateCsd


;********** FvmGetCur **********
;*	entry:	DS:DI => driver data
;*	* if first time called, identify the current screen and set fvmCur
;*	*  subsequent calls will return fvmCur
;*	*  After this call: fvmCur is initialized
;*	exit:	AL == fvm for current screen (0 => no supported screen found)
;*		AH == monitor

cProc	FvmGetCur, <NEAR, PUBLIC, ATOMIC>, <DS>
cBegin	FvmGetCur

	AssertEQ di,OFF_lpwDataCsd
	mov	ax,-1
	mov	[di].fvmCurAdap,al
	mov	[di].fvmCurDisp,ah

cEnd	FvmGetCur



;********** ModeGetCur *********
;*	entry:	n/a
;*	* get current machine mode
;*	exit:	al = mode, ah = ayMac (or 0 if unknown)

cProc	ModeGetCur, <NEAR, PUBLIC, ATOMIC>, <ES>
cBegin	ModeGetCur

	push	bx
	mov	ah,0fh
	int	10h			;* get current state, return al = mode
	and	al,7Fh			;* mask off clear video buffer bit.
	pop	bx
	mov	ah,25			;default

cEnd	ModeGetCur


;********** FInitCsd **********
;*	entry:
;*		pinch = near pointer to INCH structure to fill
;*	* Initialize the screen to the given mode
;*	exit:	AX != 0 if ok

cProc	FInitCsd, <FAR, PUBLIC, ATOMIC>, <ds,di>
    parmDP pinst
    parmDP pinch
    localB modeCur
cBegin	FInitCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment

;*	* save old mode
	cCall	ModeGetCur			;* al = mode, ah = ayMac
	mov	modeCur,al			;* current mode

	mov	bx,pinst
	cmp	ds:[bx].ayMacInst,ah
	je	@F				;* same resolution
	mov	modeCur,0			;* cause mode reset
@@:

;*	* set mode
	mov	[di].pinstDrv,bx
	mov	bx,ds:[bx].pdmInst		;* CS:BX => DM info

;*	* copy mode info into driver globals
	mov	ax,cs:[bx].vparmCursOnDm
	mov	[di].vparmCursOn,ax
	mov	[di].vparmCursSize,ax
	mov	ax,cs:[bx].wExtraDm
	mov	[di].wExtra,ax

	mov	al,cs:[bx].modeDm
	cmp	al,modeCur
	jne	@F				
	jmp	finitdone			;same mode, no reset
@@:
	xor	ah,ah				;* set mode
						;* REVIEW: always clear RGEN ??
	mov	al,cs:[bx].modeDm
	int	10h

	mov	ax,40H
	mov	es,ax
	mov	al,cs:[bx].ayMacDm
	dec	al				; rows - 1
	mov	byte ptr es:[0084H],al		;* update BIOS rows
finitdone:
	test	cs:[bx].finstDm,finstGraphics
	jz	@F

	mov	[di].SEG_lpbFont,segROM		;load PC ROM Font 
	mov	[di].OFF_lpbFont,0FA6Eh
	mov	[di].ayBox,8
	jmp short exitF
@@:
;*	* normally the INCH array would be copied (but since it is already
;*	*  setup in DATA just leave it alone).

;*	* Do other diddling
	cCall	DiddleBlinkBit
exitF:
	mov	ax,sp				;* success
cEnd	FInitCsd


;********** DoUpdateCsd **********
;*	entry:
;*		parameters just like PrepUpdateCsd
;*	* after primary buffer has been updated
;*	* For BIOS version -- send to screen
;*	* for Kanji -- parse for DBCS boundaries (OAX)
;*	exit: n/a

cProc	DoUpdateCsd,<FAR, PUBLIC, ATOMIC>, <DS, ES, SI, DI>
    parmB ayLine
    parmB axFirst
    parmB dax			;* will never be 0
    parmW offFirst
    parmW fRestoreDbcs		;* => restore DBCS 1/2 characters
    localB axCurs
    localB axCurrent
    localB flastattr		;check repeat attribute
    localB ifgd			;needed for mode A (640x200x4)
    localB ibkgd
    localB curattr
    localW wTemp
    localV LocalChar,8		;storage of char bit map for ffont mode
    localB iMode
cBegin	DoUpdateCsd
	
	cmp	dax,0
	ja	DoUpdateChar

	jmp	end_update
DoUpdateChar:
	mov	di,OFF_lpwDataCsd		;* Data in data segment
	mov	bx,[di].pinstDrv

	test	ss:[bx].finstInst,finstGraphics	;graphics text 8x14
	jnz	graf_update
	jmp	done_graf_update

graf_update:

	mov	ax,[di].posCurs			;for cursor drawing
	mov	axCurs,-1
	mov	axCurrent,0
	cmp	byte ptr [di].fCurs,0		;cursor on ?
	je	NoCursUpdate

	cmp	ah,ayLine			;check if cursor on ayLine
	jne	NoCursUpdate

	cmp	al,axFirst			;check if cursor outside axFirst
	jb	NoCursUpdate

	mov	axCurs,al			;need to update cursor
	mov	al,axFirst
	mov	axCurrent,al
NoCursUpdate:	
	mov	si,ds:[bx].pdmInst		
	mov	dl,cs:[si].modeDm		;save video mode in dl
	mov	iMode,dl
	mov	ds,ds:[bx].psPrimInst		;* DS:SI => primary buffer

;*	* DS:SI => start character in primary buffer
;*	* SS:BX => INST info
;*	* SS:DI => Driver data

;***** Graphics Text ****
;*			*
;*			*

	mov	flastattr,0		;initialize with black:black
	mov	cx,ss:[di].ayBox
	shr	cx,1			;memory interleave addressing
	xor	ax,ax			;calculate start of screen address
	mov	al,ayLine
	mul	cx
	mov	cx,80
	mul	cx
	xor	cx,cx
	mov	cl,axFirst
IFDEF TANDYCSD
	cmp	iMode,0Ah
	jne	@F
	shl	cx,1			;Tandy's 4-color mode, 2 bytes/char
@@:
ENDIF
	add	ax,cx			;ax = ayLine x 80 x ayBox + axFirst
	mov	di,ax			;point to video buffer
	xor	cx,cx
	mov	cl,dax			;no. of char to be updated
	mov	si,offFirst

;* 640x200x2(x4) graphics
	
out_next_char1:
	lodsw				;load character+attribute
	mov	curattr,ah		;save color attribute
	push	cx
	mov	wTemp,di		;save di
	mov	di,OFF_lpwDataCsd	
	mov	cx,ss:[di].ayBox	;calculate character table address

	push	ds			;save pointer to primary buffer
	push 	si

	mov	si,ss:[di].OFF_lpbFont	;default
	mov	ds,ss:[di].SEG_lpbFont

	mov	dx,ax			;save char + attribute
	cmp	al,80h
	jb	first128
		     			;use extend font (128 - 255)
	push	cs
	pop	ds
	mov	si,drvOffset rgbCGAExFont8x8	;see cga8x8.inc
	sub	al,80h

first128:
	xor	ah,ah
	mul	cl			
	add	si,ax				;ds:[si] -> char bit map

	mov	ax,ss
	mov	es,ax
	lea	di,LocalChar			;es:[di] -> local storage
	rep	movsb	 			;copy char bit map into local area
	mov	di,OFF_lpwDataCsd		;restore points
	mov	cx,ss:[di].ayBox	
	test	ss:[bx].finstInst,finstMonochrome	;Test for mono
	jz	@F
	cmp	curattr,70H			;highlighting ?
	jne	@F

	lea	si,LocalChar
loopnot:
	not	byte ptr ss:[si]
	inc	si
	loop	loopnot
	mov	cx,ss:[di].ayBox	
@@:	
	mov	ds,ax
	lea	si,LocalChar
	cmp	ss:[bx].psSecInst,0		;is sec. buffer allocated ?
	je	notfont8

	test	ss:[bx].finstInst,finstFont	;ffont mode ?
	jz 	notfont8

	mov	ax,dx			;save char
	pop	di	;si -> di
	push	di
	mov	es,ss:[bx].psSecInst		;es:[di] => ffont buffer
	mov	dx,es:[di-2]			;dx = ffont word
	or	dl,dl				;normal ?
	jz	notfont8

	cmp	al,' ' 			;check spaces
	jne	notspace1
	
	test	dl,ffontUnderline or ffontDoubleUnderline or ffontStrikeThrough or ffontOrCharacter
	jz	notfont8

notspace1:
	cCall	ChrisPFont 
	mov	di,OFF_lpwDataCsd	;restore points
	mov	cx,ss:[di].ayBox	
notfont8:
	mov	al,axCurrent		;cursor position ?
	cmp	al,axCurs
	jne	CursOff1

	mov	di,OFF_lpwDataCsd	
	push	si
	mov	cx,ss:[di].vparmCursOn
	xchg	ch,cl
	xor	ch,ch
	add	si,cx
	mov	cx,ss:[di].vparmCursOn
	sub	cl,ch
	xor	ch,ch			;cx = thickness of the cursor

outCurs1:				;display the cursor
	not	byte ptr [si]
	inc	si
	loop	outCurs1
	pop	si
	mov	di,OFF_lpwDataCsd	;restore points
	mov	cx,ss:[di].ayBox	

CursOff1:
IFDEF TANDYCSD
	mov	dh,curattr
	cmp	dh,flastattr		;same attr ?
	je	@F
	
	mov	flastattr,dh		;update attribute
	mov	dl,curattr
	mov	al,dl			;al = foreground
	and	al,03h
	mov	cl,4
	shr	dl,cl			;dl = background value
	and	dl,03h
	mov	ifgd,al
	mov	ibkgd,dl
	mov	di,OFF_lpwDataCsd	;restore points
	mov	cx,ss:[di].ayBox	
@@:					;* same attribute
ENDIF
	mov	ax,0B800h			;CGA video segment
	mov	es,ax
	mov	di,wTemp			;restore di
IFDEF TANDYCSD
	cmp	iMode,0Ah
	jne	NotMode0Ah

;;;4-color graphics mode	
	push	bx
out_1_byte:
	lodsb				;al=bit pattern
	mov	bl,al			;fgd = 1
	mov	dl,ifgd
	and	dl,1
	jnz	@F
	not	bl
@@:
	mov	bh,bl
	cmp	ifgd,1
	jb	@F
	cmp	ifgd,2
	ja	@F
	not	bh
@@:
	mov	ah,al
	and	bx,ax			;bkgd = 00 (black)
	push	bx			;save fgd pattern
	not	al
	mov	bl,al			;fgd = 1
	mov	dl,ibkgd
	and	dl,1
	jnz	@F
	not	bl
@@:
	mov	bh,bl
	cmp	ibkgd,1
	jb	@F
	cmp	ibkgd,2
	ja	@F
	not	bh
@@:
	mov	ah,al
	and	bx,ax			;fgd = 00 (black)
	pop	ax			;restore fgd pattern
	or	ax,bx			;merge fgd & bkgd
	stosw				;update one line
	add	di,2000h-2		;go to next line
	jns	@F
	add	di,-8000h+160
@@:
	loop	out_1_byte
	pop	bx
	mov	di,wTemp
	inc	di			;next char
	inc	di			;2 bytes/char
	jmp	NextChar

NotMode0Ah:	
ENDIF

;;;mono graphics mode
	mov	ax,1FFFh
	mov	dx,79-2000h
out_one_byte:				;output the character
	movsb
	add	di,ax
	xchg	ax,dx
	loop	out_one_byte

	mov	di,wTemp
	inc	di			;next char
NextChar:
	inc	axCurrent		;bump update position
	pop	si
	pop	ds
	pop	cx			;restore dax
	dec	cx
	jz	out_done1
	jmp	out_next_char1

out_done1:
done_graf_update:
IFDEF KANJI
;*	* For the OAX, we parse what we have printed and set the attribute
;*	*  byte to 0 for the second byte of double byte characters.
	cmp	fRestoreDbcs,0
	jne	end_update
	mov	si,offFirst
	xor	cx,cx
	mov	cl,dax				;* # of bytes
loop_parse_dbcs:
	lodsw					;* get char(al) + attribute(ah)
	JmpNotDbc parse_single
;*	* second byte follows
	inc	si				;* skip 2nd char
	mov	byte ptr ds:[si],0		;* clear attrib
	inc	si
	AssertNE cx,1				;* must be enough
	dec	cx
parse_single:
	loop	loop_parse_dbcs

ENDIF ;KANJI

end_update:

cEnd	DoUpdateCsd

	include cga8x8.inc		; extend font (128 - 255)

NonStandard	BltArcCsd

;********** BltArcCsd **********
;*	* CSD entry point (see documentation for interface)
;*	entry : axSrc, aySrc : upper left of source
;*		axDest, ayDest : upper left of destination
;*		dax, day : shift amount
;*	* Move a rectangle from one portion of the screen to another.
;*	exit : n/a

cProc	BltArcCsd,<FAR, PUBLIC, ATOMIC>, <SI,DI,DS>
    parmB axDest
    parmB ayDest
    parmB dax 
    parmB day
    parmB axSrc
    parmB aySrc
    localW cRows
cBegin	BltArcCsd
	mov	di,OFF_lpwDataCsd		;* Data in data segment
	mov	bx,[di].pinstDrv

;*	* SS:BX => INST info
;*	* SS:DI => Driver data

;set up Src pointer si
	mov	cx,ss:[di].ayBox
	shr	cx,1			;memory interleave
	mov	al,80			;assume 80 columns (IBM)
	mul	cl			;
	mov	bx,ax			;bx = 80 * charHeight
	mov	cl,aySrc		
	mul	cx
	mov	cl,axSrc
	add	ax,cx			;ax = ay x 80 x Height + ax
	mov	si,ax			;si points to starting byte Src

;set up Dest pointer di
;assume (Scroll down) Hi -> Lo memory
	mov	ax,bx
	mov	cl,ayDest		
	mul	cx
	mov	cl,axDest
	add	ax,cx
	mov	cx,ss:[di].ayBox	;for later use
	mov	di,ax

	mov	al,day		
	mul	cl			;ax = ayBox * day
	mov	cRows,ax		;total scan rows needed to be blt

 	mov	cl,ayDest
	cmp	cl,aySrc
	jb	fwd
	ja	bkwd
;ayDest = aySrc
	mov	cl,axDest
	cmp	cl,axSrc
	jb	fwd		
bkwd:	
;have to blt backward (Lo -> Hi memory)
;(Scroll up) 
	shr	ax,1
	dec	ax
	mov	cx,80
	mul	cx
	mov	cl,dax
	dec	cx
	add	ax,cx			;ax = block offset
	add	ax,2000h		;start blt from odd line
	add	di,ax			;si, di point to end of block
	add	si,ax	
	std				;set direction flag
fwd:
	mov	ax,0B800h
	mov	ds,ax			;ds,es point to video buffer
	mov	es,ax
	mov	cx,cRows				
Blt1:
	mov	ax,si
	mov	bx,di
	mov	dx,cx
;	push	si
;	push	di
;	push	cx	

	xor	ch,ch
	mov	cl,dax
	rep	movsb 			;load latches/store video memory

;	pop	cx
;	pop	di
;	pop	si
	mov	cx,dx
	mov	di,bx
	mov	si,ax
	cmp	di,si
	jb	bf
;blt backward
	cmp	si,2000h
	jb	@F
	mov	dx,-2000h
	jmp short Blt2
@@:
	mov	dx,2000h - 80
	jmp short Blt2
bf:
;blt forward
	cmp	si,2000h
	jb	@F
	mov	dx,-2000h + 80
	jmp short Blt2
@@:
	mov	dx,2000h
Blt2:
	add	si,dx
	add	di,dx
	loop	Blt1

	cld				;clear direction flag

cEnd	BltArcCsd



NonStandard	GetCharMapCsd

;********** GetCharMapCsd **********
;*	entry:	pinft, ch, pbitmap
;*	* copy character bit map into buffer

cProc	GetCharMapCsd, <FAR, ATOMIC, PUBLIC>, <DS,SI,DI>
    parmDP pinft
    parmB  char
    parmDP pbitmap    
cBegin	GetCharMapCsd
	mov	di,pinft			;* ds:di => INFT
	xor	ch,ch
	mov	cl,ds:[di].dyCharInft
	mov	al,char
	cmp	al,128
	jb	@F
	sub	al,128
	mov	dx,cs
	mov	ds,dx
	mov	si,drvOffset rgbCGAExFont8x8	;see cga8x8.inc
	jmp short RetFonts
@@:
	mov	dx,0F000h
	mov	ds,dx
	mov	si,0FA6Eh
RetFonts:
	mul	cl
	add	si,ax				;ds:si => character bit map		

	mov	ax,ss
	mov	es,ax
	mov	di,pbitmap			;es:di => destination
	rep	movsb
	
cEnd	GetCharMapCsd


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\update2.asm ===
;* included in:
;*		 t3100, compaq3, vectra, olivetti, ericsson, genius (.asm)

NonStandard	FvmGetCur
NonStandard	DoUpdateCsd

;*****************************************************************************

;********** FvmGetCur **********
;*	entry:	DS:DI => driver data
;*	* if first time called, identify the current screen and set fvmCur
;*	*  subsequent calls will return fvmCur
;*	*  After this call: fvmCur is initialized
;*	exit:	AL == fvm for current screen (0 => no supported screen found)
;*		AH == monitor

cProc	FvmGetCur, <NEAR, PUBLIC, ATOMIC>, <DS>
cBegin	FvmGetCur

	AssertEQ di,OFF_lpwDataCsd
	mov	ax,-1
	mov	[di].fvmCurAdap,al
	mov	[di].fvmCurDisp,ah

cEnd	FvmGetCur

IFDEF	(T3100CSD OR OLIVETTICSD OR COMPAQ3CSD)
NonStandard	ModeGetCur
;********** ModeGetCur *********
;*	entry:	n/a
;*	* get current machine mode
;*	exit:	al = mode, ah = ayMac (or 0 if unknown)

cProc	ModeGetCur, <NEAR, PUBLIC, ATOMIC>, <ES>
cBegin	ModeGetCur

	mov	ax,40H
	mov	es,ax
	mov	dl,es:[0084H]		;* read BIOS rows
	inc	dl			;* dl = screen height
	cmp	dl,25			;do this since some clones don't
	je	@F			;update BIOS data
	cmp	dl,50
	je	@F
	mov	dl,25			;* default to 25 rows
@@:	
	push	bx
	mov	ah,0fh
	int	10h			;* get current state, return al = mode
	pop	bx
	mov	ah,dl

cEnd	ModeGetCur
ENDIF	;(T3100CSD OR OLIVETTICSD OR COMPAQ3CSD)

;********** DoUpdateCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* BIOS version: update the screen

cProc	DoUpdateCsd,<FAR, PUBLIC, ATOMIC>, <DS, SI, DI>
    parmB ayLine
    parmB axFirst
    parmB dax
    parmW offFirst
    parmW fRestoreDbcs
    localB axCurs
    localB axCurrent
    localW wTemp
    localW wSec
IFDEF	GENIUSCSD
    localW wvideoseg
ENDIF	;GENIUSCSD
    localB curattr
    LocalV LocalChar,16
cBegin	DoUpdateCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment
	mov	bx,[di].pinstDrv
	test	[bx].finstInst,finstGraphics
	jnz	UpdateGrafText
	jmp	DoUpdateExit

	;***************************
	;*     			   *
	;*	Graphics Text	   *
	;*			   *
	;***************************

UpdateGrafText:
	mov	ax,[di].posCurs			;for cursor drawing
	mov	axCurs,-1
	mov	axCurrent,0
	cmp	byte ptr [di].fCurs,0		;cursor on ?
	je	NoCursUpdate

	cmp	ah,ayLine			;check if cursor on ayLine
	jne	NoCursUpdate

	cmp	al,axFirst			;check if cursor outside axFirst
	jb	NoCursUpdate

	mov	axCurs,al			;need to update cursor
	mov	al,axFirst
	mov	axCurrent,al
NoCursUpdate:	
	mov	dx,ds:[bx].psSecInst		;* DX:SI => secondary buffer
	mov	wSec,dx
	mov	ds,ds:[bx].psPrimInst		;* DS:SI => primary buffer
	mov	si,offFirst

;*	* DS:SI => start character in primary buffer
;*	* DX:SI => start ffont in secondary buffer

	;find cursor position (pixel starting address)		
IFDEF	GENIUSCSD
	mov	al,ayLine 
	xor	ah,ah
	mov	cl,11
	shl	ax,cl
	mov	wvideoseg,Upper_Screen
	jnc	@F
	mov	wvideoseg,Lower_Screen
@@:
ELSE	;!GENIUSCSD
	mov	cl,ss:[bx].axMacInst		;screen width
	mov	al,ayLine 
	xor	ah,ah
	mul	cl
	mov	cx,ax
	shl	ax,1			;mul 2 (8 bytes/char, 4 way interleave)
	cmp	ss:[di].ayBox,8
	je	@F

	shl	ax,1			;mul 4 (16 bytes/char)
@@:
ENDIF	;GENIUSCSD
	xor	dh,dh
	mov	dl,axFirst
	add	ax,dx
	mov	di,ax			;* ES:DI => video buffer (pixel address)

	xor	ch,ch
	mov	cl,dax			;# of characters to be updated

out_next_char:
	lodsw			;ah - attr, al - char
	mov	curattr,ah		;save color attribute
	push	cx		;save dax
	push	ds		;save pointer to primary buffer
	push	si			
	mov	wTemp,di		;save video address
	mov	di,OFF_lpwDataCsd
	mov	si,ss:[di].OFF_lpbFont
	mov	ds,ss:[di].SEG_lpbFont	;DS:[SI] -> char table
	mov	cx,ss:[di].ayBox
	mov	dx,ax			;save char + attribute
IFNDEF	GENIUSCSD
	cmp	cx,16
	je	@F
	cmp	al,128
	jb	@F
	push	cs
	pop	ds
	mov	si,drvOffset rgbCGAExFont8x8	;see cga8x8.inc
	sub	al,80h
@@:	
ENDIF	;not defined GENIUSCSD
	xor	ah,ah
	mul	cl
	add	si,ax			

	mov	ax,ss
	mov	es,ax
	lea	di,LocalChar			;es:[di] -> local storage
	rep	movsb  	   			;copy char bit map into local area
	mov	di,OFF_lpwDataCsd		;restore points
	mov	cx,ss:[di].ayBox	
	test	ss:[bx].finstInst,finstMonochrome	;Test for mono
	jz	@F
	cmp	curattr,70H			;highlighting ?
	jne	@F

	lea	si,LocalChar
loopnot:
	not	byte ptr ss:[si]
	inc	si
	loop	loopnot
	mov	cx,ss:[di].ayBox	
@@:	
	mov	ds,ax				;DS:[SI] -> local storage
	lea	si,LocalChar

	cmp	wSec,0			;check Sec. buffer
	je	notFont			;****

	test	ss:[bx].finstInst,finstFont	;FFont mode ?
	jz	notFont	

	pop	di			;si -> di (buffer offset)
	push	di	

	mov	ax,wSec
	mov	es,ax			;ES:[DI-2] -> ffont buffer
	mov	ax,dx			;restore character
	mov	dx,es:[di-2]		
	or	dl,dl
	jz	notFont

	cmp	al,' ' 			;check spaces
	jne	notspace1
	
	test	dl,ffontUnderline or ffontDoubleUnderline or ffontStrikeThrough or ffontOrCharacter
	jz	notfont

notspace1:
	cCall	ChrisPFont 
notFont:
IFDEF	GENIUSCSD
	mov	cx,wvideoseg		;video seg
ELSE	;!GENIUSCSD
	mov	cx,0B800h		;video seg
ENDIF	;GENIUSCSD
	mov	es,cx
	mov	di,OFF_lpwDataCsd		;restore points
	mov	cx,ss:[di].ayBox	;restore points

	mov	al,axCurrent		;cursor position ?
	cmp	al,axCurs
	jne	CursOff1

	push	cx
	push	si
	mov	cx,ss:[di].vparmCursOn
	xchg	ch,cl
	xor	ch,ch
	add	si,cx
	mov	cx,ss:[di].vparmCursOn
	sub	cl,ch
	xor	ch,ch

outCurs1:				;display the cursor
	not	byte ptr [si]
	inc	si
	loop	outCurs1
	pop	si
	pop	cx

CursOff1:
IFDEF	GENIUSCSD
	mov	di,wTemp
	mov	ax,(1024 / 8) - 1
OC9Lp:
	movsb				; move one line to screen
	add	di,ax			; go to next scan line
	loop	OC9Lp
ELSE	;!GENIUSCSD
	shr	cl,1
	shr	cl,1			;div 4
	mov	di,wTemp
IFDEF	ERICSSONCSD
;
; The following is used because the Ericsson interlaces memory funny.
;	The usual quad interlacing is 1,5,9,... in first block,
;	2,6,10,... in second block, 3,7,11,... in third block, and
;	4,8,12,... in fourth block.  The Ericsson switches blocks 2 and 3
;	to give:  1,5,9,...  3,7,11,...  2,6,10,...  4,8,12,...
;
	mov	ax,2 * 2000h - 1
OC9Lp:
	movsb				 
	ADD	DI,AX			; move to block 3
	movsb
	add	di,-2000h - 1		; back to block 2
	movsb				
	ADD	DI,AX			; move to block 4 
	movsb
	sub	di,3 * 2000h + 1 - 80	; back to block 1
	loop	OC9Lp
ELSE	;!ERICSSONCSD
	mov	ax,2000h - 1
OC9Lp:
	movsb				; And put back to screen memory
	ADD	DI,AX			; Move down to next scan line
	movsb
	add	di,ax
	movsb				; And put back to screen memory
	ADD	DI,AX			; Move down to next scan line
	movsb
	sub	di,6000h - 79
	loop	OC9Lp
ENDIF	;ERICSSONCSD
ENDIF	;GENIUSCSD
	mov	di,wTemp
	inc	di
	inc	axCurrent		;bump update position
	pop	si
	pop	ds
	pop	cx
	dec	cx
	jz	DoUpdateExit
	jmp	out_next_char
		
DoUpdateExit:

cEnd	DoUpdateCsd

	include cga8x8.inc		; extend font (128 - 255)
	CPF816 = 1
	include cpfont.asm		;* ChrisPFont with 8x8,8x16

;*****************************************************************************

IFNDEF	GENIUSCSD

NonStandard	BltArcCsd

;********** BltArcCsd **********
;*	* CSD entry point (see documentation for interface)
;*	entry : axSrc, aySrc : upper left of source
;*		axDest, ayDest : upper left of destination
;*		dax, day : shift amount
;*	* Move a rectangle from one portion of the screen to another.
;*	exit : n/a

cProc	BltArcCsd,<FAR, PUBLIC, ATOMIC>, <SI,DI,DS>
    parmB axDest
    parmB ayDest
    parmB dax 
    parmB day
    parmB axSrc
    parmB aySrc
    localW cRows
cBegin	BltArcCsd
	mov	di,OFF_lpwDataCsd		;* Data in data segment
	mov	bx,[di].pinstDrv

;*	* SS:BX => INST info
;*	* SS:DI => Driver data

;set up Src pointer si
	mov	cx,ss:[di].ayBox
	shr	cx,1			;4-way memory interleave
	shr	cx,1			;
	mov	al,80			;assume 80 columns (IBM)
	mul	cl			;
	mov	bx,ax			;bx = 80 * charHeight/4
	mov	cl,aySrc		
	mul	cx
	mov	cl,axSrc
	add	ax,cx			;ax = ay x 80 x Height/4 + ax
	mov	si,ax			;si points to starting byte Src

;set up Dest pointer di
;assume (Scroll down) Hi -> Lo memory
	mov	ax,bx
	mov	cl,ayDest		
	mul	cx
	mov	cl,axDest
	add	ax,cx
	mov	cx,ss:[di].ayBox	;for later use
	mov	di,ax

	mov	al,day		
	mul	cl			;ax = ayBox * day
	mov	cRows,ax		;total scan rows needed to be blt

 	mov	cl,ayDest
	cmp	cl,aySrc
	jb	fwd
	ja	bkwd
;ayDest = aySrc
	mov	cl,axDest
	cmp	cl,axSrc
	jb	fwd		
bkwd:	
;have to blt backward (Lo -> Hi memory)
;(Scroll up) 
	shr	ax,1
	shr	ax,1
	dec	ax
	mov	cx,80
	mul	cx
	mov	cl,dax
	dec	cx
	add	ax,cx			;ax = block offset
	add	ax,6000h		;start blt from last bank
	add	di,ax			;si, di point to end of bank
	add	si,ax	
	std				;set direction flag
fwd:
	mov	ax,0B800h
	mov	ds,ax			;ds,es point to video buffer
	mov	es,ax
	mov	cx,cRows				
Blt1:
	mov	ax,si
	mov	bx,di
	mov	dx,cx
;	push	si
;	push	di
;	push	cx	

	xor	ch,ch
	mov	cl,dax
	rep	movsb 			;blt one line

;	pop	cx
;	pop	di
;	pop	si
	mov	cx,dx
	mov	di,bx
	mov	si,ax
IFDEF	ERICSSONCSD
	cmp	di,si
	jb	bfw

	mov	dx,-4000h		;Blt backward
	cmp	si,2000h
	ja	@F
	mov	dx,6000h - 80
	jmp short Blt2
@@:
	cmp	si,4000h
	ja	Blt2
	mov	dx,2000h
	jmp short Blt2
bfw:					;blt foreward
	mov	dx,4000h
	cmp	si,6000h
	jb	@F
	mov	dx,-6000h + 80
	jmp short Blt2
@@:
	cmp	si,4000h
	jb	Blt2
	mov	dx,-2000h
ELSE	;!ERICSSONCSD
	mov	dx,2000h
	cmp	di,si
	jb	@F
	neg	dx			;blt backward
	cmp	si,2000h
	ja 	Blt2
	mov	dx,6000h - 80
	jmp short Blt2
@@:
	cmp	si,6000h		;blt foreward
	jb	Blt2
	mov	dx,80 - 6000h 
ENDIF	;ERICSSONCSD
Blt2:
	add	si,dx			;go to next row
	add	di,dx
	loop	Blt1

	cld				;clear direction flag

cEnd	BltArcCsd

ENDIF	;!GENIUSCSD



NonStandard	GetCharMapCsd

;********** GetCharMapCsd **********
;*	entry:	pinft, ch, pbitmap
;*	* copy character bit map into buffer

cProc	GetCharMapCsd, <FAR, ATOMIC, PUBLIC>, <DS,SI,DI>
    parmDP pinft
    parmB  char
    parmDP pbitmap    
cBegin	GetCharMapCsd
	mov	di,pinft			;* ds:di => INFT
	xor	ch,ch
	mov	cl,ds:[di].dyCharInft
	mov	al,char
	cmp	cl,16
	jne	@F
IFDEF	T3100CSD
	mov	dx,segROM			;8x16
	mov	ds,dx
	mov	si,T3100_Font_Off
ELSE	;!T3100CSD
	mov	dx,cs				;8x16
	mov	ds,dx
	mov	si,drvOffset rgbVectFont8x16
ENDIF	;T3100CSD
	jmp short RetFonts
@@:
	cmp	al,128
	jb	@F
	sub	al,128
	mov	dx,cs
	mov	ds,dx
	mov	si,drvOffset rgbCGAExFont8x8	;see cga8x8.inc
	jmp short RetFonts
@@:
	mov	dx,0F000h
	mov	ds,dx
	mov	si,0FA6Eh
RetFonts:
	mul	cl
	add	si,ax				;ds:si => character bit map		

	mov	ax,ss
	mov	es,ax
	mov	di,pbitmap			;es:di => destination
	rep	movsb
	
cEnd	GetCharMapCsd



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\tandy.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	tandy.asm : Tandy 1000 CSD
;*
;*****************************************************************************

	TANDYCSD = 1		;see update1.asm

	include	csd_head.inc
	include	csd_data.inc

;*****************************************************************************

	include	csd_code.asm			;* first part of code


;*	* Display modes table
rgdm:

;* #0 - standard color mode 
	DB	0ffh
	DB	0ffh
	DB	3				;* mode
	DW	finstText			;* flags
	DB	80, 25				;* screen size
	DB	16				;* coMac
	DB	8, 8, 0, 0			;* INFT (size unknown)
	DW	0B800H				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved
	Assert	<($-rgdm) EQ SIZE DM>

;* #1 - mono graphics text 
	DB	0ffh
	DB	0ffh
	DB	6				;* mode
	DW	finstGraphics or finstFont OR finstMonochrome or finstFastScroll
	DB	80, 25				;* screen size
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved

;* #2 - 4-color graphics text 
	DB	0ffh
	DB	0ffh
	DB	0Ah				;* mode
	DW	finstGraphics or finstFont 
	DB	80, 25				;* screen size
	DB	4				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved

cdmMax	equ	($ - rgdm) / (size DM)		;* # of modes

segROM	equ	0F000H

;*****************************************************************************

	include update1.asm		;* finitcsd,doupdatecsd, etc
	include cpfont.asm		;* ChrisPFont with 8x8 only

;*****************************************************************************


	include	csd_std.asm		;* standard init/term
	include	csd_ibm.asm		;* IBM specific routines

;*****************************************************************************

	include	csd_vram.asm		;* default procs for direct video I/O
	include	csd_save.asm		;* default screen save (none)

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************


	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\vect8x16.inc ===
;-----------------------------------------------------------;
	;							    ;
	;  HP Vectra RAM Charcter Set.	8 x 16 System Font	    ;
	;							    ;
	;	     ASCII Character Set (000-255)		    ;
	;							    ;
	;-----------------------------------------------------------;

rgbVectFont8x16:	
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H		; 0
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 07EH, 081H, 0A5H, 081H, 081H, 0BDH		; 1
	DB	099H, 081H, 07EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 07EH, 0FFH, 0DBH, 0FFH, 0FFH, 0C3H
	DB	0E7H, 0FFH, 07EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 036H, 07FH, 07FH, 07FH, 07FH
	DB	03EH, 01CH, 008H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 008H, 01CH, 03EH, 07FH, 03EH
	DB	01CH, 008H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 01CH, 01CH, 008H, 06BH, 07FH, 06BH
	DB	008H, 01CH, 01CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 008H, 01CH, 03EH, 07FH, 07FH, 03EH
	DB	008H, 01CH, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 018H, 03CH, 03CH
	DB	018H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0E7H, 0C3H, 0C3H
	DB	0E7H, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 000H, 000H
	DB	000H, 000H, 000H, 000H, 03CH, 066H, 042H, 042H
	DB	066H, 03CH, 000H, 000H, 000H, 000H, 000H, 000H
	DB	0FFH, 0FFH, 0FFH, 0FFH, 0C3H, 099H, 0BDH, 0BDH		; 10
	DB	099H, 0C3H, 0FFH, 0FFH, 0FFH, 0FFH, 000H, 000H
	DB	000H, 000H, 00FH, 007H, 00DH, 018H, 03CH, 066H
	DB	066H, 03CH, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03CH, 066H, 066H, 066H, 03CH, 018H
	DB	07EH, 018H, 018H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03FH, 033H, 03FH, 030H, 030H, 030H
	DB	070H, 0F0H, 0E0H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03FH, 033H, 03FH, 033H, 033H, 033H
	DB	037H, 077H, 076H, 060H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 018H, 018H, 0DBH, 03CH, 0E7H, 03CH
	DB	0DBH, 018H, 018H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 040H, 060H, 070H, 07CH, 07FH, 07CH
	DB	070H, 060H, 040H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 001H, 003H, 007H, 01FH, 07FH, 01FH
	DB	007H, 003H, 001H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 018H, 03CH, 07EH, 018H, 018H, 018H
	DB	07EH, 03CH, 018H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 066H, 066H, 066H, 066H, 066H, 066H
	DB	000H, 066H, 066H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03FH, 06BH, 06BH, 06BH, 03BH, 01BH		; 20
	DB	01BH, 01BH, 01BH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 03EH, 063H, 030H, 01CH, 036H, 063H, 063H		; 21
	DB	036H, 01CH, 006H, 063H, 03EH, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	07FH, 07FH, 07FH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 018H, 03CH, 07EH, 018H, 018H, 018H
	DB	07EH, 03CH, 018H, 07EH, 000H, 000H, 000H, 000H
	DB	000H, 000H, 018H, 03CH, 07EH, 018H, 018H, 018H
	DB	018H, 018H, 018H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 018H, 018H, 018H, 018H, 018H, 018H
	DB	07EH, 03CH, 018H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 00CH, 006H, 07FH, 006H
	DB	00CH, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 018H, 030H, 07FH, 030H
	DB	018H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 060H, 060H, 060H
	DB	07FH, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 014H, 036H, 07FH, 036H
	DB	014H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 008H, 01CH, 01CH, 03EH, 03EH		; 30
	DB	07FH, 07FH, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 07FH, 07FH, 03EH, 03EH, 01CH
	DB	01CH, 008H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 018H, 03CH, 03CH, 03CH, 018H, 018H
	DB	000H, 018H, 018H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 066H, 066H, 066H, 024H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 036H, 036H, 07FH, 036H, 036H, 036H
	DB	07FH, 036H, 036H, 000H, 000H, 000H, 000H, 000H
	DB	00CH, 00CH, 03EH, 063H, 061H, 060H, 03EH, 003H
	DB	043H, 063H, 03EH, 00CH, 00CH, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 061H, 063H, 006H, 00CH
	DB	018H, 033H, 063H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 01CH, 036H, 036H, 01CH, 03BH, 06EH
	DB	066H, 066H, 03BH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 018H, 018H, 018H, 030H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 00CH, 018H, 030H, 030H, 030H, 030H		; 40
	DB	030H, 018H, 00CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 030H, 018H, 00CH, 00CH, 00CH, 00CH
	DB	00CH, 018H, 030H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 036H, 01CH, 07FH, 01CH
	DB	036H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 018H, 018H, 07EH, 018H
	DB	018H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H		; 44
	DB	00CH, 00CH, 00CH, 018H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 07FH, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 00CH, 00CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 001H, 003H, 006H, 00CH, 018H, 030H		; 47
	DB	060H, 040H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03EH, 063H, 067H, 06FH, 07BH, 073H		; 48 0
	DB	063H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 018H, 038H, 078H, 018H, 018H, 018H		; 49
	DB	018H, 018H, 07EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03EH, 063H, 003H, 006H, 00CH, 018H		; 50
	DB	030H, 063H, 07FH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03EH, 063H, 003H, 003H, 01EH, 003H		; 51
	DB	003H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 006H, 00EH, 01EH, 036H, 066H, 07FH
	DB	006H, 006H, 00FH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 07FH, 060H, 060H, 060H, 07EH, 003H
	DB	003H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 01EH, 030H, 060H, 060H, 07EH, 063H
	DB	063H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 07FH, 063H, 003H, 006H, 00CH, 018H
	DB	018H, 018H, 018H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03EH, 063H, 063H, 063H, 03EH, 063H
	DB	063H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03EH, 063H, 063H, 063H, 03FH, 003H
	DB	003H, 006H, 03CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 00CH, 00CH, 000H, 000H, 000H
	DB	00CH, 00CH, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 00CH, 00CH, 000H, 000H, 000H
	DB	00CH, 00CH, 018H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 006H, 00CH, 018H, 030H, 060H, 030H		; 60
	DB	018H, 00CH, 006H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 07EH, 000H, 000H		; 61
	DB	07EH, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 060H, 030H, 018H, 00CH, 006H, 00CH
	DB	018H, 030H, 060H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03EH, 063H, 063H, 006H, 00CH, 00CH
	DB	000H, 00CH, 00CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03EH, 063H, 063H, 06FH, 06FH, 06FH
	DB	06EH, 060H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 008H, 01CH, 036H, 063H, 063H, 07FH		; 65
	DB	063H, 063H, 063H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 07EH, 033H, 033H, 033H, 03EH, 033H
	DB	033H, 033H, 07EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 01EH, 033H, 061H, 060H, 060H, 060H
	DB	061H, 033H, 01EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 07CH, 036H, 033H, 033H, 033H, 033H
	DB	033H, 036H, 07CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 07FH, 033H, 031H, 034H, 03CH, 034H
	DB	031H, 033H, 07FH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 07FH, 033H, 031H, 034H, 03CH, 034H		; 70
	DB	030H, 030H, 078H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 01EH, 033H, 061H, 060H, 060H, 06FH
	DB	063H, 033H, 01DH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 063H, 063H, 063H, 063H, 07FH, 063H
	DB	063H, 063H, 063H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03CH, 018H, 018H, 018H, 018H, 018H		; 73
	DB	018H, 018H, 03CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 00FH, 006H, 006H, 006H, 006H, 006H
	DB	066H, 066H, 03CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 073H, 033H, 033H, 036H, 03CH, 036H
	DB	033H, 033H, 073H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 078H, 030H, 030H, 030H, 030H, 030H
	DB	031H, 033H, 07FH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 063H, 077H, 07FH, 07FH, 06BH, 063H
	DB	063H, 063H, 063H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 063H, 073H, 07BH, 07FH, 06FH, 067H
	DB	063H, 063H, 063H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 01CH, 036H, 063H, 063H, 063H, 063H
	DB	063H, 036H, 01CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 07EH, 033H, 033H, 033H, 03EH, 030H		; 80
	DB	030H, 030H, 078H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03EH, 063H, 063H, 063H, 063H, 063H
	DB	06BH, 06FH, 03EH, 006H, 007H, 000H, 000H, 000H
	DB	000H, 000H, 07EH, 033H, 033H, 033H, 03EH, 036H
	DB	033H, 033H, 073H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03EH, 063H, 063H, 030H, 01CH, 006H
	DB	063H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 07EH, 07EH, 05AH, 018H, 018H, 018H
	DB	018H, 018H, 03CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 063H, 063H, 063H, 063H, 063H, 063H		; 85
	DB	063H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 063H, 063H, 063H, 063H, 063H, 063H
	DB	036H, 01CH, 008H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 063H, 063H, 063H, 063H, 06BH, 06BH
	DB	07FH, 03EH, 036H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 063H, 063H, 036H, 01CH, 01CH, 01CH
	DB	036H, 063H, 063H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 066H, 066H, 066H, 066H, 03CH, 018H
	DB	018H, 018H, 03CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 07FH, 063H, 046H, 00CH, 018H, 030H		; 90
	DB	061H, 063H, 07FH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03CH, 030H, 030H, 030H, 030H, 030H
	DB	030H, 030H, 03CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 040H, 060H, 070H, 038H, 01CH, 00EH
	DB	007H, 003H, 001H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03CH, 00CH, 00CH, 00CH, 00CH, 00CH
	DB	00CH, 00CH, 03CH, 000H, 000H, 000H, 000H, 000H
	DB	008H, 01CH, 036H, 063H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H		; 95
	DB	000H, 000H, 000H, 000H, 0FFH, 000H, 000H, 000H
	DB	018H, 018H, 00CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 03CH, 006H, 03EH
	DB	066H, 066H, 03BH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 070H, 030H, 030H, 03EH, 033H, 033H
	DB	033H, 033H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 03EH, 063H, 060H
	DB	060H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 00EH, 006H, 006H, 03EH, 066H, 066H		; 100
	DB	066H, 066H, 03BH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 03EH, 063H, 07FH
	DB	060H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 01CH, 036H, 032H, 030H, 078H, 030H
	DB	030H, 030H, 078H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 03BH, 066H, 066H
	DB	066H, 066H, 03EH, 006H, 066H, 03CH, 000H, 000H
	DB	000H, 000H, 070H, 030H, 030H, 036H, 03BH, 033H
	DB	033H, 033H, 073H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 018H, 018H, 000H, 038H, 018H, 018H
	DB	018H, 018H, 03CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 006H, 006H, 000H, 00EH, 006H, 006H
	DB	006H, 006H, 006H, 066H, 066H, 03CH, 000H, 000H
	DB	000H, 000H, 070H, 030H, 030H, 033H, 036H, 03CH
	DB	036H, 033H, 073H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 038H, 018H, 018H, 018H, 018H, 018H
	DB	018H, 018H, 03CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 076H, 07FH, 06BH
	DB	06BH, 06BH, 063H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 06EH, 033H, 033H		; 110
	DB	033H, 033H, 033H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 03EH, 063H, 063H		; 111
	DB	063H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 06EH, 033H, 033H
	DB	033H, 033H, 03EH, 030H, 030H, 078H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 03BH, 066H, 066H
	DB	066H, 066H, 03EH, 006H, 006H, 00FH, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 06EH, 03BH, 033H
	DB	030H, 030H, 078H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 03EH, 063H, 038H
	DB	00EH, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 008H, 018H, 018H, 07EH, 018H, 018H
	DB	018H, 01BH, 00EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 066H, 066H, 066H
	DB	066H, 066H, 03BH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 066H, 066H, 066H
	DB	066H, 03CH, 018H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 063H, 063H, 06BH
	DB	06BH, 07FH, 036H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 063H, 036H, 01CH		; 120
	DB	01CH, 036H, 063H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 063H, 063H, 063H
	DB	063H, 063H, 03FH, 003H, 006H, 07CH, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 07FH, 066H, 00CH
	DB	018H, 033H, 07FH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 00EH, 018H, 018H, 018H, 070H, 018H
	DB	018H, 018H, 00EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 018H, 018H, 018H, 018H, 000H, 018H		; 124
	DB	018H, 018H, 018H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 070H, 018H, 018H, 018H, 00EH, 018H
	DB	018H, 018H, 070H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03BH, 06EH, 000H, 000H, 000H, 000H		; 126
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 008H, 01CH, 036H, 063H		; 127
	DB	063H, 07FH, 000H, 000H, 000H, 000H, 000H, 000H

rgbVectExFont8x16:
	DB	000H, 000H, 01EH, 033H, 061H, 060H, 060H, 060H		; 128
	DB	061H, 033H, 01EH, 00CH, 00CH, 03CH, 000H, 000H
	DB	000H, 000H, 066H, 066H, 000H, 066H, 066H, 066H		; 129
	DB	066H, 066H, 03BH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 00CH, 018H, 000H, 03EH, 063H, 07FH		; 130
	DB	060H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 01CH, 036H, 000H, 03CH, 006H, 03EH		; 131
	DB	066H, 066H, 03BH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 066H, 066H, 000H, 03CH, 006H, 03EH		; 132
	DB	066H, 066H, 03BH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 018H, 00CH, 000H, 03CH, 006H, 03EH		; 133
	DB	066H, 066H, 03BH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 01CH, 036H, 01CH, 03CH, 006H, 03EH		; 134
	DB	066H, 066H, 03BH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 03CH, 066H, 060H		; 135
	DB	060H, 066H, 03CH, 018H, 018H, 038H, 000H, 000H
	DB	000H, 000H, 01CH, 036H, 000H, 03EH, 063H, 07FH		; 136
	DB	060H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 063H, 063H, 000H, 03EH, 063H, 07FH		; 137
	DB	060H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 018H, 00CH, 000H, 03EH, 063H, 07FH		; 138
	DB	060H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 066H, 066H, 000H, 038H, 018H, 018H		; 139
	DB	018H, 018H, 03CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 038H, 06CH, 000H, 038H, 018H, 018H		; 140
	DB	018H, 018H, 03CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 030H, 018H, 000H, 038H, 018H, 018H		; 141
	DB	018H, 018H, 03CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 063H, 063H, 008H, 01CH, 036H, 063H, 063H		; 142
	DB	07FH, 063H, 063H, 000H, 000H, 000H, 000H, 000H
	DB	01CH, 036H, 01CH, 000H, 008H, 01CH, 036H, 063H		; 143
	DB	07FH, 063H, 063H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 00CH, 018H, 000H, 07FH, 033H, 030H, 03EH		; 144
	DB	030H, 033H, 07FH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 07EH, 01BH, 01BH, 03FH		; 145
	DB	06CH, 06CH, 037H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03FH, 066H, 066H, 066H, 07FH, 066H		; 146
	DB	066H, 066H, 067H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 01CH, 036H, 000H, 03EH, 063H, 063H		; 147
	DB	063H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 063H, 063H, 000H, 03EH, 063H, 063H		; 148
	DB	063H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 018H, 00CH, 000H, 03EH, 063H, 063H		; 149
	DB	063H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03CH, 066H, 000H, 066H, 066H, 066H		; 150
	DB	066H, 066H, 03BH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 018H, 00CH, 000H, 066H, 066H, 066H		; 151
	DB	066H, 066H, 03BH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 063H, 063H, 000H, 063H, 063H, 063H		; 152
	DB	063H, 063H, 03FH, 003H, 006H, 03CH, 000H, 000H
	DB	000H, 063H, 063H, 01CH, 036H, 063H, 063H, 063H		; 153 
	DB	063H, 036H, 01CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 063H, 063H, 000H, 063H, 063H, 063H, 063H		; 154
	DB	063H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 018H, 018H, 03CH, 066H, 060H, 060H, 066H		; 155 
	DB	03CH, 018H, 018H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 01CH, 036H, 032H, 030H, 078H, 030H, 030H		; 156
	DB	030H, 073H, 07EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 066H, 066H, 066H, 03CH, 018H, 07EH, 018H		; 157 
	DB	07EH, 018H, 018H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 07CH, 066H, 066H, 07CH, 062H, 066H, 06FH		; 158 
	DB	066H, 066H, 063H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 007H, 00CH, 00CH, 00CH, 00CH, 03FH, 00CH		; 159
	DB	00CH, 00CH, 00CH, 06CH, 038H, 000H, 000H, 000H
	DB	000H, 000H, 00CH, 018H, 000H, 03CH, 006H, 03EH		; 160
	DB	066H, 066H, 03BH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 00CH, 018H, 000H, 038H, 018H, 018H		; 161
	DB	018H, 018H, 03CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 00CH, 018H, 000H, 03EH, 063H, 063H		; 162
	DB	063H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 00CH, 018H, 000H, 066H, 066H, 066H		; 163
	DB	066H, 066H, 03BH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 03BH, 06EH, 000H, 06EH, 033H, 033H		; 164
	DB	033H, 033H, 033H, 000H, 000H, 000H, 000H, 000H
	DB	03BH, 06EH, 000H, 063H, 073H, 07BH, 07FH, 06FH		; 165
	DB	067H, 063H, 063H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 03CH, 06CH, 06CH, 03EH, 000H, 07EH, 000H		; 166
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 038H, 06CH, 06CH, 038H, 000H, 07CH, 000H		; 167
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 018H, 018H, 000H, 018H, 018H, 030H		; 168
	DB	063H, 063H, 03EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 07FH, 060H		; 169
	DB	060H, 060H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 07FH, 003H		; 170
	DB	003H, 003H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 060H, 060H, 063H, 066H, 06CH, 018H, 030H		; 171 1/2
	DB	06EH, 043H, 006H, 00CH, 01FH, 000H, 000H, 000H
	DB	000H, 060H, 060H, 063H, 066H, 06CH, 018H, 033H		; 172 1/4
	DB	067H, 04FH, 01FH, 003H, 003H, 000H, 000H, 000H
	DB	000H, 000H, 018H, 018H, 000H, 018H, 018H, 03CH		; 173
	DB	03CH, 03CH, 018H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 01BH, 036H, 06CH, 036H		; 174
	DB	01BH, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 06CH, 036H, 01BH, 036H		; 175
	DB	06CH, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	011H, 044H, 011H, 044H, 011H, 044H, 011H, 044H		; 176
	DB	011H, 044H, 011H, 044H, 011H, 044H, 011H, 044H
	DB	055H, 0AAH, 055H, 0AAH, 055H, 0AAH, 055H, 0AAH		; 177
	DB	055H, 0AAH, 055H, 0AAH, 055H, 0AAH, 055H, 0AAH
	DB	0DDH, 077H, 0DDH, 077H, 0DDH, 077H, 0DDH, 077H		; 178
	DB	0DDH, 077H, 0DDH, 077H, 0DDH, 077H, 0DDH, 077H
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H		; 179
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 0F8H		; 180
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H
	DB	018H, 018H, 018H, 018H, 018H, 0F8H, 018H, 0F8H		; 181
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 0F6H		; 182
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 0FEH		; 183
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H
	DB	000H, 000H, 000H, 000H, 000H, 0F8H, 018H, 0F8H		; 184
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H
	DB	036H, 036H, 036H, 036H, 036H, 0F6H, 006H, 0F6H		; 185
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H		; 186
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H
	DB	000H, 000H, 000H, 000H, 000H, 0FEH, 006H, 0F6H		; 187
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H
	DB	036H, 036H, 036H, 036H, 036H, 0F6H, 006H, 0FEH		; 188
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 0FEH		; 189
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	018H, 018H, 018H, 018H, 018H, 0F8H, 018H, 0F8H		; 190
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 0F8H		; 191
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 01FH		; 192
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 0FFH		; 193
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 0FFH		; 194
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 01FH		; 195
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 0FFH		; 196
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 0FFH		; 197
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H
	DB	018H, 018H, 018H, 018H, 018H, 01FH, 018H, 01FH		; 198
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 037H		; 199
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H
	DB	036H, 036H, 036H, 036H, 036H, 037H, 030H, 03FH		; 200
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 03FH, 030H, 037H		; 201
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H
	DB	036H, 036H, 036H, 036H, 036H, 0F7H, 000H, 0FFH		; 202
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 0FFH, 000H, 0F7H		; 203
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H
	DB	036H, 036H, 036H, 036H, 036H, 037H, 030H, 037H		; 204
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H
	DB	000H, 000H, 000H, 000H, 000H, 0FFH, 000H, 0FFH		; 205
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	036H, 036H, 036H, 036H, 036H, 0F7H, 000H, 0F7H		; 206
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H
	DB	018H, 018H, 018H, 018H, 018H, 0FFH, 000H, 0FFH		; 207
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 0FFH		; 208
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 0FFH, 000H, 0FFH		; 209
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 0FFH		; 210
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 03FH		; 211
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	018H, 018H, 018H, 018H, 018H, 01FH, 018H, 01FH		; 212
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 01FH, 018H, 01FH		; 213
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 03FH		; 214
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 0FFH		; 215
	DB	036H, 036H, 036H, 036H, 036H, 036H, 036H, 036H
	DB	018H, 018H, 018H, 018H, 018H, 0FFH, 018H, 0FFH		; 216
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 0F8H		; 217
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 01FH		; 218
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H
	DB	0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH		; 219
	DB	0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 0FFH		; 220
	DB	0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH
	DB	0F0H, 0F0H, 0F0H, 0F0H, 0F0H, 0F0H, 0F0H, 0F0H		; 221
	DB	0F0H, 0F0H, 0F0H, 0F0H, 0F0H, 0F0H, 0F0H, 0F0H
	DB	00FH, 00FH, 00FH, 00FH, 00FH, 00FH, 00FH, 00FH		; 222
	DB	00FH, 00FH, 00FH, 00FH, 00FH, 00FH, 00FH, 00FH
	DB	0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 0FFH, 000H		; 223
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 03BH, 06EH, 06CH		; 224
	DB	06CH, 06EH, 03BH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 03EH, 063H, 07EH		; 225
	DB	063H, 063H, 07EH, 060H, 060H, 020H, 000H, 000H
	DB	000H, 000H, 07FH, 063H, 063H, 060H, 060H, 060H		; 226
	DB	060H, 060H, 060H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 07FH, 036H, 036H, 036H		; 227
	DB	036H, 036H, 036H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 07FH, 063H, 030H, 018H, 00CH, 018H		; 228
	DB	030H, 063H, 07FH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 03FH, 06CH, 06CH		; 229
	DB	06CH, 06CH, 038H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 033H, 033H		; 230
	DB	033H, 033H, 03EH, 030H, 030H, 060H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 03BH, 06EH, 00CH, 00CH		; 231
	DB	00CH, 00CH, 00CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 07EH, 018H, 03CH, 066H, 066H, 066H		; 232
	DB	03CH, 018H, 07EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 01CH, 036H, 063H, 063H, 07FH, 063H		; 233
	DB	063H, 036H, 01CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 01CH, 036H, 063H, 063H, 063H, 036H		; 234
	DB	036H, 036H, 077H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 01EH, 030H, 018H, 00CH, 03EH, 066H		; 235
	DB	066H, 066H, 03CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 07EH, 0DBH, 0DBH		; 236
	DB	07EH, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 003H, 006H, 07EH, 0DBH, 0DBH, 0F3H		; 237
	DB	07EH, 060H, 0C0H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 00EH, 018H, 030H, 030H, 03EH, 030H		; 238
	DB	030H, 018H, 00EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 03EH, 063H, 063H, 063H, 063H		; 239
	DB	063H, 063H, 063H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 07FH, 000H, 000H, 07FH, 000H		; 240
	DB	000H, 07FH, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 018H, 018H, 07EH, 018H, 018H		; 241
	DB	000H, 000H, 07EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 030H, 018H, 00CH, 006H, 00CH, 018H		; 242
	DB	030H, 000H, 07EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 00CH, 018H, 030H, 060H, 030H, 018H		; 243
	DB	00CH, 000H, 07EH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 00EH, 01BH, 01BH, 018H, 018H, 018H		; 244
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H
	DB	018H, 018H, 018H, 018H, 018H, 018H, 018H, 018H		; 245
	DB	0D8H, 0D8H, 070H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 018H, 018H, 000H, 07EH, 000H		; 246
	DB	018H, 018H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 03BH, 06EH, 000H, 03BH		; 247
	DB	06EH, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 01CH, 036H, 036H, 01CH, 000H, 000H, 000H		; 248
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 018H, 018H		; 249
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 018H		; 250
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 00FH, 00CH, 00CH, 00CH, 00CH, 00CH, 0ECH		; 251
	DB	06CH, 03CH, 01CH, 000H, 000H, 000H, 000H, 000H
	DB	000H, 06CH, 036H, 036H, 036H, 036H, 036H, 000H		; 252
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 01CH, 036H, 00CH, 018H, 032H, 03EH, 000H		; 253
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 03EH, 03EH, 03EH, 03EH		; 254
	DB	03EH, 03EH, 000H, 000H, 000H, 000H, 000H, 000H
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H		; 255
	DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\vga.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	vga.asm : VGA CSD
;*
;*****************************************************************************

	MDACSD = 0
	CGACSD = 0
	EGACSD = 0
	MCGACSD = 0
	VGACSD = 1

	GRAPHICSTEXT = 1

	CPF814 = 1
	CPF816 = 1

	include	ibmfont.asm


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\vectra.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	Vectra.asm : HP Vectra CSD
;*
;*****************************************************************************

	include	csd_head.inc
	include	csd_data.inc

;*****************************************************************************

	include	csd_code.asm			;* first part of code

;*	* Display modes table
rgdm:

;* #0 - standard color mode
	DB	0ffh				;* any
	DB	0ffh				;* any
	DB	3				;* mode
	DW	finstText			;* flags
	DB	80, 25				;* screen size
	DB	16				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0B800H				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved
	Assert	<($-rgdm) EQ SIZE DM>

;* #1 - 25 line Graphics text mode (mono)
	DB	0ffh				;* any
	DB	0ffh				;* any
	DB	5				;* mode
	DW	finstGraphics OR finstFont OR finstMonoChrome or finstFastScroll ;* flags
	DB	80, 25				;* screen size
	DB	2				;* coMac
	DB	8, 16, 0, 0			;* INFT
	DW	0				;* video address
	DW	0E0FH				;* cursor
	DW	0				;* reserved

;* #2 - 50 line Graphics text mode (mono)
	DB	0ffh				;* any
	DB	0ffh				;* any
	DB	5				;* mode
	DW	finstGraphics OR finstFont OR finstMonoChrome or finstFastScroll ;* flags
	DB	80, 50				;* screen size
	DB	2				;* coMac
	DB	8, 8, 0, 0			;* INFT
	DW	0				;* video address
	DW	0607H				;* cursor
	DW	0				;* reserved

cdmMax	equ	($ - rgdm) / (size DM)		;* # of modes

;*****************************************************************************
;*	* Special routines

NonStandard	ModeGetCur
NonStandard	FInitCsd

;*****************************************************************************

;********** ModeGetCur *********
;*	entry:	n/a
;*	* get current machine mode
;*	exit:	al = mode, ah = ayMac (or 0 if unknown)

cProc	ModeGetCur, <NEAR, PUBLIC, ATOMIC>, <ES>
cBegin	ModeGetCur

	mov	ax,40H
	mov	es,ax
	mov	dl,es:[0084H]		;* read BIOS rows
	inc	dl			;* dl = screen height
	cmp	dl,25			;do this since some clones don't
	je	@F			;update BIOS data
	cmp	dl,50
	je	@F
	mov	dl,25			;* default to 25 rows
@@:	
	push	bx
	mov	ah,0fh
	int	10h			;* get current state, return al = mode
	and	al,7Fh			;* mask off clear video buffer bit.
	pop	bx
	cmp	al,3			;text mode ?
	je	@F
	mov	al,5			;set graphics mode
@@:
	mov	ah,dl

cEnd	ModeGetCur




;********** FInitCsd **********
;*	* CSD entry point (see documentation for interface)
;*	* Initialize the screen to the given mode
;*	exit:	AX != 0 if ok

cProc	FInitCsd, <FAR, PUBLIC, ATOMIC>, <DI>
    parmDP pinst
    parmDP pinch
cBegin	FInitCsd

	mov	di,OFF_lpwDataCsd		;* Data in data segment

;*	* set mode
	mov	bx,pinst
	mov	[di].pinstDrv,bx
	mov	bx,ds:[bx].pdmInst		;* CS:BX => DM info

;*	* copy mode info into driver globals
	mov	ax,cs:[bx].vparmCursOnDm
	mov	[di].vparmCursOn,ax
	mov	[di].vparmCursSize,ax
	mov	ax,cs:[bx].wExtraDm
	mov	[di].wExtra,ax

	cCall	ModeGetCur			;* al = mode, ah = ayMac

	mov	cx,40H
	mov	es,cx
	mov	cl,cs:[bx].ayMacDm
	dec	cl				; rows - 1
	mov	byte ptr es:[0084H],cl		;* update BIOS rows

	test	cs:[bx].finstDm,finstGraphics
	jz	InitText

	xor	ch,ch	
	mov	cl,cs:[bx].dyCharDm
	mov	[di].ayBox,cx			;* points
	cmp	cx,8
	je	@F

	mov	[di].SEG_lpbFont,cs				;8x16 font
	mov	[di].OFF_lpbFont,drvOffset rgbVectFont8x16
	jmp short font1
@@:
	mov	[di].SEG_lpbFont,0F000h		;8x8 font (first 128)
	mov	[di].OFF_lpbFont,0FA6Eh
font1:	
	mov	ax,6F05h			;* set mode
	mov	bl,0Dh
	int	10h
	jmp	short InitDone

InitText:	
	cmp	al,cs:[bx].modeDm
	je	@F				;* don't reset

	mov	al,cs:[bx].modeDm
	xor	ah,ah				;* set mode
	int	10h				;* set mode
@@:

;*	* the INCH array already contains the standard Code Page 437
;*	*  character set, so it usually can be left the same.

;*	* Do other diddling
	cCall	DiddleBlinkBit

InitDone:
	mov	ax,sp				;* success
cEnd	FInitCsd

;*****************************************************************************

	VECTRACSD = 1
	include update2.asm
	include	vect8x16.inc		;* hard code font table

;*****************************************************************************

	include	csd_std.asm		;* standard init/term
	include	csd_ibm.asm		;* IBM specific routines

;*****************************************************************************

	include	csd_vram.asm		;* default procs for direct video I/O
	include	csd_save.asm		;* default screen save (none)

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************


	END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\csd\src\vio.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	vio.asm : VIO safe OS/2 installable driver (T+G text)
;*****************************************************************************

	include	csd_head.inc

DM_NonDefault = 1
SDDATA_NonDefault = 1
	include	csd_data.inc		;* standard data

	include scr5.inc
	include scr5data.inc

;*****************************************************************************

	include	csd_code.asm

;*****************************************************************************
					
	GRAPHICSTEXT = 1		;* include graphcis text code
	include scr5.asm		;* scr5.asm + graphcis text
	include csd_std.asm
	include csd_vram.asm
	include csd_save.asm

;*****************************************************************************

	include	csd_tail.asm		;* tail file

;*****************************************************************************

	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\inc\ingxd.inc ===
xGpt		equ	[word ptr 00000h]
yGpt		equ	[word ptr 00002h]
cbGptMin	equ	00004h

xLeftRect	equ	[word ptr 00000h]
yTopRect	equ	[word ptr 00002h]
xRightRect	equ	[word ptr 00004h]
yBottomRect	equ	[word ptr 00006h]
cbRectMin	equ	00008h

cbPolygon	equ	[word ptr 00000h]
rectBoundPolygon	equ	[00002h]
rggptPolygon	equ	[dword ptr 0000Ah]
LO_rggptPolygon	equ	[word ptr 0000Ah]
HI_rggptPolygon	equ	[word ptr 0000Ch]
cbPolygonMin	equ	0000Eh
cpenMax		equ	41
icoMax		equ	41

fingdIngd	equ	[word ptr 00000h]
reserved2Ingd	equ	[word ptr 00002h]
fingpSupportedIngd	equ	[word ptr 00004h]
dimHIngd	equ	[word ptr 00006h]
dimVIngd	equ	[word ptr 00008h]
dxScreenIngd	equ	[word ptr 0000Ah]
dyScreenIngd	equ	[word ptr 0000Ch]
dimPenHIngd	equ	[word ptr 0000Eh]
dimPenVIngd	equ	[word ptr 00010h]
cpenIngd	equ	[byte ptr 00012h]
icoAvailMacIngd	equ	[byte ptr 00013h]
icoPrefMacIngd	equ	[byte ptr 00014h]
ipaLineMacIngd	equ	[byte ptr 00015h]
ipaAreaMacIngd	equ	[byte ptr 00016h]
ccoplnIngd	equ	[byte ptr 00017h]
rgcoAvailIngd	equ	[00018h]
rgcoPrefIngd	equ	[0006Ah]
rgpaLineIngd	equ	[000BCh]
rgpaAreaIngd	equ	[000C1h]
szNameIngd	equ	[000D1h]
cbIngdMin	equ	000FAh
fingdRstrVctr	equ	00004h
fingdRasterFonts	equ	00040h
fingdMultiColor	equ	00100h
fingdVirtualPen	equ	00200h
fingdFilm	equ	00400h
fingdVarPenSize	equ	01000h
fingdNotAvailable	equ	08000h
fingpSetAreaPat	equ	00001h
fingpSetLinePat	equ	00002h
fingpSetLineWeight	equ	00004h
fingpSetColor	equ	00008h
fingpText	equ	00010h
fingpRectangle	equ	00020h
fingpArc	equ	00040h
fingpPolygon	equ	00080h
fingpBitBlt	equ	00100h

pfnFInitGraphicsIndj	equ	[dword ptr 00000h]
OFF_pfnFInitGraphicsIndj	equ	[word ptr 00000h]
SEG_pfnFInitGraphicsIndj	equ	[word ptr 00002h]
pfnTermGraphicsIndj	equ	[dword ptr 00004h]
OFF_pfnTermGraphicsIndj	equ	[word ptr 00004h]
SEG_pfnTermGraphicsIndj	equ	[word ptr 00006h]
pfnMoveIndj	equ	[dword ptr 00008h]
OFF_pfnMoveIndj	equ	[word ptr 00008h]
SEG_pfnMoveIndj	equ	[word ptr 0000Ah]
pfnDrawIndj	equ	[dword ptr 0000Ch]
OFF_pfnDrawIndj	equ	[word ptr 0000Ch]
SEG_pfnDrawIndj	equ	[word ptr 0000Eh]
pfnSetAreaPatIndj	equ	[dword ptr 00010h]
OFF_pfnSetAreaPatIndj	equ	[word ptr 00010h]
SEG_pfnSetAreaPatIndj	equ	[word ptr 00012h]
pfnSetLinePatIndj	equ	[dword ptr 00014h]
OFF_pfnSetLinePatIndj	equ	[word ptr 00014h]
SEG_pfnSetLinePatIndj	equ	[word ptr 00016h]
pfnSetLineWeightIndj	equ	[dword ptr 00018h]
OFF_pfnSetLineWeightIndj	equ	[word ptr 00018h]
SEG_pfnSetLineWeightIndj	equ	[word ptr 0001Ah]
pfnSetColorIndj	equ	[dword ptr 0001Ch]
OFF_pfnSetColorIndj	equ	[word ptr 0001Ch]
SEG_pfnSetColorIndj	equ	[word ptr 0001Eh]
pfnTextIndj	equ	[dword ptr 00020h]
OFF_pfnTextIndj	equ	[word ptr 00020h]
SEG_pfnTextIndj	equ	[word ptr 00022h]
pfnRectangleIndj	equ	[dword ptr 00024h]
OFF_pfnRectangleIndj	equ	[word ptr 00024h]
SEG_pfnRectangleIndj	equ	[word ptr 00026h]
pfnArcIndj	equ	[dword ptr 00028h]
OFF_pfnArcIndj	equ	[word ptr 00028h]
SEG_pfnArcIndj	equ	[word ptr 0002Ah]
pfnPolygonIndj	equ	[dword ptr 0002Ch]
OFF_pfnPolygonIndj	equ	[word ptr 0002Ch]
SEG_pfnPolygonIndj	equ	[word ptr 0002Eh]
pfnBitBltIndj	equ	[dword ptr 00030h]
OFF_pfnBitBltIndj	equ	[word ptr 00030h]
SEG_pfnBitBltIndj	equ	[word ptr 00032h]
cbIndjMin	equ	00034h
cpfnGxdMin	equ	13
cpfnGsdMin	equ	cpfnGxdMin
cpfnGpdMin	equ	cpfnGxdMin
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\inc\fxdrv.inc ===
;*
;*	CW : Character Windows
;*
;*	fxdrv.inc : Special Driver stuff for fixed (linked-in) drivers
;*****************************************************************************

;*****************************************************************************

;*	* Create DGROUP
createSeg _DATA,DATA,WORD,PUBLIC,DATA,DGROUP
createSeg _BSS,BSS,WORD,PUBLIC,BSS,DGROUP
defGrp DGROUP,DATA,BSS

;*****************************************************************************

sBegin	DRV
    assumes CS,DRV
    assumes DS,DRV

externW pinos			;* code segment pointer to INOS

sEnd	DRV

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\inc\drv.inc ===
;*
;*	CW : Character Windows
;*
;*	drv.inc : Main Driver Header

;*****************************************************************************

memM = 1
?WIN = 0
?PLM = 1
?TF = 1
?DF = 1
?NODATA = 1

	;* standard macros
	include cmacros.inc
	include std.inc

	;* installable driver interface
	include	indrv.inc

;*****************************************************************************
;* Segments

;* all driver code goes in the DRV segment (use drvOffset for offsets)
createSeg   DRV_FIXED,DRV,WORD,PUBLIC,CODE		;* driver

;*****************************************************************************
;* Misc Macros

;********** NonStandard **********
;*	entry: symbol = symbol to define as non-standard ???_NonDefault

NonStandard	MACRO	symbol
symbol&_NonDefault  = 1
ENDM

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\inc\indrv.inc ===
fmemFixed	equ	1
fmemNear	equ	2
cbNearMemServiceMax	equ	64
indtNil		equ	0
indtKeyboard	equ	1
indtCharacterScreen	equ	2
indtGraphicScreen	equ	3
indtCharacterPrinter	equ	4
indtGraphicPrinter	equ	5
indtSystem	equ	6

indtIndv	equ	[byte ptr 00000h]
fillerIndv	equ	[byte ptr 00001h]
rglpfnIndv	equ	[word ptr 00002h]
cpfnNeedMinIndv	equ	[word ptr 00004h]
cpfnNeedMacIndv	equ	[word ptr 00006h]
psLoadedIndv	equ	[word ptr 00008h]
cpfnLoadedIndv	equ	[word ptr 0000Ah]
cbIndvMin	equ	0000Ch

rgchMagicIndh	equ	[dword ptr 00000h]
LO_rgchMagicIndh	equ	[word ptr 00000h]
HI_rgchMagicIndh	equ	[word ptr 00002h]
dlfaTableIndh	equ	[dword ptr 00004h]
LO_dlfaTableIndh	equ	[word ptr 00004h]
HI_dlfaTableIndh	equ	[word ptr 00006h]
cbIndhMin	equ	00008h

indtInds	equ	[byte ptr 00000h]
floadInds	equ	[byte ptr 00001h]
cbCodeInds	equ	[word ptr 00002h]
dlfaCodeInds	equ	[dword ptr 00004h]
LO_dlfaCodeInds	equ	[word ptr 00004h]
HI_dlfaCodeInds	equ	[word ptr 00006h]
cbIndsMin	equ	00008h

rgchMagicIndt	equ	[dword ptr 00000h]
LO_rgchMagicIndt	equ	[word ptr 00000h]
HI_rgchMagicIndt	equ	[word ptr 00002h]
cindsIndt	equ	[word ptr 00004h]
rgindsIndt	equ	[00006h]
cbIndtMin	equ	0000Eh
floadFixed	equ	1
floadRealMode	equ	00010h
floadProtMode	equ	00020h
floadAnyMode	equ	(floadRealMode or floadProtMode)
floadStandard	equ	00080h

sdGlisInos	equ	[word ptr 00000h]
sdLoisInos	equ	[word ptr 00002h]
cpfnInos	equ	[word ptr 00004h]
lpfnDosGetVersionInos	equ	[dword ptr 00006h]
OFF_lpfnDosGetVersionInos	equ	[word ptr 00006h]
SEG_lpfnDosGetVersionInos	equ	[word ptr 00008h]
lpfnDosGetEnvInos	equ	[dword ptr 0000Ah]
OFF_lpfnDosGetEnvInos	equ	[word ptr 0000Ah]
SEG_lpfnDosGetEnvInos	equ	[word ptr 0000Ch]
lpfnDosDevConfigInos	equ	[dword ptr 0000Eh]
OFF_lpfnDosDevConfigInos	equ	[word ptr 0000Eh]
SEG_lpfnDosDevConfigInos	equ	[word ptr 00010h]
lpfnDosGetCtryInfoInos	equ	[dword ptr 00012h]
OFF_lpfnDosGetCtryInfoInos	equ	[word ptr 00012h]
SEG_lpfnDosGetCtryInfoInos	equ	[word ptr 00014h]
lpfnDosGetDBCSEvInos	equ	[dword ptr 00016h]
OFF_lpfnDosGetDBCSEvInos	equ	[word ptr 00016h]
SEG_lpfnDosGetDBCSEvInos	equ	[word ptr 00018h]
lpfnDosGetInfoSegInos	equ	[dword ptr 0001Ah]
OFF_lpfnDosGetInfoSegInos	equ	[word ptr 0001Ah]
SEG_lpfnDosGetInfoSegInos	equ	[word ptr 0001Ch]
lpfnDosDevIOCtlInos	equ	[dword ptr 0001Eh]
OFF_lpfnDosDevIOCtlInos	equ	[word ptr 0001Eh]
SEG_lpfnDosDevIOCtlInos	equ	[word ptr 00020h]
lpfnDosPortAccessInos	equ	[dword ptr 00022h]
OFF_lpfnDosPortAccessInos	equ	[word ptr 00022h]
SEG_lpfnDosPortAccessInos	equ	[word ptr 00024h]
lpfnDosGetModHandleInos	equ	[dword ptr 00026h]
OFF_lpfnDosGetModHandleInos	equ	[word ptr 00026h]
SEG_lpfnDosGetModHandleInos	equ	[word ptr 00028h]
lpfnDosLoadModuleInos	equ	[dword ptr 0002Ah]
OFF_lpfnDosLoadModuleInos	equ	[word ptr 0002Ah]
SEG_lpfnDosLoadModuleInos	equ	[word ptr 0002Ch]
lpfnDosGetProcAddrInos	equ	[dword ptr 0002Eh]
OFF_lpfnDosGetProcAddrInos	equ	[word ptr 0002Eh]
SEG_lpfnDosGetProcAddrInos	equ	[word ptr 00030h]
lpfnDosCreateThreadInos	equ	[dword ptr 00032h]
OFF_lpfnDosCreateThreadInos	equ	[word ptr 00032h]
SEG_lpfnDosCreateThreadInos	equ	[word ptr 00034h]
lpfnDosSetPrtyInos	equ	[dword ptr 00036h]
OFF_lpfnDosSetPrtyInos	equ	[word ptr 00036h]
SEG_lpfnDosSetPrtyInos	equ	[word ptr 00038h]
lpfnDosExitInos	equ	[dword ptr 0003Ah]
OFF_lpfnDosExitInos	equ	[word ptr 0003Ah]
SEG_lpfnDosExitInos	equ	[word ptr 0003Ch]
lpfnDosOpenInos	equ	[dword ptr 0003Eh]
OFF_lpfnDosOpenInos	equ	[word ptr 0003Eh]
SEG_lpfnDosOpenInos	equ	[word ptr 00040h]
lpfnDosCloseInos	equ	[dword ptr 00042h]
OFF_lpfnDosCloseInos	equ	[word ptr 00042h]
SEG_lpfnDosCloseInos	equ	[word ptr 00044h]
lpfnDosReadInos	equ	[dword ptr 00046h]
OFF_lpfnDosReadInos	equ	[word ptr 00046h]
SEG_lpfnDosReadInos	equ	[word ptr 00048h]
lpfnDosWriteInos	equ	[dword ptr 0004Ah]
OFF_lpfnDosWriteInos	equ	[word ptr 0004Ah]
SEG_lpfnDosWriteInos	equ	[word ptr 0004Ch]
lpfnDosMonOpenInos	equ	[dword ptr 0004Eh]
OFF_lpfnDosMonOpenInos	equ	[word ptr 0004Eh]
SEG_lpfnDosMonOpenInos	equ	[word ptr 00050h]
lpfnDosMonCloseInos	equ	[dword ptr 00052h]
OFF_lpfnDosMonCloseInos	equ	[word ptr 00052h]
SEG_lpfnDosMonCloseInos	equ	[word ptr 00054h]
lpfnDosMonRegInos	equ	[dword ptr 00056h]
OFF_lpfnDosMonRegInos	equ	[word ptr 00056h]
SEG_lpfnDosMonRegInos	equ	[word ptr 00058h]
lpfnDosMonReadInos	equ	[dword ptr 0005Ah]
OFF_lpfnDosMonReadInos	equ	[word ptr 0005Ah]
SEG_lpfnDosMonReadInos	equ	[word ptr 0005Ch]
lpfnDosMonWriteInos	equ	[dword ptr 0005Eh]
OFF_lpfnDosMonWriteInos	equ	[word ptr 0005Eh]
SEG_lpfnDosMonWriteInos	equ	[word ptr 00060h]
lpfnDosAllocSegInos	equ	[dword ptr 00062h]
OFF_lpfnDosAllocSegInos	equ	[word ptr 00062h]
SEG_lpfnDosAllocSegInos	equ	[word ptr 00064h]
lpfnDosReAllocSegInos	equ	[dword ptr 00066h]
OFF_lpfnDosReAllocSegInos	equ	[word ptr 00066h]
SEG_lpfnDosReAllocSegInos	equ	[word ptr 00068h]
lpfnDosFreeSegInos	equ	[dword ptr 0006Ah]
OFF_lpfnDosFreeSegInos	equ	[word ptr 0006Ah]
SEG_lpfnDosFreeSegInos	equ	[word ptr 0006Ch]
lpfnVioGetBufInos	equ	[dword ptr 0006Eh]
OFF_lpfnVioGetBufInos	equ	[word ptr 0006Eh]
SEG_lpfnVioGetBufInos	equ	[word ptr 00070h]
lpfnVioShowBufInos	equ	[dword ptr 00072h]
OFF_lpfnVioShowBufInos	equ	[word ptr 00072h]
SEG_lpfnVioShowBufInos	equ	[word ptr 00074h]
lpfnVioGetConfigInos	equ	[dword ptr 00076h]
OFF_lpfnVioGetConfigInos	equ	[word ptr 00076h]
SEG_lpfnVioGetConfigInos	equ	[word ptr 00078h]
lpfnVioGetModeInos	equ	[dword ptr 0007Ah]
OFF_lpfnVioGetModeInos	equ	[word ptr 0007Ah]
SEG_lpfnVioGetModeInos	equ	[word ptr 0007Ch]
lpfnVioSetModeInos	equ	[dword ptr 0007Eh]
OFF_lpfnVioSetModeInos	equ	[word ptr 0007Eh]
SEG_lpfnVioSetModeInos	equ	[word ptr 00080h]
lpfnVioGetStateInos	equ	[dword ptr 00082h]
OFF_lpfnVioGetStateInos	equ	[word ptr 00082h]
SEG_lpfnVioGetStateInos	equ	[word ptr 00084h]
lpfnVioSetStateInos	equ	[dword ptr 00086h]
OFF_lpfnVioSetStateInos	equ	[word ptr 00086h]
SEG_lpfnVioSetStateInos	equ	[word ptr 00088h]
lpfnVioGetCurTypeInos	equ	[dword ptr 0008Ah]
OFF_lpfnVioGetCurTypeInos	equ	[word ptr 0008Ah]
SEG_lpfnVioGetCurTypeInos	equ	[word ptr 0008Ch]
lpfnVioSetCurTypeInos	equ	[dword ptr 0008Eh]
OFF_lpfnVioSetCurTypeInos	equ	[word ptr 0008Eh]
SEG_lpfnVioSetCurTypeInos	equ	[word ptr 00090h]
lpfnVioGetCurPosInos	equ	[dword ptr 00092h]
OFF_lpfnVioGetCurPosInos	equ	[word ptr 00092h]
SEG_lpfnVioGetCurPosInos	equ	[word ptr 00094h]
lpfnVioSetCurPosInos	equ	[dword ptr 00096h]
OFF_lpfnVioSetCurPosInos	equ	[word ptr 00096h]
SEG_lpfnVioSetCurPosInos	equ	[word ptr 00098h]
lpfnVioGetFontInos	equ	[dword ptr 0009Ah]
OFF_lpfnVioGetFontInos	equ	[word ptr 0009Ah]
SEG_lpfnVioGetFontInos	equ	[word ptr 0009Ch]
lpfnVioSetFontInos	equ	[dword ptr 0009Eh]
OFF_lpfnVioSetFontInos	equ	[word ptr 0009Eh]
SEG_lpfnVioSetFontInos	equ	[word ptr 000A0h]
lpfnVioGetCPInos	equ	[dword ptr 000A2h]
OFF_lpfnVioGetCPInos	equ	[word ptr 000A2h]
SEG_lpfnVioGetCPInos	equ	[word ptr 000A4h]
lpfnVioSetCPInos	equ	[dword ptr 000A6h]
OFF_lpfnVioSetCPInos	equ	[word ptr 000A6h]
SEG_lpfnVioSetCPInos	equ	[word ptr 000A8h]
lpfnVioScrollUpInos	equ	[dword ptr 000AAh]
OFF_lpfnVioScrollUpInos	equ	[word ptr 000AAh]
SEG_lpfnVioScrollUpInos	equ	[word ptr 000ACh]
lpfnKbdOpenInos	equ	[dword ptr 000AEh]
OFF_lpfnKbdOpenInos	equ	[word ptr 000AEh]
SEG_lpfnKbdOpenInos	equ	[word ptr 000B0h]
lpfnKbdCloseInos	equ	[dword ptr 000B2h]
OFF_lpfnKbdCloseInos	equ	[word ptr 000B2h]
SEG_lpfnKbdCloseInos	equ	[word ptr 000B4h]
lpfnKbdCharInInos	equ	[dword ptr 000B6h]
OFF_lpfnKbdCharInInos	equ	[word ptr 000B6h]
SEG_lpfnKbdCharInInos	equ	[word ptr 000B8h]
lpfnKbdGetStatusInos	equ	[dword ptr 000BAh]
OFF_lpfnKbdGetStatusInos	equ	[word ptr 000BAh]
SEG_lpfnKbdGetStatusInos	equ	[word ptr 000BCh]
lpfnKbdSetStatusInos	equ	[dword ptr 000BEh]
OFF_lpfnKbdSetStatusInos	equ	[word ptr 000BEh]
SEG_lpfnKbdSetStatusInos	equ	[word ptr 000C0h]
lpfnDosBeepInos	equ	[dword ptr 000C2h]
OFF_lpfnDosBeepInos	equ	[word ptr 000C2h]
SEG_lpfnDosBeepInos	equ	[word ptr 000C4h]
lpfnVioGetPhysBufInos	equ	[dword ptr 000C6h]
OFF_lpfnVioGetPhysBufInos	equ	[word ptr 000C6h]
SEG_lpfnVioGetPhysBufInos	equ	[word ptr 000C8h]
lpfnCwBeginIOInos	equ	[dword ptr 000CAh]
OFF_lpfnCwBeginIOInos	equ	[word ptr 000CAh]
SEG_lpfnCwBeginIOInos	equ	[word ptr 000CCh]
lpfnCwEndIOInos	equ	[dword ptr 000CEh]
OFF_lpfnCwEndIOInos	equ	[word ptr 000CEh]
SEG_lpfnCwEndIOInos	equ	[word ptr 000D0h]
cbInosMin	equ	000D2h

cpfnIncs	equ	[word ptr 00000h]
cbIncsMin	equ	00002h

lpwDataInsh	equ	[dword ptr 00000h]
LO_lpwDataInsh	equ	[word ptr 00000h]
HI_lpwDataInsh	equ	[word ptr 00002h]
pinosInsh	equ	[word ptr 00004h]
pincsInsh	equ	[word ptr 00006h]
cpfnInsh	equ	[word ptr 00008h]
cbInshMin	equ	0000Ah
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\inc\inkbd.inc ===
KK_EXTENDED	equ	08000h
KK_CAPLOCK	equ	04000h
KK_NUMLOCK	equ	02000h
KK_SCRLOCK	equ	01000h
KK_ALT		equ	00800h
KK_CONTROL	equ	00400h
KK_SHIFT	equ	00200h
KK_VK		equ	001FFh
KK_SC		equ	000FFh

ifdef KANJI
KJ_SC		equ	0ff00h
KJ_KANA 	equ	00080h
KJ_OTHER	equ	00040h
KJ_KK		equ	000b0h
KJ_COUNT	equ	0003fh
endif

lpfnKeyboardMessageInkb	equ	[dword ptr 00000h]
OFF_lpfnKeyboardMessageInkb	equ	[word ptr 00000h]
SEG_lpfnKeyboardMessageInkb	equ	[word ptr 00002h]
lpfnFTestKeyboardEmptyInkb	equ	[dword ptr 00004h]
OFF_lpfnFTestKeyboardEmptyInkb	equ	[word ptr 00004h]
SEG_lpfnFTestKeyboardEmptyInkb	equ	[word ptr 00006h]
lpfnSpecialAbortInkb	equ	[dword ptr 00008h]
OFF_lpfnSpecialAbortInkb	equ	[word ptr 00008h]
SEG_lpfnSpecialAbortInkb	equ	[word ptr 0000Ah]
fAbortInkb	equ	[word ptr 0000Ch]
fPollKeyboardInkb	equ	[word ptr 0000Eh]
fKeyIsUpInkb	equ	[byte ptr 00010h]
fKeyWasUpInkb	equ	[byte ptr 00011h]
wRateKeyRepeatInkb	equ	[word ptr 00012h]
fNormalKeyboardInkb	equ	[word ptr 00014h]
fNonAltKeyHitInkb	equ	[byte ptr 00016h]
fDisableExtendedInkb	equ	[word ptr 00018h]
cbInkbMin	equ	0001Ah

pfnEnableKeyboardKbdInkj	equ	[dword ptr 00000h]
OFF_pfnEnableKeyboardKbdInkj	equ	[word ptr 00000h]
SEG_pfnEnableKeyboardKbdInkj	equ	[word ptr 00002h]
pfnPollKeyboardKbdInkj	equ	[dword ptr 00004h]
OFF_pfnPollKeyboardKbdInkj	equ	[word ptr 00004h]
SEG_pfnPollKeyboardKbdInkj	equ	[word ptr 00006h]
pfnFlushKeyRgchKbdInkj	equ	[dword ptr 00008h]
OFF_pfnFlushKeyRgchKbdInkj	equ	[word ptr 00008h]
SEG_pfnFlushKeyRgchKbdInkj	equ	[word ptr 0000Ah]
pfnMkGetShiftStatesKbdInkj	equ	[dword ptr 0000Ch]
OFF_pfnMkGetShiftStatesKbdInkj	equ	[word ptr 0000Ch]
SEG_pfnMkGetShiftStatesKbdInkj	equ	[word ptr 0000Eh]
pfnSetShiftKkKbdInkj	equ	[dword ptr 00010h]
OFF_pfnSetShiftKkKbdInkj	equ	[word ptr 00010h]
SEG_pfnSetShiftKkKbdInkj	equ	[word ptr 00012h]
pfnChAlternateKeytopKbdInkj	equ	[dword ptr 00014h]
OFF_pfnChAlternateKeytopKbdInkj	equ	[word ptr 00014h]
SEG_pfnChAlternateKeytopKbdInkj	equ	[word ptr 00016h]
cbInkjMin	equ	00018h
cpfnKbdMin	equ	6
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\inc\inmou.inc ===
MK_LBUTTON	equ	00001h
MK_RBUTTON	equ	00002h
MK_SHIFT	equ	00004h
MK_CONTROL	equ	00008h
MK_MBUTTON	equ	00010h
MK_NONCLIENT	equ	00060h
MK_NONCLIENT_X	equ	00020h
MK_NONCLIENT_Y	equ	00040h
MK_MENU		equ	08000h
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\inc\kanji.inc ===
;*
;*	CW : Character Oriented Windows
;*
;*	kanji.inc : Kanji / DBCS support

;*	* first range: 81->9F
chDbcMin1	=	081H
chDbcMac1	=	09FH+1
;*	* second range: E0->FC
chDbcMin2	=	0E0H
chDbcMac2	=	0FCH+1


;********** JmpNotDbc **********
;*	entry: al = first character
;*	* jump to label if not first byte of D.B. character
;*	* Trashes nothing except flags

JmpNotDbc MACRO label
	LOCAL	is_dbc
	cmp	al,chDbcMin1
	jb	label
	cmp	al,chDbcMac1
	jb	is_dbc
	cmp	al,chDbcMin2
	jb	label
	cmp	al,chDbcMac2
	jae	label
is_dbc:
ENDM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\inc\inscr.inc ===
dxCharInft	equ	[byte ptr 00000h]
dyCharInft	equ	[byte ptr 00001h]
dyBaseLineInft	equ	[byte ptr 00002h]
ifontInft	equ	[byte ptr 00003h]
cbInftMin	equ	00004h
finstText	equ	1
finstGraphics	equ	2
finstMonochrome	equ	4
finstAlternate	equ	8
finstFont	equ	00010h
finstCgaSnow	equ	00020h
finstDisableMouse	equ	01000h
finstFastScroll	equ	02000h
finstQuestionable	equ	04000h
finstAvailable	equ	08000h

finstInst	equ	[word ptr 00000h]
axMacInst	equ	[byte ptr 00002h]
ayMacInst	equ	[byte ptr 00003h]
coMacInst	equ	[byte ptr 00004h]
covMacInst	equ	[byte ptr 00005h]
coiMacInst	equ	[word ptr 00006h]
imodeInst	equ	[word ptr 00008h]
inftInst	equ	[dword ptr 0000Ah]
LO_inftInst	equ	[word ptr 0000Ah]
HI_inftInst	equ	[word ptr 0000Ch]
ffontSupportedInst	equ	[word ptr 0000Eh]
psPrimInst	equ	[word ptr 00010h]
psSecInst	equ	[word ptr 00012h]
cwExtraInst	equ	[word ptr 00014h]
psExtraInst	equ	[word ptr 00016h]
bits0Inst	equ	[word ptr 00018h]
bits0recInst	record	fillerInst:15,fAllocPrimInst:1
wDriver1Inst	equ	[word ptr 0001Ah]
reserved2Inst	equ	[0001Ch]
cbInstMin	equ	0002Ah
imodeUnknown	equ	0FFFFh

_chTopLeftCorner1Inch	equ	[byte ptr 00000h]
_chTopRightCorner1Inch	equ	[byte ptr 00001h]
_chBottomLeftCorner1Inch	equ	[byte ptr 00002h]
_chBottomRightCorner1Inch	equ	[byte ptr 00003h]
_chTopSide1Inch	equ	[byte ptr 00004h]
_chBottomSide1Inch	equ	[byte ptr 00005h]
_chLeftSide1Inch	equ	[byte ptr 00006h]
_chRightSide1Inch	equ	[byte ptr 00007h]
_chMiddleLeft1Inch	equ	[byte ptr 00008h]
_chMiddleRight1Inch	equ	[byte ptr 00009h]
_chTopLeftCorner2Inch	equ	[byte ptr 0000Ah]
_chTopRightCorner2Inch	equ	[byte ptr 0000Bh]
_chBottomLeftCorner2Inch	equ	[byte ptr 0000Ch]
_chBottomRightCorner2Inch	equ	[byte ptr 0000Dh]
_chTopSide2Inch	equ	[byte ptr 0000Eh]
_chBottomSide2Inch	equ	[byte ptr 0000Fh]
_chLeftSide2Inch	equ	[byte ptr 00010h]
_chRightSide2Inch	equ	[byte ptr 00011h]
_chUpArrowInch	equ	[byte ptr 00012h]
_chDownArrowInch	equ	[byte ptr 00013h]
_chLeftArrowInch	equ	[byte ptr 00014h]
_chRightArrowInch	equ	[byte ptr 00015h]
_chBulletInch	equ	[byte ptr 00016h]
_chMiddleDotInch	equ	[byte ptr 00017h]
_chScrollbarInch	equ	[byte ptr 00018h]
_chElevatorInch	equ	[byte ptr 00019h]
_chShadowInitInch	equ	[byte ptr 0001Ah]
_chCloseInch	equ	[byte ptr 0001Bh]
_chZoomInInch	equ	[byte ptr 0001Ch]
_chZoomOutInch	equ	[byte ptr 0001Dh]
_chUpDownArrowInch	equ	[byte ptr 0001Eh]
_chLeftRightArrowInch	equ	[byte ptr 0001Fh]
reservedInch	equ	[00020h]
cbInchMin	equ	00040h
ffontNormal	equ	00000h
ffontUnderline	equ	00001h
ffontDoubleUnderline	equ	00002h
ffontOrUnderline	equ	00003h
ffontStrikeThrough	equ	00004h
ffontBold	equ	00008h
ffontSubscript	equ	00010h
ffontSuperscript	equ	00020h
ffontMiniCap	equ	00030h
ffontItalic	equ	00040h
ffontOrCharacter	equ	00080h
ffontReservedBits	equ	00F00h
ffontExtraMask	equ	0F000h
ffontOrUnderlineSupport	equ	01000h
fvidsChAttr	equ	1

modeVids	equ	[byte ptr 00000h]
pageVids	equ	[byte ptr 00001h]
fvidsVids	equ	[word ptr 00002h]
cwVidDataVids	equ	[word ptr 00004h]
cwExtraVids	equ	[word ptr 00006h]
rgwExtraVids	equ	[word ptr 00008h]
cbVidsMin	equ	0000Ah

lpfnImodeGuessCurrentCsdInsj	equ	[dword ptr 00000h]
OFF_lpfnImodeGuessCurrentCsdInsj	equ	[word ptr 00000h]
SEG_lpfnImodeGuessCurrentCsdInsj	equ	[word ptr 00002h]
lpfnFQueryInstCsdInsj	equ	[dword ptr 00004h]
OFF_lpfnFQueryInstCsdInsj	equ	[word ptr 00004h]
SEG_lpfnFQueryInstCsdInsj	equ	[word ptr 00006h]
lpfnFInitCsdInsj	equ	[dword ptr 00008h]
OFF_lpfnFInitCsdInsj	equ	[word ptr 00008h]
SEG_lpfnFInitCsdInsj	equ	[word ptr 0000Ah]
lpfnTermCsdInsj	equ	[dword ptr 0000Ch]
OFF_lpfnTermCsdInsj	equ	[word ptr 0000Ch]
SEG_lpfnTermCsdInsj	equ	[word ptr 0000Eh]
lpfnMoveHwCursCsdInsj	equ	[dword ptr 00010h]
OFF_lpfnMoveHwCursCsdInsj	equ	[word ptr 00010h]
SEG_lpfnMoveHwCursCsdInsj	equ	[word ptr 00012h]
lpfnFQueryInftCsdInsj	equ	[dword ptr 00014h]
OFF_lpfnFQueryInftCsdInsj	equ	[word ptr 00014h]
SEG_lpfnFQueryInftCsdInsj	equ	[word ptr 00016h]
lpfnFGetColorPaletteCsdInsj	equ	[dword ptr 00018h]
OFF_lpfnFGetColorPaletteCsdInsj	equ	[word ptr 00018h]
SEG_lpfnFGetColorPaletteCsdInsj	equ	[word ptr 0001Ah]
lpfnSetColorPaletteCsdInsj	equ	[dword ptr 0001Ch]
OFF_lpfnSetColorPaletteCsdInsj	equ	[word ptr 0001Ch]
SEG_lpfnSetColorPaletteCsdInsj	equ	[word ptr 0001Eh]
lpfnPrepUpdateCsdInsj	equ	[dword ptr 00020h]
OFF_lpfnPrepUpdateCsdInsj	equ	[word ptr 00020h]
SEG_lpfnPrepUpdateCsdInsj	equ	[word ptr 00022h]
lpfnDoUpdateCsdInsj	equ	[dword ptr 00024h]
OFF_lpfnDoUpdateCsdInsj	equ	[word ptr 00024h]
SEG_lpfnDoUpdateCsdInsj	equ	[word ptr 00026h]
lpfnDoneUpdateCsdInsj	equ	[dword ptr 00028h]
OFF_lpfnDoneUpdateCsdInsj	equ	[word ptr 00028h]
SEG_lpfnDoneUpdateCsdInsj	equ	[word ptr 0002Ah]
lpfnSpecialUpdateCsdInsj	equ	[dword ptr 0002Ch]
OFF_lpfnSpecialUpdateCsdInsj	equ	[word ptr 0002Ch]
SEG_lpfnSpecialUpdateCsdInsj	equ	[word ptr 0002Eh]
lpfnCbSizeVidsCsdInsj	equ	[dword ptr 00030h]
OFF_lpfnCbSizeVidsCsdInsj	equ	[word ptr 00030h]
SEG_lpfnCbSizeVidsCsdInsj	equ	[word ptr 00032h]
lpfnFSaveVidsCsdInsj	equ	[dword ptr 00034h]
OFF_lpfnFSaveVidsCsdInsj	equ	[word ptr 00034h]
SEG_lpfnFSaveVidsCsdInsj	equ	[word ptr 00036h]
lpfnFRestoreVidsCsdInsj	equ	[dword ptr 00038h]
OFF_lpfnFRestoreVidsCsdInsj	equ	[word ptr 00038h]
SEG_lpfnFRestoreVidsCsdInsj	equ	[word ptr 0003Ah]
lpfnSaveVidDataCsdInsj	equ	[dword ptr 0003Ch]
OFF_lpfnSaveVidDataCsdInsj	equ	[word ptr 0003Ch]
SEG_lpfnSaveVidDataCsdInsj	equ	[word ptr 0003Eh]
lpfnRestoreVidDataCsdInsj	equ	[dword ptr 00040h]
OFF_lpfnRestoreVidDataCsdInsj	equ	[word ptr 00040h]
SEG_lpfnRestoreVidDataCsdInsj	equ	[word ptr 00042h]
lpfnEnableVidsMonitorCsdInsj	equ	[dword ptr 00044h]
OFF_lpfnEnableVidsMonitorCsdInsj	equ	[word ptr 00044h]
SEG_lpfnEnableVidsMonitorCsdInsj	equ	[word ptr 00046h]
lpfnBltArcCsdInsj	equ	[dword ptr 00048h]
OFF_lpfnBltArcCsdInsj	equ	[word ptr 00048h]
SEG_lpfnBltArcCsdInsj	equ	[word ptr 0004Ah]
lpfnGetCharMapCsdInsj	equ	[dword ptr 0004Ch]
OFF_lpfnGetCharMapCsdInsj	equ	[word ptr 0004Ch]
SEG_lpfnGetCharMapCsdInsj	equ	[word ptr 0004Eh]
cbInsjMin	equ	00050h
cpfnCsdMin	equ	20
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\inc\insyd.inc ===
lpfnDoSoundSydInyj	equ	[dword ptr 00000h]
OFF_lpfnDoSoundSydInyj	equ	[word ptr 00000h]
SEG_lpfnDoSoundSydInyj	equ	[word ptr 00002h]
lpfnLGetTimeSydInyj	equ	[dword ptr 00004h]
OFF_lpfnLGetTimeSydInyj	equ	[word ptr 00004h]
SEG_lpfnLGetTimeSydInyj	equ	[word ptr 00006h]
cbInyjMin	equ	00008h
cpfnSydMin	equ	2
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\inc\bios.inc ===
;*	CW : Character Windows
;*
;*	bios.inc : IBM specific keyboard BIOS/hardware equates
;*****************************************************************************

KbDataPort	equ	60H
KbCtrlPort	equ	61H

KbType		equ	496H		;* absolute address (off ES == 0)

BUFFER_HEAD	EQU	41AH
BUFFER_TAIL	EQU	41CH
BUFFER_START	EQU	480H
BUFFER_END	EQU	482H
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\inc\vkey.inc ===
VK_MIN		equ	00100h
VK_LBUTTON	equ	00101h
VK_RBUTTON	equ	00102h
VK_CANCEL	equ	00103h
VK_MBUTTON	equ	00104h
VK_BACK		equ	00108h
VK_TAB		equ	00109h
VK_CLEAR	equ	0010Ch
VK_RETURN	equ	0010Dh
VK_SHIFT	equ	00110h
VK_CONTROL	equ	00111h
VK_ALT		equ	00112h
VK_PAUSE	equ	00113h
VK_CAPLOCK	equ	00114h
VK_KANA		equ	00115h
VK_ROMAJI	equ	00116h
VK_ZENKAKU	equ	00117h
VK_HIRAGANA	equ	00118h
VK_KANJI	equ	00119h
VK_CONVERT	equ	0011Ch
VK_NONCONVERT	equ	0011Dh
VK_ACCEPT	equ	0011Eh
VK_MODECHANGE	equ	0011Fh
VK_ESCAPE	equ	0011Bh
VK_SPACE	equ	00120h
VK_PRIOR	equ	00121h
VK_NEXT		equ	00122h
VK_END		equ	00123h
VK_HOME		equ	00124h
VK_LEFT		equ	00125h
VK_UP		equ	00126h
VK_RIGHT	equ	00127h
VK_DOWN		equ	00128h
VK_0		equ	00130h
VK_9		equ	00139h
VK_A		equ	00141h
VK_Z		equ	0015Ah
VK_SELECT	equ	00129h
VK_PRINT	equ	0012Ah
VK_EXECUTE	equ	0012Bh
VK_INSERT	equ	0012Dh
VK_DELETE	equ	0012Eh
VK_HELP		equ	0012Fh
VK_NUMPAD0	equ	00160h
VK_NUMPAD1	equ	00161h
VK_NUMPAD2	equ	00162h
VK_NUMPAD3	equ	00163h
VK_NUMPAD4	equ	00164h
VK_NUMPAD5	equ	00165h
VK_NUMPAD6	equ	00166h
VK_NUMPAD7	equ	00167h
VK_NUMPAD8	equ	00168h
VK_NUMPAD9	equ	00169h
VK_MULTIPLY	equ	0016Ah
VK_ADD		equ	0016Bh
VK_SEPARATOR	equ	0016Ch
VK_SUBTRACT	equ	0016Dh
VK_DECIMAL	equ	0016Eh
VK_DIVIDE	equ	0016Fh
VK_F1		equ	00170h
VK_F2		equ	00171h
VK_F3		equ	00172h
VK_F4		equ	00173h
VK_F5		equ	00174h
VK_F6		equ	00175h
VK_F7		equ	00176h
VK_F8		equ	00177h
VK_F9		equ	00178h
VK_F10		equ	00179h
VK_F11		equ	0017Ah
VK_F12		equ	0017Bh
VK_F13		equ	0017Ch
VK_F14		equ	0017Dh
VK_F15		equ	0017Eh
VK_F16		equ	0017Fh
VK_OAX		equ	00180h
VK_NUMLOCK	equ	00190h
VK_SCRLOCK	equ	00191h
VK_MENU		equ	VK_ALT
VK_CAPITAL	equ	VK_CAPLOCK
VK_OEM_NUMBER	equ	VK_NUMLOCK
VK_OEM_SCROLL	equ	VK_SCRLOCK
VK_SEPARATER	equ	VK_SEPARATOR
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\inc\kbd_code.asm ===
;*
;*	CW : Character Windows
;*
;*	kbd_code.asm : Start of KBD code

;*****************************************************************************

sBegin	DRV
    assumes CS,DRV
    assumes ds,NOTHING
    assumes ss,NOTHING

	ORG	0H			;* start of .KBD file

;*****************************************************************************

lpwDataKbd		label	dword		;* allocated by driver loader
OFF_lpwDataKbd	DW	cbDataKbd	;* at load time:  cbData
					;* after loading: OFF_lpwDataKbd
SEG_lpwDataKbd	DW	fmemDataKbd	;* at load time:  fmemData
					;* after loading: SEG_lpwDataKbd

pinos:		DW	0		;* pinos
pincs:		DW	0		;* pincs

		DW	cpfnKbdMin	;* # of entries in table
rgpfn:
		DW	EnableKeyboardKbd
		DW	PollKeyboardKbd
		DW	FlushKeyRgchKbd
		DW	MkGetShiftStatesKbd
		DW	SetShiftKkKbd
		DW	ChAlternateKeytopKbd

	Assert <(($ - rgpfn) / 2) EQ cpfnKbdMin>

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\inc\kbd_data.inc ===
;*
;*	CW : Character Windows Drivers
;*
;*	kbd_data.inc : Standard KBD data


;*****************************************************************************

cbDataKbd	equ	(size KDDATA)		;* size of data structure
fmemDataKbd	equ	fmemNear		;* must be in near space

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\inc\std.inc ===
;*****************************************************************************
;*
;*	* * * STD.INC : Standard extensions to CMACROS.INC * * *
;*	(must include CMACROS.INC first)
;*	WARNING:
;*	This file is source controlled in the \LIB\INC directory !
;*****************************************************************************

by	equ	byte ptr
wo	equ	word ptr
dwo	equ	dword ptr
qwo	equ	qword ptr

;*	* external Absolute values
IFNDEF externA	;* not defined in old CMACROS
externA macro n
?ex1 <n>,0,<ABS>
endm
ENDIF

MovSeg	MACRO	segDest,segSrc			;* slow move segment
	push	segSrc
	pop	segDest
ENDM	;MovSeg

SkipW	MACRO
	DB	03DH		;;* skip word operand (CMP AX,...)
ENDM

SkipB	MACRO
	DB	03CH		;;* skip byte operand (CMP AL,...)
ENDM

IFNDEF RETF
RETF	MACRO	cbParam
    IFNB <cbParam>
	DB	0CAH		;;* return far add to stack
	DW	cbParam
    ELSE
	DB	0CBH		;;* return far
    ENDIF
ENDM
ENDIF


ASSERT	MACRO	expr		;;* Assembly time assertion check
    IFE expr
	%OUT Assertion Failed !expr!
	.ERR
    ENDIF
ENDM


BREAKPOINT MACRO		;;* insert breakpoint if debugging
    IFDEF DEBUG
	INT	3
    ENDIF
ENDM

;*****************************************************************************

;* NOTE : in adding extra code for Debugging, short jumps may no longer fit:
;*   hence the use of the SHORT_ macros

;********** SHORT_Jcc **********
;* MACROS
;*	* if non-debugging : perform a "Jcc" address (Short jump)
;*	* if debugging : perform a short jump around a long jump.
;*	* NOTE : the extra time required for the debugging case is NOT taken
;*	*  into consideration - hence profiling is not exact.

SHORT_JE MACRO	addr
	LOCAL around
    IFDEF DEBUG
	JNE	around
	JMP	addr
    ELSE
	JE	addr
    ENDIF
around:
ENDM

SHORT_JNS MACRO	addr
	LOCAL around
    IFDEF DEBUG
	JS	around
	JMP	addr
    ELSE
	JNS	addr
    ENDIF
around:
ENDM

SHORT_JNZ MACRO	addr
	LOCAL around
    IFDEF DEBUG
	JZ	around
	JMP	addr
    ELSE
	JNZ	addr
    ENDIF
around:
ENDM

SHORT_JA MACRO	addr
	LOCAL around
    IFDEF DEBUG
	JBE	around
	JMP	addr
    ELSE
	JA	addr
    ENDIF
around:
ENDM

SHORT_JAE MACRO	addr
	LOCAL around
    IFDEF DEBUG
	JB	around
	JMP	addr
    ELSE
	JAE	addr
    ENDIF
around:
ENDM

SHORT_JMP MACRO addr
    IFDEF DEBUG
	JMP	addr
    ELSE
	JMP	SHORT addr
    ENDIF
ENDM

JMP_SHORT MACRO addr
    IFDEF DEBUG
	JMP	addr
    ELSE
	JMP	SHORT addr
    ENDIF
ENDM

;*****************************************************************************
;* Runtime Asserts

IFDEF DEBUG
;********** debugging **********
AssertEQ MACRO	a,b		;* assert 2 values are equal
	LOCAL	ok
	CMP	a,b
	JE	ok
	BREAKPOINT
ok:
ENDM
AssertNE MACRO	a,b		;* assert 2 values are not equal
	LOCAL	ok
	CMP	a,b
	JNE	ok
	BREAKPOINT
ok:
ENDM
AssertTest MACRO a,cond,b	;* assert test condition
	LOCAL	ok
	TEST	a,b
	J&cond	ok
	BREAKPOINT
ok:
ENDM
AssertEven MACRO a		;* assert something is even
	LOCAL	ok
	TEST	a,1
	JZ	ok
	BREAKPOINT
ok:
ENDM
AssertOdd MACRO a		;* assert something is odd
	LOCAL	ok
	TEST	a,1
	JNZ	ok
	BREAKPOINT
ok:
ENDM
AssertCmp MACRO	a,cond,b	;* assert comparison condition
	LOCAL	ok
	CMP	a,b
	J&cond	ok
	BREAKPOINT
ok:
ENDM
AssertData MACRO sreg		;* assert a segment register is set to DDS (SS)
	LOCAL	ok
	PUSH	AX
	PUSH	BX
	MOV	AX,sreg
	MOV	BX,SS
	CMP	AX,BX
	POP	BX
	POP	AX
	JZ	ok
	BREAKPOINT
ok:
	assumes	sreg,DGROUP
ENDM
AssertZR MACRO			;* assert the zero flag is ZR.
	LOCAL	ok
	JZ	ok
	BREAKPOINT
ok:
ENDM
AssertNZ MACRO			;* assert the zero flag is NZ.
	LOCAL	ok
	JNZ	ok
	BREAKPOINT
ok:
ENDM
AssertCY MACRO			;* assert the carry flag is CY.
	LOCAL	ok
	JC	ok
	BREAKPOINT
ok:
ENDM
AssertNC MACRO			;* assert the carry flag is NC.
	LOCAL	ok
	JNC	ok
	BREAKPOINT
ok:
ENDM
ELSE
;********** non-debugging **********
AssertEQ MACRO	a,b
ENDM
AssertNE MACRO	a,b
ENDM
AssertCmp MACRO	a,cond,b
ENDM
AssertTest MACRO a,cond,b
ENDM
AssertEven MACRO a
ENDM
AssertOdd MACRO a
ENDM
AssertData MACRO sreg
	assumes	sreg,DGROUP
ENDM
AssertZR MACRO
ENDM
AssertNZ MACRO
ENDM
AssertCY MACRO
ENDM
AssertNC MACRO
ENDM
ENDIF ;!DEBUG

;*****************************************************************************

;********** Lbl **********
;*	entry:	name = name to make public at the current location
;*	* make a debugging public entry point
Lbl	MACRO	name
	PUBLIC	name
name:
ENDM	;Lbl
	
;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\inc\kbd_head.inc ===
;*
;*	CW : Character Windows
;*
;*	kbd_head.inc : header file for all KBD drivers

;*****************************************************************************

.xlist
	include	drv.inc

	include inkbd.inc				;* installable keyboard
	include	inmou.inc				;* mouse (for MK values)
.list

;*****************************************************************************
;*	* Virtual Key Codes *

	include	vkey.inc

;*****************************************************************************
;*	* To Convert VK to VW, take low byte
VwOfVk	EQU	LOW
VkOfVw	EQU	100H+

;*****************************************************************************
;*	* Fill the gaps in VK_ list
VK_1		=	VK_0+1
VK_2		=	VK_0+2
VK_3		=	VK_0+3
VK_4		=	VK_0+4
VK_5		=	VK_0+5
VK_6		=	VK_0+6
VK_7		=	VK_0+7
VK_8		=	VK_0+8

VK_B		=	VK_A+1
VK_C		=	VK_A+2
VK_D		=	VK_A+3
VK_E		=	VK_A+4
VK_F		=	VK_A+5
VK_G		=	VK_A+6
VK_H		=	VK_A+7
VK_I		=	VK_A+8
VK_J		=	VK_A+9
VK_K		=	VK_A+10
VK_L		=	VK_A+11
VK_M		=	VK_A+12
VK_N		=	VK_A+13
VK_O		=	VK_A+14
VK_P		=	VK_A+15
VK_Q		=	VK_A+16
VK_R		=	VK_A+17
VK_S		=	VK_A+18
VK_T		=	VK_A+19
VK_U		=	VK_A+20
VK_V		=	VK_A+21
VK_W		=	VK_A+22
VK_X		=	VK_A+23
VK_Y		=	VK_A+24

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\inc\cmacros.inc ===
comment $
cmacros - assembly macros for interfacing to hhls
(C)Copyright Microsoft Corp. 1984-1987
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.00.0 - 02/23/88>
??_out <Copyright (C) Microsoft Corp. 1984-1987. All rights reserved.>
outif memS,0,<Small Model>
outif memM,0,<Medium model>
outif memL,0,<Large Model>
outif memC,0,<Compact Model>
outif memH,0,<Huge Model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
outif memS,0,<Small model>
else
??error <must have only 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
outif ?COW,0,<Character Windows support>
outif ?PLM,1,<PL/M calling convention>
outif ?NOATOMIC,0,<ATOMIC disabled>
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
push x
endif
endm
endm
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
pop x
endif
endm
endm
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
ifdef ?&&x
n=n or ?&&x
endif
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
push s
push o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
push word ptr (n)
exitm
endif
ife ?t&n-2
push n
exitm
endif
ife ?t&n-4
push word ptr (n)[2]
push word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
push word ptr (n)[6]
push word ptr (n)[4]
push word ptr (n)[2]
push word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
push word ptr (n)
exitm
endif
endif
push n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
call n
if ((?cCall1 eq 0) and (?argl ne 0))
add sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ife ?NOATOMIC
ifidn <x>,<ATOMIC>
?nx=1
endif
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp
ife ?nx
ife ?COW
?ia=2
?pas = ?pas and (not ?ds)
endif
endif
endif
?adj=?adj+2
else
?wfp=0
endif
?pas = ?pas and (not (?sp+?cs+?ss))
if ?uf
?pas = ?pas and (not (?bp+?si+?di))
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w
ife ?nd
mov ax,ds
nop
endif
ife ?nx
ife ?DOS5
inc bp
endif
push bp
mov bp,sp
ife ?COW
push ds
endif
else
if ?ff+???+?po+?rp
push bp
mov bp,sp
endif
endif
ife ?nd
mov ds,ax
endif
else
if ?ff+???+?po+?rp
push bp
mov bp,sp
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
mov ax,???
ife cc
call _chkstk
else
call chkstk
endif
endif
else
sub sp,???
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
call StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
db 0c3h
else
if w
ife ?nx
if (?TF eq 0) or (???+?rp)
lea sp,-2[bp]
endif
ife ?COW
pop ds
endif
pop bp
ife ?DOS5
dec bp
endif
else
if (?TF eq 0) or (???+?rp)
mov sp,bp
endif
if ???+?po+?rp
pop bp
endif
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
mov sp,bp
endif
pop bp
endif
endif
ife cc
ret
else
ret o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
extrn n&_FARFRAME:near
call n&_FARFRAME
else
extrn n&_NEARFRAME:near
call n&_NEARFRAME
endif
db l shr 1
db p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\inc\kbd_tail.asm ===
;*
;*	CW : Character Windows
;*
;*	kbd_tail.asm : trailer file for all KBD drivers

sEnd	DRV
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\inc\kbd_std.asm ===
;*
;*	CW : Character Windows
;*
;*	kbd_std.asm : standard KBD defaults (empty procedures)
;*


ifndef PollKeyboardKbd_NonDefault
;*****************************************************************************
;********** PollKeyboardKbd **********
;*	* KBD entry point (see documentation for interface)

cProc	PollKeyboardKbd, <FAR, PUBLIC, ATOMIC>
cBegin	PollKeyboardKbd

cEnd	PollKeyboardKbd

;*****************************************************************************
endif	;* PollKeyboardKbd_NonDefault



ifndef SetShiftKkKbd_NonDefault
;*****************************************************************************
;********** SetShiftKkKbd **********
;*	* KBD entry point (see documentation for interface)

cProc	SetShiftKkKbd, <FAR, PUBLIC, ATOMIC>
    parmW  kkNew
cBegin	SetShiftKkKbd

cEnd	SetShiftKkKbd

;*****************************************************************************
endif	;* SetShiftKkKbd_NonDefault



ifndef ChAlternateKeytopKbd_NonDefault
;*****************************************************************************
;********** ChAlternateKeytopKbd **********
;*	* KBD entry point (see documentation for interface)

cProc	ChAlternateKeytopKbd, <FAR, PUBLIC, ATOMIC>
    parmB  chOriginal
cBegin	ChAlternateKeytopKbd

cEnd	ChAlternateKeytopKbd

;*****************************************************************************
endif	;* ChAlternateKeytopKbd_NonDefault



ifndef FlushKeyRgchKbd_NonDefault
;*****************************************************************************
;********** FlushKeyRgchKbd **********
;*	* KBD entry point (see documentation for interface)

cProc	FlushKeyRgchKbd, <FAR, PUBLIC, ATOMIC>
    parmDP rgchOriginal
cBegin	FlushKeyRgchKbd

cEnd	FlushKeyRgchKbd

;*****************************************************************************
endif	;* FlushKeyRgchKbd_NonDefault
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\inc\tsr3.inc ===
;*	CW : Character Windows
;*
;*	tsr3.inc : low level TSR interface for DOS 3 keyboard
;*****************************************************************************

;*****************************************************************************
;*	* types :
;*	TSRC : TSR Commands (in AX)
;*	VER  : Version parameters (in DX)
;*	ACK  : acknowledge return (in AX)
;*	TSRR : TSR Request (TSR want's something from App)
;*****************************************************************************

;*	* init/termination
tsrcInitTerm	EQU	55FEH
verTsr		EQU	0		;* version # for init
verTsrTerm	EQU	-1		;* version for term

;*	* acknowledge to init
ackTsr		EQU	4D4BH			;* "MK"

;*	* getting key & shift state
tsrcInkey	EQU	5500H		;* special get key request

;*	* TSR Requests
tsrrPoll	EQU	0		;* poll TSR for input
tsrrIgnoreAltUp	EQU	1		;* ignore next ALT up
tsrrAbort	EQU	2		;* ESCAPE

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\inc\scan3.inc ===
;*	CW : Character Windows
;*
;*	scan3.inc : DOS 3 scan codes
;*****************************************************************************

SS_RSHIFT	equ	00001h
SS_LSHIFT	equ	00002h
SS_CONTROL	equ	00004h
SS_ALT		equ	00008h
SS_SCRLOCK	equ	00010h
SS_NUMLOCK	equ	00020h
SS_CAPLOCK	equ	00040h
SS_INSERT	equ	00080h
;; Extra shift states
SS_SPACE	equ	00100h		;* for space bar keyup
SS_EXTENDED	equ	00200h		;* for extended keypad codes
ifdef KANJI
SS_KANA		equ	08000h
endif
SS_SHIFT	equ	(SS_LSHIFT or SS_RSHIFT)

SC_NO_KEY	equ	0
SC_ESC		equ	1
SC_1		equ	2
SC_2		equ	3
SC_3		equ	4
SC_4		equ	5
SC_5		equ	6
SC_6		equ	7
SC_7		equ	8
SC_8		equ	9
SC_9		equ	10
SC_0		equ	11
SC_MINUS	equ	12
SC_EQUALS	equ	13
SC_BACKSPACE	equ	14
SC_TAB		equ	15
SC_Q		equ	16
SC_W		equ	17
SC_E		equ	18
SC_R		equ	19
SC_T		equ	20
SC_Y		equ	21
SC_U		equ	22
SC_I		equ	23
SC_O		equ	24
SC_P		equ	25
SC_LEFT_BRACKET	equ	26
SC_RIGHT_BRACKET	equ	27
SC_ENTER	equ	28
SC_CTRL		equ	29
SC_A		equ	30
SC_S		equ	31
SC_D		equ	32
SC_F		equ	33
SC_G		equ	34
SC_H		equ	35
SC_J		equ	36
SC_K		equ	37
SC_L		equ	38
SC_SEMI_COLON	equ	39
SC_CLOSE_QUOTE	equ	40
SC_OPEN_QUOTE	equ	41
SC_LEFT_SHIFT	equ	42
SC_BACK_SLASH	equ	43
SC_Z		equ	44
SC_X		equ	45
SC_C		equ	46
SC_V		equ	47
SC_B		equ	48
SC_N		equ	49
SC_M		equ	50
SC_COMMA	equ	51
SC_PERIOD	equ	52
SC_SLASH	equ	53
SC_RIGHT_SHIFT	equ	54
SC_MULTIPLY	equ	55
SC_ALT		equ	56
SC_SPACE	equ	57
SC_CAPS_LOCK	equ	58
SC_F1		equ	59
SC_F2		equ	60
SC_F3		equ	61
SC_F4		equ	62
SC_F5		equ	63
SC_F6		equ	64
SC_F7		equ	65
SC_F8		equ	66
SC_F9		equ	67
SC_F10		equ	68
SC_NUM_LOCK	equ	69
SC_SCROLL_LOCK	equ	70
SC_HOME		equ	71
SC_UP_ARROW	equ	72
SC_PAGE_UP	equ	73
SC_SUBTRACT	equ	74
SC_LEFT_ARROW	equ	75
SC_GOTO		equ	76
SC_RIGHT_ARROW	equ	77
SC_ADD		equ	78
SC_END		equ	79
SC_DOWN_ARROW	equ	80
SC_PAGE_DOWN	equ	81
SC_INSERT	equ	82
SC_DELETE	equ	83
SC_SYS_REQ	equ	84
SC_EXTENDED	equ	96
SC_NUMPAD_MIN	equ	SC_HOME
SC_NUMPAD_MAX	equ	SC_DELETE+1
SC_NUMBER_MIN	equ	SC_1
SC_NUMBER_MAX	equ	SC_0+1
ifdef KANJI
SC_KANJI	equ	58
endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\fx_data.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	fx_data.asm : Fixed driver data (linked in)
;*****************************************************************************

;*	* Special DATA

sBegin	DATA
    assumes DS,DGROUP
    assumes CS,DGROUP

labelB	<PUBLIC, inkj>

	DD	EnableKeyboardKbd
	DD	PollKeyboardKbd
	DD	FlushKeyRgchKbd
	DD	MkGetShiftStatesKbd
	DD	SetShiftKkKbd
	DD	ChAlternateKeytopKbd
	Assert <(($ - inkj) / 4) EQ cpfnKbdMin>

sEnd	DATA

;*****************************************************************************
;* Zero initialized data

sBegin	BSS
    assumes DS,DGROUP

IFDEF DUALOS2
externW	rgwDataKbd
ELSE ;!DUALOS2
;*	* NOTE: Assertion (SIZE KDDATA(fxdkbd3)) >= (SIZE KDDATA(fxdkbd5))
globalW	rgwDataKbd, <((cbDataKbd + 1)/ 2) DUP (?)>	;* Keyboard driver data
ENDIF ;!DUALOS2

sEnd	BSS

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\chktandy.asm ===
;---------------------------------------------------------------------------
;CHKTANDY.ASM
;
;       Routines to check for TANDY 1000 machine and install the TANDY
;       keyboard driver for CW
;---------------------------------------------------------------------------

        include drv.inc
        include fxdrv.inc
        include inkbd.inc

;---------------------------------------------------------------------------
;Keyboard driver special data segment
;---------------------------------------------------------------------------
sBegin  DATA

externB inkj
externB tnkj

sEnd    DATA

;---------------------------------------------------------------------------
;Keyboard driver segment
;---------------------------------------------------------------------------
sBegin	DRV
    assumes CS,DRV
    assumes ds,NOTHING
    assumes ss,NOTHING

;---------------------------------------------------------------------------
;InstallTandyKBDDRV
;
;	Copies the function jump table in TANDY.ASM to the currently
;	installed table (FX_KBD3.ASM)
;
;	entry:	n/a
;
;	exit:	n/a
;
;	crunch: AX, CX
;---------------------------------------------------------------------------

cProc	InstallTandyKBDDRV,<FAR, PUBLIC>,<SI,DI,DS>
cBegin	InstallTandyKBDDRV

        mov     ax, DGROUP
        mov     es, ax
        mov     ds, ax
        mov     si, DATAoffset tnkj             ;addr if tandy jmp-table
        mov     di, DATAoffset inkj             ;addr of current jmp-table
        mov	cx, cpfnKbdMin * 2		;Number of entries (DWords)
        rep	movsw				;install new table
        
cEnd	InstallTandyKBDDRV

;----------------------------------------------------------------------------
;FCheckTandy1000
;	Check for Tandy 1000 Machine, and call the Tandy KBD DRV install
;       routine if detected.
;
;	entry:	n/a
;
;	exit:   n/a
;----------------------------------------------------------------------------

segROM	EQU     0F000H

cProc	FCheckTandy1000, <PUBLIC, FAR>, <>
cBegin	nogen	; FCheckTandy1000

	push	ds
	mov	ax,segROM
	mov	ds,ax
	cmp	byte ptr ds:[0C000h],21h
	pop	ds

	jne	fcTandyNo
        call    InstallTandyKBDDRV

fcTandyNo:
	ret

cEnd	nogen	; FCheckTandy1000

sEnd    DRV

        end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\inc\kbd_ibm.asm ===
;*
;*	CW : Character Windows
;*
;*	kbd_ibm.asm : standard IBM procedures (and helpers)



ifndef MkGetShiftStates_NonDefault
;*****************************************************************************
;********** MkGetShiftStatesKbd **********
;*	* KBD entry point (see documentation for interface)
;*	* return MK values from last saved shift states

cProc	MkGetShiftStatesKbd, <FAR, PUBLIC, ATOMIC>
cBegin	MkGetShiftStatesKbd

	mov	bx,OFF_lpwDataKbd

	xor	ax,ax
	mov	dx,[bx].ssOld
	test	dl,SS_SHIFT
	jz	not_mk_shift
	Assert	<MK_SHIFT LT 100H>
	or	ax,MK_SHIFT
not_mk_shift:
	test	dl,SS_CONTROL
	jz	not_mk_control
	Assert	<MK_CONTROL LT 100H>
	or	ax,MK_CONTROL
not_mk_control:
	test	dl,SS_ALT
	jz	not_mk_menu
	Assert	<MK_MENU GE 100H>
	or	ah,HIGH MK_MENU
not_mk_menu:

cEnd	MkGetShiftStatesKbd

;*****************************************************************************
endif	;* MkGetShiftStates_NonDefault


;*****************************************************************************
;*	* HELPER ROUTINES *


;********** DoShift **********
;*	entry : ssNew = shift state
;*		DS:DI => driver data
;*	* set the new shift state
;*	exit : n/a

cProc	DoShift, <NEAR, ATOMIC, PUBLIC>
    parmW ssNew
cBegin	DoShift

	AssertEQ di,OFF_lpwDataKbd
;{{
;	if (ssNew == ssOld)
;		return;
;}}
	mov	ax,ssNew
	mov	dx,[di].ssOld
	cmp	ax,dx
	je	end_do_shift

;{{
;	kkNew = KkOfSs(ssNew);
;	kkOld = KkOfSs(ssOld);
;	if (kkNew != kkOld)
;		// special message for change in shift states
;		KeyboardMessage(0, kkOld, kkNew, TRUE);
;}}

	cCall	KkOfSs, <ax>
	mov	cx,ax				;* cx = kkNew
	cCall	KkOfSs, <dx>			;* ax = kkOld, dx = ssOld

	cmp	ax,cx
	je	done_update_shift_kk

	mov	bx,[di].pinkbCur
	push	dx				;* save ssOld
	push	ax				;* save kkOld

	xor	dx,dx
IFDEF	KANJI
	cCall	[bx].lpfnKeyboardMessageInkb, <dx, dx, ax, cx, sp>
ELSE
	cCall	[bx].lpfnKeyboardMessageInkb, <dx, ax, cx, sp>
ENDIF	; KANJI

	pop	ax
	pop	dx

done_update_shift_kk:	;* ax = kkOld, dx = ssOld

;{{
;	/* check for shift event up or down */
;	ssDelta = ssOld ^ ssNew;
;	if (ssDelta & SS_ALT)
;		{
;		KeyboardMessage(VwOfVk(VK_MENU), VwOfVk(VK_MENU), KkOfSs(ssNew),
;		    ~ssNew & SS_ALT);
;		}
;	if ((ssDelta & SS_SPACE) && !(ssNew & SS_SPACE))
;		{
;		/* releasing SPACE key */
;		KeyboardMessage(VwOfVk(VK_SPACE), VwOfVk(VK_SPACE),
;		    KkOfSs(ssNew), TRUE);
;		}
;}}

	mov	ax,ssNew
	xor	dx,ax				;* dx = ssDelta
	test	dx,SS_ALT
	jz	not_ss_menu
	mov	bx,ax
	not	bx
	and	bx,SS_ALT			;* ssMask & ~ssNew
	mov	cl,VwOfVk(VK_MENU)
	cCall	KeyboardMessageShort

not_ss_menu:
	test	dx,SS_SPACE
	jz	not_ss_space
	test	ax,SS_SPACE
	jnz	not_ss_space

	mov	cl,VwOfVk(VK_SPACE)
	mov	bx,sp				;* fUp = TRUE
	cCall	KeyboardMessageShort

not_ss_space:
	
;{{
;	ssOld = ssNew;
;}}
	mov	ax,ssNew
	mov	[di].ssOld,ax

end_do_shift:

cEnd	DoShift


;********** KeyboardMessageShort **********
;*	entry : cl = vw
;*		bx = fUp
;*		ax = ssNew
;*		DS:DI => driver data
;*	* Call KeyboardMessage
;*	exit : n/a
;*	RETAINS : ax, dx

cProc	KeyboardMessageShort, <NEAR>, <AX, DX>
cBegin	KeyboardMessageShort

	AssertEQ di,OFF_lpwDataKbd

IFDEF	KANJI
	xor	dx,dx
	push	dx				;* sc
ENDIF	; KANJI
	xor	ch,ch
	push	cx				;* vw
	inc	ch				;* vw -> vk
	push	cx				;* vk
	cCall	KkOfSs, <ax>			;* KkOfSs(ssNew)
	push	ax
	push	bx				; fUp

	mov	bx,[di].pinkbCur
	cCall	[bx].lpfnKeyboardMessageInkb

cEnd	KeyboardMessageShort


;********** KkOfSs() **********
;*	entry : ssParm contains shift states
;*	* convert ss to kk values
;*	exit : AX = kk
;*	* TRASHES only AX

cProc	KkOfSs, <NEAR, ATOMIC, PUBLIC>
    parmW ssParm
cBegin	KkOfSs

	mov	ax,(ssParm)
;*	* the following code assumes the SS_ and KK_ values !!!
	Assert	<SS_SHIFT EQ 3>		;* lower 2 bits
	Assert	<SS_CONTROL EQ 4>
	Assert	<SS_ALT EQ 8>
	Assert	<SS_SCRLOCK EQ 10H>
	Assert	<SS_NUMLOCK EQ 20H>
	Assert	<SS_CAPLOCK EQ 40H>

	Assert	<SS_LSHIFT EQ HIGH(KK_SHIFT)>
	Assert	<SS_CONTROL EQ HIGH(KK_CONTROL)>
	Assert	<SS_ALT EQ HIGH(KK_ALT)>
	Assert	<SS_SCRLOCK EQ HIGH(KK_SCRLOCK)>
	Assert	<SS_NUMLOCK EQ HIGH(KK_NUMLOCK)>
	Assert	<SS_CAPLOCK EQ HIGH(KK_CAPLOCK)>

	test	al,SS_RSHIFT
	jz	not_rshift
	or	al,SS_LSHIFT		;* set lshift to reflect total shift
not_rshift:
	and	al,SS_CAPLOCK OR SS_NUMLOCK OR SS_SCRLOCK OR SS_ALT OR SS_CONTROL OR SS_LSHIFT
	xchg	al,ah			;* convert ss to kk
ifdef KANJI
	test	al,HIGH(SS_EXTENDED)
	jz	no_extend
	or	ah,HIGH(KK_EXTENDED)
no_extend:
	and	al,KJ_KANA
else
	and	al,HIGH(SS_EXTENDED)
	jz	no_extend
	xor	al,al
	or	ah,HIGH(KK_EXTENDED)
no_extend:
endif

cEnd	KkOfSs

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\fx_kbd3.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	fx_kbd3.asm : DOS 3 Fixed keyboard driver (linked in)
;*	* DOES NOT INCLUDE "kbd_code"
;*	* has data in application's data segment
;*****************************************************************************

	include	kbd_head.inc

	include	fxdrv.inc

	include	kbd3.inc
	;* special stuff for DOS 3 driver
	include scan3.inc
	include tsr3.inc
	include bios.inc

	include	kbd_data.inc

;*****************************************************************************

;*	* Special DATA
	include	fx_data.asm

;*****************************************************************************

sBegin	DRV
    assumes CS,DRV
    assumes ds,NOTHING
    assumes ss,NOTHING

;*	* There is no low memory structure for the linked driver
lpwDataKbd	EQU	THIS DWORD
OFF_lpwDataKbd	DW	dataOffset rgwDataKbd
SEG_lpwDataKbd	DW	SEG DGROUP

STD_NUMPAD = 1		; normal DOS3 numpad handling (eats '5')

;*****************************************************************************

;*	* keyboard tables go here

	include keytable.asm			;* Scan code tables

	include	kbd_ibm.asm			;* IBM helpers etc


;*****************************************************************************

;*	* Main routines

	include	keyacc3.asm			;* accessory routines

	include	keyddl3.asm			;* shift diddle tables

	include	keyint3.asm			;* interrupt

	include	keyxlat.asm			;* polling translations

;*****************************************************************************

	include	kbd_std.asm		;* standard init/term

;*****************************************************************************

	include	kbd_tail.asm		;* tail file

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\fx_kbd5.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	fx_kbd5.asm : OS/2 Fixed keyboard driver (linked in)
;*	* DOES NOT INCLUDE "kbd_code"
;*	* has data in application's data segment
;*****************************************************************************

DOS5	= 1			;* special OS/2 flag for table variations

	include	kbd_head.inc
	include	fxdrv.inc

	include scan3.inc
	include	kbd5.inc

	include	kbd_data.inc

;*****************************************************************************

;*	* Special DATA
	include	fx_data.asm

;*****************************************************************************

sBegin	DRV
    assumes CS,DRV
    assumes ds,NOTHING
    assumes ss,NOTHING

;*	* There is no low memory structure for the linked driver
OFF_lpwDataKbd	DW	dataOffset rgwDataKbd

;*****************************************************************************

;*	* keyboard tables go here

	include keytable.asm

;*****************************************************************************

;*	* Main routines

	include	keymon5.asm			;* monitor for keyboard

	include	keyxlat.asm			;* key translations

	include	kbd_ibm.asm			;* IBM helpers etc

;*****************************************************************************

	include	kbd_std.asm		;* standard init/term

;*****************************************************************************

	include	kbd_tail.asm		;* tail file

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\ibmcvt.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	ibmcvt.asm : IBM Convertible DOS 3 installed keyboard driver
;*****************************************************************************

	include	kbd_head.inc

	include	kbd3.inc
	;* special stuff for DOS 3 driver
	include scan3.inc
	include tsr3.inc
	include bios.inc

	include	kbd_data.inc

;*****************************************************************************

	include	kbd_code.asm

;*****************************************************************************

;*	* keyboard tables go here

	include keytable.asm			;* Scan code tables

	include	kbd_ibm.asm			;* IBM helpers etc

;*****************************************************************************

;*	* Main routines

	include keyacc3.asm			;* accessory routines

	include	keyddl3.asm			;* shift diddle tables

	include	keyint3.asm			;* interrupt

	include	keyxlat.asm			;* polling translations

;*****************************************************************************

	include	kbd_std.asm		;* standard init/term

;*****************************************************************************

	include	kbd_tail.asm		;* tail file

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\kbd5.inc ===
;*
;*	CW : Character Windows Drivers
;*
;*	kbd5.inc : OS/2 keyboard header
;*****************************************************************************

.286p		;* use 286 instructions (push immediate)

; Keystroke monitor input and output buffers length

cbBuffer	equ	128
cbStack		equ	2048


; Keystroke monitor record structure
;
KBRD	STRUC
MonFlags	dw	?       ; Open, Flush, Close info and original scan code
XlatedChar	db	?       ; Ascii code
XlatedScan	db	?       ; Translated scan code
DBCSStatus	db	?       ; Interim flag
DBCSShift	db	?       ; Reserved (also defined as NLS Shift Status)
ssKbrd		dw	?       ;
timeKbrd	dd	?       ; Time stamp of the keystroke
KbdFlags	dw	?       ;
KBRD	   ENDS

; Keystroke monitor record flags (Scan code is in upper byte)
;
fOpen	equ    0000000000000001b   ; documentation wrong, not used ?
fClose	equ    0000000000000010b   ; documentation wrong, not used ?
fFlush	equ    0000000000000100b   ; documentation wrong, not used ?
mScan	equ    0111111100000000b   ; scan code (hardware)

; Keystroke monitor keyboard flags
;
fBreak	equ    0000000001000000b   ; key is released
fSecond equ    0000000010000000b   ; scan is extended
fAccent equ    0000001000000000b   ; scan is accented
mAction equ    0000000000111111b   ; action field

; Keyboard status (KbdSet/GetStatus) structure
;
KBST	STRUC
cbKbst		DW	0Ah
fsMask		DW	0
chTurnAround	DW	0
fsInterim	DW	0
fsState		DW	0
KBST	ENDS

;*****************************************************************************

;*	* Data for the DOS 3 driver

KDDATA	STRUC		;* Keyboard driver data

;*	* Common driver items:
	pinkbCur	DW	0	;* pointer to INKB
	ssOld		DW	0	;* old state (for translation)
	pmpscvwShift	DW	0	;* shift keys
	pmpscvwPlain	DW	0	;* plain keys

;*	* Driver data	OS/2
	fEnabled	DB	0	;* => keyboard enabled
	fEnableMonitor	DB	0	;* => monitor enabled

	idThread	DW	?	; Thread ID

	hDevice		DW	?	; handle for keyboard device
	hMonitor	DW	?	; handle for keyboard device monitor

	selKthd		DW	?	;* selector for KTHD segment

	ckeyRepeat	DW	?	; count of artificial key repeats
	chPrev		DB	?	; last key hit, CH
	scPrev		DB	?	; last key hit, SC (must follow CH)
	ssPrev		DW	?	; last key hit, SS

KDDATA	ENDS

;*****************************************************************************

;* Thread extra data (pointed to by SS in thread)
KTHD	STRUC
	selAppKthd	DW	?	;* stack segment for main program

	kbrdKthd	DB	(size KBRD) dup (?)
					; kbrdCur for keyboard records

	cbMonKthd	DW	?	; keyboard monitor record length

	rgbBufferInKthd DB	cbBuffer dup (?); Monitor buffer In
	rgbBufferOutKthd DB	cbBuffer dup (?); Monitor buffer Out

;*	* stack (must be at end of KTHD structure)
	rgbStackKthd	DB	cbStack dup (?)
KTHD	ENDS

;*****************************************************************************

PushArg	MACRO	arg_list		;; Push multiple registers
	irp	x,<arg_list>
		push	x
	endm
ENDM

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\fx_tandy.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	fx_tandy.asm : Tandy 1000 DOS 3 LINKED-IN keyboard driver
;*	DOES NOT include kbd_code
;*	has data in application's data segment
;*****************************************************************************

	include	kbd_head.inc

	include	fxdrv.inc

	include	kbd3.inc
	;* special stuff for DOS 3 driver
	include scan3.inc
	include tsr3.inc
	include bios.inc

	include	kbd_data.inc

;*****************************************************************************

;*	* Special DATA
	include	fx_data.asm
                                              
;*****************************************************************************

sBegin	DRV
    assumes CS,DRV
    assumes ds,NOTHING
    assumes ss,NOTHING

;*	* There is no low memory structure for the linked driver
lpwDataKbd	EQU	THIS DWORD
OFF_lpwDataKbd	DW	dataOffset rgwDataKbd
SEG_lpwDataKbd	DW	SEG DGROUP

;STD_NUMPAD = 1		; normal DOS3 numpad handling (eats '5')
TANDY_1000 = 1	; special key interrupt handling

;*****************************************************************************

;*	* keyboard tables go here

	include tantable.asm			;* Scan code tables

	include	kbd_ibm.asm			;* IBM helpers etc

;*****************************************************************************

;*	* Main routines

	include keyacc3.asm			;* accessory routines

	include	keyint3.asm			;* interrupt

	include	tanxlat.asm			;* polling translations

;*****************************************************************************

	include	kbd_std.asm		;* standard init/term

;*****************************************************************************

	include	kbd_tail.asm		;* tail file

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\kbd3.inc ===
;*
;*	CW : Character Windows Drivers
;*
;*	kbd3.inc : DOS 3 keyboard header
;*****************************************************************************

QUEUE	STRUC		;* queue for BIOS keys
pStartQueue	dw	?
pEndQueue	dw	?
pHeadQueue	dw	?
pTailQueue	dw	?
semInsertQueue	db	?
semRemoveQueue	db	?
QUEUE	ENDS

semQueue	EQU	word ptr (semInsertQueue)
clKbdBuff	EQU	16

RST_IDLE	EQU	0		;* autorepeat states
RST_WAITING	EQU	1
RST_REPEATING	EQU	2

;*****************************************************************************

;*	* Data for the DOS 3 driver

KDDATA	STRUC		;* Keyboard driver data
	pinkbCur	DW	0		;* pointer to INKB

;*	* old pointers
	pfnOldInt09	DD	0		;* old INT 9 handler
	pfnOldInt1b	DD	0		;* old INT 1B handler
	pfnOldInt08	DD	0
	pfnOldInt16	DD	0		;* old INT 16 handler

	ssLastInt	DW	0		;* shift state at last interrupt
	ssOld		DW	0		;* old state (for translation)

;*	* Queue for keys
	queueKb		DB SIZE QUEUE DUP (?)

;*	* Extra buffer for BIOS keys :
	rglKbBuffer	DD	clKbdBuff dup(?)

	pmpscvwShift	DW	0		;* shift keys
	pmpscvwPlain	DW	0		;* plain keys

;;;*	* Misc BYTE variables:
;;	semCopyQueue	DB	0		;* semaphore for CopyQueue
	
	fKeyboardEnabled DB	0		;* => already enabled
	fShiftStateDiddled DB	0		;* => shift state diddled

	;* NOTE: The following two bytes must be together in this order because
	;* they are sometimes loaded as a word (ssCur)
	sslMirror	DB	0		;* mirror of Bios
	sshExtra	DB	0		;* our own extra states

	Int16_CmdBase	DB	0

	rstCur		DB	RST_IDLE
	scRepeatWhich	DB	0
	ckeyRepeat	DW	0
	fRepeatToggle	DB	0
	chPrev		DB	0
	scPrev		DB	0
	ssPrev		DW	0

	fInt15_4F_Supported	DB	0
	fUnhook16	DB	0

KDDATA	ENDS


;*	* Aliases for double bytes
ssCur		EQU	WORD PTR (sslMirror)
wTsrRepeat	EQU	WORD PTR (fKeyIsUpInkb)
keyPrev		EQU	WORD PTR (chPrev)

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\keyint3.asm ===
;
;	CW : Character Windows Drivers
;
;	keyint3.asm : DOS 3 key interrupt
;
;----------------------------------------------------------------------------

; Code space constants

staticD	lpsslBios,417H			;* BIOS shift state 0040:0017 !!!!

; Code space data!  Horrors!

staticD	pfnOldInt15,0			; old int 15 handler

;----------------------------------------------------------------------------

;********** EnableKeyboardKbd **********
;*	entry:	pinkb => INKB data
;*		fEnable => whether to enable or disable
;*		fExiting => exiting if !fEnable
;*	* enable or disable the keyboard handler
;*	exit : n/a

cProc	EnableKeyboardKbd, <FAR, PUBLIC, ATOMIC>, <DI>
    parmDP pinkb
    parmW  fEnable
    parmW  fExiting
cBegin	EnableKeyboardKbd

;*	* save pointer to INKB data
	mov	di,OFF_lpwDataKbd		;* Data in data segment
	mov	bx,pinkb
	mov	[di].pinkbCur,bx

	mov	ax,fEnable
	mov	[bx].fPollKeyboardInkb,ax	;* to poll or not to poll?
	or	ax,ax
	jnz	enable_keyboard

	jmp	disable_keyboard

enable_keyboard:
;*	* Enable the keyboard
	test	[di].fKeyboardEnabled,0ffh
	jz	enable_keyboard2
	jmp	end_enable_keyboard		;* already enabled

enable_keyboard2:
;*	* Initialize globals
;;	mov	[di].semCopyQueue,-1
	
	lea	ax,[di].rglKbBuffer
	mov	[di].queueKb+pStartQueue,ax
	mov	[di].queueKb+pHeadQueue,ax
	mov	[di].queueKb+pTailQueue,ax
	add	ax,clKbdBuff * 4		;* point to end
	mov	[di].queueKb+pEndQueue,ax
	mov	[di].queueKb+semQueue,-1	; initialize both semaphores

;*	* set globals to reflect initial state AND
;*	*  query to see if TSR is present
	mov	ax,tsrcInitTerm
	mov	[di].fKeyboardEnabled,al		;* enabled
	mov	bx,[di].pinkbCur
	mov	[bx].fKeyIsUpInkb,al			;* set up state

IFDEF WORDTSR
	;* Word protocal
	mov	ax,55FFh
	mov	bx,5
	xor	cx,cx
	int	16H
	xor	ax,4D53h
	jnz	@F
	mov	bx,[di].pinkbCur
	mov	[bx].fNormalKeyboardInkb,ax	;* 0 => proper TSR present
@@:
ELSE ;!WORDTSR
	;* Works (default) protocal
	lea	cx,[di].wTsrRepeat			;* DS:CX => two flags
	Assert	<verTsr EQ 0>
	xor	dx,dx
	mov	bx,drvOffset TsrRequest

	push	cs
	pop	es				;* es:bx => TsrRequest
	int	16H				;* nothing to return

	xor	ax,ackTsr			;* acknowledge ?
	mov	bx,[di].pinkbCur
	mov	[bx].fNormalKeyboardInkb,ax	;* 0 => proper TSR present
ENDIF ;!WORDTSR

;*	* Hook the INT 1B handler
	mov	al, 1Bh
	mov	bx, pfnOldInt1B		;* offset into KBD data
	mov	dx, drvOffset Int1BHandler
	cCall	Hooker

	mov	bx,[di].pinkbCur
	mov	cx,[bx].fNormalKeyboardInkb
	jcxz	end_enable_keyboard

;*	* Hook and initialize the INT 08 handler
	mov	al, 08h
	mov	bx, pfnOldInt08
	mov	dx, drvOffset Int08Handler
	cCall	Hooker

	mov	[di].rstCur, RST_IDLE
	mov	[di].ckeyRepeat, 0

;*	* Hook INT 16
	mov	al, 16h
	mov	bx, pfnOldInt16
	mov	dx, drvOffset Int16Handler
	cCall	Hooker
	mov	[di].fUnhook16, 0

;*	* Hook INT 9 (TSR not present)
	mov	al, 09h
	mov	bx, pfnOldInt09
	mov	dx, drvOffset Int09Handler
	cCall	Hooker

	call	HookInt15

	les	bx,lpsslBios
	mov	al,es:[bx]
	mov	[di].sslMirror,al
	mov	byte ptr [di].ssLastInt,al		;* set low byte only

;*	* check for extended (ronco) keyboard
	mov	[di].pmpscvwPlain,drvOffset mpscvwPlain
	mov	[di].pmpscvwShift,drvOffset mpscvwShift
IFNDEF	TANDY_1000	;* don't have to worry about this
	test	byte ptr es:[KbType],10H
	jz	not_ronco				;* not extended
	mov	bx,[di].pinkbCur
	cmp	[bx].fDisableExtendedInkb,0
	jne	not_ronco				;* not allowed
	mov	[di].Int16_CmdBase,10H
	mov	[di].pmpscvwPlain,drvOffset mpscvwPlainRonco
	mov	[di].pmpscvwShift,drvOffset mpscvwShiftRonco
ENDIF	; !TANDY_1000
not_ronco:



end_enable_keyboard:

cEnd	EnableKeyboardKbd

;*	* Disable keyboard *

disable_keyboard:
	test	[di].fKeyboardEnabled,0ffh
	jz	end_enable_keyboard
	mov	[di].fKeyboardEnabled,0

;*	* disable TSRs (even if they did not register with us)
IFDEF WORDTSR
	;* inform of departure
	mov	ax,55FFh
	mov	bx,5
	mov	cx,1
	int	16H
ELSE ;!WORDTSR
	mov	ax,tsrcInitTerm
	mov	dx,verTsrTerm			;* signal termination
	xor	bx,bx
	cmp	fExiting,0
	jne	exiting_forever
	inc	bx
exiting_forever:
	int	16H				;* nothing to return
ENDIF ;!WORDTSR

;*	* remove hooks
	push	ds
	mov	bx,[di].pinkbCur
	mov	cx,[bx].fNormalKeyboardInkb
	lds	dx,[di].pfnOldInt1B
	mov	ax,251BH
	int	21H

	jcxz	int9_not_hooked
	lds	dx,ss:[di].pfnOldInt08		;* get old int 08 handler
	mov	ax, 2508h
	int	21h

	lds	dx,ss:[di].pfnOldInt09		;* get old int 9 handler
	mov	ax,2509H
	int	21H

	lds	dx,ss:[di].pfnOldInt16
	mov	ax, 2516h
	int	21h

	cmp	ss:[di].fInt15_4F_Supported,0
	je	int15_not_hooked

	lds	dx,pfnOldInt15			;* get old int 15 handler
	mov	ax,2515H
	int	21H

int15_not_hooked:

int9_not_hooked:
	pop	ds
	jmp	short end_enable_keyboard


;----------------------------------------------------------------------------
;
; ::: Decide if we're going to hook int15 (to watch for int9 4F callback) :::
; 
; On the PS/2, it's risky to directly poll the keyboard with IN AL,60.
; The BIOS int9 provides a solution; it performs an int15 w/AH=4F and AL=
; the scan code.  An application can hook int15/4F and see the scan code
; without doing the direct polling.
;
; The only app we've seen that actually \required/ this was Word 4.0.  If
; you hold down the Alt key and roll the mouse around, Word 4.0 goes bongos.
; The int15/4F callback was implemented for Word 4.00A.
;
;;; We decided with Word 4.00A to only implement the callback with 
;;; DOS >= 3.30 but not 4.x.  This may be overly restrictive, but it 
;;; guarentees we catch all the PS/2s, which was the intent.
;
; We had decided the above.  But with MS-DOS 4.0 that changed, and we now
; implement for it also, meaning for all DOS >= 3.30.
;
; Note that if any TSR grabs int9 and does the IN AL,60, we're suspect to the
; same behaviour even if we're using the callback method.  The UB Network
; software is an example.

HookInt15:

	mov	ax,3000h
	mov	[di].fInt15_4F_Supported,al
	int	21h
	xchg	ah,al

	cmp	ax,031Eh		; If DOS < 3.30, then don't hook.
	jb	NoInt15

	mov	ax,0C000h
	int	15h			; Get system configuration parms.

	jc	NoInt15			; According to PS/2 BIOS TechRef:
	or	ah,ah			;   support    -> NC and AH == 0
	jnz	NoInt15			;   nonsupport -> CY and AH != 0

	test	byte ptr es:[bx+5],00010000b	; If kbd intercept sequence
	jz	NoInt15				; is alive, install our Int15

	mov	ax,3515h
	int	21h
	mov	word ptr pfnOldInt15,bx		; Should use CS override.
	mov	word ptr pfnOldInt15+2,es

	push	ds
	push	cs
	pop	ds
	mov	dx,drvOffset Int15Handler
	mov	ax,2515h
	int	21H
	pop	ds

	dec	[di].fInt15_4F_Supported
NoInt15:
	ret

;---------------------------------
; Hooker
;	Hooks an interrupt and saves the old handler's address in [DI].bx
;
;	entry:	AL = interrupt number
;		BX = kbd data offset of dword to contain old address
;		DX = drvOffset of new handler
;
cProc	Hooker, <NEAR, ATOMIC>
cBegin	Hooker

	AssertEQ di, OFF_lpwDataKbd

	push	dx
	push	ax
	push	bx

	mov	ah, 35h
	int	21h
	mov	ax, bx
	pop	bx
	add	bx, di
	mov	[bx], ax
	mov	[bx+2], es

	pop	ax
	mov	ah, 25h
	pop	dx
	push	ds
	push	cs
	pop	ds
	int	21h
	pop	ds

cEnd	Hooker

;----------------------------------------------------------------------------
;
;   TsrRequest
;
;	entry : AH = request code
;	* called by TSR programs to request action
;	exit : n/a (trashes normal registers)

cProc	TsrRequest, <FAR, ATOMIC>, <DS, DI>
cBegin	TsrRequest

	mov	cx,SEG_lpwDataKbd
	mov	ds,cx
	mov	di,OFF_lpwDataKbd		;* Data in data segment
	mov	bx,[di].pinkbCur
;*	* DS:DI => data, DS:BX => INKB

	cmp	ah,tsrrIgnoreAltUp
	jne	not_ignore_altup
	mov	[bx].fNonAltKeyHitInkb,1	;* => ignore next
not_ignore_altup:
	cmp	ah,tsrrAbort
	je	tsr_special_abort
end_tsr_request_poll:
;*	* after any request, poll the TSR
	mov	[bx].fPollKeyboardInkb,1
end_tsr_request_nopoll:

cEnd	TsrRequest


tsr_special_abort:
;*	* we have an escape key
	cCall	[bx].lpfnSpecialAbortInkb	;* call SpecialTsrAbort
	jmp	short end_tsr_request_nopoll

;----------------------------------------------------------------------------
;
; Int1BHandler()
;
; INT 1B is invoked when the ROM BIOS sees CTRL-BREAK.
; We hook this interrupt so that DOS never sees the CTRL-BREAK.
;
; Inputs:	none.
; Outputs:	none.
; Uses:		none, everything is saved.

Int1BHandler:
IFDEF KBD_CTRL_C_ABORT
	push	ds
	push	di
	push	ax
	mov	ax,SEG_lpwDataKbd
	mov	ds,ax
	mov	di,OFF_lpwDataKbd	;* Data in data segment
	mov	di,[di].pinkbCur	;* point to INKB
	mov	[di].fAbortInkb,1	;* Weird Abort (no message)
	pop	ax
	pop	di
	pop	ds
ENDIF
	iret


;----------------------------------------------------------------------------
;
;  InKey
;	entry : n/a
;	* Get an input key
;	exit : DX:AX = long value
;		DX = shift states
;		AH = scan code
;		AL = char
;		DS:DI => driver data
;	Note : a null character state is returned as AX==0

cProc	InKey,<PUBLIC,NEAR,ATOMIC>,<SI>
cBegin	InKey

	AssertEQ di,OFF_lpwDataKbd

	mov	bx,[di].pinkbCur
	mov	cx,[bx].fNormalKeyboardInkb
	jcxz	inkey_tsr

	xor	ax,ax
	cCall	LockRemoveQueue
	mov	dx,[di].ssCur
	jnz	end_inkey			; queue already locked
	mov	bx,[si].pHeadQueue
	cmp	bx,[si].pTailQueue
	jne	ik_readq
	cCall	FnzGetBiosKey
	jnz	ik_releaseq
	xor	ax,ax
	jmp	short ik_releaseq

ik_readq:
	mov	ax,[bx+0]
	mov	dx,[bx+2]
	cCall	IncQueuePtr
	mov	[si].pHeadQueue,bx

ik_releaseq:
	cCall	ReleaseRemoveQueue

end_inkey:

cEnd	InKey

inkey_tsr:
	xor	bx,bx
	mov	ax,tsrcInkey			;* special get key request
	int	16H				;* returns AH = sc, AL = char
						;* BX = ss
	mov	dx,bx
	jnz	end_inkey			;* got one (dx always valid)
	xor	ax,ax
	jmp	short end_inkey
	

;----------------------------------------------------------------------------


;********** FnzGetBiosKey **********
;*	entry : DS:DI => driver data
;*	* check for a bios character
;*	exit : z=> no key,
;*		else AX = char + scan code, DX = shift states
;*	TRASHES : AX/DX

cProc	FnzGetBiosKey, <NEAR>
cBegin	FnzGetBiosKey

	AssertEQ di,OFF_lpwDataKbd

	push	bx			;* Some TSRs clobber this
	push	cx			;* possibly this too

	mov	ah,[di].Int16_CmdBase	; Is there anything to get?
	inc	ah
	pushf
	call	[di].pfnOldInt16	; call the real BIOS, not our hook
	jz	end_bios_get_key	; nope return z

					; Liar!  Check again!

	mov	ah,[di].Int16_CmdBase	; Burn some time; get kbd flags.
	inc	ah
	inc	ah
	pushf
	call	[di].pfnOldInt16	; call the real BIOS, not our hook

	mov	ah,[di].Int16_CmdBase	; Is there anything to get?
	inc	ah
	pushf
	call	[di].pfnOldInt16	; call the real BIOS, not our hook
	jz	end_bios_get_key	; nope return z

	mov	ah,[di].Int16_CmdBase	; Get char + scan code
	pushf
	call	[di].pfnOldInt16

	mov	dx,[di].ssCur
	or	sp,sp			; set NZ flag, we got a key!

end_bios_get_key:
	pop	cx
	pop	bx
cEnd	FnzGetBiosKey


;----------------------------------------------------------------------------

Int15Handler:

	cmp	ah,4Fh
	jne	@F

	push	ax
	push	bx
	push	cx
	push	si
	push	di
	push	ds
	push	es

	mov	di,SEG_lpwDataKbd
	mov	ds,di
	mov	di,OFF_lpwDataKbd	; DS:DI -> Data in data segment
	mov	si,[di].pinkbCur	; DS:SI -> INKB data
	les	bx,lpsslBios		; ES:BX -> kbd data in low ram

	call	ScanCodeStuff		; al = the scan code.

	stc				; We don't want to eat the keystroke.

	pop	es
	pop	ds
	pop	di
	pop	si
	pop	cx
	pop	bx
	pop	ax

@@:
	jmp	[pfnOldInt15]

;----------------------------------------------------------------------------
;
;	The keyboard hardware interrupt handler

Int09Handler:

	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	ds
	push	es

	mov	di,SEG_lpwDataKbd
	mov	ds,di
	mov	di,OFF_lpwDataKbd	; DS:DI -> Data in data segment
	mov	si,[di].pinkbCur	; DS:SI -> INKB data
	les	bx,lpsslBios		; ES:BX -> kbd data in low ram

	cmp	[di].fInt15_4F_Supported,0
	jne	@F

	in	al,KbDataPort
	cCall	ScanCodeStuff			; Do the scan-code stuff.

@@:	mov	[di].fUnhook16, 1		; Give normal int16 to TSRs
	pushf
	call	[di].pfnOldInt09		; Daisy chain.
	mov	[di].fUnhook16, 0

; Restore anything we did to the BiosShiftState in ScanCodeStuff.

	test	[di].fShiftStateDiddled,0ffH
	jz	@F				; Jmp if not diddled
	mov	al,[di].sslMirror
	mov	es:[bx],al
	mov	[di].fShiftStateDiddled,0
@@:
	mov	al,es:[bx]
	mov	[di].sslMirror,al

ifdef KANJI
	mov	ah, 51h			; AX bios: get KANA shift status
	int	16h

	and	[di].ssCur, not SS_KANA
	test	ah, 00000010b		; test KANA bit
	jz	@F
	or	[di].ssCur, SS_KANA
@@:
endif	; KANJI

	cmp	[di].rstCur, RST_REPEATING
	jne	@F
	call	KillQueue
	jmp	short ExitInt09
@@:
	call	CopyQueue

ExitInt09:
	mov	[si].fPollKeyboardInkb,1    ;; poll to see if anything happened

	pop	es
	pop	ds
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	iret

;----------------------------------------------------------------------------
;
; Input:     AL = the scan code (this is all-important)
;            DS:SI = ptr to keyboard data.
;            DS:DI = ptr to Data in data segment.
;            ES:BX = ptr to keyboard data in low RAM.
;
; Crunches:  AX,CX
;
; Preserves: BX,DX,SI,DI,DS,ES

cProc	ScanCodeStuff, <NEAR>
cBegin	nogen	; ScanCodeStuff

	cld

	mov	ah,al
	and	ah,080H			; make/break in ah

;*	* In order to detect repeating key sequences, the "fKeyIsUp" global
;*	*  variable is clear whenever a key is down (set with any keyup).
;*	* The "fKeyWasUp" variable is set on each key up event.
;*	* (i.e. fKeyIsUp is the state, fKeyWasUp is the transition).
;*	* NOTE : this is not fool-proof but handles most cases well, see the
;*	*  API document for example usage of these two flags


	cmp	al,0E0H
	je	dont_touch_fkey		;* skip for extended key
	mov	[si].fKeyIsUpInkb,ah
	cmp	al,0F0H
	je	dont_touch_fkey		;* skip for break
	or	[si].fKeyWasUpInkb,ah
dont_touch_fkey:

	and	al,07fH			; scan code in al

IFDEF	DEBUG

;  From windows: (minor alterations)
;
;  The SYS REQ key is used to simulate an NMI.
;  This is done by clearing up the stack and doing a far jump to the NMI
;  interrupt vector location.  If the NMI interrupt points into the ROM,
;  we don't jump, since the ROM treats NMIs as parity errors.
;
;  On the RT keyboard SYS REQ is generated by hitting Alt-PrintScreen,
;  badly this combination also has a special meaning in Windows (transfert
;  screen contents to the clipboard). To survive we'll keep this 2nd
;  behaviour and the NMI feature will be reached by hitting Crt-Alt-PrintScreen.
;

SYSREQ  EQU     054h    ; PC-AT SYS REQ key
cPrint  EQU     055h

OFF_nmi	EQU	2*4
SEG_nmi	EQU	2*4+2

	or	ah,ah		    ; sysreq on key down
	jnz	notsys
        cmp     al,SYSREQ           ; SYSREQ key?
        jne     notsys

	push	es		; check for RT keyboard
	xor	cx,cx
	mov	es,cx
	test	byte ptr es:[KbType],10H
	pop	es
	jz	not_ronco_int09
	test	[di].ssCur,SS_CONTROL	; else, is Ctrl down ?
	mov	al, cPrint		; new scan code (only used if no nmi)
	jz	notsys			; if not, skip (code = Print)
not_ronco_int09:

	push	es		; get NMI vector segment
	mov	es,cx			; cx is still 0
        mov     ax,word ptr es:[SEG_nmi]
	pop	es
        cmp     ax,0F000H         	; see if it points to ROM
        jne     do_nmi
        jmp     ExitScanCodeStuff

do_nmi:

ack_port equ    20h         ; 8259 acknowledge port
eoi      equ    20h         ; 8259 end of interrupt
kb_ctl   equ    61h

	in	al,kb_ctl
	mov	ah,al
	or	al,80h
	out	kb_ctl,al
	xchg	al,ah
	out	kb_ctl,al
	mov	al,eoi			; don't pass this on, eat it
	out	ack_port,al

	int	2
;;;	jmp	ExitInt09
	jmp	ExitScanCodeStuff

notsys:	; end of sysreq test

ENDIF	;DEBUG

;
; Software autorepeat control
;	This is all bypassed unless 0 < wRateKeyRepeat <= 10.
;	There are three states: IDLE, WAITING, and REPEATING.
;	IDLE is the default state, when no keydowns have been
;	received yet.  If a keydown is received in the IDLE state,
;	the state is changed to WAITING, indicating that we are
;	waiting for another copy of the same key code (when the
;	keyboard indicates enough time has passed to begin actually
;	repeating).  When we receive the same key again in the
;	WAITING state, we move on to the REPEATING state and init
;	the repeat delay counter.  This cues the timer-interrupt
;	to dump in wRateKeyRepeat extra keys every 1/18 second.  If
;	a keydown of a different key is received in the WAITING or
;	REPEATING states, the WAITING state is restarted as above.
;	A keyup with the same scan code as the last keydown changes 
;	the state to IDLE.
;
	or	ah,ah			;* key break => maybe stop repeat
	jns	a_key_down
	cmp	al, [di].scRepeatWhich	;* ignore if not same key
	jne	repeat_done
	mov	[di].rstCur, RST_IDLE
	jmp	short kill_pending	;* kill pending repeats
a_key_down:
	cmp	[di].rstCur, RST_IDLE
	jne	not_first
	cmp	[si].wRateKeyRepeatInkb, 0  ;* skip if rate = default
	jle	repeat_done
start_waiting:
	mov	[di].rstCur, RST_WAITING  ;* waiting to start repeating
	mov	[di].scRepeatWhich, al
kill_pending:
	mov	[di].ckeyRepeat, 0	;* kill pending repeats
	jmp	short repeat_done
not_first:
	cmp	al, [di].scRepeatWhich
	jne	start_waiting
	cmp	[di].rstCur, RST_REPEATING
	je	repeat_done		;* and later ignore char
	mov	cx, [si].wRateKeyRepeatInkb  ;* get CW key repeat rate
	mov	[di].ckeyRepeat, cx
	mov	[di].fRepeatToggle, 0
	mov	[di].rstCur, RST_REPEATING
repeat_done:

;
; Look for space bar down/up, and maintain its state in ssCur
;
	cmp	al,SC_SPACE
	jne	not_space_key
;*	* update the extra shift state for the spacebar
	or	[di].ssCur,SS_SPACE		;* assume down
	test	ah,080H
	jz	shift_is_down
	and	[di].ssCur,NOT SS_SPACE		;* shift is off
shift_is_down:

not_space_key:
	or	ah, ah
	jnz	ExitScanCodeStuff

;*	* if ALT or Extended key then pass on
	cmp	al,SC_ALT
	je	ExitScanCodeStuff
	cmp	al,SC_EXTENDED
	je	ExitScanCodeStuff
;*	* otherwise we have a non-alt key
	or	[si].fNonAltKeyHitInkb,ah	;* set if key down

;
; The BIOS eats a lot of CTRL- and ALT- keys that we need to preserve.
; So if CTRL or ALT is held down, we might have to fool the BIOS into
; passing the key, which we do by turning off the CTRL or ALT shift 
; state, chaining to the BIOS, then resetting the shift state.  So now
; we look up our key in a bit-packed table to see if it requires diddling...
; We also do some weird diddling (temporarily turn on the Shift key)
; for numpad 5, cause the BIOS eats that, too.
;
	mov	ah, es:[bx]		; current shift state

IFDEF	STD_NUMPAD
	cmp	al, 76			; numpad 5 scan code
	jne	CheckAltCtrl
	test	ah, SS_ALT
	jnz	ExitScanCodeStuff	; don't diddle Alt-numpad
	test	ah, SS_NUMLOCK
	jnz	NumLock5
	or	ah, SS_LSHIFT		; NumLock off ==> turn on shift
	jmp	short Num5Diddle
NumLock5:
	test	ah, SS_SHIFT
	jz	Num5Diddle		; NL, no shift ==> don't diddle
	and	ah, not SS_NUMLOCK	; NL, shift ==> turn off NL
Num5Diddle:
	and	ah, not SS_CONTROL	; turn off Ctrl
	mov	es:[bx], ah
	jmp	short SetDiddle
ENDIF	; STD_NUMPAD

IFNDEF TANDY_1000	; Tandy 1000 doesn't require any diddling
CheckAltCtrl:	
	and	ah, SS_ALT or SS_CONTROL
	jz	ExitScanCodeStuff
	push	bx
	mov	bl, al
	mov	cl, al
	and	cl, 7
	mov	al, 1
	shl	al, cl			; bit mask
	mov	cl, 3
	shr	bl, cl			; byte address
	xor	bh, bh
	cmp	ah, SS_ALT
	je	CheckAlt
	cmp	ah, SS_CONTROL
	je	CheckCtrl
	add	bx, offset mpscffAltCtrlDiddle
	jmp	short CheckDiddle
CheckCtrl:
	add	bx, offset mpscffCtrlDiddle
	jmp	short CheckDiddle
CheckAlt:
	add	bx, offset mpscffAltDiddle
CheckDiddle:
	test	cs:[bx], al
	pop	bx
	jz	ExitScanCodeStuff
DoDiddle:
	mov	byte ptr es:[bx], 0
SetDiddle:
	mov	[di].fShiftStateDiddled,ah
ENDIF ;TANDY_1000

ExitScanCodeStuff:

	ret

cEnd	nogen	; ScanCodeStuff


;----------------------------------------------------------------------------

;*	* * * QUEUE CONTROL * * *

;---------------------------------------
;
; LockInsertQueue
; LockRemoveQueue
;
;   Access the driver's keyboard queue for Insertion and Removal
;
;   entry : DS:DI => driver data
;
;   exit  : DS:SI => queue structure
;           ZR => queue available and now locked
;           NZ => queue already locked, unavailable

cProc	LockInsertQueue, <PUBLIC, NEAR, ATOMIC>
cBegin	LockInsertQueue

	AssertEQ di,OFF_lpwDataKbd

	lea	si,[di].queueKb
	inc	[si].semInsertQueue
	jz	@F
	cCall	ReleaseInsertQueue
@@:

cEnd	LockInsertQueue

cProc	LockRemoveQueue, <PUBLIC, NEAR, ATOMIC>
cBegin	LockRemoveQueue

	AssertEQ di,OFF_lpwDataKbd

	lea	si,[di].queueKb
	inc	[si].semRemoveQueue
	jz	@F
	cCall	ReleaseRemoveQueue
@@:

cEnd	LockRemoveQueue

;---------------------------------------
;
; ReleaseInsertQueue
; ReleaseRemoveQueue
;
;   Release the queue (make it available to other threads)
;
;   entry : DS:SI => queue structure
;
;   exit  : all registers (including flags) preserved

cProc	ReleaseInsertQueue, <PUBLIC, NEAR, ATOMIC>
cBegin	ReleaseInsertQueue

	pushf
	dec	[si].semInsertQueue
	popf

cEnd	ReleaseInsertQueue

cProc	ReleaseRemoveQueue, <PUBLIC, NEAR, ATOMIC>
cBegin	ReleaseRemoveQueue

	pushf
	dec	[si].semRemoveQueue
	popf

cEnd	ReleaseQueue

;;********** IncQueuePtr **********
;*	entry : BX = current queue pointer
;*		SI => QUEUE structure
;*	* bump pointer
;*	exit : BX = new pointer

cProc IncQueuePtr, <NEAR, ATOMIC>
cBegin	IncQueuePtr

	add	bx,4				;* bump long
	cmp	bx,[si].pEndQueue
	jne	inc_ok
	mov	bx,[si].pStartQueue		;* wrap around
inc_ok:
cEnd	IncQueuePtr



;********** CopyQueue **********
;*	entry:	DS:DI => driver data
;*	* copy item from bios Q to our buffer QUEUE (ignore if no room)
;*	exit : n/a

cProc	CopyQueue,<NEAR>, <si>
cBegin	CopyQueue

	AssertEQ di,OFF_lpwDataKbd

	cCall	LockInsertQueue
	jnz	cq_exit
	mov	bx,[SI].pTailQueue		;* add after tail

CopyNextKey:
	push	bx
	cCall	IncQueuePtr
	cmp	bx,[SI].pHeadQueue		;* is there room ?
	pop	bx
	jz	DoneQueueCopy			;* no room

	cCall	FnzGetBiosKey
	jnz	EnqueueKey

;*	* test to see if shift states have changed
	mov	ax,[di].ssCur
	mov	dx,ax
	xchg	ax,[di].ssLastInt		;* set new, get old
	cmp	ax,dx
	je	DoneQueueCopy			;* shift states the same
	xor	ax,ax				;* no char, ss changed though

EnqueueKey:
	;* DX:AX = key
	mov	[bx+0],ax
	mov	[bx+2],dx
	cCall	IncQueuePtr
	jmp	short CopyNextKey

DoneQueueCopy:
	mov	[SI].pTailQueue,bx
	cCall	ReleaseInsertQueue

cq_exit:

cEnd	CopyQueue

;----------------------------------------------------------------------------
;
;  KillQueue
;
;	entry: DS:DI => driver data
;	* empty the bios key queue
;	exit: n/a

cProc	KillQueue,<NEAR>, <si>
cBegin	KillQueue

	AssertEQ di, OFF_lpwDataKbd
KillKeys:
	cCall	FnzGetBiosKey
	jnz	KillKeys

cEnd	KillQueue

;----------------------------------------------------------------------------
;
; Int08Handler()
;
; INT 08 is invoked 18.2 times per second by the timer chip.  We hook
; this to get a regular interval for software auto-repeat.

Int08Handler:
	push	ds
	push	di
	push	ax
	mov	ax, SEG_lpwDataKbd
	mov	ds, ax
	mov	di, OFF_lpwDataKbd
	pushf					;* first chain to Dos
	call	[di].pfnOldInt08
	cmp	[di].rstCur, RST_REPEATING	;* skip if not repeating
	jne	int08_done
	push	si
	mov	si, [di].pinkbCur
	mov	ax, [si].wRateKeyRepeatInkb
	add	[di].ckeyRepeat, ax
	mov	[si].fPollKeyboardInkb, 1	;* tell CW about it
	pop	si
int08_done:
	pop	ax
	pop	di
	pop	ds
	iret

;----------------------------------------------------------------------------
;
; Int16Handler()
;
; BIOS int 16h (keyboard services) emulator.
; Traps AH = 0, 1, 2, 10h, 11h, or 12h; the rest are passed
;  to the default handler.
;
Int16Handler proc far
	push	ax	;(cs)	; sp +	16	;* this is for chaining
	push	ax	;(ip)	; 	14	;* (see below)
	push	ds		; 	12
	push	di		; 	10
	push	si		; 	8
	push	dx		; 	6
	push	cx		; 	4
	push	bx		; 	2
	push	ax		; 	0

	mov	di, SEG_lpwDataKbd
	mov	ds, di
	mov	di, OFF_lpwDataKbd
	cmp	[di].fUnhook16, 0
	jnz	int16_chain
	or	ah, ah
	je	int16_0
	cmp	ah, 1
	je	int16_1
	cmp	ah, 2
	je	int16_2
	cmp	ah, 10h
	je	int16_0
	cmp	ah, 11h
	je	int16_1
	cmp	ah, 12h
	je	int16_2

; Since we need to chain to the previous int 16 handler, but can't
; afford to mess up any registers to do it (e.g., via an indirect
; call or jmp using DS and DI) we poke the handler's address into a 
; convenient blank space in the stack frame, pop all registers, 
; and "return" to the old int 16 handler.  (I.e., pop+jmp an address
; on the stack.)
;
int16_chain:
	mov	bx, sp
	mov	ax, word ptr [di].pfnOldInt16	;* segment
	mov	ss:[bx+14], ax
	mov	ax, word ptr [di].pfnOldInt16+2	;* offset
	mov	ss:[bx+16], ax
	pop	ax
	pop	bx
	pop	cx
	pop	dx
	pop	si
	pop	di
	pop	ds
	ret	;far				;* to [pfnOldInt16]

int16_0:
	cCall	InKey				;* copy queue, get key
	or	ax, ax
	jnz	int16_0done			;* go return the key
	or	dx, dx				;* make sure we've got 
	jnz	int16_0				;*  all the SS events too
	cmp	[di].ckeyRepeat, 0		;* check for repeating keys
	jz	int16_0				;* keep polling if none
	dec	[di].ckeyRepeat
	mov	ax, word ptr [di].chPrev	;* use the previous key
int16_0done:
	mov	word ptr [di].chPrev, ax	;* save for repeats
	jmp	short int16_done

int16_1:
	cmp	[di].ckeyRepeat, 0		;* check artificial repeats
	jnz	int16_1ret
	lea	si, [di].queueKb
	mov	bx, [si].pHeadQueue
int16_1loop:
	cmp	bx, [si].pTailQueue
	jz	int16_1nomo			;* no mo', go check BIOS
	cmp	word ptr [bx], 0
	jnz	int16_1ret			;* true if non-nil key
	cCall	IncQueuePtr			;* skip SS-only event
	jmp	short int16_1loop		;* otherwise keep looking
int16_1nomo:
	pop	ax				;* get int 16 function #
	push	ax				;* don't mess up stack frame
	pushf
	call	[di].pfnOldInt16		;* check the BIOS buffer too
int16_1ret:
	lahf					;* ha ha ha
	and	ah, 40h				;* ZF mask in cpu flags
	mov	bx, sp
	add	bx, 22				;* offset to caller's flags
	and	byte ptr ss:[bx], not 40h
	or	byte ptr ss:[bx], ah		;* poke in ZF
	jmp	short int16_done

int16_2:
	lds	si, lpsslBios
	lodsb

int16_done:
	add	sp, 2				;* incoming ax
	pop	bx
	pop	cx
	pop	dx
	pop	si
	pop	di
	pop	ds
	add	sp, 4				;* empty space
	iret
Int16Handler endp

;************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\keyddl3.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	keyddl3.asm : DOS 3 keyboard special shift handling tables
;*
;****************************************************************************
;
; The following two data objects are bit-packed boolean arrays
;  whose indices are key scan codes (sc's).
; mpscffAltDiddle[sc] = 1 indicates that ALT-sc needs special 
;  handling to get it past the BIOS.
; mpscffCtrlDiddle[sc] is the same thing for CTRL-sc.

mpscffAltDiddle equ this byte	; Which ALT- keys require diddling
	db	00000000b	; 0-
	db	01100000b	; 8-	'=', Backspace
	db	00000000b	; 16-
	db	00000000b	; 24-
	db	00000000b	; 32-
	db	00000000b	; 40-
	db	00000000b	; 48-
	db	00000000b	; 56-
	db	00000000b	; 64-
	db	01000100b	; 72-	SUBTRACT, LEFT_ARROW, RIGHT_ARROW, ADD
	db	00000000b	; 80-
	db	00000000b	; 88-
	db	00000000b	; 96-
	db	00000000b	; 104-
	db	00000000b	; 112-
	db	00000000b	; 120-

mpscffCtrlDiddle equ this byte	; Which CTRL- keys require diddling
	db	11111100b	; 0-	'1', '2', '3', '4', '5', '6'
	db	10101111b	; 8-	'7', '8', '9', '0', '=', TAB
	db	00000000b	; 16-
	db	00000000b	; 24-
	db	10000000b	; 32-	';'
	db	00000001b	; 40-	"'"
	db	00011000b	; 48-	',' '.'
	db	00000000b	; 56-
	db	00000000b	; 64-
	db	01010101b	; 72-	Up, SUBTRACT, Num5, ADD
	db	00001101b	; 80-	Down, Ins, Del
	db	00000000b	; 88-
	db	00000000b	; 96-
	db	00000000b	; 104-
	db	00000000b	; 112-
	db	00000000b	; 120-

mpscffAltCtrlDiddle equ this byte	; Which ALT+CTRL keys to diddle
	db	00000000b	; 0-
IFNDEF LANGUAGE_SWISS
	db	01010000b	; 8-	'-', Backspace
ELSE ;LANGUAGE_SWISS
	db	01000000b	; 8-	Backspace
ENDIF ;LANGUAGE_SWISS
	db	00000000b	; 16-
	db	00000000b	; 24-
	db	00000000b	; 32-
	db	00000000b	; 40-
	db	00000000b	; 48-
	db	00000000b	; 56-
	db	00000000b	; 64-
	db	00000000b	; 72-
	db	00000000b	; 80-
	db	00000000b	; 88-
	db	00000000b	; 96-
	db	00000000b	; 104-
	db	00000000b	; 112-
	db	00000000b	; 120-

;****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\keykana.asm ===
IFDEF KANJI
;*	* Translation table for OAX
;*	* maps 'A' -> 'Z' into Kanas on same key
rgchKana:
	DB	0c1H, 0baH, 0bfH, 0bcH, 0b2H, 0caH, 0b7H, 0b8H, 0c6H, 0cfH
	DB	0c9H, 0d8H, 0d3H, 0d0H, 0d7H, 0beH, 0c0H, 0bdH, 0c4H, 0b6H
	DB	0c5H, 0cbH, 0c3H, 0bbH, 0ddH, 0c2H

ENDIF ;KANJI


;********** ChAlternateKeytopKbd **********
;*	entry:	chIn = character to find alias to
;*	* find alias to character (KANA<->ROMAN) for keys on keyboard
;*	exit:	AX = alias character (or 0)

cProc	ChAlternateKeytopKbd, <FAR, PUBLIC, ATOMIC>
    parmB  chIn
cBegin	ChAlternateKeytopKbd

IFDEF KANJI
	push	di
	mov	di,drvOffset rgchKana
	mov	al,chIn
	cmp	al,0C0H			;* Kana or Roman ?
	jb	roman_to_kana
;*	* kana to roman (look up in table)
	push	cs
	pop	es
	mov	cx,26
	repnz scasb
	jz	bad_convert
;*	* DI points past the character that matched
	sub	di,drvOffset rgchKana - 1 - 'A'	;* map to 'A' -> 'Z'
	mov	ax,di			;* AL = ROMAN character
	jmp	short end_convert

roman_to_kana:
;*	* convert from ROMAN to KANA
	sub	al,'A'
	jb	bad_convert
	cmp	al,26
	jae	bad_convert
	xor	ah,ah
	mov	bx,ax
	mov	al,cs:[di+bx]		;* AL = KANA character
	jmp	short end_convert

bad_convert:
	xor	ax,ax			;* return 0
end_convert:
	pop	di
ELSE
	xor	ax,ax				;* non-kanji
ENDIF ;!KANJI

cEnd	ChAlternateKeytopKbd
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\keytable.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	keytable.asm : IBM Scan code translation tables
;*		(see magic in KEYPOLL.ASM for details)
;*****************************************************************************

;*	* MPSCVK : scan code -> virtual key
MPSCVW	STRUC	;* one element in array
	scMp	DB	?		;* Scan Code
	vwMp	DB	?		;* Windows Virtual key
MPSCVW	ENDS

;*	* DVW : define VW (from VK)
DVW	MACRO	vk	;; define VW
	DB	VwOfVk(vk)
ENDM

rgvwNumpad	EQU THIS BYTE
	DVW	VK_HOME
	DVW	VK_UP
	DVW	VK_PRIOR
	DVW	VK_SUBTRACT
	DVW	VK_LEFT
	DVW	VK_CLEAR
	DVW	VK_RIGHT
	DVW	VK_ADD
	DVW	VK_END
	DVW	VK_DOWN
	DVW	VK_NEXT
	DVW	VK_INSERT
	DVW	VK_DELETE

rgvwNumeric	EQU THIS BYTE
	DVW	VK_NUMPAD7
	DVW	VK_NUMPAD8
	DVW	VK_NUMPAD9
	DVW	VK_SUBTRACT
	DVW	VK_NUMPAD4
	DVW	VK_NUMPAD5
	DVW	VK_NUMPAD6
	DVW	VK_ADD
	DVW	VK_NUMPAD1
	DVW	VK_NUMPAD2
	DVW	VK_NUMPAD3
	DVW	VK_NUMPAD0
	DVW	VK_DECIMAL

;* Scan Code to Virtual Key map *

mpscvwAlt:
	MPSCVW	<16,	'Q'>
	MPSCVW	<17,	'W'>
	MPSCVW	<18,	'E'>
	MPSCVW	<19,	'R'>
	MPSCVW	<20,	'T'>
	MPSCVW	<21,	'Y'>
	MPSCVW	<22,	'U'>
	MPSCVW	<23,	'I'>
	MPSCVW	<24,	'O'>
	MPSCVW	<25,	'P'>
	MPSCVW	<30,	'A'>
	MPSCVW	<31,	'S'>
	MPSCVW	<32,	'D'>
	MPSCVW	<33,	'F'>
	MPSCVW	<34,	'G'>
	MPSCVW	<35,	'H'>
	MPSCVW	<36,	'J'>
	MPSCVW	<37,	'K'>
	MPSCVW	<38,	'L'>
	MPSCVW	<44,	'Z'>
	MPSCVW	<45,	'X'>
	MPSCVW	<46,	'C'>
	MPSCVW	<47,	'V'>
	MPSCVW	<48,	'B'>
	MPSCVW	<49,	'N'>
	MPSCVW	<50,	'M'>
	MPSCVW	<129,	'0'>
	MPSCVW	<139,	VwOfVk(VK_F11)	>		;/* RONCO only */
	MPSCVW	<140,	VwOfVk(VK_F12)	>		;/* RONCO only */
	MPSCVW	<165,	VwOfVk(VK_TAB)	>		;/* RONCO only */
ifdef OAX
	MPSCVW	<0aaH,	VwOfVk(VK_CONVERT) >		;/* OAX only */
	MPSCVW	<0aeH,	VwOfVk(VK_NONCONVERT) > 	;/* OAX only */
	MPSCVW	<0d5H,	VwOfVk(VK_OAX)	>		;/* OAX only */
endif
	MPSCVW	<0,	0>


mpscvwAltNoChar:	;* alt cases if no char
	MPSCVW	<26,	'['>
	MPSCVW	<27,	']'>
	MPSCVW	<39,	';'>
	MPSCVW	<40,	39>			;* '''
	MPSCVW	<41,	'`'>
	MPSCVW	<43,	'\'>
	MPSCVW	<51,	','>
	MPSCVW	<52,	'.'>
	MPSCVW	<53,	'/'>
	MPSCVW	<130,	'-'>
	MPSCVW	<131,	'='>
	MPSCVW	<0,	0>

mpscvwCtrl:
	MPSCVW	<115,	VwOfVk(VK_LEFT)	>
	MPSCVW	<116,	VwOfVk(VK_RIGHT)>
	MPSCVW	<117,	VwOfVk(VK_END)	>
	MPSCVW	<118,	VwOfVk(VK_NEXT)	>
	MPSCVW	<119,	VwOfVk(VK_HOME)	>
	MPSCVW	<132,	VwOfVk(VK_PRIOR)>
	MPSCVW	<137,	VwOfVk(VK_F11)	>		;/* RONCO only */
	MPSCVW	<138,	VwOfVk(VK_F12)	>		;/* RONCO only */
	MPSCVW	<141,	VwOfVk(VK_UP)	>		;/* RONCO only */
	MPSCVW	<143,	VwOfVk(VK_CLEAR) >		;/* RONCO only */
	MPSCVW	<145,	VwOfVk(VK_DOWN)	>		;/* RONCO only */
	MPSCVW	<146,	VwOfVk(VK_INSERT) >		;/* RONCO only */
	MPSCVW	<147,	VwOfVk(VK_DELETE) >		;/* RONCO only */
ifdef OAX
	MPSCVW	<0a9H,	VwOfVk(VK_CONVERT) >		;/* OAX only */
	MPSCVW	<0adH,	VwOfVk(VK_NONCONVERT) > 	;/* OAX only */
	MPSCVW	<0d4H,	VwOfVk(VK_OAX)	>		;/* OAX only */
endif
	MPSCVW	<0,	0>

	public mpscvwAltRonco
mpscvwAltRonco:
	MPSCVW	<151,	VwOfVk(VK_HOME)	>
	MPSCVW	<152,	VwOfVk(VK_UP)	>
	MPSCVW	<153,	VwOfVk(VK_PRIOR) >
	MPSCVW	<155,	VwOfVk(VK_LEFT)	>
	MPSCVW	<157,	VwOfVk(VK_RIGHT) >
	MPSCVW	<159,	VwOfVk(VK_END)	>
	MPSCVW	<160,	VwOfVk(VK_DOWN)	>
	MPSCVW	<161,	VwOfVk(VK_NEXT)	>
	MPSCVW	<162,	VwOfVk(VK_INSERT) >
	MPSCVW	<163,	VwOfVk(VK_DELETE) >
	MPSCVW	<0,	0>

	public mpscvwShiftRonco
mpscvwShiftRonco:
	MPSCVW	<135,	VwOfVk(VK_F11)	>		;/* RONCO only */
	MPSCVW	<136,	VwOfVk(VK_F12)	>		;/* RONCO only */
ifdef OAX
	MPSCVW	<0a8H,	VwOfVk(VK_CONVERT) >		;/* OAX only */
	MPSCVW	<0acH,	VwOfVk(VK_NONCONVERT) > 	;/* OAX only */
	MPSCVW	<0d3H,	VwOfVk(VK_OAX)	>		;/* OAX only */
endif
	MPSCVW	<0, 0>

	public mpscvwShift
mpscvwShift:
ifdef OAX
	MPSCVW	<0a8H,	VwOfVk(VK_CONVERT) >		;/* OAX only */
	MPSCVW	<0acH,	VwOfVk(VK_NONCONVERT) > 	;/* OAX only */
	MPSCVW	<0d3H,	VwOfVk(VK_OAX)	>		;/* OAX only */
endif
	MPSCVW	<0,	0>

	public	mpscvwPlain
mpscvwPlain:
ifdef OAX
	MPSCVW	<0a7H,	VwOfVk(VK_CONVERT) >		;/* OAX only */
	MPSCVW	<0abH,	VwOfVk(VK_NONCONVERT) > 	;/* OAX only */
	MPSCVW	<0d2H,	VwOfVk(VK_OAX)	>		;/* OAX only */
endif
	MPSCVW	<0,	0>


	public	mpscvwPlainRonco
mpscvwPlainRonco:
	MPSCVW	<133,	VwOfVk(VK_F11)	>		;/* RONCO only */
	MPSCVW	<134,	VwOfVk(VK_F12)	>		;/* RONCO only */
ifdef OAX
	MPSCVW	<0a7H,	VwOfVk(VK_CONVERT) >		;/* OAX only */
	MPSCVW	<0abH,	VwOfVk(VK_NONCONVERT) > 	;/* OAX only */
	MPSCVW	<0d2H,	VwOfVk(VK_OAX)	>		;/* OAX only */
endif
	MPSCVW	<0, 0>

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\keyxlat.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	keyxlat.asm : Key translation
;*****************************************************************************


;********** VwFromSc **********
;*	entry : CH = sc (scan code)
;*		CL = ch (character)
;*		BX = mpscvw = pointer to MPSCVW array (in CS)
;*	* convert scan code to virtual key
;*	* return virtual key
;*	exit : BL = vw
;*		Z flag set if (vw == 0)
;*	* TRASHES BX and AX only

cProc	VwFromSc, <NEAR, ATOMIC, PUBLIC>
cBegin	nogen ;VwFromSc

;{{
;	Assert(sc != 0 && sc != 0xe0);
;	while (mpscvw->sc != 0)
;		{
;		if (mpscvw->sc == sc (DH))
;			return mpscvw->vw;	// in bl
;		mpscvw++;
;		}
;	return 0;
;}}
IFDEF DEBUG
	cmp	ch,0
	jnz	ok1
	int	3
ok1:
	cmp	ch,0e0h
	jnz	ok2
	int	3
ok2:
ENDIF

tovw_loop:
	mov	al,CS:[bx].scMp
	or	al,al
	jz	fail_tovw
	add	bx,SIZE MPSCVW
	cmp	al,ch
	jne	tovw_loop
	mov	bl,CS:[bx].(vwMp - SIZE MPSCVW)
	or	bl,bl		;* set nz
	ret

fail_tovw:	;* no match
	xor	bl,bl		;* set z
	ret

cEnd	nogen ;VwFromSc



;********* XlateKey **********
;*	entry: DI => driver data
;*		AL = char, AH = scan code
;*		DX = shift states
;*	* translate into character with shifts
;*	* call UpdateShiftKk and KeyboardMessage with any results

cProc	XlateKey,<NEAR, PUBLIC, ATOMIC>,<SI, DI>
    localW	ssOn
    localW	ssTemp
ssOff	EQU	SI		;* ssOff register variable

cBegin	XlateKey

	AssertEQ di,OFF_lpwDataKbd

	mov	cx,ax				;* AL = CL = ch, AH = CH = sc
	mov	ssTemp,dx			;* WARNING ch is in cl !!!!

;{{
;	vw (bl) = 0;
;	ssOn = ssOff = 0
;}}
	xor	bx,bx				;* vw = 0, can assume bh == 0
	mov	ssOn,bx
	xor	ssOff,ssOff			; ssOff = 0

;{{
;	if (sc == 0)
;		{
;		if (ch != 0)
;			{
;			 /*
;			    ch is a character entered numerically using the
;			    Alt key in combination with the numeric key pad.
;			    (e.g. The user typed Alt-down 1 2 3 Alt-Up the enter
;			    the char with decimal value 123)
;			 */
;			vw = 0;	/* already */
;			ssOff = SS_ALT | SS_SHIFT | SS_CONTROL;
;			}
;		}
;}}

	or	ch,ch
	jnz	real_scan_code
;*	* no real scan code (probably from alt-numpad)
	jcxz	done_xlat_4		;* just update shift states
	mov	ssOff,(SS_ALT OR SS_SHIFT OR SS_CONTROL)
	jmp	short done_xlat_4

real_scan_code:
;{{	/* check for some RT extended keys ('/' and ENTER) */
;	else if (sc == 0xe0)
;		{
;		ssOn = SS_EXTENDED;
;		if (ch == 13 || ch == 10)	/* ENTER or CTRL-ENTER */
;			vw = VwOfVk(VK_RETURN);
;		}
;}}
	cmp	ch,0e0h
	jne	not_ext_ascii
	cmp	cl, 13
	je	is_enter
	cmp	cl, 10
	jne	is_ext_ascii
	or	ssOn, SS_CONTROL
is_enter:
	mov	bl, VwOfVk(VK_RETURN)
is_ext_ascii:
	mov	ssOn, SS_EXTENDED
	jmp	short done_xlat_4
not_ext_ascii:

;{{	/* special ITL keyboard check */
;	// ITL keyboards can use ALT-CTRL and ALT for special characters.
;	//  the normal BIOS will never return a (non-itl) character if the ALT
;	//  key is down.  Therefore if we get a real character with the ALT
;	//  key down we will assume it is an international character and
;	//  turn off the ALT(MENU) and CONTROL bits.
;	// there are a few exceptions, where we diddled the BIOS to let
;	//  some unusual ALT keys through (BS, '=', '+', '-')
;	else if ((ss & SS_ALT) && ch != 0 && ch != 0xe0 &&
;			ch != ' ' && 
;			ch != 8 & ch != '=' &&
;			sc != '+' && sc != '-')
;		{
;		ssOff = SS_ALT | SS_CONTROL
;		}
;}}
	test	ssTemp,SS_ALT
	jz	no_itl_char
	or	cl,cl
	jz	no_itl_char
	cmp	cl,0e0h
	je	no_itl_char
	cmp	cl, 8
	je	no_itl_char
	cmp	cl, '='
	je	no_itl_char
	cmp	cl, '+'
	je	no_itl_char
	cmp	cl, '-'
	je	no_itl_char
	cmp	cl, ' '
	je	no_itl_char
	mov	ssOff,SS_ALT OR SS_CONTROL	;* turn off special states
done_xlat_4:
	jmp	done_xlat
no_itl_char:

;{{	/* simple cases */
;	else if (sc == SC_MULTIPLY)
;		ssOn = SS_EXTENDED, vw = VwOfVk(VK_MULTIPLY);
;	else if (sc == SC_ADD)
;		ssOn = SS_EXTENDED, vw = VwOfVk(VK_ADD);
;	else if (sc == SC_SUBTRACT)
;		ssOn = SS_EXTENDED, vw = VwOfVk(VK_SUBTRACT);
;}}
	mov	al, VwOfVk(VK_MULTIPLY)
	cmp	ch, SC_MULTIPLY
	je	done_xlat_x
	mov	al, VwOfVk(VK_ADD)
	cmp	ch, SC_ADD
	je	done_xlat_x
	mov	al, VwOfVk(VK_SUBTRACT)
	cmp	ch, SC_SUBTRACT
	jne	not_greyminus
done_xlat_x:
	mov	ssOn, SS_EXTENDED
	jmp	done_xlat_al

not_greyminus:
;{{	/* more simple cases */
;	else if (sc == SC_ENTER)
;		vw = VwOfVk(VK_RETURN);
;	else if (sc == SC_ESC)
;		vw = VwOfVk(VK_ESCAPE);
;	else if (sc == SC_BACKSPACE)
;		vw = VwOfVk(VK_BACK);
;}}
	mov	al,VwOfVk(VK_RETURN)
	cmp	ch,SC_ENTER
	jz	done_xlat_al

	mov	al,VwOfVk(VK_ESCAPE)
	cmp	ch,SC_ESC
	jz	done_xlat_al

	mov	al,VwOfVk(VK_BACK)
	cmp	ch,SC_BACKSPACE
	jz	done_xlat_al

ifdef KANJI
	mov	al, VwOfVk(VK_KANJI)
	cmp	ch, SC_KANJI
	jz	done_xlat_al
endif
;*	* More complicated cases
;{{
;	else if (sc == SC_TAB)
;		ch = vw = VwOfVk(VK_TAB);
;}}
	cmp	ch,SC_TAB
	jnz	not_tab
	mov	bl,VwOfVk(VK_TAB)
	mov	cl, bl
	jmp	short done_xlat_1

not_tab:
;{{
;	else if (ch == ' ')
;		vw = 0;
;}}
	cmp	cl,' '
	je	done_xlat_1
	jmp	short not_space

;************************************************************************
;*	* done_xlat_al : al = vw	;* located here for near jumps !!
done_xlat_al:
	mov	bl,al
done_xlat_1:
	jmp	done_xlat
;************************************************************************

not_space:
;{{	/* Alphas */
;	else if (ch >= 'A' && ch <= 'Z')	/* special jump for control */
;		{
;		vw = ch;
;		ssOff = SS_ALT SS_CONTROL;
;		}
;	else if (ch >= 'a' && ch <= 'z')
;		{
;		vw = 'A' + (ch - 'a');
;		ssOff = SS_ALT | SS_CONTROL;
;		}
;}}
	mov	ax,cx
	cmp	al,'A'
	jb	maybe_control			;* maybe a control char ??
	cmp	al,'Z'
	ja	not_upper_alpha
;*	* upper case alpha
	mov	ssOff,SS_ALT OR SS_CONTROL
	jmp	done_xlat_al

not_upper_alpha:
	cmp	al,'a'
	jb	not_alpha
	cmp	al,'z'
	ja	not_alpha
;*	* lower case alpha
	sub	al,20H				;* to upper
	mov	ssOff,SS_ALT OR SS_CONTROL
	jmp	done_xlat_al

maybe_control:
;{{	/* test for control alpha characters */
;	else if (ch >= 1 && ch <= 26)
;		{
;		vw = 'A' + (ch - 1);
;		ssOff = SS_ALT;
;		ssOn = SS_CONTROL;
;		}

	cmp	al,1
	jb	not_alpha
	cmp	al,26
	ja	not_alpha
	add	al,40H
	mov	ssOff,SS_ALT
	mov	ssOn,SS_CONTROL
	jmp	done_xlat_al

not_alpha:
;{{	/* Check peculiar Ctrl keys (6 and -) */
;	else if (sc == SC_MINUS && ch == 0x1F)
;		ch = '-', ssOn |= SS_CONTROL;
;	else if (sc == SC_6 && ch == 0x1E)
;		ch = 0, vw = VwOfVk(VK_6), ssOn |= SS_CONTROL;
;}}
	cmp	cx, (SC_MINUS shl 8) + 1Fh
	jne	not_ctl_minus
	mov	cl, '-'
	jmp	short done_xlat_ctl
not_ctl_minus:
	cmp	cx, (SC_6 shl 8) + 1Eh
	jne	not_weirdctl
	xor	cl, cl
	mov	bl, VwOfVk(VK_6)
done_xlat_ctl:
	or	ssOn, SS_CONTROL
	jmp	short done_xlat_1

not_weirdctl:
;{{	/* Numpad exceptions */
;	else if (sc >= SC_NUMPAD_MIN && sc < SC_NUMPAD_MAX)
;		{
;		/*
;		At this point we know the user typed a key on the numeric
;		keypad (but NOT ctrl+numpad that's handled farther down).
;		We must figure out how the keystoke is to be interpreted.
;		If ch == 0 then we interpret the keystroke as an arrow key.
;		*/
;		if (sc != SC_INSERT)
;			ssOff = SS_CONTROL;
;		ivw (bx) = sc - SC_NUMPAD_MIN
;		vw = rgvwNumpad[ivw];
;		if (ch == 0xe0)
;			{
;			ch = 0;
;			ssOn = SS_EXTENDED;
;			}
;		else if (ch == 0)
;			{
;			if (ss & SS_NUMLOCK)
;				ssOff |= SS_SHIFT;
;			}
;		else if ((ss & SS_SHIFT) ||
;				(sc == SC_NUMPAD5 && 
;				!(ss & SS_CONTROL) && (ss & SS_NUMLOCK)))
;			ch = 0;
;		else
;			{
;			vw = rgvwNumeric[ivw];
;			ssOn = SS_EXTENDED;
;			}
;		if (ch == 0 && sc == SC_DELETE)
;			ch = (char) 0x7f;
;		}
;	}
;}}

	cmp	ch,SC_NUMPAD_MIN
	jb	not_num_pad
	cmp	ch,SC_NUMPAD_MAX
	jae	not_num_pad

IFDEF DOS5
	test	ssTemp, SS_ALT		;* ignore alt-numpad keystrokes
	jz	@F
	jmp	exit_xlat
@@:
ENDIF ;DOS5

;*	* NUMPAD
	mov	bl,ch
;;	xor	bh,bh		;; not needed
	mov	bl,(rgvwNumpad-SC_NUMPAD_MIN)[BX]
	cmp	cl,0E0H
	jne	not_E0
	xor	cl,cl
	mov	ssOn, SS_EXTENDED
	jmp	num_pad_fin
not_E0:
	or	cl,cl
	jnz	num_pad_2
	test	ssTemp,SS_NUMLOCK
	jz	num_pad_fin
	or	ssOff,SS_SHIFT
	jmp	short num_pad_fin

num_pad_2:
IFDEF	STD_NUMPAD
	cmp	ch, 76			;numpad 5
	jnz	num_pad_normal
	test	ssTemp, SS_NUMLOCK
	jz	num_pad_fun
	test	ssTemp, SS_CONTROL
	jnz	num_pad_fun
	test	ssTemp, SS_SHIFT
	jz	num_pad_num
	or	ssOff, SS_SHIFT
	jmp	short num_pad_fun
ENDIF	; STD_NUMPAD

IFDEF	TOSHIBA_NUMPAD
	test	ssTemp, SS_NUMLOCK
	jz	num_pad_fun
	test	ssTemp, SS_CONTROL
	jnz	num_pad_fun
	test	ssTemp, SS_SHIFT
	jz	num_pad_num
	or	ssOff, SS_SHIFT
ELSE	;TOSHIBA_NUMPAD
num_pad_normal:
	test	ssTemp, SS_SHIFT
	jnz	num_pad_fun
	test	ssTemp,SS_NUMLOCK
	jnz	num_pad_num
ENDIF	;TOSHIBA_NUMPAD

num_pad_fun:
	mov	cl,0
	jmp	short num_pad_fin

num_pad_num:
	mov	bl,ch
;;	xor	bh,bh		;; not needed
	mov	bl,(rgvwNumeric-SC_NUMPAD_MIN)[BX]
	mov	ssOn, SS_EXTENDED

num_pad_fin:	;* test delete case
	or	cl,cl
	jnz	done_xlat_2
	cmp	ch,SC_DELETE
	jnz	done_xlat_2
	mov	cl,07FH
done_xlat_2:
	jmp	done_xlat

not_num_pad:
;{{	/* check for number keys */
;	else if (ch >= '0' && ch <= '9')
;		{
;		vw = ch;
;		if (ss & SS_CONTROL)
;			ch = 0;
;		}
;}}

	cmp	cl,'0'
	jb	not_num
	cmp	cl,'9'
	ja	not_num
	mov	bl,cl
	test	ssTemp, SS_CONTROL
	jz	done_xlat_2
	xor	cl, cl
	jmp	done_xlat_2

not_num:
;{{	/* F1..F10 and ALT-1..9 */
;	else if (ch == 0 || ch = 0xe0)
;		{
;		ch = 0;
;		ssOff = SS_SHIFT | SS_CONTROL | SS_ALT;
;		/* special cases */
;		if (sc >= 59 && sc <= 68)		/* Fn */
;			{
;			/* normal key */
;			vw = VwOfVk(VK_F1) + (sc - 59);
;			}
;		else if (sc >= 84 && sc <= 93)		/* SHIFT Fn */
;			{
;			vw = VwOfVk(VK_F1) + (sc - 84);
;			ssOn = SS_LSHIFT;
;			}
;		else if (sc >= 94 && sc <= 103)		/* CTRL Fn */
;			{
;			vw = VwOfVk(VK_F1) + (sc - 94);
;			ssOn = SS_CONTROL;
;			ssOff = SS_ALT;	// allow SHIFT
;			}
;		else if (sc >= 104 && sc <= 113)	/* ALT Fn */
;			{
;			vw = VwOfVk(VK_F1) + (sc - 104);
;			ssOn = SS_ALT;
;			ssOff = 0;	// allow SHIFT/CONTROL
;			}
;		else if (sc >= 120 && sc <= 128)
;			{
;			vw = '1' + (sc - 120);
;			ssOn = SS_ALT;
;			ssOff = 0;	// allow SHIFT/CONTROL
;			}
;}}

	or	cl,cl
	jz	is_special
	cmp	cl, 0e0h
	jnz	done_xlat_3
	xor	cl, cl
	mov	ssOn, SS_EXTENDED

is_special:
	xor	dx, dx				;* additional shift states
	mov	ssOff,SS_SHIFT OR SS_CONTROL OR SS_ALT
	mov	ah,VwOfVk(VK_F1)		;* base vw

	mov	al,59				;* al = base sc
	cmp	ch,al
	jb	not_special
	cmp	ch,68
	jbe	do_special

	mov	al,84
	mov	dx,SS_LSHIFT
	cmp	ch,al
	jb	not_special
	cmp	ch,93
	jbe	do_special

	mov	ssOff,SS_ALT		;* menu is the only thing overridden
	mov	al,94
	mov	dx,SS_CONTROL
	cmp	ch,al
	jb	not_special
	cmp	ch,103
	jbe	do_special

	xor	ssOff,ssOff		;* allow everything
	mov	al,104
	mov	dx,SS_ALT
	cmp	ch,al
	jb	not_special
	cmp	ch,113
	jbe	do_special

	mov	al,120
	mov	dx,SS_ALT
	cmp	ch,al
	jb	not_special
	cmp	ch,128
	ja	not_special
	mov	ah,'1'
do_special:
;	* ah = base key, ch = sc, al = base scan code, dx = ssOn
	neg	al
	add	al,ch
	add	al,ah
	mov	bl,al
	or	ssOn,dx
done_xlat_3:
	jmp	done_xlat

not_special:

;{{	/* last default case */
;	else
;		{
;		if (vw == 0)
;			vw = VwFromSc(sc, pmpscvwPlain);
;		if (vw == 0)
;			{
;			if (vw = VwFromSc(sc, pmpscvwAltRonco))
;				{
;				/* Extended keypad Alt */
;				ssOn |= SS_ALT | SS_EXTENDED;
;				}
;			if (vw = VwFromSc(sc, pmpscvwAlt))
;				{
;				/* normal ALT */
;				ssOn |= SS_ALT;
;				}
;			else if (ch == 0 && vw = VwFromSc(sc, pmpscvwAltNoChar))
;				{
;				/* special ALT */
;				ssOn |= SS_ALT;
;				ch = vw;
;				vw = 0;
;				}
;			else if (vw = VwFromSc(sc, mpscvwCtrl))
;				{
;				ssOff = 0;
;				ssOn |= SS_CONTROL;
;				}
;			else if (vw = VwFromSc(sc, pmpscvwShift))
;				{
;				ssOff = 0;
;				ssOn |= SS_LSHIFT;
;				}
;			}
;		}
;	} /*end of major if*/
;}}
	mov	bx,[di].pmpscvwPlain
	cCall	VwFromSc
	jnz	done_xlat

	mov	bx,drvOffset mpscvwAltRonco
	cCall	VwFromSc
	jz	not_extalt
	or	ssOn, SS_ALT OR SS_EXTENDED
	jmp	short done_xlat

not_extalt:
	mov	bx,drvOffset mpscvwAlt
	cCall	VwFromSc
	jz	not_alt1

yes_alt:
	or	ssOn,SS_ALT
	jmp	short done_xlat

not_alt1:
	or	cl,cl
	jnz	not_alt2
	mov	bx,drvOffset mpscvwAltNoChar
	cCall	VwFromSc
	jz	not_alt2
	xchg	cl, bl			;* actually it's a CH, not a VW
	jmp	short yes_alt
	
not_alt2:
	mov	bx,drvOffset mpscvwCtrl
	cCall	VwFromSc
	jz	not_control
;*	* control
	xor	ssOff,ssOff
	or	ssOn,SS_CONTROL
	jmp	short done_xlat

not_control:
	mov	bx,[di].pmpscvwShift
	cCall	VwFromSc
	jz	done_xlat
	xor	ssOff,ssOff
	or	ssOn,SS_LSHIFT

done_xlat:	;* CX == sc:ch, ssTemp == ss, BL = vw

;{{
;	ssNew = (ss & ~ssOff) | ssOn;
;}}

	mov	ax,ssOff
	not	ax
	and	ax,ssTemp			;* ss & ~ssOff
	or	ax,ssOn
	mov	dx, ax				;* ssNew

;{{
;	if (vw | ch)
;		{
;		/* 1 message for WM_CHAR only !! */
;		KeyboardMessage(vw, ch, KkOfSs(ssNew), FALSE);
;		}
	mov	al,bl
	or	al,cl
	jz	no_key_event

	mov	al,ch				;* sc
IFDEF	KANJI
	xor	ah,ah
	push	ax				;* sc
ENDIF	; KANJI
	Assert	<?PLM>

	push	bx				;* vw
	xor	ch,ch
	or	cl,cl
	jnz	we_have_char
;*	* no char -- put in the VK
	Assert	<VwOfVk(155H) EQ 55H>
	mov	cl,bl
	inc	ch				;* ch == 1
we_have_char:
	push	cx				;* ch
	cCall	KkOfSs, <dx>
	push	ax
	xor	bx,bx
	push	bx				;* FALSE
	mov	bx,[di].pinkbCur
	cCall	[bx].lpfnKeyboardMessageInkb

no_key_event:

;{{	/* restore shift states */
;	DoShift(ss);
;}}
	cCall	DoShift,<ssTemp>

exit_xlat:
cEnd	XlateKey

;*********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\tables5.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	tables5.asm : OS/2 tables for key lookup
;*****************************************************************************
;*  Adapted from PM "atvkey.asm"
;*   Copyright (C) 1987 by Microsoft Inc.
;*	Adaptations include:
;*		change to old windows VK names
;*		compact everything to 1 byte
;*		removal of general tables
;************************************************************************

NormalTranslateTable:
	DB	5			; #scan code ranges
	DB	01h			; first scan code in range
	DB	01h			; last scan code in range
	DB	VwOfVk VK_ESCAPE	; 01h	Esc

if 0	; No translation for these
	DB	XL_NOXLATE		; 02h	1
	DB	XL_NOXLATE		; 03h	2
	DB	XL_NOXLATE		; 04h	3
	DB	XL_NOXLATE		; 05h	4
	DB	XL_NOXLATE		; 06h	5
	DB	XL_NOXLATE		; 07h	6
	DB	XL_NOXLATE		; 08h	7
	DB	XL_NOXLATE		; 09h	8
	DB	XL_NOXLATE		; 0Ah	9
	DB	XL_NOXLATE		; 0Bh	0
	DB	XL_NOXLATE		; 0Ch	-
	DB	XL_NOXLATE		; 0Dh	=
endif

	DB	0Eh			; first scan code in range
	DB	0Fh			; last scan code in range
	DB	VwOfVk VK_BACK		; 0Eh	Backspace
	DB	VwOfVk VK_TAB		; 0Fh	Tab


if 0	; No translation for these
	DB	XL_NOXLATE		; 10h	Q
	DB	XL_NOXLATE		; 11h	W
	DB	XL_NOXLATE		; 12h	E
	DB	XL_NOXLATE		; 13h	R
	DB	XL_NOXLATE		; 14h	T
	DB	XL_NOXLATE		; 15h	Y
	DB	XL_NOXLATE		; 16h	U
	DB	XL_NOXLATE		; 17h	I
	DB	XL_NOXLATE		; 18h	O
	DB	XL_NOXLATE		; 19h	P
	DB	XL_NOXLATE		; 1Ah	[
	DB	XL_NOXLATE		; 1Bh	]
endif

	DB	1Ch			; first scan code in range
	DB	1Ch			; last scan code in range
	DB	VwOfVk VK_RETURN	; 1Ch	Enter

if 0	; No translation for these
	DB	VwOfVk VK_CONTROL	; 1Dh	Ctrl
	DB	XL_NOXLATE		; 1Eh	A
	DB	XL_NOXLATE		; 1Fh	S
	DB	XL_NOXLATE		; 20h	D
	DB	XL_NOXLATE		; 21h	F
	DB	XL_NOXLATE		; 22h	G
	DB	XL_NOXLATE		; 23h	H
	DB	XL_NOXLATE		; 24h	J
	DB	XL_NOXLATE		; 25h	K
	DB	XL_NOXLATE		; 26h	L
	DB	XL_NOXLATE		; 27h	;
	DB	XL_NOXLATE		; 28h	'
	DB	XL_NOXLATE		; 29h	`
endif

	DB	2Ah			; first scan code in range
	DB	2Ah			; last scan code in range
	DB	VwOfVk VK_SHIFT		; 2Ah	Left Shift

if 0	; No translation for these
	DB	XL_NOXLATE		; 2Bh	\
	DB	XL_NOXLATE		; 2Ch	Z
	DB	XL_NOXLATE		; 2Dh	X
	DB	XL_NOXLATE		; 2Eh	C
	DB	XL_NOXLATE		; 2Fh	V
	DB	XL_NOXLATE		; 30h	B
	DB	XL_NOXLATE		; 31h	N
	DB	XL_NOXLATE		; 32h	M
	DB	XL_NOXLATE		; 33h	,
	DB	XL_NOXLATE		; 34h	.
endif

	DB	35h			; first scan code in range
	DB	54h			; last scan code in range
	DB	VwOfVk VK_DIVIDE	; 35h	/
	DB	VwOfVk VK_SHIFT		; 36h	Right Shift
	DB	VwOfVk VK_PRINT		; 37h	PrtSc
	DB	VwOfVk VK_MENU		; 38h	Alt
	DB	VwOfVk VK_SPACE		; 39h	Space
	DB	VwOfVk VK_CAPLOCK	; 3Ah	Caps Lock
	DB	VwOfVk VK_F1		; 3Bh	F1
	DB	VwOfVk VK_F2		; 3Ch	F2
	DB	VwOfVk VK_F3		; 3Dh	F3
	DB	VwOfVk VK_F4		; 3Eh	F4
	DB	VwOfVk VK_F5		; 3Fh	F5
	DB	VwOfVk VK_F6		; 40h	F6
	DB	VwOfVk VK_F7		; 41h	F7
	DB	VwOfVk VK_F8		; 42h	F8
	DB	VwOfVk VK_F9		; 43h	F9
	DB	VwOfVk VK_F10		; 44h	F10
	DB	VwOfVk VK_NUMLOCK	; 45h	Num Lock
	DB	VwOfVk VK_SCRLOCK	; 46h	Scroll Lock
	DB	VwOfVk VK_HOME		; 47h	Home
	DB	VwOfVk VK_UP		; 48h	Up
	DB	VwOfVk VK_PRIOR		; 49h	PgUp
	DB	VwOfVk VK_SUBTRACT	; 4Ah	Minus
	DB	VwOfVk VK_LEFT		; 4Bh	Left
	DB	VwOfVk VK_NUMPAD5	; 4Ch	numpad-5
	DB	VwOfVk VK_RIGHT		; 4Dh	Right
	DB	VwOfVk VK_MULTIPLY	; 4Eh	Multiply
	DB	VwOfVk VK_END		; 4Fh	End
	DB	VwOfVk VK_DOWN		; 50h	Down
	DB	VwOfVk VK_NEXT		; 51h	PgDn
	DB	VwOfVk VK_INSERT	; 52h	Ins
	DB	VwOfVk VK_DELETE	; 53h	Del
	DB	VwOfVk VK_CANCEL	; 54h	Sys Req

;*	* end of normal table

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\keyacc3.asm ===
;
;	CW : Character Windows Drivers
;
;	keyacc3.asm : DOS 3 accessory functions
;----------------------------------------------------------------------------

NonStandard	PollKeyboardKbd
NonStandard	FlushKeyRgchKbd
NonStandard	SetShiftKkKbd


;********** PollKeyboardKbd **********
;*	entry / exit : n/a
;*	* Poll the keyboard, send keyboard messages as needed

cProc	PollKeyboardKbd,<FAR, PUBLIC, ATOMIC>,<DI>
cBegin	PollKeyboardKbd

	mov	di,OFF_lpwDataKbd		;* Data in data segment

retry_polling:
;{{
;	fPollKeyboard = FALSE;
;	if (!FTestKeyboardEmpty())
;		/* keyboard is not empty enough */
;		return;
;}}
	mov	bx,[di].pinkbCur
IFNDEF KANJI
;*	* don't poll all the time
	mov	[bx].fPollKeyboardInkb,0
ELSE
;*	* OAX keyboard is weird -- poll all the time
	mov	[bx].fPollKeyboardInkb,1
ENDIF ;KANJI
	cCall	[bx].lpfnFTestKeyboardEmptyInkb
	or	ax,ax
	jz	end_polling			; Jump if no room in queue.

;{{
;	// note : for MSKEY and TSRs that introduce waits, we will poll 3
;		times before deciding we don't have anything
;	c = 3;
;	while (c--)
;		if ((key = InKey()) != 0 || ss != ssOld)
;			goto got_something;
;}}

	mov	cx,3
retry_inkey:
	Save	<cx>
	cCall	InKey				;* DX:AX = value
	or	ax,ax
	jnz	got_something
;*	* are the shift states changed ??
	cmp	dx,[di].ssOld
	jne	got_something
	loop	retry_inkey

;{{	/* Now that we've taken care of all "real" keys (including TSRs),
;		we handle artificial keys from software autorepeat */
;	if (ckeyRepeat > 0)
;		{
;		ss = ssPrev;
;		sc = scPrev;
;		ch = chPrev;
;		ckeyRepeat--;
;		XlateKey(key);
;		}
;	return;
;}}
	cmp	[di].ckeyRepeat, 0
	jle	end_polling
	mov	ax, word ptr [di].chPrev
	mov	dx, [di].ssPrev
	dec	[di].ckeyRepeat
	cCall	XlateKey
	jmp	short end_polling

got_something:

;{{	/* Save the key to prepare for software autorepeat */
;	scPrev = sc;
;	chPrev = ch;
;	ssPrev = ss;
;}}
	mov	word ptr [di].chPrev, ax
	mov	[di].ssPrev, dx

;{{
;	XlateKey(key);
;}}
	cCall	XlateKey			;* parameters in AX/DX
	jmp	retry_polling			;* keep going till Queue empty

end_polling:

cEnd	PollKeyboardKbd

;*****************************************************************************

;********** FlushKeyRgchKbd **********
;*	* KBD entry point (see documentation for interface)
;*	* poke key events into BIOS buffer

cProc	FlushKeyRgchKbd, <FAR, PUBLIC, ATOMIC>, <SI, DI>
    parmDP  rgchBuffer
cBegin	FlushKeyRgchKbd

	mov	di,OFF_lpwDataKbd		;* Data in data segment

	AssertEQ [di].fKeyboardEnabled,0	;* keyboard must be disabled

;*	* First flush the CW event queue buffer
	mov	si,rgchBuffer
loop_flush_1:
	lodsb
	or	al,al
	jz	done_flush_1
	xor	ah,ah				;* scan code info gone
	cCall	PokeCh
	jmp	short loop_flush_1

done_flush_1:
;*	* now flush the low level buffer
loop_flush_2:
	lea	si,[di].queueKb
	mov	bx,[si].pHeadQueue
	cmp	bx,[si].pTailQueue
	je	done_flush_2

	mov	ax,[bx]
	cCall	IncQueuePtr
	mov	[si].pHeadQueue,bx
	cCall	PokeCh
	jmp	short loop_flush_2
done_flush_2:

cEnd	FlushKeyRgchKbd



;********** PokeCh **********
;*	entry:	al = character, ah = scan code
;*	* Poke key event back into BIOS buffer
;*	exit: n/a

cProc	PokeCh, <NEAR, ATOMIC>, <DS>
cBegin	PokeCh

	CLI

	xor	cx,cx
	mov	ds,cx
	mov	cx,DS:[BUFFER_TAIL]
	mov	bx,cx
;*	* increment buffer pointer
	inc	cx
	inc	cx
	cmp	cx,DS:[BUFFER_END]
	jne	@F
	mov	cx,DS:[BUFFER_START]
@@:
	cmp	cx,DS:[BUFFER_HEAD]		;* full ??
	je	end_poke			;* no room!
	mov	DS:[BUFFER_TAIL],cx
	add	bx,400H				;* bias for seg 40:
	mov	DS:[bx],ax

end_poke:
	STI

cEnd	PokeCh

;*****************************************************************************

BIOS_SHIFT	equ	417h

;*********** SetShiftKkKbd *************
;*	* KBD entry point
;*	* set the BIOS shift states given a KK

cProc	SetShiftKkKbd, <FAR, PUBLIC, ATOMIC>, <DI>
	parmW	kkParm
cBegin	SetShiftKkKbd

	mov	di,OFF_lpwDataKbd

	;* translate KK to SS
	mov	ax, (kkParm)
	mov	al, ah
	and	al, SS_CAPLOCK or SS_NUMLOCK or SS_SCRLOCK or SS_ALT or SS_CONTROL or SS_LSHIFT

	;* modify BIOS shift state
	xor	cx, cx
	mov	es, cx
	mov	es:[BIOS_SHIFT], al

	xor	ah, ah
	cCall	DoShift, <ax>

cEnd	SetShiftKkKbd
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\keymon5.asm ===
;*
;*	keymon5.asm : OS/2 keyboard monitor
;*****************************************************************************

SetBxInkb MACRO				;* address inkb struct with bx
	mov	bx,[di].pinkbCur	;* assume [di] == rgwKbdData
ENDM

SetBxInos MACRO				;* address inosDrv struct with bx
	mov	bx,pinos
ENDM

PushFld	MACRO	fld			;* assume [di] == structure
	push	[di+fld]		;* [di].fld won't replace fld!!
ENDM

Os2Call	MACRO	ofn			;* Call through link table
	call	[bx+lpfn&ofn&Inos]
ENDM

;* Special call-back if in thread (DS:0 => KTHD)
ThreadCall MACRO	ofn			;* Call through link table
	mov	es,ds:[selAppKthd]
	mov	bx,pinos			;* load BX from code segment
	call	es:[bx+lpfn&ofn&Inos]
ENDM


;*****************************************************************************


;********** EnableKeyboardKbd **********
;*	entry:	pinkb => INKB data
;*		fEnable => whether to enable or disable
;*		fExiting => exiting if !fEnable
;*	* enable or disable the keyboard handler
;*	exit : n/a

cProc	EnableKeyboardKbd,<ATOMIC>,<DI>
    parmDP pinkb
    parmW  fEnable
    parmW  fExiting
cBegin	EnableKeyboardKbd

;*	* save pointer to INKB data
	mov	di,OFF_lpwDataKbd		;* Data in data segment
	mov	bx,pinkb
	mov	[di].pinkbCur,bx

	mov	bx,drvOffset Disable
	mov	cx,fEnable
	jcxz	do_it
	mov	bx,drvOffset Enable
do_it:
	call	bx				;* call Enable or Disable

cEnd	EnableKeyboardKbd


;*****************************************************************************

;********** Disable **********
;*	entry: DS:DI => driver data
;*	* since OS/2 will not kill buffers properly, we turn the keyboard
;*	*  monitor into a literal copy monitor when disabled
;*	exit: n/a

cProc	Disable,<NEAR, PUBLIC>
cBegin	Disable

	AssertEQ di,OFF_lpwDataKbd
	xor	ax,ax
	mov	[di].fEnabled,al	;* disable -> get old status
	mov	[di].fEnableMonitor,al	;* disable monitor -- keep running

cEnd	Disable


;*****************************************************************************

;********** Enable **********
;*	entry: DS:DI => driver data
;*	* opens a new keyboard monitor and creates a thread to manage
;*	  this monitor.
;*	exit:	n/a

szKbd	db	'KBD$',0	 ; device string name (Keyboard)

cProc	Enable,<NEAR, PUBLIC>
    localW  wFiller
cBegin	Enable

	AssertEQ di,OFF_lpwDataKbd
	SetBxInos				; prepare for indirect call

	cmp	[di].fEnabled,0
	je	@F				;* enable it
	jmp	enable_done
@@:

;*	* if we have started the monitor then skip
	cmp	[di].selKthd,0
	je	@F
	jmp	enable_ok			;* already have thread
@@:

;*	* One-shot initialization follows
;*	* OPEN Keyboard device
	PushArg <cs,drvOffset(szKbd)>
	lea	ax,[di].hDevice
	PushArg <ds,ax>
	lea	ax,wFiller
	PushArg <ss,ax>
	xor	ax,ax
	PushArg <ax,ax>			; filesize (zero)
	PushArg <ax>			; file attribute (zero)
	push	1			; open flag (open existing file)
	push	0000000011000000b	; open mode
;		DWFRRRRRISSSRAAA	  (private, deny none, read only)
	PushArg <ax,ax>			; reserved
	Os2Call	DosOpen
	or	ax,ax
	jnz	init_error2

;*	* Open Keyboard monitor
	PushArg <cs, drvOffset(szKbd)>
	lea	ax,[di].hMonitor
	PushArg	<ds,ax>
	Os2Call	DosMonOpen
	or	ax,ax
	jnz	init_error2

;*	* allocate KTHD segment
	lea	ax,[di].selKthd		;* segment selector
	PushArg	<(size KTHD), ds, ax, 0>
	Os2Call	DosAllocSeg
	or	ax,ax
	jnz	init_error2
@@:
	mov	es,[di].selKthd

;*	* Register monitor
	PushFld	hMonitor
	mov	ax,offset rgbBufferInKthd
	PushArg <es, ax>
	cCall	InitBuffer, <ax>
	mov	ax,offset rgbBufferOutKthd
	PushArg <es, ax>
	cCall	InitBuffer, <ax>
	PushArg <2>			; Posflag (back)
	PushArg <-1>			; index = -1 (current group)
	Os2Call	DosMonReg
	or	ax,ax
init_error2:
	jnz	init_error


;*	* create keyboard thread, ES:0 => KTHD
	PushArg <cs, drvOffset(KbdThread)>
	lea	ax,[di].idThread
	PushArg	<ds,ax>
	mov	es:[selAppKthd],ss	;* point to main App stack
	PushArg <es, (rgbStackKthd + cbStack - 10H)>	;* leave space before end of segment
	Os2Call	DosCreateThread
	or	ax,ax
	jnz	init_error

;*	* bump priority of thread
	PushArg <2>		       ; scope = 2 (thread)
	PushArg <3>		       ; class = 3 (time-critical)
	PushArg <15>		       ; delta = 15(???)
	PushFld idThread
	Os2Call	DosSetPrty
	or	ax,ax
	jnz	init_error

;*	* set for keyboard type (no problem in assuming enhanced)

	mov	[di].pmpscvwPlain,drvOffset mpscvwPlainRonco
	mov	[di].pmpscvwShift,drvOffset mpscvwShiftRonco

enable_ok:	;* ok to enable
	mov	[di].fEnabled,1		;* we are now enabled
	mov	[di].fEnableMonitor,1	;* enable monitor
	jmp	short enable_done

init_error:
	PushArg	<1, 08001H>
	Os2Call DosExit	;* exit, kill process (return 0x8001).

;*	* can't accept input => we're screwed
	mov	[di].fEnabled,0
enable_done:

cEnd	Enable


;********** InitBuffer **********
;*	entry:	ES => segment containing monitor buffer
;*		pbBuff = near pointer to start of monitor buffer
;*	* Initialize monitor buffer
;*	exit:	n/a (ES retained)

cProc	InitBuffer, <NEAR, ATOMIC>, <DI>
    parmW  pbBuff
cBegin	InitBuffer

	mov	di,pbBuff
	mov	ax,cbBuffer
	stosw			;* set length of buffer

;*	* OS/2 1.0 has a problem registering non-zero initialized buffers
	mov	cx,(cbBuffer - 2)/2
	xor	ax,ax
	rep stosw

cEnd	InitBuffer


;*****************************************************************************
;* KbdThread - Keyboard monitor thread


;*	* literal monitor mode (propagate key -- leave it alone)
literal_monitor:
	call	XmitKey
	jmp	short ThreadMain

	PUBLIC	KbdThread
KbdThread PROC FAR
	push	ss
	pop	ds
	xor	di,di			;* DS:DI => KTHD
ThreadMain:

	mov	[di].cbMonKthd,SIZE KBRD

;*	* read record from monitor
	PushArg	<ds,offset(rgbBufferInKthd)>
	push	0			; WaitFlag=0 (wait)
	PushArg <ds,offset(kbrdKthd)>
	PushArg <ds,offset(cbMonKthd)>
	ThreadCall DosMonRead		;* this may put us to sleep

	or	ax,ax
	je	@F
	jmp	Close
@@:
	mov	es,ds:[selAppKthd]
	mov	bx,OFF_lpwDataKbd

;*	* see if in we are closing
	cmp	es:[bx].fEnableMonitor,0	;* monitor enabled ?
	je	literal_monitor
	cmp	es:[bx].fEnabled,0
	je	literal_monitor			;* keyboard is disabled

	lea	si,[di].kbrdKthd
	mov	ax,[si].MonFlags

	test	ax,fOpen OR fFlush OR fClose
	jnz	noDefault

;*	* a normal event, process it
	mov	ax,[si].KbdFlags
	and	al,mAction
	jz	TakeNormalKey
	cmp	al,7			;* shift ??
	je	TakeShiftKey
	cmp	al,12H			;* pseudo-break (CTRL-C) ?
	jz	TakeNormalKey		;* just like control C
	cmp	al,2			;* extend alone ?
	je	ThreadMain		;* eat it
	cmp	al,9			;* CTRL-S ?
	je	TakeNormalKey		;* treat like normal
	cmp	al,15H			;* CTRL-P ?
	je	TakeNormalKey		;* treat like normal
	cmp	al,0AH			;* wake-up?
	je	ThreadMain		;* eat it
	cmp	al,011H			;* Break?
	je	ThreadMain		;* eat it
	cmp	al,3fH			;* not-translated
	jne	xmit_key
;*	* take a shot at translating ALT key
	test	[si].ssKbrd,SS_ALT	;* ALT down
	jz	TakeNormalKey
	cmp	[si].XlatedScan,1	;* ALT-ESC ?
	jne	TakeNormalKey		;* try if not ALT-ESC
;*	* transmit all other keys
xmit_key:
	call	XmitKey
	jmp	short ThreadMain2

TakeShiftKey:
	mov	word ptr [si].XlatedChar,0 	;* set no character (just to be sure)
TakeNormalKey:
	call	TakeKey
	jmp	short ThreadMain2

noDefault:
	test	ax,fOpen
	jz	noOpen
	jmp	short ThreadMain2	; do nothing if Open

noOpen:
	test	ax,fFlush
	jz	Close		; can be nothing except close

	call	XmitKey		; Xmit Flush to next monitor (if any)

;*	* end after flushing (since we do not get a close packet).

	or	ax,ax
	jne	Close
ThreadMain2:
	jmp	ThreadMain

;*	* Die
Close:
	xor	ax,ax
	PushArg	<ax,ax>
	ThreadCall DosExit	;* exit, return 0, kill just this thread

KbdThread ENDP


;*****************************************************************************


; XmitKey - Transmit monitor record to next
XmitKey	proc	near
	PushArg	<ds,offset(rgbBufferOutKthd)>
	PushArg <ds,offset(kbrdKthd)>
	PushArg	[di].cbMonKthd
	ThreadCall DosMonWrite
	ret
XmitKey	endp


;*****************************************************************************

;********** TakeKey **********
;*	entry:	DS:SI => keyboard monitor record
;*		DS:0 => KTHD
;*	* translate and send scan code to event proc
;*	* (don't transmit to next monitor)

cProc	TakeKey, <NEAR, ATOMIC>, <DS, DI, SI>
cBegin	TakeKey

	mov	es, ds:[selAppKthd]
	mov	di,OFF_lpwDataKbd

;*	* load up registers for call to XlateKey
	Assert	<XlatedScan EQ XlatedChar+1>
	mov	ax,word ptr [si].XlatedChar
	mov	dx,[si].ssKbrd

	or	al, al			;* some scan codes need to be
	jnz	no_convert		;*  converted for DOS3 compatibility
	or	ah, ah			;* (only check key events)
	jz	no_convert
	test	dl, SS_CONTROL OR SS_ALT
	jz	no_convert
	cmp	ah, SC_1
	jb	no_convert
	cmp	ah, SC_9
	ja	no_cvt1_9
	mov	al, ah
	add	al, '1' - SC_1
	jmp	short no_convert
no_cvt1_9:
	mov	al, '0'
	cmp	ah, SC_0
	je	cvt_char
	mov	al, '='
	cmp	ah, SC_EQUALS
	je	cvt_char
	mov	al, ','
	cmp	ah, SC_COMMA
	je	cvt_char
	mov	al, '.'
	cmp	ah, SC_PERIOD
	je	cvt_char
	mov	al, '-'
	cmp	ah, SC_SUBTRACT		;* Alt SUBTRACT
	je	cvt_char
	mov	ch, SC_SUBTRACT
	cmp	ah, 8Eh			;* Ctrl SUBTRACT
	je	cvt_scan
	mov	al, '+'
	cmp	ah, SC_ADD		;* Alt ADD
	je	cvt_char
	mov	ch, SC_ADD
	cmp	ah, 90h			;* Ctrl ADD
	je	cvt_scan
	cmp	ah, SC_ADD		;* Alt ADD
	je	cvt_scan
	mov	al, 9
	mov	ch, SC_TAB
	cmp	ah, 94h			;* Ctrl TAB
	je	cvt_scan
	xor	al, al
	jmp	short no_convert
cvt_scan:
	mov	ah, ch

cvt_char:
no_convert:
	and	dx,NOT SS_EXTENDED		;* fix left Alt key
	or	dx,SS_SPACE			;* assume on

	test	[si].KbdFlags,fBreak		;* break ?
	push	es				;* (switch to data seg)
	pop	ds
	jnz	take_keyup

	;* Fast key repeat
	mov	si, [di].pinkbCur
	mov	[si].fKeyIsUpInkb, 0
	cmp	ax, word ptr es:[di].chPrev	;* wait until 2nd same key
	jne	take_keydown
	mov	cx, [si].wRateKeyRepeatInkb
	or	cx, cx
	jle	take_keydown			;* default, don't mess w/ it
	shl	cx, 1				;* to emulate DOS3 timer
	add	[di].ckeyRepeat, cx		;* add a bunch of repeats
	mov	[di].ssPrev, dx			;* keep SS's up-to-date
take_repeat:
	cCall	[si].lpfnFTestKeyboardEmptyInkb
	or	ax, ax
	jnz	@F
	mov	[di].ckeyRepeat, ax	;0	;* minimize overruns
	jmp	short take_done
@@:	mov	ax, word ptr [di].chPrev
	mov	dx, [di].ssPrev
	cCall	XlateKey
	dec	[di].ckeyRepeat
	jnz	take_repeat
	jmp	short take_done

take_keyup:
;*	* for key up, just update shift states
	mov	[di].ckeyRepeat, 0		;* cancel pending repeats
	mov	si, [di].pinkbCur
	mov	[si].fKeyIsUpInkb, 1
	mov	[si].fKeyWasUpInkb, 1
	cmp	al,' '
	jne	not_space_up
	and	dx,NOT SS_SPACE			;* generate space up
not_space_up:
	xor	ax,ax				;* no key
take_keydown:

	mov	word ptr [di].chPrev, ax	;* save prev ch and sc
	mov	[di].ssPrev, dx
	cCall	XlateKey

take_done:
cEnd	TakeKey

;*****************************************************************************
;* Key flush

NonStandard	FlushKeyRgchKbd


;********** FlushKeyRgchKbd **********
;*	* KBD entry point (see documentation for interface)
;*	* send keys to next monitors
;*	* the keyboard monitor is assumed to be still alive

cProc	FlushKeyRgchKbd, <FAR, PUBLIC, ATOMIC>, <SI, DI>
    parmDP  rgchBuffer
cBegin	FlushKeyRgchKbd

	mov	di,OFF_lpwDataKbd		;* Data in data segment

	SetBxInos				; prepare for indirect call

	mov	cx,[di].selKthd
	jcxz	end_flush			;* no extra segment
	mov	es,cx

;*	* Flush the CW event queue buffer
	mov	si,rgchBuffer
loop_flush_1:
	lodsb
	or	al,al
	jz	done_flush_1
;*	* put that 1 character into the keyboard monitor
	mov	dl,al				;* character
	mov	es,[di].selKthd

	mov	bx,offset kbrdKthd		;* es:bx => KBRD

;*	* clear the KBRD record
	push	di
	mov	di,bx
	xor	ax,ax
	mov	cx,size KBRD / 2
	rep stosw
	pop	di

;*	* set character (other fields 0)
	mov	es:[bx].XlatedChar,dl

;*	* write the buffer
	PushArg	<es,offset(rgbBufferOutKthd)>
	PushArg <es,bx>
	PushArg	es:[cbMonKthd]
	SetBxInos				; prepare for indirect call
	Os2Call DosMonWrite

	or	ax,ax
	jz	loop_flush_1			;* go while no error
	int	3				;* write error !

done_flush_1:

end_flush:

cEnd	FlushKeyRgchKbd


;**************************************************************************
;* Set shift states

NonStandard	SetShiftKkKbd

;*********** SetShiftKkKbd *************
;*	* KBD entry point
;*	* set the actual shift states given a KK
;
cProc	SetShiftKkKbd, <FAR, PUBLIC, ATOMIC>, <SI, DI>
	parmW	kkParm
	Assert	<(size KBST) EQ 10>
	localT	kbstTmp
cBegin	SetShiftKkKbd

	mov	di, OFF_lpwDataKbd
	SetBxInos

	;* get the current keyboard status
	lea	si, (kbstTmp)
	mov	ss:[si].cbKbst, (size KBST)
	PushArg	<ss, si>
	push	0		;* system keyboard handle
	Os2Call	KbdGetStatus

	;* set the we're-gonna-change-shift-states flag
	mov	ax, ss:[si].fsMask
	or	ax, 10h
	mov	ss:[si].fsMask, ax
	
	;* translate new KK to SS
	mov	ax, (kkParm)
	and	ah, SS_CAPLOCK or SS_NUMLOCK or SS_SCRLOCK or SS_ALT or SS_CONTROL or SS_LSHIFT
	mov	byte ptr ss:[si].fsState, ah

	;* reset the keyboard status to new shift state
	PushArg	<ss, si>
	push	0		;* system keyboard handle
	Os2Call	KbdSetStatus

	mov	ax, ss:[si].fsState
	cCall	DoShift, <ax>

cEnd	SetShiftKkKbd

;**************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\tandy.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	tandy.asm : Tandy 1000 DOS 3 installed keyboard driver
;*****************************************************************************

	include	kbd_head.inc

	include	kbd3.inc
	;* special stuff for DOS 3 driver
	include scan3.inc
	include tsr3.inc
	include bios.inc

	include	kbd_data.inc

;*****************************************************************************

	include	kbd_code.asm

TANDY_1000 = 1	; special key interrupt handling

;*****************************************************************************

;*	* keyboard tables go here

	include tantable.asm			;* Scan code tables

	include	kbd_ibm.asm			;* IBM helpers etc

;*****************************************************************************

;*	* Main routines

	include keyacc3.asm			;* accessory routines

	include	keyint3.asm			;* interrupt

	include	tanxlat.asm			;* polling translations

;*****************************************************************************

	include	kbd_std.asm		;* standard init/term

;*****************************************************************************

	include	kbd_tail.asm		;* tail file

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\tantable.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	tantable.asm : Tandy 1000 Scan code translation tables
;*		(see magic in TANXLAT.ASM for more details)
;*****************************************************************************

;*	* MPSCVK : scan code -> virtual key
MPSCVW	STRUC	;* one element in array
	scMpVw	DB	?		;* Scan Code
	vwMpVw	DB	?		;* Windows Virtual key
MPSCVW	ENDS

;*	* MPSCCH : scan code -> ascii
MPSCCH	STRUC	;* one element in array
	scMpCh	DB	?		;* Scan Code
	chMpCh	DB	?		;* ASCII Character
MPSCCH	ENDS

;* Scan Code to whatever maps *

mpscvwAlt:
	MPSCVW	<007h,	'6'>			;* Alt Ctrl 6 is special
	MPSCVW	<046h,	VwOfVk(VK_MULTIPLY) >
	MPSCVW	<068h,	VwOfVk(VK_F1)	>
	MPSCVW	<069h,	VwOfVk(VK_F2)	>
	MPSCVW	<06Ah,	VwOfVk(VK_F3)	>
	MPSCVW	<06Bh,	VwOfVk(VK_F4)	>
	MPSCVW	<06Ch,	VwOfVk(VK_F5)	>
	MPSCVW	<06Dh,	VwOfVk(VK_F6)	>
	MPSCVW	<06Eh,	VwOfVk(VK_F7)	>
	MPSCVW	<06Fh,	VwOfVk(VK_F8)	>
	MPSCVW	<070h,	VwOfVk(VK_F9)	>
	MPSCVW	<071h,	VwOfVk(VK_F10)	>
	MPSCVW	<06Ah,	VwOfVk(VK_TAB)	>
	MPSCVW	<078h,	'1'>
	MPSCVW	<079h,	'2'>
	MPSCVW	<07Ah,	'3'>
	MPSCVW	<07Bh,	'4'>
	MPSCVW	<07Ch,	'5'>
	MPSCVW	<07Dh,	'6'>
	MPSCVW	<07Eh,	'7'>
	MPSCVW	<07Fh,	'8'>
	MPSCVW	<080h,	'9'>
	MPSCVW	<081h,	'0'>
	MPSCVW	<08Bh,	VwOfVk(VK_ESCAPE) >
	MPSCVW	<08Ch,	VwOfVk(VK_BACK)	>
	MPSCVW	<08Eh,	VwOfVk(VK_TAB)	>
	MPSCVW	<08Fh,	VwOfVk(VK_RETURN) >
	MPSCVW	<091h,	VwOfVk(VK_UP)	>
	MPSCVW	<092h,	VwOfVk(VK_LEFT)	>
	MPSCVW	<097h,	VwOfVk(VK_DOWN)	>
	MPSCVW	<09Eh,	VwOfVk(VK_SUBTRACT) >
	MPSCVW	<0A0h,	VwOfVk(VK_ADD)	>
	MPSCVW	<0A5h,	VwOfVk(VK_DECIMAL) >
	MPSCVW	<0A6h,	VwOfVk(VK_HOME)	>
	MPSCVW	<0B6h,	VwOfVk(VK_F11)	>
	MPSCVW	<0B7h,	VwOfVk(VK_F12)	>
	MPSCVW	<0EAh,	VwOfVk(VK_RIGHT) >
	MPSCVW	<16,	'Q'>
	MPSCVW	<17,	'W'>
	MPSCVW	<18,	'E'>
	MPSCVW	<19,	'R'>
	MPSCVW	<20,	'T'>
	MPSCVW	<21,	'Y'>
	MPSCVW	<22,	'U'>
	MPSCVW	<23,	'I'>
	MPSCVW	<24,	'O'>
	MPSCVW	<25,	'P'>
	MPSCVW	<30,	'A'>
	MPSCVW	<31,	'S'>
	MPSCVW	<32,	'D'>
	MPSCVW	<33,	'F'>
	MPSCVW	<34,	'G'>
	MPSCVW	<35,	'H'>
	MPSCVW	<36,	'J'>
	MPSCVW	<37,	'K'>
	MPSCVW	<38,	'L'>
	MPSCVW	<44,	'Z'>
	MPSCVW	<45,	'X'>
	MPSCVW	<46,	'C'>
	MPSCVW	<47,	'V'>
	MPSCVW	<48,	'B'>
	MPSCVW	<49,	'N'>
	MPSCVW	<50,	'M'>
	MPSCVW	<0,	0>

mpscchAlt:
	MPSCVW	<046h,	'*'>		;* PRINT
	MPSCCH	<082h,	'-'>
	MPSCCH	<083h,	'='>
	MPSCCH	<089h,	','>
	MPSCCH	<08Ah,	'.'>
	MPSCCH	<09Eh,	'+'>
	MPSCCH	<0A0h,	'-'>
	MPSCCH	<0F1h,	39>
	MPSCCH	<0F2h,	'/'>
	MPSCCH	<0F8h,	';'>
	MPSCCH	<0,	0>

mpscvwCtrl:
	MPSCVW	<001h,	VwOfVk(VK_ESCAPE) >
	MPSCVW	<003h,	'2'>
	MPSCVW	<007h,	'6'>
	MPSCVW	<00Eh,	VwOfVk(VK_BACK)	>
	MPSCVW	<01Ch,	VwOfVk(VK_RETURN) >	;* main ENTER
	MPSCVW	<057h,	VwOfVk(VK_RETURN) >	;* numpad ENTER
	MPSCVW	<05Eh,	VwOfVk(VK_F1)	>
	MPSCVW	<05Fh,	VwOfVk(VK_F2)	>
	MPSCVW	<060h,	VwOfVk(VK_F3)	>
	MPSCVW	<061h,	VwOfVk(VK_F4)	>
	MPSCVW	<062h,	VwOfVk(VK_F5)	>
	MPSCVW	<063h,	VwOfVk(VK_F6)	>
	MPSCVW	<064h,	VwOfVk(VK_F7)	>
	MPSCVW	<065h,	VwOfVk(VK_F8)	>
	MPSCVW	<066h,	VwOfVk(VK_F9)	>
	MPSCVW	<067h,	VwOfVk(VK_F10)	>
	MPSCVW	<06Ah,	VwOfVk(VK_TAB)	>
	MPSCVW	<073h,	VwOfVk(VK_LEFT)	>
	MPSCVW	<074h,	VwOfVk(VK_RIGHT) >
	MPSCVW	<075h,	VwOfVk(VK_END)	>
	MPSCVW	<076h,	VwOfVk(VK_NEXT)	>
	MPSCVW	<077h,	VwOfVk(VK_HOME)	>
	MPSCVW	<084h,	VwOfVk(VK_PRIOR) >
	MPSCVW	<08Dh,	VwOfVk(VK_TAB)	>
	MPSCVW	<090h,	VwOfVk(VK_UP)	>
	MPSCVW	<093h,	VwOfVk(VK_NUMPAD7) >
	MPSCVW	<094h,	VwOfVk(VK_NUMPAD8) >
	MPSCVW	<095h,	VwOfVk(VK_NUMPAD4) >
	MPSCVW	<096h,	VwOfVk(VK_DOWN)	>
	MPSCVW	<09Ah,	VwOfVk(VK_NUMPAD2) >
	MPSCVW	<09Ch,	VwOfVk(VK_NUMPAD0) >
	MPSCVW	<09Dh,	VwOfVk(VK_DELETE) >
	MPSCVW	<09Fh,	VwOfVk(VK_INSERT) >
	MPSCVW	<0A4h,	VwOfVk(VK_DECIMAL) >
	MPSCVW	<0ACh,	VwOfVk(VK_F11)	>
	MPSCVW	<0ADh,	VwOfVk(VK_F12)	>
	MPSCVW	<0E0h,	'0'>
	MPSCVW	<0E1h,	'1'>
	MPSCVW	<0E3h,	'3'>
	MPSCVW	<0E4h,	'4'>
	MPSCVW	<0E5h,	'5'>
	MPSCVW	<0E7h,	'7'>
	MPSCVW	<0E8h,	'8'>
	MPSCVW	<0E9h,	'9'>
	MPSCVW	<0FCh,	VwOfVk(VK_CLEAR) >
	MPSCVW	<0FDh,	VwOfVk(VK_NUMPAD6) >
	MPSCVW	<0,	0>

mpscchCtrl:
	MPSCCH	<001h,	27>			;* ESC
	MPSCCH	<00Ch,	'-'>
	MPSCCH	<00Eh,	127>			;* Backspace
	MPSCCH	<01Ch,	10>			;* main ENTER
	MPSCCH	<057h,	10>			;* numpad ENTER
	MPSCCH	<09Dh,	127>			;* DELETE
	MPSCCH	<0F2h,	'/'>
	MPSCCH	<0F5h,	'='>
	MPSCCH	<0F6h,	';'>
	MPSCCH	<0F7h,	39>			;* '
	MPSCCH	<0F9h,	','>
	MPSCCH	<0FAh,	'.'>
	MPSCCH	<0FBh,	'/'>
	MPSCCH	<0,	0>

	public mpscvwShift
mpscvwShift:
	MPSCVW	<001h,	VwOfVk(VK_ESCAPE) >
	MPSCVW	<00Eh,	VwOfVk(VK_BACK)	>
	MPSCVW	<00Fh,	VwOfVk(VK_TAB)	>
	MPSCVW	<01Ch,	VwOfVk(VK_RETURN) >
	MPSCVW	<049h,	VwOfVk(VK_PRIOR) >
	MPSCVW	<04Ah,	VwOfVk(VK_HOME)	>
	MPSCVW	<04Fh,	VwOfVk(VK_END)	>
	MPSCVW	<051h,	VwOfVk(VK_NEXT)	>
	MPSCVW	<054h,	VwOfVk(VK_F1)	>
	MPSCVW	<055h,	VwOfVk(VK_F2)	>
	MPSCVW	<056h,	VwOfVk(VK_F3)	>
	MPSCVW	<057h,	VwOfVk(VK_F4)	>
	MPSCVW	<058h,	VwOfVk(VK_F5)	>
	MPSCVW	<059h,	VwOfVk(VK_F6)	>
	MPSCVW	<05Ah,	VwOfVk(VK_F7)	>
	MPSCVW	<05Bh,	VwOfVk(VK_F8)	>
	MPSCVW	<05Ch,	VwOfVk(VK_F9)	>
	MPSCVW	<05Dh,	VwOfVk(VK_F10)	>
	MPSCVW	<085h,	VwOfVk(VK_UP)	>
	MPSCVW	<086h,	VwOfVk(VK_DOWN)	>
	MPSCVW	<087h,	VwOfVk(VK_LEFT)	>
	MPSCVW	<088h,	VwOfVk(VK_RIGHT) >
	MPSCVW	<09Bh,	VwOfVk(VK_NUMPAD0) >
	MPSCVW	<0A1h,	VwOfVk(VK_DECIMAL) >
	MPSCVW	<0A2h,	VwOfVk(VK_F11)	>
	MPSCVW	<0A3h,	VwOfVk(VK_F12)	>
	MPSCVW	<0F3h,	VwOfVk(VK_CLEAR) >
	MPSCVW	<0F4h,	VwOfVk(VK_NUMPAD6) >
	MPSCVW	<0,	0>

mpscchShift:
	MPSCCH	<001h,	27>			;* ESC
	MPSCCH	<00Eh,	8>			;* Backspace
	MPSCVW	<01Ch,	13>			;* ENTER
	MPSCVW	<09Bh,	'0'>
	MPSCVW	<0A1h,	'.'>
	MPSCVW	<0F4h,	'6'>
	MPSCCH	<0,	0>

	public	mpscvwPlain
mpscvwPlain:
	MPSCVW	<001h,	VwOfVk(VK_ESCAPE) >
	MPSCVW	<00Eh,	VwOfVk(VK_BACK)	>
	MPSCVW	<00Fh,	VwOfVk(VK_TAB)	>
	MPSCVW	<01Ch,	VwOfVk(VK_RETURN) >
	MPSCVW	<037h,	VwOfVk(VK_MULTIPLY) >
	MPSCVW	<03Bh,	VwOfVk(VK_F1)	>
	MPSCVW	<03Ch,	VwOfVk(VK_F2)	>
	MPSCVW	<03Dh,	VwOfVk(VK_F3)	>
	MPSCVW	<03Eh,	VwOfVk(VK_F4)	>
	MPSCVW	<03Fh,	VwOfVk(VK_F5)	>
	MPSCVW	<040h,	VwOfVk(VK_F6)	>
	MPSCVW	<041h,	VwOfVk(VK_F7)	>
	MPSCVW	<042h,	VwOfVk(VK_F8)	>
	MPSCVW	<043h,	VwOfVk(VK_F9)	>
	MPSCVW	<044h,	VwOfVk(VK_F10)	>
	MPSCVW	<047h,	VwOfVk(VK_HOME)	>
	MPSCVW	<048h,	VwOfVk(VK_UP)	>
	MPSCVW	<049h,	VwOfVk(VK_PRIOR) >
	MPSCVW	<04Bh,	VwOfVk(VK_LEFT)	>
	MPSCVW	<04Dh,	VwOfVk(VK_RIGHT) >
	MPSCVW	<04Fh,	VwOfVk(VK_END)	>
	MPSCVW	<050h,	VwOfVk(VK_DOWN)	>
	MPSCVW	<051h,	VwOfVk(VK_NEXT)	>
	MPSCVW	<052h,	VwOfVk(VK_INSERT) >
	MPSCVW	<053h,	VwOfVk(VK_DELETE) >
	MPSCVW	<098h,	VwOfVk(VK_F11)	>
	MPSCVW	<099h,	VwOfVk(VK_F12)	>
	MPSCVW	<09Bh,	VwOfVk(VK_NUMPAD0) >
	MPSCVW	<0A1h,	VwOfVk(VK_DECIMAL) >
	MPSCVW	<0F3h,	VwOfVk(VK_CLEAR) >
	MPSCVW	<0F4h,	VwOfVk(VK_NUMPAD6) >
	MPSCVW	<0, 0>

mpscchPlain:
	MPSCVW	<001h,	27>		;* Escape
	MPSCVW	<00Eh,	8>		;* Backspace
	MPSCVW	<00Fh,	9>		;* Tab
	MPSCVW	<01Ch,	13>		;* main ENTER
	MPSCVW	<037h,	'*'>		;* PRINT
	MPSCCH	<053h,	127>		;* DELETE
	MPSCCH	<057h,	13>		;* numpad ENTER
	MPSCVW	<09Bh,	'0'>
	MPSCVW	<0A1h,	'.'>
	MPSCVW	<0F4h,	'6'>
	MPSCCH	<0,	0>

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\tanxlat.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	tanxlat.asm : Tandy 1000 Key translation
;*****************************************************************************


;********** VwFromSc **********
;*	entry : CH = sc (scan code)
;*		CL = ch (character)
;*		BX = mpscvw = pointer to MPSCVW array (in CS)
;*	* convert scan code to virtual key
;*	* return virtual key
;*	exit : BL = vw
;*		Z flag set if (vw == 0)
;*	* TRASHES BX and AX only

cProc	VwFromSc, <NEAR, ATOMIC, PUBLIC>
cBegin	nogen ;VwFromSc

;{{
;	Assert(sc != 0);
;	while (mpscvw->sc != 0)
;		{
;		if (mpscvw->sc == sc (DH))
;			return mpscvw->vw;	// in bl
;		mpscvw++;
;		}
;	return 0;
;}}
IFDEF DEBUG
	cmp	ch,0
	jnz	vfs_ok1
	int	3
vfs_ok1:
ENDIF

tovw_loop:
	mov	al,CS:[bx].scMpVw
	or	al,al
	jz	fail_tovw
	add	bx,SIZE MPSCVW
	cmp	al,ch
	jne	tovw_loop
	mov	bl,CS:[bx].(vwMpVw - SIZE MPSCVW)
	or	bl,bl		;* set nz
	ret

fail_tovw:	;* no match
	xor	bl,bl		;* set z
	ret

cEnd	nogen ;VwFromSc


;********** ChFromSc **********
;*	entry : CH = sc (scan code)
;*		CL = ch (character)
;*		DX = mpscch = pointer to MPSCCH array (in CS)
;*	* convert scan code to virtual key
;*	* return virtual key
;*	exit : CL = ch (character)
;*	* TRASHES AX only

cProc	ChFromSc, <NEAR, ATOMIC, PUBLIC>
cBegin	nogen ;ChFromSc

	push	bx
	mov	bx, dx
;{{
;	Assert(sc != 0);
;	while (mpscch->sc != 0)
;		{
;		if (mpscch->sc == sc (DH))
;			return mpscch->ch;	/* in cl */
;		mpscch++;
;		}
;	return ch;	/* in cl */
;}}
IFDEF DEBUG
	cmp	ch,0
	jnz	cfs_ok1
	int	3
cfs_ok1:
ENDIF

toch_loop:
	mov	al,CS:[bx].scMpCh
	or	al,al
	jz	done_toch
	add	bx,SIZE MPSCCH
	cmp	al,ch
	jne	toch_loop
	mov	cl,CS:[bx].(chMpCh - SIZE MPSCCH)

done_toch:
	pop	bx
	ret

cEnd	nogen ;ChFromSc


;********* XlateKey **********
;*	entry: DI => driver data
;*		AL = char, AH = scan code
;*		DX = shift states
;*	* translate into character with shifts
;*	* call UpdateShiftKk and KeyboardMessage with any results

cProc	XlateKey,<NEAR, PUBLIC, ATOMIC>,<SI, DI>
    localW	ssOn
    localW	ssTemp
ssOff	EQU	SI		;* ssOff register variable

cBegin	XlateKey

	AssertEQ di,OFF_lpwDataKbd

	mov	cx,ax				;* AL = CL = ch, AH = CH = sc
	mov	ssTemp,dx			;* WARNING ch is in cl !!!!

;{{
;	vw (bl) = 0;
;	ssOn = ssOff = 0
;}}
	xor	bx,bx				;* vw = 0, can assume bh == 0
	mov	ssOn,bx
	xor	ssOff,ssOff			; ssOff = 0

;{{
;	if (sc == 0)
;		{
;		if (ch != 0)
;			{
;			 /*
;			    ch is a character entered numerically using the
;			    Alt key in combination with the numeric key pad.
;			    (e.g. The user typed Alt-down 1 2 3 Alt-Up the enter
;			    the char with decimal value 123)
;			 */
;			vw = 0;	/* already */
;			ssOff = SS_ALT | SS_SHIFT | SS_CONTROL;
;			}
;		}
;}}

	or	ch,ch
	jnz	real_scan_code
;*	* no real scan code (probably from alt-numpad)
	jcxz	done_xlat_2		;* just update shift states
	mov	ssOff,(SS_ALT OR SS_SHIFT OR SS_CONTROL)
done_xlat_2:
	jmp	done_xlat

real_scan_code:

;{{	/* Some exceptions: override CH to force table lookup */
;	if (sc == SC_6 && (ch == 01Eh || ch == '}') ||	/* [Alt] Ctrl 6 */
;		sc == SC_MINUS && ch == 01Fh ||		/* Ctrl - */
;		sc == SC_MULTIPLY && ch == 010h ||	/* PRINT key */
;		sc == SC_ENTER ||			/* main ENTER */
;		sc == SC_TAB ||
;		sc == SC_ESCAPE ||
;		sc == SC_BACKSPACE)
;		ch = 0;
;}}
	cmp	cx, 071Eh		;* Ctrl 6^
	je	kill_ch
	cmp	cx, 077Dh		;* Alt Ctrl 6^
	je	kill_ch
	cmp	cx, 0C1Fh		;* Ctrl -_
	je	kill_ch
	cmp	cx, 3710h		;* PRINT
	je	kill_ch
	cmp	ch, SC_ENTER
	je	kill_ch
	cmp	ch, SC_TAB
	je	kill_ch
	cmp	ch, SC_ESC
	je	kill_ch
	cmp	ch, SC_BACKSPACE
	jne	not_special
kill_ch:
	xor	cl, cl
	jmp	short xlat_look_1
not_special:

;{{	/* Numpad ENTER is a little peculiar */
;	if (ch == SC_NUMPAD_ENTER && ch != 0)
;		{
;		vw = VwOfVk(VK_RETURN);
;		ssOn |= SS_EXTENDED;
;		goto done_xlat;		/* skip the table lookup */
;		}
;}}

	cmp	ch, 57h			;* SC_NUMPAD_ENTER
	jne	not_num_enter
	or	cl, cl			;* watch out! Shift-F4 has same sc
	jz	not_num_enter
	mov	bl, VwOfVk(VK_RETURN)
	or	ssOn, SS_EXTENDED
	jmp	short done_xlat_2

not_num_enter:

;{{	/* Some numpad exceptions when NumLock is off */
;	if (! (ssTemp & SS_NUMLOCK))
;		{
;		if (sc == SC_NUMPAD1 && ch == '1' ||
;			sc == SC_NUMPAD3 && ch == '3' ||
;			sc == SC_NUMPAD9 && ch == '5' ||
;			sc == SC_SHIFT_INSERT && ch == '+' ||
;			sc == SC_DELETE && ch == '-')
;			{
;			ssTemp &= ~SS_SHIFT;
;			ssOn |= SS_SHIFT;
;			/* the following is optimized into the above 'if' */
;			if (sc == SC_NUMPAD5)
;				sc = SC_PLAIN_NUMPAD5, ch = 0;
;			else if (sc == SC_SHIFT_INSERT)
;				sc = SC_INSERT, ch = 0;
;			else if (sc == SC_DELETE)
;				ch = 0;
;			}
;		}
;}}
	test	ssTemp, SS_NUMLOCK
	jnz	num_lock_on		;* handle shift w/o NumLock first
	cmp	cx, 4F31h		;* sc == NUMPAD1, ch == '1'
	je	num_shift
	cmp	cx, 5133h		;* sc == NUMPAD3, ch == '3'
	je	num_shift
	cmp	cx, 4939h		;* sc == NUMPAD9, ch == '9'
	je	num_shift
	cmp	cx, 4C35h		;* sc == NUMPAD5, ch == '5'
	jne	not_5
	mov	ch, 0F3h		;* sc = PLAIN_NUMPAD5
	jmp	short num_shift
not_5:
	cmp	cx, 552Bh		;* sc == SHIFT_INSERT, ch == '+'
	jne	not_ins
	mov	ch, 52h			;* sc = INSERT
	jmp	short num_shift
not_ins:
	cmp	cx, 532Dh		;* sc == DELETE, ch = '-'
	jne	xlat_look_1
num_shift:
	xor	cl, cl			;* kill ch to force table lookup
	and	ssTemp, not SS_SHIFT	;* fool the sc to vw conversion
	or	ssOn, SS_SHIFT		;* but keep the shift state
xlat_look_1:
	jmp	xlat_lookup

num_lock_on:
;{{	/* Some more exceptions, this time with NumLock on */
;	else
;		{	/* The weird INSERT/'+' key */
;		if (sc == SC_SHIFT_INSERT && ch == '+' ||
;			sc == SC_INSERT && ch == 0 ||
;			sc == SC_CONTROL_INSERT && ch == 0)
;			ch = '+', vw = VwOfVk(VK_ADD),
;			ssOn |= SS_EXTENDED;
;			/* and skip the VwFromSc transform */
;}}
	cmp	cx, 552Bh		;* sc == SHIFT_INSERT, ch = '+'
	je	num_add_1
	cmp	cx, 5200h		;* sc == INSERT, ch == 0
	je	num_add
	cmp	cx, 9F00h		;* sc == CONTROL_INSERT, ch = 0
	jne	num_not_add
num_add:
	mov	cl, '+'
num_add_1:
	mov	bl, VwOfVk(VK_ADD)
	jmp	short num_add_sub

num_not_add:
;{{	/* The weird DELETE/'-' key */
;		else if (sc == SC_DELETE && (ch == '-' || ch == 0) ||
;			sc == SC_CONTROL_DELETE && ch == 0)
;			ch = '-', vw = VwOfVk(VK_SUBTRACT);
;			/* and skip the VwFromSc transform */
;		}
;}}
	cmp	cx, 532Dh		;* sc == DELETE, ch == '-'
	je	num_sub_1
	cmp	cx, 5300h		;* sc == DELETE, ch == 0
	je	num_sub
	cmp	cx, 9D00h		;* sc == CONTROL_DELETE, ch = 0
	jne	not_num_sub
num_sub:
	mov	cl, '-'
num_sub_1:
	mov	bl, VwOfVk(VK_SUBTRACT)
num_add_sub:
	or	ssOn, SS_EXTENDED
	jmp	done_xlat
not_num_sub:

xlat_lookup:
;{{	/* Convert scan codes to VW's, aided by knowledge of shift state */
;	if (ch == 0)
;		{
;		if (ssTemp & SS_ALT)
;			pmpscvw = pmpscvwAlt,
;			pmpscch = pmpscchAlt;
;		else if (ssTemp & SS_CONTROL)
;			pmpscvw = pmpscvwCtrl,
;			pmpscch = pmpscchCtrl;
;		else if (ssTemp & SS_SHIFT)
;			pmpscvw = pmpscvwShift,
;			pmpscch = pmpscchShift;
;		else
;			pmpscvw = pmpscvwPlain,
;			pmpscch = pmpscchPlain;
;		ch = ChFromSc(pmpscch, sc);
;		vw = VwFromSc(pmpscvw, sc);
;		if (vw)
;			if (vw == VwOfVk(VK_MULTIPLY) ||
;				vw == VwOfVk(VK_ADD) ||
;				vw == VwOfVk(VK_SUBTRACT) ||
;				vw == VwOfVk(VK_DECIMAL) ||
;				vw == VwOfVk(VK_NUMPAD0 ||
;				vw == VwOfVk(VK_NUMPAD6))
;				ssOn |= SS_EXTENDED;
;		}
;}}
	or	cl, cl
	jnz	done_lookup
	mov	ax, ssTemp
	mov	bx, drvOffset mpscvwAlt
	mov	dx, drvOffset mpscchAlt
	test	ax, SS_ALT
	jnz	lookup_bx
	mov	bx, drvOffset mpscvwCtrl
	mov	dx, drvOffset mpscchCtrl
	test	ax, SS_CONTROL
	jnz	lookup_bx
	mov	bx, drvOffset mpscvwShift
	mov	dx, drvOffset mpscchShift
	test	ax, SS_SHIFT
	jnz	lookup_bx
	mov	bx, drvOffset mpscvwPlain
	mov	dx, drvOffset mpscchPlain
lookup_bx:
	cCall	ChFromSc
	cCall	VwFromSc
	jz	done_lookup			;* if (!vw)
	cmp	bl, VwOfVk(VK_MULTIPLY)
	je	add_extend
	cmp	bl, VwOfVk(VK_ADD)
	je	add_extend
	cmp	bl, VwOfVk(VK_SUBTRACT)
	je	add_extend
	cmp	bl, VwOfVk(VK_DECIMAL)
	je	add_extend
	cmp	bl, VwOfVk(VK_NUMPAD0)
	je	add_extend
	cmp	bl, VwOfVk(VK_NUMPAD6)
	jne	done_xlat
add_extend:
	or	ssOn, SS_EXTENDED
	jmp	short done_xlat

done_lookup:
;{{	/* Assign VW's to some leftover ascii keys */
;	if (vw == 0)
;		{
;		if (ch >= 'A' && ch <= 'Z')
;			vw = VwOfVk(VK_A) + ch - 'A';
;		else if (ch >= 'a' && ch <= 'z')
;			vw = VwOfVk(VK_A) + ch - 'a';
;		else if (ch >= 1 && ch <= 26)
;			vw = VwOfVk(VK_A) + ch - 1;
;		else if (ch >= '0' && ch <= '9')
;			{
;			if (sc < SC_NUMBER_MAX)
;				vkBase = VK_0;
;			else
;				vkBase = VK_NUMPAD, ssOn |= SS_EXTENDED;
;			vw = VwOfVk(vkBase) + ch - '0';
;			}
;		else if (ch == ' ')
;			vw = 0;
;		else if (ch == '.' && sc == SC_DECIMAL)
;			vw = VwOfVk(VK_DECIMAL), ssOn |= SS_EXTENDED;
;		}
;}}
	AssertEQ bl, 0
	mov	bl, VwOfVk(VK_A)	;* min VW of run
	mov	al, 'A'			;* min CH
	cmp	cl, al
	jb	not_upper
	cmp	cl, 'Z'			;* max CH
	jna	assign_vw
not_upper:
	mov	al, 'a'
	cmp	cl, al
	jb	not_lower
	cmp	cl, 'z'
	jna	assign_vw
not_lower:
	mov	al, 1
	cmp	cl, al
	jb	not_ctrl
	cmp	cl, 26
	jna	assign_vw
not_ctrl:
	mov	bl, VwOfVk(VK_0)
	mov	al, '0'
	cmp	cl, al
	jb	not_number
	cmp	cl, '9'
	ja	not_number
	Assert	SC_NUMBER_MAX LT SC_NUMPAD_MIN
	cmp	ch, SC_NUMBER_MAX
	jb	assign_vw
	mov	bl, VwOfVk(VK_NUMPAD0)
	or	ssOn, SS_EXTENDED
assign_vw:
	sub	al, cl		;* bl = bl + (cl - al)
	sub	bl, al		;/* vw += ch - chMin; */
	jmp	short done_xlat
not_number:
	xor	bl, bl
	cmp	cl, ' '
	je	done_xlat
	cmp	cx, 562Eh	;* ch = '.', sc = SC_DECIMAL
	jne	done_xlat
	mov	bl, VwOfVk(VK_DECIMAL)
	or	ssOn, SS_EXTENDED

done_xlat:	;* CX == sc:ch, ssTemp == ss, BL = vw

;{{
;	ssNew = (ss & ~ssOff) | ssOn;
;	DoShift(ssNew);
;}}

	mov	ax,ssOff
	not	ax
	and	ax,ssTemp			;* ss & ~ssOff
	or	ax,ssOn
	push	ax				;* save ssNew
	pop	dx				;* ssNew

;{{
;	if (vw | ch)
;		{
;		/* 1 message for WM_CHAR only !! */
;		KeyboardMessage(vw, ch, KkOfSs(ssNew), FALSE);
;		}
	mov	al,bl
	or	al,cl
	jz	no_key_event

	mov	al,ch				;* sc
	Assert	<?PLM>

	push	bx				;* vw
	xor	ch,ch
	or	cl,cl
	jnz	we_have_char
;*	* no char -- put in the VK
	Assert	<VwOfVk(155H) EQ 55H>
	mov	cl,bl
	inc	ch				;* ch == 1
we_have_char:
	push	cx				;* ch
	cCall	KkOfSs, <dx>
	push	ax
	xor	bx,bx
	push	bx				;* FALSE
	mov	bx,[di].pinkbCur
	cCall	[bx].lpfnKeyboardMessageInkb

no_key_event:

;{{	/* restore shift states */
;	DoShift(ss);
;	goto retry_xlating;
;}}
	cCall	DoShift,<ssTemp>

cEnd	XlateKey

;*********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\syd\inc\syd_code.asm ===
;*
;*	CW : Character Windows
;*
;*	syd_code.asm : Start of SYD code

;*****************************************************************************

sBegin	DRV
    assumes CS,DRV
    assumes ds,NOTHING
    assumes ss,NOTHING

	ORG	0H			;* start of .SYD file

;*****************************************************************************

;*	* Format of Start of SYD file
;*	* DO NOT CHANGE THIS FORMAT !!!

lpwDataSyd		label	dword		;* allocated by driver loader
OFF_lpwDataSyd	DW	cbDataSyd	;* at load time:  cbData
					;* after loading: OFF_lpwDataSyd
SEG_lpwDataSyd	DW	fmemDataSyd	;* at load time:  fmemData
					;* after loading: SEG_lpwDataSyd

pinos		DW	0		;* pinos
pincs		DW	0		;* pincs

		DW	cpfnSydMin	;* # of entries in table

rgpfn:
		DW	DoSoundSyd
		DW	LGetTimeSyd

	Assert <(($ - rgpfn) / 2) EQ cpfnSydMin>

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\kbd\src\toshiba.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	toshiba.asm : Toshiba ??? DOS 3 installed keyboard driver
;*****************************************************************************

	include	kbd_head.inc

	include	kbd3.inc
	;* special stuff for DOS 3 driver
	include scan3.inc
	include tsr3.inc
	include bios.inc

	include	kbd_data.inc

;*****************************************************************************

	include	kbd_code.asm

TOSHIBA_NUMPAD = 1	; special numpad handling

;*****************************************************************************

;*	* keyboard tables go here

	include keytable.asm			;* Scan code tables

	include	kbd_ibm.asm			;* IBM helpers etc

;*****************************************************************************

;*	* Main routines

	include keyacc3.asm			;* accessory routines

	include	keyddl3.asm			;* shift diddle tables

	include	keyint3.asm			;* interrupt

	include	keyxlat.asm			;* polling translations

;*****************************************************************************

	include	kbd_std.asm		;* standard init/term

;*****************************************************************************

	include	kbd_tail.asm		;* tail file

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\syd\inc\syd_data.inc ===
;*
;*	CW : Character Windows Drivers
;*
;*	syd_data.inc : Standard SYD data


;*****************************************************************************

SYDATA	STRUC		;* System driver data
	;* nothing needed yet
SYDATA	ENDS

cbDataSyd	equ	(size SYDATA)		;* size of data structure
fmemDataSyd	equ	fmemNear		;* must be in near space

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\syd\inc\syd_head.inc ===
;*
;*	CW : Character Windows
;*
;*	syd_head.inc : header file for all SYD drivers

;*****************************************************************************

.xlist
	include drv.inc

	include insyd.inc				;* installable system
.list

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\syd\src\fx_data.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	fx_data.asm : linked in 3 SYD data
;*****************************************************************************

sBegin	DATA
    assumes DS,DGROUP
    assumes CS,DGROUP

labelB	<PUBLIC, inyj>			;* jump table (see header for INYJ)

	DD	DoSoundSyd
	DD	LGetTimeSyd

	Assert <(($ - inyj) / 4) EQ cpfnSydMin>

sEnd	DATA

;*****************************************************************************
;* Zero initialized data

sBegin	BSS
    assumes DS,DGROUP

IF cbDataSyd NE 0
IFDEF DUALOS2
externW	rgwDataSyd
ELSE ;!DUALOS2
;*	* NOTE: Assertion cbDataSyd(fxdsyd3) >= cbDataSyd(fxdsyd5)
globalW	rgwDataSyd, <((cbDataSyd + 1)/ 2) DUP (?)>	;* Screen driver data
ENDIF ;!DUALOS2
ENDIF

sEnd	BSS

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\cow\strings.c ===
/*
	COW : Character Oriented Windows

	strings.c : common string pool (multiused strings)

	(compiles with minimal headers)
	NOTE : the types of data in this file must track strings.h
*/

#ifndef COW
/* International build */
/* define language in compile flags
#else	/* normal build */
#include <version.h>
#endif

#include <itl.h>

char	szEmptyString[]		=	"";
char	szOkString[]		=	szOk;
char	szCancelString[]	=	szCancel;
char 	szYesString[]		=	szYes;
char	szNoString[]		=	szNo;
char	szRetryString[]		=	szRetry;
char	szAbortString[]		=	szAbort;
#ifdef HELP_BUTTON
char	szHelpString[]		=	szHelp;
#endif

/* Array of bytes containing info (see MBB structure for details) */
/* 3 bytes per option */
char pascal rgmbb[] =
	{
	0,				0,		0,
	sizeof(szOkString)-1,		cchOk+2,	'\0',
	sizeof(szCancelString)-1,	cchCancel+2,	'\0',
	sizeof(szNoString)-1,		cchNo+2,	chAccelNo,
	sizeof(szYesString)-1,		cchYes+2,	chAccelYes,
	sizeof(szRetryString)-1,	cchRetry+2,	chAccelRetry,
	sizeof(szAbortString)-1,	cchAbort+2,	chAccelAbort
#ifdef HELP_BUTTON
	, sizeof(szHelpString)-1,	  cchHelp+2,	  chAccelHelp
#endif
	};

char pascal mpmbcchButton[] =
	{
#ifdef HELP_BUTTON
#ifdef BUTTON_CENTER
	(cchOk+2) + 3 + (cchHelp+2),
	(cchYes+2) + 3 + (cchNo+2) + 3 + (cchCancel+2) + 3 + (cchHelp+2),
	(cchRetry+2) + 3 + (cchCancel+2) + 3 + (cchHelp+2),
	(cchOk+2) + 3 + (cchCancel+2) + 3 + (cchHelp+2),
	(cchAbort+2) + 3 + (cchHelp+2),
	(cchYes+2) + 3 + (cchNo+2) + 3 + (cchHelp+2),
	(cchRetry+2) + 3 + (cchHelp+2)
#else
	(cchOk+2) + 2 + (cchHelp+2) + 2,
	(cchYes+2) + 2 + (cchNo+2) + 2 + (cchCancel+2) + 2 + (cchHelp+2) + 2,
	(cchRetry+2) + 2 + (cchCancel+2) + 2 + (cchHelp+2) + 2,
	(cchOk+2) + 2 + (cchCancel+2) + 2 + (cchHelp+2) + 2,
	(cchAbort+2) + 2 + (cchHelp+2) + 2,
	(cchYes+2) + 2 + (cchNo+2) + 2 + (cchHelp+2) + 2,
	(cchRetry+2) + 2 + (cchHelp+2) + 2
#endif /*BUTTON_CENTER*/
#else /*HELP_BUTTON*/
#ifdef BUTTON_CENTER
	(cchOk+2),
	(cchYes+2) + 3 + (cchNo+2) + 3 + (cchCancel+2),
	(cchRetry+2) + 3 + (cchCancel+2),
	(cchOk+2) + 3 + (cchCancel+2),
	(cchAbort+2),
	(cchYes+2) + 3 + (cchNo+2),
	(cchRetry+2)
#else
	(cchOk+2) + 2,
	(cchYes+2) + 2 + (cchNo+2) + 2 + (cchCancel+2) + 2,
	(cchRetry+2) + 2 + (cchCancel+2) + 2,
	(cchOk+2) + 2 + (cchCancel+2) + 2,
	(cchAbort+2) + 2,
	(cchYes+2) + 2 + (cchNo+2) + 2,
	(cchRetry+2) + 2
#endif /*BUTTON_CENTER*/
#endif /*HELP_BUTTON*/
	};
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\syd\inc\syd_tail.asm ===
;*
;*	CW : Character Windows
;*
;*	syd_tail.asm : trailer file for all SYD drivers

sEnd	DRV
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\syd\inc\syd_std.asm ===
;*
;*	CW : Character Windows
;*
;*	syd_std.asm : standard defaults
;*


ifndef DoSoundSyd_NonDefault
;*****************************************************************************
;********** DoSoundSyd **********
;*	* SYD entry point (see documentation for interface)

cProc	DoSoundSyd, <FAR, PUBLIC, ATOMIC>
    parmW  req
cBegin	DoSoundSyd

cEnd	DoSoundSyd
;*****************************************************************************
endif	;* DoSoundSyd_NonDefault



ifndef LGetTimeSyd_NonDefault
;*****************************************************************************
;********** LGetTimeSyd **********
;*	* SYD entry point (see documentation for interface)

cProc	LGetTimeSyd, <FAR, PUBLIC, ATOMIC>
cBegin	LGetTimeSyd

	xor	ax,ax
	xor	dx,dx

cEnd	LGetTimeSyd
;*****************************************************************************
endif	;* LGetTimeSyd_NonDefault
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\syd\src\template.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	template.asm : template for a SYD file
;*		items marked with "||--" must be changed
;*****************************************************************************

	include	syd_head.inc

;||-- OPTIONAL: standard data for driver
	include	syd_data.inc

;*****************************************************************************

	include	syd_code.asm			;* first part of code

;*****************************************************************************

;||-- put any non-standard procedures here

;*****************************************************************************

	include	syd_std.asm		;* standard init/term

;*****************************************************************************

	include	syd_tail.asm		;* tail file

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\syd\src\fx_syd3.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	fx_syd3.asm : linked in DOS 3 SYD file
;*****************************************************************************

	include	syd_head.inc
	include	fxdrv.inc

	include	syd_data.inc

;*****************************************************************************

	include	fx_data.asm

;*****************************************************************************

sBegin	DRV
    assumes CS,DRV
    assumes ds,NOTHING
    assumes ss,NOTHING

IF cbDataSyd NE 0
;*	* There is no low memory structure for the linked driver
OFF_lpwDataSyd	DW	dataOffset rgwDataSyd
ENDIF

;*****************************************************************************

NonStandard	DoSoundSyd
NonStandard	LGetTimeSyd

;*****************************************************************************

;********** DoSoundSyd **********
;*	* SYD entry point (see documentation for interface)

cProc	DoSoundSyd, <FAR, PUBLIC, ATOMIC>
    parmW  req
cBegin	DoSoundSyd

	mov	cx,req			;* 0=> beep, 1=> click
	jcxz	do_beep
	dec	cx
	jnz	end_sound
;*	* do click
	mov	cx,200		;* ?????
	cCall	Tone
	jmp	short end_sound

;*	* do beep
do_beep:
	mov	cx,1356		;* A5
	cCall	Tone
	mov	cx,1708		;* F5
	cCall	Tone
end_sound:

cEnd	DoSoundSyd


cProc	Tone,<NEAR,ATOMIC>
cBegin	Tone
	mov	al,182
	out	43h,al
	mov	al,cl
	out	42h,al
	mov	al,ch
	out	42h,al

	in	al,61h
	or	al,3		; turn speaker on
	out	61h,al
	
;*	* delay 60 ms.
	mov	cx,60
delay1:
	push	cx
	mov	cx,260
delay2:
	loop	delay2
	pop	cx
	loop	delay1

	in	al,61h
	and	al,0fch		; turn speaker off
	out	61h,al
cEnd	Tone



;*****************************************************************************

;*****************************************************************************
;********** LGetTimeSyd **********
;*	* SYD entry point (see documentation for interface)

cProc	LGetTimeSyd, <FAR, PUBLIC, ATOMIC>
cBegin	LGetTimeSyd

TIC_COUNT	EQU	46ch
	xor	ax,ax
	mov	es,ax
	les	ax,es:[TIC_COUNT]	; ES:AX current timer count from bios
	mov	dx,es			; DX:AX count 
					; DH is always 0, so don't have to make
					; it signed.  Biggest DL gets is 18h
;
; Shouldn't do the INT 1ah, since it clears and returns the "date rolled over"
; flag.
;	mov	ah,0
;	int	1aH
;	mov	ax,dx
;	mov	dx,cx
;	and	dx,7fffH			;* make signed

cEnd	LGetTimeSyd


;*****************************************************************************

	include	syd_std.asm		;* standard init/term

	include	syd_tail.asm		;* tail file

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\syd\src\glis.inc ===
;*
;*	CW : Character Windows Drivers
;*
;*	glis : Global Info Segment Contents
;*****************************************************************************

;*	* Global Info Segment
GLIS	STRUC		;* from DosGetInfoSeg
	timeGlis	DD	?
	msGlis		DD	?
	hourGlis	DB	?
	minuteGlis	DB	?
	secGlis		DB	?
	hundredthGlis	DB	?
	dminGmtGlis	DW	?
	intervalGlis	DW	?
;*	* more here
GLIS	ENDS

;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\beef\drv\syd\src\fx_syd5.asm ===
;*
;*	CW : Character Windows Drivers
;*
;*	fx_syd3.asm : linked in DOS 3 SYD file
;*****************************************************************************

	include	syd_head.inc

	include	fxdrv.inc

	include	syd_data.inc

;*	* OS2 global info
	include glis.inc

;*****************************************************************************

	include	fx_data.asm

;*****************************************************************************

sBegin	DRV
    assumes CS,DRV
    assumes ds,NOTHING
    assumes ss,NOTHING

IF cbDataSyd NE 0
;*	* There is no low memory structure for the linked driver
OFF_lpwDataSyd	DW	dataOffset rgwDataSyd
ENDIF

;*****************************************************************************

NonStandard	DoSoundSyd
NonStandard	LGetTimeSyd

;*****************************************************************************

;********** DoSoundSyd **********
;*	* SYD entry point (see documentation for interface)

cProc	DoSoundSyd, <FAR, PUBLIC, ATOMIC>
    parmW  req
cBegin	DoSoundSyd

	mov	cx,req			;* 0=> beep, 1=> click
	jcxz	do_beep
	dec	cx
	jnz	end_sound
;*	* do click (440Hz, 10ms)
	mov	ax,440
	mov	cx,10
	jmp	short do_sound

;*	* do beep (880Hz, 50ms)
do_beep:
	mov	ax,440*2
	mov	cx,50
do_sound:
	mov	bx,pinos
	cCall	[bx].lpfnDosBeepInos,<ax, cx>

end_sound:

cEnd	DoSoundSyd



;*****************************************************************************

;*****************************************************************************
;********** LGetTimeSyd **********
;*	* SYD entry point (see documentation for interface)

cProc	LGetTimeSyd, <FAR, PUBLIC, ATOMIC>
cBegin	LGetTimeSyd

	mov	bx,pinos
	mov	es,[bx].sdGlisInos
	xor	bx,bx
reget_loop:
	mov	cx,word ptr es:[bx].msGlis		;* low word
	mov	ax,word ptr es:[bx].msGlis + 2		;* high word
	cmp	cx,word ptr es:[bx].msGlis		;* tick changed ?
	jnz	reget_loop
;*	* ax:cx = ms tick resolution (convert to 1/18th sec)
	mov	bx,55					;* divide value
	xor	dx,dx
	div	bx					;* ax = quotient,
							;*  dx = remainder
	push	ax					;* high word
	mov	ax,dx					;* remainder
	mul	bx					;* dx:ax = remainder*55
	add	ax,cx
	adc	dx,0
	div	bx					;* ax = remainder
	pop	dx
;*	* dx:ax = system time / 55

cEnd	LGetTimeSyd


;*****************************************************************************

	include	syd_std.asm		;* standard init/term

	include	syd_tail.asm		;* tail file

;*****************************************************************************

	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\cow\itl.h ===
/*
	COW : Character Oriented Windows

	itl.h   : Internationalization header

	This contains strings for use in QBASIC dialog boxes.

	You have a string in quotes, followed by its length +
	the total number of spaces to have on each side of
	the string.

	eg. "OK" is 2 long, the 4 means put 4/2=2 spaces on
	    each side of the word when it is being displayed.
	    make sure you leave the brackets around the numbers
	    ie, 2+4 is incorrect, (2+4) is correct.

	Some also have their hotkey following the key and the
	size, make sure that you leave the single qutoes (')
	around these characters.

	You may have to make some adjustments to the .des files
	when you have changed this file.

	eg, say you translate "OK" to "Okay", then the size
	might go to (4+4), or whatever you want.
	Then you would go to the .des files.
	lines with the following would have to be modified:

	OK_BUTTON AT (col, row, 6, 1) ACT...........
				^

	to

	OK_BUTTON AT (col, row, 8, 1) ACT...........
				^

*/


#define szOk            "OK"
#define cchOk           (2+4)
/* chAccelOk no accelerator */

#define szYes           "Yes"
#define cchYes          (3+2)
#define chAccelYes      'Y'

#define szNo            "No"
#define cchNo           (2+4)
#define chAccelNo       'N'

#define szCancel        "Cancel"
#define cchCancel       6
/* chAccelCancel no accelerator */

#define szRetry         "Retry"
#define cchRetry        5
#define chAccelRetry    'R'

#define szAbort         "Abort"
#define cchAbort        5
#define chAccelAbort    'A'

#ifdef HELP_BUTTON
#define szHelp          "Help"
#define cchHelp         (4+2)
#define chAccelHelp     'H'
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\cow\version.h ===
/* -- Version control for Non-Swapped Cow */

/* -- project */
#define PROJECT_QB		1	/* the project */
#define	LANGUAGE_ENGLISH	1	/* the language */

/* Mouse control */
#define	MOUSE_EXTRAS		1	/* extra mouse stuff */

/* Keyboard control */
#define	ACCEL_MULTIPLE		1	/* multiple items with same accelerator */

/* Listbox customization */
#define	LISTBOX_DIR		1	/* DIR listboxes ? */
#define	LISTBOX_HORIZ		1	/* horizontal listbox support */
#define LISTBOX_ONELINE 	1	/* skip scroll bars for one line listbox */
#define LISTBOX_NOSCROLL	1	/* No scrollbars of fNoScroll is set */
#define LISTBOX_LIMIT_SIZE	1	/* Limit the listbox size */

/* Visual attributes */
#define DIALOG_LINE		1	/* line at bottom of dialog? */
#define BUTTON_CENTER		1	/* center buttons in messagebox? */
#define MENU_RIGHT_JUSTIFY	1	/* Allow \t to right justify */
#define BUILTIN_SNOW		1	/* May be using snowy CGA driver */
#define HELP_BUTTON		1	/* add help button support to dialogs */
#define ADJUST_MSGBOX		1	/* adjust message box if flag set */

/* EDIT */
#define	EDIT_SECRET		1	/* Secret windows */
#define EDIT_FULLMGR		1	/* full screen editor ? */
#define	EDIT_LIMIT_SIZE		1	/* limit single line edit size */

/* extra customizations */
#define INT24_ALTERNATE 	1	/* alternate int24 handler provided */
#define RECORD_PLAYBACK 	1	/* record and playback of messages */
#define MOUSE_TEXT		1	/* Mouse cursor is not graphical */
#define MSG_LIMIT_SIZE		1	/* Limit message queue size */
#define DIALOG_NOSAVE		1	/* Don't save screen under dialogs */
#define DRAW_MODE_MINIMIZE	1	/* Eliminate unnecessary draw modes */

/************ Swapped attributes ***********/
/* -- n/a -- */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\87toalt.inc ===
;***
;87toalt.inc - 11-Jul-88 - Math Instruction Macros
;***
	IFNDEF	LI_EXPAND
	.XLIST
	ENDIF
;***
;
;	Copyright <C> 1988, Microsoft Corporation
;
;Purpose:
;	This include file defines macros that redefines the 8087 emulator
;	instructions so that Altmath is used.  These macros are defined
;	whenever this file is included.  For emulator versions then this
;	file is not included.
;
;	The macro names are the actual 8087 instructions and the macros
;	use the exact same parameters as the 8087 instructions.  To use
;	Altmath all that has to be done is do an include of this file
;	in every source file that uses floating point instructions and
;	link it together with 87toalt.asm.  87toalt.asm contains the
;	Altmath interface calls and some routines that are not supplied in
;	altmath.
;
;	Not all 8087 instructions are available.  Basically the following
;	instructions are available:
;		fld
;		fild
;		fst
;		fstp
;		fistp
;		fxch
;		fld1
;		fldz
;		fcompp
;		fstsw
;		fadd
;		fsub
;		fmul
;		fdiv
;		fabs
;		fchs
;		fsqrt
;		fwait
;
;	All the possible forms may not be available for all of these
;	instructions.  Which forms that are available will depend of
;	which interface routines have been included in the 87toalt.asm
;	file.
;
;	If an 8087 instruction has been added to the source that was
;	currently supported and a link error claiming that AltM**** was
;	an unresolved external then the following things will have to
;	have to be done to include that form of the instruction.
;
;	1)	find the EXTRN in this for AltM**** and uncomment it.
;	2)	find the macro-call code for AltM**** in 87toalt.asm
;		and uncomment it.
;
;
;******************************************************************************

m87toalt_INC = -1   ;needed by QBI sources which also include this file.

;******************************************************************************
;
; The macros defined in this file along with the externs done in them should
; not be included by the 87toalt.asm file.
ifndef m87toalt_ASM
;
;******************************************************************************
;
;	Helper macros used only in this file
;
;********************
; Macro MSSame compares the sbs (string being searched) starting at col c
; with slf (string to look for).  TRUE is returend if the slf is present in
; the sbs starting at col c.  FALSE is returned otherwise.  TRUE or FALSE is
; retuened in the symbol same.  This comparison is CASE SENSITIVE.
;
; Uses local symbol prefix MM3.
;
MSSame	MACRO	sbs,slf,c,same
MM3ntmp	INSTR	c,<sbs>,<slf>
same	=	(MM3ntmp EQ c)
	ENDM ;; MSSame
;
;********************
; Macro MgetST takes as input in arg a string of the form "ST(x)" where x
; is from 0..7 and is the 8087 register number.  The macro returns in dest
; the register number from 0..7.  The macro will generate assembly errors if
; the arg is not in the correct form.  If the arg is simple "ST" then dest
; is 0.
;
; Uses local symbols prefix MM1
;
MgetST	MACRO	arg,dest
ifidni	<arg>,<ST>			;; Check for ST
  dest	= 0
else ;; if ST
  MM1narglen SIZESTR <arg>		;; Make sure that it is correct length
  if (MM1narglen NE 5)
    	.err	; Invalid numeric stack register form (len)
	dest = 0
  else ;; if len = 5 
	MSSame	<arg>,<ST(>,1,MM1nust	;; Check for ST(
	MSSame	<arg>,<st(>,1,MM1nlst   ;; st( is also acceptable

    MM1sRegchar SUBSTR	<arg>,4,1	;; get the register number
    MM1nRegNo INSTR	<01234567>,MM1sRegchar

	MSSame	<arg>,<)>,5,MM1nrp	;; Check for )
  
    if ((MM1nust OR MM1nlst) AND MM1nrp AND (MM1nRegNo GT 0))
	dest = MM1nRegNo-1		;; return valid reg number
    else ;; valid register
    	.err	; Invalid numeric stack register form (invalid chars)
	dest = 0
    endif ;; valid register
  endif ;; if len = 5
endif ;; if ST
	ENDM		;; MgetST
;
;********************
; This macro decodes a memory address and finds out what segment it is.  The
; following are examples of valid forms of arg:
;	[BX]
;	DS:[BX]
;	ES:[PFrame]
;	DGROUP:[SI-6]
;	CS:[bx]
; The macro returns	0 for DS
;		 	1 for SS
;			2 for ES
;			3 for CS
;
; The macro assumes that DGROUP is same as DS.
;
; Uses prefix MM4 for local symbols
;
MGetSeg	MACRO	arg,dest
MM4cc	INSTR	<arg>,<:>		;; check for location of the :
if (MM4cc EQ 0)
  dest	=	0			;; Assume DS if no segment override
elseif (MM4cc EQ 3)
  MM4subs	SUBSTR	<arg>,1,2		;; Take of the segment part
  MM4cd	INSTR	<DSdsSSssESesCScs>,MM4subs	;; Find out wich segment
  if ((MM4cd AND 1) EQ 0)		;; then not legal segment
  	.err	; Illegal segment
    dest =	0			;; DS, even if error
  else
    dest =	((MM4cd-1) / 4)		;; get segment number
  endif		;; if MM4cd even
elseif (MM4cc EQ 7)
  	MSSame	<arg>,<DGROUP>,1,MM4isudgroup
  	MSSame	<arg>,<dgroup>,1,MM4isldgroup
  if (MM4isudgroup OR MM4isldgroup)
    dest =	0		;; DGROUP same as DS
  else ;; if DGROUP
    .err	; illegal segment
    dest =	0
  endif ;; if DGROUP
else ;; none of the above
  .err		; illegal segment
  dest	=	0
endif ;; if MM4cc
	ENDM MGetSeg
;
;********************
;
; Get the segment letter from the Segment number.  This letter is intended
; to be used in the concatination of the altmath call name.  The letters are
; the letters used by altmath.
; 	SegNo	Segment	Letter		Altmath example
;	0	DS	f		flds
;	1	SS	s		slds
;	2	ES	e		elds
;	3	CS	e		elds	;; ES must be set to CS
;
GetSegLetter	MACRO	SegNo,SegLetter
SegLetter	SUBSTR	<fsee>,(SegNo+1),1
		ENDM		;; GetSegLetter
;
;********************
;
; Get the Floating point data size letter.  This letter is intended
; to be used in the concatination of the altmath call name.
;	Typeword	Type	TypeLetter	Altmath example
;	dword		single	s		flds
;	qword		double	d		fldd
;
GetTypeRLetter	MACRO	TypeWord,TypeLetter
ifidni	<TypeWord>,<dword>
  TypeLetter	EQU	<s>		;; type is single precision
elseifidni <TypeWord>,<qword>
  TypeLetter	EQU	<d>		;; type is double precision
elseifidni <TypeWord>,<tbyte>
  TypeLetter	EQU	<t>		;; type is 10 byte float
else	;; Not dword or qword
	.err		; Illegal pointer type for floating point instruction
endif	;; <TypeWord>
	ENDM	;; GetTypeRLetter
;
;********************
;
; Get the Integer data size letter.  This letter is intended
; to be used in the concatination of the altmath call name.
;	Typeword	Type	TypeLetter	Altmath example
;	word		I2	w		fldw
;	dword		I4	l		fldl
;
GetTypeILetter	MACRO	TypeWord,TypeLetter
ifidni	<TypeWord>,<word>
  TypeLetter	EQU	<w>		;; type is I2 precision
elseifidni <TypeWord>,<dword>
  TypeLetter	EQU	<l>		;; type is I4 precision
else	;; Not word or dword
	.err		; Illegal pointer type for Integer instruction
endif	;; <TypeWord>
	ENDM	;; GetTypeILetter
;
;********************
;
; Most altmath routines expect their input from [BX].  This macro is used
; to insure that the input will be found at [BX].  This is done by checking
; the argument for [BX], if it not there then expand to a lea bx,...  If [BX]
; is there then expand to nothing
;
; Uses MM5 as prefix to local symbols.
;
MSetupBX MACRO	arg
MM5cc	INSTR	<arg>,<:>
if (MM5cc)
  MM5loc	SUBSTR	<arg>,MM5cc+1	;; get the substring after the colon
else ; colon present
  MM5loc	EQU	arg		;; get the whole arg
endif ; colon present
MM5ubx	INSTR	MM5loc,<[BX]>		;; check for [BX]
MM5lbx	INSTR	MM5loc,<[bx]>		;; check for [bx]
if ((MM5ubx NE 1) AND (MM5lbx NE 1))
	push	bx			;; Save BX only if modified here
	lea	bx,MM5loc		;; if no [BX]
endif	;; if no [BX]
	ENDM	;; MSetupBX
;
;********************
; This routine will only restore BX if saved during MSetupBX
MRestoreBX	MACRO
if ((MM5ubx NE 1) AND (MM5lbx NE 1))	;; These symbols were set in MSetupBX
	pop	bx			;; if BX was saved
endif	;; if no [BX]
	ENDM	;; MRestoreBX
;
;********************
;
; This macro is used to generate the actual altmath call when a memory
; referenace is used.  The following things are done.
;	1)	Determine the data type (single(dword) or double(qword))
;	2)	Pushes BX and sets up the BX register if needed
;	3)	Determin the segemnt used and appropriate setup for segment
;		when needed.
;	4)	create the actual call to the interface routine
;	5)	Any cleanup that is needed
;
;**********
;
; Floating point version
GenerateRPtrCall MACRO	InstName,arg1,arg3,sufx
    	GetTypeRLetter <arg1>,MMTypeLetter
	MSetupBX <arg3>
	MGetSeg	<arg3>,MMSegNumber
	GetSegLetter MMSegNumber,MMSegLetter
if (MMsegNumber EQ 3)	;; Segment = CS
	push	es	;; make ES same as CS
	push	cs
	pop	es
endif ;; segment = CS

MMsinst	CATSTR	<AltM>,MMSegLetter,<InstName>,MMTypeLetter,<sufx>
	EXTRN	MMsinst:PROC
    	call	MMsinst
if (MMsegNumber EQ 3)
	pop	es	;; restore ES
endif ;; segment CS
	MRestoreBX	;
    	ENDM	;; GenerateRPtrCall
;
;**********
;
; Integer varsion
GenerateIPtrCall MACRO	InstName,arg1,arg3,sufx
    	GetTypeILetter <arg1>,MMTypeLetter
	MSetupBX <arg3>
	MGetSeg	<arg3>,MMSegNumber
	GetSegLetter MMSegNumber,MMSegLetter
if (MMsegNumber EQ 3)	;; Segment = CS
	push	es	;; make ES same as CS
	push	cs
	pop	es
endif ;; segment = CS

MMsinst	CATSTR	<AltM>,MMSegLetter,<InstName>,MMTypeLetter,<sufx>
    	EXTRN	MMsinst:PROC		;; the altmath interface call
    	call	MMsinst			;; the altmath interface call
if (MMsegNumber EQ 3)
	pop	es	;; restore ES
endif ;; segment CS
	MRestoreBX	;
    	ENDM	;; GenerateIPtrCall
;
;******************************************************************************
; fld
;
; Forms of this macro:
; 1	fld	ST
; 2	fld	ST(x)		;; where 0<=x<=7
; 3	fld	dword ptr [bx]	
; 4	fld	qword ptr [bx]
;
fld	MACRO	arg1,arg2,arg3,arg4
ifnb <arg4>			;; Check number of arguments
	.err			; Three arguments max for fld
endif	;; ifnb arg4
ifb <arg2>			;; Check if register form
	MgetST	<arg1>,MMstreg	;; Must be of form ST or ST(x)
  if (MMstreg EQ 0)
	EXTRN	AltMfdup:PROC
	call	AltMfdup	;; if ST 0 then duplicate TOS
  else	;; if ST(0)
	push	bx		;; fld ST(streg)
	mov	bl,MMstreg
	EXTRN	AltMfldst:PROC
	call	AltMfldst
	pop	bx
  endif	;; if ST(0)
else ;; arg2 not blank
  ifidni <arg2>,<ptr>
	GenerateRPtrCall <ld>,<arg1>,<arg3>
  else		;; if (isptr)
  	.err	Illegal form of fld instruction
  endif		;; if (isptr)
endif	;; arg2 not blank
	ENDM	;;   fld
;
;******************************************************************************
; fild
;
fild	MACRO	arg1,arg2,arg3,arg4
ifnb <arg4>			;; Check number of arguments
	.err			; Three arguments max for fild
endif	;; ifnb arg4
ifidni <arg2>,<ptr>
	GenerateIPtrCall <ld>,<arg1>,<arg3>
else		;; if arg2 is ptr
  	.err	Illegal form of fild instruction
endif		;; if arg2 is ptr
	ENDM	;; fild
;
;******************************************************************************
; fxch
;
fxch	MACRO	arg1,arg2
ifnb <arg2>			;; Check number of arguments
	.err			; Maximum one argument
endif	;; ifnb arg2
ifb <arg1>
	EXTRN	AltMfxch:PROC	;; moved inside macro
	call	AltMfxch
else
  	MgetST	<arg1>,MMstreg
  	push	bx
  	mov	bl,MMstreg
  	EXTRN	AltMfxchq:PROC
  	call	AltMfxchq
  	pop	bx
endif	;; ifb <arg1>
	ENDM		;; fxch
;
;******************************************************************************
; fst
fst	MACRO	arg1,arg2,arg3,arg4
ifnb <arg4>			;; Check number of arguments
	.err			; Three arguments max for fst
endif	;; ifnb arg4
ifidni <arg2>,<ptr>
	GenerateRPtrCall <st>,<arg1>,<arg3>
else		;; if (isptr)
  	.err	Illegal form of fst instruction
endif		;; if (isptr)
	ENDM	;; fst
;
;******************************************************************************
; fstp
;
fstp	MACRO	arg1,arg2,arg3,arg4
ifnb <arg4>			;; Check number of arguments
	.err			; Three arguments max for fstp
endif	;; ifnb arg4
ifb <arg2>
	MgetST arg1,MMstreg
  if (MMstreg EQ 0)
  	EXTRN	AltMfstpST0:PROC
  	call	AltMfstpST0
  else ;; if (MMstreg EQ 0)
  	.err	Illegal form of fstp instruction
  endif	;; if (MMstreg EQ 0)
else ;; ifb <arg2> 
  ifidni <arg2>,<ptr>
	GenerateRPtrCall <st>,<arg1>,<arg3>,<p>
  else		;; if (isptr)
  	.err	Illegal form of fstp instruction
  endif		;; if (isptr)
endif ;; ifb <arg2>
	ENDM	;; fstp
;
;******************************************************************************
; fistp
fistp	MACRO	arg1,arg2,arg3,arg4
ifnb <arg4>			;; Check number of arguments
	.err			; Three arguments max for fistp
endif	;; ifnb arg4
ifidni <arg2>,<ptr>
	GenerateIPtrCall <ist>,<arg1>,<arg3>,<p>
else		;; if (isptr)
  	.err	Illegal form of fistp instruction
endif		;; if (isptr)
	ENDM	;; fistp
;
;******************************************************************************
; fld1
;
fld1	MACRO
	EXTRN	AltMfld1:PROC
	call	AltMfld1
	ENDM	;; fld1
;
;******************************************************************************
; fldz
;
fldz	MACRO
	EXTRN	AltMfldz:PROC	;; moved inside macro
	call	AltMfldz
	ENDM	;; fldz
;
;******************************************************************************
; fcompp
fcompp	MACRO
	EXTRN	AltMfcompp:PROC
	call	AltMfcompp
	ENDM	;; fcompp
;
;******************************************************************************
; fstsw
fstsw	MACRO	arg1,arg2
ifnb	<arg2>
	.err	; Illegal form of fstsw, only one argument
else	;; if too many arguments
sEnd	CODE
sBegin	DATA
	EXTRN	AltMathStatus:WORD	;; declare AltMathStatus as extrn
sEnd	DATA
sBegin	CODE
	push	ax			;; save ax
	mov	ax,AltMathStatus	;; arg1 := AltMathStatus
	mov	arg1,ax
	pop	ax			;; restore ax
endif	;; if too many arguments
	ENDM	;; fstsw
;******************************************************************************
; fadd
fadd	MACRO	arg1,arg2,arg3,arg4
ifnb <arg4>			;; Check number of arguments
	.err			; Three arguments max for fadd
endif	;; ifnb arg4
ifb <arg1>
	EXTRN	AltMfadd:PROC
	call	AltMfadd
else
  ifidni <arg2>,<ptr>
	GenerateRPtrCall <add>,<arg1>,<arg3>
  else		;; if (isptr)
  	.err	Illegal form of fadd instruction
  endif		;; if (isptr)
endif	;; ifb arg1
	ENDM	;; fadd
;******************************************************************************
; fsub
fsub	MACRO	arg1,arg2,arg3,arg4
ifnb <arg4>			;; Check number of arguments
	.err			; Three arguments max for fsub
endif	;; ifnb arg4
ifb <arg1>
	EXTRN	AltMfsub:PROC
	call	AltMfsub
else
  ifidni <arg2>,<ptr>
	GenerateRPtrCall <sub>,<arg1>,<arg3>
  else		;; if (isptr)
  	.err	Illegal form of fsub instruction
  endif		;; if (isptr)
endif	;; ifb arg1
	ENDM	;; fsub
;******************************************************************************
; fmul
fmul	MACRO	arg1,arg2,arg3,arg4
ifnb <arg4>			;; Check number of arguments
	.err			; Three arguments max for fmul
endif	;; ifnb arg4
ifb <arg1>
	EXTRN	AltMfmul:PROC
	call	AltMfmul
else
  ifidni <arg2>,<ptr>
	GenerateRPtrCall <mul>,<arg1>,<arg3>
  else		;; if (isptr)
  	.err	Illegal form of fmul instruction
  endif		;; if (isptr)
endif	;; ifb arg1
	ENDM	;; fmul
;******************************************************************************
; fdiv
fdiv	MACRO	arg1,arg2,arg3,arg4
ifnb <arg4>			;; Check number of arguments
	.err			;; Three arguments max for fdiv
endif	;; ifnb arg4
ifb <arg1>
	EXTRN	AltMfdiv:PROC
	call	AltMfdiv
else
  ifidni <arg2>,<ptr>
	GenerateRPtrCall <div>,<arg1>,<arg3>
  else		;; if (isptr)
  	.err	Illegal form of fdiv instruction
  endif		;; if (isptr)
endif	;; ifb arg1
	ENDM	;; fdiv
;******************************************************************************
; fabs
fabs	MACRO
	EXTRN	AltMfabs:PROC	;; moved inside macro
	call	AltMfabs
	ENDM	;; fabs
;******************************************************************************
; fchs
fchs	MACRO
	EXTRN	AltMfchs:PROC	;; moved inside macro
	call	AltMfchs
	ENDM	;; fchs
;******************************************************************************
; fsqrt
fsqrt	MACRO
	EXTRN	AltMfsqrt:PROC
	call	AltMfsqrt
	ENDM	;; fsqrt
;******************************************************************************
; fwait
fwait	MACRO
	ENDM	;;fwait
;******************************************************************************
;
endif		; ife m87toalt_asm
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\architec.inc ===
;*** 
; FILE: ARCHITEC.INC - architecture-specific items for QBI
;
;	Copyright <C> 1985, 1986, 1987  Microsoft Corporation
;
;Purpose:
;
;   This file contains macros that allow us to optimize certain Intel-family
;   instructions depending on the version or context in which the
;   instructions occur.
;
;
;*******************************************************************************

ARCHITEC_INC = -1



;***
;PUSHI macro - push immediate data word
;
;Entry:
;	reg - register to use as intermediate in the case we're not
;		building for a 286 environment
;	wData - a word of data to be pushed
;Exit:
;	none.
;Modifies:
;	Will alter the given register if not HP_286.
;**************************************************************************


PushI	MACRO	reg,wData
	mov	reg,wData
	push	reg
	ENDM



;***
;SHIFT macro - SHL/SHR/SAL/SAR macro
;
;Purpose:
;	The 186 and 286 instruction sets allow shift instructions of the
;	form 'SHL AX,4', whereas the 8088/8086 instruction set would
;	require either four 'SHL AX,1' instructions or 'MOV CL,4' and
;	'SHL AX,CL' to do the same thing.
;	Note that, in the case where we're not counting on 286 instructions,
;	the code produced depends on the shift count. If the count is 4 or
;	less, individual 'SHL loc,1' instructions are generated. If the
;	shift count is greater, however, the shift is done via CL for size.
;Entry:
;	type - an 'H' or an 'A', depending on whether a Logical or Arithmetic
;		shift is desired
;	dir - an 'L' or an 'R', depending on whether a Left or a Right
;		shift is desired
;	loc - register or memory byte or word to shift. If memory, this
;		parameter should include the WORD PTR or BYTE PTR directive.
;	count - number of times to shift.
;Exit:
;	The given 'loc' is shifted in the given direction 'count' times.
;Modifies:
;	Will modify CL iff the shift count > 4 and not HP_286.
;**************************************************************************
SHIFT	MACRO	type,dir,loc,count
    if count LE 4		;;not HP_286 - can't assume 286 instruction set
	REPT	count
	S&type&dir	loc,1
	ENDM
else
	MOV	CL,count
	S&type&dir	loc,CL
endif
	endm

	;SKIP1_PSW skips 1 byte of code, altering PSW

SKIP1_PSW   equ     <db 3Ch>		;CMP AL,...

	;SKIP2_PSW skips 2 bytes of code, altering PSW

SKIP2_PSW   equ     <db 3Dh>		;CMP AX,...

	;SKIP1_AL skips 1 byte of code, altering AL (leaving PSW intact)

SKIP1_AL    equ     <db 0B0h>		;MOV AL,...

	;SKIP2_AX skips 2 bytes of code, altering AX (leaving PSW intact)

SKIP2_AX    equ     <db 0B8h>		;MOV AX,...


;***
;TESTX macro - optimize test immediate with a register to save bytes.
;
;Purpose:
;
;	Optimize test immediate with AX, BX, CX, or DX to limit the
;	immediate operand to a single byte when either the low byte or
;	the high byte of the immediate value is zero.
;	This is particularly useful in those cases where the immediate operand
;	is a symbolic constant - - - it can be changed and this macro will
;	adjust and optimize the code accordingly.
;
;	In the case of the AX register, TEST AH,Value is not generated.  The
;	TEST AX,Value instruction is the same size (3 bytes) and is also one
;	cycle faster on 8086/8088.  It is the same speed for the 286 and 386.
;
;	Note that the TESTM macro does the same thing, but for the case where
;	the immediate value is tested against a word in memory.
;
;Entry:
;	reg -	A register; must be one of: AX, BX, CX, or DX
;	value -	An immediate value.
;Exit:
;	none.
;Modifies:
;	PSW flags only
;**************************************************************************
TestX	macro	Reg,Value
	local	RegLet
RegLet	substr	<Reg>,1,1		;; First letter of register

	ife	    HIGH (Value)
%	    test    RegLet&&l,Value
	elseifidni  <Reg>,<ax>		;; test ax,? is better than test ah,?
	    test    Reg,Value
	elseife     LOW (Value)
%	    test    RegLet&&h,HIGH (Value)
	else
	    test    Reg,Value
	endif
	endm

;***
;TESTM macro - optimize test immediate with memory to save bytes.
;Purpose:
;	Optimize test immediate with word-sized memory locations to limit 
;	the immediate operand to a single byte when either the low byte or
;	the high byte of the immediate value is zero.
;	This is particularly useful in those cases where the immediate operand
;	is a symbolic constant - - - it can be changed and this macro will
;	adjust and optimize the code accordingly.
;
;	Note that the TESTX macro does the same thing, but for the case where
;	the immediate value is tested against a register.
;
;	Added as revision [1].
;Entry:
;	addr -	A word address which the value is to be tested against.
;		Note: Do not enclose this in square brackets.
;	value -	An immediate value.
;Exit:
;	none.
;Modifies:
;	PSW flags only
;**************************************************************************
TestM	macro	Addr,Value
	ife	HIGH (Value)
	    test    byte ptr [Addr],Value		;;Just test low byte
	elseife low (value)
	    test    byte ptr [Addr+1],HIGH (Value)	;;Just test high byte
	else
	    test    [Addr],Value			;;Test both bytes
	endif
	endm
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\array.inc ===
;***
; array.inc - 12-Nov-86 - far memory and array descriptors
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
; Contains the definition of the array and far heap descriptors.
; 
; NOTE: If you modify this file, notify the QBI group, as they include it too.
;
;Array descriptor fields:
;
; AD_oAdjusted: This field contains the constant portion of the array indexing
;   expression, which takes into account the cumulative affect of all the lower
;   bounds for the array dimensions. Given:
;
;	DIM ARY(l1 to u1, l2 to u2, l3 to u3)
;		  \  /	    \  /      \  /
;		   \/	     \/        \/
;		   c1	     c2        c3	(count of elements)
;
;   The address of any array element can be calculated as:
;
;	(((k - l3) * c2 + j - l2) * c1 + i - l1) * elementsize + offset
;
;   This can be rearranged to isolate the items dealing with the lower bounds:
;
;	(((k * c2 + j) * c1) + i) * elementsize
;	    - (l3 * c2 * c1 + l2 * c1 + l1) * elementsize
;	    + offset
;
;   The second and third lines of this equation are known at DIM time, and are
;   placed into the AD_oAdjusted field. To access an array element then, the
;   calculation required is:
;
;	(((k * c2 + j) * c1) + i) * elementsize + AD_oAdjusted
;
;	NOTE: This is a SHARED INCLUDE FILE, used by both the RUNTIME and
;	NOTE: the interpreter projects.  Any changes made to one should
;	NOTE: be carried over (COPIED) to the other!!!
;
;
;******************************************************************************

ARRAY_INC = -1	;needed by QBI sources which also include this file.

AHD	STRUC			;Array header - in front of data in far space
AHD	ENDS			

;		FHD Structure - Far heap descriptor

FHD		STRUC
FHD_oData	DW	?	;Offset of data start
FHD_hData	DW	?	;Segment of data start
FHD_pNext	DW	?	;DGROUP offset of next FHD
FHD_cPara	DW	?	;Para count of entry (bytes for non-LNA)
FHD		ENDS

;		DM Structure - Array dimension information

DM		STRUC
DM_cElements	DW	?	;Element count for this dimension
DM_iLbound	DW	?	;Lower bound for this dimension
DM		ENDS

;		AD Structure - Array descriptor

AD		STRUC
AD_fhd		DB	SIZE FHD DUP(?) ;FHD for this AD

AD_cDims	DB	?	;Dimension count
AD_fFeatures	DB	?	;Feature flags

AD_oAdjusted	DW	?	; Adjusted offset
AD_cbElement	DW	?	;Byte count per element

AD_tDM		DB	?	;First byte of first DM structure
AD		ENDS

;		AD_fFeatures flag definitions

FADF_NEAR	EQU	0	;near allocation
FADF_FAR	EQU	1	;far allocation
FADF_HUGE	EQU	2	;huge allocation
FADF_ALCMSK	EQU	3	;allocation mask
FADF_STATIC	EQU	40h	;Array is a $STATIC array
FADF_SD 	EQU	80h	;Array is a string array

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\conint.h ===
/* File: CONINT.H - Defines which apply to the QBI Context Manager		*/
/* NOTE: When making changes to this file, be sure to make equivalent	*/
/*			changes to file CONINT.INC													*/

#undef CONINT_H
#define CONINT_H ON			/* remember that this file has been included */

/* Bit flag Constants for conFlags (in context.asm)	*/
#define	F_CON_StaticStructs	1
												/* Set (TRUE) when mrsCur, prsCur
												   and txdCur are to be used to
												   access current context. If
												   reset (FALSE), then these
												   must be accessed out of the
												   appropriate tables.					*/
#define	F_CON_LeaveTMrsEmpty	2	
												/*	normally, if MrsDiscard removes
												   the last mrs from tMrs, it
												   creates a new unnamed one; if
												   this flag is TRUE, it just
												   leaves the table empty
												   an unreferenced empty prs			*/
#define	F_CON_ResetStkSize	4		/* Set by NewStmt when not CHAINing. 
													Causes next BOS/BOL to reset the 
													stack to its default size.			*/
#define	F_CON_RunFile			8		/* Set by exStRunFile so that NewStmt 
													will not show the debug screen	*/

char conFlags;					/* bit flags, used in context.asm */

VOID	FAR	DebChkConStatStructs(VOID);
VOID	FAR	DebChkConNoStatStructs(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\context.h ===
/*** 
*context.h - Defines which apply to the Context Manager
*
*	Copyright <C> 1985, 1986, 1987 Microsoft Corporation
*
*Purpose:
* NOTE: When making changes to this file, be sure to make equivalent   
*       changes to file CONTEXT.INC                                   
*
*******************************************************************************/

#undef CONTEXT_H
#define CONTEXT_H ON       /* remember that this file has been included */

#if !HEAP_H
#include "heap.h"
#endif

/**==================== text descriptor ==================================

Definition of text table descriptor.  Both modules and procedures have
text tables.  All text-offset (otx...) fields in this descriptor are
maintained by the text manager during edit operations, and by the scanner
during pcode expansion/contraction.
For all linked lists through the pcode, (otx...Link), the link is always
a text offset to a pcode's 1st operand, NOT to the 1st byte of the pcode.
This speeds up traversal of the list.

=======================================================================**/

typedef struct txd {
   bdl      bdlText;          /* Owner of far heap entry of pcode */
   ushort   otxLabLink;       /* text offset to linked list of label
                                 definition pcodes (opBolLab etc.)
                                 Offset is to first operand  */
   ushort   otxDefTypeLink;   /* text offset to linked list of opStDefInt etc.
                                 pcodes  */
   ushort   otxTypeLink;      /* text offset to linked list of opStType/
                                 opStEndType pcodes */
   ushort   otxReParseLink;   /* linked list of opReParse opcodes */
   ushort   cLines;           /* Count of lines for scroll bar efficiency. 
                                 Maintained by TextMgr */
   ushort   cLinesIncl;       /* Count of lines from $INCLUDE files */
   ushort   lnCursor;         /* remember cursor line when not visible win */
   char     scanState;        /* Scan state of pcode */
                              /* see scanner.h for values for scanState */
                              /* SS_Executable .. SS_Rude */
   char     flags;            /* FTX_xxx - defined below */
   } txd;

/* txd.flags definitions: */
#define FTX_mrs         0x01     /* TRUE if text table is mrs, not prs */
#define FTX_asChg               0x02            /* TRUE if PreScanAsChg needs to be called
						   before we scan this text table again */
/* The following FTX_Tmp... flags are used temporarily within the scope of
 * SaveDeclares().  If another function needs to make temporary use of a flag,
 * it can use these bits as well, as long as it assumes they contain garbage
 * on entry and exit.
 */
#define FTX_TmpDecl     0x04            /* Used by SaveDeclares in text mgr */
#define FTX_TmpRef      0x08            /* Used by SaveDeclares in text mgr */



/**==================== Procedure Register Set (PRS) ======================
See equivalent comment block in context.inc for complete information.
See comment block just before PrsMake for definition of Prs State Transitions.
=========================================================================**/
/* WARNING: the context manager initialization code depends on the prs, mrs,
            and grs structures being setup such that all items to be zero-
            filled (on struct init.) are at the beginning of the structure.

            Other context mgr code depends on both the prs and the mrs having
            the ogNam field in the same place relative to the start of the
				structure.																			*/

/* bit flag constants, for use with prs.flags, below  */
#define FP_STATIC    0x80     /* TRUE if definition line terminated by STATIC */
#define FP_CDECL     0x40     /* TRUE if external procedure expects 'C' calling
                                 conventions - set by parser                  */
#define FP_DEFINED   0x20     /* Indicates prs is defined by SUB/FUNCTION/DEF
                                 Set by ContextMgr, reset by TextMgr          */
#define FP_ENDPROC   0x10     /* set/reset and tested by TextMgr              */
#define FP_DECLARED  0x08     /* This procedure has been DECLARED             */
#define FP_DEFSCANNED 0x04    /* Definition is in execute state               */

/* bit flag constants, for use with prs.flagss */
#define FP_LOCAL     0x80     /* TRUE if LOCAL procedure		      */
#define FP_AUTO      0x40
#define FP_ExeTree  0x20     /* TRUE if the call tree starting at this
				 proc is all at SS_EXECUTE state */


typedef struct prs {
   ushort   cbFrameVars;      /* Cb of variables in the frame.                */
   ushort	cbFrameTemp;		/* Temp space needed                            */
   ushort  ogNam;					/* [1] offset into global name tbl for prs name */
        /* WARNING: Binary SAVE/LOAD assumes that procType, oType, and flags are
                    contiguous, starting with procType (see binsav.asm)       */
   char     procType;         /* PT_... enumerated below */
   char     oType;            /* DEF/FUNCTION type.  Undefined for SUBs       */
   char     flags;            /* bit flags; constants defined above           */
   char     cwParams;         /* Count of words in stack for parameters */

/* WARNING: Before this point data is initialized to zero.    
            After this point, data is initialized to UNDEFINED.               */

   ushort   oVarHash;         /* offset into module's variable table for this
                                 procedure's local-variable hash table.  Set by
                                 VarMgr.  Set to UNDEFINED initially and by
                                 ModuleRudeEdit                               */
        /* WARNING: Binary SAVE/LOAD saves everything from cbAlias to here, and
                    assumes it's safe to not save or load the items below, 
						  except for the txt (see binsav.asm for complete details)  */

   /* The next 3 fields identify where the current definition of the procedure
      is.  This can refer to a SUB/FUNCTION/DEF, in which case fDefined=TRUE.
      It can refer to a DECLARE SUB/FUNCTION/DEF, in which case fDefined=FALSE.
      For SUBs, it can refer to a CALL or implied CALL reference, in which
      case fDefined=FALSE.  For DEF FN entries, we can have two enties with
      same name and type, as long as the oMrs field is different.
      These fields are used by scanner parm type checking.  If a proc is
      declared or referenced before defined, this refers to 1st reference
      and fDefined is FALSE.  When definition is seen, fDefined is set
      TRUE and these 3 fields are set to real definition. */
   ushort   oMrs;             /* MODULE of current definition - for DEF FNs,
                                 this never changes and it is used in the
                                 prs name search */
   ushort   oRsDef;           /* module/procedure of current definition.
                                 For DEF FNs, this never changes and it is
                                 used in the prs name search */
   ushort   otxDef;           /* offset into text table to current definition.
                                 If a SUB is referenced, but not DECLAREd or
                                 defined, a Prs entry is created and otx is
                                 set to UNDEFINED.  This is only true for SUBs
                                 because BASCOM allows external SUBs to be
                                 called with no DECLARE. */
   ushort  oPrsNext;	      /* [4] offset to next prs in the Rs table       */
   txd      txd;              /* Text Descriptor for pcode for procedure      */
   } prs;

#define M_PT_OTYPE   0x07     /* mask to access oType in prs.oType field (since
				 flag bits are now stored in high nibble      */

/* enumerations for procType */
#define PT_SUB       1
#define PT_FUNCTION  2
#define PT_DEFFN     3
#define PT_NOT_PROC  4	      /* just says 'not any of the above constants'.
				 used as parm internal to context mgr.	This
				 value is Never stored in prs.procType field */


/**==================== Module Register Set ==================================
The Module Register Set contains all entries and owners of tables containing
information about a particular module.

While a module is loaded into mrsCur, its entry in the global Rs table should 
not be referenced or updated.
============================================================================**/
/* WARNING: the context manager initialization code depends on the prs, mrs,
            and grs structures being setup such that all items to be zero-
            filled (on struct init.) are at the beginning of the structure. */

#define OGNAM_UNNAMED		0		/* [2] ogNam for unnamed mrs			*/
#define OGNAM_GMRS			1		/* [1] an invalid ogNam to be used as
							   [1] the ogNam of the global mrs */
#define OGNAM_CLIPBOARD		2		/* [2] ogNam for clipboard mrs		*/
#define OGNAM_IMMEDIATE		3		/* [2] ogNam for Immediate mrs		*/
#define OGNAM_PSEUDO_MAX	3		/* [2] max. pseudo ogNam value		*/

#define OMRS_GLOBAL		0		/* [13] */





/***************************************************
** bit flag constants, for use with mrs.flags, below
** Unused bits: 10, 20, 40, 80
*/
#define FM_OptionBase1  0x01  /* Set if OPTION BASE is 1 (not 0)              */
#define FM_VARNEW       0x02  /* if set, tells CLEAR code to deallocate
                               * $static arrays, not just zero-fill them      */
#define FM_asChg        0x04  /* set when AS x is inserted/deleted in module  */
#define FM_TEMPORARY    0x08  /* only set during LOAD - reset at end of LOAD  */
#define FM_AllSsRude    0x10  /* set if all text tables in module are in
                                 SS_RUDE scan state                           */
#define FM_LinksOk 	0x20  /* [10] */
#define FM_MustVisit	0x40  /* [10] */
#define FM_Visited	0x80  /* [10] */
/* NOTE: all flags except FM_asChg get set to 0 by BinaryLoad().
 *       When adding flags, make sure this is desired
 */

/****************************************************
** bit flag constants, for use with mrs.flags2, below
*/
#define FM2_Modified    0x01  /* set by TextMgr when text has changed         */
#define FM2_NewFile     0x02  /* When this mrs is saved, give a warning if
                               * another file by this name already exists */
#define FM2_Include     0x04  /* This mrs was created by View/Include menu.
                               * When saved, we need to do a ReInclude */
#define FM2_NoPcode     0x08  /* set if mrs has no pcode, just ASCII text  */
#define FM2_File        0x10  /* Set if this mrs has a FILE associated with it.
                               * It must be saved if modified.  Not set for
                               * Command-Window's text and Scrap's text */
#define FM2_AsciiLoaded 0x20  /* set if program was loaded from an ASCII file */
#define FM2_ReInclude	0x40   /* Set when a file is modified.
                                  Reset by TxtReInclude */
#define FM2_EntabSource 0x80  /* Set when ascii loading module if source
                                 file contained leading tabs.  When ascii
                                 saving, we will entab all leading spaces
                                 for this module */
/* NOTE: all flags except FM2_EntabSource get set to 0 by BinaryLoad().
 *       When adding flags, make sure this is desired
 */

/****************************************************
** bit flag constants, for use with mrs.flags3, below
*/
#define FM3_NotFound	0x01  /* Set while loading .MAK file if this module
                               * was not found */
#define FM3_Translated	0x04  //[24] TRUE if we were binary-translated
/* NOTE: flags3 is NOT saved by BinarySave/Load */

typedef struct mrs {
   ushort   cbFrameVars;   /* Cb of variables in the frame.                   */
   ushort   cbFrameTemp;   /* Temp space needed                               */
   ushort   ogNam;         /* [1] source file path name (global name table
                              [1] offset, or 0 in the case of an untitled
			      [1] module or OGNAM_GMRS for the global mrs     */
   bd       bdVar;         /* Table of all module's variables (including
                              variables which are local to procedures         */
   char     flags;         /* bit flags; FM_ constants defined above          */
   char     flags2;        /* bit flags; FM2_ constants defined above         */
   char     flags3;        /* bit flags; FM3_ constants defined above         */
   char     dummy1;        /* Extra byte to word align                        */

/* WARNING: Before this point data is initialized to zero.    
 *          After this point, data is initialized to UNDEFINED.               */

   ushort  oMrsNext;	   /* [4] offset to next mrs in the Rs table	      */
   ushort   otxHandler;    /* Text offset to error handler                    */
   bdl      bdlNam;        /* Module's Name table                             */
   txd      txd;           /* Text Descriptor for pcode for module            */

/* WARNING: Binary SAVE/LOAD depend on otxDefFnLink, oPastLastVar, and the
	    'data' struct being contiguous and in the following order	      */

   ushort   otxDefFnLink;  /* textmgr maintains this linked list of DEF FN's  */
   ushort   oPastLastVar;  /* offset to first byte past last variable in the
                              module variable table; used to ensure dead
                              direct mode FOR entries don't waste tVar space  */
   struct {                /* Head of data chain */
      ushort   otxFirst;   /* opTxt operand for 1st data statement            */
      ushort   otxCur;     /* opTxt operand for current data statement        */
      ushort   oLineCur;   /* byte offset for next READ                       */
      } data;
   } mrs;

/**==================== Global Register Set =================================
The global register set owns heap entries which define the current context.

Only one module table entry or procedure table entry may be active at any
one time.  These tables are managed by swapping a new mrs into mrsCur or
swapping a new procedure into prsCur.

While a module or procedure is loaded into mrsCur or prsCur, its entry
in the global Rs table should not be referenced or updated.

=======================================================================**/
/* WARNING: the context manager initialization code depends on the prs, mrs,
            and grs structures being setup such that all items to be zero-
            filled (on struct init.) are at the beginning of the structure    */

typedef struct grsType {
   char     fScan;         /* TRUE if all modules and procedures are scanned */
   char     fDirect;       /* TRUE if we're executing instructions out of
                              direct-mode text buffer bdlDirect.
                              This is set by UserInterface(), procedure exit,
			      RETURN.  Reset by opStDmGoto, GOSUB, CALL etc.  */
	bd  bdRs;	   /* [4] */
   bd       bdtComBlk;     /* COMMON block table owner */
   char     flags;         /* These are general flags which are independently
                                                              set and reset */
   char     filler;        /* unused */
/* WARNING: Before this point grs struct is initialized to zero.
            After this point, it's initialized to UNDEFINED.                  */

   ushort   oMrsMain;      /* Offset within mrs table for main module. Can be
                              modified by UI. Note that if mrs with this offset
                              is discarded, oMrsMain is set to UNDEFINED and
                              there is NO main module - - - RunInit checks for
                              this condition.                                 */

   ushort   oRsCur;        /* Redundant copy of oMrsCur and oPrsCur.
                              If high bit is set, a procedure is active and
                                 low 15 bits = oPrsCur
                              else
				 no procedure is active and oRsCur == oMrsCur */
   ushort   pMrsCur;
   ushort   pRsCur;
   ushort   offsetTxdSeg;  /* offset into bdtMrs or bdtPrs to the segment
                              address for the current txd                     */
   ushort   oMrsCur;       /* Offset within mrs table for module currently
                              loaded into mrsCur */
   ushort   oPrsCur;       /* Offset within prs table for procedure currently
                              loaded into prsCur */
   ushort   otxCur;        /* Offset within current text table to next
                              instruction to be executed.  This is only valid
                              while we're in UserInterface().  While executing,
                              this value is always maintained in SI reg */
   ushort   oRsCONT;       /* register set where we are to CONTinue */
   ushort   otxCONT;       /* text offset where we are to CONTinue.  Set by
                              UserInterface(), CantCONT().  Used by ExStCONT.
                              We can't continue if grs.otxCONT == UNDEFINED */
   ushort   oRsContTxtTbl; /* Identical to oRsCONT, except when oRsCONT is
                              for a DEF FN, this is the oRs of the module
                              containing the DEF FN.  It always identifies
                              the text table where containing next stmt to
                              be executed */
   bdl      bdlDirect;     /* Direct mode pcode buffer owner */
   char     flagsDir;      /* These flags get reset every time we begin
                              begin executing pcode, and when a runtime error
                              occurs.  They are defined below (FDIR_xxx) */
   } grsType; 

#define FDIR_cleared  0x01 /* TRUE when ClearWorld has been called.  Reset
                              at end of CLEAR statement.  It is strictly a
                              speed optimization */
#define FDIR_new      0x02  /* Set at start of NewStmt and reset at end of
                               NewStmt.  Speed optimization for Text Manager. */
/* bits for general grs flags */
#define FG_WatchActive  0x01  /* set if watch pcode is active */
#define FG_RetDir       0x02  /* 1 return address to direct-mode buffer
                               * exists on the stack.  Entry of direct-mode
                               * stmts when this is true causes FG_RetDirBad
                               * to be set.                                   */
#define FG_AllSsExecute 0x04H /* set if all text tables are in SS_EXECUTE */
#define FG_OtxInDir	0x08H /* set if dir mode stmt contains an oxt ref */

/* bits for mask passed to ForEach[CP]: */
#define FE_PcodeMrs     0x01  /* TRUE if mrs's containing pcode are to
                                 be visited */
#define FE_TextMrs      0x02  /* TRUE if FM_TEXT and FM_TEXTFILE mrs's
                                 are to be visited (i.e. command window's
                                 mrs, docuemnt files) */
#define FE_CallMrs      0x04  /* TRUE if pFunc is to be called for mrs's
                                 text table BEFORE it is called for prs's
                                 text tables */
#define FE_PcodePrs     0x08  /* TRUE if prs's with text tables (SUBs/
                                 FUNCTIONs) are to be visited */
#define FE_NoPcodePrs   0x10  /* TRUE if DEF FN and DECLARE prs's are
                                 to be visited */
#define FE_FarCall      0x20  /* TRUE if function to be called is FAR */
#define FE_SaveRs       0x40  /* TRUE if ForEach is to restore caller's
                                 oRsCur on exit */
#define FE_CallMrsAfter 0x80  /* TRUE if pFunc is to be called for mrs's
                                 text table AFTER it is called for prs's
                                 text tables. */



/**========================= Binary SAVE/LOAD Constants ========================
/* these three bit fields are OR'd together as inputs to Binary SAVE; the
   first two are also used in the header of a binary SAVEd file:              */
#define BINSAV_SingleModule       0x01
#define BINSAV_MultipleModule     0x02
#define BINSAV_fProtected         0x0100

/**========================= EXTERNAL VARIABLES ===============================

context.c includes this file after defining EXTERNAL as empty, causing these
variables to actually be defined.

============================================================================**/
EXTERNAL grsType  PLM grs;    /* global register set */
EXTERNAL mrs      PLM mrsCur; /* module register set for active module       */
EXTERNAL prs      PLM prsCur; /* procedure register set for active procedure */
EXTERNAL txd      PLM txdCur; /* current text table (from prs or mrs)        */
EXTERNAL ushort   PLM pGosubLast; /* Pointer to last stack GOSUB frame	     */
EXTERNAL ushort   PLM fNonQBI_Active; /* set non-zero whenever non-QBI code
					 is activated (non-0 ==> old BP)   */
EXTERNAL ushort   PLM bcurlevel_QBI;  /* value of b$curlevel for most recent
					 QBI frame when fNonQBI_Active != 0 */

#ifndef CONTEXT_NOFUNCS
VOID     FAR   InitContext(VOID);
ushort	FAR	MrsFind(ushort);
ushort	FAR	PrsFind(ushort);
VOID	 FAR   RsActivate(ushort);		/* EB_API */
VOID     NEAR  RsActivateCP(ushort);
ushort   FAR   MrsMake(ushort, ushort);
VOID     NEAR  MrsDeActivate(VOID);
VOID     FAR   MrsActivate(ushort);
boolean  FAR   MrsDiscard(VOID);
boolean  FAR   ForEachMrs(boolean (far *)());
ushort   NEAR  PrsRef(ushort, uchar, ushort);
ushort   FAR   PrsMake(ushort, char);
VOID     NEAR  PrsDeActivate(VOID);
VOID     FAR   PrsDeActivateFar(VOID);
VOID     NEAR  PrsActivateCP(ushort);
VOID     FAR   PrsActivate(ushort);
boolean  FAR   ForEachPrsInMrs(boolean (far *)());
ushort   FAR   NextPrsInMrs(VOID);
ushort   FAR   NextTextPrsInMrs(VOID);
ushort	 FAR   NextMrsFile_All(VOID);
ushort   FAR   NextMrsFile(VOID);
boolean  FAR   PrsDiscard(VOID);
VOID     FAR   PrsFree(VOID);
ushort   NEAR  FieldsOfPrs(ushort);
ushort   FAR   FieldsOfPrsFar(ushort);
ushort   NEAR  SetPrsField(ushort, ushort, ushort);
VOID     FAR   NewStmt(VOID);
VOID     FAR   RunInit(VOID);
VOID     FAR   ContReinit(VOID);
VOID     FAR   ContReinitStat(VOID);
boolean  FAR   ClearStmt(ushort, ushort);
VOID     FAR   CantCont(VOID);
VOID     NEAR  VarDealloc(VOID);
boolean  FAR   FreeAllUnrefdPrs(VOID);
VOID     FAR   AdjustITable(char *, ushort, uchar);
boolean  FAR   ForEach(uchar, boolean (far *)());
ushort	 FAR   AlphaBuildORs(void);	//[23]
ushort   FAR   oRsOfAlpha(ushort);
ushort   FAR   NextAlphaPrs(void);
VOID     FAR   AlphaORsFree(void);
boolean  FAR   FindORsFrame(void);
ushort FAR OTypeOfTypeCharFar(char);	//[22]



/**========================= Non-RELEASE Macros ===============================

Non-RELEASE and DEBUG macros, used with context.c

============================================================================**/

#define DbChkGrs()            {;}
#define DbChkMrsCur()         {;}
#define DbChkPrsCur()         {;}
#define DbChkoMrs(oMrs)       {;}
#define DbChkoPrs(oPrs)       {;}
#define DbOMrsCur()           {;}
#define DbOPrsCur()           {;}

#endif /* ifndef CONTEXT_NOFUNCS */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\debug.h ===
/* debug.h - included in each C module via interp.h							*/
/* NOTE: When making changes to this file, be sure to make equivalent	*/
/*			changes to file DEBUG.INC													*/

#undef DEBUG_H
#define DEBUG_H ON			/* remember that this file has been included */

#if !HEAP_H
#include "heap.h"
#endif

/* This function is in exdosfun.asm as part of the TIMER function.	*/
/* It returns a hundredths of a second clock as an unsigned long integer.*/
/* It is available in RELEASE versions to allow internal data collection.*/
unsigned long pascal Timer(void);


#define DbOb(bArg)							{;}
#define DbOHb(bArg)							{;}
#define DbOHbN(bArg)							{;}
#define DbON()									{;}
#define DbOsz(sz)								{;}
#define DbOszN(fsz)							{;}
#define DbOsd(psd)							{;}
#define DbOsdN(psd)							{;}
#define DbOHw(wArg)							{;}
#define DbOHwN(wArg)							{;}
#define DbOHd(dArg)							{;}
#define DbOHdN(dArg)							{;}
#define DbODw(wArg)							{;}
#define DbODwN(wArg)							{;}

#define DbHalt(fsz)							{;}
#define DbAssert(assertion)				{;}
#define DbAssertIf(fTestit,assertion)	{;}



#define STATICF(type) static type PLM NEAR
#define STATICV static

#define DbE(szName,dbglev)								{;}
#define DbEw(szName,dbglev,arg1)						{;}
#define DbEsz(szName,dbglev,arg1)					{;}
#define DbEd(szName,dbglev,arg1)						{;}
#define DbEww(szName,dbglev,arg1,arg2)				{;}
#define DbEszw(szName,dbglev,arg1,arg2)			{;}
#define DbEwsz(szName,dbglev,arg1,arg2)			{;}
#define DbEszsz(szName,dbglev,arg1,arg2)			{;}
#define DbEwww(szName,dbglev,arg1,arg2,arg3)		{;}
#define DbEszww(szName,dbglev,arg1,arg2,arg3)	{;}
#define DbX(szName,dbglev)								{;}
#define DbXw(szName,dbglev,arg1)						{;}
#define DbXsz(szName,dbglev,arg1)					{;}
#define DbXd(szName,dbglev,arg1)						{;}
							
/* perform x only if DEBUG is set */
#define DebugMacro(x)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\conint.inc ===
; File: CONINT.INC
; NOTE: When making changes to this file, be sure to make equivalent
;	changes to file CONINT.H
; NOTE: For comments, see file CONINT.H

CONINT_H = -1			;remember that this file has been included

	IncludeOnce	context	;require definitions from context.inc


;Structure initialization constants - - - for each of PRS, MRS, and GRS we
;	fill the entire struct with UNDEFINED, and then fill the first n bytes
;	with zeros
PRS_CB_ZERO_INIT	EQU	PRS_oVarHash
MRS_CB_ZERO_INIT	EQU	MRS_oMrsNext
GRS_CB_ZERO_INIT	EQU	GRS_oMrsMain


;**==================== Binary SAVE/LOAD Constants ========================

BLOCK_PROC		EQU	00h
BINSAV_1stBYTE		EQU	0FCh	;first byte of binary saved file


;**==================== Bit flags Constants ========================
	;bit flags used with conFlags in context.asm
	F_CON_StaticStructs	EQU	01H	;Set (TRUE) when mrsCur, prsCur
						;  and txdCur are to be used to
						;  access current context. If
						;  reset (FALSE), then these
						;  must be accessed out of the
						;  appropriate tables.
	F_CON_LeaveTMrsEmpty	EQU	02H	;normally, if MrsDiscard removes
						;  the last mrs from tMrs, it
						;  creates a new unnamed one; if
						;  this flag is TRUE, it just
						;  leaves the table empty
						;  an unreferenced empty prs
	F_CON_ResetStkSize	EQU	04H	;Set by NewStmt when not 
						;  CHAINing. Causes next BOS/BOL
						;  to reset the stack to its
						;  default size.
	F_CON_RunFile		EQU	08H	;Set by exStRunFile so that
						;  NewStmt will not show the
						;  debug screen
	F_CON_DontReplaceRs	EQU	10H	;Set when we don't want
						;  RsTableSearch to replace
						;  the found Prs/Mrs name with
						;  the given name (which perhaps
						;  has different case letters)

;**======================================================================**
;**==           External Interface to Context Mgr Component            ==**
;**======================================================================**

sBegin	DATA
ife	CONTEXT_ASM	;don't include in context.asm
	externB	conFlags
endif	;ife CONTEXT_ASM
ife	CONMISC_ASM	;don't include in conmisc.asm
	externB	fChaining
endif
sEnd	DATA

sBegin	CP

ife	CONMISC_ASM	;don't include these in conmisc.asm
	EXTRN ClearTheWorld:NEAR
endif
sEnd	CP
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\debug.inc ===
; File: DEBUG.INC
; NOTE: When making changes to this file, be sure to consider equivalent
;	changes to DEBUG.H

DEBUG_INC = ON

DbTimer	MACRO
	ENDM

DbMessTimer	MACRO	seg,mess
	LOCAL	szMess
	ENDM

;==============================================================================
;ClockOn, ClockOff macros
;
;These macros are for use with PROFILE.EXE. When the /n switch is given to
;PROFILE.EXE, it allows us to turn on and off the profiling clock, so we
;only profile those sections of code we're interested in.
;Rather than some complicated system, these macros are always present.
;The specific modules where we wish to turn on and off the clock must be
;re-assembled with the appropriate macros whenever we want to profile something.
;
;The clock is initially off, and will be turned off automatically after the
;profiled code terminates.  Redundant off or on directives will be ignored
;and are harmless.
;==============================================================================
ClockOn     macro
					;;in non-RELEASE case
	push	ax
	mov	ax, 1
	int	3
	pop	ax
endm

ClockOff    macro
					;;in non-RELEASE case
	push	ax
	xor	ax, ax
	int	3
	pop	ax
endm

include idmac.inc			;assertion macros shared with runtime
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\cmacros.inc ===
comment $
cmacros - assembly macros for interfacing to hhls
(C)Copyright Microsoft Corp. 1984-1987
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 3.xx.a - 02/26/87>
??_out <Copyright (C) Microsoft Corp. 1984-1987. All rights reserved.>
outif memS,0,<Small Model>
outif memM,0,<Medium model>
outif memL,0,<Large Model>
outif memC,0,<Compact Model>
outif memH,0,<Huge Model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
outif memS,0,<Small model>
else
??error <must have only 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
outif ?COW,0,<Character Windows support>
outif ?PLM,1,<PL/M calling convention>
outif ?NOATOMIC,0,<ATOMIC disabled>
ifndef ?NOSMASH 	    ;
?nosmash1=0		    ;
else			    ;
?nosmash1=1		    ;
??_out <! NOSMASH module>   ;
endif			    ;
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5,?nosmash1    ;
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
push x
endif
endm
endm
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
pop x
endif
endm
endm
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
ifdef ?&&x
n=n or ?&&x
endif
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
parmCP macro n
parmD <n>
endm
parmDP macro n
parmW <n>
endm
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
localCP macro n
localD <n>
endm
localDP macro n
localW <n>
endm
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
staticCP macro n,i,s
staticD n,<i>,<s>
endm
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
defCP macro n
defD <n>
endm
defDP macro n
defW <n>
endm
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
push s
push o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
push word ptr (n)
exitm
endif
ife ?t&n-2
push n
exitm
endif
ife ?t&n-4
push word ptr (n)[2]
push word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
push word ptr (n)[6]
push word ptr (n)[4]
push word ptr (n)[2]
push word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
push word ptr (n)
exitm
endif
endif
push n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
call n
if ((?cCall1 eq 0) and (?argl ne 0))
add sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ife ?NOATOMIC
ifidn <x>,<ATOMIC>
?nx=1
endif
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp
ife ?nx
ife ?COW
?ia=2
?pas = ?pas and (not ?ds)
endif
endif
endif
?adj=?adj+2
else
?wfp=0
endif
?pas = ?pas and (not (?sp+?cs+?ss))
if ?uf
?pas = ?pas and (not (?bp+?si+?di))
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
ife ?nosmash1					;
DbFarPrologue					;; non-release prologue chks
endif						;
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w
ife ?nd
mov ax,ds
nop
endif
ife ?nx
ife ?DOS5
inc bp
endif
push bp
ife ?COW
mov bp,sp
push ds
endif
else
if ?ff+???+?po+?rp
push bp
mov bp,sp
endif
endif
ife ?nd
mov ds,ax
endif
else
if ?ff+???+?po+?rp
push bp
mov bp,sp
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
mov ax,???
ife cc
call _chkstk
else
call chkstk
endif
endif
else
sub sp,???
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
call StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
if c and not ?nosmash1				;
DbFarEpilogue					;; non-release prologue chks
endif						;
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
db 0c3h
else
if w
ife ?nx
if (?TF eq 0) or (???+?rp)
lea sp,-2[bp]
endif
pop ds
pop bp
ife ?DOS5
dec bp
endif
else
if (?TF eq 0) or (???+?rp)
mov sp,bp
endif
if ???+?po+?rp
pop bp
endif
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
mov sp,bp
endif
pop bp
endif
endif
ife cc
ret
else
ret o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ <n>
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ <grp>
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sBeginC				;
.cref
ln&_sBeginC &macro				;
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
extrn n&_FARFRAME:near
call n&_FARFRAME
else
extrn n&_NEARFRAME:near
call n&_NEARFRAME
endif
db l shr 1
db p shr 1
&&endm
?cs2 <ln>,<n>
n segment
?segname equ <&n>				;
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBeginC					;
.cref
sBeginC macro ln				;; Rename sBegin as sBeginC
ln&_sBeginC					;
endm
;ife ?DF					;; Defined at first sBegin
;createSeg _TEXT,Code,word,public,CODE		;
;ife ?nodata1					;
;createSeg _DATA,Data,word,public,DATA,DGROUP	;
;defgrp DGROUP,Data				;
;endif						;
;if ?chkstk1					;
;ifndef ?CHKSTKPROC				;
;externp <chkstk>				;
;endif						;
;endif						;
;endif						;
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\executor.h ===
/* Executor.h - type definitions and data primarily for the executor */

#undef EXECUTOR_H       /* it will have been defined as 0 in switch.h */
#define EXECUTOR_H ON   /* to prevent duplicate #include's */

/*========================================================================
  Executor static data
  ======================================================================*/

/* Begin of Statement Flags                                             */
EXTERNAL ushort PLM BosFlags;   /* Begin of statement flags */

/* NOTE: FBOSDEBUG should have the highest value of the FBOS bits 	*/
/* NOTE: FBOSSTOP  should have the next highest value.					*/
/* NOTE: FBOSEVENT should have the next highest value. 					*/
/* NOTE: see more complete comments in executor.inc for the reasons 
			for these order dependancies											*/

#define FBOSRESETSTK 0x1    /* Set by the CLEAR support code. Causes the stack
			       to be reset at next BOS/BOL (both SP & BP).
			    */
#define FBOSEVENT    0x2    /* Set by event handlers. Tells bos to service event
			    */
#define FBOSSTOP     0x4    /* Set by runtime when user hits ctl-break.
			    */
#define FBOSDEBUG    0x8    /* Set by B$FERROR when a runtime error occurs in
                               a module for which no error handler exists.
			       B$FERROR moves the oTxt back to the last opBos
			       prior to where the error occured, sets this bit,
			       and dispatches Also set by user interface when
			       any breakpoints are set, any watch expressions
			       are active, or when program tracing is active.
			       Causes next bos to enter UserInterface()
			    */

/*
   Current frame pointer, only valid when in the user interface (i.e. after
   UserInterface is called and before it returns).
   Used to impliment PStep.
*/
EXTERNAL ushort PLM FrameCur;
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\context.inc ===
;*** 
;context.inc
;
;	Copyright <C> 1985, 1986, 1987 Microsoft Corporation
;
; NOTE: When making changes to this file, be sure to make equivalent
;       changes to file CONTEXT.H
; NOTE: For comments, see file CONTEXT.H
;
;
;*******************************************************************************
CONTEXT_INC = -1                ;remember that this file has been included
	IncludeOnce	heap	
	IncludeOnce	pointers
	IncludeOnce	sb	
;**======================================================================**
;**==           External Interface to Context Mgr Component            ==**
;**======================================================================**


;**==================== text descriptor (TXD_) ============================
;
;Definition of text table descriptor.  Both modules and procedures have
;text tables.  All text-offset (otx...) fields in this descriptor are
;maintained by the text manager during edit operations, and by the scanner
;during pcode expansion/contraction.
;For all linked lists through the pcode, (otx...Link), the link is always
;a text offset to a pcode's 1st operand, NOT to the 1st byte of the pcode.
;This speeds up traversal of the list.
;
;=======================================================================*

TXD			STRUC	;offset 	;offset
TXD_bdlText_cbLogical	DW 0	;00		;00
TXD_bdlText_seg 	DW 0	;02		;02
TXD_bdlText_dummy	DW 0	;04
TXD_bdlText_cPhysical	DW 0	;06		;04
TXD_otxLabLink		DW 0	;08		;06
TXD_otxDefTypeLink	DW 0	;0a		;08
TXD_otxTypeLink 	DW 0	;0c		;0a
TXD_otxReParseLink	DW 0	;0e		;0c
TXD_cLines		DW 0	;10		;0e
TXD_cLinesIncl		DW 0	;12		;10
TXD_lnCursor		DW 0	;14		;12
TXD_scanState		DB 0	;16		;14
TXD_flags		DB 0	;17		;15
TXD			ENDS	;18		;16

TXD_bdlText     EQU     TXD_bdlText_cbLogical
;Define place to keep address of compiled code
TXD_oCompiled   EQU     TXD_otxLabLink
TXD_segCompiled EQU     TXD_otxDefTypeLink
TXD_bdlText_status	equ	TXD_bdlText_seg 

FTX_mrs         EQU 01H ;TRUE if text table is mrs, not prs
FTX_asChg       EQU 02H ;TRUE if PreScanAsChg needs to be called
                        ; before we scan this text table again
;The following FTX_Tmp... flags are used temporarily within the scope of
;SaveDeclares().  If another function needs to make temporary use of a flag,
;it can use these bits as well, as long as it assumes they contain garbage
;on entry and exit.
;
FTX_TmpDecl     EQU 4   ;Used by SaveDeclares in text mgr.
FTX_TmpRef      EQU 8   ;Used by SaveDeclares in text mgr.



;**==================== Procedure Register Set (PRS) =======================
;The there is a procedure register set for each SUB, DEF and FUNCTION in the 
;program. 
;
;For SUB's and FUNCTION's, there is only one procedure per name, regardless
;of FUNCTION type or module of definition.
;There is at most one DEF FN per module per type per name.
;FUNCTIONs and SUBs are global to the program.  DEF FNs are local to a module.
;
;Prs's must exist whenever there is pcode (even if no variable tables
;exist), because pcode's contain references to entries.
;Prs's are used at runtime for procedure invocations for identifying
;the new module.  Prs's are built only at the request of the parser/
;user-interface.
;
;While a procedure is loaded into prsCur, its entry in the Rs table
;should not be referenced or updated.
;==========================================================================

;Flag constants used with the PRS_flags byte, below
FP_STATIC       EQU     80h
FP_CDECL        EQU     40h
FP_DEFINED      EQU     20h
FP_ENDPROC      EQU     10h
FP_DECLARED     EQU     08h
FP_DEFSCANNED	EQU	04H

; Flag constants used with the PRS_flags2 byte, below
; NOTE: only flags 08H - 80H are available, as flags2 is overlaid over oType
FP_RefDeleted 	EQU	80h			
FP_AUTO 	EQU	40h			
FP_ExeTree	EQU	20h			

PRS                     STRUC
;Begin of zero fill
PRS_cbFrameVars         DW 0    ;00	     
PRS_cbFrameTemp         DW 0    ;02	     
PRS_ogNam		DW 0	;04	;	     			
PRS_procType            DB 0    ;08	     
PRS_oType               DB 0    ;09	     
PRS_flags               DB 0    ;0a	     
PRS_cwParams            DB 0    ;0b	     
;Begin of UNDEFINED fill	
PRS_oVarHash            DW 0    ;0c	     
PRS_oMrs                DW 0    ;0e	     
PRS_oRsDef              DW 0    ;10	     
PRS_otxDef              DW 0    ;12	     
PRS_oPrsNext		DW 0	;14	;	     			
PRS_txd                 DB SIZE TXD DUP(0)   ;16
PRS			ENDS

PRS_flags2	EQU	PRS_oType	; share this byte - - - low nibble
					; is for oTyp, high nibble is flags
M_PT_OTYPE	EQU	07H		;[20] mask to allow access to PRS_oType

;enumerations for PRS_procType:
PT_SUB          EQU     1
PT_FUNCTION     EQU     2
PT_DEFFN        EQU     3
PT_NOT_PROC	EQU	4

; eb api constants


;**==================== Module Register Set (MRS) ============================
;The Module Register Set either directly contains or is the owner of all
;information about a particular module.
;
;The global Rs table contains both prs's and mrs's, each linked together.
;Entries are not compressed, due to the number of structures that have offsets
;into this table.
;
;While a module is loaded into mrsCur, its entry in the global Rs table
;should not be referenced or updated.
;============================================================================**

OGNAM_UNNAMED		EQU	0	; ogNam for an unnamed mrs
OGNAM_GMRS		EQU	1	; an invalid ogNam to be used as
					;  the ogNam of the global mrs
OGNAM_CLIPBOARD		EQU	2	; ogNam for clipboard mrs
OGNAM_IMMEDIATE		EQU	3	; ognam for Immediate window
OGNAM_PSEUDO_MAX	EQU	3	; max psuedo ogNam value

OMRS_GLOBAL		EQU	0	

;Flag constants used with the MRS_flags byte, below
FM_OptionBase1  EQU     01h
FM_VARNEW       EQU     02h
FM_asChg        EQU     04h
FM_TEMPORARY    EQU     08h
FM_AllSsRude    EQU     10h
FM_LinksOk 	EQU 	20H 		
FM_MustVisit	EQU	40H		
FM_Visited	EQU	80H		
;NOTE: all flags except FM_asChg get set to 0 by BinaryLoad().
;      When adding flags, make sure this is desired

;Flag constants used with the MRS_flags2 byte, below.  These are file related
FM2_Modified    EQU     01h
FM2_NewFile     EQU     02h
FM2_Include     EQU     04h
FM2_NoPcode     EQU     08h
FM2_File        EQU     10h
FM2_AsciiLoaded EQU     20h
FM2_ReInclude	EQU	40h
FM2_EntabSource EQU     80h
;NOTE: all flags except FM2_EntabSource get set to 0 by BinaryLoad().
;      When adding flags, make sure this is desired

;Flag constants used with the MRS_flags3 byte, below.
FM3_NotFound    EQU     01h
FM3_Translated	EQU	04h		
;NOTE: This flags are NOT saved by BinarySave/Load.

MRS                     STRUC
;Begin of zero fill
;------------------
MRS_cbFrameVars         DW 0
MRS_cbFrameTemp         DW 0
MRS_ogNam		DW 0
MRS_bdVar	DB SIZE BD DUP(0)			
MRS_flags		DB 0
MRS_flags2		DB 0
MRS_flags3		DB 0	
MRS_dummy1		DB 0	
;Begin of UNDEFINED fill
MRS_oMrsNext		DW 0
MRS_otxHandler		DW 0
MRS_bdlNam_cbLogical	DW 0
MRS_bdlNam_seg		DW 0
MRS_bdlNam_dummy	DW 0
MRS_bdlNam_cPhysical	DW 0
MRS_txd 		DB SIZE TXD DUP(0)

MRS_otxDefFnLink	DW 0
MRS_oPastLastVar	DW 0
MRS_data_otxFirst	DW 0
MRS_data_otxCur 	DW 0
MRS_data_oLineCur	DW 0
MRS			ENDS

MRS_bdlNam      EQU     MRS_bdlNam_cbLogical
MRS_bdlNam_status	equ	MRS_bdlNam_seg	

;**==================== Global Register Set (GRS) ========================
;The global register set owns heap entries which define the current context.
;
;Only one module table entry and procedure table entry may be active at any
;one time.  A module table entry MUST be active, and a procedure entry MAY
;be active. These tables are managed by swapping a new mrs into mrsCur or
;swapping a new procedure into prsCur.
;
;While a module or procedure is loaded into mrsCur or prsCur, its entry
;in the global Rs table should not be referenced or updated.
;
;=======================================================================**

GRSTYPE STRUC
;Begin of zero fill			;QB5		EB
GRS_fScan                       DB 0    ;00		00
GRS_fDirect			DB 0	;01		01
GRS_bdRs	DB SIZE BD DUP(0)				
GRS_bdtComBlk	DB SIZE BD DUP(0)				
GRS_flags			DB 0	;0e		0c
GRS_filler			DB 0	;1f		0d
;Begin of UNDEFINED fill		
GRS_oMrsMain			DW 0	;10		0e
GRS_oRsCur			DW 0	;12		10
GRS_pMrsCur			DW 0
GRS_pRsCur			DW 0
GRS_offsetTxdSeg		DW 0	;14		12
GRS_oMrsCur			DW 0	;16		14
GRS_oPrsCur			DW 0	;18		16
GRS_otxCur			DW 0	;1a		18
GRS_oRsCONT			DW 0	;1c		1a
GRS_otxCONT			DW 0	;1e		1c
GRS_oRsContTxtTbl		DW 0	;20		1e
GRS_bdlDirect_cbLogical 	DW 0	;22		20
GRS_bdlDirect_seg		DW 0	;24		22
GRS_bdlDirect_dummy		DW 0
GRS_bdlDirect_cPhysical 	DW 0	;26		24
GRS_flagsDir			DB 0	;28		2a
GRSTYPE ENDS

GRS_bdlDirect           EQU     GRS_bdlDirect_cbLogical
GRS_bdlDirect_status	equ	GRS_bdlDirect_seg	

;GRS_flags enumerations
FG_WatchActive          EQU     01H     ;set if watch pcode is active
FG_RetDir               EQU     02H     ;1 return address to direct-mode buffer
                                        ;exists on the stack.  Entry of direct-
                                        ;mode stmts when this is true causes
                                        ;FG_RetDirBad to be set.
FG_AllSsExecute         EQU     04H     ;set if all text tables are
                                        ;in SS_EXECUTE
FG_OtxInDir		EQU	08H	; Set if the mose recently scanned
					; direct mode statement contained
					; an otx reference.	If this flag
					; is set at the same time as
					; FG_RetDir, then any edit is a
					; CantCont.
;GRS_flagsDir enumerations
FDIR_cleared            EQU     01H
FDIR_new                EQU     02H

;bits for mask passed to ForEach[CP]:
;
FE_PcodeMrs     EQU 01h ;TRUE if mrs's containing pcode are to be visited
FE_TextMrs      EQU 02h ;TRUE if FM_TEXT and FM_TEXTFILE mrs's are to be
                        ; visited (i.e. command window's mrs, docuemnt files)
FE_CallMrs      EQU 04h ;TRUE if pFunc is to be called for mrs's text table
                        ; BEFORE it is called for prs's text tables.
FE_PcodePrs     EQU 08h ;TRUE if prs's with text tables (SUBs/FUNCTIONs)
                        ; are to be visited
FE_NoPcodePrs   EQU 10h ;TRUE if DEF FN and DECLARE prs's are to be visited
FE_FarCall      EQU 20h ;TRUE if function to be called is FAR
FE_SaveRs       EQU 40h ;TRUE if ForEach is to restore caller's oRsCur on exit
FE_CallMrsAfter EQU 80h ;TRUE if pFunc is to be called for mrs's text table
                        ; AFTER it is called for prs's text tables.

;***
;GETRS_SEG, RS_BASE, SETSEG_EQ_SS, [B]PTRRS
;
;Purpose:
;	Macros to allow the global Rs table to be a near or far table
;	for different products built off QB shared sources.
;	Added as revision [6].
;	GETRS_SEG:
;		Same as GETBDL_SEG, but optimized to fetch the segment of
;		this particular table. If the Rs table is near, does nothing.
;	RS_BASE:
;		Used to perform some primitive operation (add, sub, mov)
;		using the base pointer of the Rs table; if the Rs table is
;		far, does nothing (as the offset to start of table is always
;		zero in that case).
;			If the Rs table is far and FV_LMEM == TRUE, then this
;			macro must zero the arg if the operation is 'mov'.
;			(or else "RS_BASE mov,..." does nothing when it is
;			expected to get the Rs table base.)
;
;	SETSEG_EQ_SS:
;		Used to set a given seg address equal to SS, only in the
;		case where the global Rs table is far; does nothing if
;		the table is near.
;	[B]PTRRS:
;		Text macros, similar to [B]PTRTX and [B]PTRVAR, used to
;		provide an es seg override for versions with the Rs table far.
;**************************************************************************
GETRS_SEG   MACRO   reg,temp,opt		;
	ENDM					;

RS_BASE  MACRO	 op,arg,reg			;
	op	arg,grs.GRS_bdRs.BD_pb		;
	ENDM					;

SETSEG_EQ_SS MACRO  reg 			;
	ENDM					;

PTRRS	EQU word ptr				;
BPTRRS	EQU byte ptr				;




sBegin  DATA

;**======================================================================**
;**     External references to static context structures
;**
;** Since all of these are defined in context.c, we don't have to put
;** them under any switch
;**======================================================================**
        EXTRN   grs:byte        ;global register set
        EXTRN   mrsCur:byte     ;module resister set for the active module
        EXTRN   prsCur:byte     ;procedure resister set for the active proc
        EXTRN   txdCur:byte     ;current text table (from prs or mrs)

;**======================================================================**
;**     Fundamental global state variables
;**======================================================================**
        EXTRN   b$mainframe:word        ;initial value of BP after runtime
                                        ; inititalization. Only changes when
                                        ; the stack moves; used to reset the
                                        ; stack
        EXTRN   b$curframe:word ;always equal to BP, except in runtime
                                        ; support code or in U.I. code. BP is
                                        ; modified by runtime entry points and
                                        ; by non-BASIC procedures, so this is
                                        ; used to restore BP after runtime error
        EXTRN   b$pend:word             ;points to the last (bottom) word in
                                        ; the stack. Modified only by the
                                        ; runtime, on initialization & when the
                                        ; stack moves. Used by CLEAR to reset
                                        ; the stack.
        EXTRN   b$pendchk:word          ;Set to b$pend plus a fudge factor
                                        ; used to check to see if sufficient
                                        ; stack space remains at CALL time,
                                        ; GOSUB time, others that push a
                                        ; frame, and by U.I. recursive routines.
                                        ; Reset by the runtime when the stack
                                        ; moves. 
        EXTRN   fNonQBI_Active:word     ;Set TRUE whenever non-QBI code is
                                        ; active. Used to determine whether
                                        ; we can CONTinue, and for special
                                        ; code to blast stack back to last
                                        ; QBI frame when we STOP or ctl-Break
                                        ; with this flag set. 
                                        ; Note that when 'set' this flag serves
                                        ; double duty as it contains the value
					; of BP for the most recent QBI frame.
        EXTRN   bcurlevel_QBI:word      ;Only meaningful when fNonQBI_Active
                                        ; is non-zero. Contains the value of
                                        ; b$curlevel which must be restored
                                        ; whenever we blast the stack back to
                                        ; the most recent QBI frame.
        EXTRN   b$cNonQBIFrames:word    ;Set 0 by [re]init code. Incremented
                                        ; whenever non-QBI code is made active,
                                        ; decremented control is returned from
                                        ; such code to QBI. Used because we
                                        ; currently don't allow the user to
                                        ; Edit and then Continue when non-QBI
					; frames are on the stack.
        EXTRN   b$curlevel:word ;A count of procedure call invocations
                                        ; used to determine which string
                                        ; temps should be released when a
                                        ; runtime error occurs.  Reset by
                                        ; runtime for CLEAR/NEW/runtime
                                        ; initialization.
        EXTRN   pGosubLast:word         ;Pointer to last GOSUB frame on the
                                        ; stack. 0 if no GOSUB's are active.
                                        ; Note that when non-zero, should
                                        ; always be the same as SP at BOS.
                                        ; Reset to 0 whenever the stack is
                                        ; reset; modified by GOSUB & RETURN
                                        ; executors.

ife     CONTEXT_ASM
        EXTRN   oRsDupErr:word          ;Error indicator set by PrsMake and
                                        ; MrsMake for LoadFile
endif   ;CONTEXT_ASM


sEnd    DATA

;**======================================================================**
;**==           External Interface to Context Mgr Component            ==**
;**======================================================================**

ife     CONTEXT_ASM     ;don't include these in context.asm
sBegin  RARE
        EXTRN InitContext:NEAR		
sEnd    RARE

sBegin  CODE
        EXTRN RsActivateCODE:NEAR
sEnd    CODE
endif   ;ife CONTEXT_ASM

sBegin  CP

ife     CONTEXT_ASM     ;don't include these in context.asm
        EXTRN MrsMake:FAR
        EXTRN MrsDeActivate:NEAR
        EXTRN RsActivate:FAR
        EXTRN RsActivateCP:NEAR
        EXTRN MrsActivate:FAR
        EXTRN MrsActivateCP:NEAR
        EXTRN MrsDiscard:FAR
        EXTRN MrsFind:FAR
        EXTRN PrsFind:FAR
        EXTRN PrsRef:NEAR
        EXTRN PrsMake:FAR
	EXTRN PrsDefine:FAR		
        EXTRN PrsDeActivate:NEAR
        EXTRN PrsDeActivateFar:FAR
        EXTRN PrsActivate:FAR
        EXTRN PrsActivateCP:NEAR
        EXTRN NextPrsInMrs:FAR
        EXTRN NextTextPrsInMrs:FAR
        EXTRN GetNextPrsInMrs:NEAR
	EXTRN GetNextPrs:NEAR		
        EXTRN NextMrsFile:FAR
	EXTRN NextMrsFile_All:FAR	
        EXTRN PrsDiscard:FAR
        EXTRN PrsDiscard1:NEAR
        EXTRN PrsFree:FAR
        EXTRN FreeAllUnrefdPrs:FAR
        EXTRN FieldsOfPrs:NEAR
        EXTRN FieldsOfPrsFar:FAR
        EXTRN SetPrsField:NEAR
        EXTRN OMrsORs:NEAR
        EXTRN PPrsOPrs:NEAR
        EXTRN ForEach:FAR
        EXTRN ForEachCP:NEAR
        EXTRN ForEachTxtTbl:NEAR
        EXTRN ForEachTxtTblInMrs:NEAR
        EXTRN ForEachPrsInPlaceCP:NEAR
        EXTRN ForEachPrsInPlaceCPSav:NEAR
	EXTRN OTypeOfTypeCharFar:FAR	
        EXTRN ValidORs:NEAR
endif   ;ife CONTEXT_ASM

ife     CONMISC_ASM     ;don't include these in conmisc.asm
        EXTRN NewStmt:FAR
        EXTRN RunInit:FAR
        EXTRN ContReinit:FAR
        EXTRN ContReinitStat:FAR
        EXTRN ClearStmt:FAR
        EXTRN CantCont:FAR
        EXTRN VarDealloc:NEAR
        EXTRN AdjustITable:FAR
        EXTRN ResetData:NEAR
        EXTRN NextQBI_Frame:FAR
	EXTRN ActiveORs_Frame:FAR
	EXTRN FindORsFrame:NEAR
endif

ife     RSALPHA_ASM
	EXTRN AlphaBuildORs:FAR		
        EXTRN ORsOfAlpha:FAR
        EXTRN NextAlphaPrs:FAR
        EXTRN AlphaORsFree:FAR
endif   ;RSALPHA_ASM



sEnd    CP

sBegin	SCAN			
ife	CONTEXT_ASM		; don't include these in context.asm
	EXTRN PPrsOPrsSCAN:NEAR 
endif				; ife CONTEXT_ASM

ife	CONMISC_ASM		; don't include these in conmisc.asm
	EXTRN FCanCont:NEAR	
endif				; ife CONMISC_ASM

sEnd	SCAN			

;**======================================================================**
;**==           Non-RELEASE and DEBUG routines, in condebug.c          ==**
;**======================================================================**
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\fdb.inc ===
;***
; fdb.inc - 31-Jul-87
;***
	.XLIST
;***
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	This include file contains the definition of the BASIC File Data Block.
;
;	NOTE: This is a SHARED INCLUDE FILE, used by both the RUNTIME and
;	NOTE: the interpreter projects.  Any changes made to one should
;	NOTE: be carried over (COPIED) to the other!!!
;
;
;******************************************************************************

FDB_INC = -1			;remember that this file has been included


FILE_DATA_BLOCK	STRUC

FD_MODE    	DB	0	;file mode of open
FD_HANDLE   	DW	0	;file handle
FD_DEVICE  	DB	0	;device number (0 for disks)
FD_WIDTH   	DB	0	;file width
FD_FLAGS   	DB	0	;miscellaneous bit flags (defined below)

; Storage for the the following fields, as well as for a buffer, is only
; present for disk files, PIPE:, COMn:, and XENIX LPRINT.

FD_VRECL   	DW	0	;record length/buffer size
FD_FSIZ_LO   	DW	0	;low word of file size (char dev only)
FD_FSIZ_HI   	DW	0	;high word of file size (char dev only)
FD_LOGREC  	DW	0	;current logical record number
FD_HIGHLR  	DW	0	;to be used for 32-bit record numbers
FD_BUFCNT	DW	0	;# of read/unwritten bytes in seq buffer
				;  (offset of next char in buffer)
FD_OUTPS  	DB	0	;output position for tab expansion
FD_BUFFER   	DB	1 DUP(0) ;buffer for random and sequential access.
				;complete pathname for disk files is stored
				;after the buffer.
FILE_DATA_BLOCK ENDS

;	FDB-related constants

FDB_SIZE    =	FD_VRECL	; size of basic FDB, without buffer(s) or
				; extra fields.
FD_INBUFCNT  =	FD_LOGREC	;# of bytes in the sequential input buffer

;
;FileDB used for transparent reference to FDB structure
;
FileDB	EQU	[SI]		

;***
;FDB_PTR - macro to create an FDB pointer in registers
;
;Purpose:
;	Rewritten with [3].
;	This macro allows us to create a either a WORD or DWORD pointer
;	for FDB's depending on the FV_FARFDB switch.
;Entry:
;	seg  -	seg register to receive FDB segment address
;	reg  -	index register to receive actual FDB offset from handle/ptr
;		in srce; if not present, register is not loaded
;	srce -	source of handle/ptr for FDB
;		if not present, register is not loaded
;
;	NOTE:  The equate for FileDB above assumes ES:SI for seg:reg!
;
;Exit:
;	seg:reg or reg contains the physical FDB pointer.
;Preserves:
;	All.
;
;**************************************************************************
FDB_PTR MACRO	seg,reg,srce
ifnb	<reg>
	.errb <srce>			;reg specified without srce
  ifdifi <reg>,<srce>
	mov	reg,srce		;;load reg from ptr/handle in srce
  endif
else
	.errnb <srce>			;;srce specified without reg
endif
	ENDM

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\executor.inc ===
;Executor.inc
EXECUTOR_INC	= ON

;===========================================================================
;Executor static data
;
;===========================================================================


;===========================================================================
;Begin of Statement flags

sBegin	DATA

externW BosFlags	;Begin of Statement Flags

; Current frame pointer, only valid when in the user interface (i.e. after
; UserInterface() is called and before it returns).
; Used to impliment PStep.

externW FrameCur

ife	EXPRINT_ASM
externB executorFlags	;flags that get reset whenever a runtime error occurs, 
			;i.e., flags whose meaning is only valid within a 
			;single statement
endif	;EXPRINT_ASM

	ife	EXARRAY_ASM

	    extrn   DimAtScanType:byte	;Type of Dim initiated by scanner

	endif				;EXARRAY_ASM

sEnd	DATA


; NOTE: FBOSDEBUG should have the highest value of all FBOS bits. This means
;	that this bit is the LAST one to be tested (lowest priority of 
;	BOS exception handling).
; NOTE: FBOSSTOP should have the next highest value. This is so that if a user
;	has an event handler for the Ctl-Break key, it will take precedence
;	over the normal 'stop the program' behavior of Ctl-Break.
; NOTE: FBOSEVENT should have the next highest value. This is so a lot of 
;	events stacked up won't prevent other BOS items from occuring.
;	It's higher priority than FBOSDEBUG because we don't want to
;	allow user to trace into event handlers (he can set a breakpoint).
;	A useful analogy for this is interrupt handlers are not traced into
;	in symdeb.

FBOSRESETSTK	EQU 1h	;Set by the CLEAR support code; causes the stack to
			; be reset (both SP & BP) at next BOS/BOL
FBOSEVENT	EQU 2h	;Set by event handlers.  Tells bos to service event
FBOSSTOP	EQU 4h	;Set by runtime callback when user hits ctl-break
FBOSDEBUG	EQU 8h	;Set by B$FERROR when a runtime error occurs in a
			; module for which no error handler exists. B$FERROR
			; moves the oTxt back to the last opBos prior to
			; where the error occured, sets this bit, and dispatches
			; Also set by user interface when any breakpoints
			; are set, any watch expressions are active, or
			; when program tracing is active.  Causes next bos
			; to enter UserInterface()

	;The following mnemonic constants are used for DimAtScanType

SSDIM_EXECUTE	equ	0		;Normal execution time Dim
SSDIM_STATIC	equ	1		;Dim of $Static array

SSDIM_COMMON	equ	2		;Dim of Common $Static array




	;Bit flags used in executorFlags

F_EXEC_ItemPrinted	EQU 1	;TRUE if we've printed something already
F_EXEC_Write		EQU 2	;TRUE if we've seen exStWrite but haven't 
				;actually printed anything yet
;===========================================================================
;Executor entry points
;===========================================================================
ife	CONTEXT_ASM
extrn	EnStaticStructs:far
extrn	DisStaticStructs:far
endif			;CONTEXT_ASM
ife	EXARYUTL_ASM
extrn	oVarToPAd:near
endif			;EXARYUTL_ASM
ife	EXMATHOP_ASM
extrn	CompareI4:near
endif			;EXMATHOP_ASM
ife	EXCONTXT_ASM
extrn	StopGrsContext:near
extrn	StartGrsContext:far
endif			;EXCONTXT_ASM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\extort.inc ===
;***
; extort.inc
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Contains macros for defining post bytes for runtime call dispatch
;	mechanism.
;
;	This include file:
;	- includes rtmint.inc from the runtime project to define postbytes
;	  for each runtime entry point
;	- defines the CALLRT macro for use in dispatching to these entry
;	  points via extort.asm.
;
if	EXOS_ASM
if1
	%OUT	*RT post byte constants *
endif
endif

;	Create entry in table and define as external.

%PWORD	= 0		;Initial post byte value.

if	EXOS_ASM
RTMENT_OUT MACRO	entryname,lw,hg
if1
	%OUT	* P&entryname,lw,hg
endif
	ENDM
endif

RTMENT	MACRO entryname,entryseg
if	EXOS_ASM
	RTMENT_OUT	entryname,%(LOW %PWORD),%(HIGH %PWORD)
endif

P&entryname = %PWORD
%PWORD	= %PWORD + 1
IFE	LOW %PWORD
%PWORD	= %PWORD + 255
ENDIF	;;IFE
	ENDM

;Now define the post byte constants.

	include rtmint.inc

;********************************************************************
;CALLRT macro
;	Aid to using the post byte mechanism for calling the runtime
;	in a space optimized way.
;
;	rtnam  is the name of the runtime routine to be called
;********************************************************************

EXTRN	ExToRt:near		;Call RT, return
EXTRN	ExToRtMov:near		;Call RT, return - - heap movement expected
				; (but ES & DI not updated). In RELEASE case,
				; this acts just like ExToRt.
EXTRN	ExToRtDisp:near 	;Call RT, dispatch
EXTRN	ExToRtByteDisp:near 	;Call RT, dispatch - jmp'd to w/postbyte in ax
EXTRN	ExToRtDispMovAx:near	;Call RT, update di/es, push ax, dispatch
EXTRN	ExToRtDispMov:near	;Call RT, update di/es, dispatch
EXTRN	ExToRtDispAx:near	;Call RT, push ax, dispatch
EXTRN	ExToRtDispDxAx:near	;Call RT, push dx:ax, dispatch
EXTRN	ExToRtDispMovDxAx:near	;Call RT, update di/es, push dx:ax, dispatch
EXTRN	ExToRtDispR4:near	;Call RT, push R4 pointed to by AX, dispatch
EXTRN	ExToRtDispR8:near	;Call RT, push R8 pointed to by AX, dispatch
EXTRN	ExToRtDispMovR8:near	;Call RT, push R8 pointed to by AX, dispatch
EXTRN	ExToRtCall:near 	;Call RT, CALL w/ reg & error protection, ax = postbyte





CALLRT	MACRO	rtnam,rttyp
	call	ExToRt&rttyp
	db	LOW P&rtnam
IF	(P&rtnam GE 00FFH)
	db	HIGH P&rtnam
ENDIF
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\filename.inc ===
;filename.inc - This file defines all the _ASM switch names.
;it is ONLY included by switch.inc.  No make file contains dependencies on
;filename.inc, because any change that would affect one of these switch names
;will change a file that the makefile will re-assemble.  These switch names
;are in filename.inc (and not switch.inc) so that unnecessary changes won't
;cause all files to be re-assembled & so that switch.inc won't be overloaded
;with a lot of switch names (which contain little value).
;

;These switches are used to selectively switch out EXTRN's from include files.
;For example, nammgr.asm would want to switch out the EXTRN's in names.inc that
;are defined in nammgr.asm.  The EXTRN's are grouped in the .inc files so that
;the routines can easily be changed from FAR to NEAR without having to check
;out and edit all the files that reference them.  This also allows modules to 
;call routines without having to put EXTRNS in the source file. 
ifndef	BINSAV_ASM
	BINSAV_ASM = OFF
endif
ifndef	BDDEBUG_ASM
	BDDEBUG_ASM = OFF
endif
ifndef	BDMGR_ASM
	BDMGR_ASM = OFF
endif
ifndef	CMDEQV_ASM
	CMDEQV_ASM = OFF
endif
ifndef	CONMISC_ASM
	CONMISC_ASM = OFF
endif
ifndef	CONTEXT_ASM
	CONTEXT_ASM = OFF
endif
ifndef	EXAID_ASM
	EXAID_ASM = OFF
endif
ifndef	EXARRAY_ASM
	EXARRAY_ASM = OFF
endif
ifndef	EXARYUTL_ASM
	EXARYUTL_ASM = OFF
endif
ifndef	EXMATHOP_ASM
	EXMATHOP_ASM = OFF
endif
ifndef	EXCONTXT_ASM
	EXCONTXT_ASM = OFF
endif
ifndef	EXCONV_ASM
	EXCONV_ASM = OFF
endif
ifndef	EXDEBUG_ASM
	EXDEBUG_ASM = OFF
endif
ifndef	EXEVENT_ASM
	EXEVENT_ASM = OFF
endif
ifndef	EXFNMISC_ASM
	EXFNMISC_ASM = OFF
endif
ifndef	EXFOR_ASM
	EXFOR_ASM = OFF
endif
ifndef	EXGOTO_ASM
	EXGOTO_ASM = OFF
endif
ifndef	EXGRAPH_ASM
	EXGRAPH_ASM = OFF
endif
ifndef	EXIDSTUB_ASM
	EXIDSTUB_ASM = OFF
endif
ifndef	EXID_ASM
	EXID_ASM = OFF
endif
ifndef	EXIF_ASM
	EXIF_ASM = OFF
endif
ifndef	EXIO_ASM
	EXIO_ASM = OFF
endif
ifndef	EXLIT_ASM
	EXLIT_ASM = OFF
endif
ifndef	EXMATHOP_ASM
	EXMATHOP_ASM = OFF
endif
ifndef	EXMISC_ASM
	EXMISC_ASM = OFF
endif
ifndef	EXOS_ASM
	EXOS_ASM = OFF
endif
ifndef	EXPRINT_ASM
	EXPRINT_ASM = OFF
endif
ifndef	EXPROC_ASM
	EXPROC_ASM = OFF
endif
ifndef	EXREC_ASM
	EXREC_ASM = OFF
endif
ifndef	EXSTMISC_ASM
	EXSTMISC_ASM = OFF
endif
ifndef	EXSTRING_ASM
	EXSTRING_ASM = OFF
endif
ifndef	EXSTSTUB_ASM
	EXSTSTUB_ASM = OFF
endif
ifndef	EXSTUB1_ASM
	EXSTUB1_ASM = OFF
endif
ifndef	EXTORT_ASM
	EXTORT_ASM = OFF
endif
ifndef	EXUIDEB_ASM
	EXUIDEB_ASM = OFF
endif
ifndef	HENGINE_ASM
	HENGINE_ASM = OFF
endif
; only needed for EB
ifndef	INIT_ASM 
	INIT_ASM = OFF
endif
; not needed for EB
ifndef	INITTERM_ASM 
	INITTERM_ASM = OFF
endif
ifndef	LSID_ASM 
	LSID_ASM = OFF
endif
ifndef	LSOPTAB_ASM 
	LSOPTAB_ASM = OFF
endif
ifndef	LSMAIN_ASM 
	LSMAIN_ASM = OFF
endif
ifndef	LSRULES_ASM 
	LSRULES_ASM = OFF
endif
ifndef	LSSTEP2_ASM 
	LSSTEP2_ASM = OFF
endif
ifndef	LSUTIL_ASM 
	LSUTIL_ASM = OFF
endif
ifndef	MEMEMUL_ASM
	MEMEMUL_ASM = OFF
endif
ifndef	NAMDEBUG_ASM
	NAMDEBUG_ASM = OFF
endif
ifndef	NAMMGR_ASM
	NAMMGR_ASM = OFF
endif
ifndef	OPNAMATR_ASM
	OPNAMATR_ASM = OFF
endif
ifndef	OPNAMES_ASM
	OPNAMES_ASM = OFF
endif
ifndef	OPTABLE_ASM
	OPTABLE_ASM = OFF
endif
ifndef	PRSCTL_ASM
	PRSCTL_ASM = OFF
endif
ifndef	PRSEXP_ASM
	PRSEXP_ASM = OFF
endif
ifndef	PRSCG_ASM
	PRSCG_ASM = OFF
endif
ifndef	PRSID_ASM
	PRSID_ASM = OFF
endif
ifndef	PRSLEX_ASM
	PRSLEX_ASM = OFF
endif
ifndef	PRSMAIN_ASM
	PRSMAIN_ASM = OFF
endif
ifndef	PRSNT_ASM
	PRSNT_ASM = OFF
endif
ifndef	PRSNT1_ASM
	PRSNT1_ASM = OFF
endif
ifndef	PRSRWT_ASM
	PRSRWT_ASM = OFF
endif
ifndef	PRSSTMT_ASM
	PRSSTMT_ASM = OFF
endif
ifndef	PRSSTATE_ASM
	PRSSTATE_ASM = OFF
endif
ifndef	PRSUTIL_ASM
	PRSUTIL_ASM = OFF
endif
ifndef	QBLIST_ASM
	QBLIST_ASM = OFF
endif
ifndef	QBIMSGS_ASM
	QBIMSGS_ASM = OFF
endif
ifndef	RSALPHA_ASM
	RSALPHA_ASM = OFF
endif
ifndef	RTERROR_ASM
	RTERROR_ASM = OFF
endif
ifndef	RTTEMP_ASM
	RTTEMP_ASM = OFF
endif
ifndef	SSOPTAB_ASM
	SSOPTAB_ASM = OFF
endif
ifndef	SSDECLARE_ASM
	SSDECLARE_ASM = OFF
endif
ifndef	SSDESCAN_ASM
	SSDESCAN_ASM = OFF
endif
ifndef	SSBINFUN_ASM
	SSBINFUN_ASM = OFF
endif
ifndef	SSBOS_ASM
	SSBOS_ASM = OFF
endif
ifndef	SSDATA_ASM
	SSDATA_ASM = OFF
endif
ifndef	SSDECLARE_ASM
	SSDECLARE_ASM = OFF
endif
ifndef	SSAID_ASM
	SSAID_ASM = OFF
endif
ifndef	SSID_ASM
	SSID_ASM = OFF
endif
ifndef	SSIF_ASM
	SSIF_ASM = OFF
endif
ifndef	SSLIT_ASM
	SSLIT_ASM = OFF
endif
ifndef	SSMISC_ASM
	SSMISC_ASM = OFF
endif
ifndef	SSMOPEXE_ASM
	SSMOPEXE_ASM = OFF
endif
ifndef	SSOPERAT_ASM
	SSOPERAT_ASM = OFF
endif
ifndef	SSPROC_ASM
	SSPROC_ASM = OFF
endif
ifndef	SSREC_ASM
	SSREC_ASM = OFF
endif
ifndef	SSREFARG_ASM
	SSREFARG_ASM = OFF
endif
ifndef	SSRUDE_ASM
	SSRUDE_ASM = OFF
endif
ifndef	SSRULES_ASM
	SSRULES_ASM = OFF
endif
ifndef	SSSCAN_ASM
	SSSCAN_ASM = OFF
endif
ifndef	SSTXUTIL_ASM
	SSTXUTIL_ASM = OFF
endif
ifndef	TXTDATA_ASM
	TXTDATA_ASM = OFF
endif
ifndef	TXTDEL_ASM
	TXTDEL_ASM = OFF
endif
ifndef	TXTDEB_ASM
	TXTDEB_ASM = OFF
endif
ifndef	TXTDIR_ASM
	TXTDIR_ASM = OFF
endif
ifndef	TXTFIND_ASM
	TXTFIND_ASM = OFF
endif
ifndef	TXTLOAD_ASM
	TXTLOAD_ASM = OFF
endif
ifndef	TXTMGR_ASM
	TXTMGR_ASM = OFF
endif
ifndef	TXTMOVE_ASM
	TXTMOVE_ASM = OFF
endif
ifndef	TXTSAVE_ASM
	TXTSAVE_ASM = OFF
endif
ifndef	TXTTHR_ASM
	TXTTHR_ASM = OFF
endif
ifndef	TXTUTIL_ASM
	TXTUTIL_ASM = OFF
endif
ifndef	TYPMGR_ASM
	TYPMGR_ASM = OFF
endif
ifndef	UIDEBUG_ASM
	UIDEBUG_ASM = OFF
endif
ifndef	UIFILEIO_ASM
	UIFILEIO_ASM = OFF
endif
ifndef	UIMAIN_ASM
	UIMAIN_ASM = OFF
endif
ifndef	UIMEMORY_ASM
	UIMEMORY_ASM = OFF
endif
ifndef	UIMISC_ASM
	UIMISC_ASM = OFF
endif
ifndef	UINHELP_ASM
	UINHELP_ASM = OFF
endif
ifndef	UIRS_ASM
	UIRS_ASM = OFF
endif
ifndef	UIRSRC_ASM
	UIRSRC_ASM = OFF
endif
ifndef	UIUTIL_ASM
	UIUTIL_ASM = OFF
endif
ifndef	UIVARHLP_ASM
	UIVARHLP_ASM = OFF
endif
ifndef	UIWIND_ASM
	UIWIND_ASM = OFF
endif
ifndef	UTIL_ASM
	UTIL_ASM = OFF
endif
ifndef	VARMGR_ASM
	VARMGR_ASM = OFF
endif
ifndef	VARUTIL_ASM
	VARUTIL_ASM = OFF
endif

ifndef	UIEDIT_ASM
	UIEDIT_ASM = OFF
endif

ifndef	UIWORD_ASM
	UIWORD_ASM = OFF
endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\exint.inc ===
;exint.inc - executor internal declarations

;===================================================================

EXINT_INC = -1

;Constants

LOWUND	EQU LOW UNDEFINED

;The following are masks that identify the exponent bits in the exponent word.
MATH_R4SignMask EQU 8000h
MATH_R8SignMask EQU 8000h
MATH_R4ExpMask	EQU 3f80h
MATH_R8ExpMask	EQU 3ff0h

;The following are the high words of IEEE reals 0 through 10.
LitR81HighWord	EQU 3ff0h
LitR82HighWord	EQU 4000h
LitR83HighWord	EQU 4008h
LitR84HighWord	EQU 4010h
LitR85HighWord	EQU 4014h
LitR86HighWord	EQU 4018h
LitR87HighWord	EQU 401ch
LitR88HighWord	EQU 4020h
LitR89HighWord	EQU 4022h
LitR810HighWord EQU 4024h

LitR40HighWord	EQU    0h
LitR41HighWord	EQU 3f80h
LitR42HighWord	EQU 4000h
LitR43HighWord	EQU 4040h
LitR44HighWord	EQU 4080h
LitR45HighWord	EQU 40A0h
LitR46HighWord	EQU 40C0h
LitR47HighWord	EQU 40E0h
LitR48HighWord	EQU 4100h
LitR49HighWord	EQU 4110h
LitR410HighWord EQU 4120h

;===================================================================
;Math library entrypoints


extrn	B$RMI4:FAR
extrn	B$MUI4:FAR
extrn	B$DVI4:FAR
extrn	B$SCAT:FAR
extrn	B$SCMP:FAR
extrn	B$FLEN:FAR
extrn	B$ISCMPNoRel:FAR


;======================================================================
;Math related utilities
;
ife	EXMATHOP_ASM
extrn	exMathErrOVF:near
extrn	exMathErrDV0:near
endif			;EXMATHOP_ASM

;===================================================================
;Common runtime entrypoints

ife	EXFOR_ASM
sBegin	DATA
extrn	Stat:word
sEnd	DATA
endif

ife	EXARYUTL_ASM
extrn	ResolveArray:near
endif

ife	EXREC_ASM
extrn	MoveRec:near
endif

ife	EXTORT_ASM
externNP	DispMov
externNP	DispMovAx
externNP	DispMovDxAx
externNP	Disp
externNP	DispAx
externNP	DispDxAx
externNP	GetEsDi
endif	;ife EXTORT_ASM


;***********************************************************************
;Equates/Macros to handle different versions
;
ExToRtDispMovSd	equ	<ExToRtDispMovAx>


pVarBx		equ	bx+di
pFrame		equ	bx
FrameReg	equ	bx

GetpFrame	MACRO
	mov	bx,[bx+di]		;;Get oBP
	add	bx,bp
	ENDM

assumes DS, DATA



RestorePcode MACRO
	call	GetEsDi
	ENDM

RestorePcodeVar MACRO
	call	GetEsDi
	ENDM

RestoreVar MACRO
	GETSEG	ds,[grs.GRS_SbVar],,<SIZE,LOAD>
	ENDM


;===================================================================
;Executor Macros
;

	;LODSWTX loads a word from the text table

LODSWTX equ	<lods word ptr es:[si]>

PTRTX	equ	<word ptr es:>


;===================================================================
;MakeExe makes an executor entry point.


MakeExe MACRO	exeName,opName,Type
ifnb	<Type>				;; ET_ type is present
	dw	&opName+&Type*(OPCODE_MASK+1)
else
	dw	&opName 		;;Opcode for descan/list
endif

	public	&exeName
&exeName:				;;Executor entry definition

	ENDM


	;SameExe
	;Equates a new executor name to an existing executor

SameExe	MACRO	New,Old
New	=	Old
	public	New
	ENDM

;SkipExHeader
;
;Purpose:
;   skip over an executor header.
;
;NOTE:
;   this skip must be the same size as the ex header.

SkipExHeader	equ	<db 3dh>    ;Eat the next word as part of cmp ax,data


;DispMac - dispatch to the next pcode
;
;Purpose:
;   Executor dispatch definition
;   Nonrelease versions will dispatch through a central dispatcher,
;   making debugging slightly easier.
;   Release versions will dispatch directly from the end of each executor.
;	LQB version uses central dispatcher to slow it down a bit.


DispMac equ	<jmp Dispatch>



OTX_OTXEXIT equ 0	;offset in procedure pcode table to where an oTx
			;is stored (by the execute scanner). This oTx is to
			;the start of the pcode to exit the procedure


sBegin	CODE
ife	EXMISC_ASM
externNP	Dispatch
endif			;ife EXMISC_ASM
ife	EXPROC_ASM
externNP	SetSP
endif			;ife EXPROC_ASM
sEnd	CODE

;
;======================================================================
;
; Macro fpoptwo simply pops two elements of the numeric stack.  It turns out
; that the best expansion of this is different in Altmath then in emulator
; math.
; (Added by GJ)
fpoptwo MACRO
	fcompp			;; pop two things of the stack
	ENDM	; fpoptwo
;
;======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\heap.h ===
/*** 
*heap.h - Defines which apply to the QBI Heap Manager
*
*  Copyright <C> 1986, 1987, 1988 Microsoft Corporation
*
*******************************************************************************/
/* NOTE: When making changes to this file, be sure to make equivalent   */
/*       changes to file HEAP.INC                                       */

#undef HEAP_H
#define HEAP_H ON          /* to prevent duplicate #include's */

/**==================== bd ==========================================

buffer descriptor structure.
   Notice that this is a superset of a string-descriptor
   structure, which means that some functions which expect
   string descriptors can take buffer descriptors as input.
Examples of  (bd) structures  include the  prs table, mrs
table and value tables.

=======================================================================**/

typedef struct bd {
   ushort cbLogical;    /* logical size of content part of
                           heap entry.  This is the size as requested by
                           the last call to BdAlloc or BdRealloc.  There
                           may be additional padding space at the end. */

   char *pb;            /* points to 1st byte of content part
                           of heap entry.  This pointer is updated when
                           heap entry is moved. */
   ushort cbPhysical;   /* actual size of heap entry, including empty space
                           at the end.  Always >= cbLogical */

   } bd;


#define GETSEG(seg)	seg	/* [6] */


/**==================== bdp ==========================================

buffer descriptor with pointer structure
Notice that this is a superset of a (bd) structure,
which means that some functions which expect (bd)'s as
input can take (bdp)'s as input.
Examples of (bdp) structures include  the buffer  used to pass the parser a
source line and the  buffer the parser returns pcode in.

=======================================================================**/

typedef struct bdp {
   ushort cbLogical;    /* logical size of content part of
                           heap entry.  This is the size as requested by
                           the last call to BdAlloc or BdRealloc.  There
                           may be additional padding space at the end. */
   char *pb;            /* points to 1st byte of content part
                           of heap entry.  This pointer is updated when
                           heap entry is moved. */
   ushort cbPhysical;   /* actual size of heap entry, including empty
                           space at the end.  Always >= cbLogical */

   char *pbCur;         /* points to current byte within entry
                           This pointer is updated when heap entry is moved. */
   } bdp;



/**==================== bdl ==========================================

Large far buffer descriptor structure.
Examples of bdl structures include text and name tables.

=======================================================================**/

typedef struct bdl {
   ushort cbLogical;    /* logical size of content part of
                           heap entry.  This is the size as requested
                           by the last call to BdlAlloc() or BdlRealloc().    */
   ushort seg;          /* segment address of buffer, maintained by the far
                           heap manager. seg:0 is the far pointer to the
			   start of the buffer				      */
   ushort status;       /* Indicates if the bdl is currently an owner or not.
                           This field is actually used for something else by 
                           the FH manager, and so is read-only while the bdl
			   is an 'owner'.				      */
   ushort cPhysical;    /* physical size of heap entry. Under DOS 3, this is a
                           paragraph count, maintained by the FH manager; under
                           DOS 5, it's a byte count, maintained by bdmgr.asm  */
   } bdl;

#define  NOT_OWNER   UNDEFINED   /* used to test bdl.status field          */

/**===================================================================

Constants and structures related to entries in the Interpreter Heap

=======================================================================**/

/* Types of Interpreter Heap entries */
/* NOTE: see note in heap.inc */
#define IT_M_INTERP        (char)0x80  /* mask - if this bit is set in a heap 
                                          entry type byte, it's an interpreter-
                                          specific entry                      */
#define IT_NO_OWNERS       (char)0x80  /* heap entry which contains no owners.
                                          Entry is owned by a bd structure. 
                                          These can be moved without examining 
                                          content                             */
#define IT_NO_OWNERS_BDP   (char)0x90  /* same as IT_NO_OWNERS, but it is owned
                                          by a bdp structure instead of a bd, 
                                          so when moved, bdp.pbCur must be 
                                          updated                             */
#define IT_MRS             (char)0xA0  /* module register set table           */
#define IT_PRS             (char)0xB0  /* procedure register set table        */
#define IT_COMMON_BLOCK    (char)0xC0  /* table of owners of common value 
                                          tables                              */
#define IT_COMMON_VALUE    (char)0xE0  /* packed table of common values       */
#define IT_VAR             (char)0xF0  /* module variable table               */
#define IT_STRARYDESC	   (char)0x02  /* same constant used in common runtime*/


/* Forward References to Functions */

/* interpreter heap forward references */
boolean BdAlloc(bd *, ushort, char);
boolean BdAllocVar(bd *, ushort, char);
VOID BdFree(bd *);
boolean BdGrow(bd *, ushort);
boolean BdGrowVar(bd *, ushort);
boolean BdRealloc(bd *, ushort);
boolean BdCheckFree(bd *, ushort);
boolean BdAppend(bd *, char *, ushort);
ushort BdShiftRight(bd *, ushort, ushort);
VOID BdShiftLeft(bd *, ushort, ushort);
ushort BdChgContents(bd *, sd *);
VOID BdChgOwner(bd *, bd *);
VOID BdCompressAll(VOID);
ushort FAR GrabSpace(VOID);
VOID FAR ReleaseSpace(VOID);

/* far large heap forward references */
boolean BdlAlloc(bdl *, ushort);
VOID BdlFree(bdl *);
VOID BdlChgOwner(bdl *, bdl *);
boolean BdlCheckFree(bdl *, ushort);
boolean BdlRealloc(bdl *, ushort);
VOID BdlCopyTo(bdl *, ushort, char *, ushort);
VOID BdlCopyFrom(bdl *, ushort, char *, ushort);
VOID BdlTrim(bdl *);



#define DbOAbd(pbdArg)        {;}
#define DbOHbd(pbdArg)        {;}
#define DbOAbdN(pbdArg)       {;}
#define DbOHbdN(pbdArg)       {;}
#define DbDmpLHHeap(fAppend)  {;}
#define DbChkBdOwner(pbd)     {;}
#define DbChkBdlOwner(pbd)    {;}
#define DbChkBdNotOwner(pbd)  {;}
#define DbTglLHShift(fShift)  {;}
#define DbChkHeaps()          {;}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\idmac.inc ===
;***
; IDMAC.INC - 1-Apr-87 - Internal Debugging Macros
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	To provide a simple, consistent interface to internal debugging
;	code via macros; these macros allow minimal muddying of source
;	code, yet provide the ability to make runtime assertion checks,
;	and give useful status information on failure.
;
;
;******************************************************************************

IDMAC_INC = -1			


DbHalt MACRO	seg,message
	ENDM
DbAssertRel MACRO	parm1,arel,parm2,seg,message
	ENDM
DbAssertRelB MACRO	parm1,arel,parm2,seg,message
	ENDM
DbAssertFlags MACRO	arel,seg,message
	ENDM
DbAssertTst MACRO	parm1,arel,parm2,seg,message
	ENDM
DbChk	MACRO	name,parms
	ENDM
DbPub	MACRO	ep
	ENDM
DJMP	MACRO	op,parm1,parm2
	op	parm1 parm2
ENDM
DbFarPrologue	MACRO
	ENDM
DbFarEpilogue	     MACRO
	ENDM


.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\heap.inc ===
;*** 
;heap.inc
;
;	Copyright <C> 1986, 1987, 1988 Microsoft Corporation
;
;*******************************************************************************
; NOTE: When making changes to this file, be sure to make equivalent
;	changes to file HEAP.H

HEAP_INC = ON
	IncludeOnce	pointers	

;======================= bd ==========================================
;
;buffer descriptor structure.
;
;   Notice that this is a superset of a string-descriptor
;   structure, which means that some functions which expect
;   string descriptors can take buffer descriptors as input.
;
;Examples of  (bd) structures  include the  prs table, mrs
;table, value  tables and  name tables.
;
;=======================================================================*

bd	STRUC
BD_cbLogical		DW 0	;logical size of content part of
				;heap entry.  This is the size as requested by
				;the last call to BdAlloc or BdRealloc.  There
				;may be additional padding space at the end.
BD_pb			DW 0	;points to 1st byte of content part
				;of heap entry.  This pointer is updated when
				;heap entry is moved.
BD_cbPhysical		DW 0	;actual size of heap entry, including empty
				;space at the end.  Always >= cbLogical
bd	ENDS


;======================= bdp ==========================================
;
;buffer descriptor with pointer structure
;Notice that this is a superset of a (bd) structure,
;which means that some functions which expect (bd)'s as
;input can take (bdp)'s as input.
;Examples of (bdp) structures include  the buffer  used to pass the parser a
;source line and the  buffer the parser returns pcode in.
;
;=======================================================================*

bdp	STRUC
BDP_cbLogical		DW 0	;logical size of content part of
				;heap entry.  This is the size as requested by
				;the last call to BdAlloc or BdRealloc.  There
				;may be additional padding space at the end.
BDP_pb			DW 0	;points to 1st byte of content part
				;of heap entry.  This pointer is updated when
				;heap entry is moved.
BDP_cbPhysical		DW 0	;actual size of heap entry, including empty
				;space at the end.  Always >= cbLogical

; Note: IF FV_LMEM, BDP_pbCur is used as an offset from the start of the
; Note: block rather than a pointer into the block.	The pointer needed
; Note: can always be calculated by adding this offset to the starting
; Note: address of the block.  This removes the need to update this value
; Note: when the heap entry is moved.

BDP_pbCur		DW 0	;points to current byte within entry
				;This pointer is updated when heap entry is
				;moved.
bdp	ENDS


;======================= bdl ==========================================
;
;Large far buffer descriptor structure.
;Examples of bdl structures include text and name tables.
;
;=======================================================================*

IncludeOnce	array		;get FHD structure definition

NOT_OWNER	EQU	UNDEFINED	;used to test the BDL_status field

bdl	STRUC
BDL_cbLogical	DW	?	;maintained by bdmgr, ignored by FH manager.
BDL_seg 	DW	NOT_OWNER ; interpreter name for segment address
				;   or sb, depending on version.
BDL_dummy	DW	?	; required due to overlaying FHD struct
				; over the bdl struct
BDL_cPhysical	DW	?	;cPara is only maintained by FH manager under
				;DOS 3 or less; under DOS 5, bdmgr.asm maintains
				;this field as a byte count

bdl	ENDS

BDL_status	EQU	BDL_seg ; NOT_OWNER is a value that is known to
				; be an illegal value in the seg field for
				; any version. We access this same field via
				; the name 'status' to more clearly document
				; our intent.  It is assumed that this field
				; contains NOT_OWNER in a bdl that does not
				; own a far block.

; ensure that the BDL structure properly corresponds to the FHD structure
.errnz BDL_cbLogical - FHD_oData
.errnz BDL_seg 	- FHD_hData
.errnz BDL_dummy - FHD_pNext	
.errnz BDL_cPhysical - FHD_cPara
.errnz SIZE BDL - SIZE FHD

;***
;PUSHBDL_TYPE
;
;Purpose:
;	Push a word constant indicating type of bdl for EB versions
;	('type' is something like 'pcode table', 'name table', etc.)
;Entry:
;	bdlType is a constant to be passed to BdlAlloc[Sb] for EB versions.
;	reg is the helper register used to push the value (not needed in
;		versions which support the push immediate instruction)
;Modifies:
;	Given reg only
;**************************************************************************
PUSHBDL_TYPE	MACRO	bdlType,reg ;
	ENDM			;


;**===================================================================
;
;Constants and structures related to entries in the Interpreter Heap
;
;=======================================================================**

;Types of Interpreter Heap entries
;NOTE: These constants are (to some degree) known and shared by the heap
;	manager code maintained by the runtime group (currently in devdef.inc).
;	They CANNOT be modified without understanding the ramifications to
;	the heap management code (currently in nhlhutil.asm).
;	The current definition is that if bits 5 & 6 are set in the type byte,
;	the heap manager must itself do the work to update backpointers to
;	any owners in an entry being moved, else, if any of bits 4, 5, or 6
;	are set, B$IHeapEntryMoved will be called (in our bdmgr.asm) to
;	do the updating. If bit 7 is set, the heap manager knows that the
;	entry is interpreter-specific. Basically, we've got the high 4-bits,
;	and the low 4-bits are for general purpose types.
IT_M_INTERP		EQU	080h	;mask that says "interpreter entry"
IT_NO_OWNERS		EQU	080h	;Heap entry which contains no owners.
					;Entry is owned by a bd structure.
					;Can be moved w/o examining content
IT_NO_OWNERS_BDP	EQU	090h	;Same as IT_NO_OWNERS, but owned by a
					;bdp structure instead of a bd, so when
					;moved, bdp.pbCur field must be updated.
IT_MRS			EQU	0A0h	;module register set table
IT_PRS			EQU	0B0h	;procedure register set table
IT_COMMON_BLOCK 	EQU	0C0h	;table of owners of common value tables
IT_COMMON_VALUE 	EQU	0E0h	;packed table of common values
IT_VAR			EQU	0F0h	;module variable table
IT_STRARYDESC		EQU	002h	;same constant used in common runtime ..

;============================================================================
;the following EXTRN's are included in ALL files EXCEPT bdmgr.asm
;============================================================================


ife	BDMGR_ASM

	EXTRN	BdAlloc:far
	EXTRN	BdAllocVar:far
	EXTRN	BdFree:far
	EXTRN	BdChgContents:far
	EXTRN	BdChgOwner:far
	EXTRN	BdChgOwner_NoCopy:far
	EXTRN	BdGrow:far
	EXTRN	BdGrowVar:far
	EXTRN	BdRealloc:far
	EXTRN	BdCheckFree:far
	EXTRN	BdShiftRight:far
	EXTRN	BdShiftLeft:far
	EXTRN	BdAppend:far
	EXTRN	BdAdjust:far
	EXTRN	BdCompressAll:far
	EXTRN	GrabSpace:far
	EXTRN	ReleaseSpace:far
	EXTRN	BdlAlloc:far
	EXTRN	BdlAllocSb:far		
	EXTRN	BdlRealloc:far
	EXTRN	BdlGrow:far		
	EXTRN	BdlFree:far
	EXTRN	BdlChgOwner:far
	EXTRN	BdlCheckFree:far
	EXTRN	BdlCopyFrom:far
	EXTRN	BdlCopyTo:far
	EXTRN	BdlCopyFromTo:far
	EXTRN	BdlTrim:far
	EXTRN	GrabSpace:far
	EXTRN	ReleaseSpace:far
endif	;BDMGR_ASM



;======================================================================
;bd manager non-RELEASE macros
;======================================================================

DbDmpLHHeap	MACRO
		ENDM
DbShiftLH	MACRO
		ENDM
DbHeapMoveOff	MACRO
		ENDM
DbHeapMoveOn	MACRO
		ENDM
DbSegMoveOff	MACRO			;
		ENDM			;
DbSegMoveOn	MACRO			;
		ENDM			;


;======================================================================
;memory manager interface constants
;======================================================================

GMEM_ZEROINIT = 040h
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\lister.inc ===
; File: LISTER.INC
; NOTE: When making changes to this file, be sure to make equivalent
;	changes to file LISTER.H
; NOTE: For comments, see lister.h

LISTER_INC = -1			;remember that this file has been included

;**======================================================================**
;**==           External Interface to Lister Component                 ==**
;**==           This file is included by non-lister-component modules  ==**
;**======================================================================**


sBegin	LIST
ife	LSMAIN_ASM
	EXTRN	ListLine:far
	EXTRN	ListBaseNum:far
	EXTRN	ListNum:far
endif	;LSMAIN_ASM
sEnd	LIST

sBegin	DATA
ife	LSMAIN_ASM
	EXTRN	fLsIncluded:byte
	EXTRN	fLsDynArrays:byte
	EXTRN	otxListNext:word
	EXTRN	otxListNextInc:word
	EXTRN	otxLsCursor:word
	EXTRN	cLeadingSpaces:byte
endif	;LSMAIN_ASM

ife	LSRULES_ASM
	EXTRN	psdLsIncl:word
endif	;LSRULES_ASM

sEnd	DATA
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\interp.inc ===
page 49,132
;*** 
;interp.inc
;
;	Copyright <C> 1985, 1986, 1987 Microsoft Corporation
;
;For comments, see interp.h
;
;
;*******************************************************************************

TRUE		equ 1
FALSE		equ 0
NULL		equ 0		; System NULL for pointers
UNDEFINED	equ 65535d	; System NULL for offsets
MAX_LN		equ 65529d	; maximum legal line number
CB_IDNAM_MAX	equ 40d 	; max legal size of BASIC identifier

;This structure and following equates added with [18]
;pre-defined oTyp values (type constants)
;be sure to add all new types to the global table which follows.
ET_TYPES	struc
ET_IMP		db	?	; Implicitly typed variable
ET_I2		db	?	; 16 bit signed integer
ET_I4		db	?	; 32 bit signed integer

ET_R4		db	?	; 32 bit real

ET_R8		db	?	; 64 bit real


ET_SD		db	?	;String descriptor

ET_FS		db	?	


ET_TYPES	ends

ET_MAX	equ	size ET_TYPES - 1

ET_MaxNum	equ	ET_R8	

ET_MaxStr	equ	ET_FS	;[11]


; WARNING: be sure to make equivalent types in interp.h
; global et type numbers.  all new types should be appended to the end.
; added for [22]

; the next 5 types MUST be in the same order as the et types in QB 4.0

GLBL_IMP	EQU	0	    ; Implicitly typed variable
GLBL_I2 	EQU	1	    ; 16 bit signed integer
GLBL_I4 	EQU	2	    ; 32 bit signed integer
GLBL_R4 	EQU	3	    ; 32 bit real
GLBL_R8 	EQU	4	    ; 64 bit real
GLBL_SD 	EQU	5	    ; String descriptor

GLBL_CY 	EQU	6
GLBL_TX 	EQU	7	    ; Text descriptor
GLBL_FS 	EQU	8	    ; Fixed length string
GLBL_FT 	EQU	9	    ; Fixed length text
GLBL_FIELD	EQU	10
GLBL_FORM	EQU	11
GLBL_MENU	EQU	12

GLBL_ET_MAX	EQU	12	    ; number of global et types defined


CBASETYPEMAX	equ	6;Number of opcodes for different types
			 ;	i.e. number of explicit types + 1 for implicit

StartOtx	equ	0

SetStartOtx	MACRO	dest
	xor	dest,dest	;2-byte instruction for zero
	ENDM

opLitI2Max  equ     10		;Maximum literal with own executor

;SD Structure - variable length string value
SD	STRUC
SD_cb		DW	0
SD_pb		DW	0
SD	ENDS

;****************************************************************************
;includeOnce <file>
;Purpose:
;	This macro is used to make sure that include files are only
;	included once.  The included file must set <file>_INC to ON.
;	The following would include foo.inc.
;
;		includeOnce foo		;foo.inc should have the following:
;					;FOO_INC = ON
;RESTRICTIONS:
;	the include name can't contain a pathname and must omit the .inc
;	suffix.
;****************************************************************************

includeOnce	macro	name
ifndef	name&_INC
	include	name.inc   ;;include the .inc file if it hasn't already been
			   ;;included
name&_INC=OFF
endif
if2
if	name&_INC EQ OFF
	include	name.inc   ;;Include it once on the 2nd pass, too
name&_INC=ON
endif
endif
	endm
;end of 'includeOnce' macro

;
;The OrdConstStart and OrdConst macros are used to define
;	an ordered set of constants
;
OrdConstStart	MACRO	start	
OrdConstCur = start 		
	ENDM			

OrdConst	MACRO	name	
name	EQU	OrdConstCur+0	;+0 prevents name from just being an alias
OrdConstCur = OrdConstCur + 1	
	ENDM			

?NODATA =	1		;always on so ATOMIC can be used
				;harmless if ?WIN == 0
include	cmacros.inc

;macro	sBegin
;Purpose:
;The following macro is a front end to the sBegin macro in cmacros.inc.
;The reason for this macro front end is to create segments only for those
;segments that are actually used.  This is especially important in light
;of the fact that codeview only lists symbols in the first encountered
;code segment.
;
;Macro sBeginC is identical to the sBegin macro found in cMacros.  It
;was created by modifying the name of the macro in cmacros.inc.

DFP_NONE	EQU	0
DFP_FAR 	EQU	1
DFP_CODE	EQU	2
DFP_CP		EQU	3

sBegin	macro	logname
segOK	= 0
?DFP	= DFP_FAR		;; assume routine IS to be called, and far
ifidn	<&logname>,<LOADRTM>
ifCreateSeg	LOADRTM,LOADRTM,CODE
endif
ifidn	<&logname>,<FAR_PRESERVED>			;
ifCreateSeg	FAR_PRESERVED,FAR_PRESERVED,CODE	;
endif							;
ifidn	<&logname>,<LOADRTMEND>
ifCreateSeg	LOADRTMEND,LOADRTMEND,CODE
endif
ifidn	<&logname>,<RT>
ifCreateSeg	CODE,RT,CODE
endif
ifidn	<&logname>,<CODE>
ifCreateSeg	_TEXT,CODE,CODE
?DFP	= DFP_CODE		;
endif
ifidn	<&logname>,<MATH>	;
ifCreateSeg	_TEXT,MATH,CODE ;
endif				;
ifidn	<&logname>,<CP>
ifCreateSeg	CP,CP,CODE
?DFP	= DFP_CP		;
endif
ifidn	<&logname>,<UI>
ifCreateSeg	UI,UI,CODE
endif
ifidn	<&logname>,<LIST>
ifCreateSeg	LIST,LIST,CODE
endif
ifidn	<&logname>,<DBG>
ifCreateSeg	DBG,DBG,CODE
?DFP	= DFP_NONE		;
endif
ifidn	<&logname>,<ID_STRINGS>
ifCreateSeg	ID_STRINGS,ID_STRINGS,CODE
endif
ifidn	<&logname>,<RARE>
ifCreateSeg	RARE,RARE,CODE
endif
ifidn	<&logname>,<SCAN>	;
ifCreateSeg	SCAN,SCAN,CODE	;
endif				;
ifidn	<&logname>,<DATA>
segOK	= 1
endif
ifidn	<&logname>,<_TEXT>	;
ifCreateSeg	_TEXT,_TEXT,CODE;
endif				;
.erre	segOK			;;Error if logname wasn't one of the above.
sBeginC	&logname		;;See note above if this becomes undefined.
	endm

ifCreateSeg	macro	segment,logname,class
segOK	= 1
ifndef	&logname&_sBeginC
createSeg	segment,logname,WORD,PUBLIC,class
endif
		endm

createSeg	_DATA,data,word,public,DATA,DGROUP
defGrp DGROUP,DATA

ifndef NODEBUG	
include debug.inc
endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\interp.h ===
/*** 
*interp.h - Data Dictionary for the BASIC 3.0 Interpreter
*
*	Copyright <C> 1985, 1986, 1987 Microsoft Corporation
*
*******************************************************************************/
/*                             
/*  Standard Major Qualifiers  
/*                             
/* pX	       - a pointer to an X
/* szX	       - pointer to 1st byte of a zero terminated string
/* tX	       - table; A contiguous list of X's
/* iX	       - 0 relative index of item within a table of X's
/* oX	       - 0 relative byte offset of an item from a known base
/* fX	       - flag; bit field to signal binary types
/* bX	       - byte
/* cX	       - count of occurrances of X
/* cbX	       - count of bytes in an X
/* cwX	       - count of words in an X
/* mpXY        - An array which maps X's to Y's
/* opX	       - 16-bit value of BASIC Virtual Machine Opcode X
/* opStX       - value of opcode for statement keyword X. i.e. opStResume
/* opFnX       - value of opcode for intrinsic keyword X. i.e. opFnDate
/* exX	       - Function which emulates BASIC Virtual Machine Opcode opX
/*                             
/*  Standard Minor Qualifiers  
/*                             
/* xFirst      - first element of a list or sequence
/* xNext       - next element of a list or sequence
/* xLast       - last element of a list or sequence
/* xSrc        - Source
/* xDst        - Destination
/* xMax        - Strict upper limit, i.e. char tbXXX[XXXMAX]
/* xCur        - "Current value of" as opposed to xMax or xFirst
/* xT	       - Temporary
/*
/* In general, when a variable is of a type defined by a typedef the first
/* characters of the variable name are the type name.  For example, sdX is
/* an occurrence of a string descriptor.
/*
/*
***************************************************************************/

#define INTERP_H -1		 /* remember that interp.h has been included */

/* ALL DECLARATIONS and other entities not allowed in DEF files must be under */
/* NO_DECL (#ifndef) switch so DEF files may use version.h and the C	      */
/* preprocessor 							      */

#ifndef NO_DECL
#define TRUE 1
#define FALSE 0

#ifndef NULL			 /* to preclude duplicate definition warnings */
#define NULL 0			 /* System NULL for pointers */
#endif

#define UNDEFINED (ushort)65535  /* System NULL for offsets */
#define MAX_LN (ushort)65529     /* maximum legal line number */
#define CB_IDNAM_MAX 40          /* [1] max number of bytes in an id. name */

/* Variable/Literal Explicit Type Enumerations (predefined oTyp values) */
/* be sure to add all new types to the global number definitions	*/

#define  ET_IMP      0		    /* Implicitly typed variable	*/
#define  ET_I2	     1		    /* 16 bit signed integer		*/
#define  ET_I4	     2		    /* 32 bit signed integer		*/

#define  ET_R4	     3		    /* 32 bit real			*/
#define  ET_R8	     4		    /* 64 bit real			*/

#define  ET_MaxNum   ET_R8	    /* [6]				*/

#define  ET_SD	     (ET_MaxNum+1)  /* [6] String descriptor		*/

#define  ET_FS	     (ET_SD+1)	    /* [6]				*/
#define  ET_MaxStr   ET_FS	    /* [10][6]				*/

#define  ET_MAX      ET_MaxStr	    /* [10]				*/

/* WARNING: be sure to make equivalent types in interp.h		*/
/* global et type numbers.  all new types should be appended to the end.*/
/* added for [13]							*/

/* the next 5 types MUST be in the same order as the et types in QB 4.0 */

#define     GLBL_IMP	    0		/* Implicitly typed variable	*/
#define     GLBL_I2	    1		/* 16 bit signed integer	*/
#define     GLBL_I4	    2		/* 32 bit signed integer	*/
#define     GLBL_R4	    3		/* 32 bit real			*/
#define     GLBL_R8	    4		/* 64 bit real			*/
#define     GLBL_SD	    5		/* String descriptor		*/

#define     GLBL_CY	    6
#define     GLBL_TX	    7		/* Text descriptor		*/
#define     GLBL_FS	    8		/* Fixed length string		*/
#define     GLBL_FT	    9		/* Fixed length text		*/
#define     GLBL_FIELD	    10
#define     GLBL_FORM	    11
#define     GLBL_MENU	    12

#define     GLBL_ET_MAX     12		/* number of global et types defined */


#define	STARTOTX 0	 /* [11] */

#define     opLitI2Max	    10		// Maximum literal with own executor

/*************************************************************************
*	C specific definitions
*************************************************************************/
#define REG1 register	/* The 8086 has only 2 register variables */
#define REG2 register
#define REG3
#define REG4
#define REG5
#define REG6
#define REG7
#define REG8
#define REG9

#define VOID void		 /* EB_API */ /* For functions that return no value */
#define NEAR near		 /* EB_API */
#define FAR far 		 /* EB_API */
#define PLM pascal		 /* EB_API */
#define CDECL cdecl		 /* EB_API */

typedef unsigned char uchar;	 /* EB_API */
typedef unsigned short ushort;	 /* EB_API */
typedef unsigned long ulong;	 /* EB_API */
typedef ushort boolean; 	 /* EB_API */ /* -1 = TRUE, 0=FALSE	 */
typedef ushort word;		 /* EB_API */
typedef ulong  dword;		 /* EB_API */
typedef uchar  byte;		 /* EB_API */
typedef uchar  bool;

/* String Descriptor definition */
typedef struct sd {
	ushort	cb;		/* Count of data bytes in string */
	char *	pb;		/* Address of string data	 */
	} sd;

/* This structure is handy for computing the size of an odd-size structure
	regardless of whether -Zp is specified in the compile line or not */
typedef struct oneChar {
	char singleChar;
	} oneChar;

/*************************************************************************
*	Global Variables
*************************************************************************/

/* Only one module has DEFINE_VARIABLES set, so the variables
	are not external in only this module. */

#if DEFINE_VARIABLES
#define EXTERNAL
#define INIT(x) = x
#else
#define EXTERNAL extern
#define INIT(x)
#endif

/*************************************************************************
*	DEBUG Aids 
*************************************************************************/
	/* RELEASE versions can't have DEBUG code. */

#if !DEBUG_H
#include "debug.h"
#endif

/*************************************************************************
*	MATH for C source
*************************************************************************/


/* The type of the floating point variables depends on the math pack.  When 
	using other than the C math pack, one cannot use the "double" or "float" 
	types because their definition alone causes C-math pack invocation */

typedef struct DOUBLE {ulong high; ulong low;} DOUBLE;
typedef struct FLOAT {ulong value;} FLOAT;
#define double ERROR
#define float	ERROR
#endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\lister.h ===
/* File: lister.h - Defines which apply to the QBI Lister               */
/* NOTE: When making changes to this file, be sure to make equivalent   */
/*       changes to file LISTER.INC                                     */

#undef LISTER_H
#define LISTER_H ON        /* remember that this file has been included */

/**======================================================================**
 **==           External Interface to Lister Component                 ==**
 **==           This file is included by non-lister-component modules  ==**
 **======================================================================**/

ushort FAR ListLine(ushort, bd *);

extern ushort otxListNext;
   /* text offset to opBol for next line to be listed by ListLine().
      Set by ListLine on exit. */
extern ushort otxFindStmt;	/* See ListLine header for description */
extern ushort colFindStmt;	/* See ListLine header for description */
extern ushort colFindStmtEnd;	/* See ListLine header for description */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\lsint.inc ===
; File: LSINT.INC

LSINT_INC = ON			;remember that this file has been included

;**======================================================================**
;**==           Internal Interface to Lister Component                 ==**
;**======================================================================**

;LsNode is a node in a binary tree used to describe the line being listed.
LsNode	STRUC
	LN_sib		DW 0	;offset into bdNodes to sibling node
				; (NULL if none)
	LN_type		DB 0	;identifies what type of text is associated
				; with this node (LNT_xxx defined below)
	LN_val		DB 0	;variable length content which depends
				; on the value of field LN_type
LsNode	ENDS

;Node types:
LNT_CHAR_TOK EQU 0	;value is 1 or 2 ASCII characters associated with
			; this node.
LNT_STR EQU	2	;value is a 16 bit offset followed by 16 bit count
			; which identifies where the string is in
			; the text table.
LNT_ENSTR EQU	4	;value is a 16 bit offset followed by 16 bit count
			; which identifies where the string is in the
			; text table.  The string may have runs of characters
			; compressed.
LNT_CSSTR EQU	6	;value is a 16 bit offset into LIST segment to a
			; str255 struct for a string constant
LNT_LITSTR EQU  8	;same as a LNT_STR node except that the list routine
			; generates two double quotes for each occurance
;The following nodes can 'begin' a logical token (for _CrLf line splitting)
LNT_ONAM EQU	10	;value is a 16 bit name table offset for identifier
			; associated with this node.
LNT_LIST EQU	12	;this node has no atomic ASCII source directly
			; associated with it, i.e. it is a hierarchy node.
LNT_RW EQU	14	;value is a 16 bit reserved word table offset for
			; reserved word or special character associated
			; with this node.
LNT_SPACES EQU	16	;value is 16 bit count of spaces (blanks)
LNT_NUM EQU	18	;value identifies a numeric constant
LNT_COL EQU	20	;value identifies a column to advance to
LNT_CHAR EQU	22	;value is 1 or 2 ASCII characters associated with
			; this node.  Identical to LNT_CHAR_TOK, but this
			; node is guarenteed to begin a lexical token
			; (needed for _CrLf line splitting)
LNT_CURSOR EQU	24

LN_val_list EQU LN_val		;LNT_LIST's offset to list of child nodes
LN_val_oNam EQU LN_val		;LNT_ONAM's arg (offset into name table for id)
LN_val_orw EQU LN_val		;LNT_RW's arg (offset into res word table)
LN_val_char EQU LN_val		;LNT_CHAR's arg (ASCII char)
LN_val_cbStr EQU LN_val		;LNT_STR's arg (# bytes in string literal)
LN_val_oStr EQU LN_val + 2	;LNT_STR's 2nd arg (offset into program text
				;   table to start of string)
LN_val_cbEnStr EQU LN_val	;LNT_ENSTR's arg (# bytes in string literal)
LN_val_oEnStr EQU LN_val + 2	;LNT_ENSTR's 2nd arg (offset into program text
				;   table to start of string)
LN_val_CsStr EQU LN_val		;LNT_CSSTR's arg (16 bit offset into LIST seg
				; to a str255 struct for a string constant
LN_val_cbSpaces EQU LN_val	;LNT_SPACES's arg (# spaces to list)
LN_val_cbNum EQU LN_val		;size of number in bytes (2, 4, 8)
LN_val_clNum EQU LN_val + 1	;class of number (LIT_D2...LIT_R8)
				; see psint.inc for enumerations
LN_val_otxNum EQU LN_val + 2	;16 bit text offset to number's value
LN_val_col EQU LN_val		;16 bit column to advance to (LNT_COL)

CBLNT_LIST EQU	5	;size of LNT_LIST node
CBLNT_ONAM EQU	5	;size of LNT_ONAM node
CBLNT_RW EQU	5	;size of LNT_RW node
CBLNT_CHAR EQU	5	;size of LNT_CHAR node
			; even though this could be 4 bytes, this allows
			; us to convert a LNT_CHAR node to LNT_RW node
			; without changing pointers.
			; It also allows us to store 2 chars in one node.
CBLNT_STR EQU	7	;size of LNT_STR node
CBLNT_ENSTR EQU 7	;size of LNT_ENSTR node
CBLNT_CSSTR EQU	5	;size of LNT_CSSTR node
CBLNT_SPACES EQU 5	;size of LNT_SPACES node
CBLNT_NUM EQU	7	;size of LNT_NUM node
CBLNT_COL EQU 5		;size of LNT_COL node

LIT_LINENUM EQU 0FFH

;------------------------------------------------------------------
; Flags in lsBosFlags which get reset at every beginning-of-line
;------------------------------------------------------------------
FBOL_GotIf		EQU 01H	;non-zero if an IF opcode has been
				;seen on this line
FBOL_Shared		EQU 02H	;non-zero if opShared has been seen
FBOL_AsClause		EQU 04H	;non-zero if next opIdVTRf is to be
				;followed by AS <type> (set by LrAsType)

;------------------------------------------------------------------
; Flags in lsBosFlags which get reset at every beginning-of-stmt
;------------------------------------------------------------------
FBOS_Channel		EQU 01H ;non-zero if #n, needs to be listed
FBOS_StmtRw		EQU 02H	;non-zero if PushStmtRwBos has been
				;called for stmt
FBOS_PrintSemi		EQU 04H	;non-zero if next PRINT item is to be
				;preceded by ";"
FBOS_DoIdCommas		EQU 08H ;non-zero if every opIdVTRef and
				;opAVTRef is to be preceded by a comma
FBOS_NextIdComma	EQU 10H	;used to list commas between 2nd->nth
				;id (if FBOS_DoIdCommas is set)
FBOS_NextStmtComma	EQU 20H	;used to list opcodes which list
				;as a reserved word the first time
				;they occur in a statement, and as
				;a comma for the 2nd-nth occurence
				;in the statement.  See LrStCase,
				;LrStDim for examples of usage.
FBOS_CallLess		EQU 40H	;remember not to emit () around arg list
FBOS_InputPrompt	EQU 80H	;non-zero if LrInputPrompt has already
				;listed "INPUT "

;2nd byte of word which gets cleared at beginning of every statement
FBOS2_1stCoord		EQU 01H	;non-zero if coord pair seen before -(x,y)
FBOS2_DECLARE		EQU 02H	;non-zero if listing DECLARE stmt
FBOS2_Circle1		EQU 04H	;non-zero if got Circle Start argument
FBOS2_Circle2		EQU 08H	;non-zero if got Circle End argument
FBOS2_NonNilExp		EQU 10H	;see PopNilExp in lsrules.asm
FBOS2_CONST		EQU 20H ;non-zero if listing CONST id=expr stmt
FBOS2_CONST_COMMA	EQU 40H	;non-zero if listing 2nd->nth id=expr in stmt
FBOS2_DIM		EQU 80H ;non-zero if listing DIM/AUTO/PUBLIC etc.

;macro to store a constant in ds:di and bump di by 2
stosDsWord MACRO value
	mov	WORD PTR [di],value
	inc	di
	inc	di
	ENDM

;macro to store a constant in ds:di and bump di by 1
stosDsByte MACRO value
	mov	BYTE PTR [di],value
	inc	di
	ENDM

;Macro to define a List-Rule entry point
ListRule MACRO	entry
	PUBLIC	entry
entry	label	NEAR
	ENDM

sBegin LIST
EXTRN	mpOpLister:word
	;table which maps an opcode to the address of the function which
	; lists it.

EXTRN	mpOpLsArg:word
	;table which maps opcodes into offsets into reserved word table

ife	LSMAIN_ASM
	EXTRN	Stage2:near
	EXTRN	Stage2Inc:near
	EXTRN	Stg1Loop:near
	EXTRN	GrowBdNodes:near
endif	;LSMAIN_ASM

ife	LSUTIL_ASM
	EXTRN	NewChar:near
	EXTRN	NewCsStr:near
	EXTRN	NewId:near
	EXTRN	NewLabel:near
	EXTRN	NewLabelONam:near
	EXTRN	NewModLabel:near
	EXTRN	NewNum:near
	EXTRN	NewONam:near
	EXTRN	NewRw:near
	EXTRN	NewSpaces:near
	EXTRN	NewEnStr:near
	EXTRN	NewStr:near
	EXTRN	NewCol:near
	EXTRN	NewCol1:near
	EXTRN	PopRoot:near
	EXTRN	PushCommaArgs:near
	EXTRN	PushList:near
	EXTRN	PushRevList:near
	EXTRN	PushRoot:near
	EXTRN	PushRootChar:near
	EXTRN	PushRootChars:near
	EXTRN	PushRootLParen:near
	EXTRN	PushRootRParen:near
	EXTRN	PushRootSpc:near
	EXTRN	PushRootONam:near
	EXTRN	PushRootLabel:near
	EXTRN	PushRootRw:near
	EXTRN	PushRootRwSpc:near
	EXTRN	PushRootOpRw:near
	EXTRN	PushRootOpRwSpc:near
	EXTRN	PushRootQStr:near
	EXTRN	PushTemp:near
	EXTRN	PushTempChar:near
	EXTRN	PushTempChars:near
	EXTRN	PushTempLParen:near
	EXTRN	PushTempRParen:near
	EXTRN	PushTempSpc:near
	EXTRN	PushTempRw:near
	EXTRN	PushTempRwSpc:near
	EXTRN	PushTempOpRw:near
	EXTRN	PushTempOpRwSpc:near
	EXTRN	PushTempComma:near
	EXTRN	PushTempCommaSpc:near
	EXTRN	PopPushCommaSpc:near
	EXTRN	PushRootCommaSpc:near
	EXTRN	PushTempIdComma:near
	EXTRN	PushTempOpChars:near
	EXTRN	PushRootOpChars:near
	EXTRN	PushTempOpRwOrComma:near
	EXTRN	PushTempRwOrComma:near
	EXTRN	PopRootPushTemp:near
	EXTRN	PushTempCharSpc:near
	EXTRN	PushRootCharSpc:near
	EXTRN	PushStmtRwIfBos:near
	EXTRN	CharToCharTok:near
	EXTRN	ListOffToPtr:near
	EXTRN	ListSibPtr:near
endif	;LSUTIL_ASM

ife	LSID_ASM
	EXTRN	PushTempONam:near
	EXTRN	PushOffId:near
	EXTRN	PushListStg1:near
	EXTRN	PushRevListStg1:near
endif	;LSUTIL_ASM

ife	LSRULES_ASM
	EXTRN	LrRwSpc:near
endif	;LSRULES_ASM

sEnd	LIST

sBegin	DATA
ife	LSMAIN_ASM
	EXTRN	bdNodes:word
	EXTRN	cLsArgs:byte
	EXTRN	fGotBol:byte
	EXTRN	fLsIncluded:byte
	EXTRN	oNodeRoot:word
	EXTRN	oNodeTemp:word
	EXTRN	opList2:word
	EXTRN	opList:word
	EXTRN	lsBolFlags:byte
	EXTRN	lsBosFlagsWord:word
	EXTRN	lsBosFlags:byte
	EXTRN	lsBosFlags2:byte
	EXTRN	otxLsCursorTmp:word
	EXTRN	colLsCursor:word
	EXTRN	ndLsCursor:word
endif	;LSMAIN_ASM
sEnd	DATA
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\lmem.inc ===
;***
;lmem.inc - LMEM constants and entry points
;***
	.XLIST
;***
;
;	Copyright <C> 1988, Microsoft Corporation
;
;Purpose:
;	NOTE: This is a SHARED INCLUDE FILE, used by both the RUNTIME
;	NOTE: and the interpreter projects.  Any changes made to one should
;	NOTE: be carried over to the other!!!
;	NOTE: There are some minor differences between the two versions for
;	NOTE: this file, so DO NOT just copy it!!!
;
;
;******************************************************************************

LMEM_INC = ON
	IncludeOnce	sb

fcmpNoCompact		equ	0
fcmpCompact		equ	1
fcmpCompactHandles	equ	2
merrAllocMoveable	equ	1
merrAllocFixed		equ	2
merrReallocMoveable	equ	3
merrAllocBlock		equ	4

;Special Zeros
pvZero		equ	12H	;a pointer to 0 length block, 1st word is 0
ppvZero		equ	14H	;a pointer to pvZero

;Entry points
extrn	CreateHeap:far		;(SB)
extrn	CbCompactHeap:far	;(SB, WORD)
extrn	PpvAllocCb:far		;(SB, WORD)
extrn	FReallocPpv:far		;(SB, VOID **, WORD)
extrn	FreePpv:far		;(SB, VOID **)
extrn	CbSizePpv:far		;(SB, VOID **)

extrn	HFirstAllocBlock:far	;(SB, WORD)
extrn	FreeHandleBlock:far	;(SB, VOID **)


comment	| Unused entry points are kept below, in case they're needed later

extrn	PvAllocFixedCb:far	;(SB, WORD)
extrn	CbSizeFixedPv:far	;(SB, VOID *)
extrn	LockHeap:far		;(SB)
extrn	UnlockHeap:far		;(SB)

extrn	FCreateWindowsHeap:far	;(SB, WORD)
extrn	SwapHandles:far		;(SB, VOID **, VOID **)

;Debug entry points
extrn	CheckHeap:far		;(SB)
extrn	ShakeHeapSb:far		;(SB)
extrn	GetHeapInfo:far		;(SB, CKL FAR *)
extrn	FCheckHandle:far	;(SB, VOID **)
extrn	PpvWalkHeap:far		;(SB, VOID **)
extrn	PvWalkFixedHeap:far	;(SB, VOID *)
	|
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\messages.inc ===
;***
; MESSAGE.INC - 20-Jul-87 - Runtime Message Definitions
;***
	.XLIST
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	Message text, number and symbol information. If the macro RTEDEF has
;	already been defined, we just use it, else we use a macro which just
;	defines the symbolic labels that the error numbers relate to.
;
;
;******************************************************************************
	PAGE
;******************************************************************************
;
; Message Isolation and Internationalization.
;
; All text messages in the BASIC runtime are defined in this file. A kit is
; provided to allow an OEM customer to alter the text of the messages. This
; kit consists of:
;
;	messages.inc	- This file. Defines all text.
;	*.asm		- Assembly files which include this file to generate
;			  actual message text.
;	newmsg.bat	- A batch file which assembles the *.asm files, and
;			  replaces them in their appropriate libraries.
;	chmsg.exe	- A message extraction / insertion utility to alter the
;			  messages in the runtime module .EXE files without
;			  relinking.
;
; To change message text:
;
;	1) Edit this file to change the text of the messages as required. The
;	   text is always the last argument to the RTEDEF or RLEDEF macros.
;	   Commented out text is present for documentation purposes only, and
;	   editting it will have no effect.
;
;	   There is no length limit on messages altered in this file.
;
;	   Messages may not contain null characters.
;
;	2) Run newmsg.bat, with this file, the *.asm files, and the product
;	   libraries in the current directory.
;
;	3) Run chmsg on the runtime module:
;
;		chmsg brun30c.exe >brun30c.txt
;
;	4) Edit brun30c.txt to alter the messages as desired.
;
;	5) Run chmsg on the runtime module again:
;
;		chmsg brun30c.exe brun30c.txt
;
;	   Note: no redirection this time. This will install the new messages.
;	   There is a limit, as reported by chmsg, as to the available space
;	   for altered messages.
;
;	6) repeat steps 3 through 6 on brun30p.exe.
;
;******************************************************************************
	PAGE
;******************************************************************************
;
; RTEDEF macro
;
; Used to define Run Time Error and other text messages, and symbolic constants
; associated with them. If RTEDEF has not already been defined by the time this
; file is INCLUDEd, the default RTEDEF just equates the symbol to the numeric
; value. In this way, just INCLUDEing this file, without any further thought,
; gives you the set of symbolic message constants.
;
; Files which actually want to define the text associated with the messages
; will define RTEDEF, prior to including this file, to perform whatever they
; need with the information available.
;
IFNDEF	RTEDEF			;if no RTEDEF macro already defined

RTEDEF	MACRO	TYPE,SYMBOL,NUM,MSG

IFNB	<SYMBOL>		;;If there is a symbol to be defined
SYMBOL	EQU	NUM		;;Define message symbol
ENDIF

	ENDM			;;RTEDEF MACRO

ENDIF				;IFNDEF RTEDEF

;******************************************************************************
;
; RCEDEF macro
;
; This is a special case of the RCEDEF macro used to define the strings used by
; the DOS 3 runtime loader. (RCE -> Runtime C Error). By default the macro
; does what RTEDEF does. In the files needed, the macro is defined as required
; to define symbolic constants and/or text.
;
IFNDEF	RCEDEF			; if RCEDEF macro not already defined

RCEDEF	MACRO	TYPE,SYMBOL,NUM,MSG
	RTEDEF	TYPE, SYMBOL, NUM, <MSG>
	ENDM			;;RCEDEF MACRO

ENDIF	;IFNDEF	RCEDEF

;******************************************************************************
;
; RLEDEF macro
;
; This is a special case of the RTEDEF macro used to define the strings used by
; the DOS 3 runtime loader. (RLE -> Runtime Loader Error). By default the macro
; does nothing. In the files needed, the macro is defined as required to define
; symbolic constants and/or text.
;
IFNDEF	RLEDEF			;if RLEDEF macro not already defined

RLEDEF	MACRO	LABEL,TEXT	;if not defined, just null
	ENDM	;;RLEDEF MACRO  

ENDIF	;IFNDEF	RLEDEF		

;******************************************************************************
;
; RXEDEF macro [32]
;
; This is a special case of the RTEDEF macro used to define the strings used by
; the DOEXEC procedure.  (RXE -> Runtime eXec Error). By default the macro does
; nothing.  In the files needed, the macro is defined as required to define
; labels and text.
;
IFNDEF	RXEDEF			; if RXEDEF macro not already defined

RXEDEF	MACRO	LABEL,NUM,TEXT	; if not defined, just null
	ENDM	;;RXEDEF MACRO	

ENDIF	;IFNDEF	RXEDEF		


;******************************************************************************
;
; Define useful characters
;
ASCCR	=	0DH		;Carriage return

;******************************************************************************
;
;	Messages.
;	Messages are numbered as follows:
;
;	0000H - 00FFH:	BE_???? - Standard "Basic" Errors 0 through 255
;	0100H - 7FFFH:	Unused
;	8000H - FFFFH:	Internal messages.
;			8000 - 8FFFH:	MS_??? - Non-error messages
;			9000 - 9FFFH:	FE_??? - Fatal "crash and burn" errors.
;				9000-93FF:	Line number & Module valid
;				9400-96FF:	Module valid
;				9700-97FF:	QB interp initialization errors
;				9800-9BFF:	Nothing valid
;
;******************************************************************************
;
;	BE: Basic Errors
;	These are all the basic errors that can be generated at run time.
;
;******************************************************************************
	RTEDEF	SN,  BE_SYNTAX,    2,"Syntax error"
	RTEDEF	RG,  BE_RETURN,    3,"RETURN without GOSUB"
	RTEDEF	OD,  BE_NODATA,    4,"Out of DATA"
	RTEDEF	FC,  BE_ILLFUN,    5,"Illegal function call"
	RTEDEF	OV,  BE_OVERFLOW,  6,"Overflow"
	RTEDEF	OM,  BE_MEMORY,    7,"Out of memory"
	RTEDEF	BS,  BE_SUBSCRIP,  9,"Subscript out of range"
	RTEDEF	<DD>,BE_REDIM,	  10,"Duplicate definition"	; <DD> avoids assembly confusion
	RTEDEF	DV0, BE_DIVIDE0,  11,"Division by zero"
	RTEDEF	TM,  BE_TYPE,	  13,"Type mismatch"
	RTEDEF	OS,  BE_STRINGSP, 14,"Out of string space"
	RTEDEF	ST,  BE_STRINGFO, 16,"String formula too complex"
	RTEDEF	NR,  BE_NORESUME, 19,"No RESUME"
	RTEDEF	RE,  BE_RESUME,   20,"RESUME without error"
	RTEDEF	DTO, BE_DEVTIME,  24,"Device timeout"
	RTEDEF	DVF, BE_DEVFAULT, 25,"Device fault"
	RTEDEF	OTP, BE_NOPAPER,  27,"Out of paper"
	RTEDEF	,,		  39,"CASE ELSE expected"	
	RTEDEF	RVR, BE_RECVARREQ,40,"Variable required"	
	RTEDEF	FOV, BE_FIELD,	  50,"FIELD overflow"
	RTEDEF	INT, BE_INTERNAL, 51,"Internal error"
	RTEDEF	IFN, BE_FILENUM,  52,"Bad file name or number"	
	RTEDEF	FNF, BE_NOFILE,   53,"File not found"
	RTEDEF	BFM, BE_FILEMODE, 54,"Bad file mode"
	RTEDEF	FAO, BE_FILEOPEN, 55,"File already open"
	RTEDEF	FSA, BE_FLDACTIVE,56,"FIELD statement active"	
	RTEDEF	IOE, BE_DEVICEIO, 57,"Device I/O error"
	RTEDEF	FAE, BE_EXISTS,   58,"File already exists"
	RTEDEF	BRL, BE_BADRECLEN,59,"Bad record length"	
	RTEDEF	DFL, BE_DISKFULL, 61,"Disk full"
	RTEDEF	RPE, BE_PASTEND,  62,"Input past end of file"	
	RTEDEF	BRN, BE_BADREC,   63,"Bad record number"
	RTEDEF	BFN, BE_BADNAME,  64,"Bad file name"
	RTEDEF	TMF, BE_TOOMANY,  67,"Too many files"
	RTEDEF	DNA, BE_NODEVICE, 68,"Device unavailable"
	RTEDEF	CBO, BE_COMMBUFF, 69,"Communication-buffer overflow" 
	RTEDEF	FWP, BE_HANDSOFF, 70,"Permission denied"	
	RTEDEF	DNR, BE_NOTREADY, 71,"Disk not ready"
	RTEDEF	DME, BE_MEDIA,	  72,"Disk-media error"		
	RTEDEF	AFE, BE_ADVANCED, 73,"Advanced feature unavailable" 
	RTEDEF	RAD, BE_RENAME,   74,"Rename across disks"
	RTEDEF	ACD, BE_ACCESS,   75,"Path/File access error"	
	RTEDEF	PNF, BE_NOTFOUND, 76,"Path not found"

	RTEDEF	UPE, BE_UNPRINT, 255,"Unprintable error"

;******************************************************************************
;
;	MS: Internal Messages of various sorts
;	These are just text messages, not necessarily related to errors.
;
;******************************************************************************
	RTEDEF	,MS_BASE,	8000H		;Base of messages
	RTEDEF	,MS_REDO,	8000H,"Redo from start"		
	RTEDEF	,MS_BYTESFREE,	8001H,<"Bytes free",ASCCR>
	RTEDEF	,MS_ULPROMPT,	8002H		;"Cannot find file (" 
	RTEDEF	,MS_ULPROMPTEND 8003H		;"). Input path: " 
	RTEDEF	,MS_ULERR,	8004H		;"Error in loading file ( " 
	RTEDEF	,MS_ULERREND,	8005H		;") - " 
	RTEDEF	,MS_SEED,	8006H,<"Random-number seed (-32768 to 32767)">	     
	RTEDEF	,MS_HITTORETURN,8007H,"Hit any key to return to system" 
	RTEDEF	,MS_QBEND,	8007H		;End of interp messages

	RTEDEF	,MS_IN, 	8008H," in "
	RTEDEF	,MS_OF, 	8009H," of "
	RTEDEF	,MS_LINE,	800AH,"line "
	RTEDEF	,MS_MODULE,	800BH,"module "
	RTEDEF	,MS_ATADDR,	800CH," at address "
	RTEDEF	,MS_BREAK,	800DH,"*Break*"

;******************************************************************************
;
;	FE: Fatal Errors of various sorts
;
;******************************************************************************
;
;	Errors when line numbers and module names should be valid
;
;**** WARNING: If you change order, add or delete messages, make sure
;**** WARNING: that you notify the interpreter of these changes.


	RTEDEF	,FE_BASE,	9000H
	RTEDEF	SSC,FE_CORRUPT, 9000H,"String space corrupt"	
	RTEDEF	,FE_ULDISK,	9001H		;"Disk I/O error"
	RTEDEF	,FE_ULINVALID,	9002H		;"Invalid format"
	RTEDEF	,FE_ULSEGORDER, 9003H		;"Segment ordering problem"
	RTEDEF	,FE_ULFILE,	9004H		;"Cannot find file"
	RTEDEF	,FE_QBEND	9004H		;End of QB FE "all valid" messages

	RTEDEF	EXE,FE_EXE,	9005H,"Error in EXE file"	
	RTEDEF	,FE_STOP,	9006H,"STOP"
	RTEDEF	OSS,FE_NOSTACK, 9007H,"Out of stack space"    
;
;	Errors when module name should be valid
;
	RTEDEF	,FE_NOLINEBASE, 9400H
	RTEDEF	NOL,FE_NOLINES, 9400H,"No line number in "	
;
;	QB interpreter Initialization errors after Runtime init has
;	succeeded.
;
	RTEDEF	,FE_QBINITBASE, 9700H	
;
;	Errors when NOTHING is valid
;
	RTEDEF	,FE_NOTHINGBASE,  9800H
	RTEDEF	DOS,FE_DOSERR,	  9800H,"Requires DOS 2.10 or later"	
	RTEDEF	LLI,FE_LLINITERR, 9801H,"Error during run-time initialization"	
	RTEDEF	,FE_MEMORY,	  9802H,"Out of memory" 	
	RTEDEF	MEM,FE_DOSMEMERR, 9803H,"DOS memory-arena error"
	RTEDEF	FHC,FE_FHCONSIST, 9804H,"Far heap corrupt"	
;
;	User library loader messages
;
	RTEDEF	,FE_ULMEMALLOC,   9806H 	;"Memory allocation error"
	RTEDEF	,FE_QBNOTHINGEND, 9806H 	;End of QB error messages

;
; Messages that are generated by the interpeter, processed through the runtime
; error handler, and passed on to the intepreter. (9900H)
;
	RTEDEF	,FE_GODIRECT,	  9900H 	


; C message number have been given a high byte of 9Ah.  All these moved
; here with revision [32].

	RCEDEF	,FE_STARTUPBASE,9A00H		; C startup messages
	RCEDEF	,,9A00H,<'R6000',13,10,'- stack overflow',13,10>
	RCEDEF	,,9A02H,<'R6002',13,10,'- floating point not loaded',13,10>
	RCEDEF	,,9A03H,<'R6003',13,10,'- integer divide by 0',13,10>

	; Messages copied and used by DOEXEC (these 3 must be contiguous)
	RXEDEF EX_MSG_BEG,,
	RXEDEF ,9A05H,<13,10,'run-time error R6005',13,10,'- not enough memory on exec',13,10,'$'>
	RXEDEF ,9A06H,<13,10,'run-time error R6006',13,10,'- bad format on exec',13,10,'$'>
	RXEDEF ,9A07H,<13,10,'run-time error R6007',13,10,'- bad environment on exec',13,10,'$'>
	RXEDEF EX_MSG_END,,

; The following messages are required for mixed-language processing and
; internationalization.
	RCEDEF	,,9A08H,<'R6008',13,10,'- not enough space for arguments',13,10>
	RCEDEF	,,9A09H,<'R6009',13,10,'- not enough space for environment',13,10>
	RCEDEF	,,9A0CH,<'R6012',13,10,'- illegal near pointer use',13,10>
	RCEDEF	,,9A0DH,<'R6013',13,10,'- illegal far pointer use',13,10>
	RCEDEF	,,9A0EH,<'R6014',13,10,'- control-BREAK encountered',13,10>
	RCEDEF	,,9A0FH,<'R6015',13,10,'- unexpected interrupt',13,10>
	RCEDEF	,FE_STARTUPEND,9AFFH,<13,10,'run-time error '>	

; Die "really quick" errors.  These have a high byte of '9B'.

;
;	Runtime module loader error messages.
;
	RLEDEF	HeaderErrStr,<"Error in loading RTM: $"> 
	RLEDEF	MemAllocErrStr,<"Memory allocation error","$">	
	RLEDEF	CannotFindStr,<"Cannot find file in PATH","$">	
	RLEDEF	DiskIOErrStr,<"Disk I/O error","$">		
	RLEDEF	InvalidStr,<"Invalid format","$">		
	RLEDEF	OutOfMemStr,<"Out of memory","$">		
	RLEDEF	ArenaBadStr,<"DOS memory-arena error","$">	
	RLEDEF	BadUsrRtmStr,<"Incompatible extended run-time module","$"> 
	RLEDEF	TrailerErrStr,<".",13,10,"$">
	RLEDEF	PathPromptStr,<"Input run-time module path: ","$">	

	.LIST
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\msgshort.inc ===
;msgshort.inc
MSGSHORT_INC	= ON

;===========================================================================
;
;	MSGSHORT.INC - This file is a small subset of the automatically
;			produced qbimsgs.inc/.h (built from 
;			..\ir\basicmsg.doc).
;			Unlike qbimsgs.inc, this file is not updated when
;			basicmsg.doc is. This file is only used for those
;			modules which are tight on symbol space at assembly
;			time. The only message constants that should be
;			hard-coded here are those that are unlikely to be
;			changed (i.e., already existing message constants),
;			and should only be put in on an as-needed basis.
;
;===========================================================================

ER_OM	EQU	 7
ER_DD	EQU	10
ER_ID	EQU	12
ER_CN	EQU	17
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\names.h ===
/*** 
* names.h - external decl.s and constants associated with the name manager
*
*	Copyright <C> 1985, 1986, 1987 Microsoft Corporation
*
*******************************************************************************/

#undef NAMES_H
#define NAMES_H ON


/* external declarations */
VOID NEAR SetONamMask(ushort, uchar);
VOID NEAR ResetONamMaskTmp(ushort, uchar);
VOID NEAR SetONamSpace(ushort, uchar);
VOID NEAR CheckONamSpace(ushort, uchar);	/* [7] */
ushort NEAR FlagOfONam(ushort);
ushort NEAR ONamOfPsd(sd *);
ushort NEAR GetVarNamChar(ushort);
ushort FAR CopyONamBd(ushort, bd *);

ushort FAR BdAppendOgNam(bd *, ushort); /* [1] */
ushort FAR OgNamOfPsd (sd *);					/* [1] */
ushort NEAR OgNamOfPbCb(char *, ushort);	/* [1] */
ushort FAR CopyOgNamPb(char *, ushort);	/* [1] */
ushort NEAR ONamOfOgNam(ushort);				/* [1] */
ushort FAR ONamOfOgNamFar(ushort);				/* [8] */
char FAR CharOfOgNam(ushort);					/* [1] */
ushort FAR CbOfOgNam(ushort);					/* [1] */


/* flag bit constants used in the flags word of a name table entry 				*/
#define NM_fShared 0x01		/* bit 0 - TRUE (set) if exists a module SHARED 
											  	  variable of this name							*/
#define NM_fLineNum 0x02	/* bit 1 - TRUE if symbol entry is for a line number
												  this flag can only be set by the NameMgr
													and can never be reset. */
#define NM_fLineNumLabel 0x04
									/* bit 2 - TRUE if symbol entry is either a line
												  number or a label - this bit is used
												  by the text mgr to detect duplicate
												  label definitions. */
#define NM_fAs 0x08			/* bit 3 - TRUE if "x AS" clause exists in module	*/
/* unused:			0x0010	bit 4	*/
/* unused:			0x0020	bit 5	*/

/* CONSIDER: if we run out of bits here, the following enumerated 2 bits would
	CONSIDER: be an ideal candidate for moving in as the high two bits of the
	CONSIDER: NAM_SIZE field (only 6-bits are needed for the size of the largest
	CONSIDER: legal name). A definite cost to this, however, is name table
	CONSIDER: search speed (speed cost of masking the NAM_SIZE field).
									/* enumerated constants for bits 6 & 7					*/
#define NMSP_UNDEFINED	0x00
									/* initial value of this 2-bit field					*/
#define NMSP_Procedure	0x40
									/* passed by txtmgr when it inserts a ref. to a
										prs in the module											*/
#define NMSP_Variable	0x80
									/* set by MakeVariable when creating a variable 
										table entry that's not a constant or a proc		*/
#define NMSP_MASK			0xC0
									/* used to isolate this 2-bit enumerated field		*/

#define CB_MAX_NAMENTRY	255d	/* [3] max. length of a name in the name table.
											[3] do NOT confuse this with CB_IDNAM_MAX!	*/

/* Non-RELEASE and DEBUG name table macros */

#define DbOoNam(oNam) 
#define DbOogNam(ogNam) 			/* [2] */
#define DbOtNam 
#define DbOtgNam 						/* [2] */
#define DbChkoNam(oNam) 
#define DbChkogNam(ogNam) 			/* [2] */
#define DbChktNam 
#define DbChktgNam 					/* [2] */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\parser.h ===
/* File: parser.h - Defines which apply to the QBI Parser               */
/* NOTE: !!!see PARSER.INC for comments!!!                              */
/* NOTE: When making changes to this file, be sure to make equivalent   */
/*       changes to file PARSER.INC                                     */

#undef PARSER_H
#define PARSER_H ON        /* remember that this file has been included */

#if !HEAP_H
# include "heap.h"
#endif

#define CB_PCODE_MIN 20

typedef struct psType {
   char ldDummy[4];
   bdp bdpSrc;
   ushort otxLine;
   uchar flags;
   uchar tEtCur[26];
   uchar filler;
   bdp bdpDst;
   bd bdErr;
   ushort errCode;
   ushort oSrcErr;
} psType;

/* Masks for ps.errCode */
#define PSERR_fAsciiMsg 0x8000
#define PSERR_fRude 0x4000
#define PSERR_fAlert 0x2000
/* bits 0x1000, 0x0800, and 0x400 are unused */
#define PSERR_errCode 0x03FF

void FAR ParseInit(void);
void FAR ParseNewInit(void);
boolean FAR SetPsBufSz(char *);
boolean near ParseLine(void);
boolean FAR ListStdMsgToBd(ushort, bd *);
void NEAR MakeOpReParse(void);
ushort FAR ListIRW(ushort);

/* parser component global data declarations */
/* These are actually declared in qbidata.c, which defines EXTERNAL as "" */
EXTERNAL psType ps;                 /* parser's Entry/Exit parm structure */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\msdos.inc ===
;msdos.inc - MSDOS 2.x and 3.x low level macros and definitions.

;
; This is the simplest type of macro for making MSDOS 2.x/3.x calls.
; It does no error checking or status returns.
;
; The "function" is an integer constant only specifying the true call.
;
; The "string" is optional for specifying the value put into DX and is
; treated as an offset within dgroup.
;
; The "length" is option for specifying an integer value for placement
; in the CX register.
;

callos	macro function,string,length

ifnb <string>
	lea	dx,string
endif

ifnb <length>
	mov	cx,length
endif

	mov	ah,function
	int	21h

	endm

;
; Some common functions used in BIC
;

Msdos_Display_Char		= 2	;Send char to display
Msdos_Print_Char		= 5	;Send char to printer
Msdos_Put_Display		= 6	;Send char to display, no ctrl-c check.
Msdos_Get_Kybd			= 7	;Get key with no echo or ctrl-c check.
Msdos_Put_String		= 9	;Send $ terminated string to display.
Msdos_Get_Kybd_Status		= 11	;Get keyboard status.
Msdos_Reset_Drive		= 13	;Reset Current drive.
Msdos_Select_Drive		= 14	;Select drive.
Msdos_Get_Current_Drive		= 25	;Get current disk drive number.
Msdos_Set_DMA			= 26	;Set current DMA address.
Msdos_Get_Date			= 2Ah	;Get current Date.
Msdos_Get_Time			= 2Ch	;Get current Time.
Msdos_Get_DMA			= 2Fh	;Get current DMA address.
Msdos_Get_DOS_Version		= 30h	;Get's current DOS version number.
Msdos_Keep_Process		= 31h	;Terminate and stay resident.
Msdos_Get_Disk_Free		= 36h	;Get current Free disk blocks.
Msdos_Create_Directory		= 39h	;Create sub directory.
Msdos_Remove_Directory		= 3Ah	;Remove sub directory.
Msdos_Change_Directory		= 3Bh	;Change sub directories.
Msdos_Create_File		= 3Ch	;Create file (2.x style)
Msdos_Open_File			= 3Dh	;Open file (2.x style)
Msdos_Close_File		= 3Eh	;Close file (2.x style)
Msdos_Read_File			= 3Fh	;Read file (2.x style)
Msdos_Write_File		= 40h	;Write file (2.x style)
Msdos_Kill_File			= 41h	;Delete file (2.x style)
Msdos_Move_File_Pointer		= 42h	;Lseek() function.
Msdos_Change_File		= 43h	;Chmod() function.
Msdos_IO_Ctl			= 44h	;IO Control function for devices.
Msdos_Get_Current_Directory	= 47h	;Returns text of current directory.
Msdos_Alloc_Memory		= 48h	;Allocate additional memory.
Msdos_Free_Memory		= 49h	;Free additional memory.
Msdos_Modify_Memory		= 4Ah	;Modify allocated additional memory.
Msdos_Exec			= 4Bh	;Load and/or execute program.
Msdos_Terminate			= 4Ch	;Terminate job.
Msdos_Get_Child_Status		= 4Dh	;Gets Child's return status.
Msdos_Find_File			= 4Eh	;Find first occurance of file.
Msdos_Find_Next			= 4Fh	;Find next occurance of file.
Msdos_Move_File			= 56h	;Move file entry to newname/directory.
Msdos_Get_Error			= 59h	;Get MSDOS's extended error code.
Msdos_Create_Temporary_File	= 5Ah	;Create unique file.
Msdos_Create_New_File		= 5Bh	;Create file with unique name.
Msdos_Lock_Unlock_File		= 5Ch	;3.x file locking code.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\names.inc ===
;*** 
;names.inc
;
;	Copyright <C> 1985, 1986, 1987 Microsoft Corporation
;
;
;*******************************************************************************
;
NAMES_INC = ON
;
;The name table is composed of symbol elements linked together.  Each element
;has the following structure:
NM_NEXT 	EQU	0	;offset to next symbol element
NM_FLAGS	EQU	2	;Flag byte
NM_SIZE 	EQU	3	;# of bytes in NM_BUF
NM_NAME 	EQU	4	;ASCII chars that make up the symbol name

;NM_FLAGS consist of the following
NM_fShared	EQU	01	;TRUE if MakeVariable search logic should search
				;     the module level table for this symbol,
				;     even if there's an active procedure.
NM_fLineNum	EQU	02	;TRUE if symbol entry is for a line number
				;     this flag can only be set by the NameMgr
				;     and can never be reset.
NM_fLineNumLabel EQU	04	;TRUE if symbol entry is either a line number
				;     or a label - this bit is only used by
				;     the text mgr.
NM_fAS		EQU	08H	;TRUE if "x AS" clause exists anywhere in
				;     this module
;Unused:	EQU	010H	;bit 4 unused
;Unused:	EQU	020H	;bit 5 unused
;
				;enumerated constants for bits 6 & 7
NMSP_UNDEFINED	EQU	000H	;initial value of this 2-bit field
NMSP_Sub	EQU	040H	;Set by PrsDefine & PrsMake when creating a
				;prs for a SUB. VarMgr deals w/FUNCTIONs & DEFs
NMSP_Variable	EQU	080H	;passed by MakeVariable when creating a non-
				;constant variable table entry
NMSP_MASK	EQU	0C0H	;used to isolate this 2-bit enumerated field

CB_MAX_NAMENTRY	EQU	255d	; max. length of a name in the name table.
;				; NOTE: DON'T confuse this with CB_IDNAM_MAX!

;----------------------------------------------------------------------------
;The following define offsets into the name table
;----------------------------------------------------------------------------
tNam	= 0			;1st word of the name table - this is also the
				;location of the 1st entry of the chain header
				;table (1st char hash).  The main advantage of
				;tNam being 0 is that oNam's can be used as
				;pointers rather than offsets; saving the time
				;that would otherwise be needed to load the
				;base address.	This scheme works because tNam
				;is a far heap entry.
LineNumHdr1st = tNam+64           ;First Line number chain header
LineNumHdrLast = LineNumHdr1st+16 ;Last  Line number chain header
cbUsed = LineNumHdrLast+2         ;# of cbLogical bytes that have been allocated
			          ;ie - are actually being used.
CurONamHdr = cbUsed+2	          ;scratch variable used by GetNextONam to
			          ;remember which 1st char header chain to look
			          ;in when it reaches the end of it's current
			          ;chain
oNamFirst = CurONamHdr+2          ;1st symbol entry


NM_INIT_TABLE_SZ = oNamFirst + NM_NAME + CB_MAX_NAMENTRY
				;space for hash tables + one entry with max.
				;  name length
;============================================================================
;NamMgr debugging stuff
;============================================================================

;----------------------------------------------------------------------------
;macro to dump all the NM_NAME field of a symbol in tNam
;----------------------------------------------------------------------------
DbOoNam macro	oNam
endm	;DbOoNam

;----------------------------------------------------------------------------
;macro to dump all the fields of every symbol in tNam
;----------------------------------------------------------------------------
DbOtNam macro
endm	;DbOtNam

;============================================================================
;the following EXTRN's are included in ALL files EXCEPT namdebug.asm
;============================================================================


ife	NAMDEBUG_ASM


endif	;NAMDEBUG_ASM

;============================================================================
;the following EXTRN's are included in ALL files EXCEPT nammgr.asm
;============================================================================

ife	NAMMGR_ASM
sBegin	CP

	extrn	ONamOfPsd:near
	extrn	ONamOfPbCb:near
	extrn	ONamOfLn:near
	extrn	CopyONamPb:far
	extrn	TNamInit:near
	extrn	FlagOfoNam:near
	extrn	LnOfoNam:far
	extrn	SetONamMask:near
	extrn	SetONamSpace:near
	extrn	CheckONamSpace:near	
	extrn	ResetTNamMask:near
	extrn	ResetONamMask:near
	extrn	GetNextONam:near
	extrn	GetVarNamChar:near
	extrn	OgNamOfPsd:far		
	extrn	OgNamOfPbCb:near	
	extrn	CopyOgNamPb:far		
	extrn	CopyOgNamPbNear:near	
	extrn	FpNamOfOgNam:near	
	extrn	OgNamOfONam:near	
	extrn	ONamOfOgNam:near	
	extrn	ONamOfOgNamFar:far	
	extrn	CmpOgNamIns:near	
	extrn	CharOfOgNam:far		
	extrn	CbOfOgNam:far		
	extrn	BdAppendOgNam:far	
	extrn	CopyONamBd:near

sEnd	CP
endif	;ife NAMMGR_ASM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\pcode.inc ===
;*** 
;pcode.inc
;
;	Copyright <C> 1986, 1987 Microsoft Corporation
;
;Purpose:
; This include file contains constants which refer to operands in pcode
; See rtps.inc for constants which are known be the runtime as well.
;
;
;*******************************************************************************


OPCODE_MASK	=	03FFH	;Opcode is in lowest 10 bits of the word

;-----------------------------------------------------------------
;offsets into opStDeclare, opStSub, opStFunction pcodes:
; (for opStDefFn, add 2 to all but DCL_cntEos)
;
;****************************************************************************
;****************************************************************************
;** [x] WARNING: The format of the pcode for opStDeclare, et al., is       **
;**              exported to Omega so they can type check parameters.      **
;**              Any changes made here MUST be reflected in \eb\hd\ebapi.h **
;****************************************************************************
;****************************************************************************
;
DCL_cntEos	EQU 0		;# bytes from DCL_oPrs field to next opcode
DCL_oPrs	EQU 2		;identifies prs being declared/defined
DCL_atr		EQU 4		;misc attributes for the prs (see DCLA_xxx)
DCL_cParms	EQU 6		;number of formal parameters
				; 0 means proc takes no parameters.
				; In opStDeclare, UNDEFINED means user
				; didn't specify a parameter list in
				; the DECLARE, so no parm type checking
				; should be done.

;DCL_cParms field is followed by 3 words per parameter (DCLP_xxx) and
; then by the ASCII name of the alias (if any)

  ;Masks for values in the DCL_atr word
  DCLA_cdecl	EQU 8000h	;TRUE if DECLARE has CDECL keyword
  DCLA_cbAlias	EQU 7C00h	;#bytes of alias-name (0 if no alias)
  DCLA_procType	EQU 0300h	;always PT_SUB, PT_FUNCTION or PT_DEFFN
  DCLA_Explicit	EQU 0080h	;FUNCTION or DEF FN was explicitly typed
				; via a type char or its type was declared
				; by as AS clause.
  DCLA_oTyp	EQU 007Fh	

 ;Offsets into formal parameter blocks:
 DCLP_id	EQU 0		;For DECLARE, this is always the oNam of
				; the formal.  For SUB, FUNC, DEF FN,
				; this is the oNam in SS_RUDE, or the
				; oVar in SS_PARSE or SS_EXECUTE
 DCLP_atr	EQU 2		;Formal parm attributes (PATR_xxx)
 DCLP_oTyp	EQU 4		;Type of the formal parm as follows:
	  ;If scan-state = SS_RUDE AND
	  ;   neither PATR_fAsClause or PATR_fExplicit are set:
	  ;     oTyp field contains garbage.  Parameter's type is implicit
	  ;     and depends depends on preceeding DEF<type> statements.
	  ;Else if scan-state = SS_RUDE AND
	  ;   either PATR_fAsClause or PATR_fExplicit are set:
	  ;     oTyp = 0                  - AS ANY
	  ;     oTyp = 1 to ET_MAX        - AS INTEGER to STRING or % to $
	  ;     oTyp > ET_MAX             - AS <user type>, since its SS_RUDE,
	  ;				      this field is an oNam for
	  ;				      the user defined type
	  ;  Else if scan-state <> SS_RUDE:
	  ;       oTyp = 0                  - AS ANY
	  ;       oTyp = 1 to ET_MAX        - AS INTEGER to STRING or % to $
	  ;       oTyp > ET_MAX             - AS <user type>, field = oTyp for
	  ;				      user defined type
	  ;  NOTE: Fixed length strings are not allowed as DECLARE, SUB,
	  ;	FUNCTION or DEF FN parameter lists.

;Formal parameter attribute masks (found in parameter lists of opStDeclare,
; opStSub, opStFunction, and opStDefFn opcodes)
;Note: In addition to varmgr input flag dependancies on the below,
;	There also exist dependancies on these constants in ssproc.asm.
PATR_oTyp		EQU 000FH	;used to store oTyp for special cases
PATR_explicit		EQU 0200H	;set if explicit type char %&!#$

PATR_SEG		EQU 0800H	;set if BYSEG was found
					; Must = SegFlag in ssproc.asm
PATR_BYVAL		EQU 1000H	;set if BYVAL was found
					; Must = ByValFlag in ssproc.asm
PATR_array		EQU 0400H	;set if param is an array
					; Must = FVFORCEARRAY
PATR_asClause		EQU 2000H	;set if an AS clause is present
					; Must = FVASCLAUSE

;-----------------------------------------------------------------
; opLine operand constants:
;
LINEBF_none		EQU 0
LINEBF_B		EQU 1
LINEBF_BF		EQU 2

CB_EMPTY_TEXT	equ	4+StartOtx ;size of empty text table (opEndProg + opEot)
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\pointers.inc ===
;***
;pointers.inc - 30-Dec-87 - pointer reference macros
;***
	IFNDEF	LI_EXPAND
	.XLIST
	ENDIF
;***
;
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	To provide a set of macros for pointer reference whether they are
;	NEAR (1-word) or FAR (2-word).	FAR pointers may also have an SB
;	index instead of a true physical segment.
;
;	NOTE: This is a SHARED INCLUDE FILE, used by both the RUNTIME and
;	NOTE: the interpreter projects.  Any changes made to one should
;	NOTE: be carried over (COPIED) to the other!!!
;
;
;******************************************************************************

POINTERS_INC = -1   ;needed by QBI sources which also include this file.

;FV_SBPTR determines the type of 2-word pointers used in manipulating
;Far Heap and some Near Heap accesses.	When OFF, these pointers contain
;an actual physical segment.  When ON, they contain an SB (Segment Base)
;which is an index to a table containing the actual physical segment.
;The following MACRO's attempt to hide these differences.

;FV_SBSWAP is ON if an SB can be swapped out of active memory.  (Swapped
;to disk or out of active EMM.)

;Added with [11]
;***
;GetCodeIntoDs
;
;Purpose:
;	Loads DS with the segment of the executors.
;Input:
;	Optional - name of current segment.  Causes a call to TxtSegCur 
;	if OE_WIN.
;Output:
;	No registers affected (except DS), although memory movement may occur if 
;	OE_WIN, invalidating ES.  ES will be restored to the text segment 
;	if name of current segment is given.
;	Flags destroyed if OE_WIN.

sBegin	DATA
	extrn	SegCode:word
sEnd	DATA

GetCodeIntoDs	MACRO	parm
	mov	ds,[SegCode]
	ENDM
;End of [11]

;***
;GETSB_SEG - macro to get an SB's physical segment
;
;Purpose:
;	Added with [2].
;	This macro allows us to access the physical segment of an SB.
;Entry:
;	dest -	register in which the SB physical segment is to be placed
;	srce -	the SB index
;	temp -	a temporary register is required and should be used only when:
;		    SPEED, NOLOAD, (NOT FIXED) temp must be index reg
;		    SPEED, LOAD,   (NOT FIXED) temp must be index reg != dest
;		    SPEED, LOAD,   FIXED
;		    SIZE,  NOLOAD, FIXED
;		    SIZE,  LOAD,   FIXED
;	opt  -	any combination of the following options:
;		    SIZE to optimize macro code for size
;		    SPEED to optimize macro code for speed (default)
;		    LOAD tests for and reloads non-resident blocks
;		    NOLOAD no test or reload (default)
;		    FIXED if 'srce' is a fixed SB constant
;			(FIXED is also implied if srce is a constant)
;		    NOFLUSH to prohibit the flushing of all EMM blocks in
;			non-release versions
;		    FLUSH to cause EMM flushing (default)
;
;Exit:
;	register 'dest' contains the SB physical segment of 'srce'.
;Notes:
;	ES and DS are always preserved (when != dest) for SPEED and NOLOAD.
;	ES and DS are preserved (when != dest) for SIZE or LOAD if:
;	    -- it is psCur, or
;	    -- it is locked, or
;	    -- it is not-EMM and (non-swappable OR non-discardable)
;	When a desired option is important it should be specified rather
;	    than defaulted so that the defaults may be changed.
;Examples:
;	GETSB_SEG   es,[grs.GRS_sbVar],,<SIZE,LOAD>
;	GETSB_SEG   ds,bx,bx,<SPEED,NOLOAD>
;
;**************************************************************************
GETSB_SEG   MACRO   dest,srce,temp,opt
	LOCAL	NoReload
	?sz = 0 			;;default SPEED (not SIZE)
	?ld = 0 			;;default NOLOAD (not LOAD)
	?fx = 0 			;;default not FIXED
	?fl = 1 			;;default FLUSH

	irp x,<opt>
	  ifidni <x>,<SIZE>		;;if SIZE,
	    ?sz=1			;;  set size flag
	  elseifidni <x>,<SPEED>	;;if SPEED,
	    ?sz=0			;;  clr size flag
	  elseifidni <x>,<LOAD> 	;;if LOAD,
	    ?ld=1			;;  set load flag
	  elseifidni <x>,<NOLOAD>	;;if NOLOAD
	    ?ld=0			;;  clr load flag
	  elseifidni <x>,<FIXED>	;;if FIXED
	    ?fx=1			;;  set fixed flag
	  elseifidni <x>,<FLUSH>	;;if FLUSH
	    ?fl=1			;;set flush flag
	  elseifidni <x>,<NOFLUSH>	;;if NOFLUSH
	    ?fl=0			;;clr flush flag
	  else
	    if1
	      %out invalid GETSB_SEG option: &x
	    endif
	    .err ;invalid GETSB_SEG option
	  endif
	endm

	?sz = 0 			;;  always SPEED
	?ld = 0 			;;  and NOLOAD
	?fl = 0 			;;and NOFLUSH

	?fl = 0 			;;NOFLUSH in RELEASE versions

if (.type srce) and 04H 		;;if srce is a constant
	?fx = 1 			;;  must be a FIXED SB
endif

if ?sz AND ?fx AND NOT ?ld		;;SIZE & FIXED & !LOAD is actually
	?sz = 0 			;;  smaller as !SIZE
endif

if ?sz					;;SIZE
  if ?fx				;;  FIXED
	mov	temp,srce		;;    can't push constant
	push	temp
  else					;;  not FIXED
	push	srce			;;    sb arg to call on stack
  endif

  if ?fl				;;if EMM flushing desired
      % extrn	Flush_&&?segname:near	;;then do it
      % call	Flush_&&?segname	;
  endif 				;
      % extrn	DerefSb_&&?segname:near ;
      % call	DerefSb_&&?segname	;;top of stack = phys seg
	pop	dest			;;dest = phys seg
else					;;SPEED version
  if ?fx				;;  FIXED

    if ?fl				;;if EMM flushing desired
      % extrn	Flush_&&?segname:near	;;then do it
      % call	Flush_&&?segname	;
    endif				;

	mov	dest,mpsbps[srce*2]	;;    fetch seg direct from sb table
  else					;;  not FIXED
    ifdifi  <temp>,<srce>		;;    if temp != srce
	mov	temp,srce		;;	temp = srce  (SB)
    endif

    if ?fl				;;if EMM flushing desired
      % extrn	Flush_&&?segname:near	;;then do it
      % call	Flush_&&?segname	;
    endif				;

	shl	temp,1			;;    shift to make it a table index
	mov	dest,mpsbps[temp]	;;    fetch seg from sb table
  endif
  if ?ld				;;  LOAD
    ifidni  <dest>,<ds> 		;;if dest == ds
	?over	EQU <BYTE PTR SS>	;;  force SS override to DGROUP
    else				;;else
	?over	EQU <BYTE PTR DGROUP>	;;  insure DGROUP
    endif				;
    if ?fx				;
	test	?over:mpsbps[srce*2],1	;;test for resident segment
    else				;
	test	?over:mpsbps[temp],1	;;test for resident segment
      ifidni <dest>,<temp>		;;temp must be != dest here
	if1				;
	  %out temp == dest not allowed here;
	endif				;
	.err ;temp == dest not allowed here   [10]
      endif				;
    endif				;
	jnz	NoReload		;;skip reload if resident
    if ?fx
	mov	temp,srce		;
    else				;
	shr	temp,1			;;restore SB index
    endif
	push	temp			;
      % extrn	DerefSb_&&?segname:near ;
      % call	DerefSb_&&?segname	;;top of stack = phys seg
	pop	dest			;;dest = phys seg

NoReload:				;
  endif   ;;LOAD
endif	;;SIZE/SPEED
	ENDM


DGROUPSEG   EQU <SS>	;DGROUP is in SS


;***
;GETSEG - macro to access the physical segment of a far heap descriptor.
;
;Purpose:
;	Rewritten with [2].
;	This macro allows us to access the segment of a far heap descriptor
;	in different ways, depending on our far heap code support scheme.
;Entry:
;	see GETSB_SEG.
;Exit:
;	register 'dest' contains the physical segment address.
;
;**************************************************************************
GETSEG	MACRO	dest,srce,temp,opt

    ifdifi <dest>,<srce>
	mov	dest,srce		;;fetch seg address directly
endif
	ENDM

;***
;GETPTR - macro for FAR/HUGE pointer reference
;
;Purpose:
;	Rewritten with [2].
;
;	This macro allows us to use a pointer whether it be FAR (with actual
;	physical segment) or HUGE (with an SB segment).
;	HUGE pointers are used when FV_SBPTR is on.
;
;	The result will always be a FAR pointer (with actual physical segment)
;	in a register pair.
;
;Entry:
;	alias - the name to use for subsequent pointer reference.
;	seg   - register to receive the physical segment.
;		seg must be a segment register to use alias.
;	reg   - register to receive the address offset of the pointer.
;		reg must be an index register to use alias.
;	srce  - source of the pointer.  Must be defined with parmDP or localDP.
;	temp  - the temporary register to use for dereferencing the SB.
;		If not provided, reg will be used (see GETSEG).
;	opt   - see GETSB_SEG.
;Exit:
;	seg:[reg] - contains the physical pointer
;	alias	  - is a name (equated to seg:[reg]) to use when referencing
;		    the pointer, so long as seg and reg remain undisturbed.
;**************************************************************************
GETPTR	MACRO alias,seg,reg,srce,temp,opt
ifnb	<alias>
alias	equ	seg:[reg]		;;  set up alias
endif
  ifidni <seg>,<es>
	les	reg,srce		;;  optimize segreg ES load wo/SB
  elseifidni <seg>,<ds>
	lds	reg,srce		;;  optimize segreg DS load wo/SB
  else
	mov	seg,SEG_&srce		;;  load seg (not a segreg)
	mov	reg,OFF_&srce		;;  and get offset
  endif
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\parser.inc ===
; File: PARSER.INC
; NOTE: When making changes to this file, be sure to make equivalent
;	changes to file PARSER.H
; NOTE: For comments, see parser.h

PARSER_INC = -1			;remember that this file has been included
	IncludeOnce	heap

PERIOD_ID EQU TRUE		;temp switch - "." is a record separator

;**======================================================================**
;**==           External Interface to Parser Component                 ==**
;**======================================================================**

;CB_PCODE_MIN is used to ensure we never ps.bdpDst or grs.bdlDirect
;get so small so we can't execute a SYSTEM, SETMEM, or CLEAR stmt 
;in direct mode.
;
CB_PCODE_MIN EQU 20d

;**==================== parser interface descriptor ======================
;** The global  structure 'ps'  is used  to pass  inputs to  the
;** parser and receive the parser's results.
;**=======================================================================

PS_STRUCT		STRUC
;ParseLine INPUT source buffer for line to be parsed
PS_ldDummy	    DB 4 dup(0)
;ldDummy MUST immediately precede bdpSrc.  Used by TWIN
;The TWIN ld structure is layed over ldDummy and bdpSrc as follows:
;
;+-----------------------+----------+\
;| ldDummy[0]-ldDummy[1] | ld.flags | \
;+-----------------------+----------+  > Used only by TWIN (EditMgr)
;| ldDummy[2]-ldDummy[3] | ld.cb    | /
;+-----------------------+----------+<
;| bdpSrc.cbLogical	 | ld.cbMax | \
;+-----------------------+----------+  > Common data
;| bdpSrc.pb		 | ld.prgch | /
;+-----------------------+----------+/
;

PS_bdpSrc	DB SIZE BDP DUP(0) ;bdp for source buffer
PS_otxLine	DW 0		;text offset into current text table
				;where this line is being inserted.

;ParseLine INPUT/OUTPUT fields
PS_flags	DB 0		;see PSF_xxx below
PS_tEtCur	DB 26 DUP(0)
				;contains the default variable types
				;for where this statement is being
				;inserted in the text table. tEtCur[26]
				;is always ET_R4 for FN.xxx
PS_filler	DB 0		;round up to even byte boundary

;ParseLine OUTPUT fields

PS_bdpDst	DB SIZE BDP DUP(0) ;bdp for dest buffer
PS_bdErr	DB SIZE BD DUP(0)  ;bd for error buffer
PS_errCode	DW 0		;parser's error code
PS_oSrcErr	DW 0		;offset into src buffer where
				;  error occured
PS_STRUCT		ENDS

;PS_flags masks:
PSF_fParseExp		EQU 01h		;INPUT FLAG
   ;set if parser is to parse just an expression,
   ;zero if it is to parse a source line
PSF_fRetry		EQU 02h		;OUTPUT FLAG
   ;set if caller should call ParseLine again
   ;This is caused by parser non-terminals that require current
   ;text table to be in SS_RUDE state, like a COMMON statement.
   ;If current table isn't, we call AskCantCont, and if the user says
   ;ok to not continue, this flag is set.
PSF_UndoEdit		EQU 04h		;OUTPUT FLAG
   ;set if user wants to back out of this edit.
   ;Similar senerio to PSF_fRetry, but if this gets set if the user
   ;responds to AskCantCont with CANCEL.
PSF_fRef		EQU 08h		;OUTPUT FLAG
   ;If any labels or variables were referenced, on output, this is set,
   ;so the text manager knows to scan the whole program if the parsed
   ;statement was in direct mode.
PSF_fRudeIfErr		EQU 10h		;OUTPUT FLAG
   ;if non-zero, caller must call ModuleRudeEdit if line gets inserted
   ;as opReParse or doesn't get inserted at all (ie out-of-memory).
PSF_fLabelRef		EQU 20h		;OUTPUT FLAG
   ;If any labels were referenced this is set
   ;so the text manager can do an AskCantCont when the user tries to
   ;edit the program while there are label references within
   ;an active direct mode statement


;PS_errCode masks:
PSERR_fAsciiMsg		EQU 8000H
   ;Set if parser built an ASCII error message in ps.bdErr.
   ;Else, ps.errCode & PSERR_errCode = offset into QBI message table
   ;(i.e. ER_xxx or MSG_xxx)
   ;bits 1000, 0800, and 400 are unused
PSERR_fRude		EQU 4000H
   ;Set if varmgr has returned a RudeEdit error
PSERR_fAlert		EQU 2000H
   ;Set if error should be reported at entry time (FALSE if error should
   ;only be reported at ReParse time - just before RUN)
PSERR_errCode		EQU 03FFH

;Types of literal constants recognized by parser
;
OrdConstStart 0
OrdConst LIT_I2		; % suffix
OrdConst LIT_O2		; &O prefix
OrdConst LIT_H2		; &H prefix
OrdConst LIT_I4		; & suffix
OrdConst LIT_O4		; &&O prefix
OrdConst LIT_H4		; &&H prefix
OrdConst LIT_R4		; ! suffix
OrdConst LIT_R8		; # suffix
OrdConst LIT_STR	; "xxx"

;The parser compresses text strings in REMarks.  The lister expands this
;text. An encoded string record contains 3 bytes.
;	Compression STRUCT
;		fCompressed	DB 0DH
;		cRepeat 	DB ?
;		ch		DB ?
;	Compression ENDS
;The first byte is a flag identifying the char as a compression record.
;The second byte is a count of the number of characters which were compressed.
;The third byte is the character which was compressed.
;This encoding significantly cuts down the size of REMarks with sequential
;runs of characters.
;  For example, a string of 50 ' 's (spaces) is represented as:
;	0DH 32H 20H
;A single <CR> embedded in a line. Could be represented as with a compression
;record of:
;	0DH 01H 0DH
;0DH was chosen as the compresion flag since it is very difficult to embed
;a 0DH in a REM without having in interpreted as an end of line.

STR_EncodedText EQU 0DH



sBegin CP
ife	PRSUTIL_ASM
	EXTRN	ListStdMsgToBd:far
	EXTRN	CheckFreeDstBuf:near
	EXTRN	Emit16:near
	EXTRN	Emit16_AX:near
	EXTRN	ListIRW:far
endif	;PRSUTIL_ASM

ife	PRSNT_ASM
	EXTRN	SetDefBits:far
endif

ife	PRSMAIN_ASM
	EXTRN	ParseInit:far
	EXTRN	ParseNewInit:far
	EXTRN	ParseLine:near
	EXTRN	MakeOpReParse:near
	EXTRN	ParseUndo:near
	EXTRN	ResetDstPbCur:near
	EXTRN	SetDstPbCur:near
	EXTRN	SetPsBufSz:far
endif	;PRSMAIN_ASM

sEnd	CP

sBegin DATA
	EXTRN	ps:BYTE	

sEnd	DATA
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\qblist.inc ===
; File: QBLIST.INC

QBLIST_INC = -1 		 ;remember that this file has been included

;**======================================================================**
;**==		External Interface to QBC Lister support component.    ==**
;**======================================================================**

ife	QBLIST_ASM

sBegin	DATA
	EXTRN	txdCur:BYTE
	EXTRN	prsCur:BYTE
sEnd	DATA

	EXTRN	BdAlloc:FAR
	EXTRN	BdGrow:FAR
	EXTRN	BdRealloc:FAR
	EXTRN	BdlAlloc:FAR
	EXTRN	BdlRealloc:FAR


sBegin	CP
	EXTRN	UpdChanCur:NEAR
	EXTRN	LnOfONam:FAR
	EXTRN	CopyONamPb:FAR
	EXTRN	FieldsOfPrsFar:FAR
	EXTRN	ONamOvarRudeOrParse:FAR
	EXTRN	RelTempSd_CP:NEAR

;	Stubs for routines which should never be called by lister.

	EXTRN	ONamOElem:FAR
	EXTRN	ONamOTyp:FAR
	EXTRN	OTypOfONamDefault:FAR
sEnd	CP

endif	;QBLIST_ASM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\psint.h ===
/* File: psint.h - Defines which apply to the QBI Parser                */
/* NOTE: When making changes to this file, be sure to make equivalent   */
/*       changes to file psint.inc                                      */

#undef PSINT_H
#define PSINT_H ON         /* remember that this file has been included */

#if !HEAP_H
# include "heap.h"
#endif

/**======================================================================**
 **==       Internal Interface to Parser Component                     ==**
 **==       This file is only included by parser-component modules     ==**
 **======================================================================**/

#define EmitOpcode(x) Emit16(x)

/* Types of literal constants recognized by Fin and FetchToken/ScanToken */
#define  LIT_I2   0     /* % suffix */
#define  LIT_B2   1     /* &B prefix */
#define  LIT_O2   2     /* &O prefix */
#define  LIT_H2   3     /* &H prefix */
#define  LIT_I4   4     /* & suffix */
#define  LIT_B4   5     /* &&B prefix */
#define  LIT_O4   6     /* &&O prefix */
#define  LIT_H4   7     /* &&H prefix */
#define  LIT_R4   8     /* ! suffix */
#define  LIT_R8   9     /* # suffix */
#define  LIT_STR  10    /* "xxx" */

/**==================== value descriptor =================================
 ** this structure describes literal values returned by the lexical analyzer
 **=======================================================================**/

typedef struct litValue {
   ushort errCode;            /* error code reported by Fin (0 if none) */
   char type;                 /* ET_I2, ET_I4, ET_R4, ET_R8, ET_STR */
   char litType;              /* LIT_I2, LIT_I4, LIT_R4, LIT_R8,
                                 LIT_B2, LIT_H2, LIT_O2, LIT_J2, LIT_K2,
                                 LIT_B4, LIT_H4, LIT_O4, LIT_STR */
   union {
      short I2;               /* 16 bit signed integer literal */
      ushort USI2;            /* 16 bit unsigned integer literal */
      long I4;                /* 32 bit signed integer literal */
      ulong USI4;             /* 32 bit unsigned integer literal */
      FLOAT R4;               /* 32 bit real literal */
      DOUBLE R8;              /* 64 bit real literal */
      ushort cbStr;           /* byte count of string literal recognized
                                 by FetchTok() */
      } value;
   } litValue;

/**==================== token descriptor ==================================
 ** tok - (token descriptor) describes tokens returned by the lexical analyzer
 **=======================================================================**/

typedef struct tok {
   ushort class;              /*  token class - CL_xxx defined below */
   ushort oSrc;               /* offset into ps.bdpSrc where token started */
   union dsc {
      struct rw {
         ushort iRw;          /* unique index for res word (IRW_ELSE etc) */
         ushort rwf;          /* flags for this reserved word (RWF_xxx)
                                 which begin with this opcode */
         ushort iOperator;    /* index into operator table for operator with
                                 this name.  UNDEFINED if none exists. */
         char *pArgs;         /* pointer into reserved word table to list
                                 of args for reserved word */
         } rw;                /* valid when class = resword */
      struct id {
         ushort oNam;         /* name table offset for identifier */
         ushort oTyp;         /* Explicit enumerated type i.e. ET_I2 */
         ushort vmFlags;      /* varmgr flags FNVLVAL etc. - see variable.h */
         char charFirst;      /* Ucase(1st letter of id) */
         char termchar;
	 uchar lexFlags;      /* lexical analyzer flags */
	 uchar filler;	      /* pad to even byte length */
         } id;                /* valid when class = id */
      litValue lit;           /* valid when class = lit */
      char unknownChar;       /* valid when class = unknownChar */
      } dsc;
   } tok;

/* tok.id.lexFlags flags */
#define FLX_hasPeriod 01   /* TRUE if current token has a '.' in its name */

/* Enumerations for tok.class */
#define CL_RESWORD 0       /* reserved word or special character like & */
#define CL_ID 1            /* alphanumeric identifier */
#define CL_LIT 2           /* numeric or string constant */
#define CL_UNKNOWNCHAR 3   /* lexical analyzer encountered an unknown char */

/* PARSE_RESULT is the type returned by Parse() and functions which
   recognize non-terminals.  The values are PR_NotFound, PR_GoodSyntax,
   and PR_BadSyntax.
*/
#define PARSE_RESULT char
#define PR_BadSyntax ((char)(-1))
#define PR_NotFound (char)0
#define PR_GoodSyntax (char)1

/* Indecies into table of operators used by RcExp() */
#define IOP_mark 0
#define IOP_RParen 1
#define IOP_Imp 2
#define IOP_Eqv 3
#define IOP_Xor 4
#define IOP_Or 5
#define IOP_And 6
#define IOP_Not 7
#define IOP_EQ 8
#define IOP_LT 9
#define IOP_GT 10
#define IOP_LE 11
#define IOP_GE 12
#define IOP_NE 13
#define IOP_Add 14
#define IOP_Minus 15
#define IOP_Mod 16
#define IOP_Idiv 17
#define IOP_Mult 18
#define IOP_Div 19
#define IOP_Plus 20
#define IOP_UMinus 21
#define IOP_Pwr 22
#define IOP_LParen 23
#define NUM_OPERATORS 24

typedef ushort (pascal near *PUshortFunc)();
   /* ptr to near function which returns ushort */

#define ND_NONTERMINAL ND_BRANCH+1
#define ND_EXT_NONTERMINAL ND_BRANCH+2
#define ND_TOKEN ND_BRANCH+3

/* parser component global data declarations */
/* These are actually declared in qbidata.c, which defines EXTERNAL as "" */

#define LOOK_AHEAD 9
EXTERNAL tok tLookAhead[LOOK_AHEAD];   /* token circular queue */
EXTERNAL uchar cTokScan;         /* count of tokens scanned by ScanTok.
                                    Used by NtParse and NtStatementList to
                                    see if any tokens have been consumed
                                    (so they know to return PR_NotFound) */
EXTERNAL tok *pTokScan;          /* points to last token scanned by ScanTok */
EXTERNAL tok *pTokPeek;          /* points to last token scanned by PeekTok */
EXTERNAL tok *pTokLast;          /* points to last token scanned by FetTok */
EXTERNAL tok *pTokLastConsumed;  /* points to last token consumed by ScanTok */
EXTERNAL char fFirstStmtOnLine;  /* TRUE if any code emitted for this stmt */
EXTERNAL ushort cIdArgs;         /* used by code generation routines which
                                    need to output an argument count */

extern uchar tState[];              /* parse state table */
extern short tIntNtDisp[];          /* table of state driven non-terminals */
extern PUshortFunc tExtNtDisp[];    /* table of native-code non-terminals */
extern ushort tExtNtHelp[];         /* err msg for each native non-terminal */
extern uchar *tRw[];                /* reserved word table */
extern char mpIRWtoChar[];          /* table which maps 1 char reserved words
                                       to their char (like +,* etc.) */

/* Declarations for parser component functions */
PARSE_RESULT near CheckRw(char *, ushort);
PARSE_RESULT near ErrExpExpression(void);
PARSE_RESULT near NtEndStatement(void);
PARSE_RESULT near NtStatementList(void);
PARSE_RESULT near NtExp(void);
PARSE_RESULT near NtIdAryElem(void);
PARSE_RESULT near NtImpliedLetOrCall(boolean);
PARSE_RESULT near NtIntrinsic(void);
PARSE_RESULT near NtLit(void);
PARSE_RESULT near NtLitI2(void);
PARSE_RESULT near NtParse(ushort);
ushort NEAR BindVar(struct tok *);
boolean near ConsumeRw(ushort);
boolean near TestLn(void);
boolean near TestPeek(ushort);
boolean near TestScan(ushort);
ushort near RelOp();
ushort NEAR SubRef(ushort);

void near Emit16(ushort);
void near Emit16_0(void);
void near Emit32(ulong);
void near EmitSrcCompress(ushort ,ushort);
void near EmitSrc(ushort ,ushort);
void near FetchToken(struct tok *);
void near FetTok(void);
void near Peek1Tok(void);
void near PeekNextTok(void);
void near ResetExpStack(void);
void near ScanLit(struct tok *);
void near ScanTok(void);
void near ListIRWtoErrBuf(ushort);
void near PErrState(ushort);
void near PErrExpectedOr(void);
void near PErrExpMsg(ushort);
void near PErrExpRw(ushort);
void near PErrMsg(ushort);
void near PErrState(ushort);
void near ParseErr(ushort, ushort);
void near ParseErr0(ushort);
void near ParseErrOm(void);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\rtinterp.h ===
/* rtinterp.h - runtime-specific stuff on the interpreter side */

#undef   RTINTERP_H
#define  RTINTERP_H ON  


/**================ Client Error Range Constants =========================
   Embedded BASIC could be used to support a number of different
   "clients", such as Omega, Opus, etc, acting as a macro package.
   Command equivalent and other runtime calls can cause trappable
   runtime errors, where the error is generated by the client. We
   handle this by giving each client their own range of error codes,
   all of which fit in the same runtime error number space as existing
   BASIC runtime error numbers.
   NOTE: These constants must match what's in EBAPI.H.
=======================================================================**/

/**==================== ErrRet ==========================================

ErrRet stores information for special handling of calls to runtime
   entry points by code that expects error returns (see rterror.asm)

=======================================================================**/

typedef struct errRet {
   ushort   saveSP;     /* saved SP; also indicates if mechanism is in use */
   ushort   saveBP;     /* saved BP (in case RT error has changed it)      */
   ushort   saveSI;     /* saved SI (in case RT error has changed it)      */
   ushort   saveDI;     /* saved DI (in case RT error has changed it)      */
   ushort   retAddr;    /* short address of runtime entry point caller     */
   } errRet;

/**========================= EXTERNAL VARIABLES ===============================

context.c includes this file after defining EXTERNAL as empty, causing these
variables to actually be defined.

============================================================================**/
EXTERNAL errRet   PLM errCodeRet;
                              /* stores state for indirect calls to runtime   */

/* CallRtTrap takes as a parameter a far ptr to a function */
ushort FAR CallRtTrap(void (FAR *)(void));
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\psint.inc ===
; File: PSINT.INC
; NOTE: For comments, see psint.h

PSINT_INC = ON			;remember that this file has been included

;**======================================================================**
;**==           Internal Interface to Parser Component                 ==**
;**======================================================================**

;**==================== token descriptor ==================================
;** dtk - (token descriptor) describes tokens returned by the lexical analyzer
;**=======================================================================**
TOK	STRUC
TOK_class	DW	0
TOK_oSrc	DW	0
TOK_dsc		DW	0	;class specific descriptor union
TOK_filler	DW	5 DUP (0) ;fill out to max size of remaining tokens
TOK	ENDS

TOK_rw	STRUC			;12 bytes long
TOK_rw_union	DW	0,0	;TOK_class and TOK_oSrc
TOK_rw_iRw	DW	0
TOK_rw_rwf	DW	0
TOK_rw_iOperator DW	0
TOK_rw_pArgs	DW	0
TOK_rw	ENDS
.erre SIZE TOK_rw LE SIZE TOK


TOK_id	STRUC			;12 bytes long
TOK_id_union	DW	0,0	;TOK_class and TOK_oSrc
TOK_id_oNam	DW	0
TOK_id_oTyp	DW	0
TOK_id_vmFlags	DW	0	;variable mgr flags
	;can have FVIMPLICIT or FVFNNAME bits set
TOK_id_charFirst DB	0
TOK_id_termChar	DB	0	;char which terminated id (not part of id)
TOK_id_lexFlags DB	0	;lexical analyzer flags (see FLX_ below)
TOK_id_filler   DB      0	;pad to even byte length
TOK_id	ENDS
.erre SIZE TOK_id LE SIZE TOK

;TOK_id_lexFlags values:
FLX_hasPeriod	EQU 01h		;TRUE if current token has a '.' in its name
FLX_asSymConst	EQU 02h		;TRUE for x in 'x AS STRING * <symbolic const>

TOK_unknownChar	STRUC		;5 bytes long
TOK_unknownChar_union DW 0,0	;TOK_class and TOK_oSrc
TOK_unknownChar_unknownChar DB	0
TOK_unknownChar	ENDS
.erre SIZE TOK_unknownChar LE SIZE TOK

TOK_lit STRUC			;16 bytes long
TOK_lit_union	DW	0,0	;TOK_class and TOK_oSrc
TOK_lit_errCode DB	0	;0 if no error, else ER_xxx or MSG_xxx
TOK_lit_flags	DB	0	;FLIT_xxx below
TOK_lit_type	DB	0
TOK_lit_litType	DB	0
TOK_lit_value_I2 DW	0
TOK_lit_value_filler DW	0,0,0	;large enough for an R8
TOK_lit ENDS
.erre SIZE TOK_lit LE SIZE TOK

FLIT_exp	EQU	1	;TRUE if E+nnn or D+nnn exponent seen

TOK_lit_value_I4 = TOK_lit_value_I2
TOK_lit_value_R4 = TOK_lit_value_I2
TOK_lit_value_R8 = TOK_lit_value_I2
TOK_lit_value_cbStr = TOK_lit_value_I2

CB_TOK		EQU	SIZE TOK	;max size of token structure
.erre CB_TOK EQ 16 ;if this changes then the declarations in psint.h muse
		  ; be changed so that the size of tLookAhead will be correct

LOOK_AHEAD	EQU	9		;size of token lookahead queue
					;this value must be consistent with
					;same value in psint.h

;Enumerations for TOK_class
;
CL_RESWORD = 0
CL_ID = 2
CL_LIT = 3
CL_UNKNOWNCHAR = 4


; PARSE_RESULT is the type returned by NtParse() and functions which
; recognize non-terminals.  The values are PR_NotFound, PR_GoodSyntax,
; and PR_BadSyntax.
;
PR_BadSyntax	EQU	-1
PR_NotFound	EQU	0
PR_GoodSyntax	EQU	1

;Indecies into table of operators used by NtExp()
IOP_mark	EQU	0
IOP_RParen	EQU	1
IOP_Imp		EQU	2
IOP_Eqv		EQU	3
IOP_Xor		EQU	4
IOP_Or		EQU	5
IOP_And		EQU	6
IOP_Not		EQU	7
IOP_EQ		EQU	8
IOP_LT		EQU	9
IOP_GT		EQU	10
IOP_LE		EQU	11
IOP_GE		EQU	12
IOP_NE		EQU	13
IOP_Add		EQU	14
IOP_Minus	EQU	15
IOP_Mod		EQU	16
IOP_Idiv	EQU	17
IOP_Mult	EQU	18
IOP_Div		EQU	19
IOP_Plus	EQU	20
IOP_UMinus	EQU	21
IOP_Pwr		EQU	22
IOP_LParen	EQU	23
NUM_OPERATORS	EQU	24

;These flags modify the global flag byte 'psFlags' (parser internal flags)
;
PSIF_fBindVars		EQU 01h
   ;set if parser is to call variable mgr to bind variable references
PSIF_fNoPeriod		EQU 02h
   ;set if lexical analyzer is NOT to allow "." in identifiers.
   ;This is true when parsing record element identifiers.
PSIF_fPeriodOk		EQU 04h
   ;set if lexical analyzer is to allow "." in identifiers.
   ;This is true when parsing identifiers like labels and /common/ id's.
   ;If not set, the lexical analyzer treats period as a record separator,
   ;unless the lexical analyzer sets PSF_fLexPeriodOk while scanning the id.
PSIF_fLexPeriodOk	EQU 08h
   ;Flag which is local to lexical analyzer.  Set if id being scanned begins
   ;with "xxx." and xxx has not been seen in an AS clause.  Causes periods
   ;to be ok in such an id.  If xxx had been seen in an AS clause, xxx.yyy
   ;would return 3 tokens:  xxx, ., yyy
   ;This flag is only set if neither PSF_fNoPeriod or PSF_fPeriodOk are set
PSIF_fLineHasPeriodId	EQU 10h
   ;If flag is set, this line contains an identifier other than a record
   ;element with a period in it's name (like A.B).  Causes ParseLine to
   ;emit an opNoTyp opcode at the end of the line, to aid the text manager's
   ;PreScanAsChg() function.
PSIF_fNot1stStmt	EQU 20h
   ;True after we've successfully parsed 1st statement on line
PSIF_NoCaseChg		EQU 40h
   ;True if next token to be scanned should not change case of ids in namtbl
   ;Set for DEFINT..DEFSTR

;Parameters passed to ParseUndoLog():
	PUNDO_oNamAs		equ 1
	PUNDO_oPrsRef		equ 2

;Structure used to pass info from parser terminal recognizers like
;NtIdSubDecl, NtIdFn, etc. to the code generator CgDeclare():
;
PDCL_st STRUC
PDCL_oNam	dw 0	;oNam of procedure being defined/declared
PDCL_oPrs	dw 0	;oPrs of procedure being defined/declared
PDCL_cParms	dw 0	;number of arguments
PDCL_oTyp	db 0	;type returned by func
			;MUST PRECEED PDCL_fDeclare
PDCL_procType	db 0	;PT_SUB, PT_FUNCTION, PT_DEFFN
PDCL_fDeclare	db 0	;non-zero if DECLARE, not SUB/FUNCTION/DEF FN stmt
			;MUST FOLLOW PDCL_procType
PDCL_st ENDS


;------------------------------------------------
;  External DATA accessed by the parser component
;------------------------------------------------


sBegin DATA
	EXTRN	pTokScan:WORD
	EXTRN	pTokPeek:WORD
	EXTRN	pTokLast:WORD
	EXTRN	pTokLastConsumed:WORD
	EXTRN	cIdArgs:WORD
	EXTRN	tpMsgStd:WORD
	EXTRN	cTokScan:BYTE
	EXTRN	tLookAhead:BYTE

ife	PRSID_ASM
	EXTRN	oNamConstPs:WORD ;non-zero if we're parsing a CONST expression
	EXTRN	pdcl:BYTE	 ;PDCL_ST struct - passes info to CgDeclare()
endif	;PRSID_ASM

ife PRSNT_ASM
	EXTRN	pStateLastScan:WORD
	EXTRN	pStateCur:WORD
	EXTRN	pCurStkMark:WORD
	EXTRN	minStkMark:WORD
	EXTRN	maxStkMark:WORD
	EXTRN	pStateLastGood:WORD
endif
	MIN_STK_MARK	EQU	dataOFFSET minStkMark
	MAX_STK_MARK	EQU	dataOFFSET maxStkMark

ife PRSRWT_ASM
	EXTRN	mpIRWtoIOP:BYTE
	EXTRN	mpIRWtoChar:BYTE
endif

ife PRSEXP_ASM
	EXTRN	stkExpInit:BYTE
	EXTRN	pExpTos:WORD
endif

ife PRSMAIN_ASM
	EXTRN	psFlags:BYTE	;see PSIF_xxx above
	EXTRN	stkChkParse:WORD
endif

ife PRSSTATE_ASM
	EXTRN	tState:BYTE
	EXTRN	tIntNtDisp:WORD
	EXTRN	tExtNtHelp:WORD
	EXTRN	tExtNtDisp:WORD
endif

sEnd	DATA


;------------------------------------------------
;  External CODE accessed by the parser component
;------------------------------------------------

sBegin	CP
ife	PRSID_ASM
	EXTRN	NtIdAryElem:near
	EXTRN	NtImpliedLetOrCall:near
	EXTRN	NtConsumeExp:near
	EXTRN	SubRef:near
	EXTRN	PErrExpExpr:near
	EXTRN	BindVar:near
	EXTRN	IdTok:near
	EXTRN	IdTokFn:near
	EXTRN	IdTokPeriodImp:near
	EXTRN	IdTokNoPeriod:near
	EXTRN	IdTokNoPeriodImp:near
	EXTRN	CopyTokScanBx:near
endif	;PRSID_ASM

ife	PRSLEX_ASM
	EXTRN	ScanTok:near
	EXTRN	Peek1Tok:near
	EXTRN	PeekNextTok:near
	EXTRN	TestScan_AX:near
	EXTRN	TestPeek_AX:near
	EXTRN	TryScan_AX:near
	EXTRN	ConsumeRw_AX:near
	EXTRN	FindRw:near
	EXTRN	LexReset:near
endif	;PRSLEX_ASM

ife	PRSMAIN_ASM
	EXTRN	ParseUndoLog:near
	EXTRN	RudeIfErr:near
endif	;PRSMAIN_ASM

ife	PRSUTIL_ASM
	EXTRN	EmitSrcCompress:near
	EXTRN	EmitSrc:near
	EXTRN	Emit16_0:near
	EXTRN	PErrState:near
	EXTRN	PErrExpMsg_AX:near
	EXTRN	PErrMsg_AX:near
	EXTRN	PErrExpRw_AX:near
	EXTRN	PErrPrevTok_Ax:near
	EXTRN	PErrVarMgr:near
	EXTRN	ParseErr:near
	EXTRN	ParseErr0:near
	EXTRN	ParseErrOm:near
	EXTRN	ParseErrTokScan:near
	EXTRN	PErrExpId:near
	EXTRN	PErrExpIdImp:near
endif	;PRSUTIL_ASM

ife	PRSNT1_ASM
	EXTRN	NtEmitRem:near
endif	;PRSNT1_ASM

ife	PRSEXP_ASM
	EXTRN	RelOp:near
	EXTRN	NtExp:near
	EXTRN	NtIntrinsic:near
	EXTRN	NtLit:near
	EXTRN	NtLitI2:near
endif	;PRSEXP_ASM

ife	PRSCTL_ASM
	;These symbols are defined inside prsctl.asm
	EXTRN	TestLn:near
	EXTRN	NtLn:near
	EXTRN	NtLabLn:near
	EXTRN	NtIfStmt:near
	EXTRN	NtCaseRelation:near
endif	;PRSCTL_ASM

ife	PRSSTMT_ASM
	EXTRN	NtEndStatement:near
	EXTRN	NtEndLine:near
	EXTRN	NtStatementList:near
	EXTRN	NtStatementList0:near
endif	;PRSSTMT_ASM

ife	PRSNT_ASM
	;These symbols are defined inside prsnt.asm
	EXTRN	NtParse:near
	EXTRN	NtCommaNoEos:near
endif	;PRSNT_ASM

DbChkPsStk MACRO
	ENDM
sEnd	CP
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\rtmint.inc ===
;***
;rtmint.inc - 09/03/87 - runtime module communications interrupts
;***
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
; This file is defines the runtime module communications interrupts. Any entry
; exists in this file for each runtime entry point that can be called by
; compiled code.
;
; This file is used in two places. It is included in rtmint.asm to create a
; module which compiled programs FAR CALL into to get dispatched to the runtime
; module. It is also included in rtm86.asm (or an interpeter equivalent) to
; dispatch to the intended routines.
;
; The reason this file exists is so that the interrupt number assignments are
; more or less version independent (at the expense of a big maintenence
; hassle.) Also, there are very few conditionals because the generic and full
; versions of the runtime module should be interchangable (same full set of
; interrupts).
;
; The file number parameter was added to add granularity to non /o programs.
; Entry points are grouped together with those that are likely to be
; used along with each other.
; This grouping is approximate and may be changed at any time.
;
; The following system is now being used:
;	File 1:	Those functions required for a minimal "END" program
;	File 2:	B$SRUN.  This is the only function that uses __doexec,
;		which must be kept in the RTM LIBRARY.  __doexec is only
;		linked in if a program contains a RUN statement.
;	File 3:	"Common" entry points
;	File 4:	"Non-common" floating point entry points
;	File 5:	"graphics" entry points
;	File 6:	everything else (includes unused C startup entries)
;
;
;Summary of fields:
;
;	RTMENT	entryname,file,entryseg,startlabel,callflag,switches
;
;	    entryname - Name of routine
;	    file      - which file (RTMINT<file>.ASM) has the definition
;	    entryseg  - segment of <entryname> if not ???
;	    startlabel- Alternate name for routine
;	    callflag  - Blank: Function will ONLY be CALLed FAR.
;			'0'    Function can be JMP'ed to.  Will return.
;			'1'    Function can be JMP'ed to.  Will not return.
;	    switches  - set of MASM switches.  If defined and FALSE, there
;			will be no support for this routine, though the
;			postbyte will still be allocated.
;
;	NOTE: This is a SHARED INCLUDE FILE, used by both the RUNTIME and
;	NOTE: the interpreter projects.  Any changes made to one should
;	NOTE: be carried over (COPIED) to the other!!!
;
;******************************************************************************
;
; Entry points referenced by intepreter executors. (Must all be single post-
; bytes).
;


	RTMENT	B$ASSN,3
	RTMENT	B$BEEP,6
	RTMENT	B$BLOD,6
	RTMENT	B$BSAV,6
	RTMENT	B$CASP,5
	RTMENT	B$CDIR,6
	RTMENT	B$CHAN,3
	RTMENT	B$CHOU,3
	RTMENT	B$CIRC,5
	RTMENT	B$CLOS,3
	RTMENT	B$COLR,5
	RTMENT	B$CSCN,5
	RTMENT	B$CSRL,6
	RTMENT	B$CSTO,5
	RTMENT	B$CSTT,5
	RTMENT	B$DDIM,3
	RTMENT	B$DRAW,5
	RTMENT	B$DSEG,6
	RTMENT	B$DSG0,6
	RTMENT	B$DSKI,3
	RTMENT	B$DVI4,3
	RTMENT	B$DWID,6
	RTMENT	B$ENRD,3	
	RTMENT	B$ENSD,3	
	RTMENT	B$EPE0,6
	RTMENT	B$EPE1,6
	RTMENT	B$EPE2,6
	RTMENT	B$ERAS,6
	RTMENT	B$ERDS,6
	RTMENT	B$ERDV,6
	RTMENT	B$ESG0,6
	RTMENT	B$ESG1,6
	RTMENT	B$ESG2,6
	RTMENT	B$ETC0,6
	RTMENT	B$ETC1,6
	RTMENT	B$ETC2,6
	RTMENT	B$ETK0,6
	RTMENT	B$ETK1,6
	RTMENT	B$ETK2,6
	RTMENT	B$ETL0,6
	RTMENT	B$ETL1,6
	RTMENT	B$ETL2,6
	RTMENT	B$ETS0,6
	RTMENT	B$ETS1,6
	RTMENT	B$ETS2,6
	RTMENT	B$ETT0,6
	RTMENT	B$ETT1,6
	RTMENT	B$ETT2,6
	RTMENT	B$FASC,6
	RTMENT	B$FATR,6
	RTMENT	B$FCHR,3
	RTMENT	B$FCMD,3
	RTMENT	B$FCVD,3
	RTMENT	B$FCVI,3
	RTMENT	B$FCVL,3
	RTMENT	B$FCVS,3
	RTMENT	B$FDAT,3
	RTMENT	B$FEOF,3
	RTMENT	B$FEVI,6
	RTMENT	B$FEVS,6
	RTMENT	B$FHEX,6
	RTMENT	B$FICT,6
	RTMENT	B$FIEL,6
	RTMENT	B$FILS,6
	RTMENT	B$FINP,3
	RTMENT	B$FLDP,3
	RTMENT	B$FLEN,3
	RTMENT	B$FLOC,6
	RTMENT	B$FLOF,6
	RTMENT	B$FMDF,3
	RTMENT	B$FMID,3
	RTMENT	B$FMKD,3
	RTMENT	B$FMKI,3
	RTMENT	B$FMKL,3
	RTMENT	B$FMKS,3
	RTMENT	B$FMSF,3
	RTMENT	B$FOCT,6
	RTMENT	B$FPEN,6
	RTMENT	B$FPLY,3
	RTMENT	B$FPOS,6
	RTMENT	B$FREF,3
	RTMENT	B$FRI2,3
	RTMENT	B$FRSD,3
	RTMENT	B$FSCN,3
	RTMENT	B$FSEK,6	
	RTMENT	B$FSHL,6
	RTMENT	B$FSPC,3
	RTMENT	B$FSTG,3
	RTMENT	B$FTAB,3
	RTMENT	B$FTIM,3
	RTMENT	B$FVAL,3
	RTMENT	B$FWID,3
	RTMENT	B$GET1,6
	RTMENT	B$GET2,6
	RTMENT	B$GET3,6
	RTMENT	B$GET4,6
	RTMENT	B$GGET,5
	RTMENT	B$GPUT,5
	RTMENT	B$INKY,3
	RTMENT	B$INPP,3
	RTMENT	B$INS2,3
	RTMENT	B$INS3,3
	RTMENT	B$KFUN,3
	RTMENT	B$KILL,6
	RTMENT	B$KMAP,3
	RTMENT	B$LBND,3
	RTMENT	B$LCAS,3
	RTMENT	B$LDFS,3
	RTMENT	B$LEFT,3
	RTMENT	B$LINE,5
	RTMENT	B$LNIN,3
	RTMENT	B$LOCK,6
	RTMENT	B$LOCT,3
	RTMENT	B$LPOS,3
	RTMENT	B$LPRT,3
	RTMENT	B$LSET,3
	RTMENT	B$LTRM,3
	RTMENT	B$LWID,3
	RTMENT	B$MCVD,3
	RTMENT	B$MCVS,3
	RTMENT	B$MDIR,6
	RTMENT	B$MUI4,3
	RTMENT	B$N1I2,5
	RTMENT	B$N1R4,5
	RTMENT	B$N2I2,5
	RTMENT	B$N2R4,5
	RTMENT	B$NAME,6
	RTMENT	B$ONCA,6
	RTMENT	B$ONKA,6
	RTMENT	B$ONLA,6
	RTMENT	B$ONPA,6
	RTMENT	B$ONSA,6
	RTMENT	B$ONSG,6
	RTMENT	B$ONTA,6
	RTMENT	B$OOPN,3
	RTMENT	B$OPEN,3
	RTMENT	B$PAIN,5
	RTMENT	B$PAL0,5
	RTMENT	B$PAL2,5
	RTMENT	B$PALU,5
	RTMENT	B$PCI2,3
	RTMENT	B$PCI4,3
	RTMENT	B$PCPY,5
	RTMENT	B$PCR4,3
	RTMENT	B$PCR8,3
	RTMENT	B$PCSD,3
	RTMENT	B$PEEK,6
	RTMENT	B$PEI2,3
	RTMENT	B$PEI4,3
	RTMENT	B$PEOS,3
	RTMENT	B$PER4,3
	RTMENT	B$PER8,3
	RTMENT	B$PESD,3
	RTMENT	B$PINP,6	; INP and OUT are only needed for the
	RTMENT	B$POUT,6	; Interpreters
	RTMENT	B$PMAP,5
	RTMENT	B$PNI2,5
	RTMENT	B$PNR4,5
	RTMENT	B$PNT1,5
	RTMENT	B$PNTC,5
	RTMENT	B$POKE,6
	RTMENT	B$PRST,5
	RTMENT	B$PSET,5
	RTMENT	B$PSI2,3
	RTMENT	B$PSI4,3
	RTMENT	B$PSR4,3
	RTMENT	B$PSR8,3
	RTMENT	B$PSSD,3
	RTMENT	B$PSTC,5
	RTMENT	B$PUT1,6
	RTMENT	B$PUT2,6
	RTMENT	B$PUT3,6
	RTMENT	B$PUT4,6
	RTMENT	B$RDI2,3
	RTMENT	B$RDI4,3
	RTMENT	B$RDIM,6
	RTMENT	B$RDIR,6
	RTMENT	B$RDR4,3
	RTMENT	B$RDR8,3
	RTMENT	B$RDSD,3
	RTMENT	B$REST,3
	RTMENT	B$RGHT,3
	RTMENT	B$RMI4,3
	RTMENT	B$RND0,6
	RTMENT	B$RND1,6
	RTMENT	B$RNZ0,6
	RTMENT	B$RNZP,6
	RTMENT	B$RSET,3
	RTMENT	B$RTRM,3
	RTMENT	B$S1I2,5
	RTMENT	B$S1R4,5
	RTMENT	B$S2I2,5
	RTMENT	B$S2R4,5
	RTMENT	B$SADD,3
	RTMENT	B$SASS,3
	RTMENT	B$SCAT,3
	RTMENT	B$SCLS,3
	RTMENT	B$SCPY,3
	RTMENT	B$SDAT,3
	RTMENT	B$SENV,6
	RTMENT	B$SERR,6
	RTMENT	B$SETM,6
	RTMENT	B$SICT,6
	RTMENT	B$SMID,3
	RTMENT	B$SOND,3
	RTMENT	B$SPAC,3
	RTMENT	B$SPLY,3
	RTMENT	B$SSEK,6	
	RTMENT	B$SSHL,6
	RTMENT	B$STDL,3 	
	RTMENT	B$STI2,3
	RTMENT	B$STI4,3
	RTMENT	B$STIK,6
	RTMENT	B$STIM,6
	RTMENT	B$STR4,3
	RTMENT	B$STR8,3
	RTMENT	B$STRI,3
	RTMENT	B$STRS,3
	RTMENT	B$SWP2,3
	RTMENT	B$SWP4,3
	RTMENT	B$SWP8,3
	RTMENT	B$SWPN,3
	RTMENT	B$TIMR,3
	RTMENT	B$UBND,3
	RTMENT	B$UCAS,3
	RTMENT	B$USNG,3
	RTMENT	B$VARP,3
	RTMENT	B$VEW0,5
	RTMENT	B$VIEW,5
	RTMENT	B$VWPT,5
	RTMENT	B$WAIT,3	; WAIT is only needed by the Interpreter
	RTMENT	B$WIDT,3
	RTMENT	B$WIN0,5
	RTMENT	B$WIND,5
	RTMENT	B$WRIT,3
;
; Entry points not referenced by interpreter executors. (May be multiple post-
; bytes). These MAY be referenced by the interpeter, but not in a manner that
; requires a single post-byte.
;
	RTMENT	B$?EVT,3
	RTMENT	B$CEND,1
	RTMENT	B$CENP,1
	RTMENT	B$CPI4,3
	RTMENT	B$ENFA,3
	RTMENT	B$ENRA,3
	RTMENT	B$ENSA,3 	
	RTMENT	B$EVCK,3
	RTMENT	B$EXFA,3
	RTMENT	B$EXSA,3
	RTMENT	B$FBIN,3
	RTMENT	B$FERL,3
	RTMENT	B$FERR,3
	RTMENT	B$GOSA,3
	RTMENT	B$HARY,3
	RTMENT	B$LINA,3
	RTMENT	B$OEGA,3
	RTMENT	B$OGSA,3
	RTMENT	B$OGTA,3
	RTMENT	B$RELA,6
	RTMENT	B$RES0,6
	RTMENT	B$RESA,6
	RTMENT	B$RESN,6
	RTMENT	B$RETA,3
	RTMENT	B$RSTA,3
	RTMENT	B$RSTB,3
	RTMENT	B$RUNL,6 	
	RTMENT	B$SCHN,3
	RTMENT	B$SCLR,3
	RTMENT	B$SCMP,3
	RTMENT	B$SCPF,3 	
	RTMENT	B$SRUN,2	; MUST have its own file
	RTMENT	B$STOP,3
	RTMENT	B$SWSD,3 	
	RTMENT	B$CMI4,3	
	RTMENT	B$TROF,6
	RTMENT	B$TRON,6
	RTMENT	B$Undef1,6,,,,FALSE ;These four entrypoints were used in QB4
	RTMENT	B$Undef2,6,,,,FALSE ;but are no longer used (they were for
	RTMENT	B$Undef3,6,,,,FALSE ;ISAM support).  They may be used for any
	RTMENT	B$Undef4,6,,,,FALSE ;Product, but the slots must exist.


;
; The following entries must be grouped together. They are all in segment _TEXT
;
	RTMENT	B$ATN4,4,_TEXT,_TEXT_START	
	RTMENT	B$ATN8,4,_TEXT
	RTMENT	B$COS4,4,_TEXT
	RTMENT	B$COS8,4,_TEXT
	RTMENT	B$EXP4,4,_TEXT
	RTMENT	B$EXP8,4,_TEXT
	RTMENT	B$FCMP,3,_TEXT		; floating point compare
	RTMENT	B$FIL2,4,_TEXT
	RTMENT	B$FILD,4,_TEXT
	RTMENT	B$FIS2,4,_TEXT
	RTMENT	B$FIST,4,_TEXT
	RTMENT	B$FIX4,4,_TEXT
	RTMENT	B$FIX8,4,_TEXT
	RTMENT	B$FUST,4,_TEXT
	RTMENT	B$INT4,4,_TEXT
	RTMENT	B$INT8,4,_TEXT
	RTMENT	B$LOG4,4,_TEXT
	RTMENT	B$LOG8,4,_TEXT
	RTMENT	B$POW4,4,_TEXT
	RTMENT	B$POW8,4,_TEXT
	RTMENT	B$SGN4,4,_TEXT
	RTMENT	B$SGN8,4,_TEXT
	RTMENT	B$SIN4,4,_TEXT
	RTMENT	B$SIN8,4,_TEXT
	RTMENT	B$TAN4,4,_TEXT
	RTMENT	B$TAN8,4,_TEXT

	; Definition of 5th parameter:
	;	Blank:	function will ONLY be CALLed FAR.
	;	'0'	Function can be JMP'ed to directly/indirectly.  Macro
	;		will generate a far call to the INT 3F, followed by a
	;		RETF.
	;	'1'	Function can be JMP'ed to directly/indirectly.  Macro
	;		will generate a far call to the INT 3F, but will not
	;		follow it with a RETF, since routine does not return.


					; C startup functions in the RTM
					; and in QB.EXE
	RTMENT	__fpreset,1,_TEXT	;math pack reset
	RTMENT	__chkstk,1,_TEXT	; publics in CHKSTK
	RTMENT	__nullcheck,1,_TEXT	; publics in CHKSUM
	RTMENT	__fptrap,1,_TEXT,,1	; publics in CRT0FP
	RTMENT	__FMSG_TEXT,1,_TEXT,,0	; publics in FMSGHDR
	RTMENT	__amsg_exit,1,_TEXT,,1	; publics in CRT0
	RTMENT	__cintDIV,1,_TEXT,,1	


;
; NEW functions added after QB4 shipped.  Moved here with revision [27]
; to ensure that the QB shipped with BASCOM 6 remains compatable with the
; QB4.00 already shipped.
;
; They can not be moved into RTM_UNDEFINED slots, as that would break
; break backward compatibility with QB4.00B.
;
	RTMENT	B$EUE0,6,,_TEXT_END	; label to mark end of _TEXT entries
	RTMENT	B$EUE1,6		
	RTMENT	B$EUE2,6		
	RTMENT	B$ONUE,6		
	RTMENT	B$SLEP,6
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\rttemp.h ===
/*** 
*rttemp.inc - temporary extern's and data struct's for shared runtime interface
*
*	Copyright <C> 1986, Microsoft Corporation
*
*Purpose:
*	This file is for temporary use only - - - a more complete set of
*	header files will be developed in conjunction with the runtime group.
*
*******************************************************************************/

#undef	RTTEMP_H
#define	RTTEMP_H	ON
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\rttemp.inc ===
;*** 
;rttemp.inc - temporary extern's and data struct's for shared runtime interface
;
;	Copyright <C> 1986, Microsoft Corporation
;
;Purpose:
;	This file is for temporary use only - - - a more complete set of
;	header files will be developed in conjunction with the runtime group.
;
;
;*******************************************************************************
RTTEMP_INC = -1

EOF	EQU	0FFh
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\rtps.inc ===
;***
; rtps.inc - 04-Aug-87
;***
;	Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	This include file contains runtime constants needed by both the
;	runtime and QBI.  This file, along with fdb.inc, array.inc, and
;	messages.inc is part of a runtime "release" to QBI.
;
; WARNING: WARNING: WARNING: WARNING: WARNING: WARNING: WARNING: WARNING:
; WARNING:
; WARNING:  When making changes to this file, be sure to make equivalent
; WARNING:  changes to file rtps.h
; WARNING:
; WARNING: WARNING: WARNING: WARNING: WARNING: WARNING: WARNING: WARNING:
;
;******************************************************************************

RTPS_INC = -1			;remember that this file has been included

;==============================================================================
;
;QBI version & format revision constants (used by U.L. code & Binary SAVE/LOAD)
;   The version word is now a family id, it indicates what "family" the saving
;   product belongs to.  The revision byte indicates the revision of the
;   product within its family.




BINSAV_BASICVersion	EQU	0001h	; BASIC version number for QB 4.5
BINSAV_REVISION_BYTE	EQU	00h	; format revision byte
QLB_BASICVersion	EQU	0000h	; BASIC version no. for QB 4.x QLB's
QLB_REVISION_BYTE	EQU	13h	; QuickLib format revision byte

;Log of when BINSAV_REVISION_BYTE was changed:
;Date		Changed To	Reason
;------------------------------------------------------------------------
;23-Feb-87	    01		First change. Unknown number of older
;				binary-saved files in existence.
;27-Feb-87          02		No longer putting BLOCK_MOD at start of each
;				module, since we only save one module per file.
;16-Mar-87          03		Code to support compiling directly from 
;				our Binary SAVE format needs module name table
;				to be saved before the module text table.
;10-Jun-87          04		Changed for todays internal QB release. Must
;				be changed whenever peropcod.txt is changed.
;10-Jun-87 (PM)     05		Changed for todays internal QB release. Must
;				be changed whenever peropcod.txt is changed.
;17-Jun-87	    06		Changed for Beta Release because of peropcode
;				changes (DMC).
;30-Jun-87          07		Changed based on actual change to binsav format
;				(now saving both mrs flag bytes)
;15-Jul-87	    08		Peropcod changes. (DMC)
;21-Jul-87	    09		Peropcod changes and second beta. (DMC)
;03-Aug-87	    0a		Peropcod changes. (DMC)
;04-Aug-87	    0b		Peropcod changes. (DMC)
;10-Aug-87	    0c		VarMgr changes. (DMC)
;26-Aug-87	    0d		QLB dgroup compression changes. (DMC)
;31-Aug-87	    0e		C startup changes. (DMC)
;09-Sep-87	    0f		rtmint changes. (DMC)
;14-Sep-87	    10		rtmint changes. (DMC)
;15-Sep-87	    11		First final (?) beta REL.19 (DMC)
;15-Sep-87	    12		First final (?) beta REL.20 (DMC)
;??-???-87	    13		Release version REL.35 (???)
;11-Nov-87	    14		First Beta for BC6.  Want to be backwards
;				compatable to release version of QB4.
;16-Nov-87	    13		We're stuck at 13 for QB4 release compatibility!
;25-May-88	    14 (EB)	Changed for EB only, to make binary
;				incompatabilities easier to detect (BLR)
;08-Jun-88	    15 (EB)	Changed for EB only, due to changes in nam,
;				var, rs, and pcode tables to leave 2nd word
;				of each far heap buffer unused (used by Omega)
;15-Jun-88	    16 (EB)	Changed for EB only, due to additional pcode
;				changes to leave 2nd word free.
;24-Jun-88	    17 (EB)	Changed for EB only, removed data_otxfirst
;30-Jun-88	    18		Changed many AVtRfs to AIdLds in pcode
;05-Jul-88	    19		Removed obsolete pcodes
;07-Jul-88	    1a		Changed coercion pcode
;11-Jul-88	    00		Rewound due to change in binary format.  BASIC
;				version number is now a family number.	0 = QB
;				(v4.0 a,b), 1 = QB (v4.5 and later), 2 = EB.
;05-Aug-88	    01 (EB)	SQL pcode change
;==============================================================================


; [LINE] INPUT prompt flags
FINP_QSupress	EQU 1	;set if "prompt" was followed by a comma,
			;not a semicolon, indicating "? " is not to be
			;output after prompt.
FINP_CrLf	EQU 2	;set if INPUT was followed by optional ";",
			;meaning CrLf is not to be output when user
			;presses return.
FINP_Prompt	EQU 4	;set if the optional SDPrompt argument is included.


; Communications constants
cbComBuf	EQU 512 ; default COM buffer size

; File LOCK & UNLOCK Constants
LOCK_UNLOCK		EQU 0001h	;set if operation is UNLOCK, not LOCK
LOCK_1stToLast		EQU 0002h	;set if only part of file locked
LOCK_RtMask		EQU 0003h	;bits which are meaningful to runtime
LOCK_Def1stArg		EQU 4000h	;set if 1st arg defaulted - used by list
LOCK_DefLastArg		EQU 8000h	;set if last arg defaulted- used by exec

;File Open mode, access, locking flags
MD_SQI			EQU 1	; for INPUT
MD_SQO			EQU 2	; for OUTPUT
MD_RND			EQU 4	; [for RANDOM]
MD_APP			EQU 8	; for APPEND
MD_BIN			EQU 20H	; for BINARY
MD_DEFAULT		EQU MD_RND
ACCESS_READ		EQU 1	; READ
ACCESS_WRITE		EQU 2	; WRITE
ACCESS_BOTH		EQU 3	; READ WRITE
LOCK_READ		EQU 30H	; LOCK READ
LOCK_WRITE		EQU 20H	; LOCK WRITE
LOCK_BOTH		EQU 10H	; LOCK READ WRITE
LOCK_SHARED		EQU 40H	; LOCK SHARED

;----------------------------------------------------------------------
;DOS does not allow you to do a CD (change directory) to a path > 64,
;but once you are in a directory whose path is 64 bytes long, DOS
;will let you open a 64 byte relative path, making the maximum length
;of a filename accessible by DOS = 128.  Since the runtime just has 1
;static copy of a filename buffer, they decided to let running programs
;access files whose full path > 64 (even though you can't get into the
;lowest directory from DOS.
;  The user interface chooses to limit the path to 64 for the directory,
;and 12 for the filename (and 1 for a 0-byte terminator).  This is for
;two reasons:
;  - The directory that source files are saved in should be accessible by
;    all programs (including command.com).  
;  - There are several layers of functions in the user interface code that
;    each need a copy of a filename.  The increased stack demands of going
;    to 128 are prohibitive.
;
FILNAML = 128d+1	;max. filename length for runtime
FILNAML64 = 64d+12d+1	;max. filename length for user interface

;Runtime Value Types
VT_I2 EQU 02h		;short integer
VT_I4 EQU 14h		;long integer
VT_R4 EQU 04h		;32 bit real
VT_R8 EQU 08h		;64 bit real
VT_SD EQU 03h		;string

;Runtime bits for b$CtrlFlags
NoSTACKINIT EQU 01h	;Doesn't call B$STACKINIT when set during B$RUNINI
			; or B$CHNINI calls.

;Extended Out of Memory error codes for b$errinfo.
OMErr_OM   EQU 00h	;generic OM error
OMErr_NH   EQU 01h	;out of near heap space ( DS > 64k )
OMErr_FH   EQU 02h	;out or far heap space	( out of system memory )
OMErr_STK  EQU 03h	;out of stack space
OMErr_Proc EQU 04h	;out of Procedure text table space ( > 64k )
OMErr_Mod  EQU 05h	;out of Module text table space ( > 64k )
OMErr_Inc  EQU 06h	;out of Include file text table space ( > 64k )
OMErr_Doc  EQU 07h	;out of Document file text table space ( > 64k )

;File type constants for user-option path searching
LIBFILE    EQU 0	
EXEFILE    EQU 6	
INCFILE    EQU 12	
HELPFILE   EQU 18	

; Minimum space for NMALLOC buffer.  Moved here from const.inc with rev [17].
;
; This is the minimum space which must be allocated in the NMALLOC segment
; for any attempted near malloc() call to fail gracefully.  Enough space
; must be allocated for a "C" heap header.
;

NMALLOC_MIN	= 06H		;Minimum NMALLOC space needed.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\rtinterp.inc ===
;*** 
;rtinterp.inc - runtime error handling support
;
;	Copyright <C> 1986, 1987, 1988 Microsoft Corporation
;
;
;*******************************************************************************

RTINTERP_INC = ON

;**================ Client Error Range Constants =========================
; Embedded BASIC could be used to support a number of different
; "clients", such as Omega, Opus, etc, acting as a macro package.
; Command equivalent and other runtime calls can cause trappable
; runtime errors, where the error is generated by the client. We
; handle this by giving each client their own range of error codes,
; all of which fit in the same runtime error number space as existing
; BASIC runtime error numbers.
; NOTE: These constants must match what's in EBAPI.H.
;=======================================================================**

;**=========================== ERRRET ====================================
;
;errRet is used to for indirect calls to runtime; this allows error code
;	to fool caller into thinking the runtime just returned an error
;	code, if an error occurs.
;
;=======================================================================**

ERRRET		STRUC
ERRRET_saveSP	DW 0
ERRRET_saveBP	DW 0
ERRRET_saveSI	DW 0
ERRRET_saveDI	DW 0
ERRRET_retAddr	DW 0
ERRRET		ENDS


sBegin	DATA
	EXTRN	errCodeRet:byte ;state for indirect calls to runtime
sEnd	DATA

ife	RTERROR_ASM
	EXTRN	ResetSP_BP_FAR:far	
	EXTRN	CallRtTrap:far
	EXTRN	CallRtTrap_Parm:far
	EXTRN	CallRtTrap_RT:far
	EXTRN	CallRtTrap_CODE:far
sBegin	CP
	EXTRN	RtSetTrap:near
	EXTRN	RtFreeTrap:near
	EXTRN	RtPushHandler:near
	EXTRN	RtPopHandler:near
sEnd	CP
	EXTRN	RtErrorOM_INI:far
	EXTRN	RtError:far
	EXTRN	RtErrorNoSi:far
sBegin	CODE
	EXTRN	RtErrorCODE:near
sEnd	CODE
endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\rtps.h ===
/* File: rtps.h - Runtime constants                                     */
/* NOTE: When making changes to this file, be sure to make equivalent   */
/*       changes to file rtps.inc                                       */

#undef RTPS_H
#define RTPS_H ON       /* remember that this file has been included */

/* [LINE] INPUT prompt flags */
#define FINP_QSupress 1
			/* set if "prompt" was followed by a comma,
			   not a semicolon, indicating "? " is not to be
			   output after prompt. */
#define FINP_CrLf 2
			/* set if INPUT was followed by optional ";",
			   meaning CrLf is not to be output when user
			   presses return. */
#define FINP_Prompt 4	/* set if the optional SDPrompt argument is included. */

/* File LOCK & UNLOCK Constants */
#define LOCK_UNLOCK 1		/* set if operation is UNLOCK, not LOCK */
#define LOCK_1stToLast 2	/* set if only part of file */
#define LOCK_RtMask 3		/* bits which get passed to runtime */
#define LOCK_Def1stArg 4	/* set if 1st arg defaulted */
#define LOCK_DefLastArg 8	/* set if last arg defaulted */

/* File Open mode, access, locking flags */
#define MD_SQI 1		/* for INPUT */
#define MD_SQO 2		/* for OUTPUT */
#define MD_RND 4		/* [for RANDOM] */
#define MD_APP 8		/* for APPEND */
#define MD_BIN 16		/* for BINARY */
#define MD_DEFAULT MD_RND	/* [for RANDOM] */
#define ACCESS_READ 1		/* READ */
#define ACCESS_WRITE 2		/* WRITE */
#define ACCESS_BOTH 3		/* READ WRITE */
#define LOCK_READ 0x30		/* LOCK READ */
#define LOCK_WRITE 0x20		/* LOCK WRITE */
#define LOCK_BOTH 0x10		/* LOCK READ WRITE */
#define LOCK_SHARED 0x40	/* LOCK SHARED */

/* DOS does not allow you to do a CD (change directory) to a path > 64,
 * but once you are in a directory whose path is 64 bytes long, DOS
 * will let you open a 64 byte relative path, making the maximum length
 * of a filename accessible by DOS = 128.  Since the runtime just has 1
 * static copy of a filename buffer, they decided to let running programs
 * access files whose full path > 64 (even though you can't get into the
 * lowest directory from DOS.
 *   The user interface chooses to limit the path to 64 for the directory,
 * and 12 for the filename (and 1 for a 0-byte terminator).  This is for
 * two reasons:
 *   - The directory that source files are saved in should be accessible by
 *     all programs (including command.com).  
 *   - There are several layers of functions in the user interface code that
 *     each need a copy of a filename.  The increased stack demands of going
 *     to 128 are prohibitive.
 */
#define FILNAML 128+1		/* max. filename length for runtime */
#define FILNAML64 64+12+1	/* max. filename length for user interface */

/* Runtime Value Types */
#define VT_I2 0x02		/* short integer */
#define VT_I4 0x14		/* long integer */
#define VT_R4 0x04		/* 32 bit real */
#define VT_R8 0x08		/* 64 bit real */
#define VT_SD 0x03		/* string */

/* Runtime bits for b$CtrlFlags */
#define NoSTACKINIT 0x01h   /* Doesn't call B$STACKINIT when set during
			      B$RUNINI or B$CHNINI calls. */

/* Extended Out of Memory error codes for b$errinfo. */
#define OMErr_OM   0x00h    /* generic OM error                               */
#define OMErr_NH   0x01h    /* out of near heap space ( DS > 64k )            */
#define OMErr_FH   0x02h    /* out of far heap space ( out of system memory )	*/
#define OMErr_STK  0x03h    /* out of stack space                            	*/
#define OMErr_Proc 0x04h    /* out of Procedure text table space ( > 64k )    */
#define OMErr_Mod  0x05h    /* out of Module text table space ( > 64k )       */
#define OMErr_Inc  0x06h    /* out of Include file text table space ( > 64k ) */
#define OMErr_Doc  0x07h    /* out of Document file text table space ( > 64k )	*/


/* File type constants for user-option path searching			*/
#define LIBFILE    0x00     /* search user-specified LIB path		*/
#define EXEFILE    0x06     /* search user-specified EXE path		*/
#define INCFILE    0x0c     /* search user-specified INCLUDE path	*/
#define HELPFILE   0x12     /* search user-specified HELP path		*/


/* CONSIDER: Do not bump the binary revision byte without a good reason.
 * CONSIDER: If it ever reaches 40H or above, KANJI QBs will not be able
 * CONSIDER: to distinguish a binary save file from some text files.
 */

/* QBI version & format revision constants (used by U.L. & Binary SAVE/LOAD)  */
/* if BINSAV_CBSPECHDR is changed, check MAX_SPECHDRSIZE in BinSav.ASM	      */

//[1] CONSIDER: FK_KANJI
//[1] CONSIDER: SYNC: FK_KANJI is not the correct switch to use here.
//[1] CONSIDER:       However, the interpreter (with whom this source is
//[1] CONSIDER:       shared), does not have a product specific switch for
//[1] CONSIDER:       QBJ.  FK_KANJI and FV_QBJLANG are the only shared
//[1] CONSIDER:       switches that could reasonably be used.

#define BINSAV_CBSPECHDR     0x0010



#ifndef BINSAV_BASICVersion		//[2] default version (American QB)
#define BINSAV_BASICVersion  0x0001	/* BASIC version number for QB */
#define BINSAV_REVISION_BYTE 0x00	/* binary save format revision byte */
#define	QLB_BASICVersion     0x0000	/* BASIC version QLB's compat. with */
#define	QLB_REVISION_BYTE    0x13	/* QuickLib format revision byte */
#endif					//[1]

/* Minimum space for NMALLOC buffer. */

#define NMALLOC_MIN	     0x0006	/* Minimum NMALLOC space needed */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\sb.inc ===
;***
;sb.inc - SB usage definitions
;***
	.XLIST
;***
;
;	Copyright <C> 1988, Microsoft Corporation
;
;Purpose:
;	NOTE: This is a SHARED INCLUDE FILE, used by both the RUNTIME
;	NOTE: and the interpreter projects.  Any changes made to one should
;	NOTE: be carried over to the other!!!
;	NOTE: There are some minor differences between the two versions for
;	NOTE: this file, so DO NOT just copy it!!!
;
;
;******************************************************************************
SB_INC	=	ON


;HMEM_ constants used by SBMGR allocation routines

HMEM_FIXED	EQU	0000H
HMEM_MOVEABLE	EQU	0002H
HMEM_NOCOMPACT	EQU	0010H
HMEM_ZEROINIT	EQU	0040H
HMEM_DISCARDABLE EQU	0F00H
HMEM_EMM	EQU	0004H	

sBegin	DATA
sEnd	DATA

;For QB5, we need to have constants that map to the appropriate place
;in the table of FHD's
SbDgroup=	  2
SbString=	 97
SbFile	=	100
SbRs	=	103
SbGVar	=	106
SbGNam	=	109
SbDirect=	112
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\scanner.h ===
#undef SCANNER_H
#define SCANNER_H ON

/*======================================================================*/
/* Scanner state definitions															*/
#define SS_EXECUTE (ushort)0
#define SS_PARSE (ushort)1
#define SS_RUDE (ushort)2
#define SS_SUBRUDE (ushort)3

/*======================================================================*/
/* Scanner external interface.						 								*/ 

ushort	FAR SsScan(void);
ushort	FAR SsDescan(void);
void	NEAR SsRudeScan(ushort);

/*======================================================================*/
/* Non-RELEASE flag, allows for scanning from SS_RUDE to SS_PARSE			*/
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\txtint.h ===
/* File: txtint.h - Defines which apply to the QBI Text Manager         */
/* NOTE: When making changes to this file, be sure to make equivalent   */
/*       changes to file TXTINT.INC                                     */

#undef TXTINT_H
#define TXTINT_H ON        /* remember that this file has been included */

/**======================================================================**
 **==           Internal Interface to Text Manager Component           ==**
 **======================================================================**/

ulong NEAR EtDiff(char *, char *, ushort);
ushort NEAR GetPrsField(ushort, ushort);
boolean NEAR LoadEnterProc(ushort);
boolean NEAR LoadExitProc(void);
void NEAR UpdateLinks(ushort, ushort);
void NEAR TxtFlushCache(void);
boolean NEAR TxtDelete(ushort, ushort);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\scanner.inc ===
;*** 
;Scanner.inc
;
;	Copyright <C> 1985, 1986, 1987 Microsoft Corporation
;
;
;*******************************************************************************

SCANNER_INC	= ON

;=============================================================================
;Scanner Constants
;

;Scanner State definitions
SS_EXECUTE	equ LOW 0
SS_PARSE	equ LOW 1
SS_RUDE		equ LOW 2
SS_SUBRUDE	equ LOW 3	;same as rude except oPrs operands are
				;actually oNam's. 

;Offsets into frame, relative execute-time BP:
FR	struc	
FR_bpLink	dw	?	;Caller's bp
FR_otxRet	dw	?	;oTx of return address
FR_oRsRet	dw	?	;oRS of return address
FR_pGosubLast	dw	?	;Pointer to last gosub return otx
FR	ends	

FR_MinFrame	=	size FR	; Minimum frame size, not counting portion
				; of frame below the pushed bp
FR_basBpLink	=      -2d	; previous value of b$curframe
FR_FirstVar	=      -2d	; offset to first framevar
;=============================================================================
;Non-RELEASE flag, allows for scanning from SS_RUDE to SS_PARSE


sBegin	DATA

ife	SSDATA_ASM
	extrn	SsLineCount:word	;No. of lines scanned
endif	;SSDATA_ASM
sEnd	DATA

ife	SSSCAN_ASM
	EXTRN	SsScan:far		
	EXTRN	SsDescan:far		
	EXTRN	ScanAndExec:near
endif	;SSSCAN_ASM

ife	SSDECLARE_ASM
	extrn	ChainCommon:far
	extrn	SsAdjustCommon:near
	extrn	SsTrimCommon:near
endif	;SSDECLARE_ASM

ife	SSRUDE_ASM
sBegin	SCAN
	extrn	SsRudeScan:far		; Rude scanner/descanner
sEnd	SCAN
endif	;SSSCAN_ASM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\stack2.inc ===
;***
; STACK.INC - 18-Feb-88 - Stack size definitions
;***
	.XLIST
;***
;
; Copyright <C> 1987, Microsoft Corporation
;
;Purpose:
;	Stack constants
;
;	WARNING:  This file is shared between the runtime and interpreter.
;	WARNING:  The runtime is the official "owner", and all changes should
;	WARNING:  be made there first, and then propogated to the interpreter.
;
;
;******************************************************************************

STACK2_INC = -1			; remember file has been included




FAT_COW 	= 300h		; Extra slop just in case
STACK_SIZE	= 0800h	+ FAT_COW  ; Default stack size (MUST BE EVEN)
STACK_MIN	= 0320h + FAT_COW  ; Minimum stack size


STACK_CHECK	= STACK_MIN-20h+1h ; Stack check marker offset (MUST BE ODD)
				; This constant is used by runtime to ensure
				;  we never make long-term stack commitments
				;  (i.e. GOSUB, CALL, FUNCTION invocations)
				;  that would result in less than this many
				;  free bytes between SP and b$pend.
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\switch.inc ===
;*** 
;switch.inc - see switch.h for real definitions of switches
;
;	Copyright <C> 1985, 1986, 1987 Microsoft Corporation
;
;
;*******************************************************************************

;===============================================================
; This file is the first thing included by VERSION.INC.
;===============================================================

ON	EQU	(-1)
OFF	EQU	(0)

include filename.inc	;include the _INC & _ASM switches

RELEASE         = ON
NOEXTRNS	= OFF	;ON - don't include EXTRN definitions in include files.
?WIN		= OFF	;ON - cmacros.inc generates WINDOWS entries and exits
memM 		= ON	;ON - cmacros.inc generates medium model code
?PLM		= ON	;ON - cmacros.inc generates PLM calling sequence
?TF		= ON	;ON - cmacros.inc - cEnd generates no 'mov sp,bp'
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\switch.h ===
/*** 
* switch.h
*
*	Copyright <C> 1985, 1986, 1987 Microsoft Corporation
*
*******************************************************************************/

/*===========================================================================*/
/* This file is the first thing included by version.h.			     */
/*===========================================================================*/

#define ON (-1)
#define OFF 0

/*=============================================================*/
/* Switches specific to c source											*/
/* These switches are not in switch.inc								*/
/*=============================================================*/

#ifndef	DEFINE_VARIABLES			/* Allow to be defined previous to VERSION.H */
#define	DEFINE_VARIABLES	OFF	/* ON - allocate global variables.*/
#endif

#define	LINT_ARGS	OFF			/* ON - runtime lib arg types to be checked */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\txtint.inc ===
;File: TXTINT.INC - Defines which apply to the QBI Text Manager
;NOTE: When making changes to this file, be sure to make equivalent
;		changes to file TXTINT.H.  See TXTINT.H for comments.

TXTINT_INC = ON			;remember that this file has been included

;Constant for maximum $INCLUDE: nesting depth
INCLUDE_DEPTH_MAX EQU 5

;Constants for parms past to TDataNew
DT_End		EQU 0	;marks end of table bdData
DT_Data		EQU 1	;entry refers to a DATA statement
DT_EndProc	EQU 2	;shows where SUB/FUNCTION fit into main module
DT_Label	EQU 3	;entry refers to label definition referenced by RESTORE
DT_Restore	EQU 4	;entry refers to a RESTORE statement

;----------------------------------------------------------------------
; BigEdit Related variables
; See further comments near TxtStartBigEdit in txtmgr.asm
;----------------------------------------------------------------------
BIG_EDIT_FALSE		EQU 0	;not between StartBigEdit and EndBigEdit
				;default.  set by TxtEndBigEdit()
BIG_EDIT_ACTIVE		EQU 1	;within a "big edit".  set by StartBigEdit()
BIG_EDIT_REPARSE	EQU 2	;TxtEndBigEdit is active, and is parsing all
				;opReParse lines entered during the BigEdit
BIG_EDIT_CANCEL		EQU 3	;user wants to back out of a "big edit"
				;set by TxtChange()/TxtDelete


sBegin	DATA

ife	TXTMGR_ASM
	EXTRN	bdlTxtScrap:byte ;needed for use in txtdata.asm
endif	;TXTMGR_ASM

ife	TXTLOAD_ASM
	EXTRN	chanCur:WORD
	EXTRN	NormFname:Byte
	EXTRN	sdNormFname:Word
	EXTRN	tEtTemp:WORD
	EXTRN	fProcDyn:BYTE
	EXTRN	fDynArrays:BYTE	;Initialized to FALSE by AsciiMerge,
				;set TRUE when $DYNAMIC is seen by TxtChange,
				;set FALSE when $STATIC is seen by TxtChange
	EXTRN	otxUpdLinks:WORD
endif	;TXTLOAD_ASM

sEnd	DATA

sBegin	CODE
ife	TXTDEB_ASM
	EXTRN	tOpWatch:NEAR
endif	;TXTDEB_ASM
sEnd	CODE

ife	TXTFIND_ASM
	EXTRN	OtxNoInclPrev:FAR
endif	;TXTFIND_ASM

ife	TXTMOVE_ASM
endif	;TXTMOVE_ASM

sBegin	CP
ife	TXTDATA_ASM
	EXTRN	TDataStart:NEAR
	EXTRN	TDataEntry:NEAR
	EXTRN	TDataEnd:NEAR
endif	;TXTDATA_ASM

ife	TXTDEB_ASM
	EXTRN	WatchMoved:NEAR
	EXTRN	ClrBpTxt:NEAR
	EXTRN	ChkWatchErr:NEAR
endif	;TXTDEB_ASM

ife	TXTFIND_ASM
	EXTRN	TxtSkipOp:NEAR
	EXTRN	TxtFlushCache:NEAR
	EXTRN	TxtMoved:NEAR
	EXTRN	TxtChkCache:NEAR
endif	;TXTFIND_ASM

ife	TXTLOAD_ASM
	EXTRN	LoadExitProc:NEAR
	EXTRN	LoadEnterProc:NEAR
	EXTRN	MakFilename:near
	EXTRN	OpenChan:near
	EXTRN	CloseChan:near
	EXTRN	SetPsErrMsg:NEAR
	EXTRN	InsertDynDiff:NEAR
	EXTRN	InsertEtDiff:NEAR
	EXTRN	SqueezeDefs:NEAR
endif	;TXTLOAD_ASM

ife	TXTMGR_ASM
	EXTRN	TxtDelete:NEAR
	EXTRN	TxtInsert:NEAR
	EXTRN	TxtInsUpdate:NEAR
 	EXTRN	TxtParseUndo:NEAR
	EXTRN	TxtCopyScrap:NEAR
	EXTRN	TxtInsScrap:NEAR
endif	;TXTMGR_ASM

ife	TXTTHR_ASM
	EXTRN	UpdateLinks:NEAR
	EXTRN	TxtDelThread:NEAR
endif	;TXTTHR_ASM

ife	TXTUTIL_ASM
	EXTRN	TxtReEnter:NEAR
	EXTRN	TblReInclude:NEAR
	EXTRN	DoReParse:NEAR
	EXTRN	ReParseTbl:NEAR
	EXTRN	EtDiff:NEAR
	EXTRN	UpdatePcs:NEAR
	EXTRN	SystemDescanCP:NEAR
	EXTRN	SystemDescanRudeCP:NEAR
	EXTRN	ChkLastAsText:NEAR
	EXTRN	PreScanAsChg:NEAR
endif	;TXTUTIL_ASM

sEnd	CP


; Debug functions
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\txtmgr.h ===
/* File: txtmgr.h - Defines which apply to the QBI Text Manager 	*/
/* NOTE: When making changes to this file, be sure to make equivalent	*/
/*	 changes to file TXTMGR.INC					*/

#undef TXTMGR_H
#define TXTMGR_H ON	   /* remember that this file has been included */

#if !HEAP_H
# include "heap.h"
#endif

/**======================================================================**
 **==		External Interface to Text Manger Component	       ==**
 **======================================================================**/

/* special lnInsert values for LoadFile(psdFilename, lnInsert) */
#define LF_NewProg	0xFFFF	/* do a NEW before the load */
#define LF_NewModule	0xFFFE	/* don't do a NEW before the load */
#define LF_ViewIncl	0xFFFD	/* load INCLUDE file for editing */
#define LF_NewDoc	0xFFFC	/* load a document into a window */

/* The global static txtErr contains return values from TxtDirect */
typedef struct txtErrType {
   ushort errCode;   /* offset into the QBI Message Table (MSG_xxx) or,
			if UNDEFINED, ps.bdpError contains the parser-built
			ASCII error message */
   ushort oRs;	     /* identifies the text tbl where the error is.  only valid
			if fDirect is FALSE */
   ushort otx;	     /* text offset where the error is */
   ushort oSrc;      /* UNDEFINED if the error was caught by the scanner.
			   The user interface is responsible for invoking
			   the lister to map the txtErr.otx to a line and
			   column which can be displayed to the user.
			else The error was caught by the parser.
			   oSrc identifies the column within the source
			   line where the error occurred. */
   char fDirect;     /* TRUE if error was in direct mode buffer,
			FALSE if it was somewhere in loaded program */
   } txtErrType;

EXTERNAL txtErrType txtErr;   /* TxtDirect's Exit parm structure */
EXTERNAL uchar txtFindIndex;
   /* return value set by TxtFindOp (and friends).  If 1st opcode in
      list was found, 1 if 2nd opcode in list was found etc.
      (this is only set if parm2 is not NULL on entry) */
extern uchar fViewInclude;
   /* non-zero if user wants to see INCLUDEd source lines */
extern uchar fLnNotIncl;
   /* static return value of LnOfOtx, OtxOfLn, OtxBolOfOtx zero if given
      line was an INCLUDEd line */
extern ushort cWatch;
   /* number of watch expressions in all loaded modules */


/* The following masks get ORed into compSwitches by SetCompSwitches() */
#define COMP_SW_E 1	/* set for each module which has ON ERROR stmt */
#define COMP_SW_X 2	/* set for each module which has RESUME NEXT stmt */
#define COMP_SW_V 4	/* set if any module has ON <event> stmt */
#define COMP_SW_W 8	/* set if any module has ON <event> stmt */
extern uchar compSwitches;

void FAR TxtDescan(void);
void FAR TxtModified(void);
void NEAR TxtDescanCP(void);
void NEAR ChkAllUndefPrs(void);
void NEAR ChkAllUndefPrsSaveRs(void);
void NEAR FreeAllUndefPrs(void);
ushort FAR TxtChange(ushort, ushort, ushort);
ushort FAR TxtPaste(ushort, ushort);
void FAR TxtStartBigEdit();
bool FAR TxtEndBigEdit();
ushort FAR TxtDirect(void);
ushort FAR SystemScan(void);
ushort FAR TxtViewIncl(ushort, boolean);
ushort NEAR TxtSegCurCP(void);
ushort NEAR TxtTblSegCurCP(void);
ushort FAR LoadFile(sd *, ushort);
ushort FAR SaveFile(void);
ushort FAR FileGetLineBd(bd *);
ushort FAR SaveAllDeclares(void);
boolean FAR AskRudeEditFar(void);
ushort FAR TxtReInclude(void);
boolean FAR fNextStmtDoesIO(void);
void FAR WatchDel(ushort);
void FAR SkipStop(void);

boolean NEAR TxtCurInit(void);
ushort NEAR TxtDiscard(void);
void NEAR TxtActivate(void);
void NEAR TxtDeactivate(void);
void FAR TxtPrsInit(ushort);
boolean NEAR TxtFree(ushort);
void NEAR TxtMoveDown(ushort, ushort);
boolean NEAR TxtMoveUp(ushort, ushort);
ushort NEAR GetWOtx(ushort);
void NEAR PutWOtx(ushort, ushort);
boolean NEAR InsertWOtx(ushort, ushort);
ushort NEAR TxtFindOp(ushort, ushort *);
ushort NEAR TxtFindNextOp(ushort, ushort *);
ushort NEAR TxtFindOpDs(ushort, ushort *);
ushort NEAR TxtFindNextOpDs(ushort, ushort *);
ushort NEAR TxtFindOpExec(ushort, ushort *);
void NEAR TxtDeThread(ushort *, ushort, ushort);
void NEAR TxtInsThread(ushort *, ushort *, ushort, ushort);
void NEAR TxtAddThread(ushort *, ushort);
ushort NEAR TxtBindPrsS(boolean);
void NEAR OtxDefType(void);
void NEAR OtxDefTypeEot(void);
void FAR SystemDescanRude(void);
void NEAR ModuleRudeEdit(void);
void FAR ModuleRudeEditFar(void);
boolean NEAR ChkDelPrs(boolean);
ushort FAR SetViewInclude(uchar);
ushort FAR LnOfOtx(ushort);
ushort NEAR OtxEndProg(void);
ushort FAR OtxOfLn(ushort);
ushort FAR OtxBolOfOtx(ushort);
ushort FAR OtxBosOfOtx(ushort);
ushort FAR OPrsOfOtx(ushort);
ushort NEAR OtxResume(ushort);
ushort NEAR OtxTypDefined(ushort);
ushort FAR DescanOpcode(ushort);
ushort FAR SetCompSwitches(void);

/* BASIC Debugger functions */
boolean FAR ToggleBp(ushort);
void FAR ClrBpAll(void);
boolean FAR fBpSet(ushort);

# define DbObdlOpcodes(x) {;}
# define DbChkTxdCur() {;}
# define DbChkTxdThr() {;}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\ssint.inc ===
;*** 
;ssint.inc
;
;	Copyright <C> 1988 Microsoft Corporation
;
;
;*******************************************************************************

;SSINT	- Scanner internal interface definitions
SSINT_INC = ON

	IncludeOnce	architec
	IncludeOnce	scanner

;=============================================================
;Constants
;

LOWUND		EQU LOW UNDEFINED

RB_fSizeOp	EQU 80h 	;Rule table constant - indicates cbTyp operand

LineUpdate	=	64	;Number of lines scanned per screen update
				;MUST be power of two!!!

ET_FormRec	equ	ET_MAX

;=============================================================
;Scanner Stack Entry Definitions
;

;Scan stack frame ids - major types
STYP_If 	EQU 100h	;IF stack entry label
STYP_Else	EQU 200h	;opStElse that matches an If
STYP_For	EQU 400h	;FOR block identifier
STYP_DefFn	EQU 800h	;DEF FN block identifier
STYP_Do 	EQU 1000h	;DO block identifier
STYP_While	EQU 2000h	;WHILE block identifier
STYP_Case	EQU 4000h	;SELECT CASE block identifier
STYP_StackEnd	EQU 0		;End of stack token

;Scan stack frame ids - modifiers
STYP_Block	EQU  1		;TRUE for block varients of IF and ELSE
STYP_Lab	EQU  2		;Label varient of IF

STYP_Step	EQU  4h 	;STEP clause in FOR

STYP_DoWhile	EQU 10h 	;DO While varient of DO
STYP_DoUntil	EQU 20h 	;DO Until varient of DO
STYP_CaseTo	EQU 40h 	;CASE IS <const> TO <const> varient of SELECT
STYP_CaseRel	EQU 80h 	;CASE [IS <relop>] <const> varient of SELECT

;Scan stack frame ids - common combinations
STYP_IfLab	EQU  STYP_If OR STYP_Lab
				;Label varient of IF
				; Frame contains the oTx of the IF oTx field
STYP_IfBlock	EQU  STYP_If OR STYP_Block
				;Block IF stack entry label
				; Frame contains the oTx of the IF oTx field
STYP_ElseBlock	EQU  STYP_Else OR STYP_Block
				;opStElse that matches an IfBlock
STYP_ElseNop	EQU  STYP_Else OR STYP_Lab
				;opStElseNop which matches a preceding opStIfLab

;The following stack frame identifiers are used on the debug stack only.
STYP_Exp	EQU -5		;Present in debug stack only.
STYP_VtRf	EQU -4		;Present in debug stack only.
STYP_AVtRf	EQU -3		;Present in debug stack only.
STYP_ArgCnt	EQU -2		;Present in debug stack only.

;===========================================================================
;Scan stack Structure Definitions
;
;The following structures are present on the scan stack.

;FOR structure is used for all varients of FOR (but not EXIT FOR).
FFOR	STRUC
FFOR_Id 	DW 0
FFOR_oTx	DW 0
FFOR_oTxExit	DW 0 ;Must align with FDO_oTxExit
FFOR_oTxIdRf	DW 0
FFOR_oTyp	DW 0
FFOR	ENDS

;IF structure is used for all varients of IF/THEN/ELSEIF

FIF	STRUC
FIF_Id		DW 0
FIF_oTx 	DW 0
FIF_oTxBranch	DW 0
FIF	ENDS

;DO structure is used for all looping constructs DO/LOOP, and WHILE/WEND

FDO	STRUC
FDO_Id		DW 0
FDO_oTxLoop	DW 0
FDO_oTxExit	DW 0 ;Must align with FFOR_oTxExit
FDO	ENDS

;SELECT CASE structure is used for all varients of SELECT CASE / END SELECT

FCASE	STRUC
FCASE_Id	DW 0
FCASE_oTyp	DW 0
FCASE_oTxBranch DW 0
FCASE_oTxTrue	DW 0
FCASE_oTxFalse	DW 0
FCASE	ENDS

;Expressions

FEXP	STRUC
FEXP_oTyp	DW 0
FEXP_oTx	DW 0
FEXP	ENDS

;===========================================================================
;oType contains two fields.
;	The low 13 bits is either a key value for native types or is an
;	offset into the type table to a user defined type definition.
;	The high 3 bits are used by the scanner to identify the origin
;	of the argument to handle several special cases. (ST=scanner type)

ET_RC	equ	0		;Scan stack only ET type for records

;Flag bits in high byte of scan stack oTyp entry
ST_Form	=	1
ST_Seg	=	8
ST_ByVal=	10H

ST_Typ_Mask =	00ffh		;oTyp stored in low byte. Records use ET_RC.

ST_Flags=	not ST_Typ_Mask ;Mask for flag field
ST_Bits =	2000h		;First available bit

;		0*ST_Bits	;All expressions not covered by below
ST_Marker=	1*ST_Bits	;Marker for non-oType stack entries
ST_Lit	=	2*ST_Bits	;Argument is literal without operand
				;  (Replace executor to coerce to R4)
ST_LitX =	3*ST_Bits	;Argument is literal with operand or with unary minus
				;  (OK for static array in DIM index)

;For these types, Ld executors get replaced with Rf's on procedure calls
ST_ArrVar=	4*ST_Bits	;Argument is from opAIdLd
ST_SimpVar=	5*ST_Bits	;Argument is from opIdLd
ST_RecArVar=	6*ST_Bits	;Argument is from opOffLd off array
ST_RecScVar=	7*ST_Bits	;Argument is from opOffLd off scalar

;Derived bit patterns to optimize certain tests
;WARNING!! Some scanner code is very sensitive to bit assignments!
ST_Lit? =	ST_Lit and ST_LitX		;non-zero if literal
ST_RecVar=	ST_RecArVar and ST_RecScVar
ST_Var? =	ST_SimpVar and ST_ArrVar and ST_RecVar
ST_Array?=	ST_Flags and not ST_ArrVar	;Test zero if array var.
ST_Record?=	ST_RecVar and not ST_Var?	;Test non-zero if record
ST_ArrayBit=	ST_ArrVar xor ST_SimpVar	;Bit set if not array

;======================================================================
;SsRefarg flags
;Passed in dh to indicate details of required reference argument
;These must be the same as certain bit assignments in SsProc.
;Verification is made there.
Lvalue	=	3			;Indicates copy back needed
FarArg	=	28H			;Make sure argument is FAR
FScb	=	10H			;Far ref w/length to be used for FS

;======================================================================
;SsBosFlags definitions
;	These flags show state that lasts during a statement.
;	SsBosFlags is set to zero at each BOS.
;
SSBOSF_StCommon EQU	1	;COMMON statement detected
SSBOSF_StShared EQU	2	;SHARED statement detected
SSBOSF_StStatic EQU	4	;STATIC statement detected
SSBOSF_Const	EQU	8	;Scanning CONST statement
SSBOSF_Inserted EQU	10H	;Insertion occured in this statement
SSBOSF_PcUpdate EQU	20H	;PC update pcode exists in this statement
SSBOSF_StCase	EQU	40H	;CASE syntax processing required for this line

;General-purpose scanner flags, kept in SsFlags:
SSF_ScanAndExec EQU	1	;ScanAndExec is processing CONST statement
SSF_HaveDimmed	EQU	2	;Have done a DIM: OPTION BASE illegal
SSF_If		EQU	4	;IF syntax processing required for this line
SSF_StSelect	EQU	8	;SELECT CASE <stmt lst> CASE checking is
				;required
SSF_InType	EQU	10H	;Inside a TYPE declaration
SSF_CantCont	EQU	20H	;Call CantCont at end of scan

;=======================================================================
;Text table link list maintenance structure.  This structure is allocated
;as a local variable on the scanner stack.
;

TXLNK		STRUC
TXLNK_LabDefNext	DW 0	;oTx of next link in label definition list
TXLNK_LabDefLast	DW 0	;oTx of last link in label definition list
TXLNK_Data		DW 0	;oTx of last link in DATA list
TXLNK_DefType		DW 0	;oTx of last link in DEFtyp list
TXLNK_Type		DW 0	;oTx of last link in TYPE/END TYPE list
TXLNK_DefFn		DW 0	;oTx of last link in DEF FN/END DEF list
TXLNK		ENDS

;SSL		STRUC
;SSL_oTxLabDefNext	DW 0	;offset of next label definition
				;(unrelocated for expansion.)
;SSL_oTxLabDefLast	DW 0	;offset of last bound label definition
;SSL		ENDS

;=======================================================================
;Data segment locations
;


sBegin	DATA
ife	SSDATA_ASM
extrn	SsErrOTx:word		;oTx of pcode which was replaced by opEot
extrn	SsErr:word		;Error code to be returned by scanner.
extrn	SsErrOpcode:word	;Opcode which was replaced by opEot
extrn	SsDelayErr:word		;Error code of delayed error
extrn	SsDelayLoc:word		;oTx of delayed error
extrn	SsDelayCnt:word		;Count of pending delayed errors
extrn	SsStackSave:word	;Scanner sp at start of scan loop

extrn	f_Static:byte		;TRUE if current array type default is $STATIC

extrn	f_StaticCalc:byte	;TRUE if current array would be $STATIC if this
				; were the first reference.

extrn	SsExec:word		;SsExecFlag and SsExecTmp together
extrn	SsExecFlag:byte		;OPA_fExecute ORed in if can't allow COMMON
extrn	SsExecTmp:byte		;Temporary hold for SsExecFlag during CONST
extrn	ScanRet:word		;Contains address of scanner main loop
extrn	SsOTxBOS:word		;Offset of last encountered BOS
extrn	SsOTxPatchBos:word	;Address of executor to be patch with Bos
extrn	SsOTxStart:word 	;Address of point were stack was clear.  This
				;is used to find the bounds for Dim as well as
				;the insertion point for CDecl calls.
extrn	ScannerFlags:word	;SsBosFlags and SsFlags together
extrn	SsBosFlags:byte		;Scanner begin of statement flags
extrn	SsFlags:byte		;General scanner flags
extrn	SsCbTxExpand:word	;CB of text expansion during scanning.
extrn	SsLinkCtl:word		;Label Control Structure
extrn	SsCbFrameTemp:word	;Temp space for current statement

;Data for update of return addresses on stack
extrn	SsNextOTx:word		;oTx of return address
extrn	SsReturnBp:word		;offset in stack of return frame

;ScanAndExec data
extrn	SsScanExStart:word	;Starting address of execution
extrn	SsScanExSrc:word	;oTx of original source

	;Data used by ssproc to count param bytes for CDECL calls

extrn	SsCbParmCur:word	;cb of all params so far
extrn	SsParmCnt:word		;Number of parameters

extrn	SsOtxHeapMove:word	;oTx of last possible heap movement
extrn	SsBosStack:word		;SP-2 at start of statement

endif			;SSDATA_ASM
sEnd	DATA


;=======================================================================
;Entrypoints defined in SsScan.asm
;

ife	SSSCAN_ASM
	extrn	ScanExExit:far	;jmp here to terminate execution from scanner
endif				;ife SSSCAN_ASM

sBegin	SCAN			

ife	SSSCAN_ASM
extrn	ScanExit:near		;jmp here when scan is complete
extrn	SsScanExExit:near	;jmp here when scan of ScanAndExec is done
extrn	ExecuteFromScan:near	;Fire up execution from scanner

extrn	SsError:near		;Scanner error handler
extrn	SsErrorBx:near		;Scanner error handler--emit oTx bx
extrn	SsFrameType:near	;Report nesting error
extrn	DescanTerm:near 	;Descan loop termination address
extrn	DescanX:near		;Rude descan loop termination address
endif				;ife SSSCAN_ASM

;======================================================================
;Entrypoints defined in ssid.asm
;
ife	SSID_ASM
extrn	SsGetISFC:near		;Id opcode to executor scope resolution
extrn	GetCxISFC:near
endif				;ife SSID_ASM

;======================================================================
;Entrypoints defined in ssaid.asm
;
ife	SSAID_ASM
extrn	SsIndexType:near	;Index into executor map based on oType
extrn	SsIndexTypeCx:near	;Index into executor map based on oTyp in cx
extrn	SsIndexISFC:near	;Index into executor map based on ISFC
extrn	SsEmitExecutor:near	;Get executor from map and emit with operand

extrn	MakeArrayRef:near	; Convert AIdLd to AdRf.
endif				;ife SSAID_ASM

;======================================================================
;Entrypoints defined in sstxutil.asm
;
ife	SSTXUTIL_ASM
extrn	SsMakeGap:near		;Create initial gap between source and emit pcode
extrn	SsEnsureGap:near	;Ensure a gap between source and emit pcode
endif				;ife SSTXUTIL_ASM

;======================================================================
;Labels in exconv.asm
ife	EXCONV_ASM
extrn	tImpCo:word	;Table of implicit coercion executors
endif				;EXCONV_ASM

;========================================================================
;Tables and entrypoints defined in SsRules.asm
;
ife	SSRULES_ASM
extrn	EnsureArgType:near	;Ensure top stack argument is of correct type
extrn	SsCoerceReg:near	;Coercion handler (args in registers)
extrn	SsCoerceN:Near		;Coercion handler for n stack entries
extrn	TMError:near		;Type Mismatch Error
extrn	TMErrorNZ:near		;Type Mismatch Error if ZF not set
extrn	tRuleByte:byte		;Rule byte - usually an emitted type
extrn	tRuleWord:word		;Rule word - usually a coercion table address
extrn	mpOpRule:byte		;Opcode to rule table
extrn	Insert:near		;Insert into text
extrn	InsertCx:near		;Insert into text
extrn	InsertBranchBos:near	;Insert branch after opBos
extrn	InsertBranch:near	;Insert into text
extrn	Insert1Op:near		;Insert into text
endif			;ife SSRULES_ASM

;======================================================================
;SSBOS resident routines
;
ife	SSBOS_ASM
extrn	EmitExCopyOps:near	;Emit executor and copy operands
extrn	CopyOperands:near	;Copy operands for opcode bx from si to di
extrn	LabelBindCur:near	;Bind a label reference to current scope
extrn	SsBosStack:word		;SP-2 at start of statement
endif				;SSBOS_ASM

;========================================================================
;Scanner specific tables built by OPTABLER
;
extrn	mpOpExe:word		;Opcode to executor (or executor map) table
extrn	mpOpAtr:byte		;Opcode to atribute table
extrn	mpOpScanDisp:word	;Opcode to scanner dispatch table


;======================================================================
;Scanner internal entrypoint declarations for ssdescan.asm
;
ife	SSDESCAN_ASM
extrn	SsLabelRefDebind:near
extrn	SsD_NOps:near
endif				;SSDESCAN_ASM
sEnd	SCAN			

;======================================================================
;Scanner internal entrypoint declarations for ssif.asm
;
ife	SSIF_ASM
extrn	MapOpToExeNumeric:near
endif				;SSIF_ASM

;======================================================================
;Scanner internal entrypoint declarations for ssoperat.asm
;
ife	SSOPERAT_ASM
extrn	MSdFs:near
endif				;SSOPERAT_ASM

;======================================================================
;Scanner internal entrypoint declarations for ssmisc.asm
;
ife	SSMISC_ASM
extrn	GetRuleInfo:near
extrn	FindFrame:near
extrn	CbFrameSTYPCx:near
extrn	SsAllocOFrame:near
extrn	BindExit:near
extrn	BindExitCur:near
extrn	CbTypOTypSCAN:near	
extrn	CbTypOTypOMrsSCAN:near	
endif				;SSMISC_ASM

;=============================================================================
;Scanner internal entrypoint declarations for ssproc.asm
;
ife	ssproc_asm
extrn	ByValMarker:abs		;Rule table entries for BYVAL
extrn	SegMarker:abs		;   and SEG

extrn	SsCallFunc:near		;Entry point to SSPROC from SSID and SSAID
				;   for function calls
extrn	SsReLinkDecl:near	;Adjust PRS_otxDef and copy operands
extrn	SsReLinkNoCopy:near	;Adjust PRS_otxDef
extrn	SsFindOpNoList1:near	;Find NoList pcodes
extrn	CopyOps:near		;Copy operands and dispatch
endif				;SSPROC_ASM

;=============================================================================
;Scanner internal entrypoint declarations for ssrec.asm
;
ife	ssrec_asm
extrn	MakeRef:near
endif				;SSREC_ASM

;=============================================================================
;Scanner internal entrypoint declarations for ssrefarg.asm
;
ife	ssrefarg_asm
extrn	AllocTemp:near
extrn	SsRefArg:near		;Handle all reference argument problems
endif				;SSREFARG_ASM


;=============================================================================
;Scanner internal entrypoint declarations for ssdeclare.asm
;
ife	ssdeclare_asm
extrn	SetArrayType:near
endif				;SSDECLARE_ASM

;=============================================================================
;Scanner Macros and equates
;

;Scan Routine entry point definition

SsProcRude	EQU -4		;Rude mode scan and descan dispatch
SsProcParse	EQU -2		;Parse mode descan dispatch

	;Scan to SS_EXECUTE mode dispatch declaration macro

SsProc	MACRO	ScanNam,Rude,Local
ifnb	<&Rude>
extrn	SsV_&ScanNam:near
	DW	scanOFFSET SsV_&ScanNam
endif
public	Ss_&ScanNam
ifb	<&Local>
extrn	SsD_&ScanNam:near
endif
	DW	scanOFFSET SsD_&ScanNam
Ss_&ScanNam&:
	ENDM

	;Rude mode dispatch point declaration macro


SsVProc MACRO	ScanNam
	public	SsV_&ScanNam
SsV_&ScanNam&:
	ENDM


	;Descan to SS_PARSE mode dispatch point declaration macro


SsDProc MACRO	ScanNam
	public	SsD_&ScanNam
SsD_&ScanNam&:
	ENDM


	;Pcode location macros

PTRTX	equ	<word ptr es:>

LODSWTX equ	<lods word ptr es:[si]>
STOSWTX equ	<stos word ptr es:[si]>
MOVSWTX equ	<movs word ptr es:[si],word ptr es:[di]>

TEXTSEG equ	<db 26h>


sBegin	CODE	;DWEXT needs codeOFFSET defined, and this does it
sEnd	CODE


DWEXT	MACRO	pex,fDefine
	ifb	<fDefine>		;; fDefine specified?
	    extrn   pex:far		;; No, generate offset
	    dw	    codeOFFSET pex
	elseif	    fDefine		;; Yes, use specified fDefine
	    extrn   pex:far
	    dw	    codeOFFSET pex
	endif
	ENDM


DWFILL	MACRO	fDefine
	ifb	<fDefine>		;; fDefine specified?
	    dw	    ?			;; No, Assume true
	elseif	fDefine 		;; Yes, use specified fDefine
	    dw	    ?
	endif
	ENDM



DWIF	MACRO	wData,fDefine		;
	if	fDefine 		;
	    dw	    wData		;
	endif				;
	ENDM				;


DBIF	MACRO	bData,fDefine		;
	if	fDefine 		;
	    db	    bData		;
	endif				;
	ENDM				;


;***
;PUSH_ES, POP_ES, REFRESH_ES macros
;
;Purpose:
;	There are a number of places in the scanner where we can simply
;	push the text segment prior to a far call and pop it on return in
;	non-windows versions (i.e., the called routine promises to cause
;	no heap movement).  In windows versions, however, the far call could
;	cause a thunk and thus heap movement.  PUSH_ES/POP_ES allow us
;	to generate the minimal required code for either case.
;
;	REFRESH_ES is similar, but for the case where the called routine
;	itself preserves ES.
;
;	Added as part of revision [3].
;****


PUSH_ES     equ     <push es>
POP_ES	    equ     <pop es>
REFRESH_ES  equ     <>



;===========================================================================
;Scanner Debug Macros and equates
;


SsDbStackIni	equ	<>
SsDbStackEmpty	equ	<>

SsDbStackPush	MACRO	type
		ENDM

SsDbStackPop	MACRO	type
		ENDM
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\types.inc ===
;*** 
;types.inc - externs for the type manager
;
;	Copyright <C> 1985, 1986, 1987, 1988 Microsoft Corporation
;
;
;*******************************************************************************
TYPES_INC = ON

sBegin	CP
ife TYPMGR_ASM
	EXTRN	DefineTyp:far		
	EXTRN	RefTyp:far		
	EXTRN	DefineElem:near
	EXTRN	DefineElemFixed:near
	EXTRN	RefElem:far		
	EXTRN	ONamOElem:far
	EXTRN	ONamOTyp:far
	EXTRN	CompareTyps:far 	
endif
sEnd	CP
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\util.h ===
/* File: util.h - Forward references & constants for module util.asm.   */
/* NOTE: When making changes to this file, be sure to make equivalent	*/
/*			changes to file util.inc													*/

#undef UTIL_H
#define UTIL_H ON				/* to prevent duplicate #include's */

VOID FAR ZeroFill(char *, ushort);
VOID FAR FillUndef(ushort *, ushort);
VOID FAR CopyBlk(char *, char *, ushort);
ushort FAR CbSz(char *);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\util.inc ===
; File: UTIL.INC
; NOTE: When making changes to this file, be sure to make equivalent
;	changes to file UTIL.H

UTIL_INC = ON

;============================================================================
;the following EXTRN's are included in ALL files EXCEPT util.asm
;============================================================================
ife	UTIL_ASM
sBegin CP
	EXTRN	ZeroFill:far
	EXTRN	FillUndef:far
	EXTRN	CopyBlk:far
	EXTRN	CbSz:far

	EXTRN	CmpPsdIns:near
	EXTRN	CmpStrIns:near
	EXTRN	MapCpW:near
	EXTRN	MapEsW:near
	EXTRN	RelTempSd_CP:near
sEnd CP
endif
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\txtmgr.inc ===
; File: TXTMGR.INC
; NOTE: When making changes to this file, be sure to make equivalent
;	changes to file TXTMGR.H
;	See file TXTMGR.H for comments.

TXTMGR_INC = ON


DbTxtFind	MACRO	pTbl
		ENDM
DbChkTxdCur	MACRO
		ENDM


;
; GetSegAddr CODE returns the address of the code segment in ax
; GetSegAddrSCAN CODE does the same, but is used from the SCAN segment
;

GetSegAddr	MACRO	SegName
	EXTRN	Seg_&SegName:abs
	mov	ax,SEG Seg_&SegName
	ENDM

GetSegAddrSCAN	MACRO	SegName
	EXTRN	Seg_&SegName:abs
	mov	ax,SEG Seg_&SegName
	ENDM


SetfDirect MACRO reg,value
ifb	<value>
	mov	[grs.GRS_fDirect],reg
else
	mov	[grs.GRS_fDirect],value
endif
	ENDM

PopfDirect MACRO Reg
	local	RegLet
RegLet	substr	<Reg>,1,1		;; First letter of register
	pop	Reg
%	mov	[grs.GRS_fDirect],RegLet&&l
	ENDM

; macro to set es=seg addr of current text table
; fDirect must be FALSE
GetSegTxtTblCur	MACRO
	GETSEG	es,[txdCur.TXD_bdlText_seg]
	ENDM

; macro to set es=seg addr of current text table
; 
GetSegTxtCur	MACRO
      % call	TxtSegCur&&?segname
	ENDM



THDR_ST			STRUC
THDR_otxLabLink		DW 0
THDR_otxDefTypeLink	DW 0
THDR_otxTypeLink	DW 0
THDR_otxReParseLink	DW 0
THDR_ST			ENDS
THDR_SIZE		EQU size THDR_ST
; THDR_SIZE is the constant offset to 1st byte of pcode in text table

;The global static txtErr contains return values from TxtDirect
TXER_ST		STRUC
TXER_errCode	DW 0	;offset into the QBI Message Table (MSG_xxx) or,
			;if UNDEFINED, ps.bdpError contains the parser-built
			;ASCII error message
TXER_oRs	DW 0	;identifies the text table with the error (only valid
			;if fDirect is FALSE)
TXER_otx	DW 0	;offset into text table where error occurred
TXER_oSrc	DW 0	;UNDEFINED if the error was caught by the scanner.
			;The user interface is responsible for invoking
			;the lister to map the txtErr.otx to a line and
			;column which can be displayed to the user.
			;else The error was caught by the parser.
			;oSrc identifies the column within the source
			;line where the error occurred.
TXER_fDirect	DB 0	;TRUE if error was in direct mode buffer,
			;FALSE if it was somewhere in loaded program
TXER_ST		ENDS


;Macros used to build tables of opcodes used by TxtFind[Next]Op
;See TxtFindNextOp for a description of the format of these tables
;
opTabStart MACRO	tableId
	DW	tableId&_opEot+1	;num entries in table
	opTabCur = 0
	endm

;Highbit set in 1st word of table tells TxtFind... to search the table
;for each opcode, even if opcode's OPA_TxtFind bit is not set.
;This form is used for tables which are not searched at speed sensitive
;times.
;
opTabStartAll MACRO	tableId
	DW	8000h+tableId&_opEot+1	;num entries in table
	opTabCur = 0
	endm

opTabEntry MACRO	tableId,opId
	tableId&_&opId EQU opTabCur+0	;+0 means value, not alias for opTabCur
	opTabCur = opTabCur + 1
	DW opId
	endm

FLoadActive MACRO
	cmp	[cChansOpen],0
	ENDM

;Enumerated parm values for TxtBindPrsS
;
TBIND_Load	EQU 0	;map pcode oNam->oPrs, call PrsDefine
TBIND_Save1	EQU 1	;map pcode oPrs->oNam - called before writing to file
TBIND_Save2	EQU 2	;map pcode oNam->oPrs - called after writing to file

;special lnInsert values for LoadFile(psdFilename, lnInsert)
;
LF_NewProg	EQU 0FFFFH	;do a NEW before the load
LF_NewModule	EQU 0FFFEH	;don't do a NEW before the load
LF_ViewIncl	EQU 0FFFDH	;load $INCLUDE file for editing
LF_NewDoc	EQU 0FFFCH	;load a document into a window

sBegin	DATA
ife TXTMGR_ASM
	EXTRN	flagsTm:byte	;text mgr flags - FTM_xxx
endif
	FTM_reInclude EQU 1	;if set, re-include all include files before
				; next static scan
				;SS_EXECUTE
	FTM_NoSsExecute EQU   2H ;set if no text tables are in SS_EXECUTE
	FTM_PrsDefDeleted EQU 4H ;set if a "defining" prs reference has been
				 ;deleted
	FTM_BpDeleted EQU 8H	;break point has been deleted on Editted line
	FTM_TxtPaste  EQU 10H	;We are in a TxtPaste operation
	FTM_WatchPcode EQU 20H	;Set if Watch Pcode exists anywhere
	FTM_SaveProcHdr EQU 40H ;Set when in critical section while Ascii
				; saving a Proc Header. (a temp text table
				; is active).
	FTM_Linking EQU 80H	;set if LinkAllFiles is executing


sEnd	DATA

;CODE segment publics
;
sBegin	CODE
ife	TXTUTIL_ASM
	EXTRN	DescanOpcode:FAR
endif	;TXTUTIL_ASM
sEnd	CODE


;DATA segment publics
;
sBegin	DATA

;The following masks get ORed into compSwitches by SetCompSwitches()
	COMP_SW_E	EQU 1	;set for each module which has ON ERROR stmt
	COMP_SW_X	EQU 2	;set for each module which has RESUME NEXT stmt
	COMP_SW_V	EQU 4	;set if any module has ON <event> stmt
	COMP_SW_W	EQU 8	;set if any module has ON <event> stmt


	EXTRN	txtErr:word
	EXTRN	txtFindIndex:byte
	;return value set by TxtFindOp (and friends).  If 1st opcode in
	; list was found, 1 if 2nd opcode in list was found etc.
	; (this is only set if parm2 is not NULL on entry)

ife	TXTDEB_ASM
	;number of watch expressions in all loaded modules
	EXTRN	cWatch:word
endif	;TXTDEB_ASM

ife	TXTUTIL_ASM
	EXTRN	fViewInclude:byte	;non-zero if user wants to see INCLUDEd
	EXTRN	fLnNotIncl:byte		;static return value of LnOfOtx,
					; OtxOfLn, OtxBolOfOtx.  zero if given
					; line was an INCLUDEd line
	EXTRN	cInclNest:byte		;$INCLUDE nesting depth.  Non-zero if
					; currently loading an $INCLUDE file
	EXTRN	compSwitches:byte
endif	;TXTUTIL_ASM

ife	TXTLOAD_ASM
	EXTRN	cChansOpen:BYTE
endif	;TXTLOAD_ASM

sEnd	DATA

;CP segment publics
;
sBegin	CP

ife	TXTDEB_ASM
	EXTRN	WatchAdd:FAR
	EXTRN	WatchDel:FAR
	EXTRN	WatchInfo:FAR
	EXTRN	WatchRelease:FAR
	EXTRN	ZeroWatchVal:FAR
	EXTRN	DebugReset:NEAR
	EXTRN	fBpSet:FAR
	EXTRN	ToggleBp:FAR
	EXTRN	ClrBpAll:FAR
	EXTRN	FExecutable:FAR
	EXTRN	fNextStmtDoesIO:FAR
	EXTRN	SkipStop:FAR
endif	;TXTDEB_ASM

ife	TXTDIR_ASM
	EXTRN	TxtDirect:FAR
	EXTRN	SystemScan:FAR
	EXTRN	OtxEndProg:NEAR
endif	;TXTDIR_ASM

ife	TXTFIND_ASM
	EXTRN	LnOfOtx:FAR
	EXTRN	OPrsOfOtx:FAR
	EXTRN	OtxOfLn:FAR
	EXTRN	OtxBolOfOtx:FAR
	EXTRN	OtxBosOfOtx:FAR
	EXTRN	OtxBosNext:FAR
	EXTRN	OtxBolNext0:FAR
	EXTRN	OtxLabOfOtx:NEAR
	EXTRN	OtxNoInclude:FAR
	EXTRN	OtxResume:NEAR
	EXTRN	OtxResumeNext:FAR
	EXTRN	OtxTypDefined:NEAR
	EXTRN	TxtFindOp:NEAR
	EXTRN	TxtFindNextOp:NEAR
	EXTRN	TxtFindOpDS:NEAR
	EXTRN	TxtFindNextOpDS:NEAR
	EXTRN	TxtFindOpExec:FAR
	EXTRN	TxtFindNextOpFar:FAR
	EXTRN	TxtSkipOpFar:FAR
	EXTRN	TxtChkValidOpsExec:FAR

endif	;TXTFIND_ASM

ife	TXTLOAD_ASM
	EXTRN	LoadFile:FAR
	EXTRN	GetLineBd:NEAR
	EXTRN	UpdChanCur:NEAR
	EXTRN	StatusMsgCP:NEAR
	EXTRN	StatusMsg0CP:NEAR
	EXTRN	TxtGrowPsSrcEmScratch:FAR

endif	;TXTLOAD_ASM

ife	TXTMGR_ASM
	EXTRN	TxtChange:FAR
	EXTRN	TxtPaste:FAR
	EXTRN	TxtStartBigEdit:FAR
	EXTRN	TxtEndBigEdit:FAR
	EXTRN	TxtBindPrsS:NEAR
	EXTRN	UndefPrs:NEAR
	EXTRN	ChkAllUndefPrsSaveRs:NEAR
	EXTRN	ChkAllUndefPrs:NEAR
	EXTRN	FreeAllUndefinedPrs:NEAR
endif	;TXTMGR_ASM

ife	TXTMOVE_ASM
	EXTRN	TxtCurInit:NEAR
	EXTRN	TxtDelAll:FAR
	EXTRN	TxtDeleteAll:NEAR
	EXTRN	TxtDiscard:NEAR
	EXTRN	TxtActivate:NEAR
	EXTRN	TxtDeactivate:NEAR
	EXTRN	TxtPrsInit:FAR
	EXTRN	TxtFree:NEAR
	EXTRN	TxtFreeFar:FAR
	EXTRN	TxtMoveDown:NEAR
	EXTRN	TxtMoveUp:NEAR
	EXTRN	TxtMoveUpFar:FAR
	EXTRN	GetWOtx:NEAR
	EXTRN	PutWOtx:NEAR
endif	;TXTMOVE_ASM

ife	TXTSAVE_ASM
	EXTRN	SaveAllDeclares:FAR
	EXTRN	SaveFile:FAR
endif	;TXTSAVE_ASM

ife	TXTTHR_ASM
	EXTRN	TxtDeThread:NEAR
	EXTRN	TxtInsThread:NEAR
	EXTRN	TxtAddThread:NEAR
	EXTRN	ScanTypeBlock:FAR
endif	;TXTTHR_ASM

ife	TXTUTIL_ASM
	EXTRN	AskCantCont_CP:NEAR
	EXTRN	AskRudeEdit:NEAR
	EXTRN	AskRudeEditFar:FAR
	EXTRN	TxtFLnIncluded:FAR
	EXTRN	TxtViewIncl:FAR
	EXTRN	TxtDescan:FAR
	EXTRN	TxtModified:FAR
	EXTRN	TxtDescanCP:NEAR
	EXTRN	SystemDescanRude:FAR
	EXTRN	ModuleRudeEdit:NEAR
	EXTRN	ModuleRudeEditFar:FAR
	EXTRN	SetViewInclude:FAR
	EXTRN	TxtReInclude:FAR
	EXTRN	TxtSegCurCP:NEAR
	EXTRN	TxtTblSegCurCP:NEAR
	EXTRN	OtxDefType:NEAR
	EXTRN	OtxDefTypeCur:NEAR
	EXTRN	OtxDefTypeCurFar:FAR
	EXTRN	OtxDefType0Far:FAR
	EXTRN	OtxDefTypeEot:NEAR
	EXTRN	ONamOVarRudeOrParse:FAR
	EXTRN	ChkLastAs:NEAR
	EXTRN	SetCompSwitches:FAR
endif	;TXTUTIL_ASM


sEnd	CP

sBegin	SCAN
ife	TXTUTIL_ASM
	EXTRN	TxtSegCurSCAN:NEAR
endif	;TXTUTIL_ASM
sEnd	SCAN
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\ui.h ===
/***
* File: ui.h - Defines which apply to the QBI User Interface
*
*   Copyright <C> 1987, Microsoft Corporation
*
* NOTE: When making changes to this file, be sure to make equivalent
*   changes to file UI.INC
*
*******************************************************************************/

#undef UI_H
#define UI_H ON            /* to prevent duplicate #include's */

EXTERNAL ushort rsNew INIT(0);

/*
   debugFlags's bits:

   DEBUG_ERROR  - set when a runtime error occurs and is not trapped.
          The runtime error code restores SI to the beginning
          of statement, sets this flag, then re-executes the
          statement, which invokes the debugger.  The error code
          is passed in the same static variable examined by the
          ERR intrinsic function.

   DEBUG_EXEC_CMD - Set when the runtime builds a command in the direct mode
          buffer, and wants it executed.

   DEBUG_STOP   - set when a STOP statement is executed,
          when Ctrl-BREAK is pressed and not trapped,
          or when a breakpoint is reached.

   DEBUG_END    - set by the executors for opEot and opStEnd to indicate
          end-of-program for QB.

          EB specific: when a direct mode statement is executed
          while a previous EB invocation is active, we return from
          TxtExeBreak to use the same frame. DEBUG_END is used
          to get us back.

   DEBUG_WATCHPOINT - set when a Stop-Watch-Expression evaluates to TRUE

   DEBUG_TRACE  - set while tracing statement execution either because
          of TRON, single-step, or procedure-step.

   DEBUG_WATCH  - set when any Watch Expressions are active in the program.

   DEBUG_CANT_CONT - Causes UserInterface() to set grs.otxCONT to
          UNDEFINED the next time it is called.
          This is used by executors, which cannot call CantCont
          because UserInterface sets grs.otxCONT every time
          we enter UserInterface, thus undoing their change.
          Since it sets otxCONT rather than calling CantCont(),
          stack tracing and variable printing are still possible
          from direct mode, just not continuing.
*/

EXTERNAL uchar debugFlags;

#define DEBUG_ERROR 0x01        /* [1] */
#define DEBUG_EXEC_CMD  0x02        /* [1] */
#define DEBUG_STOP  0x04
#define DEBUG_END   0x08
#define DEBUG_WATCHPOINT 0x10
#define DEBUG_TRACE 0x20
#define DEBUG_WATCH 0x40
#define DEBUG_CANT_CONT 0x80


extern bool fDebugScr;  /* non-zero when DEBUG SCREEN is active */
bool fSyntaxCheck;  /* non-zero if syntax errors reported by editor */

/* bit flags to test for command-line switches */
extern ushort cmdSwitches;

//
// a-emoryh - If you change this flag, you must also change it in
//      ..\..\beef\cw\user\meditasm.asm, in addition to changing it in ui.inc.
//      And you'll need to rebuild CW lib.
#define CMD_SW_QHELP    0x0800      /* invoked from QHELP.COM */


#define CMD_SW_EDCOM    0x0400      /*[6] invoked from EDIT.COM */
#define CMD_SW_ED   0x0200      /* in Editor mode */
#define CMD_SW_GLT  0x0100
#define CMD_SW_HAR  0x0040
#define CMD_SW_HIR  0x0020
#define CMD_SW_MBF  0x0010
#define CMD_SW_RUN  0x0008
#define CMD_SW_FLE  0x0004
#define CMD_SW_NOH  0x0002
#define CMD_SW_MNO  0x0001


// a-emoryh - Topic given on command-line gets stored here
extern char szCmdLineTopic[];


#define MIN_EDITLINE    256

#define WATCH_MAX 8
   /* max lines in screen for "Watch Window" */

/* [3] Watch types for CmdWatchAdd and WatchAdd */
#define WT_Watch    0   /* [3] */
#define WT_WatchPoint   1   /* [3] */

void FAR UserInterface(void);
void FAR WatchDeleted(void);
void FAR HistReset(void);
void FAR WnResetMove(ushort);
void far UpdStatusLn(ushort);
short FAR NotSaved(void);
short FAR NotSavedInc(void);
short FAR NotSavedIncSav(void);
boolean FAR AskCantCONT(void);  /* EB_API */
void FAR UiFlushCache(void);
void FAR CmdWatchDelAll(void);
void far CmdViewInclude(bool);
boolean far FileExists(char *);
EXTERNAL bool fTraceOn INIT(FALSE);         /* TRUE if TRACE is active */
EXTERNAL bool fHistOn INIT(FALSE);          /* TRUE if HISTORY is active */
ushort FAR DelFile(char *);
void FAR DiscardHistoryORs(ushort); //[5]


/* Runtime functions invoked by user interface - eliminate when
   we integrate with runtime. */
void FAR PLM InitRuntime();
void FAR PLM OutChar(char);
void FAR PLM OutSz(char *);
void FAR PLM OutSzN(char *);
void FAR PLM OutNl(void);
char FAR PLM Fin();
ushort FAR PLM ListStdMsgFar(ushort);
ushort near PLM ListStdMsg(ushort);

/*
   bdEMScratch and ldEMScratch overlap.
   ldEMScratch is used by the EditMgr of TWIN.
   bdEMScratch is used in prsmain.asm.
*/
extern bd bdEMScratch;

#define CB_bufStdMsg 80    /* size of static structure 'bufStdMsg' */
extern char bufStdMsg[];     /* set by ListStdMsg[Far] */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\varmgr.inc ===
;*** 
; varmgr.inc - structure offsets and other constants for the VarMgr
;
;	Copyright <C> 1985, 1986, 1987 Microsoft Corporation
;
;
;*******************************************************************************
	IncludeOnce	heap

VARMGR_INC = ON

;VARPTR_D Structure- VARPTR$ descriptor definition
VARPTR_D	STRUC
VARPTR_D_oTyp	DW 0
VARPTR_D_pValue	DD 0
VARPTR_D	ENDS

;====================  Variable Table =====================================
;The variable table contains binding information for each variable or 
;function procedure. In many cases, the variable table also contains the value.
;
;There are two logical kinds of variable table. There is one tMV (Module 
;variable table) per module, and it contains module static variables, all 
;COMMON variables, and procedure reference entries.  There is one tPV 
;(Procedure variable table) per procedure, and it contains the formals, 
;dynamics, and an entry for the function return value if it is a function.
;Both logical table types reside in the same physical table; there is one
;of these per module.
;
;These tables are constructed at parse time, or by the rude scanner. They are
;considered to be built at SS_PARSE and not built as SS_RUDE.
;
;Since these tables can be built at parse time, there may be tPV entries for
;variables which are later declared to be functions. This case is handled via
;special code in the varmgr itself (old entries are redirected).
;
;The hash functions for both the tMV and the tPV is a hash on the Name
;Table offset (oNam). The hash tables for the tMV and tPV will be of
;different size.
;
;It is necessary to detect from the variable table which procedure owns each
;variable in the tMV.  This is done using oPrs.  This could be a byte entry
;if each procedure were given a unique byte size identifier.  oPrs for the
;main level is UNDEFINED.  At table build time, variables must be unique by 
;oNam, oPrs, and oTyp.
;============================================================================

; sizes of variable hash tables
CBINITMVHASH	EQU 32d		;size of module hash table for var table
CBINITPVHASH	EQU 16d		;size of a procedure hash table for var table

HASH_MV_NAMMASK	EQU 001EH	;a 32-byte table contains 16 2-byte offsets,
				;each to the start of a unique hash chain.
				;001E in binary is 0000000000011110, i.e.,
				;it is used to mask off all but bits 1,2,3,
				;& 4. When this mask is AND'd with an oNam, 
				;it produces an even hash value (hash table
				;offset) from 0 to 30
HASH_PV_NAMMASK	EQU 000EH	;a 16-byte table contains 8 2-byte offsets,
				;each to the start of a unique hash chain.
				;000E in binary is 0000000000001110, i.e.,
				;it is used to mask off all but bits 1,2,
				;& 3. When this mask is AND'd with an oNam, 
				;it produces an even hash value (hash table
				;offset) from 0 to 14

OMVHASH EQU	0		; module hash table still starts at offset
				; 0 in var table for QB5, at least for now

;AFRAME Structure -	value part of an array frame variable
AFRAME		STRUC
AFRAME_oFrame	DW 0
AFRAME_cDims	DB 0
AFRAME_filler1	DB 0
AFRAME		ENDS

;AFORMAL Structure -	value part of an array formal variable
AFORMAL		STRUC
AFORMAL_oFrame	DW 0
AFORMAL_cDims	DB 0
AFORMAL_filler1	DB 0
AFORMAL		ENDS

IncludeOnce	array	;to get AD struct

;ASTAT Structure -	value part of a static (not frame) array variable
ASTAT		STRUC
ASTAT_filler0	dw 0
ASTAT_cDims	DB 0
ASTAT_filler1	DB 0
ASTAT_ad	DB SIZE AD DUP(0)
ASTAT		ENDS

.errnz	AFRAME_cDims - AFORMAL_cDims
.errnz	AFRAME_cDims - ASTAT_cDims

CDIMS_DEFAULT	EQU	8	;default (assumed) number of dimensions in
				;  an array.


;VAR Structure - variable table entry
;Note that the oTyp field is only present when the low 3 or 4 bits in the flags
;	field are not all zero. A pointer to this structure points to the
;	value field.
VAR_oMrsTyp	EQU -10 	; only for PUBLIC's of user-defined type
VAR_oNamForm	EQU -8		; used for form/menu variables only
VAR_cbFixed	EQU -8
VAR_oTyp	EQU -8
VAR_oNam	EQU -6
VAR_oHashLink	EQU -4
VAR_flags	EQU -2
VAR_value	EQU 0

VAR_fStat EQU	VAR_oHashLink	;flag FV_STATIC stored in low bit of oHashLink

VAR_STRUCT_SIZE EQU 6		;size of the size-invarient part of var entry

;Macro for getting oTyp
;Arguments:
;	1.  16-bit register for oTyp
;	2.  Address expression which evaluates to pVar
;
;For example, a typical invocation would be
;	GetOtyp	ax,[bx]		;bx points to variable table entry
;
GetOtyp	Macro	Reg,pVar
	local	HavOtyp
	mov	Reg,pVar+VAR_flags
	and	Reg,FV_TYP_MASK
	jnz	HavOtyp
	mov	Reg,pVar+VAR_oTyp
HavOtyp:
	endm

;Text macro for accessing a var entry
;Assumes that in FV_LONGPTR case, var table is a far item, and
;	ES is set to the var table segment
PTRVAR	EQU	word ptr 
BPTRVAR	EQU	byte ptr 


;================ Variable Manager Interface Definitions =================
;
;The following constants, types, and procedures define the interface
;to the variable manager.
;=========================================================================

;Flag constants used with MKVAR_flags2, below
MV_fConstFound	EQU	01H
MV_fONamInOTyp	EQU	02H
MV_fDontCreate	EQU	04H
MV_fRecRef	EQU	08H

;MKVAR - global structure used as input to MakeVariable():
MKVAR_TYPE		STRUC
MKVAR_flags		DW 0
MKVAR_exitFlags		DW 0
MKVAR_oNam		DW 0
MKVAR_oTyp		DW 0
MKVAR_flags2		DB 0
MKVAR_cDimensions	DB 0
MKVAR_fsLength		DW 0
MKVAR_oMrsTyp		DW 0
MKVAR_TYPE		ENDS

MKVAR_oNamForm	EQU	MKVAR_fsLength	; used for form/menu variables only

;error codes returned by MakeVariable for the parser -
;two sets are defined, one for the parser (bits toward the high end
;of the word) and one for the scanner (toward the lower end of the word).
;Note that callers can count on the scanner error bits being in the
;low byte and the parser bits + 08000H in the high byte if the depending
;code does a .errnz SCN_ER_MASK - 0FFH
PRS_ER_RE	EQU 8100H	;Rude Edit -     bits 8  & 15 set
PRS_ER_RP	EQU 8200H	;Reparse -       bits 9  & 15 set

SCN_ER_MASK	EQU 0FFH	;other scanner error constants are ER_ and
				;MSG_ errors from qbimsgs.inc/.h

;====================  Type Table ========================================
;The type table is used to manage user defined variable types.
;
;There is one type table per module.  The scanner verifies type compatibility
;between modules for COMMON variables and procedure parameters.
;
;Type and element entries are maintained in the same table.
;
;The word at offset oOFIRST_TYP in the type/var table (mrsCur.bdVar) is an 
;offset to the first type in a chain of types that comprise the table. Elements
;are chained from their parent types. Following this word in table, at offset
;oCTYPES, is a count of types currently defined in the table.
;============================================================================
CTYPESMAX 	EQU 240d	;Maximum number of user-defined types 
				;allowed in a module

oOFIRST_TYP	EQU CBINITMVHASH + OMVHASH
				;the offset to the first TYP structure in the
				;var/type table is stored in the table
				;immediately following the module hash table
oCTYPES		EQU oOFIRST_TYP + 2
				;the count of TYP's in the var/type table is
				;stored immediately following the offset to the
				;first TYP.
CBINIT_TTYP	EQU 4		;number of words of overhead storage required
				;by typmgr to be allocated in MRS_bdVar right
				;after the module heash table.

;TYP Structure - type table type entry
TYP	STRUC
TYP_oNam		DW 0
TYP_oTypNext		DW 0
TYP_cbData		DW 0
TYP_oElementFirst	DW 0			;Low 15 bits only
TYP	ENDS

TYP_fReferenced		EQU TYP_oElementFirst+1	;high-bit of oElementFirst
						;used to indicate if element
						;has been referenced. This
						;constant allows easy access
						;to the high byte of this field
TYP_flags		EQU TYP_oTypNext+1	; high-bit of oTypNext used
						; as a flag
F_NOBLKCPYTYP		EQU 080H		; flag to use with TPY_flags
						; If set, means that code
						; that assigns one user-
						; defined type to another
						; cannot do so via a
						; simple block copy

;ELEM Structure - type table element entry
ELEM	STRUC
ELEM_oNam		DW 0
ELEM_oElementNext	DW 0
ELEM_oTyp		DW 0
ELEM_oVar		DW 0
ELEM	ENDS

ELEM_cbFixed	equ	ELEM_oVar + 2		;this field is only present
						;for fixed-length string/text
						;elements


;======================================================================
; External declarations for varmgr.c & vardebug.c routines
;======================================================================
sBegin	DATA
	EXTRN	mkVar:byte
ife VARUTIL_ASM
	EXTRN	oTypComMax:word 	;max oTyp of Blank Common for all MRSs
	EXTRN	oValComMax:word 	;max oVal of Blank Common for all MRSs
endif	;VARUTIL_ASM
sEnd	DATA


	IncludeOnce types	;this part split out so some modules don't
				;  need to include all of this file
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\bddebug.asm ===
TITLE BdDebug.asm - Buffer Descriptor Debugging Routines

COMMENT	\

--------- --- ---- -- ---------- ----
COPYRIGHT (C) 1985 BY MICROSOFT, INC.
--------- --- ---- -- ---------- ----

\

;============================================================================
; Module: BdDebug.asm - Buffer Descriptor Debugging Routines
;
; System: Quick BASIC Interpreter
;
;============================================================================

	.xlist

	include version.inc
	BDDEBUG_ASM = ON
	includeOnce	architec	
	includeOnce	heap
	includeOnce	util
	includeOnce	rttemp
	includeOnce	context

	.list

;	.sall


	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\ui.inc ===
;***
; File: UI.INC
;
;   Copyright <C> 1987, Microsoft Corporation
;
; NOTE: When making changes to this file, be sure to make equivalent
;   changes to file UI.H.  See UI.H for comments.
;
;
;*******************************************************************************

UI_INC = ON

sBegin  DATA
    extrn   fDebugScr:byte
    extrn   fSyntaxCheck:byte   ;non-zero if syntax checked by editor
    extrn   rsNew:word
    extrn   fTraceOn:byte       ;non-zero if TRACE is active (TRON)
    extrn   debugFlags:byte
ife UIDEBUG_ASM
    extrn   pWatchVal:word
endif   ;ife UIDEBUG_ASM

;--------------------------------------------------------------------------
;  debugFlags's bits:
;
;  DEBUG_ERROR  - set when a runtime error occurs and is not trapped.
;         The runtime error code restores SI to the beginning
;         of statement, sets this flag, then re-executes the
;         statement, which invokes the debugger.  The error code
;         is passed in the same static variable examined by the
;         ERR intrinsic function.
;
;  DEBUG_EXEC_CMD Set when the executor wants the user interface to cause
;         a newly loaded program to be scanned for errors, and if
;         none are found, the any pcode in the direct mode buffer
;         is executed (causing the program to RUN).
;
;  DEBUG_STOP   - set when a STOP statement is executed,
;         when Ctrl-BREAK is pressed and not trapped,
;         or when a breakpoint is reached.
;
;  DEBUG_END    - set by the executors for opEot and opStEnd to indicate
;         end-of-program for QB.
;
;         EB specific: when a direct mode statement is executed
;         while a previous EB invocation is active, we return from
;         TxtExeBreak to use the same frame. DEBUG_END is used
;         to get us back.
;
;  DEBUG_WATCHPOINT - set when a Stop-Watch-Expression evaluates to TRUE
;
;  DEBUG_TRACE  - set while tracing statement execution either because
;         of TRON, single-step, or procedure-step.
;
;  DEBUG_WATCH  - set when any Watch Expressions are active in the program.
;
;  DEBUG_CANT_CONT - Causes UserInterface() to set grs.otxCONT to
;         UNDEFINED the next time it is called.
;         This is used by executors, which cannot call CantCont
;         because UserInterface sets grs.otxCONT every time
;         we enter UserInterface, thus undoing their change.
;         Since it sets otxCONT rather than calling CantCont(),
;         stack tracing and variable printing are still possible
;         from direct mode, just not continuing.
;
;--------------------------------------------------------------------------
    DEBUG_ERROR EQU 01h     
    DEBUG_EXEC_CMD  EQU 02h     
    DEBUG_STOP  EQU 04h
    DEBUG_END   EQU 08h
    DEBUG_WATCHPOINT EQU 10h
    DEBUG_TRACE EQU 20h
    DEBUG_WATCH EQU 40h
    DEBUG_CANT_CONT EQU 80h



            ;     cmdSwitches are eliminated from EB
            ; For now we have to test different file name switches
            ; to determine whether cmdSwitches should be extrn'ed

   ife  INIT_ASM
    extrn   cmdSwitches:word    ;global bit flags for cmd-line switches
   endif    ;ife INIT_ASM



;;
;; a-emoryh - If you change this flag, you must also change it in
;;      ..\..\beef\cw\user\meditasm.asm, in addition to changing it in ui.inc.
;;      And you'll need to rebuild CW lib.
    CMD_SW_QHELP equ 0800h      ;/QHELP switch found


    CMD_SW_EDCOM equ 0400h      ;/EDCOM switch found
        CMD_SW_ED  equ  0200h           ;/Editor switch found
    CMD_SW_GLT equ  0100h       ;/G switch found (CGA speed, snow o.k.)
    CMD_SW_HAR equ  0040H       ;/AH switch found (Huge Arrays allowed)
    CMD_SW_HIR equ  0020H       ;/H switch found (hi-res)
    CMD_SW_MBF equ  0010h       ;/MBF switch found
    CMD_SW_RUN equ  0008h       ;execute given filename after loading
    CMD_SW_FLE equ  0004h       ;user gave a file name to load [& run]
    CMD_SW_NOH equ  0002h       ;/NOHI switch for no highlight colors
    CMD_SW_MNO equ  0001h       ;/B switch found (monochrome monitor)

    WATCH_MAX   EQU 8       ;max lines in screen for "Watch Window"

;   Watch types for CmdWatchAdd and WatchAdd
    WT_Watch    equ 0   
    WT_WatchPoint   equ 1   

    MIN_EDITLINE equ 256        ;min width for edit line

CB_bufStdMsg    EQU 80d     ;size of static structure 'bufStdMsg'
ife UIUTIL_ASM
    extrn   cbStdMsg:word       ;set by ListStdMsgFar
    extrn   bufStdMsg:byte      ;set by ListStdMsgFar
endif   ;UIUTIL_ASM

ife UIEDIT_ASM
    extrn   bdEMScratch:byte
endif

sEnd    DATA

EbAPIEnter MACRO            ;   
    ENDM                
                    
EbAPIExit MACRO             
    ENDM                


ife UIMAIN_ASM
    extrn   UserInterface:far
    extrn   AskCantCONT:far
endif   ;UIMAIN_ASM

    extrn   WnResetMove:far

sBegin  UI

    extrn   FileSpec:far
    extrn   FileExists:far
    extrn   CmdViewInclude:far
    extrn   DelFile:far
    extrn   MakeRelativeFileSpec:far
    extrn   UpdStatusLn:far
    extrn   ShowOutScr:far
    extrn   EnsMouseOff:far
    extrn   TossOutputScreen:far
    extrn   EnsShowDebugScrFar:far
    extrn   StatusMsgFar:far
    extrn   DrawDebugScrFar:far
    extrn   DoDrawDebugScrFar:far

ife UIMAIN_ASM
    extrn   NotSaved:far
    extrn   AskMakeRem:far
    extrn   UiInit:far
    extrn   UiReInit:far
    extrn   UiTerm:far
endif   ;UIMAIN_ASM

if NOT UIEDIT_ASM
    extrn   UiFlushCache:far
    extrn   fEditorActive:far
    extrn   fQhelpActive:far
endif
if NOT UIMAIN_ASM
    extrn   NotSavedInc:far
endif

ife UIUTIL_ASM
    extrn   ListStdMsg:near
    extrn   WnReAssign:far
endif   ;UIUTIL_ASM

ife UIDEBUG_ASM
    extrn   CmdWatchDelAll:far
    extrn   WatchDeleted:far
    extrn   HistReset:far
    extrn   PStepReset:far
    extrn   SetTronTroff:far
    extrn   DebugWatch:far
endif   ;UIDEBUG_ASM

ife UINHELP_ASM
    extrn   DiscardHistoryORs:far   
endif
sEnd    UI

sBegin  LOADRTM
ife UIUTIL_ASM
    extrn   ListStdMsgFar:far
endif   ;UIUTIL_ASM
sEnd    LOADRTM

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\hd\varmgr.h ===
/*** 
* varmgr.h - type definitions and data primarily for the Variable Manager
*
*  Copyright <C> 1985, 1986, 1987 Microsoft Corporation
*
*******************************************************************************/

#undef VARMGR_H               /* it will have been defined as 0 in switch.h */
#define VARMGR_H -1           /* to prevent duplicate #include's */
#if !HEAP_H
#include "heap.h"
#endif

/* VARPTR$ descriptor definition */
typedef struct varptr_d {
   ushort   oTyp;          /* BASIC data type */
   long     pValue;        /* Address of the value */
   } varptr_d;

/**====================  Variable Table =====================================
The variable table contains binding information for each variable or 
procedure.  In many cases, the variable table also contains the value.

There are two kinds of variable table. There is one tMV (Module variable table)
per module, and it contains module static variables, all COMMON variables, and 
procedure reference entries.  There is one tPV (Procedure variable table)
per procedure, and it contains the formals, dynamics, and an entry for the
function return value if it is a function.

These tables are constructed at parse time. They may also be constructed by a
special scan pass which is designed to solve instances in the syntax where
program modification causes wide spread binding changes.  This action occurs
when the scanner is called to move the pcode from scan state SS_RUDE.

Since these tables are built at parse time, there may be tPV entries for
variables which are later declared to be functions.

The hash functions for both the tMV and the tPV is a hash on the Name
Table offset (oNam). The hash tables for the tMV and tPV will be of
different size.

It is necessary to detect from the variable table which procedure owns each
variable in the tMV.  This is done using oPrs.  This could be a byte entry
if each procedure were given a unique byte size identifier.  oPrs for the
main level is UNDEFINED.  At table build time, variables must be unique by 
oNam, oPrs, and eType.  There may be a SUB of the same name as a variable.
============================================================================**/
/* sizes of hash tables */
#define CBINITMVHASH 32    /* UNDONE: want a power of 2; is this the ideal? */
#define CBINITPVHASH 16    /* UNDONE: want a power of 2; is this the ideal? */

#define HASH_MV_NAMMASK  0x001E  /* a 32-byte table contains 16 2-byte offsets,
                                    offset) from 0 to 30                      */
#define HASH_PV_NAMMASK  0x000E  /* a 16-byte table contains 8 2-byte offsets,
                                    each to the start of a unique hash chain. */
#define OMVHASH   0  /* [4] module hash table still starts at      */
            /* [4] offset 0 in var table for QB5         */

/* error codes returned by MakeVariable for the parser -
   two sets are defined; the parser error codes are toward the high
   end of the word, while the scanner error messages bits are toward
   the low end of the word.
                                                                           */
#define  PRS_ER_RE   (ushort)0x8100    /* Rude Edit -     bits 8  & 15 set */
#define  PRS_ER_RP   (ushort)0x8200    /* Reparse -       bits 9  & 15 set */

#define  SCN_ER_MASK (uchar)0xFF       /* Other scanner error message codes
                                          are ER_ or MSG_ messages, defined
                                          in qbimsgs.h/.inc                */
/* value part of an array frame variable                                */
typedef struct aFrame {
   ushort   oFrame;
   uchar    cDims;   /* Dimension count - set by varmgr at var creation */
   uchar    filler1;
   } aFrame;

/* value part of an array formal variable                               */
typedef struct aFormal {
   ushort   oFrame;
   uchar    cDims;
   uchar    filler1;
   } aFormal;

/* value part of a static (not frame) array variable                    */
typedef struct aStat {
   ushort   filler0;
   uchar    cDims;   /* Dimension count - set by varmgr at var creation */
   uchar    filler1;
   ad       aryDsc;
   } aStat;

typedef union val {
   short       I2;      /* Integer                                            */
   long        I4;      /* Long Integer                                       */
   FLOAT       R4;      /* single precision                                   */
   DOUBLE      R8;      /* double precision                                   */
   sd          sdStr;   /* Standard variable length string                    */
   comRef      common;  /* used if flags indicate a common (non-array) entry  */
   aCom        aryCom;  /* used if flags indicate a comman array entry        */
   aStat       aryStat; /* static (not frame) array variable                  */
   aFrame      aryFrame;/* dynamic array variable                             */
   aFormal     aryFormal;/* dynamic array variable                            */
   ushort      oFrame;  /* dynamic variable: value is a frame offset (oBP)    */
   ushort      oMV;     /* Module table offset for entry for this variable    */
   ushort      oPrs;    /* offset in prs table for this proc. reference       */
   char        tData;   /* First byte of record; record type indicates size   */
   } val;

/* var structure: an entry in the module variable table
   Note that this is not a normal C struct, because the oTyp might or might 
   not be present, and the value field is of variable length, and a pointer
   to the structure points not at the beginning of the structure but at
   the value field							      */
#define VAR_oMrsTyp    -10 /* used for PUBLIC vars of user-defined type       */
#define VAR_oNamForm	-8 /* used for form/menu variables only 	      */
#define VAR_cbFixed	-8 /* size of fixed-length string/text		      */
#define VAR_oTyp	-8 /* oTyp: present only for user-defined variables   */
#define VAR_oNam	-6 /* Name table offset for variable name	      */
#define VAR_oHashLink	-4 /* link to next entry w/same hash (plus a flag ... */
#define VAR_flags       -2 /* bit flags + an oTyp in low bits                 */
#define VAR_value        0 /* value of this variable                          */

#define VAR_STRUCT_SIZE  6 /* size of a 'normal' (no oTyp field) variable
                              entry minus the value field                     */
typedef ushort var;


/* bit flags constants, for use with varInp.flags2, below                     */
#define  MV_fConstFound    0x01  /* if TRUE on exit, then the oVar returned
                                    is for a CONSTant rather than for a var   */
#define  MV_fONamInOTyp    0x02  /* if TRUE on entry and oTyp isn't a Fixed 
                                    Length String or a predefined type, oTyp
                                    is really an oNam for a CONSTant to define
                                    a Fixed Length String                     */
#define  MV_fDontCreate    0x04  /* if TRUE on entry, don't create a new 
                                    variable if a match is not found (return 
                                    ER_IER instead)                           */
#define  MV_fRecRef        0x08  /* if TRUE on entry, this is a record ref.,
                                    so we don't know the type and a match
                                    MUST be found or error.                   */
                                    /* UNDONE: Nice if QB5 changes to use this
                                       UNDONE: instead of oTyp == UNDEFINED   */

typedef struct varInp {
   ushort   flags;      /* MakeVariable input flags; constants defined below  */
   ushort   exitFlags;  /* UNDONE: remove when MakeVariable in native code    */
   ushort   oNam;       /* input oNam to MakeVariable                         */
   ushort   oTyp;       /* input & output oTyp for MakeVariable               */
   uchar    flags2;     /* various input & output flags - - - these flags
                           are used to communicate special facts to/from
                           MakeVariable rather than to describe the variable
                           to be created                                      */
   uchar    cDimensions;/* count of dimensions if input variable is indexed   */
   ushort   fsLength;	/* length of fixed length string/text		      */
   ushort   oMrsTyp;	/* used only when creating entries in global tVar     */
   } varInp;

EXTERNAL varInp mkVar;

/**====================  Type Table ========================================
The type table is used to manage user defined variable types.

There is one type table per module. This table is interleaved with VAR 
entries in the variable table. The scanner verifies type compatibility
between modules for COMMON variables and procedure parameters.

Type and element entries are maintained in the same table (along with var
entries).

Note that there are two catagories of oTyp's:
- predefined oTyp's (ET_I2, ET_I4, ET_R4, ET_R8, ET_SD, etc.)
      These are all <= ET_MAX
- oTyp's for user-defined types (i.e., records)
      These fall in the range	 ET_MAX < oTypRecord
============================================================================**/
#define CTYPESMAX       240      /* maximum number of user-defined types 
                                    allowed in a module                    */

#define oOFIRST_TYP     CBINITMVHASH + OMVHASH
#define oCTYPES         oOFIRST_TYP + 2

typedef struct typ {
   ushort   oNam;          /* Name table offset of type name               */
   ushort   oTypNext;      /* offset to next type in the chain             */
   ushort   cbData;        /* cb within this type. Used by structure copy  */
   union {
      ushort   oElementFirst; /* Head of element list for this type        */
      ushort   fReferenced;   /* TRUE if exist any ref's to this type      */
      } un;
                              /* NOTE: fReferenced is overlayed onto oElement-
                                 First in order to keep the typ structure
                                 small, and of even byte size. fReferenced is
                                 the high bit, the lower 15 bits being the
                                 offset; thus, prior to using oElementFirst,
                                 the high bit must be masked off           */
   } typ;
   
typedef struct elem {
   ushort   oNam;          /* Name table offset of element name            */
   ushort   oElementNext;  /* oElement of next element within type         */
   ushort   oTyp;          /* Type of this element                         */
   ushort   oVar;          /* Offset of data from data for first sibling
                              (set by scanner, used by executor)           */
   } elem;
   /* CONSIDER: if we decide to go with the language option of allowing
      CONSIDER: arrays as record elements, we'll need to make a union
      CONSIDER: which allows the above, or the above plus an array descriptor 
      CONSIDER: template - - - this template will need to be of the 
      CONSIDER: appropriate size for the number of dimensions, and all of it 
      CONSIDER: should be filled out except for the the long data pointer. 
      
      NOTE: for this reason, make sure we don't come to depend on an
      element entry being of fixed size!                                */

typedef union typEntry {
   /* Module type table entry */
   typ eType;
   elem element;
   } typEntry;

VOID     NEAR VarRudeReset(VOID);
ushort   NEAR MakeVariable(VOID);
VOID     NEAR AdjustMrsVarTable(var *, ushort);
VOID     NEAR AdjustPrsVarTable(var *, ushort, ushort);
ushort   NEAR DefineTyp(ushort);
ushort   NEAR RefTyp(ushort, ushort);
ushort   NEAR DefineElem(ushort, ushort, ushort);
ushort	 NEAR DefineElemFixed(ushort, ushort, ushort, ushort);
ushort   NEAR ONamOElem(VOID);
ushort   NEAR CbTyp(ushort);

/* Non-RELEASE and DEBUG macros, used with vardebug.c */

#define DbSzTyp(oTyp)                           {;}
#define DbDmpVar(oVar)                          {;}
#define DbDmpVarChn(oVarFirst)                  {;}
#define DbDmpTMV()                              {;}
#define DbDmpTPV()                              {;}
#define DbDmpTTyp()                             {;}
#define DbChkoVar(oVar)                         {;}
#define DbChkPVar(pVar)                         {;}
#define DbChkoTyp(oTyp)                         {;}
#define DbChkoTyp(oTyp)                         {;}
#define DbMkVarInp()                            {;}
#define DbMkVarExit(retval,fVarFound,fPVCur)    {;}
#define DbToggleMkVarOut()                      {;}
#define DbTglVarOutAll()                        {;}
#define DbTglVarErrs()                          {;}
#define DbDmpAllInMrs()                         {;}
#define DbDmpAllVars()                          {;}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\binsav.asm ===
TITLE	binsav.asm - binary SAVE/LOAD for QBI
;*** 
;binsav.asm - binary SAVE/LOAD for QBI
;
;	Copyright (C) 1986-1989, Microsoft Corporation
;
;Purpose:
;   -  Performing Binary Load/Save of modules
;
;
;*******************************************************************************

	.xlist

	include version.inc
	BINSAV_ASM = ON
	includeOnce	architec
	includeOnce	context
	includeOnce	conint
	includeOnce	heap
	includeOnce	names		
	includeOnce	optables	
	includeOnce	qblist
	includeOnce	qbimsgs
	includeOnce	rtinterp
	includeOnce	rtps
	includeOnce	rttemp
	includeOnce	scanner
	includeOnce	txtint
	includeOnce	txtmgr
	includeOnce	sb		
	includeOnce	ui
	includeOnce	util

	.list

	assumes CS,CP
	assumes DS,DATA
	assumes SS,DATA
	assumes ES,NOTHING


	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\bfpsig.asm ===
title	bfpsig - BASIC floating point error routine


comment !
---------------------------------------------------------------------------

    This module defines the __fpsignal routine for BASIC

    Copyright (C) Microsoft Corp. 1984, 1985, 1986

    Written by Gregory F. Whitten

---------------------------------------------------------------------------

    Revision History

	 5/12/84	Greg Whitten
			signal routine moved to this module
			for C/Pascal/FORTRAN math sharing

	09/26/86	Greg Whitten
			converted to BASIC signal handling

        04/16/87        Greg Whitten
                        SS must be equal to DGROUP (DS restored from SS)

        04/21/87        Greg Whitten
                        map invalid errors to overflow because integer
                        overflow generates an invalid exception

	05/13/87	Len Oorthuys
			QBI variation - update the pcode offset of errors
			that occur in executors

	09/04/87	Leo Notenboom [1]
			Ensure that stack passed to B$RUNERR points to the
			address of the exception.

	10/09/87	Brian Lewis [2]
			Bug fix - offset of math error is at bp+08, not
			bp+0ah.

	03/10/88	Brian Lewis
			SizeD versions cannot assume ds == ss.

	04/12/88	Brian Lewis
			Last change was bogus.

---------------------------------------------------------------------------
!

	include 	version.inc
	IncludeOnce	exint
	IncludeOnce	context
	IncludeOnce	qbimsgs

externP B$RUNERR

externFP __fpmath			

sBegin	CODE
	assumes cs,CODE
	assumes es,NOTHING
	assumes ss,DATA


errtab	label	byte
	db	ER_OV			; invalid (assume integer overflow)
	db	ER_FC			; denormal
	db	ER_DV0			; zerodivide
	db	ER_OV			; overflow
	db	ER_OV			; underflow
	db	ER_FC			; precision
	db	ER_FC			; unemulated
	db	ER_FC			; sqrtneg
	db	ER_OV			; intoverflow
	db	ER_FC			; stkoverflow
	db	ER_FC			; stkunderflow


;	process floating point error - dispatch to BASIC error handling
;
;	there is stuff (return addresses) left on the stack

labelFP <PUBLIC,__fpsignal>

	sub	al,81h			; convert to 0 based error numbers
	mov	bx,offset errtab
	xlat	byte ptr cs:[bx]
	cbw				; (ax) = BASIC error code
	xchg	ax,cx			; (cx) = BASIC error code

        push    ss
        pop     ds                      ; (ds) = DGROUP

	mov	bx,sp

nextframe:
	mov	ax,[bx+0ah]		; (ax) = segment of math error
	cmp	ax,seg __fpmath 	; another iret on stack?
	jnz	gotseg
	add	bx,6
	jmp	nextframe		; go try the next frame

gotseg:
	lea	sp,[bx+08h]		; reset stack to that at error time
	mov	dx,cs
	cmp	ax,dx			; executor segment?
	jnz	sigexit 		; Not in the executors - exit
	mov	ax,[bx+08]		; (ax) = offset of math error
	cmp	ax,codeOFFSET __fpsignal; in the mathpack?
	jnb	sigexit 		; In the mathpack - exit
	mov	[grs.GRS_oTxCur],si	; record oTx of error

sigexit:
	mov	bx,cx			; (bx) = BASIC error code
	jmp	B$RUNERR		; goto BASIC error handler


sEnd	CODE
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\45\qb\ir\bdmgr.asm ===
TITLE BdMgr.asm - Buffer Descriptor Management Routines

COMMENT	\

--------- --- ---- -- ---------- ----
COPYRIGHT (C) 1985 BY MICROSOFT, INC.
--------- --- ---- -- ---------- ----

\

;============================================================================
; Module: BdMgr.asm - Buffer Descriptor Management Routines
;	This is a layer of routines which depends on the BASCOM Runtime Heap
;	Management routines in source file (strutl.asm).
;	It manages entries in the Interpreter and Far heap.
; System: Quick BASIC Interpreter
;============================================================================

	.xlist

	include version.inc
	BDMGR_ASM = ON
	includeOnce	architec
	includeOnce	context
	includeOnce	heap
	includeOnce	parser
	includeOnce	txtmgr
	includeOnce	util

	.list

;	.sall


assumes	DS,DATA
assumes	ES,DATA
assumes	SS,DATA

sBegin	DATA

; HMEM_ constants used by SBMGR allocation routines

HMEM_FIXED	EQU	0000H		
HMEM_MOVEABLE	EQU	0002H		
HMEM_NOCOMPACT	EQU	0010H		
HMEM_ZEROINIT	EQU	0040H		
HMEM_DISCARDABLE EQU	0F00H		

externW b$fVarHeapActive		;non-0 when variable heap is active

DbOMCnt	MACRO	label
	ENDM

sEnd	DATA

	EXTRN	AdjustCommon:FAR
	EXTRN	AdjustVarTable:FAR


sBegin RT
assumes	CS,RT

	EXTRN	B$ILHALC:NEAR
	EXTRN	B$LHREALC:NEAR
	EXTRN	B$LHDALC:NEAR
	EXTRN	B$LHChgBakPtr:NEAR
	EXTRN	B$ILHADJ:NEAR
	EXTRN	B$LHForEachEntry:NEAR
	EXTRN	B$NHCPCT:NEAR
	EXTRN	B$TglHeapSpt:FAR

	EXTRN	B$IFHAlloc:NEAR 	
	EXTRN	B$FHDealloc:NEAR	
	EXTRN	B$FHRealloc:NEAR	
	EXTRN	B$FHAdjDesc:NEAR	
	EXTRN	B$FHAdjOneDesc:NEAR	

CBBUFBLOCK equ 512	;Never grow a near heap by less than this
			; number of bytes to reduce heap thrashing.

VAR_EXTRA equ 30	;we want to keep up to this much free space beyond
			; cbLogical in IT_VAR (variable) tables when compressing
			; other bd's all the way back to cbLogical. This is to
			; help the user's chances of edit and CONTinuing.




;------------------------------------------------------------
;---  Interpreter Buffer Descriptor Management Routines   ---
;------------------------------------------------------------
;***
;B$IHeapEntryMoved - handle movement of Interpreter-specific Heap entry
;Purpose:
;	This routine is called by the Runtime Heap management
;	code just before it moves an Interpreter-specific Heap entry.
;	This routine performs any updating necessary due to
;	the movement of an Interpreter-specific Heap entry
;	it does not need to update entry pointer in the bd[p] for
;	the entry being moved; it just dispatches based on the
;	heap entry type to a routine which finds all string/heap
;	owners within the heap entry being moved, and calls the heap
;	management code to update the backpointers. Note that each 
;	such routine will be located in it's own component; these 
;	routines will call the runtime heap manager directly, but
;	will do so via a macro to keep runtime heap interface knowledge
;	confined to this module and associated header files.
;Entry:
;	AX = number of bytes the heap entry has moved.
;	       A positive number indicates the entry has moved
;	       to a higher address.
;	BX = pointer to the bd[p].pb field of the buffer descriptor for
;		the heap entry being moved.
;	CL = type constant for the heap type being moved (IT_MRS, ... etc.)
;
;Exit:
;	none.
;Modifies:
;	May modify BX, CX, or PSW - no others
;***************************************************************************
cProc	B$IHeapEntryMoved,<PUBLIC,NEAR,NODATA>,<AX,DX,ES,SI,DI>
cBegin

	mov	si,bx
	cmp	cl,IT_NO_OWNERS_BDP	;a bdp entry being moved?
	jnz	Not_Bdp			;brif not

	add	[bx.BDP_pbCur-2],ax	;adjust the pbCur field
	jmp	short Entry_Moved_Exit	;that's all, folks

Not_Bdp:
	mov	di,ax			;communicate adjustment factor in DI
	mov	ax,[bx-2]		;put cbLogical (table end offset) in ax
	mov	bx,[bx]
	push	ax			;save until Entry_Moved_Cont
	push	bx			;save until Entry_Moved_Cont
	push	cx			;save until Entry_Moved_Cont

	cmp	cl,IT_COMMON_VALUE	
	jae	Update_Stack_Ptrs	;brif we have to update stack ptrs, or
					;var or common table
	cmp	cl,IT_PRS		; no bd's in prs tables
	jz	Entry_Moved_Cont	; brif prs table

	cCall	AdjustITable,<bx,ax,cx> ;adjust the table, whatever it is.

Entry_Moved_Cont:
	pop	cx			;restore type constant
	pop	bx			;restore start of range
	pop	dx

FHD_TBL EQU NOT IT_M_INTERP AND (IT_MRS OR IT_PRS OR IT_COMMON_VALUE OR IT_VAR)
	test	cl,FHD_TBL
	jz	Entry_Moved_Exit	;brif entry can't contain far heap desc.

	;prs and mrs tables contain bdl's - - - get far heap to update these
	add	dx,bx			;dx is now end of range
	mov	ax,di			;adjustment factor
	call	B$FHAdjDesc

Entry_Moved_Exit:
cEnd

Update_Stack_Ptrs:
	jnz	Upd_Stk_Ptrs_Cont	;brif cl != IT_COMMON_VALUE
	call	AdjustCommon		;update backpointers to any string 
					;descriptors or string array descriptors
					;in given IT_COMMON_VALUE heap entry
	jmp	short Entry_Moved_Cont
Upd_Stk_Ptrs_Cont:
	DbAssertRelB  cl,z,IT_VAR,RT,<B$IHeapEntryMoved: cl == IT_VAR expected>
	call	AdjustVarTable		;update backpointers to any string 
					;descriptors or string array descriptors
					;in given IT_VAR heap entry
	jmp	short Entry_Moved_Cont

;***
;BdCompress - Compress a Runtime Heap entry
;Purpose:
;	Call B$LhRealloc to reduce cbPhysical to cbLogical for a Bd whose
;	pb field is at a given location.
;	Called via B$LHForEachEntry by BdCompressAll.
;
;	Note that variable tables are handled specially - - they're trimmed
;	back so that they keep up to VAR_EXTRA free space at the end of the
;	table to maximize the change of CONTinuing after variables are added.
;Entry:
;	BX = pointer to owner of a local heap entry - - - for interpreter
;		buffers, that amounts to a pointer to the 'pb' field of the
;		owning bd.
;	DL = heap entry type.
;Exit:
;	none.
;Preserves:
;	CX,SI
;Exceptions:
;	none.
;
;***************************************************************************
cProc	BdCompress,<NEAR,NODATA>
cBegin	BdCompress
	DbChk	Heaps			;ife RELEASE & checking enabled, check
					;	Local & Far Heaps for problems
	test	dl,IT_M_INTERP		;is this an interpreter buffer?
	jz	BdCompress_Exit

	dec	bx			;turn bx into a real pBd (for cmp below)
	dec	bx

	mov	ax,[bx.BD_cbLogical]
	cmp	dl,IT_VAR		;is this a variable table?
	jnz	BdCompress_Cont		;  brif not
	
	add	ax,VAR_EXTRA		;want to have up to VAR_EXTRA bytes
					;  left in each var table to improve
					;  chances of user adding a few 
					;  variables and still CONTinuing
	cmp	ax,[bx.BD_cbPhysical]
	jae	BdCompress_Exit		;brif cbPhysical <= size we want buffer
					;  to be - - - leave buffer alone
BdCompress_Cont:
	lea	dx,[ps.PS_bdpDst.BDP_cbLogical]
	cmp	bx,dx			;brif not special parser buffer that 
	jnz	BdCompress_Cont1	;  must always have a minimal amount

	cmp	ax,CB_PCODE_MIN		;never trim below this minimum
	ja	BdCompress_Cont1	;brif cbLogical > Minimum required

DbAssertRel [bx.BD_cbPhysical],ae,CB_PCODE_MIN,RT,<BdCompress:Parser buffer is too small>
	mov	ax,CB_PCODE_MIN
BdCompress_Cont1:
	push	cx			;preserve for caller
	push	si			;preserve for caller
	mov	[bx.BD_cbPhysical],ax	;set new desired cbPhysical
	mov	si,[bx.BD_pb]		;pointer to start of data in buffer
	call	B$LHREALC		;reduce entry to cbLogical size
					;  MUST succeed and CANNOT cause
					;  heap movement, because it is either
					;  reducing entry size or doing nothing

	pop	si
	pop	cx
BdCompress_Exit:
cEnd	BdCompress

;***
;BdCompressHeap - Compress all Runtime Heap entries in currently active heap
;Purpose:
;	Same as BdCompressAll (below), but only crunches bd's in the currently
;	active heap (either the local heap or the variable heap).
;Input:
;	none.
;Output:
;	none.
;Modifies:
;	no permanent registers.
;Exceptions:
;	Chance of string space corrupt.
;***************************************************************************
cProc	BdCompressHeap,<NEAR,NODATA>
cBegin
	mov	cx,RTOFFSET BdCompress
	call	B$LHForEachEntry	;compress all bd's down to cbLogical
					;  (effect is to create free blocks
					;   out of extraneous space in bd's)
	cmp	[b$fVarHeapActive],FALSE
	jnz	BdCompressHeap_Exit	;don't compact the variable heap
					;  only runtime init. does that - - 
					;  B$NHCPCT assumes local heap active.
	call	B$NHCPCT		;compact Local Heap and String Space
BdCompressHeap_Exit:
	DbChk	Heaps
cEnd
;***
;BdCompressAll - Compress all Runtime Heap entries
;Purpose:
;	To increase the speed of BdGrow, we keep a little free
;	space at the end of each heap entry.  When the program
;	begins execution, this routine is called to
;	release all t